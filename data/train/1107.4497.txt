{
  "article_text": [
    "the role of non - local quantum correlations , more familiarly known as entanglement , in modern quantum theory can not be overstated  @xcite . on the one hand , entanglement lies at the heart of quantum information theory @xcite , where it is a crucial ingredient to computation and communication schemes . on the other hand ,",
    "it is intricately related to phenomena such as decoherence @xcite and quantum phase transitions in many - body systems @xcite .",
    "one has come to realize that entanglement is also a resource that can for instance be purified , shared , and possibly irreversibly lost , and should therefore not only be detectable , but also quantifiable @xcite .",
    "one way of doing so is by virtue of entanglement measures @xcite .",
    "these are mathematical functions mapping quantum states to the set of real numbers .",
    "while there is no unique or strict definition for the notion of an entanglement measure , there are a set of properties which are commonly regarded useful , e.g. , that the measure is zero only for separable states and is invariant under local unitary transformations .",
    "another important property which we will assume throughout this work is monotonicity : an entanglement measure must not increase ( on average ) under any protocol involving only local unitary transformations and classical communication . in the following",
    ", we will use the terms ` entanglement measure ' and ` entanglement monotone ' interchangeably .    rather understandably , it is difficult to capture all properties of even a pure entangled state with just a single real number , especially in the setting of higher - dimensional and multi - partite systems .",
    "it is thus no surprise that there is quite a number of proposed entanglement monotones of various levels of complexity , generality , and the ability to capture different aspects of entangled states more or less successfully than others .",
    "as indicated previously , most of these entanglement monotones share the fact that they are conveniently defined only for pure states , namely as a function of the amplitudes of the state expressed in a certain standard basis .",
    "the situation becomes more involved in the case of mixed states , where classical and quantum correlations need to be distinguished from one another .",
    "given a density matrix @xmath0 , it is not sufficient to simply calculate the average entanglement of a given decomposition , because this decomposition is not unique .",
    "since there are in general infinitely many ways to write a density matrix as a sum of projectors onto pure states , only the infimum of entanglement over all these possible decompositions can make a reliable statement about the quantum correlations in @xmath0 , because there might be a decomposition of @xmath0 in which all pure states are separable and the total entanglement hence would vanish . taking this infimum of an averaged pure - state entanglement monotone over all decompositions of @xmath0",
    "is called ` convex - roof construction ' or ` convex - roof extension ' of that monotone @xcite .",
    "notably , the thereby obtained measure for mixed states is again an entanglement monotone . calculating the convex - roof for a generic quantum state",
    "is considered extremely difficult @xcite .",
    "in fact , even deciding whether or not a merely bipartite mixed state is separable is a hard problem itself which has no known general solution in hilbert space dimensions larger than six @xcite .    in this work ,",
    "we present the computer programs we have written and successfully applied previously to calculate such convex - roof entanglement measures of multi - partite mixed states @xcite .",
    "while we have already described the theory behind our algorithms to some extent in an earlier publication @xcite , we complete this work by publishing here the full source code in the form a user - friendly high - level library called ` libcreme ` .",
    "the package is to a large part written in the matlab programming language @xcite , but great care has been taken to make the library fully compatible with gnu octave @xcite , a free and open - source matlab clone . for the sake of simplicity , we will refer to their common language as m - script .",
    "additionally , functions which have been identified as crucial bottlenecks in terms of execution speed are provided in the form of fast c extensions and have been adapted to be easily callable from matlab and octave through their native c and c++ interfaces , respectively .",
    "while the library already comes with the ability to evaluate a choice of popular entanglement monotones , it is easily extend to calculate user - specified functions .",
    "all that needs to be implemented is the entanglement measure itself and its gradient with respect to the real and imaginary parts of the quantum state vector @xcite .",
    "the library is written in a self - contained and consistent way , making it extremely easy to use in practice and to experiment with different settings , measures , and optimization algorithms .",
    "furthermore , we provide convenience functions hiding most of the steps required to arrive at function handles ready to be optimized .",
    "this essentially simplifies the calculation of a convex - roof entanglement measure to a one - line task .",
    "table [ table : list of functions ] lists each function provided in the library together with a short description of its meaning .",
    "p4.8 cm p11 cm + _ entanglement measures _ & + ` convexsum ` & convex sum parameterized by a stiefel matrix + ` grad_convexsum ` & gradient of convex sum + ` eof2x2 ` & entanglement of formation for 2 qubits ( analytically exact result ) + ` entropyofentanglement ` & entropy of entanglement + ` grad_entropyofentanglement ` & gradient of entropy of entanglement + ` meyer_wallach ` & meyer - wallach measure + ` grad_meyer_wallach ` & gradient of meyer - wallach measure + ` tangle ` & tangle + ` grad_tangle ` & gradient of tangle +   + _ optimization routines _ & + ` cg_min ` & conjugate - gradient method + ` bfgs_min ` & bfgs quasi - newton method + ` minimize1d_exp ` & minimization along a geodesic on the stiefel manifold + ` minimize1d_lin ` & minimization along a line in euclidean space + ` get_termination_criteria ` & helper function to check and handle termination criteria for the optimization algorithms +   + _ utilities _ & + ` randdensitymatrix ` & random density matrix + ` randstate ` & random pure quantum state + ` randunitarymatrix ` & random stiefel matrix + ` decomposeunitary ` & get angles parameterizing a stiefel matrix + ` dimst ` & dimension of stiefel manifold + ` densityeig ` & get eigendecomposition of a density matrix in the form required by many functions within the library + ` psdecomposition ` & get pure - state decomposition parameterized by a stiefel matrix + ` createconvexfunctions ` & create convex - sum function handles for use with ` cg_min ` + ` createehfunctions ` & create convex - sum function handles for use with ` bfgs_min ` + ` grad_eh_adapt ` & adapter function to calculate the gradient of a convex sum parameterized by stiefel matrix angles",
    "+ ` buildunitary ` & build a complex stiefel matrix from a parameterization vector + ` grad_buildunitary ` & gradient of the above function + ` ptrace ` & partial trace over any subsystems of arbitrary ( finite ) dimensions + ` completegramschmidt ` & helper function for numerical stability used within ` cg_min ` +   + _ examples _ & + ` example_eofisotropic ` & main script to run the example from sec .",
    "[ sec : ex_eof ] + ` eofisotropic ` & entanglement of formation of an ` isotropic ' density matrix ( analytically exact result ) + ` example_tangleghzw ` & main script to run the example from sec .",
    "[ sec : ex_tangle ] + ` tangleghzw ` & tangle of ghz / w mixture ( analytically exact result ) +   +    we would briefly like to mention two other numerical libraries dealing with quantum computing and entanglement .",
    "one is the freely available ` quantum information package ' by t. cubitt @xcite written in m - script as well .",
    "the other one is the cpc library feynman ( catalog identifier adwe_v5_0 ) written by t. radtke and s. fritzsche @xcite for maple .",
    "quantum states obtained from calculations and simulations within these libraries can conveniently be anaylized further using ` libcreme ` s ability to calculate more complex entanglement measures .",
    "the paper is organized as follows : in sec .",
    "[ sec : measures ] , we briefly list and discuss the default entanglement measures coming along with ` libcreme ` .",
    "[ sec : background ] reviews the theory of convex - roof entanglement measures and how to address their calculation on a computer .",
    "[ sec : algorithms ] describes the two central algorithms in ` libcreme ` to solve the optimization problem related to the evaluation of such measures . in sec .",
    "[ sec : examples ] , we discuss two complete examples demonstrating the usage of the library , and sec .",
    "[ sec : conclusions ] concludes the work .",
    "note that the focus of this manuscript lies mainly on the functionality of the library : we have tried to provide short code examples throughout the work for all important functions and concepts in a user - friendly bottom - up way .",
    "these snippets are all valid m - script ( including the line breaks `` ... ` ' which we sometimes use due to spacial restrictions ) and can be copied directly into matlab or octave . finally , we would like to mention that all functions in ` libcreme ` are documented , and more information about them can be inquired by calling `` help `  _ function_name _ ' .",
    "we start the description of our library by listing the entanglement measures currently implemented .",
    "note that pure quantum states , such as the arguments of functions calculating entanglement monotones , are always expected to be represented as column vectors in the standard computational basis . in practice , this means that the @xmath1 orthonormal basis states @xmath2 of each @xmath1-dimensional subsystem ( where @xmath1 may be different for different subsystems ) are always chosen as @xmath3_i = \\partial f / \\partial { \\mathop\\mathrm{re}}x_i + \\mathfrak{i}\\ , \\partial f / \\partial { \\mathop\\mathrm{im}}x_i$ ] , where @xmath4 is the imaginary unit .",
    "analytical expressions for all gradients of the measures discussed in this section can be found in [ app : derivatives of measures ] .",
    "the entropy of entanglement @xcite is an entanglement monotone for bipartite quantum systems of arbitrary dimensions .",
    "it is defined as the von neumann - entropy of the reduced density matrix , i.e. , @xmath5,\\ ] ] where @xmath6 denotes the partial trace of @xmath7 and [ 0 ; 1 ] .",
    "% % note that in m - script , [ a1 ; a2 ; ... an ] % denotes a column vector , whereas   % [ a1 , a2 , ... an ] is a row vector .",
    "p_01 = kron([1 ; 0 ] , [ 0 ; 1 ] ) ; p_10 = kron([0 ; 1 ] , [ 1 ; 0 ] ) ;    % define a random superposition of the % above states .",
    "% % rand ( ) yields a random number chosen % uniformly from the interval ( 0 , 1 ) .",
    "r1 = 2*pi*rand ( ) ; r2 = 2*pi*rand ( ) ; psi = sin(r1)*p_01 + exp(1i*r2)*cos(r1)*p_10 ;    % dimensions of subsystems sys = [ 2 , 2 ] ;    % calulate measure and gradient e = entropyofentanglement(psi , sys ) g = grad_entropyofentanglement(psi ,",
    "sys ) ....    note that the entropy of entanglement is of particular importance , because its convex - roof extension is the well - known and widely used ` entanglement of formation ' @xcite . in the special case of a bipartite system composed of two - dimensional subsystems ( qubits )",
    ", there exists an operational solution for the entanglement of formation @xcite , which we have implemented in ` eof2x2 ` .",
    "the three - tangle @xcite is defined specifically for a system of three two - dimensional subsystems .",
    "it reads @xmath8 where @xmath9 and @xmath10 , are the complex amplitudes of the vector @xmath11 in the standard computational basis .",
    "the tangle is implemented in the function ` tangle ` , taking an 8-dimensional vector ` psi ` as its only argument .",
    "here follows a short example :    .... % define an 8-dimensional random state psi = randstate(8 ) ;    % calculate tangle and its gradient t = tangle(psi ) g = grad_tangle(psi ) ....    in the above code , we have introduced the function ` randstate ` , which returns a random pure quantum state of arbitrary specified dimension uniformly distributed according to the haar measure of the unitary group @xcite .",
    "finally , the measure of meyer and wallach @xcite for an arbitrary number @xmath12 of qubits is an entanglement monotone that can be written in the compact form  @xcite @xmath13,\\ ] ] where @xmath14 is the density matrix obtained by tracing out all but the @xmath15th subsystem out of @xmath16 .",
    "the implementation is given in ` meyer_wallach ` .",
    "this function also makes use of ` ptrace ` .",
    "the usage is analogous to the example given for the three - tangle above .",
    "in this section , we review how to arrive at an optimization problem ( whose solution is the desired value of the convex - roof entanglement measure ) in a form that can be dealt with on a computer .",
    "let @xmath17 be an entanglement monotone for pure states from a hilbert space @xmath18 of finite dimension @xmath19 .",
    "let @xmath0 be a density matrix acting on that space .",
    "our goal is to numerically evaluate the convex roof @xmath20 of @xmath17 , given by @xmath21 where @xmath22 is the set of all pure - state decompositions of @xmath0 . with respect to numerical optimization ,",
    "a convenient parameterization of all subsets of @xmath23 with a constant number of terms @xmath15 ( sometimes referred to as the ` cardinality ' ) is due to the schrdinger - hjw theorem @xcite .",
    "the latter states that ( i ) , every decomposition of a density matrix @xmath0 with @xmath24 into a convex sum of @xmath15 projectors onto pure states can be expressed in terms of a complex @xmath25 matrix @xmath26 obeying @xmath27 and that ( ii ) , conversely , from every such matrix one can obtain a pure - state decomposition of @xmath0 .",
    "the set @xmath28 with @xmath29 is also known as the stiefel manifold .",
    "part ( i ) and ( ii ) together ensure that optimizing over @xmath30 is equivalent to optimizing over the full subset of @xmath23 with fixed cardinality @xmath15 . part ( ii ) also provides an explicit construction of the pure - state decomposition related to an arbitrary given matrix @xmath31 : let @xmath32 , @xmath33 , @xmath34 be the non - zero eigenvalues and corresponding normalized eigenvectors of @xmath0 , i.e. , @xmath35 and @xmath36 . note that we have @xmath37 due to the positive semi - definiteness of @xmath0 .",
    "define the auxiliary states @xmath38 and set @xmath39    in ` libcreme ` , the function ` densityeig ` calculates only the non - zero eigenvalues and corresponding eigenvectors . the eigenvalues are guaranteed to be sorted in decreasing order , which is particularly convenient if one wishes to discard some parts of the density matrix occurring with low probability , such as , e.g. , high - energy sectors in density matrices @xmath40 originating from some hamiltonian @xmath41 .",
    "the function ` psdecomposition ` returns the pure - state decomposition from eqs .",
    "( [ eq : spectral decomposition of rho ] , [ eq : auxiliary states ] , [ eq : p_i of u ] , [ eq : psi_i of u ] ) . as an example , let ` rho ` store a @xmath42 density matrix of rank @xmath43 , and let ` u ` be a matrix from @xmath30 , with arbitrary @xmath29",
    ". then    .... % note that in m - script , functions can return % multiple values of arbitrary dimensions . the % syntax to assign several return values to   % local variables is % [ a , b , ... ] = foo ( ... ) ; [ chi , lambda ] = densityeig(rho ) ; [ psi , p ] = psdecomposition(u , chi , lambda ) ; ....    first yields the eigenvectors of ` rho ` in the columns of the @xmath44 matrix ` chi ` with the corresponding @xmath43 eigenvalues in the vector ` lambda ` . on the second line",
    "then , the pure - state decomposition of ` rho ` ( given in terms of the parameters ` chi ` and ` lambda ` ) corresponding to the parameterization ` u ` is calculated , with the @xmath15 state vectors @xmath2 stored in the columns of the @xmath45 matrix ` psi ` and the @xmath15 corresponding probabilities @xmath46 in the vector ` p ` .    by virtue of the schrdinger - hjw theorem",
    ", we can restate the optimization problem eq .   as @xmath47 where the dependence on @xmath0 enters implicitly as the dependence of the @xmath46 and @xmath2 on the eigenvalues and eigenvectors of @xmath0 . in practice",
    ", it has turned out to be possible to drop the minimization over @xmath15 completely and set @xmath15 to a constant but large enough value instead .",
    "note that this actually includes all cardinalities @xmath48 with @xmath49 in the search because up to @xmath50 of the @xmath46 are allowed to go to zero without breaking the optimization constraint . in ` libcreme ` , the function ` convexsum ` calculates the value of the expression @xmath51 in eq .  , which is , in fact , the objective function of the optimization .",
    "` convexsum ` takes as its first argument a parameterization matrix from the stiefel manifold , as its second a function handle @xcite to the entanglement monotone to be extended , and as its third and fourth arguments the eigendecomposition of the density matrix obtained by ` densityeig ` .",
    "here is a full example :    .... % random 8-by-8 density matrix rho = randdensitymatrix(8 ) ;    % calculate eigendecomposition of rho for   % later use [ chi , lambda ] = densityeig(rho ) ;    % random matrix from st(12 , 8) u = randunitarymatrix(12 , 8) ;    % evaluate convex sum eq . ( 15 ) with the tangle h = convexsum(u , @tangle , chi , lambda ) ....    note that we have introduced the functions ` randdensitymatrix ` and ` randunitarymatrix ` to create random density matrices and random matrices from the stiefel manifold , respectively .",
    "it is important to understand that ` convexsum ` is the key function in the whole library in the sense that it is always this function ( or more specifically , an anonymous function handle @xcite to it , see sec .  [",
    "sec : algorithms ] ) , which is ultimately optimized .",
    "as mentioned earlier , the optimization algorithms in ` libcreme ` require the knowledge of the gradient of the objective function , or more precisely , the derivatives of @xmath51 with respect to the real and imaginary parts of the matrix elements of @xmath26 .",
    "these expressions and their derivation can be found in  [ app : derivatives of h ] . within the library , this gradient of @xmath52 is implemented in ` grad_convexsum ` .",
    "it requires 5 arguments : the matrix @xmath26 , the entanglement monotone to be extended , the gradient of the latter , and the eigendecomposition of @xmath0 ( eigenvectors and -values ) .",
    "the following code illustrates its application in practice , using the variables ` chi ` , ` lambda ` , and ` u ` from the previous example :    .... % evaluate gradient of the convex sum eq .",
    "( 15 ) ,   % given in eqs .",
    "( b4 - b7 ) with the tangle gh = grad_convexsum(u , @tangle , ...",
    "@grad_tangle , chi , lambda ) ....",
    "we describe in this section two conceptually different optimization algorithms which are both provided in ` libcreme ` .",
    "one is a conjugate gradient method based on the concepts introduced in refs .",
    "it exploits the differential - geometric structure of the nonlinear search space emerging from the optimization constraint @xmath53 .",
    "the other algorithm is a standard broyden - fletcher - goldfarb - shanno ( bfgs ) quasi - newton method employing a transformation of the constrained search space to an unconstrained one .",
    "both algorithms have been discussed in greater detail in a previous work @xcite , where the expressions for the gradients and parameterization of the stiefel manifold given below have been derived .",
    "the interested reader is referred to that earlier work .",
    "here , we just state the final results for the sake of completeness and focus particularly on the implementation and usage within ` libcreme ` .",
    "this algorithm exploits the geometric structure of the unitary group @xmath54 and therefore generally over - parameterizes the true search space @xmath30 , @xmath55 .",
    "this is however not a problem in practice , since we can simply discard the last @xmath56 columns of @xmath26 when calculating the decomposition of the density matrix based on @xmath26 @xcite .",
    "the full algorithm for an input initial guess @xmath57 is given as follows :    1 .",
    "initialization : set @xmath58 .",
    "calculate the gradient @xmath59 according to the formula @xmath60 where the matrices @xmath61 and @xmath62 are given by @xmath63 and the gradient of @xmath51 can be found in  [ app : derivatives of h ] .",
    "+ finally , set @xmath64 .",
    "[ enum : step_linmin ] perform the one - dimensional minimization @xmath65 set @xmath66 and compute the new gradient @xmath67 according to eqs .",
    "( [ eq : gradient unitary group ] , [ eq : gradient a ] , [ eq : gradient b ] ) .",
    "3 .   define @xmath68 @xmath69 is the gradient @xmath70 parallel - transported to the new point @xmath71 .",
    "4 .   calculate the modified polak - ribire parameter @xmath72 where @xmath73 .",
    "5 .   set the new search direction to @xmath74 6 .",
    "set @xmath75 .",
    "repeat from step 2 until convergence .",
    "this algorithm is implemented in the function ` cg_min ` .",
    "the minimization in step [ enum : step_linmin ] is performed by the derivative - based method ` minimize1d_exp ` . `",
    "cg_min ` requires the function to be minimized , its gradient , an initial point , and optionally a struct with user - specified termination criteria discussed below . at this point",
    ", we would like to work through a full example demonstrating the use of ` cg_min ` to calculate the convex - roof extended three - tangle of a mixed state .",
    ".... % random 8-by-8 density matrix rho = randdensitymatrix(8 ) ;     % calculate eigendecomposition of rho for   % later use [ chi , lambda ] = densityeig(rho ) ;    % define anonymous function handles [ 24 ] to % the objective function and its gradient f_opt = @(x ) convexsum(x , @tangle , ...                  chi , lambda ) ; g_opt = @(x ) grad_convexsum(x , @tangle , ...",
    "@grad_tangle , chi , lambda ) ;    % choose a random starting point , here for % a decomposition with cardinality 12 u0 = randunitarymatrix(12 , 12 ) ;    % perform the optimization [ t , ut , info ] = cg_min(f_opt , g_opt , u0 ) ; ....    a few comments about the above code are in order .",
    "first , note that because ` cg_min ` requires the objective and its gradient in the form of one - parameter functions , we need to define the anonymous function handles ` f_opt ` and ` g_opt ` before continuing . in this way , ` f_opt ` is a new function that evaluates ` convexsum ` at a variable unitary input matrix while keeping the constant arguments ` @tangle ` , ` chi ` , and ` lambda ` fixed .",
    "a similar description holds for ` g_opt ` .",
    "second , note that the initial search point ` u0 ` is a unitary and therefore square matrix , although matrices from @xmath76 would be sufficient in the example above to parameterize pure - state decompositions .",
    "the reason is , as mentioned above , that ` cg_min ` is operating on the unitary group instead of the stiefel manifold . however , this is hidden from the user by the fact that both ` convexsum ` and ` grad_convexsum ` can accept larger input than required , and automatically discard any dispensable columns .",
    "third , we would like to draw the reader s attention to the output values of ` cg_min ` . in the above example , ` t ` stores the convex - roof of the entanglement monotone to be evaluated ( in this case the three - tangle ) and ` ut ` ( or more precisely , the first @xmath43 columns of it ) represent the pure - state decomposition of ` rho ` arriving at this value .",
    "the variable ` info ` is a struct that carries useful additional information , namely the criterion that terminated the iteration ( ` info.status ` ) , the function values along the iteration , excluding intermediate values during line searches ( ` info.fvals ` ) , and finally , the traversed points in the search space corresponding to ` fvals ` ( ` info.xvals ` ) .    an optional fourth argument containing settings for the termination of the algorithm can be passed to ` cg_min ` .",
    "the following code illustrates the possible struct variables ( the values in this example are also the defaults for any variables not set ) .",
    ".... % create a struct opts = struct ( ) ;    % maximum number of iterations opts.maxiter = 1000 ;    % tol . on consecutive function values opts.tolfun",
    "= 1e-12 ;    % tolerance on norm of difference between % two consecutive gradients opts.tolg = 1e-10 ;    % tolerance on norm of difference between % two consecutive iteration points opts.tolx = 1e-10 ; ....    the iteration is stopped if either the maximum number of iterations is reached , or one of the checked values is lower than its respective tolerance .",
    "finally , we would like to mention that for the convenience of the user , there is a function called ` createconvexfunctions ` which performs all the necessary steps before the actual optimization in one line :    .... % again using the tangle as an example [ f_opt , g_opt ] = createconvexfunctions(rho , ...",
    "@tangle , @grad_tangle ) ; [ t , ut , info ]   = cg_min(f_opt , g_opt , u0 ) ; ....    as with any other numerical optimization procedure , it is advisable to repeat the computations with different ( random ) initial conditions in order to reach a better approximation to the global minimum .",
    "the second algorithm is a classical bfgs quasi - newton method @xcite that makes use of a transformation which is able to unconstrain the optimization problem eq .   from the stiefel manifold to ordinary euclidean space .",
    "this transformation is conceptually identical to the example where one has an optimization problem with the constraint @xmath77 and then sets @xmath78 , @xmath79 and performs the optimization over the new variable @xmath80 .",
    "again , we only state in the following the main results required to implement the algorithm and refer the reader interested in a thorough derivation to ref .  @xcite .",
    "the number of independent real parameters required to parameterize @xmath30 is equal to its dimension which is given by @xmath81 . given a tuple of ` angles ' @xmath82 , @xmath83 , we relabel them in the following ( arbitrary but fixed ) way : @xmath84 for @xmath85 $ ] , @xmath86 for @xmath87 + 1 , \\ldots , r(2k - r - 1)$ ] , and @xmath88 for @xmath89 .",
    "then , we calculate @xmath90 according to @xmath91 r\\ ] ] where @xmath92 , @xmath93 is a @xmath25 matrix with the only non - zero elements being @xmath94 for @xmath95 , and the ` inverse givens matrices ' @xmath96 are defined in terms of their matrix elements as @xmath97_{ij } = \\begin{cases } e^{-\\mathfrak i\\varphi}\\cos\\vartheta , & \\mbox{if } \\;\\ ; i = j = s , \\\\",
    "-e^{-\\mathfrak i\\varphi}\\sin\\vartheta , & \\mbox{if } \\;\\ ; i = s , j = s + 1,\\\\ e^{\\mathfrak i\\varphi}\\sin\\vartheta , & \\mbox{if } \\;\\ ; i = s + 1 , j = s,\\\\ e^{\\mathfrak i\\varphi}\\cos\\vartheta , & \\mbox{if } \\;\\ ; i = s + 1 , j = s + 1,\\\\ \\delta_{ij } ,                  & \\mbox{otherwise}. \\end{cases}\\ ] ]    in ` libcreme ` , calculating a stiefel matrix from a vector of angles ` x ` by eq .   is implemented in ` buildunitary ` as a fast c / c++ extension and is demonstrated in the following :    .... % dimensions of the stiefel manifold k = 10 ; r = 7 ;    % random vector of angles with proper size % ( uses dimst for the dimension of the   % stiefel manifold ) .",
    "see footnote [ 30 ] .",
    "% % randn(m , n ) yields an m - by - n matrix of % normally distributed random numbers .",
    "x = 2*pi*randn(1 , dimst(k , r ) ) ;    % finally , the stiefel matrix u = buildunitary(x , k , r ) ; ....    the derivatives of @xmath98 with respect to the angles @xmath82 are implemented in the function ` grad_buildunitary ` .",
    "the inverse operation of ` buildunitary ` , namely obtaining the parameterizing angles for a given matrix ` u ` can be performed by ` decomposeunitary ` as in    .... x = decomposeunitary(u ) ; ....    this function is implemented in regular in m - script , because it is called only infrequently and thus is not time critical .",
    "we have now all the tools to describe the full bfgs quasi - newton algorithm starting from an initial vector of angles @xmath99 .    1 .   set @xmath58 , @xmath100 , @xmath101 , and @xmath102 .",
    "@xmath103 is the initial guess for the approximate hessian , @xmath52 is the convex sum eq .  , and",
    "@xmath104 is the transformation eq .  .",
    "2 .   perform the line minimization @xmath105 and set @xmath106 3 .",
    "compute the new gradient @xmath107 4 .   update the approximate hessian as  @xcite @xmath108 where the column vectors @xmath109 and @xmath110 are defined as @xmath111 and @xmath112 .",
    "5 .   set the new search direction to @xmath113 6 .",
    "set @xmath75 .",
    "repeat from step 2 until convergence .",
    "the line minimization in step 2 is performed by ` minimize1d_lin ` , a subroutine that is conceptually identical to the function ` minimize1d_exp ` used above in the conjugate - gradient method .",
    "the full algorithm is implemented in ` bfgs_min ` and its input and output parameters are identical to the ones in ` cg_min ` .",
    "hence , the descriptions in the previous section can be adapted analogously to ` bfgs_min ` .",
    "however , the target function ( and its gradient ) look slightly different in the current case and are somewhat more cumbersome in terms of function handles , because the additional intermediate transformation eq .",
    "needs to be incorporated .",
    "the following is a fully working example that should help to clarify this issue .",
    ".... % random 8-by-8 density matrix rho = randdensitymatrix(8 ) ;   [ chi , lambda ] = densityeig(rho ) ;    % convex - sum function handles for the tangle f_cr = @(x ) convexsum(x , @tangle , ...                  chi , lambda ) ; g_cr = @(x ) grad_convexsum(x , @tangle , ...",
    "@grad_tangle , chi , lambda ) ;    % dimensions of the stiefel manifold r = rank(rho ) ; k = r + 4 ;    % objective function and gradient f_opt = @(x ) f_cr(buildunitary(x , k , r ) ) ; g_opt = @(x ) grad_eh_adapt(x , k , r , g_cr ) ;    % choose a random starting point x0 = 2*pi*randn(1 , dimst(k , r ) ) ;    % perform the optimization [ t , xt , info ] = bfgs_min(f_opt , g_opt , x0 ) ; ....    notice the use of the auxiliary function ` grad_eh_adapt ` which calculates the gradient @xmath114 given the derivatives of @xmath51 with respect to the real and imaginary matrix elements of @xmath26 . for the convenience of the user",
    ", there is a function that hides all the above steps just like in the case of the conjugate - gradient algorithm .",
    "it is called ` createehfunctions ` and is analogously called , as exemplified here :    .... [ f_opt , g_opt ] = createehfunctions(rho , ...                k , r , @tangle , @grad_tangle ) ; [ t , xt , info ]   = bfgs_min(f_opt , g_opt , x0 ) ; ....    clearly , the same note as in the previous section regarding multiple restarts holds .    finally , we would like to make a remark about a detail in our implementation of ` bfgs_min ` .",
    "it has shown to be useful in practice to reset the angles modulo @xmath115 every few iterations .",
    "this improves numerical stability and convergence in the vicinity of a minimum .",
    "it is also advisable to vary the interval size after which this is done as this can improve performance depending on the problem .",
    "if ` bfgs_min ` is to be employed for non - periodic functions , these lines of code must be removed .",
    "before we end this section and look at some more examples , we would like to make a few comments . at this point ,",
    "the reader might wonder why we provide our own implementation of a line search and a bfgs quasi - newton method , instead of resorting to the functions available in matlab and octave .",
    "there are several reasons for that .",
    "first of all , it makes the library independent of the platform , since the standard routines in matlab and octave work differently and hence generally produce unequal results .",
    "furthermore , having a simple implementation at hand allows the user to quickly make modifications and customize the code to specific needs . in octave",
    "this is can only be achieved with quite an effort , whereas in matlab it is generally not possible at all .",
    "additional issues are availability and backward - compatibility .",
    "while matlab s optimization framework is well established , it is only available through the purchase of the ` matlab optimization toolbox ' . on the other hand",
    ", there is a free octave package for non - linear optimization tasks  @xcite .",
    "but since this is still under active development , its usage within ` libcreme ` might potentially become incompatible with future releases of the package .",
    "next we would like to address the performance of the algorithms as a function of @xmath116 and @xmath117 .",
    "the dimension of the stiefel manifold ( and hence the problem size ) is given by @xmath118 .",
    "since we must have @xmath29 , we can replace it by @xmath119 , with @xmath120 , yielding @xmath121 .",
    "this shows that the computational cost grows quadratically with the rank of @xmath0 , but only linearly with the ( user - specified ) cardinality .",
    "the algorithms in the library are thus most efficient for low - rank density matrices , whereas experimenting with different cardinalities is not that costly .",
    "actually , already choices for @xmath1 as low as @xmath122 have shown to produce very accurate results in practice ( see also below ) . since",
    ", on the other hand , the scaling with @xmath43 is less favorable , it is advisable to examine whether the rank of @xmath43 can be reduced . particularly in density matrices originating from physical hamiltonians",
    "it is often justified to neglect high - energy states .",
    "as mentioned earlier , reducing the rank of @xmath0 can conveniently be achieved by truncating the output of the function ` densityeig ` .",
    "in this section , we demonstrate the usage of ` libcreme ` by working through two complete examples .",
    "we calculate the entanglement of special states where analytical results are known in order to compare the numerical experiments with theory .",
    "note that we provide initial points for the optimization in separate files instead of generating them randomly , because ( i ) the random number generators in matlab and octave produce different sequences of random numbers and ( ii ) not every initial point leads to the convergence to a global minimum in such high - dimensional spaces .    ) , whereas the dashed line does the same for the tangle of a ghz / w mixture ( example in sec .",
    "[ sec : ex_tangle]).,title=\"fig:\"][fig : convergence ]      isotropic states are defined as a convex mixture of a maximally entangled state and the maximally mixed state in a system of two @xmath19-dimensional subsystems . the isotropic state with an amount of mixing specified by @xmath123 , where @xmath124 , is given by @xcite @xmath125 where @xmath126 . an analytical solution for the entanglement of formation as a function of @xmath123 and @xmath19 has been found @xcite and is implemented in ` eofisotropic ` .",
    "let us compare now the numerical results with theory .",
    "the full example can be found in the folder ` examples / eofisotropic ` , along with all other related files .",
    "we first choose a dimension for the two subsystems ,    .... d = 5 ; ....    then create the maximally entangled state @xmath127 in these systems and store it in ` psi ` :    .... psi = 0 ;    for i = 1:d           tmp = zeros(d , 1 ) ;      tmp(i ) = 1 ;      psi = psi + kron(tmp , tmp ) ; end    psi = psi / sqrt(d ) ; ....    after choosing a value for the mixing parameter ` f ` ,    .... f = 0.3 ; ....    we can construct the isotropic state specified by ` d ` and ` f ` as    .... % note that in m - script , a ' is the hermitian % conjugate of a. rho = ( 1 - f)/(d^2 - 1 ) * ( eye(d^2 ) - ...           ( psi*psi ' ) ) + f*(psi*psi ' ) ; ....    and calculate its eigendecomposition with    .... [ chi , lambda ] = densityeig(rho ) ; ....    in order to keep this example fully reproducible , we unfortunately have to load and overwrite the eigenvectors ` chi ` from a file at this point .",
    "the reason is that the density matrix is degenerate , yielding different eigendecompositions for the degenerate subspace depending on whether one uses matlab or octave due to the different diagonalization routines employed by these platforms .",
    "clearly , one arrives at comparable results in both cases , but the paths in optimization space are different .",
    ".... chi = load('example_eofisotropic_chi.txt ' ) ; ....    after setting an appropriate cardinality    .... r = rank(rho ) ; k = 2*r ; ....    and defining function handles for the entanglement measure and its gradient    .... eoe = @(x ) entropyofentanglement(x , [ d , d ] ) ; grad_eoe = ...",
    "@(x ) grad_entropyofentanglement(x , [ d , d ] ) ; ....    we can create the function handles required in the optimization    .... f_cr = @(x ) convexsum(x , eoe , chi , lambda ) ; g_cr = @(x ) grad_convexsum(x , eoe , ...",
    "grad_eoe , chi , lambda ) ; ....    finally , we choose a random initial value ` u0 ` ( here initialized from a file )    .... u0r = load('example_eofisotropic_u0r.txt ' ) ; u0i = load('example_eofisotropic_u0i.txt ' ) ; u0 = u0r + 1i*u0i ; ....    and perform the optimization :    .... [ e_res , u_res , info ] = cg_min(f_cr , g_cr , u0 ) ; ....    this yields a value of ` e_res ` @xmath128 after 80 iterations .",
    "we can check the convergence and the accuracy of the result by plotting the difference between the function value in each iteration and the theoretical value :    .... semilogy(abs(info.fvals - eofisotropic(f , d ) ) ) ; ....    this produces the solid line in fig .  1",
    ", showing that the result is exact up to an absolute error of @xmath129 .      in this example , we will calculate the three - tangle of a mixture of the two states @xmath130 given by @xcite @xmath131 the example files are in ` examples / tangleghzw ` .    in the code",
    ", we define the states    .... ghz = [ 1 ; 0 ; 0 ; 0 ; 0 ; 0 ; 0 ; 1]/sqrt(2 ) ; w = [ 0 ; 1 ; 1 ; 0 ; 1 ; 0 ; 0 ; 0]/sqrt(3 ) ; ....    choose a particular value for ` p `    .... p = 0.7 ; ....    and create the mixed state    .... rho = p*ghz*ghz ' + ( 1 - p)*w*w ' ; ....    we then specify a value for the cardinality    .... r = rank(rho ) ; k = r + 4 ; ....    and can create the objective function and gradient handles . note that we use the auxiliary function ` createehfunctions ` to do all the required work :    .... [ f_eh , g_eh ] = createehfunctions(rho , ...                  k , r , @tangle , @grad_tangle ) ;                                                ....    after choosing a random initial point ( initialized from a file , as before )    .... x0 = load('example_tangleghzw_x0.dat ' ) ; ....    we are ready to perform the optimization :    .... [ t_res , x_res , info ] = ...            bfgs_min(f_eh , g_eh , x0 ) ; ....    the value one obtains in this way after 29 iterations is ` t_res ` @xmath132 .",
    "a comparison with the analytical value @xcite is exact within numerical precision",
    ". we can again plot the error between the function values and the exact result    .... semilogy(abs(info.fvals - tangleghzw(0.7 ) ) ) ; ....    which yields the dashed line in fig .  1 .",
    "we have presented our library ` libcreme ` which serves to evaluate generic convex - roof entanglement measures .",
    "the library contains all tools required to deal with this problem , including two optimization algorithms working on the space of density matrix decompositions . the first one is based on a conjugate gradient algorithm operating directly on the group of unitary parameterizations , while the second one is a standard bfgs quasi - newton method employed with a transformation from the original search space to unconstrained euclidean space . both implementations accept generic function handles , making it easy to extend their application to user - defined entanglement measures .",
    "all that needs to be done for this is the implementation of the respective pure - state entanglement monotone and the corresponding derivatives with respect to the real and imaginary parts of the input state vector .",
    "we would like to thank stefano chesi for fruitful discussions .",
    "this work was partially supported by the swiss nsf , nccr nanoscience , nccr qsit , solid , and darpa quest .",
    "in the following , we provide the calculations for the derivatives of all entanglement measures included in ` libcreme ` .",
    "let @xmath133 be a state vector from a bipartite system with subsystem dimensions @xmath134 and @xmath135 .",
    "let us rewrite eq . in the form @xmath136 where @xmath137 and @xmath138 .",
    "let @xmath139 be an arbitrary ( complex ) entry of the state vector @xmath133 . then , using the chain rule , we have @xmath140 note that the indices @xmath15 and @xmath141 in the above sum run over the full hilbert space dimension @xmath142 , whereas @xmath143 and @xmath144 only run over the first subsystem with dimension @xmath134 .",
    "we now evaluate each term in the sum separately .    for the gradient of @xmath145",
    "we get @xmath146 \\\\ & = -\\nabla_x \\bigg\\ { \\sum_{n = 1}^\\infty \\frac{(-1)^{n+1}}{n}{\\mathop\\mathrm{tr}\\nolimits}\\left[(x - \\mathbb{i})^{n+1}\\right ] \\\\   &",
    "\\qquad + \\sum_{n = 1}^\\infty \\frac{(-1)^{n+1}}{n}{\\mathop\\mathrm{tr}\\nolimits}\\left[(x - \\mathbb{i})^n\\right]\\bigg\\ } \\\\ & = -\\bigg\\ { \\sum_{n = 1}^\\infty \\frac{(-1)^{n+1}(n+1)}{n}(x - \\mathbb{i})^n   \\\\ & \\qquad + \\sum_{n = 1}^\\infty ( -1)^{n+1}(x - \\mathbb{i})^{n-1}\\bigg\\}^t\\\\ & = -\\bigg\\{-\\sum_{n = 1}^\\infty ( \\mathbb{i } - x)^n   \\\\ & \\qquad + \\sum_{n=1}^\\infty \\frac{(-1)^{n+1}}{n}(x - \\mathbb{i})^n   + \\sum_{n = 0}^\\infty ( \\mathbb{i } - x)^n\\bigg\\}^t\\\\ & = -\\log x^t - \\mathbb{i},\\end{aligned}\\ ] ] where we have made use of the formula @xmath147 and the fact that the series expansion of the logarithm is valid because in our case @xmath148 is always a density matrix , thus having real eigenvalues between 0 and 1 .",
    "next we evaluate the derivatives of the partial trace @xmath149 .",
    "we will write coordinate indices of vectors in the full hilbert space as @xmath150 $ ] , where @xmath151 and @xmath152",
    ". then @xmath153\\,[j , k]}\\ ] ] and thus @xmath154    finally , we have to consider the derivatives of the density matrix itself with respect to the entries of the state vectors .",
    "this is the part where we have to treat @xmath155 and @xmath156 as independent variables because @xmath0 is not analytic in the entries of @xmath133 .",
    "one quickly finds @xmath157    putting all this together we find , after eliminating all kronecker @xmath109-symbols , @xmath158_{n_1 i}\\cdot\\psi^\\ast_{[i , n_2 ] } + [ \\nabla s(\\rho)]_{i n_1}\\cdot\\psi_{[i , n_2]}\\right\\}\\ ] ] and analogously for the derivatives with respect to the imaginary parts . exploiting the fact that @xmath159 is hermitian , we arrive at the final expressions @xmath160_{i n_1}\\cdot \\psi_{[i , n_2]}\\right\\ } , \\\\ \\frac{\\partial e(|\\psi\\rangle)}{\\partial { \\mathop\\mathrm{im}}\\psi_n } & = 2 \\sum_{i = 1}^{d_1}{\\mathop\\mathrm{im}}\\left\\{[\\nabla s({\\mathop\\mathrm{tr}\\nolimits}_b\\rho)]_{i n_1}\\cdot \\psi_{[i , n_2]}\\right\\}.\\end{aligned}\\ ] ]      defining @xmath161 , where @xmath162 are given in eqs .  ( [ eq : tangle_d1 ] , [ eq : tangle_d2 ] , [ eq : tangle_d3 ] ) , it is easy to see that @xmath163 note that the derivatives @xmath164 are well - defined because @xmath19 is an analytic function of the elements @xmath165 of @xmath133 .",
    "we start by calculating the derivative of @xmath166 with respect to an arbitrary complex element @xmath139 of @xmath133 until the point where non - analyticities appear : @xmath167 \\\\ & = -\\frac{4}{n}\\sum_{k = 1}^n \\sum_{j , l = 1}^2{\\mathop\\mathrm{re}}\\left [ \\left(\\rho_k^\\ast\\right)_{jl}\\cdot \\frac{\\partial}{\\partial\\psi } \\left(\\rho_k\\right)_{jl } \\right ] \\\\ & = -\\frac{4}{n}\\sum_{k = 1}^n \\sum_{j , l = 1}^2{\\mathop\\mathrm{re}}\\left\\ { \\left(\\rho_k^\\ast\\right)_{jl } \\sum_{\\alpha , \\beta = 1}^{2^n } \\left [ \\frac{\\partial\\left(\\rho_k\\right)_{jl}}{\\partial\\rho_{\\alpha\\beta } } \\cdot \\frac{\\partial\\rho_{\\alpha\\beta}}{\\partial\\psi } \\right ] \\right\\}.\\label{eq : d_gamma_final } \\end{split}\\ ] ]    the derivatives of the @xmath168 ( depending non - analytically on @xmath139 ) with respect to the real and imaginary part of @xmath139 have already been stated in eqs .",
    "( [ eq : d_rho_re ] , [ eq : d_rho_im ] ) .",
    "we are thus left to calculate the slightly cumbersome derivatives of multiple partial traces of @xmath0 with respect to the matrix elements @xmath168 .    similarly to the calculation in  [ sec : gradient_of_eof ] , we will now rewrite indices @xmath169 of the full hilbert space in the binary representation @xmath170 $ ] , where @xmath171 for all @xmath172 ( we will also employ this represention for the indices @xmath173 , and @xmath1 below ) . then , the matrix elements of @xmath14 can be written as@xmath174\\ ; [ \\nu_1,\\ldots,\\nu_{k-1 } , j , \\nu_{k+1 } , \\ldots \\nu_n ] } , $ ] where @xmath175 .",
    "hence we have @xmath176 inserting this into eq .   and working out all kronecker @xmath109 symbols , we arrive at @xmath177}\\cdot\\left(\\rho_k\\right)_{n_k , j}\\right ) , \\\\",
    "\\left.\\frac{\\partial \\gamma}{\\partial{\\mathop\\mathrm{im}}\\psi_n}\\right|_{|\\psi\\rangle } & = -\\frac{8}{n}\\sum_{k = 1}^n\\sum_{j = 1}^{2 } { \\mathop\\mathrm{im}}\\left(\\psi_{[n_1,n_2,\\ldots , n_{k-1},j , n_{k+1},\\ldots , n_n]}\\cdot\\left(\\rho_k\\right)_{n_k , j}\\right).\\end{aligned}\\ ] ]",
    "we will carry out the calculation explicitly only for the derivatives with respect to the real part of @xmath26 , but everything works analogously for the imaginary part . for the sake of readability , we will drop the usual ` ket ' notation and write quantum state vectors as @xmath178 .",
    "we write the @xmath15th element of @xmath179 as @xmath180 .      where @xmath19 is the dimension of the total hilbert space .",
    "note that we have specifically emphasized the @xmath26-dependence of the @xmath46 and @xmath179 via eqs .",
    "( [ eq : spectral decomposition of rho ] , [ eq : auxiliary states ] , [ eq : p_i of u ] , [ eq : psi_i of u ] ) .",
    "the first derivative in this expression is given by @xmath183 where we have used in the last step the orthonormality of the @xmath184 and the fact that @xmath185 for any complex number @xmath186 .",
    "we can now insert eqs .   and into .",
    "the final result ( including the derivatives with respect to the imaginary part of @xmath26 from an analogous calculation ) reads @xmath188 , \\end{split}\\ ] ] @xmath189 , \\end{split}\\ ] ] where @xmath190,\\\\ \\zeta_{\\alpha\\beta}(u ) & = \\left[\\mathfrak{i}\\sqrt{\\frac{\\lambda_\\beta}{p_\\alpha(u)}}\\chi_\\beta - \\frac{\\lambda_\\beta}{p_\\alpha(u)}{\\mathop\\mathrm{im}}(u_{\\alpha\\beta})\\psi_\\alpha(u)\\right].\\end{aligned}\\ ] ]                            it is easily seen from the cauchy - riemann equations that non - constant functions from @xmath191 to @xmath192 , such as the kind of entanglement measures we are addressing in this work , can not be analytic .",
    "we therefore have to treat the real and imaginary part of complex numbers as independent variables .                          in m - script",
    ", functions can be passed as arguments using ` function handles ' ( conceptually similar to function pointers in c ) . for a function with name ` foo ` , the corresponding function handle is given by ` @foo ` .",
    "subroutines are then able to call ` foo ` through its function handle , given the number and type of parameters are correct .",
    "a related feature of m - sript used frequently in ` libcreme ` are ad hoc , also called ` anonymous ' , function handles .",
    "these are handles to functions which are neither built - in , nor defined in a script file , but rather created on the spot . as an example , consider the following syntax to create a function of two parameters calculating the sine of the parameter s product :      the variable names used to define the function are listed in the parentheses after the `` @ ` ' sign .",
    "directely following is the actual definition of the function .",
    "it can then be called in the usual way , yielding , e.g. ,                however , in the case where one chooses @xmath193 , it is advantageous to employ an algorithm that works directly on the stiefel manifold instead of the unitary group .",
    "the concepts discussed in ref .",
    "@xcite for the real stiefel manifold can be adapted to the complex case by replacing transpositions with hermitian conjugates and the frobenius inner product @xmath194 by @xmath195 .",
    "we note that this way of generating random angles ( which we have chosen here for simplicity ) is not ideal , since it does not sample uniformly from the haar measure . a better way would be to use ` decomposeunitary(randunitarymatrix(k , r ) ) ` ."
  ],
  "abstract_text": [
    "<S> we present the software library ` libcreme ` which we have previously used to successfully calculate convex - roof entanglement measures of mixed quantum states appearing in realistic physical systems . evaluating </S>",
    "<S> the amount of entanglement in such states is in general a non - trivial task requiring to solve a highly non - linear complex optimization problem . </S>",
    "<S> the algorithms provided here are able to achieve to do this for a large and important class of entanglement measures . </S>",
    "<S> the library is mostly written in the matlab programming language , but is fully compatible to the free and open - source octave platform . </S>",
    "<S> some inefficient subroutines are written in c / c++ for better performance . </S>",
    "<S> this manuscript discusses the most important theoretical concepts and workings of the algorithms , focussing on the actual implementation and usage within the library . </S>",
    "<S> detailed examples in the end should make it easy for the user to apply ` libcreme ` to specific problems .    </S>",
    "<S> entanglement measure , convex roof    * program summary *    _ manuscript title : _ libcreme : an optimization library for evaluating convex - roof entanglement measures + _ authors : _ beat rthlisberger , jrg lehmann , daniel loss + _ program title : _ libcreme + _ journal reference : _ </S>",
    "<S> + _ catalogue identifier : _ </S>",
    "<S> + _ licensing provisions : _ gnu gpl version 3 + _ programming language : _ matlab / octave and c / c++ + _ operating system : _ all systems running matlab or octave + _ keywords : _ entanglement measure , convex roof + _ classification : _ 4.9 , 4.15 + _ nature of problem : _ + evaluate convex - roof entanglement measures . </S>",
    "<S> this involves solving a non - linear ( unitary ) optimization problem . </S>",
    "<S> + _ solution method : _ + two algorithms are provided : a conjugate - gradient method using a differential - geometric approach and a quasi - newton method together with a mapping to euclidean space . </S>",
    "<S> + _ running time : _ + typically seconds to minutes for a density matrix of a few low - dimensional systems and a decent implementation of the pure - state entanglement measure . </S>"
  ]
}