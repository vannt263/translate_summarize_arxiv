{
  "article_text": [
    "the practical significance of the discrete logarithm problem on ordinary binary elliptic curves ( see , e.g. , @xcite ) renders these groups a natural target for implementing shor s algorithm @xcite . to implement an actual discrete logarithm computation , efficient quantum circuits to implement the pertinent curve arithmetic are needed , and a number of authors have explored circuits to implement the relevant elliptic curve operations @xcite . when considering a complete implementation of shor s algorithm in such a group , maslov et al.s proposal in @xcite shows that a quadratic depth circuit is sufficient .",
    "the reason for the quadratic depth is essentially two - fold : a double - and - add computation to compute the relevant scalar multiplications in shor s algorithm and a finite field inversion are the dominating operations . as shown in @xcite , inversion in @xmath2",
    "can be implemented in depth @xmath5 , and so one may hope that the quadratic depth bound can indeed be overcome .    [ [ our - contribution . ] ] our contribution .",
    "+ + + + + + + + + + + + + + + + +    below we show that an appropriate organization of the scalar multiplication(s ) in shor s algorithm in combination with an improved @xmath2-arithmetic enables a solution to the discrete logarithm problem on ordinary binary elliptic curves in depth @xmath1 . to implement the necessary group operations we use complete binary edwards curves as described in @xcite .",
    "[ [ structure - of - the - paper . ] ] structure of the paper .",
    "+ + + + + + + + + + + + + + + + + + + + + + +    in the next section we briefly review some background on elliptic curves and shor s algorithm .",
    "in particular we recall the the definition of binary edwards curves as needed for the main part of the paper .",
    "section  [ sec : parallel ] details how with this curve representation the addition of any two curve points can be implemented in logarithmic depth .",
    "thereafter we discuss different options to organize the scalar multiplications in shor s algorithm , including a tree - based approach with polylogarithmic depth . after addressing the technical point of deriving a unique representation of group elements , in section  [ sec : theend ]",
    "we establish our main result .",
    "this section reviews some known results on ordinary binary elliptic curves and on computing discrete logarithms with shor s algorithm .      for @xmath6 a positive integer ,",
    "we denote by @xmath7 a finite field of size @xmath8for a cryptographic application , e.g. , a digital signature scheme , a typical choice would be @xmath9 or @xmath10 @xcite . to represent elements in @xmath7 we use a polynomial basis representation . in other words",
    "we fix an irreducible polynomial @xmath11 $ ] with coefficients in the integers modulo @xmath12 and identify @xmath7 with the quotient @xmath13/(p)$ ] , so that each @xmath14 has a unique expression of the form @xmath15 with @xmath16 .    using a _ short weierstrass form _ , each ordinary binary elliptic curve can be represented by a polynomial equation @xmath17 where @xmath18 with @xmath19 ( * ? ? ?",
    "* chapters  13.1.4 and 13.1.5 ) .",
    "more precisely , the elliptic curve represented by equation   consists of the points @xmath20 , where @xmath21 is the unique projective point that is obtained when homogenizing equation  .",
    "hasse s bound implies that the size of @xmath22 differs from @xmath8 by no more than @xmath23 , and the subgroups of @xmath22 considered in cryptographic applications typically have a very small cofactor .",
    "hence @xmath24 is a natural parameter to measure the complexity of a quantum circuit to solve the discrete logarithm problem in a @xmath22 .",
    "the set @xmath22 has a group structure , but implementing this group law directly comes at a certain inconvenience : case distinctions have to be made , which require the implementation of a ( nested ) if - then - else statement ( cf . the discussion in @xcite ) . to avoid this issue ,",
    "subsequently we use _ complete binary edwards curves _ as introduced by bernstein et al .",
    "for @xmath25 each ordinary elliptic curve is birationally equivalent to a complete binary edwards curve , and we can represent such a curve by an equation @xmath26 with @xmath27 being non - zero , @xmath28 and @xmath29 . can equivalently be expressed as @xmath30 .",
    "] by @xmath31 we denote the points in @xmath32 satisfying equation  .",
    "the group law on @xmath31 is given by the formula @xmath33 where @xmath34 can be arbitrary curve points  including the identity element @xmath35 .",
    "to derive efficient addition formula one can ( similarly as for a weierstrass form ) pass to projective coordinates .",
    "bernstein et al .",
    "@xcite show that from projective representations @xmath36 , @xmath37 of two points one can derive a projective representation @xmath38 of their sum by means of 21 multiplications in @xmath2 , four multiplications by one of the constant @xmath39 , @xmath40 , one squaring and 15 additions in @xmath2 .",
    "@xmath41 from an asymptotic point of view , it suffices to observe that the number of field operations is constant .",
    "it is not necessary , however , to perform these field operations sequentially , and @xcite suggest some parallelization , establishing the following upper bound for the depth of a point addition circuit , where @xmath42 stands for the depth of an @xmath2-multiplier @xmath43 .",
    "[ prop : edadd ] let @xmath44 and @xmath45 be projective representations of two ( not necessarily different ) points @xmath46 . then the addition map @xmath47 where @xmath48 is a projective representation of @xmath49 , can be implemented in depth @xmath50 .",
    "from @xcite it follows that we can choose @xmath51 , and in section  [ sec : fieldmult ] we will show that through a suitable use of trees @xmath42 can be chosen to be of logarithmic depth .",
    "as the number of field operations to add to curve points is constant , this establishes immediately the existence of a logarithmic depth circuit for point addition . to optimize the circuit depth",
    ", we can exploit the bound from proposition  [ prop : edadd ] : looking into the proof of ( * ? ? ?",
    "* proposition  3.3 ) , one recognizes that the term @xmath52 occurring as argument of the maximum in proposition  [ prop : edadd ] describes the multiplication of a binary @xmath53-matrix with a binary vector . in the next section",
    "we will see that such a multiplication can be realized in logarithmic depth as well .",
    "a technical issue that we address in section  [ sec : lowdepthdivision ] is the derivation of the unique ( affine ) representation from a projective representation of a curve point : the natural way to realize this is by means of an inversion in @xmath2 , but for none of the division circuits described in @xcite a polylogarithmic depth bound is available .",
    "we modify the construction in @xcite to achieve polylogarithmic depth .      for our discussion",
    "we assume that a generator @xmath54 of a cyclic subgroup of @xmath31 is fixed and the order @xmath55 of this group generator is known .",
    "moreover , we assume that a group element @xmath56 in the subgroup generated by @xmath57 is fixed ; our goal is to find the unique integer @xmath58 such that @xmath59 .",
    "the algorithm proceeds as follows .",
    "first , two registers of length @xmath60 qubits can be represented with @xmath60 bits . ]",
    "are created and each qubit is initialized in the @xmath61 state .",
    "then a hadamard transform @xmath62 is applied to each qubit , resulting in the state @xmath63 .",
    "next , conditioned on the content of the register holding the label @xmath64 or @xmath65 , we add the corresponding multiple of @xmath57 and @xmath56 , respectively , i.e. , we implement the map @xmath66 hereafter , the third register is discarded and a quantum fourier transform @xmath67 on @xmath68 qubits is computed . finally , the state of the first two registers  which hold a total of @xmath68 qubits  is measured . as shown in @xcite , the factor @xmath69",
    "can be computed from this measurement data via classical post - processing .",
    "the corresponding quantum circuit is shown in figure [ fig : shorcircuit ] . in the following sections ,",
    "we will be concerned with parallelizing the parts of the circuit in this figure . in section  [ sec : lowdepthdivision ] we will address the problem of having a non - unique representation of curve points , as the above description of shor s algorithm implicitly assumes group elements to have a unique representation .",
    "shor s algorithm to compute the discrete logarithm in the subgroup of an elliptic curve generated by a point @xmath57 .",
    "the input to the problem is a point @xmath56 , and the task is to find @xmath58 such that @xmath70 .",
    "the circuit naturally decomposes into three parts , namely ( i ) the hadamard layer on the left , ( ii ) a double scalar multiplication ( in this figure implemented as a cascade of point additions ) , and ( iii ) the quantum fourier transform @xmath71 at the end .",
    "we show that each of these parts can be implemented in a circuit depth of @xmath1 to obtain the main result of this paper.,scaledwidth=90.0% ]",
    "to reduce the circuit depth , we parallelize shor s algorithm on two different levels : ( i ) the computation of @xmath2-multiplications is parallelized and ( ii ) the computation of the scalar products @xmath72 is parallelized .",
    "a simple observation that will be useful is that we can implement the map @xmath73 in depth @xmath74 by arranging @xmath75 cnot gates as a tree .",
    "figure  [ fig : multifanout ] , which derives from ( * ? ? ?",
    "* figure  2 ) , shows such a ` multi - fan - out cnot with @xmath61-input ' for the case @xmath76 .",
    "we note that in general such a tree is not functionally equivalent to a cnot with fan - out greater than @xmath77 , but for the case of a @xmath61-input this equivalence holds , and for our purposes this is the only case needed .    as starting point",
    "to implement multiplication in @xmath2 we use the circuit proposed by maslov et al . in @xcite",
    " which builds on a classical mastrovito multiplier @xcite .",
    "this construction reduces the task of multiplying two elements in @xmath13/(p)$ ] to implementing a quantum circuit that evaluates two matrix - vector multiplications with a toeplitz matrix , one matrix - vector multiplication with a matrix that depends only on the polynomial @xmath78 , and an addition in @xmath79 .",
    "more specifically , the coefficients @xmath80 of the product @xmath81 are obtained as follows , where @xmath82 is independent of the specific field elements to be multiplied ; the matrix @xmath83 depends only on the irreducible polynomial @xmath78 defining the underlying finite field @xmath13/(p)$ ] : @xmath84      to implement the multiplications of @xmath87 and @xmath88 with @xmath89 respectively , we first observe that  considering both the computation of @xmath85 and @xmath86 combined  each coefficient @xmath90 ( @xmath91 ) occurs in exactly @xmath24 products of the form @xmath92 .",
    "similarly , each coefficient @xmath93 ( @xmath94 ) occurs in a total of exactly @xmath24 products .",
    "we want to compute _ all _ of these @xmath95-products in parallel .",
    "so we ensure that @xmath24 ` copies ' of each of @xmath96 are available , using a ` multi - fan - out cnot with @xmath61-input ' for each @xmath97 . as the cnot trees for @xmath97 and @xmath93 with @xmath98 operate on disjoint wires , they can be executed in parallel and implemented in depth @xmath3 .",
    "analogously , using a ` multi - fan - out cnot with @xmath61-input ' for each of @xmath99 we can  in depth @xmath3 and in parallel to the trees for copying the @xmath97-values  provide @xmath24 ` copies ' of each of @xmath99 .    having , at the cost of @xmath0 qubits , all these copies at our disposal ,",
    "we can now , in depth @xmath77 , compute all products @xmath100 that are necessary to find @xmath85 and @xmath86 in parallel , using @xmath101 toffoli gates . having evaluated all these products we can simply compute each entry of @xmath85 and @xmath86 by using a a depth @xmath3 addition tree for each entry of these two vectors . only cnot gates ( and no further ancillae ) are needed for this .",
    "figure  [ fig : ubandlb ] shows an example for the case @xmath102 , i.e. , we have @xmath103 in this case all occurring multiplications can be evaluated in depth @xmath104 , and the final addition trees reduce to a single cnot gate to compute the ` last ' entry @xmath105 of @xmath85 .      from equation  , we see that the vector @xmath106 needs to be multiplied from the left with the fixed @xmath107-matrix @xmath83 .",
    "writing @xmath108 for the hamming weight of the @xmath109 column of @xmath83 and denoting by @xmath110 the @xmath109 entry of @xmath111 , we first create @xmath112 copies of @xmath110 ( @xmath113 ) , requiring @xmath0 qubits .",
    "for this we use again ` multi - fan - out cnot gates with @xmath61-input ' that operate in parallel and can be realized in depth @xmath3 .",
    "this allows us to compute all @xmath24 entries of @xmath114 in parallel : for each entry of the result we can use an @xmath3-depth addition tree that computes the scalar product of the corresponding row of @xmath83 with @xmath111 .",
    "as the matrix @xmath83 is fixed , this can be done by means of cnot gates .",
    "figure  [ fig : mmult ] shows a ` worst case tree ' of depth @xmath115 for the case @xmath116 : multiplying a matrix row consisting entirely of @xmath77s with @xmath117 .    finally , to complete the evaluation of equation  , we add the binary vector @xmath118 to @xmath119 by means of @xmath24 cnot gates that operate in parallel . with all involved steps  computing @xmath85 and @xmath86 ,",
    "finding @xmath120 , and determining @xmath121being realizable in depth @xmath3 we obtain the following result .",
    "[ prop : gf2nlowdepthmult ] there is a polynomial - size quantum circuit of depth @xmath3 which on input polynomial basis representations of @xmath122 computes a polynomial basis representation of the product @xmath123 .    the above - described technique to multiply a vector with the fixed matrix @xmath83 can also be used to implement other matrix - vector multiplications : given a binary @xmath53 matrix @xmath124 and a vector @xmath125 , we first use @xmath24 ` multi - fan - out cnot with @xmath61-input ' to create @xmath24 copies of @xmath126 , investing @xmath0 qubits . handling all entries of @xmath126 in parallel , this can be done in depth @xmath3 .",
    "hereafter we can use an addition tree to compute the necessary @xmath24 scalar products in parallel , just as in the discussion of the matrix @xmath83 .",
    "we can apply this observation to the matrix multiplications occurring in the proof of proposition  [ prop : edadd ] given in @xcite , which replaces the argument @xmath52 of @xmath127 with a function in @xmath3 . in combination with theorem  [ prop : gf2nlowdepthmult ]",
    ", we obtain the following .",
    "[ cor : lowdepthadd ] using projective coordinates , a projective representation of the sum of two points on a complete binary edwards curve @xmath31 can be computed in depth @xmath3 .",
    "an essential part of an implementation of shor s algorithm is a circuit which on input ( binary representations of ) @xmath128 and @xmath129 computes a ( unique ) representation of @xmath72because of hasse s bound , we can assume that @xmath64 and @xmath65 are represented with ( at most ) @xmath60 qubits each .",
    "the approach taken in @xcite can be seen as implementation of a right - to - left version of the double - and add - algorithm and then continue with the necessary additions of the points @xmath130 ; this change of addition order does not affect the circuit depth . ] :    r i=0n 1 rr+2^ip rr+2^iq |return|  r    applying corollary  [ cor : lowdepthadd ] , each point addition requires circuit depth @xmath3 , and so we immediately obtain an @xmath5-depth circuit to compute @xmath131 .",
    "a feature of this particular strategy is that all points @xmath132 and @xmath133 can be precomputed classically , and in all adders involved one argument is constant .",
    "this can be exploited to simplify the addition circuits , but for a realistic value of @xmath24 several hundred different addition circuits are involved . a left - to - right formulation of the double - and - add algorithm offers an alternative that involves only three types of circuits , but this uniformity comes at the cost of a general doubling circuit :    r rr+p rr+q i = n-10 - 1 r2r rr+p rr+q |return|  r    this algorithm processes @xmath64 and @xmath65 simultaneously , so that the total number of doublings is @xmath24 ( rather than @xmath52)the latter technique goes back to straus @xcite and is also known as _",
    "shamir s trick _ ( cf .",
    "@xcite ) . realizing point doubling and addition of @xmath57 respectively",
    "@xmath56 in depth @xmath3 , this yields again an @xmath5-depth circuit to find @xmath131 .      to find @xmath131 with a quantum circuit of smaller depth , we parallelize the computation of @xmath131 . to simplify the description we assume that the length @xmath60 of the binary representation of @xmath64 and of @xmath65 is a power of @xmath12if this is not the case ,",
    "the binary expansions can be padded with @xmath134s accordingly .",
    "( r_0^(_2(n+1)),  ,r_n^(_2(n+1)))(k_02 ^ 0p,  ,k_n2^np ) ( s_0^(_2(n+1)),  ,s_n^(_2(n+1)))(_02 ^ 0s,  ,_n2^ns ) i=_2(n+1)-1 0 -1 ( r^(i)_0,  ,r^(i)_j,  ,r^(i)_2^i-1)=(r^(i+1)_0+r_1^(i+1),  ,r^(i+1)_2j+r^(i+1)_2j+1 ,  , r^(i+1)_2^i+1 - 2+r^(i+1)_2^i+1 - 1 ) ( s^(i)_0,  ,s^(i)_j,  ,s^(i)_2^i-1)=(s^(i+1)_0+s_1^(i+1),  ,s^(i+1)_2j+s^(i+1)_2j+1 ,  , s^(i+1)_2^i+1 - 2+s^(i+1)_2^i+1 - 1 ) |return|",
    "r_0^(0)+s_0^(0 )    the summation computed here is essentially the same as in the first sequential version of the double - and - add algorithm we discussed , therewith following the approach in @xcite .",
    "like maslov et al .",
    "we parallelize the execution of gates that operate on disjoint wires , but we process more than one point @xmath132 respectively @xmath135 at a time .",
    "the ( affine ) points @xmath136 and @xmath137 can be precomputed classically , and the leaves can be initialized with a sequence of cnot gates , conditioned on the individual bits of the binary representation of @xmath64 and @xmath65 . using ` multi - fan - out cnots with @xmath61-input '",
    ", we can create @xmath52 copies of the binary representation of @xmath64 and @xmath52 copies of the binary representation of @xmath65 in depth @xmath3 .",
    "each leaf corresponds to a separate quantum register of linear length , initialized with @xmath138 , and hence the cnot gates for different points operate on disjoint wires .",
    "having @xmath52 copies of each coefficient @xmath139 and @xmath140 available , we can copy all @xmath52 qubits representing a point @xmath132 or @xmath135 on @xmath31 in constant depth .",
    "and @xmath135 is always @xmath77 . ] in particular , the complete initialization can be realized in depth @xmath3 .",
    "child node @xmath141 child node @xmath142 child node @xmath143 child node @xmath144 child node @xmath145 child node @xmath143 child node @xmath146 child node @xmath143 child node @xmath143 child node @xmath147 child node @xmath148 child node @xmath143 child node @xmath143 child node @xmath149 child node @xmath143 child node @xmath143 child node @xmath150 child node @xmath151 ;    to proceed from one tree level to the next , a layer of addition circuits is used that operate in parallel , each circuit adding two curve points . realizing each such addition circuit in logarithmic depth as in corollary  [ cor : lowdepthadd ] results in a quantum circuit of depth @xmath4 to compute @xmath131 .",
    "figure  [ fig : treeaddition ] shows the resulting tree structure to compute @xmath131 .",
    "we obtain the following lemma .",
    "using projective coordinates , for a complete binary edwards curve the map @xmath152 where @xmath153 , can be realized in depth @xmath4 .      in our discussion of the elliptic curve arithmetic we focused on the use of projective coordinates , as this avoids the use of a ( costly ) @xmath2-inversion .",
    "we pay for this by a non - unique point representation , however .",
    "to pass from projective coordinates @xmath154 for a point on @xmath31 to the unique affine coordinates @xmath155 , it is sufficient to compute the inverse of @xmath156 followed by two multiplications in @xmath2 . from theorem  [ prop : gf2nlowdepthmult ] we know that these two multiplications can be implemented in depth @xmath3 , and we are left with the task of computing @xmath157 . in @xcite a depth @xmath5 circuit is proposed for this task which builds on a classical algorithm by itoh ans tsuji @xcite .",
    "this algorithm consists of two main parts followed by a final squaring in @xmath2 .",
    "the two main parts require a total of @xmath3 multiplications in @xmath2 and @xmath3 exponentiations with fixed powers of @xmath12 .",
    "the latter maps are bijective and @xmath95-linear and can be implemented as matrix - vector multiplications with a fixed matrix .",
    "consequently all necessary computations in these two parts can be implemented in depth @xmath4 .",
    "the final squaring operation can again be realized as a matrix - vector multiplication with a fixed matrix , and so the complete inversion can be implemented in depth @xmath4 .",
    "there is a polynomial - size quantum circuit of depth @xmath4 which on input a polynomial basis representation of @xmath158 computes a polynomial basis representation of the inverse @xmath159 .    implementing an @xmath2-inverter in this way and combining it with two multiplication circuits as in theorem  [ prop : gf2nlowdepthmult ]",
    ", we can derive the unique affine representation of a curve point in polylogarithmic depth . more specifically , we have the following .",
    "there is a polynomial - size quantum circuit of depth @xmath4 which on input a projective representation @xmath44 of a point on @xmath31 , returns the affine representation @xmath160 of this point .",
    "we now have all the pieces in place to establish our main result .",
    "shor s algorithm to compute the discrete logarithm on a complete binary edwards curve can be implemented using a quantum circuit of polynomial size and depth @xmath1 .    referring to the three stages as in figure  [ fig : shorcircuit ] ,",
    "we first note that the hadamard gates on the left can be implemented in depth @xmath77 .",
    "next , as shown in subsection [ sec : doubleadd ] , we can implement the operation that computes @xmath161 in depth @xmath1 with a circuit of size polynomial in @xmath24 . in order to complete the proof",
    ", we have to bound the depth of the fourier transform @xmath162 . for this",
    ", we use a result shown in @xcite that the fourier transform on @xmath75 qubits with target error @xmath163 can be implemented with a circuit of depth @xmath164 and polynomial size . choosing @xmath165 and",
    "@xmath166 is sufficient for shor s algorithm to find the discrete logarithm with constant probability of success @xcite , i.e. , we can upper bound the depth of the @xmath71 by @xmath167 and hence the overall depth of the circuit by @xmath1 . @xmath168",
    "the above discussion shows that the depth @xmath0 bound for discrete logarithm computations on ordinary binary elliptic curves can be improved exponentially : using parallelization at multiple levels , we can implement shor s algorithm on complete binary edwards curves in depth @xmath1 . to show our result we introduced the first sublinear - depth circuits for @xmath2-multiplication and @xmath2-inversion , which may be of independent interest .",
    "the price for the exponential reduction in depth is the introduction of ancillae  a parallelized @xmath2-multiplier as discussed in section  [ sec : fieldmult ] adds @xmath0 additional qubits .",
    "depending on the number of qubits available , for cryptographically significant parameters , say @xmath169 , trade - offs that put less emphasis on depth - optimization could be interesting .",
    "for instance , one could combine the parallelized double - and - add computation with a linear - depth field arithmetic . even though not being depth - optimal , thousands of qubits could be saved in this way .",
    "one could also try to avoid the general point addition circuits in the parallelized double - and - add procedure ( which involve many field multiplications ) and instead rely on a sequential depth @xmath5 solution with specialized point addition circuits as discussed in section  [ sec : seq2a ] .",
    "it is not clear at this point how the best trade - off for a large - scale discrete logarithm computation looks like .",
    "it is interesting to compare our findings for bounding the depth of shor s algorithm over an additive group on an ordinary binary elliptic curve to the case of factoring . in both cases the high - level structure ",
    "namely , phase estimation over an abelian group  of the algorithm is the same , however , the details on how to implement the arithmetic differ significantly . in the case of the elliptic curve arithmetic ,",
    "the bottle neck are the addition formulae for points on the curve which involve finite field divisions .",
    "our polylogarithmic depth implementation of shor s algorithm may be compared with the findings of @xcite in which an @xmath1 upper bound on the depth for shor s algorithm for integer factorization was given for a 2d nearest neighbor architecture and to @xcite , where a circuit of depth @xmath0 was derived , albeit on a 1d nearest neighbor architecture .",
    "the circuits presented in this paper assume an arbitrary coupling model and we leave it as an open problem whether they can be adapted to a 2d nearest neighbor architecture while maintaining the same upper bound on the circuit depth .",
    "to enable parallelization , we make intensive use of ` multi - fan - out cnots with @xmath61-input ' , and one may hope for further depth improvements if multi - fan - out gates are provided . at the moment",
    "we do not know how to derive an asymptotic benefit of such gates that goes beyond a constant factor improvement .",
    "the remaining bottleneck for an asymptotic improvement in the @xmath2-arithmetic seems the logarithmic depth for parity computations .",
    "finally , amy et al.s @xcite observation that @xmath2-multiplication can be realized in @xmath170-depth 2 suggests another natural direction for follow - up research : minimizing @xmath170-depth and the number of @xmath170-gates necessary to compute discrete logarithms on binary elliptic curves .",
    "we thank the reviewers for their constructive feedback and we thank schloss dagstuhl , germany , for providing an excellent environment for part of this research through a _",
    "quantum cryptanalysis _ seminar .",
    "rs was supported by the spanish _ ministerio de economa y competitividad _ through the project grant mtm-2012 - 15167 and by nato s public diplomacy division in the framework of `` science for peace '' , project md.sfpp 984520 .",
    "this work was carried out while mr was with nec laboratories america , princeton , nj 08540 , usa .",
    "daniel  j. bernstein , tanja lange , and reza  rezaeian farashahi . .",
    "in elisabeth oswald and pankaj rohatgi , editors , _ cryptographic hardware and embedded systems  ches 2008 _ , volume 5154 of _ lecture notes in computer science _ , pages 244265 .",
    "international association for cryptologic research , springer , 2008 .",
    "edoardo  d. mastrovito . .",
    "in teo mora , editor , _ proceedings of the sixth symposium on applied algebra , algebraic algorithms and error correcting codes _ , volume 357 of _ lecture notes in computer science _ , pages 297309 .",
    "springer , 1988 ."
  ],
  "abstract_text": [
    "<S> improving over an earlier construction by kaye and zalka @xcite , in @xcite maslov et al . </S>",
    "<S> describe an implementation of shor s algorithm , which can solve the discrete logarithm problem on ordinary binary elliptic curves in quadratic depth @xmath0 . in this paper </S>",
    "<S> we show that discrete logarithms on such curves can be found with a quantum circuit of depth @xmath1 . as technical tools we introduce quantum circuits for @xmath2-multiplication in depth @xmath3 and for @xmath2-inversion in depth @xmath4 . </S>"
  ]
}