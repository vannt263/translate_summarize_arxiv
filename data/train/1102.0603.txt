{
  "article_text": [
    "in this paper we treat the problem of controlling robots to perpetually act in a changing environment , for example to clean an environment where material is constantly collecting , or to monitor an environment where uncertainty is continually growing .",
    "each robot has only a small footprint over which to act ( e.g. to sweep or to sense ) .",
    "the difficulty is in controlling the robots to move so that their footprints visit all points in the environment regularly , spending more time in those locations where the environment changes quickly , without neglecting the locations where it changes more slowly .",
    "this scenario is distinct from most other sweeping and monitoring scenarios in the literature because the task can not be `` completed . ''",
    "that is to say , the robots must continually move to satisfy the objective .",
    "we consider the situation in which robots are constrained to move on fixed paths , along which we must control their speed .",
    "we consider both the single robot and multi - robot cases .",
    "figure  [ fig : sample_pm ] shows three robots monitoring an environment using controllers designed with our method .",
    "we model the changing environment with a scalar valued function defined , which we call the _",
    "accumulation function_. the function behaves analogously to dust accumulating over a floor .",
    "when a robot s footprint is not over a point in the environment , the accumulation function grows at that point at a constant rate , as if the point were collecting dust .",
    "when a robot s footprint is over the point , the accumulation function decreases at a constant rate , as if the dust were being vacuumed by the robot .",
    "the rates of growth and decrease can be different at different points in the environment .",
    "this model is applicable to situations in which the task of the robot is to remove material that is collecting in the environment , for example cleaning up oil in the ocean around a leaking well  @xcite , vacuuming dirt from the floor of a building  @xcite , or tending to produce in an agricultural field  @xcite .",
    "it is also applicable to monitoring scenarios in which the state of the environment changes at each point , and we want to maintain up - to - date knowledge of this changing state .",
    "some examples include monitoring temperature , salinity , or chlorophyll in the ocean  @xcite , maintaining estimates of coral reef health  @xcite , or monitoring traffic congestion over a city  @xcite .",
    "these applications all share the property that they can never be completed , because the environment is always changing .",
    "if the robot were to stop moving , the oil would collect beyond acceptable levels , or the knowledge of the ocean temperature would become unacceptably outdated . for this reason we call these applications _",
    "persistent tasks_. in this paper , we assume that the model is known either from the physics of the environment , from a human expert , or from an initial survey of the environment .",
    "however we show analytically and in simulation that our controllers are robust to model errors .",
    "we focus on the situation in which the robots are given fixed , closed paths on which to travel , and we have to carry out the persistent task only by regulating their speed .",
    "this is relevant in many real - world scenarios .",
    "for example , in the case that the robots are autonomous cars , they may be constrained to move on a particular circuit of roads in a city to avoid traffic congestion , or in the case of autonomous aircraft , they may be constrained to fly along a particular path to stay away from commercial air traffic , or to avoid being detected by an adversary . even in the case of vacuuming the floor of a building",
    ", the robots may be required to stay along a prescribed path so as not to interfere with foot traffic .",
    "furthermore , if we have the freedom to plan the robot s path , we can employ an off - line planner to generate paths that are optimal according to some metric ( using the planner in  @xcite for example ) , then apply the procedure in this paper to control the speed along the path .",
    "decoupling the path planning from the speed control in this way is a well - established technique for dealing with complex trajectory planning problems  @xcite .",
    "our approach to the problem is to represent the space of all possible speed controllers with a finite set of basis functions , where each possible speed controller is a linear combination of those basis functions .",
    "a rich class of controllers can be represented in this way .",
    "using this representation as our foundation , the main contributions of this paper are the following .    1 .",
    "we formally introduce the idea of persistent tasks for robots in changing environments , and propose a tractable model for designing robot controllers .",
    "2 .   considering the space of speed controllers parametrized by a finite set of basis functions ,",
    "we formulate a linear program ( lp ) whose solution is a speed controller which guarantees that the accumulation function eventually falls below , and remains below , a known bound everywhere .",
    "if the lp is infeasible , then no controller in the space that will keep the accumulation function bounded .",
    "3 .   we formulate an lp whose solution is the optimal speed controller  that which eventually minimizes the maximum of the accumulation function over all locations .",
    "we generalize to the multi - robot case .",
    "we find an lp whose solution is a controller which guarantees that the accumulation function falls below , and stays below , a known bound",
    ". the multi - robot controller does not require communication between robots .",
    "we do not find the optimal controller for the multi - robot case , however , as it appears that this controller can not be found as the solution to an lp .",
    "we demonstrate the performance of the controllers in numerical simulations , and show that they are robust to stochastic and deterministic errors in the environment model , and to unmodeled robot vehicle dynamics .",
    "it is desirable to cast our speed control problem as an lp since lps can be solved efficiently with off - the - shelf solvers  @xcite .",
    "this is enabled by our basis function representation .",
    "the use of basis functions is a common , and powerful method for function approximation  @xcite , and is frequently used in areas such as compressive sampling  @xcite , adaptive control  @xcite , and machine learning  @xcite .",
    "our lp formulations also incorporate both maximum and minimum limits on the robot s speed , which can be different at different points on the path .",
    "this is important because we may want a robot not to exceed a certain speed around a sharp turn , for example , while it can go much faster on a long straightaway .",
    "our work is related to the large body of existing research on environmental monitoring , sensor sweep coverage , lawn mowing and milling , and patrolling . in the environmental monitoring literature ( also called objective analysis in meteorological research @xcite and kriging in geological research @xcite ) , authors often use a probabilistic model of the environment , and estimate the state of that model using a kalman - like filter .",
    "then robots are controlled so as to maximize a metric on the quality of the state estimate .",
    "for example , the work in  @xcite controls robots to move in the direction of the gradient of mutual information .",
    "more recently , the authors of @xcite and  @xcite control vehicles to decrease the variance of their estimate of the state of the environment .",
    "this is accomplished in a distributed way by using average consensus estimators to propagate information among the robots .",
    "similarly , @xcite proposes a gradient based controller to decrease the variance of the estimate error in a time changing environment . in  @xcite sensing robots are coordinated to move in a formation along level curves of the environmental field . in  @xcite",
    "the authors find optimal trajectories over a finite horizon if the environmental model satisfies a certain spatial separation property .",
    "also , in @xcite the authors solve a dynamic program ( dp ) over a finite horizon to find the trajectory of a robot to minimize the variance of the estimate of the environment , and a similar dp approach was employed in  @xcite over short time horizons .",
    "many other works exist in this vein .",
    "although these works are well - motivated by the uncontested successes of kalman filtering and kriging in real - world estimation applications , they suffer from the fact that planning optimal trajectories under these models requires the solution of an intractable dynamic program , even for a static environment .",
    "one must resort to myopic methods , such as gradient descent ( as in  @xcite ) , or solve the dp approximately over a finite time horizon ( as in  @xcite ) .",
    "although these methods have great appeal from an estimation point of view , little can be proved about the comparative performance of the control strategies employed in these works .",
    "the approach we take in this paper circumvents the question of estimation by formulating a new model of growing uncertainty in the environment . under this model",
    ", we can solve the speed planning problem over _ infinite time _ , while maintaining _ guaranteed _ levels of uncertainty in a _ time - changing _ environment .",
    "thus we have used a less sophisticated environment model in order to obtain stronger results on the control strategy . because our model is based on the analogy of dust collecting in an environment",
    ", we also solve infinite horizon sweeping problems with the same method .",
    "our problem in this paper is also related to sweep coverage , or lawn mowing and milling problems , in which robots with finite sensor footprints move over an environment so that every point in the environment is visited at least once by a robot .",
    "lawn mowing and milling has been treated in  @xcite and other works .",
    "sweep coverage has recently been studied in  @xcite , and in @xcite efficient sweep coverage algorithms are proposed for ant robots . a survey of sweep coverage is given in  @xcite .",
    "our problem is significantly different from these because our environment is dynamic , thereby requiring continual re - milling or re - sweeping .",
    "a different notion of persistent surveillance has been considered in  @xcite and  @xcite , where a persistent task is defined as one whose completion takes much longer than the life of a robot . while the terminology is similar , our problem is more concerned with the task ( sweeping or monitoring ) itself than with power requirements of individual robots .",
    "a problem more closely related to ours is that of patrolling  @xcite , where an environment must be continually surveyed by a group of robots such that each point is visited with equal frequency .",
    "similarly , in  @xcite vehicles must repeatedly visit the cells of a gridded environment .",
    "also , continual perimeter patrolling is addressed in  @xcite . in another related work , a region",
    "is persistently covered in  @xcite by controlling robots to move at constant speed along predefined paths .",
    "our work is different from these , however , in that we treat the situation in which different parts of the environment may require different levels of attention .",
    "this is a significant difference as it induces a difficult resource trade - off problem as one typically finds in queuing theory  @xcite , or dynamic vehicle routing  @xcite . in  @xcite",
    ", the authors consider unequal frequency of visits in a gridded environment , but they control the robots using a greedy method that does not have performance guarantees .    indeed",
    ", our problem can be seen as a dynamic vehicle routing problem with some unique features .",
    "most importantly , we control the speed of the robots along a pre - planned path , whereas the typical dynamic vehicle routing problem considers planning a path for vehicles that move at constant speed . also , in our case all the points under a robot s footprint are serviced simultaneously , whereas typically robots service one point at a time in dynamic vehicle routing .",
    "finally , in our case servicing a point takes an amount of time proportional to the size of the accumulation function at that point , whereas the service time of points in dynamic vehicle routing is typically independent of that points wait - time .",
    "the paper is organized as follows . in section  [ sec : problem_formulation ] we set up the problem and define some basic notions . in section",
    "[ sec : stability_and_optimality ] two lps are formulated , one of which gives a stabilizing controller , and the other one an optimal controller .",
    "multiple robots are addressed in section  [ sec : multi_robot ] .",
    "the performance and robustness of the controllers are illustrated in simulations in section  [ sec : simulations ] .",
    "finally , section  [ sec : conclusions ] gives conclusions and extensions .",
    "in this section we formalize persistent tasks , introduce the notion of a field stabilizing controller , and provide a necessary and sufficient conditions for field stability .      consider a compact environment @xmath0 , and a finite set of points of interest @xmath1 .",
    "the environment contains a closed curve @xmath2 \\to { { \\mathbb{r}}}^2 $ ] , where @xmath3 .",
    "( see figure  [ fig : curve_setup ] for an illustration . )",
    "the curve is parametrized by @xmath4 $ ] , and we assume without loss of generality that @xmath5 is the arc - length parametrization .",
    "the environment also contains a single robot ( we will generalize to multiple robots in section  [ sec : multi_robot ] ) whose motion is constrained along the path @xmath6 .",
    "the robot s position at a time @xmath7 can be described by @xmath8 , its position along the curve @xmath6 .",
    "the robot is equipped with a sensor with finite footprint @xmath9 ( for example , the footprint could be a disk of radius @xmath10 centered at the robot s position ) .",
    "our objective is to control the speed @xmath11 of the robot along the curve .",
    "we assume that for each point @xmath5 on the curve , the maximum possible robot speed is @xmath12 and the minimum robot speed is @xmath13 .",
    "this allows us to express constraints on the robot speed at different points on the curve .",
    "for example , for safety considerations , the robot may be required to move more slowly in certain areas of the environment , or on high curved sections of the path . to summarize ,",
    "the robot is described by the triple @xmath14 .",
    "a time - varying field @xmath15 , which we call the _ accumulation function _ , is defined on the points of interest @xmath16 .",
    "this field may describe a physical quantity , such as the amount of oil on the surface of a body of water .",
    "alternatively , the field may describe the robot s uncertainty about the state of each point of interest .",
    "we assume that at each point @xmath17 , the field @xmath18 increases ( or is produced ) at a constant rate @xmath19 .",
    "when the robot footprint is covering @xmath20 , it consumes @xmath18 at a constant rate @xmath21 , so that when a point @xmath20 is covered , the net rate of decrease is @xmath22 .",
    "thus , @xmath18 evolves according to the following differential equation ( with initial conditions @xmath23 and @xmath24 ) : @xmath25 where for each @xmath17 , we have @xmath26 . in this paper , we assume that we know the model parameters @xmath19 and @xmath21 . it is reasonable to assume knowledge of @xmath21 since it pertains to the performance of the robot .",
    "for example , in an oil cleanup application , the consumption rate of oil of the robot can be measured in a laboratory environment or in field trials prior to control design . as for the production rate , @xmath19 , this must be estimated from the physics of the environment , from a human expert ( e.g. an oil mining engineer in the case of an oil well leak ) , or it can be measured in a preliminary survey of the environment . however , the accuracy of the model is not crucial , as we show analytically and in simulations that our method has strong robustness with respect to errors in @xmath19 .",
    "the production function can also be estimated and incorporated into the controller on - line , though we save the development of an on - line strategy for future work .    with this notation",
    ", we can now formally define a _",
    "persistent task_.    a persistent task is a tuple @xmath27 , where @xmath28 is the robot model , @xmath6 is the curve followed by the robot , @xmath16 is the set of points of interest , and @xmath29 and @xmath30 are the production and consumption rates of the field , respectively .     followed by the robot .",
    "the robot is located at @xmath5 and has footprint @xmath31 .",
    "the set @xmath32 of robot positions @xmath5 for which the footprint covers @xmath33 are shown as thick grey segments of the curve . ]    in general , for a given persistent task , the commanded speed @xmath11 could depend on the current position @xmath5 , the field @xmath18 , the initial conditions @xmath24 and @xmath23 , and time @xmath7 .",
    "thus , defining the set of initial conditions as @xmath34 , a general controller has the form @xmath35 . for the reader s convenience , the notation used in this paper is summarized in table  [ tab : parameters ] .      in this section",
    "we formalize the problem of stabilizing the field in a persistent task . as a first consideration",
    ", a suitable controller should keep the field bounded everywhere , independent of the initial conditions .",
    "this motivates the following definition of stability .",
    "[ def : stability ] a speed controller field stabilizes a persistent task if the field is always eventually bounded , independent of initial conditions .",
    "that is , if there exists a @xmath36 such that for every @xmath17 and initial condition @xmath23 and @xmath24 , we have @xmath37    note that in this definition of stability , for every initial condition , the field eventually enters the interval @xmath38 $ ] .",
    "there are some persistent tasks for which no controller is field stabilizing .",
    "this motivates the notion of _",
    "feasibility_.    a persistent task is feasible if there exists a field stabilizing speed controller .",
    "as stated above , for a given persistent task , a general speed controller can be written as @xmath35 . however , in the remainder of the paper we will focus on a small subset of speed controllers which we call _ periodic position - feedback controllers_. in these controllers , the speed only depends on the robot s current position @xmath4 $ ] .",
    "the controllers are periodic in the sense that the speed at a point @xmath5 is the same on each cycle of the path .",
    "the controller can be written as @xmath39 \\to { { \\mathbb{r } } } _ { > 0},\\ ] ] where each @xmath4 $ ] is mapped to a speed @xmath40 satisfying the bounds @xmath41 .",
    "these controllers have the advantage that they do not require information on the current state of the field @xmath18 , only its model parameters @xmath19 and @xmath21 .",
    "while it may seem restrictive to limit our controllers to this special form , the following result shows that it is not .",
    "[ prop : periodic_cont ] if a persistent task can be stabilized by a general controller @xmath35 , then it can be stabilized by a periodic position - feedback controller @xmath40 .    the proof of proposition  [ prop : periodic_cont ] is given in appendix  [ sec : appendix ] , and relies on the statement and proof of the upcoming result in lemma  [ lem : stab_cond ] .",
    "therefore , we encourage the reader to postpone reading the proof until after lemma  [ lem : stab_cond ] .    we will now investigate conditions for a controller to be field stabilizing and for a persistent task to be feasible .",
    "let us define a function which maps each point @xmath17 , to the curve positions @xmath5 for which @xmath20 is covered by the robot footprint . to this end , we define @xmath42 \\ ; | \\ ; { \\mathbf{q}}\\in{\\mathcal{b}}(\\theta)\\}}.\\ ] ] an illustration of the curve , the robot footprint , and the set @xmath32 is shown in figure  [ fig : curve_setup ] .",
    "( in section  [ sec : simulations ] we discuss how this set can be computed in practice . )    given a controller @xmath43 , we define two quantities : 1 ) the cycle time , or period , @xmath44 , and 2 ) the coverage time per cycle @xmath45 . since @xmath46 for all @xmath5 , the robot completes one full cycle of the closed curve in time @xmath47 during each cycle , the robot s footprint is covering the point @xmath20 only when @xmath48 .",
    "thus the point @xmath20 is covered for @xmath49 time units during each complete cycle .    with these definitions",
    "we can give a necessary and sufficient condition for a controller to stabilize a persistent task .",
    "in section  [ sec : stability_and_optimality ] , we develop a method for testing if this condition can be satisfied by a speed controller .",
    "[ lem : stab_cond ] given a persistent task , a controller @xmath40 is field stabilizing if and only if @xmath50 for every @xmath17 . applying the definitions in   and  ,",
    "the condition can be expressed as @xmath51 .",
    "the lemma has a simple intuition .",
    "for stability , the field consumption per cycle must exceed the field production per cycle , for each point @xmath17 .",
    "we now prove the result .",
    "consider a point @xmath17 , and the set of curve positions @xmath32 for which @xmath20 is covered by the robot footprint . given the speed controller @xmath11 ,",
    "we can compute the cycle time @xmath44 in  ( [ eq : rev_time ] ) . then , let us consider the change in the field from @xmath52 to @xmath53 , where @xmath54 .",
    "define an indicator function @xmath55\\times q\\to \\{0,1\\}$ ] as @xmath56 for @xmath57 and @xmath58 otherwise .",
    "then , from  ( [ eq : z_diffeq ] ) we have that @xmath59 for all values of @xmath52 , with equality if @xmath60 . integrating the above expression over @xmath61",
    "$ ] we see that @xmath62 where @xmath45 is defined in  , and the equality follows from the fact that @xmath63 is simply an indicator function on whether or not the footprint is covering @xmath20 at a given time . from   we see that for the field to be eventually bounded by some @xmath64 for all initial conditions @xmath23 , we require that @xmath65 for all @xmath17 .    to see that the condition is also sufficient , suppose that @xmath66",
    ". then there exists @xmath67 such that @xmath68 .",
    "if @xmath69 , then the field at the point @xmath17 is strictly positive over the entire interval @xmath61 $ ] , implying that @xmath70 thus , from every initial condition , @xmath52 moves below @xmath71 .",
    "additionally , note that for each @xmath72 in the interval @xmath61 $ ] , we trivially have that @xmath73 .",
    "thus , we have that there exists a finite time @xmath74 such that for all @xmath75 , @xmath76 since @xmath16 is finite , there exists a single @xmath77 such that for every point @xmath17 we have @xmath78 .",
    "hence , letting @xmath79 , we see that @xmath18 is stable for all @xmath20 , completing the proof .    in the following sections we will address two problems , determining a field stabilizing controller , and determining a minimizing controller , defined as follows :    [ prob : pm ] given a persistent task ,",
    "determine a periodic position - feedback controller @xmath80 \\to { { \\mathbb{r}}}_{>0}$ ] that satisfies the speed constraints ( i.e. , @xmath81 $ ] for all @xmath4 $ ] ) , and    1 .",
    "is field stabilizing ; or 2 .",
    "minimizes the maximum steady - state field @xmath82 : @xmath83    in section  [ sec : stability_and_optimality ] we will show that by writing the speed controller in terms of a set of basis functions , problems ( i ) and ( ii ) can be solved using linear programs . in section  [ sec : multi_robot ]",
    "we will solve problem ( i ) for multiple robots .",
    "in this paper we focus on a finite set of points of interest @xmath84 . these @xmath85 locations could be specific regions of interest , or they could be a discrete approximation of the continuous space obtained by , for example , laying a grid down on the environment . in the section  [ sec : simulations ]",
    "we will show examples of both scenarios .",
    "our two main results are given in theorems  [ thm : lin_prog ] and  [ thm : lin_prog_opt ] , which show that a field stabilizing controller , and a controller minimizing @xmath82 , can each be found by solving an appropriate linear program .    to begin , it will be more convenient to consider the reciprocal speed controller @xmath86 , with its corresponding constraints @xmath87 now , our approach is to consider a finite set of basis functions @xmath88 .",
    "example basis functions include ( a finite subset of ) the fourier basis or gaussian basis  @xcite . in what follows we will use rectangular functions as the basis : @xmath89 for each @xmath90 .",
    "this basis , which provides a piecewise constant approximation to a curve , has the advantage that we will easily be able to incorporate the speed constraints @xmath91 and @xmath12 into the controller .",
    "then let us consider reciprocal speed controllers of the form @xmath92 where @xmath93 are free parameters that we will use to optimize the speed controller .",
    "a rich class of functions can be represented as a finite linear combination of basis functions , though not all functions can be represented this way .",
    "limiting our speed controller to a linear parametrization allows us to find an optimal controller within that class , while preserving enough generality to give complex solutions that would be difficult to find in an ad hoc manner . in the following subsection we will consider the problem of synthesizing a field stabilizing controller .",
    "in this section we will show that a field stabilizing speed controller of the form   can be found through the solution of a linear program .",
    "this result is summarized in theorem  [ thm : lin_prog ] .",
    "we remind the reader that a summary of the mathematical symbols and their definitions is shown in table  [ tab : parameters ] .    [ cols=\"^,<\",options=\"header \" , ]     to begin , let us consider reciprocal speed controllers in the form of  . then for @xmath94 ,",
    "the stability condition in lemma  [ lem : stab_cond ] becomes @xmath95 rearranging , we get @xmath96 where we have defined @xmath97 finally , to satisfy the speed constraints we have that @xmath98 for the rectangular basis in  ( [ eq : rect_basis ] ) , the speed constraints become @xmath99 where @xmath100 thus , we obtain the following result .",
    "[ thm : lin_prog ] a persistent task is stabilizable by a speed controller of the form   if and only if the following linear program is feasible : @xmath101 where @xmath102 is defined in  , and @xmath103 are the optimization variables .    hence , we can solve for a field stabilizing controller using a simple linear program .",
    "the program has @xmath104 variables ( one for each basis function coefficient ) , and @xmath105 constraints ( two for each basis function coefficient , and one for each point of interest in @xmath16 ) .",
    "one can easily solve linear programs with thousands of variables and constraints  @xcite .",
    "thus , the problem of computing a field stabilizing controller can be solved for finely discretized environments with thousands of basis functions .",
    "note that in the above lemma , we are only checking feasibility , and thus the cost function in the optimization is arbitrary .",
    "for simplicity we write the cost as @xmath58 .    in theorem  [ thm : lin_prog ]",
    "the cost is set to @xmath58 to highlight the feasibility constraints .",
    "however , in practice , an important consideration is _ robustness _ of the controller to uncertainty and error in the model of the field evolution , and in the motion of the robot .",
    "robustness of this type can be achieved by slightly altering the above optimization to maximize the _ stability margin_. this is outlined in the following result .",
    "[ rmk : mincyclecontroller ] the optimization @xmath106 where @xmath103 and @xmath107 are the optimization variables , yields a speed controller which maximizes the stability margin , @xmath108 .",
    "the controller    1 .   has the largest decrease in @xmath109 per cycle , and thus achieves steady - state in the minimum number of cycles .",
    "2 .   is robust to errors in estimating the field production rate . if the robot s estimate of the production rate at a field point @xmath110 is @xmath111 , and the true value is @xmath112 , then the field is stable provided that for each @xmath94 @xmath113    the first property follows directly from the fact that @xmath114 is the amount of decrease of the field at point @xmath115 in one cycle .    to see the second property ,",
    "suppose that the optimization is based on a production rate @xmath111 for each @xmath110 , but the true production rate is given by @xmath116 , where @xmath77 . in solving the optimization above",
    ", we obtain a controller with a stability margin of @xmath117 . for the true system to be stable",
    "we require that for each @xmath110 , @xmath118 this can be rewritten as @xmath119 from which we see that the true field is stable provided that @xmath120 for each @xmath110 .",
    "given an arbitrary set of basis functions , the inequalities in   yield an infinite ( and uncountable ) number of constraints , one for each @xmath4 $ ] .",
    "this means that for some basis functions the linear program in theorem  [ thm : lin_prog ] can not be solved exactly .",
    "however , in practice , an effective method is to simply enforce the constraints in   for a finite number of @xmath5 values , @xmath121 .",
    "each @xmath122 generates two constraints in the optimization .",
    "then , we can tighten each constraint by @xmath123 , yielding @xmath124 for each @xmath125 . choosing the number of @xmath5 values @xmath126 as large as possible given the available computational resources , we",
    "can then increase @xmath127 until the controller satisfies the original speed constraints .      in this section",
    "we look at problem  [ prob : pm ] ( ii ) , which is to minimize the maximum value attained by the field over the finite region of interest @xmath16 .",
    "that is , for a given persistent task , our goal is to minimize the following cost function , @xmath128 over all possible speed controllers @xmath11 . at times",
    "we will refer to the maximum steady - state value for a point @xmath20 using a speed controller @xmath11 as @xmath129    our main result of this section , theorem  [ thm : lin_prog_opt ] , is that @xmath82 can be minimized through a linear program .",
    "however , we must first establish intermediate results .",
    "first we show that if @xmath11 is a field stabilizing controller , then for every initial condition there exists a finite time @xmath130 such that @xmath131 for all @xmath132 .",
    "[ prop : steady_state ] consider a feasible persistent task and a field stabilizing speed controller . then",
    ", there is a steady - state field @xmath133 \\to { { \\mathbb{r}}}_{\\geq 0},\\ ] ] satisfying the following statements for each @xmath17 :    1 .",
    "for every set of initial conditions @xmath24 and @xmath23 , there exists a time @xmath134 such that @xmath135 for all @xmath136 .",
    "there exists at least one @xmath137 $ ] such that @xmath138 .    from the above result we see that from every initial condition",
    ", the field converges in finite time to a steady - state @xmath139 . in steady - state , the field @xmath52 at time @xmath7 depends only on @xmath8 ( and is independent of @xmath23 ) .",
    "each time the robot is located at @xmath5 , the field is given by @xmath139 .",
    "moreover , the result tells us that in steady - state there is always a robot position at which the field is reduced to zero . in order to prove proposition  [ prop : steady_state ] we begin with the following lemma . recall that the cycle - time for a speed controller @xmath11 is @xmath140 .",
    "[ lem : reduce_to_zero ] consider a feasible persistent task and a field stabilizing speed controller .",
    "for every @xmath17 and every set of initial conditions @xmath23 and @xmath24 , there exists a time @xmath141 such that @xmath142 for all non - negative integers @xmath143 .    consider any @xmath17 , and initial conditions @xmath23 and @xmath24 , and suppose by way of contradiction that the speed controller is stable but @xmath144 for all @xmath145 . from lemma  [ lem : stab_cond ] , if the persistent task is stable , then @xmath146 for all @xmath20 .",
    "thus , there exists @xmath67 such that @xmath147 for all @xmath148 . from the proof of lemma  [ lem : stab_cond ] ,",
    "we have that @xmath149 therefore , given @xmath23 , we have that @xmath150 for some finite @xmath141 , a contradiction .",
    "next we will verify that if @xmath150 for some @xmath141 , then @xmath151 . to see this , note that the differential equation   is piecewise constant . given a speed controller @xmath40 , the differential equation is time - invariant , and admits unique solutions .",
    "based on this , consider two initial conditions for  , @xmath152 and @xmath153 since   is time - invariant , we have that @xmath154 , and @xmath155 .",
    "in addition , by uniqueness of solutions , we also know that @xmath156 implies that @xmath157 .",
    "thus , we have that @xmath158 , proving the desired result .",
    "the previous lemma shows that from every initial condition there exists a finite time @xmath130 , after which the field at a point @xmath20 is reduced to zero in each cycle . with this lemma we can prove proposition  [ prop : steady_state ] .    in lemma  [ lem : reduce_to_zero ] we have shown that for every set of initial conditions @xmath23 , @xmath24 , there exists at time @xmath141 such that @xmath159 for all non - negative integers @xmath143 . since @xmath44 is the cycle - time for the robot , we also know that @xmath160 for all @xmath143 .",
    "since   yields unique solutions ,   uniquely defines @xmath52 for all @xmath136 , with @xmath161 hence , we can define the steady - state profile @xmath139 as @xmath162    finally , we need to verify that @xmath139 is independent of initial conditions . to proceed , suppose by way of contradiction that there are two sets of initial conditions @xmath163 , @xmath164 , and @xmath165 , @xmath166 which yield different steady - state fields @xmath167 and @xmath168 .",
    "that is , there exists @xmath169 such that @xmath170 . without loss of generality , assume that @xmath171 . to obtain a contradiction , we begin by showing that this implies @xmath172 for all @xmath5 .",
    "note that @xmath173 and @xmath174 reach their steady - state profiles @xmath175 and @xmath176 in finite time .",
    "thus , there exist times @xmath177 for which @xmath178 , and @xmath179 , and @xmath180 . since @xmath181 , and since @xmath18 is a continuous function of time , either i ) @xmath182 for all @xmath183 , or ii ) there exists a time @xmath184 for which @xmath185 , which by uniqueness of solutions implies @xmath186 for all @xmath75 .",
    "thus , @xmath187 for all @xmath54 , implying that @xmath172 for all @xmath5 .    from lemma  [ lem : reduce_to_zero ]",
    ", there exists a @xmath188 for which @xmath189 . since , @xmath190 for all @xmath5 , we must have that @xmath191 .",
    "however , the value of @xmath173 and @xmath174 at @xmath188 uniquely defines @xmath175 and @xmath192 for all @xmath5 , implying that @xmath193 , a contradiction .    from proposition",
    "[ prop : steady_state ] we have shown the existence of a steady - state field @xmath139 that is independent of initial conditions @xmath23 and @xmath24 .    now , consider a point @xmath17 and a field stabilizing speed controller @xmath40 , and let us solve for its steady - state field @xmath194 .",
    "to begin , let us write @xmath32 ( the set of @xmath5 values for which the point @xmath20 is covered by the footprint ) as a union of disjoint intervals @xmath195 \\cup [ x_2,y_2 ] \\cup \\cdots \\cup [ x_{\\ell},y_{\\ell}],\\ ] ] where @xmath196 is a positive integer , and @xmath197 for each @xmath198 . , and the points @xmath199 and @xmath200 are a function of @xmath20 .",
    "however , for simplicity of notation , we will omit writing the explicit dependence . ]",
    "thus , on the intervals @xmath201 $ ] the point @xmath20 is covered by the robot footprint , and on the intervals @xmath202 $ ] , the point @xmath20 in uncovered .",
    "as an example , in figure  [ fig : curve_setup ] , the set @xmath32 consists of two intervals , and thus @xmath203 .",
    "an example of a speed controller and an example of a set @xmath32 are shown in figures  [ fig : speed_profile ] and  [ fig : steady_state ] .    from differential equation",
    "we can write @xmath204 where for @xmath205 , we define @xmath206 . combining equations   and",
    "we see that @xmath207 for each @xmath208 , let us define . therefore , if @xmath209 , then @xmath210 . ]",
    "@xmath211 note that we can write @xmath212 and , from   we have @xmath213 moreover , @xmath214 thus , we see that the quantity @xmath215 gives the maximum reduction in the field between @xmath216 and @xmath217 .",
    "an example for @xmath218 is shown in figure  [ fig : steady_state_below ] . with these definition",
    ", we can characterize the steady - state field at the points @xmath219 .    given a feasible persistent task and a field stabilizing speed controller ,",
    "consider a point @xmath17 and the set @xmath220 $ ] .",
    "then , for each @xmath198 we have @xmath221 where @xmath215 is defined in   and @xmath222 .",
    "let us fix @xmath198 . given a field stabilizing controller ,",
    "proposition  [ prop : steady_state ] tells us that there exists @xmath5 such that @xmath223 .",
    "it is clear that this must occur for some @xmath57 .",
    "therefore , @xmath224    let @xmath225 be the smallest non - negative integer such that @xmath226 .",
    "by we have @xmath227 if @xmath228",
    ", then the previous equation simply states that @xmath229 .",
    "now , if @xmath230 for all @xmath231 , then @xmath232 , and we have completed the proof .    suppose by way of contradiction that there is @xmath233 for which @xmath234 .",
    "from   we have @xmath235 where the second inequality comes from the fact that @xmath236 .",
    "however @xmath237 , implying that @xmath230 , a contradiction .",
    "the above lemma gives the value of the field in steady - state at each end point @xmath219 .",
    "the field decreases from @xmath238 to @xmath219 ( since these are the @xmath5 values over which the point @xmath20 is covered ) , and then increases from @xmath219 to @xmath239 .",
    "therefore , the maximum steady - state value is attained at an end point @xmath238 for some @xmath240 .",
    "for example , in figure  [ fig : steady_state ] , the maximum is attained at the point @xmath241 .",
    "however , the value at @xmath238 can be easily computed from the value at @xmath242 using  : @xmath243 from this we obtain the following result .",
    "[ lem : steady - state_upper ] given a field stabilizing speed controller @xmath11 , the maximum steady - state field at @xmath17 ( defined in  ) satisfies @xmath244 where @xmath245 and @xmath220 $ ] with @xmath246 for each @xmath240 .",
    "the above lemma provides a closed form expression ( albeit quite complex ) for the largest steady - state value of the field .",
    "thus , consider speed controllers of the form @xmath247 where @xmath248 are basis functions ( e.g. , the rectangular basis ) . for a finite field @xmath249",
    ", the terms @xmath250 can be written as @xmath251 where @xmath252 with these definitions we can define a linear program for minimizing the maximum of the steady - state field .",
    "we will write @xmath253 to denote the number of disjoint intervals on the curve @xmath6 over which the point @xmath20 is covered , as defined in  .",
    "[ thm : lin_prog_opt ] given a feasible persistent task , the solution to the following linear program yields a speed controller @xmath11 of the form   that minimizes the maximum value of the steady - state field  @xmath82 .",
    "@xmath254      & & k\\in\\{1,\\ldots,\\ell({\\mathbf{q}}_i)\\},\\\\      & & b\\in\\{0,\\ldots,\\ell({\\mathbf{q}}_i)-1\\}\\\\      & \\sum_{j=1}^n \\alpha_j k({\\mathbf{q}}_i,\\beta_j ) > 0      & \\forall\\ ; i\\in\\{1,\\ldots , m\\}\\\\      & \\frac{1}{{v_{\\max}}(j ) } \\leq \\alpha_j \\leq \\frac{1}{{v_{\\min}}(j ) } ,      & \\forall\\ ; j\\in\\{1,\\ldots , n\\}.    \\end{aligned}\\ ] ] the optimization variables are @xmath255 and @xmath107 and the quantities @xmath256 and @xmath102 are defined in   and  .    from the above theorem , we can minimize the maximum value of the field using a linear program .",
    "this optimization has @xmath257 variables ( @xmath104 basis function coefficients , and one upper bound @xmath107 ) .",
    "the number of constraints is @xmath258 . in practice",
    ", @xmath259 is small compared to @xmath104 and @xmath85 , and is independent of @xmath104 and @xmath85 .",
    "thus , for most instances , the linear program has @xmath260 constraints .",
    "in this section we turn to the multi - robot case . we find that a field stabilizing controller can again be formulated as the solution of a linear program .",
    "surprisingly , the resulting multi - robot controller does not rely on direct communication between the robots .",
    "we also show that the optimal controller ( the one that minimizes the steady state field ) for multiple robots can not be formulated as an lp as in the single robot case . finding the optimal multi - robot controller is a subject of ongoing work .",
    "the multiple robots travel on fixed paths , but those paths my be different ( or they may be the same ) and they may intersect arbitrarily with one another . the robots may have different consumption rates , footprints , and speed limits . we do not explicitly deal with collisions in this section , though the controller we propose can be augmented with existing collision avoidance strategies .",
    "this is the subject of on going work .",
    "we must first modify our notation to accommodate multiple robots .",
    "consider @xmath261 robots with closed paths @xmath262 \\to { { \\mathbb{r}}}^2 $ ] , @xmath263 where @xmath264 and @xmath265 may intersect with each other arbitrarily ( e.g. , they may be the same path , share some segments , or be disjoint ) .",
    "we again assume that the parametrization of each curve is an arc - length parametrization , normalized to unity .",
    "robot @xmath10 , which traverses path @xmath264 at position @xmath266 , has a consumption rate @xmath267 over a footprint @xmath268 , and has a speed controller @xmath269 with maximum and minimum speed constraints @xmath270 and @xmath271 , respectively .",
    "let @xmath272 be the tuple containing the parameters for robot @xmath10 and redefine @xmath273 to be the tuple containing all the robots tuples of parameters .",
    "also , the set of points @xmath274 from which @xmath20 is in robot @xmath10 s footprint is denoted @xmath275 .",
    "furthermore , we let @xmath276 and @xmath277 be the tuple of all robot s paths and all robots consumption functions , respectively .",
    "the persistent task with @xmath261 robots is now written @xmath278 as before , and we seek speed controllers @xmath269 to keep @xmath52 bounded everywhere , as in definition  [ def : stability ] .",
    "we make the assumption that when multiple robots footprints are over the same point @xmath20 , their consumption rates are additive .",
    "specifically , let @xmath279 be the set of robots whose footprints are over the point @xmath20 at time @xmath7 , @xmath280 then the rate of change of the function @xmath52 is given by @xmath281 we can reformulate a stability condition analogous to lemma [ lem : stab_cond ] to suit the multi - robot setting , but we must first establish the notion of a common period for the speed controllers of all the robots .",
    "let @xmath282 be the period of robot @xmath10 , and let @xmath283 be the time in that period that @xmath20 is in robot @xmath10 s footprint .",
    "the existence of a common period rests on the following technical assumption .",
    "[ ass : rational_periods ] we assume that the periods @xmath284 are rational numbers , so that there exist integers @xmath285 and @xmath286 such that @xmath287 .    an immediate consequence of assumption [ ass : rational_periods ] is that there exists a common period @xmath44 such that @xmath288 for all @xmath10 . that is , each controller executes a whole number of cycles over the time interval @xmath44 .",
    "specifically , letting @xmath289 , we have @xmath290 .",
    "now , we can state the necessary and sufficient conditions for a field stabilizing multi - robot controller .",
    "[ lem : multirobot_stab_cond ] given a multi - robot persistent task , the set of controllers @xmath291 , @xmath292 is field stabilizing if and only if @xmath293 for every @xmath17 , where @xmath282 and @xmath294",
    ".    the lemma states an intuitive extension of lemma [ lem : stab_cond ] , which is that the total consumption per cycle must exceed the total production per cycle at each point @xmath17 .",
    "the proof closely follows the proof of lemma [ lem : stab_cond ] .",
    "consider the change of @xmath52 at a point @xmath20 over any time interval @xmath44 , where @xmath44 is a common period of all the rational periods @xmath284 , so that @xmath288 for all @xmath10 . by integrating ( [ eq : multirobot_z_diffeq ] ) we have that @xmath295 where @xmath296 takes the value @xmath297 when @xmath20 is in the footprint of robot @xmath10 and @xmath58 otherwise . to simplify notation ,",
    "define @xmath298 and @xmath299 .",
    "first we prove necessity . in order to reach a contradiction ,",
    "assume that the condition in lemma [ lem : multirobot_stab_cond ] is false , but the persistent task is stable .",
    "then @xmath300 for some @xmath20 , implying @xmath301 for some @xmath20 and for all @xmath7 , which contradicts stability .",
    "in particular , for an initial condition @xmath302 , @xmath303 for all @xmath304 .    now we prove sufficiency .",
    "if the condition is satisfied , there exists some @xmath67 such that @xmath305 .",
    "suppose that at some time @xmath7 and some point @xmath20 , @xmath306 ( if no such time and point exists , the persistent task is stable ) .",
    "then for all times in the interval @xmath307 $ ] , @xmath308 , and by ( [ eq : multirobot_z_diffeq ] ) we have that @xmath309 . therefore ,",
    "after finitely many periods @xmath44 , @xmath52 will become less than @xmath310 .",
    "now for a time @xmath7 and a point @xmath20 such that @xmath311 , for all times @xmath312 $ ] we have that @xmath313 . therefore ,",
    "once @xmath52 falls below @xmath314 ( which will occur in finite time ) , it will never again exceed @xmath315 .",
    "therefore the persistent task is stable with @xmath316 .",
    "[ rem : justification_of_rational_periods ] assumption [ ass : rational_periods ] is required only for the sake of simplifying the exposition .",
    "the rational numbers are a dense subset of the real numbers , so for any @xmath317 we can find @xmath285 and @xmath286 such that @xmath318 . one could carry the @xmath319 through the analysis to prove our results in general .",
    "a field stabilizing controller for the multi - robot case can again be formulated as the solution of a linear program , provided that we parametrize the controller using a finite number of parameters .",
    "our parametrization will be somewhat different than for the single robot case , however . because there are multiple robots , each with its own period",
    ", we must normalize the speed controllers by their periods .",
    "we then represent the periods ( actually , the inverse of the periods ) as separate parameters to be optimized . in this way",
    "we maintain the independent periods of the robots while still writing the optimization over multiple controllers as a single set of linear constraints .",
    "define a normalized speed controller @xmath320 , and the associated normalized coverage time @xmath321 .",
    "we parametrize @xmath322 as @xmath323 where @xmath324 is the number of basis functions for the @xmath10th robot , and @xmath325 and @xmath326 \\to { { \\mathbb{r}}}_{\\ge 0}$ ] are robot @xmath10 s @xmath327th parameter and basis function , respectively .",
    "it is useful to allow robots to have a different number of basis functions , since they may have paths of different lengths with different speed limits . assuming the basis functions are normalized with @xmath328 for all @xmath10 and @xmath327",
    ", then we can enforce that @xmath329 is a normalized speed controller by requiring @xmath330    as before , we could use any number of different basis functions , but here we specifically consider rectangular functions of the form ( [ eq : rect_basis ] ) .",
    "we also define the frequency for robot @xmath10 as @xmath331 , and allow it to be a free parameter , so that @xmath332 from ( [ eq : multirobot_stability ] ) , for the set of controllers to be field stabilizing , we require @xmath333 for all @xmath292 and @xmath94 .",
    "thus , defining @xmath334 the stability constraints become @xmath335    to satisfy the speed constraints , we also require that @xmath336 , which from ( [ eq : multirobot_speed_param ] ) leads to @xmath337 for all @xmath338 $ ] .",
    "for the rectangular basis functions in ( [ eq : rect_basis ] ) , this specializes to @xmath339 for all @xmath10 and @xmath327 , where @xmath340 and @xmath341 this gives a linear set of constraints for stability , which allows us to state the following theorem .",
    "[ thm : stab_multi ] a persistent task is stabilizable by a set of multi - robot speed controllers @xmath269 , @xmath342 , of the form ( [ eq : multirobot_speed_param ] ) if and only if the following linear program is feasible : @xmath343 where each @xmath344 and @xmath345 is an optimization variable , and @xmath346 is defined in  .",
    "the above linear program has @xmath347 variables ( one for each basis function coefficient @xmath344 , and one for each frequency @xmath345 ) , and @xmath348 constraints . thus",
    ", if we use @xmath104 basis functions for each of the @xmath261 robot speed controllers , then the number of variables is @xmath349 and the number of constraints is @xmath350 .",
    "therefore , the size of the linear program grows linearly with the number of robots .",
    "[ rmk : mincyclemulticontroller ] as summarized in corollary  [ rmk : mincyclecontroller ] , rather than using the trivial cost function of @xmath58 in the lp in theorem [ thm : stab_multi ] , one may wish to optimize for a meaningful criterion .",
    "for example , the controller that gives the minimum number of common periods to steady - state can be obtained by maximizing @xmath107 subject to @xmath351 @xmath352 , in addition to the other constraints of theorem [ thm : stab_multi ] .",
    "[ rmk : optimalspeedcontroller ] the reader will note that we do not find the speed controller that minimizes the steady state field for the multi - robot case , as was done for the single robot case .",
    "the reason is that the quantities called @xmath353 in the single robot case would depend on the relative positions of the robots in the multiple robot case .",
    "these quantities would have to be enumerated for all possible relative positions between the multiple robots and there are infinite such relative positions .",
    "thus the problem can not be posed as an lp in the same way as the single robot case .",
    "we are currently investigating alternative methods for finding the optimal multi - robot controller , such as convex optimization .",
    "in this section we present simulation results for the single robot and multi - robot controllers .",
    "the purpose of this section is threefold : ( i ) to discuss details needed to implement the speed control optimizations , ( ii ) to demonstrate how controllers can be computed for both discrete and continuous fields , and ( iii ) to explore robustness to modeling errors , parameter uncertainty , robot tracking errors , and stochastic field evolution .",
    "the optimization framework was implemented in matlab@xmath354 , and the linear programs were solved using the freely available sedumi ( self - dual - minimization ) toolbox . to give the readers some feel for the efficiency of the approach , we report the time to solve each optimization on a laptop computer with a @xmath355 dual core processor and @xmath356 of ram .",
    "the simulations are performed by discretizing time , and thus converting the field evolution into a discrete - time evolution . to perform the optimization",
    ", we need a routine for computing the set @xmath32 for each field point @xmath17 .",
    "this is done as follows .",
    "we initialize a set @xmath32 for each point @xmath20 , and discretize the robot path into a finite set @xmath357 . for the rectangular basis , this disretization is naturally given by the set of basis functions .",
    "we iteratively place the robot footprint at each point @xmath122 , oriented with the desired robot heading at that point on the curve , and then add @xmath122 to each set @xmath32 for which @xmath20 is covered by the footprint . by approximating the robot footprint with a polygon , we can determine if a point lies in the footprint efficiently ( this is a standard problem in computational geometry ) .",
    "figure  [ fig : vehicle_2d_sim ] shows a simulation for one ground robot performing a persistent monitoring task of @xmath358 points ( i.e. , @xmath359 ) .",
    "the environment is a @xmath360 by @xmath360 square , and the closed path has a length of @xmath361 .",
    "for all points we set the consumption rate @xmath362 ( in units of@xmath363 ) . for each yellow point",
    "@xmath20 we set @xmath364 , and for the single red point we set @xmath365 .",
    "the robot has a circular footprint with a radius of @xmath366 , and for all @xmath5 the robot has a minimum speed of @xmath367 and a maximum speed of @xmath368 .",
    "if the robot were to simply move at constant speed along the path , then @xmath369 of the @xmath358 field points would be unstable .",
    "the speed controller resulting from the optimization in section  [ sec : optimal_speed ] is shown in figure  [ fig : speed_profile_2 ] .",
    "a total of @xmath370 rectangular basis functions were used .",
    "the optimization was solved in less than @xmath371 of a second . using the speed controller ,",
    "the cycle time was @xmath372 .",
    "the field @xmath52 at each point is indicated by the area of the disk centered at the point .",
    "the vehicle footprint is a disk .",
    "the time sequence of the three snapshots goes from left to right .",
    "the vehicle is moving counter - clockwise around the top half of the figure eight and clockwise around the bottom half .",
    "the time evolution of the red field point is shown in figure  [ fig:2d_sim_speed_steady_state].,title=\"fig : \" ]   points .",
    "the field @xmath52 at each point is indicated by the area of the disk centered at the point .",
    "the vehicle footprint is a disk .",
    "the time sequence of the three snapshots goes from left to right .",
    "the vehicle is moving counter - clockwise around the top half of the figure eight and clockwise around the bottom half .",
    "the time evolution of the red field point is shown in figure  [ fig:2d_sim_speed_steady_state].,title=\"fig : \" ]   points .",
    "the field @xmath52 at each point is indicated by the area of the disk centered at the point .",
    "the vehicle footprint is a disk .",
    "the time sequence of the three snapshots goes from left to right .",
    "the vehicle is moving counter - clockwise around the top half of the figure eight and clockwise around the bottom half .",
    "the time evolution of the red field point is shown in figure  [ fig:2d_sim_speed_steady_state].,title=\"fig : \" ]    the field @xmath52 for the red ( shaded ) point in figure  [ fig : vehicle_2d_sim ] , is shown as a function of time in figure  [ fig : steady_state_2 ] .",
    "one can see that the field converges in finite time to a periodic cycle .",
    "in addition , the field goes to zero during each cycle .",
    "the periodic cycle is the steady - state as characterized in section  [ sec : optimal_speed ] .         in figure",
    "[ fig : multi_3d_sim ] , a simulation is shown for the case when the entire continuous environment must be monitored by two aerial robots . for multiple robots we synthesized a field stabilizing controller by maximizing the stability margin , as discussed in remark  [ rmk : mincyclemulticontroller ] .",
    "the continuous field is defined over a @xmath373 by @xmath373 square , and was approximated using a @xmath374 grid .",
    "for all points @xmath17 we set the consumption rate @xmath362 , and the production function is shown in figure  [ fig : prod_fn ] .",
    "for the simulations in figures  [ fig : vehicle_3d_sim ] and  [ fig : multi_3d_sim ] . ]",
    "robot @xmath297 followed a figure - eight path which has a length of @xmath375 , while robot @xmath376 followed a four - leaf clover path with a length of @xmath377 .",
    "the footprint for robot @xmath297 , the higher ( yellow ) robot had a radius of @xmath378 , and the speed constraints were given by @xmath379 and @xmath380 .",
    "the footprint for robot @xmath376 , the lower ( red ) robot , had a radius of @xmath381 , and the speed constraints were given by @xmath382 and @xmath383 .",
    "the cycle time for robot @xmath297 was @xmath384 , and the cycle time for robot @xmath376 was @xmath385 .",
    "a total of @xmath370 rectangular basis functions were used for each robot s speed controller .",
    "the optimization was solved in approximately @xmath358 seconds .",
    "a snapshot for a simulation with three robots is shown in figure  [ fig : sample_pm ] . in this case",
    ", the green robot flying at a higher altitude has a square footprint which is oriented with the robot s current heading .      in this subsection",
    "we demonstrate how we can compute a speed controller that exhibits robustness to motion errors , modeling uncertainty , or stochastic fluctuations .",
    "this is important since the speed controller is computed offline .",
    "it should be noted , however , that in practice the controller can be recomputed periodically during the robot s execution , taking into account new information about the field evolution .    as shown in corollary  [ rmk : mincyclecontroller ] we can maximize stability margin of a speed controller .",
    "the corollary showed that in maximizing this metric we obtain some robustness to error . to explore the robustness properties of this controller , consider the single robot example in figure  [ fig : vehicle_3d_sim ] . in this example , the square @xmath386 by @xmath386 environment must be monitored by an aerial robot .",
    "we approximated the continuous field using a @xmath374 grid .",
    "the consumption rate was set to @xmath387 , for each field point @xmath17 .",
    "the production rate of the field was given by the function shown in figure  [ fig : prod_fn ] .",
    "the maximum production rate of the field was @xmath388 and the average was @xmath389 .",
    "the robot had a circular footprint with a radius of @xmath381 , a minimum speed of @xmath390 and a maximum speed of @xmath391 .",
    "the path had a cycle length of @xmath392 .",
    "if the robot followed the path at constant speed , then @xmath393 of the points would be unstable .    for the speed controller , we used @xmath394 rectangular basis functions , and solved the optimization as described in corollary  [ rmk : mincyclecontroller ] , resulting in a stability margin of @xmath395 .",
    "the optimization was solved in approximately @xmath358 seconds .",
    "the time for the robot to complete one cycle of the path using this controller was @xmath396 .",
    "* stochastic field evolution : * now , suppose that we add zero - mean noise to the production function . thus , the robot based its speed controller on the `` nominal '' production function @xmath397 ( shown in figure  [ fig : prod_fn ] ) , but the actual production function is @xmath398 , where @xmath399 is noise . for the simulation , at each time instant @xmath7 , and for each point @xmath17 , we independently draw @xmath399 uniformly from the set @xmath400 $ ] , where @xmath401 is the maximum value of the noise .",
    "the simulations were carried out as follows .",
    "we varied the magnitude of the noise @xmath402 , and studied the maximum value reached by the field . for each value @xmath402",
    ", we performed @xmath403 trials , and in each trial we recorded the maximum value reached by the field on a time horizon of @xmath404 . in figure",
    "[ fig : noise_exp ] , we display statistics from the @xmath403 independent trials at each noise level , namely the mean , minimum , and maximum , as well as the standard deviation . with zero",
    "added noise , one can see that the mean , minimum , and maximum all coincide . as noise",
    "is added to the evolution , the difference between the minimum and maximum value grows .",
    "however , it is interesting to note that while the performance degrades ( i.e. , the mean increases with increasing noise ) , the system remains stable .",
    "thus , the simulation demonstrates some of the robustness properties of the proposed controller .    , the plot shows statistics on the maximum value reached by the field over 20 independent trials . ]",
    "* parameter errors : * we can also consider robustness to parameter errors .",
    "in particular , consider the case where the robot bases its optimization on a production rate of @xmath397 ( shown in figure  [ fig : prod_fn ] ) , but the actual production rate is given by @xmath405 , where @xmath77 ( note that the field is trivially stable for any @xmath406 ) . by maximizing the stability margin , we obtain some level of robustness against this type of parameter uncertainty . the amount of error that we can tolerate is directly related to the stability margin @xmath395 , as shown in corollary  [ rmk : mincyclecontroller ] . in particular , we obtain @xmath407 .",
    "we performed simulations of monitoring task for successively larger values of @xmath319 . from this data",
    ", we verified that the field remains stable for any @xmath408 .",
    "for this example , the average value of @xmath19 over all points @xmath20 is @xmath389 , and so we can handle uncertainty in the magnitude of the production rate on the order of @xmath409 .    *",
    "tracking error : * after running the speed optimization , a robot has a desired trajectory , consisting of the pre - specified path and the optimized speed along the path . in practice , this trajectory will be the input to a tracking controller , which takes into account the robot dynamics . since there are inevitably tracking errors , the stability margin of the controller is needed to ensure field stability . as an example",
    ", we considered a unicycle model for an aerial robot .",
    "in this model , the robot s configuration is given by a heading @xmath410 and a position @xmath411 .",
    "the control inputs are the linear and angular speeds : @xmath412 , @xmath413 , and @xmath414 .",
    "the linear speed had bounds of @xmath390 and @xmath391 , and the angular speed was upper bounded by @xmath415 .",
    "we used the same speed controller as in the previous two examples ( maximizing the stability margin ) . for trajectory tracking",
    ", we used a dynamic feedback linearization controller  @xcite .",
    "we chose conservative controller gains of @xmath416 for the proportional and derivative control in order to accentuate the tracking error .",
    "the results are shown in figure  [ fig : tracking ] . due to the stability margin of @xmath417 ,",
    "the field remains stable , even in the presence of this tracking error .",
    "however , in simulation , the maximum field height increased by about @xmath418 from @xmath419 ( as shown for the zero noise case in figure  [ fig : noise_exp ] ) to @xmath420 .",
    "in this paper we proposed a model for persistent sweeping and monitoring tasks and derived controllers for robots to accomplish those tasks .",
    "we specifically considered the case in which robots are confined to pre - specified , closed paths , along which their speed must be controlled .",
    "we formulated an lp whose solution gives speed controllers that keep the accumulation bounded everywhere in the environment for single robots and multiple robots .",
    "for single robots , we also formulated a different lp to give the optimal controller  the one that keeps the accumulation function as low as possible everywhere .",
    "we see this as a solution to one kind of persistent task for robots , but many open problems remain .",
    "we are interested in the general problem of solving persistent tasks , which we broadly define as tasks that require perpetual attention by a robotic agent .",
    "the main objective of a persistent task is to maintain the accumulation of some undesirable quantity at as low a value as possible over an environment using one or multiple robotic agents .",
    "the difficulty of this problem depends on what is known by the robots , and precisely what the robots capabilities are .",
    "let us enumerate several possible dimensions for extension on this problem .",
    "* * trajectory vs. path vs. speed * one might consider controlling only the speed over a prescribed path , as we have done in this paper , only the path with a prescribed speed , or complete trajectory planning . *",
    "* single vs. multiple robots * there may be only one robot , or there may be a team of robots , potentially with heterogeneous capabilities and constraints .",
    "* * known vs. unknown production rate * the robot may know ( or be able to sense ) the production rate , or it may have to learn it over time from measurements . * * constant vs. time - varying production rate * the production rate may be constant in time , or it may change indicating a change in the environment s dynamics . * * finite vs. continuum points of interest * the points of interest in the environment may be viewed as a finite set of discrete points over which to control the accumulation , or as an infinite continuum in which we would like to control the accumulation at every point .      one interesting direction in which to expand this work is to consider planning full trajectories for robots to carry out persistent tasks .",
    "the high dimensionality of the space of possible trajectories makes this a difficult problem .",
    "however , if the robot s path is limited by some inherent constraints , then this problem may admit solutions with guarantees .",
    "for example , underwater gliders are commonly constrained to take piecewise linear paths , which can be parametrized with a low number of parameters .",
    "another direction of extension is to have a robot solve the lp for its controller on - line",
    ". this would be useful if , for example the production rate is not known before hand , but can be sensed over the sensor footprint of the robot .",
    "likewise if the production rate changes in time , it would be useful for a robot to be able to adjust its controller on - line to accommodate these changes .",
    "a promising approach for this is to repeatedly solve for the lp in a receding horizon fashion , using newly acquired information to update the model of the field evolution .",
    "we continue to study problems of persistent tasks for robots in these and other directions .",
    "consider a general speed controller @xmath421 where @xmath422 is the set of initial conditions .",
    "since @xmath423 for all @xmath4 $ ] , the value of @xmath5 strictly monotonically increases from @xmath58 to @xmath297 for every valid controller ( once it reaches @xmath297 it then wraps around to @xmath58 ) .",
    "in addition , the evolution of @xmath18 is deterministic and is uniquely determined by the initial conditions and the speed controller , as given in  . because of this , every controller of the form @xmath35 can be written as an infinite sequence of controllers @xmath424 , where controller @xmath425 is the controller used during the @xmath240th period ( or cycle ) .      to begin , consider a feasible persistent monitoring task and a field stabilizing controller of the form @xmath35 , where @xmath422 .",
    "without loss of generality , we can assume that @xmath426 .",
    "from the discussion above , we can write the general controller as a sequence of controllers @xmath424 , where controller @xmath425 , @xmath427 is used on the @xmath240th period ( or cycle ) .    since the controller is stable",
    ", there exists a @xmath64 such that for every set of initial conditions @xmath428 , we have @xmath429 .",
    "let us fix @xmath430 and fix the initial conditions to a set of values @xmath431 such that @xmath432 for all @xmath17 .",
    "now , we will prove the result by constructing a periodic position - feedback controller .",
    "let @xmath433 and define @xmath434 for each integer @xmath435 .",
    "thus , controller @xmath436 is used during the time interval @xmath437 $ ] . following the same argument as in the proof of lemma  [ lem : stab_cond ]",
    ", we have that for each @xmath17 , @xmath438    now , @xmath439 is the initial condition , and @xmath429 .",
    "thus , for every fixed @xmath440 , there exists a finite @xmath240 such that @xmath441 .",
    "since this must hold for every @xmath17 , we see that there exists an integer @xmath240 such that @xmath442 for every @xmath17 . rearranging the previous equation",
    "we obtain @xmath443    therefore , let us define the periodic controller @xmath444 for each @xmath4 $ ] . note that if @xmath445 for all @xmath4 $ ] and all @xmath446 , then @xmath447 but , combining the definition of @xmath40 with  , we immediately see that @xmath40 satisfies the stability condition in lemma  [ lem : stab_cond ] , and thus @xmath40 is a field stabilizing position - feedback controller .",
    "n.  correll , n.  arechiga , a.  bolger , m.  bollini , b.  charrow , a.  clayton , f.  dominguez , k.  donahue , s.  dyar , l.  johnson , h.  liu , a.  patrikalakis , t.  robertson , j.  smith , d.  soltero , m.  tanner , l.  white , and d.  rus , `` building a distributed robot garden , '' in _ ieee / rsj int .",
    "conf . on intelligent robots & systems _ , st .",
    "louis , mo , 2009 , pp .",
    "15091516 .",
    "r.  n. smith , m.  schwager , s.  l. smith , b.  h. jones , d.  rus , and g.  s. sukhatme , `` persistent ocean monitoring with underwater gliders : adapting spatiotemporal sampling resolution , '' _ journal of field robotics _ , 2010 , submitted .",
    "m.  dunbabin , j.  roberts , k.  usher , and p.  corke , `` a new robot for environmental monitoring on the great barrier reef , '' in _",
    "australasian conference on robotics and automation _",
    ", australian national university , canberra , december 2004 .",
    "s.  srinivasan , h.  latchman , j.  shea , t.  wong , and j.  mcnair , `` airborne traffic surveillance systems : video surveillance of highway traffic , '' in _ international workshop on video surveillance & sensor networks _",
    ", new york , ny , usa , october 2004 , pp .",
    "131135 .",
    "l.  s. gandin , _ objective analysis of meteorological fields_.1em plus 0.5em minus 0.4emjerusalem : israeli program for scientific translations , 1966 , ( originally published in russian in 1963 , gidrometeor , leningrad ) .",
    "j.  l. ny and g.  j. pappas , `` on trajectory optimization for active sensing in gaussian process models , '' in _ ieee conf . on decision and control and chinese control conference _ ,",
    "shanghai , china , december 2009 , pp .",
    "62826292 .",
    "f.  bourgault , a.  a. makarenko , s.  b. williams , b.  grocholsky , and h.  f. durrant - whyte , `` information based adaptive robotic exploration , '' in _",
    "ieee / rsj int . conf . on intelligent robots & systems _ , 2002 , pp .",
    "540545 .",
    "i.  rekleitis , v.  lee - shue , a.  p. new , and h.  choset , `` limited communication multi - robot team based coverage , '' in _ ieee int .",
    "conf . on robotics and automation _ ,",
    "new orleans , la , apr .",
    ". 34623468 .",
    "b.  bethke , j.  redding , j.  p. how , m.  a. vavrina , and j.  vian , `` agent capability in persistent mission planning using approximate dynamic programming , '' in _ american control conference _ , baltimore , md , jun .",
    "2010 , pp . 16231628 .",
    "s.  l. smith , m.  pavone , f.  bullo , and e.  frazzoli , `` dynamic vehicle routing with priority classes of stochastic demands , '' _ siam journal on control and optimization _ ,",
    "48 , no .  5 , pp . 32243245 , 2010 .",
    "g.  oriolo , a.  d. luca , and m.  vendittelli , `` wmr control via dynamic feedback linearization : design , implementation , and experimental validation , '' _ ieee transactions on control systems technology _ , vol .",
    "10 , no .  6 , pp .",
    "835852 , 2002 ."
  ],
  "abstract_text": [
    "<S> we present controllers that enable mobile robots to persistently monitor or sweep a changing environment . </S>",
    "<S> the changing environment is modeled as a field which grows in locations that are not within range of a robot , and decreases in locations that are within range of a robot . </S>",
    "<S> we assume that the robots travel on given closed paths . </S>",
    "<S> the speed of each robot along its path is controlled to prevent the field from growing unbounded at any location . </S>",
    "<S> we consider the space of speed controllers that can be parametrized by a finite set of basis functions . for a single robot , </S>",
    "<S> we develop a linear program that is guaranteed to compute a speed controller in this space to keep the field bounded , if such a controller exists . </S>",
    "<S> another linear program is then derived whose solution is the speed controller that minimizes the maximum field value over the environment . </S>",
    "<S> we extend our linear program formulation to develop a multi - robot controller that keeps the field bounded . </S>",
    "<S> the multi - robot controller has the unique feature that it does not require communication among the robots . </S>",
    "<S> simulation studies demonstrate the robustness of the controllers to modeling errors , and to stochasticity in the environment . </S>"
  ]
}