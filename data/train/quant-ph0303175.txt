{
  "article_text": [
    "in the last 30 years , the number of transistors per chip roughly doubled every 18 months , amounting to an exponentially growing power of classical computers .",
    "eventually this statement ( moore s law ) will be violated , since the transistor size will reach the limiting size of one atom in about 15 years .",
    "even before that , disturbing quantum effects will appear .",
    "ordinarily one states that if an algorithm is inefficient , one simply waits for hardware efficient enough to run it .",
    "if the exponential increase in the power of classical computers becomes saturated , the class of inefficient algorithms will remain useless . from this pessimistic point of view",
    ", computer science seems to face very narrow limitations in the near future , coming from the physics underneath computer architecture .",
    "it is important to keep in mind that a computer is a device governed by the laws of physics . for decades",
    ", this fact was irrelevant .",
    "computer science emerged in a mathematical context and the specifics imposed by physics were so few that most computer scientists paid no attention to them .",
    "one possible explanation for this state of matters is that computers work under the laws of classical physics , which are common sense .    in a seminal paper ,",
    "feynman @xcite argued that the way classical computers work is a special case of some more general form allowed by the laws of quantum mechanics .",
    "he gave general arguments supporting the idea that a manifestly quantum device would be exponentially faster than a classical one .",
    "subsequently , deutsch @xcite generalized the classical circuit model to its quantum counterpart and gave the first example of a quantum algorithm faster than its classical counterpart . based on deutsch s work ,",
    "simon @xcite developed a quantum algorithm exponentially faster than its classical counterpart , taking advantage of entanglement , corroborating with feynman s arguments .",
    "the greatest success came with shor s work @xcite .",
    "he developed exponentially faster quantum algorithms for factoring integers and for finding discrete logarithms when compared to the known classical algorithms .",
    "shor s algorithms allow one to render most current cryptographic methods useless , when a quantum computer of reasonable size is available .",
    "this work is an introductory review of shor s factoring algorithm .",
    "we have put all our efforts to write as clear as possible for non - specialists .",
    "we assume familiarity with undergraduate linear algebra , which is the main mathematical basis of quantum mechanics . some previous knowledge of quantum mechanics is welcome , but not necessary for a persistent reader .",
    "the reader can find further material in @xcite .",
    "section 2 reviews basic notions of quantum mechanics necessary for quantum computation .",
    "section 3 introduces the notion of quantum circuits and presents some basic examples .",
    "section 4 describes how factorization can be reduced to order calculation and section 5 gives a quantum algorithm for it .",
    "section 6 shows the quantum fourier transform .",
    "section 7 gives an example and finally section 8 shows the decomposition of the fourier transform circuit in terms of the universal gates .",
    "in classical computers , a bit can assume only values 0 or 1 .",
    "in quantum computers , the values 0 and 1 are replaced by the vectors @xmath0 and @xmath1 .",
    "this notation for vectors is called the dirac notation and is standard in quantum mechanics .",
    "the name bit is replaced by _ qubit _ , short of _ quantum bit_. the difference between bits and qubits is that a qubit @xmath2 can also be in a linear combination of the vectors @xmath3 and @xmath4 , @xmath5 where @xmath6 and @xmath7 are complex numbers .",
    "@xmath8 is said to be a _ superposition _ of the vectors @xmath3 and @xmath4 with _ amplitudes _ @xmath6 and @xmath9 .",
    "thus , @xmath10 is a vector in a two - dimensional complex vector space , where \\{@xmath3 , @xmath11 forms an orthonormal basis , called the _ computational basis _ ( see fig .",
    "[ fig05 ] in the real case ) .",
    "the state @xmath3 is not the zero vector , but simply the first vector of the basis .",
    "the matrix representations of the vectors @xmath3 and @xmath4 are given by @xmath12 \\;\\;\\;\\mbox { and } \\;\\;\\ ; |1\\rangle = \\left [ \\begin{array}{c } 0 \\\\ 1 \\end{array } \\right ] .\\ ] ] in quantum mechanics , vectors are systematically called _",
    "states_. we use this term from now on .    ,",
    "@xmath13 real . in the general case",
    "( @xmath14 , @xmath13 complex ) there is still a geometrical representation called the bloch sphere ( see @xcite page 15).,height=170 ]    the physical interpretation of @xmath10 is that it coexists in two states : @xmath3 and @xmath4 .",
    "it is similar to a coin that is partially heads up and partially tails up simultaneously .",
    "we can not push further the analogy simply because quantum phenomena do not have a classical analogue in general .",
    "the state @xmath10 can store a huge quantity of information in its coefficients @xmath15 and @xmath16 , but this information lives in the quantum level , which is microscopic ( usually quantum effects appear in atomic dimensions ) . to bring quantum information to the classical level",
    ", one must measure the qubit .",
    "quantum mechanics tells us that the measurement process inevitably disturbs a qubit state , producing a non - deterministic collapse of @xmath10 to either @xmath3 or @xmath17 .",
    "one gets @xmath3 with probability @xmath18 or @xmath1 with probability @xmath19 .",
    "the non - deterministic collapse does not allow one to determine the values of @xmath15 and @xmath16 before the measurement .",
    "they are inaccessible via measurements unless one has many copies of the same state .",
    "two successive measurements of the same qubit give the same output . if @xmath18 and @xmath19 are probabilities and there are only two possible outputs , then @xmath20 calculating the norm of @xmath10 , eq .",
    "( [ b ] ) gives @xmath21 a measurement is not the only way that one can interact with a qubit .",
    "if one does not obtain any information about the state of the qubit , the interaction changes the values of @xmath6 and @xmath9 keeping the constraint ( [ b ] ) .",
    "the most general transformation of this kind is a linear transformation @xmath22 that takes unit vectors into unit vectors .",
    "such a transformation is called _ unitary _ and can be defined by @xmath23 where @xmath24 @xmath25",
    "( @xmath26 indicates complex conjugation and @xmath27 indicates the transpose operation ) and @xmath28 is the @xmath29 identity matrix .",
    "so far we are dealing with one - qubit quantum computers . to consider the multiple qubit case , it is necessary to introduce the concept of _ tensor product_. suppose @xmath30 and @xmath31 are complex vector spaces of dimensions @xmath32 and @xmath33 , respectively .",
    "the tensor product @xmath34 is an @xmath35-dimensional vector space .",
    "the elements of @xmath34 are linear combinations of tensor products @xmath36 , @xmath37 , and @xmath38 ) :    1 .",
    "@xmath39 2 .",
    "@xmath40 3 .",
    "@xmath41 @xmath42 or @xmath43 for the tensor product @xmath44 .",
    "note that the tensor product is non - commutative , so the notation must preserve the ordering",
    ".    given two linear operators @xmath45  and @xmath46  defined on the vector spaces @xmath30and @xmath31 , respectively , we can define the linear operator @xmath47  on @xmath34  as @xmath48 where @xmath49 and @xmath50 .",
    "the matrix representation of @xmath47 is given by @xmath51 ,   \\label{c1}\\ ] ] where @xmath45 is an @xmath52 matrix and @xmath46 is a @xmath53 matrix ( we are using the same notation for the operator and its matrix representation ) .",
    "so , the matrix @xmath47 has dimension @xmath54 .",
    "for example , given @xmath55 \\;\\;\\;\\text {   and   } \\;\\;\\;b=\\left [ \\begin{array}{rrr } 1 & 0 & 0 \\\\ 0 & 1 & 0 \\\\ 0 & 0 & 1 \\end{array } \\right ] , \\ ] ] the tensor product @xmath47 is @xmath56 \\otimes \\left [ \\begin{array}{rrr } 1 & 0 & 0 \\\\ 0 & 1 & 0 \\\\ 0 & 0 & 1 \\end{array } \\right ] = \\left [ \\begin{array}{rrrrrr } 0 & 0 & 0 & 1 & 0 & 0 \\\\ 0 & 0 & 0 & 0 & 1 & 0 \\\\ 0 & 0 & 0 & 0 & 0 & 1 \\\\ 1 & 0 & 0 & 0 & 0 & 0 \\\\ 0 & 1 & 0 & 0 & 0 & 0 \\\\ 0 & 0 & 1 & 0 & 0 & 0 \\end{array } \\right ] .\\ ] ] the formula ( [ c1 ] ) can also be used for non - square matrices , such as the tensor product of two vectors . for example , if we have a 2-qubit quantum computer and the first qubit is in the state @xmath0 and the second is in the state @xmath1 , then the quantum computer is in the state @xmath57 , given by @xmath58 \\otimes \\left [ \\begin{array}{r } 0 \\\\ 1 \\end{array } \\right ] = \\left [ \\begin{array}{r } 0 \\\\ 1 \\\\ 0 \\\\ 0 \\end{array } \\right ] .",
    "\\label{ket01}\\ ] ] the resulting vector is in a 4-dimensional vector space .",
    "the general state @xmath10 of a 2-qubit quantum computer is a superposition of the states @xmath59 @xmath60 , @xmath61 , and @xmath62 , @xmath63 regarding the zeroes and ones as constituting the binary expansion of an integer , we can replace the representations of states @xmath64 by the shorter forms @xmath65 in decimal notation , which is handy in some formulas .    in general ,",
    "the state @xmath10 of an @xmath33-qubit quantum computer is a superposition of the @xmath66 states @xmath67 @xmath68 @xmath69 @xmath70 , @xmath71 with amplitudes @xmath72 constrained to @xmath73 recall that the orthonormal basis @xmath74 is the computational basis in decimal notation .",
    "the state of an @xmath33-qubit quantum computer is a vector in a @xmath75-dimensional complex vector space . when the number of qubits increases linearly , the dimension of the associated vector space increases exponentially .",
    "as before , a measurement of a generic state @xmath76 yields the result @xmath77 with probability @xmath78 , where @xmath79 .",
    "usually , the measurement is performed qubit by qubit yielding zeroes or ones that are read together to form @xmath80 .",
    "we stress again a very important feature of the measurement process .",
    "the state @xmath81 as it is before measurement is inaccessible unless it is in the computational basis .",
    "the measurement process inevitably disturbs @xmath76 forcing it to collapse to one vector of the computational basis .",
    "this collapse is non - deterministic , with the probabilities given by the squared norms of the corresponding amplitudes in @xmath76 .",
    "if we have a 2-qubit quantum computer , the first qubit in the state @xmath82 and the second in the state @xmath83 then the state of the quantum computer is the tensor product @xmath84 note that a general @xmath85-qubit state ( [ d ] ) is of the form ( [ e ] ) if and only if @xmath86 from these equalities we have that a general @xmath85-qubit state ( [ d ] ) is of the form ( [ e ] ) if and only if @xmath87 thus , the general @xmath85-qubit state is not necessarily a product of two one - qubit states .",
    "such non - product states of two or more qubits are called _ entangled _ states , for example , @xmath88 .",
    "the entangled states play an essential role in quantum computation .",
    "quantum computers that do not use entanglement can not be exponentially faster than classical computers .",
    "on the other hand , a naive use of entanglement does not guarantee any improvements .",
    "a complex vector space @xmath30 is a hilbert space if there is an _ inner product _",
    ", written in the form @xmath89 , defined by the following rules ( @xmath90 and @xmath91 ) :    1 .",
    "@xmath92 2 .",
    "@xmath93 if @xmath94    the _ norm _ of a vector @xmath95 is given by @xmath96    the notation @xmath97 is used for the _ dual vector _ to the vector @xmath95 .",
    "the dual is a linear operator from the vector space @xmath30 to the complex numbers , defined by @xmath98 given two vectors @xmath95 and @xmath10 in a vector space @xmath30 , there is also an _ outer product _",
    "@xmath99 , defined as a linear operator on @xmath30 satisfying @xmath100 if @xmath101 and @xmath102 , then the matrix representations for inner and outer products are : @xmath103 \\left [ \\begin{array}{r } c \\\\ d \\end{array } \\right ] = a ^{\\ast } c + b ^{\\ast } d , \\\\ |\\varphi \\rangle \\langle \\psi | & = & \\left [ \\begin{array}{r } a \\\\",
    "b \\end{array } \\right ] \\left [ \\begin{array}{rr } c ^{\\ast } & d ^{\\ast } \\end{array } \\right ] = \\left [ \\begin{array}{rr } ac ^{\\ast } & ad ^{\\ast } \\\\",
    "bc ^{\\ast } & bd ^{\\ast } \\end{array } \\right ] .\\end{aligned}\\ ] ] the matrix of the outer product is obtained by usual matrix multiplication of a column matrix by a row matrix .",
    "but in this case , we can replace the matrix multiplication by the tensor product , i.e. , @xmath104 ( notice the complex conjugation in the process of taking the dual ) .",
    "[ ] @xmath105 , not shown here , returns zeroes and ones.,title=\"fig : \" ]    after the above review , we are ready to outline the quantum computer . in fig .",
    "[ fig06 ] , we are taking a nonentangled input , what is quite reasonable .",
    "in fact , @xmath106 is either @xmath107 or @xmath108 generally .",
    "@xmath76 , on the right hand side of fig .",
    "[ fig06 ] , is the result of the application of a unitary operator @xmath22 on the input .",
    "the last step is the measurement of the states of each qubit , which returns zeroes and ones that form the final result of the quantum calculation .",
    "note that there is , in principle , an infinite number of possible operators @xmath22 , which are unitary @xmath109 matrices .",
    "let us start with one - qubit gates . in the classical case",
    "there is only one possibility , which is the not gate .",
    "the not gate inverts the bit value : 0 goes to 1 and vice - versa .",
    "the straightforward generalization to the quantum case is given in fig . [ fig07 ] , where @xmath110 is the unitary operator @xmath111 .\\ ] ] so , if the input @xmath10 is @xmath0 , the output is @xmath4 and vice - versa .",
    "but now we can have a situation with no classical counterpart .",
    "the state @xmath10 can be a superposition of states @xmath3 and @xmath4 . the general case is @xmath112 and the corresponding output is latexmath:[$\\alpha    one - qubit gate .",
    "there are infinitely many , since there are an infinite number of @xmath29 unitary matrices . in principle",
    ", any unitary operation can be implemented in practice .",
    "the _ hadamard _ gate is another important one - qubit gate , given by @xmath114 .\\ ] ] it is easy to see that @xmath115 if the input is @xmath3 , the hadamard gate creates a superposition of states with equal weights .",
    "this is a general feature , valid for two or more qubits .",
    "let us analyze the @xmath85-qubit case .",
    "the first example of a @xmath85-qubit gate is @xmath116 : @xmath117 the result is a superposition of all basis states with equal weights .",
    "more generally , the hadamard operator applied to the @xmath33-qubit state @xmath0 is h^n|0 & = & h^n = ( h ) ^n + & = & ( ) ^n + & = & _ i=0 ^ 2^n-1 .[psi00 ] thus , the tensor product of @xmath33 hadamard operators produces an equally weighted  superposition of all computational basis states , when the input is the state @xmath118 this state is useful for applying quantum parallelism , as we will see ahead .",
    "another important @xmath85-qubit quantum gate is the cnot gate .",
    "it has two input qubits , the control and the target qubit , respectively .",
    "the target qubit is flipped only if the control qubit is set to 1 , that is , |00 & & |00 , +        @xmath119     can be either @xmath0 or @xmath1 .",
    "the general case is obtained by linearity . ]    where @xmath120 is addition modulo 2 .",
    "now , let us obtain its matrix representation . performing the same calculations that yield eq .",
    "( [ ket01 ] ) , we have @xmath121,\\,\\,\\ \\   |01\\rangle   = \\left [ \\begin{array}{r } 0 \\\\ 1 \\\\ 0 \\\\ 0 \\end{array } \\right],\\,\\,\\ \\   |10\\rangle    = \\left [ \\begin{array}{r } 0 \\\\ 0 \\\\ 1 \\\\ 0 \\end{array } \\right],\\,\\,\\ \\   |11\\rangle   = \\left [ \\begin{array}{r } 0 \\\\ 0 \\\\ 0 \\\\ 1 \\end{array } \\right ] .",
    "\\label{vectors}\\ ] ] thus , from ( [ cnot ] ) and ( [ vectors ] ) , the matrix representation @xmath122 of the cnot gate is @xmath123 .",
    "\\label{ucnot}\\ ] ]    fig .",
    "[ fig016 ] describes the cnot gate , where @xmath124 is either @xmath107 or @xmath108 .",
    "the figure could lead one to think that the output is always nonentangled , but that is not true , since if the first qubit is in a more general state given by @xmath125 , then the output will be @xmath126 , which is entangled in general .",
    "the input can be entangled as well .",
    "we have seen two examples of @xmath85-qubit gates .",
    "the general case is a @xmath127 unitary matrix",
    ". gates that are the direct product of other gates , such as @xmath116 , do not produce entanglement . if the input is nonentangled , the output is not too .",
    "on the other hand , the output of the cnot gate can be entangled while the input is nonentangled .",
    "cnot and one - qubit gates form a universal set of gates .",
    "this means that any other gate , operating on @xmath85 or more qubits , can be written as compositions and direct products of cnot and one - qubit gates @xcite .    at the end of section 2",
    ", we gave a general outline of the quantum computer ( fig .",
    "2 ) based on the action of a unitary operator @xmath22 . in the present section , we have seen that in general @xmath22 can be broken up in terms of smaller gates .",
    "this decomposition is useful because it corresponds to the natural steps that describe an algorithm .",
    "so , a quantum algorithm consists of a sequence of unitary operators acting on sets of qubits .",
    "these unitary operators multiplied together form the operator @xmath22 of fig .",
    "more details on quantum circuits can be found in @xcite .",
    "let us describe shor s algorithm for finding the prime factors of a composite number @xmath128 .",
    "think of a large number such as one with 300 digits in decimal notation , since such numbers are used in cryptography . though @xmath128 is large , the number of qubits necessary to store it is small .",
    "in general @xmath129 is not an integer , so let us define n=_2 n .",
    "a quantum computer with @xmath33 qubits can store @xmath128 or any other positive integer less than @xmath128 . with a little thought ,",
    "we see that the number of prime factors of @xmath128 is at most @xmath33 .",
    "if both the number of qubits and the number of factors are less than or equal to @xmath33 , then it is natural to ask if there is an algorithm that factors @xmath128 in a number of steps which is polynomial in @xmath33 .",
    "more technically , the question is : is there a factorization algorithm in the complexity class @xmath130 @xcite ?",
    "reduction of factorization of @xmath128 to the problem of finding the _ order _ of an integer @xmath131 less than @xmath128 is as follows .",
    "if @xmath131 and @xmath128 have common factors , then gcd@xmath132 gives a factor of @xmath128 , therefore it suffices to investigate the case when @xmath131 is coprime to @xmath128 .",
    "the order of @xmath131 modulo @xmath128 is defined as the least positive integer @xmath133 such that @xmath134 if @xmath133 is even , we can define @xmath135 by @xmath136 the above notation means that @xmath135 is the remainder of @xmath137 divided by @xmath128 and , by definition , @xmath138 . note that @xmath135 satisfies @xmath139 , or equivalently @xmath140 , which means that @xmath128 divides @xmath141 . if @xmath142 , the factors @xmath143 and @xmath144 satisfy @xmath145 , therefore @xmath128 can not divide @xmath143 nor @xmath144 separately .",
    "the only alternative is that both @xmath143 and @xmath144 have factors of @xmath128 ( that yield @xmath128 by multiplication ) .",
    "so , gcd(@xmath146 ) and gcd(@xmath147 ) yield non trivial factors of @xmath128 ( gcd stands for the greatest common divisor ) .",
    "if @xmath128 has remaining factors , they can be calculated applying the algorithm recursively .",
    "consider @xmath148 as an example .",
    "the sequence of equivalences 2 ^ 4 & & 16 21 + 2 ^ 5 & & 11 21 + 2 ^ 6 & & 11 2 1 21 show that the order of 2 modulo 21 is @xmath149",
    ". therefore , @xmath150 . @xmath143 yields the factor 7 and @xmath144 yields the factor 3 of 21 .    in summary , if we pick up at random a positive integer @xmath131 less than @xmath128 and calculate gcd@xmath132 , either we have a factor of @xmath128 or we learn that @xmath131 is coprime to @xmath128 . in the latter case , if @xmath131 satisfies the conditions ( 1 ) its order @xmath133 is even , and ( 2 ) @xmath151 , then gcd(@xmath146 ) and gcd(@xmath147 ) yield factors of @xmath128 .",
    "if one of the conditions is not true , we start over until finding a proper candidate @xmath131",
    ". the method would not be useful if these assumptions were too restrictive , but fortunately that is not the case .",
    "the method sistematically fails if @xmath128 is a power of some odd prime , but an alternative efficient classical algorithm for this case is known .",
    "if @xmath128 is even , we can keep dividing by 2 until the result turns out to be odd .",
    "it remains to apply the method for odd composite integers that are not a power of some prime number .",
    "it is cumbersome to prove that the probability of finding @xmath131 coprime to @xmath128 satisfying the conditions ( 1 ) and ( 2 ) is high ; in fact this probability is @xmath152 , where @xmath153 is the number of prime factors of @xmath128 . in the worst case ( @xmath128 has 2 factors ) , the probability is greater than or equal to @xmath154 ( see the proof in appendix b of @xcite ) .    at first sight",
    ", it seems that we have just described an efficient algorithm to find a factor of @xmath128 .",
    "that is not true , since it is not known an efficient classical algorithm to calculate the order of an integer @xmath131 modulo @xmath128 . on the other hand ,",
    "there is ( after shor s work ) an efficient quantum algorithm .",
    "let us describe it .",
    "consider the circuit of fig . [ order ] .",
    "it calculates the order @xmath133 of the positive integer @xmath131 less than @xmath128 , coprime to @xmath128 .    [ ] [ ] @xmath155 [ ] [ ] @xmath107 [ ] [ ] @xmath156 [ ] [ ] @xmath157 [ ] [ ] @xmath158 [ ] [ ] @xmath159 [ ] [ ] @xmath160 [ ] [ ] @xmath161   modulo @xmath128.,title=\"fig : \" ]    @xmath162 is the unitary linear operator [ vx ] v_x ( j k ) = j , where @xmath163 and @xmath164 are the states of the first and second registers , respectively .",
    "the arithmetical operations are performed modulo @xmath128 , so @xmath165 .",
    "dft is the discrete fourier transform operator which will be described ahead .",
    "the first register has @xmath166 qubits , where @xmath166 is generally chosen such that @xmath167 , for reasons that will become clear later on @xcite . as an exception ,",
    "if the order @xmath133 is a power of 2 , then it is enough to take @xmath168 . in this section",
    "we consider this very special case and leave the general case for section [ generalization ] .",
    "we will keep the variable @xmath166 in order to generalize the discussion later on .",
    "the states of the quantum computer are indicated by @xmath169 to @xmath170 in fig .",
    "[ order ] .",
    "the initial state is = _ t _ n. the application of the hadamard operator h= on each qubit of the first register yields ( see eq .",
    "( [ psi00 ] ) ) = _ j=0 ^ 2^t-1 j 0 .",
    "[ psi1 ] the first register is then in a superposition of all states of the computational basis with equal amplitudes given by @xmath171 .",
    "now we call the reader s attention to what happens when we apply @xmath162 to @xmath172 : & = & v_x + & = & _ j=0 ^ 2^t-1 v_x ( j 0 ) + & = & _ j=0 ^ 2^t-1 j .",
    "[ psi2 ] the state @xmath173 is a remarkable one .",
    "because @xmath162 is linear , it acts on all @xmath174 for @xmath175 values of @xmath176 , so this generates all powers of @xmath131 simultaneously .",
    "this feature is called _",
    "quantum parallelism_. some of these powers are 1 , which correspond to the states @xmath177 , @xmath178 , @xmath179 , ... , @xmath180 .",
    "this explains the choice ( [ vx ] ) for @xmath162 .",
    "classically , one would calculate successively @xmath181 , for @xmath176 starting from 2 until reaching @xmath182 .",
    "_ quantumly _ , one can calculate all powers of @xmath131 with just one application of @xmath162 . at the quantum level ,",
    "the values of @xmath176 that yield @xmath183 are `` known '' .",
    "but this quantum information is not fully available at the classical level .",
    "a classical information of a quantum state is obtained by practical measurements and , at this point , it does not help if we measure the first register , since all states in the superposition ( [ psi2 ] ) have equal amplitudes .",
    "the first part of the strategy to find @xmath133 is to observe that the first register of the states @xmath177 , @xmath184 , @xmath179 , ...",
    ", @xmath185 is periodic .",
    "so the information we want is a period . in order to simplify the calculation ,",
    "let us measure the second register . before doing this",
    ", we will rewrite @xmath173 collecting equal terms in the second register . since @xmath181 is a periodic function with period @xmath133 , substitute @xmath186 for @xmath176 in eq .",
    "( [ psi2 ] ) , where @xmath187 and @xmath188 .",
    "recall that we are supposing that @xmath168 and @xmath133 is a power of 2 , therefore @xmath133 divides @xmath175 .",
    "( [ psi2 ] ) is converted to = _",
    "b=0^r-1 ( _ a=0 ^ -1 ) .",
    "[ psi2a ] in the second register , we have substituted @xmath189 for @xmath190 , since @xmath191 modulo @xmath128 . now the second register is measured .",
    "any output @xmath192 , @xmath193 , ...",
    ", @xmath194 can be obtained with equal probability .",
    "suppose that the result is @xmath195 .",
    "the state of the quantum computer is now = ( _ a=0 ^ -1 ) .",
    "[ psi3 ] note that after the measurement , the constant is renormalized to @xmath196 , since there are @xmath197 terms in the sum ( [ psi3 ] ) .",
    "[ graph ] shows the probability of obtaining the states of the computational basis upon measuring the first register .",
    "the probabilities form a periodic function with period @xmath133 .",
    "their values are zero except for the states @xmath198 , @xmath199 , @xmath200 , ... , @xmath201 .",
    "[ ] [ ] @xmath202 [ ] [ ] @xmath203 [ ] [ ] @xmath204 [ ] [ ] @xmath205 [ ] [ ] @xmath206 [ ] [ ] @xmath207 [ ] [ ] @xmath133    measured in the computational basis ( for the case @xmath208 and @xmath209 )",
    ". the horizontal axis has @xmath175 points .",
    "the number of peaks is @xmath197 and the period is @xmath133.,title=\"fig:\",width=432 ]    how can one find out the period of a function efficiently ?",
    "the answer is in the fourier transform .",
    "the fourier transform of a periodic function with period @xmath133 is a new periodic function with period proportional to @xmath210 .",
    "this makes a difference for finding @xmath133 .",
    "the fourier transform is the second and last part of the strategy .",
    "the whole method relies on an efficient quantum algorithm for calculating the fourier transform , which is not available classically . in section [ universal ]",
    ", we show that the fourier transform is calculated efficiently in a quantum computer .",
    "the fourier transform of the function @xmath211 is a new function @xmath212 defined as f ( k ) = _ j=0^n-1 e^2 i j k / n f(j ) [ f ] .",
    "we can apply the fourier transform either on a function or on the states of the computational basis .",
    "the fourier transform applied to the state @xmath164 of the computational basis @xmath213 is ( k ) = = _",
    "j=0^n-1 e^2 i j k / n j , [ psia ] where the set @xmath214 forms a new orthonormal basis",
    ". the fourier transform is a unitary linear operator .",
    "so , if we know how it acts on the states of the computational basis , we also know how it acts on a generic state = _ a=0^n-1 f(a ) a. the fourier transform of @xmath215 can be performed indistinctly using either ( [ f ] ) or ( [ psia ] ) .",
    "we will use the latter .    to prove that @xmath214 is an orthonormal basis ,",
    "i.e. , = _ k^k , we can use the identity _",
    "j=0^n-1 e^2 i j k / n = \\",
    "{    l 1 + 0    .",
    "[ ident ] which is useful in the context of fourier transforms .",
    "it is easy to verify that ( [ ident ] ) is true . if @xmath153 is a multiple of @xmath128 , then @xmath216 and the first case of the identity follows .",
    "if @xmath153 is not a multiple of @xmath128 , ( [ ident ] ) is true even if @xmath128 is not a power of 2 .",
    "[ 2pi7 ] shows each term @xmath217 @xmath218 for the case @xmath219 and @xmath220 , as vectors in the complex plane .",
    "note that the sum of vectors must be zero by a symmetry argument : the distribution of vectors is isotropic .",
    "usually it is said that the interference is destructive in this case .",
    "[ ] [ ] @xmath221 [ ] [ ] @xmath222 [ ] [ ] @xmath223 [ ] [ ] @xmath224 [ ] [ ] @xmath225 [ ] [ ] @xmath226 [ ] [ ] @xmath227 [ ] [ ] @xmath228   @xmath218 in the complex plane .",
    "their sum is zero by symmetry arguments .",
    "this is an example of eq .",
    "( [ ident ] ) for @xmath220 , @xmath219.,title=\"fig:\",height=220 ]    using this identity , we can define the inverse fourier transform , which is similar to ( [ psia ] ) , just with a minus sign on the exponent .",
    "note that @xmath229 , since dft is a unitary operator .",
    "we will present the details of a quantum circuit to perform the fourier transform in section [ universal ] .",
    "now we will continue the calculation process of the circuit of fig .",
    "[ order ] .",
    "we are ready to find out the next state of the quantum computer@xmath230 . applying the inverse fourier",
    "transform on the first register , using eq .",
    "( [ psia ] ) and the linearity of dft@xmath231 , we obtain & = & ^ ( ) + & = & _ a=0 ^ -1 ( _ j=0 ^ 2^t-1 e^-2 i j ( ar+b_0)/2^t j ) . [ psi4 ] inverting the summation order , we have = ( _ j=0 ^ 2^t-1 e^-2 i j b_0/2^t ) .",
    "[ psi4a ] using ( [ ident ] ) , we see that the expression in square brackets is not zero if and only if @xmath232 , with @xmath233 .",
    "when @xmath176 takes such values , the expression in the square brackets is equal to 1 .",
    "so we have = ( _ k=0^r-1 e^-2 i k r b_0 ) . [ psi4b ] in order to find @xmath133 , the expression for @xmath234 has two advantages over the expression for @xmath235 ( eq . ( [ psi3 ] ) ) : @xmath133 is in the denominator of the ket label and the random parameter @xmath236 moved from the ket label to the exponent occupying now a harmless place .    [ ] [ ] @xmath202 [ ] [ ] @xmath237 [ ] [ ] @xmath238 [ ] [ ] @xmath239 [ ] [ ] @xmath240 [ ] [ ] @xmath241 [ ] [ ] @xmath237   measured in the computational basis .",
    "the horizontal axis has @xmath175 points , only the non - null terms are shown .",
    "the number of peaks is @xmath133 and the period is @xmath197.,title=\"fig:\",width=432 ]    fig .",
    "[ graph2 ] shows the probability distribution of @xmath242 measured in the computational basis .",
    "measuring the first register , we get the value @xmath243 , where @xmath244 can be any number between 0 and @xmath245 with equal probability ( the peaks in fig .",
    "[ graph2 ] ) .",
    "if we obtain @xmath246 , we have no clue at all about @xmath133 , and the algorithm must be run again . if @xmath247 , we divide @xmath243 by @xmath175 , obtaining @xmath248 .",
    "neither @xmath244 nor @xmath133 are known .",
    "if @xmath244 is coprime to @xmath133 , we simply select the denominator .",
    "if @xmath244 and @xmath133 have a common factor , the denominator of the reduced fraction @xmath249 is a factor of @xmath133 but not @xmath133 itself .",
    "suppose that the denominator is @xmath250 .",
    "let @xmath251 .",
    "now the goal is to find @xmath252 , which is the order of @xmath253 .",
    "we run again the quantum part of the algorithm to find the order of @xmath253 .",
    "if we find @xmath252 in the first round , the algorithm halts , otherwise we apply it recursively .",
    "the recursive process does not last , because the number of iterations is less than or equal to @xmath254 .",
    "take @xmath255 as an example , which is the least nontrivial composite number .",
    "the set of numbers less than 15 , coprime to 15 is @xmath256 .",
    "the numbers in the set @xmath257 have order 2 and the numbers in the set @xmath258 have order 4 .",
    "therefore , in any case @xmath133 is a power of 2 and the factors of @xmath255 can be found in a 8-bit quantum computer ( @xmath259 ) .",
    "the authors of @xcite used a 7-qubit quantum computer , bypassing part of the algorithm .",
    "in the previous sections , we have considered a special case when the order @xmath133 is a power of 2 and @xmath168 ( @xmath166 is the number of qubits in the first register ",
    "[ order]and @xmath260 ) . in this section ,",
    "we consider the factorization of @xmath148 , that is the next nontrivial composite number .",
    "we must choose @xmath166 such that @xmath175 is between @xmath261 and @xmath262 , which is always possible @xcite .",
    "for @xmath148 , the smallest value of @xmath166 is 9 .",
    "this is the simplest example allowed by the constraints , but enough to display all properties of shor s algorithm .",
    "the first step is to pick up @xmath131 at random such that @xmath263 , and to test whether @xmath131 is coprime to @xmath128 .",
    "if not , we easily find a factor of @xmath128 by calculating gcd@xmath132 . if yes , the quantum part of the algorithm starts .",
    "suppose that @xmath264 has been chosen .",
    "the goal is to find out that the order of @xmath131 is @xmath149 .",
    "the quantum computer is initialized in the state @xmath265 where the first register has @xmath266 qubits and the second has @xmath267 qubits .",
    "next step is the application of @xmath268 on the first register yielding ( see eq .",
    "( [ psi1 ] ) ) @xmath269 the next step is the application of @xmath162 ( defined in ( [ vx ] ) ) , which yields & = & _ j=0 ^ 511 j + & = & ( + + + + + + + & & + + + + + + + & & +  ) .",
    "notice that the above expression has the following pattern : the states of the second register of each `` column '' are the same .",
    "therefore we can rearrange the terms in order to collect the second register : & = & .",
    "this feature was made explicit in eq .",
    "( [ psi2a ] ) .",
    "because the order is not a power of 2 , here there is a small difference : the first two lines of eq .",
    "( [ rearranged ] ) have 86 terms , while the remaining ones have 85 .",
    "now one measures the second register , yielding one of the following numbers equiprobably : @xmath270 .",
    "suppose that the result of the measurement is 2 , then = ( + + + ",
    "[ psi3a ] notice that the state @xmath235 was renormalized in order to have unit norm .",
    "it does not matter what is the result of the measurement ; what matters is the periodic pattern of ( [ psi3a ] ) .",
    "the period of the states of the first register is the solution to the problem and the fourier transform can reveal the value of the period .",
    "so , the next step is the application of the inverse fourier transform on the first register of @xmath235 : & = & ^ ( ) + & = & ^ ( _ a=0 ^ 85 ) 2 + & = & _ j=0 ^ 511 ( e^-2 i j ) , [ psi4 ft ] where we have used eq .",
    "( [ psia ] ) and have rearranged the sums .",
    "the last equation is similar to eq .",
    "( [ psi4a ] ) , but with an important difference . in section [ sectionorder ] , we were assuming that @xmath133 divides @xmath175 .",
    "this is not true in the present example ( 6 does not divide 512 ) , therefore we can not use the identity ( [ ident ] ) to simplify the term in brackets in eq .",
    "( [ psi4 ft ] ) .",
    "this term never vanishes , but its main contribution is still around @xmath271 @xmath272 @xmath273 @xmath274 which are obtained rounding @xmath275 for @xmath244 from 0 to 5compare to the discussion that follows eq .",
    "( [ psi4b ] ) . to see this ,",
    "let us plot the probability of getting the result @xmath176 ( in the interval 0 to 511 ) by measuring the first register of the state @xmath160 . from ( [ psi4 ft ] )",
    ", we have that the probability is [ prob ] ( j ) = | _ a=0 ^ 85 e^-2 i |^2 .",
    "the plot of prob@xmath276 is shown in fig .",
    "[ probgraph ] .",
    "we see the peaks around @xmath271 @xmath272 @xmath273 @xmath274 indicating a high probability of getting one of these values , or some value very close to them . in between",
    ", the probability is almost zero .",
    "the sharpness of the peaks depends on @xmath166 ( number of qubits in the first register ) .",
    "the lower limit @xmath277 ensures a high probability in measuring a value of @xmath176 carrying the desired information . a careful analysis of the expression ( [ prob ] )",
    "is performed in @xcite and a meticulous study of the peak form is performed in @xcite .",
    "let us analyze the possible measurement results .",
    "if we get @xmath221 ( first peak ) , the algorithm has failed in this round .",
    "it must be run again .",
    "we keep @xmath264 and rerun the quantum part of the algorithm .",
    "the probability of getting @xmath221 is low : from eq .",
    "( [ prob ] ) we have that prob@xmath278 . now suppose we get @xmath279 ( or any value in the second peak ) .",
    "we divide by 512 yielding @xmath280 , which is a rational approximation of @xmath281 , for @xmath282 .",
    "how can we obtain @xmath133 from @xmath280 ?",
    "the method of continued fraction approximation allows one to extract the desired information .",
    "a general continued fraction expansion of a rational number @xmath283 has the form @xmath284 usually represented as @xmath285 $ ] , where @xmath286 is a non - negative integer and @xmath287 are positive integers .",
    "the @xmath288-th convergent ( @xmath289 ) is defined as the rational number @xmath290 $ ] .",
    "it is an approximation to @xmath283 and has a denominator smaller than @xmath291 .",
    "this method is easily applied by inversion of the fraction followed by integer division with rational remainder .",
    "inverting @xmath280 yields @xmath292 , which is equal to @xmath293 .",
    "we repeat the process with @xmath294 until we get numerator 1 .",
    "the result is = .",
    "so , the convergents of @xmath280 are @xmath295 , @xmath296 , and @xmath280 .",
    "we must select the convergents that have a denominator smaller than @xmath148 ( since @xmath297 ) follows from the euler s theorem : @xmath298 , where @xmath131 is a positive integer coprime to @xmath128 and @xmath299 is the euler s totient function ( @xmath300 gives the number of positive integers less than @xmath128 , coprime to @xmath128 ) .",
    "the inequality @xmath301 follows from the definition of @xmath299 .",
    "( see @xcite page 492 ) ] .",
    "this method yields @xmath295 , and then @xmath149 . we check that @xmath302 modulo 21 , and the quantum part of the algorithm ends with the correct answer .",
    "the order @xmath149 is an even number , therefore gcd@xmath303 gives two non trivial factors of @xmath304 .",
    "a straightforward calculation shows that any measured result in the second peak ( say @xmath305 ) yields the convergent 1/6 .",
    "consider now the third peak , which corresponds to @xmath281 , @xmath306 .",
    "we apply again the method of continued fraction approximation , which yields @xmath307 , for any @xmath176 in the third peak ( say @xmath308 ) . in this case",
    ", we have obtained a factor of @xmath133 @xmath309 , since @xmath310 modulo 21 .",
    "we run the quantum part of the algorithm again to find the order of 8 .",
    "we eventually obtain @xmath311 , which yields @xmath312 .    the fourth and fifth peaks yield also factors of @xmath133 .",
    "the last peak is similar to the second , yielding @xmath133 directly .",
    "the general account of the succeeding probability is as follows .",
    "the area under all peaks is approximately the same : @xmath313 .",
    "the first and fourth peaks have a nature different from the others  they are not spread . to calculate their contribution to the total probability , we take the basis equal to 1 .",
    "the area under the second , third , fifth , and last peaks are calculated by adding up prob@xmath276 , for @xmath176 running around the center of each peak .",
    "so , in approximately 17% cases , the algorithm fails ( 1st peak ) . in approximately 33% cases ,",
    "the algorithm returns @xmath133 in the first round ( 2nd and 6th peaks ) . in approximately 50% cases ,",
    "the algorithm returns @xmath133 in the second round or more ( 3rd , 4th , and 5th peaks ) .",
    "now we calculate the probability of finding @xmath133 in the second round . for the 3rd and 5th peaks ,",
    "the remaining factor is @xmath311 . the graph equivalent to fig .",
    "[ probgraph ] in this case has 2 peaks , then the algorithm returns @xmath252 in 50% cases . for the 4th peak ,",
    "the remaining factor is @xmath314 and the algorithm returns @xmath252 in 66.6% cases .",
    "this amounts to @xmath315 of 50% , which is equal to around 22% . in summary ,",
    "the success probability for @xmath264 is around 55% .",
    "in the previous section , we have shown that shor s algorithm is an efficient probabilistic algorithm , assuming that the fourier transform could be implemented efficiently . in this section ,",
    "we decompose the fourier transform in terms of the universal gates : cnot and 1-qubit gates .",
    "this decomposition allows one to measure the efficiency of the quantum discrete fourier transform and shows how to implement it in an actual quantum computer .",
    "the fourier transform of the states of the computational basis is ( j ) = _",
    "k=0^n-1 e^2 i j k / n k .",
    "[ ft]noting that the right hand side of eq .",
    "( [ ft ] ) has @xmath128 terms and the computational basis has @xmath128 states , we derive that the complexity to calculate classically the fourier transform of the computational basis using eq .",
    "( [ ft ] ) is @xmath316 ",
    "double exponential growth .",
    "a very important result in computer science was the development of the classical fast fourier transform ( fft ) , which reduced the complexity to @xmath317 @xcite . in the present context",
    "we show the improvement by recognizing that the rhs of ( [ ft ] ) is a very special kind of expansion , which can be fully factored .",
    "for example , the fourier transform of \\{@xmath318 , @xmath319 , @xmath320 , @xmath321 } can be written as ( 0 ) & = & ( ) ( ) + ( 1 ) & = & ( ) ( ) + ( 2 ) & = & ( ) ( ) [ example ] + ( 3 ) & = & ( ) ( ) .",
    "note that in example ( [ example ] ) , we are using base 2 in order to factor the rhs .",
    "let us now factor the general expression .",
    "the first step is to write ( [ ft ] ) in the form ( j ) = _",
    "k_1=0 ^ 1  _",
    "k_n=0 ^ 1 e^2 i j _ l=1^n  , [ dftj ] where the ket @xmath164 was converted to base 2 and we have used the expansion @xmath322 in the exponent . using that the exponential of a sum is a product of exponentials , ( [ dftj ] ) turns into a ( non - commutative ) product of the following kets : [ ft2 ] ( j ) = _",
    "k_1=0 ^ 1  _",
    "k_n=0 ^ 1 _ l=1^n ( e^2 i j ) .",
    "now we factor ( [ ft2 ] ) by interchanging the sums and the product : [ ft3 ] ( j ) = _ l=1^n _ k_l=0 ^ 1 ( e^2 i j ) .",
    "we easily convince ourselves that the last equation is correct by going backwards : simply expand the product in eq .",
    "( [ ft3 ] ) and then put all sums at the beginning of the resulting expression to obtain ( [ ft2 ] ) . expanding the sum of eq .",
    "( [ ft3 ] ) and then the product , we finally get ( j ) & = & _ l=1^n ( 0 + e^2 i j / 2^l 1 ) + & = & ( ) ( )  ( ) .",
    "[ ftj ] the complexity to calculate eq .",
    "( [ ftj ] ) for one @xmath163 is @xmath323 , since there are @xmath33 terms in the product .",
    "the complexity in the classical calculation of the fast fourier transform of the whole computational basis is still exponential ",
    "@xmath317 , since the calculation is performed on each of the @xmath75 basis elements , one at a time . on the other hand ,",
    "the quantum computer uses quantum parallelism , and the fourier transform of the state @xmath324 that has an exponential number of terms , is calculated with one application of the quantum fourier transform .",
    "the fourier transform of the @xmath75 basis elements is performed simultaneously , so the complexity of the quantum fourier transform is measured by the size of its circuit .",
    "we now show that it requires @xmath325 gates .",
    "[ ] [ ] @xmath326 [ ] [ ] @xmath327 [ ] [ ] @xmath328 [ ] [ ] @xmath329 [ ] [ ] @xmath330 [ ] [ ] @xmath331 [ ] [ ] @xmath332 . the value of all qubits does not change , except @xmath333 that changes to @xmath334,title=\"fig : \" ]    consider the circuit of fig .",
    "[ ft(j ) ] .",
    "it is easy to check that the value of the qubits @xmath335 , @xmath336 , does not change .",
    "let us now check the hard one : @xmath333 .",
    "the unitary matrices @xmath337 are defined as r_k = .",
    "each @xmath337 gate is controlled by the qubit @xmath338 .",
    "so , if @xmath339 , then @xmath337 must be replaced by the identity matrix ( no action ) , and if @xmath340 , then @xmath337 comes in action .",
    "this means that , for calculation purposes , the @xmath337 s controlled by @xmath338 can be replaced by the 1-qubit gates _",
    "[ crk]in order to simplify the calculations , note that h = = _ _ c__r_1 + , [ hj ] where @xmath341 .",
    "so instead of using = _ _ c__r_n+1-l  _ _ c__r_2 h , which can be read directly from fig . [ ft(j ) ] , we will use = _ _ c__r_n+1-l  _ _ c__r_2 _ _ c__r_1 .",
    "we define [ pr ] _ pr__n+1-l = _ k = n+1-l^1 _ _ c__r_k ,    [ ] [ ] _ _ pr__@xmath342 [ ] [ ] _ _ pr__@xmath343 [ ] [ ] _ _ pr__@xmath344 [ ] [ ] _ _ pr__@xmath345 [ ] [ ] @xmath346 [ ] [ ] @xmath346 [ ] [ ] @xmath346 [ ] [ ] @xmath346 [ ] [ ] @xmath346 [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ]   for calculation purposes as explained in eq .",
    "( [ hj ] ) .",
    "the output is in reverse order with respect to eq .",
    "( [ ftj]).,title=\"fig : \" ]    where the product is in the reverse order . using ( [ crk ] ) and ( [ pr ] ) , we get [ prn+1-l ] _ pr__n+1-l & = & + & = & , where we have used that @xmath347 and the fact that the first @xmath348 terms of this expansion do not contribute  they are integer multiples of @xmath349 in ( [ matrix ] ) .",
    "we finally get & = & _ pr__n+1-l + + & = & .",
    "note that @xmath350 can not be implemented directly acting only in the @xmath351-th qubit because it requires the values of @xmath352 to @xmath353 .",
    "[ ] [ ] @xmath354 [ ] [ ] @xmath355 [ ] [ ] @xmath332     the next step is the circuit of fig . [ intermediate ] .",
    "we have merged the @xmath337 gates using eq .",
    "( [ pr ] ) .",
    "the gates _ _ pr__@xmath356 ( @xmath153 from @xmath33 to 1 ) are placed in sequence in fig .",
    "[ intermediate ] , so that the output of the first qubit is the last term of eq .",
    "( [ ftj ] ) , corresponding to the action of _ _",
    "pr__@xmath345 on @xmath172 controlled by the other qubits , which do not change .",
    "the same process is repeated by _ _ pr__@xmath344 acting on @xmath173 , yielding the term before the last in eq .",
    "( [ ftj ] ) , and so on , until reproducing all the terms of the fourier transform .",
    "now it remains to reverse the order of the states of the qubits .",
    "[ ] [ ] @xmath354 [ ] [ ] @xmath337 [ ] [ ] @xmath337 [ ] [ ] @xmath357   gates in terms of the universal gates.,title=\"fig : \" ]    in order to reverse the states of 2 generic qubits , we use the circuit of fig .",
    "let us show why this circuit works as desired .",
    "take the input @xmath358 .",
    "the first cnot of fig .",
    "[ swap ] does not change this state ; the upside down cnot changes to @xmath359 ; and the last cnot changes to @xmath360 .",
    "the output is @xmath361 .",
    "if we repeat the same process with @xmath362 , @xmath360 , and @xmath359 , we conclude that the circuit inverts all states of the computational basis , therefore it inverts a generic state of the form @xmath363 .    [ ] [ ] dft with [ ] [ ] reverse [ ] [ ] output [ ] [ ] @xmath327 [ ] [ ] @xmath364 [ ] [ ] @xmath365 [ ] [ ] @xmath331 [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ]     the decomposition is still not complete . it remains to write the controlled @xmath337 gates in terms of cnot and 1-qubit gates .",
    "this decomposition is given in fig .",
    "[ decomposition ] .",
    "the verification of this decomposition is straightforward .",
    "one simply follows what happens to the computational basis @xmath366 in both circuits .    the complete circuit for the quantum fourier transform is given in fig .",
    "[ complete ] .",
    "now we can calculate the complexity of the quantum fourier circuit . counting the number of elementary gates in figs .",
    "[ ft(j ) ] to [ decomposition ] we get the leading term @xmath367 , which implies that the complexity is @xmath325 .    by",
    "now one should be asking about the decomposition of @xmath162 in terms of the elementary gates .",
    "@xmath162 is the largest gate of fig .",
    "[ order ] . actually , shor stated in his 1997 paper that @xmath162 is the `` bottleneck of the quantum factoring algorithm '' due to the time and space consumed to perform the modular exponentiation ( see @xcite page 10 ) .",
    "the bottleneck is not so strict though since , by using the well known classical method of repeated squaring and ordinary multiplication algorithms ( see @xcite page 69 ) , the complexity to calculate modular exponentiation is @xmath368 .",
    "the quantum circuit can be obtained from the classical circuit by replacing the irreversible classical gates by the reversible quantum counterpart .",
    "@xmath162 is a problem in recursive calls of the algorithm when @xmath131 changes . for each @xmath131 ,",
    "a new circuit must be built , what is troublesome at the present stage of hardware development .",
    "we thank the group of quantum computation at lncc for stimulating discussions on the subject .",
    "vandersypen , m. steffen , g. breyta , c.s .",
    "yannoni , m.h .",
    "sherwood , and i.l .",
    "chuang , experimental realization of shor s quantum factoring algorithm using nuclear magnetic resonance , nature , 414 ( 2001 ) 883 - 887 ."
  ],
  "abstract_text": [
    "<S> this work is a tutorial on shor s factoring algorithm by means of a worked out example </S>",
    "<S> . some basic concepts of quantum mechanics and quantum circuits are reviewed . </S>",
    "<S> it is intended for non - specialists which have basic knowledge on undergraduate linear algebra . </S>"
  ]
}