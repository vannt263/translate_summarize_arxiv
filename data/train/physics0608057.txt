{
  "article_text": [
    "complex networks , such as the internet , the worldwide web , and social and biological networks , have attracted a remarkable amount of attention from the physics community in recent years  @xcite .",
    "most studies of these systems have concentrated on determining their structure or the effects that structure has on the behavior of the system .",
    "for instance , a considerable amount of effort has been devoted to studies of the degree distributions of networks , their measurement and the formulation of theories to explain how they come to take the observed forms , and models of the effect of particular degree distributions on dynamical processes on networks , network resilience , percolation properties , and many other phenomena .",
    "such studies are appropriate for `` naturally occurring '' networks , whose structure grows or is created according to some set of rules not under our direct control .",
    "the internet , the web , and social networks fall into this category even though they are man - made , since their growth is distributed and not under the control of any single authority .",
    "not all networks fall in this class however .",
    "there are some networks whose structure is centrally controlled , such as telephone networks , some transportation networks , or distribution networks like power grids . for these networks",
    "it is interesting to ask how , if one can design the network to have any structure one pleases , one could choose that structure to optimize some desired property of the network .",
    "for instance , paul  _ et  al . _",
    "@xcite have considered how the structure of a network should be chosen to optimize the network s robustness to deletion of its vertices .    in this paper",
    "we study a class of networks that falls between these two types .",
    "there are some networks that grow in a collaborative , distributed fashion , so that we can not control the network s structure directly .",
    "but we can control some of the rules by which the network forms and this in turn allows us a limited degree of influence over the structure .",
    "the archetypal example of such a system is a distributed database such as a peer - to - peer filesharing network , which is a virtual network of linked computers that share data among themselves .",
    "the network is formed by a dynamical process under which individual computers continually join or leave the network , and the rules of joining and leaving can be manipulated to some extent by changing the behavior of the software governing computers behaviors .",
    "it is well established that the structure of peer - to - peer networks can have a strong effect on their performance  @xcite but to a large extent that structure has in the past been regarded as an experimentally determined quantity  @xcite .",
    "here we consider ways in which the structure can be manipulated by changing the behavior of individual nodes so as to optimize network performance .",
    "in this paper we focus primarily on creating networks with desired degree distributions : the degree distribution typically has a strong effect on the behavior of the network and is relatively straightforward to treat mathematically .",
    "there are two basic problems we need to address if we want to create a network with a specific degree distribution solely by manipulating the rules by which vertices enter and leave the network .",
    "first , we need to find rules that will achieve the desired result , and second , we need to find a practical mechanism that implements those rules and operates in reasonable time",
    ". we deal with these questions in order .",
    "our approach to growing a network with a desired degree distribution is based on the idea of the `` attachment kernel '' introduced by krapivsky and redner  @xcite .",
    "we assume that vertices join our network at intervals and that when they do so they form connections ",
    "edges  to some number of other vertices in the network . by designing the software appropriately",
    ", we can in a peer - to - peer network choose the number of edges a newly joining vertex makes and also , as we will shortly show , some crucial aspects of which other vertices those edges connect to .",
    "let us define @xmath0 to be the degree distribution of our network at some time , i.e. ,  the fraction of vertices having degree  @xmath1 , which satisfies the normalization condition @xmath2 and let us define the attachment kernel @xmath3 to be the probability that an edge from a newly appearing vertex connects to a particular preexisting vertex of degree  @xmath1 , divided by the number  @xmath4 of vertices in the network .",
    "it is this attachment kernel that we will manipulate to produce a desired degree distribution .",
    "the extra factor of  @xmath4 in the definition is not strictly necessary , but it is convenient : since the total number of vertices of degree  @xmath1 is @xmath5 , it means that the probability of a new edge connecting to any vertex of degree  @xmath1 is just @xmath6 , and hence @xmath3 satisfies the normalization condition @xmath7    in a peer - to - peer network users may exit the network whenever they want and we as designers have little control over this aspect of the network dynamics",
    ". we will assume in the calculations that follow that vertices simply vanish at random .",
    "we will also assume that , on the typical time - scales over which people enter and leave the network , the total size  @xmath4 of the network does not change substantially , so that the rates at which vertices enter and leave are roughly equal .",
    "for simplicity let us say that exactly one vertex enters the network and one leaves per unit time ( although the results presented here are in fact still valid even if only the probabilities per unit time of addition and deletion of vertices are equal and not the rates ) .",
    "now let us chose the initial degrees of vertices when they join the network , i.e. ,  the number of connections that they form upon entering , at random from some distribution  @xmath8 .",
    "building on our previous results in  @xcite , we observe that the evolution of the degree distribution of our network can be described by a rate equation as follows .",
    "the number of vertices with degree  @xmath1 at a particular time is  @xmath5 .",
    "one unit of time later we have added one vertex and taken away one vertex , so that the number with degree  @xmath1 becomes @xmath9 with the convention that @xmath10 , and @xmath11 , which is the average degree of vertices added to the network . the terms @xmath12 and @xmath13 in eq .   represent the flow of vertices with degree @xmath14 to @xmath1 and @xmath1 to @xmath15 , as they gain extra edges with the addition of new vertices .",
    "the terms @xmath16 and @xmath17 represent the flow of vertices with degree @xmath15 and @xmath1 to @xmath1 and @xmath14 , as they lose edges with the removal of neighboring vertices .",
    "the term @xmath18 represents the probability of removal of a vertex of degree @xmath1 and the term @xmath8 represents the addition of a new vertex with degree @xmath1 to the network .",
    "assuming @xmath0 has an asymptotic form in the limit of large time , that form is given by setting @xmath19 thus : @xmath20 following previous convention  @xcite , let us define a generating function @xmath21 for the degree distribution thus : @xmath22 as well as generating functions for the degrees of vertices added and for the attachment kernel thus : @xmath23 multiplying both sides of   by @xmath24 and summing over  @xmath1 , we then find that the generating functions satisfy the differential equation @xmath25 we are interested in creating a network with a given degree distribution , i.e. ,  with a given @xmath21 . rearranging  ,",
    "we find that the choice of attachment kernel  @xmath3 that achieves this is such that @xmath26.\\ ] ] taking the limit @xmath27 , noting that normalization requires that all the generating functions tend to  1 at @xmath28 , and applying lhopital s rule , we find @xmath29,\\ ] ] where we have made use of the fact that the average degree in the network is @xmath30 and @xmath31 . rearranging",
    ", we then find that @xmath32 .",
    "in other words , solutions to eq .",
    "require that the average degree  @xmath33 of vertices added to the network be equal to the average degree of vertices in the network as a whole .",
    "making use of this result , we can write eq .   in the form @xmath34 where @xmath35 is the generating function for the so - called excess degree distribution @xmath36 which appears in many other network - related calculations ",
    "see , for instance , ref",
    ".  @xcite .",
    "now it is straightforward to derive the desired attachment kernel . noting that @xmath37 we can simply read off the coefficient of @xmath24 on either side of eq .  , to give @xmath38 or equivalently @xmath39,\\ ] ] where @xmath40 is the cumulative distribution of vertex degrees and",
    "@xmath41 is the cumulative distribution of added degrees : @xmath42",
    "since we are at liberty to choose both @xmath8 and  @xmath3 , we have many options for satisfying eq .  ; given ( almost ) any choice of the distribution  @xmath8 of the degrees of added vertices , we can find the corresponding @xmath3 that will give the desired final degree distribution of the network .",
    "one simple choice would be to make the degree distribution of the added vertices the same as the desired degree distribution , so that @xmath43",
    ". then @xmath44 in other words , if we have some desired degree distribution  @xmath0 for our network , one way to achieve it is to add vertices with exactly that degree distribution and then arrange the attachment process so that the degree distribution remains preserved thereafter , even as vertices and edges are added to and removed from the network .",
    "equation   tells us the choice of attachment kernel that will achieve this .",
    "equation   will work for essentially any choice of degree distribution  @xmath0 , except choices for which @xmath45 and @xmath46 for some  @xmath1 . in the latter case eq .",
    "will diverge for some value(s ) of  @xmath1 .",
    "as an example , consider the creation of a network with a power - law degree distribution .",
    "adamic  _ et  al . _",
    "@xcite have shown that search processes on peer - to - peer networks with power - law degree distributions are particularly efficient , so there are reasons why one might want to generate such a network .",
    "let us choose @xmath47 where @xmath48 and @xmath49 are constants and the normalizing factor  @xmath50 is given by @xmath51 where @xmath52 is the riemann zeta - function .",
    "then the mean degree is @xmath53 and eq .",
    "tells us that the correct choice of attachment kernel in this case is @xmath54 for @xmath55 and @xmath56    it is interesting to note that as @xmath1 becomes large , this attachment kernel goes as @xmath57 , the so - called ( linear ) preferential attachment form in which vertices connect to others in simple proportion to their current degree . in growing networks",
    "this form is known to give rise , asymptotically , to a power - law degree distribution .",
    "it is important to understand , however , that in the present case the network is not growing and hence , despite the apparent similarity , this is not the same result .",
    "indeed , it is known that for non - growing networks , purely linear preferential attachment does not produce power - law degree distributions  @xcite , but instead generates stretched exponential distributions  @xcite .",
    "thus it is somewhat surprising to observe that one can , nonetheless , create a power - law degree distribution in a non - growing network using an attachment kernel that seems , superficially , quite close to the linear form .",
    "sarshar and roychowdhury  @xcite showed previously that it is possible to generate a non - growing power - law network by using linear preferential attachment and then compensating for the expected loss of power - law behavior by rewiring the connections of some vertices after their addition to the network .",
    "our results indicate that , although this process will certainly work , it is not necessary : a slight modification to the preferential attachment process will achieve the same goal and frees us from the need to rewire any edges .",
    "note also that   is not the only solution of eq .",
    "that will generate a power - law distribution .",
    "if we choose a different ( e.g. ,  non - power - law ) distribution for the vertices added to the network , we can still generate an overall power - law distribution by choosing the attachment kernel to satisfy eq .  .",
    "suppose , for instance , that , rather than adding vertices with a power - law degree distribution , we prefer to give them a poisson distribution with mean  @xmath33 : @xmath58 in this case @xmath59 , where @xmath60 is the standard gamma function and @xmath61 is the incomplete gamma function",
    ". then the power law is correctly generated by the choice @xmath62,\\end{aligned}\\ ] ] for @xmath55 , where @xmath63 is the generalized zeta function @xmath64 .",
    "for @xmath65 , @xmath66.\\ ] ]",
    "in theory , we should be able use the ideas of the previous section to grow a network with a desired degree distribution . this",
    "does not , however , yet mean we can do so in practice . to make our scheme a practical reality , we still need to devise a realistic way to place edges between vertices with the desired attachment kernel  @xmath3 .",
    "if each vertex entering the network knew the identities and degrees of all other vertices , this would be easy : we would simply select a degree  @xmath1 at random in proportion to  @xmath67 , and then attach our new edge to a vertex chosen uniformly at random from those having that degree .    in the real world",
    ", however , and particularly in peer - to - peer networks , no vertex `` knows '' the identity of all others .",
    "typically , computers only know the identities ( such as ip addresses ) of their immediate network neighbors .",
    "to get around this problem , we propose the following scheme , which makes use of biased random walks .    a random walk , in this context , is a succession of steps along edges in our network where at each vertex  @xmath68 we choose to step next to a vertex chosen at random from the set of neighbors of  @xmath68 . in the context of a peer - to - peer computer network , for example , such a walk can be implemented by message passing between peers .",
    "the `` walker '' is a message or data packet that is passed from computer to neighboring computer , with each computer making random choices about which neighbor to pass to next .    starting a walk from any vertex in the network",
    ", we can sample vertices by allowing the walk to take some fixed number of steps and then choosing the vertex that it lands upon on its final step .",
    "we will consider random walks in which the choice of which step to make at each vertex is deliberately biased to create a desired probability distribution for the sample as follows .    consider a walk in which a walker at vertex  @xmath69 chooses uniformly at random one of the @xmath70 neighbors of that vertex .",
    "let us call this neighbor  @xmath68 .",
    "then the walk takes a step to vertex  @xmath68 with some acceptance probability @xmath71 .",
    "the total probability  @xmath72 of a transition from @xmath69 to @xmath68 given that we are currently at  @xmath69 is @xmath73 where @xmath70 is the degree of vertex  @xmath69 and @xmath74 is an element of the adjacency matrix : @xmath75 if the step is not accepted , then the random walker remains at vertex  @xmath69 for the current step .",
    "this random walk constitutes an ordinary markov process , which converges to a distribution  @xmath76 over vertices provided the network is connected ( i.e. ,  consists of a single component ) and provided @xmath72 satisfies the detailed balance condition @xmath77    in the present case we wish to select vertices in proportion to the attachment kernel  @xmath3 . setting @xmath78",
    ", this implies that @xmath72 should satisfy @xmath79 or , making use of eqs .   and   for the case where @xmath80",
    ", we find @xmath81 where @xmath82 is again the excess degree distribution , eq .  .",
    "in practice , we can satisfy this equation by making the standard metropolis - hastings choice for the acceptance probability : @xmath83 thus the calculation of the acceptance probability requires only that each vertex know the degrees of its neighboring vertices , which can be established by a brief exchange of data when the need arises .    as an example , suppose we wish to generate a network with a poisson degree distribution @xmath84 where @xmath85 is the mean of the poisson distribution .",
    "then we find that the appropriate choice of acceptance ratio is @xmath86 ( as discussed above , we must also make sure to choose the mean degree  @xmath33 of vertices added to the network to be equal to  @xmath85 . )",
    "our proposed method for creating a network is thus as follows .",
    "each newly joining vertex  @xmath68 first chooses a degree  @xmath1 for itself , which is drawn from the desired distribution  @xmath0 .",
    "it must also locate one single other vertex  @xmath69 in the network .",
    "it might do this for instance using a list of known previous members of the network or a standardized list of permanent network members .",
    "vertex  @xmath69 is probably not selected randomly from the network , so it is _ not _ chosen as a neighbor of  @xmath68 . instead , we use it as the starting point for a set of  @xmath1 biased random walkers of the type described above .",
    "each walker consists of a message , which starts at  @xmath69 and propagates through the network by being passed from computer to neighboring computer .",
    "the message contains ( at a minimum ) the address of the computer at vertex  @xmath68 as well as a counter that is updated by each computer to record the number of steps the walker has taken .",
    "( bear in mind that steps on which the walker does nt move , because the proposed move was rejected , are still counted as steps . ) the computer that the walker reaches on its @xmath87th step , where @xmath87 is a fixed but generous constant chosen to allow enough time for mixing of the walk , establishes a new network edge between itself and vertex  @xmath68 and the walker is then deleted .",
    "when all @xmath1 walkers have terminated in this way , vertex  @xmath68 has @xmath1 new neighbors in the network , chosen in proportion to the correct attachment kernel  @xmath3 for the desired distribution . after a suitable interval of time",
    ", this process will result in a network that has the chosen degree distribution  @xmath0 , but is otherwise random .    as a test of this method",
    ", we have performed simulations of the growth of a network with a poisson degree distribution as in eq .  .",
    "starting from a random graph of the desired size  @xmath4 , we randomly add and remove vertices according to the prescription given above .",
    "figure  [ fig : degdist ] shows the resulting degree distribution for the case @xmath88 , along with the expected poisson distribution . as the figure shows , the agreement between the two is excellent .",
    "vertices generated using the biased random walk mechanism described in the text with @xmath88 .",
    "the points represent the results of our simulations and the solid line is the target distribution , eq .  .",
    "as an example of the application of these ideas we consider peer - to - peer networks .",
    "bandwidth restrictions and search times place substantial constraints on the performance of peer - to - peer networks , and the methods of the previous sections can be used to nudge networks towards a structure that improves their performance in these respects .",
    "more sophisticated applications are certainly possible , but the one presented here offers an indication of the kinds of possibilities open to us .",
    "consider a distributed database consisting of a set of computers each of which holds some data items .",
    "copies of the same item can exist on more than one computer , which would make searching easier , but we will not assume this to be the case .",
    "computers are connected together in a `` virtual network , '' meaning that each computer is designated as a `` neighbor '' of some number of other computers .",
    "these connections between computers are purely notional : every computer can communicate with every other directly over the internet or other physical network .",
    "the virtual network is used only to limit the amount of information that computers have to keep about their peers .",
    "each computer maintains a directory of the data items held by its network neighbors , but not by any other computers in the network .",
    "searches for items are performed by passing a request for a particular item from computer to computer until it reaches one in whose directory that item appears , meaning that one of that computer s neighbors holds the item .",
    "the identity of the computer holding the item is then transmitted back to the origin of the search and the origin and target computers communicate directly thereafter to negotiate the transfer of the item .",
    "this basic model is essentially the same as that used by other authors  @xcite as well as by many actual peer - to - peer networks in the real world .",
    "note that it achieves efficiency by the use of relatively large directories at each vertex of the network , which inevitably use up memory resources on the computers .",
    "however , with standard hash - coding techniques and for databases of the typical sizes encountered in practical situations ( thousands or millions of items ) the amounts of memory involved are quite modest by modern standards .",
    "the two metrics of search performance that we consider in this example are search time and bandwidth , both of which should be low for a good search algorithm .",
    "we define the search time to be the number of steps taken by a propagating search query before the desired target item is found .",
    "we define the bandwidth for a vertex as the average number of queries that pass through that vertex per unit time .",
    "bandwidth is a measure of the actual communications bandwidth that vertices must expend to keep the network as a whole running smoothly , but it is also a rough measure of the cpu time they must devote to searches . since these are limited resources it is crucial that we not allow the bandwidth to grow too quickly as vertices are added to the network , otherwise the size of the network will be constrained , a severe disadvantage for networks that can in some cases swell to encompass a significant fraction of all the computers on the planet .",
    "( in some early peer - to - peer networks , issues such as this did indeed place impractical limits on network size  @xcite . )",
    "assuming that the average behavior of a user of the database remains essentially the same as the network gets larger , the number of queries launched per unit time should increase linearly with the size of the network , which in turn suggests that the bandwidth per vertex might also increase with network size , which would be a bad thing .",
    "as we will show , however , it is possible to avoid this by designing the topology of the network appropriately .      in order to treat the search problem quantitatively",
    ", we need to define a search strategy or algorithm . here",
    "we consider a very simple  even brainless ",
    "strategy , again employing the idea of a random walk .",
    "this random walk search is certainly not the most efficient strategy possible , but it has two significant advantages for our purposes .",
    "first , it is simple enough to allow us to carry out analytic calculations of its performance .",
    "second , as we will show , even this basic strategy can be made to work very well .",
    "our results constitute an existence proof that good performance is achievable : searches are necessarily possible that are at least as good as those analyzed here .",
    "the definition of our random walk search is simple : the vertex  @xmath68 originating a search sends a query for the item it wishes to find to one of its neighbors  @xmath69 , chosen uniformly at random .",
    "if that item exists in the neighbor s directory the identity of the computer holding the item is transmitted to the originating vertex and the search ends .",
    "if not , then @xmath69 passes the query to one of its neighbors chosen at random , and so forth .",
    "( one obvious improvement to the algorithm already suggests itself : that @xmath69 not pass the query back to @xmath68 again . as we have said , however , our goal is simplicity and we will allow such `` backtracking '' in the interests of simplifying the analysis . )",
    "we can study the behavior of this random walk search by a method similar to the one we employed for the analysis of the biased random walks of section  [ sec : walks ] .",
    "let @xmath76 be the probability that our random walker is at vertex  @xmath68 at a particular time .",
    "then the probability  @xmath89 of its being at @xmath68 one step later , assuming the target item has not been found , is @xmath90 where @xmath70 is the degree of vertex  @xmath69 and @xmath74 is an element of the adjacency matrix , eq .  .",
    "under the same conditions as before the probability distribution over vertices then tends to the fixed point of  , which is at @xmath91 where @xmath92 is the total number of edges in the network . that is , the random walk visits vertices with probability proportional to their degrees .",
    "( an alternative statement of the same result is that the random walk visits _ edges _ uniformly . )",
    "when our random walker arrives at a previously unvisited vertex of degree  @xmath93 , it `` learns '' from that vertex s directory about the items held by all immediate neighbors of the vertex , of which there are  @xmath94 excluding the vertex we arrived from ( whose items by definition we already know about ) .",
    "thus at every step the walker gathers more information about the network .",
    "the average number of vertices it learns about upon making a single step is @xmath95 , with @xmath76 given by  , and hence the total number it learns about after  @xmath96 steps is @xmath97,\\ ] ] where @xmath98 and @xmath99 represent the mean and mean - square degrees in the network and we have made use of @xmath100 .",
    "( there is in theory a correction to this result because the random walker is allowed to backtrack and visit vertices visited previously . for a well - mixed walk",
    ", however , this correction is of order @xmath101 , which , as we will see , is negligible for the networks we will be considering . )    how long will it take our walker to find the desired target item ?",
    "that depends on how many instances of the target exist in the network . in many cases of practical interest ,",
    "copies of items exist on a fixed _ fraction _ of the vertices in the network , which makes for quite an easy search .",
    "we will not however assume this to be the case here .",
    "instead we will consider the much harder problem in which copies of the target item exist on only a fixed _ number _ of vertices , where that number could potentially be just  1 . in this case",
    ", the walker will need to learn about the contents of @xmath102 vertices in order to find the target and hence the average time to find the target is given by @xmath103 = an,\\ ] ] for some constant  @xmath104 , or equivalently , @xmath105    consider , for instance , a network with a power - law degree distribution of the form , @xmath106 , where @xmath48 is a positive exponent and @xmath50 is a normalizing constant chosen such that @xmath107 .",
    "real - world networks usually exhibit power - law behavior only over a certain range of degree .",
    "taking the minimum of this range to be @xmath108 and denoting the maximum by @xmath109 , we have @xmath110 typical values of the exponent  @xmath48 fall in the range @xmath111 , so that @xmath112 is small for large @xmath109 and can be ignored .",
    "on the other hand , @xmath113  becomes large in the same limit and hence @xmath114 and @xmath115 the scaling of the search time with system size  @xmath4 thus depends , in this case , on the scaling of the maximum degree  @xmath109 .",
    "as an example , aiello  _ et  al . _",
    "@xcite studied power - law degree distributions with a cut - off of the form @xmath116 , which gives @xmath117 a similar result was obtained previously by adamic  _ et  al . _",
    "@xcite using different methods .",
    "bandwidth is the mean number of queries reaching a given vertex per unit time .",
    "equation   tells us that the probability that a particular current query reaches vertex  @xmath68 at a particular time is @xmath118 , and assuming as discussed above that the number of queries initiated per unit time is proportional to the total number of vertices , the bandwidth for vertex  @xmath68 is @xmath119 where @xmath120 is another constant .",
    "this implies that high - degree vertices will be overloaded by comparison with low - degree ones so that , despite their good performance in terms of search times , networks with power - law or other highly right - skewed degree distributions may be undesirable in terms of bandwidth , with bottlenecks forming around the vertices of highest degree that could harm the performance of the entire network . if we wish to distribute load more evenly among the computers in our network , a network with a tightly peaked degree distribution is desirable .",
    "a simple and attractive choice for our network is the poisson distributed network of section  [ sec : walks ] . for a poisson degree distribution with mean",
    "@xmath85 we have @xmath121 and @xmath122 .",
    "then , using eq .  , the average search time is @xmath123 as we have seen , a network of this type can be realized in practice with a biased - random - walker attachment mechanism of the kind described in section  [ sec : walks ] .",
    "now if we allow @xmath85 to grow as some power of the size of the entire network , @xmath124 with @xmath125 , then @xmath126 . for smaller values of  @xmath127 , searches will take longer , but vertices degrees are lower on average meaning that each vertex will have to devote less memory resources to maintaining its directory .",
    "conversely , for larger  @xmath127 , searches will be completed more quickly at the expense of greater memory usage . in the limiting case @xmath128 ,",
    "searches are completed in constant time , independent of the network size , despite the simple - minded nature of the random walk search algorithm .",
    "the price we pay for this good performance is that the network becomes dense , having a number of edges scaling as  @xmath129 .",
    "it is important to bear in mind , however , that this is a _ virtual _ network , in which the edges are a purely notional construct whose creation and maintenance carries essentially zero cost .",
    "there _ is _ a cost associated with the directories maintained by vertices , which for @xmath128 will contain information on the items held by a fixed fraction of all the vertices in the network .",
    "for instance , each vertex might be required to maintain a directory of 1% of all items in the network .",
    "because of the nature of modern computer technology , however , we do nt expect this to create a significant problem .",
    "user time ( for performing searches ) and cpu time and bandwidth are scarce resources that must be carefully conserved , but memory space on hard disks is cheap , and the tens or even hundreds of megabytes needed to maintain a directory is considered in most cases to be a small investment . by making the choice @xmath128 we can trade cheap memory resources for essentially optimal behavior in terms of search time and this is normally a good deal for the user .",
    "we note also that the search process is naturally parallelizable : there is nothing to stop the vertex originating a search from sending out several independent random walkers and the expected time to complete the search will be reduced by a factor of the number of walkers .",
    "alternatively , we could reduce the degrees of all vertices in the network by a constant factor and increase the number of walkers by the same factor , which would keep the average search time constant while reducing the sizes of the directories substantially , at the cost of increasing the average bandwidth load on each vertex .    as a test of our proposed search scheme",
    ", we have performed simulations of the procedure on poisson networks generated using the random - walker method of section  [ sec : walks ] .",
    "figure  [ fig : search ] shows as a function of network size the average time  @xmath96 taken by a random walker to find an item placed at a single randomly chosen vertex in the network .",
    "as we can see , the value of  @xmath96 does indeed tend to a constant ( about 100 steps in this case ) as network size becomes large .",
    "for the random walk search to find an item deposited at a random vertex , as a function of the number of vertices  @xmath4 . ]",
    "we should also point out that for small values of @xmath85 vertices with degree zero could cause a problem .",
    "a vertex that loses all of its edges because its neighbors have all left the network can no longer be reached by our random walkers , and hence no vertices can attach to them and our attachment scheme breaks down . however , in the case considered here , where @xmath85 becomes large , the number of such vertices is exponentially small , and hence they can be neglected without substantial deleterious effects .",
    "any vertex that does find itself entirely disconnected from the network can simply rejoin by the standard mechanism .      in most cases ,",
    "the search problem posed above is not a realistic representation of typical search problems encountered in peer - to - peer networks . in real networks ,",
    "copies of items often occur in many places in the network .",
    "let @xmath130 be the number of times a particular item occurs in the network and let @xmath131 be the probability distribution of @xmath130 over the network , i.e. ,  @xmath131 is the fraction of items that exist in  @xmath130 copies .    if the item we are searching for exists in  @xmath130 copies , then eq",
    ".   becomes @xmath132 since the chance of finding a copy of the desired item is multiplied by  @xmath130 on each step of the random walk . on the other hand ,",
    "it is likely that the frequency of searches for items is not uniformly distributed : more popular items , that is those with higher  @xmath130 , are likely to be searched for more often than less popular ones . for",
    "the purposes of illustration , let us make the simple assumption that the frequency of searches for a particular item is proportional to the item s popularity .",
    "then the average time taken by a search is @xmath133 where we have made use of @xmath134 and @xmath135 .",
    "one possibility is that the total number of copies of items in the network increases in proportion to the number of vertices , but that the number of _ distinct _ items remains roughly the same , so that the average number of copies of a particular item increases as @xmath136 . in this case",
    ", @xmath137  becomes independent of  @xmath4 even when @xmath85 is constant , since we have to search only a constant number of vertices , not a constant fraction , to find a desired item .",
    "perhaps a more realistic possibility is that the number of distinct items increases with network size , but does so slower than  @xmath4 , in which case one can achieve constant search times with a mean degree  @xmath85 that also increases slower than  @xmath4 , so that directory sizes measured as a fraction of the network size dwindle .",
    "an alternative scenario is one of items with a power - law frequency distribution  @xmath138 .",
    "this case describes , for example , most forms of mass art or culture including books and recordings , emails and other messages circulating on the internet , and many others  @xcite .",
    "the mean time to perform a search in the network then depends on the value of the exponent  @xmath139 . in many cases we have @xmath140 , which means that @xmath141 is finite and well - behaved as the database becomes large , and hence  @xmath137 , eq .  , differs from eq .   by only a constant factor .",
    "( that factor may be quite large , making a significant practical difference to the waiting time for searches to complete , but the scaling with system size is unchanged . ) if @xmath142 , however , then @xmath141 becomes ill - defined , having a formally divergent value , so that @xmath143 as system size becomes large .",
    "physically , this represents the case in which most searches are for the most commonly occurring items , and those items occur so commonly that most searches terminate very quickly .",
    "while this extra speed is a desirable feature of the search process , it s worth noting that average search time may not be the most important metric of performance for users of the network . in many situations ,",
    "worst - case search time is a better measure of the ability of the search algorithm to meet users demands . assuming that the most infrequently occurring items in the network occur only once , or only a fixed number of times , the worst - case performance will still be given by eq .  .",
    "one further detail remains to be considered .",
    "if we want to make the mean degree  @xmath85 of vertices added to the network proportional to the size  @xmath4 of the entire network , or to some power of  @xmath4 , we need to know  @xmath4 , which presents a challenge since , as we have said , we do not expect any vertex to know the identity of all or even most of the other the vertices .",
    "this problem can be solved using a breadth - first search , which can be implemented once again by message passing across the network .",
    "one vertex  @xmath68 chosen at random ( or more realistically every vertex , at random but stochastically constant intervals proportional to system size ) sends messages to some number  @xmath144 of randomly chosen neighbors .",
    "the message contains the address of vertex  @xmath68 , a unique identifier string , and a counter whose initial value is zero .",
    "each receiving vertex increases the counter by  1 , passes the message on to one of its neighbors , and also sends messages with the same address , identifier , and with counter zero to @xmath145 other neighbors .",
    "any vertex receiving a message with an identifier it has seen previously sends the value of the counter contained in that message back to vertex  @xmath68 , but does not forward the message to any further vertices .",
    "if vertex  @xmath68 adds together all of the counter values it receives , the total will equal the number of vertices ( other than itself ) in the entire network .",
    "this number can then be broadcast to every other vertex in the network using a similar breadth - first search ( or perhaps as a part of the next such search instigated by vertex  @xmath68 . )",
    "the advantage of this process is that it has a total bandwidth cost ( total number of messages sent ) equal to  @xmath146 . for constant  @xmath144 therefore , the cost per vertex is a constant and hence the process will scale to arbitrarily large networks without consuming bandwidth .",
    "the ( worst - case ) time taken by the process depends on the longest geodesic path between any two vertices in the network , which is @xmath147 .",
    "although not as good as @xmath148 , this still allows the network to scale to exponentially large sizes before the time needed to measure network size becomes an issue , and it seems likely that directory size ( which scales linearly with or as a power of  @xmath4 depending on the precise algorithm ) will become a limiting factor long before this happens .",
    "in this paper , we have considered the problem of designing networks indirectly by manipulating the rules by which they evolve . for certain types of networks , such as peer - to - peer networks , the limited control that this manipulation gives us over network structure , such as the ability to impose an arbitrary degree distribution of our choosing on the network , may be sufficient to generate significant improvements in network performance . using generating function methods",
    ", we have shown that it is possible to impose a ( nearly ) arbitrary degree distribution on a network by appropriate choice of the `` attachment kernel '' that governs how newly added vertices connect to the network .",
    "furthermore , we have described a scheme based on biased random walks whereby arbitrary attachment kernels can be implemented in practice .",
    "we have also considered what particular choices of degree distribution offer the best performance in idealized networks under simple assumptions about search strategies and bandwidth constraints .",
    "we have given general formulas for search times and bandwidth usage per vertex and studied in detail one particularly simple case of a poisson network that can be realized in straightforward fashion using our biased random walker scheme , allows us to perform decentralized searches in constant time , and makes only constant bandwidth demands per vertex , even in the limit where the database becomes arbitrarily large .",
    "no part of the scheme requires any centralized knowledge of the network , making the network a true peer - to - peer network , in the sense of having client nodes only and no servers .",
    "one important issue that we have neglected in our discussion is that of `` supernodes '' in the network . because the speed of previous search strategies has been recognized as a serious problem for peer - to - peer networks , designers of some networks have chosen to designate a subset of network vertices ( typically those with above - average bandwidth and cpu resources ) as supernodes .",
    "these supernodes are themselves connected together into a network over which all search activity takes place .",
    "other client vertices then query this network when they want a search performed .",
    "since the size of the supernode network is considerably less than the size of the network as a whole , this tactic increases the speed of searches , albeit only by a constant factor , at the expense of heavier load on the supernode machines .",
    "it would be elementary to generalize our approach to incorporate supernodes .",
    "one would simply give each supernode a directory of the data items stored by the client vertices of its supernode neighbors .",
    "then searches would take place exactly as before , but on the supernode network alone , and client vertices would query the supernode network to perform searches . in all other respects the mechanisms would remain the same .",
    "n.  sarshar , p.  o. boykin , and v.  p. rowchowdhury , scalable percolation search in power law networks . in _ proceedings of the 4th international conference on peer - to - peer computing _ , pp . 29 , ieee computer society , new york ( 2004 ) .",
    "w.  aiello , f.  chung , and l.  lu , a random graph model for massive graphs . in",
    "_ proceedings of the 32nd annual acm symposium on theory of computing _ , pp . 171180 , association of computing machinery , new york ( 2000 ) ."
  ],
  "abstract_text": [
    "<S> we consider distributed networks , such as peer - to - peer networks , whose structure can be manipulated by adjusting the rules by which vertices enter and leave the network . </S>",
    "<S> we focus in particular on degree distributions and show that , with some mild constraints , it is possible by a suitable choice of rules to arrange for the network to have any degree distribution we desire . </S>",
    "<S> we also describe a mechanism based on biased random walks by which appropriate rules could be implemented in practice . as an example application , </S>",
    "<S> we describe and simulate the construction of a peer - to - peer network optimized to minimize search times and bandwidth requirements . </S>"
  ]
}