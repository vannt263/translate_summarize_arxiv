{
  "article_text": [
    "here are three examples of the kinds of computation that are often required in general relativity .    numerical computation . : :    -15pt use a numerical method to evolve the time symmetric initial data    for a geodesic slicing of a schwarzschild spacetime in an isotropic    gauge . algebraic computation . : :    -15pt compute the riemann tensor for the metric    @xmath0 .",
    "tensor computations . : :    -15pt verify that @xmath1 given    @xmath2 .    what tools might we use to perform these computations ? for the first example , it is hard to envisage _ not _ using a computer to do the job .",
    "the second example is one which could easily be done by hand or on a computer ( using , for example , grtensorii @xcite ) . however , for the third example , the vast majority of researchers in general relativity would do the calculations by hand . recently",
    "a computer program , cadabra @xcite , has appeared which may greatly assist us in these tedious tensor computations .",
    "this article will provide a brief introduction to cadabra and how it can be used in general relativity .",
    "there are a number of programs that , to varying degrees , can manipulate tensor expressions , including grtensorii @xcite , mathtensor @xcite , canon @xcite , riemann @xcite , xact @xcite and my personal choice ( and the subject of this article ) cadabra .",
    "it is not my intention to provide even a cursory review of the existing computer tensor algebra systems .",
    "instead i intend to show how cadabra can be used to do useful work in general relativity .",
    "i suspect that all of the results reported in this article can also be obtained using either mathtensor or xact but as i have not done so i can not comment on their relative merits .",
    "i chose to work with cadabra for a number of reasons , it uses latex syntax for tensor expressions , it has extensive and highly optimised routines for simplifying complex tensor expressions , it uses an interpretive language that runs on top of a c++ program , it has a small but flexible grammar leading to clear and readable code and it is in active development .    the use of ( a subset of ) latex as the native language for cadabra was the feature that first grabbed my attention ( apart from the promise of relieving me of the tedium of complex tensor gymnastics ) .",
    "you may have already skimmed through this article and have wondered if i have massaged the cadabra output for inclusion in this article .",
    "the answer is an emphatic no .",
    "_ all of the output _ appearing in this article was included by a ` cut - and - paste ' operation directly from cadabra s output .",
    "no stylistic changes what so ever were made to the tex produced by cadabra .",
    "this ability to cut and paste between cadabra output and research documents is i believe one of cadabra s unique strengths .",
    "this feature not only leads to readable code ( we only need to be literate in a simple subset of latex ) but it also minimises transcription errors .    the following examples were deliberately constructed so as to require little mathematical development ( for the current audience ) while being of sufficient complexity to allow cadabra s features to be properly showcased .",
    "i will make no assumptions about the dimensionality of the space , nor the signature of the metric ( other than that the metric is non - singular ) .",
    "however , i will assume that the connection is metric compatible ( i.e. the levi - civita connection ) .",
    "for the large part i will be using abstract index notation but on the odd occasion where an explicit component based equation is given i will use a coordinate basis .",
    "you might , as a simple exercise , like to adapt some of the following cadabra examples to work with non - coordinate basis ( the changes are trivial ) .",
    "the source code for cadabra is freely available ( but subject to the gpl licence ) and has been successfully compiled on many platforms including most flavors of linux and macosx .",
    "it should compile on most standard unix like systems .",
    "the source code and binaries ( for linux ) can be download from the web site @xcite .",
    "cadabra for macosx is best installed ( by my experience ) from the source via the macports system @xcite .",
    "cadabra can be run either directly through the command line or through a purpose - built gui ( based on x11 and known as ` xcadabra ` ) . to run cadabra over the file ` myinput.cdb ` you need only type    cadabra",
    "< myinput.cdb > myoutput.tex    from the command line .",
    "the ` xcadabra ` gui produces the same output but in a more convenient environment .",
    "further details can be found in the cadabra documentation ( available through the web site ) @xcite .",
    "how might we use cadabra to verify that @xmath1 given @xmath2 ?",
    "this may seem an odd way to start but here is the full cadabra code .",
    "#  the metric connection     a , b , c , d , e , f , g , h , i , j , k , l , m , n , o , p , q , r , s , t , u#::indices .    g_a b::metric .    _ # : : partialderivative .",
    "cderiv:=_cg_a b - g_a d^d_b c - g_d b^d_a c ;    gamma:=^a_b c - > ( 1/2 ) g^a d ( _ bg_d c + _ cg_b d - _ dg_b c ) ;    @substitute!(cderiv)(@(gamma ) ) ;    @distribute!(@eliminate_metric!(@canonicalise!(@collect_terms ! (    the output from the above code is    _ cg_a b - g_a d ^d_b c - g_d b ^d_a c^a_b c g^a d ( _ bg_d c + _ cg_b d - _ dg_b c)_cg_a b - g_a d g^d e ( _ bg_e c + _ cg_b e - _ eg_b c ) - g_d b g^d e ( _ ag_e c + _ cg_a e - _ eg_a c)_cg_a b - g_a d g^d e _ bg_e c - g_a d g^d e _",
    "cg_b e + g_a d g^d e _",
    "eg_b c - g_d b g^d e _ ag_e c - g_d b g^d e _",
    "cg_a e + g_d b g^d e _",
    "eg_a c_cg_a b - _ bg_a c - _ cg_b a + _ ag_b c - _ ag_b c - _ cg_a b + _",
    "bg_a c_cg_a b - _ bg_a c - _ cg_a b + _ ag_b c - _ ag_b c - _ cg_a b + _",
    "bg_a c0    each of these line shows selected stages of processing by cadabra .",
    "the zero in the final line is what we were looking for  it shows that @xmath1 .    we will now spend a moment of time to work through the above cadabra code in some detail .",
    "comments in cadabra are single lines that begin with the ` # ` character in column one .",
    "statements in the cadabra grammar fall into three distinct categories : _ properties _ , _ expressions _ and _ algorithms_. the first three statements in the above code assign _ properties _ to some symbols , the next two statements define two _ expressions _ with names ` cderiv ` and ` gamma ` while the remaining statements apply _ algorithms _ to the expressions ( i.e. they perform the computations ) .",
    "note that each of the statements ends with either a dot `` . ` ' or a semi - colon",
    "`` ; ` ' . only those statements that finish with a semi - colon will produce output .",
    "if you look closely at the above you will see that there are seven statements in the cadabra code that end with a semi - colon and that there are seven statements of cadabra output .",
    "the statements and output are in exact one - to - one correspondence .",
    "you can suppress the cadabra output by terminating the statement with a colon `` : ` ' rather than the semi - colon `` ; ` ' .",
    "what do these statements actually mean ?",
    "the first statement    a , b , c , d , e , f , g , h , i , j , k , l , m , n , o , p , q , r , s , t , u#::indices .    simply declares a set of symbols that may used as indices .",
    "the last symbol ` u # ` informs cadabra that an infinite set of indices of the form ` u1,u2,u3`@xmath3 is allowed .",
    "if you prefer to work with greek indices then you could declare    , , , , , , # : : indices .    the next statement    g_a b::metric .    declares the symbol ` g_{a b } ` to represent a metric .",
    "this confers upon ` g_{a b } ` a raft of properties most notably that it is symmetric in its indices .    the third statement    _ # : : partialderivative",
    ".    assigns to the symbol ` \\partial ` a derivative property .",
    "note that the ` # ` in ` \\partial _ { # } ` signifies that any number of indices are allowed . that is both `",
    "\\partial_{a } ` and ` \\partial_{a b c d } ` will be seen by cadabra as derivative operators .",
    "the next statement define an expression , ` cderiv ` .",
    "cderiv:=_cg_a b - g_a d^d_b c - g_d b^d_a c ;    the name of the expression appears to the left of the `` : = ` ' characters while the corresponding tensor expression appears on the right using a familiar latex syntax . unlike latex , we must always separate the indices by one or more spaces .",
    "this ensures that cadabra knows exactly how many indices belong to an object ( e.g.  ` g_{ab } ` would be interpreted as an object with _",
    "one _ covariant index ` ab ` ) .",
    "note carefully the braces around the metric term in ` \\partial_{c}{g_{a b } } ` .",
    "this is essential ",
    "the symbol ` \\partial ` is an operator and thus needs an argument to act on . and",
    "that argument is contained inside the pair of braces .",
    "how do we tell cadabra that in the expression for ` cderiv ` the symbols ` \\gamma^{a}{}_{bc } ` stands for the metric connection ?",
    "that is , how do we couple the equation @xmath4 to the expression ` cderiv ` ?",
    "for this we create two statements , the first is an expression that defines a substitution rule , the second uses cadabra s `",
    "@substitute ` algorithm to complete the job ,    gamma:=^a_b c - > ( 1/2 ) g^a d ( _ bg_d c + _ cg_b d - _ dg_b c ) ; @substitute!(cderiv)(@(gamma ) ) ;    the essence of this pair of statements is to substitute @xmath5 wherever the symbol ` \\gamma^{a}_{b c } ` appears in the expression ` cderiv ` .",
    "this may look simple but there are some important and subtle details that must be noted .",
    "the substitution rule ` gamma ` as given above was for @xmath6 yet in the expression for ` cderiv ` we need @xmath7 and @xmath8 .",
    "cadabra handles this index manipulation with ease , it will relabel dummy indices in such a way as to avoid index clashes .",
    "this feature also exists in mathtensor and xact ( but not so in grtensorii ) .",
    "the construction ` @ ( ... ) ` is cadabra s way of referring to the contents of an expression .",
    "the exclamation character `` ! ` ' in the statement tells cadabra to impose the substitution throughout the expression ` cderiv ` . without the `` ! ` ' character the substitution will be applied once at most ( i.e. on the first of the two @xmath6 s in ` cderiv ` ) .    the remaining few statements    @distribute!(@eliminate_metric!(@canonicalise!(@collect_terms ! (    serve only to massage the expression towards our expected result  zero .",
    "the ` % ` notation is cadabra shorthand for the last computed expression , in this case ` cderiv ` .",
    "each of the ` @ ... ` statements applies an algorithm to the expression ` cderiv ` .",
    "the algorithm ` @distribute ` is used to expand products , it will expand ` a ( b+c ) ` into ` a b + b c ` .",
    "earlier we gave ` g_{a",
    "b } ` the property ` : : metric ` .",
    "this is used by the ` @eliminate_metric ` algorithm to convert combinations such as ` g^{a c } g_{c b } ` into the kronecker - delta @xmath9 .",
    "the ` @canonicalise ` algorithm is one of cadabra s most useful algorithms ( on a par with ` @substitute ` ) as it can apply a wide range of simplifications and general housekeeping on the expression . in this case",
    "it serves only to put the free indices into ascending order ( look carefully at the differences between the third and second last lines of output ) .",
    "the final algorithm ` @collect_terms ` needs no explanation .",
    "cadabra does not have predefined algorithms for computing covariant derivatives , riemann tensors , ricci tensor and so on .",
    "one of its strengths is that it provides a rich set of simple tools by which objects such as those just noted can be constructed . as a second example",
    "we will now see how cadabra can be trained to compute covariant derivatives .    for a simple dual vector such as @xmath10 the textbook definition of the covariant derivative @xmath11",
    "is @xmath12 here we will pursue a slight variation , one that lends itself well to computing higher order covariant derivatives in cadabra .",
    "choose any point @xmath13 in the spacetime and construct any curve through that point .",
    "let @xmath14 be the unit tangent vector to the curve , @xmath15 be a parallel vector field along the curve and let the curve be parametrised by the proper distance @xmath16 .",
    "thus we have    10pt @xmath17    since @xmath18 is a scalar function of @xmath16 we can compute its derivative along the curve in two ways , by ordinary differentiation in @xmath16 or by applying the leibniz rule to @xmath19 .",
    "this leads to @xmath20 the left hand side is what we are looking for , while the right hand side is something we can easily train cadabra to perform .",
    "the final code contains two new algorithms , ` @prodsort ` and ` @factor_out ` .",
    "their actions are very simple , ` \\@prodsort ` rewrites any expression so that the symbols appear in a particular order ( usually in alphabetical order though this can be over - ridden with the ` : : sortorder ` property ) and ` @factor_out ` factors out nominated symbols from an expression .",
    "so , without further ado here is the code .",
    "#  covariant differentiation     a , b , c , d , e , f , g , h , i , j , k , l , m , n , o , p , q , r , s , t , u#::indices .",
    "_ # : : partialderivative .    #  construct the scalar v_a a^a ",
    "scalar:=v_a a^a :    #  compute the derivative -",
    "derivd:=d^c_c@(scalar ) : @distribute!(@prodrule!(@distribute!(@substitute!(@substitute!(@prodsort!(@rename_dummies!(@canonicalise ! (    #  tidy up and display the results -    @factor_out!(scalar)a^a : @factor_out!(scalar)d^a ;    @factor_out!(derivd)a^a : @factor_out!(derivd)d^a ;    the above code produces the following output    v_a a^aa^a d^b ( _ bv_a - ^b_ac v_b )    the right hand side is what we were seeking , @xmath21 . as this quantity is also a scalar it could be used as a starting point for further rounds of differentiation .",
    "clearly this is easy to do and would lead to expressions for higher order covariant derivatives of @xmath10 .",
    "this is the basis for the following example .",
    "the somewhat unorthodox way in which we computed the covariant derivative in the previous example is actually very well suited to our next example  computing the riemann tensor by commutation of successive covariant derivatives . in this example",
    "we will ` discover ' that @xmath22 follows directly from @xmath23    here we will be using two covariant derivatives and thus , in the spirit of the previous example , we imagine having two distinct curves through the point @xmath13 .",
    "let @xmath14 and @xmath24 be the respective unit tangent vectors and let @xmath25 and @xmath26 be the respective proper distances along the curves ( i could have retained @xmath16 for the first curve but for aesthetics i prefer to use @xmath25 and @xmath26 here ) .",
    "this example is slightly more complicated than the previous example but we still have considerable freedoms to choose the nature of the vector fields @xmath15 , @xmath14 and @xmath24 along the two curves through @xmath13 .",
    "we will do the calculations in two parts , first we will compute @xmath27 then we reverse the order @xmath28 .",
    "so for the first part we choose to parallel transport @xmath15 and @xmath14 along @xmath24 . in the second part we simply swap @xmath14 and @xmath24 .",
    "thus we have    10pt @xmath29    and this leads to @xmath30 the right hand side is very easy to implement in cadabra  just two ( almost identical ) rounds of the code given in the previous example .",
    "here is the cadabra code .",
    "#  covariant differentiation and the riemann tensor     a , b , c , d , e , f , g , h , i , j , k , l , m , n , o , p , q , r , s , t , u#::indices .    _ # : : partialderivative .    #  force gamma to be symmetric in its lower two indices",
    "    ^a_b c::tableausymmetry(shape=2 , indices=1,2 ) .",
    "#  construct the scalar v_a a^a ",
    "scalar:=v_a a^a :    #  compute the covariant derivative in the direction of d^a ",
    "derivd:=d^c_c@(scalar ) : @distribute!(@prodrule!(@distribute!(@substitute!(@prodsort!(@rename_dummies!(@canonicalise ! (    #  compute the covariant derivative in the direction of e^a ",
    "derivde:=e^c_c@(derivd ) : @distribute!(@prodrule!(@distribute!(@substitute!(@substitute!(@prodsort!(@rename_dummies!(@canonicalise !",
    "(    #  copy to derived then swap the order of the derivatives",
    "    derived:=@(derivde ) :    @substitute!(@substitute!(@substitute !",
    "(    #  compute difference in mixed covariant derivatives",
    "    diff:=@(derivde ) - @(derived ) :    #  tidy up and display the results -",
    "a^a , d^a , e^a , v_a,^a_b c::sortorder .",
    "@prodsort!(@rename_dummies!(@canonicalise!(@collect_terms ! ( @factor_out!(@factor_out!(@factor_out!(@factor_out ! ( @print[``a^a d^b e^c ( v_a;b;c - v_a;c;b)= ''  @(diff ) ] ;    here is the output form the above code .",
    "- a^a d^b e^c ^d_a c _ bv_d - a^a d^b e^c ^d_b c",
    "_ dv_a + a^a d^b e^c _ b cv_a + a^a d^b e^c ^d_a c ^e_b d",
    "v_e + a^a d^b e^c ^d_a e ^e_b c v_d - a^a d^b e^c _ c^d_a b v_d - a^a d^b e^c ^d_a b",
    "_ cv_d- a^a e^b d^c ^d_a c _ bv_d - a^a e^b d^c ^d_b c _ dv_a + a^a e^b d^c _ b cv_a + a^a e^b d^c ^d_a c ^e_b d v_e + a^a e^b d^c ^d_a e ^e_b c v_d - a^a e^b d^c _ c^d_a b v_d - a^a e^b d^c ^d_a b _",
    "cv_da^a d^b e^c v_d ( ^d_b e ^e_a c - _ c^d_a b - ^d_c e ^e_a b +",
    "_ b^d_a c)a^a d^b e^c ( v_a;b;c - v_a;c;b)=a^a d^b e^c v_d ( ^d_b e ^e_a c - _ c^d_a b - ^d_c e ^e_a b + _ b^d_a",
    "c )    the last line of output is what we have been seeking and apart from it being mathematically correct it is worth noting how that line was created .",
    "the right hand side was obtained from a result computed by cadabra while the left hand side was a string supplied by us .",
    "this construction is performed in the ` @print [ ... ] ` algorithm .",
    "you can see it in the last line of the cadabra code .",
    "its use is clear  it creates nicely formatted output .",
    "but there is a potential danger here  the onus falls on the user ( us ) to ensure that the left hand side is what it should be , cadabra does no processing what so ever on the argument to ` @print ` .",
    "so if you chose to write nonsense such as    @print[``a_a + b_c = g_ab '' ] ;    then cadabra will dutifully obey .",
    "the output for this example could have been restricted to just the final line ( by changing the appropriate `` ; ` ' to `` : ` ' ) .",
    "but there is value in including output from other lines for it shows how the computations unfold and it allows us to verify that cadabra is doing what we think and want it to do .",
    "output like this is very useful when first writing and later debugging cadabra code .",
    "there is one very important part of the calculations that we have not yet spoken about ",
    "how do we tell cadabra that we are using a torsion free connection ?",
    "the line in the above code that does the job is    ^a_b c::tableausymmetry(shape=2 , indices=1,2 ) .",
    "this tells cadabra that we want the connection to be symmetric in its lower two indices ( i.e. torsion free ) .",
    "cadabra uses sophisticated algorithms to handle tensor symmetries based on the littlewood - richardson algorithm for finding a basis of the irreducible representations of totally symmetric groups .",
    "the algorithm uses young diagrams which consist of a set of cells arranged as series of rows which in turn are described by the ` : : tableausymmetry ` property . in short , the index symmetries of a tensor are encoded in these diagrams .",
    "the ` shape= { ... } ` parameter describes the shape of a young diagram , in this case it consists of one row with two cells .",
    "the ` indices= { ... } ` parameter describes how the tensor s indices are assigned to the cells . for this purpose ,",
    "the indices on the tensor are counted from left to right starting with zero .",
    "so in the above example the lower two indices @xmath31 and @xmath32 are counted as 1 and 2 and they are assigned to the two cells of the young diagram .",
    "more details on using tableaux as a way to describe tensor symmetries can be found in the cadabra manual .    if young diagrams and tableaux are not your cup of tea then there is a ( less than ideal ) alternative .",
    "one way to obtain a symmetric connection is to temporarily put @xmath33 where @xmath34 , ask cadabra to make its simplifications and then return the @xmath6 to the result .",
    "this is not a mathematical operation , it is just a trick to help cadabra spot what symmetries are available .",
    "here is a fragment of code that does the job ( assuming ` % ` is an expression that contains @xmath6 )    #  trick to impose zero torsion ( symmetric connection )     g_a b::symmetric .    @substitute!(@prodsort!(@canonicalise!(@collect_terms!(@substitute ! !",
    "(    the problem with this approach is that if the pair of terms @xmath35 and @xmath36 ever get separated ( e.g. from a product rule ) then it may not be possible to complete the last step of this trick , that is , to eliminate the @xmath35 and @xmath37 in favour of @xmath6 .",
    "if on the other hand you can be sure that such problems can not arise ( e.g. you apply the trick after all the derivatives have been computed ) then this method is rather easy to apply .",
    "it also provides a quick way to implement more complicated symmetries ( e.g. if @xmath38 is symmetric in the first two and last three indices put @xmath39 ) .",
    "lest it be thought that every covariant derivative in cadabra needs to be cast in the form given in the previous examples , here is an application of cadabra to the derivation of the gauss equation relating the induced and ambient curvatures of a hypersurface in an @xmath40dimensional riemannian manifold .",
    "we shall start with a brief review of the underlying mathematics .",
    "suppose @xmath41 is an @xmath42dimensional subspace of an @xmath40dimensional space @xmath43 .",
    "suppose @xmath43 is equipped with riemannian metric @xmath44 and a metric compatible derivative operator @xmath45 .",
    "the subspace @xmath41 will , by way of its embedding in @xmath43 , inherit a metric and derivative operator which we will denote by @xmath46 and @xmath47 respectively ( note this use of @xmath47 differs from that in the previous sections , here @xmath47 is a differential operator ) .",
    "let @xmath48 be the oriented unit normal to @xmath41 .",
    "then the metrics of @xmath41 and @xmath43 are related by @xmath49 while , for any dual - vector @xmath10 lying in @xmath41 ( i.e. @xmath50 ) , we have @xmath51 where @xmath52 is the projection operator . the curvature tensor for @xmath53",
    "can then be obtained by computing @xmath54 .",
    "this is all very standard and can be found in most textbooks on differential geometry ( see @xcite ) .",
    "translating these equations into cadabra code is very straightforward and follows a now familiar pattern . unlike the previous examples",
    ", we will begin by discussing fragments of code that express the basic mathematical relations as just given .",
    "these code fragments will later be glued together to form a complete cadabra program .",
    "we will start with the definition of the projection operator @xmath55 and its use in defining @xmath47 in terms of @xmath45 .",
    "we will use the symbol ` hab ` to record the projection operator and ` vpq ` to record the covariant derivative @xmath56 .",
    "thus our code will contain the lines    hab:=h^a_b - > g^a_b - n^a n_b : vpq:=v_p q - > h^a_ph^b_q_bv_a :    we will also need an expression for the commutation of the covariant derivatives,@xmath57 which we write as ` vpqr `    vpqr:=h^a_ph^b_qh^c_r ( _ cv_a b - _ bv_a c ): @substitute!(vpq)(@(hab ) ) : @substitute!(vpqr)(@(vpq ) ) :    finally we will need to introduce some standard substitutions to simplify and tidy the result .",
    "note that _ all of the previous definitions and following substitutions are exactly what we would normally do if we were to do these calculations by hand_. for example , the lines    @substitute!(@substitute ! (    expresses the condition that @xmath48 is normal to the subspace , @xmath58 and @xmath59 . the line",
    "@substitute ! (    states that the covariant derivative of @xmath44 is zero while the line    @substitute !",
    "(    is a simple re - working of @xmath60 to eliminate first derivatives of @xmath61 from the expression ` vpqr ` .",
    "the next line    @substitute ! (    squeezes a projection operator between @xmath62 and @xmath63 .",
    "this is allowed because @xmath61 has zero normal component .",
    "finally , lines like    @substitute!(@substitute ! (    can be used to introduce the extrinsic curvature tensor @xmath64",
    ".    clearly we have to supplement the above code fragments with extra statements , such as an index set , substitution and simplification rules etc .",
    ", before cadabra can do its job . such pieces of code are very similar to those given in the previous examples and thus require no further explanation here . here then is the final code",
    ".    #  the gauss equation     : : postdefaultrules ( @@collect_terms!(a , b , c , d , e , f , g , i , j , k , l , m , n , o , p , q , r , s , t , u#::indices(position = fixed ) .",
    "_ # : : derivative .",
    "k_a b::symmetric .",
    "g^a_b::kroneckerdelta .",
    "#  define the projection operator ",
    "hab:=h^a_b - > g^a_b - n^a n_b :    #  3-covariant derivative obtained by projection on 4-covariant derivative -    vpq:=v_p q - > h^a_ph^b_q_bv_a :    #  compute 3-curvature by commutation of covariant derivatives -    vpqr:=h^a_ph^b_qh^c_r ( _ cv_a b - _ bv_a c ):",
    "@substitute!(vpq)(@(hab ) ) : @substitute!(vpqr)(@(vpq ) ) :    @distribute!(@prodrule!(@distribute!(@eliminate_kr !",
    "(    #  standard substitutions     @substitute!(@substitute!(@substitute!(@substitute!(@substitute!(@substitute!(@substitute ! (    #  tidy up and display the results     h^a_b,_av_b::sortorder .    @prodsort!(@rename_dummies!(@canonicalise!(@factor_out ! !",
    "(    the output returned by cadabra is    h^a_p h^b_q h^c_r ( _ c_bv_a - _ b_cv_a ) + k_p r k_q^a v_a - k_p q k_r^a v_a    which , although correct , is not in the form we are most familiar with .",
    "we could reformat the output by including suitable ` @print ` statements or we could wrest control from cadabra and do the final tidying up by hand ( we are not invalids and it s wise to retain our skills ) .    recall that ` vpqr ` was defined to be @xmath65 . if we use this and the ricci identity for curvatures @xmath66 we very easily recover the gauss equation in ( one of ) its familiar forms @xmath67",
    "simple problems such as those given here can be done easily by hand ( or passed off to a graduate student ) .",
    "but they tell us nothing about cadabra s utility or performance for large scale tensor computations in general relativity . in a follow - up paper",
    "@xcite we will report on the use of cadabra for higher order riemann normal expansions of the metric , connection and solutions to the initial and boundary value problems for the geodesic equations .",
    "the results have been completed up to 6th order in the curvature tensor .",
    "it is my opinion that cadabra is very well suited to large scale tensor algebra computations in general relativity and will be a welcome addition to the relativist s computational toolkit .",
    "a .tar.gz archive of the cadabra files used in preparing this paper can be found at this url http://users.monash.edu.au/~leo/research/papers/files/lcb09-02.html",
    "i am very grateful to kasper peeters for his many helpful suggestions .",
    "any errors , omissions or inaccuracies in regard to cadabra are entirely my fault ( i hope there are none ) ."
  ],
  "abstract_text": [
    "<S> cadabra is a powerful computer program for the manipulation of tensor equations . </S>",
    "<S> it was designed for use in high energy physics but its rich structure and ease of use lends itself well to the routine computations required in general relativity . here </S>",
    "<S> we will present a series of simple examples showing how cadabra may be used , including verifying that the levi - civita connection is a metric connection and a derivation of the gauss equation between induced and ambient curvatures . </S>"
  ]
}