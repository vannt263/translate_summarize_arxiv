{
  "article_text": [
    "many computer communication networks require nodes to broadcast information to other nodes for network control purposes ; this is done efficiently by sending messages over a spanning tree of the network .",
    "now , optimizing the worst - case message propagation over a spanning tree is naturally achieved by reducing the diameter to a minimum .",
    "the use of a control structure spanning the entire network is a fundamental issue in distributed systems and interconnection networks . given a network , a distributed algorithm is said to be _ total _",
    "iff all nodes participate in the computation .",
    "now , all total distributed algorithms have a time complexity of @xmath4 , where @xmath5 is the network diameter ( either in terms of hops , or according to the wider sense given by christophides in  @xcite ) .",
    "therefore , having a spanning tree with minimum diameter of arbitrary networks makes it possible to design a wide variety of time - efficient distributed algorithms . in order to construct such a spanning tree , all - pairs",
    "shortest paths in the graph are needed first .",
    "several distributed algorithms already solve the problem on various assumptions .",
    "however , our requirements are more general than the usual ones .",
    "for example , we design a `` process terminating '' algorithm for ( weighted ) networks with no common knowledge shared between the processes .",
    "( see assumptions in subsection  [ prob ] below . )",
    "a distributed system is a standard point - to - point asynchronous network consisting of  @xmath6 communicating processes connected by @xmath7 bidirectional channels .",
    "each process has a local non - shared memory and can communicate by sending messages to and receiving messages from its neighbours .",
    "a single process can transmit to and receive from more than one neighbour at a time .",
    "the network topology is described by a finite , weighted , connected and undirected graph @xmath8 , devoid of multiple edges and loop - free .",
    "@xmath1 is a structure which consists of a finite set of nodes @xmath9 and a finite set of edges @xmath10 with real - valued weights ; each edge @xmath11 is incident to the elements of an unordered pair of nodes @xmath12 . in the distributed system , @xmath9 represents the processes , while @xmath10 represents the ( weighted ) bidirectional communication channels operating between neighbouring processes  @xcite .",
    "we assume that , for all @xmath13 , @xmath14 and , to shorten the notation , @xmath15 denotes the real - valued weight of edge @xmath16 .",
    "( assumptions on real - valued weights of edges are specified in the next two subsections  [ prob ] and  [ ass ] . ) throughout , we let @xmath17 , @xmath18 and , according to the context , we use @xmath1 to represent the network or the weighted graph , indistinctly .",
    "the weight of a path @xmath19 $ ] of  @xmath1 ( @xmath20 ) is defined as @xmath21 . for all nodes @xmath22 and @xmath23 in @xmath9 , the _ distance _ from @xmath22 to @xmath23 , denoted @xmath24 , is the lowest weight of any path length from @xmath22 to @xmath23 in @xmath1 .",
    "the largest ( minimal ) distance from a node @xmath23 to all other nodes in  @xmath9 , denoted @xmath25 , is the _ eccentricity _ of node  @xmath23 : @xmath26  @xcite .",
    "an _ absolute center _ of @xmath1 is defined as a node ( not necessarily unique ) achieving the smallest eccentricity in @xmath1 .",
    "@xmath27 denotes the _ diameter _ of @xmath1 , defined as @xmath28 ( see  @xcite ) and @xmath29 denotes the _ radius _ of @xmath1 , defined as @xmath30 .",
    "finally , @xmath31 represents the _ shortest paths tree _ ( spt ) of @xmath1 rooted at node @xmath22 : @xmath32 .",
    "@xmath33 is chosen _ uniquely _ among all the shortest paths trees of @xmath1 rooted at node @xmath22 ; whenever there is a tie between any two length paths @xmath34 , it is broken by choosing the path with a second node of minimal identity .",
    "the set of all spts of @xmath1 is denoted @xmath35 . when it is clear from the context , the name of the graph is omitted .",
    "in the remainder of the paper , we denote problems as `` the ( mdst ) problem '' , `` the ( mst ) problem '' , `` the ( gmdst ) problem '' , etc .",
    "( see definitions in subsection  [ rwr ] ) .",
    "distributed algorithms are denoted in italics , e.g. `` algorithm _ mdst _ '' .",
    "finally , `` mdst '' , `` apsps '' and `` spt '' abbreviate `` minimum diameter spanning tree '' , `` all - pairs shortest paths '' and `` shortest paths tree '' , respectively .      given a weighted graph @xmath8 ,",
    "the * ( mdst ) problem * is to find a spanning tree of  @xmath1 of minimum diameter @xmath5 ( according to the definition of @xmath5 ) .",
    "note that the ( mdst ) problem assumes @xmath1 to be a non - negatively real - weighted graph ( i.e. , @xmath36 ) .",
    "indeed , the ( mdst ) problem is known to be np - hard if we allow negative length cycles in @xmath1 ( cf .",
    "camerini _ et al . _",
    "@xcite ) .    in spite of the fact that the ( mdst ) problem requires arbitrary non - negative real - valued edges weights ,",
    "our distributed mdst algorithm is process terminating ( i.e. , a proper distributed termination is completed  @xcite ) .",
    "this is generally not the case on the above requirement .",
    "when weights are assumed to be real - valued , a common ( additional ) knowledge of a bound on the size of the network is usually necessary for apsps algorithms to process terminate ( see e.g.  @xcite ) .",
    "by contrast , no `` structural information '' is assumed in our algorithm , neither topological ( e.g. , size or bound on the size of the network ) , nor a sense of direction , etc .",
    "( see subsection  [ formal ] ) .",
    "in addition to the above general hypothesis of the ( mdst ) problem , we need the following assumptions on the network .",
    "* processes are faultless , and the communication channels are faithful , lossless and order - preserving ( fifo ) . * all processes have _ distinct _ identities ( _ id_s ) .",
    "( @xmath1 is called a `` named network '' , by contrast with `` anonymous networks '' . )",
    "we need distinct _",
    "id_s to compute the apsps routing tables of @xmath1 at each process of the network . for the sake of simplicity , _ id_s",
    "are also assumed to be non - negative distinct integers .",
    "+ each process must distinguish between its ports , but has no _ a priori _ knowledge of its neighbours _",
    "actually , any process knows the _ i d _ of a sending process after reception of its first message .",
    "therefore , we assume w.l.o.g .",
    "( and up to @xmath37 messages at most ) that a process knows the _ i d _ of each of its neighbours from scratch ( see protocol _ apsp _ in subsection  [ mdst ] ) .",
    "* of course , each node also knows the weights of its adjacent edges .",
    "however , edges weights do not satisfy the triangular inequality .",
    "* let @xmath38 be a distributed algorithm defined on @xmath1 . a non - empty subset of nodes of @xmath9 , called _ initiators _ ,",
    "simultaneously start algorithm @xmath38 . in other words , an external event ( such as a user request , for example ) , impels the initiators to trigger the algorithm . other ( non - initiating ) nodes `` wake up '' upon receipt of a first message . * in a reliable asynchronous network , we measure the communication complexity of an algorithm @xmath38 in terms of the maximal number of messages that are received , during any execution of @xmath38 .",
    "we also take into account the number of bits in the messages ( or message size ) : this yields the `` bit complexity '' of @xmath38 . for measuring the time complexity of @xmath38",
    ", we use the definition of standard time complexity given in  @xcite .",
    "standard time complexity is defined on _",
    "`` asynchronous bounded delay networks '' _ ( abd networks ) : we assume an upper bound transmission delay time of @xmath39 for _ each _ message in a channel ; @xmath39 is then the `` standard time unit '' in @xmath1 .",
    "the small amount of literature related to the ( mdst ) problem mostly deals either with graph problems in the euclidian plane ( geometric minimum diameter spanning tree : the ( gmdst ) problem ) , or with the steiner spanning tree construction ( see  @xcite ) .",
    "the ( mdst ) problem is clearly a generalization of the ( gmdst ) problem .",
    "the sequential problem has been addressed by some authors ( see for example  @xcite ) .",
    "surprisingly , despite the importance of having a _ mdst _ in arbitrary distributed systems , only few papers have addressed the question of how to design algorithms which construct such spanning trees .",
    "finding and maintaining a _ minimum spanning tree _ ( the ( mst ) problem ) has been extensively studied in the literature ( e.g.  @xcite ) .",
    "more recently , the problem of maintaining a _ small _ diameter was however solved in  @xcite , and the distributed ( mdst ) problem was addressed in  @xcite .      our algorithm _ apsp _ is a generalization of apsp algorithms on graphs with unit weights ( weights with value 1 ) to the case of non - negatively real - weighted graphs . to our knowledge , our mdst finding algorithm",
    "is also the first which _ distributively _ solves the ( mdst ) problem  @xcite . the algorithm _ mdst _ works for named arbitrary network topologies with asynchronous communications .",
    "it achieves an `` efficient '' @xmath40 time complexity and @xmath41 bits communication complexity , where @xmath42 is the largest weight of a channel .",
    "( an @xmath40 time complexity may be considered `` efficient '' , though not optimal , since the construction of a spanning tree costs at least @xmath4 in time ) .",
    "the paper is organized as follows . in section  [ algo ]",
    "we present a high - level description of the protocol _ apsp _ , a formal design of the procedure _ gamma_star _ and the algorithm _",
    "mdst_. section  [ anal ] is devoted to proofs and complexity analysis of the algorithm . finally , concluding remarks are given in section  [ concl ] .",
    "first , we recall in lemma  [ lem : abscenter ] that the ( mdst ) problem for a weighted graph  @xmath1 is ( polynomially ) reducible to the absolute center problem for  @xmath1 . then , we constructively find and compute an absolute center of  @xmath1 by using its apsps routing tables in lemma  [ lem : hackimi ] .    in summary , given a positively weighted graph  @xmath1 , the main steps of our algorithm for the ( mdst ) problem are the following :    1 .   the computation of apsps in @xmath1 ; 2 .   the computation of an absolute center of @xmath1 ( procedure _ gamma_star_@xmath43 in subsection  [ formal ] ) ; 3 .   the construction of a _ mdst _ of @xmath1 , and the transmission of the knowledge of that mdst to each node within the network @xmath1 .",
    "the definition of the eccentricity is generalized as follows .",
    "we view an edge @xmath12 with weight @xmath44 as a continuous interval of length @xmath44 , and for any @xmath45 we allow an insertion of a `` dummy node '' @xmath46 and replace the edge @xmath12 by a pair of edges : @xmath47 with weight @xmath48 and @xmath49 with weight @xmath50 .    according to the definition , the eccentricity @xmath51 of a _ general node _",
    "@xmath46 ( i.e. , either an actual node of @xmath9 , or a dummy node ) is clearly given by @xmath52 .",
    "a node  @xmath53 such that @xmath54 is called _ an absolute center _ of the graph .",
    "recall that @xmath53 always exists in a connected graph and that it is not unique in general .",
    "moreover , an absolute center of @xmath1 is usually one of the dummy nodes ( see fig .  [",
    "fig : mdst ] ) .",
    "similarly , the definition of @xmath33 is also generalized to account for the dummy nodes . finding a _ mdst _",
    "actually reduces to searching for an absolute center  @xmath53 of  @xmath1 : the spt rooted at  @xmath53 is a _ mdst _ of  @xmath1 .",
    "such is the purpose of the following lemma  [ lem : abscenter ] .    _",
    "_ [ lem : abscenter ] given a weighted graph g , the ( mdst ) problem for g is ( polynomially ) reducible to the problem of finding an absolute center of g.      the idea of computing absolute @xmath55-centers was first introduced by hakimi , see for example  @xcite . here",
    "we address the computation of an absolute 1-center . according to the results in  @xcite , we need the following lemma ( called hakimi s method ) to find an absolute center of  @xmath1 .",
    "[ lem : hackimi ] let @xmath8 be a weighted graph . for each edge @xmath56 ,",
    "let  @xmath57 be the set of all the general nodes of g which achieve a minimal eccentricity for  @xmath11 .",
    "a node achieving the minimal eccentricity among all nodes in @xmath58 is an absolute center . finding a minimum absolute center of g",
    "is thus achieved in polynomial time .",
    "( the proof is constructive . )    _ ( i ) _ for each edge @xmath16 , let @xmath59 .",
    "since the distance @xmath60 is the length of a path @xmath61 $ ] or a path @xmath62 $ ] , @xmath63 if we plot @xmath64 and @xmath65 in cartesian coordinates for fixed @xmath66 , the real - valued functions @xmath67 and @xmath68 ( separately depending on @xmath48 in the range @xmath69 $ ] ) are represented by two line segments @xmath70 and @xmath71 , with slope @xmath72 and @xmath73 , respectively . for a given @xmath66 ,",
    "the smallest of the two terms @xmath67 and @xmath68 in  ( [ eq : sep ] ) define a piecewise linear function @xmath74 made of @xmath70 and @xmath71 .",
    "let @xmath75 be the _ upper boundary _",
    "( @xmath76 $ ] ) of all the above @xmath77 ( @xmath78 ) .",
    "@xmath75 is a curve made up of piecewise linear segments , which passes through several local minima ( see fig .  [",
    "fig : bound ] ) .",
    "a point @xmath46 achieving the smallest minimal value ( i.e. the global minimum ) of @xmath79 is an absolute center  @xmath80 of the edge  @xmath11 .    from the definition of @xmath80 , @xmath81 ; and",
    "@xmath53 achieves the minimal eccentricity .",
    "therefore , an absolute center @xmath53 of the graph is found at any point where the minimum of all @xmath82s is attained .    by lemma  [ lem : hackimi ] , we may consider this method from an algorithmic viewpoint .",
    "for each @xmath83 , let @xmath84 now , a pair ( @xmath85@xmath86 ) is said to _ dominate _ a pair @xmath87 iff @xmath88 and @xmath89 ; namely , the function @xmath90 defined by ( @xmath85@xmath86 ) is over @xmath77 defined by @xmath87 .",
    "any such pair @xmath87 will be ignored when it is dominated by another pair ( @xmath85@xmath86 ) .",
    "the local minima of the upper boundary @xmath79 ( numbered from 1 to 3 in figure  [ fig : bound ] ) are located at the intersection of the segments @xmath91 and @xmath92 , when all dominated pairs are removed .",
    "sorting the set @xmath93 in descending order , with respect to the first term of each remaining pair @xmath87 , yields the list @xmath94 consisting of all such ordered dominating pairs .",
    "hence , the smallest minimum of @xmath75 for a given edge @xmath11 clearly provides an absolute center  @xmath80 ( see the procedure _",
    "gamma_star_@xmath43 in subsection  [ formal ] ) . by lemma  [ lem : hackimi ] ,",
    "once all the @xmath80s are computed , we can obtain an absolute center  @xmath53 of the graph  @xmath1 .",
    "last , by lemma  [ lem : abscenter ] , finding a _ mdst _ of @xmath1 reduces to the problem of computing  @xmath53 .      in  [ subsubsect : abscenter ] , we consider the distances @xmath95 and @xmath96 , for all @xmath97 and for each edge @xmath83 .",
    "the latter distances must be computed by a distributed ( process terminating ) routing algorithm ; the protocol _ apsp _",
    "is designed for that purpose in subsection  [ formal ] .      at the end of the protocol _",
    ", every node knows the node  @xmath98 with the smallest _",
    "i d _ and a shortest path in @xmath1 leading to @xmath98 .",
    "now , consider the collection of all paths @xmath99 $ ] ( computed by _ apsp _ ) , which start from a node @xmath100 and end at node @xmath98 .",
    "this collection forms a tree rooted at node @xmath98 and , since it is an spt of @xmath1 , the information is exchanged `` optimally '' in the spt @xmath101 , the information is transmitted _",
    "`` optimally '' _ in terms of time and messages , in the sense that each edge weight may be regarded as the message transmission delay of a channel . ] .",
    "hence , the number of messages needed to search an extremum in the tree @xmath101 is at most @xmath40 ( with message size @xmath102 ) .    when the computation of an absolute center @xmath53 of @xmath1 is completed , the endpoint of @xmath53 s edge having the smallest _",
    "i d _ sends a message to @xmath98 carrying the _ i d _ of  @xmath53 . upon receipt of the message , @xmath98 forwards the information all over @xmath101 ( adding the same cost in time and messages ) .",
    "therefore each node of @xmath1 knows a route to  @xmath53 , and the mdst is built as a common knowledge for all nodes .",
    "the distributed algorithm _ mdst _ finds a mdst of an input weighted graph @xmath0 by computing an absolute center of  @xmath1 .",
    "the algorithm is described from a node point of view .",
    "the algorithm assumes that each node  @xmath22 performs the following steps .",
    ": :    node @xmath22 participates in the computation of the apsp .",
    "this computation gives the diameter and the radius of the graph    @xmath1 .",
    "moreover it also gives @xmath98 , the    minimum node identity in the graph .",
    "( see  [ subsubsect : constmdst ] . )",
    "steps 2 & 3 .",
    ": :    an adjacent edge selection procedure is implemented by discarding    heavy edges .",
    "the computation of the local minimum is accelerated with    the help of an upper bound test .",
    "note that the variable    @xmath103 , used in the test , is a data structure with four    fields : the best distance @xmath48 from the first edge    end , the upper bound value associed to @xmath48 , the    identities of the first and second edge ends .",
    "( edge ends are ordered    by increasing identities . )",
    "steps 4 , 5 & 6 .",
    ": :    node @xmath22 participates in finding the minimum of all    values  @xmath103 .",
    "step 7 : :    the best @xmath103 is finally computed at the root of the    tree @xmath101 and next , it is broadcast to all    nodes through @xmath104 .    for the sake of clarity , we use abstract record data types ( with dot notation ) .    xxxxxxxxxxxxxxxxxx= elt : * record * + @xmath105 , @xmath106 : edgeweight ; + @xmath107 , @xmath108 : nodeidentity ; + ; + * var *  @xmath103 , @xmath109 : elt ; + @xmath110 , @xmath111 , @xmath48 , @xmath112 : edgeweight ; + @xmath98 : nodeidentity ; + @xmath113 : array of edgeweight ; _ ( *  after step 1 , @xmath114=d(u , v)$ ]  * ) _    1 .   * for all",
    "* @xmath115 compute @xmath116 $ ] , @xmath110 , @xmath111 and @xmath98 ; 2 .",
    "@xmath117 ; 3 .   * while * @xmath118 * do for * each edg @xmath16 s.t .",
    "@xmath119 1 .",
    "@xmath120 _ gamma_star_@xmath43 ; 2 .   * if * @xmath121 * then * @xmath122 ; 4 .   @xmath123 ; 5 .",
    "* wait for reception of * @xmath103 from each child of @xmath22 in @xmath101 * and do * +  if : :    @xmath124  * then *  @xmath123 ; 6 .   * send * @xmath109 to parent in @xmath101 ; 7 .",
    "* if *  @xmath125  * then send * @xmath109 to all its children + else : :    * wait for reception of * @xmath126 from its parent * then    send * @xmath126 to all its children    now we describe the basic procedures used in the algorithm : first the protocol _",
    "apsp _ and next the procedure _ gamma_star_@xmath43 .",
    "we need an algorithm that computes the all - pairs shortest paths in @xmath1 and does process terminate without any structural information ( e.g. , the knowledge an upper bound on  @xmath6 ) .",
    "our algorithm is based on the netchange algorithm ( see the proof in  @xcite ) , the bellman - ford algorithm ( see  @xcite ) and the @xmath48-synchroniser described in  @xcite .",
    "the three latter algorithms process terminate _ iff _ an upper bound on  @xmath6 is known . otherwise , if the processes have no structural information , the above algorithms only `` message terminate '' ( see  @xcite ) .",
    "however , proper distributed termination may be achieved without additional knowledge by using the same technique as designed in  @xcite .",
    "we now shortly describe the algorithm ( from the viewpoint of node @xmath22 , whose _",
    "i d _ is @xmath127 ) .",
    "the protocol _",
    "apsp _ is organized in phases after the first initialization step .",
    "this step starts initializing sets and variables ( @xmath127 is the selected _ i d _ ) : the distance to @xmath127 is set to 0 , while all others distances are set to @xmath128 and the set _ updatenodes _ is initialized to @xmath129 .",
    "next , every phase of the algorithm consists of three steps .",
    ": :    send to all neighbours the _ i d _ of the selected node and its distance    to node @xmath22 .",
    ": :    wait for reception of the same number of messages sent in step 1    minus the number of inactive neighbours ( see next paragraph ) . upon    receipt of a message , update distance tables . if the estimate of the    distance to a node changes , add this node to the set _",
    "updatenodes_. if    an @xmath130*inactive*@xmath131 message is    received from a neighbour , mark it _ inactive_.",
    "when the awaited number    of messages is received , start step  3 .",
    "step 3 . : :    choose an active node from the set _ updatenodes _ with the smallest    distance to @xmath22 and go to step 1 .",
    "if no such node exists    then send an @xmath130*inactive*@xmath131    messsage to each active neighbour ; node @xmath22 becomes an    inactive node .",
    "we need the following rules to make the algorithm process terminate .    1 .",
    "an inactive node forwards updating messages ( if necessary ) to its inactive neighbours .",
    "only one @xmath130*inactive*@xmath131 message is sent from node @xmath22 to a neighbour @xmath23 and this message is the last message ( of protocol _ apsp _ ) from @xmath22 to @xmath23 .",
    "( from the previous rule ) a node terminates only when two @xmath130*inactive*@xmath131 messages are received in each of its adjacent edges ( one from each direction ) .",
    "thus , we designed a new distributed apsp protocol having a good message complexity : @xmath132 .      assume the list @xmath133 ( defined in  [ subsubsect : abscenter ] ) to be already constructed ( e.g. with a heap ) when the routing tables are computed .",
    "for any fixed edge @xmath56 , the next procedure returns a value @xmath80 .",
    "@xmath134 : real ; @xmath135 ; @xmath136 ; + * for *  @xmath137  to  @xmath138  * do *   + @xmath139 ; + @xmath140 ; + * if *  @xmath141  * then *  @xmath142 ; @xmath143 ; + * return*(@xmath48,@xmath144 )    recall that for each edge @xmath16 of @xmath1 with weight @xmath145 and for any given @xmath97 , @xmath85 and @xmath146 are the distances @xmath147 and @xmath148 . moreover , all pairs @xmath149 ( @xmath150 ) are those ordered pairs @xmath87 of the list @xmath133 which are dominating pairs ( see the proof of lemma  [ lem : abscenter ] )",
    "for the purpose of the complexity analysis , let @xmath151 be the largest weight of all edges in @xmath10 : the number of bits in @xmath42 is @xmath152 .",
    "therefore , the weight of an edge requires @xmath153 bits and the weight of any path ( with no cycle ) uses @xmath154 bits .",
    "the following lemma  [ lem : apsp ] gives the complexity of the protocol _",
    "apsp_. next , the theorem  [ theo : mdst ] derives the time and the communication complexity of the algorithm _ mdst _ from lemma  [ lem : apsp ] .",
    "[ lem : apsp ] the all - pairs shortest paths protocol apsp process terminates .",
    "it runs in @xmath40 time and uses @xmath155 messages to compute the routing tables at each node of g. its message size is at most @xmath156 .    the protocol _",
    "apsp _ is almost identical to the well - known distributed bellman - ford shortest - paths algorithm ( except for the notion of active / inactive nodes ) .",
    "the following definitions are taken from  @xcite .",
    "let @xmath157 .",
    "a path @xmath158 $ ] is called an @xmath159-path if for all @xmath160 @xmath161 , @xmath162 .",
    "the @xmath159-distance from @xmath22 to @xmath23 , denoted @xmath163 , is the smallest weight of any @xmath159-path that joins @xmath22 to @xmath23 . when @xmath164 , we write @xmath165 . as a consequence , for all @xmath97 ,    1 .   if @xmath166 , then for all @xmath167 , @xmath168 2",
    "let _ neigh_@xmath169 be the set of neighbours of a node @xmath100 . for any @xmath115 ,    @xmath170    since",
    "the algorithm is built from the definitions  ( [ eq : min ] ) and  ( [ eq : dist ] ) , it does converge to the shortest paths ( see  @xcite ) .",
    "also , since the communication channels are assumed to be fifo ( see  @xcite and subsection  [ ass ] ) , the algorithm process terminates .",
    "the above rules ensure that no message in the protocol _",
    "apsp _ is sent to a terminating node .",
    "our protocol is based on algorithms which are known to converge in @xmath6 phases ( see  @xcite ) . for an active node",
    ", a phase takes at most two time units in an abd network ( see subsection  [ ass ] ) : sending a message to each neighbour and next receiving a message only from all active neighbours ) . to make the protocol _ apsp _",
    "process terminate we need an @xmath130*inactive*@xmath131 message : in the worst case ( for example when @xmath1 is a line ) exchanging @xmath130*inactive*@xmath131 messages between nodes takes @xmath40 time units .",
    "the identity of each node is sent from each active node along each of its adjacent edges .",
    "the number of messages sent from every node @xmath23 is thus @xmath171 , where @xmath172 is the degree of @xmath23 .",
    "inactive nodes simply forward update messages to their inactive neighbours and they do not increase the message complexity . therefore , the message complexity of protocol _ apsp _ is proportional to @xmath173  @xcite .    from the rules of the protocol ( in subsection  [ formal ] ) , adding all @xmath130*inactive*@xmath131 messages makes exactly @xmath174 . finally , the message complexity of protocol _ apsp _ is @xmath155 .",
    "note that each message carries the _ i d _ of the sending node , the _ i d _ of the selected node and the distance between both nodes .",
    "[ theo : mdst ] the algorithm mdst solves the ( mdst ) problem for any distributed positively weighted network g in @xmath40 time .",
    "the communication complexity of mdst is @xmath175 bits , and its space complexity is at most @xmath176 bits ( at each node ) .",
    "the number of bits used for the i d of a node is @xmath177 , and the weight of a path ending at that node is @xmath178 .",
    "the proof derives readily from the previous lemma and subsection  [ subsubsect : constmdst ]",
    "given a positively weighted graph @xmath1 , our algorithm _ mdst _ constructs a _ mdst _",
    "of @xmath1 and distributively forwards the control structure over the named network @xmath1 .",
    "this new algorithm is simple and natural .",
    "it is also time and message efficient : complexity measures are @xmath40 and @xmath155 , respectively , which , in some sense , is `` almost '' the best achievable ( though not optimal ) in a distributed setting .",
    "by contrast , the space complexity seems to be far from satisfactory .",
    "this is a drawback to the very general assumptions used in the algorithm , especially the assumptions on universal ( apsps ) routings in arbitrary network topologies .",
    "for example , algorithm _ mdst _ needs a grand total of @xmath179 bits to store all routing tables in the entire network .",
    "now , it was recently shown that reasonable apsp routing schemes require at least @xmath180 bits  @xcite .",
    "this is only a logarithmic factor away from the space complexity of algorithm _"
  ],
  "abstract_text": [
    "<S> we present a new algorithm , which solves the problem of distributively finding a minimum diameter spanning tree of any ( non - negatively ) real - weighted graph @xmath0 . as an intermediate step </S>",
    "<S> , we use a new , fast , linear - time all - pairs shortest paths distributed algorithm to find an absolute center of @xmath1 . </S>",
    "<S> the resulting distributed algorithm is asynchronous , it works for named asynchronous arbitrary networks and achieves @xmath2 time complexity and @xmath3 message complexity .    _ </S>",
    "<S> keywords _ :  spanning trees ; minimum diameter spanning trees ; shortest paths ; shortest paths trees ; all - pairs shortest paths ; absolute centers . </S>"
  ]
}