{
  "article_text": [
    "the main goal of this paper is to demonstrate that it is possible to check , in polynomial time , if a monomial ideal is the facet ideal of a simplicial tree .",
    "facet ideals were introduced in  @xcite ( generalizing results in  @xcite and  @xcite on edge ideals of graphs ) as a method to study square - free monomial ideals . the idea is to associate a simplicial complex to a square - free monomial ideal , where each facet ( maximal face ) of the complex is the collection of variables that appear in a monomial in the minimal generating set of the ideal ( see definition  [ d : facetideal ] ) .",
    "the ideal will then be called the `` facet ideal '' of this simplicial complex . a special class of simplicial complexes are called `` simplicial trees '' ( definition  [ d : tree ] ) .",
    "the definition of a simplicial tree is a generalization of the concept of a graph - tree .",
    "facet ideals of trees have many properties ; for example , they have normal and cohen - macaulay rees rings  @xcite .",
    "finding such classes of ideals is in general a difficult problem .",
    "simplicial trees also have strong cohen - macaulay properties : their facet ideals are always sequentially cohen - macaulay @xcite , and one can determine under precisely what combinatorial conditions on the simplicial tree the facet ideal is cohen - macaulay @xcite . in",
    "@xcite it is shown that the theory is not restricted to square - free monomial ideals ; via polarization , one can extend many properties of facet ideals to all monomial ideals .",
    "all these properties , and many others , make simplicial trees useful from an algebraic point of view .",
    "but how does one determine if a given square - free monomial ideal is the facet ideal of a simplicial tree ?",
    "in section  [ s : tree - problem ] , we give a characterization of trees that shows this can be done in polynomial time .",
    "this characterization is based on a careful study of the structure of cycles in section  [ s : cycles ] .",
    "the study of simplicial cycles is indeed interesting in its own right . in graph theory , the concepts of a tree and of a cycle are closely linked to each other : a tree is a connected graph that does not contain a cycle , and a cycle is a minimal graph that is not a tree .",
    "generalizing to the simplicial case , we use the latter property , together with the existing definition of a simplicial tree , to define the concept of a simplicial cycle .",
    "we then prove the remarkable fact that a simplicial cycle is either a sequence of facets connected in the shape of a circle , or a cone over such a structure .",
    "this in turns yields an alternative characterization of trees , given in section  [ s : tree - problem ] .",
    "this result enables us to produce a polynomial time algorithm to decide whether a given simplicial complex is a tree . the algorithm itself is introduced in section  [ s : tree - algorithm ] , where the complexity and optimizations are also discussed .",
    "section  [ s : cm - properties ] focuses on the algebraic properties of facet ideals : in section  [ s : grafting ] we discuss a method of adding generators to a square - free monomial ideal ( or facets to the corresponding complex ) so that the resulting facet ideal is cohen - macaulay .",
    "this method is called `` grafting '' a simplicial complex . for simplicial trees ,",
    "being grafted and being cohen - macaulay are equivalent conditions  @xcite .",
    "we then introduce an algorithm that checks whether or not a given simplicial complex is grafted and discuss its complexity .",
    "[ [ implementations . ] ] implementations .",
    "+ + + + + + + + + + + + + + + +    the algorithms described in this paper have first been coded using , the programming language of the  system ( please see http://cocoa.dima.unige.it/ ) .",
    "these prototypical implementations can be downloaded from  @xcite .",
    "much more efficient ( but less user friendly ) c++ implementations have been developed for several versions of algorithm  [ a : tree - algorithm ] using the lib framework ( http://cocoa.dima.unige.it/cocoalib/ ) .",
    "the c++ code is also available at the website @xcite .",
    "we define the basic notions related to facet ideals . more details and examples",
    "can be found in  @xcite .    a _ simplicial complex _ @xmath0 over a finite set of vertices @xmath1 is a collection of subsets of @xmath1 , with the property that if @xmath2 then all subsets of @xmath3 are also in @xmath0 .",
    "an element of @xmath0 is called a _ face _ of @xmath0 , and the maximal faces are called _ facets _ of @xmath0 .    since we are usually only interested in the facets , rather than all faces , of a simplicial complex , it will be convenient to work with the following definition :    a _ facet complex _ over a finite set of vertices @xmath1 is a set @xmath0 of subsets of @xmath1 , such that for all @xmath4 , @xmath5 implies @xmath6 .",
    "each @xmath7 is called a _ facet _ of @xmath0 .",
    "the set of facets of a simplicial complex forms a facet complex .",
    "conversely , the set of subsets of the facets of a facet complex is a simplicial complex .",
    "this defines a one - to - one correspondence between simplicial complexes and facet complexes . in this paper",
    ", we will work primarily with facet complexes .",
    "we define facet ideals , giving a one - to - one correspondence between facet complexes ( or , equivalently , simplicial complexes ) and square - free monomial ideals .",
    "[ d : facetideal ]     * let @xmath0 be a facet complex over a vertex set @xmath8 .",
    "let @xmath9 be a field , and let @xmath10 $ ] be the polynomial ring with indeterminates @xmath11 .",
    "the _ facet ideal of _ @xmath0 is defined to be the ideal of @xmath12 generated by all the square - free monomials @xmath13 , where @xmath14 is a facet of @xmath0 .",
    "we denote the facet ideal of @xmath0 by @xmath15 . *",
    "let @xmath16 be an ideal in the polynomial ring @xmath17 $ ] , where @xmath9 is a field and @xmath18 are square - free monomials in @xmath11 that form a minimal set of generators for @xmath19 .",
    "the _ facet complex of _ @xmath19 is defined to be @xmath20 , where for each @xmath21 , @xmath22 .    from now on",
    ", we often use @xmath11 to denote both the vertices of @xmath0 and the variables appearing in @xmath15 .",
    "we also sometimes ease the notation by denoting facets by their corresponding monomials ; for example , we write @xmath23 for the facet @xmath24 .    we now generalize some notions from graph theory to facet complexes .",
    "note that a graph can be regarded as a special kind of facet complex , namely one in which each facet has cardinality 2 .",
    "[ def : connected ] let @xmath0 be a facet complex . a sequence of facets @xmath25 is called a _ path _ if for all @xmath26 , @xmath27 .",
    "we say that two facets @xmath3 and @xmath28 are _ connected _ in @xmath0 if there exists a path @xmath25 with @xmath29 and @xmath30 .",
    "finally , we say that @xmath0 is _ connected _ if every pair of facets is connected .",
    "if @xmath3 , @xmath28 and @xmath31 are facets of @xmath0 , @xmath32 means that @xmath33 .",
    "the relation @xmath34 defines a preorder ( reflexive and transitive relation ) on the facet set of @xmath0 .",
    "[ d : leaf ] let @xmath3 be a facet of a facet complex @xmath0 .",
    "then @xmath3 is called a _ leaf _ of @xmath0 if either @xmath3 is the only facet of @xmath0 , or else there exists some @xmath35 such that for all @xmath36 , we have @xmath37 . the facet @xmath28 above is called a _ joint _ of the leaf @xmath3 if @xmath38 .",
    "it follows immediately from the definition that every leaf @xmath3 contains at least one _ free vertex _ , i.e. , a vertex that belongs to no other facet .",
    "[ example11 ] in the facet complex @xmath39 , @xmath23 and @xmath40 are leaves , but @xmath41 is not a leaf .",
    "similarly , in @xmath42 , the only leaves are @xmath43 and @xmath44 .",
    "@xmath45    [ d : tree ] a facet complex @xmath0 is a _ forest _ if every nonempty subset of @xmath0 has a leaf .",
    "a connected forest is called a _ tree _ ( or sometimes a _ simplicial tree _ to distinguish it from a tree in the graph - theoretic sense ) .",
    "it is clear that any facet complex of cardinality one or two is a forest .",
    "when @xmath0 is a graph , the notion of a simplicial tree coincides with that of a graph - theoretic tree .",
    "[ e : free - example ] the facet complexes in example  [ example11 ] are trees .",
    "the facet complex pictured below has three leaves @xmath46 , @xmath47 and @xmath48 ; however , it is not a tree , because if one removes the facet @xmath49 , the remaining facet complex has no leaf .",
    "the following property is proved in ( * ? ? ? * lemma 4.1 ) :    [ l : twoleaves ] every tree with two or more facets has at least two leaves .",
    "in this section , we define a simplicial cycle as a minimal complex without leaf .",
    "this in turns characterizes a simplicial tree as a connected cycle - free facet complex .",
    "we further show that cycles possess a particularly simple structure : each cycle is either equivalent to a `` circle '' of facets with disjoint intersections , or to a cone over such a circle .",
    "[ d : cycle ] a nonempty facet complex @xmath0 is called a _ cycle _",
    "if @xmath0 has no leaf but every nonempty proper subset of @xmath0 has a leaf .",
    "equivalently , @xmath0 is a cycle if @xmath0 is not a forest , but every proper subset of @xmath0 is a forest .",
    "if @xmath0 is a graph , definition  [ d : cycle ] coincides with the graph - theoretic definition of a cycle .",
    "the next two remarks are immediate consequences of the definitions of cycle and forest :    a cycle is connected .",
    "a facet complex is a forest if and only if it does not contain a cycle .    in the remainder of this section",
    ", we provide a complete characterization of the structure of cycles .",
    "[ d : strong - neighbor ] let @xmath0 be a facet complex and @xmath4 .",
    "we say that @xmath3 and @xmath28 are _ strong neighbors _ , written @xmath50 , if @xmath51 and for all @xmath52 , @xmath53 implies @xmath54 or @xmath55 .",
    "the relation @xmath56 is symmetric , i.e. , @xmath50 if and only if @xmath57 . note that if @xmath0 has more than two facets , then @xmath50 implies that @xmath58 .    for the facet complex @xmath59 in example  [ example11 ] , @xmath60 , as their intersection @xmath61 lies in the facet @xmath23 .",
    "however , @xmath62 and similarly @xmath63 .",
    "[ r : strong - sub ] suppose @xmath0 is a facet complex , and @xmath64 .",
    "let @xmath65 .",
    "if @xmath50 , then @xmath66 .",
    "the converse is not in general true .",
    "[ r : strong - leq ] we have @xmath50 if and only if @xmath28 is strictly maximal with respect to @xmath67 on @xmath68 , i.e. , for all @xmath69 , @xmath70 implies @xmath71 .",
    "this is a simple restatement of the definition .",
    "it turns out that a cycle can be described as a sequence of strong neighbors .",
    "the following lemma follows directly from definition  [ d : strong - neighbor ] .",
    "[ l : strong - double ] if @xmath0 is a facet complex with distinct facets @xmath72 such that @xmath73 and @xmath74 , then @xmath3 is not a leaf of @xmath0 .",
    "if @xmath3 is a leaf , there exists a facet @xmath75 such that @xmath76 and @xmath77 , which by remark  [ r : strong - leq ] implies that @xmath78 , a contradiction .",
    "[ c : cycle ] let @xmath0 be a facet complex , and let @xmath25 be distinct facets with @xmath79 , such that @xmath80 .",
    "then @xmath81 has no leaf .",
    "this follows directly from remark  [ r : strong - sub ] , and lemma  [ l : strong - double ] .",
    "[ l : subleaf ] suppose @xmath0 is a facet complex and @xmath82 . if @xmath3 is a leaf of @xmath83 , but not a leaf of @xmath0 , then @xmath50 .",
    "suppose @xmath31 is some facet such that @xmath53 , but @xmath69 and @xmath84 . since @xmath3 is a leaf for @xmath83 , there exists a facet @xmath85 such that @xmath86 for all @xmath87 , and so @xmath88 .",
    "but now we have @xmath89 , which implies that @xmath3 is a leaf of @xmath0 , a contradiction .",
    "[ p : cycle ] suppose @xmath0 is a cycle , and let @xmath90 .",
    "then @xmath91 , and the facets of @xmath0 can be enumerated as @xmath92 in such a way that @xmath93 and @xmath94 in all other cases , so that each facet is a strong neighbor of precisely two other facets .    first note that since @xmath0 is not a forest , @xmath91 .",
    "we begin by showing that each facet has at least two distinct strong neighbors .",
    "let @xmath7 be a facet . since @xmath0 is a cycle",
    ", @xmath95 is a tree .",
    "the subset @xmath95 also has cardinality at least two , and therefore has two distinct leaves , say @xmath28 and @xmath31 , by lemma  [ l : twoleaves ] .",
    "since neither @xmath28 nor @xmath31 are leaves of @xmath0 ( because @xmath0 is a cycle ) , we have @xmath50 and @xmath96 by lemma  [ l : subleaf ] .",
    "now we can simply choose @xmath46 arbitrarily , then choose @xmath97 such that @xmath98 , then for every @xmath99 choose @xmath100 such that @xmath101 and @xmath102 . since @xmath0 is finite , there will be some smallest @xmath21 such that @xmath103 for some @xmath104 .",
    "then @xmath105 has no leaf by corollary  [ c : cycle ] , so @xmath106 .",
    "it follows that @xmath107 and @xmath108 .",
    "finally , suppose that @xmath109 for some @xmath110 , where @xmath111 or @xmath112 .",
    "then @xmath113 has no leaf by corollary  [ c : cycle ] , contradicting the fact that it is a tree .",
    "the converse of proposition  [ p : cycle ] is not true .",
    "[ e : cycle - is ] the facet complex @xmath0 is not a cycle , as its proper subset @xmath59 ( which is indeed a cycle ) has no leaf .",
    "however , we have @xmath114 , and these are the only pairs of strong neighbors in @xmath0 .    @xmath115    [ l : cycle - to - tree ] if @xmath0 is a cycle , written as @xmath116 , then for each @xmath21 , @xmath117 is a tree with exactly two leaves @xmath118 and @xmath119 , with joints @xmath120 and @xmath121 , respectively .    we know that @xmath122 is a tree , so it has at least two leaves",
    "by lemma  [ l : strong - double ] @xmath118 and @xmath119 are the only choices . by remark  [ r : strong - leq ] @xmath120 is the only possible joint for @xmath118 , and @xmath121 is the only possible joint for @xmath119 .",
    "the following lemma will be fundamental for the classification of cycles .",
    "[ lem : cycle - fund ] let @xmath0 be a cycle with facets @xmath123 . if @xmath124 , then @xmath125 for all @xmath126 .",
    "we first prove the claim in the special case where @xmath127 .",
    "indeed , since @xmath3 is a strong neighbor of exactly two facets , there must be some @xmath128 such that @xmath129 .",
    "then lemma  [ l : cycle - to - tree ] implies that @xmath31 is a joint of @xmath3 in the tree @xmath130 , and therefore @xmath125 , or equivalently , @xmath131 .",
    "now consider the general case . by proposition  [ p :",
    "cycle ] , the facets of @xmath0 can be enumerated as @xmath132 .",
    "assume , without loss of generality , that @xmath133 and @xmath134 , where @xmath135 .",
    "by repeated applications of the special case above , we have @xmath136 in the other direction , we similarly have @xmath137 therefore , @xmath138 for @xmath139 .",
    "[ l : cone ] let @xmath0 be a facet complex , and let @xmath140 then @xmath59 is a facet complex .",
    "moreover , @xmath0 is a cycle if and only if @xmath59 is a cycle .    for each @xmath141 , let @xmath142 .",
    "since @xmath0 is a facet complex , we have @xmath143 for any two distinct facets @xmath4 , which clearly implies @xmath144 .",
    "so @xmath59 is a facet complex .",
    "let @xmath145 be any subset of @xmath0 , and let @xmath146 be the corresponding subset of @xmath59 . then for any triple of facets @xmath147 , we have @xmath148 .",
    "therefore , @xmath145 has a leaf if and only if @xmath149 has a leaf .",
    "it follows that @xmath0 is a cycle if and only if @xmath59 is a cycle .",
    "[ t : cycle - structure ] let @xmath0 be a facet complex . then @xmath0 is a cycle if and only if @xmath0 can be written as a sequence of strong neighbors @xmath150 such that @xmath91 , and for all @xmath151 @xmath152    let @xmath0 be a cycle . then by proposition",
    "[ p : cycle ] and lemma  [ lem : cycle - fund ] , @xmath0 can be written as a sequence of strong neighbors with the desired properties .",
    "conversely , suppose that @xmath0 is written as a sequence of strong neighbors @xmath153 such that @xmath154 if @xmath155 ( mod @xmath156 ) .",
    "by lemma  [ l : cone ] we can without loss of generality assume that @xmath157 .    by corollary",
    "[ c : cycle ] , @xmath0 has no leaf .",
    "suppose @xmath59 is any nonempty proper subset of @xmath0 .",
    "we need to show that @xmath59 has a leaf .",
    "suppose @xmath158 and @xmath159 .",
    "there are two cases :    1 .",
    "@xmath160 . in this case , since @xmath161 for all @xmath162 , @xmath100 is a leaf .",
    "2 .   @xmath163 . in this case ,",
    "@xmath164 for all @xmath165 , and so @xmath100 is again a leaf , this time with @xmath118 as a joint .",
    "so @xmath0 is a cycle and we are done .",
    "the implication of theorem  [ t : cycle - structure ] is that a simplicial cycle has a very intuitive structure : it is either a sequence of facets joined together to form a circle in such a way that all intersections are pairwise disjoint ( this is the case where the intersection of all the facets is the empty set in theorem  [ t : cycle - structure ] ) , or it is a cone over such a structure ( lemma  [ l : cone ] ) .",
    "[ e : cycle - structure ] the facet complex @xmath0 is a cycle .",
    "the facet complex @xmath145 is a cycle and is also a cone over the cycle @xmath149 .",
    "we now consider the problem of deciding whether or not a given facet complex is a tree . we refer to this problem as the _ decision problem for simplicial trees_.    note that the nave algorithm ( namely , checking whether every non - empty subset has a leaf ) is extremely inefficient : for a facet complex of @xmath156 facets",
    ", there are @xmath167 subsets to check .",
    "also note that the definition of a tree is not inductive in any obvious way : for instance , attaching a single leaf to a tree need not yield a tree , as example  [ e : free - example ] shows .",
    "this seems to rule out an easy recursive algorithm .",
    "nevertheless , we demonstrate that the decision problem for simplicial trees can be solved efficiently .",
    "this is done via a characterization of trees given in this section .",
    "let @xmath0 be a facet complex , and let @xmath1 be a set of vertices .",
    "we say that a sequence of facets @xmath168 is a _ path outside @xmath1 _ in @xmath0 if for all @xmath26 , @xmath169 .",
    "we say that two facets @xmath4 are _ connected outside @xmath1 _ in @xmath0 if there exists a path @xmath170 outside @xmath1 in @xmath0 such that @xmath171 and @xmath172 .",
    "note that in case @xmath173 , this coincides with the definition of connectedness from definition  [ def : connected ] .",
    "if @xmath72 are three distinct facets of @xmath0 , then we define @xmath174 to be the following subset of @xmath0 : @xmath175    let @xmath0 be a facet complex .",
    "we say a triple of facets @xmath176 satisfies the _ triple condition _ if @xmath177 and @xmath178 , and if @xmath179 and @xmath180 are connected outside @xmath3 in the facet complex @xmath174 .",
    "we note that the definitions of @xmath174 and the triple condition have changed from an earlier version of this article @xcite ; they have been simplified .",
    "consider @xmath0 in example  [ e : cycle - is ] .",
    "then the triple @xmath181 satisfies the triple condition .",
    "this is because @xmath182 and @xmath183 .",
    "moreover @xmath184 , and a path connecting @xmath47 and @xmath49 outside @xmath46 is @xmath185 .",
    "however , @xmath186 does not satisfy the triple condition , since @xmath187 ( and @xmath188 ) .",
    "also @xmath189 , and @xmath47 and @xmath48 are not connected outside @xmath28 .",
    "[ p : triple - cycle ] let @xmath0 be a facet complex .",
    "a triple @xmath176 satisfies the triple condition if and only if there exists a cycle @xmath64 such that @xmath190 and @xmath191 .",
    "suppose @xmath176 satisfies the triple condition . then by definition , @xmath192 and @xmath193 .",
    "choose a minimal ( with respect to inclusion ) path @xmath170 outside @xmath3 that connects @xmath194 to @xmath195 .",
    "note that minimality implies that for @xmath196 , @xmath197 .",
    "we claim that @xmath198 is a cycle with @xmath199    1 .",
    "@xmath200 and @xmath201 .",
    "+ if @xmath202 for some @xmath21 , @xmath203 , then since @xmath204 , we have @xmath205 .",
    "this implies that @xmath206 , a contradiction .",
    "so @xmath200 , and similarly @xmath201 2 .",
    "@xmath207 for @xmath26 .",
    "+ since @xmath208 , we have that @xmath209 . by minimality of the path , if @xmath210 for some @xmath196 , then @xmath211 , a contradiction .",
    "the case @xmath104 is similar .",
    "this shows ( [ e : chain ] ) .",
    "to finish the proof that @xmath59 is a cycle , we must show that it meets the remaining condition of theorem  [ t : cycle - structure ] .",
    "if @xmath212 , there is nothing to show ; assume therefore that @xmath91 . by definition of @xmath174 ,",
    "@xmath213 for @xmath214 , and so @xmath215 . also , if @xmath196 , then @xmath216 by minimality of the path , therefore @xmath217 so @xmath59 is a cycle .",
    "conversely , suppose that @xmath59 is a cycle containing @xmath3 , @xmath179 and @xmath180 , written as @xmath218 , where @xmath219 .    from the strong neighbor relations it follows that @xmath220 and @xmath193 .",
    "it also follows that the above sequence of strong neighbors provides a path from @xmath179 to @xmath180 outside @xmath3 .",
    "we only need to show that for @xmath221 , @xmath222 .    if @xmath223 we are done .",
    "so assume that @xmath224 .",
    "we know @xmath225 , and so by lemma  [ lem : cycle - fund ] , @xmath226 . on the other hand , since @xmath227 , lemma  [ lem : cycle - fund ] implies the opposite inclusion @xmath228 .",
    "it therefore follows that @xmath229 and we are done .",
    "an immediate implication of proposition  [ p : triple - cycle ] is an ( algorithmically ) efficient criterion to determine whether or not a facet complex is a tree .",
    "[ t : tree - char ] let @xmath0 be a connected facet complex .",
    "then @xmath0 is a tree if and only if no triple of facets in @xmath0 satisfies the triple condition .",
    "by theorem  [ t : tree - char ] , to check if a facet complex @xmath230 is a tree , we only need to check the triple condition for all triples of elements of @xmath0 .",
    "the checks themselves are straightforward .",
    "since the triple condition for @xmath231 is clearly unchanged if one switches @xmath28 and @xmath232 , we can limit triple checking to the elements of the set @xmath233 .",
    "the procedures for the basic steps follow immediately from the earlier definitions .",
    "[ a : tree - algorithm ]   + input : a connected facet complex @xmath230 with @xmath156 vertices",
    ". + output : * true * if @xmath0 is a tree , * false * otherwise .    1 .   for each triple @xmath234 1 .",
    "if @xmath235 or @xmath236 , continue with the next triple .",
    "2 .   build @xmath237 .",
    "3 .   if @xmath28 and @xmath232 are connected outside @xmath3 in @xmath237 , return * false*. 2 .",
    "return * true*.    the correctness of this algorithm is an immediate consequence of theorem  [ t : tree - char ] .",
    "the algorithm uses very little memory ; the input @xmath0 requires @xmath238 bits , and @xmath239 requires @xmath240 bits .",
    "the memory required to perform the connectedness check and to store the various counters is negligible .",
    "thus , memory locality is good , and the computations can generally take place in the cache .    in the process of checking the triple condition for a triple @xmath231 that is part of a cycle , we build a connection path outside @xmath3 . clearly , any such path can be reduced to a _ minimal _ connection path @xmath241 outside @xmath3 for @xmath242 , and therefore , by the proof of proposition  [ p : triple - cycle ] , @xmath243 forms a cycle .",
    "therefore , an easy modification of algorithm  [ a : tree - algorithm ] allow us to produce the set of all the facets @xmath7 that are part of some cycle , and a cycle @xmath244 for each of them .      for each triple",
    "it is trivial to see that steps ( a ) and ( b ) can be performed with cost @xmath245 and @xmath246 respectively . for step ( c ) ,",
    "the following holds .",
    "[ l : conn - check ] let @xmath0 be a facet complex with @xmath240 facets over @xmath156 variables such that @xmath247 are distinct facets of @xmath0 .",
    "the connectedness outside @xmath3 of @xmath248 can be determined with time cost @xmath246 .",
    "first of all we substitute @xmath0 with the set @xmath249 .",
    "we then define @xmath250 equivalence relations @xmath251 on the set @xmath252 .",
    "@xmath253 is the identity relation , i.e. , each equivalence class is a singleton . for each @xmath139 , consider the vertex @xmath254 and the set @xmath255 .",
    "let @xmath256 be the smallest equivalence relation such that @xmath257 and such that for all @xmath258 , @xmath259 .",
    "then facets @xmath100 and @xmath260 are connected if and only if @xmath261 . with a suitable data structure for representing equivalence relations , the complexity of the procedure above is @xmath246 .",
    "consequently , step ( c ) of the tree decision algorithm can be performed at cost @xmath246 .",
    "thus , the total complexity of the tree decision algorithm is as follows : in the worst case we have to check @xmath262 triples .",
    "the complexity of the steps ( a)(c ) is @xmath246 and hence the total complexity of the algorithm is @xmath263 .",
    "[ e : triple ] consider the facet complex @xmath264 .",
    "we have to check @xmath265 triples .",
    "we start with the triple @xmath266 .",
    "* @xmath267 since @xmath268 .",
    "similarly @xmath269 .",
    "* @xmath270 and @xmath271 are connected outside @xmath272 in the complex @xmath273 .",
    "we have hence discovered that @xmath0 is not a tree .",
    "a more unlucky choice of facets could have brought about the checking of @xmath274 useless triples before the discovery that @xmath0 is not a tree , the other two useful triples being @xmath275 and @xmath276 .",
    "[ e : bigger - triple ] some statistics for a bigger random example .",
    "consider the facet complex @xmath277 , @xmath278 , @xmath279 , @xmath280 , @xmath281 , @xmath282 , @xmath283 , @xmath284 , @xmath285 , @xmath286 , @xmath287 , @xmath288 , @xmath289 , @xmath290 , @xmath291 , @xmath292 , @xmath293 , @xmath294 , @xmath295 , @xmath296 .",
    "we discover that it is not a tree after checking @xmath297 facets ; we performed the connectedness check only once .",
    "if one checks all @xmath298 triples , one finds that @xmath299 of them require a connectedness check , and @xmath300 of them reveal that @xmath0 is not a tree .",
    "[ line400 ] the facet complex @xmath301 is trivially a tree .",
    "checking this by a direct application of algorithm  [ a : tree - algorithm ] requires dealing with @xmath302 triples , and takes about @xmath303 seconds on an athlon 2600 + machine for our c++ implementation .",
    "all the timings in the remainder of this paper refer to this machine .",
    "the runtime of algorithm  [ a : tree - algorithm ] can be improved by introducing some optimizations .",
    "first , note that if @xmath3 is a facet such that no triple @xmath231 satisfies the triple condition , then by proposition  [ p : triple - cycle ] , @xmath3 can not be part of any cycle of @xmath0 .",
    "therefore , @xmath3 can be removed from @xmath0 , reducing the number of subsequent triple checks .",
    "we refer to this optimization as the _ removal of useless facets_.    we check the tree @xmath301 of example  [ line400 ] with a version of algorithm  [ a : tree - algorithm ] with removal of useless facets .",
    "this requires checking @xmath304 triples and takes about @xmath305 seconds .",
    "an important special case of a `` useless facet '' is a reducible leaf , as captured in the following definition :    [ d : reducible - leaf ] a facet @xmath3 of a facet complex @xmath0 is called a _ reducible leaf _ if for all @xmath306 , either @xmath235 or @xmath236 .",
    "a reducible leaf is called a `` good leaf '' by zheng  @xcite .",
    "[ r : reducible ] the facet @xmath3 is a reducible leaf of @xmath0 if and only if @xmath3 is a leaf of every @xmath64 with @xmath307 .",
    "the remark immediately implies that a reducible leaf can not be part of a cycle .",
    "thus , it can be removed from @xmath0 , and the algorithm can then be recursively applied to @xmath68 .",
    "we were not able to find a tree without a reducible leaf ; in fact , zheng  @xcite conjectured that this is always the case .",
    "checking whether a given facet @xmath3 is a reducible leaf requires ordering all facets with respect to @xmath34 , which takes @xmath308 steps . a reducible leaf",
    "can thus be found in time @xmath309 .",
    "therefore , if zheng s conjecture is true , the tree problem can be decided in time @xmath310 .",
    "but even if the conjecture is not true , removing all reducible leaves at the beginning of algorithm  [ a : tree - algorithm ] is still a worthwhile optimization .",
    "let @xmath0 be a facet complex with @xmath240 facets .",
    "if every @xmath141 intersects a substantial ( @xmath311 ) number of facets , then the number of cycles is probably high and our algorithm is usually able to detect one of them easily .",
    "if this does not happen , we can exploit the `` sparseness '' of the facet complex in our algorithm .    for the remainder of this subsection",
    ", @xmath0 will be a facet complex with @xmath240 facets over @xmath156 vertices such that the maximum number of neighbors of a facet @xmath7 is @xmath312 and the maximum number of vertices of a facet @xmath7 is @xmath313 . note that trees are the hard cases for our algorithm , since all the triples have to be checked . also note that , if @xmath0 is a tree , then @xmath314 .",
    "this follows by induction on @xmath240 , from the fact that every leaf contains at least one free vertex .      to check",
    "if @xmath0 is a tree it is sufficient to check the connected triples only . for each facet",
    "@xmath3 ( @xmath240 facets ) : first construct the set of all facets @xmath28 connected to @xmath3 ( called the _ connection set _ , at cost @xmath315 ) , then for all @xmath242 in the set ( @xmath316 pairs ) perform the triple check on @xmath231 ( cost @xmath246 per triple ) .",
    "we call this optimization of algorithm  [ a : tree - algorithm ] the _ connection set algorithm_. the total cost is @xmath317 .",
    "the space required to construct the connection sets is @xmath318 , hence negligible .",
    "if the complex is not sparse ( @xmath319 , @xmath320 ) , the complexity is the same as algorithm  [ a : tree - algorithm ] .",
    "however , for sparse examples , this optimization is clearly worthwhile :    we check the tree @xmath301 of example  [ line400 ] with the algorithm detailed above .",
    "we deal with @xmath321 triples and spend @xmath322 seconds .",
    "the facet complex @xmath323 is a tree but not sparse .",
    "tree checking with the connection set algorithm is still quite efficient ; it requires dealing with @xmath324 triples , and takes about @xmath325 seconds . without any optimization ,",
    "the number of triples to check is @xmath326 and the time spent by the algorithm is @xmath327 days .",
    "the connectedness relation for a facet complex @xmath0 can be represented by a graph through an incidence matrix .",
    "this matrix can be built and used during the tree checking algorithm . since creating incidence matrices from a complex",
    "is a relatively expensive operation , we build them in steps , exploiting at every step the relations already computed .",
    "we compute the connectedness relation for @xmath0 at cost @xmath328 .",
    "then for every facet @xmath7 we compute the `` connectedness outside @xmath3 '' relation for @xmath0 , at cost @xmath329 .",
    "then for every triple @xmath231 ( there are @xmath316 of them ) we compute the `` connectedness outside @xmath3 '' relation for @xmath237 at cost @xmath330 . using this additional structure , we do not actually need to build @xmath237 , and we can check connectedness outside @xmath3 in @xmath237 using the connectedness relations at cost @xmath331 .",
    "we call this optimization of algorithm  [ a : tree - algorithm ] the _ incidence matrix algorithm_.    the total complexity for this algorithm is hence @xmath332 .",
    "if @xmath0 is not sparse ( @xmath320 , @xmath319 ) , then this algorithm has roughly the same complexity as algorithm  [ a : tree - algorithm ] .    on the other hand , if @xmath333 , which is a reasonable assumption for sparseness , then the complexity of the incidence matrix algorithm is @xmath334 , while the complexity of the connection set algorithm is @xmath335 and that of algorithm  [ a : tree - algorithm ] is @xmath336 .",
    "we now study facet ideals from a more algebraic point of view . in particular , we are interested in ways to determine whether a given facet complex @xmath0 is cohen - macaulay , meaning whether @xmath337 is a cohen - macaulay ring . we first need to introduce some new terminology .",
    "let @xmath0 be a facet complex .",
    "vertex cover _ for @xmath0 is a set @xmath338 of vertices of @xmath0 , such that @xmath339 for every facet @xmath3 .",
    "the smallest cardinality of a vertex cover of @xmath0 is called the _ vertex covering number _ of @xmath0 and is denoted by @xmath340 .",
    "a vertex cover @xmath338 is _ minimal _ if no proper subset of @xmath338 is a vertex cover .",
    "a facet complex @xmath0 is _ unmixed _ if all of its minimal vertex covers have the same cardinality .",
    "consider the two facet complexes in example  [ example11 ] .",
    "we have @xmath341 . also , @xmath0 is unmixed as its minimal vertex covers @xmath342 , @xmath343 , @xmath344 , @xmath345 and @xmath346 all have cardinality equal to two .",
    "we further have @xmath347 , but @xmath59 is not unmixed , because @xmath348 and @xmath349 are minimal vertex covers of different cardinalities .",
    "1 .   @xmath351 and @xmath352 .",
    "an ideal @xmath353 of @xmath12 is a minimal prime of @xmath19 if and only if the set @xmath354 is a minimal vertex cover for @xmath0 .",
    "if @xmath17/{{\\mathcal{f}}}({\\delta})$ ] is cohen - macaulay , then @xmath0 is unmixed .",
    "note that the definition is recursive , since graftedness of @xmath0 is defined in terms of graftedness of @xmath363 .",
    "also note that a facet complex that consists of only one facet or several pairwise disjoint facets is grafted , as it can be considered as a grafting of the empty facet complex .",
    "it is easy to check that conditions ( i ) to ( v ) above are satisfied in this case .",
    "it is also clear that the union of two or more grafted facet complexes is itself grafted .",
    "( 385,220 ) ( 0,180)@xmath365 ( 40,155 ) ( 150,180)@xmath366 ( 220,180)@xmath367 ( 250,150 ) ( 100,130)@xmath368 ( 110,105)_graft _ ( 0,30)@xmath369 ( 40,0 ) ( 180,130)@xmath370 ( 220,105)_graft _ ( 220,30)@xmath371 ( 250,10 )                a direct application of definition  [ grafting ] is not very convenient for checking whether a given facet complex @xmath0 is grafted , since at each step of the recursion , one potentially needs to check condition ( v ) for several of the @xmath362 , and this leads to a worst - case exponential algorithm . in order to arrive at a more efficient algorithm , we characterize graftedness as follows :    [ l : grafted - equivalent ] a facet complex @xmath0 is grafted if and only if ( 1 ) for each vertex @xmath313 , there exists a unique leaf @xmath3 such that @xmath372 , and ( 2 ) all leaves of @xmath0 are reducible .",
    "first , assume that @xmath0 is grafted .",
    "condition ( 1 ) follows from ( i ) , ( ii ) and ( iv ) .",
    "the fact that all leaves are reducible is shown by induction on the number of facets of @xmath0 .",
    "the converse is also shown by induction .",
    "suppose @xmath0 satisfies ( 1 ) and ( 2 ) , and let @xmath373 and @xmath374 be the sets of leaves and non - leaves , respectively .",
    "conditions ( i)(iv ) hold trivially . further , if @xmath362 is a joint , then @xmath375 are still reducible leaves of @xmath363 by remark  [ r : reducible ] .",
    "also , there are no additional leaves in @xmath363 , since none of the @xmath376 have free vertices by condition ( 1 ) .",
    "therefore , @xmath363 satisfies ( 1 ) and ( 2 ) and is therefore grafted by induction hypothesis , proving ( v ) .        1 .",
    "build the lists @xmath377 ( leaves of @xmath0 ) and @xmath378 ( facets of @xmath0 which are not leaves ) .",
    "2 .   if @xmath379 , return * false*. 3 .",
    "if @xmath380 , return * false*. 4 .   if @xmath381 that is not a reducible leaf , return * false*. 5 .",
    "return * true*.      the leaf checking cost is @xmath246 , hence the cost of step 1 is @xmath382 .",
    "the cost of steps 2 and 3 is @xmath246 . for step 4 , there are @xmath9 facets @xmath3 to check . checking whether @xmath3 is reducible takes @xmath308 steps as mentioned in section  [ sub : optimization ] .",
    "therefore the total cost for step 4 is @xmath309 , and this is the cost of the algorithm .",
    "let @xmath383 , with @xmath384 and @xmath385 . then @xmath386 and @xmath387 .",
    "additionally , we check that each @xmath388 is a reducible leaf by showing that the set @xmath389 is a totally ordered set under inclusion .",
    "for example , if @xmath390 , then this set is equal to @xmath391 which is totally ordered .",
    "this holds for all @xmath388 , and hence the facet complex is grafted .",
    "@xmath392                s.  faridi .",
    "monomial ideals via square - free monomial ideals . in : commutative",
    "algebra : geometric , homological , combinatorial and computational aspects .",
    "lecture notes in pure and applied mathematics 244 . pp .",
    "85114 , 2005"
  ],
  "abstract_text": [
    "<S> we generalize the concept of a cycle from graphs to simplicial complexes . </S>",
    "<S> we show that a simplicial cycle is either a sequence of facets connected in the shape of a circle , or is a cone over such a structure . </S>",
    "<S> we show that a simplicial tree is a connected cycle - free simplicial complex , and use this characterization to produce an algorithm that checks in polynomial time whether a simplicial complex is a tree . </S>",
    "<S> we also present an efficient algorithm for checking whether a simplicial complex is grafted , and therefore cohen - macaulay . </S>"
  ]
}