{
  "article_text": [
    "combining logic and probability in a logic programming language provides us with a powerful modeling tool for machine learning .",
    "the resulting language allows us to build complex yet comprehensible probabilistic models in a declarative way .",
    "prism  @xcite is one of the earliest attempts to develop such a language .",
    "it covers a large class of known models including bayesian networks ( bns ) , hidden markov models ( hmms ) and probabilistic context free grammars ( pcfgs ) and computes probabilities with the same time complexity as their standard algorithms , as well as unknown models such as probabilistic context free graph grammars @xcite .    the efficiency of probability computation in prism is attributed to the use of tabling  @xcite that eliminates redundant computation .",
    "given a top - goal @xmath0 , we search for all proofs of @xmath0 an sld - refutation of @xmath1@xmath2 .",
    "] while tabling probabilistic goals and recording their logical dependencies as a set @xmath3 of propositional formulas with a graphical structure which we call an _ explanation graph _ for @xmath0  @xcite . by applying dynamic programming to @xmath3",
    "when it is acyclic and partially ordered we can efficiently compute the probability of @xmath0 in time linear in the size of the graph .",
    "the use of tabling also gives us another advantage over non - tabled computation ; it stops infinite loop by detecting recurrence patterns of goals .",
    "tabled logic programs thus can directly use left recursive rules in cfgs without the need of converting them to right recursive ones .",
    "+ in this paper we investigate another possibility of tabling that has gone unnoticed in the non - probabilistic setting ; we apply tabling to compute an infinite sum of probabilities that typically appears in the context of prefix probability computation for pcfgs  @xcite .",
    "pcfgs are a probabilistic extension of cfgs in which cfg rules are assigned probabilities and the probability of a sentence is computed as a sum - product of probabilities assigned to the rules used to derive the sentence  @xcite .",
    "a prefix @xmath4 is an initial substring of a sentence .",
    "the probability of the prefix @xmath4 is a sum of probabilities of infinitely many sentences of the form @xmath5 for some string @xmath6 .",
    "prefix probability is useful in speech recognition as discussed in @xcite .",
    "we generalize this prefix probability computation for pcfgs to probability computation on _ cyclic explanation graph_s generated by prism programs using tabled search .",
    "since we can use arbitrary programs , our approach not only allows us to deal with non - pcfgs such as probabilistic left - corner grammars ( plcgs ) in addition to pcfgs , but opens a way to practical applications such as planning and model checking as will be demonstrated in section  [ sec : plan_recog ] and in section  [ sec : reachability ] respectively .",
    "prism constructs an explanation graph for a top - goal @xmath0 by collecting clauses used in a proof of @xmath0 while checking if there is a loop , i.e.  if there is a proved goal that calls itself as one of its descendent goals .",
    "loops easily occur for example in programs for prefix of pcfgs and in ones for markov chain containing self loops . by default",
    "whenever prism detects a loop during the construction of the explanation graph , it fails with an error message but by setting error_on_cycle flag to off using set_prism_flag/2 , we can let prism skip loop checking and as a result can obtain a cyclic explanation graph . so constructing cyclic explanation graphs",
    "requires no extra cost in prism .",
    "however , while computing probability from such cyclic graphs is possible  @xcite , efficient computation is difficult except for the case of _ linear cyclic explanation graph_s that can be turned into a set of linear probability equations straightforwardly solvable by matrix operation .",
    "so the practical issue is to guarantee the linearity of cyclic explanation graphs .",
    "we specifically examine a prism program for prefix probability computation for pcfgs and prove that the program always generates linear cyclic explanation graphs .",
    "we also prove that the probability equations obtained from the linear cyclic explanation graphs are solvable by matrix operation under some mild assumptions on pcfgs .    to empirically test our approach , we conduct experiments of computing prefix probability for a pcfg and also for a plcg using a real corpus of moderate size . to our knowledge , prefix probability computation for plcgs",
    "is new and has not been attempted so far . as applications ,",
    "we apply prefix probability computation to plan recognition in which action sequences are derived from plans using a pcfg .",
    "our task is to infer , given an action sequence , the plan underlying it .",
    "note that we do not require the action sequence to be complete as a sentence unlike previous approaches  @xcite as we are able to deal with prefix action sequences .",
    "we also apply our approach to the reachability probability problem in probabilistic model checking  @xcite .",
    "this class of problems needs to describe markov chains and to compute the reachability probability between two states .",
    "the experiment suggests that our approach is reasonably fast .",
    "in what follows , we first review probability computation in prism in section  [ sec : probcomp ] . in section  [ sec : prepcfg ] we explain how prefix probability is computed for pcfgs in prism together with some formal proofs . then we tackle the problem of prefix probability computation for plcgs in section  [ sec : preplc ] .",
    "we apply prefix probability computation to plan recognition in section  [ sec : plan_recog ] and to the reachability probability problem in probabilistic model checking in section  [ sec : reachability ] .",
    "section  [ sec : relatedwork ] contains related work and section  [ sec : conclusion ] is the conclusion .",
    "we assume the reader has a basic familiarity with prism  @xcite .",
    "we review probability computation in prism for self - containedness .",
    "prism is a probabilistic extension of prolog with built - in predicates for machine learning tasks such as parameter learning and bayesian inference  @xcite .",
    "theoretically a prism program @xmath7 is a union @xmath8 of a set of definite clauses @xmath9 and and a set @xmath10 of ground probabilistic atoms of the form msw(@xmath11,@xmath6 ) that represent simple probabilistic choices where @xmath11 and @xmath6 are ground terms . using probabilities assigned to msw atoms",
    ", @xmath7 uniquely defines a probability measure @xmath12 over possible herbrand interpretations from which the probability of an arbitrary closed formula is calculated .",
    "practically however prism programs are just prolog programs that use msw atoms introduced by values/2 declarations,[@xmath13 ) introduces a set of ground probabilistic atoms msw(@xmath11,@xmath14)(@xmath15 ) .",
    "they represent as a group a discrete random variable on a sample space @xmath16 .",
    "so only one of them becomes probabilistically true and others are false . to specify their distribution we use a prism command set_sw(@xmath11,[@xmath17 ) that sets @xmath18 , the probability of msw(@xmath11,@xmath14 ) being true , to @xmath19 ( @xmath15 ) where @xmath20 .",
    "] as probabilistic primitives , x ) as a prism goal returns @xmath21 with probability @xmath19 . on the other hand",
    "a ground goal msw(@xmath11,@xmath6 ) is equivalent to msw(@xmath11,x),x=@xmath6 and fails if the value returned in x differs from @xmath6 .",
    "we assume that different occurrences of msw/2 atom in a program or in a proof are independent and if they have the same @xmath11 , they represent samples from independent and identically distributed random variables  @xcite . ] as shown in fig .",
    "[ fig : prism : prog0 ] of subsection  [ subsec : exampleprepcfg ] .    in prism , the probability @xmath22 of a ground atom @xmath0 w.r.t .   a program @xmath7 is basically computed as a sum of probabilities of all _ explanation_s for @xmath0 where an _ explanation for _ @xmath0 is a conjunction @xmath23 of ground msw atoms such that @xmath24 is the completion of @xmath9",
    "it is a union of the if - and - only - if form of @xmath9 and the so called clark s equational theory . ] .",
    "however naively computing @xmath22 is computationally expensive because of exponentially many explanations .",
    "instead we compute @xmath22 in three steps . in the first step ,",
    "we perform tabled search for all proofs of @xmath0 while recording clause instantiations used in a proof in the external memory area ( through some c - interface predicates ) . in the second step , we construct an explanation graph @xmath3 for @xmath0 from recorded clause instantiations .",
    "it compactly represents all possible explanations for @xmath0 by subformula sharing . in the third step",
    ", we convert @xmath3 to a set of probability equations and obtain @xmath22 by solving it using dynamic programming . in the following we discuss each of them in detail .",
    "in general there are exponentially many proofs of @xmath0 and so are explanations .",
    "fortunately we can often compress them to an equivalent but much smaller representation by factoring out common sub - conjunctions as intermediate goals  @xcite .",
    "we can express the set of all explanations as a set of _ defining formula_s that take the form @xmath25 . here",
    "@xmath26 is the top - goal @xmath0 or an intermediate goal .",
    "hereafter the top - goal and intermediate goals are collectively called _ defined goal_s .",
    "we call each @xmath27 ( @xmath28 ) a _ defining clause _ for @xmath26 where @xmath29 is a conjunction @xmath30 ( @xmath31 ) of defined goals @xmath32 and msw atoms @xmath33 .",
    "we say that @xmath26 is a _ parent _ of @xmath34 ( @xmath35 ) and call the transitive closure of this parent - child relation the _ ancestor relation_. the whole set of defining formulas is denoted by @xmath3 and called an _ explanation graph _ for @xmath0 as is called so far . in @xmath3",
    "each defined goal has only one defining formula and possibly is referred to by other defined goals .",
    "an n - ary predicate p / n is said to be _",
    "probabilistic _ if the predicate symbol p is msw or recursively , there is a clause in @xmath7 such that the head contains the predicate symbol p and a probabilistic predicate occurs in the body .",
    "likewise an atom p(@xmath36 ) is probabilistic if p / n is probabilistic .",
    "then roughly @xmath3 is obtained from exhaustive tabled search for all proofs of @xmath0 while tabling probabilistic predicates in @xmath7 .",
    "what we actually use however is not @xmath7 but another non - probabilistic prolog program @xmath37 translated from @xmath7 that has a mechanism of recording instantiated clauses used in a proof of @xmath0 .",
    "we construct @xmath3 by tabled search for all proofs of @xmath0 w.r.t .",
    "@xmath37 while tabling probabilistic predicates and collect instantiated clauses used in a proof as defining clauses constituting @xmath3  @xcite .",
    "@xmath37 is obtained by translating each clause in @xmath7 as follows  @xcite .",
    "suppose for example p(x , f(v)):-msw(x , v),q(g(x , v)),r(v ) is a clause in @xmath7 and also suppose p/2 and q/1 are probabilistic but r/1 is not ( generalization is easy ) .",
    "we replace msw(x , v ) with ( get_values(x , vs),member(v , vs ) ) , get_values(x , vs ) returns the list of possible values vs for msw(@xmath11,@xmath38 ) . ] and further add a special goal to store a defining clause in the external memory area .",
    "so the translated clause is +    [ cols= \" < \" , ]     a state transition in a markov chain is made by a probabilistic choice of next state . since the choice is exclusive and independent at each state , prism can simulate markov chains , except when there is a self - loop , or more generally there is a set of state transitions forming a loop . in this case probability computation",
    "requires an infinite sum of probabilities which prism has been unable to deal with .",
    "however , by applying the general procedure described in fig .",
    "[ fig : prefix_comp ] , we are now able to compute an infinite sum of probabilities , in particular for the reachability probability problem . for example , the reachable probability from s0 to s3 is represented as p(reach(s0,s3 ) ) and is computed by the program as 0.6 .    in the following",
    "we tackle a more complicated problem and verify the synchronous leader election protocol as described in a web page for the prism model checker  @xcite as one of the case studies .",
    "the protocol probabilistically elects a leader among processors distributed over a ring network communicating by synchronous message passing .",
    "it has two parameters , n , the number of processors and k , the number of candidate ids used for election .",
    "our task is to show that a leader will be elected with probability one .",
    "we use a prism program faithfully translated from the one shown in the web page with one exception .",
    "that is , we separate probabilistic transition from deterministic transition and only the predicate representing the former is tabled using prism s p_table declaration .",
    "[ fig : mck ] shows cpu time taken for verification , varying n and k. as we see , the plotted curves for n=5 and n=6 look alike and the cpu time is almost exponential in k. we note that they are similar in shape to the ones ( pip - full ) obtained by who conducted the same experiment to compare their approach with the prism model checker .",
    "however an exact comparison with our approach would be difficult because of the difference in cpu processors and more seriously because of the difference in coding .",
    "tabling in logic programming has traditionally been used to eliminate redundant computation and to avoid infinite loop , but the use of loop detected by tabling for infinite probability computation seems new , though tabling for ( finite ) probability computation is well - known and implemented in some probabilistic logic programming languages such as prism  @xcite , problog  @xcite and pita  @xcite .",
    "this is probably because looping goals have long been considered useless despite the fact that they make sense if probabilities are involved and the loop computes converging probabilities like prefix probability computation . +",
    "technically our approach is closely related to @xcite in which gorlin et al .",
    "proposed pip ( probabilistic inference plus ) that computes the probability of infinitely many explanations and applied pip to model checking . in pip , to compute the probability of a query q w.r.t .",
    "a probabilistic logic program p , a residual program is first constructed using xsb prolog  @xcite from p and q. then it is converted to a dcg called equation generator that generates possible explanations for q as strings , from which a factored explanation diagram ( fed ) is derived .",
    "it is a compressed representation of the set of ( possibly infinitely many ) explanations for q w.r.t .",
    "p and further converted to a system of polynomial equations .",
    "the probability of q is obtained by solving the equations .",
    "the basic idea of pip is similar to our approach : probability computation by solving a set of equations derived from a symbolic diagram constructed from a program and a query .",
    "nonetheless there are substantial differences between pip and our approach .",
    "first pip uses msw/3 that has three arguments in which the second argument ( trial - id @xcite ) is a term ( clock ) indicating when the msw is executed in the computing process .",
    "to ensure statistically correct treatment of the second argument for probability computation , pip requires programs to be `` temporally well - formed '' and places three syntactic conditions on the occurrences of `` instance arguments '' , i.e.  arguments that work as a clock .",
    "these conditions look restrictive but how they affect the class of definable probabilistic models or how they are related to prism programs is unclear and not discussed in @xcite .",
    "prism on the other hand uses msw/2 that omits the second argment from msw/3 for computational efficiency and allows arbitrary programs but instead assumes every occurrence of msw/2 in a proof for the query is independent ( _ independence condition _ ) which guarantees the correctness of probability computation in prism .",
    "also pip constructs an fed , bdd - like graphical structure representing a set of explanations via a dcg ( equation generator ) whereas prism constructs an explantion graph without using a dcg .",
    "feds are powerful ; they enable pip to deal with programs that violate the exclusiveness condition required by prism while capturing common patterns in the set of explanations .",
    "however when programs satisfy the exclusiveness condition ( and the independence condition as well ) as is often the case in probabilistic modeling by generative models such as bns , hmms , pcfgs and plcgs , the construction of feds is unnecessary .",
    "a simpler structure , explanation graphs , is enough .",
    "as we have demonstrated , the sum of probablities of infinitely many explanations can be efficiently computed by cyclic explanation graphs in such cases .",
    "in addition , though it is not clearly stated in @xcite , gorlin et al .  seem to solve the set of equations by an iterative method described in @xcite that is applicable to nonlinear cases .",
    "prism contrastingly assumes the linearity of equations and efficiently solves hierarchally ordered sets of system of linear equations , corresponding to sccs , by matrix operation in cubic time in the number of variables .",
    "considering the fact that nonlinearity occurs even in the case of pcfgs when we compute infix probability  @xcite however , it is important future work to enhance prism s equation solving ability for nonlinear cases",
    ".    current tabling in prism employs linear tabling in b - prolog and it is straightforward to construct cyclic explanation graphs from defining clauses for tabled answers stored in the memory . constructing cyclic explanation graphs in other prolog systems such as xsb  @xcite that employ a suspend - resume mechanism for tabling also seems possible .",
    "approximate computation of prefix probability seems possible for example by the iterative deepening algorithm used in problog @xcite .",
    "to develop such an approximation algorithm remains as future work .",
    "prefix probability computation is mostly studied about pcfgs  @xcite .",
    "proposed a cky like algorithm for prefix probability computation in pcfgs in chomsky normal form .",
    "their algorithm does not perform parsing but instead uses a single monolithic matrix whose dimension is the number of nonterminals which is constructed from a given pcfg .",
    "it runs in @xmath39 where @xmath40 is the length of an input prefix . applied the earley style parsing to compute prefix probabilities .",
    "his algorithm uses a matrix of `` probabilistic reflexive , transitive left - corner relation '' computed from a given pcfg , independently of input sentences similarly to @xcite .",
    "our approach differs from them first in that it is general and works for arbitrary prism programs and second in that it constructs an explanation graph for each input prefix and probabilities are computed on the basis of the sccs derived from the explanation graph .    generalized prefix probability computation for pcfgs to infix probability computation for pcfgs .",
    "they also studied prefix probability computation for a variant of pcfgs  @xcite .",
    "nederhof et al .   proposed prefix probability computation for stochastic tree adjoining grammars  @xcite .",
    "however , prefix probability computation for plcgs has been unknown and our example in section  [ sec : preplc ] is the first one to our knowledge .",
    "applying prefix probability computation to plan recognition in section  [ sec : plan_recog ] is not new but our approach generalizes previous grammar - based approaches  @xcite in that it allows for incomplete action sequences ( prefixes ) as observations . in relation to plan recognition , it is possible to apply prefix probability computation to predict the most likely action ( word ) that follows an observed action sequences ( prefix )  @xcite , though we do not discuss it here .",
    "we eliminated in this paper one of the restrictive assumptions on prism that the number of explanations for a goal is finite .",
    "however there still remain restrictive assumptions , the exclusiveness assumption and the independence assumption  @xcite .",
    "their elimination by introducing bdds  @xcite or feds  @xcite remains future work .",
    "we have proposed an innovative use of tabling : infinite probability computation based on cyclic explanation graphs generated by tabled search in prism .",
    "it generalizes prefix probability computation for pcfgs and is applicable to probabilistic models described by prism programs in general and to non - pcfg probabilistic grammars such as plcgs in particular as we demonstrated .",
    "we applied our approach to plan recognition and to the reachability probability problem in probabilistic model checking .",
    "we expect that our approach provides a declarative way of logic - based probabilistic modeling of cyclic relations .    , kusserow , m. , and troster , g. 2007 .",
    "probabilistic parsing of dietary activity events . in _ proceedings of the international workshop on wearable and implantable body sensor networks_. vol .",
    "13 . 242247 .        , kimmig , a. , and toivonen , h. 2007 . : a probabilistic prolog and its application in link discovery . in _ proceedings of the 20th international joint conference on artificial intelligence ( ijcai07)_. 24682473 .          ,",
    "kwiatkowska , m. , norman , g. , and parker , d. 2006 . : a tool for automatic verification of probabilistic systems . in _ proceedings of the 12th international conference on tools and algorithms for the construction and analysis of systems ( tacas06)_. lncs , vol .",
    "springer , 441444 .",
    "efficient em learning for parameterized logic programs . in _ proceedings of the 1st conference on computational logic ( cl00)_. lecture notes in artificial intelligence , vol .",
    "springer , 269294 .    , norman , g. , and parker , d. 2011 . 4.0",
    ": verification of probabilistic real - time systems . in _ proceeding of the 23rd international conference on computer aided verification ( cav11 ) _ , g.  gopalakrishnan and s.  qadeer , eds .",
    "lncs , vol . 6806 .",
    "springer , 585591 .    ,",
    "teixeira , t. , and savvides , a. 2007 .",
    "detecting patterns for assisted living using sensor networks : a case study . in _ proceedings of the 2007 international conference on sensor technologies and applications (",
    "sensorcomm 07)_. 590596 .",
    ", anoop  sarkar , a. , and satta , g. 1998 .",
    "prefix probabilities from stochastic tree adjoining grammars . in _ proceedings of the 36th annual meeting of the association for computational linguistics ( acl98)_. 953959 .",
    ", le  goc , m. , eric , p. , and alain , a. 2011 . combining timed data and expert s knowledge to model human behavior . in _ proceedings of the health ambiant information systems workshop , ( hamis11)_. vol .",
    "729 .                                  ,",
    "kameya , y. , and sato , t. 2010 .",
    "mode - directed tabling for dynamic programming , machine learning , and constraint solving . in",
    "_ proceedings of the 22th international conference on tools with artificial intelligence ( ictai-2010)_."
  ],
  "abstract_text": [
    "<S> tabling in logic programming has been used to eliminate redundant computation and also to stop infinite loop . in this paper </S>",
    "<S> we investigate another possibility of tabling , i.e.  to compute an infinite sum of probabilities for probabilistic logic programs . using prism , a logic - based probabilistic modeling language with a tabling mechanism , </S>",
    "<S> we generalize prefix probability computation for probabilistic context free grammars ( pcfgs ) to probabilistic logic programs . given a top - goal , we search for all proofs with tabling and obtain an explanation graph which compresses them and may be cyclic . </S>",
    "<S> we then convert the explanation graph to a set of linear probability equations and solve them by matrix operation . </S>",
    "<S> the solution gives us the probability of the top - goal , which , in nature , is an infinite sum of probabilities . </S>",
    "<S> our general approach to prefix probability computation through tabling not only allows to deal with non - pcfgs such as probabilistic left - corner grammars ( plcgs ) but has applications such as plan recognition and probabilistic model checking and makes it possible to compute probability for probabilistic models describing cyclic relations . </S>",
    "<S> to appear in theory and practice of logic programming ( tplp ) .    </S>",
    "<S> # 1    [ firstpage ]    tabling , probability computation , prefix , probability equation </S>"
  ]
}