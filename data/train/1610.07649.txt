{
  "article_text": [
    "finding all frequent patterns from large databases is np - hard for it s an exhaustive search problem  @xcite .",
    "almost all existing data mining technologies reviewed in  @xcite are limited by the high response time due to the tough and compute - intensive nature of the task . as pointed out by dass  @xcite ,",
    "all of the algorithms produce outputs only at the completion ( either run to completion or provide no useful results ) and are not amenable to the real - time decision - making need .    for instance , consider a gene expression data set , i.e. , microarray data , produced in bioinformatics , which usually have a large number of columns ( genes ) .",
    "it s meaningful to find all the co - regulated genes or gene groups for ( 1 ) cancer treatment ; ( 2 ) drug sensitivity analysis .",
    "however , it often can not run to completion in a reasonable time for large microarray data .",
    "imagine a mining process might be stuck computing for hours , days , even weeks without any response , it greatly challenges the user s patience and absolutely unacceptable in mission critical applications .",
    "can we at least draw some partial conclusions during such a mining process without waiting until completion , i.e. , first generate the higher support / coverage combination of genes which might have higher influence ?",
    "could an algorithm guarantee that all itemsets with support exceeding the current checkpoint s support have been found before it proceeds further ?",
    "alpine is such an algorithm .",
    "therefore , it exhibits so - called anytime feature .",
    "an _ anytime algorithm _ uses well - defined quality measures to monitor the progress in problem - solving and is expected to improve the quality of the solution as the computational time increases  @xcite . anytime algorithms have been categorized into two types : interruptible and contract algorithms  @xcite .",
    "an interruptible algorithm can be interrupted at any time . a contract algorithm ,",
    "if interrupted at any point before the termination of the contract time , might not yield any useful results . from this definition ,",
    "an anytime algorithm is able to return many possible intermediate partial approximate answers to any given input .",
    "thus , it is useful for solving problems where the search space is large and the quality of the results can be compromised  @xcite . clearly , the anytime approach is particularly well suited for data mining and more generally for intelligent systems .",
    "sub - search spaces w.r.t . a set of decreasing",
    "minimum supports @xmath0 .",
    "the utility of the current solution is plotted as a function of time , where @xmath1 is a set of randomly selected probes in time .",
    ", scaledwidth=50.0% ]    in the context of frequent itemset mining , the common framework is to use a @xmath2 threshold to ensure the generation of the _ correct _ and _ complete _ set of patterns  @xcite .",
    "we require that an anytime mining algorithm reaches partial _ completeness _ through checkpoints , which define the exploration of well - defined subspaces of the entire problem .",
    "according to the law of diminishing marginal utility in economics  @xcite , we believe that the additional benefit derived from the completeness of itemsets with a @xmath2 diminishes with the decrease of the value of @xmath2 ( refer to the upper right graph in figure  [ fig : anytimeframework ] ) .",
    "the total utility derived from the outcome of an anytime mining algorithm can be utilized to quantify the usefulness of its intermediate results .",
    "the proposed anytime mining framework is illustrated in figure 1 , @xmath0 is the set of all distinct supports of itemsets in a transaction database in decreasing order and @xmath1 is a set of randomly selected probes in time . upon the completion of all the itemsets with support greater than or equal to @xmath3 , the utility associated with the minimum support , @xmath4 ,",
    "is obtained instantly .",
    "the goal of an anytime miner is to maximize the average utility at the set of random probes , i.e. , @xmath5 .    in this work",
    ", we are investigating anytime algorithms for frequent itemset mining and present the alpine algorithm , namely , automatic @xmath2 lowering with progress indicator in never - ending mining . the alpine algorithm proceeds in the defined anytime mining manner  from checkpoint to checkpoint . in alpine ,",
    "the checkpoints correspond to decreasing values of minimum support .",
    "alpine guarantees that all itemsets with support exceeding the current checkpoint s support have been found before it proceeds further . in this way , we know that we have completed a well - defined subset of the overall , potentially enormous search space .",
    "alpine proceeds in this monotonic  manner with minimal computational overhead as compared to the best existing frequent itemset mining algorithms . in alpine , though the mining process is continuous , it does not go totally unchecked .",
    "alpine can be stopped at any point , we will always be able to offer partial conclusions based on the last checkpoint reached as indicated in figure  [ fig : anytimeframework ] .",
    "in contrast , the traditional itemset mining algorithms do not give any intermediate partial completeness guarantees , requiring the user to wait until completion to get any definite results .",
    "there is another very critical advantage of alpine .",
    "it does not require setting the minimum support apriori .",
    "this requirement has always been problematic for all frequent itemset generation algorithms .",
    "how do we set the minimum support if we do not know the data ?",
    "we only learn the data as we continue mining it , but then it is too late to change the value of minimum support .",
    "however , it is not the case for alpine .",
    "alpine moves the minimum support as it goes ahead from checkpoint to checkpoint .",
    "alpine is , to our knowledge , the first anytime algorithm to mine frequent itemsets and closed frequent itemsets .",
    "extensive experiments , with one of the fastest itemset mining algorithms in literature  lcm  @xcite , illustrate the added value of this anytime feature and alpines minimal overhead compared with lcm . since the sequential top - k mining algorithm , i.e. , seq - miner  @xcite , enjoys some properties of the contract - type anytime algorithms , we also conduct a set of experiments to compare alpine with seq - miner .",
    "let @xmath6 be a set of literals , called _ items _ , and @xmath7 be a _ transaction database _ , where each transaction @xmath8 in @xmath9 is a set of items such that @xmath10 . a unique transaction identifier , @xmath11 ,",
    "is associated with each transaction .",
    "each subset of @xmath12 is called an _ itemset _ and a transaction is said to contain an itemset if all the items in the itemset are present in the transaction  @xcite . for an itemset @xmath13 , the _ cover _ @xmath14 ( a @xmath15 ) be the set of transactions it is contained in and the support of @xmath13 , denoted as @xmath16 , is the number of these transactions . hence , @xmath17",
    "if @xmath16 exceeds a minimum support threshold @xmath2 , then @xmath13 is called a _ frequent itemset _  @xcite . for a transaction",
    "set @xmath18 , its intersection is @xmath19 .",
    "if an itemset @xmath13 satisfies @xmath20 , then @xmath13 is called a _ closed itemset _  @xcite .",
    "to avoid enumerating itemsets with duplications , it s natural to order the items to structure the search space .",
    "we define a total order among the set of items from @xmath12 as item @xmath21 item @xmath22 iff @xmath23 .",
    "the search is confined to extend an itemset only with items greater than all items inside it .",
    "items from @xmath12 can be recoded to 0 , 1 , ... , @xmath24 according to this order .",
    "let @xmath25 be an itemset as an ordered sequence such that @xmath26 , the _ tail _ of @xmath13 is @xmath27  @xcite",
    ". then itemset @xmath13 will only be extended with all items greater than @xmath28 , resulting in a tree structured subset lattice .    to further reduce the search tree size , the closure operator @xmath29 is utilized at each step .",
    "together with the above extension rule , we define the _ closure _ of itemset @xmath13 as @xmath30 , where @xmath31 , for we know that @xmath13 union any subset of @xmath32 is supported exactly by @xmath33 ( @xmath32 is a shortcut of support equivalence extension ) .",
    "then @xmath13 is not needed to extend with items belong to @xmath32 .",
    "if @xmath34 , this operation will reduce the size of the subtree rooted at @xmath13 by a factor of @xmath35 . in general , for itemset @xmath36 and @xmath37 , with @xmath38 , the set of all itemset @xmath39 which is a superset of @xmath36 and a subset of @xmath37 can be compactly represented as an _ itemset interval _ : @xmath40 , for they all share the same supporting transactions as @xmath36 . in this definition ,",
    "@xmath36 and @xmath37 specify the minimum itemset and the maximum itemset in an itemset interval , respectively .",
    "we also define a mapping , @xmath41 , from support to set of itemsets , which is applicable to both frequent and closed itemsets .",
    "we name it _ support index _ , for it is used to index all the itemsets from a transaction database by support .",
    "given a support value @xmath42 , the indexed set of itemsets is @xmath43 .",
    "the degree of completeness for a specific support @xmath42 , is defined as the number of itemsets discovered so far with support @xmath42 divided by the total number of itemsets with support @xmath42 from the transaction database , i.e. , @xmath44 .",
    "in alpine , itemsets are discovered in order of their supports  from higher support to lower support .",
    "alpine will automatically lower the @xmath2 threshold to the next possible , lower value and continue mining .",
    "the basic idea of alpine is to dynamically build the support index , from the highest possible support gradually to the lowest possible value of support in the given transaction database .",
    "it progressively partitions itemset intervals into disjoint bins of different supports .",
    "0.46     .25 cm    0.48     alpine starts with the index built from all the itemset interval ( @xmath45 , @xmath46 ) of singleton itemset @xmath45 from a transaction database in figure  [ fig : frontier1 ] . in this figure , all singleton itemset intervals are sorted in decreasing support from left to right and binned based on their support values .",
    "this index is not static , though , it is updated by new itemset intervals generated by extending the minimum itemset of an itemset interval . at any point in time",
    ", we are working on the uncompleted bin ( there are still some remaining itemset intervals in this bin ) with the highest support value @xmath42 .",
    "to enumerate all itemsets with support above or equal to @xmath42 , we extend the minimum itemset of each itemset interval in the bin .",
    "let @xmath47 be an itemset interval we are currently working on , we extend @xmath36 with all item @xmath22 greater than @xmath48 and not contained in @xmath37 .",
    "denote @xmath49 as itemset @xmath50 , we also find @xmath51 according to the definition of an itemset closure",
    ". we can prove lemma  [ lemma : interval ] and get the itemset interval for @xmath50 accordingly : @xmath52 , where @xmath53 .",
    "[ section ]    all itemsets in the itemset interval @xmath52 , where @xmath53 , are supported by @xmath54 .",
    "[ lemma : interval ]    @xmath55 itemset @xmath56 itemset interval @xmath52 , we can denote @xmath13 as @xmath57 , where @xmath58 . for @xmath53",
    ", we can further decompose @xmath39 into two disjoint subsets @xmath59 and @xmath60 , with @xmath61 .",
    "then , the cover @xmath62 . according to the definition of @xmath51",
    ", we have @xmath63 , so @xmath64 . since @xmath65 , then @xmath66 .",
    "the itemset @xmath67 is in the itemset interval @xmath47 , so it is supported by @xmath68 .",
    "thus , @xmath69 .",
    "all of the newly generated itemset intervals @xmath52 are segregated by their support values into different bins of the support index . and",
    "@xmath70 will always be smaller than @xmath71 according to the closure operation , otherwise , item @xmath22 will belong to @xmath37 .",
    "there are two different situations : 1 ) the support of @xmath50 is already associated with some existing bin and we only need to add itemset interval @xmath52 to that bin ; 2 ) the support of @xmath50 is a new value , which hasnt been indexed yet and we need to create a new bin to place @xmath52 in it .    an example is given in figure  [ fig : frontier2 ] , the itemset interval under exploration is on top of @xmath72 and @xmath73 corresponds to the highest uncompleted bin .",
    "let s denote the interval as ( @xmath74 ) .",
    "we extend @xmath36 with items greater than @xmath48 and not contained in @xmath37 .",
    "suppose item @xmath22 and item @xmath75 belong to such set of items .",
    "when @xmath36 is extended with item @xmath22 , we obtained itemset @xmath65 and @xmath76 .",
    "it happens that @xmath70 is equal to some @xmath77 indexed , so the itemset interval ( @xmath78 ) will be added to @xmath79 as indicated by the red dashed line in figure  [ fig : frontier2 ] .",
    "however , when it comes to item @xmath75 , the support of @xmath80 has not been indexed yet , a new bin @xmath81 is created to place its interval ( @xmath82 ) with @xmath83 .",
    "only when we finish exploring all itemset intervals in a bin of the support index , we are safe to conclude that we have discovered all itemsets with support above or equal to the support associated with that bin .",
    "that s when we can declare that support as a new minimum support , @xmath2 , and we have reached the successive checkpoint .",
    "this checkpoint completes the subspace of all itemsets with support above or equal to @xmath2 , even though the bins with lower supports are not complete yet .",
    "alpine always continues to build new bins for the new possible support values or extends existing bins . in this way ,",
    "alpine mines patterns with descending value of support sequentially and outputs partially complete information from checkpoint to checkpoint in the defined anytime mining manner .",
    "the pseudo - code of our prototypical algorithm alpine is given in algorithm  [ algorithm : alpine ] .",
    "it starts from the bin of the highest support and it explores all itemset intervals in that bin one by one",
    ". then it continues with the bins of successively lower support values .",
    "the init process in line 1 initializes the support index from all the itemset intervals of the singleton itemsets in the given transaction database @xmath9 in decreasing support order .",
    "each itemset interval in a given bin is explored by the sub - routine explorer given in algorithm  [ algorithm : explorer ] ( line 5 ) , in which the minimum itemset of each itemset interval is extended with all possible items in descending support order from the most promising one to the least promising one .",
    "line 8 issues a checkpoint after completing all itemset intervals in a bin ( with support above or equal to the support of that bin ) .",
    "the anytime feature makes the alpine algorithm can be interrupted at any moment ( line 9 - 11 ) . from the described procedure , we can deduce the following lemma and observations :    init @xmath84 by all itemset interval @xmath85 of singleton itemset @xmath45 in @xmath9 ; get bin @xmath72 indexed by @xmath73 ; explorer(@xmath36 , @xmath37 , @xmath84 ) ; declare @xmath73 to be @xmath2 ; issue checkpoint : complete subspace of all itemsets @xmath86 ; break ; //",
    "terminate requested by user    output itemset interval : ( @xmath74 ) ; continue ; // no need to extend with item @xmath87 @xmath88 ; @xmath89 ; add @xmath52 to the indexed bin ; create a new bin with support @xmath70 for @xmath84 and add @xmath52 to it ;    each itemset will be output in exactly one itemset interval .",
    "this lemma can be proved by contradiction .",
    "suppose the same itemset @xmath13 can be output in two different itemset intervals : ( @xmath90 ) and ( @xmath91 ) with @xmath92 .",
    "then we have , @xmath93 ( 1 ) .",
    "thus , @xmath94 and @xmath95 can not be inclusion relation with each other , otherwise , @xmath96 .",
    "if we sort the items in @xmath94 and @xmath95 as ordered sequence according to the order defined in preliminaries and denote the first different item between them as @xmath97 and @xmath98 ( @xmath99 , and we denote this set of items as @xmath100 and the associated itemset interval as ( @xmath101 ) .",
    "without loss of generality , we can assume @xmath102 . from ( 1 )",
    ", we have @xmath103 .",
    "consider itemset @xmath104 , since the itemset is only extended with items not in @xmath105 , we have @xmath106 . regarding itemset @xmath107 , @xmath108 .",
    "according to the definition of @xmath109 , it does nt include any item less than @xmath98 , so @xmath97 must be in @xmath105 , which is a contradiction .",
    "[ section ]    every itemset with support above or equal to minsup was output at the related checkpoint .    with the defined item order and the exploration procedure in algorithm  [ algorithm : explorer ] ,",
    "each item greater than @xmath48 is either extended explicitly , or it is already contained in @xmath37 , which completes the search space . and all itemsets generated from the itemset intervals in the bins with lower supports are less than the @xmath2 of the current checkpoint according to the anti - monotone property of itemset support",
    ".    every distinct support count of an itemset in the transaction database @xmath9 will be @xmath2 value of some alpine s checkpoint .",
    "[ observation : checkpoint ]    this observation is readily obtained from the monotonic manner the alpine algorithm explores successive bins of the support index as discussed above .",
    "thus ,    [ section ]    given a transaction database @xmath9 with @xmath110 transactions over @xmath111 items , the number of checkpoints from it is bounded by @xmath112 .",
    "the minimum support of the first checkpoint is equal to the highest support of the singleton itemsets in @xmath9 .",
    "[ property : firstcheckpoint ]    [ section ]    the highest support value which will correspond to the first and highest checkpoint for alpine is equal to the support of the most frequent item . if no other item shares that support , that item alone constitutes the first checkpoint . in this case , the subspace of itemsets corresponding to the first checkpoint has just one singleton set - that most frequent item",
    ".    it may be the case that several items share the same , highest support . in such case ,",
    "alpine needs to do more work to reach the first checkpoint . in the extreme case",
    ", these top support items may be perfectly correlated ( that is , all their combinations also have the same support ) .",
    "this is , of course , unlikely but possible .",
    "suppose there are @xmath75 such items @xmath113 sharing the highest value of support , and the order among them is @xmath114 .",
    "then alpine needs to explore and output the following itemset intervals ( by algorithm  [ algorithm : explorer ] ) before reaching the first checkpoint : @xmath115 , @xmath116 , ... ,",
    "@xmath117 , @xmath118 , even though all the @xmath75 intervals are contained in one closed itemset @xmath119 .",
    "in this situation , it might be beneficial to confine the tree - shaped transversal routes of alpine to only closed itemsets , which can reduce the work for the aforementioned extreme case to explore only one itemset interval .",
    "in the next section , we ll show how to adapt alpine to mine closed itemsets .",
    "the alpine algorithm elaborated in section  [ section : alpine ] can build the full support index of all itemsets from a transaction database @xmath9 in decreasing support order . if we denote @xmath120 and @xmath121 the sets of all frequent itemsets and all frequent closed itemsets , respectively . according to their definitions , we know that @xmath121 is a subset of @xmath120 . thus , a straightforward way to adapt alpine for closed itemset mining is to add the closeness check for the maximum itemset of an itemset interval at each step of the mining process .",
    "let @xmath47 be an itemset interval , then @xmath37 is closed if and only if @xmath122 .",
    "[ observation : closeness ]    from the definition of itemset interval , we have @xmath37 is supported exactly by @xmath68 .",
    "thus , @xmath123 .",
    "according to the definition of closed itemset given in section  [ section : preliminaries ] , @xmath37 is a closed itemset .    for singleton itemset @xmath45 ,",
    "we know its itemset interval is @xmath85 .",
    "the closeness condition in observation  [ observation : closeness ] for @xmath46 is violated if and only if there exists some item @xmath124 such that @xmath125 occurs in every transaction in @xmath126 . for an itemset interval",
    "@xmath52 generated from some itemset interval @xmath47 in the intermediate stages of alpine , where @xmath53 , things are slightly different .",
    "to fail the closeness check , there must exist some item @xmath127 satisfies : ( 1 ) @xmath125 is shared by every transaction of @xmath54 ; ( 2 ) @xmath128 . in other words , for closed itemset @xmath129 , item @xmath130 can only be obtained from @xmath37 .",
    "init @xmath84 by all itemset interval @xmath85 of singleton itemset @xmath45 in @xmath9 satisfying @xmath131 ( closed ) ; get bin @xmath72 indexed by @xmath73 ; explorer2(@xmath36 , @xmath37 , @xmath84 ) ; declare @xmath73 to be @xmath2 ; issue checkpoint : complete subspace of all _ closed _",
    "itemsets @xmath86 ; break ; // terminate requested by user    output closed itemset : @xmath37 ; continue ; // no need to extend with item @xmath87 @xmath88 ; @xmath132 ; add @xmath52 to the indexed bin ; create a new bin with support @xmath70 for @xmath84 and add @xmath52 to it ;    with this observation , we can modify the alpine algorithm given in section  [ section : alpine ] to the alpineclosed algorithm ( algorithm  [ algorithm : alpineclosed ] ) . note that in line 8 of algorithm  [ algorithm : explorer2 ]",
    ", to test the closeness of itemset @xmath129 , we only need to check all the item @xmath133 . for any nonempty closed itemset @xmath134 , its parent is always defined and belongs to @xmath121  @xcite .",
    "this guarantees the completeness of the proposed alpineclosed algorithm in mining all closed frequent itemsets .",
    "the difference of the alpine and alpineclosed algorithm lies in :    * initialization : alpine is initialized with all itemset intervals of singleton itemsets from a database @xmath9 ( line 1 of algorithm  [ algorithm : alpine ] ) .",
    "in contrast , alpineclosed is initialized with those itemset intervals passing the closeness test ( line 1 of algorithm  [ algorithm : alpineclosed ] ) . *",
    "exploration : alpine outputs itemset interval and keeps all newly generated itemset intervals @xmath52 in the mining process ( algorithm  [ algorithm : explorer ] ) .",
    "alpineclosed , on the other hand , only outputs closed itemset and maintains itemset intervals @xmath52 meeting the closeness condition ( algorithm  [ algorithm : explorer2 ] ) .",
    "* status report : alpine reports the completion of the subspace of all frequent itemsets above the current @xmath2 ( line 8 of algorithm  [ algorithm : alpine ] ) . alpineclosed issues checkpoint about finishing all closed frequent itemsets above the current @xmath2 instead ( line 8 of algorithm  [ algorithm : alpineclosed ] ) .",
    "in this section , we empirically evaluate the alpine algorithm and perform analysis in comparison with related works in both frequent itemset mining and sequential top-@xmath75 itemset mining . for frequent itemset generation , we choose one of the fastest itemset mining algorithms closely related with our work  lcm ( ver .",
    "3 )  @xcite and downloaded its implementation from the author s website .",
    "the utility gained at each probe of both algorithms can be used to quantify the usefulness of the intermediate partial solutions . as the measure of utility is usually application - dependent",
    ", we do nt define the concrete utility function form here , but directly list the @xmath2 reached at each probe by both algorithms .",
    "in top-@xmath75 mining , we select the seq - miner  @xcite that mines the top-@xmath75 frequent patterns sequentially without any minimum support .",
    "the proposed alpine algorithm is implemented in java and all the experiments were carried out on a cluster with 10 2.4 ghz processors and 256 gb memory .",
    "both the experimental datasets from the fimi repository and a real gene expression dataset from the cancer cell line encyclopedia ( ccle ) project are used here .",
    "let us start with emphasizing the benefits of anytime data mining . since all conventional frequent itemset generation algorithms require setting up minimum support apriori by the user , what if the minimum support is set too low and the transaction database is too large ?",
    "if this happens , such algorithms may run for very long time ( practically forever ) , hanging  without providing any information to the user , except generating huge numbers of itemsets .",
    "however , no guarantees on the minimum support reached at each point are given .",
    "alpine , on the other hand , will provide the user with checkpoints which guarantee the partial completeness .",
    "it will provide lower and lower values of minimum support for which the set of frequent itemsets alpine produces is _ * complete*_. these guarantees will offer the user a measure of progress and knowledge about the subspace of the entire itemset search space that has been completely explored .",
    "a set of experiments is designed here to verify the added value of the anytime alpine algorithm and to check how alpine systematically explore the itemset space .",
    "we also analyze the computational overhead of alpine in time .      in the first set of experiments , we study the performance of alpine and lcm on experimental datasets from the fimi repository . to illustrate the benefits of alpine , two relatively large transaction databases , i.e. , t40i10d100k and kosarak , which have many items and many transactions , are selected here .",
    "t40i10d100k has 100,000 transactions over 1,000 items generated by the ibm quest synthetic data generator , while kosarak has 990,000 transactions over 41,270 items containing the click - stream data of a hungarian on - line news portal . to reduce the number of mined itemsets , both alpine and lcm have confined to mine _",
    "itemsets in this experiment .",
    "the experimental setting is as follows : we start both the alpine and the lcm algorithm at the same time , and probe every hour since they are started , i.e. , hour 1 , hour 2 , ... , to check the status of both algorithms .",
    "since alpine is parameter - free , it is not required to set any thresholds .",
    "it just continuously mines itemsets from checkpoint to checkpoint and tries to build the full support index for a given transaction database @xmath9 . different from alpine , lcm must be initialized with some user - provided minimum support . in this experiment",
    ", we set the minimum support threshold of lcm to be 1 to mine all itemsets from @xmath9 in consideration of building the full support index .",
    "the minimum support reached , i.e. , all the itemsets with support greater than or equal to the minimum support are discovered , at each probe @xmath135 by the alpine algorithm is readily obtained from its last checkpoint before @xmath135 , while this information for the lcm algorithm is obtained by post - processing all its output itemsets up to time @xmath135 .",
    "probe & lcm & alpine + 1 & 7314 & 116 + 2 & 6390 & 56 + 3 & 5855 & 34 + 4 & 5317 & 22 + 5 & 4873 & 16 + 6 & 4499 & 13 + 7 & 4168 & 11 + 8 & 3882 & 10 + 9 & 3575 & 9 + 10 & 3313 & 8 +        probe & lcm & alpine + 1 & 10178 & 982 + 2 & 9569 & 926 + 3 & 9264 & 907 + 4 & 8955 & 894 + 5 & 8810 & 885 + 6 & 8684 & 878 + 7 & 8645 & 872 + 8 & 8450 & 867 + 9 & 8379 & 862 + 10 & 8158 & 858 +    [ table : fimi ]    the results of both the algorithms for the set of probes up to ten hours on t40i10d100k and kosarak datasets are shown in table  [ table : fimi ] .",
    "for both datasets , the first column is the probe time in hour , and the second and third column list the @xmath2 reached at each probe by lcm and alpine , respectively .",
    "it s clear from the table that alpine can quickly reach some lower minimum support value than lcm .",
    "for instance , on the t40i10d100k dataset , alpine can reach the minimum support of 116 in the first hour while lcm only completes the subspace of all itemsets with support above 7314 .",
    "the same trend is also observed in the kosarak dataset . for the kosarak dataset",
    "has more items , it s even harder for the lcm algorithm to move minimum support .",
    "we notice that even after twenty hours , the minimum support lcm reached on the kosarak dataset is 7920 , while alpine has already finished all itemsets with support greater than or equal to 835 .",
    "the underlying reason is alpine systematically explore the itemset space in a monotonic  manner .",
    "alpine guarantees that all itemsets with support exceeding the current checkpoint s support have been found before it proceeds further , to build the support index for lower minimum support values .",
    "in contrast , lcm directly enumerate itemsets in a depth - first - search manner . to understand how these two algorithms behavior differently ,",
    "we have taken the partial solutions generated for the t40i10d100k dataset at one hour , three hours , six hours and ten hours as slices to look into the algorithms .",
    "we analyze these intermediate results and calculate the degree of completeness of all support levels .",
    "the results are plotted in figure  [ fig : t40i10d100k ] . in each graph , the horizontal axis is the support value in a log scale , and the vertical axis is the normalized degree of completeness .",
    "for example , in figure  [ fig : t40i10d100k1 ] , it plots the partial answer generated by lcm and alpine after one hour . for lcm , in this intermediate solution",
    ", we can find almost all itemsets with different support values exist but the majority of them are incomplete .",
    "different from lcm , in alpine s partial output , all larger supports to the left of the current working bin are complete , while none of the itemsets from a lower support bin have been generated .",
    "thus , the computational overhead at each checkpoint of alpine is minimum .    by checking all the graphs in figure  [ fig : t40i10d100k ] together",
    ", we can intuitively perceive how both algorithms make progress as the computational time increases .",
    "the quality of the solution from alpine improves as the built support index is more and more complete . for lcm , though the completeness of a specified support value improves , in terms of the moving of minimum support , the progress is not so obvious .",
    "imagine a dataset with even more items , the lcm algorithm might be stuck computing while alpine can report useful and actionable knowledge in time through _ checkpoints_. in the next subsection , we ll test both algorithms on a real gene expression dataset .",
    "0.49     0.49        0.49     0.49       in the second set of experiments , we use lcm and alpine to mine all the co - regulated genes or gene groups from a real gene expression dataset from the cancer cell line encyclopedia project for the drug sensitivity analysis .",
    "the gene - centric rma - normalized mrna expression data consists of the expression values of 18,988 genes in 1,037 patients . to make the dataset usable for binary pattern mining algorithms , each column pertaining to the expression of a single gene",
    "is split into several binary columns . since the data has been properly normalized , we simply adopt the equal - depth ( frequency ) partitioning method to discretize each gene expression into five bins .",
    "the resulting transaction database has 94,940 items and 1,037 transactions , with a density of 20 percent .",
    "we name this dataset as the ccle_expression dataset in the following paragraphs . to compress the output from this high - dimensional dataset , only _ closed _ patterns",
    "are mined in this experiment .",
    "we ran both lcm and alpine on the gene expression dataset .",
    "the minimum support threshold of lcm is set to 80 , due to the huge number of resulting closed frequent patterns from this dataset .",
    "similar to the experimental setting in section  [ section : fimi ] , a series of random probes are selected in time and the minimum support reached by both algorithms are checked at every probe .",
    "the results are presented in table  [ table : ccle_expression ] .",
    "we can find that alpine can continuously make progress in terms of lowering the reached minimum support .",
    "however , the lcm algorithm is stuck in this case at the minimum support of 208 . since alpine always focuses on building the uncompleted bin with the highest support from the index , while lcm spreads its power to the whole support spectrum , making all bins to be completed almost at the same time .",
    "m.8 cm | m.8 cm | m1 cm | m1 cm | m1 cm | probe & 2 & 3 & 4 & 5 & 6 & 7 & 8 & 9 & 10 & 13 & 15 & 18 & 23 + lcm & 209 & 208 & 208 & 208 & 208 & 208 & 208 & 208 & 208 & 208 & 208 & 208 & 208 + alpine & 136 & 125 & 122 & 120 & 119 & 118 & 117 & 116 & 115 & 114 & 113 & 112 & 111 +    [ table : ccle_expression ]    0.33     0.33     0.33     0.33     0.32     0.33     in practical scenarios like this one , it is generally reasonable to have some time period for most data analysis operations . though alpine might also not be able to finish the whole mining task within the time period , but it is always able to offer a partial solution based on its last checkpoint .",
    "furthermore , the partial solution offered by alpine is _ complete _ in itself and has the definite guarantee with regard to a higher minimum support .",
    "thus , these complete sets of co - regulated genes or gene groups with a higher minimum support returned early by alpine can be used to predict the drug response even though the mining process continues .",
    "the high support implies high coverage , which might lead to more widely applicable associations in this case .",
    "besides , as the computational time increases , the built support index is more and more complete and alpine continues to offer those lower support patterns .",
    "many frequent pattern discovery algorithms have been developed in literature and it is not our intention to develop yet another efficient algorithm for finding these patterns . instead",
    ", our aim here is to show the usefulness of anytime data mining . to complete the picture",
    ", we also conducted experiments to evaluate the performance of alpine in mining frequent / closed itemsets in comparison with lcm .    in this set of experiments ,",
    "we select bms - webview-1 , bms - webview-2 , retail , t10i4d100k , chess and mushroom datasets from the fimi repository .",
    "alpine started without any parameter , while lcm was initialized with some minimum support value from alpine s checkpoints for the comparison purpose .",
    "the results are displayed in figure  [ fig : fim ] . in each graph",
    ", the horizontal axis is the absolute minimum support value , and the vertical axis is the runtime .",
    "note that for every transaction database , alpine executes once to mine all frequent or closed itemsets , while lcm runs multiple times for the set of different initial minimum support values .",
    "the curves for alpine_all and alpine_closed in the plots are continuous in the sense that the runtime is known for each distinct @xmath2 value , indicated by solid lines .",
    "in contrast , the lcm_all and lcm_closed are plotted in dashed lines for only the results at markers were tested .",
    "overall , for all instances and minimum support values , the alpine algorithm is comparable to the lcm algorithm , which can be verified from the graphs , though the extra support index information needs to be maintained .",
    "the results validate the effectiveness of the itemset closure operator and the compact itemset interval representation .",
    "generally , the runtime grows much slower for closed itemset mining than that of all frequent itemset mining . for closed itemset mining ,",
    "alpine is slightly slower than lcm , however , the trend and the order of magnitude of the runtime of both algorithms are similar . for all frequent itemset mining , alpine catch up with or even compete with lcm as they get to lower and lower minimum support .",
    "the reason is alpine processes and outputs groups of itemsets compactly in itemset intervals instead of enumerating each individual itemset in an interval .",
    "0.33     0.33     0.33     for sparse datasets like figure  [ fig : bms1 ] - figure  [ fig : t10i4d100k ] , the graphs show similar trends : the curves of lcm and alpine are close to each other and alpine is slightly slower than lcm at the beginning .",
    "the difference between them might further increase in the middle of the curves as they are mining all frequent itemsets , for the overhead in generating and maintaining a large number of itemset intervals below the current @xmath2 might dominate the acceleration of the itemset closure operator and itemset interval compression .",
    "however , as the @xmath2 gets lower and lower , the previously built partial index for lower minimum supports saves the cost for later stages and the low support itemsets might be more compactly grouped in itemset intervals .",
    "that s why we can see alpine might compete with lcm at some lower minimum support value for all frequent itemset mining on these datasets . for",
    "dense datasets in figure  [ fig : chess ] and figure  [ fig : mushroom ] , the compression ratio of itemset intervals is even higher , so alpine becomes faster than lcm for mining all frequent itemsets . this advantage will become more obvious as we get to lower and lower minimum support , as indicated in figure  [ fig : mushroom ] .      in this subsection , we also compared the performance of alpine with seq - miner .",
    "seq - miner mines the top-@xmath75 frequent patterns sequentially and outputs every top @xmath136 ( a user defined chunk size ) patterns .",
    "seq - miner shares some flavor of the contract - type anytime algorithm and it can also provide definite results at each chunk , i.e , all itemsets with support above or equal to the support of the last one in the chunk .",
    "the advantage is similar to the one provided by alpine , checkpoints can now be provided just like alpine .    from the set of datasets used in section  [ section : fim ] , we selected two sparse datasets and one dense dataset as representatives for this experiment , namely , bms - webview-2 , t40i10d100k and mushroom . for seq - miner , the chunk size @xmath136 of these datasets are selected to be @xmath137 , @xmath138 and @xmath139 , respectively , according to the density and output number of frequent patterns of each dataset . the number of patterns generated at each checkpoint and the time to reach that checkpoint is plotted in figure  [ fig : topk ] for both algorithms . in this figure",
    ", the horizontal axis is the running time since the algorithm starts and the vertical axis is the number of generated patterns . between any two of these checkpoints , the intermediate status is unchecked , that s why we got these staircase - shaped curves in figure  [ fig : topk ] .    from these graphs , it s easy to verify",
    "the following facts : 1 ) alpine produces far more number of checkpoints than seq - miner given the same execution time ; 2 ) the step size ( time between two successive checkpoints ) of seq - miner is much longer than that of alpine , and it grows as the running time increases .",
    "the reason is a new and larger fp - tree has to be rebuilt from scratch whenever a given top-@xmath75 is changed in the seq - miner .",
    "every time a new call to the mining algorithm is made with the smaller value of minimum support discovered in the virtualgrowth .",
    "thus , the fp - tree is built many times and the most frequent itemsets are generated again and again .",
    "different from seq - miner , alpine monotonically explores itemset intervals with descending values of support and mines continuously from checkpoint to checkpoint without any redundancy ( never starting from scratch ) .",
    "not surprisingly , the iterative process of seq - miner incurs substantial time penalty as compared to that of alpine .",
    "the step size of seq - miner is related with the parameter - chunk size @xmath136 , and we can reduce the step size by reducing its chunk size . in that case , it will result in more iterations in this iterative process and more repeated work in total .",
    "in general , the number of iterations and the total runtime of seq - miner might grow dramatically as we generate more and more frequent patterns .",
    "this is consistent with the trend displayed in the graphs of figure  [ fig : topk ] that the runtime difference of seq - miner and alpine grows with the increasing of the number of generated patterns .",
    "thus , the superiority of alpine increases with the number of iterations of frequent pattern mining of seq - miner . given the same time , alpine can always generate more frequent patterns than seq - miner .",
    "in other words , using alpine , users can obtain the complete set of itemsets above a lower @xmath2 in the equivalent execution time in comparison with using seq - miner .",
    "alpine turns out to be even more efficient than the contract - type like algorithm , though it is interruptible at any time .",
    "* frequent itemset mining * : a lot of algorithms have been proposed to mine itemsets in the past decade  @xcite , the key is how to efficiently reduce the search space .",
    "apriori - like methods utilize the anti - monotone property to prune candidates  @xcite , fp - growth family employs some highly condensed data structure , such as fp - tree  @xcite or ppc - tree  @xcite , to confine the search space , while prepost+  @xcite introduces the children-parent equivalence pruning strategy .",
    "however , the pruning might be incomplete .",
    "thus , the closure operator @xmath29 is incorporated in other algorithms  @xcite as we do .",
    "in@xcite , duplicated closed itemset may be generated .",
    "the most similar work to ours is the lcm algorithm  @xcite , which also transverses a tree composed of closed itemsets .",
    "however , lcm requires to set the @xmath2 threshold and no completeness guarantees is given for its intermediate partial solutions .",
    "* top-@xmath75 mining * : in concept mining , the top-@xmath75 mining can gradually raise the @xmath2 to mine the @xmath75-most interesting patterns  without specifying a @xmath2 threshold in advance to increase the usability of a data mining algorithm . shen _ et al . _",
    "@xcite first introduced the top-@xmath75 mining problem to generate an appropriate number of most interesting itemsets . the itemset - loop / itemset - iloop algorithm  @xcite based on the apriori approach  @xcite and the tfp algorithm  @xcite extending the fp - growth method  @xcite are developed to mine the @xmath75-most interesting patterns thereafter .",
    "generally , these algorithms follow the same process : initially , the @xmath2 threshold is set to 0 to ensure no pattern will be missing , then the @xmath2 is gradually raised by the algorithm to prune the search space until top-@xmath75 patterns are found . though these algorithms do nt need the parameter @xmath2 , but the threshold @xmath75 is still necessary .",
    "when @xmath75 is too large , mining takes an unacceptably long time ; on the contrary , when @xmath75 is too small , it will miss a lot of potential interesting patterns .",
    "the problem of setting up the value of @xmath2 is now replaced with setting the value of @xmath75 .",
    "thus , hirate _ et .",
    "@xcite propose the tf@xmath140p - growth algorithm to mine the top-@xmath75 pattens sequentially without any thresholds .",
    "tf@xmath140p - growth outputs every top @xmath136 patterns , where @xmath136 is some user - defined chunk size .",
    "for instance , @xmath141 , it sequentially returns exactly the top 1000 , 2000 , 3000 patterns _",
    "etc_. for @xmath136 is a user specified number , it might not return all itemsets having the same support as the last one .",
    "@xcite overcame this shortcoming and proposed an improved algorithm , the seq - miner .",
    "these methods have a flavor of the contract - type anytime algorithms  @xcite , but they can not be interrupted before the termination of every top @xmath136 patterns . in contrast , alpine monotonically explores itemsets with descending values of support and mines continuously from checkpoint to checkpoint , which guarantees the quality of the partial results is checked at any time .    * pattern sampling",
    "* : zhang _ et al . _",
    "@xcite used sampling and incremental mining to support multiple - user inquiries at any time .",
    "et al . _",
    "@xcite proposed to use metropolis - hastings sampling for the construction of data mining systems that do not require any user - specified threshold , _",
    "i.e. _ , minimum support or confidence . however , all the algorithms generate approximate results and the completeness can not be guaranteed .",
    "in this work , we defined the anytime itemset mining problem and proposed the alpine algorithm .",
    "alpine proceeds in the defined anytime mining manner and can be interrupted at any time but offer intermediate meaningful and complete results with definite guarantees .",
    "alpine is , to our knowledge , the first interruptible anytime algorithm to mine frequent itemsets and closed frequent itemsets .",
    "it guarantees that all itemsets with support exceeding the current checkpoint s support have been found before it proceeds further .",
    "this anytime feature is the most important contribution of alpine , which is also fast but not necessarily the fastest algorithm around .",
    "another critical advantage of alpine is that it do not require setting the minimum support apriori , but can be adjusted automatically as the mining process continues .",
    "m.  boley and c.  lucchese and d.  paurat and t.  grtner .",
    "direct local pattern sampling by efficient two - step random procedures . in _ int",
    ". conf . on knowledge discovery and data mining _ ,",
    "pages 582590 , 2011 .",
    "y.  hirate , e.  iwahashi , and h.  yamana .",
    "tf@xmath140p - growth : an efficient algorithm for mining frequent patterns without any thresholds . in _ proceedings of ieee international conference on data mining _ , 2004 .",
    "n.  pasquier , y.  bastide , r.  taouil , and l.  lakhal .",
    "discovering frequent closed itemsets for association rules . in _ proceedings of 7th international conference on database theory ( icdt 99 )",
    "_ , pages 398416 , 1999 .",
    "t.  uno , t.  asai , y.  uchida , and h.  arimura .",
    "lcm : an efficient algorithm for enumerating frequent closed item sets . in _ proceedings of workshop on frequent itemset mining implementations ( fimi03 )",
    "_ , 2003 .",
    "t.  uno , m.  kiyomi , and h.  arimura .",
    "lcm ver.3 : collaboration of array , bitmap and prefix tree for frequent itemset mining . in _ the 1st int .",
    "workshop on open source data mining : frequent pattern mining implementation _ ,",
    "pages 7786 , 2005 ."
  ],
  "abstract_text": [
    "<S> alpine is to our knowledge the first anytime algorithm to mine frequent itemsets and closed frequent itemsets . </S>",
    "<S> it guarantees that all itemsets with support exceeding the current checkpoint s support have been found before it proceeds further . </S>",
    "<S> thus , it is very attractive for extremely long mining tasks with very high dimensional data ( for example in genetics ) because it can offer intermediate meaningful and complete results . </S>",
    "<S> this anytime feature is the most important contribution of alpine , which is also fast but not necessarily the fastest algorithm around . </S>",
    "<S> another critical advantage of alpine is that it does not require the apriori decided minimum support value . </S>"
  ]
}