{
  "article_text": [
    "a software execution trace is a log of information captured during a given execution run of a computer program . for example",
    ", the trace depicted in figure [ fig : trc_ex ] shows the program flow entering function f1 ; calling f2 from f1 ; f2 recursively calling itself , and eventually exiting these functions . in order to capture this information ,",
    "each function in the software is instrumented to log both : entry to it and exit from it .    ....",
    "1 f1 entry      2 | f2 entry      3 | | f2 entry      4 | | f2 exit      5 | f2 exit      6 f1 exit           ....    the comparison of program execution traces is important for a number of problem areas in software development and use . in the area of testing trace comparisons",
    "can be used to : 1 ) determine how well user execution paths ( traces collected in the field ) are covered in testing @xcite ; 2 ) detect anomalous behavior arising during a component s upgrade or reuse @xcite ; 3 ) map and classify defects @xcite ; 4 ) determine redundant test cases executed by one or more test teams @xcite ; and 5 ) prioritize test cases ( to maximize execution path coverage with a minimum number of test cases ) @xcite .",
    "trace comparisons are also used in operational profiling ( for instance , in mapping the frequency of execution paths used by different user classes ) @xcite and intrusion analysis ( e.g. , detecting deviations of field execution paths from expectations ) @xcite",
    ".    for some problems such as test case prioritization , traces gathered in a condensed form ( such as a vector of executed function names or caller - callee pairs ) are adequate @xcite .",
    "however for others , such as the detection of missing coverage and anomalous behavior using state machines , detailed execution paths are necessary @xcite .",
    "the time required for analyzing traces can be critical .",
    "examples of the use of trace analysis in practice include : 1 ) a customer support analyst may use traces to map a reported defect onto an existing set of defects in order to identify the problem s root cause ; 2 ) a development analyst working with the testing team may use trace analysis to identify missing test coverage that resulted in a user - observed defect .    _ research problem and practical motivation _ : to be compared and analyzed , traces must be converted into an abstract format .",
    "existing work has progressed by representing traces as signals @xcite , finite automata @xcite , and complex networks @xcite .",
    "unfortunately , many trace comparison techniques are not scalable @xcite .",
    "for example the finite - state automata based ktail algorithm , when applied to representative traces , did not terminate even after 24 hours of execution @xcite ; similar issues have been experienced with another finite - state automata algorithm , kbehavior @xcite .",
    "these observations highlight the need for fast trace matching solutions .",
    "based on our experience , support personnel of a large - scale industrial application with hundreds of thousands of installations can collect tens of thousands of traces per year .",
    "moreover , a single trace collected on a production system is populated at a rate of millions of records per minute .",
    "thus , there is a clear need for scalable trace comparison techniques .",
    "_ solution approach _ : the need to compare traces , together with a lack of reliable and scalable tools for doing this , motivated us to investigate alternate solutions . to speed up trace comparisons",
    ", we propose that a given set of traces first be filtered , rejecting those that are not going to match with the test cases , allowing just the remaining few to be compared for target purposes . the underlying assumption ( based on our practical experience )",
    "is that most traces are very different , just a few are even similar , and only a very few are identical .",
    "this strategy is implemented and validated in the * * s**calable * * i**terative - un**f**olding * * t**echnique ( sift ) @xcite .",
    "the collected traces are first compressed into several levels prior to comparison .",
    "each level of compression uses a unique signature or `` fingerprint '' . starting with the highest compression level , the traces",
    "are compared , and unmatched ones are rejected .",
    "iterating through the lower levels until the comparison process is complete leaves only traces that match at the lowest ( uncompressed ) level .",
    "the sift objective ends here .",
    "the traces so matched can then be passed on to external tools , such as the ones presented here , for further analysis such as defect or security breach identification .",
    "the process of creating a fingerprint can be interpreted as a map from the very high dimensional space of traces to a low ( ideally one ) dimensional space .",
    "simple examples of such fingerprints are 1 ) the total number of unique function names in a trace ; and 2 ) the number of elements in a trace .",
    "however , while these fingerprints may be useful for our purposes , neither are sufficient .",
    "the `` number of unique function names '' fingerprint does not discriminate enough  many quite dissimilar traces can share the same function names called . at the other extreme",
    ", the number of elements in the trace discriminates too much ",
    "traces which are essentially similar may nonetheless have varying numbers of elements .",
    "the mapping should be such that projections of traces of different types should be positioned far apart in the resulting small space .    using the frequency of the function names called",
    "is the next step in selecting useful traces .",
    "a natural one dimensional representation of this data is the shannon information @xcite , mathematically identical to the entropy of statistical mechanics",
    ". other forms of entropy / information , obeying slightly less restrictive axiom lists , have been defined @xcite . these extended entropies ( as reviewed in @xcite )",
    "are indexed by a parameter @xmath0 which , when @xmath1 reduces them to the traditional shannon entropy and which can be set to make them more ( @xmath2 ) or less ( @xmath3 ) sensitive to the frequency of rare events , improving the classification power of algorithms . indeed , an extended rnyi entropy @xcite with @xmath4 ( known as the hartley entropy of information theory ) applied in the context of this paper returns the `` number of unique function names '' fingerprint .",
    "the entropy concept can also be extended in another way .",
    "traces differ not only in which functions they call but in the pattern linking the call of one function with the call of another . as such it makes sense to collect not only the frequency of function calls , but also the frequency of calling given pairs , triplets , and in general @xmath5-tuples of calls .",
    "the frequency information assembled for these `` @xmath5-words '' can be converted into `` word entropies '' for further discriminatory power .",
    "in addition each record in a trace can be encoded in different ways ( denoted by @xmath6 ) by incorporating various information such as a record s function name or type .    _",
    "research question : _ in this paper we study the applicability of the shannon entropy @xcite and the landsberg - vedral @xcite , rnyi @xcite , and tsallis @xcite entropies to the comparison and classification of traces related to various software defects .",
    "we also study the effect of @xmath0 , @xmath5 , and @xmath6 values on the classification power of the entropies .",
    "note that the idea of using word entropies for general classification problems is not new to this paper .",
    "similar work has been done to apply word entropy classification techniques to problems arising in biology @xcite , chemistry @xcite , analysis of natural languages @xcite , and image processing @xcite . in the context of software traces ,",
    "the shannon entropy has been used to measure trace complexity @xcite . however , no one has yet applied word entropies to compare software traces .",
    "the structure of the paper is as follows : in section  [ sec:2 ] we define entropies and explain the process of trace entropy calculation .",
    "the way in which entropies are used to classify traces is shown in section  [ sec:3 ] .",
    "section  [ sec:4 ] provides a case study which describes and validates the application of entropies for trace classification , and section  [ sec:5 ] summarizes the paper .",
    "in this section we describe techniques for extracting the probability of various events from traces ( section  [ sec:2.1 ] ) and the way we use this information to calculate trace entropy ( section  [ sec:2.2 ] ) .",
    "a trace can be represented as a string , in which each trace record is encoded by a unique character .",
    "we concentrate on the following three character types @xmath6 :    1 .",
    "record s function name ( @xmath7 ) , 2 .",
    "record s type ( @xmath8 ) , 3 .",
    "record s function names , type , and depth in the call tree ( @xmath9 ) .",
    "in addition , we can generate consecutive and overlapping substrings , where @xmath10 .",
    "] of length @xmath5 from a string .",
    "we call such substrings @xmath5-words . for example , a string `` abca '' contains the following 2-words : `` ab '' ; `` bc '' ; and `` ca '' .    one can consider a trace as a message generated by a source with source dictionary @xmath11 consisting of @xmath12 @xmath5-words @xmath13 , @xmath14 , and discrete probability distribution @xmath15 , where @xmath16 is the probability @xmath13 is observed . to illustrate these ideas , the dictionaries @xmath17 and their respective probability distributions @xmath18 for various values of @xmath6 and @xmath5 are summarized in table  [ tab : dic_of_trc ] for the trace shown in figure  [ fig : trc_ex ] .",
    "lrrll    @xmath19 & @xmath20 & @xmath21 & @xmath22 & @xmath23 +    @xmath7 & 1 & 2 & f1 , f2 & 1/3 , 2/3 + @xmath7 & 2 & 3 & f1-f2 , f2-f2 , f2-f1 & 1/5 , 3/5 , 1/5 + @xmath7 & 3 & 3 & f1-f2-f2 , f2-f2-f2 , f2-f2-f1 & 1/4 , 1/2 , 1/4 + @xmath8 & 1 & 4 & f1-entry , f1-exit , f2-entry , f2-exit & 1/6 , 1/6 , 1/3 ,",
    "1/3 + @xmath9 & 1 & 6 & f1-entry - depth1 , f1-exit - depth1 ,    f2-entry - depth2 , & 1/6 , 1/6 , 1/6 , + &    &    & f2-exit - depth2 , f2-entry - depth3 , f2-exit - depth3 & 1/6 , 1/6 , 1/6 +    define a function @xmath24 that , given a trace @xmath25 , will return a discrete probability distribution @xmath18 for @xmath5-words of length @xmath5 and characters of type @xmath6 : @xmath26 the above empirical probability distribution @xmath18 can now be used to calculate the entropy of a given trace for a specific @xmath5-word with type-@xmath6 characters . for notation convenience",
    "we suppress the dependence of @xmath18 ( and the individual @xmath27 s ) on the @xmath25 , @xmath5 , and @xmath6 .",
    "we now define entropies and discuss how we can utilize @xmath18 to compute them .",
    "the shannon entropy @xcite is defined as @xmath28 where @xmath18 is the vector containing probabilities of the @xmath12 states , and @xmath27 is the probability of @xmath29-th state .",
    "the logarithm base @xmath30 controls the units of entropy . in this paper",
    "we set @xmath31 , to measure entropy in bits .",
    "three extended entropies , landsberg - vedral @xcite , rnyi @xcite , and tsallis @xcite are defined as : @xmath32}}{{1 - q } } , \\text { and}\\\\      { h_t}(p;q ) & = & \\frac{{q(p;q ) - 1}}{{1 -q } } , \\nonumber\\end{aligned}\\ ] ] respectively , where @xmath33 is the entropy index , and @xmath34    these extended entropies reduce to the shannon entropy ( by lhpital s rule ) when @xmath1 .",
    "the extended entropies are more sensitive to states with small probability of occurrence than the shannon entropy for @xmath35 . setting @xmath3 leads to increased sensitivity of the extended entropies to states with high probability of occurrence",
    "the entropy @xmath36 of a trace @xmath25 for a given @xmath5 , @xmath6 , and @xmath0 is calculated by inserting the output of equation  ( [ eq : p ] ) into one of the entropies described in equations ( [ eq : s ] ) and ( [ eq : lht ] ) : @xmath37\\end{aligned}\\ ] ] where @xmath38 .",
    "note that if @xmath39 then @xmath0 is ignored , since in fact it must be that @xmath1 .",
    "a typical scenario for trace comparison is the following .",
    "a software service analyst receives a phone call from a customer reporting software failure .",
    "the analyst must quickly determine the root cause of this failure and identify if 1 ) this is a rediscovery of a known defect exposed by some other customer in the past or 2 ) this is a newly discovered defect .",
    "if the first case is correct then the analyst will be able to provide the customer with a fix - patch or describe a workaround for the problem .",
    "if the second hypothesis is correct the analyst must alert the maintenance team and start a full scale investigation to identify the root - cause of this new problem . in both cases time",
    "is of the essence ",
    "the faster the root cause is identified , the faster the customer will receive a fix to the problem .    in order to validate the first hypothesis , the analyst asks the customer to reproduce the problem with a trace capturing facility enabled .",
    "the analyst can then compare the newly collected trace against a library of existing traces collected in the past ( with known root - causes of the problems ) and identify potential candidates for rediscovery . to identify a set of traces relating to similar functionality the library traces",
    "are usually filtered by names of functions present in the trace of interest .",
    "after that the filtered subset of the library traces is examined manually to identify common patterns with the trace of interest .    if the analyst finds an existing trace with common patterns then the trace corresponds to a rediscovered defect .",
    "otherwise the analyst can conclude that this failure relates to a newly discovered defect .",
    "this process is similar in nature to an internet search engine .",
    "a user provides keywords of interest and the engine s algorithm returns a list of web pages ranked according to their relevance .",
    "the user examines the returned pages to identify her most relevant ones .    to automate this approach using entropies as fingerprints ,",
    "we need an algorithm that would compare a trace against a set of traces , rank this set based on the relevance to a trace of interest , and then return the top @xmath40 closest traces for manual examination to the analyst . in order to implement this algorithm",
    "we need the measure of distance between a pair of traces described in section  [ sec:3.1 ] , and the ranking algorithm described in section  [ sec:3.2 ] .",
    "the algorithm s efficiency is analyzed in section  [ sec:3.3 ] .",
    "we can obtain multiple entropy - based fingerprints for a trace by varying values of @xmath41 , @xmath0 , @xmath5 and @xmath6 .",
    "denote a complete set of 4-tuples of @xmath42 $ ] as @xmath43 .",
    "we define the distance between a pair of traces @xmath44 and @xmath45 as : @xmath46 - { h_{{e_k}}}\\left [ { \\alpha ( { t_j};{l_k},{c_k});{q_k } } \\right ] } } { { \\max \\left\\ { { { h_{{e_k}}}\\left [ { \\alpha ( t;{l_k},{c_k});{q_k } } \\right ] } \\right\\ } } } } \\right|}^w } } } \\right)^{1/w } , \\end{aligned}\\]]where @xmath47 is the number of elements in @xmath43 , @xmath48 controls ; experimental analysis shows that our results are robust to the value of @xmath48 ( c.f . , appendix  [ sec : p ] for more details ) . ]",
    "the type of `` norm '' , @xmath49 } \\right\\}$ ] denotes the maximum value of @xmath50 for the complete set of traces under study for a given @xmath51 , @xmath52 , and @xmath53 ; @xmath54 indexes the 4-tuple @xmath55 $ ] in @xmath43 with @xmath56 , @xmath51 , @xmath52 , and @xmath53 indicating the entropy , @xmath0 , @xmath5-word length and character type for the @xmath54-th 4-tuple , @xmath57 .",
    "this denominator is used as a normalization factor to set equal weights to fingerprints related to different 4-tuples in @xmath43 .",
    "formula [ eq : d_all ] satisfies three of the four usual conditions of a metric : @xmath58    however , the fourth metric condition , @xmath59 ( identity of indiscernibles ) , holds true only for the fingerprints of traces ; the actual traces may be different even if their entropies are the same .",
    "in other words , the identity of indiscernibles axiom only `` half '' holds : @xmath60 but @xmath61 as such , @xmath62 represents a pseudo - metric .",
    "note that @xmath63 and our hypothesis is the following : the larger the value of @xmath62 , the further apart are the traces .",
    "note that for a single pair of entropy - based fingerprints the normalization factor in equation  ( [ eq : d_all ] ) can be omitted and we define @xmath62 as @xmath64 - { h_e}\\left [ { \\alpha ( { t_j};l , c);q } \\right ] } \\right| . \\end{aligned}\\ ] ]    entropies have the drawback that they can not differentiate dictionaries of events , since entropy formulas operate only with probabilities of events .",
    "therefore , the entropies of the strings `` f1-f2-f3-f1 '' and `` f4-f5-f6-f4 '' will be exactly the same for any value of @xmath41 , @xmath5 , @xmath6 , and @xmath0 .",
    "the simplest solution is to do a pre - filtering of traces in @xmath65 in the spirit of the sift framework described in section  [ sec:1 ] .",
    "for example , one can filter out all the traces that do not contain `` characters '' ( e.g. , function names ) present in the trace of interest before using entropy - based fingerprints .",
    "we now define an algorithm for ranking a set of traces with respect to the trace of interest .      given a task of identifying the top @xmath40 closest classes of traces from a set of traces @xmath65 closest to trace @xmath25 we employ the following algorithm :    1 .",
    "calculate the distance between @xmath25 and each trace in @xmath65 ; 2 .",
    "sort the traces in @xmath65 by their distance to trace @xmath25 in ascending order ; 3 .   replace the vector of sorted traces with the vector of classes ( e.g. , defect ids ) to which these traces map ; 4 .",
    "keep the first occurrence ( i.e. , the closest trace ) of each class in the vector and discard the rest ; 5 .",
    "calculate the ranking of classes taking into account ties using the `` modified competition ranking '' approach ; 6 .",
    "return a list of classes with ranking smaller than or equal to @xmath40 .",
    "the `` modified competition ranking '' can be interpreted as a worst case scenario approach .",
    "the ordering of traces of equal ranks is arbitrary ; therefore we examine the case when the most relevant trace will always reside at the bottom of the returned list . to be conservative",
    ", we consider the outcome in which our method returns a trace in the top @xmath40 positions as being in the @xmath40-th position .",
    "now consider an example of the algorithm .",
    "[ sec:3.2.1 ]    assume we have five traces @xmath44 , @xmath66 related to four software defects @xmath67 , @xmath68 as shown in table [ tab : ex_t_d ] : trace @xmath69 relates to defect @xmath70 ; traces @xmath71 and @xmath72 relate to defect @xmath73 ; trace @xmath74 to defect @xmath75 ; and trace @xmath76 to defect @xmath77 .",
    ".example : relation between traces and defects [ cols=\"<,<\",options=\"header \" , ]",
    "we have observed that the classification power of the @xmath78 $ ] metric is highest when @xmath79 . in order to explain this phenomenon we expand @xmath80 $ ] ( given in equation  ( [ eq : lht ] ) ) in a taylor series :    @xmath81 & \\mathop = \\limits^{q \\to 0 } &   1 - \\frac{1 } { { { n_i } } }   + q\\left ( \\frac{{{a_i}}}{{n_i^2 } } + \\frac{{{n_i } - 1}}{{{n_i } } } \\right ) + o({q^2 } ) , \\nonumber \\\\",
    "{ h_r}\\left [ { \\alpha ( { t_i};l , c);q } \\right ] & \\mathop   = \\limits^{q \\to 0 } & { \\log _ 2}({n_i } )   \\\\ & + & q\\left [ { \\frac{{{a_i } } } { { \\ln ( 2){n_i } } } + { { \\log } _ 2}({n_i } ) } \\right ] + o({q^2 } ) , \\text { and } \\nonumber \\\\    { h_t}\\left [ { \\alpha ( { t_i};l , c);q } \\right ] & \\mathop   = \\limits^{q \\to 0 } & { n_i } - 1 + q\\left ( { { a_i } + n - 1 } \\right ) + o({q^2 } ) , \\nonumber \\end{aligned}\\ ] ]      equation  ( [ eq : d_approx ] ) can be interpreted as follows . in the case",
    "in which @xmath79 and the dictionaries for each trace in the pair are similar , the key contribution to the measure of distance is coming from the @xmath85 term ( which depends only on @xmath5 and @xmath6 ) making the rest of the variables irrelevant ( @xmath0 and @xmath12 become parts of scaling factors ) .",
    "this can be highlighted by solving a system of equations to identify conditions that generate the same ordering for three traces @xmath86 for all extended entropies ( using approximations from ( [ eq : d_approx ] ) ) :      in information theory @xmath88 measures the `` surprise '' ( in bits ) in receiving symbol @xmath54 which is received with probability @xmath89 .",
    "thus @xmath90 is the expected surprise or information ( shannon entropy ) .",
    "what about just @xmath91 ?",
    "it scales with the total number of bits needed to specify each symbol .",
    "this is related to the problem of simulating processes in the presence of rare events , see @xcite for details .",
    "d.  cotroneo , r.  pietrantuono , l.  mariani , and f.  pastore .",
    "investigation of failure causes in workload - driven reliability testing . in _ proceedings of the 4th international workshop on software quality assurance : in conjunction with the 6th esec / fse joint meeting _ , pages 7885 , 2007 .",
    "m.  haran , a.  karr , a.  orso , a.  porter , and a.  sanil .",
    "applying classification techniques to remotely - collected program execution data . in _ proceedings of the 10th european software engineering conference held jointly with 13th acm sigsoft international symposium on foundations of software engineering _ ,",
    "pages 146155 , 2005 .",
    "m.  hutchins , h.  foster , t.  goradia , and t.  ostrand .",
    "experiments of the effectiveness of dataflow- and controlflow - based test adequacy criteria . in _ proceedings of the 16th international conference on software engineering _ , pages 191200 , 1994 .",
    "j.  a. jones and m.  j. harrold .",
    "empirical evaluation of the tarantula automatic fault - localization technique . in _ proceedings of the 20th ieee / acm international conference on automated software engineering _ , pages 273282 , 2005 .",
    "w.  lee , s.  j. stolfo , and p.  k. chan . learning patterns from unix process execution traces for intrusion detection . in _ proceedings of the aaai workshop on ai approaches to fraud detection and risk management _ ,",
    "pages 5056 , 1997 .",
    "a.  v. miranskyy , m.  s. gittens , n.  h. madhavji , and c.  a. taylor .",
    "usage of long execution sequences for test case prioritization . in _",
    "supplemental proceedings of the 18th ieee international symposium on software reliability engineering _ , 2007 .",
    "a.  v. miranskyy , n.  h. madhavji , m.  s. gittens , m.  davison , m.  wilding , d.  godwin , and c.  a. taylor . a scalable iterative - unfolding technique for filtering execution traces . in _ proceedings of the 2008 conference of the center for advanced studies on collaborative research",
    "_ , pages 274288 , 2008 .",
    "s.  s. murtaza , m.  gittens , z.  li , and n.  h. madhavji .",
    "f007 : finding rediscovered faults from the field using function - level failed traces of software in the field . in _ proceedings of the 2010 conference of the center for advanced studies on collaborative research _ , pages 5771 , 2010 .",
    "a.  podgurski , d.  leon , p.  francis , w.  masri , m.  minch , j.  sun , and b.  wang .",
    "automated support for classifying software failure reports . in _ proceedings of the 25th international conference on software engineering _ , pages 465475 , 2003 .",
    "g.  rothermel , m.  j. harrold , j.  ostrin , and c.  hong",
    ". an empirical study of the effects of minimization on the fault detection capabilities of test suites . in _ proceedings of the international conference on software maintenance _",
    ", page  34 , 1998 .                c.  yuan , n.  lao , j.  wen , j.  li , z.  zhang , y.  wang , and w.  ma . automated known problem diagnosis with event traces . in _ proceedings of the 1st",
    "acm sigops / eurosys",
    "european conference on computer systems 2006 _ , pages 375388 , 2006 ."
  ],
  "abstract_text": [
    "<S> the analysis of execution paths ( also known as software traces ) collected from a given software product can help in a number of areas including software testing , software maintenance and program comprehension . </S>",
    "<S> the lack of a scalable matching algorithm operating on detailed execution paths motivates the search for an alternative solution .    </S>",
    "<S> this paper proposes the use of word entropies for the classification of software traces . using a well - studied defective software as an example </S>",
    "<S> , we investigate the application of both shannon and extended entropies ( landsberg - vedral , rnyi and tsallis ) to the classification of traces related to various software defects . </S>",
    "<S> our study shows that using entropy measures for comparisons gives an efficient and scalable method for comparing traces . </S>",
    "<S> the three extended entropies , with parameters chosen to emphasize rare events , all perform similarly and are superior to the shannon entropy . </S>"
  ]
}