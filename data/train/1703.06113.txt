{
  "article_text": [
    "the enumeration of structures is a primal theme of combinatorics . whereas the problem of enumerating the labeled tree graphs has been solved by borchardt @xcite  and",
    "subsequently improved by cayley @xcite  over one century ago , an analogue for the unlabeled case remained elusive . here , we present an algorithm that , on input @xmath0 , lists every [ unlabeled ] tree of order @xmath0 exactly once .",
    "+ before we begin , a couple remarks on notational conventions and terminology : a _ multiset _ is a duple @xmath1 , where @xmath2 is a set , called the _ underlying set _ and @xmath3 is the so - called @xmath4 .",
    "a partition @xmath5 of a natural number @xmath0 is a multiset @xmath6 , @xmath7 such that @xmath8 .",
    "we denote by @xmath9 the set of all partitions of @xmath0 , and exceptionally , cortiously let ( 0,(0,1 ) ) be the unique partition of zero .",
    "+ additionally , by @xmath10 we denote the linear [ sometimes called  path \" ] graph on @xmath0 vertices , that connected graph which either contains exactly two vertices of degree one , all other vertices having degree two , or is the unique graph on one vertex .",
    "our algorithm works in a series of steps , illustrated below for the case where our input @xmath11 .",
    "+ _ fig . 1 _    that is , at the @xmath12 step , we have the linear graph @xmath13 , which we call our _ backbone _ , plus @xmath14  free \" vertices . within each of these steps , we _ append _",
    "the @xmath14 free vertices to the backbone  that is , add an edge between a free vertex and a vertex of the backbone  in every possible way , while avoiding repetitions and conserving diameter_i.e .",
    "_ all trees generated at step @xmath14 must have diameter @xmath15 , and then print out the resulting trees .",
    "2 _    above",
    "we have a few examples of trees we might run into upon initialization of our algorithm on input @xmath16 at steps zero , and three through five , respectively .",
    "moreso , the figure above evinces a phenomenon to keep in mind : not only can we append our free vertices _ directly _ to our backbone , as in the second tree above , but we can also combine them with one another before doing so , as in the third and fourth trees , forming _ compound appendices _ ; to the free vertices that were added directly to our backbone , as in the second tree , we by contrast refer as _",
    "singular appendices_. appendices , compound or not , can also be _ linear _ , as in the second and third trees , or _",
    "nonlinear_. appendices that have already been connected to the backbone we call _ substituents_. + but there is more than seemingly unnecessary terminological conventions to the figure above : as a matter of fact , instead of jumping straight into our algorithm , we will visit the two simpler cases exemplified by the second and third trees above , viz .",
    "those where we can only append the free vertices to our backbone directly or as halves of linear graphs , so as to warm us up and gather insight which shall later come to us useful .",
    "how many ways are there to append @xmath14 free vertices directly to a backbone of order @xmath0 ?",
    "the nave way tells us that there are @xmath17 possibilities ; however this of course leads to redundancies .",
    "3 _    in any given backbone , appending free vertices directly to vertices of same color as in the figure above results in the same tree . of course",
    ", if we only have one free vertex to append then we might as well just cut our backbone in half .",
    "things do get more complicated as the number of free vertices that are to be appended grows , however in fact , cutting our trees into  half - trees \" shall prove to be a didactic experiment , helping us deal with the aforeseen symmetry .",
    "+ _ fig . 4 _    above we have a half - backbone of order four with three free vertices to be directly appended .",
    "being devoid of symmetry , unlike their ` complete ' congeners , the matter of appending a given number of free vertices directly to a half - backbone of a given order is trivial .",
    "indeed , the figure below hints at a mechanical method we can employ to generate all the possible trees that could arise therefrom , without repetitions .     + _ fig .",
    "5 _    and with some further thought , one can see that there are @xmath18 ways to append @xmath14 free vertices directly to a half - backbone of order @xmath0 , where    @xmath19    now to pass from half - backbones to full backbones , we proceed as follows : we regard a backbone of order @xmath20 as two half - backbones , @xmath21 ; if we are to append @xmath14 free vertices directly to this backbone , then there are the following options : we can append @xmath14 free vertices directly to @xmath22 and zero to @xmath23 ; or we can append @xmath24 free vertices directly to @xmath22 and one to @xmath23 ; or @xmath25 to @xmath22 and two to @xmath23 , and so on , up until @xmath26 to @xmath22 and @xmath27 to @xmath23if we went further than that then we would be going backwards , as illustrated in the figure below for the case where we have a backbone of order six , split into two half - backbones of order three , and four vertices to append .",
    "6 _    and at each of these steps , we can  glue \" our half - trees into trees .",
    "but how many ways are there to do that ?",
    "if we append @xmath28 free vertices to @xmath22 and @xmath29 free vertices to @xmath23 , then there are only two options : +    \\(a ) @xmath30 , in which case , the sets of half - trees generated [ from appending @xmath31 free vertices to @xmath32 and @xmath33 free vertices to @xmath34 have no elements in common , and thus there are in total @xmath35 trees that result from the gluing of the half - trees@xmath0 assumed to be the order of the half - trees ; + ( b ) @xmath36 , in which case the sets are the same , and as such there are @xmath37 trees resulting from the gluing of the half - trees .",
    "+    from the above we can thus derive that there are    @xmath38    ways to directly append @xmath14 free vertices to a backbone of order @xmath20 , where    @xmath39    is our gluing function .",
    "+ this however only solves the case for even backbones . to deal with odd backbones , we proceed as follows : we regard a backbone of order @xmath40 as two half - backbones of order @xmath0the  sides\" and one extra vertex  the  middle \" .",
    "and now we do as earlier : if we are to append @xmath14 free vertices directly to an odd backbone , we can append @xmath14 free vertices to the sides and zero to the middle ; or we can append @xmath24 free vertices to the sides and one to the middle , and so on , up until zero free vertices to the sides and @xmath14 to the middle . + as such we obtain that there are    @xmath41    ways to append @xmath14 free vertices to a backbone of order @xmath0 , where @xmath42 is just a function that maps its input to one , if it is odd , and to zero otherwise .",
    "7 _    there is yet another thing that we must note . recall how we stated that our algorithm requires that all trees resulting from the appending of the free vertices to the backbones have the same diameter as their backbones .",
    "above we see a tree with diameter eight generated by the appending of two free vertices to a backbone of diameter six .",
    "were we to allow this genre of thing in our algorithm , we would have repetitions : indeed , were we to initialize our algorithm on input @xmath43 , then the tree above would be listead [ at least ] twice : once on the zeroth step , as the backbone of order eight with no substituents ; and then again at step two .",
    "+ in our case dealing only with the direct appending of free vertices to backbones , the solution to this is simple : we just forbid substituents at end vertices of our backbones .",
    "we shall see how things play out in other settings shortly .      here",
    ", we can combine our set of free vertices into halves of linear graphs before appending them to our backbone .",
    "first let us examine how the simplest cases of this episode behave : those where all appendices are equal .",
    "+ notice how we can use the very same methods from the previous subsection here to append linear appendices to our backbones and half - backbones .",
    "the sole difference lies in how we can commit to our conservation of diameter restriction .     + _",
    "8 _    the tree above was obtained from a backbone of diameter four , and yet displays diameter five , despite the fact that the substituent is not found on the end vertex .",
    "nonetheless , the solution to this is simple : we stipulate that appendices of radius @xmath44 must be appended to vertices of the backbone with distance equal to or greater than @xmath44 from an end vertex , the end vertices themselves having distance zero .",
    "+ with this , we can obtain that there are    @xmath45    ways to append @xmath14 appendices of radius @xmath44 to a backbone of order @xmath0 such that the resulting trees all have diameter @xmath0 .",
    "+ however even though we are equipped to compute the number of and mechanically generate trees obtained by the appending of linear appendices to backbones , we can only do so when all appendices in question are all of equal radii .",
    "let us see how things go when we are without this prerogative .",
    "+ the first thing to note is that , evidently , the dividing of a set of @xmath14 free vertices into halves of linear graphs coincides with integer partitions of @xmath14 .",
    "+ now suppose we are faced with the following :     + _ fig .",
    "9 _    we know how to both generate [ while conserving diameters ] the trees from the appending of the two singular vertices and from the appending of the one half line graph of order two , though so far only separately .",
    "+ _ fig . 10 _    to attain simultaneity , we can  combine \" the trees generated from appendices of different radii .",
    "above we see the results of combining the top - right tree with the top - left and bottom trees [ fig .",
    "one can see that there are two ways to combine the top - right tree with the top - left one , though only one way to combine the top - right one with the bottom one .",
    "evidently this is a matter of symmetry . without much thought",
    "one can notice that whenever a symmetric tree is combined with another tree  be this second one symmetric or asymetric  there is only one possible combination , and when two asymmetric trees are combined , there are two possibilites .",
    "+ let us then introduce the @xmath46 operation : for two sets @xmath47 of trees of same diameter , let @xmath48 denote the set of all trees resulting from combining @xmath49 with @xmath50 ; patently we have that    @xmath51    where by @xmath52 we denote the number of symmetric , resp .",
    "asymmetric trees in @xmath53 .",
    "+ let us denote by @xmath54 the set of all trees generated by appending @xmath14 linear appendices of radius @xmath44 to a backbone of order @xmath0 without altering its diameter ; we can calculate this set s cardinality with equation ; however if we are interested in the cardinality of the set of trees generated by combining several @xmath55 s , then we also need to calculate their @xmath56 and @xmath57 .",
    "clearly , if @xmath14 is odd , then @xmath58 , and if @xmath14 is even , then @xmath59 ; from these , @xmath60 can trivially be derived . + armed with these",
    ", we can calculate the number of trees that arise from the combination of two sets of trees generated by the appending of halves of linear graphs of two different radii ; however we will also want to calculate combinations of combinations of several sets of graphs . by noting that the combination of an asymmetric tree with any other tree  be it symmetric or asymmetric  yields an asymmetric tree , and that the combination of two symmetric trees yields a symmetric tree",
    ", we can determine that    @xmath61    whence again @xmath62 can trivially be inferred .",
    "+ there is just one last thing with which we must deal before concluding our work here , and as in the previous subsection , it pertains to odd graphs and their middles . in the case where all appendices were singular , we proceeded by gradually increasing the number of free vertices directly appended to the middle ; but in this here case , we are dealing with partitions , and if we just increase those blindly , mistakes can happen .",
    ". 12 _    in the bottom - left tree above , for example , the middle substituent has radius greater than the distance between the vertex to which it is appended and an end vertex , violating our rule ; indeed , even though it was generated from a backbone of diameter five , it displays diameter six .",
    "we need , as such , to discard those partitions .",
    "+ putting all of the above together , we can obtain that there are    @xmath63\\ ] ]    trees generated by appending a set of @xmath14 free vertices as halves of linear graphs to a backbone of order @xmath0 , where    @xmath64    is the function that prevents appendices that are  too long \" to be appended to the middle vertex by checking the greatest element of the underlying set of the given partition  corresponding to the appendix of greatest radius .",
    "we are now ready to tackle the case where the free vertices are allowed to combine with one another in any way they please .",
    "the first challenge thus to us presented is finding all possible such combinations  of compound appendices .",
    "note how compound appendices coincide with half - trees .",
    "the following is an overview of a procedure to list all half - trees of a given order .",
    "13 _    just as we said that our algorithm for the listing of trees would be divided in steps , so will be our algorithm for the listing of half - trees : at the @xmath12 step we have a ( half-)backbone of order @xmath15 and @xmath14 free vertices , @xmath0 being our input ; illustrated above is the case for @xmath11 . within each of those steps",
    "we do as follows : we go over the partitions of @xmath14 , and for each of those we  apply \" them to our set of @xmath14 free vertices .",
    "that is , if @xmath66 , say , and we have @xmath67 as our given partition , then we shall divide our @xmath14 free vertices into three half - trees of order two , and three half - trees of order three .",
    "14 _    and for each of those sets of half - trees of same order , we can choose from the set of all half - trees of that given order to form our _ fixed order half - three multiset _ , as seen above for the case of the aforementioned partition on @xmath66 : there are only two half - trees of order three ; in our partition we must have three of those , so naturally there are @xmath68 possible fixed order half - three multisets to choose from",
    ". meanwhile , there is only one half - three of order two .",
    "now , we can choose any combination of fixed order half - tree multisets to  manifest \" our partition , yielding us our _ appendix set _ , itself a multiset whose underlying set has half - trees as elements , the union of its fixed order half - tree multiset constituents .",
    "+     + _ fig . 15 _",
    "we go over all appendix sets , and for each @xmath69 of them , for each @xmath70 , we list all of the half - trees generated by appending @xmath71 appendices @xmath72 to our half - backbone in question while conserving radius . in the figure above , for example we have chosen one of the appendix sets from fig .",
    "14 and apply it to a half - backbone of order four .",
    "+ so far , everything is just like earlier when all substituents were linear .",
    "indeed , most of the times we can treat nonlinear substiuents in the same manner we treat linear ones , but as we shall see later they have a behavior of their own . for the purpose of this overview , we can simply ignore that and assume that we already know how to deal with them .",
    "+ now , as earlier , we combine our half - trees and obtain our set of half - trees generated from appendix set @xmath69 applied to the given half - backbone . + recapitulating in a clumsy mixture of prose and pseudocode ,    .... ht_n : = { } for k in [ 0,n-2 ] :      for p in p(k ) :          for as generatable from p :              for a in as :              generate h .-",
    "'s by appending m_as(a ) a 's to half - backbone of order n - k          combine h .-",
    "t . 's generated from different a 's          append the results to ht_n ....    where ` ht_n ` is meant to be the set of all half - trees of order @xmath0 , to which we add the sets of half - trees generated by appending @xmath14 free vertices , combined as per every appendix set generatable from every partition of @xmath14 to half - backbones of order @xmath15 .",
    "@xmath65 + and now we turn to the aforementioned peculiarity of nonlinear appendices .",
    "+ _ fig . 16 _",
    "consider the two half - trees above .",
    "each was generated by appending three free vertices to a half - backbone of order four , though by different appendix sets and partitions , and as such  were we to ignore the peculiarities of nonlinear appendices ; above we have assumed that we already know how to deal with those  would both be listed , were we to initialize our algorithm for listing half - trees on input @xmath73 , at the third step .",
    "however note how they are isomorphic .",
    "+ let us call a substituent of radius @xmath44 that is appended to a vertex of the half - backbone with distance exactly @xmath44 from the half - backbone [ such as the nonlinear substituent on the tree to the left in the figure above ] _",
    "terminal_. one can easily verify that often times , when appending nonlinear substituents terminally , the resulting half - tree is isomorphic to another half - tree generated from the same number @xmath14 of free vertices , but with different appendix set .",
    "other times , this does not happen , as in the top tree in the figure below .",
    "17 _    to deal with this , we will introduce an ordering relation @xmath74 on the half - trees . in a tree with a terminal substiuent , call the half - tree formed by cutting the edge between the vertex of the half - backbone to which the substituent in question is appended and its neighbor closer to the end vertex  in fig .",
    "17 above , merely everything to the left of the blue vertex  of the half - backbone the _ tip _ induced by that substituent .",
    "we stipulate that an appendix @xmath72 can only be appended terminally if we have that @xmath75 , where @xmath76 is the tip it shall thereby induce .",
    "+ the idea behind @xmath74 shall be simple .",
    "consider an expanded version of the aforementioned algorithm for the listing of all half - trees of a given order wherein all half - trees of all orders are listed : we simply go over the positive integers , starting from one , and run the algorithm above at each of those .",
    "we will say that for two half - trees @xmath77 , we have that @xmath78 if by this expanded algorithm , @xmath72 is listed before @xmath79 . + as such it is required of us that we order the ` for ` s within our first algorithm , define an ordering on the partitions of a given integer , and then on the appendix sets of a given partition . to order these last ones in turn",
    ", we need an ordering on the fixed order half - tree multisets",
    ". + let us begin with the ordering @xmath80 on the partitions . to decide the relationship between two given partitions @xmath81 of the same integer , we proceed as follows :    .... 1 .",
    "x_p : = p * 2 .",
    "x_q : = q * 3 .",
    "if max{i in x_p } < max{j in x_q } :          then p <",
    "q      else :          if m_p(max{i in x_p } ) < m_q(max{j in x_q } :              then p < q          else :              x_p -= max{i in x_p }              x_q -= max{j in x_q }              go to step 3 ....    that is , we compare the greatest part of the partitions , and then its multiplicity , and then the second greatest part , and then its multiplicity and so on . in the procedure described above , at some point , ` x_p ` and ` x_q ` ( our containers ) will become empty , and then , seeing as all previous comparison of parts and their multiplicities led to a tie , the partitions will be equal . it also does nt hurt to notice that it is impossible for one of the ` x ` s become empty before the other  if a partition @xmath5 has fewer parts than another partition @xmath82 on the same integer , by our definition we will have @xmath83 and our algorithm will decide that before we run out of parts .",
    "+ next , an ordering on the appendix sets .",
    "first , only appendix sets generated from the same partition are important to us . this ordering here will be similar to our ordering on the partitions : recall that an appendix set consists of fixed order half - three multisets , each derived from a part of the partition whence the appendix set was generated .",
    "assuming an ordering on these last ones , we simply proceed just like we did for partitions : for two appendix sets @xmath84 generated from the same partition @xmath5 , we compare first the fixed order half - three multiset derived from @xmath85 and so on .",
    "+ thus , on to the ordering @xmath86 on the fixed order half - three multisets .",
    "let us denote by @xmath87 the set of all half - trees of order @xmath0 .",
    "to each @xmath88 we assign a prime number as follows : to the first half - tree that is listed by the first half - tree listing algorithm ( the one that lists half - trees of a given input ) , @xmath89 is assigned ; to the second , @xmath90 is assigned , and so on .",
    "for a half - tree @xmath91 , let us denote by @xmath92 the prime number thereto assigned .",
    "now for a fixed order half - tree multiset @xmath93 we let    @xmath94    now we define that for two fixed order half - tree multisets ( of half - three of same order ) @xmath95 , we have that @xmath96 iff @xmath97.@xmath65 + now , at first sight it might seem self - referential , impossible or illegal devise an ordering on the half - trees based on an ordering on fixed order half - tree multisets that is itself based on the ordering on the half - trees .",
    "however notice that the smallest half - trees , by virtue of being simple , are greater or lesser than one another not because of the fixed order half - tree multisets that make up their appendix set , but rather because of petty differences in their radii or even partitions on their free vertex set : these minimal trees are too little to make room for such complexity . as our half - trees grow and the first half - trees start to exhibit big free vertex sets allowing diverse appendix sets , these last ones , in their turn , will be made out of the simpler half - trees , which will have already been ordered , and induce themselves an ordering on the larger half - trees .",
    "+ armed with all of the above , we are now able to go in greater depth into our half - tree listing algorithm , whence we shall subsequently , at last , derive our tree listing algorithm . having fixed @xmath0 our input , +    @xmath98 for natural @xmath99 $ ] : + @xmath98 for each @xmath100 : + @xmath98 for each appendix set @xmath69 generatable from @xmath101 : + @xmath98 for each @xmath70 : + @xmath98 generate @xmath102 ; + @xmath98 combine all of the @xmath102 s ; + @xmath98 list the half - trees in the resulting set .",
    "+    a few comments are warranted : +  in keeping with the orderings we devised above , at the second , third and fourth bullets we go over the partitions , appendix sets and half - trees respectively in increasing order ; +  here , @xmath103 is an extension of our @xmath93 from the previous subsection ; whereas the latter only took numbers as inputs  seeing as all graphs with which it dealt coincided with numbers  the former s second argument is a half - tree ; as such , @xmath104 is the set of all half - trees generated by appending @xmath14 half - trees @xmath72 to a half - backbone of order @xmath0 while conserving radius ( here we allow nonlinear appendices to be appended terminally , for our half - trees are not done yet ) ; +  it is in the combine step that lie the nottiness the nonlinear appendices bring to the table ; trees without terminal nonlinear substituents can be combined freely , however when combining a tree with terminal nonlinear substituents @xmath105 , it must be verified if the induced tip @xmath76 is such that @xmath106 . as such , it must be the case that when combining the @xmath104 s , we begin from the half - trees of substituents of least radius , so that when the time comes to deal with a half - tree with a nonlinear terminal substituent , all appendices that could have been appended to the tip have already been ; +  at last the listing of the half - trees must be orderly . for many half - trees",
    "arise from the same appendix set , partition and half - backbone and yet we must order these as well . here",
    ", we do so according to the position of the substituents .",
    "the simple idea is that the trees that have the smallest ( by @xmath74 ) substituents closer to the end are lesser , in keeping with the the mechanical method we employ to append a given number of free vertices onto a half - backbone ( cf .",
    "fig . 5 and many others ) .",
    "this is solved for the case were all substituents are equal , however we still must with half - trees with varied substituents .",
    "we do this as follows : for two trees with the same substituents @xmath107 , we first verify how close to the end vertex the @xmath108 substituents are in both trees ; there being a tie there , we go on to consider the @xmath109 substituents and so on .",
    "@xmath65    at last , our algorithm for the listing of trees  which by now should look like an obvious extension of the one for half - trees above , seeing as the only additions are the steps where we fuse the half - trees and deal with the middle vertices : having @xmath0 our input been fixed , + @xmath98 for natural @xmath110 $ ] : + @xmath98 if @xmath15 is even : + @xmath98 for @xmath100 : + @xmath98 for each appendix set @xmath69 generatable from @xmath101 : + @xmath98 for each @xmath70 : + @xmath98 for natural @xmath111 $ ] : + @xmath98 generate @xmath112 ; + @xmath98 generate @xmath113 ; + @xmath98 fuse the @xmath103 s into trees , yielding a set @xmath114 of trees ; + @xmath98 combine all of the @xmath114 s ; + @xmath98 list the trees in the resulting set .",
    "+ @xmath98 if @xmath15 is odd : + @xmath98 for natural @xmath115 $ ] : + @xmath98 @xmath116 + @xmath98 for @xmath117 : + @xmath98 @xmath118 + @xmath98 for each appendix set @xmath119 generatable from @xmath120 : + @xmath98 for each @xmath121 : + @xmath98 for natural @xmath122 $ ] : + @xmath98 generate @xmath123 ; + @xmath98 generate @xmath124 ; + @xmath98 fuse the @xmath103 s into trees , yielding a set @xmath125 of trees ; + @xmath98 combine all of the @xmath125 s , call the resulting set of trees @xmath126 ; + @xmath98 @xmath127 + @xmath98 @xmath128 + @xmath98 for every @xmath129 : + @xmath98 for every appendix set @xmath130 generatable from @xmath131 : + @xmath98 check if the @xmath132 of greater radius has radius greater than @xmath133 ; + @xmath98 if it does , discard this appendix set and move on to the next ; if not , proceed ; + @xmath98 append the appendices to the middle vertex of a backbone of order @xmath15 as per @xmath130 ; + @xmath98 combine the resulting tree to all of those in @xmath134 ; + @xmath98 list the resulting trees ;    @xmath135",
    "evidently , from here , the elaboration of a closed - form expression for the number of trees listed by our algorithm on a given input , whence an enumeration on the unlabeled tree graphs would be yielded , presents an interesting task ; such shall be the subject of a future writing . in passing ,",
    "an implementation of the algorithm is also on its way",
    ".    1 borchardt , c. w. ( 1860 ) ; +  ber eine interpolationsformel fr eine art symmetrischer functionen und ben deren anwendung \" ; + _ math . abh .",
    "der akademie der wiessenschaften zu berlin _ , pp .",
    "cayley , a. ( 1889 ) ; +  a theorem on trees \" ; + _ quart . j. math .",
    "23 , pp . 3768"
  ],
  "abstract_text": [
    "<S> we present an algorithm that , on input @xmath0 , lists every unlabeled tree of order @xmath0 . </S>"
  ]
}