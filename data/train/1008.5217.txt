{
  "article_text": [
    "wireless environments lend themselves naturally to network coding ( nc ) , thanks to their inherent broadcast and overhearing capabilities . in this paper , we are interested in wireless mesh networks used for carrying traffic from unicast sessions , which is the dominant traffic today . network coding has been used as a way to improve throughput over such wireless environments .",
    "given that optimal inter - session nc for unicast is still an open problem , constructive approaches are used in practice @xcite .",
    "one of the first practical wireless nc systems is cope @xcite - a coding shim between the ip and mac layers that performs one - hop , opportunistic nc .",
    "cope codes packets from different unicast sessions , and relies on receivers being able to decode these using overheard packets . this way ,",
    "cope combines multiple packets by using information on overheard packets which are exchanged through transmission reports and effectively forwards multiple packets in a single transmission to improve throughput . in order for",
    "cope to work in a multihop network , nodes must cooperate to ( i ) exchange information about what packets they have overheard and also ( ii ) code so that all one - hop downstream nodes can decode .",
    "this must be done at every hop across the path of a flow and cross - layer optimization approaches can be used @xcite to further boost the performance .",
    "one important problem that remains open , and is the focus of this paper , is cope s performance in the presence of non - negligible loss rates .",
    "the reason is that intermediate nodes in cope require the knowledge of what their neighbors have overheard , in order to perform one - hop inter - session nc .",
    "however , in the presence of medium - high loss rate , although each node fully cooperates to report what it has overheard , this information is limited , possibly corrupted , and/or delayed over lossy wireless channels .",
    "cope turns off nc if loss rate exceeds a threshold with default value 20% @xcite .",
    "however , this does not take full advantage of all the available nc opportunities . to better illustrate this key point ,",
    "let us discuss the following example .",
    "[ ex1 ] let us consider fig .",
    "[ fig : one - hop ] , and focus on the neighborhood of node @xmath1 , _",
    "i.e. , _ only the packets transmitted via @xmath1 , from @xmath2 to @xmath3 and from @xmath4 to @xmath5 .",
    "this forms an `` x '' topology which is a well - known , canonical example of one - hop opportunistic nc @xcite . in the absence of loss",
    ", throughput is improved by @xmath6 , because @xmath1 delivers two packets in three transmissions ( with nc ) , instead of four ( without nc ) .",
    "let us re - visit this example when there is packet loss . assume that there is loss only on the overhearing link @xmath7 , with probability @xmath8 , and all other links have no loss . in this case ,",
    "@xmath9 of the packets can still be coded together , and throughput can be improved by @xmath10 , which is still a significant improvement . even at higher loss rate , _",
    "@xmath11 , inter - session coding still improves throughput up to @xmath12 this is under the assumption that @xmath1 knows the exact state of @xmath13 , _",
    "i.e. , _ what packets were overheard , and thus @xmath1 is able to decide what packets to code together so as to guarantee decodability at the receivers . however , at high loss rates , cooperation among nodes becomes difficult .",
    "this is why cope turns off the coding functionality when loss rate is higher than a threshold with default value 20% , thus not taking full advantage of all coding opportunities .",
    "we propose a solution to this problem with a design which combines intra- and inter - session nc over wireless mesh networks .",
    "we use intra - session nc to combine packets within the same flow and introduce parity packets to protect against loss .",
    "then , we use inter - session nc to combine packets from different ( already intra - session coded ) flows , and thus increase throughput .",
    "our approach for combining intra - session with inter - session nc , which we refer to as i@xmath0nc , has two key benefits .",
    "first , it can correct packet loss and still perform inter - session nc , even in the presence of medium - high loss rates , thus improving throughput .",
    "second , the use of intra - session nc makes all packets in the session equally beneficial .",
    "thus , i@xmath0nc eliminates the need to know the exact packets that have been overheard by the neighbors of intermediate node @xmath1 .",
    "it is sufficient to know the loss probabilities of overheard and transmitted packets . in our scheme , this information is reported by each node to the nodes in its neighborhood which makes nc possible even at higher loss rates .",
    "adding redundancy in this setting is non - trivial , since a flow is affected not only by loss on its direct links , but also by loss on overhearing links .",
    "this affects the decodability of coded packets .",
    "therefore , the amount of redundancy needed to be determined carefully .",
    "_ example 1 - continued : _ consider again the neighborhood of @xmath1 in fig .",
    "[ fig : one - hop ] . flow 2 ( originated from @xmath15 ) is affected not only by loss on its own path @xmath16 , but also by loss on the overhearing link @xmath7 , which affects the decodability of coded packet @xmath17 at @xmath5 . in order to protect flow 2 from high loss rate on the overhearing link @xmath7",
    ", @xmath1 may decide either to add redundancy on flow 2 , or to not perform coding , or a combination of the two . on the other hand ,",
    "@xmath1 may also decide to add redundancy on flow 1 ( originated from @xmath18 ) , to correct loss on the overhearing link @xmath7 , thus helping @xmath5 to receive @xmath19 and decode @xmath17 .",
    "@xmath14    therefore , a number of questions need to be addressed in the design of a system that combines both intra- and inter - session nc .",
    "in particular :    * _ how to gracefully combine intra- and inter - session nc _ ?",
    "we propose a generation - based design , and specify the order we perform the two types of coding . *",
    "_ how much redundancy to add in each flow ? _ we show how to adjust the amount of redundancy after taking into account the loss on the direct and overhearing links .",
    "we implement the intra - session nc functionality as a thin layer between ip and transport layer . *",
    "_ what percentage of flows should be coded together _ and what parts should remain uncoded ?",
    "we design algorithms that make this decision taking into account the loss characteristics on the direct and overhearing links .",
    "we implement this and other functionality ( _ e.g. , _ queue management ) performed with or after inter - session nc as a layer between mac and ip . *",
    "_ what information should be reported to make these decisions _ ?",
    "we propose two schemes : i@xmath0nc - state , which needs to know the state ( _ i.e. , _ overheard packets ) of the neighbors ; and i@xmath0nc - stateless , which only needs to know the loss rate of links in the neighborhood .    our approach is grounded on a network utility maximization ( num ) framework @xcite .",
    "we formulate two variants of the problem , depending on available information ( as in q4 above ) .",
    "the solution of each problem decomposes into several parts with an intuitive interpretation , such as rate control , nc rate , redundancy rate , queue management , and scheduling .",
    "the structure of the optimal solution provides insight into the design of our two schemes , i@xmath0nc - state and i@xmath0nc - stateless .",
    "we evaluate our schemes in a multi - hop setting , and we consider their interaction with the transport layer , including tcp and udp . we propose a thin adaptation layer at the interface between tcp and the underlying coding , to best match the interaction of the two .",
    "we perform simulations in glomosim @xcite , and we show that our schemes significantly improve throughput compared to cope .",
    "the structure of the rest of the paper is as follows .",
    "section  [ sec : related ] presents related work .",
    "section  [ sec : system ] gives an overview of the system model .",
    "section  [ sec : opt2 ] presents the num formulation and solution .",
    "section  [ sec : algs ] presents the design of the i@xmath0nc schemes in detail .",
    "section  [ sec : performance ] presents simulation results .",
    "section  [ sec : conclusion ] concludes the paper .",
    "_ cope and follow - up work .",
    "_ this paper builds on cope , a practical scheme for one - hop nc across unicast sessions in wireless mesh networks @xcite , which has generated a lot of research interest .",
    "some researchers tried to model and analyze cope @xcite , @xcite , @xcite .",
    "some others proposed new coded wireless systems , based on the idea of cope @xcite , @xcite . in @xcite , the performance of cope",
    "is improved by looking at its interaction with mac fairness .",
    "our recent work in @xcite improves tcp s performance over cope with a nc - aware queue management scheme .",
    "this paper also improves cope by adding intra - session redundancy with a cross - layer design and reducing the amount of information that is needed to be exchanged among nodes cooperatively , _",
    "i.e. , _ nodes no longer need to know the exact packets overheard by their neighbors and can operate only with knowledge of the link loss rates .    _",
    "num in coded systems . _ the num framework can be applied in networks , to understand how different layers and/or modules ( such as flow control , congestion control , routing , etc . )",
    "should be restructured when nc is used . although the approach is general , the parts and interpretation of the distributed solution is highly problem - specific . for num to be successful",
    ", the optimization model must be formulated so as to capture and exploit the nc properties .",
    "this is highly non - trivial and problem - specific .",
    "a body of work has looked at the joint optimization of nc of unicast flows , formulated in a num framework .",
    "optimal scheduling and routing for cope are considered in @xcite and @xcite , respectively . a linear optimization framework for packing butterflies",
    "is proposed in @xcite . a re - transmission scheme for one - hop nc",
    "is proposed in @xcite .",
    "forward error correction over wireless for pairwise nc is proposed in @xcite , @xcite , which are also the most closely related formulations to ours .",
    "our main differences are that we consider : ( i ) multiple flows coded together instead of pairwise , ( ii ) local instead of end - to - end redundancy , and ( iii ) the effect of losses over direct and overhearing links , to generate the right amount of redundancy .    _ dealing with wireless loss . _",
    "recent studies of ieee 802.11b based wireless mesh networks @xcite , @xcite , have reported packet loss rates as high as 50% .",
    "dealing such level of loss in wireless networks is a hard enough problem on its own , which is further amplified by nc .",
    "there is a wide spectrum of well - studied options for dealing with loss , _",
    "e.g. , _ using redundancy and/or re - transmissions , locally ( mac ) and/or end - to - end ( transport layer ) . local re - transmissions increase end - to - end delay and jitter , which , if excessive , may cause tcp timeouts or hurt real - time multimedia .",
    "furthermore , the best re - transmission scheme for network coded packets varies with the loss probability and it is hard to switch among re - transmission policies when the loss rate varies over time .",
    "re - transmission also requires state synchronization to perform inter - session nc , which is not reliable at all loss rates .",
    "we follow an alternative approach of local redundancy because we are interested in keeping delay low and we want to eliminate the need for knowing the state of neighbors .",
    "there is extended work on tcp over wireless .",
    "one key problem is the need to distinguish between wireless and congestion loss and have tcp react only to congestion ; this is possible _",
    "e.g. , _ through explicit congestion notification ( ecn ) .",
    "when re - transmissions exceed the delay budget , end - to - end redundancy may also be used to combat loss on the path @xcite .",
    "the error - correcting capabilities of intra - session nc have recently been used in conjunction with the tcp sliding window in @xcite . in contrast",
    ", we focus on one - hop inter - session coding rather than end - to - end intra - session coding .",
    "we consider multi - hop wireless networks , where intermediate nodes perform intra- and inter - session nc ( i@xmath0nc ) .",
    "next , we provide an overview of the system and highlight some of its key characteristics .",
    "let @xmath20 be the set of unicast flows between source - destination pairs in the network .",
    "each flow @xmath21 is associated with a rate @xmath22 and a utility function @xmath23 , which we assume to be a strictly concave function of @xmath22 .",
    "packets from a source ( _ e.g. , _",
    "@xmath18 in fig .",
    "[ fig : one - hop ] ) traverse potentially multiple wireless hops before being received by the receiver ( _ e.g. , _",
    "@xmath24 ) .",
    "we consider a model for interference described in @xcite : each node can either transmit or receive at the same time , and all transmissions in the range of the receiver are considered as interfering .",
    "we use the following terminology for wireless .",
    "a hyperarc @xmath25 is a collection of links from node @xmath26 to a non - empty set of next - hop nodes @xmath27 .",
    "a hypergraph @xmath28 represents a wireless mesh network , where @xmath29 is the set of nodes and @xmath30 is the set of hyperarcs . for simplicity",
    ", @xmath31 denotes a hyperarc , @xmath32 denotes node @xmath33 and @xmath34 denotes the set of nodes in @xmath35 , _",
    "i.e. _ , @xmath36 and @xmath37 .",
    "we use these notations interchangeably in the rest of the paper .",
    "each hyperarc @xmath38 is associated with a channel capacity @xmath39 . since @xmath38 is a set of links",
    ", @xmath39 is the minimum capacity of all the links in the hyperarc , _",
    "i.e. , _ @xmath40",
    "@xmath26 . in the example of node @xmath1 in fig .",
    "[ fig : one - hop ] , @xmath41 is one of the hyperarcs , and its capacity is @xmath42 .    note that with both intra- and inter - session nc , it is possible to construct more than one code over a hyperarc @xmath38 .",
    "let @xmath43 be the set of inter - session network codes over a hyperarc @xmath38 .",
    "@xmath44 be the set of flows coded together using code @xmath45 and broadcast over @xmath38 . as well as @xmath31 is determined at each node with periodic control packet exchanges or estimated through routing table . ]    given @xmath46 , we can construct the conflict graph @xmath47 , whose vertices are the hyperarcs of @xmath46 and edges indicate interference between hyperarcs .",
    "a clique @xmath48 consists of several hyperarcs , at most one of which can transmit without interference , _",
    "i.e. , _ a transmission over a hyperarc interferes with transmissions over other hyperarcs in the same clique .",
    "a flow @xmath49 may experience loss in two forms : loss @xmath50 over the direct transmission links ; or loss @xmath51 of antidotes that are coded together with @xmath49 , and thus are needed for the next hop of @xmath49 to be able to decode .",
    "_ e.g. _ , in fig.[fig : one - hop ] , @xmath19 is the `` antidote '' that @xmath5 needs to overhear over link @xmath7 , to decode @xmath17 and obtain @xmath52 . ] on overhearing links .",
    "these two types of loss have different impact on network coded flows .",
    "first , let us discuss loss on the direct links . a flow @xmath49 transmitted over hyperarc @xmath38 experiences loss with probability @xmath50 .",
    "this probability is different per flow @xmath49 , even if several flows are coded and transmitted over the same hyperarc @xmath38 , because different flows are transmitted to different next hops , thus see different channels . for example , in fig .",
    "[ fig : one - hop ] , @xmath53 is equal to the loss probability over link @xmath54 and @xmath55 is equal to the loss probability over link @xmath56 .",
    "second , let us discuss the effect of lost antidotes on the overhearing link . consider that flow @xmath49 is combined with flow @xmath57 s.t .",
    "@xmath58 , and that some packets of flow @xmath57 are lost on the overhearing link to the next hop of @xmath49 .",
    "then , coded packets can not be decoded at the next hop and flow @xmath49 loses packets , with probability @xmath51 .",
    "for example , in fig .",
    "[ fig : one - hop ] , packets from flow @xmath18 can not be decoded ( hence are lost ) at node @xmath3 due to loss of antidotes from flow @xmath15 on the overhearing link @xmath59 .    in our formulation and analysis , we assume that @xmath50 and @xmath51 are i.i.d .",
    "according to a uniform distribution .",
    "however , in our simulations , we consider a rayleigh fading channel model .",
    "the loss probabilities are calculated at each intermediate node as explained later in this section .",
    "each flow @xmath21 follows a single path @xmath60 from the source to the destination , which is pre - determined by a routing protocol , _",
    "e.g. _ , olsr or aodv , and given as input to our problem .",
    "note that the nature of wireless networks is time varying , _",
    "i.e. , _ nodes join and leave the system dynamically . in such cases ,",
    "the routing protocol actively determines new paths which are used as input to our problem .",
    "it is not critical that the paths remain fixed , neither from a theoretical nor from a practical point of view , as explained in the following sections .",
    "also , note that several different hyperarcs may connect two consecutive nodes along the path .",
    "we define @xmath61 if @xmath49 is transmitted through hyperarc @xmath38 using network code @xmath45 ; and @xmath62 , otherwise .",
    "next , we give an overview of how an intermediate node performs intra- and inter - session nc .",
    "the implementation details are provided in section [ sec : algs ] .",
    "consider the commonly used generation - based nc @xcite : packets from flow @xmath21 are divided into generations ( note that we use `` generation '' and `` block '' terms interchangeably ) , with size @xmath63 . at the source @xmath49 ,",
    "packets within the same generation are linearly combined ( assuming large enough field size ) to generate @xmath63 network coded packets .",
    "each intermediate node along the path of flow @xmath49 adds @xmath64 parity packets , depending on the loss rates of the links involved in this hop . at the next hop",
    ", it is sufficient to receive @xmath63 out of @xmath65 packets .",
    "the same process is repeated at every intermediate node until the receiver receives @xmath63 error - free packets , which can then be decoded and be passed on to the application .",
    "there are many ways to generate parities ( @xmath66 ) in practice .",
    "we use generation based intra - session nc @xcite for this purpose .",
    "although one could use various coding techniques , such as reed - solomon or fountain codes , using intra - session nc has several advantages .",
    "first , it has lower computational complexity .",
    "second , in systems like cope that already implement inter - session nc , it is natural to incrementally add intra - session nc functionality .",
    "moreover , in this setting , hop - by - hop intra - session coding ( in which redundant packets are generated at each hop ) is clearly a better choice than end - to - end coding for dealing with loss . in terms of performance ,",
    "hop - by - hop coding achieves higher end - to - end throughput ( thanks to introducing less redundancy than end - to - end coding ) , without adding high complexity ( and thus delay ) to the intermediate nodes .",
    "furthermore , in terms of system implementation , our hop - by - hop scheme requires minimal modifications on top of the inter - session nc , which is already implemented .",
    "after an intermediate node has added redundancy ( @xmath66 ) to flow @xmath49 , it treats all ( @xmath67 ) packets as indistinguishable parts of the same flow .",
    "inter - session nc is applied on top of the already intra - coded flows , as a thin layer between mac and ip ( similar to cope ) , shown in fig .",
    "[ fig : protocol_stack ] .",
    "we design two schemes , i@xmath0nc - state and i@xmath0nc - stateless , depending on the type of information that is needed to make network coding decisions .",
    "we define as state of a node the information about which exact packets have been overheard at that node .    * i@xmath0nc - state :",
    "* first , we assume that intermediate nodes use cope @xcite for inter - session coding .",
    "each node @xmath33 listens all transmissions in its neighborhood , stores the overheard packets in its decoding buffer , and periodically advertises the content of this buffer to its neighbors . when a node @xmath33 wants to transmit a packet , it checks or estimates the contents of the decoding buffer of its neighbors .",
    "if there is a coding opportunity , the node combines the relevant packets using simple coding operations ( xor ) and broadcasts the combination to @xmath35 .",
    "the content of the decoding buffers needs to be exchanged , in order to make nc decisions , _",
    "i.e. , _ state synchronization is required .",
    "* i@xmath0nc - stateless : * second , we design an improved version of cope , which no longer requires state synchronization .",
    "the key idea is to exploit the fact that the redundancy already introduced by intra - session coding makes all @xmath67 packets in a generation equally important .",
    "out of @xmath67 , it can decode with high probability .",
    "as long as it knows the percentage of received packets it can make coding decisions .",
    "] in this improved scheme , each node @xmath33 still listens to all transmissions in its neighborhood and stores the overheard packets .",
    "the node periodically advertises the loss rate for each received and overheard flow , which is then provided as input to the intra - session nc module to determine the amount of redundancy needed .",
    "in particular , the loss rates are calculated at each intermediate node as one minus the ratio of correctly received packets over all the packets in a generation .",
    "also , the loss rate over overhearing links is calculated as effective loss rate .",
    "_ e.g. , _ in fig .",
    "[ fig : one - hop ] , the loss rate at node @xmath3 is calculated as follows .",
    "if @xmath68 packets are sent by @xmath4 and at least @xmath69 packets are received at @xmath3 , then the loss rate is set to 0 . if @xmath70 packets are received by @xmath3 such that @xmath71 , then the loss rate is set to @xmath72 .",
    "the loss rates calculated for each generation are advertised to other nodes in the neighborhood .",
    "then , each node calculates its loss probabilities ( @xmath50 and @xmath51 ) as weighted average of the loss rates it has received .    in summary , there is a synergy between intra- and inter - session nc .",
    "intra - session makes the process sequence agnostic , which allows inter - session coding to operate using only information about the loss rates , not about the identity of the packets .",
    "the loss rates can be used as input for tuning the amount of redundancy in intra - session nc . in terms of implementation ,",
    "the two modules are separable : an intermediate node first performs intra - session , then inter - session nc .",
    "our objective is to maximize the total utility function by optimally choosing the flow rates @xmath73 at sources @xmath21 , as well as the following variables at the intermediate nodes : the fraction @xmath74 ( or `` traffic splitting '' parameters , following the terminology of @xcite ) of flows inter - session coded using code @xmath45 over hyperarc @xmath38 ; and the percentage of time @xmath75 each hyperarc is used .",
    "@xmath76 the first constraint is the capacity constraint for each flow @xmath77 .",
    "it is well - known , @xcite , that nc allows flows that are coded together in code @xmath45 , to coexist , _",
    "i.e. _ , each have rate up to the rate allocated to that code @xmath78 .",
    "the right hand side , @xmath79 , is the capacity of hyperarc @xmath38 ; @xmath75 is the percentage of time hyperarc @xmath38 can be used for transmitting the @xmath78-th network code .",
    "@xmath75 is determined by scheduling in the third constraint , taking into account interference : all hyperarcs in a clique interfere and should time - share the medium .",
    "therefore , the sum of the time allocated to all hyperarcs in a clique should be less than an over - provisioning factor , @xmath80 .",
    "the second constraint is the flow conservation : at every node @xmath33 on the path @xmath81 of source @xmath49 , the sum of @xmath74 over all network codes and hyperarcs should be equal to 1 . indeed , when a flow enters a particular node @xmath33 , it can be transmitted to its next hop @xmath82 as part of different network coded and uncoded flows .",
    "the first constraint is key to our work because it determines how to deal with loss on the direct ( @xmath50 ) and overhearing ( @xmath51 ) links and how large a fraction ( @xmath74 ) of flow rate ( @xmath73 ) to code in the @xmath78-th code over hyperarc @xmath38 .",
    "let us discuss the left hand side in more detail . ) ) .",
    "second , we allow for loss rates of each link to be specified separately , even for links in the same hyperarc . ]",
    "the first term refers to the direct link of flow @xmath49 .",
    "@xmath83 is the fraction of flow rate @xmath73 allocated to code @xmath78 and hyperarc @xmath38 .",
    "it is scaled by @xmath84 to indicate that we use redundancy to protect against loss that flow @xmath49 experiences with probability @xmath50 .",
    "@xmath85 is the total rate of flow @xmath49 , including data and redundancy .",
    "the second term refers to loss on the overhearing links .",
    "@xmath86 is the amount of redundancy ( via intra - session coding ) added by the intermediate node on flow(s ) @xmath57 to protect flow @xmath49 against loss of antidote packets .",
    "these antidotes come from other flows ( @xmath87 ) that are coded together with flow @xmath49 , reach the next hop for flow @xmath49 through the overhearing links , and are needed to decode inter - session coded packets .    _",
    "example 1- continued .",
    "_ in fig .",
    "[ fig : one - hop ] , let us consider flow 2 from @xmath4 to @xmath5 , as the flow of interest .",
    "the intermediate node @xmath1 adds redundancy to @xmath15 to protect against loss rate @xmath55 on the direct link @xmath56",
    ". it also adds redundancy to flow 1 to protect against loss rate @xmath88 of antidotes coming to @xmath5 from flow 1 over the overhearing link @xmath7 .      to solve eq .",
    "( [ opt : eq1 ] ) we follow a similar approach proposed in @xcite .",
    "first , we relax the capacity constraint in eq .",
    "( [ opt : eq1 ] ) , and we have the lagrangian function : @xmath89 where @xmath90 is the lagrange multiplier , which can be interpreted as the queue size for @xmath78-th network code at hyperarc @xmath38 for flow @xmath49 .",
    "we define @xmath91 if @xmath92 and we rewrite @xmath93 @xmath94 as @xmath95 @xmath96 .",
    "the lagrange function is @xmath97 @xmath98 .",
    "it can be decomposed into several intuitive parts ( rate control , traffic splitting , scheduling , and queue update ) , each of which solves the optimization problem for one variable .    *",
    "rate control . *",
    "first , we solve the lagrangian w.r.t @xmath73 : @xmath99 where @xmath100 is the inverse function of the derivative of @xmath101 , and @xmath102 is the occupancy of flow @xmath49 at node @xmath33 and expressed as @xmath103 where @xmath104 is the queue size of flow @xmath49 associated with hyperarc and network code pair @xmath105 : @xmath106    * traffic splitting .",
    "* second , we solve the lagrangian for @xmath74 . at each node",
    "@xmath33 along the path ( _ i.e. _ , @xmath107 ) , the traffic splitting problem can be expressed as follows : @xmath108 let us assume that @xmath109 $ ] is the maximal @xmath110 at time @xmath111 such that @xmath112 with @xmath113 . at each node @xmath33 , the amount of traffic splitting factor @xmath74 for flow @xmath49 over hyperarc @xmath38 and code @xmath78 follows ; @xmath114 - h_{h , k}^{s}q_{h , k}^{s}]_{\\alpha_{h , k}^{s}}^{+}$ ] , where @xmath115 is a positive constant , and @xmath116_{z}^{+ } = b$ ] if @xmath117 and @xmath116_{z}^{+ } = 0 $ ] if @xmath118 and @xmath119 .",
    "it can be seen that @xmath120 and @xmath121 . also , @xmath122 only if @xmath123 which is possible only if @xmath124 , and @xmath125 .    the structure of the optimal solution of eq .",
    "( [ opt : eq1_trafficsplit ] ) ( _ i.e. , _ @xmath114 - h_{h , k}^{s}q_{h , k}^{s}]_{\\alpha_{h , k}^{s}}^{+}$ ] ) has the following interpretation : the higher the loss rate of antidotes on overhearing links @xmath126 , the higher @xmath104 , and the smaller @xmath74 .",
    "this means that flow @xmath49 should code fewer packets with packets from flow(s ) @xmath57 in code @xmath78 , when antidotes from @xmath57 are likely to be lost .",
    "_ example 1 - continued : _ in fig .",
    "[ fig : one - hop ] , this means that @xmath1 should combine fewer packets from the two flows if there is loss on the overhearing link @xmath7 . in the extreme case where loss rate is 1 over the link @xmath7",
    ", inter - session coding should be turned off . at the other extreme , where there is no loss ,",
    "the two flows should always be combined .",
    "* scheduling .",
    "* third , we solve the lagrangian for @xmath75 .",
    "this problem is solved for every hyperarc and every clique for the conflict graphs in the hypergraph .",
    "@xmath127 let us assume that @xmath128 , and @xmath129 $ ] is the minimal @xmath130 at time @xmath111 such that ; @xmath131 with @xmath132 .",
    "at each clique @xmath133 , the fraction of the time @xmath75 that is allocated to hyperarc @xmath38 , and code @xmath78 is as follows ; @xmath134_{\\tau_{h , k}}^{+}$ ] , where @xmath135 is a positive constant and @xmath116_{z}^{+ } = b$ ] if @xmath117 and @xmath116_{z}^{+ } = 0 $ ] if @xmath118 and @xmath119 .",
    "it can be seen that @xmath136 and @xmath137 .",
    "also , @xmath138 only if @xmath139 which requires that @xmath140 or @xmath141 and @xmath142",
    ".    * queue update .",
    "* we find the lagrange multipliers ( queue sizes ) @xmath90 , using the gradient descent : @xmath143 where @xmath111 is the iteration number , @xmath144 is a small constant , and the @xmath145 operator makes the lagrange multipliers positive .",
    "@xmath90 is interpreted as the queue for flow @xmath49 allocated for the @xmath78-th network code over hyperarc @xmath146 . indeed , in eq .",
    "( [ opt : eq1_parameterupdate ] ) , @xmath90 is updated with the difference between the incoming @xmath147 and outgoing @xmath148 traffic rates at @xmath38 . ) can be re - written as ; @xmath149 @xmath150_{q_{h , k}^{s}}^{+}$ ] , where @xmath151 is a positive constant . ]      the second term in eq .",
    "( [ opt : eq1 ] ) describes the redundancy added by node @xmath33 to protect flow @xmath49 from loss of antidotes on the overhearing link .",
    "an implicit assumption was that node @xmath33 knows what antidotes are available at the next hop and uses only those packets for inter - session coding .",
    "however , this knowledge can be imperfect , especially in the presence of loss . here",
    ", we formulate a variation of the problem , where such knowledge is not necessary .",
    "instead , node @xmath33 needs to know only the loss rate on all the links to the next hop for flow @xmath49 ( _ e.g. , _ in fig .",
    "[ fig : one - hop ] for flow 2 ( @xmath15 ) , these are links @xmath56 and @xmath7 ) .",
    "we replace the capacity constraint in eq .",
    "( [ opt : eq1 ] ) with : @xmath152 and this is @xmath153 .",
    "the other constraints remain the same as in eq .",
    "( [ opt : eq1 ] ) . the difference from eq .",
    "( [ opt : eq1 ] ) is in the second term , related to the overheard packets at the next hop .",
    "any fraction of flow @xmath57 added as redundancy to flow @xmath49 , as well as overheard packets from @xmath57 in the next hop , help to decode inter - session coded packets of @xmath49 with flow @xmath57 . to protect transmissions of these `` helping '' fractions ( @xmath154 ) from being lost on the direct link to the next hop of flow @xmath49 ( _ e.g. , _ from @xmath1 to @xmath5 ) , we add redundancy to match the loss rate of that direct link ( @xmath50 in general , @xmath155 in the example ) .",
    "this is why the term @xmath154 is divided by @xmath156 .",
    "the solution of this optimization problem also decomposes into rate control , traffic splitting , and scheduling problems , which correspond to eq .",
    "( [ opt : eq1_ratecontrol1 ] ) , ( [ opt : eq1_trafficsplit ] ) , and ( [ opt : eq1_scheduling ] ) , respectively .",
    "@xmath104 needs to be updated : @xmath157 the lagrange multiplier is updated as follows ; @xmath158 we provide the convergence analysis of our solution in appendix a. we first give the proof of convergence , then we verify the convergence through numerical calculations .",
    "we propose practical implementations of the i@xmath0nc - state and i@xmath0nc - stateless schemes ( fig .",
    "[ fig : protocol_stack ] ) , following the num formulation structure .      at the end nodes",
    ", there is an adaptation layer between transport and intra - session nc which has two tasks : ( i ) to interface between application and intra - session nc ; and ( ii ) to optimize the reliability mechanism at the transport layer .    _ task ( i ) : _ at the source , the adaptation layer sets the generation ( block ) size @xmath159 .",
    "@xmath159 is set according to application ; _",
    "e.g. , _ media transmission requirements for udp , or set equal to tcp congestion window for tcp applications and changes over time .",
    "the adaptation layer receives @xmath159 original packets @xmath160 from the transport layer of flow @xmath49 and generates @xmath159 intra - session coded packets ; @xmath161 , @xmath162 , @xmath163 , @xmath164 .",
    "we call this coding `` incremental additive coding '' .",
    "we chose the incremental additive coding to avoid introducing coding delays ( _ i.e. , _ our algorithm does not need to wait @xmath63 packets to encode packets ) as proposed in @xcite .",
    "the intra - session header includes the block i d , packet i d , block size , and coding coefficients . at the receiver side ,",
    "the reverse operations are performed .",
    "_ task ( ii ) : _ to further optimize the interaction between i@xmath0nc and transport , particularly tcp , we keep track of and acknowledge the number of received packets in a generation , rather than their sequence numbers ( note that this part is not needed for udp protocol ) .",
    "this idea is similar to the use of end - to - end fec and intra - session nc that make tcp sequence agnostic @xcite .",
    "_ e.g. _ , if a receiver receives the first packet labeled with block i d @xmath165 , then it generates an ack with block i d @xmath165 and packet i d @xmath166 .",
    "the uncoded packets , @xmath160 , are stored in a buffer at the source for tcp ack adaptation .",
    "_ e.g. _ , if an ack for block i d @xmath165 and packet i d @xmath166 is received by the source , then the tcp adapter matches this ack to packet @xmath167 and informs tcp that packet @xmath167 is ack - ed . as long as the tcp receiver transmits acks , the tcp clock moves , thus improving tcp goodput . after the ack with the block and packet ids",
    "is transmitted by the tcp receiver , the packet is stored at the receiving buffer .",
    "when the last packet from a generation is received , then packets are decoded and passed to the application .",
    "an intermediate node needs to take a number of actions when it receives ( alg .",
    "[ alg : packet_insert ] ) or transmits ( alg .",
    "[ alg : packet_transmit ] ) a packet .",
    "+ * buffer packets .",
    "* a node @xmath33 may receive a packet from higher layers or from previous hops . in the latter case , if the received packet is inter - coded , it is decoded and the packet with destination to this node is stored ( or is passed to transport if it is the last hop ) .",
    "if it is not the last hop , a packet @xmath168 is stored in the output queue @xmath169 .",
    "in addition to the physical output queue @xmath169 , the node @xmath33 keeps track of several virtual queues ; @xmath104 per ( flow , hyperarc , code ) . the packet @xmath170 is labeled with @xmath171 , which essentially indicates whether and how to code this packet according to the traffic splitting in eq .",
    "( [ opt : eq1_trafficsplit ] ) : we pick @xmath172 , randomly breaking ties . note that this labeling is local at the node , and does not introduce any transmission overhead .",
    "note that @xmath173 is the indicator whether flow @xmath49 is transmitted over hyperarc @xmath38 with code @xmath78 .",
    "this indicator is determined at each node using a routing table which has a data structure to determine the next hops ( note that paths do not need to be known by the sources or any node in the system ) .",
    "basically , if a packet from flow @xmath49 is able to reach to the next hop determined by the routing table when it transmitted over hyperarc @xmath38 and with code @xmath78 , then the indicator is set to @xmath174 , otherwise @xmath175 .",
    "we also note that in this system , as long as paths remain fixed for longer ( at least longer than a time required to transmit a packet ) time periods , we can see more benefit from nc , because each node will learn which flows can be network coded and estimate the loss rates better as time gets longer .",
    "however , even in the extreme case in which paths change very fast ( say for example at every packet transmission ) , our system works well , but it does not fully exploit nc opportunities , since it can not estimate whether nc is possible or not . however , it works not worse than a system without nc . therefore , i@xmath0nc is designed to adapt to path changes and to exploit nc benefit if possible .",
    "read the information : packet @xmath170 , from flow @xmath49 ( generation size @xmath63 ) insert @xmath170 into the physical output queue @xmath169 .",
    "determine @xmath176 and label @xmath170 with @xmath176 pair and @xmath49 update @xmath177 ( using eqs .",
    "( [ opt : eq1_parameterupdate ] ) and ( [ opt : eq2_parameterupdate ] ) ) and @xmath178 calculate @xmath179 ( using eqs .",
    "( [ opt : eq1_q_h_k_s ] ) and ( [ opt : eq2_q_h_k_s ] ) ) and @xmath102 ( using eq .",
    "( [ opt : eq1_q_i_s ] ) ) @xmath180 calculate the number of parities @xmath181 , @xmath182 create @xmath181 parities from @xmath49 and @xmath182 parities from @xmath57 label all generated parities with @xmath105 pair and @xmath49    * update virtual queue sizes . *",
    "when packet @xmath170 is selected to be transmitted with the @xmath183-th network code over hyperarc @xmath184 , the virtual queues ; @xmath179 and @xmath177 should be updated .",
    "@xmath177 is updated according to eqs .",
    "( [ opt : eq1_parameterupdate ] ) and ( [ opt : eq2_parameterupdate ] ) .",
    "@xmath179 is calculated according to eq .",
    "( [ opt : eq1_q_h_k_s ] ) for i@xmath0nc - state and eq .",
    "( [ opt : eq2_q_h_k_s ] ) for i@xmath0nc - stateless .",
    "@xmath102 is calculated according to eq .",
    "( [ opt : eq1_q_i_s ] ) .",
    "then , the number of packets @xmath185 from the same generation that are allocated to @xmath186 pair is incremented : @xmath180 .",
    "@xmath187 is set to 0 for each new generation .",
    "* generate parities . * after @xmath63 packets from a generation of flow @xmath49 are received at node @xmath33 , @xmath66 parity packets are generated via intra - session nc ( which is performed according to random linear nc @xcite ) and labeled with information @xmath188 .",
    "there are two types of parities .",
    "* @xmath189 parities are added on flow @xmath49 s virtual queue to correct for loss during direct transmission to the next hop over hyperarc @xmath38 . * @xmath190",
    ", @xmath191 parities are added on the virtual queues of other flows @xmath57 that are inter - session coded together with @xmath49 .",
    "this is to help the next hop for @xmath57 to decode despite losses on the overhearing link .",
    "these parity packets are for i@xmath0nc - state . for i@xmath0nc - stateless @xmath181",
    "is the same , but @xmath192 , _",
    "i.e. , _ additional redundancy is used to protect parity packets from loss on the direct link .",
    "select @xmath193 pair that maximizes @xmath194 initialize : @xmath195 insert packet to @xmath196 network code ( xor ) all packets in @xmath196 broadcast the network coded packet over hyperarc @xmath197 update @xmath198 , @xmath199 re - calculate @xmath194 and @xmath102 ( using eq .",
    "( [ opt : eq1_q_i_s ] ) )      we consider the 802.11 mac .",
    "when a node @xmath33 accesses a channel , @xmath193 is chosen to maximize @xmath194 according to eq .",
    "( [ opt : eq1_scheduling ] ) , randomly breaking ties .",
    "although the pair @xmath193 determines the hyperarc , code and flows to be coded together in the next transmission , the specific packets from those flows still need to be selected and coded .",
    "we call these packets the set @xmath196 , and select them using the procedure specified in alg .",
    "[ alg : packet_transmit ] .    to achieve this ,",
    "we first initialize the set of network coded packets @xmath195 . for each packet @xmath200 , check whether @xmath170 is labeled with @xmath193 .",
    "if it is , then we check whether its flow i d label already exists in one of the packets in @xmath196 , _",
    "i.e. , _ another packet from the same flow has already been put in @xmath196 . if not , there is one more check for i@xmath0nc - state for decodability at the next hops of all packets in the network code , based on reports or estimates of overheard packets in the next hops , similarly to @xcite .",
    "if the packet is decodable with some probability larger than a threshold ( default value is 0.20 ) then , @xmath170 is inserted to @xmath196 . in i@xmath0nc - stateless",
    ", the packet @xmath170 is inserted to @xmath196 without checking the decodability , which is ensured through the additional redundancy packets .",
    "this is the strength of i@xmath0nc - stateless : it eliminates the need to exchange detailed state , which is costly and unreliable at high loss rates .",
    "after all packets in @xmath169 are checked , the labels ( @xmath201 ) of the packets in @xmath196 , inter - session nc header is added , and coded ( xored ) and broadcast over @xmath38 .    after a coded packet is transmitted , the virtual queues are updated according to eqs .",
    "( [ opt : eq1_parameterupdate ] ) , ( [ opt : eq2_parameterupdate ] ) . the queues @xmath202 and @xmath102",
    "are calculated according to eqs .",
    "( [ opt : eq1_q_h_k_s ] ) , ( [ opt : eq2_q_h_k_s ] ) , ( [ opt : eq1_q_i_s]).nc may cause re - ordering at the receiver , but since we already implemented intra - session nc , and made tcp receiver sequence agnostic in this term , out of packet delivery is not a problem for tcp . ]",
    "we note that in both i@xmath0nc - state and stateless , packets are network coded if some conditions are satisfied .",
    "however , if these conditions are not met , a packet without nc is still transmitted , because at least one packet is inserted in @xmath196 ( alg .",
    "[ alg : packet_transmit ] ) .",
    "thus , we do not delay any packets in our schemes . yet , delaying packets may create more nc opportunities and there is a tradeoff between delay and throughput .",
    "these issues have been considered in some previous work @xcite , @xcite . however , this is an aspect orthogonal to the focus of i@xmath0nc ( which is the synergy between inter- and intra - session nc ) and can potentially be combined with it .      for i@xmath0nc - state ,",
    "intermediate nodes need also to keep track of and exchange information with each other , so as to enable the intra- and inter - session nc modules to make their redundancy and coding decisions and to provide reliability .",
    "an approach similar to cope is used : acks are sent after the reception and successful decoding of a packet .",
    "information about overheard packets is piggy - backed on the acks . with i@xmath0nc - stateless",
    ", we only need neighbors to exchange information about the loss rates at the neighboring nodes .",
    "information about the loss rates as well as the number of received packets at a generation is reported through control packets for every generation . sample . each sample",
    "is given a weight inversely proportional to its sample number .",
    "] in order to provide reliability , we consider re - transmissions . in i@xmath0nc - state , a packet is removed from the output queue only after an ack related to the packets is received . otherwise , the packet is re - transmitted after a round trip time . in i@xmath0nc - stateless",
    ", packets are removed from the output queue when a control packets is received and confirms the successful transmission of all packets of the corresponding generation .",
    "otherwise , a number of intra - session coded packets from the generation which are missing at the receiver are generated from the packets kept in the queue and transmitted .",
    "end - to - end congestion control ( _ i.e. , _ rate control ) is given by eq .",
    "( [ opt : eq1_ratecontrol1 ] ) in which if @xmath203 , then @xmath204 .",
    "this means that flow rate @xmath73 is inversely proportional with increasing queue size over the path of flow @xmath49 .",
    "this behavior is similar to tcp s end - to - end congestion control algorithm , where congestion at a node may result in one or more packets may be dropped from the buffer at this node .",
    "tcp reacts to packet drops by reducing its rate .",
    "thus , tcp reduces its flow rate when queue size increases .",
    "this gives us intuition that tcp mimics the rate control part of the decomposed solution .",
    "this intuition has been validated in @xcite , @xcite , @xcite , @xcite .",
    "similarly , we consider that tcp already mimics the structure of the rate control part in eq .",
    "( [ opt : eq1_ratecontrol1 ] ) .",
    "therefore , upon congestion at node @xmath33 , the per - flow queue sizes @xmath205 are compared and the last packet from flow @xmath49 having the largest @xmath205 is dropped from the queue ; in case of a tie , an incoming packet is dropped .",
    "we do not make any additional updates to tcp s end - to - end congestion control algorithm .",
    "also , we do not implement any end - to - end congestion control mechanism for udp .",
    "our goal is to keep udp as it is ( without any end - to - end control ) and show the effectiveness of i@xmath0nc - state and i@xmath0nc - stateless when there is no end - to - end control .",
    "[ ex4 ] let us re - visit the x - topology from fig .",
    "[ fig : one - hop ] , shown again for convenience in fig .",
    "[ fig : example_intra_inter ] , and illustrate how we perform intra- and inter - session nc under scheme i@xmath0nc - stateless .",
    "the loss probabilities over the direct ( @xmath56 ) and overhearing ( @xmath7 ) links are assumed @xmath206 and @xmath207 .     +    [ fig : example_intra_inter ]    in fig .",
    "[ fig : example_intra_inter](a ) , we describe intra - session nc .",
    "let us assume the generation size of @xmath18 is @xmath208 and @xmath15 is @xmath209 .",
    "the packets transmitted by @xmath2 , @xmath4 are @xmath210 and @xmath211 , respectively .",
    "note that there is only one option for inter - session nc , _",
    "i.e. , _ to xor packets from the two flows , thus there exists only one possible network code @xmath212 over hyperarc @xmath213 .",
    "all packets are labeled with this information and their flow ids .",
    "the labeled packets are @xmath214 and @xmath215 .",
    "parities are generated as follows . since @xmath216 and @xmath217 , the number of parities is @xmath218 , @xmath219 , @xmath220 ( thus generating one parity from flow @xmath15 and labeling it with @xmath15 , _",
    "i.e. _ , @xmath221 ) , and @xmath222 ( thus generating two parities from flow @xmath18 and labeling them with @xmath15 , _",
    "i.e. _ , @xmath223 ) .    in fig .",
    "[ fig : example_intra_inter](b ) , we describe inter - session nc .",
    "node @xmath1 performs inter - session nc and transmits packets according to alg .",
    "[ alg : packet_transmit ] : it xors packets from the two queues , for @xmath224 , and broadcasts over the hyperarc @xmath225 .",
    "in particular , it transmits the following packets : @xmath226 , @xmath227 , @xmath228 , and @xmath229 .",
    "@xmath3 receives and decodes all the packets .",
    "@xmath5 receives @xmath230 packets on the average over overhearing link @xmath7 and receives @xmath231 packets over transmission link @xmath56 .",
    "five received packets allows @xmath5 to decode all five packets @xmath232 , so @xmath211 is successfully decoded .",
    "we used the glomosim simulator @xcite , which is well suited for simulating wireless environments .",
    "we considered various _",
    "topologies _ : x topology , shown in part of fig .",
    "[ fig : one - hop ] and repeated in fig .",
    "[ fig : all_topologies](a ) ; the cross - topology with four end - nodes generating bi - directional traffic , with one relay shown in fig .",
    "[ fig : all_topologies](b ) ; the wheel topology shown in fig .",
    "[ fig : all_topologies](c ) ; and the multi - hop topology shown in fig .",
    "[ fig : one - hop ] . in x ,",
    "cross , and wheel topologies , the intermediate node @xmath1 is placed in a center of of circle with radius @xmath233 over @xmath234 terrain and all other nodes @xmath2 , @xmath4 and etc .",
    "are placed around the circle . in the multi - hop topology of fig .",
    "[ fig : one - hop ] , two x topologies are cascaded and the distance between consecutive nodes is set to @xmath233 .",
    "the topology is over a @xmath235 terrain .",
    "we also considered various _",
    "traffic scenarios _ : ftp / tcp and cbr / udp .",
    "tcp and cbr flows start at random times within the first @xmath236 and are on until the end of the simulation which is @xmath237 .",
    "the cbr flow generates data packets at every @xmath238 .",
    "ieee 802.11b is used in the _ mac layer _",
    ", with the addition of the pseudo - broadcasting mechanism , as in cope @xcite . in terms of _ wireless channel _ , we simulated the two - ray path loss model and a rayleigh fading channel with average channel loss rates @xmath239 % .",
    "we have repeated each @xmath237 simulation for @xmath240 seeds .",
    "channel capacity is @xmath241 , the buffer size at each node is set to @xmath242 packets , packet sizes are set to @xmath243 , the generation size is set to 15 packets for udp flows and to the tcp window size for tcp flows .",
    "we compare our schemes ( i@xmath0nc - state and i@xmath0nc - stateless ) to no network coding ( _ nonc _ ) , and _",
    "@xcite , in terms of total transport - level throughput ( added over all flows ) .",
    "_ tcp traffic .",
    "_ in fig .",
    "[ fig : tcp_results_vs_specific_loss ] , we present simulation results for two tcp flows in x topology shown in fig .",
    "[ fig : all_topologies](a ) to illustrate the key intuition of our approach .",
    "consider , for the moment , that loss occurs only on one link , either ( a ) the overhearing link @xmath7 or ( b ) the direct link @xmath56 .",
    "+    the first case is depicted in fig .",
    "[ fig : tcp_results_vs_specific_loss](a ) .",
    "loss on the overhearing link does not affect the uncoded streams , thus the throughput of tcp+nonc does not change with loss rate . when nc is employed , reports carrying information about overheard packets may be delivered late to intermediate node @xmath1 .",
    "thus , there are some instances that intermediate node should make a decision even if it does not have the exact knowledge . in this case",
    ", @xmath1 makes a decision probabilistically .",
    "specifically , if decoding probability exceeds some threshold ( 20% in our simulations ) , @xmath1 codes packets . however , some of these packets may not be decodable at the receiver .",
    "it is why the performance of tcp+cope and tcp+i@xmath0nc - state reduce with increasing loss rate and equals to the throughput of tcp+nonc after 20% loss rate ( nc is turned off after 20% loss rate ) .",
    "however , tcp+i@xmath0nc - state is still better than tcp+cope , because when it makes probabilistic nc decision ( when loss rate is less than 20% ) , it adds redundancy considering the loss rate over the overhearing link .",
    "this improves throughput , because adding redundancy using intra - session nc makes all packets equally beneficial to the receiver and the probability of decoding inter - session network coded packets increases .",
    "tcp+i@xmath0nc - stateless  outperforms other schemes over the entire loss range .",
    "for example , if there is no loss , i@xmath0nc - stateless  still brings the benefit due to eliminating ack packets and using less overhead to communicate information ( _ i.e. , _ cope and i@xmath0nc - state  exchanges the information about the overheard packets , while i@xmath0nc - stateless  exchanges the information about the loss rates ) , thus using the medium more efficiently .",
    "when the loss rate increases , the improvement of i@xmath0nc - stateless  becomes significant , reaching up to 30% .",
    "the reason is that at high loss rates , i@xmath0nc - state  and cope  do not have reliable knowledge of the decoding buffers of their neighbors and can not do nc efficiently .",
    "in contrast , i@xmath0nc - stateless  does not rely on this information , but on the loss rate of the overhearing link to make nc decision . in the discussion of example 1",
    ", we mentioned that at 50% loss rate , 16.6% improvement can be achieved via nc . here , we see this improvement ( 13% ) as well as the the additional benefit of eliminating ack packets ( 12% ) .",
    "note that the total improvement is 25% .",
    "the second case is depicted in fig .",
    "[ fig : tcp_results_vs_specific_loss](b ) .",
    "the throughput of tcp+nonc decreases with increasing loss rate because , the loss is over the direct link and some packets whether they are coded or not are lost on the direct link ( @xmath56 ) .",
    "this leads to decrease in throughput level . tcp+i@xmath0nc - state  outperforms tcp+cope  in this scenario , because i@xmath0nc - state  corrects errors on the direct link thanks to the added redundancy which reduces the number of re - transmissions .",
    "thus , i@xmath0nc - state  uses the channel more efficiently than cope  and improves the throughput . note that tcp+i@xmath0nc - state  outperforms tcp+cope  even after 20% loss rate , although inter - session nc is turned off after this level .",
    "the reason is that although i@xmath0nc - state  does not do inter - session nc after 20% loss rate , it keeps doing intra - session nc which adds redundancy to correct errors . due to this property",
    ", tcp+i@xmath0nc - state  outperforms tcp+cope  even at high loss rates .",
    "tcp+i@xmath0nc - stateless  significantly outperforms all alternatives again due to performing nc at all loss rates and eliminating ack packets .",
    "[ fig : tcp_results_vs_loss ] presents simulation results for tcp traffic over x , cross , and the multi - hop topologies assuming loss on all links . for ease of presentation , here , we report only the results when all links have the same loss probability .",
    "[ fig : tcp_results_vs_loss](a ) shows the results for the x topology . at low - medium loss rates ( 10% - 30% ) , i@xmath0nc - state  and cope  are still able to do nc ,",
    "so tcp+i@xmath0nc - state and tcp+cope improve throughput significantly as compared to tcp+nonc . at higher loss rates ,",
    "i@xmath0nc - state and cope do not have reliable knowledge of the decoding buffers of their neighbors and can not do nc efficiently . as a result , the improvement of tcp+i@xmath0nc - state and tcp+cope as compared to tcp+nonc reduce with increasing loss rate .",
    "tcp+i@xmath0nc - state is better than tcp+cope at higher loss rates thanks to its error correction mechanism .",
    "tcp+i@xmath0ncstateless outperforms other schemes over the entire loss range thanks to combining nc and error correction as well as eliminating acks . for example , if there is no loss , tcp+i@xmath0nc - stateless still brings the benefit by eliminating ack packets , thus using the medium more efficiently . when the loss rate increases , the improvement of i@xmath0nc - stateless becomes significant , because i@xmath0nc - stateless does not rely on the knowledge of the decoding buffers of their neighbors , but only on the link loss rates for inter - session nc .    fig .",
    "[ fig : tcp_results_vs_loss](b ) shows the results for the cross topology .",
    "the improvement of tcp+i@xmath0nc - stateless is higher as compared to the x topology , because there are more nc opportunities here for i@xmath0nc - stateless to exploit .",
    "we also performed simulations with increasing number of flows , ( _ i.e. _ , nodes in this topology ) ; the details are provided later in this section .",
    "[ fig : tcp_results_vs_loss](c ) presents the results for the multi - hop topology in fig .",
    "[ fig : one - hop ] .",
    "the improvement of tcp+i@xmath0nc - state is higher than in the x and cross topologies , especially at higher loss rates .",
    "this is because intra - session coding , employed by i@xmath0nc - state , reduces the dependency on link level arq .",
    "more specifically , in this multi - hop topology , the end - to - end residual loss rate increases with the number of hops .",
    "intra - session nc overcomes this , thus increasing tcp throughput .",
    "the improvement of i@xmath0nc - stateless is even more significant for this topology , because the benefit of eliminating acks is more pronounced with larger number of hops .",
    "we also performed simulations with increasing number of flows , _",
    "i.e. , _ nodes in wheel topology in fig .",
    "[ fig : all_topologies](c ) .",
    "it is seen in fig .",
    "[ fig : cross_number_of_flows ] that the total throughput achieved by nc schemes increases with the increasing number of flows . when the number of flows increases , the probability of nc at the intermediate node @xmath1 increases .",
    "more nc opportunities leads to higher throughput .",
    "wheel topology shown in fig .",
    "[ fig : all_topologies](c ) with increasing number of flows . loss rate on all links is set to 10%.,width=226 ]    _ udp traffic .",
    "_ we repeated the simulations for the three topologies for the case that there is loss over all links .",
    "the results are presented in fig .",
    "[ fig : udp_results_vs_loss ] .    fig .",
    "[ fig : udp_results_vs_loss](a ) presents the results for the x topology .",
    "the improvement of udp+i@xmath0nc - stateless  is up to 60% as compared to udp+nonc .",
    "this is significantly higher than the improvement of tcp+i@xmath0nc - stateless  and the optimal scheme ( in which the improvement is 33.3% ) .",
    "the reason is the mac gain as explained in @xcite .",
    "we present the results for the load at which the system saturates . at this load , udp+nonc",
    "is already saturated , several packets are dropped from the buffers , and they do not arrive to their receivers . this reduces the throughput of nonc , while nc schemes still handle the traffic created by the load .",
    "notice that even at 50% loss rate , udp+i@xmath0nc - stateless  improves over udp+nonc by 40% , which is significant .",
    "[ fig : udp_results_vs_loss](b ) presents the results for the cross topology . in this topology ,",
    "the improvement of nc is very large .",
    "when there is no loss , the improvement is around 250% .",
    "the effectiveness of udp+i@xmath0nc - stateless  is also significant in this topology : at 50% loss rate the improvement of udp+i@xmath0nc - stateless  over udp+nonc is 70% .",
    "[ fig : udp_results_vs_loss](c ) presents the results for multi - hop topology .",
    "we see similar behavior as observed by figs .",
    "[ fig : udp_results_vs_loss](b ) and ( c ) . however , the improvement of udp+i@xmath0nc - stateless  is larger in this topology , because the benefit of eliminating acks is more pronounced with larger number of hops .",
    "we consider the x and cross topologies shown in figs .",
    "[ fig : all_topologies](a ) and [ fig : all_topologies](b ) . in the x topology",
    ", @xmath2 transmits packets to @xmath3 via @xmath1 with rate @xmath244 , and @xmath4 transmits packets to @xmath5 via @xmath1 with rate @xmath245 . in the cross topology , @xmath2 transmits packets to @xmath3 with rate @xmath244 , @xmath3 transmits packets to @xmath2 with rate @xmath245 , @xmath4 transmits packets to @xmath5 with rate @xmath246 , and @xmath5 transmits packets to @xmath4 with rate @xmath247 .",
    "all transmissions are via @xmath1 . in both topologies ,",
    "the data rate of each link is set to @xmath174 packet / transmission .",
    "we compare our schemes i@xmath0nc - state  and i@xmath0nc - stateless  with nonc which is also formulated in a network utility maximization framework without any nc constraints .",
    "[ fig : x_nc_results_vs_loss ] shows the total throughput ; @xmath248 for x topology .",
    "[ fig : x_nc_results_vs_loss](a ) shows the results when there is loss on @xmath7 .",
    "it is seen that the throughput of nonc is flat with increasing loss rate , because it is not affected by the loss rate on the overhearing link .",
    "i@xmath0nc - state  and i@xmath0nc - stateless  improve over nonc , because they exploit nc benefit .",
    "when the loss rate increases , the improvement reduces , because @xmath5 overhears only part of the data transmitted by @xmath2 .",
    "although the improvement decreases with increasing loss rate , it is still significant , _",
    "16.6% at 50% loss rate .",
    "note that fig .",
    "[ fig : x_nc_results_vs_loss](a ) is the counterpart of the simulation results presented in fig .",
    "[ fig : tcp_results_vs_specific_loss](a ) .",
    "it is seen that tcp+i@xmath0nc - stateless  in fig .",
    "[ fig : tcp_results_vs_specific_loss](a ) shows similar performance as i@xmath0nc - stateless  in fig .",
    "[ fig : x_nc_results_vs_loss](a ) .",
    "this shows the effectiveness of i@xmath0nc - stateless  in a realistic simulation environment .",
    "+    fig .",
    "[ fig : x_nc_results_vs_loss](b ) shows the results when there is loss on @xmath56 .",
    "it is seen that i@xmath0nc - state  and i@xmath0nc - stateless  improve over nonc significantly at all loss rates .",
    "it is also interesting to note that at 50% loss rate , i@xmath0nc - state  and i@xmath0nc - stateless  improve over nonc by 44% which is even higher than in the no loss case ( 33% ) .",
    "the reason is in the following . in the optimal solution ,",
    "the throughput values are @xmath249 and @xmath250 . in this case , in the downlink @xmath56 , data part of @xmath245 with rate @xmath251 and the parity part with rate @xmath251 ( considering loss rate 50% ) are combined with @xmath244 .",
    "this means that our schemes combine both parity and data parts of a flow with other flows and this improves the throughput significantly .",
    "this is one of the important contributions of i@xmath0nc .",
    "[ fig : x_nc_results_vs_loss](c ) shows the results when there is loss on links @xmath7 and @xmath56 .",
    "it is seen that i@xmath0nc - state  improves the throughput significantly while the improvement of i@xmath0nc - stateless  reduces to @xmath175 with increasing loss rate .",
    "the reason is that , i@xmath0nc - stateless  is a more conservative scheme as compared to i@xmath0nc - state  in the sense that it eliminates the perfect knowledge on antidotes .",
    "yet , it still improves the throughput significantly , _",
    "e.g. , _ it improves over nonc by 22% at 30% loss rate .",
    "[ fig : x_nc_results_vs_loss](d ) shows the results when there is loss on all links .",
    "it is seen that i@xmath0nc - state  and i@xmath0nc - stateless  improve over nonc significantly at all loss rates .",
    "note that throughput of i@xmath0nc - stateless  reduces to that of nonc at 50% loss rate in fig .",
    "[ fig : x_nc_results_vs_loss](c ) .",
    "the reader might wonder why we do not see such behavior in fig .",
    "[ fig : x_nc_results_vs_loss](d ) .",
    "the reason is that since there is loss over link @xmath252 as well as @xmath7 , the number of parities added by @xmath2 to correct losses over link @xmath252 also increases the number of overheard packets at @xmath5 .",
    "therefore , i@xmath0nc - stateless  does not add redundancy at node @xmath1 for both @xmath7 and @xmath56 as in fig .",
    "[ fig : x_nc_results_vs_loss](c ) , but adds redundancy only for loss on link @xmath56 .",
    "this improves the performance of i@xmath0nc - stateless  .",
    "note that the counterpart of these results are presented in fig .",
    "[ fig : tcp_results_vs_loss](a ) .",
    "it is seen that the throughput improvement of i@xmath0nc - stateless  over nonc at 50% loss rate is around 30% in fig .",
    "[ fig : x_nc_results_vs_loss](d ) .",
    "as compared to this , the improvement of tcp+i@xmath0nc - stateless  over nonc is limited in fig .",
    "[ fig : tcp_results_vs_loss](a ) , because , in simulations , the block size is limited and fixed , and the scheduling is not perfect ( we consider ieee 802.11 ) . yet , the throughput improvement of tcp+i@xmath0nc - stateless  over nonc is around 20% in fig .",
    "[ fig : tcp_results_vs_loss](a ) , which is significant .    fig .",
    "[ fig : cross_nc_results_vs_loss ] shows the total throughput ; @xmath253 for i@xmath0nc - state , i@xmath0nc - stateless  and nonc for the cross topology shown in fig .",
    "[ fig : all_topologies](b ) for different loss patterns .",
    "it is seen that the results are similar to the ones in fig .",
    "[ fig : x_nc_results_vs_loss ] .",
    "one difference is that the throughput improvement of nc schemes is higher , _",
    "i.e. _ , up to 80% , because there are more nc opportunities in the cross topology",
    "in this paper , we proposed i@xmath0nc : a one - hop intra- and inter - session network coding approach for wireless networks .",
    "i@xmath0nc builds on and improves cope in two aspects : it is resilient to loss and it does not need to rely on the exact knowledge of the state of the neighbors . our design is grounded on a num formulation and its solution .",
    "simulations in glomosim demonstrate significant throughput gain of our approach compared to no network coding and cope .",
    "y.  wu , p.  a.  chou , and s.  y.  kung , `` information exchange in wireless network coding and physical layer broadcast , '' _ in proc . of ciss _ , baltimore , md , march 2005 .",
    "s.  katti , h.  rahul , w.  hu , d.  katabi , m.  mdard , and j.  crowcroft , `` xors in the air : practical wireless network coding , '' _ in ieee trans . on networking _ ,",
    "16(3 ) , june 2008 .",
    "m. effros , t. ho and s. kim , `` a tiling approach to network code design for wireless networks , '' _ in proc . of itw _ , punta del este , uruguay , march 2006 .",
    "d.  traskov , n.  ratnakar , d.  s.  lun , r.  koetter , and m.  medard , `` network coding for multiple unicasts : an approach based on linear optimization , '' _ in proc . of isit _ ,",
    "seattle , wa , july 2006 .",
    "s.  omiwade , r.  zheng , and c.  hua .",
    "`` butterflies in the mesh : lightweight localized wireless network coding , '' _ in proc . of netcod _ , lausanne , switzerland , jan . 2008 .",
    "h.  seferoglu and a.  markopoulou , `` network coding - aware queue management for unicast flows over coded wireless networks , '' _ in proc . of netcod _ ,",
    "toronto , canada , june 2010 .",
    "m.  chiang , s.  t.  low , a.  r.  calderbank , and j.  c.  doyle , `` layering as optimization decomposition : a mathematical theory of network architectures , '' _ in proceedings of the ieee _ ,",
    "95(1 ) , jan .",
    "glomosim version 2.0 , `` global mobile information systems simulation library , '' _ available at pcl.cs.ucla.edu / projects / glomosim/_.    p.  chaporkar and a.  proutiere , `` adaptive network coding and scheduling for maximizing througput in wireless networks , '' _ in proc . of acm mobicom _ ,",
    "montreal , canada , sep . 2007 .",
    "j.  le , j.  lui , and d.  m.  chiu , `` how many packets can we encode ? - an analysis of practical wireless network coding , '' _ in proc . of infocom _ ,",
    "phoenix , az , april 2008 . s.  sengupta , s.  rayanchu , and s.  banarjee , `` an analysis of wireless network coding for unicast sessions : the case for coding - aware routing , '' _ in proc . of infocom _ ,",
    "anchorage , ak , may 2007 .    q.  dong , j.  wu , w.  hu , and j.  crowcroft , `` practical network coding in wireless networks , '' _ in proc . of mobicom _ ,",
    "montreal , canada , sept .",
    "f.  zhao and m.  medard , `` on analyzing and improving cope performance , '' _ in proc . of ita _ , san diego , ca , feb .",
    "s.   rayanchu , s.  sen , j.  wu , s.  banerjee , and s.  sengupta , `` loss - aware network coding for unicast wireless sessions : design , implementation , and performance evaluation , '' _ in proc . of sigmetrics _ ,",
    "annopolis , md , june 2008 .",
    "j.  y.  lee , w.  j.  kim , j.  y.  baek , and y.  j.  suh , `` a wireless network coding scheme with forward error correction code in wireless mesh networks , '' _ in proc . of globecom _ ,",
    "honolulu , hi , dec .",
    "k.  ronasi , a.  h.  mohsenian - rad , v.  w.  s.  wong , s.  gopalakrishnan , and r.  schober , `` reliability - based rate allocation in wireless inter - session network coding systems , '' _ in proc . of globecom _ ,",
    "honolulu , hi , dec .",
    "d.  aguayo , j.  bicket , s.  biswas , g.  judd , and r.  morris , `` link - level measurements from an 802.11b mesh network , '' _ in proc . of acm sigcomm _ ,",
    "portland , or , sept . 2004 . c.  steger , p.  radosavljevic , and j.  p.  frantz , `` performance of ieee 802.11b wireless lan in an emulated mobile channel , '' _ in proc . of vtc _ , orlando , fl , oct .",
    "o.  tickoo , v.  subramanian , s.  kalyanaraman , and k.  k.  ramakrishnan , `` lt - tcp : end - to - end framework to improve tcp performance over networks with lossy channels , '' _ in proc . of iwqos",
    "_ , passau , germany , june 2005 .",
    "j.  k.  sundararajan , d.  shah , m.  medard , m.  mitzenmacher , and j.  barros , `` network coding meets tcp , '' _ in proc . of infocom _ , rio de janeiro , brazil , april 2009 .",
    "h.  seferoglu , a.  markopoulou , and k.  k.  ramakrishan , `` i@xmath0nc : intra- and inter - session network coding for unicast flows in wireless networks , '' _ in proc . of infocom _ ,",
    "shanghai , china , april 2011 .",
    "p.  gupta and p.  r.  kumar , `` the capacity of wireless networks , '' _ in ieee trans . on information theory _ ,",
    "46(2 ) , march 2000 .",
    "p.  a.  chou and y.  wu,``network coding for the internet and wireless networks , '' _ in ieee signal proc .",
    "24(5 ) , sept .  2007 .",
    "l.  chen , t.  ho , s.  low , m.  chiang , and j.  c.  doyle , `` optimization based rate control for multicast with network coding , '' _ in proc . of infocom _",
    ", anchorage , ak , may 2007 .",
    "d.  s.  lun , n.  ratnakar , m.  medard , r.  koetter , d.  r.  karger , t.  ho , e.  ahmed , and f.  zhao , `` minimum - cost multicast over coded packet networks , '' _ in ieee trans . on information theory _ ,",
    "52(6 ) , june 2006 .",
    "r.  ahlswede , n.  cai , s.  y.  r.  li , r.  w.  yeung , `` network information flow , '' _ in ieee trans . on information theory _ ,",
    "46(4 ) , july 2000 .",
    "r.  koetter , m.  mdard , `` an algebraic approach to network coding , '' _ in ieee / acm trans . on networking _ ,",
    "11(5 ) , oct .",
    "t.  ho and d.  s.  lun , `` network coding : an introduction , '' cambridge university press , cambridge , u.k .",
    ", april 2008 .",
    "v.  sharma , k.  k.  ramakrishnan , k.  kar , and s.  kalyanaraman , `` complementing tcp congestion control with forward error correction , '' _ in proc . of networking",
    "_ , aachen , germany , may 2009 .",
    "t.  ho , m.  medard , r.  koetter , d.  r.  karger , m.  effros , j.  shi , and b.  leong , `` a random linear network coding approach to multicast , '' _ in ieee trans . on information theory _ ,",
    "52(10 ) , oct .",
    "y.  huang , m.  ghaderi , d.  towsley , and w.  gong , `` tcp performance in coded wireless mesh networks , '' _ in proc .",
    "of ieee secon _ , san francisco , ca , june 2008 .",
    "h.  seferoglu and a.  markopoulou , `` delay - optimized network coding for video streaming over wireless networks , '' _ in proc . of icc",
    "_ , south africa , may 2010 .",
    "r.  srikant , `` the mathematics of internet congestion control , '' birkhauser , 2004 .",
    "s.  h.  low , `` a duality model of tcp and queue management algorithms , '' _ in ieee / acm transactions on networking _ , vol .",
    "11(4 ) , aug .",
    "2003 .    s.  h.  low , j.  doyle , and f.  paganini , `` internet congestion control , '' _ in ieee control syst . mag .",
    "_ , vol .",
    "21(1 ) , feb .",
    "l.  chen , t.  ho , m.  chiang , s.  h.  low , and j.  c.  doyle , `` congestion control for multicast network coding , '' http://www.princeton.edu/  chiangm / netcod.pdf .",
    "h.  k.  khalil , `` nonlinar systems , '' prentice - hall , 1996 .",
    "in this section , we analyze the convergence of the distributed solution of the num problem , given in section  [ sec : opt2 ] .",
    "first , we provide a proof of convergence , and then present some numerical calculations to verify the convergence .",
    "the derivative of the lyapunov function with respect to the lagrange multipliers is expressed as ; @xmath265_{q_{h , k}^{s}}^{+ } + \\sum_{h \\in { \\mathcal{a } } } \\sum_{k \\in { \\mathcal{k}}_{h } } ( \\tau_{h , k } - \\overset{*}{\\tau}_{h , k } ) [ q_{h , k } - e_{{\\mathcal{c}}_q}[q]]_{\\tau_{h , k}}^{+ } + \\sum_{h \\in { \\mathcal{a } } } \\sum_{k \\in { \\mathcal{k}}_{h } } \\sum_{s \\in { \\mathcal{s}}_{k } } \\overset{*}{x_{s } } ( \\alpha_{h , k}^{s } - \\overset{*}{\\alpha}_{h , k}^{s } ) [ e_{i}[q ] - h_{h , k}^{s}q_{h , k}^{s}]_{\\alpha_{h , k}^{s}}^{+}$ ] .    by using the definition of the function @xmath116_{z}^{+}$ ] , and considering that since @xmath266 $ ] is the minimal @xmath130 and @xmath267 $ ]",
    "is the maximal @xmath110 , the following holds ; @xmath268 ) + \\sum_{h \\in { \\mathcal{a } } } \\sum_{k \\in { \\mathcal{k}}_{h } } \\sum_{s \\in { \\mathcal{s}}_{k } } \\overset{*}{x_{s } } ( \\alpha_{h , k}^{s } - \\overset{*}{\\alpha}_{h , k}^{s } ) ( e_{i}[q ] - h_{h , k}^{s}q_{h , k}^{s})$ ] .",
    "when we arrange the terms in the above inequality by adding and removing terms , we have ; @xmath274 @xmath275 @xmath276 @xmath277 @xmath278 @xmath279 since the marginal utility @xmath280 is a decreasing function , its inverse , _",
    "i.e. , _ the eq .",
    "( [ appendix : ly_eq8_1 ] ) is less than 0 . due to the optimality condition in eq .",
    "( [ appendix : opt_cond_eq2 ] ) and eq .",
    "( [ appendix : opt_cond_eq4 ] ) , eq .",
    "( [ appendix : ly_eq8_2 ] ) is less than 0 . due to the optimality condition in eq .",
    "( [ appendix : opt_cond_eq3 ] ) , eq .",
    "( [ appendix : ly_eq8_3 ] ) is less than 0 . due to the optimality condition in eq .",
    "( [ appendix : opt_cond_eq5 ] ) , eq .",
    "( [ appendix : ly_eq8_4 ] ) is less than 0 .",
    "thus , @xmath281 .",
    "this implies the convergence of our solutions , @xcite , @xcite .",
    "we consider again the x and cross topologies shown in figs .",
    "[ fig : all_topologies](a ) and [ fig : all_topologies](b ) . in the x topology",
    ", @xmath2 transmits packets to @xmath3 via @xmath1 with rate @xmath244 , and @xmath4 transmits packets to @xmath5 via @xmath1 with rate @xmath245 . in the cross topology , @xmath2 transmits packets to @xmath3 with rate @xmath244 , @xmath3 transmits packets to @xmath2 with rate @xmath245 , @xmath4 transmits packets to @xmath5 with rate @xmath246 , and @xmath5 transmits packets to @xmath4 with rate @xmath247 .",
    "all transmissions are via @xmath1 . in both topologies ,",
    "the data rate of each link is set to @xmath174 packet / transmission and the loss rate is set to 30% .    in figs .",
    "[ fig : x_nc_state_convergence ] and [ fig : x_nc_stateless_convergence ] , we present the throughput vs. the iteration number for the x topology at different loss patterns for i@xmath0nc - state  and i@xmath0nc - stateless , respectively .",
    "each figure shows the convergence of @xmath244 , @xmath245 , and @xmath248 to their optimum values .",
    "_ e.g. _ , @xmath248 converges to its optimum value @xmath282 in fig .",
    "[ fig : x_nc_state_convergence](c ) and @xmath248 converges to its optimum value @xmath283 in fig .  [ fig : x_nc_stateless_convergence](c ) .    fig .",
    "[ fig : cross_nc_state_convergence ] and [ fig : cross_nc_stateless_convergence ] present the throughput vs. the iteration number for the cross topology at different loss patterns for i@xmath0nc - state  and i@xmath0nc - stateless , respectively .",
    "we see similar convergence results . specifically , each flow rate , @xmath244 , @xmath245 , @xmath246 , @xmath247 , and the total rate converge to their optimum values ."
  ],
  "abstract_text": [
    "<S> in this paper , we are interested in improving the performance of constructive network coding schemes in lossy wireless environments . </S>",
    "<S> we propose i@xmath0nc - a cross - layer approach that combines inter - session and intra - session network coding and has two strengths . </S>",
    "<S> first , the error - correcting capabilities of intra - session network coding make our scheme resilient to loss . </S>",
    "<S> second , redundancy allows intermediate nodes to operate without knowledge of the decoding buffers of their neighbors . based only on the knowledge of the loss rates on the direct and overhearing links </S>",
    "<S> , intermediate nodes can make decisions for both intra - session ( _ i.e. , _ how much redundancy to add in each flow ) and inter - session ( _ i.e. , _ what percentage of flows to code together ) coding . our approach is grounded on a network utility maximization ( num ) formulation of the problem . </S>",
    "<S> we propose two practical schemes , i@xmath0nc - state and i@xmath0nc - stateless , which mimic the structure of the num optimal solution . </S>",
    "<S> we also address the interaction of our approach with the transport layer . </S>",
    "<S> we demonstrate the benefits of our schemes through simulations .    network coding , wireless networks , error correction , cross - layer optimization . </S>"
  ]
}