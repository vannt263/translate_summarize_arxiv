{
  "article_text": [
    "game theory @xcite is a great theoretical outcome of the 20th century and is used widely in interpreting social and economic phenomena . because of the universality of games , games are also widely used in science and engineering . on one side , game theory has been applied in many domains successfully . on the other side , using different tools to interpret game theory is also an interesting direction",
    ".    in computer science , there are various kind of tools to capture the computation concept concerned with the nature of computability .",
    "there is no doubt that process algebra @xcite is one of the most influential tools .",
    "milner s ccs ( calculus of communicating systems ) @xcite , hoare s csp ( communicating sequential processes ) @xcite and acp ( algebra of communicating process ) @xcite are three dominant forms of process algebra , and there are also several kinds of process calculi .",
    "such process algebras often have a formal deductive system based on equational logic and a formal semantics model based on labeled transition systems , can be suitable to reason about the behaviors of parallel and distributed systems .",
    "the combination of games and computer science is a fascinating direction , and it gains great successes , such as the so - called game semantics @xcite . since there exist lots of game phenomena in parallel and distributed systems , especially interactions between a system and its environment , interactions among system components , and interactions among system components and outside autonomous software agents , the introduction of games into traditional computation tools , such as the above mentioned process algebra , is attractive and valuable .",
    "the computation tools extended to support games can be used to reason about the behaviors of systems in a new viewpoint .    using these computation tools to give game theory",
    "an interpretation is an interesting problem @xcite .",
    "this direction has subtle difference with introducing games and ideas of games into the computation tools .",
    "it not only can make these tools having an additional ability to using games in computation , but also gives game theory a new interpretation which will help the human to capture the nature of games and also the development of game theory .",
    "although in some process algebras , such as csp , there are an internal choice @xmath0 and an external choice @xmath1 , process algebra acp does not distinguish the internal choice and the external choice . in this paper , we introduce external choice into process algebra acp in a game theory flavor .",
    "we give games an axiomatic foundation called gameacp based on process algebra acp @xcite .",
    "because of acp s clear semantic model based on bisimulation or rooted branching bisimulation @xcite and well designed axiomatic system , gameacp inherits acp s advantages in an elegant and convenient way .",
    "this is the first step to use computation tools to interpret games in an axiomatic fashion as far as we know .",
    "this paper is organized as follows . in section 2 , we analyze the related works .",
    "application scenarios called submittingorder , transacting and purchasing are illustrated in section 3 . in section 4",
    ", we briefly introduce some preliminaries , including equational logic , structural operational semantics , process algebra acp and also games . in section 5 , the extension of bpa ( basic process algebra ) for games is done , which is called gamebpa , including opponent s alternative composition operator and another new operator called playing operator of gameacp processes , and their transition rules and the properties of the extension , and we design the axioms of opponent s alternative composition and playing operator , including proving the soundness and completeness of the axiomatic system . in section 6 , we do another extension based on acp , which is called gameacp . we give the correctness theorem in section 7 . in section 8 , we show the support for multi - person games . finally , conclusions are drawn in section 9 .",
    "as mentioned above , the combination of computation tools and game semantics includes two aspects : one is introducing games or idea of games into these computation languages or tools to give them a new viewpoint , and the other is using these computation tools to interpret games .",
    "the first one has plenty of works and gained great successes , but the second one has a few works @xcite @xcite as we known .",
    "we introduce the two existing works in the following .",
    "it is no doubt that the so - called game semantics gained the most great successes in introducing games into computer science .",
    "game semantics models computations as playing of some kind of games , especially two person games . in the two person game",
    ", the player ( p ) represents the system under consideration and the opponent ( o ) represents the environment in which the system is located . in game semantics , the behaviors of the system ( acts as p ) and the environment ( acts as o )",
    "are explicitly distinguished .",
    "so the interactions between the system and the environment can be captured as game plays between the opponent and the player , and successful interactions can be captured by the game strategy .",
    "for example , the function @xmath2 where @xmath3 can be deemed as the games played in fig . [ f(x ) ] .",
    "firstly , the opponent ( the environment ) moves to ask the value of @xmath4 , then the player ( the function ) moves to ask the value of @xmath5 , and then the opponent moves to answer that the value of @xmath5 is 5 , the player moves to answer that the value of @xmath4 is 25 finally .     where @xmath3 . ]",
    "game semantics has gained great successes in modeling computations , such as an initial success of modeling the functional programming language pcf ( programming computable functions ) @xcite @xcite @xcite , multiplicative linear logic @xcite , idealized algol @xcite , general reference @xcite , etc . to model concurrency in computer science with game semantics , a new kind of game semantics called asynchronous game @xcite",
    "@xcite @xcite @xcite @xcite is established and a bridge between the asynchronous game and traditional game semantics is founded . moreover , asynchronous games perfectly model propositional linear logic and get a full completeness result .",
    "another kind of game semantics to describe concurrency is concurrent game @xcite @xcite , and a work to bridge asynchronous game and concurrent game is introduced in @xcite .",
    "algorithmic game semantics @xcite is the premise of implementation of game semantics for further automatic reasoning machine based on some specific game semantics model . and",
    "game semantics can be used to establish the so - called interaction semantics @xcite among autonomous agents , and can be used to model and verify compositional software @xcite @xcite .",
    "game semantics utilizes such dialogue games to model interactions between the system under consideration and the environment , and pays more attention to the playing process of the two players . and",
    "it develops some key concepts which have correspondents to traditional computation concepts , such as innocence to context independence and bracketing to well - structured property .",
    "different to game semantics , there are also several works to use computation tools to model games of two agents .",
    "game - ctr @xcite introduces games into ctr ( concurrent transaction logic ) to model and reason about runtime properties of workflows that are composed of non - cooperative services  such as web services .",
    "game - ctr includes a model and proof theory which can be used to specify executions under some temporal and causality constraints , and also a game solver algorithm to convert such constraints into other equivalent game - ctr formulas to be executed more efficiently .",
    "chatzikokolakis et al@xcite develop a game semantics for a certain kind of process calculus with two interacting agents .",
    "games and strategies on this process calculus are defined , and strategies of the two agents determine the execution of the process . and also , a certain class of strategies correspond to the so - called syntactic schedulers of chatzikokolakis and palamidessi . in these works ,",
    "the games used are not dialogue games , and there are no interactions such as questions and answers and also no wining concept .    more like game - ctr @xcite and chatzikokolakis s work @xcite , we introduce games into acp , or we use acp to give games an interpretation . unlike @xcite and @xcite , our work gameacp is an attempt to do axiomatization with an extension of process algebra acp for games .",
    "it has the following characteristics :    1 .",
    "we introduce the external choice into process algebra acp in a game theory flavor . as a result of axiomatization",
    ", gameacp has not only an equational logic , but also a bisimulation semantics .",
    "the conclusions of gameacp are without any assumption or restriction , such as epistemic restrictions on strategies in @xcite .",
    "though the discussions of gameacp are aimed at two person games , gameacp can be naturally used in multi - person games .",
    "gameacp provides a new viewpoint to model interactions between one autonomous agent and other autonomous agents , and can be used to reason about the behaviors of parallel and distributed systems with game theory supported .",
    "in this section , we will illustrate the universality of game phenomena that exist in computer systems through three different examples . using these examples throughout this paper",
    ", we illustrate our core concepts and ideas .",
    "graphical user interface is the most popular human - machine interface now .",
    "[ submittingorder]-a illustrates the flow of submitting an order for a user through a graphical interface .",
    "the flow is as follows .    1 .",
    "the interface program starts",
    "the user writes an order via the interface .",
    "3 .   when the order is completed , the user can decide to submit the order or cancel the order .",
    "if the order is submitted , then the order is stored and the program terminates .",
    "if the order is canceled , then the program terminates .        in this submittingorder example , the selection of submitting or canceling the order is done by the user , but not the program according to its inner states .",
    "this situation is suitable to be captured by use of a game between the user and the interface program .",
    "transaction processing is the core mechanism of database and business processing .",
    "traditional transaction has acid properties and is illustrated in fig .",
    "[ transaction]-a .",
    "the flow of traditional database transaction is following .    1 .",
    "the transaction is started .",
    "operations on the data are done by a user .",
    "3 .   the user can decide to submit the transaction or abort the transaction .",
    "if the transaction is submitted , the data are permanently stored and the transaction terminates .",
    "if the transaction is aborted , the data are rollbacked and the transaction also terminates .        in this transaction example",
    ", the selection of submitting or aborting the transaction is also done by the user , but not the database or business processing system according to its inner states .",
    "this situation is also suitable to be modeled by use of a game between the user and the database or business processing system .",
    "web service is a quite new distributed object and web service composition created new bigger web services from the set of smaller existing web services .",
    "a composite web service is defined by use of a kind of web service composition language and is executed by interpreting the definition of the composite web service .",
    "ws - bpel@xcite is a kind of such language . in ws - bpel",
    ", the atomic function units are called atomic activities and the corresponding structural activities define the control flow among these atomic activities . *",
    "pick * activity is a kind of choice structural activity in which the decision is made by outside autonomous web services , and is different from the * if * activities , in which the decision is made by the composite web service according to its inner states .    in fig .",
    "[ purchasing1 ] , a composite web service implements the following flow of purchasing goods and can be used by a user through a user agent web service .    1 .",
    "the composite web service is started by a user through a user agent web service .",
    "2 .   the user shops for goods . 3 .   after the shopping is finished , the user can select the shipping way : by truck , by train or by plane .",
    "4 .   if the truck way is selected , then the user should order a truck and pay online for the fees .",
    "5 .   if the train way is selected , then user should order a train and pay online for the fees .",
    "6 .   if the plane way is selected , then the user should order a plane , if the money amount is greater than 1000 dollars , he / she should pay offline for the fees ; and if not , he / she should pay online .        the ws - bpel skeleton of the purchasing composite web service is shown in fig .",
    "[ purchasing2 ] .",
    "note that the first choice is modeled by use of a * pick * activity and the second choice is modeled by use of an * if * activity .        in this purchasing composite web service , the selection of shipping ways",
    "is also done by the user through a user agent web service , and not the composite web service according to its inner states .",
    "this situation is also suitable to be modeled by use of a game between the user ( or the user agent web service ) and the composite web service .",
    "in this section , we introduce some preliminaries , including equational logic , structural operational semantics , process algebra acp and games .    in the following , the variables @xmath6 range over the collection of process terms , the variables @xmath7 range over the set @xmath8 of atomic actions , @xmath9 , @xmath10 are closed items , @xmath11 is the special constant silent step , @xmath12 is the special constant deadlock , @xmath13 is the special constant non - determinacy , and the predicate @xmath14 represents successful termination after execution of the action @xmath15 .",
    "we introduce some basic concepts about equational logic briefly , including signature , term , substitution , axiomatization , equality relation , model , term rewriting system , rewrite relation , normal form , termination , weak confluence and several conclusions .",
    "these concepts are coming from @xcite , and are introduced briefly as follows . about the details ,",
    "please see @xcite .",
    "* definition [ elp].1 ( signature)*. a signature @xmath16 consists of a finite set of function symbols ( or operators ) @xmath17 , where each function symbol @xmath18 has an arity @xmath19 , being its number of arguments . a function symbol @xmath20 of arity _ zero _",
    "is called a constant , a function symbol of arity one is called unary , and a function symbol of arity two is called binary .",
    "* definition [ elp].2 ( term)*. let @xmath16 be a signature .",
    "the set @xmath21 of ( open ) terms @xmath22 over @xmath16 is defined as the least set satisfying : ( 1)each variable is in @xmath21 ; ( 2 ) if @xmath23 and @xmath24 , then @xmath25 .",
    "a term is closed if it does not contain free variables .",
    "the set of closed terms is denoted by @xmath26 .",
    "* definition [ elp].3 ( substitution)*. let @xmath16 be a signature .",
    "a substitution is a mapping @xmath27 from variables to the set @xmath21 of open terms .",
    "a substitution extends to a mapping from open terms to open terms : the term @xmath28 is obtained by replacing occurrences of variables @xmath5 in t by @xmath29 .",
    "a substitution @xmath27 is closed if @xmath30 for all variables @xmath5 .",
    "* definition [ elp].4 ( axiomatization)*. an axiomatization over a signature @xmath16 is a finite set of equations , called axioms , of the form @xmath31 with @xmath32 .",
    "* definition [ elp].5 ( equality relation)*. an axiomatization over a signature @xmath16 induces a binary equality relation @xmath33 on @xmath21 as follows .",
    "( 1)(substitution ) if @xmath31 is an axiom and @xmath27 a substitution , then @xmath34 .",
    "( 2)(equivalence ) the relation @xmath33 is closed under reflexivity , symmetry , and transitivity .",
    "( 3)(context ) the relation @xmath33 is closed under contexts : if @xmath35 and @xmath18 is a function symbol with @xmath36 , then @xmath37 .",
    "* definition [ elp].6 ( model)*. assume an axiomatization @xmath38 over a signature @xmath16 , which induces an equality relation @xmath33 . a model for @xmath38 consists of a set @xmath39 together with a mapping @xmath40 .",
    "( 1 ) @xmath41 is sound for @xmath38 if @xmath31 implies @xmath42 for @xmath43 ; ( 2 ) @xmath41 is complete for @xmath38 if @xmath42 implies @xmath31 for @xmath43 .    *",
    "definition [ elp].7 ( term rewriting system)*. assume a signature @xmath16 .",
    "a rewrite rule is an expression @xmath44 with @xmath32 , where : ( 1 ) the left - hand side @xmath45 is not a single variable ; ( 2 ) all variables that occur at the right - hand side @xmath46 also occur in the left - hand side @xmath45 .",
    "a term rewriting system ( trs ) is a finite set of rewrite rules .    *",
    "definition [ elp].8 ( rewrite relation)*. a trs over a signature @xmath16 induces a one - step rewrite relation @xmath47 on @xmath21 as follows .",
    "( 1 ) ( substitution ) if @xmath44 is a rewrite rule and @xmath27 a substitution , then @xmath48 .",
    "( 2 ) ( context ) the relation @xmath47 is closed under contexts : if @xmath49 and f is a function symbol with @xmath36 , then @xmath50 .",
    "the rewrite relation @xmath51 is the reflexive transitive closure of the one - step rewrite relation @xmath47 : ( 1 ) if @xmath44 , then @xmath52 ; ( 2 ) @xmath53 ; ( 3 ) if @xmath52 and @xmath54 , then @xmath55 .    * definition [ elp].9 ( normal form)*. a term is called a normal form for a trs if it can not be reduced by any of the rewrite rules .    *",
    "definition [ elp].10 ( termination)*. a trs is terminating if it does not induce infinite reductions @xmath56 .",
    "* definition [ elp].11 ( weak confluence)*. a trs is weakly confluent if for each pair of one - step reductions @xmath57 and @xmath58 , there is a term @xmath59 such that @xmath60 and @xmath61 .",
    "* theorem [ elp].1 ( newman s lemma)*. if a trs is terminating and weakly confluent , then it reduces each term to a unique normal form .    * definition",
    "[ elp].12 ( commutativity and associativity)*. assume an axiomatization @xmath38 .",
    "a binary function symbol @xmath18 is commutative if @xmath38 contains an axiom @xmath62 and associative if @xmath38 contains an axiom @xmath63 .",
    "* definition [ elp].13 ( convergence)*. a pair of terms @xmath45 and @xmath46 is said to be convergent if there exists a term @xmath59 such that @xmath55 and @xmath54 .",
    "axiomatizations can give rise to trss that are not weakly confluent , which can be remedied by knuth - bendix completion @xcite .",
    "it determines overlaps in left hand sides of rewrite rules , and introduces extra rewrite rules to join the resulting right hand sides , witch are called critical pairs .",
    "* theorem [ elp].2*. a trs is weakly confluent if and only if all its critical pairs are convergent .",
    "the concepts about structural operational semantics include labelled transition system ( lts ) , transition system specification ( tss ) , transition rule and its source , source - dependent , conservative extension , fresh operator , panth format , congruence , bisimulation , etc .",
    "these concepts are coming from @xcite , and are introduced briefly as follows . about the details ,",
    "please see @xcite .",
    "we assume a non - empty set @xmath64 of states , a finite , non - empty set of transition labels @xmath8 and a finite set of predicate symbols .",
    "* definition [ sosp].1 ( labeled transition system)*. a transition is a triple @xmath65 with @xmath66 , or a pair ( s , p ) with @xmath67 a predicate , where @xmath68 .",
    "a labeled transition system ( lts ) is possibly infinite set of transitions .",
    "an lts is finitely branching if each of its states has only finitely many outgoing transitions .",
    "* definition [ sosp].2 ( transition system specification)*. a transition rule @xmath69 is an expression of the form @xmath70 , with @xmath71 a set of expressions @xmath72 and @xmath73 with @xmath74 , called the ( positive ) premises of @xmath69 , and @xmath75 an expression @xmath72 or @xmath73 with @xmath74 , called the conclusion of @xmath69 .",
    "the left - hand side of @xmath75 is called the source of @xmath69 .",
    "a transition rule is closed if it does not contain any variables . a transition system specification ( tss )",
    "is a ( possible infinite ) set of transition rules .    *",
    "definition [ sosp].3 ( proof)*. a proof from a tss @xmath76 of a closed transition rule @xmath70 consists of an upwardly branching tree in which all upward paths are finite , where the nodes of the tree are labelled by transitions such that : ( 1 ) the root has label @xmath75 ; ( 2 ) if some node has label @xmath77 , and @xmath78 is the set of labels of nodes directly above this node , then ( a ) either @xmath78 is the empty set and @xmath79 , ( b ) or @xmath80 is a closed substitution instance of a transition rule in @xmath76 .",
    "* definition [ sosp].4 ( generated lts)*. we define that the lts generated by a tss @xmath76 consists of the transitions @xmath75 such that @xmath81 can be proved from @xmath76 .",
    "* definition [ sosp].5*. a set @xmath82 of expressions @xmath83 and @xmath84 ( where @xmath46 ranges over closed terms , @xmath15 over @xmath8 and @xmath67 over predicates ) hold for a set @xmath85 of transitions , denoted by @xmath86 , if : ( 1 ) for each @xmath87 we have that @xmath88 for all @xmath89 ; ( 2 ) for each @xmath90 we have that @xmath91 .",
    "* definition [ sosp].6 ( three - valued stable model)*. a pair @xmath92 of disjoint sets of transitions is a three - valued stable model for a tss @xmath76 if it satisfies the following two requirements : ( 1 ) a transition @xmath75 is in @xmath93 if and only if @xmath76 proves a closed transition rule @xmath94 where @xmath82 contains only negative premises and @xmath95 ; ( 2 ) a transition @xmath75 is in @xmath96 if and only if @xmath76 proves a closed transition rule @xmath94 where @xmath82 contains only negative premises and @xmath97 .    *",
    "definition [ sosp].7 ( ordinal number)*. the ordinal numbers are defined inductively by : ( 1 ) @xmath98 is the smallest ordinal number ; ( 2 ) each ordinal number @xmath99 has a successor @xmath100 ; ( 3 ) each sequence of ordinal number @xmath101 is capped by a limit ordinal @xmath102 .    * definition [ sosp].8 ( positive after reduction)*. a tss is positive after reduction if its least three - valued stable model does not contain unknown transitions .    *",
    "definition [ sosp].9 ( stratification)*. a stratification for a tss is a weight function @xmath103 which maps transitions to ordinal numbers , such that for each transition rule @xmath69 with conclusion @xmath75 and for each closed substitution @xmath27 : ( 1 ) for positive premises @xmath72 and @xmath73 of @xmath69 , @xmath104 and @xmath105 , respectively ; ( 2 ) for negative premise @xmath83 and @xmath84 of @xmath69 , @xmath106 for all closed terms @xmath107 and @xmath108 , respectively .",
    "* theorem [ sosp].1*. if a tss allows a stratification , then it is positive after reduction .    *",
    "definition [ sosp].10 ( process graph)*. a process ( graph ) @xmath109 is an lts in which one state @xmath45 is elected to be the root . if the lts contains a transition @xmath110 , then @xmath111 where @xmath112 has root state @xmath113 . moreover , if the lts contains a transition @xmath114 , then @xmath115 .",
    "( 1 ) a process @xmath116 is finite if there are only finitely many sequences @xmath117 .",
    "( 2 ) a process @xmath116 is regular if there are only finitely many processes @xmath118 such that @xmath117 .    *",
    "definition [ sosp].11 ( bisimulation)*. a bisimulation relation @xmath119 is a binary relation on processes such that : ( 1 ) if @xmath120 and @xmath121 then @xmath122 with @xmath123 ; ( 2 ) if @xmath120 and @xmath122 then @xmath121 with @xmath123 ; ( 3 ) if @xmath120 and @xmath115 , then @xmath124 ; ( 4 ) if @xmath120 and @xmath124 , then @xmath115 .",
    "two processes @xmath109 and @xmath125 are bisimilar , denoted by @xmath126 , if there is a bisimulation relation @xmath119 such that @xmath120 .",
    "* definition [ sosp].12 ( congruence)*. let @xmath16 be a signature . an equivalence relation @xmath119 on @xmath26 is a congruence if for each @xmath127 , if @xmath128 for @xmath129 , then @xmath130 .    *",
    "definition [ sosp].13 ( panth format)*. a transition rule @xmath69 is in panth format if it satisfies the following three restrictions : ( 1 ) for each positive premise @xmath131 of @xmath69 , the right - hand side @xmath107 is single variable ; ( 2 ) the source of @xmath69 contains no more than one function symbol ; ( 3 ) there are no multiple occurrences of the same variable at the right - hand sides of positive premises and in the source of @xmath69 .",
    "a tss is said to be in panth format if it consists of panth rules only .",
    "* theorem [ sosp].2*. if a tss is positive after reduction and in panth format , then the bisimulation equivalence that it induces is a congruence .    *",
    "definition [ sosp].14 ( branching bisimulation)*. a branching bisimulation relation @xmath119 is a binary relation on the collection of processes such that : ( 1 ) if @xmath120 and @xmath121 then either @xmath132 and @xmath133 or there is a sequence of ( zero or more ) @xmath11-transitions @xmath134 such that @xmath135 and @xmath136 with @xmath123 ; ( 2 ) if @xmath120 and @xmath122 then either @xmath132 and @xmath137 or there is a sequence of ( zero or more ) @xmath11-transitions @xmath138 such that @xmath139 and @xmath140 with @xmath123 ; ( 3 ) if @xmath120 and @xmath115 , then there is a sequence of ( zero or more ) @xmath11-transitions @xmath134 such that @xmath135 and @xmath141 ; ( 4 ) if @xmath120 and @xmath124 , then there is a sequence of ( zero or more ) @xmath11-transitions @xmath138 such that @xmath139 and @xmath142 . two processes @xmath109 and @xmath125 are branching bisimilar , denoted by @xmath143 , if there is a branching bisimulation relation @xmath119 such that @xmath120 .",
    "* definition [ sosp].15 ( rooted branching bisimulation)*. a rooted branching bisimulation relation @xmath119 is a binary relation on processes such that : ( 1 ) if @xmath120 and @xmath121 then @xmath122 with @xmath144 ; ( 2 ) if @xmath120 and @xmath122 then @xmath121 with @xmath144 ; ( 3 ) if @xmath120 and @xmath115 , then @xmath124 ; ( 4 ) if @xmath120 and @xmath124 , then @xmath115 .",
    "two processes @xmath109 and @xmath125 are rooted branching bisimilar , denoted by @xmath145 , if there is a rooted branching bisimulation relation @xmath119 such that @xmath120 .    *",
    "definition [ sosp].16 ( lookahead)*. a transition rule contains lookahead if a variable occurs at the left - hand side of a premise and at the right - hand side of a premise of this rule .",
    "* definition [ sosp].17 ( patience rule)*. a patience rule for the i - th argument of a function symbol @xmath18 is a panth rule of the form    @xmath146    * definition [ sosp].18 ( rbb cool format)*. a tss @xmath76 is in rbb cool format if the following requirements are fulfilled .",
    "( 1 ) @xmath76 consists of panth rules that do not contain lookahead . ( 2 ) suppose a function symbol @xmath18 occurs at the right - hand side the conclusion of some transition rule in @xmath76 .",
    "let @xmath147 be a non - patience rule with source @xmath148 .",
    "then for @xmath129 , @xmath149 occurs in no more than one premise of @xmath69 , where this premise is of the form @xmath150 or @xmath151 with @xmath152 .",
    "moreover , if there is such a premise in @xmath69 , then there is a patience rule for the i - th argument of @xmath18 in @xmath76 .",
    "* theorem [ sosp].3*. if a tss is positive after reduction and in rbb cool format , then the rooted branching bisimulation equivalence that it induces is a congruence .    *",
    "definition [ sosp].19 ( conservative extension)*.",
    "let @xmath153 and @xmath154 be tsss over signatures @xmath155 and @xmath156 , respectively .",
    "the tss @xmath157 is a conservative extension of @xmath153 if the ltss generated by @xmath153 and @xmath157 contain exactly the same transitions @xmath72 and @xmath73 with @xmath158 .    *",
    "definition [ sosp].20 ( source - dependency)*. the source - dependent variables in a transition rule of @xmath69 are defined inductively as follows : ( 1 ) all variables in the source of @xmath69 are source - dependent ; ( 2 ) if @xmath72 is a premise of @xmath69 and all variables in @xmath46 are source - dependent , then all variables in @xmath107 are source - dependent .",
    "a transition rule is source - dependent if all its variables are .",
    "a tss is source - dependent if all its rules are .    *",
    "definition [ sosp].21 ( freshness)*. let @xmath153 and @xmath154 be tsss over signatures @xmath155 and @xmath156 , respectively . a term in @xmath159",
    "is said to be fresh if it contains a function symbol from @xmath160 .",
    "similarly , a transition label or predicate symbol in @xmath154 is fresh if it does not occur in @xmath153 .    * theorem [ sosp].4*. let @xmath153 and @xmath154 be tsss over signatures @xmath155 and @xmath156 , respectively , where @xmath153 and @xmath157 are positive after reduction . under the following conditions , @xmath157 is a conservative extension of @xmath153 .",
    "( 1 ) @xmath153 is source - dependent . ( 2 ) for each @xmath161 , either the source of @xmath69 is fresh , or @xmath69 has a premise of the form @xmath72 or @xmath73 , where @xmath162 , all variables in @xmath46 occur in the source of @xmath69 and @xmath107 , @xmath15 or @xmath67 is fresh .",
    "acp@xcite is a kind of process algebra which focuses on the specification and manipulation of process terms by use of a collection of operator symbols . in acp",
    ", there are several kind of operator symbols , such as basic operators to build finite processes ( called bpa ) , communication operators to express concurrency ( called pap ) , deadlock constants and encapsulation enable us to force actions into communications ( called acp ) , linear recursion to capture infinite behaviors ( called acp with linear recursion ) , the special constant silent step and abstraction operator ( called @xmath163 with guarded linear recursion ) allows us to abstract away from internal computations .",
    "bisimulation or rooted branching bisimulation based structural operational semantics is used to formally provide each process term used the above operators and constants with a process graph .",
    "the axiomatization of acp ( according the above classification of acp , the axiomatizations are @xmath164 , @xmath165 , @xmath166 , @xmath166 + rdp ( recursive definition principle ) + rsp ( recursive specification principle ) , @xmath167 + rdp + rsp + cfar ( cluster fair abstraction rule ) respectively ) imposes an equation logic on process terms , so two process terms can be equated if and only if their process graphs are equivalent under the semantic model .",
    "acp can be used to formally reason about the behaviors , such as processes executed sequentially and concurrently by use of its basic operator , communication mechanism , and recursion , desired external behaviors by its abstraction mechanism , and so on .",
    "acp can be extended with fresh operators to express more properties of the specification for system behaviors .",
    "these extensions are required both the equational logic and the structural operational semantics to be extended .",
    "then the extension can be done based on acp , such as its concurrency , recursion , abstraction , etc .",
    "the process graph of the submittingorder example is illustrated in fig .",
    "[ submittingorder]-b . since acp",
    "does not distinguish the choice decision made by outside agent or inner states , the process of the submittingorder example can be expressed by the following process term in acp .",
    "@xmath168 .",
    "the process graph of the transaction example is illustrated in fig .",
    "[ transaction]-b .",
    "the process of the transaction example can be expressed by the following process term in acp .",
    "@xmath169 .",
    "the process graph of the purchasing composite web service is illustrated in fig .",
    "[ purchasing3 ] .",
    "the process of the purchasing composite web service can be expressed by the following process term in acp .",
    "@xmath170 .          in the above application scenarios , one agent interacts with other autonomous agents or human beings . in the agent s viewpoint ,",
    "some branch decisions are made by outside agents or human beings , but not the inner states .",
    "in this situation , a two person game is suitable to model the interaction . in the game ,",
    "the agent is modeled as the player ( denoted as p ) and the other agent or the human being is modeled as the opponent ( denoted as o ) .",
    "corresponding to a process graph , there exists a game tree , for example , the game tree corresponding to process graph in fig .",
    "[ purchasing3 ] is illustrated in fig .",
    "[ purchasinggametree ] .",
    "we define move and strategy as follows .",
    "* definition [ games].1 ( move ) * every execution of an action @xmath15 in the process graph causes a move @xmath15 in the corresponding game tree .",
    "and we do not distinguish the action @xmath15 and the move @xmath15 .",
    "* definition [ games].2 ( p strategy ) * a strategy @xmath171 of p in a game tree is a subtree defined as follows :    1 .   the empty move @xmath172 ; 2 .   if the move @xmath173 is a p move , then exactly one child move @xmath174 of @xmath175 and @xmath176 ; 3 .",
    "if the move @xmath173 is an o move , then all children @xmath177 of @xmath175 are in @xmath171 , that is @xmath178 .    since p and o are relative , the strategy @xmath179 of o can be defined similarly .",
    "* definition [ games].3 ( o strategy ) * a strategy @xmath179 of o in a game tree is a subtree define as follows :    1 .   the empty move @xmath180 ; 2 .   if the move @xmath181 is a o move , then exactly one child move @xmath174 of @xmath175 and @xmath182 ; 3 .   if the move @xmath181 is an p move , then all children @xmath177 of @xmath175 are in @xmath179 , that is @xmath183 .    in the game tree illustrated in fig .",
    "[ purchasinggametree ] of purchasing example , there are two choice decisions .",
    "one is made by the user agent ( or the user ) , and the other is made by the composite service . in this game , we model the composite service as p and the user agent ( or the user ) as o.    a strategy of p is illustrated as fig .",
    "[ purchasingplayer ] shows . and a strategy of o is as fig .",
    "[ purchasingopponent ] illustrates .",
    "we can see that the actual execution a game tree are acted together by the p and the o. for a p strategy @xmath171 and an o strategy @xmath179 of a game tree , @xmath184 has the form @xmath185 according to the definition of strategy .",
    "we can get that the maximal element @xmath186 of @xmath184 exactly defines an execution of the game tree .    for the p strategy @xmath171 illustrated in fig .",
    "[ purchasingplayer ] and o strategy @xmath179 illustrated in fig .",
    "[ purchasingopponent ] , the maximal element @xmath187 of @xmath184 defines an execution of the process as illustrated in process graph fig .",
    "[ purchasing3 ] .",
    "this is shown in fig .",
    "[ execution ] .",
    "gamebpa is based on bpa . in bpa , there are two basic operators called alternative composition @xmath188 and sequential composition @xmath189 .",
    "we give the transition rules for bpa as follows .",
    "@xmath190    @xmath191    @xmath192    @xmath193    @xmath194    @xmath195    @xmath196    the axioms of bpa are in table [ axiomofbpa ] .",
    ".axioms of bpa [ cols= \" < , < \" , ]     the axioms dl1-dl2 are presented for the deadlock constant @xmath12 , and the axioms po1-po14 are for the playing operator @xmath0 .",
    "there are not axioms for the association of the deadlock constant @xmath12 and the playing operator @xmath0 , just because the function of the playing operator @xmath0 is eliminating all non - deterministic factors .",
    "* theorem 7 * @xmath197 + dl1-dl2 + po1-po14 is sound for gamebpa with playing operator and deadlock constant modulo bisimulation equivalence .",
    "since bisimulation is both an equivalence and a congruence , we only need to check that the first clause in the definition of the relation @xmath33 is sound .",
    "that is , if @xmath31 is an axiom in gamebpa and @xmath27 is a closed substitution that maps the variables in @xmath45 and @xmath46 to process terms , then we need to check that @xmath198 .",
    "we only provide some intuition for soundness of the axioms in table [ axiomofpo ] .    1 .",
    "the axiom dl1 says that @xmath12 displays no behavior , so the process term @xmath199 is equal to the process term @xmath46 .",
    "the axioms dl2 , po3 and po4 say that @xmath12 blocks the behavior of the process term @xmath200 , @xmath201 and @xmath202 .",
    "the axioms po1 and po2 say that the co - action of two same actions will lead to the only action , otherwise , it will cause a deadlock .",
    "the axioms po5-po10 say that @xmath203 makes as initial transition a playing of initial transitions from @xmath45 and @xmath46 .",
    "if the execution sequence of @xmath45 is not matched with that of @xmath46 , a deadlock will be caused .",
    "the axioms po11-po12 say that the function of playing operator makes two non - deterministic gamebpa processes deterministic .",
    "the axioms po13-po14 say that the playing operator satisfies right and left distributivity to the operator @xmath188 .",
    "these intuitions can be made rigorous by means of explicit bisimulation relations between the left- and right - hand sides of closed instantiations of the axioms in table [ axiomofpo ] .",
    "hence , all such instantiations are sound modulo bisimulation equivalence .    * theorem 8 * @xmath197 + dl1-dl2 + po1-po14 is complete for gamebpa with playing operator and deadlock constant modulo bisimulation equivalence .    the proof is based on the proof of the theorem 4 .",
    "the proof consists of three main step : ( 1 ) we will show that the axioms dl1 , dl2 and po1-po14 can be turned in to rewrite rules ( see section [ elp ] ) , and the resulting trs is terminating ( see section [ elp ] ) ; ( 2 ) we will show that norm forms ( see section [ elp ] ) do not contain occurrences of the fresh opponent s alternative composition operator @xmath0 ; ( 3 ) we will prove that @xmath197 + dl1-dl2 + po1-po14 is complete for gamebpa with playing operator and deadlock constant modulo bisimulation equivalence .",
    "\\(1 ) the axioms dl1-dl2 + po1-po14 is turned into rewriting rules directly from left to right , and added to the rewriting rules in the proof the completeness of @xmath197 ( see proof of theorem 4 ) .",
    "the resulting trs is terminating modulo ac ( associativity and commutativity ) of @xmath188 operator through defining new weight functions on process terms .",
    "@xmath204    @xmath205    @xmath206    @xmath207    we can get that each application of a rewriting rule strictly decreases the weight of a process term , and that moreover process terms that are equivalent modulo ac of + have the same weight . hence , the trs is terminating modulo ac of @xmath188 .",
    "( 2)we will show that the normal form @xmath208 are not of the form @xmath203 .",
    "the proof is based on induction with respect to the size of the normal form @xmath208 .    *",
    "if n is an atomic action , then it does not contain @xmath0 . *",
    "suppose @xmath209 or @xmath210 .",
    "then by induction , the normal forms @xmath45 and @xmath46 do not contain @xmath0 , so @xmath208 does not contain @xmath0 .",
    "* suppose @xmath211 . by induction",
    ", the normal form @xmath45 does not contain @xmath0 .",
    "we distinguish the possible forms of the normal form @xmath45 : * * if @xmath212 , then the directed version of po1 , po2 , po5 or po6 apply to @xmath213 ; * * if @xmath214 , then the directed version of po7-po10 apply to @xmath203 ; * * if @xmath215 , then the directed version of po13 applies to @xmath213 ; * * if @xmath216 , then the directed version of po11 applies to @xmath213 .",
    "( actually , we already prove that @xmath217 can not occur in the norm forms , see the proof of theorem 4 ) .",
    "+ these four cases , which cover the possible forms of the normal form @xmath45 , contradict the fact that @xmath208 is a normal form .",
    "similarly , we can induce the possible forms of the normal form @xmath46 .",
    "so , we conclude that @xmath208 can not be of the form @xmath203 .",
    "we proved that normal forms are all basic process terms .",
    "( 3)we proceed to prove that the axiomatization @xmath197 + dl1-dl2 + po1-po14 is complete for gamebpa with playing operator and deadlock constant modulo bisimulation equivalence .",
    "let the process terms @xmath45 and @xmath46 be bisimilar .",
    "the trs is terminating modulo ac of the @xmath188 , so it reduces @xmath45 and @xmath46 to normal forms @xmath208 and @xmath218 , respectively . since the rewrite rules and equivalence modulo ac of the + can be derived from @xmath197 + dl1-dl2 + po1-po14 , @xmath219 and @xmath220 .",
    "soundness of @xmath197 + dl1-dl2 + po1-po14 then yields @xmath221 and @xmath222 , so @xmath223 .",
    "we shown that the normal forms @xmath208 and @xmath218 are basic process terms .",
    "then it follows that @xmath224 implies @xmath225 .",
    "hence , @xmath226 .",
    "gamebpa extends to process algebra bpa and does not use the full outcomes of acp , such as concurrency , recursion , abstraction , etc .",
    "now , we make gamebpa be based on the full acp ( exactly @xmath227 with guarded linear recursion ) and this extension is called gameacp .",
    "gameacp remains the opponent s alternative composition operator @xmath217 , the playing operator @xmath0 . because the deadlock constant",
    "is already existing in acp , we remove the duplicate definition of deadlock constant in gameacp .",
    "the transition rules of the opponent s alternative composition operator @xmath217 and the playing operator @xmath0 are the same as those in gamebpa . through defining @xmath228 , we extend @xmath8 to @xmath229",
    ".    we can get the following two conclusions .",
    "* theorem 9 * gameacp ( exactly @xmath227 with guarded linear recursion , opponent s alternative composition operator @xmath217 , playing operator @xmath0 is a conservative extension of acp ( exactly @xmath227 with guarded linear recursion ) ( see section [ acpp ] ) .",
    "the sources of transition rules of opponent s alternative composition operator @xmath217 and playing operator @xmath0 contain one fresh function symbol @xmath217 and @xmath0 . and",
    "it is known that the transition rules of @xmath227 with guarded linear recursion are source - dependent .",
    "according to the definition of conservative extension ( see section [ sosp ] ) , gameacp is a conservative extension of @xmath227 with guarded linear recursion .",
    "* theorem 10 * rooted branching bisimulation equivalence is a congruence with respect to gameacp ( exactly @xmath227 with guarded linear recursion , opponent s alternative composition operator @xmath217 , playing operator @xmath0 .",
    "we introduce successful termination predicate @xmath230 .",
    "a transition rule @xmath231 is added into transition rules of gameacp . replacing transition rules occurring @xmath14 by @xmath232 , the result transition rules of gameacp are in rbb cool format according to the definition of rbb cool format .",
    "so rooted branching bisimulation equivalence is a congruence with respect to gameacp according to the definition of congruence ( see section [ sosp ] ) .    because of the remove of the deadlock constant in gameacp",
    ", the axiomatization @xmath233 of gameacp ( exactly @xmath227 with guarded linear recursion , opponent s alternative composition operator @xmath217 , playing operator @xmath0 ) only contains @xmath167 + rdp , rsp , cfar and oa1 , po1-po14 .",
    "now , we get the following two conclusions",
    ".    * theorem 11 * @xmath233 ( @xmath167 + rdp , rsp , cfar + oa1 + po1-po14 ) is sound for gameacp ( exactly @xmath227 with guarded linear recursion , opponent s alternative composition operator @xmath217 , playing operator @xmath0 ) modulo rooted branching bisimulation equivalence .",
    "because rooted branching bisimulation is both an equivalence and a congruence , we only need to check that if @xmath35 is an axiom and a closed substitution @xmath27 replacing the variables in @xmath46 and @xmath59 to get @xmath28 and @xmath234 , then @xmath235 .",
    "we only provide some intuition for soundness of the axioms ao1 , po1-po14 .    1",
    ".   the axiom oa1 says a gamebpa process term @xmath236 is the same as the process term @xmath237 in the view of o. 2 .",
    "the axioms po3 and po4 say that @xmath12 blocks the behavior of the process term @xmath200 , @xmath201 and @xmath202 .",
    "the axioms po1 and po2 say that the co - action of two same actions will lead to the only action , otherwise , it will cause a deadlock .",
    "the axioms po5-po10 say that @xmath203 makes as initial transition a playing of initial transitions from @xmath45 and @xmath46 .",
    "if the execution sequence of @xmath45 is not matched with that of @xmath46 , a deadlock will be caused .",
    "the axioms po11-po12 say that the function of playing operator makes two non - deterministic gamebpa processes deterministic .",
    "the axioms po13-po14 say that the playing operator satisfies right and left distributivity to the operator @xmath188 .",
    "these intuitions can be made rigorous by means of explicit rooted branching bisimulation relations between the left- and right - hand sides of closed instantiations of the axioms in table [ axiomofpo ] .",
    "hence , all such instantiations are sound modulo rooted branching bisimulation equivalence .",
    "* theorem 12 * @xmath233 ( @xmath167 + rdp , rsp , cfar + oa1 + po1-po14 ) is complete for gameacp ( exactly @xmath227 with guarded linear recursion , opponent s alternative composition operator @xmath217 , playing operator @xmath0 ) modulo rooted branching bisimulation equivalence .    we need to prove that each process term @xmath46 in gameacp is equal to a process term @xmath238 with a guarded linear recursive specification @xmath239 .",
    "that is , if @xmath240 for guarded linear recursive specifications @xmath241 and @xmath242 , then @xmath243 can be gotten from @xmath233 .",
    "this proof is based on the completeness proof@xcite of @xmath167 + rdp , rsp , cfar .",
    "we apply structural induction the size of process term @xmath46 .",
    "the new case is @xmath244 .",
    "first assuming @xmath245 with a guarded linear recursive specification @xmath239 and @xmath246 with a guarded linear recursive specification @xmath247 , we prove the case of @xmath248 .",
    "let @xmath239 consists of guarded linear recursive equations    @xmath249 for @xmath250 .",
    "let @xmath247 consists of guarded linear recursive equations    @xmath251 for @xmath252 .",
    "@xmath253    then we can use the axioms po1-po10 into the above equation .",
    "this will lead to several cases and we do not enumerate all these cases .",
    "but , we can see that every case will lead to a guarded linear recursive specification .",
    "* theorem 13 * if @xmath171 is a p strategy and @xmath179 is an o strategy as illustrated in section [ games ] , and if the gameacp process term @xmath45 corresponds to @xmath171 and the gameacp process term @xmath46 corresponds to @xmath179 , then the process term @xmath213 exactly defines an execution of @xmath171 and @xmath179 .",
    "we will show that @xmath203 exactly results in the maximal element of @xmath184 .",
    "the axioms po11 , po12 make non - deterministic gameacp processes deterministic .",
    "the axioms po13 , po14 inspect all deterministic branches .",
    "the axioms dl2 , po2 , po3 , po4 , po6 , po8 , po10 assure that the mismatched execution sequence will cause a deadlock .",
    "the axiom dl1 eliminates the deadlock branches in a gameacp process .",
    "the axioms po1 , po5 , po7 and po9 assure occurrence of the matched execution sequence of two gameacp processes .",
    "the axioms po5 , po7 assure the selection the maximal execution sequence .",
    "we illustrate the correctness theorem through three examples in section [ as ] .    for the p strategy@xmath171 corresponding to the gameacp process term @xmath254 and the o strategy corresponding to the gameacp process term @xmath255 in fig .",
    "[ submittingorder ] , the maximal element @xmath255 of @xmath184 defines an execution of process graph fig .",
    "[ submittingorder]-b .",
    "@xmath256    for the p strategy @xmath171 corresponding to the gameacp process term @xmath257 and the o strategy corresponding to the gameacp process term @xmath258 in fig .",
    "[ transaction ] , the maximal element @xmath258 of @xmath184 defines an execution of the process as illustrated in process graph fig .",
    "[ transaction]-b .",
    "@xmath259    for the p strategy @xmath171 corresponding to the gameacp process term @xmath260 in fig .",
    "[ purchasingplayer ] and the o strategy corresponding to the gameacp process term @xmath261 in fig .",
    "[ purchasingopponent ] , the maximal element @xmath187 of @xmath184 defines an execution of the process as illustrated in fig .",
    "[ execution ] .",
    "in fact , the axioms in table [ axiomofoac ] and table [ axiomofpo ] can be naturally used in multi - person games without any alternation . for a three - person games ,",
    "let @xmath46 be a gameacp process term corresponding to a strategy of the first player , @xmath45 a gameacp process term corresponding to a strategy of the second player and @xmath59 a gameacp process term corresponding to a strategy of the third player .",
    "the process term @xmath263 can be deduced to an execution of these strategies by use of the above axioms .",
    "we show this situation in the section .",
    "the process graph of the extended purchasing composite web service is illustrated in fig .",
    "[ purchasing21 ] .",
    "the process of the purchasing composite web service can be expressed by the following process term in acp .",
    "@xmath264 .        the game tree to process graph in fig .",
    "[ purchasing21 ] is illustrated in fig .",
    "[ purchasinggametree2 ] .        in the game tree illustrated in fig .",
    "[ purchasinggametree2 ] of the extended purchasing example , there are three choice decisions .",
    "the first is made by the user agent ( or the user ) , and the second is made by the composite service , and the third is made by the air corporation . in this game , we model the user agent as player 1 , the composite service as player 2 and the air corporation as player 3 .    a strategy of player 1",
    "is illustrated as fig .",
    "[ purchasingplayer1 ] shows . and a strategy of player 2 is as fig .",
    "[ purchasingplayer2 ] illustrates . and",
    "[ purchasingplayer3 ] shows a strategy of player 3 .",
    "we can see that the actual execution a game tree are acted together by all players . for a strategy @xmath265 ,",
    "a strategy @xmath266 and a strategy @xmath267 of a game tree , @xmath268 has the form @xmath269 according to the definition of strategy .",
    "we can get that the maximal element @xmath186 of @xmath268 exactly defines an execution of the game tree .    for the strategy @xmath265 illustrated in fig .",
    "[ purchasingplayer1 ] , the strategy @xmath266 illustrated in fig .",
    "[ purchasingplayer2 ] , and the strategy @xmath267 illustrated in fig .",
    "[ purchasingplayer3 ] the maximal element @xmath270 of @xmath268 defines an execution of the process as illustrated in process graph fig .",
    "[ purchasing2 ] .",
    "this is shown in fig .",
    "[ execution2 ] .        in extended purchasing example , in the view of the player 1",
    ", the process can be expressed by the following process term in gameacp .",
    "@xmath271 .",
    "so the subtrees corresponding to term @xmath272 , @xmath273 and @xmath274 are all strategies of the player 1 .    in the view of the player 2",
    ", the process can be expressed by the following process term in gameacp .",
    "@xmath275 .",
    "so the subtrees corresponding to term @xmath276 and @xmath277 are all strategies of the player 2 .    in the view of the player 3",
    ", the process can be expressed by the following process term in gameacp .",
    "@xmath278 .",
    "so the subtrees corresponding to term @xmath279 and @xmath280 are all strategies of the player 3 .",
    "if @xmath265 is a strategy of the player 1 , @xmath266 is a strategy of player 2 and @xmath267 is a strategy of player 3 as illustrated in section [ games ] , and if the gameacp process term @xmath45 corresponds to @xmath265 , the gameacp process term @xmath46 corresponds to @xmath266 and the gameacp process term @xmath281 corresponds to @xmath267 , then the process term @xmath282 exactly defines an execution of @xmath265 , @xmath266 and @xmath267 .    for the strategy @xmath265 corresponding to the gameacp process term @xmath274 in fig.[purchasingplayer1 ] , the strategy @xmath266 corresponding to the gameacp process term @xmath277 in fig.[purchasingplayer2 ] , and the strategy @xmath267 corresponding to the gameacp process term @xmath280 in fig.[purchasingplayer3 ] , the maximal element @xmath270 of @xmath184 defines an execution of the process as illustrated in fig.[execution2 ] .    @xmath283",
    "in order to describe game theory and external choice in acp , we do extension of acp with an opponent s alternative composition operator @xmath217 which is called gameacp . to model the playing process of games , an extension of gameacp with a playing operator @xmath0 and a deadlock constant @xmath12 is also made . and two sound and complete axiomatic system are designed . as a result of axiomatization",
    ", gameacp has several advantages , for example , it has both a proof theory and also a semantics model , it is without any assumptions and restrictions and it can be used in multi - person games naturally .",
    "gameacp can be used to reason about the behaviors of parallel and distributed systems with game theory supported . and",
    "also , gameacp gives games an axiomatization interpretation naturally , this will help people to capture the nature of games .    it must be explained that any computable process can be represented by a process term in acp ( exactly @xmath227 with guarded linear recursion ) @xcite . that is , acp may have the same expressive power as turing machine .",
    "although gameacp can not improve the expressive power of acp , it still provides an elegant and convenient way to model game theory in acp .    as @xcite pointed out",
    ", the combination of computation tools and game theory , not only includes using computation tools to interpret games or introducing games into the computation tools , but also includes using game theory to give computation concepts an interpretation .",
    "the second one remains an open problem and is a future work we would do .",
    "lam94 j. c. c. mckinsey : _ introduction to the theory of games . _ dover publications , 2003 . j. c. m. baeten : _ a brief history of process algebra _ theor comput sci in process algebra , 2005 , 335(2 - 3 ) : 131146 .",
    "luca aceto and kim g. larsen and anna inglfsdttir : _ an introduction to milner s ccs .",
    "_ http://www.cs.auc.dk/  luca / sv / intro2ccs.pdf , 2004 . c. a. r. hoare : _ communicating sequential processes . _",
    "http://www.usingcsp.com , 1985 .",
    "w. fokkink : _ introduction to process algebra 2nd ed .",
    "_ springer - verlag , 2007 .",
    "g. d. plotkin : _ a structural approach to operational semantics .",
    "_ aarhus university , 1981 , tech .",
    "report daimifn-19 .",
    "s. abramsky and r. jagadeesan and p. malacaria : _ full abstraction for pcf ( extended abstract ) .",
    "_ proc theoretical aspects of computer software 1994 , 1994 : 115 .",
    "h. nickau : _ hereditarily sequential functionals .",
    "_ proc the symposium on logical foundations of computer science , 1994 . s. abramsky and g. mccusker : _ game semantics .",
    "_ computational logic 1999 , 1999 .",
    "s. abramsky and r. jagadeesan : _ games and full completeness for multiplicative linear logic . _ j. symbolic logic , 1994 , 59(2 ) : 543 - 574 .",
    "s. abramsky and c. mccusker : _ linearity , sharing , and state : a fully abstract game semantics for idealized algol with active expressions .",
    "_ electronic notes in theoretical computer science , 1996 , 3(2 ) : 214 .",
    "s. abramsky and k. honda and g. mccusker : _ fully abstract game semantics for general reference .",
    "_ proc ieee symposium on logic in computer science , 1998 .",
    "a. mellis : _ innocence in 2-dimensional games .",
    "_ http://www.pps.jussieu.fr/@xmath284mellies/papers.html , 2002 .",
    "a. mellis : _ asynchronous game 1 : uniformity by group invariance .",
    "_ http://www.pps.jussieu.fr/@xmath284mellies/papers.html , 2003 .",
    "a. mellis : _ asynchronous game 2 : the true concurrency of innocence .",
    "_ proc concur 2004 , 2004 .",
    "a. mellis : _ asynchronous game 3 : an innocent model of linear logic .",
    "_ electronic notes in theoretical computer science , 2005 .",
    "a. mellis : _ asynchronous game 4 : a fully complete model of propositional linear logic",
    ". _ proc 20th annual ieee symposium on logic in computer science , 2005 : 386395 .",
    "p. a. mellis and s. mimram : _ asynchronous games : innocence without alternation .",
    "_ proc concur 2007 , 2007 .",
    "s. abramsky : _",
    "sequentiality vs. concurrency in games and logic .",
    "_ mathematical structures in computer science , 2003 , 13(04 ) : 531565 .",
    "s. abramsky and p. a. mellis : _ concurrent games and full completeness . _",
    "proc the fourteenth annual ieee symposium on logic in computer science , 1999 .",
    "s. abramsky : _ algorithmic game semantics : a tutorial introduction .",
    "_ proc marktoberdorf , 2001 . s. abramsky : _ semantics of interaction .",
    "_ proc the 21st international colloquium on trees in algebra and programming , 1996 : 130 . s. abramsky and d. ghica and a. murawski : _ applying game semantics to compositional software modeling and verifications .",
    "_ proc tacas , 2004 : 421435 .",
    "a. dimovski and r. lazi : _ compositional software verification based on game semantics and process algebra .",
    "j. softw tools technol transfer , 2007 , 9 : 3751 .",
    "h. davulcu : _ a game logic for workflows of non - cooperative services .",
    "_ state university of new york , 2002 .",
    "k. chatzikokolakis and s. knight and c. palamidessi and p. panangaden : _ epistemic strategies and games on concurrent processes .",
    "acm trans .",
    "computational logic , 2012 , 13(4 ) : 140 .",
    "oasis : _ web services business process execution language version 2.0 .",
    "_ oasis , 2007 .",
    "j. c. m. baeten and j. a. bergstra and j. w. klop : _ on the consistency of koomen s fair abstraction rule .",
    "_ theoretical computer science , 1987 , 51(1/2 ) : 129176 .",
    "d.e . knuth and p.b .",
    "bendix . : _",
    "simple word problems in universal algebras .",
    "_ computational problems in abstract algebra , pergamon press , 1970 , 263297 ."
  ],
  "abstract_text": [
    "<S> using formal tools in computer science to describe games is an interesting problem . </S>",
    "<S> we give games , exactly two person games , an axiomatic foundation based on the process algebra acp ( algebra of communicating process ) . a fresh operator called opponent s alternative composition operator ( oa ) is introduced into acp to describe game trees and game strategies , called gameacp . and </S>",
    "<S> its sound and complete axiomatic system is naturally established . to model the outcomes of games ( the co - action of the player and the opponent ) , correspondingly in gameacp </S>",
    "<S> , the execution of gameacp processes , another operator called playing operator ( po ) is extended into gameacp . </S>",
    "<S> we also establish a sound and complete axiomatic system for po . finally , we give the correctness theorem between the outcomes of games and the deductions of gameacp processes .    </S>",
    "<S> [ firstpage ]    games ; process algebra ; algebra of communicating processes ; axiomatization </S>"
  ]
}