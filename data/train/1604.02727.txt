{
  "article_text": [
    "one of the objectives of systems control is _ performance regulation _ , namely the output tracking of a given setpoint reference despite modeling uncertainties , time - varying system s characteristics , noise , and other unpredictable factors having the effects of system - disturbances .",
    "a commonly - practiced way to achieve tracking is by a feedback control law that includes an integrator .",
    "an integral control alone may have destabilizing effects on the closed - loop system , and hence the controller often includes proportional and derivative elements as well thereby comprising the well - known pid control @xcite .",
    "recently there has been a growing interest in performance regulation of event - driven systems , including discrete event dynamic systems ( deds ) and hybrid systems ( hs ) , and a control technique has been proposed which leverages on the special structure of discrete - event dynamics @xcite .",
    "the controller consists of a standalone integrator with an adaptive gain , adjusted in real time as part of the control law .",
    "the rule for changing the gain is designed for stabilizing the closed - loop system as well as for simplicity of implementation and robustness to computational and measurement errors .",
    "therefore it obviates the need for proportional and derivative elements , and can be implemented in real - time environments by approximating complicated computations by simpler ones . in other words ,",
    "the balance between precision and required computing efforts can be tilted in favor of simple , possibly imprecise computations .",
    "a key feature of the control law is that it is based on the derivative of the plant function , namely the relation between the system s control parameter and its output , which is computed or estimated by infinitesimal perturbation analysis ( ipa ) .",
    "this will be explained in detail in the following paragraphs .",
    "ipa is a well - known and well - tested technique for computing sample - performance derivatives ( gradients ) in deds , hs , and other event - driven systems with respect to controlled variables ; see @xcite for extensive presentations and surveys .",
    "its salient feature is in simple rules for tracking the propagations associated with a gradient along the sample path of a system , by low - cost algorithms .",
    "however , this simplicity may come at the expense of statistical unbiasedness of the ipa derivatives . in situations",
    "where ipa is biased , alternative perturbation - analysis techniques have been proposed , but they may require far - larger computing efforts than the basic ipa ( see @xcite ) . for the performance regulation technique described in this paper , it has been shown that ipa need not be unbiased and , as mentioned earlier , its most important requirement is low computational complexity @xcite .",
    "the control system we consider is depicted in figure 1 . assuming discrete time and one - dimensional variables",
    ", @xmath0 is the setpoint reference , @xmath1 denotes the time counter , the control variable @xmath2 is the input to the plant at time @xmath3 , @xmath4 is the corresponding output , and @xmath5 is the error signal at time @xmath3 .",
    "the control law is defined by the following equation , @xmath6 and we recognize this as an adder , the discrete - time analogue of an integrator , if the gain @xmath7 is a constant that does not depend on @xmath3 .",
    "the plant is an event - driven dynamical system whose output @xmath4 is related to its input @xmath2 in a manner defined in the next paragraph , and denoted by the functional term @xmath8 where @xmath9 is a random function .",
    "its ipa derivative @xmath10 is used to define the controller s gain @xmath11 via the equation @xmath12 and the error signal is defined as @xmath13 a recursive application of eqs .",
    "( 1)-(4 ) defines the closed - loop system .    as for the plant , it can have the following form .",
    "consider a continuous - time or discrete - time dynamical system whose input is @xmath14 , and its state is @xmath15 for some @xmath16 ; the notation @xmath17 designates continuous time or discrete time .",
    "let @xmath18 be a function that is absolutely integrable over finite - length intervals .",
    "partition the time - axis @xmath19 into contiguous left - closed , right - open intervals , @xmath20 , called _ control cycles_. suppose that the input to the latter dynamical system has constant values during each interval @xmath21 , and it can be changed only at the boundary of these intervals . in the setting of the system of figure 1 , @xmath22 is the value of the input @xmath23 during @xmath21 , and @xmath4 can be either @xmath24 or @xmath25 where @xmath26 is the duration of @xmath21 .",
    "in the case of discrete time , a sum - term of the form @xmath27 replaces the integral .",
    "we do not specify how to determine the control cycles @xmath21 , and they can have an a - priori constant length , or their termination can be the result of certain events .",
    "for example , let the plant consist of an m / d/1 queue , @xmath2 is the value of the service time during @xmath28 , and @xmath4 is the time - average of the sojourn times of all jobs arriving during @xmath28 .",
    "ipa can be used to compute the derivative @xmath29 via a well - known formula @xcite .",
    "generalizing this example , suppose that the plant - system is a stochastic event - driven system ( deds or hs ) , @xmath30 is a control variable , assumed to have a constant value ( @xmath22 ) during @xmath21 , @xmath31 , is a random function of @xmath22 as indicated by eq .",
    "( 2 ) , and its derivative @xmath32 is computed by ipa . later we will be concerned with measurement and computational errors and hence modify eqs .",
    "( 2 ) and ( 3 ) accordingly .",
    "the development of the proposed regulation technique has been motivated primarily by applications to computer cores , especially regarding regulation of power and instruction - throughput by adjusting the core s clock rate ( frequency ) @xcite .",
    "concerning throughput , there are no prescriptive , let alone analytic models for the frequency - to - throughput relationship , and a complicated , intractable queueing model has had to be used for simulation . nonetheless a simple ipa algorithm has been developed and used to approximate the sample derivative for determining the integrator s gain via eq .",
    "the regulation technique was extensively tested on programs from an industry - based suite of benchmarks , splash-2 @xcite , using a detailed simulation platform for performance assessment of computer architectures , manifold @xcite .",
    "we reported the results in @xcite , and deemed them encouraging and meriting a further exploration of the regulation technique .    in the context of ipa research",
    ", this regulation technique represents two new perspectives .",
    "first , the traditional application of ipa throughout its development has been to optimization , whereas here it is applied in a new way , namely to performance regulation .",
    "second , much of the research of ipa has focused on its unbiasedness , whereas here , in contrast , the concern is with fast computation which may come at the expense of accuracy and unbiasedness .",
    "the main novelty of the paper as compared to references @xcite is in the fact that it concerns not simulation but an actual implementation . in this",
    "we were facing new challenges associated with real - time measurements , computations , and control .",
    "consequently we were unable to control each core separately as in @xcite , and hence applied the regulation method to a processor containing multiple cores .",
    "furthermore , due to issues with real - time computation , we were forced to take drastically cruder approximations to the ipa derivatives than in @xcite , and in fact it seems that we drove the degree of imprecision to the limit .",
    "how this worked on application programs will be seen in the sequel . in any event ,",
    "the work described here is , to our knowledge , the first implementation ( beyond simulation ) of ipa in a real - time control environment .",
    "the rest of the paper is structured as follows .",
    "section 2 summarizes relevant convergence results of the regulation technique in an abstract setting .",
    "section 3 describes the system under study and its model , presents simulation results on manifold followed by implementation on a state - of - the - art computer processor , and compares the two .",
    "section 4 derives some lessons from these results and proposes directions for future research .",
    "this section recounts established results concerning convergence of the regulation technique defined by recursive applications of eqs .",
    "( 1 ) to ( 4 ) , as summarized in ref .",
    "ideally convergence means that @xmath33 hence @xmath34 ( see figure 1 ) .",
    "this can be achieved under suitable assumptions ( mentioned below ) if the plant system is time invariant , and hence the function @xmath35 does not depend on @xmath36 . in that case",
    "the control loop comprised of equations ( 1)-(4 ) essentially implements newton s method for solving the equation @xmath37 , for which there are well - known sufficient conditions for convergence .",
    "these include situations where the derivative term @xmath38 in eq .",
    "( 3 ) is computed in error , for which convergence in the sense of ( 5 ) is ascertained under upper bounds on the magnitude of the error @xcite .    if the system is time varying , eq .",
    "( 5 ) may not hold true , and in this case convergence can be characterized by the equation @xmath39 where @xmath40 depends on a measure of the system s variability . to make matters concrete",
    "let @xmath41 be a differentiable function , and suppose that the term @xmath42 in eq .",
    "( 2 ) is a functional approximation of @xmath43 . assuming that @xmath44 is differentiable as well",
    ", we can view the term @xmath32 as an approximation to @xmath45 in ( 3 ) .",
    "however , for reasons that will be seen in the sequel , we add another layer of approximation to @xmath32 , denoted by @xmath46 , so that eq .",
    "( 3 ) computes the term @xmath47 . defining @xmath48 and @xmath49 , eqs .",
    "( 2 ) and ( 3 ) become @xmath50 and @xmath51 respectively .",
    "the regulation technique now is defined by recursive applications of eqs .",
    "( 1),(7),(8),(4 ) .    to analyze its convergence ,",
    "suppose first , to simplify the discussion , that there exists a closed , finite - length interval , @xmath52 , such that every point @xmath22 computed by the regulation algorithm is contained in @xmath52 ; this assumption will be removed later .",
    "moreover , @xmath52 satisfies the following assumption .",
    "\\(i ) the function @xmath53 and the functions @xmath54 are differentiable throughout @xmath52 .",
    "( ii ) the function @xmath53 is either convex or concave , and monotone increasing or decreasing throughout @xmath52 .",
    "( iii ) there exists @xmath55 such that @xmath56 .",
    "various ways to relax this assumption will be discussed shortly .",
    "the following result was proved in @xcite .",
    "_ proposition 2.3 and lemma 2.2 in @xcite _ : for every @xmath57 , @xmath58 , and @xmath59 , there exist @xmath60 , @xmath61 , and @xmath62 such that , for every interval @xmath52 satisfying assumption 1 and the following two additional conditions : ( i ) @xmath63 , and ( ii ) @xmath64 :    1 ) . if for some @xmath65 , and for @xmath66 , @xmath67 , @xmath68 , and @xmath69 , then @xmath70    2 ) .",
    "if for all @xmath71 , @xmath67 , @xmath68 , and @xmath69 , then @xmath72 @xmath73    in the context of the system considered in this paper , what we have in mind is a situation where the plant is an event - driven system controlled by a real - valued parameter @xmath74 , @xmath75 is an expected - value function defined over a finite horizon ( hence not in steady state and possibly dependent on an initial condition ) , @xmath76 is a sample - based approximation ( possibly biased ! ) of @xmath43 over the control cycle @xmath21 , and @xmath77 is a sample approximation of @xmath78 .",
    "a few remarks concerning assumption 1 are due .    1 ) .",
    "the differentiability assumption is unnecessary , convexity of @xmath75 and almost - sure differentiability of @xmath79 at a given point @xmath74 suffice .",
    "these conditions often arise in the context of ipa . under these weaker assumptions the proofs in @xcite",
    "can be carried out in the context of convex analysis rather than differentiable calculus .    2 ) .",
    "the condition that @xmath67 , @xmath36 , can be enforced in the case where @xmath52 is a constraint set for the sequence @xmath80 . in that case",
    "( 1 ) would be replaced by @xmath81 where @xmath82 is the projection of @xmath83 onto i , i.e. , the point in @xmath52 closest to @xmath84 .",
    "the proof of convergence is unchanged .",
    "often the magnitude of the error terms @xmath85 and @xmath86 can be controlled by taking longer control cycles , but there is no way to ensure the inequalities @xmath68 and @xmath69 _ for every _",
    "@xmath71 , which is stipulated as a condition for eq .",
    "practically , however , with long - enough control cycles we can expect those inequalities to hold for finite strings of @xmath87 , thus guaranteeing the validity of eq .",
    ". if these strings are long enough , equation ( 9 ) would result in @xmath88 approaching 0 at a geometric rate , then periodically jumping away due to the sporadic occurrence of larger errors , but again returning towards 0 rapidly , etc .",
    "this behavior has been observed in all of the examples where we tested the regulation technique for a variety of event - driven systems @xcite .",
    "another source of the jitters described in the previous paragraph is the time - varying nature of the system .",
    "this is particularly pronounced in the system tested in this paper , since the workload of programs processed by a core can vary widely in unpredictable ways .",
    "nonetheless we shall see that the regulation algorithm gives good results .",
    "it is possible to ascertain the assumptions underscoring the analysis in @xcite for simple systems ( e.g. , tandem queues and some marked graphs ) , but may be impossible to ascertain them for more complicated systems .",
    "for instance , it can be impossible to prove differentiability or even convexity of an expected - value function from characterizations of its sample realizations , or bounds on the errors associated with ipa .",
    "moreover , some of these assumptions , including convexity or concavity , were made in @xcite in order to enable an analysis but may not be necessary .",
    "the aforementioned convergence results serve to explain the behavior of the regulation method that was observed in all of our former experiments @xcite as well as in those described later in this paper .",
    "the system - architecture considered in this paper is based on an out - of - order ( ooo ) core technology whereby instructions may complete execution in an order different from the program order , hence the `` out of order '' designation .",
    "this enables instructions execution to be limited primarily by data dependency and not by the order in which they appear in the program .",
    "data dependency arises when an instruction requires variables that first must be computed by other instructions .",
    "a detailed description of ooo architectures can be found in @xcite , while a high - level description is contained in @xcite .",
    "here we provide an abstract functional and logical description , and refer the reader to @xcite for a more - detailed exposition .",
    "the functionality of an ooo core is depicted in figure 2 .",
    "instructions are fetched sequentially from memory and placed in the instruction queue , where they are processed by functional units , or servers in the parlance of queueing theory . the queue is assumed to have unlimited storage and there is a server associated with each buffer .",
    "the processing of an instruction starts as soon as it arrives _ and _ all of its required variables become available .",
    "the instruction departs from the queue as soon as its execution is complete _ and _ the previous instruction ( according to the program order ) departs . in the parlance of computer architectures ,",
    "an instruction is said to be _ committed _ when it departs from the queue .",
    "the instruction - throughput of the core is defined and measured by the average number of instructions committed per second .    [ !",
    "t ]     instructions generally are classified as _ computational instructions _ or _",
    "memory instructions_. access times of external , off - chip , memory instructions are one - to - two orders of magnitude longer than those of computational instructions .",
    "therefore most architectures make use of a hierarchical memory arrangement where on - chip cache access takes less time than external memory such as dram",
    ". first the cache is searched , and if the variable is found there then it is fetched and the instruction is completed .",
    "if the variable is not stored in cache ( a situation known as _ cache miss _ ) then it is fetched from external memory ( typically dram ) and placed in the cache , whence it is accessed and the instruction is completed .",
    "external memory instructions can be thought of as being placed in a finite - buffer , first - in - first - out queue , designated as the _ memory queue _ in figure 2 . when this queue becomes full , the entire memory access , including cache ,",
    "is stalled .",
    "thus , there are three causes for an instruction to be stalled : a computational or memory instruction waiting for variables computed by other instructions , a memory instruction waiting for the memory queue to become non - full , and any instruction waiting ( after processing ) for the previous instruction to depart from the queue .",
    "we point out that instructions involving computation and @xmath89 cache - access are subjected to the core s clock rate , while memory instructions involving external memory , such as dram , are not subjected to the same clock .",
    "this complicates the application of ipa and may cause it to be biased .    a quantified discrete - event model of this process",
    "is presented in the appendix , and a more general description can be found in @xcite , which also contains a detailed algorithm for the ipa derivative of the throughput as a function of frequency .",
    "we use a cycle - level , full system discrete event simulation platform for multi - core architectures , manifold .",
    "the simulated model consists of a 16-core x86 processor die , where each core is in a separate clock domain and can control its own clock rate independently of other cores . for a detailed description of the manifold simulation environment and its capabilities",
    ", please see ref .",
    "@xcite .",
    "we simulated two application programs from the benchmark - suite splash-2 , barnes and water - ns @xcite .",
    "barnes is a computation - intensive , memory - light application while water - ns is memory intensive . for each execution ,",
    "all of the 16 cores of the processor run threads of the same benchmark concurrently while each one of them is controlled separately .",
    "the control cycle is set to @xmath90 ms for both barnes and water - ns .",
    "the frequency range of the cores is set to @xmath91 $ ] .",
    "we assume a continuous frequency range for the simulations , but later will consider a realistic , discrete range for the implementation described in the sequel .",
    "the target instruction throughput is set to the same value for each core for both barnes and water - ns , and we experiment with the target throughput values of 1,200 mips ( million instructions per second ) , 1,000 mips , and 800 mips . in terms of instructions per control cycle ,",
    "these target values correspond to @xmath92 , @xmath93 , and @xmath94 , respectively .",
    "the relationship between clock frequency and instruction throughput is determined by the manifold processor model , but its ipa derivative was computed according to the high - level instruction flow described above and in the appendix . for each application",
    "run we present , in the following paragraphs , the results for one of the 16 cores chosen at random .",
    "consider first the target throughput of 1,200 mips .",
    "the throughput simulation results for the barnes benchmark are shown in figure  [ fig : mipsmanifoldbarnesco10t1200 ] , where the horizontal axis indicates time in ms and the vertical axis indicates instruction throughput .",
    "we discern a rise of the throughput from its initial value ( measured at 643.1 mips ) towards the target level of 1,200 mips , which it reaches for the first time in about 1.5 ms , or 15 control cycles .",
    "thereafter it oscillates about the target value , which is not surprising due to the unpredictable , rapidly - changing program workload .",
    "the average throughput computed over the time interval [ @xmath95,@xmath96 ( soon after the throughput has reached the target value ) is @xmath97 mips , which is 42.6 mips off the target level of 1,200 mips .",
    "figure [ fig : freqmanifoldbarnesco10target1200 ] depicts the graph of frequency vs. time ( in ms ) , and it shows some saturation at its highest level of 5.0 ghz , in the time - interval @xmath98 $ ] .",
    "saturation at the highest level can correspond to a negative offset of the average throughput from its target level , since it indicates that the system may be unable to raise the throughput to a desired level . during the period of frequency saturation indicated in figure 4 ,",
    "the throughput shown in figure 3 it more jittery and sporadically attains slightly - lower values than after time 25ms .",
    "it also shows these characteristics between the end of the saturation period and time @xmath99 .",
    "therefore , the extent of the effects of the saturation on the aforementioned offset of 46.4 mips is not clear",
    ". nonetheless we mention this point since it will be more pronounced in some of the results on which we report later . also , we computed the average throughput in the intervals @xmath100 $ ] and @xmath101 $ ] , after the jittery behavior of the throughput has somewhat subsided .",
    "the results are 1,192.6 mips and 1,192.9 mips , respectively , corresponding to offsets of 7.4 mips and 7.1 mips from the target throughput of 1,200 mips .",
    "these results suggest that the frequency saturation plays some role in the larger , 46.4-mips offset that was computed over the interval @xmath102 $ ] .    for the target throughput of 1,000 mips ,",
    "the results ( not shown due to space limitations ) showed a rise in throughput from its initial value of 420.5 mips to 1,000 mips in 2.1 ms , or 21 control cycles .",
    "the average throughput in the @xmath103 $ ] interval is 990.2 mips , corresponding to an offset of 9.8 mips of the throughput from its target value of 1,000 mips .",
    "the frequency saturated at its upper limit only at 5 isolated control cycles with minimal effects on the throughput .    for the throughput target of 800 mips ,",
    "the results show a rise in the throughput from its initial value of 679.3 mips to 800 mips in 1.9 ms , or 19 iterations .",
    "the average throughput in the interval [ 1.9ms,100ms ] was 839.6 mips , which is 39.6 mips off the target value of 800 mips .",
    "there was a considerable frequency saturation at the lowest level of 0.5 ghz , which explains the positive offset .",
    "returning to the results for the target level of 1,200 mips , we considered a way to reduce the throughput oscillations and frequency saturation by scaling down the gain in eq .",
    "we did this by replacing eq .",
    "( 1 ) by the following equation , @xmath104 for a suitably - chosen constant @xmath105 . after some experimentation on various benchmarks ( excluding those tested here ) we chose @xmath106 .",
    "the resulting frequencies did not saturate throughout the program s run , and yielded an average throughput of 1,198,5 mips , which is 1.5 mips off the target level of 1,200 mips .",
    "though working well for this example , this technique may be problematic when used with an implementation rather than simulation , as will be discussed in the next subsection .    for water - ns ,",
    "consider first the throughput target of 1,200 mips .",
    "simulation results of throughput and frequency are shown in figure  [ fig : mipsmanifoldwaternsco10target1200 ] and figure [ fig : freqmanifoldwaternsco10target1200 ] , respectively .",
    "we notice greater fluctuations and more saturation than for barnes .",
    "in particular , figure [ fig : freqmanifoldwaternsco10target1200 ] shows three distinct periods of frequency saturations at its upper limit of 5.0 ghz , and figure [ fig : mipsmanifoldwaternsco10target1200 ] shows very low throughput during these periods . to explain this , recall that water - ns is a memory - heavy program , and execution times of memory instructions are longer ( typically by one or two orders of magnitude ) than computational instructions . during those periods the instructions of water - ns mainly concern memory access , which are low - throughput instructions .",
    "the controller is applying its highest frequency in order to push the throughput to its target value , but that frequency is not high enough to have much effect .",
    "this is why the periods of high - limit frequency saturation are characterized by very low throughput .",
    "this has a pronounced affect of lowering the average frequency measured during the program s execution .",
    "in fact , the throughput obtained from the simulation rises from its initial value of 429 to its target level of 1,200 mips in about 1.8 ms , or 18 control cycles ( this rise is not evident from figure [ fig : mipsmanifoldwaternsco10target1200 ] due to its insufficient granularity ) , and the average throughout from the time the target level is reached ( @xmath107 ) to the end of the program - run ( @xmath108 ) is @xmath109 mips , which is 73.2 mips off the target level of 1,200 mips . despite this offset , we observe that as soon as the program transitions from memory mode to computational mode , as indicated by the end of the saturation periods in figure [ fig : freqmanifoldwaternsco10target1200 ] , the throughput returns quickly to about its target level , as can be seen in figure [ fig : mipsmanifoldwaternsco10target1200 ] .    for the target throughput of 1,000 mips ,",
    "simulation results show the throughput increasing from its initial value of 472.1 mips to the target level on 1,000 mips in 2.3 ms , or 23 control cycles .",
    "there is considerable frequency saturation at the high limit of 5.0 ghz .",
    "the average throughput in the interval @xmath110 $ ] is 947.8 mips , which means an offset of 52.2 mips off the target throughput .    for the target throughput of 800 mips , simulation results indicated a rise of the throughput from its initial value of 443.3 to its target level in about 2.3 ms , or 23 control cycles .",
    "there is considerable saturation of the frequency at its lower level of 0.5 ghz , and hence a positive offset between the computed average throughput and its target level .",
    "indeed , the average throughput in the interval @xmath110 $ ] is 862.6 , mips , hence meaning an offset of 62.6 mips of the throughput from its target value of 800 mips .    all of these results are summarized in table i , showing the offset ( in mips ) of average throughput from target throughput , obtained from manifold simulations of barnes and water - ns with throughput targets of 1,200 , 1,00 , and 800 mips .    returning to the throughput target of 1,200 mips , an application of the modified algorithm with @xmath106 in eq .",
    "( 12 ) yielded the average throughput of 1,143.6 mips which is 56.4 mips off the target level of 1,200 mips .",
    "this is a smaller offset than the 73.2 mips obtained from the unmodified algorithm , and it is explained by the fact that there is still considerable , though less frequency saturation than with the unmodified algorithm .    [ !",
    "t ]     [ !",
    "t ]     [ !",
    "t ]     [ ! t ]",
    ".manifold simulations : offset of average throughput from target levels [ cols=\"<,<,<,<\",options=\"header \" , ]     comparing the data summarized in table i and table ii , we that the regulation technique performs slightly better on the haswell implementation platform than on the manifold simulation environment .",
    "the reason for this may be due to the fact that in the simulation experiment we regulate the throughput of each core separately , while in the implementation we control the average throughput of all the cores in the processor .",
    "this paper describes the testing of an ipa - based throughput regulation technique in multicore processors .",
    "the testing was performed on both a simulation environment and an implementation platform . despite crude approximations that have had to be made in the implementation setting , the proposed technique performed slightly better than in the simulation setting .",
    "future research will extend the regulation method from a centralized control of a single processor to a distributed control of networked systems .",
    "this section provides a quantitative description of the instruction - flow in the ooo - cache high - level model described at the beginning of section iii .",
    "denote by @xmath111 , @xmath112 , the instructions arriving at the instruction queue in increasing order .",
    "let @xmath74 denote the clock rate , or frequency , and let @xmath113 be the clock cycle . denote by @xmath114 the arrival time of @xmath111 relative to the arrival time of @xmath115 , namely @xmath116 , and let @xmath117 be the clock counter at which @xmath111 arrives .",
    "then , @xmath118 denote by @xmath119 the time at which execution of @xmath111 starts , and let @xmath120 denote the time at which execution of @xmath111 ends .",
    "we next describe a way to compute @xmath119 .",
    "consider first the case were @xmath111 is a computational instruction .",
    "if all of its required variables are available at its arrival time then @xmath121 .",
    "on the other hand , if @xmath111 has to wait for such variables , let @xmath122 denote the index ( counter ) of the instruction last to provide such a variable , then @xmath123 .",
    "next , if @xmath111 is a memory instruction , then @xmath119 is the time it starts a cache access .",
    "if the memory queue is not full at time @xmath114 , then @xmath121 .",
    "on the other hand , if the memory queue is full at time @xmath114 , let @xmath124 denote the index of the instruction at the head of the queue , then , @xmath125 .    to compute @xmath120 , consider first the case where @xmath111 is a computational instruction .",
    "let @xmath126 denote the number of clock cycles it takes to execute @xmath111 .",
    "then , @xmath127 .",
    "on the other hand , if @xmath111 is a memory instruction , let @xmath128 denote the number of clock cycles it takes to perform a cache attempt .",
    "if the cache attempt is successful and the variable is found in cache , then @xmath129 .",
    "if the variable is not in cache , the instruction is directed to the memory queue .",
    "its transfer there involves a small number of clock cycles , @xmath130 , hence its arrives at the queue at time @xmath131 .",
    "the memory queue is a fifo queue whose service time represents an external - memory access , which is independent of the core s clock .",
    "denote by @xmath132 the sojourn time of @xmath111 at the memory queue . then @xmath133 .",
    "finally , the departure time of @xmath111 from the instruction queue , denoted by @xmath134 , is @xmath135 . given a control cycle consisting of @xmath136 instructions ,",
    "the throughput is defined as @xmath137 . since @xmath138",
    ", we can view the throughput as a function of @xmath74 and denote it by @xmath139 .",
    "its ipa derivative , @xmath140 , can be computed by following the above dynamics of the instructions flow .",
    "this , and a more detailed discussion of the model , can be found in @xcite .",
    "y. wardi , x. c. seatzu , chen , and s. yalamanchili , performance regulation of event - driven dynamical systems using infinitesimal perturbation analysis , under review in _ nonlinear analysis : hybrid systems _ , also in arxiv , ref .",
    "arxiv:1601.03799v1 [ math.oc ] , 2016 .",
    "woo , m. oharat , e. torriet , j. singhi and a. guptat , the splash-2 programs : characterization and methodological considerations , _ proceedings of the isca 22nd annual international symposium on computer architectures , ( isca95 ) _ , santa margherita ligure , italy , 1995 .    j. wang , j. beu , r. behda , t. conte , z. dong , c. kersey , m. rasquinha , g. riley , w. song , h. xiao , p. xu , and s. yalamanchili , manifold : a parallel simulation framework for multicore systems , _ proc .",
    "ieee international symposium on performance evaluation of systems and software ( ispass ) _",
    ", 2014 .",
    "x. chen , h. xiao , y. wardi , and s. yalamanchili , throughput regulation in shared memory multicore prtocessors , _ proc .",
    "22nd ieee intl .",
    "conference on high performance computing ( hipc ) _ , bengaluru , india , december 16 - 19 , 2015 .      c. seatzu , and y. wardi , performance regulation via integral control in a class of stochastic discrete event dynamic systems , _ proc .",
    "12th ifac - ieee international workshop on discrete event systems ( wodes14 ) _ , paris , france , may 14 - 16 , 2014 .        s. browne , j. dongarra , n. garner , g. ho , and p. mucci , a portable programming interface for performance evaluation on modern processors , _ the international journal of high performance computing applications _",
    ", volume 14 , number 3 , pp .",
    "189 - 204 , fall 2000 ."
  ],
  "abstract_text": [
    "<S> a new technique for performance regulation in event - driven systems , recently proposed by the authors , consists of an adaptive - gain integral control . </S>",
    "<S> the gain is adjusted in the control loop by a real - time estimation of the derivative of the plant - function with respect to the control input . </S>",
    "<S> this estimation is carried out by infinitesimal perturbation analysis ( ipa ) . </S>",
    "<S> the main motivation comes from applications to throughput regulation in computer processors , where to - date , testing and assessment of the proposed control technique has been assessed by simulation . </S>",
    "<S> the purpose of this paper is to report on its implementation on a machine , namely an intel haswell microprocessor , and compare its performance to that obtained from cycle - level , full system simulation environment . </S>",
    "<S> the intrinsic contribution of the paper to the workshop on discrete event system is in describing the process of taking an ipa - based design and simulation to a concrete implementation , thereby providing a bridge between theory and applications . </S>"
  ]
}