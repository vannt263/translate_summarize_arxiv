{
  "article_text": [
    "with the advent of initiatives like open data and new data publication paradigms as linked data  @xcite , the volume of data available as rdf  @xcite datasets in the semantic web has grown dramatically .",
    "projects such as the linking open data community ( lod ) encourage the publication of open data using the linked data principles which recommend using rdf as data publication format . by september 2010 ( last update of the lod diagram ) , more than 200 datasets were available at the lod site , which consisted of over 25 billion rdf triples .",
    "this massive amount of semi - structured , interlinked and distributed data publicly at hand , faces the database community with new challenges and opportunities : published data need to be loaded , updated , and queried efficiently .",
    "one question that immediately arises is : could traditional data management techniques be adapted to this new context , and help us deal with problems such as data integration from heterogeneous and autonomous data sources , query rewriting and optimization , control access , data security , etc . ?",
    "in particular , in this paper we address the issue of view definition mechanisms over rdf datasets .",
    "rdf datasets are formed by triples , where each triple _ ( s , p , o ) _ represents that subject _ s _ is related to object _ o _ through the property _",
    "p_. usually , triples representing schema and instance data coexist in rdf datasets ( these are denoted tbox and abox , respectively in description logics ontologies ) .",
    "a set of reserved words defined in rdf schema ( called the rdfs - vocabulary)@xcite is used to define classes , properties , and to represent hierarchical relationships between them .",
    "for example , the triple _",
    "( s , ` rdf : type ` , c ) _ explicitly states that _ s _ is an instance of _ c _ but it also implicitly states that object _",
    "c _ is an instance of ` rdf : class ` since there exists at least one resource that is an instance of _ c _ ( see section [ sec2:rdf ] for further details on rdf ) .",
    "the standard query language for rdf data is sparql@xcite , which is based on the evaluation of graph patterns ( see below for examples on sparql queries ) .",
    "although view definition mechanisms for rdf have been discussed in the literature , there is no consensus on what a view over rdf should be , and the requirements it should fulfill .",
    "moreover , although we could expect views to be useful over the web of linked data , as they have proved to be in many traditional data management application scenarios ( e.g. , data integration , query answering ) there is no evidence so far that this will be the case in the near future . in this work",
    "we discuss the usage of views in those scenarios , and study current rdf view definition mechanisms , with focus on key issues such as expressiveness , scalability , rdfs inference support and the integration of views into existent tools and platforms .",
    "the dbtune project gathers more than 14 billion triples from different music - related websites .",
    "figure  [ fig.lod ] presents a lod diagram that represents dbtune datasets ( purple nodes ) , their inter - relationships and the relationships with other lod datasets ( white nodes ) .",
    "each of the datasets included in the dbtune project has its own particularities .",
    "for instance , their structures or schemas differ from each other . this is because although dbtune datasets are described in terms of concepts and relationships defined in the music ontology ( mo ) , they do not strictly adhere to it , producing semantic and syntactic heterogeneities among them .",
    "we have selected three datasets from the dbtune project : bbc john peel sessions dataset , the jamendo website dataset and the magnatune record label dataset ( section [ sec5:datasets ] presents detailed information on this selection process , and explains the rationale behind this decision ) .",
    "information about the ` schema ' of the datasets can be extracted by means of sparql queries .",
    "figure [ fig : sourcesch ] presents a graphical representation of this information . in these graphs , light grey nodes represent classes for which at least one instance is found in the dataset ( we denote them used classes ) , dark grey nodes represent classes from the mo that are related to used classes ( either as subclasses or superclasses ) , solid arcs represent predicates between used classes , and dashed arcs represent the ` rdfs : subclassof ` predicate .",
    "predicates that relate classes with untyped uris are represented in italics .",
    "appendix [ sec : app1 ] describes how these graphs have been constructed .",
    "figure [ fig : sourcesch ] shows that there are differences between the schemas of each data source .",
    "let us consider , for example , the representation of the authoring relationship between _ musicartists _ and _ records_. in the jamendo dataset this relationship is represented using the ` foaf : made ` predicate ( figure [ fig : jamendo ] ) that connects artists with their records but also using its inverse relationship , namely the ` foaf : maker ` predicate between _ records _ and _ musicartists_. although these two relationships are the inverse of each other , no assumption can be made on the consistency of data , namely that the existence of a triple ( _ jam : artist1 foaf : made jam : record1 _ ) does not enforce the existence of another triple of the form ( _ jam : record1 foaf : maker jam : artist1 _ ) . in the magnatune dataset _ musicartists _ and",
    "_ records _ are related using the ` foaf : maker ` predicate ( figure [ fig : magnatune ] ) .",
    "we next present some use cases over the selected datasets that show how the notion of view ( in the traditional sense ) could be applied .",
    "* use case 1 : retrieving artists and their records .",
    "*    a user needs to collect information about artists and their records . to fulfill this simple requirement ,",
    "a not trivial sparql query must be written .",
    "this query must take into consideration all the different representations of the relationship between artists and records in each dataset .",
    "example [ fig.uc1select ] presents a sparql query that returns the expected answer .",
    "a sparql 1.0 ` select ` query that retrieves artists and their records .",
    "+    .... select distinct ?",
    "record from named < http://dbtune.org/jamendo > from named < http://dbtune.org/magnatune >    where {           { graph < http://dbtune.org/jamendo/ >          {   ?",
    "artist foaf : made ?",
    "record .              ?",
    "artist rdf : type mo : musicartist .                 ?",
    "record rdf : type mo : record }      } union      { graph < http://dbtune.org/jamendo/ >          { ?",
    "record foaf : maker ?",
    "artist .            ?",
    "artist rdf : type mo : musicartist .            ?",
    "record rdf : type mo : record }      } union      { graph < http://dbtune.org/magnatune/ >          { ?",
    "record foaf : maker ?",
    "artist .            ?",
    "artist rdf : type mo : musicartist .            ?",
    "record rdf : type mo : record   } } }       ....    [ fig.uc1select ]    sparql queries are too complex to be written by an end user , and require a precise knowledge of the schema . therefore , it would be desirable to somehow provide a uniform representation of this relationship in order to simplify querying the integrated information .",
    "several strategies could be used to provide a uniform view of all datasets .",
    "one possibility would be to materialize the missing triples , which in this case leads to the creation of new triples in the magnatune and jamendo datasets .",
    "( record , ` foaf : maker ` , artist ) _ triple that relates a record _ record _ with an artist _ artist _ , a new triple _ ( artist , ` foaf : made ` , record ) _ must be added to the dataset .",
    "this strategy would be hard to maintain and could also interfere with the independence of the sources .    to avoid",
    "maintenance issues , approaches that dynamically generate virtual triples are needed .",
    "some of them use reasoning and rules to create mappings between concepts and infer knowledge that is not explicitly stated @xcite .",
    "another approach could be to build new graphs that encapsulate underlying heterogeneities .",
    "for instance , sparql ` construct ` queries return graphs dynamically created from existent ones and allow the creation of new triples as the next example shows .",
    "the following sparql ` construct ` query returns a graph that contains all the _",
    "( artist , ` foaf : made ` , record ) _",
    "triples from the jamendo dataset but also generates new triples .",
    "that is , for each _",
    "( record , ` foaf : maker ` , artist ) _ triple in the magnatune and jamendo datasets it creates a _ ( artist , ` foaf : made ` , record ) _",
    "triple ) ( i.e , the query of example  [ fig.uc1select ] ) .",
    ".... construct { ?",
    "artist foaf : made ?",
    "record } from named < http://dbtune.org/jamendo > from named < http://dbtune.org/magnatune > where {           { graph < http://dbtune.org/jamendo >          { ?",
    "artist foaf : made ?",
    "record .            ?",
    "artist rdf : type mo : musicartist .             ?",
    "record rdf : type mo : record   }      } union      { graph < http://dbtune.org/jamendo >          { ?",
    "record foaf : maker ?",
    "artist .            ?",
    "artist rdf : type mo : musicartist .            ?",
    "record rdf : type mo : record }      } union      { graph < http://dbtune.org/magnatune >          { ?",
    "record foaf : maker ?",
    "artist .            ?",
    "artist rdf : type mo : musicartist .            ?",
    "record rdf : type mo : record   }       } }    ....    [ fig.uc1construct ]    let us suppose that now our user wants to reutilize this query to retrieve the title of each record made by an artist .",
    "although the query in example [ fig.uc1construct ] generates a new graph , sparql does not provide mechanisms to pose queries against dynamically generated graphs ( e.g. , using graphs as sub - queries in the ` from ` clause ) . to answer this query in sparql 1.0 existent queries",
    "can not be reused , and a new query must be formulated ( see next example ) .",
    "the sparql 1.0 ` select ` query below , retrieves artists , records and record titles .",
    ".... select distinct ?",
    "title from < http://dbtune.org/jamendo > from < http://dbtune.org/magnatune > from named < http://dbtune.org/jamendo > from named < http://dbtune.org/magnatune > where { ?",
    "record dc : title ?",
    "title .      { graph < http://dbtune.org/jamendo/ >          {   ?",
    "artist foaf : made ?",
    "record .              ?",
    "artist rdf : type mo : musicartist .                 ?",
    "record rdf : type mo : record .          }      } union      { graph < http://dbtune.org/jamendo/ >          { ?",
    "record foaf : maker ?",
    "artist .            ?",
    "artist rdf : type mo : musicartist .            ?",
    "record rdf : type mo : record .          }      } union      { graph < http://dbtune.org/magnatune/ >          { ?",
    "record foaf : maker ?",
    "artist .            ?",
    "artist rdf : type mo : musicartist .            ?",
    "record rdf : type mo : record .          } } } ....    [ fig.uc1sparql10app ]    the sparql 1.1 proposal  @xcite ( see section [ sec2 ] ) partially supports sub - queries , allowing only ` select ` queries to be part of the ` where ` clause .",
    "existent ` construct ` queries can not be reused either in the ` from ` clause ( e.g. : as datasets ) nor in the ` where ` clause ( e.g. : as graph patterns ) .",
    "example [ fig.uc1sparql11app ] presents a sparql 1.1 ` select ` query that retrieves artists , their records and their titles .",
    "it shows that , in order to reuse the query presented in example [ fig.uc1select ] , the code must be ` copy - pasted ' , which is hard to maintain , error - prone , and limits the use of optimization strategies based on view materialization .",
    "a sparql 1.1 ` select ` query that retrieves artists , records and record titles .    ....",
    "recordtitle where { ?",
    "record dc : title ?",
    "record   from < http://dbtune.org/magnatune >   where { ?",
    "record foaf : maker ?",
    "artist .           ?",
    "artist a mo : musicartist .           ?",
    "record a mo : record } } union { select ?",
    "record   from < http://dbtune.org/jamendo >   where { ?",
    "artist foaf : made ?",
    "record .           ?",
    "artist a mo : musicartist .           ?",
    "record a mo : record } } union { select ?",
    "record   from < http://dbtune.org/jamendo >   where { ?",
    "record foaf : maker ?",
    "artist .           ?",
    "artist a mo : musicartist .           ?",
    "record a mo : record } } } ....    [ fig.uc1sparql11app ]    in light of the above , sparql extensions have been proposed to allow ` construct ` queries to be used as subqueries .",
    "for instance , networked graphs ( ng )  @xcite allow defining and storing graphs for later use in other queries .",
    "example [ fig.uc1ngdef ] shows , using rdf trig syntax , how the graph in example [ fig.uc1select ] can be implemented using ngs .",
    "an ng is defined by means of an rdf triple whose subject is the uri that identifies the graph , its predicate is denoted ` ng : definedby ` , and its object is a string that represents the ` construct ` query that will be evaluated at runtime , and whose results will populate the graph .",
    "applying networked graphs to use case 1 : definition    .... def : query1 { def : query1 ng : definedby `` construct { ?",
    "artist foaf : made ?",
    "record } where {           { graph < http://dbtune.org/jamendo/ >          { ?",
    "artist foaf : made ?",
    "record .            ?",
    "artist rdf : type mo : musicartist .             ?",
    "record rdf : type mo : record          }      } union      { graph < http://dbtune.org/jamendo/ >          { ?",
    "record foaf : maker ?",
    "artist .            ?",
    "artist rdf : type mo : musicartist .            ?",
    "record rdf : type mo : record          }      } union      { graph < http://dbtune.org/magnatune/ >          { ?",
    "record foaf : maker ?",
    "artist .            ?",
    "artist rdf : type mo : musicartist .            ?",
    "record rdf : type mo : record           }      } } ' ' ^^ng : query } ....    [ fig.uc1ngdef ]    once defined , the ng can be reused in further queries .",
    "example [ fig.uc1ngapp ] presents a sparql query that uses the previously defined ng , encapsulating the different representations of the relationship between artists and their records .    applying networked graphs to use case 1 : usage    ....",
    "select distinct ?",
    "recordtitle where    { ?",
    "record dc : title ?",
    "recordtitle .",
    "{ graph < http://definedviews / query1 >              { ?",
    "artist foaf : made ?",
    "record }                  } } ....    [ fig.uc1ngapp ]    * use case 2 : musical manifestations and their authors .",
    "*    let us now consider that the user wants to retrieve information about all musical manifestations stored in the datasets .",
    "figure  [ fig : sourcesch ] shows that there are no instances of the _ musicalmanifestation _ class in the datasets but there are instances of two of their sub - classes : _ record _ and _ track_. sparql supports different entailment regimes , in particular rdf , rdfs , and owl . under rdfs",
    "entailment the application of inference rules generates results that are not explicitly stated in the datasets . for example",
    ", one of such rules allows inferring that , since _",
    "record _ and _ track _ are sub - classes of _ musicalmanifestation _ all the instances of _ record _ and _ track _ are also instances of _",
    "musicalmanifestation_. we take a closer look at inference mechanisms in section [ sec2:rdf ]    example [ fig.usecase2 ] shows a sparql ` construct ` query that creates a graph that contains all the musical manifestation instances and for each instance its author , in case available . since _",
    "record _ and _ track _ are sub - classes of _ musicalmanifestation _ , all instances of the former two are also instances of the latter .",
    "thus , they should appear in the resulting graph .",
    "this query can be stored using ngs or implemented using sparql++  @xcite .",
    "we discuss sparql++ later in this paper .",
    "musical manifestations and their authors .    ....",
    "construct {          ?",
    "mm rdf : type mo : musicalmanifestation .      ?",
    "mm foaf : maker ?",
    "artist } where { ?",
    "mm rdf : type mo : musicalmanifestation .          optional {              ?",
    "mm foaf : maker ?",
    "artist } .",
    "optional {              ?",
    "mm a mo : track .              ?",
    "record mo : track ?",
    "mmanifestation .              ?",
    "record foaf : maker ?",
    "artist } .                         }    ....    [ fig.usecase2 ]    this use case exemplifies a problem orthogonal to the one stated in use case 1 : the need of support entailment regimes in sparql implementations and in view definition mechanisms .",
    "although these mechanisms , at first sight , seem to solve the problems above , little information can be found in the literature regarding how to use them , the volume of data they can handle and also on the restrictions that may apply to the queries they support .",
    "the purpose of this work is two - fold .",
    "first , study different application scenarios in which views over rdf datasets could be useful ; second , discuss to what extent existent view definition mechanisms can be used on the described scenarios .",
    "this paper is aimed at providing an analysis of the state - of - the - art in view definition mechanisms over rdf datasets , and identifying open research problems in the field .",
    "we first introduce the basic concepts on rdf , rdfs and sparql ( section [ sec2 ] ) . in section  [ sec3 ] , to give a framework to our study , we propose a definition of views over rdf datasets , along with four scenarios in which views have been traditionally applied in relational database systems . in section [ sec4 ]",
    "we study current view definition mechanisms , with a focus on the three ones that fulfill most of the conditions of our definition of views , and support the scenarios mentioned above .",
    "these proposals are sparql++ , networked graphs , and vsparql .",
    "we also provide a wider view , discussing other proposals in the field . in section [ sec5 ]",
    "we analyze the three selected proposals with respect to four goals : sparql 1.0 support , inference support , scalability , and facility for integration with existent platforms .",
    "we also perform experiments over the current a networked graphs implementation .",
    "finally , in section [ sec6 ] we present our conclusions and analyze open research directions .",
    "to make this paper self - contained in this section we present a brief review of basic concepts on rdf , rdfs and sparql  @xcite .",
    "the resource description framework ( rdf )  @xcite is a data model for expressing assertions over resources identified by an universal resource identifier ( uri ) .",
    "assertions are expressed as _ subject - predicate - object _",
    "triples , where _ subject _ are always resources , and _ predicate _ and _ object _ could be resources or strings . _",
    "blank nodes _ ( _ bnodes _ ) are used to represent anonymous resources or resources without an uri , typically with a structural function , e.g. , to group a set of statements .",
    "data values in rdf are called _ literals _ and can only be _ objects _ in triples . a set of rdf triples or _",
    "rdf dataset _ can be seen as a directed graph where _ subject _ and _ object _ are nodes , and _ predicates _ are arcs . formally :    consider the following sets u ( uri references ) ; @xmath0 ( blank nodes ) ; and l ( rdf literals ) .",
    "a triple @xmath1 is called an rdf triple .",
    "we denote ubl the union u @xmath2 b @xmath2 l. an rdf graph is a set of rdf triples .",
    "a subgraph is a subset of a graph .",
    "a graph is _ ground _ if it has no blank nodes .",
    "although the standard rdf serialization format is rdf / xml  @xcite , several formats coexist in the web such as ntriples@xcite , turtle  @xcite , n3  @xcite , trig  @xcite , and several serialization formats over json  @xcite .",
    "rdf schema ( rdfs )  @xcite is a particular rdf vocabulary supporting inheritance of classes and properties , as well as typing , among other features . in this work",
    "we restrict ourselves to a fragment of this vocabulary which includes the most used features of rdf , contains the essential semantics , and is computationally more efficient than the complete rdfs vocabulary  @xcite this fragment , called @xmath3df , contains the following predicates : rdfs : range ` [ range ] ` , rdfs : domain ` [ dom ] ` , rdf : type ` [ type ] ` , rdfs : subclassof ` [ sc ] ` , and rdfs : subpropertyof ` [ sp ] ` .",
    "the following set of rules captures the semantics of @xmath3df and allows reasoning over rdf .",
    "capital letters represent variables to be instantiated by elements of ubl .",
    "we use this subset of rdfs for addressing inference capabilities in view definitions .",
    "sparql is a query language for rdf graphs , which became a w3c standard in 2008  @xcite .",
    "the query evaluation mechanism of sparql is based on subgraph matching : rdf triples in the queried data and a query pattern are interpreted as nodes and edges of directed graphs , and the query graph is matched to the data graph , instantiating the variables in the query graph definition  @xcite .",
    "the selection criteria is expressed as a graph pattern in the ` where ` clause , and it is composed of basic graph patterns defined as follows :    sparql  queries are built using an infinite set v of variables disjoint from ubl . a variable v @xmath4 v is denoted using either ? or $ as a prefix .",
    "a triple pattern is member of the set @xmath5 , that binds variables in v to rdf terms in the graph .",
    "a basic graph pattern ( bgp ) is a set of triple patterns connected by the ` . '",
    "operator .      * * group graph patterns * , a graph pattern containing multiple graph patterns that must all match , * * optional graph patterns * , a graph pattern that may match and extend the solution , but will not cause the query to fail , * * union graph patterns * , a set of graph patterns that are tried to match independently , and * * patterns on named graphs * , a graph pattern that is matched against named graphs .      * ` select ` , which returns a set of the variables bound in the query pattern , * ` construct ` , which returns an rdf graph constructed by substituting variables in a set of triple templates , * ` ask ` , which returns a boolean value indicating whether a query pattern matches or not , and * ` describe ` , which returns an rdf graph that describes resources found ."
  ],
  "abstract_text": [
    "<S> views on rdf datasets have been discussed in several works , nevertheless there is no consensus on their definition nor the requirements they should fulfill . in traditional data management systems , views have proved to be useful in different application scenarios such as data integration , query answering , data security , and query modularization .    in this work </S>",
    "<S> we have reviewed existent work on views over rdf datasets , and discussed the application of existent view definition mechanisms to four scenarios in which views have proved to be useful in traditional ( relational ) data management systems . to give a framework for the discussion we provided a definition of views over rdf datasets , an issue </S>",
    "<S> over which there is no consensus so far . </S>",
    "<S> we finally chose the three proposals closer to this definition , and analyzed them with respect to four selected goals . </S>"
  ]
}