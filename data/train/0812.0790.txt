{
  "article_text": [
    "_ answer set programming ( asp ) _ is a programming paradigm @xcite based on logic programming under answer set semantics @xcite .",
    "asp is a _ highly declarative _ paradigm . in order to solve a problem @xmath1 ,",
    "we specify it as a logic program @xmath2 , whose answer sets correspond one - to - one to solutions of @xmath1 , and can be computed using an answer set solver .",
    "asp is also attractive because of its numerous building block results ( see , e.g. , @xcite ) .",
    "this can be seen in the following example .",
    "consider the problem of computing the hamiltonian cycles of a graph .",
    "the graph can be encoded as a collection of facts , e.g. , @xmath3 a program contains rules , in the form of horn clauses ; in our case : @xmath4 it can be shown that every answer set of the program consisting of the rules representing the graph and the above rules corresponds to an hamiltonian cycle of the graph and vice versa .",
    "furthermore , the program has no answer set if and only if the graph does not have an hamiltonian cycle .",
    "@xmath5    the popularity of asp has grown significantly over the years , finding innovative and highly declarative applications in a variety of domains , such as intelligent agents  @xcite , planning  @xcite , software modeling and verification  @xcite , complex systems diagnosis  @xcite , and phylogenetic inference  @xcite .",
    "the growing popularity of asp , especially in domains like non - monotonic and commonsense reasoning , has been supported by the development of excellent inference engines  @xcite . on the other hand , a source of difficulties in learning to use asp lies in the lack of _ methodologies _ and _ tools _ which can assist users in understanding a program s behavior and debugging it .",
    "the highly declarative nature of the asp framework and the `` hand - off '' execution style of asp leave a programmer with little information that helps in explaining the behavior of the programs , except for the program itself .",
    "for example , the additional information that can be gained by exploring the intermediate state of an execution ( e.g. , value of variables ) of an imperative program using a debugger does not have any equivalent in the context of asp .",
    "this situation is especially difficult when the program execution produces unexpected outcomes , e.g. , incorrect or missing answer sets . in this sense",
    ", this paper shares the spirit of other attempts in developing tools and methodologies for understanding and debugging of asp programs , as in @xcite .    although the traditional language of logic programming under answer set semantics , e.g. , referred to as ansprolog in @xcite or a - prolog @xcite , is syntactically close to prolog , the execution model and the semantics are sufficiently different to make debugging techniques developed for prolog impractical .",
    "for example , the traditional _ trace - based",
    "_ debuggers  @xcite ( e.g. , prolog four - port debuggers ) , used to trace the entire proof search tree ( paired with execution control mechanisms , like spy points and step execution ) , are cumbersome in asp , since :    * trace - based debuggers provide the entire search sequence , including the failed paths , which might be irrelevant in understanding how specific elements are introduced in an answer set . *",
    "the process of computing answer sets is bottom - up , and the determination of the truth value of one atom is intermixed with the computation of other atoms ; a direct tracing makes it hard to focus on what is relevant to one particular atom .",
    "this is illustrated in the following example .",
    "+ [ exbelow ] consider the following simple program .",
    "@xmath6 the program @xmath1 has a unique answer set , @xmath7 .",
    "in particular , @xmath8 , since @xmath9 appears as a fact in the program , and @xmath10 because of the rule and @xmath8 . in this process , there is no need to expose the processing of the rule to the user , since ` r \\not \\in m`.@xmath5 * tracing repeats previously performed executions , degrading debugging performance and confusing the programmer .",
    "we address these issues by elaborating the concept of _ off - line justification _ for asp . this notion is an evolution of the concept of _ justification _ , proposed to justify truth values in tabled prolog  @xcite .",
    "intuitively , an off - line justification of an atom w.r.t .",
    "an answer set is a graph encoding the reasons for the atom s truth value .",
    "this notion can be used to explain the presence or absence of an atom in an answer set , and provides the basis for building a _ justifier _ for answer set solvers . in this paper",
    ", we develop this concept and investigate its properties .    the notion of off - line justification is helpful when investigating the content of one ( or more ) answer sets .",
    "when the program does not have answer sets , a different type of justification is needed .",
    "this leads us to the notion of _ on - line justification _ , which provides justifications with respect to a _ partial _ and/or ( sometimes ) _ inconsistent _ interpretation .",
    "an on - line justification is _ dynamic _ , in that it can be obtained at any step of the answer set computation , provided that the computation process follows certain strategies .",
    "the intuition is to allow the programmer to interrupt the computation ( e.g. , at the occurrence of certain events , such as assignment of a truth value to a given atom ) and to use the on - line justification to explore the motivations behind the content of the partial interpretation ( e.g. , why a given atom is receiving conflicting truth values ) .",
    "we describe a _",
    "generic _ model of on - line justification and a version specialized to the execution model of smodels  @xcite .",
    "the latter has been implemented in @xmath0  @xcite .",
    "justifications are offered as first - class citizens of a prolog system , enabling the programmer to use prolog programs to reason about asp computations .",
    "debugging is one of the possible uses of the notion of justification developed in this paper .",
    "in this paper , we focus on a logic programming language with negation as failure  e.g . , the language of smodels without weight constraints and choice rules @xcite .",
    "each program @xmath1 is associated with a signature @xmath11 , where    * @xmath12 is a finite set of _ constants _ , * @xmath13 is a set of _ variables _ , and * @xmath14 is a finite set of _ predicate _ symbols .",
    "in particular , we assume that @xmath15 ( stands for @xmath16 ) and @xmath17 ( stands for @xmath18 ) are zero - ary predicates in @xmath14 .",
    "a _ term _ is a constant of @xmath12 or a variable of @xmath13 .",
    "atom _ is of the form @xmath19 , where @xmath20 , and @xmath21 are terms .",
    "in particular , a term ( atom ) is said to be _ ground _ if there are no occurrences of elements of @xmath13 in it .",
    "a _ literal _ is either an atom ( _ positive literal _ ) or a formula of the form @xmath22 , where @xmath23 is an atom ( _ naf literal _ ) . in what follows",
    ", we will identify with @xmath24 the set of all ground literals .    a _ rule _ , @xmath25 ,",
    "is of the form @xmath26 ( @xmath27 ) where @xmath28 is an atom and @xmath29 .",
    "the atom @xmath28 is referred to as the _ head _ of the rule , while the set of literals @xmath30 represents the _ body _ of the rule . given a rule @xmath25 , we denote @xmath28 with @xmath31 and we use @xmath32 to denote the set @xmath33",
    ". we also denote with @xmath34i.e . , all the elements of the body that are not negated  and with @xmath35i.e . , the atoms that appear negated in the body of the rule .    given a rule @xmath25 , we denote with @xmath36 the set of all rules obtained by consistently replacing the variables in @xmath25 with constants from @xmath12 ( i.e. , the _ ground instances _ of @xmath25 ) .",
    "we identify special types of rules :    * a rule @xmath25 is _ definite _ if @xmath37 ; * a rule @xmath25 is a _ fact _ if @xmath38 ; for the sake of readability , the fact @xmath39 will be simply written as @xmath40    a program @xmath1 is a set of rules .",
    "a program with variables is understood as a shorthand for the set of all ground instances of the rules in @xmath1 ; we will use the notation : @xmath41 a program is _ definite _ if it contains only definite rules .",
    "the answer set semantics of a program ( subsection [ semantics ] ) is highly dependent on the truth value of atoms occurring in the negative literals of the program . for later use ,",
    "we denote with @xmath42 the atoms which appear in naf literals in @xmath1i.e .",
    ", @xmath43 we will also use @xmath44 to denote the herbrand base of a program @xmath1 . for brevity ,",
    "we will often write @xmath45 instead of @xmath44 .    [ exa ] let us consider the program @xmath46 containing the rules : @xmath47 the rule @xmath48 is definite , while the rule @xmath49 is a fact .",
    "for the rule @xmath50 we have :    * @xmath51 * @xmath52 * @xmath53 * @xmath54    for @xmath46 , we have @xmath55 . @xmath5      we will now review two important semantics of logic programs , the answer set semantics and the well - founded semantics . the former is foundational to asp and the latter is important for the development of our notion of a justification .",
    "we will also briefly discuss the basic components of asp systems .      a _ ( three - valued ) interpretation _",
    "@xmath56 is a pair @xmath57 , where @xmath58 and @xmath59 .",
    "intuitively , @xmath60 collects the knowledge of the atoms that are known to be true , while @xmath61 collects the knowledge of the atoms that are known to be false .",
    "@xmath56 is a _ complete interpretation _ if @xmath62 .",
    "if @xmath56 is not complete , then it means that there are atoms whose truth value is _ undefined _ with respect to @xmath56 . for convenience",
    ", we will often say that an atom @xmath23 is undefined in @xmath56 and mean that the truth value of @xmath23 is undefined in @xmath56 .",
    "let @xmath1 be a program and @xmath56 be an interpretation .",
    "a positive literal @xmath23 is satisfied by @xmath56 , denoted by @xmath63 , if @xmath64 .",
    "a naf literal @xmath65 is satisfied by @xmath56denoted by @xmath66if @xmath67 .",
    "a set of literals @xmath68 is satisfied by @xmath56 ( @xmath69 ) if @xmath56 satisfies each literal in @xmath68 .",
    "the notion of satisfaction is easily extended to rules and programs as follows .",
    "a rule @xmath25 is satisfied by @xmath56 if @xmath70 or @xmath71 .",
    "@xmath56 is a _ model _ of a program if it satisfies all its rules .",
    "an atom @xmath23 is _ supported _ by @xmath56 in @xmath1 if there exists @xmath72 such that @xmath73 and @xmath74 .",
    "we introduce two partial orders on the set of interpretations :    * for two interpretations @xmath56 and @xmath75 , we say that @xmath76 iff @xmath77 and @xmath78 * for two interpretations @xmath56 and @xmath75 , we say that @xmath79 iff @xmath77    we will denote with @xmath80 the set of all possible interpretations and with @xmath81 the set of complete interpretations .",
    "an important property  @xcite of definite programs is that for each program @xmath1 there exists a unique model @xmath82 which is @xmath83-minimal over @xmath81 .",
    "@xmath82 is called the _ least herbrand model _ of @xmath1 .      for an interpretation @xmath56 and a program @xmath1 , the _ reduct _ of @xmath1 w.r.t .",
    "@xmath56 ( denoted by @xmath84 ) is the program obtained from @xmath1 by deleting _ (",
    "i ) _ each rule @xmath25 such that @xmath85 , and _",
    "( ii ) _ all naf literals in the bodies of the remaining rules .",
    "formally , @xmath86 given a complete interpretation @xmath56 , observe that the program @xmath84 is a definite program .",
    "a complete interpretation @xmath56 is an _ answer set _",
    "@xcite of @xmath1 if @xmath60 is the least herbrand model of @xmath84  @xcite .",
    "briefly let us reconsider the program @xmath46 in example  [ exa ] .",
    "if we consider the interpretation @xmath87 , then the reduct @xmath88 will contain the rules : @xmath89 it is easy to see that @xmath90 is the least herbrand model of this program ; thus , @xmath56 is an answer set of @xmath46 .",
    "@xmath5    for a definite program @xmath1 and an interpretation @xmath56 , the immediate consequence operator @xmath91 is defined by @xmath92 @xmath91 is monotone and has a least fixpoint @xcite .",
    "the fixpoint of @xmath91 will be denoted by @xmath93 .",
    "let us describe the _ well - founded semantics _",
    ", following the definition proposed in @xcite .",
    "we note that this definition is slightly different from the original definition of the well - founded semantics in @xcite .",
    "let us start by recalling some auxiliary definitions .",
    "[ tpj ] let @xmath1 be a program , @xmath68 and @xmath94 be sets of atoms from @xmath45 .",
    "the set @xmath95 ( _ immediate consequence of s w.r.t p and v _ ) is defined as follows : @xmath96    it is easy to see that , if @xmath94 is fixed , the operator is monotone with respect to @xmath68 . against , we use @xmath97 to denote the least fixpoint of this operator when @xmath94 is fixed .",
    "[ kui ] let @xmath1 be a program and @xmath98 be the set of definite rules in @xmath1 .",
    "the sequence @xmath99 is defined as follows : @xmath100    let @xmath101 be the first index of the computation such that @xmath102 .",
    "we will denote with @xmath103 the ( unique ) _ well - founded _ model of @xmath1 , where @xmath104 and @xmath105 .",
    "briefly    let us reconsider the program @xmath46 of example  [ exa ] .",
    "the computation of the well - founded model proceeds as follows : @xmath106 thus , the well - founded model will be @xmath107 .",
    "observe that both @xmath108 and @xmath109 are undefined in the well - founded model.@xmath5        as recognized by a number of authors @xcite , the adoption of answer set semantics requires a _ paradigm shift _ to reconcile the peculiar features of the semantics  i.e . , the existence of multiple admissible models  with the traditional program view of logic programming . in the first place , each program potentially admits more than one intended model , leading to an additional level of non - determinism .",
    "the presence of multiple answer sets complicates the framework in two ways .",
    "first of all , we need to provide programmers with a way of handling the multiple answer sets .",
    "the additional level of non - determinism is a real need for a number of applications , and it bears some similarities with the proposals put forward in other communities  such as the _ choice _ and _ witness _ constructs used in the database community  @xcite .",
    "the presence of multiple answer sets , in turn , leads to a new set of requirements on the _ computational mechanisms _ used . given a program ,",
    "now the main goal of the computation is not to provide a goal - directed tuple - at - a - time answer ( as in prolog ) , but the goal is to return _ complete answer sets_. the traditional resolution - based control used in prolog is largely inadequate , and it should give place to a different form of control and different execution mechanisms .    in simple terms , the goal of an asp program is to identify a _ collection of answer sets_i.e .",
    ", each program is interpreted as a specification of a collection of _ sets of atoms_. each rule in the program plays the role of a _ constraint _",
    "@xcite on the collection of sets specified by the program : a generic rule + @xmath110 requires that whenever @xmath111 are part of the answer set and @xmath112 are not , then @xmath113 has to be in the answer set as well . thus , the collection of rules in a program constrain what sets of literals can be considered admissible answer sets .",
    "the shift of perspective from traditional logic programming to asp is very important .",
    "the programmer is led to think about writing programs as manipulating sets of elements , and the outcome of the computation is going to be a collection of sets  instead of an answer substitution , as in prolog .",
    "this perspective comes very natural in a large number of application domains ( e.g. , graph applications , planning problems ) .",
    "several efficient asp solvers have been developed , such as smodels  @xcite , dlv  @xcite , cmodels  @xcite , assat  @xcite , and clasp  @xcite .",
    "one of the most popular asp solvers is smodels @xcite which comes with lparse , a grounder .",
    "lparse takes as input a logic program @xmath1 and produces as output a simplified version of @xmath114 .",
    "the output of lparse is in turn accepted by smodels , and used to produce the answer sets of @xmath1 ( see figure  [ lparse_smodel ] ) .    the lparse / smodels system supports several extended types of literals , such as the _ cardinality literals _ , which are of the form : @xmath115 , where @xmath116 and @xmath117 are integers , @xmath118 , and @xmath119 are literals .",
    "the cardinality literal is satisfied by an answer set @xmath120 if the number @xmath121 of literals in @xmath122 that are true in @xmath120 is such that @xmath123 .",
    "the back - end engine , smodels in figure  [ lparse_smodel ] , produces the collection of answer sets of the input program .",
    "various control options can be provided to guide the computation ",
    ", establish a limit on the number of answer sets provided or request the answer set to contains specific atoms .",
    "we note that all of the available asp solvers  @xcite operate in a similar fashion as smodels .",
    "dlv uses its own grounder while others use lparse .",
    "new grounder programs have also been recently proposed , e.g. , gringo in @xcite .",
    "sat - based answer set solvers rely on sat - solver in computing answer sets @xcite .",
    "@xmath0  @xcite is a system which provides a tight and semantically well - founded integration between prolog ( in the form of ciao prolog  @xcite ) and answer set programming ( in the form of smodels ) .",
    "the @xmath0  system has been developed using the module and class capabilities of ciao prolog .",
    "@xmath0  allows programmers to develop programs as collections of _",
    "modules_. along with the traditional types of modules supported by ciao prolog ( e.g. , prolog modules , constraint logic programming modules ) , it allows the presence of _ asp modules _ , each being a complete asp program .",
    "each ciao prolog module can access the content of any asp module ( using the traditional module qualification of prolog ) , read its content , access its models , and modify it ( using the traditional assert and retract predicates of prolog ) .",
    "@xmath0  allows us to create prolog modules that access ( and possibly modify ) other modules containing asp code .",
    "for example , the following prolog module    ....     : - use_asp(aspmod , ' asp_module.lp ' ) .",
    "count_p(x ) : -           findall(q , ( aspmod : model(q ) , q : p ) , list ) ,          length(list , x ) .",
    "....    accesses an asp module ( called aspmod ) and defines a predicate ( count_p ) which counts how many answer sets of aspmod contain the atom p. @xmath5",
    "the traditional methodology employed in asp relies on encoding each problem @xmath124 as a logic program @xmath125 , whose answer sets are in one - to - one correspondence with the solutions of @xmath124 . from the software development perspective , it would be important to address the question _ `` why is @xmath120 an answer set of the program @xmath1 ? '' _ this question gives rise to the question `` why does an atom @xmath23 belong to @xmath126 ( or @xmath127 ) ? ''",
    "answering this question can be very important , in that it provides us with explanations regarding the presence ( or absence ) of different atoms in @xmath120 . intuitively , we view answering these questions as the `` declarative '' parallel of answering questions of the type `` why is @xmath128 the value of the variable @xmath121 ? '' in the context of imperative languages  a question that can be typically answered by producing and analyzing an _ execution trace _ ( or _ event trace _",
    "@xcite ) .",
    "the objective of this section is to develop the notion of _ explanation _ , as a graph structure used to describe the `` reason '' for the truth value of an atom w.r.t .",
    "a given answer set .",
    "in particular , each explanation graph will describe the derivation of the truth value ( i.e. , true or false ) of an atom using the rules in the program .",
    "the explanation will also need to be flexible enough to explain those contradictory situations , arising during the construction of answer sets , where an atom is made true _ and _ false at the same time  for reference , these are the situations that trigger a backtracking in systems like smodels  @xcite .    in the rest of this section , we will introduce this graph - based representation of the support for the truth values of atoms in an interpretation .",
    "in particular , we will incrementally develop this representation .",
    "we will start with a generic graph structure ( _ explanation graph _ ) , which describes truth values without accounting for program rules .",
    "we will then identify specific graph patterns that can be derived from program rules ( _ local consistent explanations _ ) , and impose them on the explanation graph , to obtain the _ @xmath129-based explanation graphs_. these graphs are used to explain the truth values of an atom w.r.t .",
    "an interpretation @xmath75 and a set of assumptions @xmath130where an assumption is an atom for which we will not seek any explanations .",
    "the assumptions derive from the inherent `` guessing '' process involved in the definition of answer sets ( and in their algorithmic construction ) , and they will be used to justify atoms that have been `` guessed '' in the construction of the answer set and for which a meaningful explanation can not be constructed .",
    "before we proceed , let us introduce notation that will be used in the following discussion .",
    "for an atom @xmath23 , we write @xmath131 to denote the fact that the atom @xmath23 is true , and @xmath132 to denote the fact that @xmath23 is false .",
    "we will call @xmath131 and @xmath132 the _ annotated _ versions of @xmath23 .",
    "furthermore , we will define @xmath133 and @xmath134 . for a set of atoms",
    "@xmath68 , we define the following sets of annotated atoms :    * @xmath135 , * @xmath136 .    furthermore , we denote with @xmath137 the set @xmath138 .      in building the notion of justification",
    ", we will start from a very general ( labeled , directed ) graph structure , called _",
    "explanation graph_. we will incrementally construct the notion of justification , by progressively adding the necessary restrictions to it .",
    "[ explanation graph ] [ egraph ] for a program @xmath1 , an _ explanation graph _ ( or _ e - graph _ ) is a labeled , directed graph @xmath139 , where @xmath140 and @xmath141 , which satisfies the following properties :    1 .",
    "[ one1 ] the only sinks in the graph are : @xmath142 , @xmath15 , and @xmath17 ; 2 .   [ two1 ] for every @xmath143 , we have that @xmath144 and @xmath145 ; 3 .   [ three1 ] for every @xmath146 , we have that @xmath147 and @xmath148 ; 4 .",
    "[ four1 ] for every @xmath149 , if @xmath150 for some @xmath151 and @xmath152 then @xmath153 is the only outgoing edge originating from @xmath154 .",
    "property ( [ one1 ] ) indicates that each atom appearing in an e - graph should have outgoing edges ( which will explain the truth value of the atom ) . properties ( [ two1 ] ) and ( [ three1 ] ) ensure that true ( false ) atoms are not explained using explanations that are proper for false ( true ) atoms . finally , property ( [ four1 ] )",
    "ensures that atoms explained using the special explanations @xmath142 , @xmath15 , @xmath17 have only one explanation in the graph .",
    "intuitively ,    * @xmath15 will be employed to explain program facts  i.e .",
    ", their truth does not depend on other atoms ; * @xmath17 will be used to explain atoms that do not have defining rules  i.e .",
    ", the falsity is not dependent on other atoms ; and * @xmath142 is used for atoms we are not seeking any explanations for .",
    "each edge of the graph connects two annotated atoms or an annotated atom with one of the nodes in @xmath155 , and it is marked by a label from @xmath156 .",
    "edges labeled @xmath157 are called _ positive _ edges , while those labeled @xmath158 are called _ negative _ edges .",
    "a path in an e - graph is _ positive _ if it contains only positive edges , while a path is negative if it contains at least one negative edge .",
    "we will denote with @xmath159 the fact that there is a positive path in the e - graph from @xmath160 to @xmath161 .",
    "[ ex1 ] figure  [ img1 ] illustrates several simple e - graphs .    intuitively ,    * the graph ( i ) describes the true state of @xmath108 by making it positively dependent on the true state of @xmath109 and @xmath162 ; in turn , @xmath109 is simply assumed to be true while @xmath162 is a fact in the program .",
    "* the graph ( ii ) describes more complex dependencies ; in particular , observe that @xmath9 and @xmath163 are both false and they are mutually dependent  as in the case of a program containing the rules @xmath164 observe also that @xmath165 is explained being false because there are no rules defining it . *",
    "the graph ( iii ) states that @xmath108 has been simply assumed to be false .",
    "@xmath5    given an explanation graph and an atom , we can extract from the graph the elements that directly contribute to the truth value of the atom .",
    "we will call this set of elements the support of the atom .",
    "this is formally defined as follows .",
    "let @xmath166 be an e - graph and @xmath167 a node in @xmath168 . the direct support of @xmath154 in @xmath168 , denoted by @xmath169 ,",
    "is defined as follows .",
    "* @xmath170 , if for every @xmath171 and @xmath152 , @xmath172 ; * @xmath173 if @xmath174 , @xmath171 and @xmath152 .",
    "if we consider the e - graph ( ii ) in figure  [ img1 ] , then we have that @xmath175 while @xmath176 .",
    "we also have @xmath177 .",
    "@xmath5    it is worth mentioning that an explanation graph is a general concept aimed at providing arguments for answering the question ` _ why is an atom true or false ? _ ' in this sense , it is similar to the concept of a support graph used in program analysis @xcite .",
    "the main difference between these two concepts lies in that support graphs are defined only for definite programs while explanation graphs are defined for general logic programs .",
    "furthermore , a support graph contains information about the support for _ all _ answer while an explanation graph stores only the support for _ one _ atom .",
    "an explanation graph can be used to answer the question of why an atom is false which is not the case for support graphs .",
    "the next step towards the definition of the concept of justification requires enriching the general concept of e - graph with explanations of truth values of atoms that are derived from the rules of the program .",
    "a _ local consistent explanation ( lce ) _ describes one step of justification for a literal .",
    "note that our notion of local consistent explanation is similar in spirit , but different in practice , from the analogous definition used in  @xcite .",
    "it describes the possible local reasons for the truth / falsity of a literal .",
    "if @xmath23 is true , the explanation contains those bodies of the rules for @xmath23 that are satisfied by @xmath56 .",
    "if @xmath23 is false , the explanation contains sets of literals that are false in @xmath56 and they falsify all rules for @xmath23 .",
    "the construction of a lce is performed w.r.t . a possible interpretation and a set of atoms @xmath117the latter contains atoms that are automatically assumed to be false , without the need of justifying them .",
    "the need for this last component ( to be further elaborated later in the paper ) derives from the practice of computing answer sets , where the truth value of certain atoms is first guessed and then later verified .",
    "[ lcedef ] let @xmath1 be a program , @xmath154 be an atom , @xmath75 a possible interpretation , @xmath117 a set of atoms ( _ assumptions _ ) , and @xmath178 a set of literals .",
    "we say that    1 .",
    "@xmath68 is _ a _ local consistent explanation of @xmath179 w.r.t .",
    "@xmath180 , if @xmath181 and * @xmath182 , or * @xmath183 , @xmath184 , and there is a rule @xmath25 in @xmath1 such that @xmath185 and @xmath186 ; for convenience , we write @xmath187 to denote the case where @xmath188 .",
    "@xmath68 is a local consistent explanation of @xmath189 w.r.t .",
    "@xmath180 if @xmath190 and * @xmath182 ; or * @xmath191 , @xmath192 , and @xmath68 is a minimal set of literals such that for every rule @xmath72 , if @xmath185 , then @xmath193 or @xmath194 ; for convenience , we write @xmath195 to denote the case @xmath196 .",
    "we will denote with @xmath197 the set of all the lces of @xmath179 w.r.t .",
    "@xmath180 , and with @xmath198 the set of all the lces of @xmath189 w.r.t .",
    "@xmath180 .",
    "observe that @xmath117 is the set of atoms that are assumed to be false .",
    "for this reason , negative lces are defined for elements @xmath199 but positive lces are defined only for elements in @xmath200 .",
    "we illustrate this definition in a series of examples .",
    "[ ex3 ] let @xmath1 be the program : @xmath201 the program admits only one answer set @xmath202 .",
    "the lces for the atoms of this program w.r.t .",
    "@xmath203 are : @xmath204@xmath5    the above example shows a program with a unique answer set .",
    "the next example discusses the definition in a program with more than one answer set and an empty well - founded model .",
    "it also highlights the difference between the positive and negative lces for atoms given a partial interpretation and a set of assumptions .",
    "[ ex6 ] let @xmath1 be the program : @xmath205 let us consider the partial interpretation @xmath206 .",
    "the following are lces w.r.t .",
    "@xmath203 : @xmath207 the above lces are explanations for the truth value of @xmath108 and @xmath109 being true and false with respect to @xmath120 and the empty set of assumptions .",
    "thus , the only explanation for @xmath108 being true is that it is assumed to be true , since the only way to derive @xmath108 to be true is to use the first rule and nothing is assumed to be false , i.e. , @xmath208 is not true . on the other hand",
    ", @xmath209 leads to the fact that there is no explanation for @xmath210 being false . likewise , because @xmath211 , there is no positive lce for @xmath109 w.r.t . @xmath203 .",
    "the lces w.r.t .",
    "@xmath212 are : @xmath213 assuming that @xmath109 is false leads to one additional explanation for @xmath108 being true . furthermore , there are now two explanations for @xmath109 being false .",
    "the first one is that it is assumed to be false and the second one satisfies the second condition in definition  [ lcedef ] .",
    "consider the complete interpretation @xmath214 .",
    "the lces w.r.t .",
    "@xmath215 are : @xmath216 @xmath5    the next example uses a program with a non - empty well - founded model .",
    "let @xmath1 be the program : @xmath217 this program has the answer sets : @xmath218 observe that the well - founded model of this program is @xmath219 .",
    "the following are lces w.r.t .",
    "the answer set @xmath220 and the empty set of assumptions ( those for @xmath221 have a similar structure ) : @xmath222 @xmath5    let us open a brief parenthesis to discuss some complexity issues related to the existence of lces .",
    "first , checking whether or not there is a lce of @xmath179 w.r.t .",
    "@xmath180 is equivalent to checking whether or not the program contains a rule @xmath25 whose head is @xmath154 and whose body is satisfied by the interpretation @xmath223 .",
    "this leads to the following observation .",
    "given a program @xmath1 , a possible interpretation @xmath75 , a set of assumptions @xmath117 , and an atom @xmath154 , determining whether or not there is a lce @xmath68 of @xmath179 w.r.t .",
    "@xmath180 such that @xmath224 can be done in time polynomial in the size of @xmath1 .    in order to determine whether or not there exists a lce of @xmath189 w.r.t .",
    "@xmath180 , we need to find a minimal set of literals @xmath68 that satisfies the second condition of definition [ lcedef ] .",
    "this can also be accomplished in time polynomial in the size of @xmath1 .",
    "in fact , let @xmath225 be the set of rules in @xmath1 whose head is @xmath154 .",
    "furthermore , for a rule @xmath25 , let @xmath226 intuitively , @xmath227 is the maximal set of literals that falsifies the rule @xmath25 w.r.t .",
    "@xmath180 . to find a lce for @xmath189 ,",
    "it is necessary to have @xmath228 for every @xmath229 .",
    "clearly , computing @xmath227 for @xmath229 can be done in polynomial time in the size of @xmath1 . finding a minimal set @xmath68 such that @xmath230 for every @xmath229",
    "can be done by scanning through the set @xmath225 and adding to @xmath68 ( initially set to @xmath231 ) an arbitrary element of @xmath227 if @xmath232 .",
    "this leads to the following observation .",
    "given a program @xmath1 , a possible interpretation @xmath75 , a set of assumptions @xmath117 , and an atom @xmath154 , determining whether there exists a lce @xmath68 of @xmath189 w.r.t .",
    "@xmath180 such that @xmath224 can be done in time polynomial in the size of @xmath1 .",
    "we are now ready to instantiate the notion of e - graph by forcing the edges of the e - graph to represent encodings of local consistent explanations of the corresponding atoms .",
    "to select an e - graph as an acceptable explanation , we need two additional components : the current interpretation ( @xmath75 ) and the collection ( @xmath117 ) of elements that have been introduced in the interpretation without any `` supporting evidence '' .",
    "an e - graph based on @xmath180 is defined next .",
    "[ ja - based ] let @xmath1 be a program , @xmath75 a possible interpretation , @xmath117 a set of atoms , and @xmath154 an element in @xmath233 .",
    "a @xmath180-_based explanation graph _",
    "@xmath234 of @xmath154 is an e - graph such that    * * ( relevance ) * every node @xmath235 is reachable from @xmath154 * * ( correctness ) * for every @xmath236 , @xmath237 is an lce of @xmath238 w.r.t . @xmath180    the two additional conditions we impose on the e - graph force the graph to be connected w.r.t",
    ". the element @xmath154 we are justifying , and force the selected nodes and edges to reflect local consistent explanations for the various elements .    the next condition we impose on the explanation graph is aimed at ensuring that no positive cycles are present .",
    "the intuition is that atoms that are true in an answer set should have a non - cyclic support for their truth values .",
    "observe that the same does not happen for elements that are false  as in the case of elements belonging to unfounded sets  @xcite .    a @xmath180-based e - graph @xmath139 is _ safe _ if @xmath239 , @xmath240 .",
    "consider the e - graphs in figure [ fig1 ] , for the program of example  [ ex5 ] .",
    "neither the e - graph of @xmath241 ( ( i ) nor the e - graph ( ii ) ) is a @xmath242-based e - graph of @xmath241 , since @xmath243 in both cases , and this does not represent a valid lce for @xmath244 ( since @xmath245 ) .",
    "observe , on the other hand , that they are both acceptable @xmath246-based e - graphs of @xmath241 .",
    "the e - graph of @xmath247 ( the graph ( iii ) ) is neither a @xmath242-based nor a @xmath246-based e - graph of @xmath247 , while the e - graph of @xmath248 ( graph ( iv ) ) is a @xmath242-based and a @xmath246-based e - graph of @xmath248 .",
    "observe also that all the graphs are safe.@xmath5",
    "_ off - line _ justifications are employed to characterize the `` reason '' for the truth value of an atom w.r.t . a given answer set @xmath120 .",
    "the definition will represent a refinement of the @xmath249-based explanation graph , where @xmath130 will be selected according to the properties of the answer set @xmath120 .",
    "off - line justifications will rely on the assumption that @xmath120 is a _",
    "complete _ interpretation .",
    "let us start with a simple observation .",
    "if @xmath120 is an answer set of a program @xmath1 , and @xmath250 is the well - founded model of @xmath1 , then it is known that , @xmath251 and @xmath252 @xcite .",
    "furthermore , we observe that the content of @xmath120 is uniquely determined by the truth values assigned to the atoms in @xmath253 , i.e. , the atoms that    * appear in negative literals in the program , and * their truth value is not determined by the well - founded model .",
    "we are interested in the subsets of @xmath94 with the following property : if all the elements in the subset are assumed to be false , then the truth value of all other atoms in @xmath45 is uniquely determined and leads to the desired answer set",
    ". we call these subsets the _ assumptions _ of the answer set .",
    "let us characterize this concept more formally .",
    "let @xmath1 be a program and @xmath120 be an answer set of @xmath1 .",
    "the _ tentative assumptions _ of @xmath1 w.r.t .",
    "@xmath120 ( denoted by @xmath254 ) are defined as : @xmath255    the negative reduct of a program @xmath1 w.r.t .",
    "a set of atoms @xmath117 is a program obtained from @xmath1 by forcing all the atoms in @xmath117 to be false .",
    "[ nred ] let @xmath1 be a program , @xmath120 an answer set of @xmath1 , and @xmath256 a set of tentative assumption atoms .",
    "the _ negative reduct _ of @xmath1 w.r.t .",
    "@xmath117 , denoted by @xmath257 , is the set of rules : @xmath258    let us consider the program    ....    p : - not q.                 q : - not p.",
    "r : - p , s.                  t : - q , u.    s. ....    the well - founded model for this program is @xmath259 .",
    "the program has two answer sets , @xmath260 and @xmath261 .",
    "the tentative assumptions for this program w.r.t .",
    "@xmath220 is the set @xmath262 .",
    "if we consider the set @xmath262 , the negative reduct of the program is the set of rules    ....    p : - not q.    r : - p , s.         t : - q , u.    s. ....    @xmath5    we are now ready to introduce the proper concept of assumptions  these are those tentative assumptions that are sufficient to allow the reconstruction of the answer set .",
    "[ assumption ] let @xmath1 be a program and @xmath120 be an answer set of @xmath1 .",
    "an _ assumption _",
    "@xmath120 is a set of atoms @xmath117 satisfying the following properties :    * @xmath256 , and * the well - founded model of @xmath257 is equal to @xmath120i.e . , @xmath263    we will denote with @xmath264 the set of all assumptions of @xmath1 w.r.t .",
    "@xmath120 . a _ minimal assumption _ is an assumption that is minimal w.r.t .",
    "the set inclusion operator .",
    "we will denote with @xmath265 the set of all the minimal assumptions of @xmath1 w.r.t .",
    "@xmath120 .",
    "an important observation we can make is that @xmath264 is not an empty set , since the complete set @xmath254 is an assumption .",
    "[ prop1 ] given a program @xmath1 and an answer set @xmath120 of @xmath1 , the well - founded model of the program @xmath266 is equal to @xmath120 .",
    "appendix a.    let us consider the program of example  [ ex6 ] .",
    "the interpretation @xmath267 is an answer set . for this program",
    "we have : @xmath268 observe that @xmath269 .",
    "the well - founded model of this program is @xmath270 , which is equal to @xmath120 .",
    "thus , @xmath262 is an assumption of @xmath1 w.r.t .",
    "in particular , one can see that this is the only assumption we can have.@xmath5    [ ex - wf ] let us consider the following program @xmath1 : @xmath271 the interpretation @xmath272 is an answer set of the program . in particular",
    ": @xmath273 the program @xmath274 is : @xmath275 the well - founded model of this program is @xmath276 .",
    "thus , @xmath277 is an assumption w.r.t . @xmath220 .    observe also that if we consider @xmath278 @xmath279 the well - founded model of this program is also @xmath276 , thus making @xmath280 another assumption .",
    "note that this second assumption is not minimal.@xmath5    we will now specialize e - graphs to the case of answer sets , where only false elements can be used as assumptions .",
    "let @xmath1 be a program , @xmath75 a partial interpretation , @xmath117 a set of atoms , and @xmath154 an element in @xmath233 .",
    "an _ off - line explanation graph _",
    "@xmath234 of @xmath154 w.r.t .",
    "@xmath75 and @xmath117 is a @xmath180-based e - graph of @xmath154 satisfying the following additional conditions :    * there exists no @xmath281 such that @xmath282 ; and *",
    "@xmath283 iff @xmath284 .",
    "we will denote with @xmath285 the set of all off - line explanation graphs of @xmath154 w.r.t .",
    "@xmath75 and @xmath117 .",
    "the first condition ensures that true elements can not be treated as assumptions , while the second condition ensures that only assumptions are justified as such in the graph .",
    "let @xmath1 be a program , @xmath120 an answer set , @xmath286 , and @xmath287 .",
    "an _ off - line justification _ of @xmath23 w.r.t .",
    "@xmath120 and @xmath117 is an element @xmath139 of @xmath288 which is safe .    if @xmath120 is an answer set and @xmath289 ( resp .",
    "@xmath290 ) , then @xmath168 is an off - line justification of @xmath121 w.r.t . @xmath120 and",
    "the assumption @xmath117 iff @xmath168 is an off - line justification of @xmath291 ( resp .",
    "@xmath292 ) w.r.t . @xmath120 and @xmath117 .",
    "[ ex2 ] let us consider the program in example [ ex5 ] .",
    "we have that @xmath293 .",
    "the assumptions for this program are : @xmath294 the off - line justifications for atoms in @xmath220 w.r.t . @xmath220 and @xmath295 are shown in figure  [ fig2 ] .",
    "justifications are built by assembling items from the lces of the various atoms and avoiding the creation of positive cycles in the justification of true atoms . also , the justification is built w.r.t . a chosen set of assumptions ( @xmath130 ) , whose elements are all assumed false .    in general",
    ", an atom may admit multiple justifications , even w.r.t .",
    "the same assumptions .",
    "the following lemma shows that elements in @xmath250 can be justified without negative cycles and assumptions .",
    "[ good ] let @xmath1 be a program , @xmath120 an answer set , and @xmath250 the well - founded model of @xmath1 .",
    "each atom @xmath296 has a justification w.r.t . @xmath120 and @xmath231 which does not contain any negative cycle .",
    "from the definition of assumption and from the previous lemma we can infer that a justification free of negative cycles can be built for every atom .",
    "[ propimp ]",
    "let @xmath1 be a program and @xmath120 an answer set .",
    "for each atom @xmath23 , there is an off - line justification w.r.t . @xmath120 and @xmath297 which does not contain negative cycles .",
    "proposition [ propimp ] underlines an important property  the fact that all true elements can be justified in a non - cyclic fashion .",
    "this makes the justification more natural , reflecting the non - cyclic process employed in constructing the minimal answer set ( e.g. , using the iterations of @xmath91 ) and the well - founded model ( e.g. , using the characterization in  @xcite ) .",
    "this also gracefully extends a similar property satisfied by the justifications under well - founded semantics used in  @xcite . note that the only cycles possibly present in the justifications are positive cycles associated to ( mutually dependent ) false elements ",
    "this is an unavoidable situation due the semantic characterization in well - founded and answer set semantics ( e.g. , unfounded sets ) .",
    "a similar design choice has been made in  @xcite .",
    "let us reconsider the following program @xmath1 from example [ ex - wf ] : @xmath298 and the answer set @xmath299 is an answer set of the program .",
    "the well - founded model of this program is @xmath300 @xmath301 and @xmath302 are assumed to be false .",
    "off - line justifications for @xmath303 and for @xmath304 with respect to @xmath120 and @xmath305 , which do not contain negative cycles , are the same as those depicted in figure  [ fig2 ] .",
    "@xmath306 has an off - line justification in which it is connected to @xmath142 by a negative edge , as it is assumed to be false .",
    "off - line justifications provide a `` declarative trace '' for the truth values of the atoms present in an answer set .",
    "the majority of the inference engines for asp construct answer sets in an incremental fashion , making choices ( and possibly undoing them ) and declaratively applying the rules in the program .",
    "unexpected results ( e.g. , failure to produce any answer sets ) require a more refined view of computation . one way to address",
    "this problem is to refine the notion of justification to make possible the `` declarative tracing '' of atoms w.r.t . a partially constructed interpretation .",
    "this is similar to debugging of imperative languages , where breakpoints can be set and the state of the execution explored at any point during the computation . in this section ,",
    "we introduce the concept of _ on - line justification",
    "_ , which is generated _ during _ the computation of an answer set and allows us to justify atoms w.r.t . an incomplete interpretation  that represents an intermediate step in the construction of the answer set .",
    "the concept of on - line justification is applicable to computation models that construct answer sets in an incremental fashion , e.g. , smodels and dlv @xcite .",
    "we can view the computation as a sequence of steps , each associated to a partial interpretation .",
    "we will focus , in particular , on computation models where the progress towards the answer set is monotonic .",
    "[ genc ] let @xmath1 be a program .",
    "general computation _ is a sequence @xmath307 , such that    _ (",
    "i ) _ : :    @xmath308 , _ ( ii ) _ : :    @xmath309 are partial interpretations , and _ ( iii ) _ : :    @xmath310 for    @xmath311 .",
    "a _ general complete computation _ is a computation @xmath312 such that @xmath313 is an answer set of @xmath1 .    in general",
    ", we do not require @xmath313the ending point of the computation  to be a partial interpretation , since we wish to model computations that can also `` fail''i.e .",
    ", @xmath314 .",
    "this is , for example , what might happen during a smodels computation  whenever the conflict function succeeds  @xcite",
    ".    we will refer to a pair of sets of atoms as a _ possible interpretation _ ( or _ p - interpretation _ for short ) .",
    "clearly , each partial interpretation is a p - interpretation , but not vice versa . abusing the notation",
    ", we use @xmath200 and @xmath315 to indicate the first and second component of a p - interpretation @xmath75 ; moreover , @xmath76 denotes that @xmath77 and @xmath78 .",
    "our objective is to associate a form of justification to each intermediate step @xmath316 of a general computation .",
    "ideally , we would like the justifications associated to each @xmath316 to explain truth values in the `` same way '' as in the final off - line justification . since the computation model might rely on guessing some truth values",
    ", @xmath316 might not contain sufficient information to develop a valid justification for each element in @xmath316 .",
    "we will identify those atoms for which a justification can be constructed given @xmath316 .",
    "these atoms describe a p - interpretation @xmath317 .",
    "the computation of @xmath318 is defined based on the two operators , @xmath319 and @xmath320 , which will respectively compute @xmath321 and @xmath322 .",
    "let us start with some preliminary definitions .",
    "let @xmath1 be a program and @xmath56 be a p - interpretation .",
    "a set of atoms @xmath68 is called a _",
    "cycle w.r.t .",
    "i _ if , for every @xmath323 and for each @xmath72 such that @xmath73 , we have that one of the following holds :    * @xmath324 ( rule is falsified by @xmath56 ) , or * @xmath325 ( rule is falsified by @xmath56 ) , or * @xmath326 ( rule is in a cycle with elements of @xmath68 ) .",
    "we can observe that , if @xmath56 is an interpretation , @xmath68 is a cycle w.r.t .",
    "@xmath56 , and @xmath120 is an answer set with @xmath327 , then @xmath328since the elements of @xmath68 are either falsified by the interpretation ( and , thus , by @xmath120 ) or they are part of an unfounded set .    the set of cycles w.r.t .",
    "@xmath56 is denoted by @xmath329 .",
    "furthermore , for every element @xmath330 , let @xmath331 be the set of local consistent explanations of @xmath23 w.r.t .",
    "@xmath56 and @xmath231i.e . ,",
    "lces that do not require any assumptions and that build on the interpretation @xmath56 .",
    "we are now ready to define the operators that will compute the @xmath318 subset of the p - interpretation @xmath316 .",
    "let @xmath1 be a program and @xmath76 be two p - interpretations .",
    "we define @xmath332    intuitively , for @xmath76 , @xmath333 is a set of atoms that are true in @xmath75 and they will remain true in every answer set extending @xmath75 , if @xmath75 is a partial interpretation .",
    "the set @xmath334 contains atoms that are false in @xmath75 and in each answer set that extends @xmath75 .",
    "in particular , if @xmath56 is the set of _ `` justifiable '' _ atoms  i.e . , atoms for which we can construct a justification  and @xmath75 is the result of the current computation step",
    ", then we have that @xmath335 is a new interpretation satisfying the following two properties :    * @xmath336 , and * it is possible to create a justification for all elements in @xmath335 .",
    "observe that it is not necessarily true that @xmath337 and @xmath338 .",
    "this means that there may be elements in the current step of computation for which it is not possible ( yet ) to construct a justification .",
    "this reflects the practice of guessing literals and propagating these guesses in the computation of answer sets , implemented by several solvers ( based on variations of the davis - putnam - logemann - loveland procedure  @xcite ) .",
    "we are now ready to specify how the set @xmath318 is computed .",
    "let @xmath103 be the well - founded model of @xmath1 and let @xmath75 be a p - interpretation .. ]    @xmath339 intuitively ,    1 .",
    "the iteration process starts by collecting the facts of @xmath1 ( @xmath340 ) and all those elements that are false either because there are no defining rules for them or because they have been chosen to be false in the construction of @xmath75 .",
    "all these elements can be easily provided with justifications .",
    "the successive iterations expand the set of known justifiable elements from @xmath75 using @xmath319 and @xmath320 .    finally , we repeat the iteration process until a fixpoint is reached : @xmath341 because @xmath342 and @xmath343 ( recall that @xmath76 ) , we know that both @xmath344 and @xmath345 are well - defined",
    ". we can prove the following :    [ gammadelta ] for a program @xmath1 , we have that :    * @xmath319 and @xmath320 maintains the consistency of @xmath75 , i.e. , if @xmath75 is an interpretation , then @xmath346 is also an interpretation ; * @xmath319 and @xmath320 are monotone w.r.t the argument @xmath75 , i.e. , if @xmath347 then @xmath348 and @xmath349 ; * @xmath350 and @xmath351 ; and * if @xmath120 is an answer set of @xmath1 , then @xmath352 and @xmath353 .",
    "we next introduce the notion of on - line explanation graph .",
    "let @xmath1 be a program , @xmath130 a set of atoms , @xmath75 a p - interpretation , and @xmath330 .",
    "an _ on - line explanation graph _",
    "@xmath234 of @xmath23 w.r.t .",
    "@xmath75 and @xmath130 is a @xmath129-based e - graph of @xmath23 .    in particular , if @xmath75 is an answer set of @xmath1 , then any off - line e - graph of @xmath23 w.r.t .",
    "@xmath75 and @xmath130 is also an on - line e - graph of @xmath23 w.r.t .",
    "@xmath75 and @xmath130 .",
    "observe that @xmath354 contains the set of facts of @xmath1 that belongs to @xmath200 , while @xmath355 contains the set of atoms without defining rules and atoms belonging to positive cycles of @xmath1 .",
    "as such , it is easy to see that , for each atom @xmath23 in @xmath356 , we can construct an e - graph for @xmath131 or @xmath132 whose nodes belong to @xmath357 . moreover :    * if @xmath358 , then an e - graph with nodes ( except @xmath131 ) belonging to @xmath359 can be constructed ; * if @xmath360 , an e - graph with nodes ( except @xmath132 ) belonging to @xmath361 can be constructed .",
    "this leads to the following lemma .",
    "[ just - free ] let @xmath1 be a program , @xmath75 a p - interpretation , and @xmath362 .",
    "the following properties hold :    * for each atom @xmath363 ( resp .",
    "@xmath364 ) , there exists a _",
    "safe _ off - line e - graph of @xmath131 ( resp .",
    "@xmath132 ) w.r.t .",
    "@xmath75 and @xmath130 ; * for each atom @xmath365 ( resp .",
    "@xmath366 ) there exists an on - line e - graph of @xmath131 ( resp .",
    "@xmath132 ) w.r.t . @xmath75 and @xmath130 .",
    "we will now discuss how the above proposition can be utilized in defining a notion called _ on - line justification_. to this end , we associate to each partial interpretation @xmath75 a snapshot @xmath367 :    [ snapdef ] a _ snapshot _ of a p - interpretation @xmath75 is a tuple @xmath368 , where    @xmath369    @xmath370 ,    for each @xmath23 in @xmath344 , +    @xmath371 contains exactly one safe off - line e - graph of @xmath131 w.r.t .",
    "@xmath75 and @xmath372 ;    for each @xmath23 in @xmath345 , +    @xmath371 contains exactly one safe off - line e - graph of @xmath132 w.r.t .",
    "@xmath75 and @xmath372 ;    for each @xmath373 , +    @xmath374 contains exactly one on - line e - graph of @xmath131 w.r.t .",
    "@xmath75 and @xmath372 ;    for each @xmath375 , +    @xmath374 contains exactly one on - line e - graph of @xmath132 w.r.t .",
    "@xmath75 and @xmath372 .    given",
    "a computation @xmath307 , an _ on - line justification _ of the computation is a sequence of snapshots @xmath376 .",
    "it is worth to point out that an on - line justification can be obtained in answer set solvers employing the computation model described in definition [ genc ] .",
    "this will be demonstrated in the next section where we discuss the computation of on - line justifications in the smodels system .",
    "we next illustrate the concept of an on - line justification .",
    "[ rem1 ] observe that the monotonicity of the computation allows us to avoid recomputing @xmath319 and @xmath320 from scratch at every step .",
    "in particular , when computing the fixpoint , we can start the iterations from @xmath377 and @xmath378 and look only at the elements of @xmath379 .",
    "similarly , the computation of @xmath380 can be made incremental , by simply adding to @xmath380 the off - line e - graphs for the elements in @xmath381 and @xmath382 .",
    "note also that these new off - line graphs can be constructed reusing the off - line graphs already present in @xmath383 .",
    "let us consider the program @xmath1 containing @xmath384 two possible general computations of @xmath1 are @xmath385 the first computation is a complete computation leading to an answer set of @xmath1 while the second one is not .",
    "an on - line justification for the first computation is given next : @xmath386 where ( for the sake of simplicity we report only the edges of the graphs ) : @xmath387 an on - line justification for the second computation is : @xmath388 where : @xmath389 @xmath5    we can relate the on - line justifications and off - line justifications as follows .",
    "[ conserve ] let @xmath1 be a program , @xmath75 an interpretation , and @xmath120 an answer set such that @xmath390 . for every atom @xmath23 , if @xmath139 is a safe off - line e - graph of @xmath23 w.r.t .",
    "@xmath75 and @xmath130 where @xmath391 then it is an off - line justification of @xmath23 w.r.t .",
    "@xmath120 and @xmath254 .",
    "this leads to the following proposition .",
    "[ on - off ] let @xmath392 be a general complete computation and @xmath393 be an on - line justification of the computation . then , for each atom @xmath23 in @xmath313 , the e - graph of @xmath23 in @xmath394 is an off - line justification of @xmath23 w.r.t .",
    "@xmath313 and @xmath395 .",
    "the notion of on - line justification presented in the previous section is very general , to fit the needs of different answer set solver implementations that follow the computation model presented in subsection [ subsec - comp ] . in this section ,",
    "we illustrate how the notion of on - line justification has been specialized to ( and implemented in ) a specific computation model  the one used in smodels @xcite .",
    "this allows us to define an incremental version of on - line justification  where the specific steps performed by smodels are used to guide the incremental construction of the justification .",
    "the choice of smodels was dictated by availability of its source code and its elegant design .",
    "we begin with an overview of the algorithms employed by smodels .",
    "the following description has been adapted from @xcite . although more abstract than the concrete implementation , and without various implemented features ( e.g. , heuristics , lookahead ) , it is sufficiently faithful to capture the spirit of our approach , and to guide the implementation ( see section  [ imple ] ) .",
    "we propose a description of the smodels algorithms based on a composition of state - transformation operators . in the following ,",
    "we say that an interpretation @xmath56 does not satisfy the body of a rule @xmath25 ( i.e. , @xmath32 is false in @xmath56 ) if @xmath396 .",
    "the @xmath397 operator is used to expand a partial interpretation @xmath56 in such a way that each answer set @xmath120 of @xmath1 that `` agrees '' with @xmath56i.e . , the elements in @xmath56 have the same truth value in @xmath120 ( or @xmath327)also agrees with the expanded interpretation .    given a program @xmath1 and a partial interpretation @xmath56 , we define the intermediate operators @xmath398 as follows :    * * case 1 . * if @xmath399 , @xmath400 , @xmath401 and @xmath402 then @xmath403 * * case 2 . * if @xmath404 and @xmath405 , then @xmath406 * * case 3 . * if @xmath407 and @xmath25 is the only rule in @xmath1 with @xmath408 and whose body is not false in @xmath56 then @xmath409 * * case 4 . * if @xmath410 , @xmath73 , and * * if @xmath411 then @xmath412 * * if @xmath413 then @xmath414 + @xmath415 then @xmath416    given a program @xmath1 and an interpretation @xmath56 , @xmath417 if @xmath418 and @xmath419 ( @xmath420 ) ; otherwise , @xmath421 .      the @xmath422 operator recognizes atoms that are defined exclusively as mutual positive dependences ( i.e. , `` positive loops'')and falsifies them . given a set of atoms @xmath68 , the operator @xmath423 is defined as @xmath424 .    given an interpretation @xmath56 ,",
    "the @xmath425 operator is defined as @xmath426 where @xmath427 and @xmath428 .",
    "this operator is used to randomly select an atom that is unknown in a given interpretation . given a partial interpretation @xmath56 , @xmath429 returns an atom of @xmath45 such that @xmath430      given an interpretation @xmath56",
    ", we define the transitions : @xmath431 if there is an @xmath432 in @xmath433 such that @xmath434 , then we will simply denote this fact with @xmath435 .",
    "the smodels system imposes constraints on the order of application of the transitions .",
    "intuitively , the smodels computation is depicted in the algorithms of figs .",
    "[ main ] and [ exp ] .",
    "we will need the following notations .",
    "a computation @xmath436 is said to be _",
    "@xmath437-pure _ if every transition in the computation is an @xmath438 transitions and for every @xmath439 , @xmath440",
    ". a choice point of a computation @xmath436 is an index @xmath441 such that @xmath442 .",
    "let @xmath1 be a program .",
    "let @xmath443 be a computation and @xmath444 ( @xmath445 ) be the sequence of all choice points in @xmath446 .",
    "we say that @xmath446 is a _ smodels computation _ if for every @xmath447 , there exists a sequence of indices @xmath448 ( @xmath449 and @xmath450 ) such that    * the transition @xmath451 is an @xmath452 transition ( @xmath453 ) * the computation @xmath454 is a @xmath437-pure computation .",
    "* for every @xmath101 , @xmath455 , @xmath456 , * for every @xmath447 , there exists a sequence of indices @xmath448 ( @xmath449 and @xmath450 ) such that * * the transition @xmath451 is an @xmath452 transition ( @xmath453 ) * * all transitions from @xmath457 to @xmath458 are @xmath459 transitions ( @xmath453 and @xmath460 ) ; in particular , for each @xmath461 we have that if @xmath462 then @xmath463 for @xmath464 * * @xmath465 * there is no @xmath466 such that @xmath467 .",
    "we illustrate this definition in the next example .",
    "[ exnew ] consider the program of example  [ ex5 ] .",
    "a possible computation of @xmath220 is : @xmath468 @xmath5      we can use knowledge of the specific steps performed by smodels to guide the construction of an on - line justification .    assuming that @xmath469 is a computation of smodels .",
    "let @xmath470 and @xmath471 be the snapshots correspond to @xmath316 and @xmath472 respectively .",
    "obviously , @xmath473 can be computed by the following steps :    * computing @xmath474 ; * updating @xmath475 and @xmath476 to obtain @xmath477 and @xmath478 .",
    "we observe that @xmath479 can be obtained by computing the fixpoint of the @xmath319- and @xmath320-function with the starting value @xmath377 and @xmath378 .",
    "this is possible due to the monotonicity of the computation .",
    "regarding @xmath477 and @xmath478 , observe that the e - graphs for elements in @xmath480 can be constructed using the e - graphs constructed for elements in @xmath481 and the rules involved in the computation of @xmath480 .",
    "thus , we only need to update @xmath477 with e - graphs of elements of @xmath480 which do not belong to @xmath481 .",
    "also , @xmath478 is obtained from @xmath476 by removing the e - graphs of atoms that `` move '' into @xmath482 and adding the e - graph @xmath483 ( resp .",
    "@xmath484 ) for @xmath485 ( resp .",
    "@xmath486 ) not belonging to @xmath482 . clearly , this computation depends on the transition from @xmath316 to @xmath472 .",
    "assume that @xmath487 , the update of @xmath488 to create @xmath473 is done as follows .",
    "* let @xmath489 be the atom chosen in this step .",
    "+ if @xmath489 is chosen to be true , then we can use the graph @xmath490 and the resulting snapshot is @xmath491 . observe that @xmath492 is unchanged , since the structure of the computation ( in particular the fact that an _ expand _ has been done before the choice ) ensures that @xmath489 will not appear in the computation of @xmath492 .",
    "+ if @xmath489 is chosen to be false , then we will need to add @xmath489 to @xmath493 , compute @xmath494 and @xmath495 , and update @xmath475 and @xmath476 correspondingly ; in particular , @xmath489 belongs to @xmath495 and @xmath496 is added to @xmath475 . * in this case , @xmath497 .",
    "the computation of @xmath473 is performed as from definition of on - line justification . in particular , observe that if @xmath498 we have that @xmath499 then the computation can be started from @xmath500 and @xmath501 .",
    "* let @xmath489 be the atom dealt with in this step and let @xmath25 be the rule employed .",
    "we have that @xmath502 . if @xmath503 then @xmath473 will be computed starting from @xmath504 and @xmath505 .",
    "in particular , an off - line graph for @xmath489 , let s say @xmath506 , will be added to @xmath475 , and such graph will be constructed using the lce based on the rule @xmath25 and the e - graphs in @xmath475 .",
    "+ otherwise , @xmath507 , where @xmath508 is an e - graph of @xmath509 constructed using the lce of rule @xmath25 and the e - graphs in @xmath510 ( note that all elements in @xmath32 have an e - graph in @xmath511 ) .",
    "* let @xmath489 be the atom dealt with in this step . in this case @xmath512 .",
    "if there exists @xmath513 , then @xmath473 can be computed according to the definition of on - line justification , starting from @xmath500 and @xmath514 .",
    "observe that the graph of @xmath489 can be constructed starting with @xmath515 ) .",
    "+ otherwise , given an arbitrary @xmath516 , we can construct an e - graph @xmath506 for @xmath517 , such that @xmath518 , the graphs @xmath511 are used to describe the elements of @xmath519 , and @xmath520 .",
    "* let @xmath25 be the rule used in this step and let @xmath521 .",
    "then @xmath522 and @xmath473 is computed according to the definition of on - line justification .",
    "observe that the e - graph @xmath506 for @xmath509 ( added to @xmath475 or @xmath476 ) for @xmath473 will be constructed using @xmath32 as @xmath523 , and using the e - graphs in @xmath524 for some @xmath525 * let @xmath25 be the rule processed and let @xmath154 the atom detected in the body .",
    "if @xmath526 , then @xmath527 , while if @xmath528 then @xmath529 . in either cases , the snapshot @xmath473 will be computed using the definition of on - line justification .",
    "[ ex44 ] let us consider the computation of example  [ exnew ] .",
    "a sequence of snapshots is ( we provide only the edges of the graphs and we combine together e - graphs of different atoms ) :    [ cols=\">,^,^,^\",options=\"header \" , ]     @xmath530 @xmath5    let @xmath1 be the program : @xmath531 this program does not admit any answer sets where @xmath489 is false .",
    "one possible computation ( we highlight only steps that change the trace ) : @xmath532 from this computation we can obtain a sequence of snapshots :    @xmath533 observe that a conflict is detected by the computation and the sources of conflict are highlighted in the presence of two justifications for @xmath489 , one for @xmath509 and another one for @xmath517 .",
    "@xmath5      in this subsection , we discuss possible ways to extend the notion of justifications on various language extensions of asp .",
    "we also describe a system capable of computing off - line and on - line justifications for asp programs .      in the discussion presented above , we relied on a standard logic programming language .",
    "various systems , such as smodels , have introduced language extensions , such as choice atoms , to facilitate program development .",
    "the extension of the notion of justification to address these extensions is relatively straightforward .",
    "let us consider , for example , the choice atom construct of smodels .",
    "a choice atom has the form @xmath534 where @xmath535 are integers ( with @xmath536 ) and the various @xmath537 are atoms .",
    "choice atoms are allowed to appear both in the head as well as the body of rules . given an interpretation @xmath56 and a choice atom , we say that @xmath56 satisfies the atom if @xmath538    the local consistent explanation of a choice atom can be developed in a natural way :    * if the choice atom @xmath539 is true , then a set of literals @xmath68 is an lce if * * @xmath540 and @xmath541 * * for each @xmath542 such that @xmath543 and @xmath544 we have that @xmath545 * if the choice atom @xmath539 is false , then a set of literals @xmath68 is an lce if * * @xmath540 and @xmath541 * * for each @xmath542 such that @xmath543 and @xmath544 we have that @xmath546    the notions of e - graphs can be extended to include choice atoms . choice atoms in the body",
    "are treated as such and justified according to the new notion of lce . on the other hand ,",
    "if we have a rule of the type @xmath547 and @xmath120 is an answer set , then we will    * treat the head as a new ( non - choice ) atom ( @xmath548 ) , and allow its justification in the usual manner , using the body of the rule * for each atom @xmath549 , the element @xmath509 has a new lce @xmath550    consider the program containing the rules : @xmath551 the interpretation @xmath552 is an answer set of this program .",
    "the off - line justifications for @xmath553 and @xmath554 are illustrated in figure  [ choiceexp ] .",
    "@xmath5    the concept can be easily extended to deal with weight atoms .",
    "the notions of off - line and on - line justifications proposed in the previous sections have been implemented and integrated in a debugging system for answer set programming , developed within the @xmath0  framework  @xcite .",
    "the notions of justification proposed here is meant to represent the basic data structure on which debugging strategies for asp can be developed .",
    "@xmath0  allows the construction of prolog programs  using ciao prolog  @xcite  which include modules written in asp ( the smodels flavor of asp ) . in this sense ,",
    "the embedding of asp within a prolog framework ( as possible in @xmath0 ) allows the programmer to use prolog itself to query the justifications and develop debugging strategies .",
    "we will begin this section with a short description of the system @xmath0 .",
    "the @xmath0  system has been developed using the module and class capabilities of ciao prolog .",
    "@xmath0  allows programmers to develop programs as collections of _",
    "modules_. along with the traditional types of modules supported by ciao prolog ( e.g. , prolog modules , constraint logic programming modules ) , it allows the presence of _ asp modules _ , each being a complete asp program .",
    "each ciao prolog module can access the content of any asp module ( using the traditional module qualification of prolog ) , read its content , access its models , and modify it ( using the traditional assert and retract predicates of prolog ) .",
    "@xmath0  allows us to create prolog modules that access ( and possibly modify ) other modules containing asp code .",
    "for example , the following prolog module    ....     : - use_asp(aspmod , ' asp_module.lp ' ) .",
    "count_p(x ) : -           findall(q , ( aspmod : model(q ) , q : p ) , list ) ,          length(list , x ) . ....",
    "accesses an asp module ( called aspmod ) and defines a predicate ( count_p ) which counts how many answer sets of aspmod contain the atom p. @xmath5    [ [ off - line - justifications ] ] off - line justifications : + + + + + + + + + + + + + + + + + + + + + + + +    the smodels engine has been modified to extract , during the computation , a compact footprint of the execution , i.e. , a trace of the key events ( corresponding to the transitions described in sect .",
    "[ smo ] ) with links to the atoms and rules involved .",
    "the modifications of the trace are trailed to support backtracking .",
    "parts of the justification ( as described in the previous section ) are built on the fly , while others ( e.g. , certain cases of @xmath555 and @xmath556 ) are delayed until the justification is requested .    to avoid imposing the overhead of justification construction on every computation , the programmer has to specify what asp modules require justifications , using an additional argument ( justify ) in the module import declaration : @xmath557).}\\ ] ] figure  [ ovju ] shows a general overview of the implementation of asp justifications in @xmath0 .",
    "each program is composed of ciao prolog modules and asp modules ( each containing rules of the form ( [ rule ] ) , possibly depending on the content of other asp / prolog modules ) .",
    "the implementation of @xmath0 , as described in  @xcite , automatically generates , for each asp module , an _ interface module_which supplies the predicates to access / modify the asp module and its answer sets  and a _",
    "model class_which allows the encoding of each answer set as a ciao prolog object  @xcite .",
    "the novelty is the extension of the model class , to provide access to the justification of the elements in the corresponding answer set .",
    "@xmath0  provides the predicate model/1 to retrieve answer sets of an asp module ",
    "it retrieves them in the order they are computed by smodels , and it returns the current one if the computation is still in progress .",
    "the main predicate to access the justification is justify/1 which retrieves a ciao prolog object containing the justification ; i.e. , @xmath558 will assign to j the object containing the justification relative to the answer set q of the asp module my_asp .",
    "each justification object provides the following predicates :    * just_node/1 which succeeds if the argument is one of the nodes in the justification graph , * just_edge/3 which succeeds if the arguments correspond to the components of one of the edges in the graph , and * justify_draw/1 which will generate a graphical drawing of the justification for the given atom ( using the _ udrawgraph _ application ) .",
    "an example display produced by @xmath0  is shown in figure  [ gf1 ] ; observe that rule names are also displayed to clarify the connection between edges of a justification and the generating program rules .",
    "for example , @xmath559    will collect in l all the edges supporting p in the justification graph ( for answer set q ) .",
    "[ [ on - line - justifications ] ] on - line justifications : + + + + + + + + + + + + + + + + + + + + + + +    the description of smodels on - line justifications we proposed earlier is clearly more abstract than the concrete implementation  e.g .",
    ", we did not address the use of lookahead , the use of heuristics , and other optimizations introduced in smodels .",
    "all these elements have been handled in the current implementation , in the same spirit of what described here .",
    "on - line justifications have been integrated in the @xmath0  system as part of its asp debugging facilities .",
    "the system provides predicates to set breakpoints on the execution of an asp module , triggered by events such as the assignment of a truth value to a certain atom or the creation of a conflicting assignment .",
    "once a breakpoint is encountered , it is possible to visualize the current on - line justification or step through the rest of the execution . off",
    "- line justifications are always available .",
    "the smodels solver is in charge of handling the activities of interrupting and resuming execution , during the computation of an answer set of an asp program .",
    "a synchronous communication is maintained between a prolog module and an asp module  where the prolog module requests and controls the asp execution .",
    "when the asp solver breaks , e.g. , because a breakpoint is encountered , it sends a compact encoding of its internal data structures to the prolog module , which stores it in a asp - solver - state table . if the prolog module requests resumption of the asp execution , it will send back to the solver the desired internal state , that will allow continuation of the execution .",
    "this allows the execution to be restarted from any of a number of desired points ( e.g. , allowing a `` replay''-style of debugging ) and to control different asp modules at the same time .",
    "@xmath0  provides the ability to establish a number of different types of breakpoints on the execution of an asp module .",
    "in particular ,    * break(atom , value ) interrupts the execution when the atom is assigned the given value ; value could true , false or any .",
    "* break(conflict ) interrupts the execution whenever a conflict is encountered during answer set computation . *",
    "break(conflict(atom ) ) interrupts the execution if a conflict involving the atom is encountered . *",
    "break(answer(n ) ) interrupts the execution at the end of the computation of the answer set referred to by the object n.    execution can be restarted using the built - in predicate run ; the partial results of an interrupted computation ( e.g. , the partial answer set , the on - line justification ) can be accessed using the predicates model and justify .",
    "consider the following fragment of a prolog program :    ....      : - module ( p , [ m/0 ] ) .",
    ": - use_asp ( asp , ' myasp.lp ' , justify ) .",
    "m : - asp : break(atom(a , true ) ) ,           asp : run ,           asp : model(q ) ,           q : justify(j ) ,           j : justify_draw(a ) . ....    this will stop the execution of the answer set program myasp.lp whenever the atom a is made true ; at that point , the prolog program shows a graphical representation of the corresponding on - line justification of a. @xmath5      the previous subsection discusses a possible application of the notion of justification developed in this paper , namely the construction of an interactive debugging system for logic programs under the answer set semantics .",
    "it is worth mentioning that the notion of justification is general and can be employed in other applications as well .",
    "we will now briefly discuss other potential uses of this concept .",
    "thanks to their ability to explain the presence and absence of atoms in an answer set , off - line justifications provide a natural solution to problems in the domain of asp - based diagnosis . as in systems like @xcite , off - line justifications can help in discriminating diagnoses .",
    "let us consider , for example , a system composed of two components , @xmath560 and @xmath561 .",
    "let us assume that there is a dependence between these components , stating that if @xmath560 is defective then @xmath561 will be defective as well .",
    "this information can be expressed by the following rule : @xmath562 where @xmath563 ( resp .",
    "@xmath564 ) being true indicates that the component @xmath560 ( resp .",
    "@xmath561 ) is defective at an arbitrary time @xmath565 .    given this rule , @xmath564 ( @xmath566 is defective ) belongs to any answer set which contain @xmath563 ( @xmath567 is defective ) .",
    "thus , any off - line justification for @xmath568 can be extended to an off - line justification for @xmath569 by adding a positive edge from @xmath569 to @xmath568 .",
    "this is another argument , besides the minimality criteria , for preferring the diagnosis @xmath570 over @xmath571 .",
    "the implemented system for on - line justification in this paper can be adapted to create a direct implementation of the cr - prolog @xcite .",
    "currently , a generate - and - test front - end to smodels is provided for computing answer sets of cr - prolog programs .",
    "more precisely , the algorithm for computing the answer sets of a cr - prolog program @xmath1 , whose set of normal rules is @xmath124 , iterates through two steps until an answer set is found . in each iteration , a minimal set of cr - rules",
    "is selected randomly ( or according to some preferences ) , activated ( i.e. , converted to normal rules ) and added to @xmath124 to create a new program @xmath572 .",
    "the answer sets of @xmath572 are computed using smodels .",
    "if any answer set is found , then the computation stops .",
    "this implementation does not make use of any information about possible conflicts or inconsistencies that can be recognized during the computation .",
    "a more effective implementation can be achieved by collecting on - line justifications during each cycle of execution of smodels .",
    "the on - line justifications can be traversed to identify inconsistencies and identify rules outside of @xmath124 that unavoidably conflict with rules in @xmath124 .",
    "such knowledge can then be employed to suggest more effective selections of cr - rules to be activated .",
    "consider the following simple cr - prolog program @xmath573 in this case , the set of normal rules @xmath124 contains the two rules @xmath50 and @xmath574 , and @xmath124 does not admit a ( consistent ) answer set .",
    "the point of conflict is characterized by the on - line justification shown in figure  [ cr1 ] .",
    "the conflict is clearly represented by the presence of justifications for @xmath131 and @xmath575 ; the justification also highlights that the only way of defeating the conflict is to remove the positive edge between @xmath576 and @xmath131 .",
    "this suggests the need of introducing a cr - rule that has @xmath154 as head , i.e. , rule @xmath48 .",
    "simple @xmath0  meta - interpreters can be introduced to detect this type of situations and suggest some consistency restoring rules to be used ; e.g. , given the partial answer set @xmath120 present at the time of conflict , we can use the following clause to resolve conflicts due to atoms of the type @xmath489 and @xmath577 both being true : @xmath578 where reachable performs a simple transitive closure over the edges of the justification @xmath75 .",
    "various approaches to logic program understanding and debugging have been investigated ( and a thorough comparison is beyond the limited space of this paper ) . early work in this direction geared towards the understanding of prolog programs rather than logic programs under the answer set semantics . only recently",
    ", we can find some work on debugging inconsistent programs or providing explanation for the presence ( or absence ) of an atom in an answer set .",
    "while our notion of justification is related to the research aimed at debugging prolog and xsb programs , its initial implementation is related to the recent attempts in debugging logic programs under the answer set semantics .",
    "we will discuss each of these issues in each subsection .      as discussed in @xcite , @xmath579 main phases",
    "can be considered in understanding / debugging a logic program :    * _ program instrumentation and execution : _ assertion - based debugging ( e.g. , @xcite ) and algorithmic debugging @xcite are examples of approaches focused on this first phase . * _ data collection : _ focuses on _ extracting _ from the execution data necessary to understand it , as in event - based debugging @xcite , tracing , and explanation - based debugging @xcite .",
    "* _ data analysis : _ focuses on reasoning on data collected during the execution .",
    "the proposals dealing with automated debugging ( e.g. , @xcite ) and execution visualization ( e.g. , @xcite ) are approaches focusing on this phase of program understanding .",
    "the notion of _ justification _ has been introduced in @xcite to support understanding and debugging of logic programs .",
    "justification is the process of generating evidence , in terms of high - level proofs based on the answers ( or models ) produced during the computation .",
    "justifications are _ focused _ ,",
    "i.e. , they provide only the information that are relevant to the item being explained  and this separates them from other debugging schemes ( e.g. , tracing ) .",
    "justification plays an important role in manual and automatic verification , by providing a _ proof description _ if a given property holds ; otherwise , it generates a _",
    "counter - example _ , showing where the violation / conflict occurs in the system .",
    "the justification - based approach focuses on the last two phases of debugging  collecting data from the execution and presenting them in a meaningful manner . differently from generic tracing and algorithmic",
    "debugging , justifications are focused only on parts of the computation relevant to the justified item .",
    "justifications are fully automated and do not require user interaction ( as in declarative debugging ) .",
    "justifications relies on describing the evidence for an answer in terms of a graph structure .",
    "the term _ justification _ was introduced in @xcite , as a data structure to explain answers to prolog queries within a prolog system with tabling . the notion of justification and its implementation in the xsb prolog system",
    "was successively refined in  @xcite .",
    "similar structures have been suggested to address the needs of other flavors of logic programming  e.g .",
    ", various approaches to tree - based explanation for deductive databases ( e.g. , the _ explain _ system  @xcite , the explanation system for lola  @xcite , and the ddb trees method  @xcite ) .",
    "similar methods have also been developed for the analysis of clp programs ( e.g. ,  @xcite ) .    in this work ,",
    "we rely on graph structures as a mean to describe the _ justifications _ that are generated during the generation ( or from ) an answer set of a program .",
    "graphs have been used in the context of logic programming for a variety of other applications .",
    "_ call graphs _ and _ dependence graphs _ have been extensively used to profile and discover program properties ( e.g. ,  @xcite ) . _ support graphs",
    "_ are used for program analysis in @xcite .",
    "the use of graphs proposed in this paper is complementary to the view proposed by other authors , who use graph structures as a mean to describe answer set programs , to make structural properties explicit , and to support the development of the program execution . in  @xcite ,",
    "_ rule dependency graphs",
    "_ ( a.k.a . _ block graphs _ ) of answer set programs",
    "are employed to model the computation of answer sets as special forms of graph coloring . a comprehensive survey of alternative graph representations of answer set programs , and their properties with respect to the problem of answer set characterization , has been presented in  @xcite . in particular ,",
    "the authors provide characterizations of desirable graph representations , relating the existence of answer sets to the presence of cycles and the use of coloring to characterize properties of programs ( e.g. , consistency ) .",
    "we conjuncture that the outcome of a successful coloring of an edg  @xcite to represent one answer set can be projected , modulo non - obvious transformations , to an off - line graph and vice versa . on the other hand , the notion of on - line justification does not seem to have a direct relation to the graph representations presented in the cited works .",
    "this paper continues the work initiated in  @xcite , by proposing a more advanced and sound notion of off - line justification , by developing the concept of on - line justification , and introducing these concepts in smodels .",
    "the approach differs significantly from the recently introduced approach to debugging asp programs in @xcite while our approach relies on the notion of justification , the approach in @xcite uses the tagging technique @xcite to compile a program into a new program whose answer sets can be used to debug the original program . inspecting an answer set of the new program can reveal the rules which have been applied in its generation .",
    "it does not , however , provides explanation of why an atom does ( or does not ) belong to the answer set . in this sense , we can say that the approach of @xcite and ours are complementary to each other .",
    "an advantage of the approach in @xcite is that it enables the development of a debugger as a front - end of an answer set solver .",
    "however , their approach does not consider on - line justification .    at this point , it is worth mentioning that the @xmath0  debugger , described in section [ smo ] , differs from the system spock @xcite  which was developed based on the technical foundation in @xcite  in several aspects . in our system , the justification for the truth value of an atom consists of facts , assumptions , and rules which are applicable given these facts and assumptions , i.e. , we not only justify why an atom is _ true _ but also why an atom is _",
    "false_. moreover , justifications can be queried during the process of answer set computation .",
    "spock only provides the justification , or the applicable rules , for the presence of an atom in a given answer set . in this sense , justifications in spock is similar to our off - line lces .    in @xcite ,",
    "a tool for developing and testing dlv programs was described .",
    "the commands provided by this tool allow an user to inspect why an atom is true in the current model and why there is no answer set .",
    "this is similar to the on - line justifications developed for smodels .",
    "the tool in @xcite , however , does not answer the question why an atom is not in the current model .",
    "the notion of justifications is not developed in @xcite .",
    "the proposed debugger is similar to the system described in @xcite in that it provides the users with the information on why some atoms occur in an answer set and some others do not .",
    "an explanation given by the tool described in this work is similar to an off - line justification in our work .",
    "our implementation also provides users with on - line justifications but the system described in @xcite does not .",
    "the paper @xcite presents a theory for debugging of inconsistent programs and an implementation of this theory .",
    "the focus of this paper is on inconsistent programs .",
    "on the other hand , our focus is not solely on inconsistent programs .",
    "our notion of on - line justification can be used in identifying the reasons that lead to the inconsistency of the problem but it is significant different from the theory of diagnosis developed in @xcite .",
    "in this paper we provided a generalization of the notion of _ justification _ ( originally designed for prolog with slg - resolution @xcite ) , to suit the needs of asp . the notion , named _ off - line justification _ , offers a way to understand the motivations for the truth value of an atom within a specific answer set , thus making it easy to analyze answer sets for program understanding and debugging .",
    "we also introduced _ on - line justifications _ , which are meant to justify atoms _ during _ the computation of an answer set .",
    "the structure of an on - line justification is tied to the specific steps performed by a computational model for asp ( specifically , the computation model adopted by smodels ) .",
    "an on - line justification allows a programmer to inspect the reasons for the truth value of an atom at the moment such value is determined while constructing an answer set .",
    "these data structures provide a foundation for the construction of tools to understand and debug asp programs .",
    "the process of computing and presenting justifications has been embedded in the asp - prolog system  @xcite , thus making justifications a first - class citizen of the language .",
    "this allows the programmer to use prolog to manipulate justifications as standard prolog terms .",
    "a prototype implementation has been completed and is currently under testing . as future work",
    ", we propose to complete the implementation , refine the definition of on - line justification to better take advantage of the smodels mechanisms , and develop a complete debugging and visualization environment for asp based on these data structures .",
    "* acknowledgement * : we would like to thank the anonymous reviewers for their comments and suggestions that help improve the papers in many ways .",
    "the authors are partially supported by nsf grants cns-0220590 , hrd-0420407 , and iis-0812267 .    ,",
    "gebser , m. , linke , t. , neumann , a. , and schaub , t. 2005 . the nomore++ approach to answer set solving . in _ proceedings of the 12th international conference on logic for programming , artificial intelligence , and reasoning_. 95109 .",
    "logic programming and negation : a survey .",
    "_ 19,20 _ , 971 .    , ramakrishnan , r. , roth , w. , seshadri , p. , and drivastava , d. 1993 .",
    ". in _ proceedings of the dood conference_. springer verlag",
    ".    \\2000 .",
    "assertion checker for the c programming language based on computations over event traces . in _",
    "aadebug_.    \\2007 .",
    "cr - models : an inference engine for cr - prolog . in _ lpnmr _ , c.  baral , g.  brewka , and j.  s. schlipf , eds .",
    "lecture notes in computer science , vol . 4483 .",
    "springer , 1830 .",
    "\\2003 . .",
    "_ 3 , _  4,5 , 425461 .    ,",
    "gelfond , m. , and nogueira , m. 2006 . .    . .",
    "in _ answer set programming : advances in theory and implementation _ , m.  d. vos and a.  provetti , eds .",
    "142152 .    ,",
    "gebser , m. , phrer , j. , schaub , t. , tompits , h. , and woltran , s. 2007a .",
    "debugging asp programs by means of asp . in _ proceedings of the ninth international conference on logic programming and nonmonotonic reasoning ( lpnmr07 ) _ , c.  baral , g.  brewka , and j.  schlipf , eds .",
    "lecture notes in artificial intelligence , vol . 4483 .",
    "springer - verlag , 3143 .    ,",
    "gebser , m. , phrer , j. , schaub , t. , tompits , h. , and woltran , s. 2007b .",
    "hat is illogical captain ! \" ",
    "the debugging support tool spock for answer - set programs : system description . in _ proceedings of the workshop on software engineering for answer set programming ( sea07 ) _ , m.  de vos and t.  schaub , eds .",
    "7185 .    ,",
    "dix , j. , freitag , b. , and zukowski , u. 2001 .",
    "transformation - based bottom - up computation of the well - founded model .",
    "_ 1 , _  5 , 497538 .",
    "in _ answer set programming workshop_.    , dantona , o.  m. , and provetti , a. 2002 . on the equivalence and range of applicability of graph - based representations of logic programs .  _ 84 ,",
    "_  5 , 241249 .    ,",
    "logemann , g. , and loveland , d.  w. 1962 . a machine program for theorem - proving .",
    "_ 5 , _  7 , 394397 .    , lopez - garcia , p. , hermenegildo , m. , and lin , n. 1997 .",
    ". in _ international logic programming symposium_. mit press , 291305",
    ".    , schaub , t. , and tompits , h. 2003 . a framework for compiling preferences in logic programs .",
    "_ 3 , _  2 ( mar . ) , 129187 .    , hermenegildo , m.  v. , and maluszynski , j. , eds",
    "lecture notes in computer science , vol . 1870 .",
    "springer .",
    "opium : an extendable trace analyzer for prolog .",
    "_ 39 , _  1 - 3 , 177223 .    ,",
    "leone , n. , mateis , c. , pfeifer , g. , and scarcello , f. 1998 . .",
    "in _ international conference on principles of knowledge representation and reasoning_. 406417 .    , pontelli , e. , and son , t.  c. 2005 . justification and debugging of",
    "answer set programs in asp . in _ proceedings of the sixth international workshop on automated debugging , aadebug 2005 , monterey , california ,",
    "usa , september 19 - 21 , 2005 _ , c.  jeffery , j .- d .",
    "choi , and r.  lencevicius , eds .",
    "acm , 4958 .    ,",
    "pontelli , e. , and son , t. 2004 . .",
    "in _ proceedings of the sixth international symposium on practical aspects of declarative languages ( padl-2004)_. springer , 148162 .    , lifschitz , v. , and ringe , d. 2006 .",
    "temporal phylogenetic networks and logic programming .",
    "_ 6 , _  5 , 539558 .",
    "consistency of clark s completion and existence of stable models .  1 , 5160 .    ,",
    "kaufmann , b. , neumann , a. , and schaub , t. 2007 .",
    "clasp : a conflict - driven answer set solver . in _ proceedings of the ninth international conference on logic programming and nonmonotonic reasoning ( lpnmr07 ) _ , c.  baral , g.  brewka , and j.  schlipf , eds .",
    "lecture notes in artificial intelligence , vol . 4483 .",
    "springer - verlag , 260265 .    , schaub , t. , and thiele , s. 2007 .",
    "gringo : a new grounder for answer set programming . in _ proceedings of the ninth international conference on logic programming and nonmonotonic reasoning ( lpnmr07 ) _ , c.  baral , g.  brewka , and j.  schlipf , eds .",
    "lecture notes in artificial intelligence , vol . 4483 .",
    "springer - verlag , 266271 .",
    "logic programming and knowledge representation  the a - prolog perspective .",
    "_ 138 , _  1 - 2 , 338 .",
    "the stable model semantics for logic programming . in _ logic programming : proceedings  of the fifth international conf .  and symp .",
    "_ , r.  kowalski and k.  bowen , eds .",
    "10701080 .    , lierler , y. , and maratea , m. 2004 .",
    "sat - based answer set programming . in _ proceedings of the nineteenth national conference on artificial intelligence ,",
    "sixteenth conference on innovative applications of artificial intelligence , july 25 - 29 , 2004 , san jose , california , usa_. aaai press / the mit press , 6166 .    \\2005 . in _ logic programming ,",
    "21st international conference , iclp 2005 , sitges , spain , october 2 - 5 , 2005 , proceedings _",
    ", m.  gabbrielli and g.  gupta , eds .",
    "lecture notes in computer science , vol . 3668 .",
    "springer , 3751 .",
    "\\2000 . a new module system for prolog . in _ computational logic - cl 2000 , first international conference , london , uk , 24 - 28 july , 2000 , proceedings _ , j.  w. lloyd , v.  dahl , u.  furbach , m.  kerber , k .- k .",
    "lau , c.  palamidessi , l.  m. pereira , y.  sagiv , and p.  j. stuckey , eds .",
    "lecture notes in computer science , vol . 1861 .",
    "springer , 131148 .    ,",
    "ramakrishnan , c. , and ramakrishnan , i. 2001 . .",
    "in _ international conference on logic programming_. springer verlag , 150165 .",
    "\\2003 . bounded ltl model checking with stable models .",
    "_ 3 , _  4,5 , 519550 .    ,",
    "linke , t. , and schaub , t. 2006 . .",
    "_ 6 , _  12 , 61106 .",
    "answer set planning . in _ international conference on logic programming_. 2337 .",
    "\\2002 . .",
    "_ 138 , _  12 , 3954 .",
    "112117 .",
    "springer verlag .",
    "second , extended edition .",
    "generating deductive database explanations . in _ international conference on logic programming_. 154168 .",
    "stable models and an alternative logic programming paradigm . in _ the logic programming paradigm : a 25-year perspective_. 375398 .    , lopez - garcia , p. , puebla , g. , carro , m. , and hermenegildo , m. 2006 . .",
    "in _ international conference on logic programming_. springer verlag , 431432 .",
    "logic programming with stable model semantics as a constraint programming paradigm .",
    "_ 25 , _  3,4 , 241273",
    ".    \\1997 .",
    "- an implementation of the stable model and well - founded semantics for normal logic programs . in _ proceedings of iclp & lpnmr_. 420429 .    ,",
    "guo , h .- f . ,",
    "dong , y. , ramakrishnan , c.  r. , and ramakrishnan , i.  v. 2004 .",
    "online justification for tabled logic programs . in _ functional and logic programming , 7th international symposium , flops 2004 , nara , japan , april 7 - 9 , 2004 , proceedings _ ,",
    "y.  kameyama and p.  j. stuckey , eds .",
    "lecture notes in computer science , vol . 2998 .",
    "springer , 2438 .    ,",
    "ricca , f. , terracina , g. , cianni , d. , and veltri , p. 2007 . .",
    "in _ proceedings of the 1st sea workshop , lpnmr07_. 86100 .    \\1999 . .",
    "clip 6/99.0 , upm madrid .    ,",
    "bueno , f. , and hermenegildo , m.  v. 1998 .",
    "a framework for assertion - based debugging in constraint logic programming . in _ principles and practice of constraint programming - cp98 , 4th international conference , pisa , italy , october 26 - 30 , 1998 , proceedings _",
    ", m.  j. maher and j .- f .",
    "puget , eds .",
    "lecture notes in computer science , vol . 1520 .",
    "springer , 472 .    , ramakrishnan , c.  r. , and ramakrishnan , i.  v. 2000 .",
    "justifying proofs using memo tables . in _",
    ".    \\2005 .",
    "symbolic support graph : a space efficient data structure for incremental tabled evaluation . in _ logic programming ,",
    "21st international conference , iclp 2005 , sitges , spain , october 2 - 5 , 2005 , proceedings _ , m.  gabbrielli and g.  gupta , eds .",
    "lecture notes in computer science , vol . 3668 .",
    "springer , 235249 .",
    "algorithmic program diagnosis . in _",
    "popl_. 299308 .    ,",
    "niemel , n. , and soininen , t. 2002 . .",
    "_ 138 , _  12 , 181234 .",
    "generating explanation trees even for negations in deductive database systems . in _",
    "lpe_. 813 .",
    "debugging inconsistent answer set programs . in",
    "_ proceedings of the 11th international workshop on non - monotonic reasoning_. lake district , uk , 7784 .",
    "the semantics of predicate logic as a programming language .",
    "_ 23 , _  4 , 733742 .    ,",
    "ross , k. , and schlipf , j. 1991 . the well - founded semantics for general logic programs .",
    "_ 38 , _  3 , 620650 .    ,",
    "pontelli , e. , and gupta , g. 1997 .",
    "visualization of and / or - parallel execution of logic programs . in _",
    "iclp_. 271285 .",
    "let @xmath582 denote the traditional immediate consequence operator for a definite program @xmath583 @xcite .",
    "we will also make use of the usual notations such as @xmath584 , @xmath585 .",
    "given a program @xmath1 and one of its answer sets @xmath120 , to simplify the presentation , let us denote with @xmath586 the negative reduct @xmath587 .",
    "we will denote with @xmath588 the pair @xmath589 ( definition [ kui ] ) for the original program @xmath1 and with @xmath590 the pair @xmath589 for program @xmath586 respectively .",
    "let us prove , by induction on @xmath594 , that @xmath595 .",
    "the result is trivial for the base case .",
    "let us assume that the result holds for @xmath594 and let us prove it for @xmath596 .",
    "consider @xmath597 .",
    "this means that there is a rule @xmath598 such that @xmath73 and @xmath599 . since @xmath600 , we know that @xmath601 and therefore @xmath602 .",
    "thus , thanks to the inductive hypothesis , we can conclude that @xmath603 .",
    "@xmath5          * base : * the result is obvious for @xmath607 , since @xmath608 let @xmath609 .",
    "this implies that there is @xmath610 such that @xmath73 , @xmath611 , and @xmath612 . since @xmath613",
    ", we also have that @xmath72 .",
    "furthermore , since @xmath604 ( from corollary  [ co1 ] ) , we have that @xmath614 .",
    "* step : * let us assume the result to hold for @xmath594 and let us consider the iteration @xmath596 .",
    "let @xmath628 .",
    "this implies that there is a rule @xmath72 such that @xmath73 , @xmath629 , and @xmath623 . since @xmath624",
    ", we have that @xmath625 , thus @xmath610 .",
    "furthermore , since @xmath605 , we have that @xmath626 , and from the inductive hypothesis we have that @xmath630 . thus @xmath631 . @xmath5",
    "* * base : * let @xmath635 .",
    "this implies that there is a rule @xmath72 such that @xmath73 , @xmath611 , and @xmath636 . since @xmath637",
    ", we have that @xmath638 , and thus @xmath610 .",
    "furthermore , since @xmath639 , we have that @xmath640 .",
    "hence , @xmath641 . * * step : * let us assume the result to hold for @xmath101 and let us prove it for @xmath642 .",
    "let @xmath643 .",
    "this implies that there is a rule @xmath72 such that * * @xmath73 , * * @xmath644 , and * * @xmath636 . + since @xmath637 , we have that @xmath638 , and thus @xmath610 .",
    "furthermore , since @xmath639 , we have that @xmath640 . by inductive hypothesis ,",
    "we have that @xmath645 .",
    "hence , @xmath646 .      *",
    "* base : * let @xmath648 .",
    "this implies that there is a rule @xmath610 such that @xmath73 , @xmath611 , and @xmath649 . since @xmath613",
    ", we have that @xmath72 .",
    "furthermore , since @xmath650 , we have that @xmath651 . hence , @xmath652 . * * step : * let us assume the result to hold for @xmath101 and let us consider the case @xmath642 .",
    "let @xmath653 .",
    "this implies that there is a rule @xmath610 such that @xmath73 , @xmath654 , and @xmath649 . since @xmath613",
    ", we have that @xmath72 .",
    "furthermore , since @xmath650 , we have that @xmath651 . by inductive hypothesis , we also have that @xmath655 .",
    "hence , @xmath656 .                      * proof . * from proposition [ sequence ] , we have that @xmath673 and @xmath674 . furthermore , since @xmath668 , we can conclude that @xmath675 .",
    "since @xmath120 is an answer set of @xmath586 , we also have that @xmath676 .",
    "thus , @xmath677 .",
    "this conclusion implies that there is a value @xmath678 such that @xmath679 .",
    "* base : * let @xmath661 .",
    "this implies that there is a rule @xmath72 such that @xmath73 , @xmath611 , and @xmath662 . since @xmath601",
    ", we have that @xmath610 .",
    "furthermore , since @xmath679 and @xmath662 , we have that @xmath683 .",
    "thus , @xmath684 .",
    "* step : * let @xmath664 .",
    "this implies that there is a rule @xmath72 such that @xmath73 , @xmath665 , and @xmath662 . since @xmath601",
    ", we have that @xmath610 .",
    "furthermore , since @xmath679 and @xmath662 , we have that @xmath683 . by inductive hypothesis , we also have that @xmath685 .",
    "thus , @xmath686 .",
    "@xmath5      the proof of this lemma makes use of several results and definitions in @xcite . for this reason ,",
    "let us recall the necessary definitions from @xcite . given a program @xmath1 ,",
    "let us denote with @xmath687 and with @xmath688 . we can consider the following program transformations  @xcite :    * @xmath689 iff @xmath690 , @xmath691 , @xmath692 , and + @xmath693 * @xmath694 iff @xmath690 , @xmath691 , @xmath695 , and + @xmath696 * @xmath697",
    "iff @xmath690 , @xmath698 , @xmath699 , and + @xmath700 * @xmath701 iff @xmath690 , @xmath698 , @xmath702 , and + @xmath696 * @xmath703 iff there is a non - empty set of atoms @xmath68 such that * * for each rule @xmath704 in @xmath46 where @xmath705 we have that @xmath706 * * @xmath707 * * @xmath708    we write @xmath709 to indicate that there exists a transformation @xmath710 such that @xmath711 .",
    "a program @xmath1 is _ irreducible _ if @xmath712 for every @xmath713 .",
    "the results in @xcite show that the above transformation system is terminating and confluent , i.e. , given a program @xmath1 , ( a ) there exists a sequence of programs @xmath714 such that @xmath715 for @xmath716 and @xmath717 is irreducible ; and ( b ) for every sequence of programs @xmath718 such that @xmath719 for @xmath720 and @xmath721 is irreducible then @xmath722 .",
    "we call the irreducible program @xmath717 obtained from @xmath1 through this transformation system the normal form of @xmath1 .",
    "the result in @xcite shows that the well - founded model @xmath723 of @xmath1 can be obtained by @xmath724 where @xmath717 is the normal form of @xmath1 .",
    "_ lemma [ good ] .",
    "_ let @xmath1 be a program , @xmath120 an answer set , and @xmath250 the well - founded model of @xmath1 .",
    "each atom @xmath296 has an off - line justification w.r.t . @xmath120 and @xmath231 which does not contain any negative cycle .",
    "* proof : * let us consider the sequence of transformations of the program @xmath725 such that the transformation @xmath726 is used only when no other transformation can be applied .",
    "furthermore , let @xmath727 we wish to prove , by induction on @xmath594 , that if @xmath728 then it has a justification which is free of negative cycles and it contains exclusively elements in @xmath729 . for the sake of simplicity , we will describe justification graphs simply as set of edges . also , we will denote with @xmath730 the graph created for the element @xmath23 .",
    "* @xmath732 .",
    "this means that @xmath733 .",
    "this implies that @xmath734 is a cycle - free justification for @xmath23 w.r.t .",
    "@xmath735 and @xmath231 .",
    "* @xmath736 .",
    "this means that @xmath737 . from the definition of off - line justification",
    ", this means that we can build the justification @xmath738 , which is also cycle - free .",
    "in addition , the only atoms in the justification belongs to @xmath739 .",
    "* @xmath742 . without loss of generality",
    ", we can assume that @xmath743 .",
    "this means that the reduction step taken to construct @xmath744 from @xmath745 produced a fact of the form @xmath746 .",
    "this implies that there exists a rule @xmath747 in @xmath1 such that each @xmath748 has been removed in the previous steps by @xmath749 transformations , and each @xmath750 has been removed by @xmath751 transformations .",
    "this means that each @xmath752 , each @xmath753 , and , by inductive hypothesis , they admit justifications free of negative cycles .",
    "we can construct a justification @xmath730 for @xmath23 , which is free of negative cycles and is the union of all the justifications free of negative cycles of @xmath754 and the edges @xmath755 .",
    "note that , with the exception of @xmath23 , the atoms involved in the justification @xmath730 are only atoms of @xmath756 . *",
    "let us now consider @xmath757 .",
    "again , we assume that @xmath758 .",
    "this means that in @xmath744 there are no rules left for @xmath23 .",
    "let us consider each individual rule for @xmath23 in @xmath1 , of the generic form @xmath759 we consider two cases : * * @xmath760 or @xmath761 . by our assumption about the sequence of transformations , we can conclude that the transformation @xmath726 has not been applied in removing rules whose head is @xmath23 . in other words ,",
    "each rule ( [ generic ] ) has been removed by either a @xmath762 or a @xmath763 transformation .",
    "this implies that for each rule ( [ generic ] ) , there exists either a @xmath764 or a @xmath765 , i.e. , there exists @xmath766 and @xmath767 such that for each rule @xmath25 with @xmath408 , @xmath768 or @xmath769 . without loss of generality , we can assume that @xmath770 and @xmath771 are minimal ( w.r.t .",
    "@xmath772 ) . by inductive hypothesis , we know that each element in @xmath770 and @xmath771 posses a justification free of negative cycles which contain only atoms in @xmath773 .",
    "similar to the first item , we have that @xmath774 is a justification free of negative cycles for @xmath23 which , with the exception of @xmath132 , contains only atoms in @xmath773 . *",
    "* @xmath775 .",
    "the fact that @xmath776 indicates that all rules with @xmath23 as head have been removed . in this case",
    ", there might be some rules with @xmath23 as its head that have been removed by other transformations .",
    "let @xmath777 ( resp .",
    "@xmath778 ) be the set of rules , whose head is @xmath23 , which are removed by a transformation @xmath763 or @xmath762 ( resp .",
    "@xmath726 ) .",
    "+ let @xmath68 be the set of atoms employed for the @xmath726 step ( i.e. , the @xmath594-th step ) .",
    "let @xmath779 be an enumeration of @xmath68 .",
    "for a subset @xmath780 of @xmath68 , let @xmath781 denote the element in @xmath780 with the smallest index according to the above enumeration .",
    "+ let @xmath782 + because of the finiteness of @xmath68 , there exists some @xmath101 such that @xmath783 .",
    "let be the graph @xmath784 .",
    "because of the property of @xmath68 , it is easy to see that for each atom @xmath238 in the graph @xmath168 , @xmath237 is a lce of @xmath238 w.r.t .",
    "@xmath773 and @xmath231 ( w.r.t .",
    "the program @xmath745 ) .",
    "thus , we have that @xmath168 is an off - line justification for @xmath23 in @xmath745 .",
    "furthermore , it contains only positive cycles and it is composed of atoms from @xmath785 .",
    "+ the construction of @xmath168 takes care of rules of the form ( [ generic ] ) , which belong to @xmath778 .",
    "similar to the previous case , we know that for each atom @xmath154 such that @xmath189 is a node in @xmath168 , there exists @xmath786 and @xmath787 such that for each rule @xmath25 with @xmath185 in @xmath788 , @xmath789 or @xmath790",
    ". @xmath168 can be extended to an off - line justification of @xmath23 by adding to its the justifications of other atoms that falsify the rules in @xmath788 for every @xmath791 .",
    "more precisely , for each atom @xmath154 such that @xmath189 is a node in @xmath168 , let @xmath792 note that @xmath793 in the above equation exists due to the inductive hypothesis .",
    "furthermore , each @xmath794 contains only atoms in @xmath773 with the exception of @xmath154 and therefore can not contain negative cycles .",
    "thus , @xmath795 does not contain negative cycles .",
    "it is easy to check that @xmath796 is a lce of @xmath238 in @xmath1 w.r.t . @xmath797 and @xmath231 .",
    "thus , @xmath798 is an off - line justification for @xmath23 in @xmath1 w.r.t . @xmath797 and @xmath231 .",
    "+ let us now extend this into a justification for @xmath23 in @xmath1 .",
    "let us define : @xmath799 + the elements added in @xmath800 corresponds to the justifications for the rules for the atoms of @xmath168 that have been removed before @xmath801by inductive hypothesis all these have justifications that are free of recursive cycles , and they can be safely added to @xmath168 .        _",
    "proposition [ propimp ] .",
    "_ let @xmath1 be a program and @xmath120 an answer set . for each atom @xmath23",
    ", there is an off - line justification w.r.t . @xmath120 and @xmath254 which does not contain negative cycles .",
    "* proof : * the result is trivial , since all the elements in @xmath254 are immediately set to false , and @xmath266 has a well - founded model equal to @xmath120 ( and thus all elements have justifications free of negative cycles , from lemma  [ good ] ) . @xmath5      the proof of this proposition will develop through a number of intermediate steps . let us start by introducing some notation . given a program @xmath1 and given the herbrand universe @xmath45 , let @xmath802 .",
    "furthermore , for two sets of atoms @xmath803 such that @xmath804 , we define a program transformation @xmath805 as follows .",
    "the program @xmath806 , obtained from @xmath1 by    * removing @xmath25 from @xmath1 if @xmath807 or @xmath808 ( remove rules that are inapplicable w.r.t .",
    "@xmath809 ) .",
    "* replacing each remaining rule @xmath25 with @xmath810 where @xmath811 , @xmath812 , and @xmath813 ( normalize the body of the rules w.r.t .",
    "@xmath809 )        [ l1 ] let @xmath1 be a program @xmath319 and @xmath320 be two sets of atoms such that @xmath815 , @xmath816 where @xmath817 and @xmath818 is a sequence of sets of atoms such that @xmath819 for @xmath820 .",
    "it holds that if @xmath821 then there exists a sequence of basic transformations @xmath822 where @xmath823 ( see the proof of lemma  [ good ] for the definition of these transformations ) .      1 .",
    "since @xmath319 is a set of facts , we can repeatedly apply the @xmath762 and @xmath749 transformations to @xmath1 .",
    "the result is a program @xmath46 with the following properties : for every @xmath826 , there exists some @xmath827 with @xmath828 1 .",
    "@xmath829 2 .",
    "@xmath830 and 3 .",
    "since @xmath780 is a set of atoms with no rules in @xmath46 , we can repeatedly apply the @xmath751 and @xmath763 transformations to @xmath46 for the atoms belonging to @xmath780 .",
    "the result is a program @xmath832 with the following properties : for every @xmath833 , there exists some @xmath834 with @xmath835 and 1 .",
    "@xmath836 2 .",
    "@xmath830 and 3 .",
    "since @xmath838 is a set of atoms with cycles , we can apply the loop detection transformation @xmath726 for each of the loops in @xmath838 to @xmath832 ; thus , we obtain @xmath839 .",
    "since atoms in @xmath838 will no longer have defining rules in @xmath840 , the transformations for atoms in @xmath838 ( similar to those for atoms in @xmath780 ) can be applied to @xmath840 ; the result is the program @xmath841 with the property : for every @xmath842 , there exists some @xmath843 with @xmath844 and 1 .",
    "@xmath836 2 .",
    "@xmath830 and 3 .",
    "@xmath845 .                    1 .",
    "the first property holds because of the construction of @xmath745 and the definitions of @xmath858 and @xmath859 .",
    "2 .   consider some @xmath860 . by the definition of @xmath744",
    ", there exists some rule @xmath861 such that * @xmath73 , * @xmath862 , * @xmath863 , * @xmath864 , and * @xmath865 . +",
    "this implies that @xmath866 and @xmath867 , i.e. , @xmath868 .",
    "this proves the equality of the second item .",
    "3 .   consider some @xmath869 .",
    "this means that every rule of @xmath745 having @xmath23 in the head has been removed ; i.e. , for every @xmath861 with @xmath73 , we have that * @xmath870 or * @xmath871 . +",
    "this implies that @xmath872 , which allows us to conclude the third property .                  1 .",
    "* base : * @xmath607 .",
    "this step is obvious , since @xmath886 .",
    "* step : * let @xmath887 and @xmath888 . from the inductive hypothesis",
    ", we can conclude that @xmath889 .",
    "this result , together with the fact that , for any rule @xmath25 , @xmath890 implies @xmath891 , allows us to conclude that @xmath892 .",
    "similarly , from the fact that @xmath893 and the inductive hypothesis , we can show that @xmath894 .",
    "* let us prove this lemma by contradiction .",
    "let @xmath896 .",
    "first , lemma [ l4 ] and [ prop - wfs ] imply that @xmath897 .",
    "since @xmath120 is an answer set of @xmath1 , there exists some level mapping @xmath898 such that @xmath120 is a _",
    "well - supported model _",
    "@xmath898 @xcite , i.e. , for each @xmath601 there exists a rule @xmath899 satisfying the following conditions :        * * case 1 : * @xmath905 .",
    "consider @xmath906 such that @xmath907 .",
    "there exists a rule @xmath25 such that @xmath73 , @xmath25 is supported by @xmath120 , and @xmath903 for each @xmath526 .",
    "the minimality of @xmath908 implies that @xmath909 .",
    "the fact that @xmath910 implies that @xmath911 .",
    "consider some @xmath912 .",
    "clearly , @xmath913otherwise , it would belong to @xmath315 .",
    "this implies that @xmath914 because @xmath915 .",
    "hence , @xmath916 .",
    "this represents a contradiction . *",
    "* case 2 : * @xmath917 .",
    "consider @xmath918 .",
    "this is possible only if there exists some rule @xmath25 such that * * @xmath73 , * * @xmath919 , * * @xmath920 , and * * either 1 .",
    "@xmath921 , or 2 .",
    "+ in what follows , by @xmath923 we denote the set of rules in @xmath1 whose head is @xmath23 and whose bodies are neither true nor false in @xmath75 .",
    "+ if ( i ) is true , then there exists some @xmath924 . since @xmath528 , we have that @xmath925 .",
    "this implies that @xmath926 or @xmath927 .",
    "the second case can not happen since @xmath928 ( lemma [ l4 ] ) .",
    "so , we must have that @xmath926 .",
    "this means that @xmath929 ( since @xmath120 is an answer set , and thus a complete interpretation ) , and hence , @xmath181 ( case 1 ) .",
    "this contradicts the fact that @xmath920 .",
    "therefore , we conclude that ( i ) can not happen . + since ( i ) is not true , we can conclude that @xmath930 and for every @xmath931 and @xmath932 , @xmath933 and @xmath934 .",
    "let us consider the following sequence : @xmath935 let @xmath936 .",
    "it is easy to see that for each @xmath937 , it holds that @xmath938 , @xmath939 , and for each @xmath940 , @xmath941 .",
    "this means that @xmath942 .",
    "this is a contradiction with @xmath943 . @xmath5",
    "* @xmath319 and @xmath320 maintains the consistency of @xmath75 , i.e. , if @xmath75 is an interpretation , then @xmath346 is also an interpretation ; * @xmath319 and @xmath320 are monotone w.r.t the argument @xmath75 , i.e. , if @xmath347 then @xmath348 and @xmath349 ; * @xmath350 and @xmath351 ; and * if @xmath120 is an answer set of @xmath1 , then @xmath352 and @xmath353 .      1",
    ".   follows immediately from the definition of @xmath319 and @xmath320 .",
    "since @xmath944 implies @xmath945 and @xmath946 implies @xmath947 if @xmath948 , the conclusion of the item is trivial .",
    "this derives from lemma [ prop - wfs ] .",
    "this derives from lemma [ prop - ans ] .",
    "let @xmath75 be a p - interpretation , @xmath362 , and let @xmath959 such that there exists at least one local consistent explanation of @xmath132 w.r.t",
    ". @xmath960 .",
    "thus , there are no rules with @xmath23 as head in @xmath1 , which implies that @xmath961 .",
    "* @xmath966 , @xmath967 , and @xmath968 are pairwise disjoint .",
    "* for each @xmath969 there exists a lce @xmath970 of @xmath132 w.r.t .",
    "@xmath971 and @xmath130 such that for each rule @xmath72 with @xmath73 , @xmath972",
    ".    * proof . *",
    "the first item is trivial thanks to the definition of @xmath966 , @xmath967 , and @xmath968 . for the second item , for @xmath969",
    ", there exists some @xmath973 such that @xmath974 and @xmath975 . from the definition of a cycle",
    ", there exists some @xmath976 which satisfies the condition of the second item .",
    "we will now proceed to prove lemma [ just - free ] . for each @xmath594",
    ", we construct a dependency graph @xmath977 for elements in @xmath978 and @xmath979 as follows .",
    "again , we describe a graph by its set of edges .",
    "first , the construction of @xmath980 is as follows .    1 .   for each @xmath981",
    ", @xmath980 contains the edge @xmath982 .",
    "2 .   let @xmath966 , @xmath967 , and @xmath968 be defined as in lemma  [ split - d0 ] .",
    "1 .   for @xmath983",
    ", @xmath980 contains the edge @xmath984 ; 2 .   for @xmath985",
    ", @xmath980 contains the edge @xmath986 .",
    "3 .   let @xmath987 .",
    "this implies that there exists some @xmath988 such that @xmath974 and @xmath989 . for each @xmath957 , let @xmath990 be an explanation of @xmath189 w.r.t .",
    "@xmath971 and @xmath372 which satisfies the conditions of the second item in lemma [ split - d0 ] .",
    "then , @xmath980 contains the set of edges @xmath991 .",
    "no other edges are added to @xmath980 .      1 .   for each @xmath992",
    ", @xmath993 is a safe off - line e - graph of @xmath131 w.r.t .",
    "@xmath994 and @xmath130 .",
    "2 .   for each @xmath995 , @xmath996 is a safe off - line e - graph of @xmath132 w.r.t .",
    "@xmath994 and @xmath130 .      *",
    "consider @xmath981 .",
    "since @xmath980 contains @xmath982 for every @xmath981 and @xmath15 is a sink in @xmath980 , we can conclude that @xmath997 and @xmath998 is a safe off - line e - graph of @xmath131 w.r.t .",
    "@xmath994 and @xmath130 . *",
    "consider @xmath959 .",
    "let @xmath966 , @xmath967 , and @xmath968 be defined as in lemma [ split - d0 ] .",
    "there are three cases : 1 .",
    "@xmath983 . since @xmath980 contains @xmath984 and @xmath17 is a sink in @xmath980 , we can conclude that @xmath999 and @xmath1000 is a safe off - line e - graph of @xmath132 w.r.t .",
    "@xmath994 and @xmath130 .",
    "2 .   @xmath985 .",
    "since @xmath980 contains @xmath986 and @xmath142 is a sink in @xmath980 , we can conclude that @xmath1001 and @xmath1000 is a safe off - line e - graph of @xmath132 w.r.t .",
    "@xmath994 and @xmath130 .",
    "3 .   for @xmath987 , let @xmath1002 .",
    "it is easy to see that @xmath168 is indeed a @xmath129-based e - graph of @xmath132 because , from the construction of @xmath168 , we have that 1 .   every node in @xmath1003 is reachable from @xmath132 , and 2 .   if @xmath1004 then @xmath1005 is a local consistent explanation of @xmath189 w.r.t .",
    "@xmath994 and @xmath130 .",
    "+ the safety of the e - graph derives from the fact that it does not contain any nodes of the form @xmath509 .",
    "+ @xmath5        * @xmath1009 ; * for each @xmath1010 there exists some lce @xmath970 of @xmath132 w.r.t .",
    "@xmath955 and @xmath130 such that @xmath1011 and @xmath1012 ; and * for each @xmath1013 there exists some lce @xmath970 of @xmath132 w.r.t .",
    "@xmath955 and @xmath130 such that @xmath1014 and @xmath1012 .        1 .   for each @xmath1017 , from the definition of @xmath1018 we know that there exists a rule @xmath25 such that @xmath73 , @xmath1019 , and @xmath1020 .",
    "@xmath977 contains the node @xmath131 and the set of edge @xmath1021 .",
    "2 .   let @xmath1022 and @xmath1023 be defined as in lemma [ split - di ] .",
    "1 .   for @xmath1010 ,",
    "let @xmath970 be a lce of @xmath132 satisfying the second condition of lemma [ split - di ] .",
    "then , @xmath977 contains the following set of edges : @xmath1024 ; 2 .   for @xmath1013 ,",
    "let @xmath970 be a lce of @xmath132 satisfying the third condition of lemma [ split - di ] .",
    "then , @xmath977 contains the set of links @xmath1025 3 .",
    "no other links are added to @xmath977 .      1 .   for each @xmath1026",
    ", @xmath1027 is a safe off - line e - graph of @xmath131 w.r.t .",
    "@xmath955 and @xmath130 .",
    "2 .   for each @xmath1028 , @xmath1029 is a safe off - line e - graph of @xmath132 w.r.t .",
    "@xmath955 and @xmath130 .    * proof . *",
    "the proof is done by induction on @xmath594 .",
    "the base case is proved in lemma [ lbase ] .",
    "assume that we have proved the lemma for @xmath1030 .",
    "we now prove the lemma for @xmath594 .",
    "we consider two cases :    1 .",
    "let @xmath25 be the rule with @xmath73 used in item 1 of the construction of @xmath977 .",
    "for each @xmath526 , let @xmath1031 .",
    "for each @xmath528 , let @xmath1032 .",
    "we have that @xmath1033 where @xmath1034 and @xmath1035 from the inductive hypothesis , we have that @xmath225 s ( resp .",
    "s ) are safe off - line e - graphs of @xmath179 ( resp .",
    "@xmath189 ) w.r.t . @xmath1037 and @xmath130 .",
    "this implies that @xmath168 is a @xmath1038-based e - graph of @xmath131 .",
    "furthermore , for every @xmath1039 , @xmath1040 or @xmath1041 .",
    "thus , @xmath1042 .",
    "2 .   for each @xmath1043 , let @xmath1044 . from the definition of @xmath168 ,",
    "every node in @xmath1003 is reachable from @xmath132 and @xmath1045 is a local consistent explanation of @xmath953 w.r.t .",
    "@xmath955 and @xmath130 for every @xmath1046 .",
    "thus , @xmath168 is a @xmath1038-based e - graph of @xmath132 .",
    "furthermore , it follows from the definition of @xmath977 that there exists no node @xmath1046 such that @xmath1047 .",
    "thus , if @xmath1048 and @xmath1049 then we have that @xmath1050 is not safe .",
    "this contradicts the fact that it is safe due to the inductive hypothesis .",
    "* for each atom @xmath363 ( resp .",
    "@xmath364 ) , there exists a _",
    "safe _ off - line e - graph of @xmath131 ( resp .",
    "@xmath132 ) w.r.t . @xmath75 and @xmath130 ; * for each atom @xmath365 ( resp .",
    "@xmath366 ) there exists an on - line e - graph of @xmath131 ( resp .",
    "@xmath132 ) w.r.t . @xmath75 and @xmath130",
    ".    * proof . *",
    "the first item follows from the lemma [ lprop - sigma ] .",
    "the second item of the lemma is trivial due to the fact that @xmath1051 + ( resp .",
    "@xmath1052 ) is a @xmath129-based e - graph of @xmath131 ( resp .",
    "@xmath132 ) , and hence , is an on - line e - graph of @xmath131 ( resp .",
    "@xmath132 ) w.r.t . @xmath75 and @xmath130",
    ". @xmath5    _ lemma [ conserve ] . _",
    "let @xmath1 be a program , @xmath75 be an interpretation , and @xmath120 be an answer set such that @xmath390 . for every atom @xmath23 ,",
    "if @xmath139 is a safe off - line e - graph of @xmath23 w.r.t .",
    "@xmath75 and @xmath130 where @xmath391 then it is an off - line justification of @xmath23 w.r.t .",
    "@xmath120 and @xmath254 .",
    "_ proposition [ on - off ] .",
    "_ let @xmath392 be a general complete computation and + @xmath393 be an on - line justification of the computation .",
    "then , for each atom @xmath23 in @xmath313 , the e - graph of @xmath23 in @xmath394 is an off - line justification of @xmath23 w.r.t .",
    "@xmath313 and @xmath395 ."
  ],
  "abstract_text": [
    "<S> the paper introduces the notion of _ off - line justification _ for answer set programming ( asp ) . </S>",
    "<S> justifications provide a graph - based explanation of the truth value of an atom w.r.t . a given answer set . </S>",
    "<S> the paper extends also this notion to provide justification of atoms _ during _ the computation of an answer set ( _ on - line justification _ ) , and presents an integration of on - line justifications within the computation model of smodels . </S>",
    "<S> off - line and on - line justifications provide useful tools to enhance understanding of asp , and they offer a basic data structure to support methodologies and tools for _ debugging _ answer set programs . a preliminary implementation has been developed in @xmath0 .    answer set programming , justification , offline justification , online justification </S>"
  ]
}