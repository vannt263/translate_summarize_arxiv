{
  "article_text": [
    "users who query data sources using keyword searches often are not familiar with the data source schema or the appropriate query language . for the query to succeed",
    ", the keywords have to have matches in the data source . failing this ,",
    "an empty result is returned even when semantically related content exists .",
    "when keywords have indirect mappings in a data source that can not be found by traditional systems , the user faces the no - but - semantic - match problem .    .",
    "consider a user submitted a keyword query @xmath1 = \\{@xmath2 , @xmath3 , @xmath4 } on xml database given in fig .",
    "[ fig : motivating ] and would like to find information about the professor @xmath2 .",
    "using conjunctive keyword search , traditional systems will show an empty result because there is no occurrence for the keywords @xmath3 and @xmath4 in the data source .",
    "however , the keyword @xmath3 has a semantic connection to @xmath5 and @xmath6 @xmath7 while the keyword @xmath4 is semantically related to @xmath8 , @xmath9 and @xmath10 which exist in the data source and could generate results that might interest the user .    the xml keyword search has been addressed by researchers before .",
    "the concept of lowest common ancestor ( lca ) was first proposed by guo et al .",
    "@xcite to extract xml nodes which contain all query keywords within the same subtree .",
    "xu and papakonstantinou @xcite introduced the concept of smallest lowest common ancestor ( slca ) to reduce the query result to the smallest tree that contains all keywords .",
    "sun , chan and goenka  @xcite extended this work by applying the slca principle to logical or searches .",
    "hristidis et al .",
    "@xcite explored the trees below lca to provide information about the proximity of the keywords in the document .",
    "none of the existing studies use the slca semantics to provide a solution when one or more keywords do not exist in the database . in this paper",
    ", we adapt the widely - accepted slca semantics and algorithms to retrieve meaningful results when some non - mapped keywords are submitted to the system .",
    "when a query encounters the no - but - semantic - match problem , we need to find candidate keywords for the non - mapped keywords to produce non - empty results .",
    "even though the non - mapped keywords may be semantically close to some items in data source , traditional systems do not attempt to discover them . to produce an answer to the user s initial query",
    ", the candidate keywords must be semantically close to the non - mapped keywords .",
    "one way of fulfilling this requirement is to find substitutes for non - mapped keywords in an ontological knowledge base .",
    "clearly , only candidate keywords that have a mapping in the data source can be selected as substitutes for a new query . replacing each of the non - mapped keywords with one or more semantically related words that are known to exist in the database leads to a list of candidate queries .",
    "depending on the number of available keywords , the number of potential queries and results can be impractically large .",
    "hence the degree of semantic similarity with the original query is calculated for each candidate query before it is executed .",
    "before the results can be presented to the user , results of poor quality in terms of cohesiveness must be eliminated to ensure all results are meaningful answers to the original query .",
    "thus , to solve the no - but - semantic - match problem , two aspects are considered : ( a ) query similarity ; and ( b ) result cohesiveness .    .",
    "consider the keyword query @xmath1 = \\{@xmath2 , @xmath3 , @xmath4 } presented in example 1 on the database shown in fig .",
    "[ fig : motivating ] .",
    "keywords @xmath3 and",
    "@xmath4 do not have a mapping in the data source and the traditional system generates an empty result for it .",
    "the ontological knowledge base @xcite has @xmath11 semantic counterparts for @xmath3 and @xmath12 for @xmath4 .",
    "all possible substitutions and their combinations are considered . in the extreme case when all candidate keywords are available in the data source , @xmath13 = @xmath14 queries",
    "are generated and each query may have several answers that have to be considered .",
    "when a high number of keywords have to be replaced and these keywords have many semantic counterparts , we may face an unmanageably large number of combinations that have to be analyzed for semantic similarity with the original query .",
    "hence , there is a need to identify and remove less promising candidate queries early .    in this paper",
    ", we present a novel two - step solution to the no - but - semantic - match problem in xml keyword search . in the first step , semantically",
    "related candidate queries are created by replacing non - mapped keywords in the original queries with semantic counterparts and in the second step , the queries are processed and the top - k semantically related results retrieved . in order to present the top - k results to the user for evaluation , each result retrieved from the queries",
    "is separately analyzed in terms of its similarity to the original query and its cohesiveness in data source .",
    "since there may be a large number of semantically related results , retrieving the top - k results is potentially costly .",
    "therefore , we propose two pruning techniques , inter - query and intra - query pruning . since the candidate queries are generated by replacing non - mapped keywords , some keywords are shared between the candidate queries .",
    "we exploit this property to propose a more efficient batch query processing technique to improve the performance substantially .",
    "the issue of finding semantically related results for queries with no - but - semantic - match problem has not been addressed in the context of semi - structured data before .",
    "our contributions are as follows :    1 .",
    "we are the first to formulate the no - but - semantic - match problem in xml keyword search .",
    "we propose two pruning methods and an efficient approach of processing the no - but - semantic - match query .",
    "3 .   based on keywords the candidate queries have in common , we also propose a method to process multiple queries in a batch which improves the performance substantially .",
    "we conduct extensive experiments which verify the effectiveness and efficiency of our solutions on two real datasets .",
    "the rest of the paper is organized as follows : section 2 discusses xml keyword search and presents the no - but - semantic - match problem .",
    "section 3 presents the details of our pruning ideas and the efficient processing of the no - but - semantic - match query .",
    "section 4 presents the batch query processing scheme to further improve the performance .",
    "the experiments are presented in section 5 .",
    "section 6 reviews the related work .",
    "finally , section 7 concludes our paper .",
    "an xml document is an ordered tree @xmath15 with labeled nodes and a designated root .",
    "all xml elements are treated as nodes containing information in @xmath15 .",
    "there are parent - child and sibling relationships between the nodes .",
    "the depth of the tree is denoted as @xmath16 , and the root node has a depth of 1 .",
    "each node @xmath17 in the tree @xmath15 is marked with a unique identifier in dewey code , which describes the path from the root to the node @xmath17 as a sequence of numbers separated by a dot (  . \" ) .",
    "sibling nodes have dewey codes of equal length with a unique last number .    .",
    "[ fig : motivating ] shows an xml tree which contains information about staff and students of a university .",
    "the root node s dewey code is 0 .",
    "dewey code 0.0.1 refers to a node containing information about a member of the university and the code prefix 0.0 refers to its parent node .",
    "* keyword match node : * a node @xmath18 in the tree @xmath15 is a match node for keyword @xmath19 if it contains @xmath19 .",
    "e.g. , the match nodes for keyword @xmath20 presented in fig . [ fig : motivating ] are : @xmath21 $ ] , @xmath22 $ ] , @xmath23 $ ] , and @xmath24 $ ] .    * keyword inverted list : * each keyword",
    "@xmath19 corresponds to a list @xmath25 of entries and each entry corresponds to a node @xmath18 which contains @xmath19 in the tree @xmath15 .",
    "e.g. , the keyword inverted list for keyword @xmath20 is @xmath26,[0.1.2.0.0],[0.2.3.$ ] @xmath27,[0.2.4.0.1.0]\\}$ ] .    * smallest lowest common ancestor ( slca ) : * let @xmath28 returns the lowest common ancestor ( lca ) of match nodes @xmath29",
    ". then lcas of query @xmath30 on @xmath15 are defined as @xmath31 @xmath32 .",
    "slcas are a subset of lcas which do not have other lcas as child nodes and defined as @xmath33 .    . in fig .",
    "[ fig : preliminaries ] , for a keyword query @xmath30=\\{@xmath2 , @xmath34 } , there are 4 lca nodes which are computed as : @xmath35 = @xmath36,[0.0.2.0.0]),lca([0.0.3.0],[0.1 $ ] @xmath37),lca([0.1.1 $ ] @xmath38,[0.1.2.0.0]),lca([0.2.1.0.0],[0.2.3.0 $ ] @xmath39)\\}$]=@xmath40,[0,0],[0.1]$ ] @xmath41\\}$ ] .",
    "since the lca node @xmath42 $ ] is the ancestor node of @xmath43$],@xmath44 $ ] and @xmath45 $ ] , it is not an slca and should be removed .",
    "therefore , @xmath46,[0.1],[0.2]\\}$ ] .",
    "* keyword query and subtree result : * in xml data , a keyword query @xmath30 consists of a set of keywords @xmath47 .",
    "a result @xmath48 for @xmath30 is a subtree in @xmath15 which contains all keywords @xmath49 . here , we consider @xmath50 , the root of the subtree , an slca node , i.e. @xmath51 .    * tightest slca subtree result : * for an slca node",
    ", there may exist several subtree results .",
    "this is because that under an slca node @xmath50 , we may find several match nodes @xmath52 for the keyword @xmath53 , where @xmath54 is the number of match nodes for @xmath19 under @xmath50 .",
    "let @xmath55 be the closest match node from @xmath52 to @xmath50 for @xmath56 , then we get the the tightest subtree result @xmath57 .",
    "for example , for @xmath58 $ ] in fig .",
    "[ fig : preliminaries ] , there are two subtree results , ( c ) and ( d ) .",
    "the tightest subtree result is ( c ) @xmath59,\\{[0.2.1.0.0],[0.2.3.0.0]\\})$ ] .",
    "we argue to return only the tightest slca subtree results to the user as these results match the user s search intention better than the results containing the sparsely distributed keyword match nodes under @xmath50 .",
    "that is , a result is more likely to be meaningful when the result subtree is more tight and cohesive ( for survey @xcite , @xcite ) .",
    ".the list of symbols [ cols=\"<,<\",options=\"header \" , ]     [ table : topquerydblp ]      in this section , we evaluate the quality of our approach and compare it with xo - qp . here",
    ", we select some sample queries with no - but - semantic - match problem for both datasets to conduct a comprehensive user study and thereafter , evaluate the overall quality of our approach . in order to carry out a fair user study",
    ", we select the users among both experts who have worked in xml keyword search areas and naive users who are graduate computer science students .",
    "to do the study , we present to the users with the original queries and their top-10 candidate queries / results retrieved from the top result list @xmath60 .",
    "after that , we ask the users to assess the quality of each candidate query with regards to their semantic similarity to the original query by scoring the candidate queries / results using cumulated gain metric @xcite .",
    "they score each candidate query / result from 0 to 5 points ( 5 means the best and 0 means the worst ) .",
    "the average quality scores of the top-5 and top-10 queries /results for our approach and the existing counterpart xo - qp are presented in fig . [",
    "fig : userstudy ] and fig.[fig : userstudyxonto ] respectively . from fig .",
    "[ fig : userstudy ] , we observe that our proposed method suggests reasonable results for the no - match query for both top-5 and top-10 results . also , we see that the average quality of top-5 results are always better than the average quality of top-10 results which indicates that our ranking function successfully ranks more similar and meaningful results higher than the rest of the results . however , we observe that in many cases for the existing method xo - qp , the average quality of results for top-10 is higher than top-5 results ( for instance for @xmath61 in imdb and for @xmath62 in dblp ) as shown in fig . [",
    "fig : userstudyxonto ] .",
    "this indicates that xo - qp sometimes ranks some less similar and meaningful results higher .",
    "this is probably because of adapting xrank scheme into xo - qp .",
    "we conclude that our approach addresses the no - but - semantic - match problem better than the existing xo - qp method .      in this section ,",
    "we compare the precision of our proposed method with the xo - qp method . in order to make a comparison , we count the number of meaningful results in top-10 results . a result is regarded as meaningful if the average quality score of the assessors is not less than 3 .",
    "we see that the precision of our approach and xo - qp is presented on both imdb and dblp as shown in fig .",
    "[ fig : precisioncomparison ] . in imdb , we see that the precision of our proposed method is better than xo - qp . this is because we use both semantic similarity and cohesiveness scores to rank the results and retrieve the tightest slca results with the maximum similarity to the original query keywords .",
    "also in dblp , we observe that the precision of our method is better than xo - qp in many cases specially in @xmath63 and @xmath64 . that s because our method can effectively retrieve the most similar results that are cohesive and make a meaningful combination in terms of data cohesiveness .",
    "however , in some cases like @xmath65 and @xmath66 , we see that the precision of our method is smaller than xo - qp because it uses less similar keywords in the candidate query to retrieve more cohesive results .",
    "but the precision is not largely deteriorated as we see in xo - qp in many cases .      to demonstrate the efficiency of our approach , we use a baseline method which applies inter query pruning only , and uses scan eager for query processing .",
    "we call this baseline query processing as bl - qp . the purpose of this baseline is to demonstrate the efficiency of the intra - query pruning scheme in our proposed methods .",
    "overall , we compare the performance of the following methods : ( a)bl - qp , ( b ) se - qp , ( c ) an - qp , and ( d ) ba - qp , and ( e ) xo - qp .      fig .",
    "@xmath67 shows the response time of computing the top-10 semantically related results for the sample queries ( presented in table [ tbl : sample ] ) on the imdb and dblp datasets . according to the results",
    ", ba - qp achieves the best performance .",
    "the reason behind this is that we apply inter and intra batch prunings in ba - qp in addition of inter and intra - query prunings . also , we share the partial results of the shared keywords among the candidate queries in a batch .",
    "on average , ba - qp consumed 30 percent time of the time needed by the se - qp and an - qp methods .",
    "the difference , however , depends on the number of candidate queries . in fig .",
    "@xmath67 ( a ) , the response time for processing the test query @xmath68 in ba - qp is very close to those of se - qp and an - qp due to the small number of candidate queries for @xmath68 which is 12 and insufficient number of batches ( in this case we have only one batch ) to apply inter - batch pruning .",
    "moreover , if the cost of merging the shared part @xmath69 with the unshared part @xmath70 is relatively high in most of the batches , ba - qp may not outperform the other methods as we see in @xmath71 on dblp . in imdb @xmath71",
    ", however , an - qp outperforms se - qp by a large margin because the data distributions in most of the inverted lists are skewed . in such case , many nodes are skipped in an - qp , which improves the performance . clearly , bl - qp has the worst performance on most cases because it does not apply the intra query pruning , therefore , incurs unnecessary computations .",
    "the xo - qp , however , is comparable to ba - qp in many cases because we set the node score threshold to @xmath72 which means that only the relevant nodes to the keywords with the similarity degree bigger than @xmath72 are selected .",
    "if we set this value to a smaller number , xo - qp performance deteriorates and gets closer to an - qp and se - qp .",
    "moreover , xo - qp builds a special inverted list called xonto - dil for the keywords which takes additional time and space for its creation while our proposed methods do not use such indexing and use the normal dil for query processing .        in fig.[fig : totalprocessingtime ] , the average processing time of different methods for all test queries are presented .",
    "clearly the baseline method which does not use intra query pruning spends the maximum time for processing on both datasets .",
    "the se - qp and an - qp spend less time comparing to bl - qp because we apply inter and intra query pruning and therefore , the processing terminates early when we reach to the global @xmath73 .",
    "moreover , there is a narrow improvement in the an - qp over se - qp due to using the anchor node processing which skips many redundant computations and expedites the efficiency .",
    "the ba - qp processing improves sharply on both datasets because in ba - qp , we execute queries in batch and share the computations among the queries in the batch and thereafter , we reach to the global @xmath73 before se - qp and an - qp can do .",
    "also , we can apply inter and intra - batch pruning which expedite its efficiency . in xo - qp , however , the performance is close to ba - qp on both datasets because we build the xonto - dil on the nodes with the relevance degree no less than @xmath72 . in such condition",
    ", only the highly relevant nodes are selected to replace the keywords , therefore , the processing time does not grow considerably due to small number of candidate keywords .",
    "in contrast , by setting the threshold to lower numbers , the processing time will grow exponentially and gets closer to se - qp . furthermore",
    ", our methods do not need to build special indexing , therefore , avoid using additional space and offline processing time for building such indexing .      in this experiment ,",
    "we choose test queries that have at least 100 candidate queries . at each step",
    ", we set their length to a number of settings ( @xmath74 ) and compute the average response time of all queries when processing 100 candidate queries while setting @xmath0 to 10 . in each step , for the test queries that have smaller number of keywords , we add additional keywords to increase their length .",
    "we also use the same queries to conduct experiments and compare the results with xo - qp method . in fig .",
    "@xmath75 the effect of growing the length of queries on the response time is analyzed .",
    "the response time of ba - qp is almost fixed compared to xo - qp , bl - qp , se - qp , and an - qp on imdb .",
    "similarly in dblp , ba - qp has the slowest growth in response time when the number of keywords increases while bl - qp , se - qp and an - qp show a big jump in processing times .",
    "also , xo - qp shows a jump in the processing time when the query length increases .",
    "thus , the performance of xo - qp is sensitive to the query length parameter .",
    "the sharpest increase in the processing time is related to bl - qp because it does not apply intra - query pruning , therefore , all the inverted lists are accessed during the processing and this incurs many useless computations specifically when the query length increases .    in summary",
    ", we can conclude that ba - qp method is not sensitive to the number of keywords due to sharing the computations while the performance of se - qp and an - qp is highly sensitive to the query length .      in this experiment ,",
    "we vary the top-@xmath0 size @xmath0 and compute the average processing time . in fig .",
    "@xmath76 , we observe the effect of top-@xmath0 size @xmath0 on the average processing time for different methods .",
    "clearly , the ba - qp and xo - qp methods are not that sensitive to the value of @xmath0 . by increasing the value of @xmath0 , processing times of ba - qp and xo - qp show only a small increase or almost fixed .",
    "on the other hand , for se - qp and an - qp methods , any increase on @xmath0 , leads to a considerable jump on the average processing time .",
    "however , this increase is not big when we change @xmath0 from 10 to 20 .",
    "when @xmath0 is selected as a bigger number , @xmath73 will be smaller and this causes the inter query pruning in se - qp and an - qp to be less effective .",
    "that is , the application of inter - query pruning is delayed in se - qp and an - qp for big @xmath0 .",
    "however in ba - qp , we execute a candidate query batch by sharing the computations among the queries in it and thereafter , we reach to the global @xmath73 before se - qp and an - qp can do .",
    "also , we can apply inter and intra - batch pruning with this early found global @xmath73 which helps ba - qp to expedite its efficiency .      in this experiment",
    ", we vary @xmath77 between a number of settings ( @xmath78 ) and compute the average processing time of the test queries when @xmath79 . fig .",
    "@xmath80 presents the effect of choosing different values for @xmath77 .",
    "larger values of @xmath77 reduce the sensitivity to data cohesiveness .",
    "this usually leads to a more effective intra - query pruning and decreases the processing time . on the contrary , as @xmath77 decreases , the possibility for the partial results scores to be smaller than the @xmath73 also decreases . in this case",
    ", the intra - query pruning becomes less effective and therefore , the processing time increases , specifically , in se - qp and an - qp . in bl - qp , however , there is no significant difference in the processing time when @xmath77 changes to smaller number .",
    "this is because bl - qp does not apply intra query pruning and therefore , the processing time is not affected that much by @xmath77 .      for this experiment ,",
    "we choose test queries which have at least 200 candidate queries . at each step",
    "we process a certain number ( @xmath82 ) of their candidate queries and compute the average processing time when @xmath79 . in fig .",
    "@xmath83 , the effect of growing the number of candidate queries @xmath81 on the response time is analyzed .",
    "the response time of ba - qp method grows slowly compared to bl - qp , se - qp , and an - qp which show a sharp rise in each step . in bl - qp , the growth in the query processing time",
    "is the maximum among the methods because it does not apply intra query pruning , therefore , it incurs many unnecessary computations during execution of the candidate queries .",
    "we can conclude that ba - qp is not that sensitive to @xmath81 .",
    "this is because ba - qp not only shares the computations among the candidate query batch but also applies inter and intra batch pruning with the early - found global @xmath73 to expedite its performance .      in this section ,",
    "we show the pruning effect on the processing time . from fig .",
    "[ fig : pruningtime ] , the sample queries processing time are shown for 3 scenarios : ( a ) when there is no pruning for processing the queries , ( b ) when only the inter query pruning is implemented , and ( c ) when both inter and intra pruning methods are implemented .",
    "the processing time are measured using se - qp method . clearly , the inter query pruning shows the most effective method to cut the processing time on most of the sample queries . if the number of candidate queries is large and the breaking point occurs when most of the queries are not executed , then inter query has the best performance . e.g. , in the sample queries @xmath84 and @xmath85 on imdb , the number of executed queries are @xmath86 and @xmath87 respectively and in the sample queries @xmath88 and @xmath84 on dblp , the number of executed queries are @xmath89 and @xmath90 respectively . therefore in these cases , most of the queries are not executed by using inter query pruning and the processing time reduced sharply . the intra query pruning is more effective when the number of query keywords is bigger or the inverted list that is not accessed due to pruning is big sized . in such condition ,",
    "some inverted lists are not accessed when the result is not able to beat the @xmath73 and this expedites the processing time .",
    "for example , in the sample queries @xmath64 and @xmath84 on imdb and @xmath91 and @xmath84 on dblp , the query keywords are from 4 to 5 keywords and include some big sized inverted lists that are not accessed , therefore the processing time reduced considerably .",
    "[ fig : totalpruningtime ] presents the average processing time for the set of test queries for 3 scenarios : ( a ) no pruning is implemented , ( b ) only inter query pruning is implemented , and ( c ) both pruning techniques are implemented . clearly , the processing time for the case with no pruning is maximum on both datasets .",
    "this shows that inter query pruning has the most tangible effect on the processing time by avoiding to execute the queries that can not contribute to the @xmath60 .",
    "the efficiency improvement on imdb and dblp is 2 and 3 times respectively .",
    "after that , intra query pruning expedites the efficiency by avoiding to access all inverted lists when the result can not beat @xmath73 .",
    "[ fig : pruningtimebaqp ] presents the sample queries processing time for ba - qp in 2 scenarios : ( a ) when no batch pruning is implemented , ( b ) when batch pruning is implemented . in most cases ,",
    "the processing time for the method which uses pruning has decreased .",
    "the batch pruning becomes more effective when the query length increases as shown in @xmath92 and @xmath93 on imdb or in @xmath94 and @xmath95 on dblp .",
    "moreover , when the candidate queries contain some big inverted lists and we reach to the global @xmath73 early , the improvement is more considerable as in @xmath68 and @xmath96 on imdb and in @xmath68 and @xmath97 on dblp .",
    "[ fig : totalpruningtimebaqp ] shows the average processing time of the test queries for ba - qp on 2 cases : ( a ) when no batch pruning is implemented , ( b ) when batch pruning is implemented .",
    "we observe from the picture that the batch pruning improved the processing time on both datasets , however , the improvement on dblp is more considerable . the improvement is achieved because we reach to the global @xmath73 earlier by applying batch pruning , therefore it expedites the performance .",
    "* failed queries . *",
    "when a user queries a data source , the result may be empty or otherwise below expectation .",
    "this problem known as failed queries has inspired a broad range of research in the database community ( e.g. @xcite,@xcite,@xcite ) . in the context of relational databases ,",
    "the problem has been studied by nambiar and kambhampati @xcite , muslea @xcite as well as muslea and lee @xcite .",
    "nambiar and kambhampati @xcite presented approximate functional dependencies to relax the user original query and find tuples similar to the user query .",
    "muslea @xcite , as well as muslea and lee @xcite used machine learning techniques to infer rules for generating replacement queries .",
    "amer - yahia , cho and srivastava @xcite , brodianskiy and cohen @xcite as well as cohen and brodianskiy @xcite studied query relaxation for xml data .",
    "the studies proposed to discover the constraints in the queries that prevent results from being generated and remove them so that a result can be produced .",
    "all these investigations focus on the modification of the user original query constraints on the content level rather than the semantic analysis of the original query constraints .",
    "hill et al .",
    "@xcite , used the ontology information to relax structured xml queries .",
    "farfan et al .",
    "@xcite , proposed xontorank system to address the ontology - aware xml keyword search of electronic medical records .",
    "unlike their work which uses snomed ontology for enhancing the search on medical records , we address the general no - match problem on xml data and use a general ontological knowledge base like a thesaurus or dictionary to solve the problem for general documents .",
    "* query expansion .",
    "* query expansion has widely studied in many works such as @xcite,@xcite,@xcite,@xcite .",
    "schenkel , theobald , and weikum @xcite proposed xxl which combines the keyword search with structural conditions and semantic similarity to increase the quality of results .",
    "kim and kong @xcite suggested a query expansion technique that uses an ontology algorithm to map a target dtd to ontology .",
    "this scheme is successful for expanding the queries minimally .",
    "kim , kong , and jeon @xcite developed a web xml document search engine that applies ontology - dtd match algorithm for remote documents .",
    "however , in all of the above works , the focus is on structured queries . in our work",
    ", we find some semantic counterparts for specific non - mapped keywords for replacement , therefore , query expansion is not useful in our case .    * recommendation systems . *",
    "users are often interested in items similar to those they have visited before or to content that has been looked up by similar users .",
    "these items are presented by the recommendation systems .",
    "akbarnejad et al .",
    "@xcite and chatzopoulou , eirinaki and @xcite proposed query recommendation based on a prediction of the items that user is interested in .",
    "yao et al .",
    "@xcite proposed to exploit structural semantics for query reformulation .",
    "meng , cao and shao @xcite used the semantic relationships between keywords and keyword queries to suggest a set of keyword queries from the query log .",
    "however , the semantic relationship is interpreted as the co - occurrence of the keywords and no ontological analysis is carried out .",
    "moreover , the work focuses on extracting similar queries from the query log using data mining techniques without processing the results .",
    "drosou and pitoura @xcite presented a database exploration framework which recommends additional items called  you may also like \" results .",
    "however , the recommended results are compiled based on the results of the original query and there is no focus on semantic connection between the original query and recommended results",
    ".    * mismatch problem . *",
    "sometimes the system shows erroneous mismatch results for a user query which is called mismatch problem .",
    "bao et al .",
    "@xcite proposed a framework to detect the keyword queries that lead to a list of irrelevant results on xml data .",
    "they detect a mismatch problem by analyzing the results of a user query and inferring the user s intended node type result based on data structure . based on this",
    ", they are able to suggest queries with relevant results to the user . unlike the current study , bao et al .",
    "investigate ways of producing relevant results instead of finding results for no - match queries .",
    "* query cleaning . *",
    "sometimes the empty result is caused by typographical errors .",
    "pu and yu @xcite and lu et al .",
    "@xcite investigated a way of suggesting queries that have been cleaned of typing errors . unlike our study , these authors do not tackle the problem of non - mapped keywords .",
    "* ontology - based querying .",
    "* many studies have used ontology information for searching the semantic web @xcite , @xcite , @xcite .",
    "studies by aleman - meza @xcite , cakmak and zsoyoglu @xcite as well as wu , yang and yan @xcite used ontology information to find frequent patterns in graphs .",
    "wu , yang and yan @xcite proposed an improved subgraph querying technique by ontology information .",
    "they revised subgraph isomorphism by mapping a query to semantically related subgraphs in terms of a given ontology graph .",
    "our work generates substitute queries for the user given keyword query by extracting the semantically related keywords from the ontological knowledge base and thereafter , produce semantically related results to the user query instead of returning an empty result set to the user .",
    "this paper investigates ways of efficiently building substitute queries against xml data sources when the user given keyword query fails to produce any result as one or more of its keywords do not exist in the data source .",
    "our approach depends on an ontological knowledge base for a discovery of semantically related keywords to generate the substitute queries , which can be executed against the data source to produce the semantically related results for the user s original query .",
    "as the number of substitute queries can be potentially large and also , not all semantically related results are meaningful to the same degree , we propose efficient pruning techniques to reduce the number of substitute queries and return only the top-@xmath0 semantically related results .",
    "we develop two query processing algorithms to evaluate the substitute queries against the data source based on our pruning techniques .",
    "we also develop a batch processing technique that exploits the shared keywords among the substitute queries to expedite the performance further .",
    "the extensive experiments with two real datasets validate the effectiveness and efficiency of our approach .",
    "this work is supported by the australian research council discovery grants dp140103499 and dp160102412 .",
    "j.  hill , j.  thorson , b.  guo , and z.  chen . toward ontology - guided knowledge - driven xml query relaxation . in _",
    "second international conference on computational intelligence , modeling and simulation _ , pages 448453 , 2010 ."
  ],
  "abstract_text": [
    "<S> users are rarely familiar with the content of a data source they are querying , and therefore can not avoid using keywords that do not exist in the data source . </S>",
    "<S> traditional systems may respond with an empty result , causing dissatisfaction , while the data source in effect holds semantically related content . in this paper </S>",
    "<S> we study this no - but - semantic - match problem on xml keyword search and propose a solution which enables us to present the top - k semantically related results to the user . </S>",
    "<S> our solution involves two steps : ( a ) extracting semantically related candidate queries from the original query and ( b ) processing candidate queries and retrieving the top-@xmath0 semantically related results . </S>",
    "<S> candidate queries are generated by replacement of non - mapped keywords with candidate keywords obtained from an ontological knowledge base . </S>",
    "<S> candidate results are scored using their cohesiveness and their similarity to the original query . </S>",
    "<S> since the number of queries to process can be large , with each result having to be analyzed , we propose pruning techniques to retrieve the top-@xmath0 results efficiently . </S>",
    "<S> we develop two query processing algorithms based on our pruning techniques . </S>",
    "<S> further , we exploit a property of the candidate queries to propose a technique for processing multiple queries in batch , which improves the performance substantially . </S>",
    "<S> extensive experiments on two real datasets verify the effectiveness and efficiency of the proposed approaches . </S>"
  ]
}