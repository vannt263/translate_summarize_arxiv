{
  "article_text": [
    "how life came to existence and evolved has been a key scientific question in the past hundreds of years . traditionally , a ( phylogenetic ) tree has been used to model the evolutionary history of species , in which a node represents a _ speciation event _ and the leaves represent the extant species under study .",
    "such evolutionary trees are often reconstructed from the gene or protein sequences sampled from the extant species under study . since",
    "genomic studies have demonstrated that genetic material is often transfered between organisms in a non - reproductive manner @xcite , it has been commonly accepted that ( phylogenetic ) networks are more suitable for modeling horizontal gene transfer , introgression , recombination and hybridization events in genome evolution @xcite .",
    "mathematically , a network is a rooted acyclic digraph with labeled leaves .",
    "algorithmic and combinatorial aspects of networks have been intensively studied in the past two decades @xcite .",
    "an important issue is to check the `` consistency '' of two evolutionary models .",
    "a somewhat simpler ( but nonetheless very important ) version of this issue asks whether a given network is consistent with an existing tree model or not .",
    "this motivates researchers to study the problem of determining whether a tree is displayed by a network or not , called the tree containment problem ( tcp ) .",
    "the cluster containment problem ( ccp ) is another related algorithmic problem that asks whether or not a subset of taxa is a cluster in a tree displayed by a network .",
    "both tcp and ccp have also been investigated in the development of network metrics @xcite    the tcp and ccp are np - complete @xcite , even on a very restricted class of networks @xcite .",
    "van iersel , semple and steel posed an open problem whether or not the tcp is solvable in polynomial time for reticulation - visible networks @xcite .",
    "the visibility property was originally introduced to capture an important feature of galled networks @xcite .",
    "a network is reticulation - visible if every reticulation node separates the network root from some leaves .",
    "real network models are likely reticulation - visible ( see @xcite for example ) .",
    "although great effort has been devoted to the study of the tcp , it has been shown to be polynomial - time solvable only for a couple of very restricted subclasses of reticulation - visible networks @xcite .",
    "other studies related to the tcp include @xcite .    in this paper , we make three contributions .",
    "we give an affirmative answer to the open problem by presenting a cubic time algorithm for the tcp for binary reticulation - visible networks .",
    "additionally , we present a linear - time algorithm for the ccp for binary reticulation - visible networks .",
    "these two algorithms are further modified into polynomial time algorithms for non - binary reticulation - visible networks .",
    "our algorithms rely on an important decomposition theorem , which is proved in section 4 . empowered by it",
    ", we also prove that any arbitrary galled network with @xmath0 leaves has @xmath1 reticulation nodes at most .",
    "the rest of the paper is organized as follows .",
    "section  [ sec2 ] introduces basic concepts and notation .",
    "section  [ sec3 ] lists our main results ( theorems  [ main - theorem ] and  [ main - theorem2 ] ) and gives a brief summary of algorithmic methodologies that lead us to the results . in section  [ sec4 ]",
    ", we present a decomposition theorem ( theorem  [ decomp_thm ] ) that reveals an important structural property of reticulation - visible networks , based on which the two main theorems are respectively proved in section  [ sec5 ] and appendix 3 ( due to page limitation ) .",
    "in phylogenetics , _ networks _ are acyclic digraphs in which a unique node ( the _ root _ ) has a directed path to _ every _ other node and the nodes of indegree one and outdegree zero ( called the _ leaves _ ) are _ uniquely _ labeled .",
    "leaves represent bio - molecular sequences , extant organisms or species under study . in this paper",
    ", we also assume that each non - root node in a network is of either indegree one or outdegree one .",
    "a node is called a _ reticulation _",
    "node if its indegree is strictly greater than one and its outdegree is precisely one .",
    "reticulation nodes represent reticulation events occurring in evolution .",
    "non - reticulation nodes are called _ tree _ nodes , which include the root and leaves .    for convenience in describing the algorithms and proofs , we add an _ open _ incoming edge to the root so that its degree is also 3 ( figure  [ example1 ] ) .",
    "a network is _ binary _ if leaves have degree 1 and all other nodes have degree 3 in the network .",
    "let @xmath2 be a network .",
    "we use the following notation :    * @xmath3 is the root of @xmath2 . *",
    "@xmath4 is the set of all leaves in @xmath2 .",
    "* @xmath5 is the set of all reticulation nodes in @xmath2 .",
    "* @xmath6 is the set of all tree nodes of degree 3 in @xmath2 .",
    "* @xmath7 , which is the set of all nodes in @xmath2 .",
    "* @xmath8 is the set of all edges in @xmath2 .",
    "* for two nodes @xmath9 in @xmath2 : * * @xmath10 is a _ parent _ of @xmath11 or alternatively @xmath11 is a _ child _ of @xmath10 if @xmath12 is a directed edge in @xmath2 , and * * @xmath10 is an _ ancestor _ of @xmath11 or alternatively @xmath11 is a _ descendant _ of @xmath10 if there is a directed path from @xmath10 to @xmath11 . in this case",
    ", we also say @xmath10 is _ below",
    "_ @xmath11 .",
    "* @xmath13 is the set of the parents of @xmath14 or the unique parent of @xmath15 .",
    "* @xmath16 is the set of the children for @xmath17 or the unique child for @xmath14 .",
    "* @xmath18 is the _ subnetwork _ vertex - induced by @xmath19 and all descendants of @xmath10 .",
    "* for any @xmath20 , @xmath21 is the _ subnetwork _ of @xmath2 with the ( same ) node set @xmath22 and the edge set @xmath23 .",
    "* for any subset @xmath24 of nodes of @xmath2 , @xmath25 is the _ subnetwork _ of @xmath2 with the node set @xmath26 and the edge set @xmath27 .",
    "let @xmath2 be a network and @xmath28 .",
    "we say that @xmath10 is _ visible _ ( or stable ) on @xmath11 if every path from the root @xmath3 to @xmath11 _ must _ contain @xmath10 @xcite(also see @xcite ) . in computer science , @xmath10 is called a dominator of @xmath11 if @xmath10 is visible on @xmath11 @xcite .",
    "a reticulation node is _ visible _ if it is visible on some leaf .",
    "a network is _ reticulation - visible _ if every reticulation node is visible . in other words ,",
    "each reticulation node separates the root from some leaves in a reticulation - visible network . the phylogenetic network in figure",
    "[ example1]a is reticulation - visible",
    ". clearly , all trees are reticulation - visible , as they do not contain any reticulation nodes .",
    "in fact , the widely studied tree - child networks and galled networks are also reticulation - visible @xcite .",
    "( * b * ) and the node @xmath29 ( * c * ) . here",
    ", the reticulation nodes are represented by shaded circles .",
    "[ example1],scaledwidth=50.0% ]      _ suppression _ of a node of indegree and outdegree one means that the node is removed and the two edges incident to it are merged into an edge with the same orientation between the two neighbors of it .",
    "a tree @xmath30 is called a _",
    "subdivision _ of another tree @xmath31",
    "if @xmath31 can be obtained from @xmath30 by the suppression of some nodes of indegree and outdegree one in @xmath30 .",
    "consider a binary network @xmath2 in which each reticulation node has two incoming and one outgoing edges .",
    "thus , the removal of one incoming edge for each reticulation node results in a directed tree .",
    "however , there may exist new ( dummy ) leaves in the obtained tree .",
    "for example , after removing @xmath32 , and @xmath33 in the network given in figure  [ example1]a , we obtain the tree shown in figure  [ example1]b in which @xmath29 is a new leaf besides the original leaves @xmath34 ( @xmath35 ) .",
    "if the obtained tree contains such dummy leaves , we will have to remove them and some of their ancestors to obtain a subtree having the _ same _ set of leaves as @xmath2 .",
    "let @xmath2 be a network .",
    "for each @xmath19 , @xmath36 denotes the indegree of @xmath10 .",
    "@xmath2 _ displays _",
    "( or contains ) a phylogenetic tree @xmath31 over the same taxa ( that is @xmath37 ) if @xmath38 and @xmath39 exist such that ( i ) @xmath40 contains exactly @xmath41 incoming edges for each @xmath14 , and ( ii ) @xmath42 is a subdivision of @xmath31 .",
    "because of the existence of dummy leaves , @xmath24 may be nonempty to guarantee that @xmath42 has the same set of leaves as @xmath31 . note that a binary network with @xmath43 reticulation nodes can display as many as @xmath44 trees . the _ tcp _ is to determine whether a network displays a phylogenetic tree or not .",
    "the set of all the labeled leaves in a subtree rooted at a node is called the _ cluster _ of the node in a phylogenetic tree .",
    "an internal node in a network may have different clusters in different trees displayed in the network .",
    "given a _ subset _ of labeled leaves @xmath45 , @xmath46 is a _ soft cluster _ in @xmath2 if @xmath46 is the cluster of a node in some tree displayed in @xmath2 .",
    "ccp _ is to determine whether a subset @xmath46 of @xmath4 is a soft cluster in a network @xmath2 or not .",
    "[ main - theorem ] given a binary reticulation - visible network @xmath2 and a binary tree @xmath31 , the tcp for @xmath2 and @xmath31 can be solved in @xmath47 time .",
    "the ccp is another important problem that has a quadratic - time algorithm for reticulation - visible networks @xcite . here , we design an optimal algorithm for it .",
    "the details of this algorithm are omitted due to page limitation and can be found in appendix 3 .",
    "[ main - theorem2 ] given a binary reticulation - visible network @xmath2 and an arbitrary subset @xmath46 of labeled leaves in @xmath2 , the ccp for @xmath2 and @xmath46 can be solved in @xmath48 time .",
    "* synopsis of algorithmic methodologies *   the reader may wonder why solving the tcp is hard , as after all @xmath2 is an acyclic digraph and @xmath31 is a binary tree . first , it is closely related to the subgraph isomorphism problem ( sip ) . in general , it is very tricky to find out whether a special case of the sip remains np - complete or can be solved in polynomial time .",
    "for example , whether or not a directed tree @xmath49 is a subgraph of an acyclic digraph @xmath50 is np - complete , but can be solved in polynomial time provided that @xmath50 is a forest @xcite .",
    "second , there are non - planar reticulation - visible networks .",
    "hence , algorithmic techniques for planar graphs might not be suitable here .",
    "thirdly , the tcp remains np - complete even for binary networks in which each reticulation node has a tree node as its sibling and another tree - node as its child @xcite .",
    "the tcp has been known to be solved in polynomial time only for tree - child networks @xcite and the so called nearly - stable networks @xcite . in a tree - child network",
    ", each reticulation node is essentially connected to a leaf by a path consisting of only tree nodes .",
    "a simulation study indicates that tree - child networks comprise a very restricted subclass of reticulation - visible networks ( gambette , http://phylnet.univ-mlv.fr/recophync/ ) . in a nearly - stable network",
    ", each child of a node is visible if it is not visible . because of the simple local structure around a reticulation node in such a network , one can determine whether or not it displays a phylogenetic tree by examining reticulation nodes one by one .",
    "however , any approach that works on reticulation nodes one by one is not good enough for solving the tcp for a reticulation - visible network having the structure shown in figure  [ example1 ] if it has a larger number of reticulation nodes above the two reticulation nodes at the bottom . we need to deal with even the whole set of reticulation nodes simultaneously for reticulation - visible networks of this kind .",
    "our algorithms for the tcp and ccp rely primarily on a powerful decomposition theorem ( theorem  [ decomp_thm ] ) .",
    "roughly speaking , the theorem states that , in a reticulation - visible network , all non - reticulation nodes can be partitioned into a collection of disjoint connected components such that each component has at least _ two nodes _ if it does not consist of a single leaf .",
    "most importantly , each component _ contains _ either a network leaf or all the parents of a reticulation node .",
    "the topological property uncovered by this theorem allows us to solve the tcp and ccp by the divide - and - conquer approach : we work on the tree components one - by - one in a bottom - up fashion . in the tcp case ,",
    "when working on a tree component , we simply call a dynamic programming algorithm to decipher all the reticulation nodes right below it . in the ccp case ,",
    "a slightly structural complex ( but faster ) dynamic programming algorithm is used .",
    "in this section , we shall present a decomposition theorem that plays a vital role in designing a fast algorithm for the tcp and ccp .",
    "we first show that reticulation - visible networks have two useful properties .",
    "[ basic_facts ] a reticulation - visible network @xmath2 has the following two properties :    * ( reticulation separability ) the child and the parents of a reticulation node are tree nodes . *",
    "( visibility inheritability ) let @xmath20 . if @xmath21 is connected and @xmath51 , then @xmath21 is also reticulation - visible .",
    "\\(a ) suppose on the contrary there are @xmath52 such that @xmath11 is the child of @xmath10 .",
    "let @xmath53 be another parent of @xmath11 .",
    "since @xmath2 is acyclic , @xmath53 is not below @xmath11 and hence not below @xmath10 . since @xmath53 is not a descendant of @xmath10 ,",
    "there is a path @xmath54 from @xmath3 to @xmath29 that does not contain @xmath10 .",
    "we now prove that @xmath10 is not visible on any leaf by contradiction .",
    "assume @xmath10 is visible on a leaf @xmath55 .",
    "there is a path @xmath56 from @xmath3 to @xmath55 containing @xmath10 .",
    "since @xmath11 is the only child of @xmath10 , @xmath11 appears after @xmath10 in @xmath56 .",
    "define @xmath57 $ ] to be the subpath of @xmath56 from @xmath11 to @xmath55 .",
    "the concatenation of @xmath58 , @xmath59 , and @xmath57 $ ] gives a path from @xmath3 to @xmath55 .",
    "however , this path does not contain @xmath10 , a contradiction .",
    "\\(b ) the proposition follows from the observation that the removal of an edge only eliminates some directed paths and does not add any new path from the root to a leaf .    consider a reticulation - visible network @xmath2 . by proposition  [ basic_facts ] , each reticulation node is incident to only tree nodes .",
    "furthermore , each connected component @xmath60 of @xmath61 ( ignoring edge direction ) is actually a subtree of @xmath2 in which edges are directed away from its root .",
    "indeed , if @xmath60 contains two nodes @xmath10 and @xmath11 both of indegree 0 , where indegree is defined over @xmath61 , the path between @xmath10 and @xmath11 ( ignoring edge direction ) must contain a node @xmath29 with indegree @xmath62 , contradicting that @xmath29 is a tree node in @xmath2 .",
    "hence , the connected components of @xmath63 are called the _ tree - node components _ of @xmath2 .",
    "let @xmath60 be a tree - node component of @xmath2 and @xmath64 denote its vertex set .",
    "it is called a _ single - leaf component _ if @xmath65 for some @xmath66 .",
    "it is a _ big _ tree - node component if @xmath67 .",
    "the binary reticulation - visible network in figure  [ example2]a has four big tree - node components and five single - leaf components .",
    "tree - node components , of which four ( @xmath68@xmath69 ) are the big ones .",
    "( * b * ) a tree for consideration of its containment in the network .",
    "when @xmath70 is first selected , we focus on the path from the root @xmath71 to @xmath72 in the given tree , where @xmath73 , @xmath74 and @xmath75.[example2 ] , scaledwidth=70.0% ]    by definition , any two tree - node components @xmath76 and @xmath77 of @xmath2 are disjoint .",
    "we say @xmath76 is _ below _",
    "@xmath77 if there is a reticulation node @xmath78 such that @xmath77 contains a parent of @xmath78 and the child of @xmath78 is the root of @xmath76 .",
    "[ decomp_thm ] ( * decomposition theorem * ) let @xmath2 be a reticulation - visible network with @xmath79 tree - node components @xmath80 .",
    "the following statements are true :    * @xmath81 .",
    "* for each reticulation node @xmath78 , its child @xmath82 is the root of some @xmath83 , and each of its parents is a node in a different @xmath84 .",
    "* for each tree - node component @xmath85 , * * @xmath86 iff @xmath87 for some @xmath66 ( i.e. it is a single - leaf component ) , and * * if @xmath85 is big , either @xmath85 contains a network leaf or a reticulation node @xmath78 exists such that its parents are all in @xmath85 . * a big tree - node component @xmath60 exists such that there are only single - leaf components below it .",
    "\\(i ) the set equality follows from the fact that the tree - node components are all the connected components of @xmath88 .",
    "\\(ii ) let @xmath89 . by the _ reticulation separability _ property in proposition  [ basic_facts ] , @xmath82 and the parents of @xmath78 are all tree nodes .",
    "thus , by ( i ) , each of them is in a tree - node component .",
    "furthermore , since @xmath82 is of indegree 0 in @xmath61 , @xmath82 must be the root of the tree - node component where it is found .",
    "\\(iii ) ( a ) let @xmath60 be a tree - node component such that @xmath90 .",
    "assume @xmath91 . since @xmath10 is the only non - leaf tree node in @xmath60 , @xmath92 and @xmath93 .",
    "any leaf descendant of @xmath13 must be below some child of @xmath10 .",
    "let @xmath94 be the children of @xmath10 . since @xmath43 is finite and @xmath2 is acyclic",
    ", there is a subset @xmath95 of @xmath96 children @xmath97 such that ( i ) @xmath98 is not below any node in @xmath16 for each @xmath99 , and ( ii ) each child in @xmath16 is either in @xmath95 or below some child in @xmath95 . for each @xmath100 , using the same argument as in the proof of the part ( a ) of proposition  [ basic_facts ] , we can prove that for each leaf @xmath55 below @xmath98 , there is path from @xmath3 to @xmath55 not containing @xmath13 . since any leaf below @xmath13 must be below some child in @xmath95 , @xmath13 is not visible .",
    "this contradicts the fact that @xmath2 is reticulation - visible .",
    "therefore , @xmath90 if and only it is a single - leaf component .",
    "\\(b ) assume that @xmath60 is a big tree - node component of @xmath2 , that is , @xmath101 .",
    "let @xmath102 be the root of @xmath60 .",
    "@xmath102 and its reticulation parent are visible on some network leaf , say @xmath55 . if @xmath55 is in @xmath60 , we are done .",
    "if @xmath55 is not in @xmath103 , we define @xmath104 . for any @xmath105",
    ", we write @xmath106 if @xmath107 is below @xmath108 , that is , there is a direct path from @xmath108 to @xmath107 . since @xmath109 is transitive",
    ", @xmath110 is finite and @xmath2 is acyclic , @xmath110 contains a maximal element @xmath111 with respect to @xmath109 .",
    "let @xmath112 .",
    "since @xmath113 , we may assume that @xmath114 . if @xmath115 for some @xmath116 , @xmath117 is not below any node in @xmath60 , as @xmath2 is acyclic and @xmath111 is maximal under @xmath109 .",
    "hence , there is a path @xmath118 from @xmath119 to @xmath117 that does not contain any node in @xmath60 . since @xmath55 is a descendant of @xmath111 , @xmath118",
    "can be extended into a path from @xmath119 to @xmath55 that does not contain @xmath102 .",
    "this contradicts that @xmath102 is visible on @xmath55 .",
    "therefore , the parents of @xmath111 are all in @xmath60 .",
    "\\(iv ) it is derived from the fact that @xmath2 is acyclic .",
    "* time complexity for finding tree - node decomposition * let @xmath2 be a binary reticulation - visible network . since @xmath2 is a dag and has at most @xmath120 nodes @xcite",
    ", we can determine the tree - node components using the breadth - first search technique in @xmath48 time .",
    "additionally , a topological ordering of its nodes can also be found in @xmath48 time .",
    "using such a topological ordering , we can derive a topological ordering for the big tree - node components . with this ordering",
    ", we can identify a lowest tree - node component described in theorem  [ decomp_thm](iv ) in constant time .    for non - binary networks , the above process for determining the big tree - node components and a lowest one in @xmath121 time .",
    "we will use the decomposition theorem to develop fast algorithms for the tcp in section  [ sec5 ] .",
    "the theorem also seems to be very useful for studying the combinatorial aspects of networks .",
    "a network is galled if each reticulation node @xmath78 has an ancestor @xmath10 such that two internal - node disjoint paths exist from @xmath10 to @xmath78 in which all nodes except @xmath78 are tree nodes .",
    "galled networks are reticulation - visible @xcite .    [ bound ] for any arbitrary galled network @xmath2 with @xmath0 leaves , @xmath122 .",
    "let @xmath2 be a galled network with @xmath0 leaves .",
    "it is reticulation - visible @xcite .",
    "we consider the tree - node components of @xmath2 . since the root of each tree - node component is either the network root or the unique child of a reticulation , latexmath:[\\[\\begin{aligned } \\label{key_eqn }",
    "we first show that @xmath2 does not contain any cross reticulations .",
    "suppose on the contrary @xmath2 contains a cross reticulation @xmath78 . by the definition of cross reticulation , the parents of @xmath78 are in different tree - node components .",
    "assume @xmath124 and @xmath125 are two parents of @xmath78 in different tree - node components .",
    "since @xmath2 is acyclic , we may assume that _",
    "@xmath124 is not below @xmath125_. let @xmath126 be the tree - node components containing @xmath127 for @xmath128 .",
    "we consider the parent @xmath107 of @xmath129 .",
    "@xmath107 is a reticulation node .",
    "furthermore , @xmath125 is below @xmath107 and hence @xmath78 is also below @xmath107 .",
    "however , we can reach @xmath78 from @xmath124 using a single edge without passing through @xmath107 , contradicting the separation lemma for galled networks @xcite .",
    "we have proved that @xmath2 does not contain any cross reticulations .",
    "therefore , all the tree - node components are connected in a tree structure .",
    "precisely , if @xmath50 is the graph whose nodes are the tree - node components in which a node @xmath130 is connected to another @xmath131 by a directed edge if the tree - node components represented by them are separated by a reticulation node between them , @xmath50 is then a rooted tree .",
    "consider a leaf @xmath132 in @xmath50 . if the tree - node component represented by @xmath132 is not a single - leaf component in @xmath2 ,",
    "there is no reticulation node below it and thus it must contain a leaf of @xmath2 .",
    "therefore , @xmath50 has at most @xmath0 leaves and thus at most @xmath133 nodes . in other words",
    ", @xmath2 contains at most @xmath133 tree - node components . by eqn .",
    "( [ key_eqn ] ) , @xmath134",
    "in this section , we first present a polynomial - time algorithm for the tcp in the case when the given reticulation - visible network is binary . then",
    ", we describe how to modify the algorithm into one for non - binary networks .      in this subsection , we assume the given network is _ binary _ in which a tree node has two children and a reticulation node has two parents .",
    "we remark that each internal node has two children in a phylogenetic tree .",
    "let @xmath2 be a binary reticulation - visible network and @xmath31 be a tree over the same leaves .",
    "a reticulation node in @xmath2 is _ inner _ if its parents are all in the _ same _ tree - node component of @xmath2 .",
    "it is called a _ cross _",
    "reticulation otherwise . by theorem  [ decomp_thm ] ,",
    "there exists a `` lowest '' big tree - node component @xmath60 below which there are only ( if any ) single - leaf components ( figure  [ fig3 ] ) .",
    "we assume that @xmath60 contains @xmath43 network leaves , say @xmath135 , and there are :    * @xmath79 inner reticulations @xmath136 , and * @xmath0 cross reticulations @xmath137    below @xmath60 . since @xmath60 is a big tree - node components , it has two or more nodes , implying that @xmath138 .",
    "let @xmath102 denote the root of @xmath60 .",
    "we further define : @xmath139 by theorem  [ decomp_thm](iii)(b ) , @xmath140 and so @xmath141 is non - empty .",
    "each path @xmath118 from @xmath3 to @xmath142 must contain @xmath143 .",
    "since the parents of @xmath143 are all in @xmath60 , @xmath118 must contain @xmath102 .",
    "hence , @xmath102 is visible on each network leaf in @xmath141 .",
    "we select an @xmath144 .",
    "since @xmath31 has the same leaves as @xmath2 , @xmath145 and there is a unique path @xmath146 from @xmath147 to @xmath55 in @xmath31 .",
    "let : @xmath148 where @xmath149 and @xmath150 .",
    "then , @xmath151 is a union of @xmath152 disjoint subtrees @xmath153 , where @xmath154 is the subtree rooted at the sibling of @xmath155 for each @xmath156 ( see figure  [ example2]b ) . for the sake of convenience , we consider the single leaf @xmath55 as a subtree , written as @xmath157 .",
    "we now define @xmath158 as : @xmath159 since @xmath160 , @xmath158 is well defined . in the example",
    "given in figure  [ example2 ] , @xmath161 .",
    "[ prop_51 ] the index @xmath158 can be computed in @xmath48 time .    since @xmath31 is a binary tree with the same set of labeled leaves as the network @xmath2 .",
    "@xmath31 has @xmath162 nodes and @xmath163 edges . for each @xmath164 , we define a flag variable @xmath165 to indicate whether the subtree below @xmath29 contains a network leaf in @xmath141 or not .",
    "we first traverse @xmath31 in the post - order :    * for a leaf @xmath166 , @xmath167 if @xmath168 and 0 otherwise .",
    "* for an non - leaf node @xmath29 with children @xmath169 and @xmath170 , @xmath171 .",
    "then , we compute @xmath158 as @xmath172 clearly , this algorithm correctly computes @xmath158 in @xmath173 time .",
    "[ prop52 ] if @xmath2 displays @xmath31 , then @xmath174 is displayed in @xmath175 .",
    "when @xmath176 , then the statement is trivial , as @xmath102 is visible on @xmath55 and thus every path from the network root to @xmath55 must contain @xmath102 .    when @xmath177 , by the definition of @xmath158 , there is a network leaf @xmath178 in @xmath179 such that @xmath180 .",
    "if @xmath2 displays @xmath31 , @xmath31 has a subdivision @xmath30 in @xmath2 .",
    "recall that @xmath102 is visible on both @xmath55 and @xmath178 .",
    "the paths from @xmath181 to @xmath55 and to @xmath178 in @xmath30 must both contain @xmath102 . since @xmath30 is a tree ,",
    "the lowest common ancestor @xmath182 of @xmath55 and @xmath178 is a descendant of @xmath102 in @xmath30 and it is the node in @xmath30 that corresponds to @xmath183 .",
    "therefore , the subnetwork of @xmath30 below @xmath182 is a subdivision of @xmath174 , that is , @xmath175 displays @xmath174 .",
    "if @xmath2 displays @xmath31 , then @xmath60 may display more that @xmath174 .",
    "in other words , it may display a subtree @xmath184 for some @xmath185 .",
    "we define : @xmath186 in the example given in figure  [ example2 ] , @xmath187 .",
    "[ prop53 ] if @xmath2 displays @xmath31 , there must be a subdivision @xmath188 of @xmath31 in @xmath2 such that the node ( in @xmath188 ) corresponding to @xmath189 is in @xmath60 .",
    "assume that @xmath2 displays @xmath31 via a subdivision @xmath30 of @xmath31 .",
    "let @xmath10 be the node in @xmath30 that corresponds to @xmath189 .",
    "since @xmath102 is visible on the leaf @xmath55 , @xmath102 is in the unique path @xmath118 from the root to @xmath55 in @xmath30 .",
    "if @xmath10 is @xmath102 or below it , we are done .",
    "assume that @xmath10 is neither @xmath102 nor below @xmath102 in @xmath30 . since @xmath55 is a network leaf below @xmath189 in @xmath31",
    ", @xmath55 is also below @xmath10 in @xmath30 .",
    "hence , @xmath118 must also contain @xmath10 . since @xmath10 is not below @xmath102",
    ", @xmath102 must be below @xmath10 in @xmath118 .    on the other hand , by assumption",
    ", @xmath190 is displayed in @xmath191 .",
    "it has a subdivision @xmath192 in @xmath191 .",
    "let @xmath189 correspond to @xmath193 in @xmath192 .",
    "it is not hard to see that @xmath193 is in the path from @xmath102 to @xmath55 in @xmath192 .",
    "let @xmath56 be the subpath from @xmath10 to @xmath102 of @xmath118 and @xmath194 be the path from @xmath102 to @xmath193 in @xmath60 .",
    "since the subtree below @xmath193 in @xmath192 and the subtree below @xmath10 in @xmath30 has the same set of labeled leaves as the subtree below @xmath189 in @xmath31 , @xmath195 is also a subdivision of @xmath31 in @xmath2 , in which @xmath189 is mapped to @xmath193 in @xmath60 . here , @xmath196 is the graph with the same node set as @xmath50 and the edge set being the union of @xmath197 and @xmath198 for graphs @xmath50 and @xmath49 such that @xmath199 .     in a binary reticulation - visible network and",
    "the corresponding tree @xmath200 constructed for computing @xmath201 in proposition  [ prop_55].[fig3 ] , scaledwidth=60.0% ]    to compute @xmath201 defined in eqn.([eq3 ] ) , we create a tree @xmath200 from @xmath60 by attaching two identical copies of the network leaf below each @xmath202 to its parents in @xmath203 in @xmath60 and one copy of the network leaf below @xmath204 to the parent in @xmath205 .",
    "that is , @xmath200 has the node set : @xmath206 and the edge set @xmath207 where @xmath208 , @xmath209 , and @xmath210 are new leaves with the same label as @xmath82 for each @xmath78 in @xmath211 or @xmath212 .",
    "@xmath200 is illustrated in figure  [ fig3 ] .",
    "[ prop_55 ] there is a dynamic programming algorithm that takes @xmath200 and @xmath31 as input and outputs @xmath201 defined in eqn .",
    "( [ eq3 ] ) in @xmath213 time .",
    "it is a special case of a problem studied in @xcite .    for each @xmath202 , @xmath200 contains two leaves with the same label as @xmath82 . to detect whether or not @xmath214 is displayed in @xmath215 , we have to consider which of these two leaves will be removed .",
    "such leaves will be referred to the _ ambiguous _ leaves .",
    "we use @xmath216 to denote the set of ambiguous leaves in @xmath200 .    for each @xmath204",
    ", @xmath200 contains one leaf with the same label as @xmath82 .",
    "similar to the case of ambiguous leaves , this leaf may be removed or kept .",
    "such leaves are called _ optional _ leaves .",
    "we use @xmath217 to denote the set of optional leaves in @xmath200 .    since each node in @xmath60 is a tree node of degree 3 in @xmath2",
    ", @xmath200 is a full binary tree with at most @xmath218 nodes .    for our purpose , we shall present a dynamic programming algorithm to compute the following set @xmath219 of nodes in @xmath31 : @xmath220 for each node @xmath10 in @xmath200 . here , that @xmath221 displays @xmath222 means that @xmath223 exists such that @xmath224 is a subdivision of @xmath222 . since @xmath200 is a tree , @xmath225 consists of all the ambiguous or optional leaves that are in @xmath221 but not in @xmath222 and some ancestors of these leaves .",
    "we introduce a boolean variable @xmath226 to indicate whether or not @xmath221 displays @xmath222 and a set variable @xmath227 to record those removed leaves if so .",
    "that is , @xmath228 and @xmath229 if @xmath230 , where @xmath231 denotes the set of leaves below @xmath170 in the tree @xmath131 .",
    "when @xmath10 is a leaf in @xmath200 , we consider whether @xmath29 is a leaf or not to compute @xmath226 .",
    "if @xmath29 is a leaf with the same label as @xmath10 , then @xmath221 displays @xmath222 and thus we set @xmath230 and @xmath232 .",
    "if @xmath29 is a leaf and its label is different from the label of @xmath10 , @xmath221 does not display @xmath222 . in this case",
    ", @xmath233 and @xmath227 is undefined .",
    "if @xmath29 is not a leaf , it is trivial that @xmath221 does not display @xmath222 .",
    "hence , @xmath233 and @xmath227 is undefined .",
    "when @xmath10 is an internal node with children @xmath11 and @xmath53 in @xmath200 , we consider similar cases .",
    "if @xmath29 is a leaf , @xmath222 may or may not be displayed in @xmath221 if it is displayed below a child of @xmath10 . if @xmath222 is displayed below @xmath11 , it is also displayed at @xmath10 only if every ambiguous leaf in @xmath234 is not below @xmath53 and all the leaves below @xmath53 are either ambiguous or optional .",
    "if @xmath222 is displayed below neither @xmath11 nor @xmath53 , it is not displayed at @xmath10 .",
    "the remaining cases can be found in table  [ table1 ]    .the recursive formulas on @xmath226 for different cases when @xmath10 is an internal node in @xmath200 .",
    "[ table1 ] [ cols=\"^,^,^,<\",options=\"header \" , ]     using eqn .",
    "( [ 13eqn ] ) and ( [ 14eqn ] ) , we can pre - compute @xmath235 and @xmath236 for all @xmath202 in @xmath237 time .",
    "when @xmath226 is updated , we need to check whether or not @xmath238 and @xmath239 for each @xmath240 and each child @xmath241 .",
    "this can be done in @xmath242 time .",
    "similarly , the condition ( i ) is independent of @xmath29 and can be checked in @xmath242 time ; the condition ( ii ) can be checked in @xmath243 time .",
    "hence , for all nodes @xmath29 in @xmath31 , the run time for updating @xmath226 in @xmath200 takes latexmath:[$o(\\sum_{u\\in { \\cal v}(t_c ) } ( |c(u)| + |\\mbox{ir}(c)|))=o(|{\\cal e}(t_c)|+|\\mbox{ir}(c)| \\cdot    @xmath200 for all nodes in @xmath31 is @xmath245\\ ; ) $ ] time .",
    "therefore , the total run time for determining whether or not @xmath31 is displayed in @xmath2 is @xmath246)=o(|{\\cal v}(t)|\\cdot |{\\cal e}(n)|\\cdot |{\\cal r}(n)|)$ ] time . in general , @xmath247 is not bounded by any function linear in the number of leaves in an arbitrary network .",
    "as another application of the decomposition theorem , we shall design a linear - time algorithm for the ccp .",
    "we first present a desired algorithm for binary reticulation - visible networks and then generalize it to non - binary networks .      given a binary reticulation - visible network @xmath2 and a subset @xmath248 , the goal is to determine whether or not @xmath46 is a cluster of some node in a tree displayed by @xmath2 .",
    "assume @xmath2 has @xmath152 big tree - node components @xmath249 consider a lowest big tree - node component @xmath60 .",
    "we use the same notation as in section  [ sec5 ] : @xmath141 is defined in eqn .",
    "( [ eq0 ] ) ; @xmath102 denotes the root of @xmath60 ; @xmath211 and @xmath250 denote the set of inner and cross reticulations below @xmath60 , respectively .",
    "we also set @xmath251 .",
    "when @xmath252 and @xmath253 , @xmath141 contains @xmath254 and @xmath255 such that @xmath256 , but @xmath257 .",
    "if @xmath46 is the cluster of a node @xmath170 in a subtree @xmath30 of @xmath2 , @xmath170 is in the unique path @xmath118 from @xmath181 ( @xmath258 ) to @xmath254 in @xmath30 .",
    "assume @xmath170 is between @xmath3 and @xmath102 in @xmath118 , no matter which incoming edge is contained in @xmath30 for each @xmath202 , @xmath259 is below @xmath102 , as @xmath102 is visible on @xmath259 .",
    "this implies that @xmath259 is below @xmath170 and thus in @xmath46 , a contradiction .",
    "therefore , if @xmath46 is a soft cluster , it must be a soft cluster of a node in @xmath60 .    when @xmath260 ( that is , @xmath261 ) , we define @xmath262    construct a subtree @xmath30 of @xmath191 by deleting :    * all but one of the incoming edges for each @xmath263 , * all incoming edges but one with a tail not in @xmath60 for each @xmath264 , and * all incoming edges but one with a tail in @xmath60 for each @xmath265 .",
    "we then define @xmath266 it is not hard to see that @xmath267 is the cluster of the root of @xmath30 such that @xmath268 . hence , if @xmath269 , then @xmath46 is a cluster contained in @xmath191 . if @xmath270 , we reconstruct @xmath271 from @xmath2 by :    * removing all the edges in @xmath272 , * removing all the edges in @xmath273 , * removing all but one of edges in @xmath274 , and * replacing @xmath191 by a new leaf @xmath275 .    and set @xmath276 .",
    "we have the following fact .    [ prop_61 ] if @xmath260 , @xmath46 is contained in @xmath2 if and only if @xmath277 is contained in @xmath271 .",
    "recall that @xmath278 . if @xmath277 is the cluster of a node @xmath170 in a tree @xmath188 displayed in @xmath271 .",
    "when @xmath271 was reconstrcuted , @xmath275 replaced the subtree @xmath30 rooted at @xmath102 whose leaves are @xmath267 ; so if we re - expand @xmath275 into @xmath30 , the cluster of @xmath170 in @xmath2 becomes @xmath279 , thus @xmath46 is contained in @xmath2 .",
    "assume @xmath46 is the cluster of a node @xmath170 in a subtree @xmath31 displayed in @xmath2 .",
    "let @xmath40 be the set of edges entering the reticulations nodes such that @xmath280 .",
    "since @xmath281 , there is a leaf @xmath282 not below @xmath102 . since @xmath283 is below @xmath170 in @xmath31 , @xmath170 must be above @xmath102 in @xmath31 .",
    "consider a reticulation node @xmath284 .",
    "since @xmath82 is a leaf in @xmath46 , it is a leaf below @xmath170 in @xmath31 . by definition of cross reticulation",
    ", @xmath78 has at least one parent in @xmath60 .",
    "let @xmath285 be an edge such that @xmath286 .",
    "note that all but one of that incoming edges of @xmath78 are in @xmath40 .",
    "define @xmath287 \\cup   \\ { ( p , r ) \\in { \\cal e}(n ) \\;|\\ ; r\\in \\mbox{cr}(c)\\backslash x \\ ; \\ & \\ ; p\\notin { \\cal v}(c ) \\}\\ ] ] .",
    "it is not hard to see that @xmath285 is the unique incoming edge of @xmath78 not in @xmath288 for each @xmath289 .",
    "let @xmath290 .",
    "it is easy to see that the cluster of @xmath170 is equal to @xmath46 and @xmath267 is the cluster of @xmath102 in @xmath30 .",
    "therefore , if we contract the subtree below @xmath102 into a single leaf @xmath275 , the cluster of @xmath170 becomes @xmath291 , which is @xmath277 .",
    "therefore , @xmath277 is contained in @xmath271 .    when @xmath292 , @xmath46 may or may not be contained in @xmath191 .",
    "if it is not , we use @xmath130 defined in eqn .",
    "( [ eq_x ] ) to reconstruct @xmath271 from @xmath2 by :    * removing all the edges in @xmath293 , * removing all the edges in @xmath294 , and * replacing @xmath191 by a new leaf @xmath275 .",
    "similar to the last case , we have the following fact .",
    "[ prop_62 ] if @xmath46 is not in @xmath191 and @xmath295 , it is a soft cluster in @xmath2 if and only if @xmath46 is a soft cluster in @xmath271 .",
    "@xmath271 is a subnetwork of @xmath2 .",
    "if @xmath46 is a soft cluster in @xmath271 , it is a soft cluster in @xmath2 .",
    "conversely , assume @xmath46 is the cluster of a node @xmath170 in a subtree @xmath31 of @xmath2 .",
    "let @xmath40 be the set of reticulation edges such that @xmath280 . by assumption , @xmath46",
    "is not contained in @xmath191 .",
    "since @xmath102 is visible on all leaves in @xmath141 , @xmath102 is not below @xmath170 in @xmath30 .",
    "therefore , @xmath102 and @xmath170 do not have ancestral relationship .",
    "consider a reticulation @xmath296 . since @xmath78 is a cross reticulation",
    ", it has a parent @xmath297 in @xmath60 .",
    "if @xmath298 , @xmath82 is a leaf below @xmath170 in @xmath31 and thus the unique incoming edge not in @xmath40 has a tail not in @xmath60 . if @xmath299 , the unique incoming edge not in @xmath40 may or may not have a tail in @xmath60 .",
    "we define : @xmath300 note that @xmath285 is the unique incoming edge of @xmath78 not in @xmath288 for each @xmath301 such that @xmath302 .",
    "let @xmath290 .",
    "it is easy to see that the cluster of @xmath170 in @xmath30 remains the same as the cluster of @xmath170 in @xmath31 , which is equal to @xmath46 .",
    "if we contract @xmath303 into a single leaf @xmath275 , @xmath30 is a subtree of @xmath271 , implying that @xmath46 is a soft cluster in @xmath271 .",
    "we next show that whether or not @xmath46 is in @xmath60 can be determined in linear time .",
    "[ prop63 ] let @xmath200 be a subtree constructed from @xmath60 in eqn.([eq4 ] ) and ( [ eq5 ] ) .",
    "an algorithm exists that takes @xmath200 and @xmath46 as inputs and determines whether or not @xmath46 is a soft cluster in @xmath60 in @xmath304 time .",
    "first , we check whether or not each of the leaves in @xmath46 is below @xmath102 .",
    "if @xmath305 , @xmath46 is not a soft cluster in @xmath306 .",
    "we assume that @xmath307 and all its leaves are found below @xmath102 .",
    "assume @xmath46 is a cluster of a node @xmath11 in a subtree @xmath31 of @xmath308 .",
    "clearly , any network leaf in @xmath60 is not below @xmath11 if it is not in @xmath46 .",
    "for each @xmath202 , @xmath309 exists such that @xmath310 was removed . if @xmath311 , the parent of @xmath78 other than @xmath312 must not be below @xmath11 .",
    "since @xmath46 is not singleton , @xmath11 is an internal node in @xmath200 . taken together ,",
    "these facts imply that @xmath11 satisfies the following properties :    * every leaf in @xmath46 is below @xmath11 .",
    "* if a leaf below @xmath11 is neither ambiguous nor optional , it must be in @xmath46 .",
    "* if the ambiguous leaves introduced for a @xmath202 are both below @xmath11 , then @xmath313 .",
    "conversely , if an internal node @xmath11 of @xmath200 satisfies the above three properties , we can then construct a subtree @xmath31 of @xmath2 in which @xmath46 is the cluster of @xmath11 as follows :    * for each @xmath314 below @xmath11 , if it has a parent @xmath124 below @xmath11 and another parent @xmath125 not below @xmath11 , remove @xmath315 if @xmath82 is in @xmath46 and remove @xmath316 otherwise . *",
    "for any other reticulation node not below @xmath11 , choose an arbitrary incoming edge to remove .",
    "it is easy to verify that @xmath46 is a cluster of @xmath11 in the resulting tree .",
    "assume @xmath46 is a cluster of an internal node @xmath11 in @xmath191 and @xmath317 .",
    "if @xmath55 is not the child of an inner reticulation node below @xmath60 , then @xmath11 is contained in the path from @xmath102 to @xmath55 in @xmath200 .",
    "otherwise , @xmath11 is contained in the path from @xmath102 to one of the ambiguous leaves defined for @xmath55 in @xmath200 .    based on the above facts , we obtain algorithm 1 ( table  [ table3 ] ) to determine whether @xmath46 is a cluster in @xmath60 .",
    "l + input : @xmath200 and a subset @xmath46 of leaves in @xmath318 ; + 1 . if @xmath319 , output  yes \" and exit",
    "; + 2 . set @xmath320 and @xmath321 +  set a @xmath43-tuple @xmath322 $ ] ; / * record if a leaf in @xmath46 has been seen * / +  set a @xmath79-tuple @xmath323$]l ; +   /*use @xmath324 to record the copies of @xmath325 have not been seen so far * / + 3 .",
    "select @xmath317 .",
    "+ each leaf @xmath29 in @xmath200 that has the same label as @xmath55 @xmath326 + 3.1 @xmath327 ; @xmath328 ; / * @xmath329 is the no .  of leaves in @xmath46",
    "have been seen so far * / + 3.2 for each @xmath96 from @xmath330 to @xmath43 , @xmath331=0 $ ] ; + 3.3 for each @xmath96 from 1 to @xmath79 +  if ( the @xmath332 leaf @xmath333 is ambiguous or optional ) @xmath334=2 $ ] else @xmath334=1 $ ] ; + 3.4 * repeat * while @xmath335 @xmath326 + @xmath336 ; @xmath337 ; @xmath338 ; + each @xmath178 in the subtree \\ { / * traverse the subtree @xmath200 rooted at @xmath339 * / + ( @xmath340 having rank @xmath99 ) & ( @xmath341== 0 $ ] ) \\ { @xmath341= 1 ;   f = f + 1 $ ] } ; + ( @xmath333 having rank @xmath99 ) + @xmath342=z[j]- 1 $ ] ; if ( @xmath342==0 $ ] ) * stop * step 3.4 ; + } / * end for * / + ( @xmath343 ) output  yes \" and * exit * ; + } / * end repeat * / + } / * end the outer for * / + 4 . output  no \" and * exit * ; +    the correctness of the algorithm follows from the following facts . when the algorithm stops with answer",
    " no \" during the traversal of the subtree branching off at @xmath10 in the path from @xmath344 to the leaf @xmath29 .",
    "it means that two ambiguous copies of a leaf not in @xmath46 have been seen in the subtree below @xmath10 .",
    "this implies that for any descendant @xmath53 of @xmath10 , not all leaves in @xmath46 have been seen below @xmath53 and for @xmath10 and each of its ancestor , some leaf not in @xmath46 has two ambiguous copies below it .",
    "hence , no node exists in the path from the root to @xmath29 in @xmath200 that satisfies the properties ( i)-(iii ) .",
    "when the algorithm exists at step 4 , @xmath46 is clearly not a soft cluster in @xmath60 .    when the algorithm stops with answer ",
    "yes \" at @xmath10 inside step 3.4 , @xmath10 is the lowest node satisfying the three properties .",
    "hence , @xmath46 is a soft cluster in @xmath60 .",
    "next , we analyze the complexity of algorithm 1 .",
    "step 1 and step 2 can be done in @xmath345 time .",
    "since there are at most two leaves with that same label as @xmath55 in @xmath200 , outer for - loop will execute twice at most . at each execution of the for - loop ,",
    "steps 3.1 - 3.3 take @xmath345 time . in step 3.4 , we may traverse different subtree of @xmath200 that branch off at a node in the path from the root of @xmath200 to @xmath29 , so the total running time for step 3.4 is @xmath304 . hence , the algorithm runs in @xmath346 , as @xmath347 in a binary network .    taking all the above facts together , we are able to give a linear time algorithm for the ccp .",
    "l + * input : * a binary network @xmath2 and a subset @xmath45 ; + 1 . compute the big tree - node components sorted in a topological order : +  @xmath348 ; + 2 .",
    "* for * @xmath349 * to * @xmath152 * do * @xmath326 + 2.1 .",
    "set @xmath350 ; compute @xmath351 defined in eqn .",
    "( 1 ) ; + 2.2 .",
    "@xmath352 ; + 2.3 .",
    "* if * ( @xmath353 ) output  yes \" and * exit * ; + 2.4 .   * if * ( @xmath354 ) @xmath326 +   @xmath355 ; +   * if * ( @xmath356 & @xmath357 ) output  no \" and * exit * ; +   * if * ( @xmath358 ) @xmath326 +   remove edges in @xmath359 ; +   remove edges in @xmath360 ; +   @xmath361 +   * if * ( @xmath362 ) @xmath326 +   remove edges in @xmath363 ; +   remove edges in @xmath364 ; +   @xmath365 ; +   @xmath361 +   replace @xmath191 by a leaf @xmath366 ; +   remove @xmath60 from the list of big tree - node components ; +   update @xmath367 for affected big tree - node components @xmath76 ; +  @xmath361 + @xmath361 / * for * / +   +    the obtained ccp algorithm runs in linear time",
    ". step 1 takes @xmath368 time , as @xmath2 is binary .",
    "step 2 is a for - loop that runs @xmath152 times .",
    "since the total number of the network leaves in @xmath85 and the reticulation nodes below @xmath85 is at most @xmath369 , step 2.1 takes @xmath370 time for each execution . in step 2.2 , the linear - time algorithm 1 is called to compute @xmath131 in @xmath370 time .",
    "obviously , step 2.3 takes constant time . to implement step 2.4 in linear time , we need to use an array @xmath371 to indicate whether a network leaf is in @xmath46 or not",
    "@xmath371 can be constructed in @xmath48 time . with @xmath371 , each conditional clause in step 2.4",
    "can be determined in @xmath372 time , which is at most @xmath370 .",
    "since the total number of inner and cross reticulations is at most @xmath373 , each line of step 2.4 takes at most @xmath370 time .",
    "hence , step 2.4 still takes @xmath370 time . taking all these together",
    ", we have that the total time taken by step 2 is @xmath374 therefore , theorem  [ main - theorem2 ] is proved .      propositions 6.1 and 6.2 have been proved for non - binary reticulation - visible networks .",
    "the straightforward generalization of algorithm 1 does not give a linear - time algorithm for determining whether a subset @xmath46 of leaves is a soft cluster in @xmath375 for non - binary networks , as the outer for - loop in step 3.4 will run @xmath43 times if @xmath200 contains @xmath43 ambiguous / optional leaves that have the same label as the selected leaf in @xmath46 .",
    "however , it is widely known that the lowest common ancestor ( lca ) of any two nodes in a tree can be computed in @xmath376 after a linear - time pre - processing . in the rest of this subsection , we will use this result to prove proposition 6.3 for non - binary networks .",
    "given a non - binary reticulation - visible network @xmath2 and a @xmath248 such that @xmath377 , we work on a lowest big tree - node component @xmath60 of @xmath2 .",
    "let @xmath200 be the tree defined in eqn .",
    "( [ eq44 ] ) and ( [ eq55 ] ) . for each @xmath202",
    ", @xmath378 denotes the set of ambiguous leaves defined in eqn .",
    "( [ ar - def ] ) and @xmath379 denotes the lca of the leaves in @xmath378 .",
    "[ prop64 ] all the nodes in @xmath380 can be computed in @xmath381 time .",
    "we first pro - process @xmath200 in @xmath382 time so that for any two nodes @xmath10 and @xmath383 in @xmath200 , @xmath384 can be find in @xmath376 time @xcite .    initially , each lca node is undefined .",
    "we visit all leaves in @xmath200 in a depth - first manner .",
    "when visiting a leaf @xmath55 that is ambiguous and added for @xmath202 , we set @xmath385 if @xmath379 is undefined , and @xmath386 otherwise .",
    "since each lca operation takes @xmath376 time , the whole process takes @xmath381 time .",
    "[ prop65 ] ( i ) let @xmath55 be a leaf in @xmath200 that is neither ambiguous nor optional .",
    "if @xmath387 , @xmath46 is not a soft cluster of any node @xmath10 in the path from @xmath102 to @xmath55 in @xmath2 .",
    "\\(ii ) for each @xmath202 such that @xmath299 , @xmath46 is not a soft cluster of any @xmath10 in the path from @xmath102 to @xmath388 inclusively in @xmath2 .",
    "\\(i ) since @xmath55 is neither ambiguous nor optional , all the nodes in the path from @xmath102 to @xmath55 appears in any subtree @xmath31 of @xmath2 .",
    "since @xmath325 , so , the cluster of each node in the path is not equal to @xmath46 .",
    "\\(ii ) for an inner reticulation node @xmath78 below @xmath60 , @xmath389 contains at least two ambiguous leaves and thus @xmath379 is an internal node in @xmath60 .",
    "any subtree @xmath31 of @xmath2 contains exactly one incoming edge of @xmath78 below @xmath379 .",
    "thus , the cluster of each node @xmath10 in the path from @xmath102 to @xmath379 in @xmath31 must contain @xmath82 and hence is not equal to @xmath46 .",
    "let @xmath390 be the spanning subtree of @xmath200 over @xmath391 , where @xmath216 and @xmath217 are the set of ambiguous and optional leaves in @xmath200 , respectively .",
    "clearly , @xmath390 is rooted at @xmath102 .",
    "we further define @xmath392 .",
    "[ prop66 ] @xmath46 is a soft cluster in @xmath375 if and only if a node @xmath393 exists such that for each @xmath394 there is a leaf below @xmath11 with the same label as @xmath55 .",
    "assume @xmath46 is a soft cluster of a node @xmath10 in @xmath375 . by proposition  [ prop65 ] ,",
    "@xmath10 is not in @xmath390 and thus it is below some @xmath393 . for any @xmath317 , @xmath10 and",
    "hence @xmath11 has a leaf descendant having the same label as @xmath55 .",
    "let @xmath393 satisfy the property that for each @xmath394 , there is a leaf @xmath178 having the same label as @xmath55 . for each @xmath395",
    "such that @xmath396 , by the definition of @xmath397 , @xmath398 contains an ambiguous leaf not below @xmath11 . for this @xmath29",
    ", we select a parent @xmath399 of @xmath78 not below @xmath11 in @xmath60 .    for each @xmath400 such that @xmath401",
    ", we select a parent @xmath402 below @xmath11 .    for each @xmath204",
    "such that @xmath313 , we select a parent @xmath297 below @xmath11",
    ".    set @xmath403 then , @xmath404 is a subtree in which @xmath46 is the cluster of @xmath11 .",
    "it is not hard to see that @xmath404 can be extended into a subtree of @xmath2 .    taken together , the above facts imply algorithm 2 for determining whether a leaf subset is a soft cluster in a lowest big tree - node component or not , presented in table  [ table4 ] .",
    "l + input : @xmath200 and a subset @xmath46 of leaves in @xmath318 ; + 1 . if @xmath405 , output ",
    "yes \" and * exit * ; + 2 . construct @xmath200 defined in eqn .",
    "( [ eq44 ] ) and ( [ eq55 ] ) ; + 3",
    ". pre - process @xmath200 so that the lca of any two nodes can be found in @xmath376 time ; + 4 . traverse the leaves in @xmath200 to compute the nodes in @xmath406 ; + 5 .",
    "for each leaf @xmath407 such that @xmath325 +  mark the nodes in the path from @xmath344 to it ; +  for each @xmath202 such that @xmath311 +  mark the nodes in the path from @xmath344 to @xmath379 inclusively ; + 6 .",
    "traverse the nodes @xmath10 in @xmath200 to compute the nodes in @xmath397 : +   check if @xmath10 is unmarked and its parent is marked in step 5 when visiting @xmath10 ; + 7 . for each node @xmath408 @xmath326 +   7.1 check whether or not all leaves in @xmath46 are below @xmath10 ; +   7.2 output ",
    "yes \" and * exit * if so ; + 8 .",
    "no \" and * exit * ; +    the correctness of the algorithm 2 follows from propositions  [ prop65 ] and [ prop66 ] .",
    "step 1 takes constant time .",
    "step 2 can be done in @xmath409 time .",
    "step 3 takes @xmath382 time ( see @xcite ) . by proposition  [ prop64 ] ,",
    "step 4 can be done in @xmath382 time .",
    "two paths from @xmath344 to nodes in @xmath406 may have a common subpath starting at the root .",
    "we mark the nodes in each of these paths in a bottom - up manner : whenever we reach a marked node , we stop the marking process in the current path . in this way , each marked node is visited twice at most and hence step 5 can be executed in @xmath382 time .",
    "obviously , step 6 takes @xmath382 time . for each node @xmath10 ,",
    "step 7.1 takes @xmath410 time .",
    "since all the examined subtrees are disjoint , the total time taken by step 7.1 is @xmath382 time .    taken together , these facts imply that algorithm 2 is a line - time algorithm . plugging algorithm 2 into step 2.2 in the ccp algorithm , we can solve the ccp in linear time .",
    "our algorithms are designed using a powerful decomposition theorem .",
    "the theorem holds for arbitrary reticulation - visible networks .",
    "we are very interested in exploring its applications in the estimate of the size of a network having a visibility property and designs of algorithms for reconstructing reticulation - visible networks from gene trees or gene sequences .",
    "another interesting problem is how to determine whether two networks display the same set of binary trees in polynomial time .",
    "a solution for this is definitely valuable in phylogenetics .",
    "the authors are grateful to philippe gambette , anthony labarre , and stphane vialette for discussion on the problems studied in this work .",
    "this work was supported by a singapore moe arf tier-1 grant r -146 - 000 - 177 - 112 and the merlion programme 2013 .",
    "marcussen , t. , _ et al .",
    "_ : , burkhard steuernagel , klaus f. x. mayer , and odd - arne olsen .",
    "ancient hybridizations among the ancestral genomes of bread wheat .",
    "_ science _",
    ", doi : 10.1126/science.1250092 ( 2014 )"
  ],
  "abstract_text": [
    "<S> in phylogenetics , phylogenetic trees are rooted binary trees , whereas phylogenetic networks are rooted acyclic digraphs . </S>",
    "<S> edges are directed away from the root and leaves are uniquely labeled with taxa in phylogenetic networks . for the purpose of evolutionary model validation , biologists check whether or not a phylogenetic tree is contained in a phylogenetic network on the same taxa . </S>",
    "<S> such a tree containment problem is np - complete . </S>",
    "<S> a phylogenetic network is reticulation - visible if every reticulation node separates the network root from some leaves . </S>",
    "<S> we answer an open problem by proving that the problem is solvable in cubic time for reticulation - visible phylogenetic networks . the key gadget used in our answer </S>",
    "<S> can also allow us to design a linear - time algorithm for the cluster containment problem for networks of this type and to prove that every galled network with @xmath0 leaves has @xmath1 reticulation nodes at most . </S>"
  ]
}