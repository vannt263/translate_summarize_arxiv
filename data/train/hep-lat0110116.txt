{
  "article_text": [
    "fermiqcd is a collection of classes , functions and parallel algorithms for lattice qcd  @xcite , written in c++ .",
    "it is based on matrix distributed processing ( mdp )  @xcite .",
    "the latter is a library that includes c++ methods for matrix manipulation , advanced statistical analysis ( such as jackknife and boostrap ) and optimized algorithms for interprocess communications of distributed lattices and fields .",
    "these communications are implemented using message passing interface ( mpi ) but mpi calls are hidden to the high level algorithms that constitute fermiqcd .",
    "fermiqcd works also on single processor computers and , in this case , mpi is not required .",
    "the basic fields defined in fermiqcd are : * class gauge_field : *    list of implemented algorithms :    * heatbath algorithm * anisotropic heatbath * @xmath0 heatbath    these algorithms work for arbitrary gauge groups @xmath1 , for arbitrary lattice dimensions and topologies .",
    "fermiqcd also supports arbitrarily twisted boundary conditions for large @xmath2 computations and studies of topology .",
    "* class fermi_field : *    list of implemented algorithms :    * multiplication by @xmath3 , for wilson and clover actions , for isotropic and anisotropic lattices * minimal residue inversion for @xmath4 * stabilized biconjugate gradient ( bicgstab ) inversion for @xmath4 * wupperthal smearing for the field * stochastic propagators    these algorithms work for arbitrary gauge groups @xmath1 and for arbitrary topologies in 4 dimensions .",
    "the multiplication by @xmath4 , clover ( isotropic and anisotropic ) , for @xmath5 , is optimized using pentium 4 sse2 instructions in assembler language .",
    "this implementation is based on the assembler macro functions written by martin lscher  @xcite * class fermi_propagator : *    this is an implementation of ordinary quark propagators .",
    "a fermi_propagator can be generated using any of the inversion algorithms of a fermi_field .",
    "* class staggered_field : *    kogut - susskind ( ks ) fermion",
    ". list of implemented algorithms :    * multiplication by @xmath4 , for unimproved and @xmath0 ( asqtad ) improved actions  @xcite * bicgstab inversion for @xmath4 * bicgstab inversion for @xmath4 using the uml decomposition  @xcite * function make_meson    these algorithms work for arbitrary gauge groups @xmath1 and for an arbitrary even number of dimensions ( except make_meson ) .",
    "the multiplication by @xmath4 , both improved and unimproved , for @xmath5 , is optimized using pentium 4 sse2 instructions in assembler language . in the unimproved case only half of the sse2 registries",
    "are used and there is room for an extra factor two in speed .",
    "the function make_meson builds any meson propagator ( made out of staggered quarks ) for arbitrary spin@xmath6flavour structure .",
    "this algorithm is described in ref .",
    "@xcite * class staggered_propagator : *    this is an implementations of the staggered propagator consisting of 16 sources contained in a @xmath7 hypercube at the origin of the lattice .",
    "a staggered_propagator can be used to propagate any hadron from the hypercube at the origin of the lattice to any other hypercube without extra inversions .",
    "all fields in fermiqcd inherit the standard i / o methods of mdp ( save and load ) and the file format is independent on the lattice partitioning over the parallel processes .",
    "these i / o functions , as well as all the fermiqcd algorithms , are designed to optimize interprocess communications .",
    "we present here , as an example , a full program that generates 100 @xmath5 gauge configurations ( u ) , starting from a hot one . on each configuration",
    "it computes a pion propagator ( pion ) made of @xmath0 improved quark propagators and prints it out .",
    "these propagators are computed using the sse2 optimized clover action and the bicgstab inversion algorithm .",
    "the program works in parallel .    ' '' ''    height 1pt    .... # define parallel # include \" fermiqcd.h \"    void main(int argc , char * * argv ) {     mpi.open_wormholes(argc , argv ) ;       int t , a , b , conf ;     int nc=3 , box[4]={16,8,8,8 } ;     generic_lattice   l(4,box ) ;     gauge_field       u(l , nc ) ;     fermi_propagator s(l , nc ) ;     site              x(l ) ;     float             pion[16 ] ;     u.param.beta=5.7 ;     s.param.kappa=0.1345 ;     s.param.csw=1.5 ;       default_fermi_action=                         mul_q_luscher ;     default_inversion_method=                    bicgstab_inversion ;       set_hot(u ) ;     heatbath(u,100 ) ;     for(conf=0 ; conf<100 ; conf++ ) {        heatbath(u,30 ) ;        compute_em_field(u ) ;        generate(s , u ) ;        for(t=0 ; t<16 ; t++ ) pion[t]=0 ;        forallsites(x )           for(a=0 ; a<4 ; a++ )              for(b=0 ; b<4 ; b++ )                 pion[x(time)]+=                    real(trace(s(x , a , b ) *                    hermitian(s(x , b , a ) ) ) ) ;        mpi.add(pion , 16 ) ;        if(me==0 ) for(t=0 ; t<16 ; t++ )           printf(\"%i % f\\n \" , t , pion[t ] ) ;     }     mpi.close_wormholes ( ) ; } ....    ' '' ''    height 1pt    = 7.5 cm -1 cm    comments :    * l is the user - defined name of the lattice ( @xmath8 ) * u , s and x are the gauge field , the fermi propagator and an auxiliary site variable defined on the lattice l * default_fermi_action is a pointer to the function that implements the action to be used .",
    "mul_q_luscher is one of the the built - in clover actions , optimized for pentium 4 .",
    "* default_inversion_method is a pointer to the function that implements the inversion algorithm ( minimal residue or bicgstab ) * compute_em_field computes the chromo - electro - magnetic field required by the action . *",
    "generate computes the quark propagtor s on the given gauge configuration u. * forallsites(x ) is a parallel loop on x. each processor loops on the local sites . *",
    "mpi.add(pion,16 ) sums the vector pion[16 ] in parallel . *",
    "if(me==0 ) guarantees that only one processor performs the output .",
    "in fig .  [ bench1 ] and fig .  [ bench2 ] we report some benchmarks for the multiplication by @xmath4 of a fermionic field , for the different actions ( using a single cpu pentium 4 pc running at 1.4 ghz , linux 2.4 and gcc 2.95.3 ) .",
    "this work was performed at fermilab ( u.s .",
    "department of energy lab ( operated by the university research association , inc . ) , under contract de - ac02 - 76cho3000 .",
    "m.  di  pierro , hep - lat/0009001 .",
    "( lattice qcd tutorial with examples in fermiqcd ) m.  di  pierro , hep - lat/0004007 .",
    "( updated tutorial on mdp ) to be published on cpc .",
    "m.  lscher , _ these proceedings _",
    "g.  p.  lepage , phys.rev .",
    "d59 ( 1999 ) 074502 k.  orginos _ at al . _",
    "( milc ) , phys.rev .",
    "d59 ( 1999 ) 014501 m.  di  pierro , _ in preparation _"
  ],
  "abstract_text": [
    "<S> we present here the most recent version of fermiqcd , a collection of c++ classes , functions and parallel algorithms for lattice </S>",
    "<S> qcd , based on matrix distributed processing . </S>",
    "<S> fermiqcd allows fast development of parallel lattice applications and includes some sse2 optimizations for clusters of pentium 4 pcs . </S>"
  ]
}