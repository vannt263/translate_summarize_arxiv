{
  "article_text": [
    "google s android operating system is the most popular mobile platform , with a 52.5% share of all smartphones  @xcite . due to android s open application development community ,",
    "more than 400,000 apps are available with 10 billion cumulative downloads by the end of 2011  @xcite .",
    "while most of these third - party apps have legitimate reasons to access private data , utilize the internet , or make changes to local settings and file storage , the permissions provided by android are too coarse , allowing malware to slip through the cracks . for instance , an app that needs to read information from only a specific website and access to gps information must , necessarily , be granted full read / write access to the entire internet , allowing it to maliciously leak location information . in another example , a note - taking application that writes notes to the file system can use the file system permissions to wipe out sd card files when a trigger condition is met .",
    "meanwhile , a task manager that legitimately requires every permission available can be benign . to understand application behaviors like these before running the program , we need to statically analyze the application , tracking what data is accessed , where sensitive data flows , and what operations are performed with the data , _",
    "i.e. _ , determine whether data is tampered with .",
    "however , static malware analysis for android apps is challenging .",
    "first , there is the general challenge of analyzing object - oriented programs where the state of the art is finite state based .",
    "specifically , traditional analysis regimes like @xmath1-cfa  @xcite and its many variants implicitly or explicitly finitize the stack during abstraction . in effect , analyzers carve up dynamic return points and exception - handling points among a finite number of abstract return contexts .",
    "when two dynamic return points map to the same abstract context , the analyzer loses the ability to distinguish them .",
    "second , there is the domain - specific challenge from the android programming paradigm , which is event - driven with multiple entry points and asynchronous interleaved execution .",
    "a typical strategy of existing static malware detection usually relies upon an existing analytic framework , _",
    "i.e. _ , chex  @xcite depends on wala  @xcite , woodpecker depends on soot  @xcite , and various _ ad hoc _ techniques proposed to deal with the problem : either by heuristic aborting of the paths unsoundly  @xcite , or combining dynamic execution to eliminate paths not appearing at run time  @xcite .",
    "one problem with this strategy is the inherent imprecision of the underlying analytic framework means imprecise malware analysis on top of it .",
    "another problem is that many static malware analyzers go unsound in order to handle the large number of permutations for multiple entry points for the sake of efficiency .",
    "this means the static analyzer can no longer prove the absence of behaviors , malicious or otherwise .    in this paper , we describe anadroid , a generic static malware analyzer for android apps .",
    "anadroid depends on two integrated techniques : ( 1 ) it is the first static analysis using higher - order pushdown control - flow - analysis for an object - oriented programming language ;",
    "( 2 ) it uses _ entry - point saturation _ ( eps ) to soundly approximate interleaving execution of asynchronous entry points in android apps .",
    "we also integrate static taint flow analysis and least permissions analysis as application security analysis .",
    "in addition , anadroid provides a rich user interface to support human - in - the - loop malware analysis .",
    "it allows user - supplied predicates to filter and highlight analysis results .    to demonstrate the effectiveness of anadroid s malware analysis , we evaluate a challenge suite of 52 android apps released as part of the darpa automated program analysis for cybersecurity ( apac ) program .",
    "we compare a malware analyzer driven by finite - state control - flow - analysis with our model with respect to accuracy and analysis time .",
    "we found that pushdown - driven malware analysis leads to statistically significant improvements in both aspects over traditional static analysis methods ( which use finite - state methods like @xmath1-cfa to handle program control  @xcite ) .",
    "the remainder of this paper is organized as follows .",
    "we illustrate the challenges via a condensed example malicious application in section  [ sec : motivation - exam ]",
    ". then we present our solutions in the subsequent two sections , where section  [ sec : pushdown ] presents the foundational pushdown control - flow analysis and section  [ sec : multi - entries ] details _ entry - point saturation _ ( eps ) .",
    "based on pushdown control - flow analysis and eps , we integrate static taint flow analysis and least permissions analysis into our analytic framework , as presented in section  [ sec : other - techs ] .",
    "section  [ sec : tool ] presents our tool and section  [ sec : eval ] evaluates the effectiveness of our technique by comparing our results with results from finite state - based analysis .",
    "case studies summarizing the vulnerabilities we have found are described in section  [ sec : cases ] . section  [ sec : related ] presents related work and section  [ sec : concl ] concludes .",
    "the program _ kitty.java _ is adapted from an android malware application developed and released by a red team on the darpa apac program .",
    "it exfiltrates location data from pictures stored on the users phone to a malicious site ( on lines 19 and 33 ) or posts the information ( on lines 3638 ) via an android intent if the first attempt fails .",
    "this example helps illustrate the two challenges of static malware detection for android programs .",
    "[ [ fundamental - challenge - imprecision - induced - by - finite - based - analytic - model - for - object - oriented - programs ] ] fundamental challenge : imprecision induced by finite - based analytic model for object - oriented programs + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + +    android apps are written in java , and it can be difficult to statically produce a precise control flow graph of the program , particularly in the presence of exceptions .",
    "many existing static analyzers for java programs are based on finite - state - machine analysis , _",
    "i.e. _  @xmath1-cfa or @xmath1-object sensitivity , which have limited analytic power for analyzing dynamic dispatch or exceptions precisely .",
    "analyzers built using these techniques have a greater rate of false positives and false negatives due to this imprecision .",
    "for instance , in the example , both _",
    "aboutbutton _ and _ kittyquotebutton _ create a non - blocking background thread via the class _ sendout _ ( lines 19 and 33 ) wrapped inside a try block . in the _ aboutbutton _ code ,",
    "normal exception handling occurs at line 20 . in the _ kittyquotebutton _ code ,",
    "the exception handler attempts a second malicious action in lines 3638 using an android web view activity to send out location information .",
    "this illustrates one of the difficulties in making a precise analysis of the program , where the flow of the exception is difficult to track , leading to false positives or false negatives .",
    "specifically , a finite - state - based analyzer can not determine which exception handler block will be used when an exception is thrown at line 19 .",
    "it can ( incorrectly ) conclude that the handler block in lines 3638 will be invoked .",
    "this causes a false positive where line 19 is identified as potentially leading to the malicious behavior in lines 3638 . in the same way",
    ", a finite - state - based analyzer can not determine which exception handler block will be used when an exception is thrown from line 33 .",
    "it may determine that the handler block on line 19 is the appropriate exception handler block .",
    "this leads to a false negative , where the malicious behavior resulting from an exception at line 33 is missed .",
    "the pushdown control - flow analysis model can precisely track exception handling , so our analyzer identifies the correct handler block ( line 20 ) where no malicious behavior exists .",
    "in fact , the fundamental imprecision caused by spurious control flows due to exceptions has been reported before . fu  _ et al . _",
    "@xcite report this problem when testing java server apps , and bravenboer  _ et al . _",
    "@xcite describe the need to combine points - to and exception analysis to attempt to regain some of this precision .",
    "unlike approaches using finite - state - based control flow analysis , the pushdown control - flow analysis used as the foundation for our malware analyzer can precisely match both normal and exception return flows achieving lower false positive and false negative rates .",
    "[ [ domain - specific - challenge - permutations - of - asynchronous - multi - entry - points ] ] domain specific challenge : permutations of asynchronous multi - entry - points + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + +    the second challenge in analyzing android apps is caused by the asynchronous multiple entry points into an android application .",
    "the android framework allows developers to create rich , responsive , and powerful apps by requiring developers to organize their code into components .",
    "each component type serves a different purpose : ( 1 ) activities for the main user - interface , ( 2 ) services for non - blocking code or remote processes , ( 3 ) content providers for managing application data , and ( 4 ) broadcast receivers to provide system - wide announcements .",
    "applications can register various component handlers , either explicitly in code or through a resource file ( res / layout/_filename_.xml ) .",
    "whenever an event occurs , the callbacks for the event are invoked asynchronously , potentially interleaving their execution with those in other components .",
    "different apps can also invoke each other by exposing functionality via an _ intent _ at both the application and component level . unlike an application with a single entry point , static analysis for an android application must explore all permutations of these asynchronous entry points .",
    "analyzing all permutations can greatly increase the expense of the analysis . as a result many analyzers use an unsound approximation that can lead to false negatives .",
    "our example illustrates these problems .",
    "first , not all of the callback methods are explicitly registered in code , like the _ oncreate _ method of _ kittyquote _ and the _ doinbackground _ method of _ sendout _ , _ aboutbutton _ , _ nextbutton _ , _ prevbutton _ , and _",
    "_ kittyquotebutton _ _ are registered in an xml layout resource file as follows .",
    "[ source , xml ] ---- < button          android : id=\"@+id / button2 \"          ...          android : onclick=\"prevbutton \" / > ----    second , malicious behaviors can be triggered from an entry point or series of entry points .",
    "for instance , if the _ prevbutton _ or _ nextbutton _ methods are called before the _ aboutbutton _ or _ kitteyquotebutton _ methods , the application will leak location data gathered from the exif data of pictures on the device . in order to avoid missing malicious behavior ,",
    "while still performing the analysis efficiently , we need a way to approximate the possible permutations of the asynchronous multi - entry points without loosing soundness .",
    "this means we can not use heuristic pruning , but we also do not want to use a dynamic analysis , since we hope to analyze the program before we attempt to run it .",
    "this leads to our second contribution , entry - point saturation ( eps ) , which can be used to analyze multi - entry points in a sound way .    to summarize the relationship between the challenges ,",
    "an unsound approximation of asynchronous entry points can miss malicious behavior , while any imprecision in the underlying control - flow analysis can result in an analysis that misses malicious behavior in programs .",
    "this problem is further exacerbated by additional highly dynamic dispatched inter - procedural control flows caused by permutations of entry points .",
    "we need to address both challenges to ensure our analyzer does not miss malicious behavior in the program .",
    "the next two sections describe our solutions to these challenges .",
    "in this section , we describe our pushdown control - flow - analysis for object - oriented programs .",
    "we present the analysis as a small - step semantic analysis following the style of felleisen  _ et al .",
    "_  @xcite and more recently van horn  _ et al .",
    "_  @xcite .",
    "we first define an object - oriented bytecode language closely modeled on dalvik bytecode .",
    "our language dispenses with some of the bytecode size optimizations that the dalvik bytecode uses to shrink the size of programs , allowing the analyzer to treat dalvik instructions with similar functionality as a single instruction .",
    "our language also includes explicit line number instructions to allow it to more easily relate malicious behavior in the bytecode to the original source code .",
    "then we develop our pushdown control - flow analysis for this language .",
    "the syntax of the bytecode language is given in figure  [ fig : oo - syntax ] .",
    "statements encode individual actions for the machine ; complex expressions encode expressions with possible side effects or non - termination ; and atomic expressions encode atomically computable values",
    ". there are four kinds of names : @xmath2 for registers , @xmath3 for class names , @xmath4 for field names , and @xmath5 for method names .",
    "there are two special register names : @xmath6 , which holds the return value of the last function called , and @xmath7 , which holds the most recently thrown exception .",
    "the syntax is a straightforward abstraction of dalvik bytecode , but it is worth examining statements related to exceptions in more detail :    * @xmath8 indicates that a method can throw one of the named exception classes , * @xmath9 pushes an exception handler frame on the stack that will catch exceptions of type @xmath10 and divert execution to @xmath11 , and * @xmath12 pops the initial exception handler frame off the stack .",
    "@xmath13 )   \\\\ & \\;\\;{\\mathrel{|}}\\;\\ ; ( { \\mathsf{field}}\\mhyphen{\\mathsf{put } } ~{\\mbox{\\sl { \\ae}}}_o ~\\mathit{field}\\mhyphen\\mathit{name } ~{\\mbox{\\sl { \\ae}}}_v )   \\\\ & \\;\\;{\\mathrel{|}}\\;\\ ;   ( { \\mathsf{field}}\\mhyphen{\\mathsf{get}}\\ ; { \\mathit{name}}~{\\mbox{\\sl { \\ae}}}_o ~\\mathit{field}\\mhyphen\\mathit{name } ) \\\\ & \\;\\;{\\mathrel{|}}\\;\\ ; ( { \\mathsf{push}}\\mhyphen{\\mathsf{handler } } ~\\mathit{class}\\mhyphen\\mathit{name } ~\\mathit{label } ) \\\\ & \\;\\;{\\mathrel{|}}\\;\\ ; ( { \\mathsf{pop}}\\mhyphen { \\mathsf{handler } } ) { \\mathrel{|}}({\\mathsf{throw}}~{\\mbox{\\sl { \\ae } } } ) { \\mathrel{|}}({\\mathsf{return } } ~{\\mbox{\\sl { \\ae } } } )   \\\\ { \\mbox{\\sl { \\ae}}}\\in { \\mathsf{aexp } } & { \\mathrel{::=}}{\\mathsf{this } } { \\mathrel{|}}{\\mathsf{true } } { \\mathrel{|}}{\\mathsf{false } } { \\mathrel{|}}{\\mathsf{null } } { \\mathrel{|}}{\\mathsf{void } }   \\\\ & \\;\\;{\\mathrel{|}}\\;\\ ; \\mathit{{\\mathit{name } } } { \\mathrel{|}}\\mathit{int }   \\\\ & \\;\\;{\\mathrel{|}}\\;\\ ;   ( \\mathit{atomic}\\mhyphen\\mathit{op } ~{\\mbox{\\sl { \\ae}}}\\dots { \\mbox{\\sl { \\ae } } } )    \\\\   & \\;\\;{\\mathrel{|}}\\;\\ ; { \\mathsf{instance}}\\mhyphen{\\mathsf{of}}({\\mbox{\\sl { \\ae } } } , \\mathit{class}\\mhyphen\\mathit{name } )   \\\\ { \\mathit{ce}}&{\\mathrel{::=}}({\\mathsf{new}}\\ ; \\mathit{class}\\mhyphen\\mathit{name } )   \\\\ & \\;\\;{\\mathrel{|}}\\;\\;(\\mathit{invoke}\\mhyphen\\mathit{kind } ~({\\mbox{\\sl { \\ae}}}\\dots{\\mbox{\\sl { \\ae } } } ) ( \\mathit{type}\\;\\dots\\ ; ) ) \\\\ \\mathit{invoke}\\mhyphen\\mathit{kind } & { \\mathrel{::=}}{\\mathsf{invoke}}\\mhyphen{\\mathsf{static } }   { \\mathrel{|}}{\\mathsf{invoke}}\\mhyphen{\\mathsf{direct } }    \\\\ & \\;\\;{\\mathrel{|}}\\;\\;{\\mathsf{invoke}}\\mhyphen{\\mathsf{virtual } }   { \\mathrel{|}}{\\mathsf{invoke}}\\mhyphen{\\mathsf{interafce } }     \\\\ & \\;\\;{\\mathrel{|}}\\;\\;{\\mathsf{invoke}}\\mhyphen{\\mathsf{super } } \\\\ \\mathit{type } & { \\mathrel{::=}}~\\mathit{class}\\mhyphen\\mathit{name } { \\mathrel{|}}{\\mathsf{int } } { \\mathrel{|}}{\\mathsf{byte } } { \\mathrel{|}}{\\mathsf{char } } { \\mathrel{|}}{\\mathsf{boolean } } \\\\ \\mathit{attribute } & { \\mathrel{::=}}{\\mathsf{public } } { \\mathrel{|}}{\\mathsf{private } } { \\mathrel{|}}{\\mathsf{protected } }   \\\\ & \\;\\;{\\mathrel{|}}\\;\\ ; { \\mathsf{final } } { \\mathrel{|}}{\\mathsf{abstract } } \\\\ { \\mathit{name } } & ~\\text{is an infinite set of frame - local variables }   \\\\ & \\text{or registers in the parlance of dalvik byte code } \\text.\\end{aligned}\\ ] ]    with respect to a given program , we assume a syntactic metafunction @xmath14 , which maps a label to the sequence of statements that start with that label .      with the language in place ,",
    "the next step is to define the concrete semantics of the language , providing the most accurate interpretation of program behaviors .",
    "however , the concrete semantics can not be used directly for static analysis , since it is not computable .",
    "fortunately , we can adapt the technique of abstracting abstract machines  @xcite to derive a sound abstract semantics for the dalvik bytecode using an abstract cesk machine",
    ".    states of this machine consist of a series of statements , a frame pointer , a heap , and a stack .",
    "the evaluation of a program is defined as the set of _ abstract _ machine configurations reachable by an abstraction of the machine transition relation .",
    "largely , abstract evaluation is defined as @xmath15 , where @xmath16 therefore , abstract evaluation is defined by the set of configurations reached by the reflexive , transitive closure of the @xmath17 relation , which shall be defined in section  [ sec : abs - transition - rules ] .",
    "[ [ abstract - configuration - space ] ] abstract configuration - space + + + + + + + + + + + + + + + + + + + + + + + + + + + +    figure  [ fig : abs - conf - space ] details the abstract configuration - space for this abstract machine .",
    "we assume the natural element - wise , point - wise , and member - wise lifting of a partial order across this state - space .",
    "@xmath18    to synthesize the abstract state - space , we force frame pointers and object pointers ( and thus addresses ) to be a finite set .",
    "when we restrict the set of addresses to a finite set , the machine may run out of addresses to allocate , and when it does , the pigeon - hole principle will force multiple abstract values to reside at the same address . as a result ,",
    "the range of the @xmath19 becomes a power set in the abstract configuration - space .",
    "crucially , in this machine , the stack is left unbounded , unlike the final step in the abstracting abstract machine approach .",
    "this enables us to faithfully model both normal function call and return and exception throw and catch handling intraprocedurally and interprocedurally . in the next section we detail the essence of the abstract cesk machine , which is one of the main contributions of this work .",
    "the machine relies on helper functions to evaluate atomic expressions and look up field values :    * @xmath20 injects a sequence of instructions into a configuration : @xmath21 , { \\langle \\rangle } )    \\text.\\ ] ] * @xmath22 evaluates atomic expressions : @xmath23 }      \\text .",
    "\\end{aligned}\\ ] ] * @xmath24 looks up fields : @xmath25    the abstract transition relation @xmath26 has rules to soundly model all possible concrete executions of a bytecode program .",
    "in the subsequent subsections , we illustrate the rules that involve objects , function calls , and exceptions , omitting more obvious rules to save space .    [ [ new - object - creation ] ] new object creation + + + + + + + + + + + + + + + + + + +    creating a new object allocates a potentially non - fresh address and joins the newly initialized object to other values residing at this store address .",
    "@xmath27\\ ! ] } } , { \\hat{\\mathit{fp } } } , { { \\hat{\\sigma } } } ,   { { \\hat{\\kappa}}})}^{{{\\hat c } } }    $ ] @xmath28     \\\\    { { \\hat{\\sigma } } } '' & = \\widehat{\\mathit{initobject}}({{\\hat{\\sigma } } } ' , \\mathit{class}\\mhyphen\\mathit{name } )    \\text { , }      \\end{aligned}\\ ] ] the helper function @xmath29 initializes the object s fields .",
    "[ [ instance - field - referenceupdate ] ] * instance field reference / update * + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + +    referencing a field uses @xmath30 to lookup the field values and joins these values with the values at the store location for the destination register :    @xmath31\\ ! ] } } , { \\hat{\\mathit{fp } } } , { { \\hat{\\sigma}}},{{\\hat{\\kappa}}})$ ] @xmath32     \\text .",
    "\\end{aligned}\\ ] ] updating a field first determines the abstract object values from the store , extracts the object pointer from all the possible values , then pairs the object pointers with the field name to get the field address , and finally _ joins _ the new values to those found at this store location :    @xmath33\\ ! ] } } , { \\hat{\\mathit{fp } } } , { { \\hat{\\sigma } } } , { { \\hat{\\kappa } } } )      $ ] @xmath34     \\\\    ( { { \\widehat{\\mathit{op } } } } , & \\mathit{class}\\mhyphen{name } ) \\in { { \\hat{\\mathcal{a}}}}({\\mbox{\\sl { \\ae}}}_o , { \\hat{\\mathit{fp } } } , { { \\hat{\\sigma}}})\\text .",
    "\\end{aligned}\\ ] ]    [ [ method - invocation ] ] method invocation + + + + + + + + + + + + + + + + +    this rule involves all four components of the machine .",
    "the abstract interpretation of non - static method invocation can result in the method being invoked on a _ set _ of possible objects , rather than a single object as in the concrete evaluation .",
    "since multiple objects are involved , this can result in different method definitions being resolved for the different objects .",
    "the method is resolved and then applied as follows :    @xmath35\\ ! ] } } :   \\vec{s } , { \\hat{\\mathit{fp } } } , { { \\hat{\\sigma } } } , { { \\hat{\\kappa } } } )      } ^{{{\\hat c } } }      \\\\    { \\leadsto}\\widehat{\\mathit{applymethod}}(m , \\vec{{\\mbox{\\sl { \\ae } } } } ,        { \\hat{\\mathit{fp}}},{{\\hat{\\sigma}}},{{\\hat{\\kappa } } } ) \\text ,    \\end{aligned}\\ ] ]    where the function @xmath36 takes a method definition , arguments , a frame pointer , a store , and a new continuation and produces the next configuration :    @xmath37 where @xmath38\\text.\\end{aligned}\\ ] ]    [ [ procedure - return ] ] * procedure return * + + + + + + + + + + + + + + + + + +    procedure return restores the caller s context and _ extends _ the return value in the dedicated return register , @xmath6 .",
    "@xmath39\\ ! ] } } , { \\hat{\\mathit{fp } } } , { { \\hat{\\sigma } } } ,   \\mathbf{fun}({\\hat{\\mathit{fp}}}',\\vec{s } ' ) : { { \\hat{\\kappa } } } )      { \\leadsto}(\\vec{s } ' , { \\hat{\\mathit{fp } } } ' , { { \\hat{\\sigma } } } ' ,   { { \\hat{\\kappa}}})\\text , $ ] @xmath40     \\text . $ ]    if the top frame is an exception handler ( @xmath41 ) frame , the abstract interpreter pops until the top - most frame is a function call ( @xmath42 ) frame : @xmath43\\ ! ] } } :   \\vec{s } , { \\hat{\\mathit{fp } } } , { { \\hat{\\sigma } } } ,        \\mathbf{handle}(\\mathit{class}\\mhyphen\\mathit{name}~\\mathit{label } ) : { { \\hat{\\kappa } } } )    \\\\    { \\leadsto}({\\ensuremath{[\\![{({\\mathsf{return } } ~{\\mbox{\\sl { \\ae}}})}]\\ ! ] } } :   \\vec{s } , { \\hat{\\mathit{fp}}},{{\\hat{\\sigma } } } , { { \\hat{\\kappa } } } )   \\text{. }    \\end{aligned}\\ ] ]    [ [ pushing - and - popping - handlers ] ] pushing and popping handlers + + + + + + + + + + + + + + + + + + + + + + + + + + + +    pushing and popping exception handlers is straightforward : @xmath44\\ ! ] } } :   \\vec{s } , { \\hat{\\mathit{fp } } } , { { \\hat{\\sigma } } } , { { \\hat{\\kappa } } } )      \\\\      { \\leadsto}(\\vec{s},{\\hat{\\mathit{fp}}},{{\\hat{\\sigma}}},\\mathbf{handle}(\\mathit{class}\\mhyphen\\mathit{name}~\\mathit{label } ) : { { \\hat{\\kappa } } } )      \\end{aligned}\\ ] ] @xmath45\\ ! ] } } :   \\vec{s } , { \\hat{\\mathit{fp } } } , { { \\hat{\\sigma } } } , \\mathbf{handle}(\\mathit{class}\\mhyphen\\mathit{name}~\\mathit{label } ) : { { \\hat{\\kappa } } } )      \\\\      { \\leadsto}(\\vec{s},{\\hat{\\mathit{fp}}},{{\\hat{\\sigma } } } , { { \\hat{\\kappa } } } )     \\text .      \\end{aligned}\\ ] ]    [ [ throwing - and - catching - exceptions ] ] throwing and catching exceptions + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + +    the throw statement pops entries off the stack until it finds a matching exception handler : @xmath46\\ ! ] } } :   \\vec{s } , { \\hat{\\mathit{fp } } } , { { \\hat{\\sigma}}},{{\\hat{\\kappa } } } )      & { \\leadsto}\\widehat{\\mathit{handle}}({\\mbox{\\sl { \\ae } } } , \\vec{s } , { \\hat{\\mathit{fp } } } , { { \\hat{\\sigma } } } , { { \\hat{\\kappa } } } )     \\text ,      \\end{aligned}\\ ] ] where the function @xmath47 @xmath48 behaves like its concrete counterpart when the top - most frame is a compatible handler : @xmath49 , { { \\hat{\\kappa } } } ' )      \\text.\\end{aligned}\\ ] ] otherwise , it pops a frame : @xmath50\\ ! ] } } :   \\vec{s } , { \\hat{\\mathit{fp } } } , { { \\hat{\\sigma } } } , { { \\hat{\\kappa } } } ' )   \\\\      \\widehat{\\mathit{handle}}({\\mbox{\\sl { \\ae } } } , \\vec{s } , { \\hat{\\mathit{fp } } } , { { \\hat{\\sigma } } } ,   \\mathbf{fun}(\\_,\\ _ ) : { { \\hat{\\kappa } } } ' )      \\\\      =       ( { \\ensuremath{[\\![{({\\mathsf{throw}}~{\\mbox{\\sl { \\ae}}})}]\\ ! ] } } :   \\vec{s } , { \\hat{\\mathit{fp } } } , { { \\hat{\\sigma } } } , { { \\hat{\\kappa } } } ' )       \\text.\\end{aligned}\\ ] ]    executing the analysis consists of solving for the reachable control states of the implicit pushdown system in the abstract semantics . to compute the reachable control states of this pushdown system , we employ standard reachability algorithms from reps  _ et al .",
    "@xcite work on pushdown - reachability .",
    "the pushdown control - flow analysis described in the previous section provides the foundation for our object - oriented analysis .",
    "now , we shift our focus to addressing the domain specific challenge : asynchronous multiple entry points using entry - point saturation ( eps ) and integrating it into pushdown control - flow analysis .",
    "an entry point is defined as any point through which the system can enter the user application  @xcite .",
    "this means that any method that can be invoked by the framework is an entry point .",
    "since there is no single `` main '' method , the static analysis must first identify the entry points in the program .",
    "entry - point discovery is not a challenge , however , since they are defined by the android framework .",
    "we briefly summarize possible entry - points here .",
    "there are three categories of entry points , which we generalize as _",
    "_ unit__s .",
    "first , all the callback events of components defined by the android framework are entry points .",
    "these entry points are designed to be overridden by application code and are invoked and managed by the framework for the purpose of component life cycle management , coordinating among different components , and responding to user events which are themselves defined to be asynchronous .",
    "second , asynchronous operations that can be executed in the background by the framework are considered to be entry points .",
    "these include the _ asynctask _ class for short background operations , the _ thread _ class for longer operations , and the _ handler _ class for responding to messages . finally , all event handlers in android ui widgets , such as button , check box , etc . are entry points .",
    "each ui widget has standard event listeners defined , where the event handler interface methods are meant to be implemented by application code .",
    "entry points from the first two categories are found by parsing dalvik bytecode and organized into a set attached to the corresponding _",
    "unit_. entry points from the final category can also be defined in resource layout files _ res / layout/_filename_.xml _ , as illustrated in section  [ sec : motivation - exam ] .",
    "these entry points can be obtained by parsing resource files before analysis .    after the entry point set for each unit",
    "is determined the real challenge begins .",
    "if we want to do a sound analysis , all the permutations of the entry points need to be considered . complicating things further , entry points in the second category involve threads so interleaved execution of these entry points is possible .",
    "other analyzers , such as chex , deal with this complexity using _ app - splitting _ , which is unsound and can not model the threading case . here , we present a sound and efficient technique which directly relies on the underlying pushdown analytic engine presented in section  [ sec : pushdown ] . figure  [ fig : mep ] illustrates the process .        for each entry point @xmath51 in a _ unit _",
    "( represented as a square ) , we compute the fixed point via pushdown analysis ( refer to section  [ sec : abs - transition - rules ] ) .",
    "after one round of computation the analysis returns a set of configurations .",
    "we then use the _ configuration widening _ technique from might  @xcite on the set of configurations to generate a widened @xmath52 .",
    "this abstract component will be `` inherited '' by the next entry point in the fixed point computation .",
    "the process repeats until the last entry point finishes its computation in a _",
    "unit_. in this way , the unit has reached a fixed point .",
    "the next step computes the fixed point between _ _ unit__s .",
    "this is computed in a similar fashion to the intra - unit fixed point computation , so the widened result @xmath53 from the previous unit ( the left square ) participates in the reachability analysis of the next unit ( the right square ) .",
    "eps soundly models all permutations of entry points and their interleaving execution by passing the store resulting from analyzing one entry - point as the initial store for the next entry - point .",
    "this gives the `` saturated '' store for a given component .",
    "the saturated store for a component is similarly passed as the initial store for the next component .",
    "the final store models every execution path without needing to enumerate every combination .",
    "eps has several advantages :    1 .",
    "it computes the fixed point from bottom up , intra - entry point , inter - entry point , and inter - unit , in an efficient manner and significantly simplifies the static analysis ; 2 .",
    "it not only computes all permutations of entry points , but also interleaving executions of them ; 3 .",
    "it is sound and easy to prove , because it is based on widening on the abstract configurations , where the soundness proof follows the same structure as shown by might  @xcite and so we omit it here .    applying this technique to the example in section  [ sec : motivation - exam ] , we can see that all execution sequences where location information is read ( _ nextbutton _ and _ prevbutton _ ) to where it is leaked through the action_view intent or the _ doinbackground _ method of the _ sendout _ asynctask are covered and analyzed .",
    "as a whole , the previous two sections have described a solid foundation for static malware analysis .",
    "this section demonstrates two possible applications that build upon the foundation for specific security analyses .      for any mobile application ,",
    "one of the biggest concerns is leakage or tampering with private data .",
    "we can easily instrument our framework to perform taint flow analysis to detect these malicious behaviors .",
    "the idea is adapted from early work by liang  _ et al . _",
    "@xcite , but has been enriched with android sensitive data categories as taint values .",
    "the taint flow analysis within our pushdown - based analysis framework is done by modifying the abstract configuration in figure  [ fig : abs - conf - space ] as :    @xmath54    and adding the definition for @xmath55 , which is a flat lattice across all taint values : @xmath56    all the transition rules have an additional @xmath57 added , operations resemble the ones on @xmath58 , except that the taint values are _ monotonically _ propagated through the abstract semantics . for example , in a function call , tainted values in arguments are bound to the formal parameters of the functions ( using the @xmath59 operation in the taint store @xmath57 ) , returning abstract taint values bound to a register address with @xmath6 , etc .",
    "the detailed formalism is omitted to save space .",
    "the taint propagation analysis is not limited to detecting sensitive data leakage or tampering . as we discuss in section  [ sec : cases ] , it can help analysts to find malicious behaviors , such as when sms messages are blocked by a trigger condition or a limited resource is consumed , such as the local file system on the device being filled .      our analysis framework can also detect malicious behaviors in the presence of zero - permissions , as the motivating example demonstrates .",
    "however , for apps that request permissions , it is highly desirable to analyze how the apps use the permissions , since over - privileged apps can easily be exploited by other apps in the android framework .",
    "it is straightforward to determine this situation in our framework by instrumenting it with knowledge about permissions .",
    "specifically , we use the data set from pscout  @xcite to annotate each api call with permissions that are required for usage . during reachability analysis , permissions are inferred and collected .",
    "the reached permissions are determined during the analysis . when the analysis finishes these permissions",
    "can be compared with the set of permissions requested in the manifest file .",
    "this allows us to statically determine whether an application is over - privileged .",
    "anadroid is built on the principles illustrated in the previous sections .",
    "figure  [ fig : anadroid - archi ] briefly sketches the software architecture .        anadroid has the following features :    * it consumes off - the - shelf android application packages ( files with suffix @xmath60 ) . in figure",
    "[ fig : anadroid - archi ] _ jdexsexp _ extracts the @xmath61 file by invoking @xmath62  @xcite and then disassembles binaries and generates an s - expression ir based on the @xmath63  @xcite format ; * it enables human - in - the - loop analysis , by providing a rich user interface for an analyst to configure the analyzer , _ i.e._setting the @xmath1 value , configuring abstract garbage collection to be used or not , specifying predicates over the state space , etc . , to trade off precision and performance , as well as semantic predicates to search analysis results ; * it generates various reports and state graphs . the following three reports",
    "are included : ( 1 ) least permissions presents which permissions are requested by an app and which permissions are inferred by anadroid , reporting whether the app requests more permissions than it actually uses .",
    "( 2 ) the information flow report presents triggers ( mainly ui triggers ) and tainted paths that lead from sources to sinks , with contexts such as class files , method names , and line numbers .",
    "( 3 ) the heat map report shows rough profiling results of the analyzer , which can be used to help an analyst understand where the analysis has focused its efforts and might indicate where an app developer has attempted to hide malicious behavior .",
    "analysis graphs are presented with an svg formatted file as a reachable control flow graph .",
    "it highlights suspicious source and sink states , as well as showing tainted paths between them .",
    "in addition , an analyst can click on any state node in the graph for detailed inspection of the abstract execution at this point in the graph .",
    "in fact , the pushdown analysis based analyzer evolved from an older version with a similar user interface and output forms ( reports and graphs ) .",
    "the previous version of anadroid used traditional finite - state methods ( mainly @xmath1-cfa and @xmath1-object - sensitivity ) that are employed in analysis platforms such as wala  @xcite , soot  @xcite , etc .",
    "the old analyzer enables us to compare the traditional finite - state based analysis with our new pushdown control - flow analysis to help us determine whether the new analysis is more effective and efficient .",
    "the following section details this comparison .",
    "we had two teams of analysts analyze a challenge suite of 52 android apps released as part of the darpa automated program analysis for cybersecurity ( apac ) program .",
    "both teams are composed of the same five people , a mixture of graduate students and undergraduate students , however , the applications are shuffled , ensuring the same app is not evaluated by the same analyst .",
    "the first team analyzed the apps with a version of anadroid that uses traditional ( finite - state - machine - based ) control - flow - analysis used in many existing malware analysis tools ; the second team analyzed the apps with a version of anadroid that uses our enhanced pushdown - based control - flow - analysis .",
    "we measure the time the analyzer takes , the time human analysts spent reviewing the results , and the accuracy of the human analyst in determining if an app is malicious .",
    "accuracy is measured by comparing the result of human - in - the - loop analysis with the results released by darpa .",
    "all other factors being equal , we found a statistically significant ( p @xmath64 0.05 ) decrease in time and a statistically significant increase ( p @xmath64 0.05 ) in accuracy with the pushdown - based analyzer .",
    "[ [ the - challenge - suite ] ] the challenge suite : + + + + + + + + + + + + + + + + + + + +    among the apps , 47 are adapted from apps found on the android market , contagio  @xcite , or the developer s source repository .",
    "a third - party within the apac project injects malicious behavior into these apps and uses an anti - diffing tool on apps with larger code bases to make it difficult to simply diff the application with the original source code .",
    "the remaining five apps are variants of the original 47 apps with different malicious behaviors .",
    "for example , _",
    "app1 _ may leak location information to a malicious website while _",
    "may not . the apps range in size from 18.7 kb to 10 mb , with 11,600 lines of source code in each app on average .    [ [ experiment - setup ] ] experiment setup + + + + + + + + + + + + + + + +    the two teams of analysts were given instructions on how to use the tool ( both versions of the tool use similar uis and output forms ) and some warm - up exercises on a couple of examples apps .",
    "then they were given examples from the darpa - supplied challenge suite .",
    "the analysts used anadroid ( deployed as a web application on our server ) to analyze each app and then record the run time of the analyzer , the total time the human analysis spent investigating the results , and an indication if the analyst felt the app was malicious .",
    "we have made efforts to ensure that other factors remained unchanged so that the only difference was the tool the analyst used to detect malware .",
    "this restriction can help us gain insight into whether any improvement is made by our new analysis techniques .    finally , we compare the analysts results with the darpa supplied information on whether an app is malicious to check accuracy and run statistical analysis using one - way analysis of variance ( anova ) to get mean value and p - value of analyzer time , analyst time , and accuracy",
    ". this allows us to see the statistical results of the experiment on finite - state - based - machine versus pushdown - based control - flow analysis .",
    "this is shown in table  [ tbl : eval - stats2 ] .",
    "cc|c|c| & & * mean * & * p - value * + & & 994 sec & + & & 560 sec & 0.003 + & & 1.13 hr & + & & 0.44 hr & * 0.0 * + & & 71% & + & & 95% & * 0.0005 * +    we found that pushdown malware analysis yields statistically significant improvements with @xmath0 in both accuracy and analysis time over traditional static analysis .",
    "in this section we report case studies of malware detected by anadroid .",
    "the malicious behavior of the 52 apps provided as part of the apac challenge are summarized in table  [ tbl : cases ] .",
    "we separate these behaviors into four categories : data leakage , data tampering , denial of service attacks , and other malicious behaviors .    [ cols=\"^,^,^ \" , ]     _ data leakage _ is one of most common , and concerning , malicious behaviors in android apps  @xcite .",
    "sensitive data , including location information , an sms message , or a device i d , is exfiltrated to a third - party host via an http request or android web component intent , or to a predefined reachable local file via standard file operations .",
    "this kind of behavior is often embedded in a background android service component , such as an asynctask or a thread , without interfering with the normal functionality of the app .",
    "anadroid identifies this malicious behavior in 57% of the 42 malicious android apps from our test suite that manifest malicious behavior .",
    "we found the taint flow analysis to be more useful than the least permissions analysis in identifying these behaviors , since half of these apps are designed to avoid requesting any permissions .",
    "for instance , instead of requesting the @xmath65 an app can instead read locations from photos stored on the file system using exif data and instead of requesting the @xmath66 the app can use the default android web view through an @xmath67 intent , in both cases avoiding the need to explicitly request these permissions .",
    "_ data tampering _ , similar to data leakage , can be detected using static taint flow analysis by determining which operations are performed on data .",
    "malware in this category might corrupt the local file system by overwriting file contents with meaningless data , recursively delete files from the sd card , or delete sms messages . in these real - world apps ,",
    "exceptions are frequently used , especially around io operations .",
    "we found that finite - state - based analysis can lead to many spurious execution flows in the control graph when used with eps .",
    "the pushdown - based model , on the other hand , produces more precise execution flows , which contributes to the sharp decline in analyst time when using anadroid .",
    "_ dos attack and other malicious behaviors _ : denial of service ( dos ) on mobile phones exhaust limited resources by intentionally causing the phone to use these resources in an inefficient manner .",
    "for instance , an app might drain the battery by setting brightness to maximum or keeping wifi on at all times or exhaust file system space by logging every operation to a file .",
    "_ other malicious behaviors _ include those that do not leak or tamper with sensitive data but still do not behave the way the app was intended to behave .",
    "for example , a calculator that uses a random number in a calculation rather than the expected number , or blocks sms messages in the _ onreceive _ method when a trigger condition is met .",
    "these two categories are more application - dependent and subject to human judgment , by determining if this functionality is too far outside the advertised functionality of the app . in these scenarios , it is important that the analyzer results not overwhelm analysts .",
    "anadroid can not determine precisely whether the application is malicious or not by itself .",
    "instead , it identifies suspicious application behavior and uses analyst - supplied predicates to help search analysis results for locations of interest to the analyst .",
    "[ [ static - analysis - for - java - programs ] ] static analysis for java programs + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + +    precise and scalable context - sensitive pointer analysis for java ( object - oriented ) programs has been an open problem for decades .",
    "remarkably , a large bulk of the previous literature focused on finite - state abstractions for java programs , _",
    "@xmath1-cfa , limited object sensitivity , and their variants . in work that addresses exception flows  @xcite ,",
    "the analysis is often based on context - insensitivity or limited context - sensitivity , which means they can not differentiate the contexts where an exception is thrown or precisely determine which handlers can handle an exception .",
    "spark  @xcite and paddle  @xcite both use imprecise exception analysis .",
    "soot  @xcite also uses a separate exception analysis implemented by fu  _ et al . _",
    "@xcite which is not based on pointer analysis and not integrated into the tool .",
    "bravenboer and smaragdakis  @xcite propose joining points - to analysis and exception flow analysis to improve precision and analysis run time in their doop framework  @xcite .",
    "they have conducted extensive comparison of different options for polyvariance .",
    "it provides a more precise and efficient exception - flow analysis than spark , paddle , and soot , with respect of points - to and exception - catch links with respect to the metric used in  @xcite .",
    "ibm research s wala is a static analysis library designed to support different pointer analysis configurations .",
    "the points - to analyses of wala can compute which exceptions a method can throw , but does not guarantee precise matches between exceptions and their corresponding handlers .",
    "[ [ cfl -- and - pushdown - reachability - techniques ] ]   cfl- and pushdown - reachability techniques + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + +    earl  _ et al . _",
    "@xcite develop a pushdown reachability algorithm suitable for pushdown systems , which essentially draws on cfl- and pushdown - reachability analysis  @xcite .",
    "we modify their traditional cesk machine to handle object - oriented programs and extend it to analyze exceptions .",
    "this allows us to apply their algorithm directly to our analysis .",
    "cfl - reachability techniques have also been used to compute classical finite - state abstraction cfas  @xcite and type - based polymorphic control - flow analysis  @xcite .",
    "these analyses should not be confused with pushdown control - flow analysis , which is a fundamentally different kind of cfa .",
    "[ [ malware - detection - for - android - applications ] ] malware detection for android applications + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + +    several analyses have been proposed for android malware detection .",
    "dynamic taint analysis has been applied to identify security vulnerabilities at run time in android applications .",
    "taintdroid  @xcite dynamically tracks the flow of sensitive information and looks for confidentiality violations .",
    "ipcinspection  @xcite , quire  @xcite , and xmandroid  @xcite are designed to prevent privilege - escalation , where an application is compromised to provide sensitive capabilities to other applications .",
    "the vulnerabilities introduced by interapp communication is considered future work .",
    "however , these approaches typically ignore implicit flows raised by control structures in order to reduce run - time overhead .",
    "moreover , dynamically executing all execution paths of these applications to detect potential information leaks is impractical .",
    "the limitations make these approaches inappropriate for computing information flows for all submitted applications .",
    "woodpecker  @xcite uses traditional data - flow analysis to find possible capability leaks .",
    "comdroid  @xcite targets vulnerabilities related to interapp communications",
    ". however , it does not perform deep program analysis as anadroid does , and this results in high false positive rates .",
    "smartdroid  @xcite targets finding complex ui triggers and paths that lead to sensitive sinks .",
    "it addresses imprecision of static analysis by combining dynamic executions to filter out infeasible paths at run time .",
    "chex  @xcite focuses on detecting _ component hi - jacking _ by augmenting existing analysis framework using app - splitting to handle android s multiple entry points .",
    "our tool takes a significantly different approach from it ( and other finite - state - based static analysis tools ) in three aspects .",
    "( 1 ) we use pushdown flow analysis that handles traditional control - flow and exception flows precisely and efficiently . ( 2 ) our entry point saturation technique is sound , and we are able to detect interleaving execution of multiple entry points while chex handles only permutations of multi - entry points . ( 3 ) our tool enables human - in - the - loop analysis by allowing the analyst to supply predicates for the analyzer allowing it to highlight inspection of deeply disguised malware .",
    "jeon  _ et al . _",
    "@xcite proposes enforcing a fine - grained permission system .",
    "it limits access to resources that could normally be accessed by one of android s default permissions .",
    "specifically , the security policy uses a white list to determine which resources an app can use and a black list to deny access to resources .",
    "in addition , strings potentially containing urls are identified by pattern matching and constant propagation is used to infer more specific internet permissions .",
    "grace  _ et al . _",
    "@xcite have also identified unprivileged malicious apps that can exploit permissions on protected resources through a privileged agent ( or app component in our test suite ) that does not enforce permission checks .",
    "anadroid can also identify this malicious behavior .",
    "stowaway  @xcite is a static analysis tool identifying whether an application requests more permissions than it actually uses .",
    "pscout  @xcite aims for a similar goal , but produces more precise and fine - grained mapping from apis to permissions .",
    "our least permission report uses the pscout permission map as anadroid s database .",
    "however , they use a different approach , adapting testing methodology to test applications and identify apis that require permissions , while our approach annotates apis with permissions and statically analyzes all executable paths .",
    "in this paper , we address two challenges in static malware detection for android apps : the fundamental challenge of analyzing object - oriented programs and the android domain specific challenge of asynchronous multi - entry points .",
    "we address the first challenge using pushdown control flow analysis ( pdcfa ) to precisely analyze both traditional control flows and exception flows .",
    "the second challenge is addressed via entry - point saturation ( eps ) that when integrated with pdcfa serves as the basis for our analysis engine .",
    "we demonstrate a malware analyzer built on this engine , adding pushdown taint flow and least permissions analysis .",
    "we describe anadroid , a generic analysis framework for dalvik - bytecode that enables human - in - the - loop analysis by accepting user - supplied predicates to search analysis results for detailed inspection .",
    "we compare the new analyzer with a traditional finite - state analyzer using a test suite released by darpa apac project .",
    "we find that pdcfa together with eps yields statistically significant improvements in both accuracy and analysis time over traditional static analysis methods .",
    "our implementation is publicly available : github.com/shuyingliang/pushdownoo .",
    "this material is based on research sponsored by darpa under agreement number fa8750 - 12- 2 - 0106 . the u.s .",
    "government is authorized to reproduce and distribute reprints for governmental purposes notwithstanding any copyright notation thereon .",
    "reachability analysis of pushdown automata : application to model - checking . in _ proceedings of the 8th international conference on concurrency theory _",
    "( london , uk , uk , 1997 ) , concur 97 , springer - verlag , pp .  135150 .          analyzing inter - application communication in android . in _ proceedings of the 9th international conference on mobile systems , applications , and services _",
    "( new york , ny , usa , 2011 ) , mobisys 11 , acm , pp .",
    "239252 .",
    "an information - flow tracking system for realtime privacy monitoring on smartphones . in _ proceedings of the 9th usenix conference on operating systems design and implementation _ ( berkeley , ca , usa , 2010 ) , osdi10 , usenix association , pp .",
    "16 .    a calculus for assignments in higher - order languages . in",
    "popl 87 : proceedings of the 14th acm sigact - sigplan symposium on principles of programming languages _",
    "( new york , ny , usa , 1987 ) , acm , pp .  314 + .",
    "exception - chain analysis : revealing exception handling architecture in java server applications . in _ proceedings of the 29th international conference on software engineering _",
    "( washington , dc , usa , 2007 ) , icse 07 , ieee computer society , pp .",
    "230239 .",
    "fine - grained permissions in android applications . in _ proceedings of the second acm workshop on security and privacy in smartphones and mobile devices _",
    "( new york , ny , usa , 2012 ) , spsm 12 , acm , pp .",
    "314 .",
    "statically vetting android apps for component hijacking vulnerabilities . in _ proceedings of the 2012 acm conference on computer and communications security _",
    "( new york , ny , usa , 2012 ) , ccs 12 , acm , pp .",
    "229240 .",
    "type - based flow analysis : from polymorphic subtyping to cfl - reachability . in _",
    "popl 01 : proceedings of the 28th acm sigplan - sigact symposium on principles of programming languages _",
    "( new york , ny , usa , 2001 ) , acm , pp .",
    "5466 .                    an automatic system for revealing ui - based trigger conditions in android applications . in _ proceedings of the second acm workshop on security and privacy in smartphones and mobile devices",
    "( new york , ny , usa , 2012 ) , spsm 12 , acm , pp ."
  ],
  "abstract_text": [
    "<S> sound malware analysis of android applications is challenging . </S>",
    "<S> first , object - oriented programs exhibit highly interprocedural , dynamically dispatched control structure . </S>",
    "<S> second , the android programming paradigm relies heavily on the asynchronous execution of multiple entry points . </S>",
    "<S> existing analysis techniques focus more on the second challenge , while relying on traditional analytic techniques that suffer from inherent imprecision or unsoundness to solve the first .    </S>",
    "<S> we present anadroid , a static malware analysis framework for android apps . </S>",
    "<S> anadroid exploits two techniques to soundly raise precision : ( 1 ) it uses a pushdown system to precisely model dynamically dispatched interprocedural _ and _ exception - driven control - flow ; ( 2 ) it uses _ entry - point saturation _ ( eps ) to soundly approximate all possible interleavings of asynchronous entry points in android applications . </S>",
    "<S> ( it also integrates static taint - flow analysis and least permissions analysis to expand the class of malicious behaviors which it can catch . ) </S>",
    "<S> anadroid provides rich user interface support for human analysts which must ultimately rule on the `` maliciousness '' of a behavior . to demonstrate the effectiveness of anadroid s malware analysis </S>",
    "<S> , we had teams of analysts analyze a challenge suite of 52 android applications released as part of the automated program analysis for cybersecurity ( apac ) darpa program . </S>",
    "<S> the first team analyzed the apps using a version of anadroid that uses traditional ( finite - state - machine - based ) control - flow - analysis found in existing malware analysis tools ; the second team analyzed the apps using a version of anadroid that uses our enhanced pushdown - based control - flow - analysis . </S>",
    "<S> we measured machine analysis time , human analyst time , and their accuracy in flagging malicious applications . with pushdown analysis </S>",
    "<S> , we found statistically significant ( @xmath0 ) decreases in time : from 85 minutes per app to 35 minutes per app in human plus machine analysis time ; and statistically significant ( @xmath0 ) increases in accuracy with the pushdown - driven analyzer : from 71% correct identification to 95% correct identification .    </S>",
    "<S> [ program analysis , operational semantics ]    languages , security    static analysis ; taint analysis ; abstract interpretation ; pushdown systems ; malware detection </S>"
  ]
}