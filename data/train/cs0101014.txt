{
  "article_text": [
    "the well - founded semantics was introduced in @xcite to provide 3-valued interpretations to logic programs with negation . since its introduction , the well - founded semantics has become one of the most widely studied and most commonly accepted approaches to negation in logic programming @xcite .",
    "it was implemented in several top - down reasoning systems , most prominent of which is xsb @xcite .",
    "the well - founded semantics is closely related to the stable - model semantics @xcite , another major approach to logic programs with negation .",
    "the well - founded semantics approximates the stable - model semantics @xcite .",
    "moreover , computing the well - founded model of propositional programs is polynomial @xcite while computing stable models is np - hard @xcite .",
    "consequently , evaluating the well - founded semantics can be used as an effective preprocessing technique in algorithms to compute stable models @xcite .",
    "in addition , as demonstrated by smodels @xcite , at present the most advanced and most efficient system to compute stable models of datalog@xmath3 programs , the well - founded semantics can be used as a powerful lookahead mechanism .    despite the importance of the well - founded semantics , the question of how fast it can be computed",
    "has not attracted significant attention .",
    "van gelder @xcite described the so called _ alternating - fixpoint _ algorithm .",
    "van gelder s algorithm runs in time @xmath0 , where @xmath4 is the set of atoms occurring in a logic program @xmath2 , @xmath5 denotes the cardinality of @xmath4 , and @xmath1 is the size of @xmath2 ( the total number of atom occurrences in @xmath2 ) . improving on",
    "this algorithm turned out to be difficult .",
    "the first progress was obtained in @xcite .",
    "the algorithm described there , when restricted to programs whose rules contain at most two positive occurrences of atoms in their bodies , runs in time @xmath6 , where @xmath7 is the number of rules in @xmath2 . for programs",
    "whose rules have no more than one positive atom in the body a better estimate of @xmath8 was obtained . for some classes of programs",
    "this is an asymptotically better estimate than the @xmath0 estimate that holds for the algorithm by van gelder .",
    "a different approach to computing the well - founded model was proposed in @xcite .",
    "it is based on the notion of a program transformation @xcite .",
    "the authors describe there several transformations that can be implemented in linear time and that simplify a program while ( essentially ) preserving the well - founded semantics .",
    "these transformations are : the positive reduction , success , negative reduction , and failure ( psnf transformations , for short ) .",
    "they allow one to compute in linear time the kripke - kleene semantics @xcite of the program . to compute",
    "the well - founded semantics one also needs to detect the so - called _ positive loops_. the complexity of this task dominates the asymptotic complexity of the well - founded semantics computation .",
    "no improved algorithms for the positive - loop detection are offered in @xcite so the worst - case asymptotic complexity of the algorithm presented there remains the same as that of the alternating - fixpoint method . however , due to the use of psnf transformations , that simplify the program , the algorithm based on program transformations may in practice run faster .",
    "in contrast to the approach studied in @xcite , we focus here on the positive - loop detection task .",
    "the alternating - fixpoint algorithm works by successively improving lower approximations @xmath9 and @xmath10 to the sets of atoms that are true and false ( under the well - founded semantics ) , respectively .",
    "the algorithm starts with @xmath11 . using this estimate",
    ", it computes the first estimate for @xmath10 .",
    "next , using this estimate , in turn , it computes a better estimate for @xmath9 .",
    "the algorithm continues until further improvements are not possible .",
    "it returns the final sets @xmath9 and @xmath10 as the well - founded semantics .",
    "a dual version of the alternating - fixpoint algorithm , starting with @xmath12 and then alternatingly computing approximations to @xmath9 and @xmath10 , is also possible .",
    "the most time - consuming part of this algorithm is in computing estimates to the set of atoms that are false ( in this part , in particular , positive loops are detected ) . in the van gelder algorithm ,",
    "the best possible approximation ( given the current estimate for @xmath9 ) is always computed by using a bottom - up approach .    in this paper",
    "we focus on the problem of detecting positive loops and computing new false atoms .",
    "we restrict our attention to the class of programs that have at most one positive atom in the body .",
    "we denote this class of programs by @xmath13 .",
    "we show that for programs from @xmath13 , false atoms can be computed by means of a top - down approach by finding atoms that do not have a proof .",
    "moreover , we show that it is not necessary to find _ all _ atoms that can be established to be false at a given stage .",
    "finding a proper subset ( as long as it is not empty ) is also sufficient and results in a correct algorithm .",
    "we apply these techniques to design a version of an alternating - fixpoint algorithm computing the well - founded semantics of programs from the class @xmath13 .",
    "we demonstrate that the resulting algorithm is asymptotically better than the original alternating - fixpoint algorithm by van gelder .",
    "specifically , we show that our algorithm runs in time @xmath14 .",
    "thus , for programs with @xmath15 , the asymptotic estimate of the running time of our algorithm is better than that of algorithms by van gelder @xcite and berman et al .",
    "@xcite .",
    "as mentioned above , our approach is restricted to the class @xmath13 .",
    "applicability of our method can , however , be slightly extended .",
    "let us denote by @xmath16 the class of these logic programs that , after simplifying by means of psnf transformations ( or , equivalently , with respect to the kripke - kleene semantics ) fall into the class @xmath13 .",
    "since psnf transformations ( the kripke - kleene semantics ) can be computed in linear time , the asymptotic estimate of the running time of our method extends to all programs in the class @xmath16 .",
    "the paper is organized as follows . in the next section we provide a brief review of the key notions and terminology . in section [ algs ]",
    "we describe several modifications to the original van gelder algorithm , we show their correctness and estimate their running time .",
    "the ultimate effect of our considerations there is a general template for an algorithm to compute the well - founded semantics .",
    "any algorithm computing some ( not necessarily all ) atoms that can be established as false given a current estimate to the well - founded can be used with it .",
    "one such algorithm , for programs from the class @xmath13 , is described and analyzed in section [ cluster ] .",
    "it constitutes the main contribution of the paper and yields a new , currently asymptotically most efficient algorithm for computing the well - founded semantics for programs in @xmath13 .",
    "the last section contains conclusions .",
    "we start by reviewing basic concepts and notation related to logic programs and the well - founded semantics , as well as some simple auxiliary results . in the paper",
    "we consider the propositional case only .",
    "let @xmath2 be a normal logic program .",
    "by @xmath4 we denote the set of atoms occurring in @xmath2 .",
    "let @xmath17 ( throughout the paper we often drop a reference to @xmath2 from our notation , whenever there is no danger of ambiguity ) . by @xmath18",
    "we denote the program obtained from @xmath2 by removing all rules whose bodies contain negated literals of the form @xmath19 , where @xmath20 .",
    "further , by @xmath21 we denote the program obtained from @xmath2 by removing from the bodies of its rules _ all _ negative literals . clearly , the program @xmath22 coincides with the _ gelfond - lifschitz _ reduct of @xmath2 with respect to @xmath23 ( throughout the paper , we write @xmath24 for @xmath22 , to simplify notation ) .",
    "the _ gelfond - lifschitz _ operator on the algebra of all subsets of @xmath25 , @xmath26 ( following our convention , we omit the reference to @xmath2 from the notation ) , is defined by @xmath27 where @xmath28 stands for a least model of a horn program @xmath29 .",
    "we now present characterizations of the well - founded semantics .",
    "we phrase them in the language of operators and their fixpoints .",
    "all operators considered here are defined on the algebra of subsets of @xmath4 .",
    "we denote a least fixpoint ( if it exists ) of an operator @xmath30 by @xmath31 .",
    "it is well known that @xmath26 is antimonotone .",
    "consequently , @xmath32 is monotone and has a least fixpoint .",
    "the set of atoms that are true with respect to the well - founded semantics of a program @xmath2 , denoted by @xmath33 , is precisely the least fixpoint of the operator @xmath34 , that is , @xmath35 @xcite .",
    "the set of atoms that are false with respect to the well - founded semantics of a program @xmath2 , denoted by @xmath36 , is given by @xmath37 ( throughout the paper , @xmath38 denotes the complement of a set @xmath39 with respect to @xmath4 ) .",
    "one can define a dual operator to @xmath34 by @xmath40 it is easy to see that @xmath41 is monotone and that its least fixpoint is @xmath36 .",
    "thus , @xmath42 and @xmath43 .",
    "we close this section by discussing ways to compute @xmath44 for a given finite propositional logic program @xmath2 and a set of atoms @xmath45 .",
    "a straightforward approach is to compute the gelfond - lifschitz reduct @xmath24 and then to compute its least model .",
    "the resulting algorithm is asymptotically optimal as it runs in time linear in the size of the program .",
    "however , in this paper we will use a different approach , more appropriate for the computation of the well - founded semantics .",
    "let @xmath2 be a logic program with negation .",
    "we define @xmath46 . for every set @xmath47",
    ", we define @xmath48 . if we interpret literals of @xmath49 as new _ atoms _ , then for every set @xmath17 , the program @xmath50 can be viewed as a horn program .",
    "thus , it has a least model .",
    "it is easy to see that @xmath51 here , @xmath2 appearing at the left - hand side of the equation stands for the original logic program , while @xmath2 appearing at the right - hand side of the equation stands for the same program but interpreted as a horn program .",
    "thus , using the algorithm of dowling and gallier @xcite , the gelfond - lifschitz reduct can be computed in time @xmath52 ( since @xmath17 , @xmath53 ) .",
    "the departure point for our discussion of algorithms to compute the well - founded semantics is the _ alternating - fixpoint _ algorithm of van gelder @xcite . using the terminology introduced in the previous section",
    "it can be formulated as follows .",
    "= = = = = = = = = = + * algorithm 1 ( van gelder ) + @xmath54 ; +   + @xmath55 ; ( * or equivalently : @xmath56 ; * ) + @xmath57 ; ( * or equivalently : @xmath58 ; * ) + no change in @xmath10 ; + @xmath9 and @xmath10 . *",
    "let @xmath59 and @xmath60 be the values of the set @xmath10 just before and just after an iteration of the * repeat * loop in algorithm 1 . clearly , @xmath61 thus , after iteration @xmath62 of the * repeat * loop , @xmath63 .",
    "consequently , it follows from our earlier remarks that when algorithm 1 terminates , the set @xmath10 that is returned satisfies @xmath64 .",
    "since there is no change in @xmath10 in the last iteration , when the algorithm terminates , we have @xmath65 .",
    "that is , algorithm 1 is correct .",
    "we will now modify algorithm 1 .",
    "the basis for algorithm 1 is the operator @xmath41 .",
    "this operator is not _",
    "progressive_. that is , @xmath23 is not necessarily a subset of @xmath66",
    ". we will now introduce a related progressive operator , say @xmath67 , and show that it can be used to replace @xmath41 .",
    "let @xmath2 be a logic program and let @xmath9 and @xmath10 be two subsets of @xmath4 . by @xmath68",
    "we denote the program obtained from @xmath2 by removing    1 .",
    "all rules whose heads are in @xmath10 2 .",
    "all rules whose bodies contain a positive occurrence of an atom from @xmath10 3 .",
    "all rules whose bodies contain a negated literal of the form @xmath19 , where @xmath69 .",
    "clearly , @xmath70 .",
    "we define an operator @xmath71 as follows : @xmath72 where @xmath73 and @xmath74 abbreviates @xmath75 .",
    "the following result gathers key properties of the operator @xmath67 .",
    "[ l1a ] let @xmath2 be a normal logic program .",
    "then :    1 .",
    "[ l11 ] @xmath67 is monotone 2 .",
    "[ l12 ] for every @xmath76 , @xmath77 3 .",
    "[ l13 ] for every @xmath78 , @xmath79 4 .",
    "[ l15 ] @xmath80 5 .",
    "[ l14 ] for every @xmath76 , @xmath81 , where @xmath73 .",
    "proof : ( [ l11 ] ) assume that @xmath82 .",
    "set @xmath83 , @xmath84 .",
    "clearly , @xmath85 and , by antimonotonicity of @xmath26 , @xmath86 . by the definition of @xmath68 ,",
    "consequently , @xmath88 and , so , @xmath89 .",
    "+ ( [ l12 ] ) let @xmath73 .",
    "clearly , @xmath70 .",
    "thus , @xmath90 .",
    "+ ( [ l13 ] ) we have , @xmath91 .",
    "it follows that removing from @xmath92 rules with heads in @xmath93 and those that contain an atom from @xmath93 in their bodies does not change the least model .",
    "that is , @xmath94 since , @xmath95 , @xmath96 .",
    "let @xmath97 .",
    "then , by ( [ l11 ] ) , @xmath98",
    ". thus , we have @xmath99 ( [ l15 ] ) the least fixpoint of @xmath67 is given by @xmath100 . by ( [ l13 ] ) , @xmath101 .",
    "on the other hand , by ( [ l11 ] ) and ( [ l12 ] ) , @xmath102 .",
    "thus , @xmath103 .",
    "it follows that @xmath104 .",
    "( [ l14 ] ) let @xmath73",
    ". since @xmath68 has no rules with head in @xmath10 , @xmath105 and , consequently , @xmath106 .",
    "thus , the assertion follows .",
    "@xmath107    theorem [ l1a ] allows us to prove the correctness of the following modification of algorithm 1 .",
    "= = = = = = = = = = + * algorithm 2 + @xmath54 ; +   + @xmath55 ; + @xmath108 ; + @xmath109 ; + no change in @xmath10 ; + @xmath9 and @xmath10 . *    by theorem [ l1a ] , each iteration of the * repeat * loop computes @xmath71 as the new value for the set @xmath10 . more formally ,",
    "the set @xmath10 just after iteration @xmath62 , satisfies @xmath110 .",
    "thus , when the algorithm terminates , the set @xmath10 that is returned is the least fixpoint of @xmath67 .",
    "consequently , by theorem [ l1a]([l15 ] ) , algorithm 2 is correct",
    ".    we will now modify algorithm 2 to obtain a general template for an alternating - fixpoint algorithm to compute the well - founded semantics .",
    "the key idea is to observe that it is enough to compute a subset of @xmath111 in each iteration and the algorithm remains correct .",
    "let us assume that for some operator @xmath112 defined for pairs @xmath113 , where @xmath114 and @xmath29 is a horn program such that @xmath115 ( the complement is , as always , evaluated with respect to @xmath4 ) , we have :    ( w1 ) : :    @xmath116  ( w2 ) : :    @xmath117 if and only if    @xmath118 .",
    "let @xmath119 . by the definition of @xmath68 ,",
    "thus , we define @xmath121 , where @xmath122 .",
    "it is clear that for every @xmath76 , @xmath123 , the latter inclusion follows from theorem [ l1a]([l14 ] ) and ( w1 ) .",
    "consequently , for every @xmath62 , @xmath124 it follows that @xmath125 .",
    "it also follows that there is the first @xmath62 such that @xmath126 .",
    "let us denote this set @xmath127 by @xmath128",
    ". then @xmath129 . in the same time",
    ", by condition ( w2 ) , @xmath130 . since @xmath36 is the least fixpoint of @xmath67 , @xmath131 .",
    "it follows that a modification of algorithm 2 in which line @xmath132 is replaced by @xmath133 correctly computes the well - founded semantics of a program @xmath2 .",
    "thus , we obtain the following algorithm for computing the well - founded semantics .",
    "= = = = = = = = = = + * algorithm 3 + @xmath54 ; +   + @xmath55 ; + @xmath134 ; + @xmath109 ; + no change in @xmath10 ; + @xmath9 and @xmath10 .",
    "*    we will now refine algorithm 3 .",
    "specifically , we will show that the sets @xmath9 and @xmath10 can be computed incrementally .",
    "let @xmath135 be a horn program .",
    "we define the _ residual _ program of @xmath135 , @xmath136 , to be the horn program obtained from @xmath135 by removing all rules of @xmath135 with the head in @xmath137 and by removing from the bodies of the remaining rules those elements that are in @xmath137 .",
    "we have the following technical result .    [ l0 ]",
    "let @xmath135 be a horn program and let @xmath23 be a set of atoms such that @xmath138 .",
    "then @xmath139 .",
    "@xmath107    lemma [ l0 ] implies that ( we treat here negated literals as new atoms and @xmath2 as horn program over the extended alphabet ) @xmath140 thus , if the set @xmath10 is expanded by new elements from @xmath111 , then the new set @xmath9 can be computed by increasing the old set @xmath9 by @xmath141 .",
    "important thing to note is that the increment @xmath142 can be computed on the basis of the residual program and the increment @xmath111 .",
    "similarly , we have @xmath143 thus , computing @xmath68 can also be done incrementally on the basis of the program considered in the previous iteration by taking into account most recently computed increments @xmath111 and @xmath142 .",
    "this discussion implies that algorithm 3 can be equivalently restated as follows :    = = = = = = = = = = + * algorithm 3 + 1@xmath144 ; + 2@xmath145 ; ( * @xmath135 will be treated as a horn program * ) + 3@xmath146 ; + 4 + 5@xmath147 ; + 6@xmath148 ; + 7@xmath149 ; + 8@xmath150 ; + 9@xmath151 ; + 10@xmath152 ; + 11 no change in @xmath10 ; + 12 @xmath9 and @xmath10 . *    we will now estimate the running time of algorithm 3 .",
    "clearly line 1 requires constant time .",
    "setting up appropriate data structures for programs @xmath135 and @xmath29 ( lines 2 and 3 ) takes @xmath153 steps . in each iteration , @xmath142 is computed and the current program @xmath135 is replaced by the program @xmath154 ( lines 5 and 6 ) . by modifying the algorithm from @xcite and assuming that @xmath135 is already stored in the memory ( it is avaliable either as the result of the initialization in the case of the first iteration or as a result of the computation in the previous iteration ) , both tasks can be accomplished in @xmath155 steps . here",
    "@xmath156 denotes the old version of @xmath135 and @xmath157 denotes the new version of @xmath135 .",
    "consequently , the total time needed for lines 5 and 6 over all iterations is given by @xmath158 ( where @xmath159 is the program @xmath135 , when the algorithm terminates ) .",
    "the time needed for all lines 7 is proportional to the number of iterations and is @xmath160 .    given a logic program @xmath29 and sets of atoms @xmath142 and @xmath111 , it takes @xmath161 steps to compute the program @xmath162 in line 8 .",
    "we assume here that @xmath29 is already in the memory as a result of the initialization in the case of the first iteration , or as the result of the computation in the previous iteration , otherwise .",
    "it follows that the total time over all iterations needed to execute line 8 is @xmath163 .",
    "thus , we obtain that the running time of algorithm 3 is given by @xmath164 , where @xmath165 is the total time needed to compute @xmath166 over all iterations of the algorithm .    in the standard ( van gelder s )",
    "implementation of algorithm 3 , we compute the whole set @xmath167 as @xmath166 .",
    "in addition , computation is performed in a bottom - up fashion .",
    "that is , we first compute the least model of @xmath168 and then its complement with respect to @xmath169 .",
    "such approach requires @xmath170 steps per iteration to execute line 9 and leads to @xmath0 running - time estimate for the alternating - fixpoint algorithm .",
    "in this section we will focus on the class of programs , @xmath13 , that is , programs whose rules have no more than one positive atom in their bodies .",
    "we assume that we have a procedure @xmath171 that , given a horn program @xmath172 , returns a subset of the set @xmath173 .",
    "we also assume that @xmath171 returns the empty set _ if and only if _ @xmath174 .",
    "for every pair @xmath113 , where @xmath76 and @xmath29 is a horn program such that @xmath115 , we define @xmath175 it is easy to see that this operator @xmath176 satisfies conditions ( w1 ) and ( w2 ) . consequently , it can be used in algorithm 3 . clearly , the procedure @xmath112 and its computational properties are determined by the procedure @xmath171 . in the remainder of the paper",
    ", we will describe a particular implementation of the procedure @xmath171 and estimate its running time .",
    "we will use this estimate to obtain a bound on the running time of the resulting version of algorithm 3 .    a straightforward way to compute the least model of @xmath29 and so , to find @xmath177 ,",
    "is `` bottom - up '' .",
    "that is , we start with atoms which are heads of rules with the empty bodies and use the rules of @xmath29 to compute all atoms in @xmath28 by iterating the van emden - kowalski operator .",
    "an efficient implementation of the process is provided by the dowling - gallier algorithm @xcite .",
    "the approach we follow here in the procedure @xmath171 is `` top - down '' and gives us , in general , only a part of the set @xmath177 . more precisely , for an atom @xmath178 we proceed `` backwards '' attempting to construct a proof or to demonstrate that no proof exists . in the process , we either go back to an atom that is the head of a rule with empty body or we show that no proof exists . in the former case , @xmath179 . in the latter",
    "one , none of the atoms considered while searching for a proof of @xmath178 are in @xmath28 ( because @xmath180 and each rule has at most one antecedent ) .",
    "the problem is that we may find an atom @xmath178 that does not have a proof only _",
    "after _ we look at all other atoms first .",
    "thus , in the worst case , finding one new false atom may require time that is proportional to the size of @xmath29 .    to improve the time performance , we look for proofs simultaneously for all atoms and grow the proofs `` backwards '' in a carefully controlled way .",
    "namely , we never let one search to get too much ahead of the other searches . this controlled way of looking for proofs is the key idea of our approach and leads to a better performance",
    ". we will now provide an informal description of the procedure @xmath171 followed later by a formal specification and an example .    in the procedure , we make use of a _ new _ atom , say @xmath181 , different from all atoms occurring in @xmath29 .",
    "further , we denote by @xmath182 the atom in the head of a rule @xmath183 and by @xmath184 the atom which is either the unique positive atom in the body of @xmath185 , if such an atom exists , or @xmath181 otherwise .",
    "we call an atom @xmath186 _ accessible _ if there are rules @xmath187 in @xmath29 such that @xmath188 , for @xmath189 , @xmath190 and @xmath191 . clearly , the least model @xmath28 of @xmath29 is precisely the set of all accessible atoms .    in each step of the algorithm ,",
    "the set of atoms from @xmath192 is partitioned into _ potentially false sets _ or _ pf - sets _ , for short .",
    "we say that a set @xmath193 is a _ pf - set _",
    "if for each pair of _ distinct _ atoms @xmath194 there are rules @xmath187 in @xmath29 such that @xmath195 , for @xmath189 , @xmath196 and @xmath191 .",
    "it is clear that if @xmath197 is a pf - set then either all its elements are accessible ( belong to the least model of @xmath29 ) or none of them does ( they are all false ) . clearly , singleton sets consisting of individual atoms in @xmath198 are pf - sets . in the algorithm , with each pf - set we maintain its cardinality .",
    "current information about the state of all top - down searches and about the dependencies among atoms , that were discovered so far , is maintained in a directed graph @xmath199 .",
    "the vertex set of this graph , say @xmath200 , consists of @xmath201 and of a family of pf - sets forming a partition of the set @xmath192 .",
    "the edges of @xmath199 are specified by a _ partial _",
    "function @xmath202 .",
    "we write @xmath203 if @xmath204 is undefined for @xmath197 .",
    "thus , the set of edges of @xmath199 is given by @xmath205 .",
    "since @xmath204 is a partial function , it is easy to see that the connected components of the graph @xmath199 are unicyclic graphs or trees rooted in those vertices @xmath197 for which @xmath206 is undefined . throughout the algorithm we always have @xmath207 .",
    "thus , the connected component of @xmath199 containing @xmath201 is always a tree and @xmath201 is its root .",
    "if @xmath208 and @xmath197 are two different pf - sets , the existence of the edge @xmath209 in @xmath199 means that we have already discovered a rule in the original program whose head is in @xmath197 and whose tail is in @xmath208 .",
    "thus , if vertices in @xmath208 are accessible , then so are the vertices in @xmath197 . a pf - set that is the root of a tree forming a component of @xmath199 is called an _ active _ pf - set .",
    "if @xmath197 is an active pf - set then no rule @xmath185 with @xmath210 and @xmath211 has been detected so far .",
    "thus , @xmath197 is a candidate for a set of atoms which does not intersect the least model of @xmath29 .",
    "let us note that even though @xmath201 is a root of a tree in @xmath199 it is never active as it is not a pf - set in the first place .",
    "we let active pf - sets grow by gluing them with other pf - sets .",
    "however , we allow to grow only these active pf - sets whose cardinalities are the least . in each iteration of the algorithm",
    "the value of the variable @xmath212 is a lower bound for the cardinalities of active pf - sets . to grow an active pf - set @xmath197",
    ", we look for rules with heads in @xmath197 and with tails in pf - sets _ other _ than @xmath197 ( not necessarily active ) or in @xmath201 .",
    "the dependencies between pf - sets discovered in this way are represented as new directed edges in @xmath199 .",
    "pf - sets that appear in the same cycle are glued together ( in the procedure _ cycle _ ) .",
    "since @xmath201 is not an active pf - set , it never becomes an element of a cycle in @xmath199 .    if , when attempting to grow a pf - set @xmath197 we discover a rule with head in @xmath197 and with the tail in a vertex of the tree of @xmath199 rooted in @xmath201 , then @xmath197 is from now on ignored ( all its vertices belong to the least model of @xmath29 ) .",
    "indeed , @xmath197 gets connected to a tree of @xmath199 rooted in @xmath201 .",
    "consequently , it can not become a member of a cycle in @xmath199 in the future and is never again considered by the procedure _",
    "cycle_.    the main loop ( lines 6 - 23 ) of the algorithm @xmath171 below starts by incrementing @xmath212 followed by a call to the procedure @xmath213 .",
    "this procedure scans the graph @xmath199 and identifies all its cycles .",
    "it then modifies @xmath199 by considering each cycle and by gluing its pf - sets into a single pf - set . to this end",
    ", it modifies the vertex set @xmath214 of @xmath199 and the function @xmath204 defining the edges of @xmath199 .",
    "each such new pf - set becomes the root of its tree in @xmath199 and so , it becomes active .",
    "the procedure _ cycle _ computes the cardinality of each new active pf - set .",
    "finally , it creates a list @xmath215 so that it consists of active pf - sets of cardinality @xmath212 .",
    "if no such set is found ( @xmath215 is empty ) , we move on to the next iteration of the main loop and increment @xmath212 by 1 .",
    "we give a more detailed description of the procedure @xmath216 later in the paper when we analyze the time complexity of our method .",
    "for each active pf - set @xmath217 we consider the tail of each rule with head in @xmath197 ( lines 9 - 22 ) .",
    "if there is a rule @xmath185 with @xmath210 and @xmath211 then it is detected ( line 15 ) .",
    "the value @xmath206 is set to this element in @xmath214 that contains @xmath184 ( it may be that this set is @xmath201 ) .",
    "we also set the variable @xmath218 to * true * ( line 16 ) .",
    "the pf - set @xmath197 stops to be active .",
    "we move on to the next active pf - set on @xmath215 .",
    "if such a rule @xmath185 does not exist then @xmath219 and @xmath197 is a set of cardinality @xmath212 consisting of atoms which are not in the least model of @xmath29 .",
    "this set is returned by the procedure @xmath171 ( line 21 ) .",
    "hence , for an active pf - set considered in the loop 6 - 23 , either we find a pf - set @xmath220 ( and we have to consider the next pf - set on @xmath215 ) or @xmath197 is returned as a set of atoms which are not in the least model of @xmath29 ( and the procedure @xmath171 terminates ) .",
    "thus , the procedure @xmath171 is completed if either a nonempty set @xmath197 of atoms which are not in the least model of @xmath29 is found or , after some passes of the loop 6 - 23 , the graph @xmath199 has no active pf - sets . in the latter case",
    "@xmath199 is a tree with the root in @xmath221 .",
    "thus , @xmath222 and @xmath223 is returned ( line 24 ) .    in the procedure @xmath171 , as formally described below , an input program @xmath29 is represented by lists @xmath224 , @xmath186 , of all atoms @xmath225 such that @xmath225 is the body of some rule with the head @xmath178 . if there is a rule with the head @xmath178 and empty body , we insert @xmath181 into the list @xmath224 .",
    "we also use an operation @xmath226 on lists and elements .",
    "let @xmath227 be a list and @xmath208 be an element , either belonging to @xmath227 or having a special value * undefined*. then @xmath228 the value * undefined * should not be mixed with * nil * which indicates the end of a list .",
    "finally , we use a procedure @xmath229 which , for an atom @xmath208 and a collection @xmath214 of disjoint sets , one of which contains @xmath208 , finds the name of the set in @xmath214 containing @xmath208 ( it follows from our assumptions that such a set is unique ) .",
    "elements of @xmath214 are maintained as linked lists .",
    "each element on such a list has a pointer to the head of the list .",
    "the head serves as the identifier for the list . when the procedure @xmath229 is called , it returns the head of the list to which @xmath208 belongs .",
    "= = = = = = = = = = + 1**procedure @xmath230 ; + 2@xmath231 ; + 3 @xmath232 * do * @xmath233 ; + 4 @xmath234 * do * \\{@xmath235 ;  @xmath236 } ; + 5@xmath237 ; + 6 @xmath238 * do * + 7@xmath239 ; + 8@xmath240 ; + 9 all @xmath241 * do * + 10@xmath242 ; + 11@xmath243 ; + 12 @xmath244 * nil and * * not * @xmath218 * do * + 13@xmath245 ; + 14 @xmath246 * nil and * * not * @xmath218 * do * + 15@xmath247*if * @xmath248 + 16 @xmath249 ; @xmath250 + 17 @xmath245 + 18 ( 14)@xmath251 ; + 19 @xmath218 * then * @xmath243 + 20 ( 12)@xmath251 ; + 21 @xmath218 * then return * @xmath197  ( * the procedure terminates * ) + 22 ( 9)@xmath251 + 23 ( 6)@xmath251 ; + 24**return @xmath223 + 25 @xmath171 ; + * * *",
    "*    we will now illustrate the operation of the algorithm .",
    "let us consider the following horn logic program @xmath29 : @xmath252    this program is represented as a graph , @xmath253 , in fig .",
    "the vertices of this graph correspond to the atoms of the program .",
    "in addition , @xmath253 has an auxiliary vertex @xmath254 .",
    "an edge @xmath255 , where @xmath256 , represents the clause @xmath257 from @xmath29 .",
    "an edge @xmath258 , where @xmath259 , represents the clause @xmath260 .",
    "when illustrating the algorithm , we assume that atoms from @xmath192 ( atoms @xmath261 in our example ) appear on the lists @xmath262 , @xmath263 , in the alphabetical order .",
    "we also assume that whenever @xmath181 belongs to a list @xmath262 , it appears as the first atom on the list .    in the algorithm _",
    "false _ , the current state of knowledge about the possibility of proving an atom from @xmath29 is represented by the graph @xmath264 .",
    "initially , @xmath199 consists of isolated vertices .",
    "indeed , line 3 of the algorithm sets @xmath265 to undefined , for every vertex @xmath266 of @xmath214 ( see fig .",
    "[ rys1a ] ( left ) ) .",
    "all of the vertices of @xmath199 , except for @xmath201 are active pf - sets .",
    "the procedure @xmath216 ( line 8) , called with @xmath267 , puts all of them on the list @xmath215 .",
    "the algorithm considers next ( line 9 ) all elements on the list @xmath215 , that is , all vertices of @xmath199 that are active pf - sets and have cardinality equal to _ size_. during the first iteration of the loop 6 - 23 , @xmath215 consists of all vertices of @xmath199 , except for @xmath201 ( that is , singleton sets @xmath268 , where @xmath269 ) . for each vertex @xmath197 of @xmath199 on @xmath215 ,",
    "the algorithm looks for a _ back rule _ for @xmath197 , that is , a rule in @xmath29 with the head in @xmath197 and the tail in a pf - set other than @xmath197 or in @xmath201 . in our graphical representation of @xmath29 by means of the graph @xmath253 , a back rule for @xmath197 corresponds to an edge ( referred to as a _",
    "back _ edge ) in @xmath253 with the head in @xmath197 and the tail in a vertex of @xmath199 other than @xmath197 ( possibly in @xmath201 ) . to find a back rule ( edge ) for @xmath197 , all atoms @xmath270 of @xmath29 ( equivalently ,",
    "all vertices @xmath270 of @xmath253 ) that belong to @xmath197 are considered ( the loop 12 - 20 ) . for each such atom @xmath270 ,",
    "the algorithm searches for the first atom on the list @xmath271 that does not belong to @xmath197 .",
    "let us recall that @xmath271 is the list of atoms that are the tails of rules with the head @xmath270 or , in the terms of the graph @xmath253 , that are the tails of edges with the head @xmath270 .",
    "if such an atom is found , together with @xmath270 it determines a back rule ( edge ) @xmath185 for @xmath197 .",
    "the algorithm sets @xmath206 to be equal to the pf - set containing the tail of @xmath185 ( line 16 ) .",
    "that is , an edge from @xmath206 to @xmath197 is added to @xmath199 .",
    "the algorithm moves then on to the next element of the list @xmath215 .    in our example",
    ", in the first iteration of the loop 6 - 23 , a back rule is found for every element on @xmath215 , that is , for every vertex of @xmath199 other than @xmath201 .",
    "for instance , for the vertex @xmath272 , the algorithm considers atoms on the list @xmath273 ( let us recall that atoms on lists @xmath262 are arranged alphabetically with the exception of the special atom @xmath181 which , if present on a list , is always its first element ) .",
    "the first atom on the list , @xmath274 does not belong to @xmath272 .",
    "thus , it defines , together with @xmath275 a back rule for @xmath272 , @xmath276 .",
    "the resulting graph @xmath199 is shown in fig . [ rys1a ] on the right .",
    "let us note that when scanning the list @xmath277 in subsequent iterations the algorithm resumes the scan with the first atom that has not been looked at yet ( cf .",
    "the definition of the operation _ next _ ) .",
    "thus , the next time @xmath275 is considered as an element of an active pf - set for which a back rule is searched for , the scan of @xmath277 will start with @xmath278 .",
    "the same holds true for all lists @xmath262 , @xmath279 .",
    "consequently , each atom on each of these lists is considered just once .",
    "such an approach still guarantees that finding back rules works correctly ( that is , that they are found by the algorithm whenever they exist ) .",
    "indeed , when an atom on a list @xmath262 is considered , it either defines a back rule with the head @xmath266 ( and , thus , can not define any new back rule with the head @xmath266 in the future ) or it is in the same active pf - set as @xmath266 ( and , thus , it neither defines a back rule now nor it will define it in the future , as it will remain in the same pf - set as @xmath266 till the algorithm terminates ) .",
    "the second iteration of the loop 6 - 23 starts with the procedure _ cycle _ contracting each cycle in the graph @xmath199 to a single vertex . the resulting graph is shown in fig .",
    "[ rys2a ] on the left .",
    "the procedure _ cycle _ then creates a new list @xmath215 .",
    "it consists of all active pf - sets of cardinality 2 . in our case",
    ", @xmath215 contains @xmath280 and @xmath281 ( @xmath282 is also active but has cardinality 3 )",
    ".    continuing with the second iteration , the algorithm next considers each vertex on @xmath215 ( the loop 9 - 22 ) and looks for back rules . in this iteration ,",
    "a back rule is found for each of the nodes on @xmath215 and the modified graph @xmath199 is given in fig .",
    "[ rys2a ] on the right .    in the third iteration , the procedure _",
    "cycle _ contracts the only cycle in @xmath199 to a single active pf - set of cardinality 4 ( figure [ rys3a ] , left side ) .",
    "it also creates a new list @xmath215 .",
    "this time it consists of active pf - sets of cardinality 3 . there is just one such set - @xmath282 .",
    "subsequently , the algorithm _ false _ looks for a back rule for @xmath282 .",
    "it starts by considering edges ending in @xmath275 ( line 11 ; we assume that @xmath197 is represented by the list @xmath283 ) .",
    "it scans the list @xmath277 starting at the first atom that has not been inspected so far , that is , @xmath278 .",
    "however , since @xmath278 belongs to the same pf - set as @xmath275 , @xmath278 does not specify a back rule .",
    "since there are no more atoms on the list @xmath277 , we move on to the next iteration of the loop 12 - 20 and consider atom @xmath274 .",
    "we have @xmath284 . since @xmath278 was already considered ( and yielded a back rule for @xmath285 ) in the first iteration , we consider @xmath286 . since @xmath287 , it defines a back rule for @xmath282 , @xmath288 .    the resulting graph @xmath199 is shown in figure [ rys3a ] ( on the right ) .",
    "it has no cycles .",
    "so , the only thing done by the procedure _ cycle _ in the iteration 4 is that it puts on @xmath215 active pf - sets of cardinality 4 .",
    "there is just one such set in @xmath199 , @xmath289 . the algorithm _ false _",
    "looks for a back edge for @xmath289 and does not find any .",
    "the variable _ success _ remains * false*. the algorithm returns @xmath289 and terminates ( line 21 ) .",
    "let us note that this set is a proper subset of the set @xmath173 .",
    "the following theorem formally establishes two key properties of the procedure @xmath171 .",
    "[ t1 ]    1 .",
    "the procedure @xmath171 returns a set @xmath197 such that @xmath290 .",
    "@xmath171 returns the empty set if and only if @xmath291 .",
    "proof : ( 1 ) the statement is trivially true if _ false _ returns the empty set .",
    "thus assume that the returned set @xmath292 .",
    "it means that the value of the variable @xmath218 is * false * after all passes of the loop 12 - 20 for some active pf - set @xmath197 in the list @xmath215 .",
    "thus every rule in @xmath29 with the head in @xmath197 has been considered .",
    "suppose there is a rule @xmath185 in @xmath29 with @xmath293 and @xmath294 .",
    "this rule was considered by the procedure @xmath171 when @xmath295 was a member of some active pf - set , say @xmath296 .",
    "since larger pf - sets are obtained by gluing smaller ones , @xmath297 . while @xmath185 was being considered , the value of @xmath298 in the loop 14 - 18 was @xmath225 and the value of @xmath197 was @xmath296 .",
    "consequently , @xmath299 in line 15 because @xmath297 and @xmath300 so @xmath301 .",
    "hence the value of @xmath218 was set to * true * and @xmath302 was defined to be , say , @xmath303 in line 16 .",
    "the pf - set @xmath296 stopped to be active .",
    "recall that @xmath197 is active when the procedure stops .",
    "hence @xmath296 had to be glued with other pf - sets to obtain @xmath197 .",
    "this is , however , impossible because if @xmath296 were glued with some other pf - sets to form a larger pf - set @xmath266 then @xmath304 .",
    "notice that @xmath305 .",
    "we have got a contradiction with @xmath300 .    hence , there are no rules @xmath185 in @xmath29 with @xmath210 and @xmath306 .",
    "thus no atom in @xmath197 is accessible so @xmath290 .",
    "+ ( 2 ) suppose _ false _ returns the empty set and consider the last pass of the loop 6 - 23 , for @xmath307 .",
    "if the list @xmath215 is empty then no vertex of @xmath199 is an active pf - set .",
    "hence , @xmath199 is a tree with the root @xmath221 .",
    "thus all atoms in @xmath198 are accessible and consequently @xmath308 .",
    "if the list @xmath215 is nonempty then it contains one pf - set @xmath309 .",
    "the empty set is returned by the procedure @xmath171 so the value of the variable @xmath218 in line 16 is * true * for @xmath309 .",
    "it means that for some rule @xmath185 in @xmath29 with @xmath310 , @xmath311 so @xmath312 .",
    "hence , @xmath270 is accessible and , consequently , all atoms in @xmath198 are accessible .",
    "that is , we have @xmath291 .",
    "the converse of the implication proved above follows immediately from the first part of the theorem .",
    "@xmath107    we shall now consider the procedure @xmath216 a little bit more carefully . the procedure can be informally written in the following form .",
    "= = = = + * procedure * @xmath240 + 1.initialize @xmath215 to empty .",
    "+ 2.find all cycles @xmath313 in the graph @xmath199 .",
    "put @xmath314 .",
    "+ 3.for every cycle @xmath315 , @xmath316 , do ( i)-(iv ) .",
    "+ ( i)set @xmath317 ; + ( ii)compute @xmath318 ( sum up the cardinalities of all vertices in @xmath319 ) ; + ( iii)update the set @xmath214 : set @xmath320 ; ( * @xmath321 becomes + an active pf - set * ) + ( iv)update the function @xmath204 : for every @xmath322 , if @xmath323 ( for + some @xmath324 ) then @xmath325 ; + 4.for every vertex of @xmath199 that is an active pf - set , if @xmath326 , insert @xmath197 + into the list @xmath215 .",
    "since @xmath199 is a directed graph whose connected components are either unicyclic graphs or trees , step 2 of the procedure @xmath216 can be implemented in @xmath327 time . since pf - sets are represented as linked lists , with each node on the list pointing to the head of the list , step ( i ) can be implemented to take @xmath328 steps .",
    "the time needed for step ( ii ) is , clearly , @xmath329 .",
    "each execution of step ( iii ) takes also @xmath330 . finally , the running time of each execution of step ( iv ) is @xmath331 , where @xmath332 is the size of the connected component of the graph @xmath199 containing @xmath319 .",
    "thus , an iteration of the loop 3 for a cycle @xmath316 takes @xmath333 . clearly , @xmath334 .",
    "moreover , @xmath335 and @xmath336 ( they are all disjoint subsets of @xmath192 ) .",
    "thus , the total time needed for the loop 3 is @xmath337 .",
    "it is easy to see that the time needed for the loop 4 is also @xmath337 .",
    "consequently , the running time of the procedure @xmath216 is @xmath337 .",
    "we are now in a position to estimate the running time of the procedure @xmath171 .",
    "[ l1 ] if the procedure @xmath230 returns a nonempty set @xmath197 , then the running time of @xmath171 is @xmath338 .",
    "if @xmath230 returns the empty set then its running time is @xmath339 .",
    "proof : let @xmath340 and @xmath341 .",
    "as we have already observed the procedure @xmath216 runs in time @xmath342 .",
    "it is not hard to see that , since we represent all sets occurring in the procedure @xmath171 as linked lists , with each node on a list pointing to the head of the list , the operations : @xmath343 and @xmath226 require a constant time .",
    "first assume that the output @xmath197 of the procedure @xmath171 is nonempty .",
    "let us estimate the number of passes of the * while * and * for * loops in the procedure .",
    "clearly , the loop 6 - 23 is executed @xmath344 times .",
    "hence the total running time of all calls of the procedure @xmath216 is @xmath345 .",
    "the number of passes of the loop 9 - 22 is not larger than @xmath346 , where @xmath347 denotes the list @xmath215 in an iteration @xmath62 of the loop . since @xmath347 is a list of disjoint pf - sets of cardinality @xmath62 , @xmath348 , for each @xmath349 .",
    "hence the number of passes of the loop 9 - 22 can be very roughly estimated by @xmath350 .",
    "the loop 12 - 20 is executed at most @xmath351 times .",
    "this inequality follows from the fact that the sets @xmath197 in the lists @xmath347 are disjoint subsets of atoms so @xmath352 .",
    "the estimation of the number of passes of the loop 14 - 18 is a little bit more complicated .",
    "first notice that in each execution of the loop we check a rule of the program @xmath29 and rules are checked only one time .",
    "the rules @xmath185 checked in the loop have either both the head and the tail in some pf - set @xmath232 or @xmath210 and @xmath184 is in some other pf - set @xmath353 . in the latter case @xmath206 is defined in line 16 .",
    "the number of executions of line 16 is not larger than the number of passes of the loop 9 - 22 so it is bounded by @xmath350 .",
    "when the procedure returns the output , the pf - sets have cardinalities not larger than @xmath344 .",
    "hence the number of rules with both the head and the tail in the same pf - set that has been checked before the procedure stops is not larger than @xmath354    thus the number of passes of the loop 14 - 18 in the whole procedure @xmath171 is less than @xmath355 .",
    "it follows that if the output @xmath197 of @xmath171 is nonempty then the running time of @xmath171 is @xmath338 .",
    "now consider the case when the procedure @xmath171 returns the empty set .",
    "clearly the number of passes of the loop 6 - 23 is @xmath356 so it takes @xmath357 time for all executions of the procedure @xmath216 . since the rules are checked in the loop 14 - 18 only one time , the number of passes of this loop is not larger than the number @xmath165 of rules in @xmath29 .",
    "obviously @xmath358 so the running time of @xmath171 in this case is @xmath339 .",
    "@xmath107    by lemma [ l1 ] and considerations in section 3 we get an estimation of the running time of algorithm 3 .",
    "[ t2 ] if @xmath2 is a program whose rules have at most one positive atom in the body then algorithm 3 can be implemented so that its running time is @xmath359 . @xmath107",
    "the method for computing the well - founded semantics described in this paper is a refinement of the basic alternating - fixpoint algorithm .",
    "the key idea is to use a top - down search when identifying atoms that are false .",
    "our method is designed to work with programs whose rules have at most one positive atom in their bodies ( class @xmath360 ) .",
    "its running time is @xmath14 ( where @xmath2 is an input program ) .",
    "thus , our algorithm is an improvement over other known methods to compute the well - founded semantics for programs in the class @xmath13 .",
    "our algorithm runs in linear time for the class of programs @xmath361 for which @xmath362 .",
    "however , it is not a linear - time algorithm in general .",
    "it is an open question whether a linear - time algorithm for computing the well - founded semantics for programs in the class @xmath13 exists .",
    "our results extend to the class @xmath16",
    ". however , the extension is straightforward and the class @xmath16 is still rather narrow .",
    "moreover , it is not specified syntactically ( it is described by means of the kripke - kleene semantics ) .",
    "the question arises whether our top - down approach to positive - loop detection can be generalized to any class of programs significantly extending the class @xmath13 and possessing a simple syntactic description .    finally , let us note that the general problem of computing the well - founded semantics still remains a challenge .",
    "no significant improvement over the alternating - fixpoint algorithm of van gelder has been obtained for the class of arbitrary finite propositional logic programs .",
    "this research was supported by the nsf grants cda-9502645 and iri-9619233 .",
    "rao , p. , ramskrishnan , i.v .",
    ", sagonas , k. , swift , t. , warren , d.  s. , & freire , j. ( 1997 ) . : a system for efficiently computing well - founded semantics . .",
    "springer - verlag .",
    "ecture notes in computer science , 1265 ."
  ],
  "abstract_text": [
    "<S> the well - founded semantics is one of the most widely studied and used semantics of logic programs with negation . in the case of finite propositional programs , it can be computed in polynomial time , more specifically , in @xmath0 steps , where @xmath1 denotes the total number of occurrences of atoms in a logic program @xmath2 . </S>",
    "<S> this bound is achieved by an algorithm introduced by van gelder and known as the alternating - fixpoint algorithm . </S>",
    "<S> improving on the alternating - fixpoint algorithm turned out to be difficult . in this paper </S>",
    "<S> we study extensions and modifications of the alternating - fixpoint approach . </S>",
    "<S> we then restrict our attention to the class of programs whose rules have no more than one positive occurrence of an atom in their bodies . for programs in that class </S>",
    "<S> we propose a new implementation of the alternating - fixpoint method in which false atoms are computed in a top - down fashion . </S>",
    "<S> we show that our algorithm is faster than other known algorithms and that for a wide class of programs it is linear and so , asymptotically optimal .    </S>",
    "<S> [ firstpage ] </S>"
  ]
}