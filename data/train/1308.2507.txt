{
  "article_text": [
    "the architecture of concurrent software usually exhibits some forms of modularity . for example , concurrent algorithms are encapsulated in libraries and complex algorithms are often constructed using libraries of simpler ones .",
    "this lets developers benefit from ready - made libraries of concurrency patterns and high - performance concurrent data structures , such as @xmath0 for java and threading building blocks for c++ . to simplify reasoning about concurrent software",
    ", we need to exploit the available modularity .",
    "in particular , in reasoning about a client of a concurrent library , we would like to abstract from the details of a particular library implementation .",
    "this requires an appropriate notion of library correctness .",
    "correctness of concurrent libraries is commonly formalised by _ linearizability _",
    "@xcite , which fixes a certain correspondence between the library and its specification .",
    "the latter is usually just another library , but implemented atomically using an abstract data type ; the two libraries are called _ concrete _ and _ abstract _ , respectively . a good notion of linearizability",
    "should validate an _ abstraction theorem _",
    "@xcite : the behaviours of any client using the concrete library are contained in the behaviours of the client using the abstract one .",
    "this makes it sound to replace a library by its specification in reasoning about its client .",
    "classical linearizability assumes a complete isolation between a library and its client , with interactions limited to passing values of a given data type as parameters or return values of library methods .",
    "this notion is not appropriate for low - level heap - manipulating languages , such as c / c++ .",
    "there the library and the client run in a shared address space ; thus , to prove the whole program correct , we need to verify that one of them does not corrupt the data structures used by the other .",
    "type systems  @xcite and program logics  @xcite usually establish this using the concept of _ ownership _ of data structures by a program component : the right to access a data structure is given only to a particular component or a set of them .",
    "when verifying realistic programs , this ownership of data structures can not be assigned statically ; rather , it should be _ transferred _ between the client and the library at calls to and returns from the latter .",
    "the times when ownership is transferred are not determined operationally , but set by the proof method : as ohearn famously put it , `` ownership is in the eye of the asserter ''  @xcite . however , ownership transfer reflects actual interactions between program components via the heap , e.g. , alternating accesses to a shared area of memory .",
    "such interactions also exist in high - level languages providing basic memory protection , such as java . in this case",
    ", we need to ensure that a client does not subvert a library by accessing a memory object after its ownership was transferred to the latter .    for an example of ownership transfer between concurrent libraries and their clients consider a memory allocator accessible concurrently to multiple threads .",
    "we can think of the allocator as owning the blocks of memory on its free - list ; in particular , it can store free - list pointers in them .",
    "having allocated a block , a thread gets its exclusive ownership , which allows accessing it without interference from the other threads .",
    "when the thread frees the block , its ownership is returned to the allocator .",
    "trying to write to a memory cell after it was freed has dire consequences .    as another example , consider any container with concurrent access , such as a concurrent set from @xmath0 or threading building blocks .",
    "a typical use of such a container is to store pointers to a certain type of data structures .",
    "however , when verifying a client of the container , we usually think of the latter as holding the ownership of the data structures whose addresses it stores  @xcite .",
    "thus , when a thread inserts a pointer to a data structure into a container , its ownership is transferred from the thread to the container .",
    "when another thread removes a pointer from the container , it acquires the ownership of the data structure the pointer identifies .",
    "if the first thread tries to access a data structure after a pointer to it has been inserted into the container , this may result in a race condition .",
    "unlike a memory allocator , the container code usually does not access the contents of the data structures its elements identify , but merely ferries their ownership between different threads .",
    "for this reason , correctness proofs for such containers  @xcite have so far established their classical linearizability , without taking ownership transfer into account .",
    "we would like to use the notion of linearizability and , in particular , an abstraction theorem to reason about the above libraries and their clients in isolation , taking into account only the memory that they own . to this end , we would like the correctness of a library to constrain not only pointers that are passed between it and the client , but also the contents of the data structures whose ownership is transferred .",
    "so far , there has been no notion of linearizability that would allow this .",
    "in the case of concurrent containers , we have no way of using classical linearizability established for them to validate an abstraction theorem that would be applicable to clients performing ownership transfer .",
    "this paper fills in these gaps .",
    "* contributions . * in this paper , we generalise linearizability to a setting where a library and its client execute in a shared address space , and boundaries between their data structures can change via ownership transfers .",
    "linearizability is usually defined in terms of _ histories _ , which are sequences of calls to and returns from a library in a given program execution , recording parameters and return values passed . to handle ownership transfer",
    ", histories also have to include descriptions of memory areas transferred .",
    "however , in this case , some histories can not be generated by any pair of a client and a library : while generating histories of a library we should only consider its executions in an environment that respects ownership .",
    "for example , a client that transfers an area of memory upon a call to a library not communicating with anyone else can not then transfer the same area again before getting it back from the library upon a method return .",
    "we propose a notion of _ balancedness _ that characterises those histories that treat ownership transfer correctly .",
    "we then define a _",
    "linearizability relation _ between balanced histories , matching histories of a concrete and an abstract library ( section  [ sec : observ ] ) .",
    "this definition does not rely on a particular model of program states for describing memory areas transferred in histories , but assumes an arbitrary model defined by a _ separation algebra _  @xcite . by picking a model with so - called _ permissions _",
    "@xcite , we can allow clients and libraries to transfer non - exclusive rights to access certain memory areas in particular ways , instead of transferring their full ownership .",
    "this makes our results applicable even when libraries and their clients share access to some areas of memory .",
    "our definition of balancedness for arbitrary separation algebras relies on a new formalisation of the notion of a _ footprint _ of a state , describing the amount of permissions the state includes ( section  [ sec : prelim ] ) .",
    "the rest of our technical development relies on a novel compositional semantics for a language with libraries that defines the denotation of a library or a client considered separately in an environment that communicates with the component correctly via ownership transfers ( sections  [ sec : prog ] and  [ sec : semantics ] ) .",
    "in particular , the semantics allows us to generate the set of all histories that can be produced by a library solely from its code , without considering all its possible clients .",
    "this , in its turn , allows us to lift the linearizability on histories to libraries and establish the abstraction theorem ( section  [ sec : refinement ] ) . on the way",
    ", we also obtain an insight into the original definition of linearizability without ownership transfer , showing a surprising relationship between one of the ways of its formulation and the plain subset inclusion on the sets of histories produced by concrete and abstract libraries .",
    "we note that the need to consider ownership transfer makes the proof of the abstraction theorem highly non - trivial .",
    "this is because proving the theorem requires us to convert a computation with a history produced by the concrete library into a computation with a history produced by the abstract one , which requires moving calls and returns to different points in the computation . in the setting without ownership transfer ,",
    "these actions are thread - local and can be moved easily ; however , once they involve ownership transfer , they become global and the justification of their moves becomes subtle , in particular , relying on the fact that the histories involved are balanced ( section  [ sec : rearr - proof ] ) .    to avoid having to prove the new notion of linearizability from scratch for libraries that do not access some of the data structures transferred to them , such as concurrent containers",
    ", we propose a _ frame rule for linearizability _",
    "( section  [ sec : frame ] ) .",
    "it ensures the linearizability of such libraries with respect to a specification with ownership transfer given their linearizability with respect to a specification without one .",
    "we provide a glossary of notation at the end of the paper .",
    "our results hold for a class of models of program states called _ separation algebras _  @xcite , which allow expressing the dynamic memory partitioning between libraries and clients .",
    "a * _ separation algebra _ * is a set @xmath1 , together with a partial commutative , associative and cancellative operation @xmath2 on @xmath1 and a unit element @xmath3 . here",
    "commutativity and associativity hold for the equality that means both sides are defined and equal , or both are undefined .",
    "the property of cancellativity says that for each @xmath4 , the function @xmath5 is injective .",
    "we think of elements of a separation algebra @xmath1 as _ portions _ of program states and the @xmath2 operation as combining such portions .",
    "the partial states allow us to describe parts of the program state belonging to a library or the client .",
    "when the @xmath2-combination of two states is defined , we call them * _ compatible_*. incompatible states usually make contradictory claims about the ownership of memory .",
    "we sometimes use a pointwise lifting @xmath6 of @xmath2 to sets of states : for @xmath7 we let @xmath8 .",
    "elements of separation algebras are often defined using partial functions .",
    "we use the following notation : @xmath9 means that the function @xmath10 is defined on @xmath11 , @xmath12 means that it is undefined on @xmath11 , @xmath13 denotes the set of arguments on which @xmath10 is defined , @xmath14 $ ] denotes a nowhere - defined function , and @xmath15 $ ] denotes the function that has the same value as @xmath10 everywhere , except for @xmath11 , where it has the value @xmath16 .",
    "we also write @xmath17 for an expression whose value is irrelevant and implicitly existentially quantified .",
    "below is an example separation algebra @xmath18 : @xmath19 a ( partial ) state in this model consists of a finite partial function from allocated memory locations to the values they store .",
    "the @xmath2 operation on @xmath18 is defined as the disjoint function union @xmath20 , with the nowhere - defined function @xmath14 $ ] as its unit .",
    "thus , @xmath2 combines disjoint pieces of memory .",
    "more complicated separation algebras do not split memory completely , instead allowing heap parts combined by @xmath2 to overlap .",
    "this is done by associating so - called _ permissions _",
    "@xcite with memory cells in the model , which do not give their exclusive ownership , but allow accessing them in a certain way .",
    "types of permissions range from read sharing  @xcite to accessing memory in an arbitrary way consistent with a given specification  @xcite .",
    "we now give an example of a separation algebra with permissions of the former kind .",
    "we define the algebra @xmath21 as follows : @xmath22 ; \\qquad { { \\sf ram}}_\\pi = { { \\sf loc}}\\rightharpoonup_{\\it fin } ( { { \\sf val}}\\times { { \\sf perm}}).\\ ] ] a state in this model consists of a finite partial function from allocated memory locations to values they store and so - called _",
    "permissions_numbers from @xmath23 $ ] that show `` how much '' of the memory cell belongs to the partial state  @xcite .",
    "the latter allow a library and its client to share access to some of memory cells .",
    "permissions in @xmath21 allow only read sharing : when defining the semantics of commands over states in @xmath21 , the permissions strictly less than @xmath24 are interpreted as permissions to read ; the full permission @xmath24 additionally allows writing .",
    "the @xmath2 operation on @xmath21 adds up permissions for memory cells .",
    "formally , for @xmath25 , we write @xmath26 if : @xmath27 if @xmath26 , then we define @xmath28 otherwise , @xmath29 is undefined . the unit for @xmath2 is the empty heap  @xmath14 $ ] .",
    "this definition of @xmath2 allows us , e.g. , to split a memory area into two disjoint parts .",
    "it also allows splitting a cell with a full permission @xmath24 into two parts , carrying read - only permissions @xmath30 and agreeing on the value stored in the cell .",
    "these permissions can later be recombined to obtain the full permission , which allows both reading from and writing to the cell .",
    "since we develop all our results for an arbitrary separation algebra , by instantiating it with algebras similar to @xmath21 , we can handle cases when a library and its client share access to some memory areas .",
    "consider an arbitrary separation algebra @xmath1 with an operation @xmath2 .",
    "we define a partial operation @xmath31 , called * _ state subtraction _ * , as follows : @xmath32 is a state in @xmath1 such that @xmath33 ; if such a state does not exist , @xmath32 is undefined .",
    "the cancellativity of @xmath2 implies that @xmath32 is determined uniquely , and hence , the @xmath34 operation is well - defined .",
    "when reasoning about ownership transfer between a library and a client , we use the @xmath2 operation to express a state change for the component that is receiving the ownership of memory , and the @xmath34 operation for the one that is giving it up .",
    "[ prop - diff ] for all @xmath35 , if @xmath29 and @xmath36 are defined , then @xmath37      our definition of linearizability uses a novel formalisation of a _ footprint _ of a state , which , informally , describes the amount of memory or permissions the state includes .",
    "[ defn - foot ] a * _ footprint _ * of a state @xmath38 in a separation algebra @xmath1 is the set of states @xmath39    in the following , @xmath40 ranges over footprints .",
    "the function @xmath41 computes the equivalence class of states with the same footprint as @xmath38 . in the case of @xmath18",
    ", we have @xmath42 for every @xmath43 .",
    "thus , states with the same footprint contain the same memory cells .",
    "definitions of @xmath41 for separation algebras with permissions are more complicated , taking into account not only memory cells present in the state , but also permissions for them . in the case of the algebra @xmath21 , for @xmath44 we have @xmath45 in other words , states with the same footprint contain the same memory cells with the identical permissions ; in the case of memory cells on read permissions , the states also have to agree on their values .",
    "let @xmath46 be the set of footprints in a separation algebra @xmath1 .",
    "we now lift the @xmath2 and @xmath34 operations on @xmath1 to @xmath47 .",
    "first , we define the operation @xmath48 for adding footprints .",
    "consider @xmath49 and @xmath50 such that @xmath51 and @xmath52 .",
    "if @xmath53 is defined , we let @xmath54 ; otherwise @xmath55 is undefined .",
    "the @xmath56 operation is well - defined .",
    "consider @xmath49 and @xmath57 such that @xmath51 and @xmath52 .",
    "take another pair of states @xmath58 such that @xmath59 and @xmath60 .",
    "thus , @xmath61 and @xmath62 , which implies : @xmath63 furthermore , if @xmath64 and @xmath53 are defined , then for all @xmath65 , @xmath66 hence , @xmath67 , so that @xmath56 is well - defined .    for @xmath18",
    ", @xmath56 is just the pointwise lifting of the disjoint function union @xmath68 .    to define a subtraction operation on footprints , we use the following condition .    [ foot - canc ]",
    "the @xmath2 operation of a separation algebra @xmath1 is * _ cancellative on footprints _ * when for all @xmath69 , if @xmath53 and @xmath64 are defined , then @xmath70    for example , the @xmath2 operations on @xmath18 and @xmath21 satisfy this condition .",
    "when the @xmath2 operation of an algebra @xmath1 is cancellative on footprints , we can define an operation @xmath71 of * _ footprint subtraction _ * as follows .",
    "consider @xmath72 .",
    "if for some @xmath73 , we have @xmath51 , @xmath52 and @xmath74 , then we let @xmath75 .",
    "when such @xmath76 do not exist , @xmath77 is undefined .",
    "the @xmath78 operation is well - defined .",
    "consider @xmath79 and @xmath80 such that @xmath81 , @xmath82 , @xmath83 and @xmath84 .",
    "we have : @xmath85 since @xmath86 , by definition  [ foot - canc ] this implies @xmath87 , so that @xmath78 is well - defined .    for @xmath18 ,",
    "the @xmath78 operation is defined as follows . for @xmath88 , take any @xmath89 such that @xmath90 and @xmath91 .",
    "then @xmath92 , if @xmath93 ; otherwise , @xmath94 is undefined .",
    "we say that a footprint @xmath95 is * _ smaller _ * than @xmath96 , written @xmath97 , when @xmath77 is defined .",
    "the @xmath56 and @xmath78 operations on footprints satisfy an analogue of proposition  [ prop - diff ] .",
    "[ prop - delta ] for all @xmath98 , if @xmath99 and @xmath100 are defined , then @xmath101    in the rest of the paper , we fix a separation algebra @xmath1 with the @xmath2 operation cancellative on footprints .",
    "in the following , we consider descriptions of computations of a library providing several methods to a multithreaded client .",
    "we fix a set @xmath102 of thread identifiers and a set @xmath103 of method names . as we explained in section",
    "[ sec : intro ] , a good definition of linearizability has to allow replacing a concrete library implementation with its abstract version while keeping client behaviours reproducible . for this",
    ", it should require that the two libraries have similar client - observable behaviours .",
    "such behaviours are recorded using _ histories _ , which we now define in our setting .",
    "[ def : intact ] an * _ interface action _ * @xmath104 is an expression of the form @xmath105 or @xmath106 , where @xmath107 , @xmath108 and @xmath109 .",
    "we denote the sets of all call and return actions by @xmath110 and @xmath111 , and the set of all interface actions by @xmath112 .",
    "an interface action records a call to or a return from a library method @xmath113 by thread @xmath114 .",
    "the component @xmath38 in @xmath105 specifies the part of the state transferred upon the call from the client to the library ; @xmath38 in @xmath115 is transferred in the other direction .",
    "for example , in the algebra @xmath18 , the annotation @xmath116 $ ] implies the transfer of the cell at the address @xmath117 storing @xmath118 . in the algebra @xmath21 ,",
    "@xmath119 $ ] implies the transfer of a read permission for this cell .    a * _ history _ * @xmath120 is a finite sequence of interface actions such that for every thread @xmath114 , its projection @xmath121 to actions by @xmath114 is a sequence of alternating call and return actions over matching methods that starts from a call action .    in the following ,",
    "we use the standard notation for sequences : @xmath122 is the empty sequence , @xmath123 is the @xmath124-th element of a sequence @xmath125 , @xmath126 is the prefix of @xmath125 of length @xmath127 , and @xmath128 is the length of @xmath125 .",
    "not all histories make intuitive sense with respect to the ownership transfer reading of interface actions . for example , let @xmath129 and consider the history in figure  [ fig : hist](a ) .",
    "the history is meant to describe _ all _ the interactions between the library and the client . according to the history",
    ", the cell at the address @xmath130 was first owned by the client , and then transferred to the library by thread @xmath24 . however , before this state was transferred back to the client , it was again transferred from the client to the library , this time by thread @xmath131 .",
    "this is not consistent with the intuition of ownership transfer , as executing the second action requires the cell to be owned both by the library and by the client , which is impossible in @xmath18 .    as we show in this paper ,",
    "histories that do not respect the notion of ownership , such as the one above , can not be generated by any program , and should not be taken into account when defining linearizability .",
    "we now use the notion of footprints of states from section  [ sec : prelim ] to characterise formally the set of histories that respect ownership .",
    "a finite history @xmath120 induces a partial function @xmath132 , which tracks how a computation with the history @xmath120 changes the footprint of the library state : @xmath133{@{}r@{\\ } c@{\\ } l@{\\ \\ } l@ { } } { \\llbracket \\varepsilon \\rrbracket^\\sharp}l   & = &   l ; \\\\[2pt ] { \\llbracket h \\psi \\rrbracket^\\sharp}l & = &   { \\llbracket h \\rrbracket^\\sharp}l \\circ \\delta(\\sigma ) , & \\mbox{if } \\psi = ( \\ _ , { { \\sf call}}\\ \\_(\\sigma ) ) \\wedge { ( { \\llbracket h \\rrbracket^\\sharp}l \\circ \\delta(\\sigma)){\\mathpunct{\\downarrow } } } ; \\\\[2pt ] { \\llbracket h \\psi \\rrbracket^\\sharp}l & = &   { \\llbracket h \\rrbracket^\\sharp}l { \\mathop{{\\backslash}\\!\\!{\\backslash}}}\\delta(\\sigma ) , & \\mbox{if } \\psi = ( \\ _ , { { \\sf ret}}\\ \\_(\\sigma ) ) \\wedge { ( { \\llbracket h \\rrbracket^\\sharp}l{\\mathop{{\\backslash}\\!\\!{\\backslash}}}\\delta(\\sigma)){\\mathpunct{\\downarrow } } } ; \\\\[2pt ] { \\llbracket h \\psi \\rrbracket^\\sharp}l   & = &   \\mbox{undefined } , & \\mbox{otherwise}. \\end{array}\\ ] ] using this function , we characterise histories respecting the notion of ownership as follows .    [",
    "defn : balance ] a history @xmath120 is * _ balanced _ * from @xmath134 if @xmath135 is defined .",
    "we call subsets of @xmath136 * _ interface sets_*.    an interface set can be used to describe all the behaviours of a library relevant to its clients . in the following ,",
    "@xmath137 ranges over interface sets .    to keep client behaviours reproducible when replacing a concrete library by an abstract one",
    ", we do not need to require the latter to reproduce the histories of the former exactly : the histories generated by the two libraries can be different in ways that are irrelevant for their clients .",
    "we now introduce a _ linearizability relation _ that matches a history of a concrete library with that of the abstract one that yields the same client - observable behaviour .",
    "[ lin ] the * _ linearization relation _ * @xmath138 on histories is defined as follows : @xmath139 holds if there exists a bijection @xmath140 such that @xmath141 & ( h(i ) = ( \\ _ , { { \\sf ret}}\\ \\ _ ) \\wedge h(j ) = ( \\_,{{\\sf call}}\\ \\ _ ) ) ) ) { \\implies } \\rho(i ) < \\rho(j ) ) .",
    "\\end{array}\\ ] ]    we lift @xmath138 to @xmath142 as follows : @xmath143 holds if @xmath144 and @xmath139 .    finally , we lift @xmath138 to interface sets as follows : @xmath145 holds if @xmath146    thus , a history @xmath120 is linearized by a history @xmath147 when the latter is a permutation of the former preserving the order of actions within threads and non - overlapping method invocations .",
    "the duration of a method invocation is defined by the interval from the method call action to the corresponding return action ( or to the end of the history if there is none ) .",
    "an interface set @xmath148 is linearized by an interface set @xmath149 , if every history in @xmath148 may be reproduced in a linearized form by @xmath149 without requiring more memory .",
    "we now discuss the definition in more detail .",
    "definition  [ lin ] treats parts of memory whose ownership is passed between the library and the client in the same way as parameters and return values in the classical definition  @xcite : they are required to be the same in the two histories .",
    "in fact , the setting of the classical definition can be modelled in ours if we pass parameters and return values via the heap .",
    "let @xmath129 and let us fix distinct locations @xmath150 for @xmath151 meant for the transfer of parameters and return values",
    ". then histories of the classical definition are represented in our setting by histories where all actions are of the form @xmath152 ) ) \\mbox { or } ( t,{{\\sf ret}}\\ m([{{\\sf arg}}_t : { \\it    retval } ] ) ) , \\mbox { where } { \\it param } , { \\it retval } \\in { { \\sf val}}.\\ ] ] the novelty of our definition lies in restricting the histories considered to balanced ones , which are the only ones that can be produced by programs ( we formalise this fact in section  [ sec : semantics ] ) .",
    "the notion of balancedness also plays a key role in proving the abstraction theorem in the presence of ownership transfer ( section  [ sec : rearr ] ) .",
    "the fact that the linearizability relation allows us to permute actions by different threads lets us arrange method invocations into a linear sequence .",
    "for example the history in figure  [ fig : hist](b ) is linearized by that in figure  [ fig : hist](c ) .",
    "the former might correspond to a concurrent stack implementation , where threads @xmath24 and @xmath131 pass parameters and return values via locations @xmath24 and @xmath131 , respectively .",
    "histories such as the one in figure  [ fig : hist](c ) , where a call to every method is immediately followed by the corresponding return , are called * _ sequential_*. sequential histories correspond to abstract libraries with every method implemented atomically .",
    "when the histories in figures  [ fig : hist](b ) and  [ fig : hist](c ) are members of interface sets defining the behaviour of concurrent and atomic stack implementations , the linearizability relationship between them allows us to justify that the call to pop by thread @xmath24 in figure  [ fig : hist](b ) can return @xmath153 , since this behaviour can be witnessed by the valid history of the atomic implementation in figure  [ fig : hist](c ) .",
    "( in fact , the pop would also be allowed to return @xmath154 , since the resulting history would be linearized by a sequential history with the push of @xmath154 preceding the pop . )    the requirement that the order of non - overlapping method invocations be preserved is inherited from the classical notion of linearizability  @xcite . as shown by filipovi et al .",
    "@xcite , this requirement is essential to validate an abstraction theorem for clients that can communicate via shared client - side variables .",
    "for example , since in figure  [ fig : hist](b ) the push of @xmath155 returns before the push of @xmath154 is called , the order between these method invocations has to stay the same in any linearizing history , such as the one in figure  [ fig : hist](c ) .    following filipovi et al .",
    "@xcite , we do not require the abstract history @xmath147 to be sequential , like in the classical definition of linearizablity .",
    "this allows our definition to compare behaviours of two concurrent library implementations .",
    "we also allow a concrete history to contain calls without matching returns , arising , e.g. , because the corresponding method invocation did not terminate . in this case",
    ", we require the same behaviour to be reproduced in the abstract history  @xcite , which is possible because the latter does not have to be sequential .",
    "for example , the history in figure  [ fig : hist](d ) is linearized by that in figure  [ fig : hist](e ) .",
    "this yields a simpler treatment of non - terminating calls than the use of completions in the classical definition of linearizability  @xcite .",
    "definition  [ lin ] requires that the initial footprint of an abstract history @xmath147 be smaller than that of the concrete history @xmath120 .",
    "this requirement is standard in data refinement  @xcite : it ensures that , when we replace a concrete library by an abstract one in a program , the library - owned memory stays disjoint from the client - owned one .",
    "it does not pose problems in practice , as the abstract library generating @xmath147 usually represents some of the data structures of the concrete library abstractly and , hence , more concisely .",
    "so far we have defined the notion of linearizability on interface sets without taking into account library implementations that generate them . in the rest of the paper , we develop this notion for libraries written in a particular programming language and prove an abstraction theorem , which guarantees that a library can be replaced by another library linearizing it when we reason about its client program .",
    "we consider a simple concurrent programming language : @xmath156 { \\mathcal{l } } & : : = &   \\{m = c;\\ \\ldots;\\ m = c \\ } \\\\[2pt ] { \\mathcal{s } } & : : = &     { \\sf let}\\ { \\mathcal{l}}\\ { \\sf in}\\ c \\parallel \\ldots \\parallel c    \\end{array}\\ ] ] a program consists of a single * _ library _ * @xmath157 implementing methods @xmath108 and its * _ client _ * @xmath158 , given by a parallel composition of threads . the language is parameterised by a set of * _ primitive commands _ * @xmath159 , meant to execute atomically . commands also include method calls @xmath108 , sequential composition @xmath160 , nondeterministic choice @xmath161 and finite iteration @xmath162 .",
    "we use @xmath163 and @xmath164 instead of conditionals and while loops for theoretical simplicity : as we show below , the latter can be defined in the language as syntactic sugar .",
    "methods do not take arguments and do not return values , as these can be passed via special locations on the heap associated with the identifier of the thread calling the method ( section  [ sec : observ ] ) .",
    "we disallow nested method calls .",
    "we also assume that every method called in the program is defined by the library , and thus call @xmath165 a * _ complete program_*. an * _ open program _ * is a library @xmath157 without a client , or a client @xmath166 without a library implementation : @xmath167\\ { \\sf in}\\ c\\parallel\\ldots\\parallel c \\\\[2pt ] { \\mathcal{p}}&::= & { \\mathcal{s}}\\mid { \\mathcal{c}}\\mid { \\mathcal{l}}\\end{array}\\ ] ] in @xmath166 , we allow the client to call methods that are not defined in the program ( but belong to the missing library ) .",
    "an open program represents a library or a client considered in isolation .",
    "the novelty of the kind of open programs we consider here is that we allow them to communicate with their environment via ownership transfers .",
    "we now define a way to specify a contract this communication follows .",
    "a * _ predicate _ * is a set of states from @xmath1 , and a * _ parameterised predicate _ * is a mapping from thread identifiers to predicates .",
    "we use the same symbols @xmath168 for ordinary and parameterised predicates ; it should always be clear from the context which one we mean .",
    "when @xmath169 is a parameterised predicate , we write @xmath170 for the predicate obtained by applying @xmath169 to a thread @xmath114 . both kinds of predicates can be described syntactically , e.g. , using separation logic assertions  @xcite .",
    "we define possible ownership transfers between components with the aid of * _ method specifications _ * @xmath171 , which are sets of hoare triples @xmath172 , at most one for each method . here",
    "@xmath169 and @xmath173 are parameterised predicates such that @xmath170 describes pieces of state transferred when thread @xmath114 calls the method @xmath113 , and @xmath174 , those transferred at its return .",
    "note that the intention of the pre- and postconditions in method specifications is only to identify the areas of memory transferred ; in other words , they describe the `` type '' of the returned data structure , but not its `` value '' . as usual for concurrent algorithms , a complete specification of a library is given by its abstract implementation ( section  [ sec : refinement ] ) .    for example , as we discussed in section  [ sec : intro ] , when programmers store pointers in a concurrent container , they often intend to transfer the ownership of the data structures these pointers identify at calls to and returns from the container s methods . in figure  [ fig : impl](a ) we give an example of such a container  a bounded stack represented by an array . for readability , we write examples in c instead of the minimalistic language introduced above .",
    "the library protects the array by a lock ; more complicated algorithms allow a higher degree of concurrency  @xcite .",
    "take @xmath129 and for @xmath175 let @xmath176 denote the set of states representing all well - formed data structures of a certain type allocated at the address @xmath11 .",
    "for example , for objects with a single integer field we have @xmath177 \\mid y \\in { { \\sf val}}\\}$ ] .",
    "then the specification of the stack when it stores pointers to such data structures can be given as follows : [ container ]    l \\{x .",
    "arg_t x * obj(x ) }  push  \\{arg_t ( arg_t * obj(x ) ) } ; + \\{arg_t _ }  pop   \\{x .",
    "arg_t x * ( ( x = empty emp ) ( x = empty ( x)))}.    here we use the separation logic syntax to describe predicates parameterised by the thread identifier @xmath114 .",
    "thus , @xmath178 denotes the empty heap @xmath14 $ ] , @xmath179 the heap @xmath180 $ ] , and @xmath2 the combination of heaps with disjoint domains . in the following we also use the assertion @xmath181 for @xmath182 , denoting all the heaps with the domain @xmath183 .",
    "we use distinguished locations @xmath184 , @xmath185 to pass parameters and return values . according to the specification",
    ", the stack gets the ownership of an object when a pointer to it is pushed , and gives it up when the pointer is popped .",
    "@l@|@l@    void * stack[size ] ; int count = 0 ; // count of // elements stored lock array_lock ; // protects // the array and the count    int push(void * arg ) lock(array_lock ) ; if ( count = = size ) unlock(array_lock ) ; return full ; stack[count++ ] = arg ; unlock(array_lock ) ; return ok ;    void * pop ( ) lock(array_lock ) ; if ( count = = 0 ) unlock(array_lock ) ; return empty ; void * obj = stack[count ] ; unlock(array_lock ) ; return obj ;    &    struct node node * prev , * next ; ; node * free_list ; // a cyclic doubly- // linked list with a sentinel node lock * list_lock ; // protects the list    void free(void * arg ) node * block = ( node*)arg ; lock(list_lock ) ; block->prev = free_list ; block->next = free_list->next ; free_list->next->prev = block ; free_list->next = block ; unlock(list_lock ) ;    void * alloc ( ) lock(list_lock ) ; if ( free_list->next = = free_list ) unlock(list_lock ) ; return null ; node * block = free_list->next ; free_list->next = block->next ; block->next->prev = free_list ; unlock(list_lock ) ; return block ;     +   + ( a ) & ( b )    now take @xmath186 and let @xmath187 we specify an allocator managing blocks of _ size _ memory cells as follows : [ alloc ]    l \\{x .",
    "arg_t x * ( x .. (x+_size_-1 ) _ ) }   free   \\{arg_t _ } ; + \\{arg_t _ }  alloc   \\{x .",
    "arg_t x * ( ( x = 0 emp ) ( x = 0 ( x .. (x+_size_-1 ) _ ) ) ) } .",
    "the specification corresponds to the ownership transfer reading of allocator calls explained in section  [ sec : intro ] . in figure",
    "[ fig : impl](b ) we give an example allocator corresponding to the specification ( we have omitted initialisation code from the figure ) .",
    "note that , unlike the stack , the allocator does access the blocks of memory transferred to it by the client , since it stores free - list pointers inside them .    to define the semantics of ownership transfers unambiguously ( section  [ sec : semantics ] ) , we require pre- and postconditions in method specifications to be _ precise _  @xcite .    a predicate @xmath188 is * _ precise _ * if for every state @xmath38 there exists at most one substate @xmath189 satisfying @xmath190 , i.e. , such that @xmath191 and @xmath192 for some @xmath193 .    since the @xmath2 operation is cancellative , when such a substate @xmath189 exists , the corresponding substate @xmath193 is unique and is denoted by @xmath194 .",
    "a parameterised predicate @xmath190 is precise if so is @xmath195 for every @xmath114 .    informally , a precise predicate carves out a unique piece of the heap .",
    "for example , assuming the algebra @xmath18 , the predicate @xmath196\\}$ ] and those used in the allocator specification are precise .",
    "however , the predicate @xmath197 , [ \\,]\\}$ ] is not : when @xmath116 $ ] we can take either @xmath198 $ ] and @xmath199 $ ] , or @xmath200 $ ] and @xmath201 $ ] .",
    "a * _ specified open program _ * is of the form @xmath202 or @xmath203 . in the former",
    ", the specification @xmath171 describes all the methods that @xmath166 may call . in the latter",
    ", @xmath171 provides specifications for the methods in the open program that can be called by its external environment . in both cases",
    ", @xmath171 specifies the type of another open program that can fill in the hole in @xmath166 or @xmath157 .",
    "when we are not sure which form a program has , we write @xmath204 . in this case , if @xmath205 does not have a client , then @xmath171 is empty ; if @xmath205 does not have a library , then @xmath206 is empty ; and if @xmath205 is complete , then both @xmath171 and @xmath206 are empty . for specified open programs @xmath207\\ { \\sf in}\\ c_1\\parallel\\ldots\\parallel c_n\\ ] ] and @xmath208 agreeing on the specification @xmath171 of library methods , we denote by @xmath209 the complete program @xmath210      we now discuss primitive commands in more detail .",
    "consider the set @xmath211 of subsets of @xmath1 with a special element @xmath212 used to denote an error state , resulting , e.g. , from dereferencing an invalid pointer .",
    "we extend the @xmath2 operation on @xmath213 to @xmath214 by letting @xmath215 for all @xmath216 .",
    "we assume an interpretation of every primitive command @xmath217 as a transformer @xmath218 , which maps pre - states to states obtained when thread @xmath219 executes @xmath220 from a pre - state .",
    "the fact that our transformers are parameterised by @xmath114 allows atomic accesses to areas of memory indexed by thread identifiers .",
    "this idealisation simplifies the setting in that it lets us do without special thread - local or method - local storage for passing method parameters and return values .",
    "some typical primitive commands are : @xmath221 = e ' , \\qquad { \\sf assume}(e),\\ ] ] where expressions @xmath222 are defined as follows : @xmath223   \\mid   e+e   \\mid { -}e   \\mid { ! e }   \\mid \\ldots\\ ] ] here @xmath224 refers to the identifier of the thread executing the command , @xmath225 $ ] returns the contents of the address @xmath222 in memory , and @xmath226 is the c - style negation of an expression @xmath222it returns @xmath24 when @xmath222 evaluates to @xmath118 , and @xmath118 otherwise .",
    "the @xmath227 command filters out all the input states where @xmath222 evaluates to @xmath118 .",
    "hence , after @xmath227 is executed , @xmath222 always has a non - zero value . using it ,",
    "the standard commands for conditionals and loops can be defined in our language as follows : @xmath228    for the above commands @xmath220 and @xmath107 , we define @xmath229 using the transition relation @xmath230 in figure  [ fig : transfer ] : @xmath231 in the figure , @xmath232 denotes the result of evaluating the expression @xmath222 in the state @xmath38 with the current thread identifier @xmath114 .",
    "when this evaluation dereferences illegal memory addresses , it results in the error value @xmath212 .",
    "we define @xmath233 similarly , but using the transition relation @xmath234 in figure  [ fig : transfer - permission1 ] .",
    "the transformers formalise the semantics of permissions explained in section  [ sec : prelim ] : permissions less than @xmath24 allow reading , and the full permission @xmath24 additionally allows writing . note that @xmath235 yields an empty set of post - states when its condition evaluates to zero , leading to the program getting stuck . thus , even though , when executing the if statement  ( [ if - assm ] ) , both branches of the non - deterministic choice will be explored , only the branch where the assume condition evaluates to true will proceed further .",
    "@xmath236 \\sigma , [ e ] = e ' & \\leadsto_t & \\sigma{[{\\llbracket e \\rrbracket}_{\\sigma , t } : { \\llbracket e ' \\rrbracket}_{\\sigma , t } ] } , & \\mbox{if}\\ { \\llbracket e \\rrbracket}_{\\sigma , t } \\in { { \\sf dom}}(\\sigma ) , { \\llbracket e ' \\rrbracket}_{\\sigma , t}\\in { { \\sf",
    "val}}\\\\[2pt ] \\sigma , { [ e ] } = e ' & \\leadsto_t &   \\top , & \\mbox{if}\\   { \\llbracket e \\rrbracket}_{\\sigma , t } \\not\\in { { \\sf dom}}(\\sigma ) \\mbox { or } { \\llbracket e ' \\rrbracket}_{\\sigma , t } = \\top \\\\[2pt ] \\sigma , { { \\sf assume}}(e ) & \\leadsto_t &   \\sigma , & \\mbox{if}\\ { \\llbracket e \\rrbracket}_{\\sigma , t } \\in { { \\sf val}}- \\{0\\ } \\\\[2pt ] \\sigma , { { \\sf assume}}(e ) & \\leadsto_t & \\top , & \\mbox{if}\\ { \\llbracket e \\rrbracket}_{\\sigma , t } = \\top \\end{array}\\ ] ]    @xmath237 \\sigma , { [ e ] } = e ' & \\leadsto_t & \\sigma{[{\\llbracket e \\rrbracket}_{\\sigma , t } : ( { \\llbracket e ' \\rrbracket}_{\\sigma , t},1 ) ] } , & \\mbox{if}\\ \\sigma({\\llbracket e \\rrbracket}_{\\sigma , t } )   = ( \\ _ , 1 ) , { \\llbracket e ' \\rrbracket}_{\\sigma , t } \\in { { \\sf val}}\\\\[2pt ] \\sigma , { [ e ] } = e ' & \\leadsto_t &   \\top , & \\mbox{if the above condition does not hold } \\\\[2pt ] \\sigma , { { \\sf assume}}(e ) & \\leadsto_t &   \\sigma , & \\mbox{if}\\ { \\llbracket e \\rrbracket}_{\\sigma , t } \\in { { \\sf val}}- \\{0\\ }   \\\\[2pt ] \\sigma , { { \\sf assume}}(e ) & \\leadsto_t & \\top , & \\mbox{if}\\ { \\llbracket e \\rrbracket}_{\\sigma , t } = \\top \\end{array}\\ ] ]    for our results to hold , we need to place some restrictions on the transformers @xmath238 for every primitive command @xmath217 and thread @xmath185 :    footprint preservation : :    @xmath239 .",
    "strong locality : :    @xmath240 .",
    "footprint preservation prohibits primitive commands from allocating or deallocating memory .",
    "this does not pose a problem , since in the context of linearizability , an allocator is just another library and should be treated as such .",
    "the strong locality of @xmath238 says that , if a command @xmath220 can be safely executed from a state @xmath189 , then when executed from a bigger state @xmath53 , it does not change the additional state @xmath193 and its effect depends only on the state @xmath189 and not on the additional state @xmath193 .",
    "the strong locality is a strengthening of the locality property in separation logic  @xcite : @xmath241 locality rules out commands that can check if a cell is allocated in the heap other than by trying to access it and faulting if it is not allocated . for example , let @xmath242 and consider the following transformer @xmath243 : @xmath244\\ } \\mbox { else } \\{\\sigma\\}.\\ ] ] the transformer @xmath245 defines the denotation of a ` command ' that writes @xmath118 to the cell at the address @xmath24 if it is allocated and acts as a no - op if it is not .",
    "this violates locality .",
    "indeed , take @xmath246 $ ] and @xmath247 $ ] . then @xmath248 )",
    "= \\{[1 : 0]\\}\\ ] ] and @xmath249 ) * \\{[1:1]\\}= \\{[\\,]\\ } * \\{[1:1]\\}=\\{[1:1]\\}.\\ ] ] hence , @xmath250 does not hold .    while locality prohibits the command from changing the additional state , it permits the effect of the command to depend on this state  @xcite .",
    "the strong locality forbids such dependencies . to see this , consider another ` command ' defined by the following transformer @xmath243 : @xmath251    @l@  l@ f^t ( )  =  & + & + & .",
    "@xmath251 the command does not access the cell at the address @xmath131 , since it does not fault if the cell is not allocated .",
    "however , when the cell is allocated , the effect of the command depends on its value .",
    "it is easy to check that @xmath245 is local .",
    "however , it is not strongly local , since for @xmath252 $ ] and @xmath253 $ ] , we have @xmath254 ) = \\{[1 : 0 , 2:0]\\}\\ ] ] and @xmath255 ) * \\{[2:0]\\ } = \\{[1:0 ] , [ 1:1]\\ } * \\{[2:0]\\ } = \\{[1:0 , 2:0 ] , [ 1:1 , 2:0]\\},\\ ] ] so that @xmath256 does not hold .",
    "the property of strong locality subsumes the one of contents independence used in situations similar to ours in previous work on data refinement in a sequential setting  @xcite .    the transformers for standard commands , except memory ( de)allocation ,",
    "satisfy the conditions of footprint preservation and strong locality .",
    "we now give the semantics to complete and open programs . in the latter case",
    ", we define component - local semantics that include all behaviours of an open program under any environment satisfying the specification associated with it . in section  [ sec : refinement ] , we use these to lift linearizability to libraries and formulate the abstraction theorem .",
    "programs in our semantics denote sets of _ traces _ , recording every step in a computation .",
    "these include both internal actions by program components and calls and returns .",
    "we define program semantics in two stages .",
    "first , given a program , we generate the set of the possible execution traces of the program .",
    "this is done solely based on the structure of its statements , without taking into account restrictions arising from the semantics of primitive commands or ownership transfers .",
    "the next step filters out traces that are not consistent with the above restrictions using a trace evaluation process and , for open programs , annotates calls and returns appropriately .",
    "traces consist of _ actions _ , which include primitive commands performed internally by a component and calls or returns , possibly annotated with states .",
    "thus actions , include all interface actions @xmath104 from definition  [ def : intact ] .",
    "the set of * _ actions _ * is defined as follows : @xmath257 where @xmath107 , @xmath108 and @xmath217 .    a * _ trace _ * @xmath125 is a finite sequence of actions such that for every thread @xmath114 , the projection of @xmath125 to @xmath114 s call and return actions is a sequence of alternating call and return actions over matching methods that starts from a call action .",
    "we classify actions in a trace as those performed by the client and the library based on whether they happen inside a method .    for a trace @xmath125 and an index @xmath258 ,",
    "an action @xmath123 is a * _ client action _ * if @xmath259 for some thread @xmath114 and a primitive command @xmath220 and @xmath260 an action @xmath123 is a * _ library action _",
    "* if @xmath259 for some @xmath114 and @xmath220 but @xmath123 is not a client action , that is , @xmath261 a trace is a * _ client trace _ * , if all of its actions of the form @xmath262 are client actions ; it is a * _ library trace _ * , if they all of them are library actions .    in the following",
    ", @xmath263 denotes client traces , @xmath264 library traces , and @xmath125 arbitrary ones .",
    "we write @xmath265 for the projection of @xmath125 to client , call and return actions , @xmath266 for that to library , call and return actions , and @xmath267 for that to call and return actions .",
    "consider a program @xmath204 and let @xmath268 be the set of methods implemented by its library or called by its client .",
    "we define the trace set @xmath269 of @xmath205 in figure  [ fig : trace ] .",
    "we first define the trace set @xmath270 of a command @xmath271 , parameterised by the identifier @xmath114 of the thread executing it and a mapping @xmath272 giving the trace set of the body of every method that @xmath271 can call when executed by a given thread .",
    "the trace set of a client @xmath273 is obtained by interleaving traces of its threads .",
    "@xmath274 { \\llparenthesis\\hspace{1pt } c_1 + c_2 \\hspace{1pt}\\rrparenthesis}_t \\eta & = & { { \\llparenthesis\\hspace{1pt } c_1 \\hspace{1pt}\\rrparenthesis}_t \\eta } \\cup { { \\llparenthesis\\hspace{1pt } c_2 \\hspace{1pt}\\rrparenthesis}_t \\eta } \\\\[2pt ] { \\llparenthesis\\hspace{1pt } c^ * \\hspace{1pt}\\rrparenthesis}_{t}\\eta & = & \\big({\\llparenthesis\\hspace{1pt } c \\hspace{1pt}\\rrparenthesis}_t \\eta\\big)^ * \\\\[2pt ] { \\llparenthesis\\hspace{1pt } m \\hspace{1pt}\\rrparenthesis}_t \\eta & = &   \\{(t , { { \\sf call}}\\ m)\\ , \\tau\\ , ( t , { { \\sf ret}}\\ m ) \\mid \\tau \\in \\eta(m , t)\\ } \\\\[2pt ] { \\llparenthesis\\hspace{1pt } c_1 ; c_2 \\hspace{1pt}\\rrparenthesis}_t \\eta & = &   \\{\\tau_1 \\tau_2 \\mid \\tau_1 \\in { \\llparenthesis\\hspace{1pt } c_1 \\hspace{1pt}\\rrparenthesis}_t \\eta \\wedge   \\tau_2 \\in { \\llparenthesis\\hspace{1pt } c_2 \\hspace{1pt}\\rrparenthesis}_t \\eta\\ } \\\\[2pt ] { \\llparenthesis\\hspace{1pt } c_1 \\parallel \\ldots \\parallel c_n \\hspace{1pt}\\rrparenthesis } \\eta & = &   \\bigcup\\{\\tau_1 \\parallel \\ldots \\parallel \\tau_n \\mid \\forall t \\in \\ { 1,\\ldots , n\\}.\\ , \\tau_t \\in { \\llparenthesis\\hspace{1pt } c_t \\hspace{1pt}\\rrparenthesis}_t \\eta\\ } \\end{array } \\\\ \\\\ \\begin{array}{@{}r@{}c@{}l@ { } } { \\llparenthesis\\hspace{1pt }   { \\sf let}\\ \\{m = c_m \\mid m \\in m\\}\\ { \\sf in}\\   c_1 \\parallel\\ldots \\parallel c_n \\hspace{1pt}\\rrparenthesis } & = & { { \\sf prefix}}({\\llparenthesis\\hspace{1pt } c_1 \\parallel\\ldots",
    "\\parallel c_n \\hspace{1pt}\\rrparenthesis } ( { \\boldsymbol{\\lambda}}(m , t).\\ , { \\llparenthesis\\hspace{1pt } c_m \\hspace{1pt}\\rrparenthesis}_t ( \\ _ ) ) ) \\\\[2pt ] { \\llparenthesis\\hspace{1pt } \\gamma : { \\sf let}\\ [ -]\\ { \\sf in}\\ c_1\\parallel\\ldots\\parallel c_n \\hspace{1pt}\\rrparenthesis } & { } = { } & { { \\sf prefix}}({\\llparenthesis\\hspace{1pt } c_1\\parallel\\ldots\\parallel c_n \\hspace{1pt}\\rrparenthesis }   ( { \\boldsymbol{\\lambda}}(m , t).\\ , \\{\\varepsilon\\ } ) ) \\\\[2pt ] { \\llparenthesis\\hspace{1pt } \\{m = c_m \\mid m \\in \\{m_1,\\ldots , m_j\\}\\ } : \\gamma \\hspace{1pt}\\rrparenthesis } & = & { }   \\\\[2pt ] \\multicolumn{3}{@{}l@ { } } { \\hfill \\begin{array}{@{}r@ { } } { { \\sf prefix}}(\\bigcup\\nolimits_{k\\ge 1 } { \\llparenthesis\\hspace{1pt }   c_{{\\sf mgc}}\\parallel \\ldots ( \\mbox{$k$ times } ) \\ldots \\parallel c_{{\\sf mgc}}\\hspace{1pt}\\rrparenthesis}({\\boldsymbol{\\lambda}}(m , t).\\ , { \\llparenthesis\\hspace{1pt } c_m \\hspace{1pt}\\rrparenthesis}_t ( \\ _ ) ) ) \\\\[2pt ] ( \\mbox{where } c_{{\\sf mgc}}= ( m_1 + \\ldots + m_j)^ * ) \\end{array } } \\end{array } \\end{array}\\ ] ]    the",
    "trace set @xmath275 of a complete program is that of its client computed with respect to a mapping @xmath276 associating every method @xmath113 with the trace set of its body @xmath277 .",
    "since we prohibit nested method calls , @xmath278 does not depend on @xmath279 .",
    "we prefix - close the resulting trace set to take into account incomplete executions . in particular",
    ", this allows the thread scheduler to be unfair : a thread can be preempted and never scheduled again .    a program @xmath202 generates client traces @xmath280 , which do not include internal library actions .",
    "this is achieved by associating an empty trace with every library method .",
    "finally , a program @xmath281 generates all possible library traces @xmath282 .",
    "this is achieved by running the library under its _ most general client _ , where every thread executes an infinite loop , repeatedly invoking arbitrary library methods .",
    "@xmath283 & & \\mbox{else }   \\{\\tau ' \\mid \\exists \\tau \\in { \\llparenthesis\\hspace{1pt } \\gamma \\vdash    { \\mathcal{p } } : \\gamma ' \\hspace{1pt}\\rrparenthesis}.\\ ,   ( \\ _ , \\tau ' ) \\in   { \\llbracket \\gamma \\vdash \\tau : \\gamma ' \\rrbracket}\\sigma\\ } \\end{array } $ ]    @xmath284 { \\llbracket \\gamma \\vdash   \\tau\\varphi : \\gamma ' \\rrbracket}\\sigma & { } = { } & \\begin{array}[t]{@{}l@ { } } \\mbox{if $ ( { \\llbracket \\gamma \\vdash   \\tau : \\gamma ' \\rrbracket}\\sigma = \\top)$ then $ \\top$ } \\\\[2pt ] \\mbox{else if $ ( \\exists ( \\sigma',\\ _ ) \\in { \\llbracket \\gamma \\vdash   \\tau : \\gamma ' \\rrbracket}\\sigma.\\ , { \\llbracket \\gamma \\vdash \\varphi : \\gamma ' \\rrbracket}\\sigma ' = \\top)$ then $ \\top$ }   \\\\[2pt ] \\mbox{else $ \\{(\\sigma'',\\tau'\\varphi ' ) \\mid\\exists    \\sigma'.\\,(\\sigma',\\tau ' ) \\in { \\llbracket \\gamma \\vdash \\tau : \\gamma ' \\rrbracket}\\sigma \\wedge    ( \\sigma'',\\varphi ' ) \\in { \\llbracket \\gamma \\vdash \\varphi : \\gamma ' \\rrbracket}\\sigma'\\}$ } \\end{array } \\end{array } $ ]    @xmath285 { \\llbracket ( t,{{\\sf call}}\\ m ) \\rrbracket}\\sigma & { } = { } & \\{(\\sigma , ( t,{{\\sf call}}\\ m))\\ } \\\\[2pt ] { \\llbracket ( t,{{\\sf ret}}\\ m ) \\rrbracket}\\sigma & { } = { } & \\{(\\sigma , ( t,{{\\sf ret}}\\ m))\\ } \\\\[2pt ] { \\llbracket   ( t,{{\\sf call}}\\ m ) : ( \\{p\\}\\ { m}\\ \\{q\\ } ) , \\gamma ' \\rrbracket}\\sigma & { } = { } & \\{(\\sigma * \\sigma_p , ( t,{{\\sf call}}\\ m(\\sigma_p ) ) ) \\mid \\sigma_p \\in p_t   \\wedge ( \\sigma * \\sigma_p){\\mathpunct{\\downarrow}}\\ } \\\\[2pt ] { \\llbracket ( t,{{\\sf ret}}\\ m ) : ( \\{p\\}\\ { m}\\ \\{q\\ } ) , \\gamma ' \\rrbracket}\\sigma & { } = { } & \\mbox{if } ( \\sigma { \\mathop{\\backslash}}q_t){\\mathpunct{\\uparrow}}\\mbox { then } \\top \\mbox",
    "{ else } \\{(\\sigma { \\mathop{\\backslash}}q_t , ( t,{{\\sf ret}}\\ m(\\sigma { \\mathop{\\backslash}}{(\\sigma { \\mathop{\\backslash}}q_t)})))\\ } \\\\[2pt ] { \\llbracket   ( \\{p\\}\\ { m}\\ \\{q\\ } ) , \\gamma \\vdash ( t,{{\\sf call}}\\ m ) \\rrbracket}\\sigma & { } = { } & \\mbox{if } ( \\sigma { \\mathop{\\backslash}}p_t){\\mathpunct{\\uparrow}}\\mbox { then } \\top \\mbox { else } \\{(\\sigma { \\mathop{\\backslash}}p_t , ( t,{{\\sf call}}\\ m(\\sigma { \\mathop{\\backslash}}{(\\sigma { \\mathop{\\backslash}}p_t)})))\\ } \\\\[2pt ] { \\llbracket   ( \\{p\\}\\ { m}\\ \\{q\\ } ) , \\gamma \\vdash ( t,{{\\sf ret}}\\ m ) \\rrbracket}\\sigma & { } = { } & \\{(\\sigma * \\sigma_q , ( t,{{\\sf ret}}\\ m(\\sigma_q ) ) ) \\mid \\sigma_q \\in q_t \\wedge ( \\sigma * \\sigma_q){\\mathpunct{\\downarrow}}\\ } \\end{array } $ ]    the set of traces generated using @xmath286 may include those not consistent with the semantics of primitive commands or expected ownership transfers .",
    "we therefore define the meaning of a program @xmath287 by evaluating every trace in @xmath288 from a given initial state to determine whether it is feasible . for open programs",
    ", this process also annotates calls and returns in a trace with states transferred .",
    "the formal definition of @xmath289 is given in figure  [ fig : eval ] with the aid of a trace evaluation function @xmath290 .",
    "given an initial state , this either yields multiple final states and annotated traces , or fails and produces @xmath212 . if the resulting set of state - trace pairs is empty , then the trace is infeasible and is discarded .",
    "if the evaluation produces @xmath212 on any trace from @xmath291 , then the program has no semantics for the given initial state and its denotation is defined to be @xmath212 .",
    "the evaluation of @xmath125 is defined inductively on its length using a function @xmath292 that evaluates a single action @xmath293 .",
    "we explain this function by considering separately the cases of a complete program , open program with a library and open program with a client .",
    "the evaluation @xmath294 for an action in a complete program has the standard semantics , with the effects of primitive commands computed using their transformers from section  [ sec : prog ] . in this case ,",
    "calls and returns are left unannotated , since no ownership transfers to or from the external environment are performed .",
    "the function @xmath295 gives a * _ library - local _ * semantics to the program @xmath296 , in the sense that it generates library traces under any client respecting @xmath206 .",
    "when a method @xmath113 from @xmath206 is called by thread @xmath114 , the library receives the ownership of any state consistent with the method precondition @xmath170 .",
    "this state has to be compatible with that of the library .",
    "after the method returns , the library has to give up the piece of state satisfying its postcondition .",
    "since @xmath174 is precise , this piece of state is determined uniquely . the evaluation faults if the state to be transferred is not available ; thus , a library has no semantics if it violates the contract with its client given by @xmath206 .",
    "this also ensures that the histories produced by a library are balanced .",
    "[ safe2wb ] if @xmath297 , then @xmath298 is balanced from @xmath299 .",
    "the function @xmath300 gives a * _ client - local _ * semantics to @xmath202 , in the sense that it generates traces of this client assuming any behaviour of the library consistent with @xmath171 .",
    "when a thread @xmath114 calls a method @xmath113 in @xmath171 , it transfers the ownership of a piece of state satisfying the method precondition @xmath170 to the library being called . as before",
    ", this piece is defined uniquely , because preconditions are precise . when such a piece of state is not available , the evaluation faults .",
    "this ensures that client respects the method specifications of the libraries it uses . when the method returns , the client receives the ownership of an arbitrary piece of state satisfying its postcondition @xmath174 , compatible with the current state of the client .",
    "we now formulate a lemma , used in the proof of the abstraction theorem ( section  [ sec : refinement ] ) , that states the connection between the library - local and client - local semantics on one side and the semantics of complete programs on the other .",
    "we start by introducing some auxiliary definitions .",
    "a program @xmath204 is * _ safe _ * at @xmath38 , if @xmath301 ; @xmath205 is safe for @xmath302 , if it is safe at @xmath38 for all @xmath303 .    for a set of initial states",
    "@xmath304 , let @xmath305 we define an operator @xmath306 combining the resulting sets @xmath307 and @xmath308 of state - trace pairs produced by the client - local and library - local semantics into a set corresponding to the complete program : @xmath309 where @xmath310 and @xmath311 is a function on traces that erases the state annotations from their interface actions .",
    "[ prop : sem : local - global ] assume @xmath202 and @xmath312 safe for @xmath313 and @xmath314 , respectively .",
    "then @xmath209 is safe for @xmath315 and @xmath316    the lemma shows that the set of traces produced by @xmath209 can be obtained by combining pairs of traces with the same history produced by @xmath166 and @xmath157 .",
    "note that , since the semantics of @xmath209 does not annotate calls and returns with the states transferred , in @xmath317 we have to erase these annotations from the local traces @xmath263 or @xmath318 before comparing the traces with @xmath125 .",
    "unpacking the definition of @xmath319 and using the fact that @xmath320 from lemma  [ prop : sem : local - global ] we get the following two corollaries .    [ lemma - clientlocal ] assume @xmath202 and @xmath312 safe for @xmath313 and @xmath314 , respectively .",
    "then @xmath209 is safe for @xmath315 and @xmath321    [ lemma - clientlocal2 ] if @xmath202 and @xmath312 are safe for @xmath313 and @xmath314 , respectively , then @xmath322    corollary  [ lemma - clientlocal ] can be viewed as carrying over properties of the local semantics , such as safety , to the global one , and in this sense is the statement of the soundness of the former with respect to the latter .",
    "the corollary also confirms that the client defined by @xmath282 and @xmath323 is indeed most general , as it reproduces library behaviours under any possible clients .",
    "corollary  [ lemma - clientlocal2 ] carries over properties of the global semantics to the local ones , stating the adequacy of the latter .",
    "lemma  [ prop : sem : local - global ] is proved in appendix  [ sec : proofs ] .",
    "most of the proof deals with maintaining a splitting of the state of @xmath324 into the parts owned by @xmath157 and @xmath166 , which changes during ownership transfers .",
    "the proof relies crucially on the safety of the client and the libraries and the strong locality property of primitive commands . in more detail",
    ", safety is defined by considering executions of a component in the library - local or the client - local semantics .",
    "these execute the component code only on the memory it owns , whose amount only changes with ownership transfers to and from its environment according to method specifications . because of the strong locality property , commands fault when accessing memory cells that are not present in the state they are run from , and their execution does not depend on any additional memory that might be present in the state .",
    "hence , when we use a component inside a complete program , its safety guarantees that the component code does not touch the part of the heap belonging to other components in the program , and its execution is not affected by the state of such components .",
    "this guarantees that the behaviour a component produces as part of the complete program can be reproduced when we execute it in isolation and vice versa , allowing us to establish lemma  [ prop : sem : local - global ] . in practice , the safety of a program can be established using existing program logics , such as separation logic  @xcite .",
    "we are now in a position to define the notion of linearizability on libraries and prove the central technical result of this paper  the abstraction theorem .",
    "we define linearizability between specified libraries @xmath312 , together with their sets of initial states @xmath325 .",
    "first , using the library - local semantics of section  [ sec : semantics ] , we define the interface set describing all the behaviours of a library @xmath157 when run from initial states in @xmath325 : @xmath326    [ lin2 ] consider @xmath327 and @xmath328 safe for @xmath314 and @xmath329 , respectively .",
    "we say that @xmath330 * _ is linearized by _",
    "* @xmath331 , written @xmath332 , if , according to definition  [ lin ] , @xmath333 for an interface set @xmath149 we say that @xmath330 * _ is linearized by _",
    "* @xmath149 , written @xmath334 , if @xmath335    thus , @xmath330 is linearized by @xmath331 if every history generated by the library - local semantics of the former may be reproduced in a linearized form by the library - local semantics of the latter without requiring more memory .",
    "the relation @xmath336 allows us to specify a library by another piece of code , but possibly simpler than the original one .",
    "for example , the stack and the allocator from figure  [ fig : impl ] with method specifications  ( [ container ] ) and  ( [ alloc ] ) can be specified by the libraries in figure  [ fig : spec ] .",
    "the libraries replace the array and the linked list in the implementations by the abstract data types of a sequence and a set ( we assume a trivial extension of the @xmath18 algebra from section  [ sec : prelim ] to allow memory cells to store values of such types ) .",
    "thus , the abstract libraries use less memory than the concrete ones . instead of using locking , all operations on the abstract data types",
    "are done atomically ; formally , we assume primitive commands corresponding to the code in the atomic blocks .",
    "@l@|@l@    sequence < void * > stack ;    int push(void * arg ) atomic if ( nondet ( ) ) return full ; else add_to_head(stack , arg ) ; return ok ;    void * pop ( ) atomic if ( !",
    "isempty(stack ) ) void * obj = head(stack ) ; stack = tail(stack ) ; return obj ; else return empty ;    &    set < void * > free_list ;    void free(void * arg ) atomic add(free_list , arg ) ;    void * alloc ( ) atomic if ( ! isempty(free_list ) ) node * block = ( node*)take(free_list ) ; block->next = nondet ( ) ; block->prev = nondet ( ) ; return block ; else return 0 ;     +   + ( a ) & ( b )    the other relation @xmath334 introduced in definition  [ lin2 ] allows us to specify a library directly by an interface set , without fixing a piece of code generating it .",
    "the interface set @xmath149 can still be simpler than that of @xmath330 , e.g. , containing only sequential histories .",
    "even though the two forms of defining linearizability may seem very similar , as we show in section  [ sec : rearr ] , their mathematical properties are fundamentally different .",
    "we now formulate two variants of the abstraction theorem , corresponding to the two ways of specifying libraries ( we prove them in section  [ sec : rearr ] ) .",
    "[ thm2 ] if    @xmath337    @xmath327 , @xmath328 , @xmath202 are safe for @xmath314 , @xmath329 , @xmath325 , respectively , and    @xmath338 ,    then    @xmath337    @xmath339 and @xmath340 are safe for @xmath341 and @xmath342 , respectively , and    @xmath343    thus , when reasoning about a client @xmath344 of a library @xmath345 , we can soundly replace @xmath345 by a library @xmath346 linearizing it : if a safety property over client traces holds of @xmath347 , it will also hold of @xmath344 . in practice , we are usually interested in * _ atomicity abstraction _ * , a special case of this transformation when methods in @xmath346 are atomic .",
    "an instance is replacing one of the libraries from figure  [ fig : impl ] by its specification from figure  [ fig : spec ] .",
    "the requirement that @xmath166 be safe in the theorem restricts its applicability to well - behaved clients that do not access memory owned by the library : you can not replace a library by another one if the client can access its internal data structures and thereby `` look inside the box '' .",
    "similarly , the safety of the libraries ensures that they can not corrupt the data structures owned by the client .",
    "the other version of the abstraction theorem , allowing library specification by an interface set , guarantees that replacing a library by its specification leaves all the original client behaviours reproducible modulo the following notion of trace equivalence .",
    "client traces @xmath263 and @xmath348 are * _ equivalent _ * , written @xmath349 , if @xmath350 for all @xmath185 and the projections of @xmath263 and @xmath348 to non - interface actions are identical .",
    "[ thm - spec ] if    @xmath337    @xmath327 and @xmath202 are safe for @xmath314 and @xmath325 , respectively , and    @xmath351 ,    then    @xmath337    @xmath339 is safe for @xmath341 and    @xmath352    the theorem shows that client behaviours of @xmath339 can be reproduced by the client - local semantics of @xmath166 projected to histories in @xmath149 with initial footprints compatible with initial client states .",
    "note that @xmath353 in theorem  [ thm2 ] implies that @xmath354 , i.e. , @xmath340 can reproduce the history of @xmath339 exactly .",
    "in contrast , theorem  [ thm - spec ] does not guarantee this , since @xmath355 does not imply @xmath356 ; we only know that the projection to non - interface actions is reproduced .",
    "we discuss the reason for this discrepancy below .",
    "the key component used for establishing theorem  [ thm2 ] is the rearrangement lemma : if @xmath139 , then every execution trace of a library producing @xmath147 can be transformed into another trace of the same library that differs from the original one only in the order of interface actions and produces @xmath120 , instead of @xmath147 .",
    "hence , the library specification can simulate any behaviour of its implementation the client can expect .",
    "[ cor - rearr ] if @xmath357 and @xmath312 is safe at @xmath358 , then @xmath359    the proof of the lemma is highly non - trivial and is a subject of section  [ sec : rearr - proof ] .",
    "we point out lemma  [ cor - rearr ] would not hold had we included unbalanced histories in our definition of linearizability . to show this ,",
    "take @xmath129 and consider the histories in figure  [ fig : cex ] . in figure",
    "[ fig : cex](b ) the library receives the cell @xmath130 from the client , then returns it and then receives it again .",
    "even though the history in figure  [ fig : cex](a ) is linearized by that in figure  [ fig : cex](b ) , the former is not balanced , and by proposition  [ safe2wb ] , can not be produced by @xmath157 .",
    "this shows that lemma  [ cor - rearr ] does not hold for unbalanced @xmath120 .",
    "note that we have @xmath360 for any history @xmath120 . as a consequence , from lemma  [ cor - rearr ]",
    "we obtain the following surprising result , stating that linearizability between libraries is equivalent to inclusion between the sets of histories they produce .",
    "[ cor : subset ] if @xmath327 and @xmath361 are safe for @xmath362 and @xmath363 , respectively , then @xmath364    this fact is not a consequence of ownership transfer and also holds for the classical notion of linearizability .",
    "intuitively , lemma  [ cor - rearr ] , and hence , corollary  [ cor : subset ] hold due to a closure property of the semantics of the language from section  [ sec : prog ] .",
    "namely , in this and other programming languages , there may always be a delay between the point when a library method is called and when it starts executing and , conversely , when it ends executing and when the control returns to the client .",
    "for example , when executing the code in figure  [ fig : spec](a ) , there may be delays between a call to push , the execution of the atomic block and the return from push .",
    "hence , this library can produce both of the histories in figures  [ fig : hist](b ) and  [ fig : hist](c ) .",
    "due to this property of the program semantics , a trace from @xmath365 , e.g. , one producing the history in figure  [ fig : hist](c ) , will stay valid if we execute some of the calls in it earlier and returns later , like in figure  [ fig : hist](b ) .",
    "this is also ( usually ) safe given the ownership transfer reading of calls and returns in the library - local semantics defined by @xmath366 : it just means that the library receives state from the client earlier and gives it up later .",
    "the proof of lemma  [ cor - rearr ] uses such transformations on a history to `` de - linearize '' it , e.g. , transforming the history in figure  [ fig : hist](c ) into that in figure  [ fig : hist](b ) .",
    "the above closure property is also the reason for theorem  [ thm2 ] guaranteeing that @xmath340 can reproduce the history of @xmath339 exactly .    given that replacing a library @xmath345 by its linearization @xmath346 does not simplify its interface set , can theorem  [ thm2 ] really simplify reasoning about a complete program @xmath339 ?",
    "fortunately , the answer is yes , since the point of the theorem is to simplify _ the code _ of this program .",
    "for example , replacing the library in figure  [ fig : impl](a ) by the one in figure  [ fig : spec](a ) allows us to pretend in reasoning about a complete program that changes to the library state , shared between different threads , are atomic , and thus consider fewer possible thread interleavings .",
    "calls and returns in such a complete program are merely thread - local operations that do not complicate reasoning . in section",
    "[ sec : example ] , we discuss an example of using theorem  [ thm2 ] to simplify proofs of complicated algorithms .    specifying a library by an interface set @xmath149 instead of code , as in theorem  [ thm - spec ] , does not allow us to get results such as lemma  [ cor - rearr ] and corollary  [ cor : subset ] , since the set @xmath149 is not guaranteed to satisfy any closure properties .",
    "for example , it might contain only sequential histories , where every call is immediately followed by the corresponding return without a delay . in fact , @xmath149 has to be simpler than the interface set of @xmath345 for theorem  [ thm - spec ] to be useful , since this is what the theorem replaces @xmath345 by . fortunately , to prove theorem  [ thm - spec ] we can exploit a closure property of the client - local semantics , formalised by the following variant of the rearrangement lemma : any client trace can be transformed into an equivalent one with a given history linearizing the history of the original one",
    ".    [ thm ] if @xmath143 and @xmath202 is safe at @xmath38 , then @xmath367    intuitively , the lemma holds because , in the client - local semantics , it is safe to execute calls later and returns earlier . like lemma  [ cor - rearr ] , this lemma would not hold if we allowed @xmath147 to be unbalanced .    in summary ,",
    "when a library is specified by the code of its abstract implementation , the ability to linearize a concrete history while looking for a matching abstract one allowed by definition  [ lin ] is not strictly needed .",
    "however , it is indispensable when the library is specified directly by a set of histories .",
    "we were able to obtain this insight into the original definition of linearizability by formalising the guarantees the linearizability of a library provides to its clients as abstraction theorems .",
    "using lemmas  [ cor - rearr ] and  [ thm ] , we now prove the two versions of the abstraction theorem .",
    "[ [ proof - of - theoremthm2 . ] ] _ proof of theorem  [ thm2 ] .",
    "_ + + + + + + + + + + + + + + + + + + + + + + + + + +    the safety of @xmath339 and @xmath340 follows from corollary  [ lemma - clientlocal ] .",
    "take @xmath368 .",
    "we transform the trace @xmath369 of @xmath339 into a trace @xmath370 of @xmath340 with the same client projection using the local semantics of @xmath345 , @xmath346 and @xmath166 .",
    "namely , we first apply corollary  [ lemma - clientlocal ] to generate a pair @xmath371 of a library - local initial state and a trace and a client - local pair @xmath372 , such that [ eq - decomp ] = _ * c**_*l*^1   client(_1)=ground ( )   history ( ) = history(_1 ) . since @xmath373 , for some @xmath374",
    ", we have @xmath375 which implies @xmath376 . by lemma  [ cor - rearr ]",
    ", @xmath377 can be transformed into a trace @xmath378 such that @xmath379 since @xmath376 and @xmath380 , we have @xmath381 .",
    "we then use corollary  [ lemma - clientlocal2 ] to compose the library - local trace @xmath378 with the client - local one @xmath263 into a trace @xmath370 such that @xmath382    the above proof scheme can be described mnemonically as ` decompose , rearrange , compose ' .",
    "we reuse its first two steps to prove theorem  [ thm - spec ] .",
    "[ [ proof - of - theoremthm - spec . ] ] _ proof of theorem  [ thm - spec ] . _ +",
    "+ + + + + + + + + + + + + + + + + + + + + + + + + + + + +    take @xmath383 .",
    "like in the proof of theorem  [ thm2 ] , we apply corollary  [ lemma - clientlocal ] to generate @xmath384 and @xmath385 such that  ( [ eq - decomp ] ) holds . since @xmath386 ,",
    "for some @xmath387 , we have @xmath388 then by lemma  [ thm ] , @xmath263 can be transformed into a trace @xmath348 , such that @xmath389 since @xmath390 , we thus have @xmath391 . furthermore , since @xmath392 and @xmath393 , we have @xmath394 . hence , @xmath348 and @xmath96 are the required trace and footprint .      our preliminary investigations show that linearizability with ownership transfer can be established by generalising existing proof systems for proving classical linearizability based on separation logic  @xcite .",
    "the details of such a generalisation are out of the scope of this paper ; we plan to report on it in the future .",
    "the abstraction theorem is not just a theoretical result : it enables compositional reasoning about complex concurrent algorithms that are challenging for existing verification methods .",
    "for example , the theorem can be used to justify vafeiadis s compositional proof  ( * ? ? ? * section 5.3 ) of the multiple - word compare - and - swap ( mcas ) algorithm implemented using an auxiliary operation called rdcss  @xcite ( the proof used an abstraction of the kind enabled by theorem  [ thm2 ] without justifying its correctness ) .",
    "if the mcas algorithm were verified together with rdcss , its proof would be extremely complicated .",
    "fortunately , we can consider mcas as a client of rdcss , with the two components performing ownership transfers between them .",
    "the abstraction theorem then makes the proof tractable by allowing us to verify the linearizability of mcas assuming an atomic specification of the inner rdcss algorithm .",
    "we only give the proof of lemma  [ cor - rearr ] , as that of lemma  [ thm ] is completely symmetric .",
    "the proof transforms @xmath395 into @xmath318 by repeatedly swapping adjacent actions in it according to a certain strategy to make the history of the trace equal to @xmath120 .",
    "the most subtle place in the proof is swapping @xmath396 to yield @xmath397 where @xmath398 .",
    "this case is subtle for the following reason .",
    "let the state of the library @xmath157 before the return action be @xmath399 ; then @xmath400 and the state of the library after executing the return and the call is @xmath401 . for the swapping to be possible , we need @xmath402 ; then by proposition  [ prop - diff ] [ theta - swap ] ( _ 1 ) * _ 2 = ( _ 2)_1 , which can be used to establish that the resulting trace is still produced by @xmath157 . however , @xmath402 is not guaranteed if the history @xmath120 is arbitrary .",
    "for example , take @xmath403 and let @xmath120 and @xmath147 be defined by figures  [ fig : cex](a ) and  [ fig : cex](b ) .",
    "since @xmath120 is unbalanced , it can not be produced by any library , and hence , we can not swap @xmath404))\\,(2 , { { \\sf call}}\\ m_2([10:0]))\\ ] ] in @xmath147 . in our proof",
    "we use the fact that the history @xmath120 is balanced to show that a situation in which we can not swap a return followed by a call while transforming @xmath395 into @xmath318 can not happen .",
    "this is non - trivial , as the problematic situation can potentially happen midway through the transformation .",
    "we only know that the target history @xmath120 of @xmath318 is balanced , but this does not straightforwardly imply that the histories of the intermediate traces obtained while transforming @xmath395 into @xmath318 are , since these histories might be quite different from @xmath120 . inferring their balancedness from that of @xmath120 represents the most challenging part of the proof .",
    "we therefore first do the proof under an assumption that allows swapping a return followed by a call easily and consider the general case later .",
    "this lets us illustrate the overall idea of the proof , which is then reused in the additional part of the proof dealing with the challenge presented by the general case .",
    "namely , we make the following assumption : [ assm ]    @xmath129 and for any @xmath405 and interface actions @xmath406 and @xmath407 in @xmath408 , if @xmath398 , then @xmath409 .    for example , this holds when states transferred between the client and the library are always thread - local .",
    "it is easy to check that in @xmath18 , if @xmath400 , @xmath410 and @xmath411 , then @xmath402 and thus  ( [ theta - swap ] ) holds .",
    "hence ,  ( [ assm ] ) allows us to justify swapping a return followed by a call in a trace easily .",
    "we now proceed to prove lemma  [ cor - rearr ] under this assumption . in our proof",
    ", we use the assumption in a single place , which we note explicitly ; the rest of the proof is independent from it .",
    "below we sometimes write @xmath412 instead of @xmath138 to make the bijection @xmath413 used to establish the relation between histories in definition  [ lin ] explicit . for a bijection @xmath413 between histories",
    "@xmath120 and @xmath147 , we write @xmath414 if @xmath413 is an identity on the first @xmath127 actions in @xmath120 .",
    "take @xmath415 and consider a trace @xmath416 .",
    "assume histories @xmath417 such that @xmath418 and @xmath419 , so that @xmath120 is balanced from @xmath299 and @xmath147 from @xmath420 .",
    "we prove that there exists a trace @xmath421 such that @xmath422 . to this end",
    ", we define a finite sequence of steps that transforms @xmath395 into a such a trace @xmath318 .",
    "the main idea of the transformation is to make progressively longer prefixes of the trace have histories coinciding with prefixes of @xmath120 .",
    "namely , the transformation is done in stages , and on stage @xmath423 we obtain a trace @xmath424 , where @xmath425 .",
    "every one of these traces is such that for some prefix @xmath426 of @xmath427 we have : @xmath428 we let @xmath429 , so that the above conditions are initially satisfied . thus , during the transformation , progressively longer prefixes @xmath426 of @xmath427 have histories coinciding with prefixes of @xmath120 , while the linearizability relation between the history @xmath120 and that of @xmath427 is preserved .",
    "we then take @xmath430 as the desired trace @xmath318 .",
    "the trace @xmath431 is constructed from the trace @xmath427 by applying the following lemma for @xmath432 , @xmath433 , @xmath434 , @xmath435 , @xmath436 and @xmath437 .",
    "[ lemma ] assume  ( [ assm ] ) holds .",
    "consider a history @xmath438 and a trace @xmath439 such that @xmath440 then there exist traces @xmath378 and @xmath441 such that @xmath442 and @xmath443    to prove lemma  [ lemma ] , we convert @xmath444 into @xmath445 by swapping adjacent actions in the trace a finite number of times while preserving its properties of interest .",
    "these transformations are described by the following proposition , which formalises the closure properties of the library - local semantics we alluded to in section  [ sec : rearr ] .",
    "[ prop ] let @xmath312 be safe at @xmath446 and consider @xmath447 and a history @xmath448 such that @xmath449 . then swapping any two adjacent actions @xmath450 in @xmath408 executed by different threads such that    1 .",
    "@xmath451 , @xmath452 ; or 2 .",
    "@xmath453 , @xmath452 , @xmath454 precedes @xmath455 in @xmath448 , and  ( [ assm ] ) holds ; or 3 .",
    "@xmath456 , @xmath457    yields a trace @xmath458 such that @xmath459 for the bijection @xmath460 defined as follows . if @xmath461 or @xmath462 , then @xmath463",
    "otherwise , let @xmath124 be the index of @xmath455 in @xmath448 .",
    "then @xmath464 , @xmath465 and @xmath466 for @xmath467 .",
    "since , in the library - local semantics , the library gains state at a call and gives it up at a return , intuitively , the transformation in the proposition allows the library to gain state earlier ( i , ii ) and give it up later ( iii ) .",
    "the assumption that @xmath454 precede @xmath455 in case ( ii ) is needed to ensure that the transformation does not violate the linearizability relation .",
    "the proof of case ( ii ) is the only place where the assumption  ( [ assm ] ) is used .",
    "[ [ proof - sketch - for - propositionprop . ] ] _ proof sketch for proposition  [ prop ] . _ + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + +    consider @xmath468 and let @xmath469 .",
    "the proof of the required linearizability relationship is trivial .",
    "it therefore remains to show that @xmath470 .",
    "we know that for some @xmath471 we have @xmath472 and @xmath473 .",
    "let @xmath474 and @xmath475 , where @xmath476 and @xmath477 correspond to @xmath455 and @xmath454 .",
    "it is easy to see that @xmath478 .",
    "it therefore remains to show that @xmath479 .",
    "the proof proceeds by case analysis on the kind of actions @xmath455 and @xmath454 .",
    "the justification of the case when @xmath455 is a return and @xmath454 is a call follows from  ( [ assm ] ) by the argument given earlier . out of the remaining cases ,",
    "we only consider a single illustrative one : @xmath480 and @xmath481 for @xmath398 .",
    "assume @xmath482 .",
    "then for some @xmath399 we have @xmath483 , @xmath484 and @xmath485 . by the footprint preservation property , we get @xmath486 . then by the strong locality property , @xmath487 hence , @xmath488 .",
    "thus , footprint preservation and strong locality guarantee that a call can be safely executed earlier than a primitive command .",
    "[ [ proof - of - lemmalemma . ] ] _ proof of lemma  [ lemma ] . _ + + + + + + + + + + + + + + + + + + + + + + + + +    from  ( [ 1 ] ) and  ( [ 2 ] ) it follows that @xmath489 for some traces @xmath490 and @xmath491 , where @xmath413 maps @xmath104 in @xmath438 to the @xmath104 action shown in @xmath377 ; see figure  [ fig : diag ] .",
    "we consider two cases .",
    "@xmath492 . let @xmath114 be the thread executing @xmath104 .",
    "by  ( [ 2 ] ) we have @xmath493 .",
    "then , since @xmath444 is a library trace ,  ( [ 1 ] ) implies that there are no actions by thread @xmath114 in @xmath490 .",
    "furthermore , for any return action @xmath293 in @xmath490 , the action in @xmath438 corresponding to it according to @xmath413 is in @xmath494 .",
    "thus , we can move the action @xmath104 to the position between @xmath495 and @xmath490 by swapping it with adjacent actions a finite number of times as described in proposition  [ prop](i , ii ) . as a result",
    ", we obtain the trace @xmath496 .",
    "conditions  ( [ 4])([5 ] ) then follow from proposition  [ prop](i , ii ) for @xmath497 and @xmath498 .",
    "assume that @xmath490 contains a call action @xmath293 , so that it precedes the return action @xmath104 in @xmath500 . then by  ( [ 1 ] ) and  ( [ 2 ] ) the action in @xmath501 corresponding to @xmath293 according to @xmath413 is in @xmath494 and thus follows @xmath104 in @xmath438 .",
    "this violates the preservation of the order of non - overlapping method invocations required by  ( [ 2 ] ) .",
    "hence , there are no call actions in @xmath490 .",
    "since @xmath444 is a library trace , this implies that for any action @xmath502 in @xmath490 there are no actions by the thread @xmath114 in @xmath490 following @xmath293 .",
    "thus , we can move all return actions in the subtrace @xmath490 of @xmath444 to the position between @xmath104 and @xmath491 by swapping them with adjacent actions a finite number of times as described in proposition  [ prop](iii ) .",
    "we thus obtain the trace @xmath503 , where @xmath504 consists of all return actions in @xmath490 , and @xmath505 of the rest of actions in the subtrace ; in particular , @xmath505 does not contain any interface actions .",
    "conditions  ( [ 4])([5 ] ) then follow from proposition  [ prop](iii ) for @xmath506 and @xmath507 .",
    "this completes the proof of lemma  [ cor - rearr ] under the assumption  ( [ assm ] ) .",
    "let us now lift this assumption and consider the only place in the proof of the lemma that relies on it  that when we swap a return followed by a call using proposition  [ prop](ii ) in case 1 in the proof of lemma  [ lemma ] .",
    "let us now identify precise conditions under which this situation happens .",
    "let @xmath508 and let the adjacent return action with which we are trying to swap it be @xmath509 .",
    "let @xmath510 be the target history @xmath438 from lemma  [ lemma ] and @xmath511 be the history of the trace in which we are trying to swap the return and the call .",
    "then the two histories are of the form [ 2hist ]    r@  c@  l s^1 & = & s ( t_1,call  m_1(_1 ) ) s_1 ( t_2,ret  m_2(_2 ) ) s_2 ; + s^2 & = & s s_1 ( t_2,ret  m_2(_2 ) ) ( t_1,call  m_1(_1 ) ) s_2    for some @xmath512 . furthermore , from the conditions of lemma  [ lemma ]",
    ", we have :    a.   [ cond0 ] @xmath513 ; b.   @xmath510 and @xmath511 are balanced from some @xmath95 and @xmath96 , respectively , such that @xmath514 ; and c.   @xmath515 , where @xmath516 and @xmath413 maps @xmath517 and @xmath509 in @xmath510 to the corresponding actions shown in @xmath511 .",
    "as the following proposition shows , we can always do the desired transformation if the history [ hist1 ] s s_1 ( t_1,call  m_1(_1 ) ) ( t_2,ret  m_2(_2 ) ) s_2 resulting from swapping the return and the call in @xmath511 is balanced from @xmath96 .",
    "[ cor - call - ret ] let @xmath312 be safe at @xmath446 .",
    "consider traces @xmath518 and @xmath519 if @xmath520 is balanced from @xmath521 , then @xmath522 .",
    "thus , the only problematic case we have is when the history  ( [ hist1 ] ) is not balanced from @xmath96 .",
    "we summarise all the conditions under which such case can happen in the following definition .",
    "[ def - confl ] histories @xmath510 and @xmath511 of the form  ( [ 2hist ] ) are * _ conflicting _ * if the conditions ( i)(iii ) above are satisfied and the history  ( [ hist1 ] ) is not balanced from @xmath96 .    given proposition  [ cor - call - ret ] , the only case when the transformation in the proof of lemma  [ lemma ] can fail to convert the trace is when @xmath501 and the history currently being transformed are conflicting .",
    "thus , with the assumption  ( [ assm ] ) lifted , lemma  [ lemma ] turns into    [ lemma2 ] consider a history @xmath438 , and a trace @xmath523 such that ( [ 1 ] ) and ( [ 2 ] ) hold .",
    "then either @xmath438 and another history composed of actions from @xmath500 are conflicting , or there exist traces @xmath378 and @xmath441 such that @xmath442 and  ( [ 4 ] ) and  ( [ 5 ] ) hold .    we now show that no conflicting pairs of histories exist , hence guaranteeing that lemma  [ lemma2 ] can always be used to construct @xmath431 from @xmath427 in transforming @xmath395 into @xmath318 .",
    "this completes the proof of lemma  [ cor - rearr ] in the general case .",
    "we first discuss the main idea of the proof .",
    "the history @xmath510 in  ( [ 2hist ] ) is similar to  ( [ hist1 ] ) in that the call precedes the return .",
    "we would like to use the fact that @xmath510 is balanced to prove that so is  ( [ hist1 ] ) , thereby yielding a contradiction . as we noted at the beginning of this section , this is not straightforward due to the differences in the form of the histories @xmath510 and @xmath511 other than the precedence of the two call and return actions .",
    "we resolve this problem by adjusting the strategy we used above to transform @xmath395 into @xmath318 under the assumption  ( [ assm ] ) to iron out the differences between @xmath510 and @xmath511 .",
    "in particular , we use a variant of the transformation that , when the process of moving the call action @xmath104 to the left in @xmath444 gets stuck ( figure  [ fig : diag ] ) , leaves the corresponding action in @xmath438 unmatched and continues bringing the rest of the trace @xmath444 in sync with the target history .",
    "[ call - ret ] there are no conflicting pairs of histories .",
    "consider histories @xmath510 and @xmath511 satisfying the conditions in definition  [ def - confl ] . since @xmath511 is balanced from @xmath96 , @xmath524 is defined .",
    "assume @xmath525 is defined .",
    "since @xmath526 is defined , by proposition  [ prop - delta ] , we have : @xmath527 then  ( [ hist1 ] ) is balanced from @xmath96 , contradicting our assumptions . hence , @xmath528 .",
    "a call action in @xmath529 can not be in @xmath530 : in this case it would follow @xmath509 in @xmath510 , but precede it in @xmath511 , contradicting @xmath531 . hence , all call actions in @xmath529 are in @xmath532 .",
    "let @xmath533 , where @xmath534 is the minimal prefix of @xmath532 containing all call actions from @xmath529 . then @xmath535 s^2 & = & s s'_1\\ , ( t_2,{{\\sf ret}}\\ m_2(\\sigma_2))\\ , ( t_1,{{\\sf call}}\\ m_1(\\sigma_1 ) ) \\,s'_2 . \\end{array}\\ ] ] if @xmath534 is non - empty , any return action in it precedes its last call action , which is also in @xmath529 . since @xmath531",
    ", such a return action also has to be in @xmath529 .",
    "thus , all return actions in @xmath534 are in @xmath529 .",
    "the traces @xmath510 and @xmath511 are of the following more general form , obtained by letting @xmath536 and @xmath537 : @xmath538 s^2 & = & s'_0 s'_1\\ , ( t_2,{{\\sf ret}}\\ m_2(\\sigma_2))\\ , ( t_1,{{\\sf call}}\\ m_1(\\sigma_1 ) ) \\,s'_2 , \\end{array}\\ ] ] where    @xmath337    @xmath510 and @xmath511 are balanced from some @xmath95 and @xmath96 , respectively , such that @xmath514 ;    @xmath539 and @xmath540 are identical , except @xmath539 may have some extra call actions ;    @xmath515 ;    @xmath541 maps all call actions in @xmath529 to actions in @xmath534 ;    @xmath413 maps all return actions in @xmath534 to actions in @xmath529 ;    @xmath541 maps actions in @xmath540 to those in @xmath539 , in particular @xmath542 to an action in @xmath539 , and @xmath509 to the same action shown in @xmath510 ; and    @xmath543 .",
    "we denote this form by ( * f * ) .",
    "the additional call actions in @xmath539 are the ones for which the transformation in lemma  [ lemma ] failed .",
    "the conditions relating @xmath534 and @xmath529 imply that @xmath534 may have more calls than @xmath529 , and @xmath529 more returns than @xmath534 .",
    "thus , intuitively , @xmath544 gains more state than @xmath545 , including that transferred by @xmath517 , and @xmath545 gives up more than @xmath544 . in the following , we use this and the fact that @xmath510 is balanced from a bigger footprint than @xmath511 to show that @xmath546 , thereby yielding a contradiction .    to this end",
    ", we describe a process that transforms the histories @xmath510 and @xmath511 into another pair of histories satisfying the conditions above , but such that @xmath534 is strictly smaller . repeatedly applying this process",
    ", we can make @xmath534 empty , obtaining histories satisfying ( * f * ) : [ hist - temp ]    l s_0 s_4 ( t_2,ret  m_2(_2 ) ) s_2 ; + s_0 s_1 ( t_2,ret  m_2(_2 ) ) ( t_1,call  m_1(_1 ) ) s_2 .",
    "in particular , @xmath543 . before describing the transformation process ,",
    "we show that , given the above pair of histories , we can obtain a contradiction .",
    "we use the following simple proposition , proved in appendix  [ sec : proof - foot ] .",
    "[ prop - foot ] assume @xmath448 is identical to @xmath547 , except it may have extra calls , and @xmath448 and @xmath547 are balanced from @xmath95 and @xmath96 , respectively , such that @xmath548 .",
    "then the @xmath56-combination @xmath549 of footprints of states transferred at the extra call actions in @xmath448 is defined , @xmath547 is balanced from @xmath95 and @xmath550    consider the histories in  ( [ hist - temp ] ) . since all calls from @xmath529 are in @xmath551 , @xmath529 contains only returns .",
    "since the histories are balanced from @xmath95 and @xmath96 , respectively , @xmath552 and @xmath553 are defined .",
    "the history @xmath539 is identical to @xmath540 , except it may have extra calls . by proposition  [ prop - foot ] , the @xmath56-combination of footprints of states transferred at the extra call actions in @xmath539 is defined . since an action @xmath517 is in @xmath539 , but not in @xmath540 , this combination is of the form @xmath554 for some @xmath549 ; hence , @xmath555 therefore , @xmath556 is defined . since @xmath529 contains only return actions , @xmath557 where @xmath558 is the @xmath559-combination of the footprints of states transferred at these actions .",
    "this implies @xmath560 where both expressions are defined .",
    "but then so is @xmath561 hence , @xmath562 is defined , contradicting the opposite fact established above .",
    "this contradiction implies that a conflicting pair of histories does not exist",
    ".    now assume arbitrary histories @xmath510 and",
    "@xmath511 satisfying ( * f * ) : @xmath538 s^2 & = & s'_0 s'_1\\ , ( t_2,{{\\sf ret}}\\ m_2(\\sigma_2))\\ , ( t_2,{{\\sf call}}\\ m_1(\\sigma_1 ) ) \\,s'_2 , \\end{array}\\ ] ] we show that from these we can construct another pair of histories satisfying ( * f * ) , but with @xmath534 strictly smaller .",
    "we use the same transformation as in the proof of lemma  [ lemma ] .",
    "when this transformation gets stuck , we obtain another pair of histories of the form ( * f * ) , but again with a smaller @xmath534 .",
    "let us make a case split on the next action in @xmath534 .",
    "@xmath337    @xmath563 , such that the action corresponding to @xmath105 according to @xmath413 is not in @xmath529 . in this case",
    "we let @xmath564 and @xmath565 .",
    "thus , the call action @xmath105 unmatched in @xmath529 becomes part of @xmath539 .",
    "@xmath563 , such that the action corresponding to @xmath105 according to @xmath413 is in @xmath529 .",
    "let @xmath566 , so that @xmath567 s^2 & = & s'_0 s'_3\\ , ( t , { { \\sf call}}\\ m(\\sigma))\\ , s'_4\\ , ( t_2,{{\\sf ret}}\\ m_2(\\sigma_2))\\ , ( t_2,{{\\sf call}}\\ m_1(\\sigma_1 ) ) \\,s'_2 . \\end{array}\\ ] ] using the transformations from case 1 in the proof of lemma  [ lemma ] , we can try to move the action @xmath105 to the position between @xmath540 and @xmath568 while preserving the balancedness of the history .",
    "if this succeeds , we construct a new pair of histories of the form ( * f * ) by letting @xmath564 , @xmath569 , @xmath570 and @xmath571 .",
    "otherwise , we get a pair of conflicting histories , which are of the form ( * f * ) but with a smaller @xmath534 . again , in this case the unmatched call action @xmath105 becomes part of @xmath539 .",
    "then the action corresponding to @xmath573 according to @xmath413 is also in @xmath529 , so that @xmath574 : @xmath575 s^2 & = & s'_0 s'_3\\ , ( t , { { \\sf ret}}\\ m(\\sigma))\\ , s'_4\\ , ( t_2,{{\\sf ret}}\\ m_2(\\sigma_2))\\,(t_2,{{\\sf call}}\\ m_1(\\sigma_1))\\ , s'_2 . \\end{array}\\ ] ] using the transformations from case 2 in the proof of lemma  [ lemma ] , we can move the return action to the position between @xmath540 and @xmath568 while preserving the balancedness of the history .",
    "we thus obtain a pair of histories : @xmath576 s^2 & = & s'_0\\ , ( t , { { \\sf ret}}\\ m(\\sigma))\\ , s'_3 s'_4\\ , ( t_2,{{\\sf ret}}\\ m_2(\\sigma_2))\\,(t_2,{{\\sf call}}\\ m_1(\\sigma_1 ) ) \\,s'_2 . \\end{array}\\ ] ] then we can let @xmath577 , @xmath569 , @xmath578 and @xmath571 .",
    "libraries such as concurrent containers are used by clients to transfer the ownership of data structures , but do not actually access their contents .",
    "we show that for such libraries , the classical linearizability implies linearizability with ownership transfer .",
    "[ def : gamma2 ] a method specification @xmath579 * _ extends _ * a specification @xmath580 , if @xmath581 .",
    "for example , the method specification  ( [ container ] ) of the stack in figure  [ fig : impl](a ) extends the following specification : [ container - val ]    l \\{x .",
    "arg_t x }   push  \\{arg_t arg_t } ; + \\{y .",
    "arg_t y }  pop   \\{x .",
    "arg_t x}.    according to this specification ,",
    "push just receives an arbitrary pointer @xmath11 as a parameter ; in contrast , the specification  ( [ container ] ) additionally mandates that the object the pointer identifies be transferred to the library .",
    "we now identify conditions under which the linearizability between a pair of libraries satisfying @xmath171 entails that of the same libraries satisfying an extended method specification @xmath206 .",
    "this yields a result somewhat analogous to the frame rule of separation logic  @xcite .",
    "we start by introducing some auxiliary definitions .",
    "we first define operations for mapping between histories corresponding to extended and non - extended method specifications . for the method specification @xmath171 from definition  [ def : gamma2 ] , we define operations @xmath582 and @xmath583 on interface actions as follows : @xmath584 \\llfloor(t , { { \\sf ret}}\\ m(\\sigma))\\rrfloor_{\\gamma } & = &   ( t , { { \\sf ret}}\\ m(\\sigma { \\mathop{\\backslash}}{(\\sigma{\\mathop{\\backslash}}q^m_t ) } ) ) ; \\\\[2pt ] \\llceil ( t , { { \\sf call}}\\ m(\\sigma ) ) \\rrceil_{\\gamma } & = & ( t , { { \\sf call}}\\ m(\\sigma{\\mathop{\\backslash}}p^m_t ) ) ; \\\\[2pt ] \\llceil ( t , { { \\sf ret}}\\ m(\\sigma ) ) \\rrceil_{\\gamma } & = & ( t , { { \\sf ret}}\\ m(\\sigma{\\mathop{\\backslash}}q^m_t ) ) ; \\end{array}\\ ] ] otherwise , the result is undefined .",
    "thus , @xmath585 selects the part of the state in @xmath104 that is required by @xmath171 and @xmath586 the extra piece of state not required by it .",
    "we then lift @xmath587 and @xmath588 to traces by applying them to every interface action .    given a history @xmath589 produced by a library @xmath281 , we need to be able to check that the library does not modify the extra pieces of state not required by the original method specification @xmath171 , which are given by @xmath590 . to this end",
    ", we define an evaluation function similar to @xmath591 from section  [ sec : observ ] , which is meant to be applied to @xmath592 . for an interface action",
    "@xmath104 we define @xmath593 as follows : @xmath594 { \\langle ( t,{{\\sf ret}}\\;m(\\sigma_0 ) ) \\rangle}\\sigma & = &   \\mbox{if } { ( \\sigma { \\mathop{\\backslash}}\\sigma_0){\\mathpunct{\\downarrow } } } \\mbox { then } \\sigma { \\mathop{\\backslash}}\\sigma_0   \\mbox { else } \\top .",
    "\\end{array}\\ ] ] we then define the evaluation @xmath595 of a history @xmath120 as follows : @xmath596 thus , if the evaluation does not fail , then the history respects the notion of ownership and the pieces of state transferred to the library are returned to the client unmodified .",
    "[ thm : frame ] assume    1 .",
    "@xmath206 extends @xmath171 ; 2 .   for all @xmath597 , @xmath598 and @xmath599",
    "are safe for @xmath600 and @xmath601 , respectively ; 3 .   @xmath602 ; and 4 .   for every @xmath603 , @xmath604 and @xmath605",
    ", we have @xmath606 .    then @xmath607 .",
    "the theorem allows us to establish the linearizability relation with respect to the extended specification @xmath206 given the relation with respect to @xmath171 .",
    "this enables the use of the abstraction theorem for clients performing ownership transfer .",
    "however , the theorem does not guarantee the safety of the libraries with respect to @xmath206 for free , because it is not implied by their safety with respect to @xmath171 .",
    "intuitively , this is because @xmath206 extends both preconditions and postconditions in @xmath171 ; hence , not only does it guarantee to the library that the client will provide extra pieces of state at calls , but it also requires the library to provide ( possibly different ) extra pieces of state at returns . for example , @xmath171 might assign the specification @xmath608 to every method @xmath113 , and @xmath206 , the specification @xmath609 . unless a library already has all the memory required by the postconditions in @xmath206 in its initial state",
    ", it has no way of satisfying @xmath206 .",
    "this situation is in contrast to the frame rule of separation logic  @xcite , which guarantees the safety of a piece of code with respect to an extended specification .",
    "however , the frame rule requires the latter specification to extend both pre- and postconditions with the same piece of state , so that the code returns it immediately after termination . in our setting , a library can return the extra state to its client after a different method invocation and , possibly , in a different thread .    finally ,",
    "condition ( 4 ) in theorem  [ thm : frame ] ensures that the extra memory required by postconditions in @xmath206 comes from the extra memory provided in its preconditions and the extension of the initial state , not from the memory transferred according to @xmath171 .",
    "it can be shown that for the library @xmath345 in figure  [ fig : impl](a ) , the library @xmath346 in figure  [ fig : spec](a ) and method specification @xmath171 defined by  ( [ container - val ] ) , we have @xmath610 .",
    "it is also not difficult to prove ( e.g. , using separation logic ) that @xmath611 and @xmath612 are safe .",
    "condition ( 4 ) in theorem  [ thm : frame ] is satisfied , since the proof of safety of @xmath611 would use only the extra state provided in the preconditions of @xmath206 to provide the extra state required by its postconditions .",
    "hence , by theorem  [ thm : frame ] we have @xmath613 .",
    "however , theorem  [ thm : frame ] is not applicable to the memory allocators in figures  [ fig : impl](b ) and  [ fig : spec](b ) : since the allocator implementation in figure  [ fig : impl](b ) stores free - list pointers inside the memory blocks , it is unsafe with respect to the variant of the method specification  ( [ alloc ] ) that does not transfer their ownership .",
    "the proof of theorem  [ thm : frame ] relies on the following two lemmas , proved in appendices  [ proof : frame - out ] and  [ proof : frame - in ] , that convert between library traces corresponding to extended and original method specifications .",
    "the first lemma shows that for a trace @xmath318 produced by @xmath614 , the trace @xmath615 can be produced by @xmath203 .",
    "the safety of the library with respect to @xmath171 and condition ( 4 ) from theorem  [ thm : frame ] guarantee that the smaller preconditions specified by @xmath171 are enough for the library to execute safely and that the extra pieces of state in @xmath206 do not influence its execution .",
    "[ frame - out ] if @xmath616 , @xmath617 is safe at @xmath446 , and @xmath618 , then @xmath619 .",
    "the other lemma gives conditions under which we can conclude that a trace @xmath318 is produced by @xmath281 given that @xmath620 is produced by @xmath312 .",
    "[ frame - in ] assume @xmath621 , @xmath622 , @xmath298 is balanced from @xmath623 for @xmath624 , and @xmath625 . then @xmath626 .",
    "[ [ proof - of - theoremthmframe . ] ] _ proof of theorem  [ thm : frame ] . _ + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + +    consider a trace @xmath627 , where @xmath628 and @xmath629 . then by ( 4 ) we have @xmath630 , and hence by lemma  [ frame - out ] we have @xmath631 . since @xmath602 , for some @xmath632 and @xmath633 we have @xmath634 by lemma  [ cor - rearr ] , there exists @xmath635 such that @xmath636 .",
    "let @xmath441 be the trace @xmath378 with its interface actions replaced so that they form the history @xmath637 . then @xmath638 and @xmath639 .",
    "since @xmath640 , we have @xmath641 . hence , by lemma  [ frame - in ] , @xmath642 , from which the required follows .",
    "the original definition of linearizability  @xcite was proposed in an abstract setting that did not consider a particular programming language and implicitly assumed a complete isolation between the states of the client and the library .",
    "furthermore , at the time it was not clear what the linearizability of a library entails for its clients .",
    "filipovi et al .",
    "@xcite were the first to observe that linearizability implies a form of contextual refinement ; technically , their result is similar to our lemma  [ thm ] , but formulated over a highly idealistic semantics . in a previous work  @xcite , we generalised their result to a compositional proof method , formalised by an abstraction theorem , that allows one to replace a concrete library by an abstract one in reasoning about a complete program .",
    "this paper is part of our recent push to propose notions of concurrent library correctness for realistic programming languages .",
    "so far we have developed such notions together with the corresponding abstraction theorems for supporting reasoning about liveness properties  @xcite and weak memory models  @xcite .",
    "all these results assumed that the library and its client operate in disjoint address spaces and , hence , are guaranteed not to interfere with each other and can not communicate via the heap .",
    "lifting this restriction is the goal of the present paper .",
    "although the basic proof structure of theorems  [ thm2 ] and  [ thm - spec ] is the same as in  @xcite , the formulations and proofs of the abstraction theorem and the required lemmas here have to deal with technical challenges posed by ownership transfer that did not arise in previous work .",
    "first , their formulations rely on the novel forms of client - local and library - local semantics ( section  [ sec : semantics ] ) that allow a component to communicate with its environment via ownership transfers . proving lemma  [ prop : sem : local - global ]",
    "then involves a delicate tracking of a splitting between the parts of the state owned by the library and the client , and how ownership transfers affect it .",
    "second , the key result needed to establish the abstraction theorem is the rearrangement lemma ( lemmas  [ cor - rearr ] and  [ thm ] ) .",
    "what makes the proof of this lemma difficult in our case is the need to deal with subtle interactions between concurrency and ownership transfer that have not been considered in previous work .",
    "namely , changing the history in the lemma requires commuting ownership transfer actions ; justifying the correctness of these transformations is non - trivial and relies on the notion of history balancedness that we propose .",
    "these differences notwithstanding , we hope that techniques for handling ownership transfer proposed in this paper can be combined with the ones for handling other types of client - library interactions considered so far  @xcite .",
    "recently , there has been a lot of work on verifying linearizability of common algorithms ; representative papers include  @xcite . all of them proved classical linearizability , where libraries and their clients exchange values of a given data type and do not perform ownership transfers .",
    "this includes even libraries , such as concurrent containers , that are actually used by client threads to transfer the ownership of data structures .",
    "the frame rule for linearizability we propose ( theorem  [ thm : frame ] ) justifies that classical linearizability established for concurrent containers entails linearizability with ownership transfer .",
    "this makes our abstraction theorem applicable , enabling compositional reasoning about their clients .",
    "turon and wand  @xcite have proposed a logic for establishing refinements between concurrent modules , likely equivalent to linearizability  @xcite .",
    "their logic considers libraries and clients residing in a shared address space , but not ownership transfer . as a result",
    ", they do not support separate reasoning about a library and its client in realistic situations of the kind we consider .",
    "elmas et al .",
    "@xcite have developed a system for verifying concurrent programs based on repeated applications of atomicity abstraction .",
    "they do not use linearizability to perform the abstraction .",
    "instead , they check the commutativity of an action to be incorporated into an atomic block with _ all _ actions of other threads . in particular , to abstract a library implementation in a program by its atomic specification , their method would have to check the commutativity of every internal action of the library with all actions executed by the client code of other threads .",
    "thus , the method of elmas et al .",
    "does not allow decomposing the verification of a program into verifying libraries and their clients separately .",
    "in contrast , our abstraction theorem ensures the atomicity of a library under _ any _ safe client .",
    "the most common approach of decomposing the verification of concurrent programs is using _ thread - modular _ reasoning methods , which consider every thread in the program in isolation under some assumptions on its environment  @xcite .",
    "however , a single thread would usually make use of multiple program components .",
    "this work goes further by allowing a finer - grain _ intrathread - modular _ reasoning : separating the verification of a library and its client , the code from both of which may be executed by a single thread .",
    "note that this approach is complementary to thread - modular reasoning , which can still be used to carry out the verification subtasks , such as establishing the linearizability of libraries and proving the safety of clients .",
    "thread - modular techniques do enable a restricted form of intrathread - modular reasoning , since they allow reasoning about the control of a thread in a program while ignoring the possibility of its interruption by the other threads .",
    "hence , they allow considering a library method called by the thread in isolation , e.g. , by using the standard proof rules for procedures .",
    "however , such a decomposition is done under fixed assumptions on the environment of the thread and thus does not allow , e.g. , increasing the atomicity of the environment s actions . as the example of mcas shows ( section  [ sec : example ] )",
    ", this is necessary to deal with complex algorithms .",
    "ways of establishing relationships between different sequential implementations of the same library have been studied in _ data refinement _",
    "@xcite , including cases of interactions via ownership transfer  @xcite .",
    "our results can be viewed as generalising data refinement to the concurrent setting . moreover ,",
    "when specialised to the sequential case , they provide a more flexible method of performing it in the presence of the heap and ownership transfer than previously proposed ones . in more detail , the way we define client safety ( section  [ sec : semantics ] ) is more general some of the ways used in data refinement  @xcite .",
    "there , it is typical to fix a ( precise ) invariant of a library and check that the client does not access the area of memory fenced off by the invariant .",
    "here we do not require an explicit library invariant , using the client - local semantics instead : since primitive commands fault when accessing non - existent memory cells , the safety of the client in this semantics ensures that it does not access the internals of the library .",
    "we note that the approach requiring an invariant for library - local data structures does not generalise to the concurrent setting : while a precise invariant for the data structures _ shared _ among threads executing library code is not usually difficult to find , the state of data structures _",
    "local _ to the threads depends on their program counters .",
    "thus , an invariant insensitive to program positions inside the library code often does not exist .",
    "such difficulties are one of reasons for using client- and library - local semantics in this paper .",
    "finally , we note that the applicability of our results is not limited to proving existing programs correct : they can also be used in the context of formal program development . in this case , instead of _ abstracting _ an existing library to an atomic specification while proving a complete program , the abstraction theorem allows _ refining _ an atomic library specification to a concrete concurrent implementation while developing a program top - down  @xcite .",
    "our work thus advances the method of atomicity refinement to a setting with concurrent components sharing an address space and communicating via ownership transfers .",
    "we would like to thank anindya banerjee , josh berdine , xinyu feng , hongjin liang , victor luchangco , david naumann , peter ohearn , matthew parkinson , noam rinetzky and julles villard for helpful comments .",
    "gotsman was supported by the eu fet project advent .",
    "yang was supported by epsrc .    10    d.  amit , n.  rinetzky , t.  w. reps , m.  sagiv , and e.  yahav .",
    "comparison under abstraction for verifying linearizability . in _ cav07 : conference on computer aided verification _ , volume 4590 of _ lncs _ , pages 477490 .",
    "springer , 2007 .",
    "r .- j . back . on correct refinement of programs .",
    ", 23(1):4968 , 1981 .    a.  banerjee and d.  a. naumann .",
    "ownership confinement ensures representation independence in object - oriented programs .",
    ", 52(6):894960 , 2005 .",
    "mark batty , mike dodds , and alexey gotsman .",
    "library abstraction for c / c++ concurrency . in _",
    "popl13 : symposium on principles of programming languages _ , pages 235248 .",
    "acm press , 2013 .",
    "r.  bornat , c.  calcagno , p.",
    "ohearn , and m.  parkinson .",
    "permission accounting in separation logic . in _",
    "popl05 : symposium on principles of programming languages _ , pages 259270 .",
    "acm press , 2005 .",
    "s.  burckhardt , a.  gotsman , m.  musuvathi , and h.  yang .",
    "concurrent library correctness on the tso memory model . in _",
    "esop12 : european symposium on programming _ , volume 7211 of _ lncs _ , pages 87107 .",
    "springer , 2012 .    c.  calcagno , p.",
    "ohearn , and h.  yang . local action and abstract separation logic . in _",
    "lics07 : symposium on logic in computer science _ , pages 366378 .",
    "ieee , 2007 .",
    "d.  g. clarke , j.  noble , and j.  m. potter .",
    "simple ownership types for object containment . in _",
    "ecoop01 : european conference on object - oriented programming _ , volume 2072 of _ lncs _ , pages 5376 .",
    "springer , 2001 .",
    "m.  dodds , x.  feng , m.  parkinson , and v.  vafeiadis .",
    "deny - guarantee reasoning . in _",
    "esop09 : european symposium on programming _ , volume 5502 of _ lncs _ , pages 363377 .",
    "springer , 2009 .",
    "t.  elmas , s.  qadeer , a.  sezgin , o.  subasi , and s.  tasiran .",
    "simplifying linearizability proofs with reduction and abstraction . in _",
    "tacas10 : conference on tools and algorithms for the construction and analysis of systems _ , volume 6015 of _ lncs _ , pages 296311 .",
    "springer , 2010 .",
    "t.  elmas , s.  qadeer , and s.  tasiran . a calculus of atomic actions . in _",
    "popl09 : symposium on principles of programming languages _ , pages 215 .",
    "acm press , 2009 .",
    "i.  filipovi , p.  ohearn , n.  rinetzky , and h.  yang .",
    "abstraction for concurrent objects .",
    ", 411(51 - 52):43794398 , 2010 .",
    "i.  filipovi , p.  ohearn , n.  torp - smith , and h.  yang .",
    "blaiming the client : on data refinement in the presence of pointers .",
    ", 22(5):547583 , 2010 .",
    "a.  gotsman and h.  yang .",
    "liveness - preserving atomicity abstraction . in _",
    "icalp11 : international colloquium on automata , languages and programming _ , volume 6756 of _ lncs _ , pages 453465 .",
    "springer , 2011 .",
    "alexey gotsman , madanlal musuvathi , and hongseok yang .",
    "show no weakness : sequentially consistent specifications of tso libraries . in _",
    "disc12 : symposium on distributed computing _ ,",
    "volume 7611 of _ lncs _ , pages 3145 .",
    "springer , 2012 .",
    "t.  harris , k.  fraser , and i.  pratt . a practical multi - word compare - and - swap operation . in _",
    "disc02 : symposium on distributed computing _ ,",
    "volume 2508 of _ lncs _ , pages 265279 .",
    "springer , 2002 .",
    "m.  herlihy and n.  shavit . .",
    "morgan kaufmann , 2008 .",
    "m.  herlihy and j.  m. wing .",
    "linearizability : a correctness condition for concurrent objects .",
    ", 12(3):463492 , 1990 .    c.  a.  r. hoare .",
    "proof of correctness of data representations .",
    ", 1:271281 , 1972 .",
    "c.  b. jones . specification and design of ( parallel )",
    "programs . in _ ifip congress _ , pages 321332 , 1983 .    c.  b. jones . splitting atoms safely . , 375(1 - 3):109119 , 2007 .",
    "i.  mijajlovic and h.  yang .",
    "data refinement with low - level pointer operations . in _",
    "aplas05 : asian symposium on programming languages and systems _ ,",
    "volume 3780 of _ lncs _ , pages 1936 .",
    "springer , 2005 .",
    "p.  ohearn .",
    "resources , concurrency and local reasoning . , 375(1 - 3):271307 , 2007 .",
    "a.  pnueli . in transition from global to modular temporal reasoning about programs . in _ logics and models of concurrent systems _ ,",
    "pages 123144 .",
    "springer , 1985 .",
    "j.  c. reynolds .",
    "types , abstraction and parametric polymorphism . in _ ifip congress _ , pages 513523 , 1983 .    j.  c. reynolds .",
    "logic : a logic for shared mutable data structures . in _",
    "lics02 : symposium on logic in computer science _ , pages 5574 .",
    "ieee , 2002 .",
    "a.  turon and m.  wand . a separation logic for refining concurrent objects . in _",
    "popl11 : symposium on principles of programming languages _",
    ", pages 247258 .",
    "acm press , 2011 .",
    "v.  vafeiadis .",
    "modular fine - grained concurrency verification .",
    "phd thesis .",
    "university of cambridge , 2008 .",
    "v.  vafeiadis .",
    "automatically proving linearizability . in _",
    "cav10 : conference on computer aided verification _",
    ", volume 6174 of _ lncs _ , pages 450464 .",
    "springer , 2010 .",
    "we prove the required by induction on the length of @xmath448 . if @xmath448 is empty , then so is @xmath547 and @xmath643 . assume the statement of the proposition is valid for all histories @xmath448 of length less than @xmath644 .",
    "consider a history @xmath645 of length @xmath646 and a corresponding history @xmath547 satisfying the conditions of the proposition .",
    "we now make a case split on the type of the action @xmath104 .",
    "@xmath337    @xmath104 is a call transferring @xmath446 that is not in @xmath547 .",
    "then @xmath539 and @xmath547 are identical except @xmath539 may have extra calls .",
    "hence , by the induction hypothesis for @xmath539 and @xmath547 , @xmath547 is balanced from @xmath95 , @xmath647 and @xmath648    @xmath104 is a call transferring @xmath446 also present in @xmath547 .",
    "then @xmath649 , where @xmath540 and @xmath539 are identical except @xmath539 may have extra calls .",
    "hence , by the induction hypothesis for @xmath539 and @xmath540 , we have @xmath650 in particular , @xmath547 is balanced from @xmath95 . by the induction hypothesis for @xmath539 and @xmath540",
    ", we also have @xmath651 . from this",
    "we get @xmath652    @xmath104 is a return transferring @xmath446 .",
    "then it is also present in @xmath547 , so that @xmath653 , where @xmath539 and @xmath540 are identical except @xmath539 may have extra calls .",
    "then by the induction hypothesis for @xmath539 and @xmath540 , we have : @xmath654 since @xmath655 is balanced from @xmath96 , @xmath656 is defined .",
    "furthermore , by the induction hypothesis for @xmath539 and @xmath540 , we also have @xmath651 .",
    "hence , @xmath657 is defined as well . by proposition",
    "[ prop - delta ] , we then have : @xmath658 in particular , @xmath547 is balanced from @xmath95 . from @xmath651 , it also follows that @xmath659      before delving into the proof of lemma  [ prop : sem : local - global ] , we prove three important lemmas about our semantics that justify its key steps .",
    "the first concerns the evaluation of a call or a return action : intuitively , it says that the evaluation of such an action by the client matches that by the library .",
    "[ lem : preservation ] let @xmath171 be a method specification , @xmath660 states , and @xmath293 an action describing a call to or return from a method specified in @xmath171 such that @xmath661 then for all @xmath662 , @xmath663 if furthermore @xmath664 is defined , then we have @xmath665    consider @xmath666 satisfying the conditions in the lemma .",
    "we show the lemma only for the case when @xmath293 is a call action : for some @xmath667 , we have @xmath668 and @xmath669 .",
    "the proof for the other case is symmetric .    to show the first claim of the lemma , consider @xmath662 such that @xmath670 by the definition of the action evaluation",
    ", there exist @xmath671 such that @xmath672 hence , @xmath673    let us move on to the second claim of the lemma . since @xmath674 , @xmath170 is precise and the @xmath2 operator is cancellative , there exists a unique splitting @xmath675 of @xmath446 such that @xmath676",
    ". let @xmath677 .",
    "then @xmath678 hence , @xmath679    the second lemma describes the decomposition and composition properties of trace evaluation .",
    "[ lem : comp : eval ] consider traces @xmath680 without interface actions such that @xmath681 .",
    "for all states @xmath660 , if @xmath682 then @xmath683 and @xmath684    consider @xmath685 satisfying the assumptions .",
    "we prove the lemma by induction on the length of @xmath125 .",
    "the base case of @xmath125 being the empty sequence is trivial .",
    "now suppose that @xmath686 for some @xmath687 .",
    "then there exist @xmath348 and @xmath395 such that @xmath688 by the assumption of the lemma , we have that @xmath689 hence , by the induction hypothesis , we have that @xmath690 and @xmath691    from it follows that : @xmath692 next , we prove that @xmath693 for the sake of contradiction , suppose this disequality does not hold . because of , there exists @xmath694 such that @xmath695 by , this implies the existence of @xmath696 such that @xmath697 we split cases based on the relationships among @xmath263 , @xmath348 , @xmath318 and @xmath395 .    1 .   if @xmath698 and @xmath699 , then @xmath700 for some @xmath701",
    ". by , @xmath702 ,",
    "so that @xmath703 . hence , by the strong locality of @xmath704 , @xmath705 , so that @xmath706 . but this contradicts .",
    "2 .   if @xmath707 and @xmath708 , then @xmath700 for some @xmath701 .",
    "this case is symmetric to the previous one .",
    "3 .   if @xmath698 and @xmath708 , then @xmath293 is a call or a return action . then , by the definition of evaluation , @xmath709 . this gives the desired contradiction .",
    "the remainder of the proof is again done by a case analysis on the relationships among @xmath263 , @xmath348 , @xmath318 and @xmath395 .",
    "we consider three cases .",
    "\\1 . @xmath698 and @xmath699 . in this case , @xmath710 for some @xmath701 . as shown in @xmath711 , @xmath712 .",
    "pick @xmath694 such that [ alexey1 ] (  ,  ) (_0 * _ 1 ) . by the definition of the trace evaluation and the induction hypothesis in ,",
    "there exist @xmath713 , @xmath714 , @xmath715 and @xmath716 such that [ alexey2 ] (  , ) (  _ 0 *  _ 1 ) (  _ 0 ,  )  _ 0 (  _ 1 ,  )  : _ 1 cover( ,  ,  ) .",
    "then @xmath717 we have @xmath718 , because @xmath719 and @xmath720 .",
    "hence @xmath721 and , furthermore , @xmath722 .",
    "hence , by the strong locality of @xmath704 , there exists @xmath723 such that @xmath724 this implies @xmath725 from what we have shown so far , it follows that @xmath726 thus , [ alexey3 ] ( _ 0 * _ 1 ) \\ { (  , ) _ 0 : _",
    "1}.    to show the other inclusion and the part of the lemma , consider @xmath727 such that @xmath728 then for some @xmath729 we have @xmath730 by the definition of the evaluation function , there exists @xmath723 such that @xmath731 by the induction hypothesis in and , @xmath732 now by the footprint preservation property of @xmath704 , the first conjunct above implies that @xmath733 , which proves @xmath734 . by the strong locality of @xmath704 , @xmath735 from what we have shown above it follows that @xmath736 hence , [ alexey4 ] ( _ 0 * _ 1 ) \\ { (  , ) _ 0 : _ 1}.    \\2 . @xmath707 and @xmath708 .",
    "this case is symmetric to the previous one .",
    "\\3 . @xmath737 and @xmath708 . in this case",
    "@xmath293 is a call to or a return from a method in @xmath171 . as shown in ,",
    "pick @xmath694 such that  ( [ alexey1 ] ) holds . by the definition of evaluation and the induction hypothesis in ,",
    "there exist @xmath713 , @xmath714 , @xmath715 and @xmath716 such that  ( [ alexey2 ] ) holds .",
    "but @xmath738 furthermore , @xmath739 .",
    "hence , by lemma  [ lem : preservation ] and the definition of the evaluation , there exist @xmath740 such that @xmath741 this in turn implies that @xmath742 from what we have shown so far , it follows that @xmath743 thus ,  ( [ alexey3 ] ) holds .    to show the other inclusion and the part of the lemma , consider @xmath744 such that @xmath745 we need to show that @xmath746 in particular , this establishes  ( [ alexey4 ] ) .",
    "since @xmath747 and @xmath748 is a call to or a return from a method in @xmath171 , @xmath749 we now use the induction hypothesis in and and derive that @xmath750 but @xmath751 and @xmath752 .",
    "hence , by lemma  [ lem : preservation ] , @xmath753 by the definition of evaluation , @xmath754 from what we have shown , it follows that @xmath755 as required .",
    "the following lemma shows that the trace - set generation of our semantics also satisfies the decomposition and composition properties .",
    "[ lem : comp : tracesemantics ] @xmath756    let @xmath757\\ { \\sf in}\\ c_1\\parallel{\\ldots}\\parallel c_n ; \\ \\ , { \\mathcal{l}}= \\{m = c_m \\mid m \\in \\{m_1,{\\ldots},m_j\\}\\ } ; \\ \\ ,   c_{{\\sf mgc}}= ( m_1 + { \\ldots } + m_j)^*.\\ ] ]    first , consider @xmath758 . by the definition of the semantics , for some trace @xmath759 , @xmath125 is a prefix of @xmath759 , @xmath760 and all actions in @xmath759 are done by some thread @xmath761 .",
    "then @xmath762 since all actions in @xmath759 are done by some thread @xmath761 , we have @xmath763 hence , @xmath764 since @xmath265 is a prefix of @xmath765 and @xmath266 is a prefix of @xmath766 , this implies @xmath767 furthermore , @xmath768 , as desired .",
    "assume now that @xmath769 then for some traces @xmath348 and @xmath395 , @xmath263 is a prefix of @xmath348 , @xmath318 is a prefix of @xmath395 , and @xmath770 the definition of our semantics in figure  [ fig : trace ] allows us to choose @xmath395 in such a way that for some trace @xmath759 , @xmath125 is a prefix of @xmath759 and @xmath771",
    ". then @xmath772 and @xmath773 .",
    "thus , @xmath774 , which implies @xmath758 , as desired .",
    "[ [ proof - of - lemmapropsemlocal - global . ] ] _ proof of lemma  [ prop : sem : local - global ] . _ + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + +    we first show that @xmath209 is safe for @xmath775 .",
    "pick states @xmath776 such that @xmath777 by lemma  [ lem : comp : tracesemantics ] , there exist traces @xmath778 such that [ alexey10 ] : cover ( , , ) . by our assumptions ,",
    "@xmath202 and @xmath312 are safe for @xmath779 and @xmath362 , respectively .",
    "hence , @xmath720 and @xmath780 . by lemma  [ lem :",
    "comp : eval ] , these disequalities imply that @xmath781 .",
    "we have just shown the safety of @xmath209 for @xmath782 .",
    "next , we show that @xmath783 pick @xmath784",
    ". then for some @xmath660 we have @xmath785 by lemma  [ lem : comp : tracesemantics ] , there are @xmath778 such that  ( [ alexey10 ] ) holds .",
    "we use lemma  [ lem : comp : eval ] and deduce that for some @xmath786 we have @xmath787 furthermore , @xmath788 , @xmath789 and @xmath790 .",
    "hence , @xmath791 as desired .    finally , we prove that @xmath792 pick @xmath793 . by the definition of the @xmath319 operator and our semantics , there exist @xmath794 such that @xmath795 by the definition of our semantics , @xmath796 and @xmath797 . because of this and @xmath798 we have @xmath681 . by lemma  [ lem :",
    "comp : tracesemantics ] , this implies @xmath799 .",
    "also , by lemma  [ lem : comp : eval ] , we have that @xmath800 hence , @xmath801 as desired .",
    "consider @xmath616 .",
    "then there exist @xmath189 and @xmath802 such that @xmath803 .",
    "we show that for some @xmath193 we have @xmath804    we proceed by induction on the length of @xmath408 .",
    "the base case of @xmath805 is trivial .",
    "assume that the above holds for some @xmath806 and consider @xmath807 such that @xmath808 we show that for some @xmath809 we have @xmath810 we consider three cases , depending on the type of the actions @xmath293 and @xmath748 .",
    "@xmath337    @xmath811 .",
    "then @xmath812 . since @xmath617 is safe at @xmath446 , @xmath813",
    "hence , by the strong locality property , we have @xmath814 then @xmath815 for some @xmath816 .",
    "@xmath817 and @xmath818 , where @xmath819 and @xmath820 .",
    "then @xmath821 hence , the required holds for @xmath822 .",
    "@xmath823 and @xmath824 , where @xmath825 and @xmath826 .",
    "then @xmath827 since @xmath617 is safe at @xmath446 , @xmath828 for some @xmath809 , so that @xmath829 by the cancellativity of @xmath2 , this entails @xmath830 we also know that @xmath831 , so that @xmath832 is defined .",
    "hence , @xmath833 .      in the following , we extend the @xmath587 operation to non - interface actions by assuming that it does not change them .",
    "consider @xmath834 satisfying the conditions of the lemma . then @xmath298 is balanced from @xmath623 for @xmath835 , and there exist @xmath38 and @xmath802 such that @xmath836 .",
    "we show that @xmath837 by induction on the length of @xmath408 .",
    "the base case of @xmath838 is trivial .",
    "assume that the above holds for some @xmath839 and consider @xmath840 such that @xmath841 we show that @xmath842 we consider three cases , depending on the type of the actions @xmath293 and @xmath748 .",
    "@xmath337    @xmath811 .",
    "then @xmath843 and @xmath844 .",
    "since @xmath845 by the footprint preservation property , @xmath846 . then by the strong locality property , @xmath847    @xmath817 and @xmath848 , where @xmath819 and @xmath849 .",
    "in this case we have @xmath850 .",
    "since @xmath851 is balanced from @xmath623 , we have @xmath852",
    ". then @xmath853    @xmath823 and @xmath854 , where @xmath825 and @xmath855 . in this case",
    "we have @xmath856 .",
    "we know @xmath857 .",
    "thus , @xmath858 .",
    "since @xmath859 is defined , so is @xmath860",
    "[ cols= \" < , < \" , ]"
  ],
  "abstract_text": [
    "<S> linearizability is a commonly accepted notion of correctness for libraries of concurrent algorithms . </S>",
    "<S> unfortunately , it assumes a complete isolation between a library and its client , with interactions limited to passing values of a given data type . </S>",
    "<S> this is inappropriate for common programming languages , where libraries and their clients can communicate via the heap , transferring the ownership of data structures , and can even run in a shared address space without any memory protection .    in this paper </S>",
    "<S> , we present the first definition of linearizability that lifts this limitation and establish an abstraction theorem : while proving a property of a client of a concurrent library , we can soundly replace the library by its abstract implementation related to the original one by our generalisation of linearizability . </S>",
    "<S> this allows abstracting from the details of the library implementation while reasoning about the client . </S>",
    "<S> we also prove that linearizability with ownership transfer can be derived from the classical one if the library does not access some of data structures transferred to it by the client . </S>"
  ]
}