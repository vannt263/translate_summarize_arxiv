{
  "article_text": [
    "sparse polynomials are a fundamental object in computer algebra .",
    "computer algebra programs including maple , mathematica , sage , and singular use a sparse representation by default for multivariate polynomials , and there has been considerable recent work on how to efficiently store and compute with sparse polynomials @xcite .",
    "however , despite the memory advantage of sparse polynomials , the alternative dense representation is still widely used for an obvious reason : speed .",
    "it is now classical @xcite that two degree-@xmath0 dense polynomials can be multiplied in softly linear time : @xmath1 ring operations , and even better in many cases @xcite . by contrast , two size-@xmath2 sparse polynomials require @xmath3 operations , and this excludes the potentially significant cost of exponent arithmetic .",
    "much of the recent work on sparse arithmetic has focused on `` somewhat dense '' or structured cases , where the sparsity of the product is sub - quadratic @xcite . at the same time , sparse interpolation algorithms , which in the fastest case can learn an unknown @xmath2-sparse polynomial from @xmath4 evaluations , have gained renewed interest @xcite .",
    "most closely related to the current work , @xcite recently presented algorithms to discover the coefficients of a sparse polynomial product , provided a list of the exponents and some preprocessing . in the context of pattern matching problems",
    ", @xcite gave a las vegas algorithm to multiply sparse polynomials with nonnegative integer coefficients whose cost is @xmath5 .",
    "a remaining question is whether output - sensitive sparse multiplication is possible in time comparable to that of dense multiplication .",
    "this paper answers that question , with three provisos : first , our complexity is proportional to the `` structural sparsity '' of the output that accounts for exponent collisions but not coefficient cancellations ; second , our algorithms are randomized and may produce incorrect results with controllably low probability ; and third , we ignore logarithmic factors in the size of the input .    to explain the first proviso , define for a polynomial @xmath6 its _ support _",
    "@xmath7 to be the set of exponents of nonzero terms in @xmath6 .",
    "the _ sparsity _ of @xmath6 , written @xmath8 , is exactly @xmath9 . for two polyomials @xmath6 and @xmath10 , we have @xmath11 .",
    "but in many cases the set of _ possible exponents _",
    "@xmath12 is much smaller than @xmath13 .",
    "this _ structural sparsity _",
    "@xmath14 , is an upper bound on the actual sparsity @xmath15 of the product .",
    "strict inequality @xmath16 occurs only in the presence of _ coefficient cancellations_. part of our algorithm s cost depends only on the actual sparsity , and part depends on the potentially - larger structural sparsity .",
    "our algorithms have not yet been carefully implemented , and we do not claim that they would be faster than the excellent software of @xcite and others for a wide range of practical problems .",
    "however , this complexity improvement indicates that the barriers between sparse and dense arithmetic may be weaker than we once thought , and we hope our work will lead to practical improvements in the near future .",
    "our main algorithm is summarized in theorem  [ thm : main ] . here and throughout",
    ", we rely on a version of `` soft - oh '' notation that also accounts for a bound @xmath17 on the probability of failure : @xmath18 , for any function @xmath19 , where @xmath20 means @xmath21 for some fixed @xmath22 ( * ? ? ?",
    "* see sec .",
    "25.7 ) .",
    "[ thm : main ] given @xmath23 $ ] with degree bound @xmath24 and height bound @xmath25 , and @xmath26 , algorithm [ proc : sparsemulzz ] correctly computes the product @xmath27 with probability exceeding @xmath28 , using worst - case expected @xmath29 bit operations , where @xmath30 and @xmath31 are the actual and structural sparsity of the product , respectively .",
    "our algorithm relies on two subroutines , both of which are based on techniques from sparse interpolation and rely on number - theoretic results on the availability of primes .",
    "the first subroutine [ proc : sumset]@xmath32 computes the _ sumset _ of two sets of integers @xmath33 and @xmath34 , defined as @xmath35 this algorithm , which may be of independent interest , has softly - linear complexity in the size of the output @xmath36 .",
    "the second subroutine [ proc : knownsupp](@xmath37 ) requires a set containing @xmath38 in order to compute @xmath39 in time softly - linear in the input and output sizes .",
    "it is based on an algorithm in @xcite , but is more efficient for large exponents .",
    "the main steps of our multiplication algorithm are :    1 .",
    "use [ proc : sumset ] to compute @xmath40 .",
    "2 .   run [ proc : knownsupp ] with @xmath41 but with smaller coefficients , to discover the true @xmath38 .",
    "3 .   run [ proc : knownsupp ] again , with the smaller exponent set @xmath38 but with the full coefficients .",
    "steps 1 and 2 work with a size-@xmath2 exponent set but with small coefficients , and both contribute @xmath42 to the overall bit complexity . step 3 uses the size-@xmath43 true support but with the full coefficients , and requires @xmath44 bit operations , for a total of @xmath45 .",
    "section  [ sec : prelim ] states our notational conventions and some standard results , and section  [ sec : redexp ] contains the technical number theoretic results on which we base our randomizations .",
    "section  [ sec : basecase ] revisits and adapts our sparse interpolation algorithm from issac 2014 that will be a subroutine for our sumset algorithm , presented in section  [ sec : sumset ] .",
    "our new method to find the coefficients , once the support is known , is presented in section  [ sec : knownsupp ] .",
    "this is then used in concert with our sumset algorithm in section  [ sec : smul ] to describe fully the algorithm of theorem  [ thm : main ] , and also to explain how this can be easily extended to output - sensitive sparse multiplication over @xmath46 $ ] , where @xmath47 is @xmath48 , @xmath49 , or @xmath50 .",
    "we count the cost of our algorithms in terms of bit complexity on a random - access machine .",
    "we state their costs using @xmath51 notation , meaning that our algorithms have a factor @xmath52 in the running time .",
    "we can make @xmath53 by running the entire algorithm with error bound @xmath54 some @xmath55 times , then returning the most frequent result .",
    "our main algorithm depends on an unknown number - theoretic constant , as discussed in section [ sec : redexp ] .",
    "thus we have proven only the _ existence _ of a monte carlo algorithm .",
    "we also discuss how this could be easily handled in practice .",
    "our randomized procedures return either the correct answer ( with controllable probability @xmath28 ) , or an incorrect answer , or the symbol @xmath56 .",
    "whenever a subroutine returns @xmath56 , we assume the calling procedure returns @xmath56 as well .",
    "we let @xmath57 denote a commutative ring with identity . for @xmath58",
    "$ ] we let @xmath59 $ ] denote the ideal generated by @xmath6 . for @xmath60 , @xmath61 ,",
    "we let @xmath62 and @xmath63 denote the integers @xmath64 and @xmath65 respectively , such that @xmath66 . we write",
    "@xmath48 for @xmath67 , typically represented as @xmath68 .    unless otherwise stated we assume @xmath69 $ ] is of the form @xmath70 with coefficients @xmath71 and exponents @xmath72 .",
    "often we assume each @xmath73 and the exponents are sorted @xmath74 , but it is sometimes useful to relax these conditions .",
    "we write @xmath75 and @xmath76 for the sparsity and degree bounds .",
    "when @xmath77 we write @xmath78 for the _ height _ of @xmath6 .",
    "we also use the norm @xmath79 .    more generally , we consider multivariate laurent polynomials in the case @xmath77 , the _ sparse representation _ of @xmath6 consists of a tuple @xmath80 , followed by a list of @xmath43 tuples @xmath81 , where each @xmath82 is stored using @xmath83 bits and each @xmath84 is stored using @xmath85 bits . when @xmath57 is instead a finite ring , @xmath86 is omitted and each @xmath82",
    "is stored using @xmath87 bits .    when multiplying @xmath23 $ ] , we assume shared bounds @xmath86 and",
    "@xmath0 so that total input / output size is @xmath88 given that @xmath89 .",
    "the _ dense representation _ of an @xmath90-variate polynomial @xmath6 is an @xmath90-dimensional array of @xmath91 coefficients , where exponents are implicitly stored as array indices . in the case",
    "that @xmath77 with bound @xmath86 as above , this requires @xmath92 bits .",
    "the terms `` sparse polynomial '' and `` dense polynomial '' refer only to the choice of representation , and not to the relative number of nonzero coefficients .",
    "typically , we assume @xmath6 is sparse and reserve @xmath93 to indicate a dense polynomial .",
    "converting between the sparse and dense representations has softly linear cost in the combined input / output size .",
    "when computing a sumset @xmath94 , we assume that every integer in @xmath95 or @xmath96 is represented using @xmath85 bits , where @xmath97 .",
    "we cite the following results from integer and polynomial arithmetic , which we use throughout .",
    "assume @xmath98 $ ] as in with bounds @xmath0 , @xmath43 , and @xmath86 as described above .",
    "our algorithm performs arithmetic on modular images of @xmath6 . for @xmath99",
    "$ ] , we represent @xmath100/{\\langle}x^p-1 { \\rangle}$ ] by the remainder from dividing @xmath101 by @xmath102 .",
    "note we treat @xmath103 and @xmath104 as elements of @xmath105 $ ] and @xmath105/{\\langle}x^p-1{\\rangle}$ ] respectively . to reduce a sparse polynomial @xmath106",
    ", we reduce each exponent modulo @xmath107 , and then add like - degree terms .",
    "by fact [ fact : int_arithmetic ] , we have :    [ cor : modxp_m ] given any @xmath99 $ ] , we can compute @xmath108 using @xmath109 bit operations .",
    "we first recall how to choose a random prime number .",
    "[ fact : rosser ] if @xmath110 , then the number of primes in @xmath111 $ ] is at least @xmath112 .",
    "we test if @xmath107 is prime in @xmath113 time via the method in @xcite .",
    "this test and fact [ fact : rosser ] lead to procedure [ proc : getprime ] .",
    "@xmath56    [ lem : getprime_cost ] [ proc : getprime](@xmath114 ) works as stated and has bit complexity @xmath115    the stated cost follows from fast primality testing due to @xcite .",
    "the probability that any chosen @xmath107 is prime is at least @xmath116 , from fact  [ fact : rosser ] .",
    "therefore , using the fact that @xmath117 for any nonzero @xmath118 , the probability that none of the chosen @xmath107 are prime is at most @xmath119 as desired .",
    "it is frequently useful to choose a random prime that divides very few of the integers in some unknown set @xmath120 .",
    "if a fraction of @xmath121 integers in @xmath122 do not vanish modulo @xmath107 , then we call @xmath107 a _ @xmath121-vanish - prime _ for @xmath122 .",
    "we call a @xmath123-vanish - prime for @xmath122 a _ good vanish - prime_. procedure [ proc : vanp ] shows how to choose a random @xmath121-vanish - prime .",
    "@xmath124 [ proc : getprime](@xmath125 , @xmath126 )    [ lem : vanp ] procedure [ proc : vanp ] works as stated to produce a @xmath121-vanish - prime @xmath107 satisfying @xmath127 and has bit complexity @xmath128 .",
    "let @xmath122 be any subset of integers with @xmath129 and @xmath130 .",
    "write @xmath131 , and write @xmath132 for the number of `` bad primes '' for which more than @xmath133 elements of @xmath122 vanish modulo @xmath107 .",
    "since each @xmath134 , this means that @xmath135 , and because @xmath136 , @xmath137 is an upper bound on the number of bad primes .",
    "if @xmath138 is very small , we instead use a similar argument to say that the number of primes for which _ any _ element of @xmath122 vanishes is at most @xmath139 .",
    "then fact  [ fact : rosser ] guarantees the prevalence of bad primes among all primes in @xmath140 is at most @xmath126 , so the probability of getting a bad prime , or of erroneously returning a composite @xmath107 , is bounded by @xmath17 .",
    "a closely related problem is to choose @xmath107 so that most integers in a set @xmath122 are unique modulo @xmath107 .",
    "we say that @xmath141 _ collides _ modulo @xmath107 if there exists @xmath142 with @xmath143 .",
    "we say @xmath107 is a _ @xmath121-difference - prime for @xmath122 _ if the fraction of integers in @xmath122 which do not collide modulo @xmath107 is at least @xmath121 .",
    "a 1-difference - prime is called a _ good difference - prime for  _ .",
    "procedure [ proc : diffp ] shows how to compute difference - primes , conditioned on the _ diameter _ of the unknown set @xmath122 : @xmath144    [ lem : diffp ] procedure [ proc : diffp ] has bit complexity @xmath128 and works as stated to produce a @xmath121-difference - prime @xmath107 satisfying @xmath145 and @xmath146    let @xmath122 be any set as described .",
    "an element @xmath141 collides modulo @xmath107 iff the product of differences @xmath147 vanishes modulo @xmath107 .",
    "if @xmath148 this can never happen . otherwise , as each such product is at most @xmath149 , the result follows from the lemma  [ lem : vanp ] , setting the @xmath0 of the lemma to @xmath150 .",
    "@xmath151    our algorithms often perform arithmetic modulo @xmath102 .",
    "similar to the notion of collisions above for a set of integers modulo @xmath107 , we say two distinct terms @xmath152 and @xmath153 of @xmath69 $ ] _ collide _ modulo @xmath102 if @xmath154 .    essentially , reduction modulo @xmath102 `` hashes '' exponent @xmath155 to @xmath156 .",
    "if @xmath107 is a good difference - prime for @xmath7 and @xmath157 is a good vanish - prime for the coefficients of @xmath6 , then @xmath158 with coefficients reduced modulo @xmath157 has the same sparsity as @xmath6 itself .",
    "sometimes we implicitly reduce exponents modulo @xmath107 by evaluating at @xmath107th roots of unity . in such cases we need to construct primes @xmath157 such that @xmath159 , and to find @xmath107th roots of unity modulo each @xmath157 .    in principle , this procedure is no different than the previous ones , as there is ample practical and theoretical evidence to suggest that the prevalence of primes in arithmetic progressions without common divisors is roughly the same as their prevalence over the integers in general .",
    "however , the closest to fact  [ fact : rosser ] that we can get here is as follows , which is a special case of lemma  7 in @xcite .",
    "[ lem : arithprog ] there exists an absolute constant @xmath160 such that , for all @xmath161 , and for all but at most @xmath162 primes @xmath107 in the range @xmath163 $ ] , there are at least @xmath164 primes @xmath157 in the range @xmath165 $ ] such that @xmath159 .",
    "set @xmath166 , which means @xmath167 .",
    "fixing @xmath168 , and for any @xmath169 , lemma  7 in @xcite guarantees the existence of positive constants @xmath170 and @xmath171 such that the following holds : for all @xmath172 , and for all but @xmath173 integers @xmath174 $ ] , there are at least @xmath175 primes @xmath157 in the range @xmath176 $ ] such that @xmath177 , where @xmath178 is the euler totient function .    setting @xmath179 , and letting @xmath180 , @xmath181 , and @xmath182 , the statement of our lemma holds because @xmath183 thus @xmath184    @xmath185 @xmath186 @xmath187 @xmath56    lemma  [ lem : arithprog ] forms the basis for algorithm  [ proc : getpqw ] , where we assume that the constant @xmath160 is given .",
    "since this constant has not actually been computed , a reasonable strategy would be to choose some small `` guess '' for @xmath160 and run the algorithm until it does not report failure .",
    "if the algorithm fails , it could be due to the random prime @xmath107 being an `` exception '' in lemma  [ lem : arithprog ] , or due to unlucky guesses for the primitive roots @xmath188 , or due to the guessed constant @xmath160 being too small . because our primality tests are deterministic , failure due to @xmath160 being too small is detectable by the algorithm returning @xmath56 .",
    "we state the running time and correctness , assuming @xmath160 is sufficiently large , as follows .",
    "[ lem : getpqwcost ] procedure [ proc : getpqw ] has worst - case bit complexity with probability at least @xmath28 , it returns a good difference - prime @xmath107 for @xmath6 , primes @xmath189 such that @xmath190 , and @xmath107th primitive roots modulo each @xmath191 , @xmath192 .",
    "the lower bound @xmath193 guarantees that there are sufficiently many even integers in the range @xmath194 $ ] in order for step  [ getpqw : choosea ] to be valid , since for any @xmath195 , we have @xmath196 .    for the running time , the outer loop does not affect the complexity in our notation because @xmath197 .",
    "observe also that @xmath198 the running time is dominated by the aks primality tests in the inner loop , which are performed @xmath199 times , each at cost @xmath200 , giving the stated worst - case bit complexity .",
    "all of the checks for primality of @xmath107 and @xmath191 s , as well as the test that each @xmath201 is a @xmath107th primitive root of unity modulo @xmath191 , are deterministic .",
    "therefore the only possibility that the algorithm returns an incorrect result other than @xmath56 is the probability that @xmath107 is not a good difference - prime for @xmath7 . according to the proof of lemma  [ lem : diffp ] , the condition @xmath202 , and using the union bound over all outer loop iterations , the probability that _ any _ of the chosen @xmath107 s is not a good difference - prime is less than @xmath126 .    consider next a single iteration of the outer loop .",
    "this will produce a valid output unless insufficiently many good @xmath191 s and @xmath201 s are found for that choice of @xmath107 .",
    "from fact  [ fact : rosser ] and lemma  [ lem : arithprog ] , the probability that @xmath107 is an exception to the lemma is at most @xmath203 , which is less than @xmath204 from the bound @xmath205 .",
    "if @xmath107 is not an exception , then lemma  [ lem : arithprog ] tells us that the probability of each @xmath157 being prime is at least @xmath206 .",
    "when @xmath157 is prime , since prime @xmath107 divides @xmath207 , the probability that each @xmath208 is a @xmath107-pru in @xmath209 is @xmath210 , easily making the total probability of successfully adding to @xmath211 and @xmath212 at each loop iteration at least @xmath213 .",
    "let @xmath214 be the size of @xmath33 . by hoeffding s inequality ( @xcite , thm .",
    "1 ) , the probability that fewer than @xmath215 integers are added to @xmath211 after all iterations of the inner loop is at most @xmath216 where the last inequality holds because @xmath217 .    therefore , with probability at least @xmath218 , and using again @xmath219 , at least @xmath220 integers are added to @xmath211 each time through the inner loop . since each @xmath221",
    ", this means @xmath222 , and the algorithm will return on step  [ getpqw : checkret ] .",
    "combining with the probability that @xmath107 is an exception , we conclude that the probability the algorithm does _ not _ return in each iteration of the outer loop is at most @xmath223 .",
    "as this is repeated @xmath224 times , the probability is less than @xmath126 that the algorithm returns @xmath56 . using the union bound with the probability that any @xmath107 is not a good difference - prime",
    ", we have the overall failure probability less than @xmath17 .",
    "let @xmath225 $ ] be sparse polynomials with @xmath226 and @xmath227 . the subroutine [ proc : sumset ] computes @xmath40 by first reducing the degrees and heights of the input polynomials and then multiplying them .",
    "however , it can not perform the multiplication using a recursive call to [ proc : sparsemulzz ] because the degrees are never reduced small enough to allow the use of dense arithmetic in a base case .",
    "instead , we present here a `` base case '' algorithm which , given @xmath6 , @xmath10 , and a bound @xmath228 , computes @xmath39 , in time softly linear in @xmath229 , and @xmath230 . any algorithm with such running time suffices ; we will use our own from @xcite , which is a monte carlo sparse interpolation algorithm for univariate polynomials over finite fields .    to adapt @xcite for multiplication over @xmath231 $ ]",
    ", we first choose a `` large prime '' @xmath232 and treat @xmath233 and their product @xmath27 as polynomials over @xmath234 .",
    "this size of @xmath157 ensures that no extension fields are necessary .",
    "the subroutine [ proc : bb ] specifies how the unknown polynomial @xmath235 $ ] will be provided to the algorithm .",
    "it exactly matches the sorts of black - box evaluations that @xcite requires .",
    "the entire procedure is stated as [ proc : sm1 ] .",
    "@xmath236 @xmath237 via dense arithmetic sparse representation of @xmath238    [ lem : bb ] the algorithm [ proc : bb ] works correctly and uses @xmath239 bit operations .",
    "correctness is clear . to compute @xmath240 ,",
    "we replace every term @xmath152 of @xmath6 and @xmath10 with @xmath241 .",
    "this costs @xmath242 by binary powering . reducing modulo @xmath243 costs @xmath244 by corollary [ cor : modxp_m ] .",
    "dense arithmetic costs @xmath245 bit operations by fact [ fact : dense_arithmetic ] . summing these costs",
    "yields @xmath246 .",
    "@xmath247[proc : getprime]@xmath248 call procedure majorityvotesparseinterpolate from @xcite , with coefficient field @xmath209 , sparsity bound @xmath43 , degree bound @xmath249 , error bound @xmath250 , and black box [ proc : bb]@xmath251 .",
    "the algorithm [ proc : sm1 ] correctly returns the product @xmath27 with probability at least @xmath28 , and has bit complexity @xmath252    in order to use [ proc : bb ] in the algorithm from @xcite , we simply replace the straight - line program evaluation on the first line of procedure computeimage with our procedure [ proc : bb ] .",
    "again , note that as the prime @xmath157 was chosen with @xmath253 , the majorityvotesparseinterpolate algorithm does not need to work over any extension fields .",
    "the correctness is guaranteed by the previous lemma , as well as theorem 1.1 in @xcite .",
    "for the bit complexity , in section 7 of @xcite , we see that the cost is dominated by @xmath254 calls to the black box evaluation function , each of which is supplied @xmath255 , and @xmath256 . applying the bit complexity of lemma [ lem : bb ]",
    "gives the stated result .",
    "let @xmath257 be nonempty , @xmath258 , and @xmath259 throughout this section .",
    "we prove as follows :    [ thm : supp ] procedure @xmath260 has bit complexity @xmath261 and produces @xmath36 with probability at least @xmath28 .",
    "we compute the sumset @xmath36 as @xmath262 , @xmath263 $ ] , where @xmath264 and @xmath265 . here",
    "@xmath266 has exponents in @xmath267 and @xmath268 .",
    "thus it suffices to construct the exponents of @xmath266 modulo @xmath269 .",
    "moreover , we have @xmath270 , and that @xmath271      we first show how to compute a tighter upper bound on the true value of @xmath272 . to this end ,",
    "let @xmath145 be a good difference - prime for @xmath262 , using the naive bound @xmath273 from , and define the @xmath274 , where @xmath275 $ ] are defined by @xmath276 then @xmath277 and each term @xmath152 of @xmath266 corresponds to either one or two terms in @xmath278 , of degrees @xmath156 and @xmath279 . therefore @xmath280    we will compute an approximation @xmath281 such that @xmath282 , and therefore @xmath283 . to this end",
    "we present a test that , given @xmath284 , always accepts if @xmath285 and probably rejects if @xmath286 .",
    "we do this for @xmath284 initially @xmath287 , doubling whenever the test rejects .",
    "given the current estimate @xmath284 , we next choose a ( 1/2)-difference - prime @xmath157 for the support of any @xmath288-sparse polynomial with degree @xmath289 , and compute @xmath290 .",
    "we work modulo @xmath291 , such that none of the coefficients of @xmath292 vanish modulo @xmath293 .",
    "if @xmath278 is @xmath284-sparse then @xmath292 is as well .",
    "if @xmath278 has @xmath288 terms then , as fewer than @xmath284 terms of @xmath278 are in collisions , @xmath292 is _ not _ @xmath284-sparse . as no terms of @xmath278 vanish modulo @xmath293 , additional terms in @xmath278 can only increase @xmath294 .",
    "we choose @xmath157 so that the test is correct with probability at least @xmath295 . by iterating @xmath296 times , by hoeffding s inequality ,",
    "the probability is at least @xmath297 that the test runs correctly in at least half of the iterations . as @xmath298",
    ", it suffices that the test is correct @xmath299 times .",
    "the [ proc : sumset ] procedure performs this test on lines [ proc : ss : size0][proc : ss : sizen ] . by corollary [ cor : modxp_m ] the respective costs of constructing @xmath300 and @xmath301 are @xmath302 and @xmath303 , and similarly for @xmath304 .",
    "the cost of the dense arithmetic here is @xmath305 .",
    "given that @xmath306 , the total bit - cost of this part is @xmath261 .",
    "armed with the bound @xmath307 , we aim to compute @xmath27 .",
    "our approach is to compute images @xmath308 for an integer @xmath309 .",
    "since the coefficients of @xmath310 are scaled by powers of @xmath311 , a single term @xmath312 in the original polynomial @xmath266 becomes @xmath313 in @xmath278 and @xmath314 in @xmath310 , and if they are uncollided we can discover @xmath315 by computing their quotient .",
    "modulo @xmath316 , this quotient @xmath315 is simply @xmath317 , from which we can obtain the exponent @xmath318 .",
    "this idea is similar to the `` coefficient ratios '' technique suggested by @xcite , but working modulo @xmath316 allows us to avoid costly discrete logarithms .",
    "procedure [ proc : sumset ] contains the complete description .",
    "@xmath319[proc : diffp]@xmath320 @xmath321    @xmath322 [ proc : ss : size0 ]    @xmath323 @xmath324 @xmath325[proc : sm1]@xmath326 @xmath327[proc : sm1]@xmath328    @xmath329 empty list of integers @xmath122    [ proc : sumset ] has four steps that are probabilistic : choosing a good difference - prime @xmath107 , estimating the sumset size @xmath259 , and constructing @xmath278 and @xmath310 . as each is set to fail with probability less than @xmath330 , [ proc : sumset ] succeeds with probability at least @xmath28 .",
    "we now analyze the total cost of this algorithm .",
    "[ proc : diffp ] produces @xmath107 of size @xmath331 . constructing @xmath332 at the beginning , and the reduction of @xmath333 modulo @xmath334 at the end , both cost @xmath261 bit operations .",
    "the search for @xmath284 costs @xmath261 from the previous section . finally , as @xmath335 , @xmath336 , and similarly for @xmath337 , @xmath338 , and @xmath339 , the sparse multiplications due to [ proc : sm1 ] also costs @xmath340 bit operations .",
    "these dominate the complexity as stated in theorem  [ thm : supp ] .",
    "we turn now to the problem of multiplying sparse @xmath341 $ ] , provided some @xmath342 .",
    "this algorithm is used twice in our overall multiplication algorithm : first with large @xmath343 but small coefficients , then with the actual support @xmath344 but full - size coefficients .",
    "[ thm : knownsupp ] given @xmath345 $ ] and a set @xmath346 such that @xmath347 , the product @xmath39 can be computed in time @xmath348 where @xmath349 and @xmath24 .",
    "this is @xmath51-optimal , as it matches the bit - size of the inputs .",
    "our algorithm requires a small randomly - selected good difference - prime @xmath107 with @xmath350 bits , and a series of pairs @xmath351 , where each @xmath157 is a slightly larger prime with @xmath352 bits , and @xmath353 is an order-@xmath107 element in @xmath209 .",
    "these numbers are provided by [ proc : getpqw ] ( sec .",
    "[ sec : redexp ] ) .",
    "our algorithm works by first reducing the exponents modulo @xmath107 , then repeatedly reducing the coefficients modulo @xmath157 and performing evaluation and interpolation at powers of @xmath353 .",
    "this inner loop follows exactly the algorithm of @xcite and @xcite for applying a transposed vandermonde matrix and its inverse .",
    "since @xmath107 is a good difference - prime for the support of the product , there are no collisions and this gives us each coefficient modulo @xmath157 .",
    "the process is then repeated @xmath354 times in order to recover the full coefficients via chinese remaindering .      without affecting the complexity",
    ", we may assume that @xmath122 contains the support of the inputs too , i.e. , @xmath7 and @xmath355 .",
    "we also assume that @xmath356 , such that no @xmath357 is too large to be an exponent of @xmath39 . under these assumptions , and writing @xmath358 , the stated complexity of our algorithm is simply @xmath359 .",
    "the problem of computing the coefficients of a sparse product , once the exponents of the product are given , has been recently and extensively investigated by van der hoeven and lecerf , where they present an algorithm whose bit complexity ( in our notation ) is @xmath360 ( @xcite , corollary 5 ) .",
    "as @xmath361 , the algorithm here saves a factor of at most @xmath362 in comparison , which could be substantial if the exponents are very large .",
    "their algorithm is more efficient if the support superset @xmath122 is _ fixed _ , in which case they can move the most expensive parts into precomputation and compute the result in the same soft - oh time as our approach , @xmath44 .",
    "furthermore , the support bit - length @xmath363 is at most @xmath364 , but could be as small as @xmath365 , for example if the support contains only a single large exponent . in such cases our savings",
    "is only on the order of @xmath366 .      applying transposed vandermonde systems , and their inverses , is an important subroutine in sparse interpolation algorithms , and efficient algorithms are discussed in detail by @xcite and @xcite .",
    "we restate the general idea here and refer the reader to those papers for more details .",
    "if @xmath93 is a dense polynomial , it is well known that applying the vandermonde matrix @xmath367 to a vector of coefficients from @xmath93 corresponds to evaluating @xmath93 at the points @xmath368 . applying the inverse vandermonde matrix corresponds to interpolating @xmath93 from its evaluations at those points .",
    "the product tree method can perform both of these using @xmath369 field operations ( @xcite , chapter 10 ) .",
    "if @xmath6 is instead a sparse polynomial @xmath370 , evaluating @xmath6 at consecutive powers of a single high - order element @xmath353 corresponds to multiplication with the transposed vandermonde matrix : @xmath371    the transposition principle tells us it is possible to compute the maps @xmath372 and @xmath373 in essentially the same time as dense evaluation and interpolation . in particular , if the coefficients @xmath82 are in the modular ring @xmath209 , then the transposed vandermonde map and its inverse can be computed using @xmath374 bit operations @xcite .",
    "@xmath375 @xmath376[proc : getpqw]@xmath377 [ proc : ks : choosep ] @xmath378 [ proc : ks : reduce ] @xmath379 list of @xmath43 empty lists of integers @xmath380    procedure  [ proc : knownsupp ] works as stated when @xmath342 . in any case",
    "it has bit - complexity @xmath381    we first analyze the probability of failure when @xmath342 .",
    "the randomization is in the choices of @xmath107 , @xmath157 , and @xmath353 ; problems can occur if these lack the required properties .",
    "if @xmath107 is a good difference - prime for @xmath38 , then by definition there will be no collisions in @xmath382 .",
    "furthermore , if @xmath353 is a @xmath107th root of unity modulo @xmath157 , then there are no collisions among the values @xmath383 , so @xmath384 is invertible modulo @xmath157 .",
    "algorithm [ proc : getpqw ] ensures this is the case with high probability , and if so the algorithm here faithfully computes each coefficient @xmath385 modulo @xmath157 .",
    "conversely , if there are no collisions in @xmath382 , and if no zero divisors modulo @xmath157 are encountered in the application of the vandermonde matrix and its inverse , then the algorithm correctly computes then values @xmath386 , even if @xmath107 is not prime or some @xmath387 is not actually a @xmath107th root of unity .",
    "therefore all failures in choosing tuples @xmath388 are either detected by the algorithm or do not affect its correctness . since that is the only randomized step ,",
    "we conclude that the entire algorithm is correct whenever the input exponent set @xmath122 contains the support of the product .    for the complexity analysis",
    "first define @xmath389 .",
    "step  [ proc : ks : choosep ] costs @xmath390 bit operations by lemma  [ lem : getpqwcost ] . reducing each exponent",
    "@xmath391 modulo @xmath107 , on step  [ proc : ks : reduce ] , can be done for a total of @xmath392 bit operations .",
    "now we examine the cost of the for loop that begins on step  [ proc : ks : eachq ] . as",
    "the exponents are now all less than @xmath107 , computing each @xmath393 on step  [ proc : ks : binpow ] requires only @xmath352 operations modulo @xmath157 , for a total of @xmath394 , which is @xmath395 bit operations . from before we know that applying the transposed vandermonde matrix and its inverse takes @xmath396 , or @xmath395 bit operations .    because @xmath397 , the loop on step  [ proc : ks : eachq ] repeats @xmath354 times , for a total cost of @xmath398 bit operations .",
    "this also bounds the cost of the chinese remaindering in the final loop .",
    "the complete multiplication algorithm over @xmath231 $ ] that was outlined in the introduction is presented as [ proc : sparsemulzz ] .",
    "@xmath399[proc : sumset]@xmath400 [ proc : smz : sumset ] @xmath401 [ proc : smz : height ]",
    "@xmath402[proc : vanp]@xmath403",
    "@xmath404[proc : knownsupp]@xmath405 [ proc : smz : ks1 ] @xmath406 [ proc : knownsupp]@xmath407    unless failure occurs , we have @xmath408 . every coefficient in @xmath266",
    "is a sum of products of coefficients in @xmath6 and @xmath10 , so the value @xmath409 computed on step [ proc : smz : height ] is an upper bound on @xmath410 , and @xmath107 is a good vanish - prime for @xmath266 .",
    "thus @xmath411 , so the final step correctly computes the product @xmath39 .    by the union bound , lemma [ lem : vanp ] and theorems [ thm : supp ] and [ thm : knownsupp ] ,",
    "the probability of failure is less than @xmath17 .    writing @xmath14 and @xmath15 , we see that @xmath412 , thus steps [ proc : smz : sumset ] and [ proc : smz : ks1 ] contribute @xmath42 to the overall cost , whereas the last step costs @xmath413 bit operations . as @xmath414 ,",
    "the total bit complexity is @xmath45 , as required .",
    "we now consider extensions of this algorithm to positive and negative exponents ( laurent polynomials ) , multiple variables , and other common coefficient rings , using kronecker substitution .",
    "this is stated in the following theorem .",
    "thmextensions let @xmath415 $ ] be sparse laurent polynomials over @xmath47 , where @xmath416 , @xmath48 , @xmath417 , or @xmath49 .",
    "the product @xmath39 can be computed using @xmath418 bit operations , where @xmath31 is the structural sparsity of the product , @xmath419 , and @xmath96 is the largest bit - length of any coefficient in the input or output .",
    "write the output polynomial @xmath27 as @xmath420 where each @xmath71 and each @xmath84 satisfies @xmath421 .",
    "we first apply the kronecker substitution , providing an easily - invertible map between @xmath46 $ ] and @xmath422 $ ] : @xmath423 for @xmath424 .",
    "this increases the degree to @xmath91 , such that the logarithm of this degree @xmath425 , matching the exponent bit - size in the multivariate representation .",
    "the algorithm [ proc : sumset ] already handles negative exponents ( i.e. , laurent polynomials ) explicitly .",
    "the other primary subroutine to [ proc : sparsemulzz ] is [ proc : knownsupp ] , which only uses the exponents in the set @xmath382 , which are reduced modulo @xmath107 and therefore cause no difficulty if they are negative . thus the multiplication algorithms handle univariate laurent polynomials without any changes .",
    "to extend the multiplication algorithm and it subroutines beyond @xmath416 , we use that our algorithm is also softly - linear in the input _",
    "heights_. this allows us to adapt to many coefficient domain that provides a natural mapping to the integers , and to preserve softly - linear time if that mapping provides only a softly - linear increase in size .    for a modular ring @xmath426",
    ", we can trivially treat the inputs as actual integers , then reduce modulo @xmath293 after multiplying .",
    "for a finite field @xmath427 , elements are typically represented as polynomials over @xmath428 $ ] modulo a degree-@xmath429 irreducible polynomial , so these coefficients can be converted to integers using a low - degree kronecker substitution . for the rationals @xmath430 , we might choose a prime @xmath157 larger than the product of the largest numerator and denominator in the output , multiply modulo @xmath157 , then use rational reconstruction to recover the actual coefficients .",
    "in all the above cases , there is growth in the bit - length of coefficients , but only in poly - logarithmic terms of input and output size , therefore not affecting the soft - oh complexity .",
    "the only downside is that we are no longer able to split the cost neatly between @xmath431 and @xmath432 because the unreduced integer polynomial product might have nonzero coefficients which are really zeros in @xmath433 .",
    "we thank mark giesbrecht for helpful discussions on the development of this paper ( and much more ) .",
    "matthew  t. comer , erich  l. kaltofen , and clment pernet .",
    "sparse polynomial interpolation and berlekamp / massey algorithms that correct outlier errors in input values . in _ proc .",
    "issac 12 _ , pages 138145 .",
    "acm , 2012 .",
    "doi : 10.1145/2442829.2442852 .",
    "mickal gastineau and jacques laskar .",
    "highly scalable multiplication for distributed sparse multivariate polynomials on many - core systems . in _ proc .",
    "casc 2013 _ , pages 100115 , new york , 2013 .",
    "springer - verlag .",
    "doi : 10.1007/978 - 3 - 319 - 02297 - 0_8 .",
    "erich kaltofen and lakshman yagati .",
    "improved sparse multivariate polynomial interpolation algorithms . in _ symbolic and algebraic computation _ ,",
    "volume 358 of _ lect .",
    "notes comput .",
    "_ , pages 467474 .",
    "springer berlin / heidelberg , 1989 .",
    "doi : 10.1007/3 - 540 - 51084 - 2_44 ."
  ],
  "abstract_text": [
    "<S> we present randomized algorithms to compute the sumset ( minkowski sum ) of two integer sets , and to multiply two univariate integer polynomials given by sparse representations . </S>",
    "<S> our algorithm for sumset has cost softly linear in the combined size of the inputs and output . </S>",
    "<S> this is used as part of our sparse multiplication algorithm , whose cost is softly linear in the combined size of the inputs , output , and the sumset of the supports of the inputs . as a subroutine , we present a new method for computing the coefficients of a sparse polynomial , given a set containing its support . </S>",
    "<S> our multiplication algorithm extends to multivariate laurent polynomials over finite fields and rational numbers . </S>",
    "<S> our techniques are based on sparse interpolation algorithms and results from analytic number theory . </S>"
  ]
}