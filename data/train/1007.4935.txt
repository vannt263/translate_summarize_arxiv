{
  "article_text": [
    "the optimal base problem is all about finding an efficient representation for a given collection of positive integers .",
    "one measure for the efficiency of such a representation is the sum of the digits of the numbers .",
    "consider for example the decimal numbers @xmath1 .",
    "the sum of their digits is 25 .",
    "taking binary representation we have @xmath2 @xmath3 and the sum of digits is 13 , which is smaller .",
    "taking ternary representation gives @xmath4 with an even smaller sum of digits , 12 .",
    "considering the _ mixed radix _",
    "base @xmath5 , the numbers are represented as @xmath6 @xmath7 and the sum of the digits is 9 .",
    "the optimal base problem is to find a ( possibly mixed radix ) base for a given sequence of numbers to minimize the size of the representation of the numbers . when measuring size as `` sum of digits '' , the base @xmath8 is indeed optimal for the numbers of @xmath9 . in this paper",
    "we present the optimal base problem and illustrate why it is relevant to the encoding of pseudo - boolean constraints to sat .",
    "we also present an algorithm and show that our implementation is superior to current implementations .",
    "pseudo - boolean constraints take the form @xmath10 , where @xmath11 are integer coefficients , @xmath12 are boolean literals ( i.e. , boolean variables or their negation ) , and @xmath13 is an integer .",
    "we assume that constraints are in pseudo - boolean normal form  @xcite , that is , the coefficients @xmath14 and @xmath13 are always positive and boolean variables occur at most once in @xmath15 .",
    "pseudo - boolean constraints are well studied and arise in many different contexts , for example in verification @xcite and in operations research @xcite .",
    "typically we are interested in the satisfiability of a conjunction of pseudo - boolean constraints .",
    "since 2005 there is a series of pseudo - boolean evaluations @xcite which aim to assess the state of the art in the field of pseudo - boolean solvers .",
    "we adopt these competition problems as a benchmark for the techniques proposed in this paper .",
    "pseudo - boolean constraint satisfaction problems are often reduced to sat .",
    "many works describe techniques to encode these constraints to propositional formulas @xcite .",
    "the pseudo - boolean solver minisat@xmath0  ( @xcite , cf.http://minisat.se ) chooses between three techniques to generate sat encodings for pseudo - boolean constraints .",
    "these convert the constraint to : ( a ) a bdd structure , ( b ) a network of sorters , and ( c ) a network of ( binary ) adders .",
    "the network of adders is the most concise encoding , but it has the weakest propagation properties and often leads to higher sat solving times than the bdd based encoding , which , on the other hand , generates the largest encoding .",
    "the encoding based on sorting networks is often the one applied and is the one we consider in this paper .",
    "r42 mm    @xmath16    to demonstrate how sorters can be used to translate pseudo - boolean constraints , consider the constraint @xmath17 where the sum of the coefficients is 8 . on the right , we illustrate an @xmath18 sorter where @xmath19 are each fed into a single input , @xmath20 into two of the inputs , and @xmath21 into three of the inputs .",
    "the outputs are @xmath22 .",
    "first , we represent the sorting network as a boolean formula , @xmath23 , which in general , for @xmath24 inputs , will be of size @xmath25 @xcite .",
    "then , to assert @xmath26 we take the conjunction of @xmath23 with the formula @xmath27 .",
    "but what happens if the coefficients in a constraint are larger than in this example ?",
    "how should we encode @xmath28 ?",
    "how should we handle very large coefficients ( larger than 1,000,000 ) ? to this end , the authors in  @xcite generalize the above idea and propose to decompose the constraint into a number of interconnected sorting networks .",
    "each sorter represents a digit in a mixed radix base .",
    "this construction is governed by the choice of a suitable mixed radix base and the objective is to find a base which minimizes the size of the sorting networks . here",
    "the optimal base problem comes in , as the size of the networks is directly related to the size of the representation of the coefficients .",
    "we consider the sum of the digits ( of coefficients ) and other measures for the size of the representations and study their influence on the quality of the encoding .    in minisat@xmath0  the search for an optimal base",
    "is performed using a brute force algorithm and the resulting base is constructed from prime numbers up to 17 . the starting point for this paper",
    "is the following remark from @xcite ( footnote 8) :    _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ this is an ad - hoc solution that should be improved in the future .",
    "finding the optimal base is a challenging optimization problem in its own right .",
    "_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _    in this paper we take the challenge and present an algorithm which scales to find an optimal base consisting of elements with values up to 1,000,000 .",
    "we illustrate that in many cases finding a better base leads also to better sat solving time .",
    "section  [ section : obp ] provides preliminary definitions and formalizes the optimal base problem .",
    "section  [ sec : encoding ] describes how minisat@xmath0decomposes a pseudo - boolean constraint with respect to a given mixed radix base to generate a corresponding propositional encoding , so that the constraint has a solution precisely when the encoding has a model .",
    "section  [ section:4 ] is about ( three ) alternative measures with respect to which an optimal base can be found .",
    "sections  [ sec : ob1][sec : ob3 ] introduce our algorithm based on classic ai search methods ( such as cost underapproximation ) in three steps : heuristic pruning , best - first branch and bound , and base abstraction .",
    "sections  [ sec : exp ] and [ relwork ] present an experimental evaluation and some related work . section  [ sec : conc ] concludes .",
    "proofs are given in the appendix .",
    "in the classic base @xmath29 radix system , positive integers are represented as finite sequences of digits @xmath30 where for each digit @xmath31 , and for the most significant digit , @xmath32 .",
    "the integer value associated with @xmath33 is @xmath34 .",
    "a mixed radix system is a generalization where a base is an infinite radix sequence @xmath35 of integers where for each radix , @xmath36 and for each digit , @xmath37 .",
    "the integer value associated with @xmath33 is @xmath38 where @xmath39 and for @xmath40 , @xmath41 .",
    "the sequence @xmath42 specifies the weighted contribution of each digit position and is called the _",
    "weight sequence of @xmath8_. a finite mixed radix base is a finite sequence @xmath43 with the same restrictions as for the infinite case except that numbers always have @xmath44 digits ( possibly padded with zeroes ) and there is no bound on the value of the most significant digit , @xmath45 .",
    "in this paper we focus on the representation of finite multisets of natural numbers in finite mixed radix bases .",
    "let @xmath46 denote the set of finite mixed radix bases and @xmath47 the set of finite non - empty multisets of natural numbers .",
    "we often view multisets as ordered ( and hence refer to their first element , second element , etc . ) . for a finite sequence or multiset @xmath9 of natural numbers ,",
    "we denote its length by @xmath48 , its maximal element by @xmath49 , its @xmath50 element by @xmath51 , and the multiplication of its elements by @xmath52 ( if @xmath9 is the empty sequence then @xmath53 ) .",
    "if a base consists of prime numbers only , then we say that it is a prime base .",
    "the set of prime bases is denoted @xmath54 .",
    "let @xmath55 with @xmath56 .",
    "we denote by @xmath57 the representation of a natural number @xmath58 in base @xmath8 .",
    "the most significant digit of @xmath59 , denoted @xmath60 , is @xmath45 .",
    "if @xmath61 then we say that @xmath8 is redundant for @xmath58 .",
    "let @xmath62 with @xmath63 .",
    "we denote the @xmath64 matrix of digits of elements from @xmath9 in base @xmath8 as @xmath65 .",
    "namely , the @xmath50 row in @xmath65 is the vector @xmath66 .",
    "the most significant digit column of @xmath65 is the @xmath44 column of the matrix and denoted @xmath67 .",
    "if @xmath68 , then we say that @xmath8 is redundant for @xmath9 .",
    "this is equivalently characterized by @xmath69 .",
    "[ def : nrb ] let @xmath62 .",
    "we denote the set of non - redundant bases for @xmath9 , @xmath70 .",
    "the set of non - redundant prime bases for @xmath9 is denoted @xmath71 .",
    "the set of non - redundant ( prime ) bases for @xmath9 , containing elements no larger than @xmath72 , is denoted @xmath73 ( @xmath74 ) .",
    "the set of bases in @xmath75/@xmath73/@xmath74 , is often viewed as a tree with root @xmath76 ( the empty base ) and an edge from @xmath8 to @xmath77 if and only if @xmath77 is obtained from @xmath8 by extending it with a single integer value .",
    "[ def : sumdigits ] let @xmath62 and @xmath55 .",
    "the sum of the digits of the numbers from @xmath9 in base @xmath8 is denoted @xmath78 .",
    "the usual binary `` base 2 '' and ternary `` base 3 '' are represented as the infinite sequences @xmath79 and @xmath80 . the finite sequence @xmath81 and the empty sequence @xmath82 are also bases .",
    "the empty base is often called the `` unary base '' ( every number in this base has a single digit ) . let @xmath83 . then , @xmath84 ,   @xmath85 ,   @xmath86 ,  and @xmath87 .    let @xmath62 .",
    "a cost function for @xmath9 is a function @xmath88 which associates bases with real numbers .",
    "an example is @xmath89 . in this paper",
    "we are concerned with the following _ optimal base problem_.    let @xmath90 and @xmath91 a cost function .",
    "we say that a base @xmath8 is an _",
    "optimal base for @xmath9 _ with respect to @xmath91 , if for all bases @xmath77 , @xmath92 .",
    "the corresponding _ optimal base problem _ is to find an optimal base @xmath8 for @xmath9 .",
    "the following two lemmata confirm that for the @xmath93 cost function , we may restrict attention to non - redundant bases involving prime numbers only .",
    "[ l1 ] let @xmath90 and consider the @xmath93 cost function . then , @xmath9 has an optimal base in @xmath75 .",
    "[ lem : primes ] let @xmath90 and consider the @xmath93 cost function . then , @xmath9 has an optimal base in @xmath71 .",
    "how hard is it to solve an instance of the optimal base problem ( namely , for @xmath62 ) ?",
    "the following lemma provides a polynomial ( in @xmath49 ) upper bound on the size of the search space .",
    "this in turn suggests a pseudo - polynomial time brute force algorithm ( to traverse the search space ) .",
    "[ zeta ] let @xmath62 with @xmath94 .",
    "then , @xmath95 where @xmath96 and where @xmath97 is the riemann zeta function .",
    "chor _ et al .",
    "_  prove in @xcite that the number of ordered factorizations of a natural number @xmath24 is less than @xmath98 .",
    "the number of bases for all of the numbers in @xmath9 is hence bounded by @xmath99 , which is bounded by @xmath100 .",
    "this section presents the construction underlying the sorter based encoding of pseudo - boolean constraints applied in minisat@xmath0@xcite .",
    "it is governed by the choice of a mixed radix base @xmath8 , the optimal selection of which is the topic of this paper .",
    "the construction sets up a series of sorting networks to encode the digits , in base @xmath8 , of the sum of the terms on the left side of a constraint @xmath101 .",
    "the encoding then compares these digits with those from @xmath102 from the right side .",
    "we present the construction , step by step , through an example where @xmath103 and @xmath104 .",
    "+    r30 mm @xmath105    the coefficients of @xmath26 form a multiset @xmath106 and their representation in base @xmath8 , a @xmath107 matrix , @xmath65 , depicted on the right .",
    "the rows of the matrix correspond to the representation of the coefficients in base @xmath8 .",
    "representing the coefficients as four digit numbers in base @xmath103 and considering the values @xmath108 of the digit positions , we obtain a decomposition for the left side of @xmath26 : @xmath109 to encode the sums at each digit position ( @xmath110 ) , we set up a series of four sorting networks as depicted below .",
    "given values for the variables , the sorted      outputs from these networks represented unary numbers @xmath112 such that the left side of @xmath26 takes the value @xmath113 .",
    "for the outputs @xmath112 to represent the digits of a number in base @xmath103 , we need to encode also the `` carry '' operation from each digit position to the next .",
    "the first 3 outputs must represent valid digits for @xmath8 , i.e. , unary numbers less than @xmath114 respectively . in our example",
    "the single potential violation to this restriction is @xmath115 , which is represented in 6 bits . to this end",
    "we add two components to the encoding : ( 1 ) each third output of the second network ( @xmath116 and @xmath117 in the diagram ) is fed into the third network as an additional ( carry ) input ; and ( 2 ) clauses are added to encode that the output of the second network is to be considered modulo 3 .",
    "we call these additional clauses a _ normalizer_. the normalizer      defines two outputs @xmath119 and introduces clauses specifying that the ( unary ) value of @xmath120 equals the ( unary ) value of @xmath121 .",
    "the outputs from these four units now specify a number in base @xmath8 , each digit represented in unary notation . this number is now compared ( via an encoding of the lexicographic order ) to @xmath122 ( the value from the right - hand side of @xmath26 ) .",
    "we now return to the objective of this paper : for a given pseudo - boolean constraint , how can we choose a mixed radix base with respect to which the encoding of the constraint via sorting networks will be optimal ?",
    "we consider here three alternative cost functions with respect to which an optimal base can be found .",
    "these cost functions capture with increasing degree of precision the actual size of the encodings .",
    "the first cost function , @xmath93 as introduced in definition  [ def : sumdigits ] , provides a coarse measure on the size of the encoding .",
    "it approximates ( from below ) the total number of input bits in the network of sorting networks underlying the encoding .",
    "an advantage in using this cost function is that there always exists an optimal base which is prime .",
    "the disadvantage is that it ignores the carry bits in the construction , and as such is not always a precise measure for optimality . in  @xcite ,",
    "the authors propose to apply a cost function which considers also the carry bits .",
    "this is the second cost function we consider and we call it @xmath123 .",
    "[ cost2 ] let @xmath62 , @xmath55 with @xmath56 and @xmath124 the corresponding @xmath64 matrix of digits .",
    "denote the sequences @xmath125 ( sums ) and @xmath126 ( carries ) defined by : @xmath127 for @xmath128 , @xmath129 , and @xmath130 for +    @xmath128 .",
    "the `` sum of digits with carry '' cost function is defined by the equation on the right .",
    "@xmath131    the following example illustrates the @xmath123 cost function and that it provides a better measure of base optimality for the ( size of the ) encoding of pseudo - boolean constraints .",
    "[ runningd ]    consider the encoding of a pseudo - boolean constraint with coefficients @xmath132 with respect to bases : @xmath133 , @xmath134 , and @xmath135 .",
    "figure  [ fig:3cost ] depicts the sizes of the sorting networks for each of these bases .",
    "the upper tables illustrate the representation of the coefficients in the corresponding bases . in the lower tables ,",
    "the rows labeled `` sum '' indicate the number of bits per network and ( to their right ) their total sum which is the @xmath93 cost .",
    "with respect to the @xmath93 cost function , all three bases are optimal for @xmath9 , with a total of 9 inputs .",
    "the algorithm might as well return @xmath136 .",
    "the rows labeled `` carry '' indicate the number of carry bits in each of the constructions and ( to their right ) their totals . with respect to the @xmath123 cost function , bases @xmath137 and @xmath138 are optimal for @xmath9 , with a total of @xmath139 bits while @xmath136 involves @xmath140 bits .",
    "the algorithm might as well return @xmath137 .",
    "the following example shows that when searching for an optimal base with respect to the @xmath123 cost function , one must consider also non - prime bases .",
    "consider again the pseudo boolean constraint @xmath142 from section  [ sec : encoding ] .",
    "the encoding with respect to @xmath133 results in 4 sorting networks with 10 inputs from the coefficients and 2 carries .",
    "so a total of 12 bits .",
    "the encoding with respect to @xmath143 is smaller .",
    "it has the same 10 inputs from the coefficients but no carry bits .",
    "base @xmath138 is optimal and non - prime .",
    "we consider a third cost function which we call the @xmath144 cost function .",
    "sorting networks are constructed from `` comparators '' @xcite and in the encoding each comparator is modeled using six cnf clauses",
    ". this function counts the number of comparators in the construction .",
    "let @xmath145 denote the number of comparators in an @xmath146 sorting network . for small values of @xmath147",
    ", @xmath145 takes the values @xmath148 and @xmath149 respectively which correspond to the sizes of the optimal networks of these sizes @xcite . for larger values",
    ", the construction uses batcher s odd - even sorting networks @xcite for which @xmath150 .",
    "[ num_comparators ] consider the same setting as in definition  [ cost2 ] .",
    "then , @xmath151    consider again the setting of example  [ runningd ] .",
    "in figure  [ fig:3cost ] the rows labeled `` comp '' indicate the number of comparators in each of the sorting networks and their totals .",
    "the construction with the minimal number of comparators is that obtained with respect to the base @xmath134 with 10 comparators .",
    "it is interesting to remark the following relationship between the three cost functions : the @xmath93 function is the most `` abstract '' .",
    "it is only based on the representation of numbers in a mixed radix base .",
    "the @xmath123 function considers also properties of addition in mixed - radix bases ( resulting in the carry bits ) .",
    "finally , the @xmath144 function considers also implementation details of the odd - even sorting networks applied in the underlying minisat@xmath0  construction . in section  [ sec : exp ]",
    "we evaluate how the alternative choices for a cost function influence the size and quality of the encodings obtained with respect to corresponding optimal bases .",
    "this section introduces a simple , heuristic - based , depth - first , tree search algorithm to solve the optimal base problem .",
    "the search space is the domain of non - redundant bases as presented in definition  [ def : nrb ] .",
    "the starting point is the brute force algorithm applied in minisat@xmath0 . for a sequence of integers @xmath9 ,",
    "minisat@xmath0  applies a depth - first traversal of @xmath152 to find the base with the optimal value for the cost function @xmath153 .",
    "our first contribution is to introduce a heuristic function and to identify branches in the search space which can be pruned early on in the search .",
    "each tree node @xmath8 encountered during the traversal is inspected to check if given the best node encountered so far , @xmath154 , it is possible to determine that all descendants of @xmath8 are guaranteed to be less optimal than @xmath154 . in this case",
    ", the subtree rooted at @xmath8 may be pruned .",
    "the resulting algorithm improves on the one of minisat@xmath0  and provides the basis for the further improvements introduced in sections  [ sec : ob2 ] and  [ sec : ob3 ] .",
    "we need first a definition .",
    "let @xmath62 , @xmath155 , and @xmath91 a cost function .",
    "we say that : ( 1 ) @xmath77 extends @xmath8 , denoted @xmath156 , if @xmath8 is a prefix of @xmath77 , ( 2 ) @xmath157 is a partial cost function for @xmath91 if @xmath158 , and ( 3 ) @xmath159 is an admissible heuristic function for @xmath91 and @xmath157 if @xmath160 .",
    "the intuition is that @xmath161 signifies a part of the cost of @xmath8 which will be a part of the cost of any extension of @xmath8 , and that @xmath162 is an under - approximation on the additional cost of extending @xmath8 ( in any way ) given the partial cost of @xmath8 .",
    "we denote @xmath163 .",
    "if @xmath157 is a partial cost function and @xmath159 is an admissible heuristic function , then @xmath164 is an under - approximation of @xmath165 .",
    "the next lemma provides the basis for heuristic pruning using the three cost functions introduced above .",
    "[ lem : h ] the following are admissible heuristics for the cases when :    1 .",
    "@xmath89 :   @xmath166 .",
    "@xmath167 :   @xmath166 .",
    "@xmath168 :   @xmath169 .    in the first two settings we take @xmath170 .",
    "+ in the case of @xmath144 we take the trivial heuristic estimate @xmath171    /*input*/ & multiset s + /*init*/ & base bestb = @xmath172 + /*dfs*/ & depth - first traverse @xmath173 + & at each node @xmath8 , for the next value p @xmath174 b.extenders(s ) do + & base newb = b.extend(p ) + & if ( @xmath175 ) * prune * + & else if ( @xmath176 ) bestb = newb + /*output*/ & return bestb ; +    the algorithm , which we call ` dfshp ` for depth - first search with heuristic pruning , is now stated as figure  [ fig : alg1 ] where the input to the algorithm is a ` multiset ` of integers ` s ` and the output is an optimal base .",
    "the algorithm applies a depth - first traversal of @xmath75 in search of an optimal base .",
    "we assume given : a cost function @xmath91 , a partial cost function @xmath157 and an admissible heuristic @xmath159 .",
    "we denote @xmath163 .",
    "the abstract data type ` base ` has two operations : ` extend(int ) ` and ` extenders(multiset ) ` . for a base ` b ` and an integer ` p ` , ` b.extend(p ) ` is the base obtained by extending ` b ` by ` p ` . for a multiset ` s ` , ` b.extenders(s ) ` is the set of integer values ` p ` by which ` b ` can be extended to a non - redundant base for ` s ` , i.e. , such that @xmath177 .",
    "the definition of this operation may have additional arguments to indicate if we seek a prime base or one containing elements no larger than @xmath72 .",
    "initialization ( /*init*/ in the figure ) assigns to the variable ` bestb ` a finite binary base of size @xmath178 .",
    "this variable will always denote the best base encountered so far ( or the initial finite binary base ) . throughout the traversal , when visiting a node ` newb ` we first check if the subtree rooted at ` newb ` should be pruned .",
    "if this is not the case , then we check if a better `` best base so far '' has been found . once the entire ( with pruning )",
    "search space has been considered , the optimal base is in ` bestb ` .    to establish a bound on the complexity of the algorithm , denote the number of different integers in @xmath9 by @xmath179 and @xmath94 .",
    "the algorithm has space complexity @xmath180 , for the depth first search on a tree with height bound by @xmath181 ( an element of @xmath75 will have at most @xmath182 elements ) .",
    "for each base considered during the traversal , we have to calculate @xmath183 which incurs a cost of @xmath184 . to see why , consider that when extending a base @xmath8 by a new element giving base @xmath77 , the first columns of @xmath185 are the same as those in @xmath65 ( and thus also the costs incurred by them ) .",
    "only the cost incurred by the most significant digit column of @xmath65 needs to be recomputed for @xmath185 due to base extension of @xmath8 to @xmath77 .",
    "performing the computation for this column , we compute a new digit for the @xmath179 different values in @xmath9 .",
    "finally , by lemma  [ zeta ] , there are @xmath186 bases and therefore , the total runtime is @xmath187 . given that @xmath188 , we can conclude that runtime is bounded by @xmath189 .",
    "in this section we further improve the search algorithm for an optimal base .",
    "the search algorithm is , as before , a traversal of the search space using the same partial cost and heuristic functions as before to prune the tree .",
    "the difference is that instead of a depth first search , we maintain a priority queue of nodes for expansion and apply a best - first , branch and bound search strategy .",
    "figure  [ fig : alg2 ] illustrates our enhanced search algorithm .",
    "we call it ` b&b ` . the abstract data",
    "type ` priority_queue ` maintains bases prioritized by the value of @xmath190 .",
    "operations ` popmin ( ) ` , ` push(base ) ` and ` peek ( ) ` ( peeks at the minimal entry ) are the usual .",
    "the reason to box the text `` ` priority_queue ` '' in the figure will become apparent in the next section .",
    "base findbase(multiset s ) + /*1*/ base bestb = @xmath172 ; q = @xmath191 ; + /*2*/ while ( @xmath192 @xmath193 ) + /*3*/ base b = q.popmin ( ) ; + /*4*/ foreach ( p @xmath174 b.extenders(s ) ) + /*5*/ base newb = b.extend(p ) ; + /*6*/ if ( @xmath194 ) + /*7*/ \\ { q.push(newb ) ; if ( @xmath195 ) bestb = newb ; } + /*8*/ return bestb ; +    on line /*1*/ in the figure , we initialize the variable ` bestb ` to a finite binary base of size @xmath178 ( same as in figure  [ fig : alg1 ] ) and initialize the queue to contain the root of the search space ( the empty base ) . as long as there are still nodes to be expanded in the queue that are potentially interesting ( line /*2*/ ) , we select ( at line /*3*/ ) the best candidate base ` b ` from the frontier of the tree in construction for further expansion .",
    "now the search tree is expanded for each of the relevant integers ( calculated at line /*4*/ ) . for each child ` newb ` of ` b ` ( line /*5*/ ) , we check if pruning at ` newb ` should occur ( line /*6*/ ) and if not we check if a better bound has been found ( line /*7*/ ) finally , when the loop terminates , we have found the optimal base and return it ( line /*8*/ ) .",
    "this section introduces an abstraction on the search space , classifying bases according to their product . instead of maintaining ( during the search ) a priority queue of all bases ( nodes ) that still need to be explored , we maintain a special priority queue in which there will only ever be at most one base with the same product .",
    "so , the queue will never contain two different bases @xmath137 and @xmath138 such that @xmath196 . in case a second base , with the same product as one already in ,",
    "is inserted to the queue , then only the base with the minimal value of @xmath190 is maintained on the queue .",
    "we call this type of priority queue a _ hashed priority queue _ because it can conveniently be implemented as a hash table .",
    "the intuition comes from a study of the @xmath93 cost function for which we can prove the following * property 1 * on bases : consider two bases @xmath137 and @xmath138 such that @xmath196 and such that @xmath197 . then for any extension of @xmath137 and of @xmath138 by the same sequence @xmath198 , @xmath199 .",
    "in particular , if one of @xmath137 or @xmath138 can be extended to an optimal base , then @xmath137 can .",
    "a direct implication is that when maintaining the frontier of the search space as a priority queue , we only need one representative of the class of bases which have the same product ( the one with the minimal value of @xmath190 ) .",
    "a second * property 2 * is more subtle and true for any cost function that has the first property : assume that in the algorithm described as figure  [ fig : alg2 ] we at some stage remove a base @xmath137 from the priority queue .",
    "this implies that if in the future we encounter any base @xmath138 such that @xmath196 , then we can be sure that @xmath200 and immediately prune the search tree from @xmath138 .",
    "our third and final algorithm , which we call ` hashb&b ` ( best - first , branch and bound , with hash priority queue ) is identical to the algorithm presented in figure  [ fig : alg2 ] , except that the the boxed priority queue introduced at line /*1*/ is replaced by a    .    the abstract data type ` hash_priority_queue ` maintains bases prioritized by the value of @xmath190 . operations ` popmin ( ) ` and ` peek ( ) ` are as usual . operation ` push(b_1 ) ` works as follows : ( a ) if there is no base @xmath138 in the queue such that @xmath201 , then add @xmath137 . otherwise , ( b ) if @xmath202 then do not add @xmath137 .",
    "otherwise , ( c ) remove @xmath138 from the queue and add @xmath137 .    [ algisgood ]   + ( 1 ) the @xmath93 cost function satisfies * property 1 * ; and ( 2 ) the ` hashb&b ` algorithm finds an optimal base for any cost function which satisfies * property  1*.    we conjecture that the other cost functions do not satisfy * property 1 * , and hence can not guarantee that the ` hashb&b ` algorithm always finds an optimal base .",
    "however , in our extensive experimentation , all bases found ( when searching for an optimal prime base ) are indeed optimal .",
    "a direct implication of the above improvements is that we can now provide a tighter bound on the complexity of the search algorithm .",
    "let us denote the number of different integers in @xmath9 by @xmath179 and @xmath94 .",
    "first note that in the worst case the hashed priority queue will contain @xmath203 elements ( one for each possible value of a base product , which is never more than @xmath203 ) .",
    "assuming that we use a fibonacci heap , we have a @xmath180 cost ( amortized ) per ` popmin ( ) ` operation and in total a @xmath204 cost for popping elements off the queue during the search for an optimal base .",
    "now focus on the cost of operations performed when extracting a base @xmath8 from the queue . denoting @xmath205",
    ", @xmath8 has at most @xmath206 children ( integers which extend it ) . for each child",
    "we have to calculate @xmath183 which incurs a cost of @xmath184 and possibly to insert it to the queue . pushing",
    "an element onto a hashed priority queue ( in all three cases ) is a constant time operation ( amortized ) , and hence the total cost for dealing with a child is @xmath184 .    finally , consider the total number of children created during the search which corresponds to the following sum : @xmath207 so , in total we get @xmath208 .",
    "when we restrict the extenders to be prime numbers then we can further improve this bound to @xmath209 by reasoning about the density of the primes . a proof can be found in the appendix",
    "experiments are performed using an extension to minisat@xmath0@xcite where the only change to the tool is to plug in our optimal base algorithm .",
    "the reader is invited to experiment with the implementation via its web interface .",
    "all experiments are performed on a quad - opteron 848 at 2.2 ghz , 16 gb ram , running linux .",
    "our benchmark suite originates from 1945 pseudo - boolean evaluation @xcite instances from the years 20062009 containing a total of 74,442,661 individual pseudo - boolean constraints . after normalizing and removing constraints with @xmath210 coefficients",
    "we are left with 115,891 different optimal base problems where the maximal coefficient is @xmath211 .",
    "we then focus on 734 pb instances where at least one optimal base problem from the instance yields a base with an element that is non - prime or greater than 17 .",
    "when solving pb instances , in all experiments , a 30 minute timeout is imposed as in the pseudo - boolean competitions . when solving an optimal base problem , a 10 minute timeout is applied .",
    "[ [ experiment-1-impact - of - optimal - bases ] ] experiment 1 ( impact of optimal bases ) : + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + +    the first experiment illustrates the advantage in searching for an optimal base for pseudo - boolean solving .",
    "we compare sizes and solving times when encoding w.r.t . the binary base vs.  w.r.t . an optimal base ( using the ` hashb&b ` algorithm with the @xmath144 cost function ) .",
    "encoding w.r.t . the binary base , we solve 435 pb instances ( within the time limit ) with an average time of 146 seconds and average cnf size of 1.2 million clauses . using an optimal base ,",
    "we solve 445 instances with an average time of 108 seconds , and average cnf size of 0.8 million clauses .",
    "[ [ experiment-2-base - search - time ] ] experiment 2 ( base search time ) : + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + +    here we focus on the search time for an optimal base in six configurations using the @xmath123 cost function . configurations ` m17 ` , ` dfshp17 ` , and ` b&b17 ` , are respectively , the minisat@xmath0  implementation , our ` dfshp ` and our ` b&b ` algorithms , all three searching for an optimal base from @xmath212 , i.e. , with prime elements up to 17 .",
    "configurations ` hashb&b1,000,000 ` , ` hashb&b10,000 ` , and ` hashb&b17 ` are our ` hashb&b ` algorithm searching for a base from @xmath213 with bounds of @xmath214 1,000,000 , @xmath215 10,000 , and @xmath215 17 , respectively .",
    "results are summarized in fig .",
    "[ fig : results1 ] which is obtained as follows .",
    "we cluster the optimal base problems according to the values @xmath216 where @xmath217 is the maximal coefficient in a problem .",
    "then , for each cluster we take the average runtime for the problems in the cluster .",
    "the value @xmath218 is chosen to minimize the standard deviation from the averages ( over all clusters ) .",
    "these are the points on the graphs .",
    "configuration ` m17 ` times out on 28 problems . for ` dfshp17 ` , the maximal search time is 200 seconds .",
    "configuration ` b&b17 ` times out for 1 problem .",
    "the ` hashb&b ` configurations have maximal runtimes of 350 seconds , 14 seconds and 0.16 seconds , respectively for the bounds 1,000,000 , 10,000 and 17 .",
    "-axis with 50k ms on the left and 8k ms on the right .",
    "configuration ` dfshp17 ` ( yellow ) is lowest on left and highest on right , setting the reference point to compare the two graphs .",
    ", title=\"fig : \" ] -axis with 50k ms on the left and 8k ms on the right .",
    "configuration ` dfshp17 ` ( yellow ) is lowest on left and highest on right , setting the reference point to compare the two graphs .",
    ", title=\"fig : \" ]    fig .",
    "[ fig : results1 ] shows that : ( left ) even with primes up to 1,000,000 , ` hashb&b ` is faster than the algorithm from minisat@xmath0  with the limit of 17 ; and ( right ) even with primes up to 10,000 , the search time using ` hashb&b ` is essentially negligible .",
    "[ [ experiment-3-impact - on - pb - solving ] ] experiment 3 ( impact on pb solving ) : + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + +    fig .",
    "[ fig : results2 ] illustrates the influence of improved base search on sat solving for pb constraints .",
    "both graphs depict the number of instances solved ( the @xmath219-axis ) within a time limit ( the @xmath220-axis ) . on the left ,",
    "total solving time ( with base search ) , and on the right , sat solving time only .",
    "[ fig : results2 ]    both graphs consider the @xmath221 instances of interest and compare sat solving times with bases found using five configurations .",
    "the first is minisat@xmath0with configuration ` m17 ` , the second is with respect to the binary base , the third to fifth are ` hashb&b ` searching for bases from @xmath222 with cost functions : @xmath93 , @xmath123 , and @xmath144 , respectively .",
    "the average total / solve run - times ( in sec ) are 150/140 , 146/146 , 122/121 , 116/115 and 108/107 ( left to right ) .",
    "the total number of instances solved are 431 , 435 , 442 , 442 and 445 ( left to right ) .",
    "the average cnf sizes ( in millions of clauses ) for the entire test set / the set where all algorithms solved / the set where no algorithm solved are 7.7/1.0/18 , 9.5/1.2/23 , 8.4/1.1/20 , 7.2/0.8/17 and 7.2/0.8/17 ( left to right ) .",
    "the graphs of fig .",
    "[ fig : results2 ] and average solving times clearly show : * ( 1 ) * sat solving time dominates base finding time , * ( 2 ) * minisat@xmath0  is outperformed by the trivial binary base , * ( 3 ) * total solving times with our algorithms are faster than with the binary base , and * ( 4 ) * the most specific cost function ( comparator cost ) outperforms the other cost functions both in solving time and size . finally , note that sum of digits with its nice mathematical properties , simplicity , and application independence solves as many instances as cost carry .    [ [ experiment-4-impact - of - high - prime - factors ] ] experiment 4 ( impact of high prime factors ) : + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + +    r73 mm     this experiment is about the effects of restricting the maximal prime value in a base ( i.e. the value @xmath223 of minisat@xmath0 ) .",
    "an analysis of the our benchmark suite indicates that coefficients with small prime factors are overrepresented . to introduce instances where coefficients have larger prime factors we select 43 instances from the suite and multiply their coefficients to introduce the prime factor 31 raised to the power @xmath224 .",
    "we also introduce a slack variable to avoid gcd - based simplification .",
    "this gives us a collection of 258 new instances .",
    "we used the ` b&b ` algorithm with the @xmath123 cost function applying the limit @xmath223 ( as in minisat@xmath0 ) and @xmath225 .",
    "results indicate that for @xmath225 , both cnf size and sat - solving time are independent of the factor @xmath226 introduced for @xmath227 .",
    "however , for @xmath223 , both measures increase as the power @xmath228 increases .",
    "results on cnf sizes are reported in fig.[fig : resultsgencactus ] which plots for 4 different settings the number of instances encoded ( @xmath219-axis ) within a cnf with that many clauses ( @xmath220-axis ) .",
    "recent work @xcite encodes pseudo - boolean constraints via `` totalizers '' similar to sorting networks , determined by the representation of the coefficients in an underlying base . here",
    "the authors choose the standard base 2 representation of numbers .",
    "it is straightforward to generalize their approach for an arbitrary mixed base , and our algorithm is directly applicable . in",
    "@xcite the author considers the @xmath93 cost function and analyzes the size of representing the natural numbers up to @xmath24 with ( a particular class of ) mixed radix bases .",
    "our lemma  [ lem : primes ] may lead to a contribution in that context .",
    "it has been recognized now for some years that decomposing the coefficients in a pseudo - boolean constraint with respect to a mixed radix base can lead to smaller sat encodings .",
    "however , it remained an open problem to determine if it is feasible to find such an optimal base for constraints with large coefficients . in lack of a better solution",
    ", the implementation in the minisat@xmath0  tool applies a brute force search considering prime base elements less than 17 .    to close this open problem ,",
    "we first formalize the optimal base problem and then significantly improve the search algorithm currently applied in minisat@xmath0 .",
    "our algorithm scales and easily finds optimal bases with elements up to 1,000,000 .",
    "we also illustrate that , for the measure of optimality applied in minisat@xmath0 , one must consider also non - prime base elements .",
    "however , choosing the more simple @xmath93 measure , it is sufficient to restrict the search to prime bases .    with the implementation of our search algorithm it is possible , for the first time , to study the influence of basing sat encodings on optimal bases .",
    "we show that for a wide range of benchmarks , minisat@xmath0  does actually find an optimal base consisting of elements less than 17 .",
    "we also show that many pseudo - boolean instances have optimal bases with larger elements and that this does influence the subsequent cnf sizes and sat solving times , especially when coefficients contain larger prime factors .",
    "we thank daniel berend and carmel domshlak for useful discussions .",
    "10    o.  bailleux , y.  boufkhad , and o.  roussel .",
    "a translation of pseudo boolean constraints to sat .",
    ", 2(1 - 4):191200 , 2006 .",
    "o.  bailleux , y.  boufkhad , and o.  roussel .",
    "new encodings of pseudo - boolean constraints into cnf . in _ proc .  theory and applications of satisfiability testing ( sat 09 ) _ , pages 181194 , 2009 .",
    "p.  barth . .",
    "kluwer academic publishers , norwell , ma , usa , 1996 .",
    "k.  e. batcher .",
    "sorting networks and their applications . in _",
    "afips spring joint computing conference _ , volume  32 of _ afips conference proceedings _ , pages 307314 .",
    "thomson book company , washington d.c .",
    ", 1968 .",
    "r.  e. bixby , e.  a. boyd , and r.  r. indovina . : a test set of mixed integer programming problems .",
    ", 25:16 , 1992 .",
    "r.  e. bryant , s.  k. lahiri , and s.  a. seshia .",
    "deciding clu logic formulas via boolean and pseudo - boolean encodings .",
    "in _ proc .",
    "workshop on constraints in formal verification ( cfv 02 ) _ , 2002 .",
    "b.  chor , p.  lemke , and z.  mador . on the number of ordered factorizations of natural numbers . , 214(1 - 3):123133 , 2000 .",
    "n.  en and n.  srensson .",
    "translating pseudo - boolean constraints into sat .",
    ", 2(1 - 4):126 , 2006 .",
    "d.  knuth . .",
    "addison - wesley , 1973 .",
    "v.  m.  manquinho and o.  roussel .",
    "the first evaluation of pseudo - boolean solvers ( pb05 ) .",
    ", 2(1 - 4):103143 , 2006 .",
    "n.  sidorov .",
    "sum - of - digits function for certain nonstationary bases .",
    ", 96(5):36093615 , 1999 .",
    "let @xmath62 and let @xmath55 be an optimal base for @xmath9 with @xmath69 .",
    "let @xmath77 be the base obtained by removing the last element from @xmath8 . we show that @xmath229 and that @xmath230 .",
    "the claim then follows .",
    "assume falsely that for @xmath231,@xmath232 .",
    "then we get the contradiction @xmath233 . from the definition of @xmath93 and the above contradiction we deduce that @xmath234 .",
    "[ pnib ] let @xmath235 be a base with @xmath236 and let @xmath237 .",
    "then , the unique representation of @xmath58 in @xmath8 is obtained as @xmath238 such that : ( 1 ) @xmath239 , ( 2 ) @xmath240  for @xmath241 , and ( 3 ) @xmath242 .",
    "[ pprimesonly ] let @xmath246 and let @xmath247 and @xmath248 be bases which are identical except that at some position @xmath249 , two consecutive base elements in @xmath137 are replaced in @xmath138 by their multiplication .",
    "formally : @xmath250 for @xmath251 , @xmath252 , and @xmath253 for @xmath254 .",
    "then , the sum of the digits in @xmath255 is greater or equal to the sum of the digits in @xmath256 .",
    "let @xmath138 be a base with @xmath262 elements of the form @xmath263 where the element @xmath264 at position @xmath265 is non - prime and @xmath266 .",
    "so , taking @xmath267 , we are in the setting of proposition  [ pprimesonly ] .",
    "the result follows : @xmath268      consider the notation of definition  [ cost2 ] .",
    "let @xmath62 , @xmath55 with @xmath56 and @xmath124 . denote the sequences @xmath269 ( sums ) and @xmath270 ( carries ) defined by : @xmath271 for @xmath128 , @xmath272 , and @xmath273 for @xmath128 .",
    "we denote also @xmath274 .",
    "[ psubbase2 ] let @xmath277 , and @xmath8 a base .",
    "then for every @xmath278 such that @xmath279 there exists @xmath280 let @xmath281 be any monotonically increasing function such that for @xmath282 , @xmath283 .",
    "let @xmath62 .",
    "then @xmath284 given by :        let @xmath288 and @xmath9 be as defined above and @xmath8 , @xmath77 bases such that @xmath156 , @xmath56 , and @xmath289 . for every base @xmath290 we can see that @xmath291 ( the size of a finite set is a natural number ) .",
    "therefore it is sufficient to prove that @xmath292 . from proposition  [ psubbase1 ]",
    "we get that @xmath293 . from the definition of @xmath294 and of @xmath288 we see that @xmath295 for @xmath296 , denote @xmath297 . + let @xmath298 .",
    "by proposition [ psubbase2 ] there exists @xmath299 such that @xmath300 and therefore @xmath301 .",
    "this implies that @xmath302 in total we have @xmath303 the proof that @xmath304 is similar noting that @xmath305 .",
    "( of lemma  [ lem : h ] ) + if @xmath306 , then @xmath307 . by proposition  [ lhc ] both definitions give a heuristic cost function .",
    "the proof for the case of @xmath144 and @xmath93 is of the same structure as proposition  [ lhc ] .",
    "the case of @xmath308 is the most complicated one .",
    "( * property 1 * ) [ dbme ] a heuristic cost function @xmath309 is called _ base mul equivalent _ if for every @xmath62 and for every bases @xmath137 , @xmath138 such that @xmath196 and @xmath197 the following holds :        [ pbestrep ] let @xmath62 and let @xmath309 be a base mul equivalent heuristic cost function . for every base @xmath137 extracted from the queue and for every base @xmath138 such that @xmath310 then @xmath311 .",
    "assume that the claim is true for every @xmath243 and assume that during the run of the algorithm we extract a base @xmath137 from the queue with @xmath314 .",
    "assume falsely that there exists a base @xmath138 such that @xmath315 and @xmath316.this means that @xmath138 was not evaluated yet ( otherwise @xmath317 ) .",
    "therefore the father of @xmath138 ( in the tree of bases ) was never extracted from the queue .",
    "let @xmath318 be the closest ancestor of @xmath138 that was extracted . denote by @xmath319 the child of @xmath318 which is also the ancestor of @xmath138 ( potentially @xmath138 itself ) .",
    "so , @xmath319 was evaluated .",
    "observe that @xmath318 and @xmath319 are unique because the search space ( of bases ) is a tree and @xmath320 .",
    "so , @xmath321 and that is a contradiction to the existence of @xmath138 .                for @xmath330 ,",
    "first notice that @xmath331 .",
    "this follows directly from the definition of admissible heuristics ( for the @xmath93 case ) .",
    "hence , @xmath332 . from propositions  [ pnib ] and  [ pbaseextenstion ] , we have that @xmath333      for @xmath334 , we define @xmath335 .",
    "so by the complete induction assumption for @xmath336 we get that @xmath337 . by the fact that @xmath338 we can deduce that @xmath339 . by the definition of admissible heuristics for @xmath93 : @xmath340 therefore , @xmath341 . combining it with the fact that @xmath342 we have that @xmath343 .",
    "finally from the inductive assumption we get that @xmath344 .",
    "\\2 ) let @xmath345 a base mul equivalent heuristic cost function and @xmath62 .",
    "we denote by @xmath154 the best base found by the algorithm at each point of the run .",
    "let @xmath8 be the first base extracted from the queue such that @xmath346 .",
    "this is the condition that terminates the main loop of the algorithm , so we need to prove that @xmath154 is the optimal base for @xmath9 .",
    "assume falsely that there exists an optimal base @xmath347 such that @xmath348 .",
    "let @xmath349 be the nearest ancestor of @xmath77 such that the its base equivalence class representative @xmath120 was extracted from queue ( @xmath350 otherwise @xmath351 ) . by proposition  [ pbestrep ]",
    "we know that @xmath352 and by * property 1 * that for any base c @xmath353 .",
    "in particular for the case where @xmath354 . by choice of @xmath349",
    "we get that the equivalence class representative of @xmath355 was not extracted ( and it is the same class of @xmath356 ) .",
    "therefore , @xmath357 , which is a contradiction .",
    "we use the prime number theorem which states that the density of the primes near @xmath219 is @xmath358 .",
    "the number of prime bases evaluated in the worst case scenario is : @xmath359 but @xmath360 and so the total number of bases evaluated during a run of the algorithm is bounded by @xmath361 and the overall complexity is @xmath362 .",
    "let @xmath363 with @xmath364 .",
    "it is standard to define @xmath365 and @xmath366 as natural numbers such that @xmath367 and @xmath368 . in our proofs",
    "we note that @xmath365 is the maximal number such that there exists @xmath369 with @xmath370 .      by definition if @xmath374 , @xmath375 and @xmath376 .",
    "then , @xmath377 , @xmath378 and @xmath379 .",
    "now , @xmath380 because otherwise it would be a contradiction to the maximality of @xmath381 . if @xmath382 then @xmath383 .",
    "assume that @xmath384 .",
    "then @xmath385 and from that we deduce @xmath386 ( otherwise it would be a contradiction to the maximality of @xmath13 ) . on the other hand , @xmath387 @xmath388 @xmath389 . from the definition of modulus we get that @xmath390 and so @xmath391 , and therefore @xmath392 . in total",
    "we get that @xmath393 and because @xmath13 and @xmath394 are natural numbers we get the equality .",
    "let @xmath396 , @xmath397 , @xmath398 , and @xmath399 . by definition",
    "we can see that @xmath400 , @xmath378 , and @xmath379 . therefore @xmath401",
    "@xmath388 @xmath402 @xmath388 @xmath403 @xmath388 @xmath404 @xmath388 @xmath405 @xmath388 @xmath406 @xmath388 @xmath407 @xmath388 @xmath408 and this is true by proposition [ pdiv ] .",
    "assume the assumption is true for every base @xmath8 such that @xmath415 .",
    "let @xmath56 such that @xmath416 .",
    "define the base @xmath417 with @xmath418 .",
    "we can see that for @xmath419 , @xmath420 , and that for @xmath421 , @xmath422 . from this",
    "we can see that for @xmath423 , @xmath424 and also that @xmath425 . back to the main claim by the induction",
    "we know that @xmath426",
    ". therefore @xmath427 . + by proposition [ pdivmod ] we can see that @xmath428 . and",
    "therefore we get that @xmath429 .",
    "( of proposition [ psubbase1 ] ) + first we notice that because @xmath156 then for @xmath430 we get that @xmath431 and therefore @xmath432 . by proposition  [ pnib ]",
    "we see that @xmath433 . by definition of @xmath65 and by proposition  [ pnib ] and the definition of @xmath434 we prove this proposition by induction on  @xmath435 .",
    "( of proposition [ psubbase2 ] ) + let @xmath58 and @xmath8 be as defined above .",
    "let @xmath440 such that @xmath441 .",
    "if there exists an @xmath442 such that @xmath443 then we get that  @xmath444  and in any case ( @xmath445 or @xmath446 )   @xmath447 .",
    "otherwise let @xmath448 be the maximal index such that @xmath449 .",
    "if @xmath446 then @xmath450 .",
    "consider the case when @xmath445 then @xmath451 such that   @xmath452 and so by dividing both sides by @xmath453 we get that @xmath454 , which means that @xmath455 .      1 .   for @xmath251 by definition @xmath456 which means that @xmath457 and therefore @xmath458 . for @xmath260",
    "again we get that @xmath459 and @xmath460 which again means that @xmath259 ) .",
    "we can see that @xmath461 . by proposition [ pnib ]",
    "we know that + @xmath462 + @xmath463 + @xmath464 + therefore   @xmath465 + because @xmath466 we deduce that  @xmath467 + and in total we get that + @xmath468    ( of proposition [ pbaseextenstion ] ) + let @xmath322 and @xmath8,@xmath77 bases such that @xmath156 .",
    "let @xmath469 ( @xmath470 , otherwise there is no such index ) . for @xmath471 by proposition  [ pnib ] we get that @xmath472 .",
    "if @xmath227 then by proposition  [ pnib ] and definition of @xmath473 we can deduce @xmath474 ."
  ],
  "abstract_text": [
    "<S> this paper formalizes the _ optimal base problem _ , presents an algorithm to solve it , and describes its application to the encoding of pseudo - boolean constraints to sat . </S>",
    "<S> we demonstrate the impact of integrating our algorithm within the pseudo - boolean constraint solver minisat@xmath0 . </S>",
    "<S> experimentation indicates that our algorithm scales to bases involving numbers up to 1,000,000 , improving on the restriction in minisat@xmath0  to prime numbers up to 17 . </S>",
    "<S> we show that , while for many examples primes up to 17 do suffice , encoding with respect to optimal bases reduces the cnf sizes and improves the subsequent sat solving time for many examples . </S>"
  ]
}