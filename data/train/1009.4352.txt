{
  "article_text": [
    "iterative decoding of error - correcting codes , while introduced by gallager in his 1960 ph.d .",
    "thesis , was largely forgotten until the 1993 discovery of turbo codes by berrou , et al . since then",
    ", message - passing iterative decoding has been a very popular decoding algorithm in research and practice . in 1995 ,",
    "the turbo decoding of a finite - state channel ( fsc ) and a convolutional code ( instead of two convolutional codes ) was introduced by douillard , et al as a _ turbo equalization _ ( te ) @xcite . before this , one typically separated channel decoding from error - correcting code decoding @xcite@xcite .",
    "this breakthrough received immediate interest from the magnetic recording community , and te was applied to magnetic recording channels by a variety of authors ( e.g. , ) . te and also extended to low - density parity - check ( ldpc ) codes ( and called _ joint iterative decoding _ ) by constructing one large graph representing the constraints of both the channel and the code ( e.g. , ) .    in @xcite@xcite , feldman , et al .",
    "introduced a linear - programming ( lp ) decoder for general binary linear codes and considered it specifically for both ldpc and turbo codes .",
    "it is based on solving an lp relaxation of an integer program which is equivalent to maximum - likelihood ( ml ) decoding . for long codes and/or low snr",
    ", the performance of lp decoding appears to be slightly inferior to belief - propagation decoding .",
    "but , unlike the iterative decoder , the lp decoder either detects a failure or outputs a codeword which is guaranteed to be the ml codeword .",
    "recently , the lp formulation has been extended to the joint decoding of a binary - input fsc and outer ldpc code @xcite@xcite . in this case",
    ", the performance of lp decoding appears to outperform belief - propagation decoding at moderate snr .",
    "moreover , all integer solutions are indeed codewords and the joint decoder also has a certain ml certificate property .",
    "this allows all decoder failures to be explained by _ joint - decoding pseudo - codewords _ .    in the past ,",
    "the primary value of lp decoding was as an analytical tool that allowed one to better understand iterative decoding and its modes of failure .",
    "this is because lp decoding based on standard lp solvers is quite impractical and has a superlinear complexity in the block length .",
    "this motivated several authors to propose low - complexity algorithms for lp decoding of ldpc codes in the last five years    in this paper , we extend this approach to the problem of low - complexity joint lp decoding of ldpc codes and fscs . we argue that by taking advantage of the special structure in dual - domain of the joint lp problem and replacing minima in the formulation with soft - minima , we can obtain an efficient method that solves the joint lp .",
    "while there are many ways to iteratively solve the joint lp , our main goal was to derive one as the natural analogue of te .",
    "this should lead to an efficient method for joint lp decoding whose performance is similar to joint lp and whose complexity similar to te .",
    "the paper is structured as follows .",
    "after briefly reviewing joint lp decoding in sec .",
    "[ sec : background ] , sec .",
    "[ sec : joint - lpd ] is devoted to develop the iterative solver for the joint lp decoder .",
    "finally , we provide , in sec . [",
    "sec : simulations ] , the decoder performance results and conclude in sec .",
    "[ sec : concl ] . due to space limitations",
    "we omit many of the proofs , but they can be found in @xcite .",
    "throughout the paper we borrow notation from @xcite .",
    "let @xmath0 and @xmath1 be sets of indices for the variable and parity - check nodes of a binary linear code .",
    "a variable node @xmath2 is connected to the set @xmath3 of neighboring parity - check nodes .",
    "abusing notation , we also let @xmath4 be the neighboring variable nodes of a parity - check node @xmath5 when it is clear from the context . for the trellis associated with a fsc , we let @xmath6 index the set of trellis edges associated with one trellis section . for each edge",
    "is used to denote a trellis edge while @xmath7 denotes the universal constant that satisfies @xmath8 . ] , @xmath9 , in the length-@xmath10 trellis , the functions @xmath11 ,  @xmath12 , @xmath13 ,  @xmath14 ,  and @xmath15 map this edge to its respective time index , initial state , final state , input bit , and noiseless output symbol .",
    "finally , the set of edges in the trellis section associated with time @xmath16 is defined to be @xmath17 .",
    "the _ dicode channel _ ( dic ) is a binary - input fsc with a linear response of @xmath18 and additive gaussian noise .",
    "if the input bits are differentially encoded prior to transmission , then the resulting channel is called the _ precoded dicode channel _ ( pdic ) .",
    "the state diagrams of these two channels are shown : noiseless dicode channel without ( left ) and with precoding ( right ) .",
    "the edges are labeled by the input / output pair . ]",
    "now , we describe _ the joint lp decoder _ in terms of the trellis of the fsc and the checks in the binary linear code .",
    "let @xmath10 be the length of the code and @xmath19 be the received sequence .",
    "the trellis consists of @xmath20 vertices ( i.e. , one for each state and time ) and a set of at most @xmath21 edges ( i.e. , one edge for each input - labeled state transition and time ) .",
    "the lp formulation requires one indicator variable for each edge @xmath22 , and we denote that variable by @xmath23 .",
    "so , @xmath23 is equal to 1 if the candidate path goes through the edge @xmath24 in @xmath25 .",
    "likewise , the lp decoder requires one cost variable for each edge and we associate the branch metric @xmath26 with the edge @xmath24 given by@xmath27\\!\\!\\ ! &",
    "\\mbox{if}\\ , t(e)\\!=\\!1.\\end{cases}\\ ] ]    the _ trellis polytope _ @xmath28 enforces the flow conservation constraints for channel decoder . the flow constraint for state @xmath29 at time @xmath16 is given by@xmath30^{n\\times o}\\left|\\,\\sum_{\\substack{e : s'(e)=k } } g_{i , e}=\\sum_{\\substack{e : s(e)=k } } g_{i+1,e}\\right.\\right\\ } .\\",
    "] ] using this , the _ trellis polytope _ @xmath28 is given by@xmath31    [ def : projection]let _ @xmath32 _ be the projection of @xmath33 onto the input vector @xmath34^{n}$ ] defined by @xmath35 with @xmath36    illustration of joint - lp decoder outputs for the single parity - check code spc(3,2 ) over dic ( starts in zero state ) . by ordering the trellis edges appropriately",
    ", joint - lp decoder converges to either a _ trellis - wise ( ml ) codeword _ @xmath37 ( top dashed blue path ) or a _ joint - decoding trellis - wise pseudo - codeword _ @xmath38 ( bottom dashed red paths ) .",
    "using @xmath32 to project them into @xmath39 , we obtain the corresponding _",
    "( symbol - wise ) codeword _ @xmath40 and _ joint - decoding symbolwise pseudo - codeword _ @xmath41 ]    let @xmath42 be the length-@xmath10 binary linear code defined by a parity - check matrix and @xmath43 be a codeword .",
    "let @xmath44 be the set whose elements are the sets of indices involved in each parity check , or @xmath45 then , we can define the set of codewords to be@xmath46 the _ codeword polytope _ is the convex hull of @xmath47",
    ". this polytope can be quite complicated to describe though , so instead one constructs a simpler polytope using local constraints .",
    "each parity - check @xmath48 defines a local constraint equivalent to the extreme points of a polytope in @xmath49^{n}$ ] .",
    "[ def : lcp ] the _ local codeword polytope _ @xmath50 associated with a parity check is the convex hull of the bit sequences that satisfy the check . it is given explicitly by@xmath51^{n}\\,\\bigg|\\sum_{i\\in s}c_{i}-\\!\\!\\!\\sum_{i\\in l - s}\\!\\ !",
    "c_{i}\\leq\\left|s\\right|\\!-\\!1\\right\\ } .\\ ] ]    the _ relaxed polytope _ @xmath39 is the intersection of the lcps over all checks and @xmath52    [ def : tpoly]the _ trellis - wise relaxed polytope _ @xmath53 for @xmath39 is given by    @xmath54    [ @xcite ]",
    "in this section , we develop an iterative solver for the joint decoding lp .",
    "there are few key steps in deriving our iterative solution for the joint lp decoding problem .",
    "for the first step , given by problem - p , we reformulate the original lp in thm .",
    "[ thm : jointlp ] using only equality constraints involving the indicator variables for each parity - check @xmath5 allow us to define the indicator variables @xmath55 ( for @xmath5 and @xmath56 ) which equal 1 if the codeword satisfies parity - check @xmath57 using configuration @xmath58 @xmath33 and @xmath59 .",
    "the second step , given by problem - d1 , follows from standard convex analysis ( e.g. , see @xcite ) .",
    "the lagrangian dual of problem - p is equivalent to problem - d1 and the minimum of problem - p is equal to the maximum of problem - d1 . from now on , we consider the problem - d1 where the code and trellis constraints separate into two terms in the objective function .",
    "[ fig : problemp ] for a diagram of the variables involved .",
    "the third step , given by problem - d2 , observes that forward / backward recursions can be used to perform the optimization over @xmath60 and remove one of the dual variable vectors .",
    "this splitting was enabled by imposing the trellis flow normalization constraint in problem - p only at one time instant @xmath61 .",
    "this detail gives @xmath10 different ways to write the same lp and is an important part of obtaining update equations similar to te .",
    "illustration of primal variables @xmath33 and @xmath59 defined for problem - p and dual variables @xmath60 and @xmath62 defined for problem - d1 on the same example given by fig . [ fig : example ] : spc(3,2 ) with dic for @xmath63    _ [ lem : problem - d-2]problem - d1 is equivalent to the problem - d2 . _    by rewriting the inequality constraint in problem - d as@xmath64 we obtain the recursive upper bound for @xmath65 as@xmath66 this upper bound @xmath67 is achieved by the forward viterbi update in problem - d2 for @xmath68 again , by expressing the same constraint as @xmath69 we get recursive upper bound for @xmath70 .",
    "similar reasoning shows this upper bound @xmath71 is achieved by the backward viterbi update in problem - d2 for @xmath72 see fig .",
    "[ fig : problemd-2 ] for a graphical depiction of this .",
    "the fourth step , given by problem - ds , is replacing minimum operator in problem - d2 with the soft - minimum operation .",
    "a smooth approximation is obtained by using @xmath73 as in @xcite .",
    "it is easy to verify that this log - sum - exp function converges to the minimum function as @xmath74 increases .",
    "since the soft - minimum function is used in two different ways , we use different constants , @xmath75 and @xmath76 for the code and trellis terms .",
    "this problem - ds allows one to to take derivative of ( giving the kkt equations , derived in lemma [ lem : innerloop ] ) , and represent and as bcjr - like forward / backward recursions ( given by lemma [ lem : outerloop ] ) .",
    "illustration of viterbi updates in problem - d2 on the same example given by fig .",
    "[ fig : example ] : dic for @xmath77 with forward @xmath78 and backward @xmath79 ]    _ [ lem : innerloop]the unique maximum of over @xmath80 can be found using the kkt equations , and an iterative solution for _ _ @xmath61 is given by _",
    "_ for _ @xmath81    [ lem : outerloop ] _ equations and are equivalent to the bcjr - based forward and backward recursion given by ( [ eq : bcjr1 ] ) , ( [ eq : bcjr2 ] ) , and ( [ eq : bcjr3 ] ) . _    now , we have all the pieces to complete the algorithm . as the last step ,",
    "we combine the results of lemma [ lem : innerloop ] and [ lem : outerloop ] to obtain the iterative solver for the joint decoding lp , which is summarized in algorithm [ alg : ijlp ] .",
    "[ rem : teconnection]while resulting algorithm [ alg : ijlp ] has the bit - node update different from standard belief propagation ( bp ) , we note that setting @xmath82 in the inner loop gives the exact bp check - node update and setting @xmath83 in the outer loop gives the exact bcjr channel update .",
    "in fact , one surprising result of this work is that such a small change to the bcjr - based te update provides an iterative solver for the lp whose complexity similar to te .",
    "it is also possible to prove the convergence of a slightly modified iterative solver that is based on a less efficient update schedule .",
    "initialize @xmath84 for @xmath85 and iteration count @xmath86 * step 2 .",
    "update outer loop : for @xmath2 , * * \\(i ) compute bit - to - trellis message @xmath87 where @xmath88 * * \\(ii ) compute forward / backward trellis messages + @xmath89 + @xmath90 + where @xmath91 for all @xmath92 . * * \\(iii ) compute trellis - to - bit message @xmath93@xmath94 * step 3 .",
    "update inner loop for @xmath95 rounds : for @xmath2 , * * \\(i ) compute bit - to - check msg @xmath96 for @xmath97 @xmath98 * * \\(ii ) compute check - to - bit msg @xmath99 for @xmath97 @xmath100 where @xmath101 * step 4 . compute hard decisions and stopping rule * * \\(i ) for @xmath2 , @xmath102 * * \\(ii ) if @xmath103 satisfies all parity checks or the iteration number , @xmath104 , is reached , stop and output @xmath103 . otherwise increase @xmath105 by 1 and go to step 2 .",
    "this section considers the convergence properties of the proposed algorithm [ alg : ijlp ] .",
    "although we have always observed convergence of algorithm [ alg : ijlp ] in simulation , our proof requires a modified update schedule that is less computationally efficient .",
    "following vontobel s approach in @xcite , which is based on general properties of gauss - seidel - type algorithms for convex minimization , we show that the modified version algorithm [ alg : ijlp ] is guaranteed to converge .",
    "moreover , a feasible primal solution can be obtained that is arbitrarily close to the solution of problem - p .",
    "the modified update rule for algorithm [ alg : ijlp ] consists of cyclically , for each @xmath106 , computing the quantity @xmath107 ( via step 2 of algorithm [ alg : ijlp ] ) and then updating @xmath108 for all @xmath109 ( based on step 3 of algorithm [ alg : ijlp ] ) .",
    "the drawback of this approach is that one bcjr update is required for each bit update , rather than for @xmath10 bit updates .",
    "this modification allows us to interpret algorithm [ alg : ijlp ] as a gauss - seidel - type algorithm .",
    "therefore , the next theorem can be seen as a natural generalization of @xcite@xcite .    _ _ [ thm : fesability]let @xmath110 and @xmath111 be the minimum value of problem - p and problem - ps _ _ , @xmath112 and @xmath113 for @xmath114 in the standard simplex .",
    "the minimum of problem - ps is equal to the maximum of problem - ds . _",
    "_ ] _ and denote @xmath115 be the optimum solution of problem - ps . for any @xmath116 _ , _ there exist sufficiently large @xmath75 and @xmath117 such that sufficient many iterations of the modified algorithm [ alg : ijlp ] yields @xmath118 which is feasible in problem - p and satisfies _ @xmath119",
    "to validate proposed solutions for the problem of the joint decoding of a binary - input fsc and outer ldpc , we use the following two simulation setups :    * for preliminary studies , we use @xmath120-regular binary ldpc codes with length 455 on the precoded dicode channel ( pdic ) * for practical study , we use a @xmath121-regular binary ldpc code with length 4923 and rate 8/9 on the class - ii partial response ( pr2 ) channel used as a partial - response target for perpendicular magnetic recording .",
    "all parity - check matrices were chosen randomly except that double - edges and four - cycles were avoided . since the performance depends on the transmitted codeword , the results were obtained for a few chosen codewords of fixed weight .",
    "the weight was chosen to be roughly half the block length , giving weights 226 and 2462 .",
    "[ fig : result1 ] shows the decoding results based on the algorithm [ alg : ijlp ] compared with the joint lp decoding performed in the dual domain using matlab in the first setup .",
    "the choice of parameters and scheduling scheme has yet to be optimized .",
    "instead , we use a simple scheduling update scheme : variables are updated cyclically with 5 inner loop iterations after single outer iteration with @xmath122 . somewhat interestingly , we find that iterative joint lp decoding wer curve loses about 0.2  db at low snr .",
    "this may be caused by using too few iterations or finite values of @xmath75 and @xmath117 .",
    "but , at high snr this gap disappears and the curve converges towards the error rate predicted for joint lp decoding .",
    "this shows that joint lp decoding outperforms belief - propagation decoding for short length code at moderate snr with the predictability of lp decoding .",
    "of course this can be achieved with a computational complexity similar to turbo equalization .",
    "[ fig : result3 ] shows the decoding results based on the algorithm [ alg : ijlp ] compared with the state - based jimpd algorithm described in @xcite in more practical scenario . to make a fair comparison , we fix the maximum iteration count , @xmath123 of each algorithm to roughly 1000 and choose @xmath124 for algorithm [ alg : ijlp ] .",
    "surprisingly , we find that iterative joint lp decoding wer curve with algorithm [ alg : ijlp ] wins over jimpd at all snr with substantial gains .",
    "also , the slope difference between two curves anticipate greatly better error - floor performance of algorithm [ alg : ijlp ] .",
    "this shows that joint lp decoding outperforms belief - propagation decoding even for long length code at all snr with a computational complexity similar to te .",
    "the dashed curves are computed using the union bound based on joint - decoding pseudo - codewords observed at 2.67 db as described in @xcite note that snr is defined as channel output power divided by @xmath126 . ]",
    "in this paper , we consider the problem of low - complexity joint linear - programming ( lp ) decoding of low - density parity - check codes and finite - state channels .",
    "we present a novel iterative solver for the joint lp decoding problem .",
    "this greatly reduces the computational complexity of the joint lp solver by exploiting the lp dual problem structure .        c.  douillard , m.  jzquel , c.  berrou , a.  picart , p.  didier , and a.  glavieux , `` iterative correction of intersymbol interference : turbo equalization , '' _ eur .",
    "trans .  telecom .",
    "_ , vol .  6 , no .  5 , pp .",
    "507511 , sept .",
    "1995 .",
    "w.  e. ryan , `` performance of high rate turbo codes on a pr4-equalized magnetic recording channel , '' in _ _ proc .",
    "ieee int .",
    "commun.__1em plus 0.5em minus 0.4ematlanta , ga , usa : ieee , june 1998 , pp . 947951 .",
    "m.  berg and p.  h. siegel , `` performance analysis of turbo - equalized dicode partial - response channel , '' in _ proc .",
    "36th annual allerton conf .  on commun . , control , and comp .",
    "_ , monticello , il , usa , sept .",
    "1998 , pp .",
    "230239 .",
    "kim and h.  d. pfister , `` on the joint decoding of ldpc codes and finite - state channels via linear programming , '' in _ proc .",
    "information theory _",
    ", austin , tx , june 2010 , pp . 754758 .",
    "m.  punekar and m.  f. flanagan , `` low complexity linear programming decoding of nonbinary linear codes , '' in _ proc .",
    "48th annual allerton conf .  on commun . , control , and comp .",
    "_ , monticello , il , sept . 2010 .",
    "kim and h.  d. pfister , `` joint decoding of ldpc codes and finite - state channels via linear - programming , '' jan .",
    "2011 , submitted to _ ieee j. select .",
    "topics in signal processing_. [ online ] .",
    "available : http://arxiv.org/abs/1102.1480 .",
    "a.  kavi , x.  ma , and m.  mitzenmacher , `` binary intersymbol interference channels : gallager codes , density evolution and code performance bounds , '' _ ieee trans .",
    "theory _ , vol .",
    "49 , no .  7 , pp .",
    "16361652 , july 2003 .",
    "s.  jeon , x.  hu , l.  sun , and b.  kumar , `` performance evaluation of partial response targets for perpendicular recording using field programmable gate arrays , '' _ ieee trans .",
    "_ , vol .",
    "43 , no .  6 , pp .",
    "22592261 , 2007 .",
    "this figure shows comparison between the iterative joint lp decoding and other te based methods on the pr2 channel with awgn for random ( 3,27 ) regular ldpc codes of length @xmath127 .",
    "the curves shown are the joint iterative lp decoding wer ( solid ) , the stated - based joint iterative message - passing ( mp ) decoding wer ( dash - dot ) described in @xcite , and the soft output viterbi algorithm ( sova)-based te decoding wer ( dashed ) taken from @xcite .",
    "note that snr is defined as channel output power divided by @xmath126 . ]"
  ],
  "abstract_text": [
    "<S> in this paper , we for the joint linear - programming ( lp ) decoding of low - density parity - check ( ldpc ) codes and finite - state channels ( fscs ) . </S>",
    "<S> in particular , we extend the approach of iterative approximate lp decoding , proposed by vontobel and koetter and explored by burshtein , to this problem . by taking advantage of the dual - domain structure of the joint decoding lp , </S>"
  ]
}