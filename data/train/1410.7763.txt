{
  "article_text": [
    "the essence of programming is to manipulate data structures through procedures @xcite .",
    "objects which group ( _ encapsulate _ ) data and the procedures ( _ methods _ ) to use them is at the basis of object - oriented programming .",
    "when the decomposition into objects is adequate , object programming is usually considered as leading to more natural and safer programs as it reduces the distance between the programmer s intuition and the program structure .",
    "for example , let us consider a physical system made of atoms .",
    "in an object - oriented approach , an atom is quite naturally represented by an object containing the atom state ( e.g. position , velocity , and mass ) and the procedures to transform the atom state ( e.g. computing the next position ) .",
    "some systems to simulate physics are coded with objects as lammps , programmed in c++ @xcite . as more traditional systems programmed in fortran ( e.g. dl_poly @xcite ) ,",
    "their central structure basically consists in arrays storing data , and loops to process the array elements in turn .",
    "a general issue with such structures is the difficulty to add ( and to remove ) data , or objects , during the course of a simulation ( _ dynamically _ ) .",
    "some molecular simulation systems are able to deal with dynamic creation of chimical bonds ( this is for example the case of lammps , in which the reaxff @xcite potential is implemented ) , but , to our knowledge , no simulation system is able to deal with the dynamic creation / destruction of general components ( e.g. atoms )",
    ".    the dynamic creation / destruction of components can be useful to model multi - scale systems @xcite , in which the scale of sub - systems is allowed to change during execution .",
    "let us consider , a molecule simulated at the all - atom ( aa ) scale ; when the molecule is isolated from the others , il may be possible to switch its scale to coarse - grained ( cg ) and thus to simulate the molecule more efficiently . the inverse scale change may be mandatory when molecules become so close that their interactions must be described at the lowest aa level . in both cases ,",
    "a change of scale can be seen as the _ replacement _ of the molecule by a new one .",
    "for example , the aa to cg change of scale consists in the creation of a new cg molecule , simultaneous with the destruction of the old aa molecule .    in this text",
    ", we propose an approach to the implementation of physical simulations in which the dynamic creation or destruction of components can be simply and naturally expressed .",
    "the objective is the design of a molecular dynamics ( md ) system allowing multi - scale modeling .",
    "we use a programming approach , called reactive programming ( rp ) @xcite , with a generalized notion of object : an object encapsulates not only its data and methods to manipulate them , but also its _ behaviour _ which can be used to code its interactions with the other objects . in this context",
    ", a simulation is structured as an assembly of interacting objects whose behaviours are run in a coordinated way , by an execution machine able to dynamically create and run new objects , and to destroy others .",
    "the paper is structured as follows : section [ section : rationale ] justifies the use of rp for the implementation of physical simulations .",
    "section [ section : reactive - programming ] describes rp in general and more precisely the sugarcubes framework .",
    "md is described in section [ section : molecular - dynamics ] .",
    "the implementation of the md simulation system is described in section [ section : md - system ] .",
    "related work is considered in section [ section : related - work ] , and section [ section : conclusion ] concludes the paper , giving several tracks for future work .",
    "when it is not possible , while considering a physical system , to find exact analytical solutions describing its dynamics , the numerical simulation approach becomes mandatory .",
    "numerical simulations are based , first , on a discretization of time and second , on a stepwise _ resolution method _ implementing an integration algorithm .",
    "the possibility to get analytical solutions is basically limited by complexity issues : complex systems can not usually be analytically solved .",
    "this renders numerical simulations an important topics for physics .",
    "[ [ parallelism . ] ] parallelism .",
    "+ + + + + + + + + + + +    at the logical level , it is often the case that the processing of a complex system is facilitated by decomposing it into several sub - systems linked together .",
    "the sub - systems can thus be considered as independent components , running and interacting in a coordinated way .",
    "recast in the terminology of informatics , one would say that the sub - systems are run _ in parallel _ in an environment where they share the same notion of time . here , we are not speaking of real time but of a _ logical time _",
    ", shared by all the sub - systems . in this approach ,",
    "the steps of the numerical resolution method used to simulate the system have to be mapped onto the logical time ; we shall return on this subject later .",
    "since we are assuming time to be logical , we should also qualify parallelism as being logical : parallelism is not introduced here to accelerate execution ( for example , by using several processors ) but to describe a complex system as a set of parallel entities .",
    "the use of real - parallelism ( offered by multiprocessor and multicore machines ) to accelerate simulations is of course a major issue , but we think that it is basically a matter of _ optimisation _ , while the use of logical parallelism is basically a matter of _ expressivity_.    [ [ determinism . ] ] determinism .",
    "+ + + + + + + + + + + +    simulations of physical systems must verify a strong and mandatory constraint : no energy should be either created or destroyed during the simulation of a closed system ( without interaction with the external world ) . in other words , _ total energymust be preserved _ during the simulation process .",
    "this is a fundamental constraint : it corresponds to the _ reversibility in time _ of the newton s laws which is at the basis of classical physics .",
    "this constraint can be formulated differently : classical physics is _",
    "deterministic_. in informatics , this has a deep consequence : as physical simulations should be deterministic , one should give the preference to programming languages in which programs are _",
    "deterministic by construction_. note however , that parallelism and determinism do not usually go well together ; there are very few programming languages which are able to provide both ; we shall return on this point later .",
    "[ [ broadcast - events . ] ] broadcast events .",
    "+ + + + + + + + + + + + + + + + +    in addition to time reversibility , classical physics rests on a second fundamental assumption : forces ( gravitation , electrostatic and inter - atomic forces ) are instantaneously transmitted .",
    "instantaneity in our case should accommodate with the presence of the logical time ; actually , instantaneity means that action / reaction forces ( third newton s law ) should always be exerted during the same instant of the logical time .",
    "it is in the nature of classical physical forces to be broadcast everywhere . in informatics terms , forces correspond to information units that are instantaneously broadcast to all parallel components .",
    "this vision of forces actually identifies forces with _ instantaneously broadcast events _ ; we shall see that this notion of instantaneously broadcast event exists in the so - called synchronous reactive formalisms , which thus appear to be good candidates to implement physical simulations .",
    "[ [ modularity . ] ] modularity .",
    "+ + + + + + + + + + +    it may be the case that some components of a system have to be removed from the system because their simulation is no more relevant ( imagine for example an object whose distance from the others becomes greater than some fixed threshold , so that its contribution may be considered as negligible ) .",
    "destruction of components is usually not a big issue in simulations : in order to remove an object from the global system , it may be for example sufficient to stop considering it during the resolution phase .",
    "dually , in some situation , new components may have to be created , for example in chemistry where chemical bonds linking two atoms can appear in the course of a simulation .",
    "dynamic creation is more difficult to deal with than destruction ; for example , a new created object must be introduced only at specific steps of the resolution method , in order to avoid inconsistencies . in informatics terms , both dynamic destruction and dynamic creation of parallel components should be possible during the course of simulations .",
    "this possibility is often called _ modularity _ : in a modular system , new components can appear or disappear during execution , without need to change the other components .",
    "note that the notion of broadcast event fits well with modularity as the introduction of a new component listening or producing an event , or the removal of an already existing one , does not affect the communication with the other parallel components .",
    "[ [ hybrid - systems . ] ] hybrid systems .",
    "+ + + + + + + + + + + + + + +    there exist _ hybrid _ physical systems which mix continuous and discrete aspects .",
    "for example , consider a ball linked by a string to a fixed pivot and turning around the pivot ( continuous aspect ) ; one can then consider the possibility for the string to be broken ( discrete aspect ) .",
    "numerical simulations of hybrid systems are more complex than those of standard systems : in the previous example , the string component has to be removed from the simulation when the destruction of the string occurs , and the simulation of the ball has to switch from a circle to a straight line . in this respect ,",
    "a hybrid system can be seen as gathering several related systems ( for example , the system where the ball is linked to the pivot , and the system where it is free ) ; then , the issue becomes to define when and how to switch from one system to another .",
    "note that the simulation of hybrid systems is related to modularity : in the previous example , one can consider that the breaking of the string entails on the one hand the destruction of both the string component and the circular - moving ball , and on the other hand the _ simultaneous creation _ of a straight - moving new ball appearing at the position of the old one .",
    "[ [ resolution - method . ] ] resolution method .",
    "+ + + + + + + + + + + + + + + + + +    let us discuss now the relation between logical time and the discretized time of the resolution method .",
    "we shall call _ instant _ the basic unit of the logical time ; thus , a simulation goes through a first instant , then a second , and so on , until termination .",
    "the only required property of instants is convergence : all the parallel components terminate at each instant .",
    "execution of instants does not necessarily take the same amount of real time ; actually , real time becomes irrelevant for the logic of simulations : the basic simulation time is the logical time , not the real time .",
    "the numerical resolution method works on a time discretized in _ time - steps _ during which forces integration is performed according to newton s second law .",
    "typically , in simulations of atoms , time - steps have a duration of the order of the femto - second .",
    "several steps of execution may be needed by the resolution algorithm to perform one time - step integration ; for example , two steps are needed by the velocity - verlet integration scheme @xcite to integrate forces during one time - step : positions are computed during the first step , and velocities during the second . actually , a quite natural scheme associates _ two _ instants with each time - step : during the first instant , each component provides its own information ; the global information produced during the first instant is then processed by each component during the second instant .",
    "note that such a two - instant scheme maps quite naturally to the velocity - verlet method : each step of the resolution method is performed during one instant .",
    "[ [ multi - time - aspects . ] ] multi - time aspects .",
    "+ + + + + + + + + + + + + + + + + + +    the use of the same time - step during the whole simulation is not mandatory : one calls _ multi - time _ a system in which the time - step of the resolution method is allowed to vary during the simulation .",
    "the change of time - step can be _ global _ , meaning that it concerns all the objects present in the simulation .",
    "this can be helpful for example to get a more accurate simulation when a certain configuration of objects is reached ( for example , when objects become confined in a certain volume ) .",
    "alternatively , the change of time - step can be _ local _",
    ", i.e. concerning only certain objects , but not all .",
    "this means that different components of the same simulation are simultaneously simulated using different time - steps",
    ". this could be the case for a system in which _ diffusion _ aspects occur ; in such a system , objects in some regions are separated by large distances and evolve freely , simulated with large time - steps , while in other regions , objects are closely interacting and should thus be simulated using smaller time - steps .",
    "we will return later on a situation of this kind .",
    "we shall call such systems _ multi - time , multi - step _ systems ( mtms systems , for short ) .",
    "a major interest of mtms is that loosely - coupled objects ( with rare interactions ) can be simulated during long time periods .    in this text",
    ", we consider the reactive programming @xcite ( rp ) approach to simulate physical systems .",
    "the choice of rp is motivated by the fact that rp genuinely offers logical parallelism , instantaneously broadcast events , and dynamic creation / destruction of parallel components and events .",
    "moreover , we choose a totally deterministic instance of rp , called sugarcubes @xcite , based on the java programming language : indeed , in sugarcubes , programs are deterministic by construction .",
    "to illustrate our approach , we shall consider the implementation of a mtms simulation system of molecular dynamics @xcite ( md ) in the context of java , with the java3d library @xcite for 3d visualisation .",
    "reactive programming @xcite ( rp ) offers a simple framework , with a clear and sound semantics , for expressing logical parallelism . in the rp approach , systems are made of parallel components that share the same _",
    "instants_. instants thus define a _ logical clock _ , shared by all components .",
    "parallel components synchronise at each end of instant , and thus execute at the same pace . during instants",
    ", components can communicate using _",
    "instantaneously broadcast events _ , which are seen in the same way by all components .",
    "there exists several variants of rp , which extend general purpose programming languages ( for example , reactivec @xcite which extends c , and reactiveml @xcite which extends the ml language ) . among these reactive frameworks",
    "is sugarcubes @xcite , which extends java . in sugarcubes ,",
    "the parallel operator is very specific : it is totally deterministic , which means that , at each instant , a sugarcubes program has a unique output for each possible input .",
    "actually , in sugarcubes parallelism is implemented in a sequential way .    due to its `` determinism by construction ''",
    ", we have choosen to use the sugarcubes framework to implement the md system ; we are going to describe sugarcubes in the rest of the section .",
    "the two main sugarcubes classes are instruction and machine .",
    "instruction is the class of reactive instructions which are defined with reference to instants , and machine is the class of reactive machines which run reactive instructions and define their execution environment .",
    "the main instructions of sugarcubes are the following ( their names always start by the prefix sc ) :    * sc.nothing does nothing and immediately terminates .",
    "* sc.stop does nothing and suspends the execution of the running thread for the current instant ; execution will terminate at the next instant .",
    "* sc.seq ( inst1,inst2 ) behaves like inst1 and switches immediately to inst2 as soon as inst1 terminates .",
    "* sc.merge ( inst1,inst2 ) executes one instant of instructions inst1 and inst2 and terminates if both inst1 and inst2 terminate .",
    "execution always starts by inst1 and switches to inst2 when inst1 either terminates or suspends . *",
    "sc.loop ( inst ) executes cyclically inst : execution of inst is immediately restarted as soon as it terminates .",
    "one supposes that it is not possible for inst to terminate at the same instant it is started ( otherwise , one would get an _ instantaneous loop _ which would cycle forever during the same instant , preventing thus the reactive machine to detect the end of the current instant ) . *",
    "sc.action ( jact ) runs the execute method of the java action jact ( of type javaaction ) ( this can happen several time , as the action can be in a loop ) .",
    "* sc.generate ( event , value ) generates event , with value as associated value , and immediately terminates .",
    "* sc.await ( event ) terminates immediately if event is present ( i.e. it has been previously generated during the current instant ) , otherwise , execution is suspended waiting either for the generation of event or for the end of the current instant , detected by the reactive machine .",
    "* sc.callback ( event , jcall ) executes the java callback jcall ( of type javacallback ) for each value generated with event during the current instant . in order not to lose",
    "possibly generated values , the execution of the instruction lasts during the whole instant and terminates at the next instant . *",
    "sc.until ( event , inst ) executes inst and terminates either because inst terminates , or because event is present .    the sequence and merge operators",
    "are naturally extended to more than two branches ; for example sc.seq ( i1,i2,i3 ) is the sequence of the three instructions i1,i2,i3 .",
    "a reactive machine of the class machine runs a program ( of type program ) which is an instruction ( initially sc.nothing ) .",
    "new instructions added to the machine are put in parallel ( merge ) with the previous program .",
    "addings of new instructions do not occur during the course of an instant , but only at beginnings of instants .",
    "basically , a machine cyclically runs its program , detects the end of the current instant , that is when all branches of merge instructions are all terminated or suspended , and then goes to the next instant .",
    "note that the execution of an instruction by a machine during one instant can take several phases : for example , consider the following code , supposing that event e is not already generated :    .... sc.merge (      sc.await e ,      sc.generate ( e , null ) ) ....    execution switches to the await instruction ( line 2 ) which is suspended , as e is not present .",
    "then , execution switches to the generate instruction ( line 3 ) , which produces e and terminates .",
    "the executing machine detects that execution has to be continued , because one branch of a merge instruction is suspended , awaiting an event which is present .",
    "thus , the await instruction is re - executed , and it now terminates , as e is present .",
    "the merge instruction is also now terminated .",
    "the execution of a program by a machine is totally deterministic : only one trace of execution is possible for a given program .",
    "the execution of sugarcubes programs is actually purely sequential : the parallelism presently offered by sugarcubes is a logical one , not a real one ; the issue of real parallelism is considered in sec . [ section : conclusion ] .",
    "numerical simulation at atomic scale predicts system states and properties from a limited number of physical principles , using a numerical resolution method implemented with computers . in molecular dynamics ( md ) @xcite systems are organic molecules , metallic atoms , or ions .",
    "the goal is to determine the temporal evolution of the geometry and energy of atoms .    at the basis of md",
    "is the classical ( newtonian ) physics , with the fundamental equation :    @xmath0    where @xmath1 is the force applied to a particle of mass @xmath2 and @xmath3 is its acceleration ( second derivative of the variation of the position , according to time ) .",
    "a _ force - field _ is composed of several components , called",
    "_ potentials _ ( of bonds , valence angles , dihedral angles , van der waals contributions , electrostatic contributions , _ etc_. ) and is defined by the analytical form of each of these components , and by the parameters caracterizing them .",
    "the basic components used to model molecules are the following :    * atoms , with 6 degrees of freedom ( position and velocity ) ; * bonds , which link two atoms belonging to the same molecule ; a bond between two atoms @xmath4 tends to maintain constant the distance @xmath5 .",
    "* valence angles , which are the angle formed by two adjacent bonds @xmath6 et @xmath7 in a same molecule ; a valence angle tends to maintain constant the angle @xmath8 .",
    "a valence angle is thus concerned by the positions of three atoms . * torsion angles ( also called _ dihedral angles",
    "_ ) are defined by four atoms @xmath9 consecutively linked in the same molecule : @xmath10 is linked to @xmath11 , @xmath11 to @xmath12 , and @xmath12 to @xmath13 ; a torsion angle tends to priviledge particular angles between the planes @xmath14 and @xmath15 .",
    "* van der waals interactions apply between two atoms which either belong to two different molecules , or are not linked by a chain of less than three ( or sometimes , four ) bonds , if they belong to the same molecule .",
    "they are pair potentials .",
    "all these potentials depend on the nature of the concerned atoms and are parametrized differently in specific force - fields .",
    "molecular models can also consider electrostatic interactions ( coulomb s law ) which are pair potentials , as van der waals potentials are ; their implementation is close to van der waals potentials , with a different dependence to distance .    intra - molecular forces ( bonds , valence angles , torsion angles ) as well as inter - molecular forces ( van der waals ) are conservative : the work between two points does not depend on the path followed by the force between these two points .",
    "thus , forces can be defined as derivatives of scalar fields . from now on",
    ", we consider that potentials are scalar fields and we have :    @xmath16    where @xmath17 denotes the coordinates of the point on which the force @xmath18 applies , and @xmath19 is the potential from which the force derives .",
    "the precise definition of the application of forces according to a specific force - field ( namely , the opls force - field @xcite ) is described in detail in @xcite , from which we have taken the overall presentation of md .",
    "we now describe the rationals for the choice of rp to implement md .",
    "the choice of rp , and more specifically of sugarcubes , is motivated by the following reasons :    * md systems are composed of separate , interacting components ( atoms and molecules ) .",
    "it seems natural to consider that these components execute in parallel . in standard approaches",
    ", there is generally a `` big loop '' which considers components in turn ( components are placed in an array ) .",
    "this structuration is rather artificial and does not easily support dynamic changes of the system ( for example , additions of new components or removals of old ones , things that one can find in modeling chemical reactions ) .",
    "* in md simulations , time is discrete , and the resolution method which is at the heart of simulations is based on this discrete time . in rp , time is basically discrete , as it is decomposed in instants . thus , rp makes the discretisation of time which is at the basis of md very simple . *",
    "md is based on classical ( newtonian ) physics which is deterministic .",
    "the strict determinism of the parallel operator provided by sugarcubes reflects the fundamental determinism of newtonian physics . at implementation level",
    ", it simplifies debugging ( a faulty situation can be simply reproduced ) . at the physical level",
    ", it is mandatory to make simulations reversible in time . * in classical physics",
    ", interactions are instantaneous which can be quite naturaly expressed using the instantaneously broadcast event notion of rp .    in conclusion ,",
    "the use of rp for md simulations is motivated by its following characteristics : modularity of logical parallelism , intrinsic discretisation of time due to instants , strict determinism of the parallel operator , instantaneity of events used to code interactions .",
    "let us now consider the use of rp to implement molecular dynamics .",
    "a molecular system consists in a set of molecules , each molecule being made of atoms , bonds , valence angles and torsion angles . in the approach we propose , the molecule components ( atoms , bond , angles ) are _ programs _ that are executed under the supervision of another main program called a _",
    "reactive machine_. the reactive machine is in charge of executing the components in a coordinated way , allowing them to communicate through _ events_. events are broadcast to all the components run by the reactive machine , that is , all components always `` see '' an event in the same way : either it is present for all components if it is generated by one of them , or it is absent for all components if it is not generated during the instant .",
    "all events are reset to absent by the reactive machine at the beginning of each instant .",
    "values can be associated with event generations . in order to process the values generated with an event",
    ", a component has to wait during the whole instant , processing the values in turn , as they are generated .    the reactive machine proceeds in instants : the first instant is executed , then the second , and so on indefinitely .",
    "all components ( atoms , bonds , etc ) in the machine are run at each instant and there is an implicit synchronization ( synchronization barrier ) of all the components at the end of each instant .",
    "in this way , one is sure that all component have finished their reaction for the current instant and have processed all the generated events and all their values before the next instant can start . basically , this mode of execution is synchronous parallelism .",
    "the steps of the resolution method ( velocity - verlet ) are identified with the instants of the reactive machine .",
    "the positions of atoms are computed during one step of the resolution method , and the velocities during the next step .",
    "actually , at each instant , atoms generate their position and collect the various forces exerted on them ( by bonds , angles , etc ) .",
    "the new positions are computed from previously collected information at even instants and the new velocities are computed at odd instants , following the two - step scheme of the velocity - verlet numerical resolution method .",
    "note that the new positions and velocities are computed by the atom itself : we say that they are parts of the atom _",
    "behavior_. strictly speaking , an atom is a structure that encapsulates data ( in particular , position and velocity ) together with a behavior which is a program intended to be run by the reactive machine in which the atom is added .",
    "the good programming practice is that the atom s behavior is the only component that should access the atom s data .",
    "this discipline entails the absence of time - dependent errors . as direct access to the atom s data",
    "is unwilled , events are the only means for a component to influence an atom . for example , in order to apply a force to an atom , a component generates an event whose value is the force ; the atom should wait for the event and process the generated values ; in this way , the atom is able to process the force applied to it .",
    "the constuction of molecules is a program whose execution adds the molecule components into the reactive machine . the main steps to simulate a molecular system are : 1 ) define a reactive machine ; 2 ) run a set of molecules in order to add them in the machine ; 3 ) cyclically run the machine .    in the rest of this section",
    ", we give a brief overview of the various programs that are used to build a simulation .",
    "note that these are small pieces of code , that we hope to be natural and easily readable .",
    "this depart from standard md system descriptions , which are usually decomposed in procedures whose chaining of calls is poorly specified . in our approach ,",
    "the scheduling of the various sub - programs is made clear and unambiguous .",
    "we shall first describes ( generic and specific ) atoms , then intra - molecular components ( bonds and angles ) .",
    "we will also consider inter - molecular interactions .",
    "then , we will explain how molecules are built from the previous atoms and components .",
    "an atom cyclically collects the constraints issues from bonds , valence angles , and dihedrals , then computes one step of the resolution method , and finally visualizes itself .",
    "this behavior can be preempted by a kill signal ( generated for example when the molecule to which the atom belongs is destroyed ) .",
    "it is coded by the following sugarcubes program :    .... sc.until ( killsignal ,      sc.loop (         sc.seq (           collection ( ) ,           sc.action ( new resolution ( this ) ) ,           sc.action ( new paint3d ( this ) ) ) ) ) ....    a constraint is a force that is added to the atom .",
    "the constraints are received as values of a specific event associated with the atom ( generation of this event is considered in [ subsec : components ] ) .",
    "the collection of constraints is performed by a program which is returned by the following function collection :    .... program collection ( )     {        return sc.callback ( constraintsignal ,                  new collectconstraints ( this ) ) ;     } ....    the collectconstraints java callback is defined by :    .... public class collectconstraints implements javacallback {      final atom me ;      public void execute ( final reactiveengine _ , final object args )      {          vector3d f = ( vector3d)args ;          utils.add ( me.force,f ) ;      }      public collectconstraints ( atom me )      {          this.me = me ;      } } ....    vector3d is the type of 3d vectors .",
    "the class utils provides several methods to deal with vectors : vect creates a vector between two atoms ; normalize normalizes a vector ( same direction , but unit length ) ; sum is the vector addition ; perp is the cross - product of vectors ; opposite defines the opposite vector ; finally , extprod multiplies a vector by a scalar .",
    "the addition `` in place '' utils.add ( x , y ) is equivalent to x = utils.sum ( x , y ) .",
    "we have choosen to define the collection of constraints as a function ( and not to inline its body in the atom behavior ) to allow specific atoms to redefine it ( actually , to extend it ) for their specific purpose ; this is considered in [ subsub : spec - atom ] .",
    "action resolution performs the resolution method for the atom ; it is described in [ subsub : resolution ] .",
    "paint3d asks for the repainting of the atom ; for the sake of simplicity , we do not consider it here .",
    "the resolution method used is the _ velocity - verlet _",
    "method @xcite .",
    "let * r * be the position ( depending of the time ) of an atom , * v * its velocity , and * a * its acceleration .",
    "the _ velocity - verlet _ method is defined by the following equations , where @xmath20 is a time interval : @xmath21    implementation proceeds in two steps :    1 .",
    "compute the velocity at half of the time - step , from previous position and acceleration , by : + @xmath22 + use the result to compute the position at full time - step by : @xmath23 2 .",
    "get acceleration @xmath24 from forces applied to the atom , and compute velocity at full time - step using the velocity at half time - step by : @xmath25    in order to allow dynamic introduction of new molecules in the system , they should only be introduced at instants corresponding to the same step of the resolution method .",
    "note that , otherwise , the processing of lj forces between atoms belonging to two distinct molecules could be asymetric , which could introduce fake energy in the system .",
    "one choses to introduce molecules , and thus atoms , only at even instants .",
    "the _ velocity - verlet _ resolution is coded by the following class resolution :    .... public class resolution implements javaaction {    final atom atom ;    boolean started = false ;    final vector3d acceleration = new vector3d ( ) ;    public resolution ( atom atom )      {          this.atom = atom ;      }    public void execute ( final reactiveengine _ )      {        double dt = atom.molecule.context.timestep ;        boolean eveninstant = ( 0 = = atom.workspace.instant % 2 ) ;        if ( ! started & & !",
    "eveninstant ) return ; else started = true ;        if ( dt !",
    "= 0 ) {          if ( eveninstant ) step1 ( dt ) ; else step2 ( dt ) ;        }        atom.resetforce ( ) ;      }    void step1 ( double dt )      {        utils.add ( atom.velocity,utils.extprod ( 0.5*dt , acceleration ) ) ;        utils.add ( atom.position,utils.extprod ( dt , atom.velocity ) ) ;      }        void step2 ( double dt )      {        utils.extprod ( acceleration,1/atom.mass , atom.force ) ;        utils.add ( atom.velocity,utils.extprod ( 0.5*dt , acceleration ) ) ;              } } ....    the control of the instant at which atom resolution is started is done at lines 12 - 14 .",
    "equation [ verlet : velocity1 ] is coded at line 22 .",
    "[ verlet : position ] is then coded at line 23 ( it uses the previous atom position ) .",
    "the acceleration of the atom is computed from the force exerted on it ( second newton s law ) at line 32 .",
    "then , eq . [ verlet : velocity2 ] is computed at line 28 .",
    "note that , for all atoms , the forces computed during an odd instant are determined from the positions computed during the previous even instant .",
    "we now consider specific atoms , e.g. carbon atoms , for which we have to deal with lj interactions .",
    "the collection function is extended for this purpose .",
    "a specific event is defined for each kind of atom , on which atoms signal their existence . in this way",
    ", an atom can collect all the signaling events and compute the forces induced by the lj interactions with the other atoms .",
    "the collection function of a carbon atom is for example defined by :    .... program collection ( )     {        return sc.seq (             sc.generate ( csignal , this ) ,            sc.merge (                super.collection ( ) ,                collectlj ( csignal , new ljpotential ( ljc_c ) ) ,            collectlj ( hsignal , new ljpotential ( ljc_h ) ) ,                      collectlj ( osignal , new ljpotential ( ljc_o ) ) ) ) ;     } ....    note that this definition actually extends the previous collection method of standard atom ; this method continues to be called ( super.collection ( ) ) but is now put in parallel with the specific treatments of lj interactions .",
    "the collection of the interactions corresponding to a specific kind of atoms is coded by :    .... program collectlj ( identifier signal , potential potential )     {        return sc.callback ( signal ,           new collectinteractions ( potential , this ) ) ;     } ....    the collectinteractions callback applies the computeforce method of the potential parameter to all the atoms ( except itself ) which signal their presence through the parameter signal , and adds the obtained force to the previously collected forces .",
    "we now consider the way intra - molecular forces are produced and applied to atoms .",
    "the application of forces to atoms from a potential is defined in @xcite . here , we shall only consider bonds which are the simplest components .",
    "the treatment of the others components ( valence and torsion angles ) is very similar .",
    "htb ]        a _ harmonic bond potential _ is a scalar field @xmath26 which defines the potential energy of two atoms placed at distance @xmath27 as : @xmath28 where @xmath29 is the strength of the bond and @xmath30 is the equilibrium distance ( the distance at which the force between the two atoms is null ) .",
    "we thus have : @xmath31    bonds are coded by the class harmonicbond which has the following behavior :    .... sc.loop (     sc.seq (        sc.action ( new controllength ( ) ) ,        sc.generate ( first.constraintsignal,fa ) ,        sc.generate ( second.constraintsignal,fb ) ,        sc.action ( new paint3d ( this ) ) ,        sc.stop ( ) )   ) ....    the controllength action is called at each instant , to determine the force to be applied to the two atoms linked by the bond .",
    "the application of forces is realized through the constraintsignal of the two atoms .",
    "the applied forces are the values generated with these events .",
    "note the presence of the stop statement to avoid an instantaneous loop ( which would produce a warning message at each instant ) .",
    "the controllength action sets the force field of class harmonicbond and is defined by :    .... public class controllength implements javaaction {      public void execute ( final reactiveengine _ )         {             double dist = utils.distance ( a , b ) ;             double diff = dist - length ;             energy = strength * diff * diff ;             dudr = 2.0 * strength * diff ;             vector3d v12 = utils.vect ( a , b ) ;             v12.normalize ( ) ;             utils.extprod ( fa , dudr , v12 ) ;             utils.extprod ( fb ,- dudr , v12 ) ;         } } ....    eq . [ bond : potential ] is coded at line 7 , and eq .",
    "[ bond : force ] at line 8 .",
    "the force to be applied to the first atom is computed at line 11 ( the force to be applied to the second is the opposite ) .",
    "we are considering molecules made of carbon and hydrogen atoms ( linear alkane ) , as shown on fig .",
    "[ figure : carbonchain ] .",
    "the two extremal carbon atoms have three hydrogen atoms attached to them , while the others have two .",
    "the number of carbon atoms is a parameter .    [ !",
    "htb ]        these molecules are coded by the class carbonchain . the following method builds a carbon chain with cnum carbon atoms :    .... public void build ( )     {        buildbackbone ( ) ;        addtop ( ) ;        for ( int k = 1 ; k < cnum-1 ; k++ ) addh2 ( k ) ;        addbottom ( ) ;        createbonds ( ) ;        createangles ( ) ;        createdihedrals ( ) ;     } ....    the backbone of carbon atoms is built by the call to buildbackbone .",
    "methods addtop and addbottom add 3 hydrogen atoms to the extremities of the molecule , and addh2 adds 2 hydrogens to each carbon , except the extremities .",
    "the molecule components are created by the 3 methods createbonds , createangles , and createdihedrals .",
    "the crucial point is that created molecules have an energy which is minimal .",
    "minimality is obtained by placing atoms at positions compatibles with the potentials of the molecule components .",
    "let us consider how this is done for the two hydrogens attached to each carbon , except the extremities .",
    "one first defines the ( equilibrium ) length lch of bonds between carbon and hydrogen atoms , and the ( equilibrium ) valence angle ahch between two hydrogens and one carbon atoms .    .... double lch = bondc_h[1 ] ; double ahch = angleh_c_h[1 ] ; double cos = lch * math.cos ( ahch /2 ) ; double sin = lch * math.sin ( ahch /2 ) ; ....    the addh2 method is defined by :    ....    void addh2 ( int k )      {        atom a = backbone[k-1 ] ;        atom b = backbone[k ] ;        atom c = backbone[k+1 ] ;          vector3d ba = utils.vect ( b , a ) ;        vector3d bc = utils.vect ( b , c ) ;        vector3d p = utils.normalize ( utils.sum ( ba , bc ) ) ;        vector3d n = utils.normalize ( utils.perp ( ba , bc ) ) ;                 vector3d u = utils.extprod ( -cos , p ) ;        vector3d v = utils.extprod ( -sin , n ) ;        vector3d w = utils.sum ( u , v ) ;        vector3d q = utils.sum ( u , utils.opposite ( v ) ) ;                          atom h1 = new h ( this , utils.sum ( b.position,w),b.velocity ) ;        atom h2 = new h ( this , utils.sum ( b.position,q),b.velocity ) ;                        others [ k ] = new atom [ 2 ] ;        others [ k][0 ] = h1 ;        others [ k][1 ] = h2 ;    } ....    atoms a , b , c are three successive carbon atoms , and b is the carbon on which two hydrogens have to be attached .    two hydrogens atoms h1 and h2 are created and placed at their correct equilibrium positions . the two hydrogens are made accessible by the others array of b. by this construction , the two planes h1bh2 and abc are orthogonal , the angle h1bh2 is equals to ahch , and the distances h1b and h2b are both equal to lch .    we now consider the creation of bonds . for the sake of simplicity , we do not consider the other components , which are processed in a similar manner .",
    "bonds are created by the following method :    .... void createbonds ( )     {        for ( int k = 0 ; k < cnum - 1 ; k++ ) {           new harmonicbond ( this , backbone[k],backbone[k+1],bondc_c ) ;        }        for ( int k = 0 ; k < cnum ; k++ ) {            atom c = backbone [ k ] ;              for ( int l = 0 ; l < others [ k].length ; l++ ) {                 atom a = others[k][l ] ;                 if ( a instanceof h )                     new harmonicbond ( this , c , a , bondc_h ) ;                 else if ( a instanceof o )                     new harmonicbond ( this , c , a , bondc_o ) ;                        }         }         } ....    lines 12 - 13 consider the case of oxygen atoms , to build acid molecules , which is not considerered here .",
    "the molecule shown on fig .",
    "[ figure : carbonchain ] is made of 20 atoms , 19 bonds , 36 valence angles , and 45 dihedral angles .",
    "reactive machines are basically provided by the class simulation which extends the class machine .",
    "an application can simply be defined as an extension of simulation , as in :    .... public class minimalapp extends simulation {    int cnum = 6 ;    double timestep = 1e-3 ;    void molecule ( double x , double y , double z )       {          molecule mol = new carbonchain ( this , cnum , x , y , z,0,0,0 ) ;      mol.context.timestep = timestep ;      mol.build ( ) ;      mol.registerin ( this ) ;       }    public minimalapp ( )        {           createuniverse ( ) ;           double dist = 0.4 ;           molecule ( -dist,0.5,0 ) ;           molecule ( dist,0.5,0 ) ;        }     public static void main ( string [ ] args )        {            standalone ( new minimalapp ( ) ) ;        } } ....    the number of carbon atoms cnum is set to 6 and the time - step is set to the femto - second ( lines 3 and 4 ; the basic time unit of the system is the pico - second ) . a function which creates a molecule is defined lines 5 - 11 .",
    "the molecule is built and registered in the simulation ( which is denoted by this ) ; the registration of the molecule entails the registration of all its components .",
    "the time - step of the created molecule is also set by the function .",
    "the constructor of the class is defined in lines 12 - 18 .",
    "first , the createuniverse method provided by java3d is called to initialise the graphics , then two molecules are created .",
    "the definition of the main java method terminates the definition of the class minimalapp .",
    "the intial state of the simulation is shown on left of fig .",
    "[ figure : simul1 ] and the result after 50 ns ( @xmath32 instants ) is shown on the right .",
    "the evolution of the energy up to 200 ns ( the internal energy unit is @xmath33 ) is shown on fig .",
    "[ figure : stability ] to illustrate the stability of the resolution ( actually , stability has been tested up to one micro - second , that is @xmath34 instants ) . the mean value is @xmath35 with standard deviation @xmath36 .",
    "the energy is negative as result of the attraction due to van der waals forces .    [ !",
    "htb ]        [ ! htb ]",
    "the domain of physical simulations is huge and we shall thus only consider the use of reactive programming for implementing them , and the implementations of md systems .    the application of reactive programming to newtonian physics has been initiated by alexander samarin in @xcite where several 2d `` applets '' are proposed to illustrate the approach .    cellular automata ( ca ) have been used in several contexts of physics .",
    "the implementation of ca using a reactive programming formalism is described in @xcite .    in @xcite",
    "is described a system that mimicks several aspects of quantum mechanics ( namely , self - interference , superposition of states , and entanglement ) .",
    "the system basically relies on a cellular automaton plunged into a reactive based simulation whose instants define the global time .",
    "actually , this can not be strictly speaking considered as a physical simulation but more as a kind of `` proof of concept '' .",
    "a large number of md simulation systems exist ( for example @xcite and @xcite , which are both open - source software ) .",
    "they are implemented in fortran or c / c++ . at the implementation level , the focus is put on real - parallelism and the use of multi - processor and/or multi - core architectures . on the contrary , we have choosen to use the java language , and to put the focus more on expressivity than on efficiency , by using the logical parallelism of rp .",
    "we have adopted an open - source approach and integrated the 3d aspects directly in the system , by using java3d .",
    "we have shown that rp can be considered as a valuable tool for the implementation of simulations in classical physics .",
    "we have illustated our approach by the description of a md system @xcite coded in rp .",
    "we plan to extend this md system in several directions :    * introduction of several multi - scale , multi - time - step aspects , building thus a true mtms system .",
    "note that the dynamic creation / destruction possibilities offered by rp will be central for the implementation of several notions ( chimical reactions and reconstruction techniques , for example ) .",
    "* use of real - parallelism .",
    "a first study has lead to the definition of a new version of sugarcubes ( called sugarcubesv5 @xcite ) in which gpu - based approaches become possible .",
    "the use of multi - processor machines should also of course be of great interest ."
  ],
  "abstract_text": [
    "<S> we consider the reactive programming ( rp ) approach to simulate physical systems . </S>",
    "<S> the choice of rp is motivated by the fact that rp genuinely offers logical parallelism , instantaneously broadcast events , and dynamic creation / destruction of parallel components and events . to illustrate our approach </S>",
    "<S> , we consider the implementation of a system of molecular dynamics , in the context of java with the java3d library for 3d visualisation .    </S>",
    "<S> [ [ keywords . ] ] keywords . </S>",
    "<S> + + + + + + + + +    concurrency  ; parallelism  ; reactive programming  ; physics  ; molecular dynamics . </S>"
  ]
}