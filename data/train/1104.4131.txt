{
  "article_text": [
    "tableau - based reasoning is popular in many areas of computer science and various branches of logic . for description logics and ontology",
    "reasoning they provide the main method for doing reasoning ( see , for example ,  @xcite ; some recent work is  @xcite ) . for modal logics and applications such as multi - agent systems tableau approaches",
    "are frequently used ( see , for example ,  @xcite ; some recent work is  @xcite ) .",
    "tableau calculi have been developed and are being used for non - classical logics such as intuitionistic logic  @xcite , conditional logic  @xcite , logics of metric and topology  @xcite and hybrid logics  @xcite .",
    "rather than developing tableau calculi one by one for individual logics , it is possible to develop tableau calculi in a systematic way for large classes of logics .",
    "this is evident from the literature in all these areas and studies such as  @xcite .    in this paper",
    "we want to go further and investigate the possibility to generate tableau calculi automatically from the specification of a logic .",
    "we assume that the logic of interest is defined by a high - level specification of its formal semantics .",
    "our aim is to turn this into a set of inference rules that provides a sound and complete deduction calculus for the logic .",
    "ideally we also want to be able to guarantee termination if the logic is decidable",
    ". automated synthesis of calculi is a challenging problem and in general it is of course not possible to turn every specification of a logic into a sound , complete and terminating deduction calculus .",
    "it is however possible to describe classes of logical specifications for which the problem is solvable uniformly .    in previous work",
    "we have shown that it is possible to synthesise tableau calculi for modal logics by translation to first - order logic combined with first - order resolution  @xcite . in this approach the semantic specification of a logic",
    "is transformed into clausal form and then a set of inference rules .",
    "soundness and completeness of the generated calculus follows from the soundness and completeness of the simulating resolution refinement used . in the present paper",
    "we introduce another approach for generating tableau calculi . rather than proceeding via simulation by resolution , our approach generates a tableau calculus directly from the specification of a logic . for traditional modal logics essentially the same tableau calculi can be obtained , but for more expressive dynamic modal logics and description logics the method in  @xcite produces calculi with introduction rules , whereas the method in this paper can be used to produce calculi with only elimination rules .",
    "in other previous work we have described a framework for turning sound and complete tableau calculi into decision procedures  @xcite .",
    "the key for this framework is the unrestricted blocking mechanism from  @xcite which is added to the given calculus in order to turn it into a terminating calculus .",
    "enhancing a tableau calculus with the unrestricted blocking mechanism produces a terminating tableau calculus , whenever the logic can be shown to admit finite filtration with respect to its semantics  @xcite .",
    "more specifically , the prerequisites are that the following conditions all hold .    1 .   [ efmp_item ]",
    "the logic admits the effective finite model property shown by a filtration argument .",
    "[ sound_constructively_complete_item ] the tableau calculus is sound and constructively complete .",
    "[ subexpression_property_item ] a weak form of subexpression property holds for tableau derivations .",
    "constructive completeness is a slightly stronger notion than completeness and means that for every open branch in a tableau there is a model which reflects all the expressions ( formulae ) occurring on the branch .",
    "the subexpression property says that every expression in a derivation is a subexpression of the input expression with respect to a finite subexpression closure operator .    in order to be able to exploit this ` termination through blocking ' result from  @xcite , in this paper , our goal is to synthesise tableau calculi that satisfy the prerequisites  ( [ sound_constructively_complete_item ] ) and  ( [ subexpression_property_item ] ) .",
    "it turns out that , provided the specification of the semantics of the logic is well - defined in a certain sense , the subexpression property can be imposed on the generated calculus .",
    "crucial is the separation of the syntax of the logic from the ` extras ' in the meta - language needed for the semantic specification of the logic .",
    "the process of generating tableau calculi can be completely automated and gives , together with the unrestricted blocking mechanism and the results in  @xcite , an automated procedure for generating tableau decision procedures for logics , whenever they have the effective finite model property with respect to a well - defined first - order semantics , that is , condition   holds .",
    "the tableau synthesis method introduced in this paper works as follows .",
    "the user defines the formal semantics of the given logic in a many - sorted first - order language so that certain well - definedness conditions hold .",
    "the semantic specification of the logic is then automatically reduced to skolemised implicational forms which are further transformed into tableau inference rules .",
    "combined with a set of default closure and equality rules , the generated rules provide a sound and constructively complete calculus for the logic . under certain conditions",
    "the set of rules can be further refined .",
    "if the logic can be shown to admit finite filtration , then the generated calculus can be automatically turned into a terminating calculus by adding the unrestricted blocking mechanism from  @xcite .",
    "the method is intended to be as general as possible , and cover as many logics as possible .",
    "our main focus is non - classical logics and description logics . as case studies we consider the application of the method to propositional intuitionistic logic @xmath0",
    "@xcite and the description logic @xmath1 .",
    "propositional intuitionistic logic provides a nearly perfect example because the semantics of the logical connectives is not boolean and the semantics is restricted by a background theory .",
    "in addition , the logic is simple .",
    "@xmath1is the extension of the description logic @xmath2with singleton concepts ( or nominals ) and transitive roles .",
    "@xmath1  is a fragment of many expressive description logics considered in the literature  @xcite and is the analogue of the hybrid  @xcite version of the standard modal logic @xmath3  @xcite .",
    "the paper is structured as follows .",
    "section  [ section_semantic_specification ] defines the apparatus for specifying the logic of interest .",
    "it consists of two languages , a language for specifying the syntax of the logic and a language for specifying its semantics . how to specify the semantics of a logic",
    "is described in section  [ section_semantics ] . because there are many ways of writing semantic specifications , in this paper",
    ", we focus on what we call well - defined semantic specifications for which sound and complete tableau calculi can be generated .",
    "the tableau generation process is presented in section  [ section_tableau_synthesis ] , and section  [ section_sound_constructively_complete ] proves soundness and constructive completeness of the generated calculus .",
    "sections  [ section_optimisation ] and  [ section : refinement 2 ] discuss two techniques for refining a calculus .",
    "the first refinement aims at reducing branching in derivations .",
    "the second refinement aims at reducing the use of extraneous constructs in the language of the tableau calculus . in section  [ section :",
    "blocking ] we show how the unrestricted blocking mechanism of @xcite can be used to obtain terminating tableau calculi for logics with the effective finite model property . to illustrate the approach we use the description logic @xmath1as a running example throughout the paper . in section  [ section_case_studies ] the approach is applied to propositional intuitionistic logic .",
    "the paper concludes with a discussion of the approach .    the paper is written using terminology of description logics , but all the results apply equally to modal logics and other non - classical logics . in most cases where we use the word ` expression ' we could have equally used the words ` formula ' or ` logical term '",
    "in order for the user to specify the semantics of the given logic for which they want to develop a tableau calculus there are two specification languages :    1 .   an object language for defining the syntax of the logic , and 2 .   a meta - language for specifying the semantics of the logic .    for the sake of generality the _ object language",
    ", denoted by @xmath4 , is a many - sorted propositional language , thus allowing for the specification of many - sorted propositional logics including modal logics , description logics and other non - classical logics .    throughout the paper the standard notation @xmath5",
    "is used for the smallest infinite countable ordinal , that is , @xmath6 .",
    "let @xmath7 be the index set of the sorts of the object language .",
    "the idea is that , for @xmath8 , symbols of sort  @xmath9 are interpreted as @xmath9-ary relations and symbols of sort  @xmath10 are interpreted as domain elements . of the sorts ,",
    "the sort  @xmath11 is regarded as the _",
    "primary sort_.    let @xmath12 be a countable set of the logical connectives of the logic to be specified .",
    "every connective  @xmath13 in @xmath12 is associated with a tuple @xmath14 , where  @xmath15 .",
    "the last argument  @xmath16 is the sort of the expression obtained by applying @xmath13 to expressions of sorts @xmath17 , respectively .",
    "we say that @xmath13 is an @xmath18-ary connective of sort @xmath19 .",
    "the object language @xmath4 is defined over an alphabet given by a set of sorts @xmath20 , a set of connectives @xmath12 , a countable set of variable symbols @xmath21 , and a countable set of constant symbols @xmath22 .",
    "@xmath4 is defined as the set of _ expressions _ over the alphabet closed under the connectives in @xmath12 .",
    "more formally , let @xmath23 , where each @xmath24 denotes the _ set of expressions of sort  @xmath25 _ defined as the smallest set of expressions satisfying the following conditions :    1 .",
    "all variables @xmath26 and all constants @xmath27 in the alphabet are expressions belonging to @xmath24 .",
    "2 .   for every connective @xmath28 of sort @xmath29 ,",
    "@xmath30 is an expression belonging to @xmath31 , whenever @xmath32 belong to @xmath33 , respectively .",
    "symbols , expressions and connectives in the language @xmath4 are also referred to as @xmath4-symbols , @xmath4-expressions and @xmath4-connectives .",
    "variables and constants in @xmath4 are called _ atomic _ @xmath4-expressions .",
    "we refer to expressions in @xmath34 as _ individuals _ , expressions in @xmath35 as _ concepts _ , and expressions in @xmath36 as _ roles_. that is , individuals are expressions of sort  0 , concepts are expressions ( or formulae ) of the primary sort and roles are expressions ( or formulae ) of sort  2 .    for an @xmath4-expression @xmath37",
    ", the notation @xmath38 indicates that @xmath39 are ( distinct ) variables occurring in the expression @xmath37 . to avoid ambiguity in this notation",
    "we standardly assume that all the variables of the language @xmath4 are linearly ordered by an ordering @xmath40 and @xmath41 .",
    "@xmath42 denotes the expression obtained by uniformly substituting @xmath43 into @xmath44 , for all @xmath45 .",
    "similarly , if @xmath46 is a set of @xmath4-expressions depending on variables @xmath39 , we indicate this as @xmath47 and denote by @xmath48 the set of expressions which are instances of expressions from @xmath46 under uniform substitution of the expressions @xmath32 into @xmath39 , respectively .    throughout the paper",
    "we use the logic  @xmath1as a running example . recall that @xmath1is the description logic @xmath2extended with nominals , or singleton concepts , and transitive roles .",
    "the object language @xmath49 for specifying the syntax of @xmath50 consists of three sorts , namely  @xmath10 , @xmath11 and  @xmath51 for individuals , concepts , and roles , respectively .",
    "atomic expressions of sort @xmath10 are individual variables from a countable set @xmath52 .",
    "we denote individual variables also by @xmath53 .",
    "the variables @xmath54 are of sort  @xmath11 and are the concept symbols . in this paper concept symbols",
    "are denoted by @xmath55 .",
    "the variables @xmath56 of sort @xmath51 are the atomic roles and are denoted by @xmath57 .",
    "the connectives in @xmath49 are the following :    1 .   the ` singleton concept ' connective @xmath58 of the sort @xmath59 .",
    "that is , @xmath60 is a concept for every individual @xmath61 .",
    "2 .   the boolean connectives @xmath62 and @xmath63 of sorts @xmath64 and @xmath65 , respectively . as usual",
    ", we use infix notation for @xmath62 and prefix notation for @xmath63 .",
    "thus , @xmath66 and @xmath67 are concepts for any concept expressions @xmath68 and @xmath69 .",
    "3 .   the existential restriction connective @xmath70 of sort @xmath71 .",
    "that is , @xmath72 is a concept for any role expression @xmath73 and concept expression @xmath68 .",
    "thus , expressions of @xmath49 are built from individuals , concept symbols and role symbols using the given connectives , and there are no other expressions in @xmath49 . in this language , individual and",
    "role expressions are allowed to be atomic only .",
    "the _ meta - language _ in which the semantics of the given logic is specified is a many - sorted first - order language with equality and is denoted by @xmath74 .",
    "@xmath74 extends the object language @xmath4 , the idea being that @xmath4-expressions are represented as terms in @xmath74 and @xmath4-connectives as functions .",
    "formally , @xmath74 is defined as an extension of @xmath4 with one additional sort , namely , additional symbols , the standard first - order connectives @xmath75 , @xmath76 , @xmath77 , @xmath78 , the equivalence connective @xmath79 , first - order quantifiers @xmath80 and @xmath81 , and the equality predicate @xmath82 .",
    "thus the sorts of @xmath74 are @xmath83 .",
    "we call the additional sort @xmath84 the _ domain sort _ , and symbols over this sort are called the _ domain symbols_. the additional symbols comprise of a countable set of variable symbols @xmath85 of the domain sort , a countable set of constants @xmath86 of the domain sort , function symbols @xmath87 mapping argument terms to terms of sort @xmath84 , and a countable set of constant predicate symbols @xmath88 of the domain sort ( that is , argument terms are required to be terms of sort @xmath84 )",
    ". intuitively , the domain sort contains symbols necessary for formalising semantic properties of the domain elements of interpretations of the target logic .",
    "in addition , @xmath74 contains the symbols @xmath89 , one for each sort in @xmath20 of the object language .",
    "in particular , @xmath90 is a unary function symbol of sort @xmath91 ( that is , a function from sort @xmath10 to sort @xmath84 ) .",
    "each of the remaining  @xmath92 is a predicate symbol of sort @xmath93 with arity @xmath94 .",
    "the purpose of these symbols is to define the semantics of the connectives of the logic by using conditions similar to satisfaction conditions in standard definitions .",
    "@xmath90 can be viewed as the interpretation mapping for individuals ( represented as terms ) in the object language .",
    "all other @xmath95 can be viewed as interpretation mappings for expressions in the object language ; they can be viewed as the ` holds ' or ` satisfaction ' predicates .",
    "finally , for every sort we assume the presence in @xmath74 of a binary predicate symbol representing the equality predicate for that sort . for reasons of simplicity ,",
    "we use one symbol , namely @xmath82 , for each of the equality predicates .    _ formulae _ in @xmath74 are just first - order formulae defined over the symbols of @xmath74 , where each expression in @xmath4 is represented by a term in @xmath74 . in particular , each variable symbol @xmath26 in  @xmath24",
    "is represented by a variable of sort @xmath25 in @xmath74 , each constant symbol @xmath27 in  @xmath24 is represented by a constant of sort @xmath25 in @xmath74 , and every connective  @xmath13 is represented by a function of the same sort as @xmath13 .    to illustrate how expressions of a logic are represented in a meta - language we continue our running example . according to our definitions the meta - language @xmath96 for @xmath1is a first - order language with sorts @xmath10 , @xmath11 , @xmath51 and @xmath97 .",
    "the interpretation symbols are @xmath90 ( which is a function symbol ) and the holds predicate symbols @xmath98 and @xmath99 .",
    "also included in @xmath96 is the equality predicate symbol @xmath82 .",
    "every variable of @xmath49 is represented by a variable of the corresponding sort in @xmath96 .",
    "thus , every individual variable @xmath61 in @xmath49 is represented by a variable of sort @xmath10 in @xmath96 .",
    "every concept symbol @xmath100 in @xmath49 is represented by a variable of sort  @xmath11 , and every role symbol  @xmath73 in @xmath49 by a variable of sort  @xmath51 in @xmath96 .",
    "connectives of the object language become function symbols of an appropriate sort in @xmath96 . thus , every expression in @xmath49 becomes a first - order term of the corresponding sort .",
    "for instance , the concept expression @xmath101 is represented as a term of sort @xmath11 .    whereas the sorts @xmath10 , @xmath11 , and @xmath51 are the sorts in the object language @xmath49 , the sort @xmath97 is a separate sort in @xmath96 with its own sets of variables , individual constants , function symbols , and symbols of predicate constants .",
    "sort  3 is the domain sort for @xmath50 .",
    "finally , for every individual @xmath61 , @xmath102 is a term of sort  @xmath97 in @xmath96 , and @xmath103 and @xmath104 are atomic formulae of @xmath96 , for any concept expression @xmath68 , any role expression  @xmath73 , and any terms @xmath105 and @xmath106 of sort @xmath97 .",
    "before we describe how a logic can be defined in the meta - language @xmath74 in the next section , we fix some more notation and terminology .",
    "let @xmath107 denote a sequence of first - order variables , that is @xmath108 .",
    "similarly , let @xmath109 denote the universal quantifier prefix on all variables @xmath110 , that is , @xmath111 . for any set @xmath112 of formulae",
    ", @xmath113  denotes the universal closure of @xmath112 , that is , the set @xmath114 for every first - order formula @xmath115 we let @xmath116    formulae of @xmath74 in which all occurrences of the @xmath4-variables @xmath26 ( of sorts @xmath117 ) are free are called _",
    "@xmath4-open _ formulae",
    "@xmath4-open sentence _ is an @xmath4-open formula that does _ not _ have free occurrences of variables of the domain sort @xmath84 .",
    "for example , the formula @xmath118 is an @xmath49-open formula because the variables @xmath100 and @xmath73 occur only freely .",
    "because the variable  @xmath119 of domain sort @xmath97 also occurs freely , it is _ not _ an @xmath49-open sentence .",
    "in contrast , the formula @xmath120 is an @xmath49-open sentence , because all the occurrences of the domain variables @xmath119 and @xmath121 are bound by quantifiers and all the occurrences of @xmath100 and @xmath73 are unbound .",
    "the formulae @xmath122 are not @xmath49-open because of the presence of quantified variables of sorts other than the domain sort ( @xmath100 and @xmath73 ) .",
    "( the symbol @xmath80 in @xmath101 should not be confused with the existential quantifier of first - order logic . )    for any set  @xmath112 of @xmath4-open formulae in @xmath74 and a set @xmath46 of @xmath4-expressions , let @xmath123 @xmath124 is the set of instances of formulae in @xmath112 under substitutions into the variables of  @xmath4 that do not contain expressions outside @xmath46 .",
    "suppose , for example , @xmath125 then the instantiations of formulae in @xmath112 relative to @xmath46 are @xmath126 the only formula in this list where all @xmath127-subexpressions belong to @xmath46 is @xmath128 .",
    "thus @xmath129 the formula @xmath130 does not belong to @xmath124 because @xmath131 does not belong to @xmath46 .",
    "other instances do not belong to @xmath124 for similar reasons .",
    "first , we define the model structures in terms of which the semantics of the object language is then defined .    an _ @xmath4-structure _ is a tuple @xmath132 where @xmath133 is a non - empty set , @xmath134 for every individual @xmath135 , @xmath136 , for @xmath137 .",
    "@xmath138 and @xmath139 , where @xmath18 is the arity of  @xmath140 . for simplicity",
    "we omit the sets @xmath141 and simply write @xmath142 observe that an @xmath4-structure @xmath143 is a first - order interpretation of the language @xmath74 .    for our sample logic @xmath1an @xmath49-structure",
    "is given by a tuple @xmath144 .",
    "this means , the @xmath145 are arbitrary interpretation functions for @xmath1-expressions . as yet no additional conditions are assumed . in the description logic literature instead of",
    "a family of holds relations @xmath92 just one holds relation @xmath146 is used , resulting in the simpler and more familiar notation for an interpretation , namely @xmath147 .    a _ valuation _ in @xmath143 is a mapping @xmath148 from the set of variables and constants of  @xmath74 to @xmath149 such that @xmath150 , and @xmath151 .",
    "we use the standard notation @xmath152 to indicate a ( first - order ) formula @xmath153 is _ true _ in the ( first - order ) interpretation  @xmath143 under valuation @xmath148 . given a set of formulae",
    "@xmath112 , we write @xmath154 if @xmath152 for every formula  @xmath153 in @xmath112 .",
    "we say that a valuation @xmath148 in an @xmath4-structure is _ canonical _ if every variable and constant of any sort @xmath117 is mapped to itself , that is , @xmath155 and @xmath156 for every variable @xmath26 and constant @xmath27 in the language @xmath4 .",
    "this means that the canonical valuation of any term of sort @xmath117 is the term itself .",
    "it is not difficult to see that any @xmath4-open formula @xmath153 is satisfiable in an @xmath4-structure iff it is satisfiable in an @xmath4-structure under a canonical valuation .",
    "we write @xmath157 for sets of formulae @xmath112 and @xmath158 , if , for every @xmath4-structure @xmath143 and a canonical valuation @xmath148 in @xmath143 , @xmath154 implies @xmath159 .",
    "similarly , we write @xmath160 iff there is a canonical valuation @xmath148 such that @xmath154 .",
    "satisfiability for expressions of the given logic is defined only for expressions of the primary sort , that is , concept expressions .",
    "we say a concept expression @xmath68 is _ satisfiable _ in  @xmath143 if there is an element @xmath161 in @xmath133 such that @xmath162 , or equivalently , @xmath163 .",
    "a concept expression @xmath68 is _ valid _ in @xmath143 if @xmath164 .",
    "next we describe how the semantics of a given logic can be specified in @xmath74 , where  @xmath4 is the object language of the logic .",
    "let @xmath112 be any set of @xmath4-open sentences in @xmath74 and @xmath13 be a connective of a sort @xmath165 .",
    "a formula @xmath166 in the language of @xmath112 _ defines the connective @xmath13 _ with respect to @xmath112 if it does not contain  @xmath13 and the following holds : @xmath167 here @xmath39 are variables of sorts @xmath168 respectively .",
    "if there is a formula @xmath166 which defines @xmath13 with respect to @xmath112 , we also say @xmath112 _ defines _",
    "@xmath13 and @xmath169 which is an @xmath4-open sentence , is a _",
    "@xmath13-definition with respect to @xmath112_. connective definitions are always @xmath4-open sentences , that is , they do not contain any quantifiers over variables of sorts @xmath170 ( these are implicitly regarded as being universally quantified ) .",
    "@xmath171    by definition , a _ ( first - order ) semantic specification _ of the object language @xmath4 is a set @xmath112 of @xmath4-open @xmath74-sentences defining the connectives of @xmath4 . for the sake of generality",
    "we always include the standard equality axioms listed in figure  [ fig : equality axioms ] in a semantic specification  @xmath112 .",
    "this ensures that @xmath82 is a congruence on every sort in any first - order interpretation of @xmath74 .",
    "we assume the set of @xmath13-definitions with respect to @xmath112 of all the connectives @xmath13 of @xmath4 is fixed and explicitly given as the set @xmath172 .",
    "intuitively , a specification @xmath112 of a semantics of the given logic is an axiomatisation in the language @xmath74 of a class of @xmath4-structures where each @xmath4-connective @xmath13 has an unambiguous representation .",
    "because the beth definability property holds for first - order logic we can assume that all such representations are explicit , that is , every connective @xmath13 is defined by an explicit formula @xmath166 .",
    "the collection of explicit definitions of all the connectives constitutes the set @xmath172 .",
    "since there are many ways of axiomatising the same ( axiomatisable ) class of first - order structures and choosing explicit representations for connectives , there are many ways of specifying a semantics and choosing a set of semantic definitions for a semantic specification .",
    "axiomatisations of the empty class of @xmath4-structures are all inconsistent and , hence , semantic specifications can be inconsistent .    as an example we give a semantic specification for the logic @xmath1 .",
    "suppose @xmath173 consists of the following @xmath49-open sentences together with the default equality axioms .",
    "connective definitions : @xmath174    transitivity axiom : @xmath175    the first four sentences are the connective definitions of @xmath49 and constitute the set @xmath176 .",
    "the fifth sentence does not belong to @xmath176 .",
    "it is the transitivity axiom specifying that all role symbols @xmath73 are transitive . if we wanted to specify that only a subset of the role symbols are transitive , this can be done by including one transitivity axiom for each role ( constant ) symbol that is meant to be transitive .    because , in general , there are many possibilities of axiomatising the same class of @xmath4-structures , there are many possibilities for specifying the semantics of a logic . in this paper",
    "we restrict our attention to semantic specifications in forms that are standard in the literature for non - classical logics .",
    "we say a semantic specification @xmath112 is _ normalised _",
    ", if it consists of three disjoint parts , that is , @xmath177 , where @xmath178 , @xmath179 and @xmath180 are disjoint sets of sentences satisfying the following :    [ def : positive connective def ] @xmath178 is a set of @xmath4-open sentences of the form : @xmath181    [ def : negative connective def ] @xmath179 is a set of @xmath4-open sentences of the form : @xmath182    all @xmath4-expressions occurring in @xmath180 are atomic .    here , @xmath37 denotes any @xmath4-expression .    in this definition",
    "we assume that multiple sentences of the form  [ def : positive connective def ] for the same expression  @xmath37 in @xmath178 and @xmath179 are all equivalently reduced to a single sentence @xmath183 .",
    "similarly for  [ def : negative connective def ] and  @xmath184 .",
    "the intuition is that @xmath178 and @xmath179 define the semantics of the connectives .",
    "@xmath178  defines it for positive occurrences of expressions @xmath37 ( with free variables @xmath39 ) , while  @xmath179   defines it for negative occurrences of expressions  @xmath37 .",
    "we refer to  @xmath180 as the _ background theory _ of the semantics @xmath112 .",
    "in particular , @xmath180 includes the equality axioms from figure  [ fig : equality axioms ] .",
    "a semantic specification in the form @xmath185 can be turned into normalised form by decomposing each connective definition in @xmath172 into two implications .",
    "in fact , @xmath172 and play the same role in axiomatising @xmath4-connectives in @xmath74 modulo the background theory  @xmath180 .    the sample semantic specification @xmath186 can be normalised by decomposing the connective definitions in @xmath187 into @xmath188-sentences and @xmath189-sentences as follows .",
    "@xmath188-sentences : @xmath190    @xmath189-sentences : @xmath191    the background theory @xmath192 of @xmath50 consists of this sentence , @xmath193 specifying transitivity of roles plus the default equality axioms .",
    "it is worth noting that the symbol @xmath37 in definitions  [ def : positive connective def ] and  [ def : negative connective def ] denotes an arbitrary expression in @xmath4 .",
    "this means that @xmath37 does not necessarily have the form @xmath194 where  @xmath13 is a connective .",
    "for example , a specification might be : @xmath195 in this case @xmath196 and @xmath197 .",
    "it is convenient to introduce notation for the set of instantiations of the right hand sides and left hand sides of the @xmath183 and @xmath184 , respectively . for every @xmath4-expression @xmath37 ,",
    "let @xmath198 thus , @xmath199 ( respectively  @xmath200 ) is the set of instantiations of succedents ( respectively  antecedents ) of positive ( respectively  negative ) specifications in @xmath112 , where the antecedents ( respectively  succedents ) match the given expression @xmath37 .",
    "for example , in the case of our specification for @xmath50 and @xmath201 , we have @xmath202    let @xmath203 be any ordering on @xmath4-expressions .",
    "for any @xmath4-expression @xmath37 and any set @xmath46 of @xmath4-expressions we define @xmath204 that is , @xmath205 is the set of all expressions @xmath203-smaller than some expression in @xmath46 . we often write @xmath206 rather than @xmath207 .",
    "any normalised specification @xmath112 of a semantics _",
    "induces _ a relation @xmath203 on expressions as follows .",
    "let @xmath203 be the smallest transitive relation satisfying : @xmath208 whenever @xmath209 , for some @xmath4-expressions @xmath32 , and @xmath210 occurs in @xmath211 or @xmath212 , respectively , for some sentence @xmath213 or @xmath214 in @xmath112 .",
    "the reflexive closure of  @xmath203 is denoted by @xmath215 .",
    "recall that @xmath172 denotes the set of @xmath4-open sentences that define the @xmath4-connectives .",
    "a semantic specification @xmath112 is _ well - defined _ iff @xmath112 is normalised and the following conditions are all true .",
    "[ condition : well - defined semantics 1 ] @xmath216 ,    [ condition : well - defined semantics 2][condition : well - defined semantics : well - founded ordering ] the relation @xmath203 induced by @xmath112 is a well - founded ordering on @xmath4-expressions , and    [ condition : well - defined semantics 3 ] for every expression @xmath217 , + @xmath218 \\forall{\\overline{x}}\\bigl ( & \\bigl(\\bigwedge \\phi^e_+\\imp\\phi^\\sigma(e_1,\\ldots , e_m,{\\overline{x}})\\bigr)\\land{}\\\\ & \\bigl(\\phi^\\sigma(e_1,\\ldots , e_m,{\\overline{x}})\\imp\\bigvee \\phi^e_-\\bigr)\\bigr ) .",
    "\\end{aligned } $ ] +    condition  [ condition : well - defined semantics 3 ] follows from the following first - order condition :    [ condition : well - defined semantics 3a]for every connective @xmath13 , + @xmath219 \\forall{\\overline{x}}\\bigl ( & \\bigl(\\bigwedge \\phi^{\\sigma({\\overline{p}})}_+\\imp\\phi^\\sigma({\\overline{p}},{\\overline{x}})\\bigr)\\land{}\\\\ & \\bigl(\\phi^\\sigma({\\overline{p}},{\\overline{x}})\\imp\\bigvee \\phi^{\\sigma({\\overline{p}})}_-\\bigr)\\bigr ) .",
    "\\end{aligned}$ ]    because we can assume that @xmath172 is also a normalised semantic specification , it similarly induces a relation @xmath220 that can be assumed to be a well - founded ordering .",
    "standardly , the semantics of a logic is defined by induction over the interpretation of the connectives and primitives ( that is , constants , and variables ) which is homomorphically lifted to arbitrary @xmath4-expressions .",
    "this is equivalent to assuming a well - founded ordering on expressions of  @xmath4 .",
    "for any reasonable definition of a semantics such a well - founded ordering exists .",
    "thus , although it is not difficult to imagine formulae @xmath166 such that  @xmath220 is not well - founded , we assume that the  @xmath166 are chosen in such a way that it is possible to lift the semantics of @xmath4-primitives to arbitrary @xmath4-expressions , that is , @xmath220 is well - founded .    in the case of @xmath186 , because @xmath188 and @xmath189 are obtained by decomposing the set @xmath176 , the two orderings @xmath203 and @xmath220 coincide .",
    "similar to many cases of description and modal logics , @xmath203 and @xmath220 are both just the direct subexpression ordering on @xmath49 .",
    "there are different semantic specifications which describe the same class of @xmath4-structures .",
    "as we have just noted , some semantic specifications already allow the lifting of the semantics from atomic expressions to arbitrary @xmath4-expressions .",
    "we assume that @xmath185 is such a specification and implicitly accommodates @xmath4-connectives . according to this definition ,",
    "a well - defined semantic specification @xmath112 is equivalent to @xmath185 modulo the background theory  @xmath180 .",
    "this is ensured by condition  [ condition : well - defined semantics 1 ] and the assumption that @xmath112 defines all @xmath4-connectives in @xmath172 . through condition  [ condition : well - defined semantics 2 ] , @xmath112 imposes its own inductive structure on @xmath4-expressions .",
    "condition  [ condition : well - defined semantics 3 ] specifies a correlation between @xmath112 and @xmath172 on instances of @xmath4-expressions .",
    "it can be seen that @xmath185 is a well - defined semantic specification itself .",
    "let us consider if the semantic specification of @xmath50 above is well - defined .",
    "the first condition is satisfied because @xmath221 .",
    "the second condition is satisfied because  @xmath203  is the direct subexpression ordering .",
    "condition  [ condition : well - defined semantics 3a ] is true for all @xmath222 connectives . for instance , consider the case of @xmath223 . since @xmath224 , the formula @xmath225 on the right hand side of condition  [ condition : well - defined semantics 3a ] , is a tautology . in a similar way",
    ", the condition  [ condition : well - defined semantics 3a ] can be checked for the other connectives .",
    "a _ ( propositional ) logic _ @xmath226 over the language @xmath4 is a subset of concepts in @xmath4 which is closed under arbitrary substitutions of variables with expressions of the same sorts .",
    "a logic @xmath226 is _ first - order definable _ iff there is a semantic specification  @xmath227 such that @xmath226 coincides with the set of all concepts that are valid in all @xmath4-structures satisfying  @xmath228 , that is , @xmath229    for a fixed semantic specification @xmath227 of a logic @xmath226 , if @xmath143 is an @xmath4-structure satisfying @xmath227 then by definition @xmath143 is a _ model of @xmath226 _ or simply an _ @xmath226-model _ ( with respect to  @xmath227 ) .",
    "first , we give the needed basic definitions for the kind of tableau calculi our method generates .",
    "let @xmath230 denote a tableau calculus comprising of a set of inference rules .",
    "a _ tableau derivation _ or _ tableau _ for @xmath230 is a finitely branching , ordered tree whose nodes are sets of formulae in @xmath74 . assuming that  @xmath231 is the input set of concept expressions in @xmath4 to be tested for satisfiability the root node of the tableau is the set @xmath232 , where @xmath161 denotes a fresh constant of the domain sort . for a finite set @xmath233 , @xmath161 can be viewed as the skolem constant introduced by skolemising the @xmath74-formula @xmath234 .",
    "( this can be naturally expanded to infinite sets of concepts but this is not essential for the paper . )",
    "successor nodes are constructed in accordance with a set of inference rules in the calculus .",
    "the inference rules have the general form @xmath235 where both the numerator @xmath236 and all denominators @xmath237 are finite sets of negated or unnegated atomic formulae in the language @xmath74 .",
    "the formulae in the numerator are called _ premises _ , while the formulae in the denominators are called _",
    "conclusions_. @xmath9 is called the _ branching factor _ of the rule .",
    "the numerator and all the denominators are non - empty , but @xmath9 may be zero , in which case the denominators are not present and the rule is a _",
    "closure rule_. closure rules are also written @xmath238 .",
    "if the branching factor @xmath9 is greater than one , the rule is a _",
    "branching rule_. an inference rule is applicable to a selected formula @xmath153 in a node of the tableau , if @xmath153 together with other formulae in the node , are simultaneous instantiations of all the premises of the rule",
    ". then @xmath9  successor nodes are created which contain the formulae of the current node and the appropriate instances of @xmath237 .",
    "we assume that _ any rule is applied at most once to the same set of premises _ , which is a standard assumption for tableau derivations .",
    "we use the notation @xmath239 for a finished ( in the limit ) tableau built by applying the rules of the calculus @xmath230 starting with the set @xmath231 ( of @xmath4-concepts ) as input .",
    "that is , we assume that all branches in the tableau are fully expanded and all applicable rules have been applied in  @xmath239 .",
    "we assume that all the rules of the calculus are applied _ non - deterministically to a tableau_. this means that we do not assume any order of rule application and , at any given node , an arbitrary rule is chosen for the node expansion from all the rules which are applicable to formulae of the node .    in a tableau , a maximal path from the root node",
    "is called a _",
    "branch_. for a branch  @xmath240 of a tableau we write @xmath241 to indicate that the formula @xmath153 has been derived in  @xmath240 , that is , @xmath153 belongs to a node of the branch  @xmath240 .",
    "our notion of a tableau branch can be viewed in two ways . on the one hand",
    ", one can view it as having procedural flavour as a path of nodes in the tableau derivation . on the other hand",
    ", a branch can be identified with the set - theoretical union of the nodes in it .",
    "a branch of a tableau is _ closed _ if a closure rule has been applied in this branch , otherwise the branch is called _",
    "open_. the tableau @xmath242 is _ closed _ if all its branches are closed and @xmath242 is _ open _ otherwise .",
    "the calculus @xmath230 is _ sound _",
    "iff for any ( possibly infinite ) set of concepts  @xmath233 , each @xmath242 is open whenever @xmath233 is satisfiable .",
    "@xmath230 is _ complete _ iff for any ( possibly infinite ) unsatisfiable set of concepts @xmath233 there is a @xmath242 which is closed .",
    "now , let @xmath226 be a first - order definable propositional logic over @xmath4 and @xmath227 a well - defined semantic specification of @xmath226 , that is , conditions  [ condition : well - defined semantics 1][condition : well - defined semantics 3 ] hold for @xmath227 . we now describe how tableau rules can be synthesised from @xmath227 .",
    "if @xmath227 is not already normalised we first normalise it .",
    "thus assume @xmath243 .",
    "next we take a positive specification @xmath183 in @xmath244 .",
    "eliminate existential quantifiers using skolemisation and equivalently rewrite @xmath183 into the following implicational form @xmath245 where each @xmath246 denotes a literal .",
    "this is always possible .",
    "the implication is now turned into the rule : @xmath247 where @xmath248 denote the free variables occurring in @xmath246 which do not occur among the variables @xmath249 .",
    "essentially , the antecedent of the implication has become the main premise in the numerator and the succedent has been turned into the denominators of the rule .",
    "we say the rule _ corresponds _ to @xmath183 .",
    "this is repeated for each positive specification in  @xmath244 .",
    "analogously , we generate a tableau rule for each negative specification  @xmath184 in  @xmath250 .",
    "the corresponding rules have the form @xmath251 this is obtained by skolemising the contrapositive of @xmath184 and then equivalently rewriting it to an implication of the form @xmath252 where each @xmath246 denotes a literal .",
    "we refer to the rules @xmath253 and @xmath254 generated in this way , as the _ decomposition rules_.    if the right hand sides of the implicational forms contain free variables @xmath255 then these are assumed to be universally quantified and the generated rules are @xmath256-rules in the smullyan classification .",
    "our use of the equalities @xmath257 in the premises of the generated rules is a bit non - standard , and can be omitted if this is preferred .",
    "we use the equalities to achieve domain predication , which makes explicit that applying @xmath256-rules only instantiates with terms ( domain elements ) that occur on the current branch .",
    "the sentences in the background theory of @xmath227 are turned into rules by first equivalently transforming them into skolemised disjunctive normal form .",
    "more specifically , let @xmath258 be an arbitrary sentence in @xmath259 .",
    "it is first equivalently rewritten to @xmath260 where each @xmath246 denotes a literal , and is then turned into the corresponding rule , namely @xmath261 the @xmath262 are the variables appearing in  ( [ theory_dnf ] ) .",
    "the purpose of the equalities in the premises is domain predication and can optionally be omitted .",
    "rules corresponding to sentences in @xmath263 are called _ theory rules_.    for example,[example : generated e - rules ] the generated decomposition rules for the existential restriction operator in the description logic @xmath1 are @xmath264 @xmath265 in the left rule is the skolem term introduced for the quantifier @xmath266 in the connective definition of @xmath70 .",
    "the intuition is that for each @xmath73 , each @xmath100 and each @xmath119 matching the premise of the rule there is an element @xmath265 so that the conclusions of the rule are both true .",
    "the transitivity property for roles in the background theory of the semantic specification of @xmath1is transformed to the rule @xmath267 these rules are not the familiar rules used in standard description logic tableau systems , but in section  [ section_optimisation ] we see how to get those by rule refinement .",
    "@xmath268    the _ equality rules _ are generated in essentially the same way from the equality axioms in the background theory and are refined in accordance with the method described in section  [ section_optimisation ] .",
    "figure  [ fig : equality rules ] lists the full set of the _ refined _ equality rules included by default in the generated tableau calculus .",
    "since in our formalisation the equality predicate(s ) are also used as domain predicate(s ) in order to keep track of the ground terms that occur in the tableau branches , we include rules which ensure that expressions of the form @xmath269 are treated as domain predicates and appear in every branch of a tableau for every term @xmath105 in the branch .",
    "these are the first four rules in figure  [ fig : equality rules ] .",
    "in particular , these rules ensure that for any term occurring in a literal @xmath270 or @xmath271 on any branch , the equalities @xmath272 and @xmath273 are added to the branch .",
    "the rules also state reflexivity of the equality predicate(s ) .",
    "the remaining rules are variations of standard rules for equality .",
    "the rules in row three and four ensure that @xmath82 is a congruence relation for predicates on terms occurring in a branch .",
    "the rule in the last row is a congruence rule for function symbols @xmath274 occurring in a branch including skolem function symbols .",
    "we note that the equality predicate @xmath82 is treated as an ordinary constant predicate symbol of the meta - language @xmath74 and , hence , can occur in any place where an ordinary predicate symbol @xmath140 can occur .",
    "finally the generated tableau calculus also includes the following _ closure rules_. @xmath275 for each sort @xmath9 and every constant predicate symbol @xmath140 occurring in the semantic specification  @xmath227 of the logic .",
    "we use @xmath276 to denote the generated tableau calculus . in summary",
    ", it consists of these rules",
    ".    the decomposition rules @xmath277 and @xmath278 corresponding to all positive specifications  @xmath258 in  @xmath244 and all negative specifications @xmath279 in @xmath250 .",
    "the theory rules @xmath280 corresponding to all sentences @xmath281 in the background theory  @xmath259 .",
    "the equality rules of figure  [ fig : equality rules ] .",
    "the closure rules ( [ closure_rules ] ) .    note for each connective there are exactly two decomposition rules in the calculus @xmath276 , one for unnegated occurrences and one for negated occurrences of the connective .",
    "decomposition rules : @xmath282    transitivity rule : @xmath283    equality congruence rules : @xmath284    closure rules : @xmath285    for @xmath1the described approach generates the tableau rules listed in figure  [ fig : so tableau ] .",
    "we first prove soundness of the calculus @xmath276 synthesised from a normalised semantic specification @xmath227 .",
    "it is possible to prove that every rule of the generated calculus  @xmath276 preserves satisfiability of @xmath74-formulae .",
    "that is , if all premises of a rule are true in an @xmath226-model @xmath143 ( under a canonical valuation ) then the conclusions of some branch are also true .",
    "this is the case because the transformation of the semantic specification ensures that the definitions of the rules basically mimic the semantic definitions .",
    "hence , soundness is ensured .",
    "[ theorem_soundness ] let @xmath276 be a tableau calculus generated from a normalised semantic specification @xmath227 of a logic @xmath226 . then @xmath276 is sound for @xmath226 , that is , for every possibly infinite set of concepts @xmath233 satisfiable in an @xmath226-model , any finished tableau derivation @xmath286 is open .",
    "now , we prove constructive completeness of @xmath276 .",
    "let @xmath240 denote an arbitrary branch in a @xmath276-tableau derivation .",
    "we define the following relation @xmath287 with respect to @xmath240 : @xmath288 for any ground terms @xmath105 and @xmath106 of the domain sort @xmath84 in  @xmath240 .",
    "let @xmath289 be the equivalence class of an element @xmath105 .",
    "the presence of the rules of figure  [ fig : equality rules ] ensures that  @xmath287 is a congruence relation on all domain ground terms in  @xmath240 .",
    "we say a model  @xmath143 , under a ( canonical ) valuation  @xmath148 , _ reflects _ an expression @xmath37 of the sort  @xmath9 occurring in a branch @xmath240 iff for all ground terms @xmath290 we have that    1 .",
    "@xmath291 whenever @xmath292 , and 2 .",
    "@xmath293 whenever @xmath294 .",
    "similarly , @xmath143 _ reflects _ predicate constant @xmath140 from @xmath240 under a ( canonical ) valuation  @xmath148 in @xmath143 iff for all ground terms @xmath290 we have that    1 .",
    "@xmath295 whenever @xmath296 , and 2 .",
    "@xmath297 whenever @xmath298 .",
    "a model @xmath143 _ reflects _ branch @xmath240 under a valuation @xmath148 , if @xmath143 reflects all predicate constants and expressions occurring in @xmath240 under @xmath148 .    a tableau calculus @xmath276 is said to be _ constructively complete _ ( for @xmath226 ) iff for any given set of concept @xmath233 ,",
    "if @xmath240 is an open branch in a tableau derivation  @xmath286 then there is an @xmath226-model @xmath143 such that :    the domain @xmath299 of @xmath143 is the set of the equivalence classes @xmath300 for each ground term @xmath105 occurring in @xmath240 .",
    "@xmath143 reflects @xmath240 under the _ canonical projection valuation _",
    "@xmath301 defined by @xmath302 , for every ground term @xmath105 occurring in @xmath240 .",
    "it is clear that if @xmath276 is constructively complete then @xmath276 is complete for @xmath226 .",
    "suppose now that @xmath227 is a well - defined semantic specification and @xmath220 is a well - founded ordering on @xmath4-expressions induced by the set @xmath303 of the definitions of the connectives of the form   with respect to @xmath227 .",
    "let @xmath240 be an open branch in a finished tableau derivation in @xmath276 .",
    "we define interpretations of predicate symbols in @xmath304 by induction on @xmath220 as follows :    1 .   for every @xmath9-ary constant predicate symbol @xmath140 in @xmath227 , @xmath305 2 .   for every @xmath8",
    "the interpretation @xmath306 of the @xmath95 symbols is defined as the smallest subset of @xmath307 satisfying both the following , for every variable or constant @xmath100 of the sort @xmath9 , every connective @xmath13 , and any expressions @xmath32 : @xmath308[l]{$(\\sigma(e_1,\\ldots , e_m),{\\|t_1\\|},\\ldots,{\\|t_n\\|})\\in\\nu_n^{{{\\mathcal{i}}({{{\\ensuremath{\\mathcal{b}}\\xspace}}})}}$ } \\\\         & \\iff { { { \\mathcal{i}}({{{\\ensuremath{\\mathcal{b}}\\xspace}}})}}\\models_c\\phi^\\sigma(e_1,\\ldots , e_m,{\\|t_1\\|},\\ldots,{\\|t_n\\|}).\\end{aligned}\\ ] ]    in what follows , we say that @xmath304 reflects an expression @xmath37 ( a predicate @xmath140 , or a branch @xmath240 ) if @xmath304 reflects @xmath37 ( @xmath140 , or @xmath240 , respectively ) under the canonical projection valuation @xmath301 , and omit any explicit reference to @xmath301 .",
    "a consequence of the definition of @xmath304 is that the definitions of the connectives are valid in @xmath304 :    @xmath309 .",
    "[ lemma : slb induction ] let @xmath46 be any set of expressions occurring in @xmath240 .",
    "suppose @xmath304 reflects all the expressions from @xmath46",
    ". then @xmath310 .",
    "consider any @xmath311 and suppose the skolemised form of @xmath258 is as in  , that is : @xmath312 let @xmath32 be any expressions from @xmath46 and @xmath290 any ground terms of sort @xmath84 occurring in @xmath240 . by rule @xmath313",
    ", there is a @xmath314 such that , for all @xmath315 , the literals @xmath316 are in the branch  @xmath240 . since  @xmath259 does not contain non - atomic expressions of the language @xmath4 we have that @xmath317 by the assumptions of the lemma for every @xmath315",
    "this implies that @xmath318 .",
    "[ corr : slb ] @xmath319 .    from the definition of @xmath304 and the closure rules we get that @xmath296 implies @xmath320",
    ", @xmath298 implies @xmath321 , @xmath322 implies @xmath323 , and @xmath324 implies @xmath325 for every constant predicate symbol @xmath140 , @xmath326 , and primitive @xmath100 of sort @xmath9 .",
    "thus , @xmath319 by lemma  [ lemma : slb induction ] .",
    "[ lemma : ib reflects b ] @xmath304 reflects the branch @xmath240 .    by simultaneous induction on the well - founded ordering @xmath203 induced by @xmath227 we show that for all @xmath8 , for every @xmath37 , and all domain ground terms @xmath290 ( of sort @xmath84 ) in @xmath240 , we have that    1 .",
    "@xmath327 whenever @xmath292 , and 2 .",
    "@xmath328 whenever @xmath294 .",
    "we have the following two cases which correspond to the base case of the induction and to the induction step :    case @xmath329 .",
    "this case follows from the definition of @xmath304 .",
    "case @xmath217 .",
    "suppose @xmath292 .",
    "let @xmath330 be such that @xmath331 for some @xmath332 and the skolemised form of the corresponding @xmath333 is as follows @xmath334 then by rule @xmath335 there is a @xmath314 such that , for all @xmath315 , the literals @xmath336 are in @xmath240 .",
    "further , for every expression @xmath337 which occurs in @xmath336 , where @xmath315 , we have @xmath338 .",
    "thus , by the induction hypothesis , for every @xmath315 , @xmath339 .",
    "consequently , we have @xmath340 and , hence , @xmath341 . by lemma  [ lemma : slb induction ] ,",
    "since @xmath343 , we obtain @xmath344 and , therefore , by the definition of @xmath304 , we have @xmath327 .    the second implication for negative literals is proved similarly .    as a consequence",
    "we obtain the following theorem .",
    "[ theorem_constructive_completeness ] let @xmath276 be a tableau calculus generated from a well - defined semantic specification @xmath227 of a logic @xmath226 .",
    "then @xmath276 is constructively complete .",
    "we only need to prove that @xmath345 .",
    "however , this follows from @xmath346 since @xmath347 by lemma  [ lemma : ib reflects b ] and lemma  [ lemma : slb induction ] .",
    "generally the degree of branching of the generated rules is higher than is necessary .",
    "furthermore , representation of the generated rules involves the additional symbols of the language @xmath74 creating a syntactic overhead which may not always be justified . to address these problems in this section , and",
    "the next , we introduce two techniques for refining the generated rules .    the first technique reduces the number of branches of a rule by constraining the rule with additional premises and deriving fewer conclusions .",
    "suppose  @xmath73 is a tableau rule in a sound and constructively complete tableau calculus @xmath276 .",
    "suppose @xmath73 has this form .",
    "@xmath348 let @xmath349 be one of the denominators of the rule @xmath73 for some @xmath350 . without loss of generality",
    "we assume that @xmath351 .",
    "consider the rules @xmath352 with @xmath353 defined by @xmath354 each @xmath352 is obtained from the rule @xmath73 by removing the first denominator @xmath355 and adding the negation of one of the formulae in @xmath355 as a premise .",
    "we can drop any domain predication equalities from the numerator when they are not necessary .",
    "let @xmath73 denote a rule in @xmath276 .",
    "we denote by @xmath356 the _ refined tableau calculus",
    "_ obtained from @xmath276 by replacing the rule @xmath73 with rules @xmath357 .",
    "it is clear that the calculus @xmath356 is sound . in general",
    ", @xmath356 is however not constructively complete .",
    "nevertheless , analysis of the proofs of lemma  [ lemma : ib reflects b ] and lemma  [ lemma : slb induction ] shows that the following theorem is true .    [",
    "theorem : tableau transformation ] let @xmath276 be a tableau calculus generated from a well - defined specification @xmath227 of the logic @xmath226 .",
    "let @xmath73 be the rule @xmath358 in @xmath276 and suppose @xmath356 is a refined version of @xmath276 .",
    "further , suppose @xmath240 is an open branch in a @xmath356-tableau derivation and for every set @xmath359 of @xmath4-expressions from @xmath240 the following holds .",
    "if all expressions in @xmath359 are reflected in @xmath304 then for every @xmath360 , @xmath361    then , @xmath240 is reflected in @xmath304 .",
    "roughly , condition   says that the replaced rule @xmath73 is admissible in the model @xmath304 associated with @xmath240 constructed using the refined calculus @xmath356 .",
    "an immediate consequence is the following .",
    "[ corollary : refinement preserves constructive completeness ] if the condition of theorem  [ theorem : tableau transformation ] holds for every open branch @xmath240 of any @xmath356-tableau derivation then the refined calculus @xmath356 is constructively complete .    generalising this refinement to turning more than one denominator into premises is not difficult .",
    "theorem  [ theorem : tableau transformation ] can be reformulated to accommodate this generalisation and the formulation of corollary  [ corollary : refinement preserves constructive completeness ] does not change then .",
    "we observe that the condition   is implied by the following condition : @xmath362 this follows by an induction argument on the well - founded ordering @xmath203 .",
    "for example , consider the generated rule for negative occurrences of the existential restriction operator given in section  [ section_tableau_synthesis ] .",
    "@xmath363 in most description logics it can be replaced with the more often seen rule : @xmath364 in such cases , condition   has the following form .",
    "@xmath365 for description and modal logics such as @xmath1the proof of this condition is typically part of the proof of the completeness theorem for the calculus which is standardly proved by induction on the well - founded relation @xmath203 ( or equivalently , by induction on the way formulae are derived on a branch ) . for @xmath1condition",
    "can be proved separately and implies that condition   is true for every branch of the refined tableau .",
    "thus , this rule refinement preserves constructive completeness .",
    "the default equality rules ( given in figure  [ fig : equality rules ] ) added to every generated calculus are already in refined form .",
    "the rules that would be produced from the semantic specification of equality in figure  [ fig : equality axioms ] have a different form .",
    "for example , the congruence rule @xmath366 is a refined form ( obtained in two steps ) of the following rule : @xmath367    transitivity of a role @xmath73 provides another example where rule refinement converts the rule @xmath368 into the more familiar rule @xmath369 condition   holds in this case since it follows from the definition of @xmath304 that @xmath304 reflects all atomic formulae of the form @xmath370 for any role symbol @xmath73 in the branch @xmath240 .    as a negative example",
    "let us consider the possibility of replacing the rule for disjunction @xmath371\\label{rule : or}\\ ] ] by this rule .",
    "@xmath372\\label{rule : ke or}\\ ] ] in ke tableau calculi this rule is used together with an analytic cut rule  @xcite .",
    "this raises the question whether a cut rule is essential for completeness and whether the  -rule alone would suffice instead of  .",
    "consider a tableau calculus @xmath230 without any other rules to decompose positive occurrences of disjunctions except the standard rule  .",
    "suppose @xmath373 is the calculus where the -rule has been replaced by the -rule .",
    "that is , @xmath374 .",
    "examination reveals that condition   in theorem  [ theorem : tableau transformation ] does not hold for @xmath373 .",
    "given a formula @xmath375 , the branch  @xmath376 containing only @xmath375 is fully expanded .",
    "the interpretation @xmath377 constructed from  @xmath376 as defined in the previous section reflects the expressions @xmath100 and @xmath378 .",
    "the instantiation of the premise of the -rule with the expressions @xmath100 and @xmath378 belongs to the branch @xmath376 , that is , @xmath379 , but @xmath380 and @xmath381 .",
    "this means condition   fails for  @xmath376 and  @xmath382 .",
    "the following example shows that @xmath373 is in fact incomplete .",
    "let @xmath383 be the branch with formulae @xmath384 .",
    "the branch is fully expanded , because the -rule is not applicable .",
    "however the formulae are unsatisfiable .",
    "this is why ke tableau calculi typically contain an analytic cut rule for completeness .",
    "in some cases , the object logic @xmath226 is expressive enough to represent its own semantics .",
    "for example , in the case of standard modal logics , any kripke frame condition can be encoded if a slightly more expressive hybrid modal language is used  @xcite .",
    "this phenomenon leads us to consider a second kind of refinement , where all ` holds ' predicates @xmath385 and additional predicates of @xmath74 are expressible via validity of special expressions of the primary sort ( concepts ) of the object logic .    what does it mean for logic @xmath226 to be expressive enough to represent its own semantics ?",
    "assume that for every @xmath326 and every @xmath9-ary predicate constant  @xmath140 occurring in the specification  @xmath227 , there are expressions @xmath386 of the primary sort ( concepts ) , depending on variable @xmath100 of sort @xmath9 and individual variables @xmath387 of sort @xmath10 , such that the following all hold .",
    "@xmath388 it is worth noting that because the equality theory is included in the specification  @xmath227 the following also hold : @xmath389    if there are expressions such that ( [ second_refinement_stmt_one])([second_refinement_stmt_four ] ) are true it is possible to express all tableau rules in  @xmath276 in the object language @xmath4 itself as follows .",
    "let @xmath390 be a one - to - one mapping of domain variables to variables of sort  @xmath10 .",
    "now we only need to replace every positive occurrence of @xmath391 in  @xmath276 with the concept @xmath392 , every ( negative ) occurrence of @xmath393 in  @xmath276 with the concept @xmath394 .",
    "similarly , all predicate constants  @xmath140 need to be replaced with occurrences of @xmath395 or @xmath396 depending on the polarity of  @xmath140 .",
    "then the domain sort @xmath84 of the meta - language @xmath74 is reflected by the sort @xmath10 .    a small technical complication is caused by functions in @xmath74 ( skolem functions and skolem constants , in particular ) occurring in the generated tableau rules . for them",
    "there may not be corresponding function symbols in the object language  @xmath4 .",
    "this can be addressed by introducing new connectives @xmath397 into  @xmath4 for every function  @xmath398 ( including constants ) of @xmath74 so that for any @xmath399 , the term @xmath400 is of sort @xmath10 and its semantics is defined by @xmath401 an alternative is to introduce unique , new individual constants ( for every @xmath39 , @xmath387 ) instead of new connectives .    if @xmath230 is a tableau calculus for the logic @xmath226 we denote by @xmath402 the _ refined tableau calculus _ obtained by replacing every positive occurrence of @xmath391 in  @xmath276 by the concept @xmath392 , every occurrence of @xmath393 by @xmath394 , every positive occurrence of a predicate constants  @xmath140 by @xmath395 , every negative occurrence of a predicate constants  @xmath140 by @xmath396 , and every function @xmath398 with the new connective @xmath397 .",
    "[ theorem : rfe ] let @xmath230 be a sound and complete tableau calculus for a logic @xmath226 . if there are expressions such that ( [ second_refinement_stmt_one])([second_refinement_stmt_four ] ) then @xmath402 is sound and complete .",
    "if , in addition , @xmath230 is constructively complete then @xmath402 is also constructively complete for @xmath226 .    to illustrate the refinement introduced in this section we enrich the object language of @xmath1with an additional connective .",
    "in particular , we add the colon connective @xmath403 , with sort  @xmath404 , defined by : @xmath405 we also introduce connectives which correspond to skolem functions into the object language .",
    "this allows us to find object expressions for defining the predicates @xmath82 , @xmath98 and  @xmath99 in the language of the logic : @xmath406    this means the notation of the tableau calculus can be refined and simplified .",
    "the refined and simplified rules are given in figure  [ fig : optimised so tableau ] .",
    "comparing figure  [ fig : so tableau ] and figure  [ fig : optimised so tableau ] we can see that the refined formulations of the rules @xmath407 are all redundant and can be removed from the refined tableau calculus since their premises coincide with the conclusions . furthermore , the refined equality congruence rules equivalently reduce to a smaller set of rules . for instance , the refined rule of transitivity of the equality @xmath408 can be derived from the following rules .",
    "finally , the closure rule for equality is subsumed by the usual closure rule .    by theorems  [",
    "theorem : tableau transformation ] and  [ theorem : rfe ] the rules in figure  [ fig : optimised so tableau ] provide a sound and ( constructively ) complete labelled tableau calculus for the logic  @xmath50 .",
    "decomposition rules : @xmath410    transitivity rule : @xmath411    equality congruence rules : @xmath412    closure rule : @xmath413",
    "we say a tableau calculus @xmath230 is _ terminating _ ( for satisfiability )",
    "iff for every _ finite _ set of concepts  @xmath233 every closed tableau  @xmath242 is finite and every open tableau  @xmath242 has a finite open branch .    for some logics , for example , modal logic @xmath414 ,",
    "the synthesised tableau calculi are terminating but in general they are not . in order to guarantee termination",
    ", various blocking mechanisms have been developed .",
    "generally one can distinguish between at least three kinds of blocking techniques : those that reuse domain terms , those that are based on case analysis over conjectured equality constraints between domain terms and equality reasoning , and specialised loop checking mechanisms .",
    "approaches based on reusing domain terms have been used for minimal model generation for classical logic  @xcite .",
    "approaches based on conjectured equality constraints include @xcite .",
    "loop checking mechanisms are based on comparing sets of concepts ( expressions of sort  @xmath11 ) labelled by the same domain terms ( or individuals ) with minimal equality reasoning and without explicitly conjectured equality constraints and backtracking .",
    "several such loop checking mechanisms have been developed for different modal and description logics , but also hybrid logics and other logics  @xcite .    in this section",
    "we adopt the unrestricted blocking mechanism of  @xcite to obtain terminating tableau calculi .",
    "an alternative that could also be used is blocking through reusing domain terms , but this would have required changing the rules of the calculus .",
    "both unrestricted blocking and blocking through reuse of terms are less specialised and more generic than standard loop checking mechanisms .",
    "though introduced for deciding expressive description logics with role negation , the applicability of the unrestricted blocking mechanism is not limited to description logics  @xcite .",
    "it provides a powerful method for obtaining tableau decision procedures for logics with the effective finite model property ( with respect to their semantics ) .",
    "a logic  @xmath226 has the _ effective finite model property _",
    "iff there is a computable function @xmath415 , with the set of all finite sets of concept expressions as domain and a subset of the set of natural numbers as range , such that the following holds : for every finite set of concept expressions @xmath233 , if @xmath233 is satisfiable in an @xmath226-model then there is a finite @xmath226-model for @xmath233 with the number of elements in the domain not exceeding @xmath416 .",
    "the unrestricted blocking mechanism is based on adding the following rule , called the _ unrestricted blocking _",
    "rule , to a sound and complete tableau calculus .",
    "@xmath417 \\label{rule : unrestricted blocking}\\ ] ] in our context the idea is that the rule conjectures whether pairs of domain terms ( of sort  @xmath84 in @xmath74 ) on the current branch are equal or not . in the left branch two",
    "such terms are conjectured to be equal .",
    "if this leads to a contradiction then they can not be equal , which is the information carried by the right branch .",
    "the rule is generally sound , thus adding it to any sound and ( constructive ) complete tableau calculus preserves soundness and ( constructive ) completeness .    for termination",
    "it is crucial to impose additional restrictions on the application of the rules in the tableau calculus that introduce new domain terms to the derivation .",
    "this is achieved by defining an ordering @xmath418 on terms and imposing conditions  ( c[req : blocking ] ) and  ( c[req : ub before exists ] ) below on the calculus .    in particular , let @xmath418 be an ordering of terms of the domain sort @xmath84 in the branch which is a linear extension of the order of the introduction of the terms during the derivation .",
    "that is , @xmath419 , whenever the first appearance of term @xmath106 in the branch is strictly later than the first appearance of term @xmath105 .",
    "the mentioned conditions are :    1 .",
    "[ req : blocking ] if @xmath420 appears in a branch and @xmath419 , then possible applications of any rules to formulae with the term @xmath106 producing new terms of the domain sort are not performed .",
    "[ req : ub before exists ] in every open branch there is some node from which point onwards before any application of any rules which produce new terms of the domain sort all possible applications of the  rule have been performed .    condition  ( c[req : blocking ] ) specifies that term - producing rules may only be applied to formulae where the domain terms are the smallest representatives in their equivalence classes .",
    "the positive rule for @xmath70 is the only term - producing rule in the calculus for @xmath50 .",
    "condition  ( c[req : ub before exists ] ) says that at some point in a branch the unrestricted blocking rule has been applied exhaustively before the application of term - producing rules .    for a tableau calculus",
    "@xmath230 we denote by @xmath421 a tableau calculus obtained from @xmath230 by adding the above blocking mechanism based on the unrestricted blocking rule .    according to  @xcite , one of the prerequisites for termination of the calculus @xmath421 is the subexpression property of @xmath230 .",
    "let @xmath215 be a reflexive and transitive ordering on @xmath4-expressions .",
    "following  @xcite , we say that a tableau calculus @xmath230 is _ compatible with  @xmath422 _ , or has the _ subexpression property _ with respect to @xmath215 , iff for every set of concepts",
    "@xmath233 , all @xmath4-expressions occurring in the tableau derivation  @xmath242 belong to @xmath423 .    given a well - defined semantic specification @xmath112 the process of construction of @xmath230 from  @xmath112 described in section  [ section_tableau_synthesis ] ensures that every rule of @xmath230 is monotone with respect to the ordering  @xmath203 induced by @xmath112 .",
    "that is , every @xmath4-expression in each conclusion of a rule is not greater with respect to @xmath203 than @xmath4-expressions in the premises of the rule .",
    "therefore , we can conclude that  @xmath230 has the subexpression property with respect to the reflexive closure of the ordering  @xmath203 .",
    "thus :    [ lemma : subexpresiion property ] let @xmath215 be a reflexive closure of the ordering @xmath203 induced by a well - defined semantic specification @xmath112 .",
    "then the tableau calculus  @xmath230 generated from @xmath112 has the subexpression property with respect to @xmath215 .",
    "this property is a necessary condition for termination of the calculus enhanced by the unrestricted blocking rule mechanism  @xcite .",
    "another necessary condition for termination is finiteness of @xmath422 .",
    "the operator @xmath424 mapping sets of concepts to sets of expressions is _ finite _ iff @xmath425 is finite for every finite set of concepts @xmath233 . by knig",
    "s infinity lemma , @xmath422 is finite whenever  @xmath203  is well - founded and finitely branching .",
    "therefore :    [ lemma : sub is finite ] let @xmath215 be a reflexive closure of the ordering @xmath203 induced by a well - defined semantic specification @xmath112 .",
    "if @xmath426 is finite then the operator @xmath422 is finite .",
    "reformulating the main result in  @xcite in terms of the notation of this paper gives us :    [ theorem : termination ] [ theorem_general_termination ] let @xmath226 be a logic and @xmath230 be a sound and constructively complete tableau calculus for a semantic specification @xmath227 of the logic @xmath226 . then @xmath421 is sound and constructively complete for @xmath227 .",
    "furthermore , @xmath421 is terminating for @xmath226 , if the following conditions all hold :    1 .",
    "there is a finite closure operator @xmath424 ( defined on sets of concepts of the language of  @xmath226 ) such that @xmath230 is compatible with @xmath424 .",
    "2 .   @xmath226 has the effective finite model property with respect to @xmath227 .    from this theorem and theorems  [ theorem_soundness ] , [ theorem_constructive_completeness ] , [ theorem : tableau transformation ] , [ theorem : rfe ] and lemmas  [ lemma : subexpresiion property ] and  [ lemma :",
    "sub is finite ] it follows that the extensions of the generated and refined tableau calculi with unrestricted blocking are sound and ( constructively ) complete .",
    "moreover , if it is known that the given logic has the effective finite model property with respect to a finite semantic specification then both extensions are terminating as well .",
    "it is well known that @xmath50 has the effective finite model property with respect to @xmath173 , and clearly @xmath173 has a finite number of statements . as a consequence , a terminating tableau calculus for @xmath1is obtained if the calculus in figure  [ fig : optimised so tableau ] is enhanced with the unrestricted blocking mechanism as described above . using the refinements in section  [ section : refinement 2 ]",
    "the unrestricted blocking rule can be transformed as follows .",
    "\\label{rule : so unrestricted blocking}\\ ] ]    let @xmath428 be a tableau calculus comprising of the rules listed in figure  [ fig : optimised so tableau ] and the rule  .",
    "the calculus @xmath428 is sound and constructively complete for @xmath50 .",
    "furthermore , @xmath428 is terminating provided that conditions  ( c[req : blocking ] ) and  ( c[req : ub before exists ] ) are both true for @xmath428-derivations .    in the calculus @xmath428 , the imposed conditions  ( c[req : blocking ] ) and  ( c[req : ub before exists ] )",
    "are restrictions on applications of the rule @xmath429 following  @xcite , the calculus @xmath428 can be turned into a deterministic decision procedure using breadth - first search or depth - first search .    the calculus @xmath428 presents a new terminating tableau calculus for @xmath1or equivalent hybrid logics .",
    "the main difference to existing tableau approaches ( in a similar style ) for  @xmath1or equivalent hybrid logics is that the individuals ( or nominals ) are handled differently . to force termination typically",
    "either equality or subset ancestor loop checking is used , and often transitivity is handled by a propagation rule .",
    "we consider another example to illustrate the method .",
    "propositional intuitionistic logic  @xmath430 is a logic where the ` holds ' predicates @xmath385 can not be expressed in the language of the logic .",
    "it is non - boolean and provides an example of a logic where the background theory interacts with the definitions of the connectives .",
    "the language of intuitionistic logic is a one - sorted language defined over a countable set of propositional symbols @xmath431 , and the standard connectives are @xmath432 .",
    "the semantic specification @xmath433 in @xmath74 is given by ( confer  @xcite ) :    connective definitions : @xmath434    background theory : @xmath435    the connective definitions impose the usual requirements for truth of a formula in a world of an intuitionistic kripke model .",
    "for instance , the definition of implication expresses in  @xmath74 the property that an implication of @xmath378 from @xmath100 is true in a world @xmath119 if and only if @xmath378 is true in every successor of @xmath119 whenever @xmath100 is true in that successor .",
    "@xmath436  is the domain predicate symbol representing a partial order , which is specified by the first three sentences of the background theory .",
    "the last sentence in the background theory specifies monotonicity of the truth of formulae ( of sort  @xmath11 ) .    for intuitionistic logic the orderings @xmath220 and @xmath203 coincide . the ordering @xmath203 on subexpressions induced by the semantic definition of the connectives is the smallest ordering satisfying @xmath437 and @xmath438 , for each @xmath439 and any intuitionistic formulae @xmath440 and @xmath441 .",
    "that is , @xmath203 is the direct subexpression ordering on intuitionistic formulae .",
    "thus , the closure operator @xmath422 induced by the reflexive closure @xmath215 of the ordering @xmath203 is finite .",
    "decomposition rules : @xmath442    theory rules : @xmath443    closure rules : @xmath444    the tableau rules generated from the specification @xmath433 are those listed in figure  [ fig : int tableau ] .",
    "together with the equality rules of figure  [ fig : equality rules ] , they form a calculus , which is sound and constructively complete for intuitionistic logic .",
    "this is a consequence of theorems  [ theorem_soundness ] and  [ theorem_constructive_completeness ] .",
    "refining the generated rules yields the rules listed in figure  [ fig : optimised int tableau ] . using theorem  [ theorem : tableau transformation ]",
    "we conclude that together with the equality rules these rules provide a sound and constructively complete tableau calculus for intuitionistic logic .",
    "we denote this calculus by @xmath445 .",
    "decomposition rules : @xmath446    theory rules : @xmath447    closure rules : @xmath448    similarly to the case of @xmath1 , because intuitionistic logic has the effective finite model property , by theorem  [ theorem : termination ] together with lemmas  [ lemma : subexpresiion property ] and  [ lemma : sub is finite ] , a terminating tableau calculus for @xmath430 is obtained if the calculus @xmath445 is enhanced with the unrestricted blocking mechanism .",
    "the tableau calculus @xmath449 is sound , constructively complete and terminating for @xmath430 .",
    "following  @xcite , @xmath449 can be turned into deterministic decision procedures for @xmath430 using breadth - first search or depth - first search .",
    "the method introduced in this paper automatically produces a sound and constructively complete tableau calculus from the semantic first - order specification of a many - sorted logic .",
    "the method is directly applicable to many non - classical logics and covers many types of ground tableau calculi commonly found in the literature .    on one hand , the formalisation is based on ideas used in the implementation of tableau decision procedures for modal and description logics in the @xmath450system  @xcite .",
    "the @xmath450system provides a core for tableau derivations , which does not depend on a logical language . due to this language flexibility , without any modification of the core code , the prover constructs ( sound , complete , and terminating ) tableau derivations for standard modal logics , superintuitionistic logics ( via the gdel translation ) , many description logics , as well as for logics of metrics and topology for which it was originally written .",
    "termination is achieved via an implementation of generalisations of standard blocking mechanisms as well as the unrestricted blocking mechanism .",
    "this means that @xmath450provides an implementation of a tableau decision procedure for description logics with full support of the role negation operator , which can not currently be handled by other tableau - based description and modal logic theorem provers . on the other hand",
    ", the results of this paper provide the theoretical foundation for the correct behaviour of tableau algorithms implemented in @xmath450 .",
    "more importantly , the results can be viewed as providing a mathematical formalisation and generalisation of tableau development methodologies .",
    "the formalisation separates the creative part of tableau calculus development , which needs to be done by a human developer , and the automatic part of the development process , which can be left to an automated ( currently first - order ) prover and an automated tableau synthesiser . in general",
    ", there is no algorithm for checking that an arbitrarily given binary relation forms a well - founded ordering .",
    "therefore the creative part is writing down the semantic specification of the object logic so that the conditions of well - foundedness of the orderings  @xmath220 and @xmath203 hold .",
    "the automatic part deals with verification of the first - order conditions  [ condition : well - defined semantics 1 ] and  [ condition : well - defined semantics 3a ] , and the generation of tableau rules from the ( well - defined ) semantics provided by the developer .    for common modal and description logics conditions  [ condition : well - defined semantics 1 ] and  [ condition : well - defined semantics 3 ] are simple to check , even trivial in many cases .",
    "in fact , a developer usually implicitly formalises the logic s semantics @xmath112 in such a way that @xmath451 .",
    "this is the case for almost all known logics . if the specification of the semantics satisfies @xmath451 then conditions  [ condition : well - defined semantics 1 ] and  [ condition : well - defined semantics 3 ] hold trivially and the orderings @xmath220 and @xmath203 coincide .",
    "this means the ordering used for the specification of the semantics of the logical connectives ( which is usually well - founded ) is enough for tableau synthesis .      1 .   most description logics , including @xmath452 , @xmath1 , @xmath453  @xcite , @xmath454  @xcite ; 2 .",
    "most propositional modal logics , including @xmath455 , @xmath3 , @xmath456 , @xmath457 , @xmath458 ; 3 .",
    "propositional intuitionistic logic  @xcite and many kripke - complete propositional superintuitionistic logics ; 4 .",
    "the logic of metric and topology  @xcite .",
    "this paper also presents a general method for proving ( constructive ) completeness of tableau calculi .",
    "in addition , the generated rules can be transformed to the rules with lower branching factors provided that condition   has been proved by induction on the ordering  @xmath203 for the refined calculus .    with enough expressivity for representing the basics of the semantics within the logic it is possible to simplify the language of the tableau calculus .",
    "in this case , the obtained calculus is similar to tableau calculi for description logics with singleton concepts , but also hybrid modal logic  @xcite and labelled tableau calculi  @xcite .",
    "otherwise , the calculus has the same flavour as standard tableau calculi for intuitionistic logic , where every node in a tableau derivation is characterised by two complementary sets of true and false formulae ( concepts ) .    that the generated calculi are constructively complete has the added advantage that models can be effectively generated from open , finished branches in tableau derivations .",
    "this means that the synthesised tableau calculi can be used for finding models .",
    "if the calculus includes the unrestricted blocking mechanism various strategies on the application of the unrestricted blocking rule can be employed for obtaining models with minimal domain sizes .    as case studies we considered tableau synthesis for propositional intuitionistic logic and the description logic @xmath1with singleton concepts and transitive roles .",
    "we believe the approach is also applicable to most known , first - order definable modal and description logics including the ones mentioned above .",
    "non first - order translatable logics such as propositional dynamic logic are currently beyond the scope of the method .",
    "the tableau calculi generated are smullyan - type tableau calculi , that is , ground semantic tableau calculi .",
    "we believe that other types of tableau calculi can be generated using the same techniques .",
    "we expect that generating unlabelled tableau calculi without explicit background predicates or domain terms will be possible , at least to some extent , but this is not immediate .",
    "one possibility would be to investigate if these can be derived as further refinements of the labelled tableau calculi generated by method presented in this paper .",
    "such a line of investigation would be interesting and shed more light on the relationship between different kinds of tableau calculi .",
    "exploiting the known relationships to other deduction methods we expect synthesis of non - tableau approaches is possible as well , but all this is future work .",
    "further investigations are needed to explore the extension of the framework to generate calculi based on propagation rules which incorporate frame correspondence properties into the definition of connectives to replace the theory rules for modal and description logics ( for example , transitivity for the logic @xmath1 ) .",
    "it is clear though that this is a much harder problem because guaranteeing completeness becomes more difficult .",
    "it is also clear that no results at the same level of generality as for the use of theory rules in this paper can be expected .",
    "we plan to implement the methodology as an automatic generator of tableau calculi . this will give users the ability to obtain tableau calculi very easily and without needing to have relevant knowledge of tableau - based reasoning or experience in developing tableau calculi .",
    "combined with a prover engineering platform such as @xmath459  @xcite or the tableau workbench  @xcite there is even the potential to build systems that would allow users to get implemented provers from the specification of logics .",
    "@xmath459and the tableau workbench are generic systems for building tableau - based theorem provers for non - classical logics .",
    "currently they allow users to define tableau procedures by flexibly specifying the set of tableau rules , the search strategies , the blocking technique and the optimisation techniques to be used .",
    "this is then compiled into a specialised prover for the specified procedure .",
    "enhanced with the tableau synthesis methodology , such systems could allow the user to define just the logic and produce an implemented prover for this logic .",
    "p.  abate and r.  gor .",
    "the tableaux work bench . in m.  c. mayer and f.  pirri , eds , _ proceedings of the 12th international conference on automated reasoning with analytic tableaux and related methods ( tableaux03 ) _ , vol .",
    "lecture notes in computer science _ , pp . 230236 .",
    "springer , 2003 .",
    "r.  alenda , n.  olivetti , c.  schwind , and d.  tishkovsky .",
    "tableau calculi for csl over minspaces . in a.",
    "dawar and h.  veith , eds , _ proceedings of the 19th annual conference of the european association for computer science logic ( csl10 ) _ , vol .",
    "lecture notes in computer science _ , pp . 5266 .",
    "springer , 2010 .",
    "a.  avellone , p.  miglioli , u.  moscato , and m.  ornaghi .",
    "generalized tableau systems for intemediate propositional logics . in d.",
    "galmiche , ed . ,",
    "_ proceedings of the 6th international conference on automated reasoning with analytic tableaux and related methods ( tableaux97 ) _ , vol .",
    "1227 of _ lecture notes in computer science _ , pp . 4361 .",
    "springer , 1997 .",
    "p.  baumgartner and r.  a. schmidt . blocking and other enhancements for bottom - up model generation methods . in u.",
    "furbach and n.  shankar , eds , _ proceedings of the 3rd international joint conference on automated reasoning ( ijcar06 ) _ , vol .",
    "lecture notes in artificial intelligence _ , pp . 125139 .",
    "springer , 2006 .",
    "f.  bry and r.  manthey .",
    "proving finite satisfiability of deductive databases . in e.",
    "brger , h.  kleine  bning , and m.  m. richter , eds , _ proceedings of the 1st workshop on computer science logic ( csl87 ) _ , vol .",
    "329 of _ lecture notes in computer science _ , pp . 4455 .",
    "springer , 1988 .",
    "f.  bry and s.  torge .",
    "a deduction method complete for refutation and finite satisfiability . in j.  dix ,",
    "l.  farias  del cerro , and u.  furbach , eds , _ proceedings of the 6th european conference on logics in artificial intelligence ( jelia98 ) _ , vol .",
    "lecture notes in computer science _ , pp . 117 .",
    "springer , 1998 .",
    "m.  cialdea  mayer and s.  cerrito .",
    "nominal substitution at work with the global and converse modalities . in l.",
    "beklemishev , v.  goranko , and v.  shehtman , eds , _ advances in modal logic _ , vol .  8 , pp . 5774 .",
    "college publications , 2010 .",
    "o.  gasquet , a.  herzig , d.  longin , and m.  sahade . : logical tableaux research engineering companion . in b.",
    "beckert , ed . ,",
    "_ proceedings of the 14th international conference on automated reasoning with analytic tableaux and related methods ( tableaux05 ) _ , vol .",
    "3702 of _ lecture notes in computer science _ , pp . 318322 .",
    "springer , 2005 .",
    "v.  goranko and d.  shkatov .",
    "tableau - based decision procedure for full coalitional multiagent temporal - epistemic logic of linear time . in c.  sierra , c.  castelfranchi , k.  s. decker , and j.  s. sichman , eds , _ proceedings of the 8th international joint conference on autonomous agents and multi - agent systems ( aamas09 ) _ , pp . 969976 .",
    "ifaamas , 2009 .",
    "u.  hustadt and r.  a. schmidt . on the relation of resolution and tableaux proof systems for description logics . in t.",
    "dean , ed .",
    ", _ proceedings of the 16th international joint conference on artificial intelligence ( ijcai99 ) _ , pp .",
    "morgan kaufmann , 1999 .",
    "u.  hustadt , d.  tishkovsky , f.  wolter , and m.  zakharyaschev .",
    "automated reasoning about metric and topology ( system description ) . in m.",
    "fisher , w.  van  der hoek , b.  konev , and a.  lisitsa , eds , _ proceedings of the 10th european conference on logics in artificial intelligence ( jelia06 ) _ , vol .",
    "4160 of _ lecture notes in artificial intelligence _ , pp . 490493 .",
    "springer , 2006 .",
    "r.  a. schmidt .",
    "developing modal tableaux and resolution methods via first - order resolution . in g.  governatori , i.  m. hodkinson , and y.  venema , eds , _ advances in modal logic , volume 6",
    "_ , pp . 126 .",
    "college publications , 2006 .",
    "r.  a. schmidt and d.  tishkovsky .",
    "using tableau to decide expressive description logics with role negation . in k.",
    "aberer , k .- s .",
    "choi , n.  noy , d.  allemang , k .-",
    "lee , l.  nixon , j.  golbeck , p.  mika , d.  maynard , r.  mizoguchi , g.  schreiber , and p.  cudr - mauroux , eds , _ proceedings of the 6th international semantic web conference and the 2nd asian semantic web conference ( iswc07 ) _ , vol .",
    "4825 of _ lecture notes in computer science _ , pp . 438451 .",
    "springer , 2007 .",
    "r.  a. schmidt and d.  tishkovsky . a general tableau method for deciding description logics , modal logics and related first - order fragments . in a.",
    "armando , p.  baumgartner , and g.  dowek , eds , _ proceedings of the 4th international joint conference on automated reasoning ( ijcar08 ) _ , vol .",
    "lecture notes in computer science _ , pp . 194209 .",
    "springer , 2008 .",
    "r.  a. schmidt and d.  tishkovsky . automated synthesis of tableau calculi . in m.",
    "giese and a.  waaler , eds , _ proceedings of the 18th international conference on automated reasoning with analytic tableaux and related methods ( tableaux09 ) _ , vol .",
    "5607 of _ lecture notes in artificial intelligence _ , pp . 310324 .",
    "springer , 2009 .",
    "d.  tishkovsky , r.  a. schmidt , and m.  khodadadi .",
    "@xmath450 : a tableau prover with logic - independent inference engine . in g.",
    "metcalfe and k.  brnnler , eds , _ automated reasoning with analytic tableaux and related methods ( tableaux11 ) _ , lecture notes in computer science .",
    "springer , 2011 . to appear .",
    "m.  tzakova .",
    "tableau calculi for hybrid logics . in n.",
    "v. murray , ed . , _ proceedings of the 8th international conference on automated reasoning with analytic tableaux and related methods ( tableaux99 ) _ , vol . 1617 of _ lecture notes in computer science",
    ", pp . 278292 .",
    "springer , 1999 ."
  ],
  "abstract_text": [
    "<S> this paper presents a method for synthesising sound and complete tableau calculi . given a specification of the formal semantics of a logic , the method generates a set of tableau inference rules that can then be used to reason within the logic . </S>",
    "<S> the method guarantees that the generated rules form a calculus which is sound and constructively complete . </S>",
    "<S> if the logic can be shown to admit finite filtration with respect to a well - defined first - order semantics then adding a general blocking mechanism provides a terminating tableau calculus . </S>",
    "<S> the process of generating tableau rules can be completely automated and produces , together with the blocking mechanism , an automated procedure for generating tableau decision procedures . </S>",
    "<S> for illustration we show the workability of the approach for a description logic with transitive roles and propositional intuitionistic logic . </S>"
  ]
}