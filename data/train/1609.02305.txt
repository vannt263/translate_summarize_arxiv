{
  "article_text": [
    "computer networks such as datacenter networks , enterprise networks , carrier networks etc .  have become a critical infrastructure of the information society .",
    "the importance of computer networks and the resulting strict requirements in terms of availability , performance , and correctness however stand in contrast to today s ossified computer networks : the techniques and methodologies used to build , manage , and debug computer networks are largely the same as those used in 1996  @xcite .",
    "indeed , operating traditional computer networks is often a cumbersome and error - prone task , and even tech - savvy companies such as github , amazon , godaddy , etc .  frequently report issues with their network , due to misconfigurations , e.g. , resulting in forwarding loops  @xcite .",
    "another anecdote reported in  @xcite illustrating the problem , is the one by a wall street investment bank : due to a datacenter outage , the bank was suddenly losing millions of dollars per minute .",
    "quickly the compute and storage emergency teams compiled a wealth of information giving insights into what might have happened .",
    "in contrast , the networking team only had very primitive connectivity testing tools such as ping and traceroute , to debug the problem .",
    "they could not provide any insights into the actual problems of the switches or the congestion experienced by individual packets , nor could the team create any meaningful experiments to identify , quarantine and resolve the problem  @xcite . given the increasing importance computer networks play today , this situation is worrying .",
    "software - defined networking is an interesting new paradigm which allows to operate and verify networks in a more principled and formal manner , while also introducing flexibilities and programmability , and hence faster innovations . in a nutshell , a software - defined network ( sdn ) outsources and consolidates the control over the forwarding or routing devices ( located in the so - called _ data plane _ ) to a logically centralized controller software ( located in the so - called _ control plane _ ) .",
    "this decoupling allows to evolve and innovate the control plane independently from the hardware constraints of the data plane .",
    "moreover , openflow , the de facto standard sdn protocol today , is based on a simple match - action paradigm : the behavior of an openflow switch is defined by a set of forwarding rules installed by the controller .",
    "each rule consists of a match and an action part : all packets matched by a given rule are subject to the corresponding action .",
    "matches are defined over layer-2 to layer-4 header fields ( e.g. , mac and ip addresses , tcp ports , etc . ) , and actions typically describe operations such as forward to a specific port , drop , or update certain header fields . in other words , in an sdn / openflow network , network devices become simpler : their behavior is defined by a set of rules installed by the controller .",
    "this enables formal reasoning and verification , as well as flexible network update , from a logically centralized perspective  @xcite .",
    "moreover , as rules can be defined over multiple osi layers , the distinction between switches and routers ( and even simple middleboxes  @xcite ) becomes blurry .",
    "however , the decoupling of the control plane from the data plane also introduces new challenges .",
    "in particular , the switches and controllers as well as their interconnecting network form a complex asynchronous distributed system . for example , a remote controller may learn about and react to network events slower ( or not at all ) than a hardware device in the data plane : given a delayed and inconsistent view , a controller ( and accordingly the network ) may behave in an undesirable way .",
    "similarly , new rules or rule updates communicated from the controller(s ) to the switch(es ) may take effect in a delayed and asynchronous manner : not only because these updates have to be transmitted from the controller to the switches over the network , but also the reaction time of the switches themselves may differ ( depending on the specific hardware , data structures , or concurrent load ) .",
    "thus , while sdn offers great opportunities to operate a network in a correct and verifiable manner , there remains a fundamental challenge of how to deal with the asynchrony inherent in the communication channel between controller and switches as well as in the switches themselves .",
    "accordingly , the question of how to update network behavior and configurations correctly yet efficiently has been studied intensively over the last years .",
    "however , the notions of correctness and efficiency significantly differs across the literature .",
    "indeed , what kind of correctness is needed and which performance aspects are most critical often depends on the context : in security - critical networks , a very strong notion of correctness may be needed , even if it comes at a high performance cost ; in other situations , however , short transient inconsistencies may be acceptable , as long as at least some more basic consistency guarantees are provided ( e.g. , loop - freedom ) .",
    "we observe that not only the number of research results in the area is growing very quickly , but also the number of models , the different notions of consistency and optimization objectives , as well as the algorithmic techniques .",
    "thus , it has become difficult to keep an overview of the field even for active researchers .",
    "moreover , we observe that many of the underlying problems are not entirely new or specific to sdn : rather , similar consistency challenges arose and have been studied already in legacy networks , although update algorithms in legacy protocols are often more distributed and indirect ( e.g. , based on igp weights ) .",
    "accordingly , we believe that it is time for a comprehensive survey of the subject .      any dependable network does not only need to maintain a range of static invariants , related to correctness , availability , and performance , but also needs to be flexible and support reconfigurations and updates .",
    "reasons for updating a network are manifold , including :    1 .",
    "_ change in the security policy : _ due to a change in the enterprise security policy , traffic from one subnetwork may have to be rerouted via a firewall before entering another subnetwork . or",
    ", in the wide - area network , the set of countries via which it is safe to route sensitive traffic may change over time .",
    "_ traffic engineering : _ in order to improve traffic engineering metrics ( e.g. , minimizing the maximal link load ) , a system administrator or operator may decide to reroute ( parts of ) the traffic along different links . for example , many internet service providers switch between multiple routing patterns during the day , depending on the expected load .",
    "these patterns may be precomputed offline , or may be computed as a reaction to an external change ( e.g. , due to a policy change of a content distribution provider ) .",
    "maintenance work : _ also maintenance work may require the update of network routes . for example , in order to replace a faulty router , or to upgrade an existing router , it can be necessary to temporarily reroute traffic .",
    "link and node failures : _ failures happen quite frequently and unexpectedly in today s computer networks , and typically require a fast reaction . accordingly , fast network monitoring and update mechanisms are required to react to such failures , e.g. , by determining a failover path .    despite these changes ,",
    "it is often desirable that the network maintains certain minimal consistency properties , _ during the update_. for example , per - packet consistency ( a packet should be forwarded along the old or the new route , but never a mixture of both ) , loop - freedom ( at no point in time are packets forwarded along a loop ) , or waypoint enforcement ( a packet should never bypass a firewall ) .    moreover , while the reasons for network updates identified above are general and relevant in any network , both software - defined and traditional , we believe that the flexibilities introduced by programmable networks are likely to increase the frequency of network updates , also enabling , e.g. , a more fine - grained and online traffic engineering  @xcite .      this paper presents a comprehensive survey of the consistent network update problem .",
    "we identify and compare the different notions of consistency as well as the different performance objectives considered in the literature . in particular , we provide an overview of the algorithmic techniques required to solve specific classes of network update problems , and discuss inherent limitations and tradeoffs between the achievable level of consistency and the speed at which networks can be updated .",
    "in fact , as we will see , some update techniques are not only less efficient than others , but with them , it can even be impossible to consistently update a network .    while our survey is motivated by the advent of software - defined networks ( sdns ) , the topic of consistent network updates is not new , and for example , guaranteeing disruption - free igp operations has been considered in several works for almost two decades .",
    "accordingly , we also present a historical perspective , surveying the consistency notions provided in traditional networks and discussing the corresponding techniques accordingly .",
    "moreover , we put the algorithmic problems into perspective and discuss how these problems relate to classic optimization and graph theory problems , such as multi - commodity flow problems or maximum acyclic subgraph problems .",
    "the goal of our survey is to ( 1 ) provide active researchers in the field with an overview of the state - of - the - art literature , but also to ( 2 ) help researchers who only recently became interested in the subject to bootstrap and learn about open research questions .",
    "the remainder of this paper is organized as follows . ",
    "[ sec : history ] presents a historical perspective and reviews notions of consistency and techniques both in traditional computer networks as well as in software - defined networks .",
    " [ sec : taxo ] then presents a classification and taxonomy of the different variants of the consistent network update problems . ",
    "[ sec : forwarding ] ,  [ sec : policies ] , and ",
    "[ sec : cap ] review models and techniques for connectivity consistency , policy consistency , and performance consistency related problems , respectively .  [ sec : orthogonal ] discusses proposals to further relax consistency guarantees by introducing tighter synchronization . in ",
    "[ sec : practice ] , we identify practical challenges . after highlighting future research directions in  [ sec : openprob ] , we conclude our paper in ",
    "[ sec : conclusion ] .",
    "any computer network needs to provide basic mechanisms and protocols to change forwarding rules and network routes , and hence , the study of consistent network updates is not new and the topic to some extent evergreen .",
    "for example , a forwarding loop can quickly deplete switch buffers and harm the availability and connectivity provided by a network , and protocols such as the spanning tree protocol ( stp ) have been developed to ensure loop - free layer-2 forwarding at any time .",
    "however , consistency problems may also arise on higher layers in the osi stack .    in this section",
    ", we provide a historical perspective on the many research contributions that lately focused on guaranteeing consistency properties during network updates , that is , while changing device configurations ( and how they process packets ) .",
    "we first discuss update problems and techniques in traditional networks (  [ subsec : history - igp]-[subsec : history - routing ] ) . in those networks ,",
    "forwarding entries are computed by routing protocols that run standardly - defined distributed algorithms , whose output is influenced by both network topology ( e.g. , active links ) and routing configurations ( e.g. , logical link costs ) .",
    "pioneering works then aimed at avoiding transient inconsistencies due to modified topology or configurations , mainly focusing on igps , i.e. , the routing protocols that control forwarding within a single network .",
    "a first set of contributions tried to modify igp protocol definitions , mainly to provide forwarding consistency guarantees upon link or node failures .",
    "progressively , the research focus has shifted to a more general problem of finding a sequence of igp configuration changes that lead to new paths while guaranteeing forwarding consistency , e.g. , for service continuity (  [ subsec : history - igp ] ) .",
    "more recent works have also considered reconfigurations of protocols different or deployed in addition to igps , mostly generalizing previous techniques while keep focusing on forwarding consistency (  [ subsec : history - routing ] ) .    subsequently (  [ subsec : history - sdn ] ) , we discuss update problems tackled in the context of logically - centralized networks , implementing the software defined networking ( sdn ) paradigm .",
    "sdn is predicated around a clear separation between controller ( implementing the control logic ) and dataplane elements ( applying controller s decision on packets ) .",
    "this separation arguably provides new flexibility and opens new network design patterns , for example , enabling security requirements to be implemented by careful path computation ( done by the centralized controller ) .",
    "this also pushed network update techniques to consider additional consistency properties like policies and performance .",
    "we rely on the generic example shown in fig .",
    "[ fig : example - history ] for illustration .",
    "the figure shows the intended forwarding changes to be applied for a generic network update .",
    "observe that possible forwarding loops can occur during this update because edges @xmath0 and @xmath1 are traversed in opposite directions before and after the update .      in traditional ( non - sdn ) networks ,",
    "forwarding paths are computed by distributed routing protocols .",
    "link - state interior gateway protocols ( igps ) are the most popular of those protocols used to compute forwarding paths within a network owned by the same administrative entity .",
    "link - state igps are based on computing shortest - paths on a weighted graph , representing a logical view of the network , which is shared across routers .",
    "parameters influencing igp computations , like link weights of the shared graph , are set by operators by editing router configurations .    as an illustration ,",
    "[ fig : example - history - igp ] shows a possible implementation for the update example presented in fig .",
    "[ fig : example - history ] . in particular , fig .",
    "[ fig : example - history - igp ] reports the igp graph ( consistent with the physical network topology ) with explicit mention of the configured link weights . based on those weights , for each destination ( e.g. , @xmath2 in this example ) , all routers independently compute the shortest paths , and forward the corresponding packets to the next - hops on those paths .",
    "consequently , the igp configurations in figs .",
    "[ subfig : example - history - igp - init ] and  [ subfig : example - history - igp - fin ] respectively produce the forwarding paths depicted in figs .",
    "[ subfig : example - history - generic - init ] and  [ subfig : example - history - generic - fin ] .",
    "when the igp graph is modified ( e.g. , because of a link failure , a link - weight change or a router restart ) , messages are propagated by the igp itself from node to node , so that all nodes rebuild a consistent view of the network : this process is called _",
    "igp convergence_. however , igps do not provide any guarantee on the time and order in which nodes receive messages about the new igp graphs .",
    "this potentially triggers transient forwarding disruptions due to temporary state inconsistency between a set of routers .",
    "for example , assume that we simply remove link @xmath3 from the igp graph shown in fig .",
    "[ subfig : example - history - igp - init ] .",
    "this will eventually lead us to the configuration presented in fig .",
    "[ subfig : example - history - igp - fin ] . before the final state",
    "is reached , the notification that @xmath3 is removed has to be propagated to all routers .",
    "if @xmath4 receives such notification before @xmath5 ( e.g. , because closer to the removed link ) , then @xmath4 would recompute its next - hop based on the new information , and starts forwarding packets for @xmath2 to @xmath5 ( see fig .",
    "[ subfig : example - history - generic - fin ] ) . nevertheless , @xmath5 keeps forwarding packets to @xmath6 as it still forwards as @xmath3 is still up .",
    "this creates a loop between @xmath4 and @xmath5 : the loop remains until @xmath5 is notified about the removed link .",
    "a similar loop can occur between @xmath5 and @xmath6 .",
    "guaranteeing disruption - free igp operations has been considered by research and industry since almost two decades .",
    "we now briefly report on the main proposals .",
    "* disruption - free igps have been studied . * early contributions focused on modifying the routing protocols , mainly to avoid forwarding inconsistencies . among them , protocol extensions have been proposed  @xcite to gracefully restart a routing process , that is , to avoid forwarding disruptions ( e.g. , blackholes ) during a software update of a router .",
    "other works focused on preserving forwarding consistency , that is , avoiding loops , upon network failures .",
    "for example , franois _ et al . _",
    "@xcite propose ofib , an igp extension that guarantees the absence of forwarding loops after topological changes ( link / node addition or removal ) .",
    "the key intuition behind ofib is to use explicit synchronization between routers in order to constrain the order in which each node changes its forwarding entries .",
    "in particular , each router ( say , @xmath5 in our example ) is forced not to update its forwarding entry for a given destination ( @xmath2 in our example ) until all its final next - hops ( @xmath6 ) use their own final next - hops ( @xmath2 in our case ) .",
    "et al . _",
    "@xcite generalize the previous approach by defining a loop - free ordering of igp - entry updates for arbitrary forwarding changes .",
    "moreover , plsn  @xcite specializes ofib : it allows routers to dynamically avoid loops by locally delaying forwarding changes that are not safe . a variant of ofib , studied by shi _",
    "et al . _",
    "@xcite , also extends the reconfiguration mechanism to consider traffic congestion in addition to forwarding consistency .",
    "modifying protocol specifications may seem the most straightforward solution to deal with reconfigurations in traditional networks , but it actually has practical limitations .",
    "first , this approach can not accommodate custom reconfiguration objectives .",
    "for instance , ordered forwarding changes generally work only on a per - destination basis  @xcite , which can make the reconfiguration process slow if many destinations are involved  while one operational objective could be to exit transient states as quickly as possible .",
    "second , protocol modifications are typically targeted to specific reconfiguration cases ( e.g. , single - link failures ) , since it is technically hard to predict the impact of any configuration change on forwarding paths",
    ". finally , protocol extensions are not easy to implement in current igps , because of the need for passing through vendors ( to change proprietary router software ) , the added complexity and the potential overhead ( e.g. , load ) induced on routers .",
    "limited practicality of protocol modifications quickly motivated new approaches , based on coordinating operations in order to eventually replace the initial configuration with the final one on all network nodes , while guaranteeing absence of disruptions throughut the process . those approaches , summarized in the following , mainly focused on support for planned operations .",
    "* optimization algorithms can minimize disruptions .",
    "* as a first attempt , keralapura _ et al . _",
    "@xcite studied the problem of finding the optimal way in which devices and links can be added to a network to minimize disruptions .",
    "many following contributions focused on finer - grained operations to gain additional degrees of freedom in igp reconfiguration problems .",
    "a natural choice among finer - grained operations readily supported by traditional routers is tweaking igp link weights .",
    "for example , in  @xcite and  @xcite , raza _ et al . _",
    "propose a theoretical framework to formalize the problem of minimizing a certain disruption function ( e.g. , link congestion ) when the link weights have to be changed .",
    "the authors also propose a heuristic to find an ordering in which to modify several igp weights within a network , so that the number of disruptions is minimal .",
    "while easily applicable to real reconfiguration cases , those approaches assume primitives which are quite coarse grained ( e.g. , addition of a link , or weight changes ) , and can not guarantee the absence of disruptions in several cases : the scenario in fig .",
    "[ fig : example - history - igp ] is an example where coarse - grained operations ( link removal ) can not prevent forwarding loops .",
    "* progressively changing link weights can avoid loops . *",
    "intermediate igp link weights can be used during a reconfiguration to avoid disruptions  at the cost of increasing the size of the update sequence and slowing down the update .",
    "consider again the example in fig .",
    "[ fig : example - history - igp ] , and let the final weight for link @xmath3 conventionally be @xmath7 . in this case , the forwarding loops potentially triggered by the igp reconfiguration can be provably prevented by using two intermediate weights for link @xmath3 , as illustrated in fig .",
    "[ fig : example - history - igp - seq ] .",
    "the first of those intermediate weights ( see fig .  [",
    "subfig : example - history - igp - seq2 ] ) is used to force @xmath6 and only @xmath6 to change its next - hop , from @xmath5 to @xmath2 : intuitively , this prevents the loop between @xmath5 and @xmath6 . the second intermediate weight ( see fig",
    ".  [ subfig : example - history - igp - seq3 ] ) similarly guarantees that the loop between @xmath4 and @xmath5 is avoided , i.e. , by forcing @xmath5 to use its final next - hop before @xmath4 .",
    "of course , finding intermediate weights that guarantee the absence of disruptions becomes much trickier when multiple destinations are involved .",
    "such a technique can be straightforwardly applied to real routers .",
    "for example , an operator can progressively change the weight of @xmath3 to @xmath8 by editing the configuration of @xmath4 and @xmath2 , then check that the all igp routers have converged on the paths in fig .",
    "[ subfig : example - history - igp - seq2 ] , repeat similar operations to reach the state in fig .  [ subfig : example - history - igp - seq3 ] , and safely remove the link .",
    "even better , it has been shown  @xcite that a proper sequence of intermediate link weights can always avoid all possible transient loops for any single - link reweighting .",
    "obviously , the weight can be changed on multiple links in a loop - free way , by progressively reweighting links one by one .",
    "additional research contributions then focused on minimizing the number of intermediate weights that ensure loop - free reconfigurations . surprisingly , the problem is _ not _ computationally hard , despite the fact that all destinations have potentially to be taken into account when changing link weights .",
    "polynomial - time algorithms have been proposed to support planned operations at the per - link  @xcite ( e.g. , single - link reweighting ) and at a per - router  @xcite ( e.g. , router shutdown / addition ) granularity .",
    "* ships - in - the - night ( sitn ) techniques generalize the idea of incremental changes to avoid loops . * to improve the update speed in the case of many link changes and deal with generalized reconfigurations ( from changing routing parameters to replacing an igp with another ) , both industrial best practices and research works often rely on a technique commonly called ships - in - the - night  @xcite .",
    "this technique builds upon the capability of traditional routers to run multiple routing processes at the same time .",
    "thanks to this capability , both the initial and final configurations can be installed ( as different routing processes ) on all nodes at the same time .",
    "[ fig : example - history - sitn - setup ] shows the setup for a ships - in - the - night reconfiguration for the reconfiguration case in fig .",
    "[ fig : example - history - igp ] .        in sitn ,",
    "the reconfiguration process then consists in swapping the preference of the initial configuration with the final one on every node , potentially for a single destination .",
    "hence , at any moment in time , every node uses only one of the two configurations , but different nodes can use different configurations .",
    "this implies that ( 1 ) for each destination , every switch either uses its initial next - hops or its final ones , meaning that the update does not add overhead to the hardware memory of any node ; but ( 2 ) inconsistencies may arise from the mismatch between routing processes used by distinct nodes .",
    "for example , fig .",
    "[ fig : example - history - sitn - seq ] shows a sitn - based reconfiguration that mimicks the progressive link weight increment depicted in fig .  [",
    "fig : example - history - igp - seq ] .",
    "sitn reconfiguration techniques are more powerful than igp link reweighting .",
    "the ships - in - the - night framework enables to change the forwarding next - hop of each router independently from the others , hence providing a finer - grained reconfiguration primitive with respect to igp weight modifications ( which influence all routers for all destinations ) .",
    "moreover , sitn techniques can be applied to arbitrary changes of the igp configuration , rather than just link reweighting .    on the flip side",
    ", the ships - in - the - night approach also opens a new algorithmic problem , that is , to decide a safe order in which to swap preferences on a per - router basis . indeed , naive approaches in swapping configuration preferences can not guarantee disruption - free reconfigurations .",
    "for example , replacing the initial configuration with the final one on all nodes at once provides no guarantee on the order in which new preferences are applied by nodes , hence potentially triggering packet losses and service disruptions ( in addition to massive control - plane message storms ) .",
    "even worse , such an approach could leave the network in an inconsistent , disrupted and hard - to - troubleshoot state if any reconfiguration command is lost or significantly delayed .",
    "similarly , industrial best practices ( e.g. ,  @xcite ) only provide rules of thumb which do not apply in the general case , and do not guarantee lossless reconfiguration processes .    to guarantee the absence of disruptions , configuration preference",
    "must then be swapped incrementally , in a carefully - computed order  @xcite .",
    "this called for research contributions .",
    "prominently , vanbever _ et al .",
    "_  @xcite proposed various algorithms ( based on linear programming , and heuristic ones ) to deal with many more igp reconfiguration scenarios , including the simultaneous change of multiple link weights , the modification of other parameters ( e.g. , ospf areas ) influencing igp decisions , and the replacement of one igp protocol with another ( e.g. , ospf with is - is ) .",
    "to minimize the update time , the proposed algorithms also try to touch each router only once , i.e. , modifying its forwarding entries to all possible destinations altogether .",
    "as such , they also generalize the algorithms behind protocol - modification techniques , especially ofib  @xcite , that restrict to per - destination operational orderings . beyond providing ordering algorithms , @xcite also describe comprehensive system to carry out loop - free igp reconfigurations in automatically or semi - automatically , i.e. , possibly waiting the input from the operator to perform the next set of operations in the computed operational sequence .",
    "research contributions have been devoted to reconfigurations in more realistic settings , including other protocols than just an igp .    * enterprise networks , with several routing domains . * as a first example , the ships - in - the - night framework has been used to carry out igp reconfigurations in enterprise networks .",
    "those networks typically use _ route redistribution _",
    "@xcite , a mechanism enabling the propagation of information from one routing domain ( e.g. , running a given igp ) to another ( e.g. , running a different igp ) .",
    "unfortunately , route redistribution may be responsible for both routing ( inability to converge to a stable state ) and forwarding ( e.g. , loop ) anomalies  @xcite .",
    "generalized network update procedures have been proposed in  @xcite to avoid transient anomalies while ( i )   reconfiguring a specific routing domain without impacting another , and/or ( ii )   arbitrarily changing the size and shape of routing domains .    * internet service providers ( isps ) , with bgp and mpls . * in isp networks , the bgp and often mpls protocols are pervasively used to manage transit internet traffic , for which both the source and the destination is external to the network .",
    "et al . _",
    "@xcite showed that even techniques guaranteeing safe igp reconfigurations can cause transient forwarding loops in those settings , because of the interaction between igp and bgp .",
    "they also proved conditions to avoid those bgp - induced loops during igp reconfigurations , by leveraging mpls or bgp configuration guidelines .    in parallel , a distinct set of techniques aimed at supporting bgp reconfigurations .",
    "those contributions range from mechanisms to avoid churn of bgp messages during programmed operations ( e.g. , router reboots or bgp session maintenance  @xcite ) to techniques for safely moving virtual routers  @xcite or part of physical - router configuration ( e.g. , bgp sessions )  @xcite . a framework that guarantees strong consistency for arbitrary changes of the bgp configuration",
    "is presented in  @xcite : it is based on implemeting ships - in - the - night in bgp and using packet tags to uniformly apply either the initial or the final forwarding at all routers .",
    "internet - level problems , like maintaining global connectivity upon failures , have also been explored ( see , e.g. ,  @xcite ) .",
    "* protocol - independent reconfiguration frameworks . * by design ,",
    "all the above approaches are dependent on the considered ( set of ) protocols and even on their implementation .",
    "protocol - independent reconfiguration techniques have also been proposed .",
    "prominently , in  @xcite , alimi _ et al .",
    "_ generalize the ship - in - the - night technique , by re - designing the router architecture .",
    "this re - design would allow routers not only to run multiple configurations simultaneously but also to select the configuration to be applied on every packet based on the value of a specific bit in the packet header .",
    "the authors also describe a commitment protocol to support the switch between configurations without creating forwarding loops .",
    "mechanisms for consensus routing have been explored in  @xcite .",
    "recently , software defined networking ( sdn ) has grown in popularity , thanks to its promises to spur abstractions , mitigate compelling management problems and avoid network ossification  @xcite .",
    "software - defined networks differ from traditional ones from an architectural viewpoint : in sdn , the control is outsourced and consolidated to a logically - centralized element , the network controller , rather than having devices ( switches and routers ) run their own distributed control logic .",
    "in pure sdn networks , the controller computes ( according to operators input ) and installs ( on the controlled devices ) the rules to be applied to packets traversing the network : no message exchange or distributed computation are needed anymore on network devices .",
    "[ fig : example - history - sdn - init ] depicts an example of an sdn network , configured to implement the initial state of our update example ( see fig .",
    "[ fig : example - history ] ) . beyond the main architectural components ,",
    "the figure also illustrate a classic interaction between them .",
    "indeed , the dashed lines indicate that the sdn controller instructs the reprogrammable network devices , typically switches  @xcite ) , on how to process ( e.g. , forward ) the traversing packets .",
    "an example command sent by the controller to switch @xmath9 is also reported next to the dashed line connecting the two .     in an sdn network . ]",
    "the sdn architecture makes the role of network updates even more frequent and critical than in traditional networks . on the one hand ,",
    "controllers are often intended to support several different requirements , including performance ( like optimal choice of per - flow paths ) , security ( like firewall and proxy traversal ) and packet - processing ( e.g. , through the optimized deployment of virtualized network functions ) ones .",
    "on the other hand , devices can not provide any reaction ( e.g. , to topological changes ) like in traditional networks . in turn , this comes at the risk of triggering inconsistencies , e.g. , creating traffic blackholes during an update , that are provably impossible to trigger by reconfiguring current routing protocols  @xcite . as a consequence",
    ", the controller has to carry out a network update for every event ( from failures to traffic surges and requirement modification ) that can impact the computed forwarding entries , while typically supporting more critical consistency guarantees and performance objectives than in traditional networks .",
    "an extended corpus of sdn update techniques have already been proposed in the literature , following up on the large interest raised by sdn in the last decade .",
    "this research effort nicely complements approaches to specify  @xcite , compile  @xcite , and check the implementation of  @xcite network requirements specified by operators in sdn networks .    historically speaking ,",
    "the first cornerstone of sdn updates is represented by the work by reitblatt _",
    "_ in  @xcite .",
    "this work provides a first analysis of the additional ( e.g. , security ) requirements to be considered for sdn updates , extending the scope of consistency properties from forwarding to policy ones .",
    "in particular , it focuses on per - packet consistency property , imposing that packets have to be forwarded either on their initial or on their final paths ( never a combination of the two ) , throughout the update .",
    "the technical proposal is centered around the 2-phase commit technique , which relies on tagging packets at the ingress so that either all initial rules or all final ones can be consistently applied network - wide .",
    "initially , all packets are tagged with the `` old label '' ( e.g. , no tag ) and rules matching the old label are pre - installed on all the switches . in a first step ,",
    "the controller instructs the internal switches to apply the final rule to packets carrying the `` new label '' ( i.e. , no packet at this step ) .",
    "after the internal switches have confirmed the successful installation of these new rules , the controller then changes the tagging policy at the ingress switches , requiring them to tag packets with the `` new label '' . as a result",
    ", packets are immediately forwarded along the new paths .",
    "finally , the internal switches are updated ( to remove the old rules ) , and an optional cleaning step can be applied to remove all tags from packets .",
    "[ fig : example - history-2phase - seq ] shows the operational sequence produced by the 2-phase commit technique for the update case in fig .",
    "[ fig : example - history - igp - seq ] .",
    "several works have been inspired by the 2-phase technique presented in  @xcite .",
    "on the one hand , a large set of contributions focused on additional guarantees that can be provided by building upon that technique , e.g. , to avoid congestion during sdn updates ( from  @xcite to  @xcite ) . on the other hand , several algorithms  @xcite to compute a set of ordered rule replacements have been proposed to deal with specific sdn update cases ( e.g. , where only forwarding consistency is needed ) avoid adding rules and wasting critical network resources ( i.e. , expensive and rare switch tcam memory slots ) .    in the following sections , we detail most of those contributions and the insights on different update problems that globally emerge from them .",
    "with this historic perspective and traditional network update problems and techniques in mind , we now present a general formulation of network update problem (  [ subsec : taxo - problem ] ) , which abstracts from assumptions and settings considered in different works .",
    "this formulation enables us to classify research contributions on the basis of the proposed techniques ( e.g. , simultaneous usage of multiple configurations on nodes or not ) and algorithms , independently of their application to traditional and sdn networks (  [ subsec : taxo - taxo ] ) .      in order to compare and contrast research contributions ,",
    "we first provide a generalized statement for network update problems .",
    "we use again fig .",
    "[ fig : example - history ] for illustration .    *",
    "basic problem . * generally speaking , a network update problem consists in computing a sequence of operations that changes the packet - processing rules installed on network devices .",
    "consider any communication network : it is composed by a given set of inter - connected devices , that are able to process ( e.g. , forwarding to the next hop ) data packets according to rules installed on them .",
    "we refer to the set of rules installed on all devices at a given time as network state at that time . given an initial and final state , a network update consists in passing from the initial state to the final one by applying operations ( i.e. , adding , removing or changing rules ) on different devices . in fig .",
    "[ fig : example - history ] , the initial state forces packets from source @xmath9 to destination @xmath2 along the path @xmath10 . in contrast , the final state forwards the same packets over @xmath11 , as well as packets from @xmath4 to @xmath2 on @xmath12 .",
    "the network update problem consists in replacing the initial rules with the final ones , so that the paths for @xmath2 are updated from @xmath10 to @xmath11 and @xmath12 .",
    "* operations . * to perform a network update , a sequence of operations has to be computed . by operation , we mean any modification of a device behavior in processing packets . as an example ,",
    "an intuitive and largely - supported operation on all network devices is rule replacement : instructing any device ( e.g. , @xmath4 ) to replace an initial rule ( e.g. , forward the @xmath13 packet flow to @xmath5 ) with the corresponding final one ( e.g. , forward the @xmath13 flow to @xmath2 )",
    ".    * consistency . *",
    "the difficulty in solving network update problems is that some form of consistency must be guaranteedly preserved throughout the update , for practical purposes like avoiding service disruptions and packet losses . preserving consistency properties , in turn ,",
    "depends on the order in which operations are executed by devices  even if both the initial and the final states comply with those properties .",
    "for example , if @xmath4 replaces its initial rule with its final one before @xmath5 in fig .",
    "[ fig : example - history ] , then the operational sequence triggers a forwarding loop between @xmath5 and @xmath4 that interrupts the connectivity from @xmath9 to @xmath2 . in  [ subsec : taxo - taxo ]",
    ", we provide an overview of consistency properties considered in prior work .",
    "the practical need for guaranteeing consistency has two main consequences .",
    "first , it forces network updates to be carried out incrementally , i.e. , conveniently scheduling operations over time so that the installed sequence of intermediate states is provably disruption - free .",
    "second , it requires a careful computation of operational sequences , implementing specific reasoning in the problem - solving algorithms ( e.g. , to avoid replacing @xmath4 s rule before @xmath5 s one in the previous example )",
    ".    * performance .",
    "* another algorithmic challenge consists in optimizing network - update performance . as an example , minimizing the time to complete an update is commonly considered among those optimization objectives .",
    "indeed , carrying out an update generally requires to install intermediate configurations , and in many cases it is practically desirable to minimize the time spent in such intermediate states .",
    "we provide a broader overview of performance goals considered by previous works in ",
    "[ subsec : taxo - taxo ] .    * final operational sequences . *",
    "generally , the solution for an update problem can be represented as a sequence of _ steps _ or _ rounds _ , that both guarantees consistency properties and optimizes update performance .",
    "each step is a set of operations that can be started at the same time .",
    "note that this does not mean that operations in the same step are assumed to be executed simultaneously on the respective devices .",
    "rather , all operations in the same step can be started in parallel because target consistency properties are guaranteed irrespectively of the respective order in which those operations are executed",
    ". examples of operational sequences , computed by different techniques , are reported in  [ sec : history ] ( see figs .  [",
    "fig : example - history - igp - seq ] and  [ fig : example - history - sitn - seq ] ) .      in this section ,",
    "we provide an overview of the problem space and classify existing models and techniques .",
    "previous contributions have indeed considered several variants of the generalized network update problem as we formulated in  [ subsec : taxo - problem ] .",
    "those variants differ in terms of both consistency constraints , performance goals and operations that can be used to solve an update problem",
    ".    * routing model .",
    "* we can distinguish between two alternative routing models : _ destination - based _ and _ per - flow _ routing .",
    "1 .   * destination - based routing : * in destination - based routing , routers forward packets based on the destination only . an example for destination - based routing is ip routing , where routers forward packets based on the longest common ip destination prefix . in particular , destination - based routing describes confluent paths : once two flows from different sources destined toward the same destination intersect at a certain node , the remainder ( suffix ) of their paths will be the same . in destination - based routing , routers store at most one forwarding rule per specific destination .",
    "per - flow routing : * in contrast , according to _ per - flow _ routing , routes are not necessarily confluent : the forwarding rules at the routers are defined per - flow , i.e. , they may depend not only on the destination but for example also on the source . in traditional networks ,",
    "flows and per - flow routing could for example be implemented using mpls : packets belonging to the same equivalence class resp .",
    "packets with the same mpls tag are forwarded along the same path .",
    "* operations . *",
    "techniques to carry out network updates can be classified in broad categories , depending on the operations that they consider .    1 .",
    "* rule replacements : * a first class of network update algorithms is based on partitioning the total set of updates @xmath14 to be made at the different switches into different rounds : @xmath15 , where @xmath16 for all @xmath17 $ ] and where @xmath18 denotes the set of switches which is updated in round @xmath19 .",
    "consistent node ordering update schedules have the property that the updates in each round @xmath18 may occur asynchronously , i.e. , in an arbitrary order , without violating the desired consistency properties ( e.g. , loop - freedom ) . the next batch of updates @xmath20",
    "is only issued to the switches after the successful implementation of the @xmath21 updates has been confirmed ( i.e. , acked ) by the switches .",
    "* rule additions : * a second class of network update algorithms is based on adding rules to guarantee consistency during the update .",
    "the following two main variants of this approach have been explored so far",
    ".   * 2-phase commit : * in this case , both the initial and the final rules are installed on all devices in the central steps of the updates .",
    "packet are tagged at the border of the network to enforce that the internal devices either ( i )   all use the initial rules , or ( ii )   all use the final rules .",
    "see fig .",
    "[ fig : example - history-2phase - seq ] for an example .",
    "* additional helper rules : * for the purpose of the update , additional rules may be introduced temporarily , which do not belong neither to the old path nor to the new path .",
    "these rules allow to divert the traffic temporarily to other parts of the network , and are called _",
    "helper rules_.    * consistency properties . *",
    "another canonical classification can be defined along the fundamental types of consistency properties :    1 .",
    "* connectivity consistency : * the most basic form of consistency regards the capability of the network to continuously deliver packets to their respective destinations , throughout the update process .",
    "this boils down to guaranteeing two correctness properties : absence of blackholes ( i.e. , paths including routers that can not forward the packets further ) and absence of forwarding loops ( i.e. , packets bouncing back and forth over a limited set of routers , without reaching their destinations ) .",
    "* policy consistency : * paths used to forward packets may be selected according to specific forwarding policies , for example , security ones imposing that given traffic flows must traverse specific waypoints ( firewalls , proxies , etc . ) . in many cases ,",
    "those policies have to be preserved during the update . generally speaking ,",
    "policy consistency properties impose constraints on which paths can be installed during the update ( as a consequence of the partial application of an operational sequence ) .",
    "for example , a well - studied policy consistency property , often referred to as _ strong consistency _ , requires that packets are always forwarded along either the pre - update or the post - update paths , but never a combination of the two .",
    "* performance consistency : * a third class of consistency properties takes into account actual availability and limits of network resources .",
    "for instance , many techniques account for traffic volumes and the corresponding constraints raised by the limited capacity of network links : they indeed aim at respecting such constraints in each update step , e.g. , to avoid _ transient congestion _ during updates .",
    "this classification is also reflected in the structure of this survey .    *",
    "performance goals .",
    "* we can distinguish between three broad classes of performance goals .    1 .",
    "* link - based : * a first class of consistent network update protocols aims to make new links available as soon as possible , i.e. , to maximize the number of switch rules which can be updated simultaneously without violating consistency .",
    "* round - based : * a second class of consistent network update protocols aims to minimize the number of inter - actions between the controller and the switches .",
    "* cross - flow objectives : * a third class of consistent network update protocols targets objectives arising in the presence of multiple flows . 1 .",
    "* augmentation : * minimize the extent to which link capacities are oversubscribed during the update ( or make the update entirely congestion - free ) .",
    "* touches : * minimize the number of interactions with the router .",
    "link - based and round - based objectives are usually considered for node - ordering algorithms and for weak - consistency models .",
    "congestion - based objectives are naturally considered for capacitated consistency models .",
    "[ fig : taxonomy ] gives an overview of different types of network update problems .",
    "[ t ]     +",
    "in this section , we focus on update problems where the main consistency property to be guaranteed concerns the delivery of packets to their respective destinations . packet delivery can be disrupted during an update by forwarding loops or blackholes transiently present in intermediate states .",
    "we separately discuss previous results on how to guarantee loop - free and blackhole - free network updates .",
    "we start from the problem of avoiding forwarding loops during updates , because they are historically the first update problems considered  by works on traditional networks ( see  [ sec : history ] ) .",
    "this is also motivated by the fact that blackholes can not be created by reconfiguring current routing protocols , as proved in  @xcite .",
    "we then shift our focus on avoiding blackholes during arbitrary ( e.g. , sdn ) updates .",
    "loop - freedom is a most basic consistency property and has hence been explored intensively already .",
    "we distinguish between flow - based and destination - based routing : in the former , we can focus on a single ( and arbitrary ) path from @xmath9 to @xmath2 : forwarding rules stored in the switches depend on both @xmath9 and @xmath2 , can flows can be considered independently . in the latter , switches store a single forwarding rule for a given destination :",
    "once the paths of two different sources destined to the same destination intersect , they will be forwarded along the same nodes in the rest of their route : the routes are confluent .",
    "moreover , once can distinguish between two different definitions for loop - free network updates : _ strong loop - freedom ( slf ) _ and _ relaxed loop - freedom ( rlf ) _  @xcite .",
    "slf requires that at any point in time , the forwarding rules stored at the switches should be loop - free .",
    "rlf only requires that forwarding rules stored by switches _ along the path from a source @xmath9 to a destination @xmath2 _ are loop - free : only a small number of `` old packets '' may temporarily be forwarded along loops .",
    "* node - based objective ( `` greedy approach '' ) .",
    "* mahajan and wattenhofer  @xcite initiated the study of destination - based ( strong ) loop - free network updates .",
    "in particular , the authors show that by scheduling updates across multiple rounds , consistent update schedules can be derived which do not require any packet tagging , and which allow some updated links to become available earlier .",
    "the authors also present a first algorithm that quickly updates routes in a transiently loop - free manner .",
    "the study of this model has been refined in  @xcite , where the authors also establish hardness results .",
    "in particular , the authors prove that for two destinations and for sublinear @xmath22 , it is np - hard to decide if @xmath22 rounds ( cf .  round - based objectives ) of updates suffice . furthermore , maximizing the number of rules updated for a single destination is np - hard as well , but can be approximated well .",
    "et al . _",
    "@xcite initiated the study of arbitrary route updates : routes which are not necessarily destination - based .",
    "the authors show that the update problem in this case boils down to an optimization problem on a very simple directed graph : initially , before the first update round , the graph simply consists of two connected paths , the old and the new route . in particular ,",
    "every network node which is not part of both routes can be updated trivially , and hence , there are only three types of nodes in this graph : the source @xmath9 has out - degree 2 ( and in - degree 0 ) , the destination @xmath2 has in - degree 2 ( and out - degree 0 ) , and every other node has in - degree and out - degree 2 .",
    "the authors also observe that loop - freedom can come in two flavors , strong and relaxed loop - freedom  @xcite .    despite the simple underlying graph , however , amiri _",
    "et al . _",
    "@xcite show that the node - based optimization problem is np - hard , both in the strong and the relaxed loop - free model ( slf and rlf ) . as selecting a maximum number of nodes to be updated in a given round ( i.e. , the node - based optimization objective )",
    "may also be seen as a heuristic for optimizing the number of update rounds ( i.e. , the round - based optimization objective ) , the authors refer to the node - based approach as the `` greedy approach '' .",
    "amiri _ et al . _",
    "@xcite also present polynomial - time optimal algorithms for the following scenarios : both a maximum slf update set as well as a maximum rlf update set can be computed in polynomial - time in trees with two leaves . regarding polynomial - time approximation results , the problem is 1/2-approximable in general , both for strong and relaxed loop - freedom . for additional approximation results for specific problem instances",
    ", we refer the reader to amiri _",
    "et al . _",
    "@xcite .    * round - based objective ( `` greedy approach '' ) . * ludwig _ et al . _",
    "@xcite initiate the study of consistent network update schedules which minimize the number of interaction rounds with the controller : _ how many communication rounds @xmath23 are needed to update a network in a ( transiently ) loop - free manner ? _",
    "the authors show that answering this question is difficult in the strong loop - free case .",
    "in particular , they show that while deciding whether a @xmath23-round schedule exists is trivial for @xmath24 , it is already np - complete for @xmath25 .",
    "moreover , the authors show that there exist problem instances which require @xmath26 rounds , where @xmath27 is the network size .",
    "moreover , the authors show that the greedy approach , aiming to `` greedily '' update a _ maximum _ number of nodes in each round , may result in @xmath26-round schedules in instances which actually can be solved in @xmath28 rounds ; even worse , a _ single _",
    "greedy round may inherently delay the schedule by a factor of @xmath26 more rounds .",
    "however , fast schedules exist for _ relaxed loop - freedom _ : the authors present a deterministic update scheduling algorithm which completes in @xmath29-round in the worst case .",
    "* hybrid approaches .",
    "* vissicchio _ et al . _",
    "presented flip  @xcite , which combines per - packet consistent updates with order - based rule replacements , in order to reduce memory overhead : additional rules are used only when necessary .",
    "moreover , hua _ et al . _",
    "@xcite initiated the study of adversarial settings , and presented foum , a flow - ordered update mechanism that is robust to packet - tampering and packet dropping attacks .",
    "* other objectives .",
    "* dudycz _ et al . _",
    "@xcite initiated the study of how to update multiple policies simultaneously , in a loop - free manner . in their approach , the authors aim to minimize the number of so - called _ touches _ , the number of updates sent from the controller to the switches : ideally , all the updates to be performed due the different policies can be sent to the switch in one message .",
    "the authors establish connections to the _ shortest common supersequence ( scs ) _ and _ supersequence run _",
    "problems  @xcite , and show np - hardness already for two policies , each of which can be updated in two rounds , by a reduction from _",
    "max-2sat _  @xcite .",
    "however , the authors also present optimal polynomial - time algorithms to combine consistent update schedules computed for individual policies ( e.g. , using any existing algorithm , e.g. ,  @xcite ) , into a global schedule guaranteeing a minimal number of touches .",
    "this optimal merging algorithm is not limited to loop - free updates , but applies to any consistency property : if the consistency property holds for individual policies , then it also holds in the joint schedule minimizing the number of touches .",
    "the _ shortest common supersequence ( scs ) _ and _ supersequence run _  @xcite .      the link - based optimization problem , the problem of maximizing the number of links ( or equivalently nodes ) which can be updated simultaneously , is an instance of the maximum acyclic subgraph problem ( or equivalently : dual minimum feedback arc set problem ) . for",
    "the np - hardness , reductions from _ sat _ and _ max-2sat _ are presented .",
    "loop - free network updates still pose several open problems . regarding the node - based objective , amiri _",
    "et al . _",
    "@xcite conjecture that update problems on bounded directed path - width graphs may still be solvable efficiently : none of the negative results for bounded degree graphs on graphs of bounded directed treewidth seem to be extendable to digraphs of bounded directed pathwidth with bounded degree .",
    "more generally , the question of on which graph families network update problems can be solved optimally in polynomial time in the node - based objective remains open .",
    "regarding the round - based objective , it remains an open question whether strong loop - free updates are np - hard for any @xmath30 ( but smaller than @xmath27 ) : so far only @xmath25 has been proved to be np - hard .",
    "more interestingly , it remains an open question whether the relaxed loop - free update problem is np - hard , e.g. , are 3-round update schedules np - hard to compute also in the relaxed loop - free scenario ?",
    "moreover , it is not known whether @xmath31 update rounds are really needed in the worst - case in the relaxed model , or whether the problem can always be solved in @xmath28 rounds .",
    "some brute - force computational results presented in  @xcite indicate that if it is constant , the constant must be large .",
    "remarks # rounds , strong lf & is there a 3-round loop - free update schedule ?",
    "@xcite _ for 2-destination rules and sublinear @xmath22 : is there a @xmath22-round loop - free update schedule ?",
    "@xcite _ & is there a 2-round loop - free update schedule ?",
    "@xcite & in the worst case , @xmath26 rounds may be required .",
    "@xcite_. @xmath32-round schedules always exist  _ @xcite_. both applies to flow - based & _ destination - based _",
    "rules . # rounds , relaxed lf & no results known . &",
    "@xmath29-round update schedules always exist .",
    "@xcite & it is not known whether @xmath33-round schedules exist ( in the worst case ) .",
    "no approximation algorithms are known .",
    "# links , strong lf & is it possible to update @xmath22 nodes in a loop - free manner ?",
    "@xcite _ & polynomial - time optimal algorithms are known to exist in the following cases : a maximum slf update set can be computed in polynomial - time in trees with two leaves .",
    "@xcite & the optimal slf schedule is 2/3-approximable in polynomial time in scenarios with exactly three leaves . for scenarios with four leaves , there exists a polynomial - time 7/12-approximation algorithm .",
    "@xcite approximation algorithms from maximum acyclic subgraph  @xcite and minimum feedback arc set  _",
    "@xcite _ apply .",
    "# links , relaxed lf & is it possible to update @xmath22 nodes in a loop - free manner ?",
    "@xcite & polynomial - time optimal algorithms are known to exist in the following cases : a maximum rlf update set can be computed in polynomial - time in trees with two leaves .",
    "@xcite & no approximation results known .",
    "@xcite      another consistency property is blackhole freedom , i.e. , a switch should always have a matching rule for any incoming packet , even when rules are updated ( e.g. , removed and replaced ) .",
    "this property is easy to guarantee by implementing some default matching rule which is never updated , which however could in turn induce forwarding loops . a straightforward mechanism ,",
    "if there is currently no blackhole for any destination , is to install new rules with a higher priority , and then delete the old rules  @xcite .",
    "nonetheless , in the presence of memory limits and guaranteeing loop - freedom , finding the fastest blackhole - free update schedule is np - hard  @xcite .",
    "while connectivity invariants are arguably the most intensively studied consistency properties in the literature , especially in traditional networks , operators often have additional requirements to be preserved .",
    "for example , operators want to ensure that packets traverse a given middlebox ( e.g. , a firewall ) for security reasons or a chain of middleboxes ( e.g. , encoder and decoder ) for performance reasons , or that paths comply with service level agreements ( e.g. , in terms of guaranteed delay ) . in this section",
    ", we discuss studied problems and proposed techniques aiming at preserving such additional requirements .      additional requirements on forwarding paths that may have to be respected during a network update can be modeled by _ routing policies _ , that is , sub - paths that have to be traversed by transient paths installed during network updates .    over the years",
    ", several contributions have targeted policy - preserving updates , typically focusing on specific policies .",
    "historically , the first policy considered during network updates is _ per - packet consistency ( ppc ) _ , which ensures that every packet travels either on its initial or on its final paths , never on intermediate ones .",
    "this property is the most natural to ( try to ) preserve .",
    "assume indeed that both the initial and the final paths comply with high - level network requirements , e.g. , security , performance , sla policies . the most straightforward way to guarantee that those requirements are not violated is to constrain all paths installed during the update to always be either initial paths or final ones .",
    "nonetheless , guaranteeing per - packet consistency may be an unnecessarily strong requirement in practice .",
    "not always it is strictly needed that transient paths must coincide with either the initial or the final ones .",
    "for example , in some cases ( e.g. , for enterprise networks ) , security may be a major concern , and many security requirements may be enforced by guaranteeing that packets traverse a firewall .",
    "we refer to this specific case where single nodes ( waypoints ) have to be traversed by given traffic flows as _ waypoint enforcement ( wpe)_. an example wpe - consistent update is displayed in fig .",
    "[ fig : example - wpe ]    more complex policies ( i.e. , beyond wpe ) may also be needed in general .",
    "indeed , policies to be satisfied in sdn networks tend to grow in number and complexity over time , because of both new requirements ( e.g. , as dictated by use cases like virtualized infrastructure and network functions ) and novel opportunities ( e.g. , programmability and flexibility ) opened by sdn . for example , it may desirable that specific traffic flows follow certain sub - paths ( e.g. , with low delay for video streaming and online gaming applications ) or are explitictly denied to pass through other sub - paths ( e.g. , because of political or economical constraints ) .",
    "such _ arbitrary policies _ are also considered in recent sdn update works .",
    "* 2-phase commit techniques . * as described in ",
    "[ subsec : taxo - taxo ] , 2-phase commit techniques deploy carry out updates by ( 1 ) tagging packets at their ingress in the network , and ( 2 ) using packet tags to use initial or final paths consistently network - wide .",
    "unsurprisingly , this approach guarantees per - packet consistency ( hence , potentially any policy satisfied by both pre- and post - update paths ) .",
    "while the idea is quite intuitive , some support is needed on the devices , e.g. , to tag packets and match packet tags . a framework to implement this update approach in traditional networks",
    "has been proposed by alimi _",
    "_ in  @xcite .",
    "it requires invasive modification of router internals , to manage tags and run arbitrary routing processes in separate process spaces .",
    "the counterpart of such a framework for sdn networks is presented in  @xcite . those works",
    "avoid the need for changing device internals since it relies on openflow , the protocol classically used in sdn networks .",
    "they also argue on the criticality of supporting ppc in the sdn case and the advantages of integrating 2-phase commit techniques within an sdn controller .",
    "a major downside of 2-phase commit is that it doubles the consumed memory on switches , along with requiring header space , tagging overhead , and complications with middleboxes changing tags .",
    "it indeed requires devices to maintain both the initial and final sets of forwarding rules throughout the update , in order to possibly apply any of the two sets according to packet tags . to mitigate this problem ,",
    "a variant of the basic approach has been studied in  @xcite .",
    "the authors of the latter work proposed to break a given update into several sub - updates , such that each sub - update changes the paths for a different set of flows . of course",
    ", this approach would make it longer for the full update to be completed .",
    "in other words , it can limit the memory overhead on each switch at any moment in time but at the price of slowing down the update .",
    "actually , the switch - memory consumption of 2-phase commit techniques remains a fundamental limitation of the approach , which also motivated the exploration of alternatives .",
    "* sdn - based update protocols .",
    "* mcgeer  @xcite presented two protocols to carry out network updates and defined on top of openflow .",
    "the first update protocol  @xcite saves switch resources by sending packets to the controller during updates . as a result ,",
    "switch resources ( like precious tcam entries ) are saved , at the cost of adding delay on packet delivery , and consuming network bandwidth and controller memory .",
    "the second update protocol  @xcite is based on a logic circuit for the update sequence which requires neither rule - space overhead nor transferring the packets to the shelter during the update .",
    "both proposals need a dedicated protocol which is not currently supported by devices out of the box .    * rule replacement ordering . *",
    "some works explored which policies can be supported , and how , by only relying on ( ordered ) rule replacements , given that this both ( i )  comes with no memory overhead and ( ii )   is supported by both traditional and sdn devices .",
    "some works noticed that ppc can be an unnecessarily strong requirements in several practical cases .",
    "initial contributions mainly focused on wpe consistency , e.g. , to preserve security policies .",
    "prominently ,  @xcite studies how to compute quick updates that preserve wpe by only replacing initial with final rules , when any given flow has to traverse a single waypoint .",
    "the authors propose wayup , an algorithm that guarantees wpe during the update and terminates in 4 rounds .",
    "however , they also show that it may not be possible to ensure waypointing through a single node and loop - freedom at the same time .",
    "[ fig : example - wpe ] actually shows one case in which any rule replacement ordering either causes a loop or a wpe consistency violation .",
    "those infeasibility results are extended to waypoint chains in  @xcite . in that work , in particular , the authors show that flexibility in ordering and placing virtualized functions specified by a chain do not make the update problem always solvable .",
    "the two works also show that it is computationally hard ( np - hard ) to even decide if an ordering preserving both wpe and loop - freedom exists .",
    "mixed integer program formulations to find an operational are proposed and evaluated in both cases .",
    "the more general problem of preserving policies defined by operators is tackled in  @xcite .",
    "that paper describes an approach to ( i )   model update - consistency properties as linear temporal logical formulas , and ( ii )   automatically synthesize sdn updates that preserve input properties .",
    "such a synthesis is performed by an efficient algorithm based on counterexample - guided search and incremental model checking .",
    "experimental evidence is provided about the scalability of the algorithm ( up to one - thousand node networks ) .",
    "finally ,  @xcite explores algorithmic limitations of guaranteeing per - packet consistency without relying on state duplication .",
    "the work shows that a greedy strategy implements a correct and complete approach in this case , meaning that it finds the maximal sequence of rule replacements that do not violate ppc .",
    "et al . _",
    "@xcite complement those findings , by presenting a polynomial - time synthesis algorithm that preserves ppc while allowing the maximal parallelism between per - switch updates .",
    "also , an evaluation on realistic update cases is presented in  @xcite .",
    "it shows that ppc can be preserved while replacing many forwarding entries on the majority of the switches , despite updates can rarely be completed this way .",
    "however , this observation motivates both approaches tailored to a more restricted family of policies ( like wpe - preserving ones , described above ) , and efforts for mixed approaches ( mixing rule replacements and duplication , see below )",
    ".    * mixed approaches . * in  @xcite ,",
    "a basic mixed approach is considered to ensure ppc in generalized networks running both traditional and sdn control - planes ( or any of the two ) .",
    "this approach consists in first computing the maximal sequence of rule replacements that preserve ppc , and then applying a restricted 2-phase commit procedure on a subset of ( non - ordered ) devices and flows .",
    "vissicchio _ et al . _",
    "@xcite propose an algorithm addressing a larger set of update problems with a more general algorithmic approach , but restricting to sdn networks .",
    "this work focuses on the problem of preserving generic policies during sdn updates . for each flow",
    ", a policy is indeed defined as a set of paths so that the flow must traverse any of those paths in each intermediate state .",
    "the proposed algorithm interleaves rule replacements and additions ( i.e. , packet tagging and tag matching ) in the returned operational sequences and during its computation  rather than considering the two primitives in subsequent steps as in  @xcite .",
    "both works argue that it is practically profitable to combine rule replacements and additions , as it greatly reduces the amount of memory overhead while keeping the operational sequence always computable .",
    "many policy - preserving algorithms face generalized versions of the optimization problems associated to connectivity - preserving updates ( see  [ sec : forwarding ] ) : while the most common objective remains the maximization of parallel operations ( to speed - up the update ) , policy consistency requires that all possible intermediate paths comply with certain regular expressions in addition to being simple ( that is , loop - free ) paths .",
    "mixed policy - preserving approaches focus on even more general problems where ( i )   different operations can be interleaved in the output operational sequence ( which provides more degrees of freedom in solving the input problems ) , and ( ii )   multiple optimization objectives are considered at the same time ( typically , maximizing the update parallelism while also minimizing the consumed switch memory ) .      unsurprisingly , preserving policies requires more sophisticated update techniques , since it is generally harder to extract policy - induced constraints and model the search space .",
    "two major families of solutions have been explored so far . on the one hand ,",
    "2-phase commit techniques and update protocols sidestep the algorithmic challenges , at the cost of relying on specific primitives ( packet tagging and tag matching ) that comes with switch memory consumption . on the other hand",
    ", ordering - based techniques directly deal with problem complexities , at the cost of algorithmic simplicity and impossibility to always solve update problems . finding the best balance between those two extremes is an interesting research direction .",
    "some initial work has started in this direction , with the proposal of algorithms that can interleave different kinds of operations within the computed sequence ( see mixed approaches in  [ subsec : policies - algo ] ) .",
    "however , many research questions are left open .",
    "for example , the computational complexity of solving update problems while mixing rule additions ( for packet tagging and matching ) with replacements is unknown .",
    "moreover , it is unclear whether the proposed algorithms can be improved exploiting the structure of specific topologies or the flexibility of new devices ( e.g. , p4-compatible ones  @xcite ) , e.g. , to achieve better trade - offs between memory consumption and update speed .",
    "computer networks are inherently capacitated , and respecting resource constraints is hence another important aspect of consistent network updates .",
    "congestion is known to significantly impact throughput and increase latency , therefore negatively impacting user experience and even leading to unpredictable economic loss .",
    "the capacitated update problem is to migrate from a multi - commodity flow @xmath34 to another multi - commodity flow @xmath35 , where consistency is defined as not violating any link capacities and not rate - limiting any flow below its demand in @xmath36 . in few works , e.g. ,",
    "@xcite , @xmath35 is only implicitly specified by its demands , but not by the actual flow paths .",
    "some migration algorithms will violate consistency properties to guarantee completion , as a consistent migration does not have to exist in all cases .",
    "typically , four different variants are studied in the literature : first , individual flows may either only take one path ( unsplittable ) or they may follow classical flow - theory , where the incoming flow at a switch must equal its outgoing flow ( splittable ) . secondly , flows can take any paths via helper rules in the network during the migration ( intermediate paths ) , or may only be routed along the old or the new paths ( no intermediate paths ) .    to exactly pinpoint congestion - freedom , one would need to take many detailed properties into account , e.g. , buffer sizes and asic computation times .",
    "as such , the standard consistency model does not take this fine - grained approach , but rather aims at avoiding ongoing bandwidth violations and takes a mathematical flow - theory point of view",
    ". introduced by  @xcite , consistent flow migration is captured in the following model : no matter if a flow is using the rules before the update or after the update , the sum of all flow sizes must be at most the links capacity .",
    "current algorithms for capacitated updates of network flows use the seminal work by reitblatt _",
    "et al . _",
    "@xcite as an update mechanism .",
    "analogously to _ per - packet consistency _",
    "[ sec : policies ] ) , one can achieve _ per - flow consistency _ by a 2-phase commit protocol . while this technique avoids many congestion problems ,",
    "is not sufficient for bandwidth guarantees : when updating the two flows in fig .",
    "[ fig : move up ] , the lower green flow could move up before orange flow is on its new path , leading to congestion .",
    "an overview over all algorithmic approaches discussed here can be found in table  [ flow - algo - table ] .",
    "mizrahi _ et al . _",
    "@xcite prove that flow swapping is necessary for throughput optimization in the general case , as thus algorithms are needed that do not violate any capacity contraints during the network update , beyond simple flow swapping as well .    the seminal work by hong _",
    "et al . _",
    "@xcite on _ swan _ introduces the current standard model for capacitated updates .",
    "their algorithmic contribution is two - fold , and also forms the basis for  _ zupdate _",
    "@xcite : first , the authors show that if all flow links have free capacity _ slack _",
    "@xmath9 , consistent migration is possible using @xmath37 updates : e.g. , if the free capacity is 10% , 9 updates are required , always moving 10% of the links capacity to the new flow paths .",
    "if the network contains non - critical background traffic , free capacity can be generated for a migration by rate - limiting this background traffic temporarily , cf .",
    "[ fig : move up - swan ] : removing some background traffic allows for consistent migration .",
    "second , the authors provide an lp - formulation for splittable flows which provides a consistent migration schedule with @xmath22 updates , if one exists . by performing a binary search over the number of updates ,",
    "the number of necessary updates can be minimized .",
    "this approach allows for intermediate paths , where the flows can be re - routed anywhere in the network .",
    "e.g. , consider the example in fig .",
    "[ fig : move up - swan ] with all flows and links having unit size .",
    "if there was an additional third route to @xmath2 , the orange flow could temporarily use this intermediate path : we can then switch the green flow , and eventually the orange flow could be moved to its desired new path .",
    "this second lp - formulation was extended by zheng _",
    "et al . _",
    "@xcite to include unsplittable flows as well via a mip .",
    "furthermore , using randomized rounding with an lp , zheng _ et al . _  can approximate the minimum congestion that will occur if the migration has to be performed using @xmath22 updates .",
    "should intermediate paths be allowed however , then their lp is of exponential size .",
    "et al . _",
    "@xcite also consider the tradeoff between reconfiguration effects and update speed in the context of dynamic flow arrivals .",
    "in terms of tradeoffs , luo _",
    "et al . _",
    "@xcite allow for user - specified deadlines ( e.g. , a flow has to be updated until some time @xmath19 ) via an mip or an lp - based heuristic .    the work by brandt _ et al . _",
    "@xcite tackles the problem of deciding in polynomial time if consistent migration is possible at all for splittable flows with intermediate paths allowed . by iteratively checking for augmenting flows that create free capacity ( slack ) on fully - capacitated links , it is possible to decide in polynomial time if slack can be obtained on all flow links .",
    "if yes , then the first technique of  @xcite can be used , else no consistent migration is possible .",
    "should the output be no , they also provide an lp - formulation to check to which demands it is possible to migrate consistently .",
    "jain _ et al . _",
    "@xcite also consider the variable update times of switches in the network .",
    "for both splittable and unsplittable flows without intermediate paths , they build a dependency graph for the update problem .",
    "then , this dependency graph is traversed in a greedy fashion , updating whatever flows are currently possible .",
    "e.g. , in fig .",
    "[ fig : move up ] , the orange flow would be moved first , then the green flow next .",
    "should this traversal result in a deadlock , flows are rate - limited to guarantee progress .",
    "et al . _",
    "@xcite improve the local dependency resolving to improve the greedy traversal .",
    "et al . _",
    "@xcite provide a mip - formulation of the problem , and also provide a heuristic framework using tiny mips .",
    "foerster and wattenhofer  @xcite consider an alternative approach to migrating unsplittable flows without intermediate paths : they split each flow along its old and new path , changing the size allocations during the updates , until the migration is complete .",
    "their algorithm has polynomial computation time , but has slightly stronger consistency requirements than the model of  @xcite .",
    "lastly , brandt _ et al . _",
    "@xcite consider a modified migration problem by not fixing the new multi - commodity flow , but just its demands .",
    "if the final ( and every intermediate ) configuration has no congestion then the locations of the flows in the network do not matter . in scenarios with a single destination ( or a single source ) , augmenting flows can be used to compute the individual updates : essentially , the flows are changed along the routes of the augmenting flows , allowing for a linear number of updates for splittable flows with intermediate paths .",
    "the augmentation model can not be extended to the general case of multi - source multi - destination network flows .",
    "the complexity of capacitated updates can roughly be summarized as follows : problems involving splittable flows can be decided in polynomial time , while restrictions such as unsplittable flows or memory limits turn the problem np - hard , see table  [ hardness results - table ] . in a way , the capacitated update problems differs from related network update problems in that it is not always solvable in a consistent way . on the other hand ,",
    "e.g. , per - packet / flow consistency can always be maintained by a 2-phase commit , and loop - free updates for a single destination can always be performed in a linear number of updates .",
    "one standard approach in recent work for flow migration is linear ( splittable flows ) or integer programing ( unsplittable flows ) : with the number of intermediate configurations @xmath22 as an input , it is checked if a consistent migration with @xmath22 intermediate states exists .",
    "should the answer be yes , then one can use a binary search over @xmath22 to find the fastest schedule .",
    "this idea originated in _ swan _",
    "@xcite for splittable flows , and was later extended to other models , cf .  table  [ flow - algo - table ] .    however , the lp - approach via binary search ( likewise for the integer one ) suffers from the drawback that it is only complete if the model is restricted : if @xmath22 is unbounded , then one can only decide whether a migration with @xmath22 updates exists , but not whether there is no migration schedule with @xmath38 steps , for some @xmath39 .",
    "additionally , it is not even clear to what complexity class the general capacitated update problem belongs to , cf .",
    "the decision problem hardness column of table  [ hardness results - table ] .",
    "the only exception arises in case of splittable flows without memory restrictions , where either an ( implicit ) schedule or a certificate that no consistent migration is possible , is found in polynomial time  @xcite .",
    "the authors use a combinatorial approach not relying on linear programming . adding memory restrictions turns this problem np - hard as well  @xcite .    if the model is restricted to allow every flow only to be moved once ( from the old path to the new path ) , then the capacitated update problem becomes np - complete  @xcite : essentially , as the number of updates is limited by the number of flows , the problem is in np . in this specific case , one can also approximate the minimum congestion for unsplittable flows in polynomial time by randomized rounding  @xcite",
    ".    hardly any ( in-)approximability results exist today , and most work relies on reductions from the partition problem , cf .",
    "table  [ flow - hardness - table ] .",
    "the only result that we are aware of is via a reduction from max 3-sat , which also applies to unit size flows  @xcite .      in a practical",
    "setting , splitting flows is often realized via deploying multiple unsplittable paths , which is an np - hard optimization problem as well , both for minimizing the number of paths and for maximizing @xmath23-splittable flows , cf .",
    "another popular option is to split the flows at the routers using hash functions ; other major techniques are flow(let ) caches and round - robin splitting , cf .",
    "nonetheless , splitting flows along multiple paths can lead to packet reordering problems , which need to be handled by further techniques , see , e.g. ,  @xcite .",
    "many of the discussed flow migration works rely on linear programming formulations : even though their runtime is polynomial in theory , the timely migration of large networks with many intermediate states is currently problematic in practice  @xcite . if the solution takes too long to compute ,",
    "the to - be solved problem might no longer exist , a problem only made worse when when resorting to ( np - hard ) integer programming for unsplittable flows . as such",
    ", some tradeoff has to be made between finding an optimal solution and one that can actually be deployed .",
    "orthogonal to the problem of consistent flow migration is the approach of scheduling flows beforehand , not changing their path assignments in the network during the update .",
    "we refer to the recent works by kandula _",
    "et al . _",
    "@xcite and perry _ et al . _",
    "@xcite for examples .",
    "game - theoretic approaches have also been considered , e.g. ,  @xcite .",
    "lastly , the application of model checking to consistent network updates does not cover bandwidth problem restrictions yet  @xcite .",
    "the classification of the complexity of flow migration still poses many questions , cf .",
    "table  [ flow - hardness - table ] : if every flow can only be moved once , then the migration ( decision ) problem is clearly in np .",
    "however , what is the decision complexity if flows can be moved arbitrarily often , especially with intermediate paths ? is the `` longest '' fastest update schedule for unsplittable flows : linear , polynomial or exponential , or even worse ?",
    "related questions are also open for flows of unit or integer size in general .",
    "the problem of migrating splittable flows without memory limits and without intermediate paths is still not studied either : it seems as if the methods of  @xcite and  @xcite also apply to this case , but a formal proof is missing .",
    "approach & ( un-)splittable model & intermediate paths & computation & # updates & complete ( decides if consistent migration exists ) @xcite & install old and new rules , then switch from old to new & both , move each flow only once & no & polynomial & 1 & no bandwidth guarantees @xcite & partial moves according to free slack capacity @xmath9 & splittable & no & polynomial & @xmath37 & requires slack on flow links +  @xcite & greedy traversal of dependency graph & both , move each flow only once & no & polynomial & linear & no ( rate - limit flows to guarantee completion ) + @xcite & mip of  @xcite & both , move each flow only once & no & exponential & linear & yes +    @xcite & & both & no & polynomial & any @xmath40 & & & & yes & _ exponential _ & & & & & & & & @xcite & ... via mip & both & both & _ exponential _ & any @xmath40 & for any given @xmath22 yes , but can not decide in general +  @xcite & binary search of intermediate states via lp & splittable & yes & polynomial in # of updates & unbounded & can not decide if migration possible +    @xcite & create slack with intermediate states , then use partial moves of  @xcite & splittable & yes & polynomial & unbounded & yes    @xcite & split unsplittable flows along old and new paths & 2-splittable & no & polynomial & unbounded & yes + @xcite & use augmenting flows to find updates & splittable , 1 dest . ,",
    "paths not fixed & yes & polynomial & linear & yes +  @xcite &  @xcite &  @xcite &  @xcite &     memory restrictions & decision problem hardness & & yes &    & & no & & & yes & & & no &    & & yes &    & & no & & & yes & & & no &    & & yes & np - hard  @xcite    & & no & p  @xcite & & yes & np - hard  @xcite & & no & open    & & yes &    & & no & & & yes & np - complete  @xcite & & no & np - complete  @xcite     via & ( un-)splittable model & intermediate paths & memory limits & decision problem in general & optimization problems / remarks  @xcite & partition & splittable & no & yes & np - hard & np - complete if every flow may only move once +  @xcite & partition & splittable & no & no &  & np - hard ( fewest rule modifications ) +  @xcite &  & splittable & yes & no & p & fastest schedule can be of unbounded length , lp for new reachable demands if can not migrate +  @xcite &  & 2-splittable & no & no & p & studies slightly different model +  @xcite & ( max ) 3-sat & unsplittable & yes & no & np - hard ( also for unit size flows ) & np - hard to approx .",
    "additive error of flow removal for consistency better than @xmath41 +  @xcite & partition & unsplittable & yes & no & no &  & np - hard ( fastest schedule ) +  @xcite & partition & unsplittable & no & no & np - hard & stronger consistency model , but proof carries over +  @xcite & part . & subset sum & unsplittable & no & no &  & np - hard ( does a 3-update schedule exist ? ) +",
    "so far we studied network updates from the viewpoint that consistency in the respective model must be maintained , e.g. , no forwarding loops should appear at any time . in situations where the computation is no longer tractable or the consistency property",
    "can not be maintained at all , some of the discussed works opted to break consistency in a controlled manner .",
    "an orthogonal approach is to relax the consistency safety guarantees , and try to minimize the time the network is in an inconsistent state , with underlying protocols being able to correct the induced problems ( e.g. , dropped packets are re - transmitted ) , as done in a production environment in google _ b4 _  @xcite .",
    "one idea mainly investigated by mizrahi",
    "_ et al . _",
    "@xcite is to synchronize the clocks in the switches s.t .",
    "network updates can be performed simultaneously : with perfect clock synchronization and switch execution behavior , at least in theory , e.g. , loop freedom could be maintained . as the standard network time protocol ( ntp ) does not have sufficient synchronization behavior , the precision time protocol ( ptp )",
    "was adapted to sdn environments in  @xcite , achieving microsecond accuracy in experiments . however , even if the time is synchronized well enough , there will be unpredictable variations of command execution time from network switches  @xcite , motivating the need for prediction - based scheduling methods  @xcite .",
    "even worse , if a switch fails to update at all , the network can stay in an inconsistent state until the controller is notified , then either rolling back the update on the other switches or computing another update .",
    "additionally , ongoing message overhead for time synchronization is required in the whole network , and controller - to - switch messages can be delayed / lost .",
    "in contrast , at the expense of additional updates , sequential approaches can verify the application of sent network updates one by one , possibly moving forward ( to the next update ) or back ( if a command is not received or not yet applied ) with no risk of incurring ongoing safety violations .",
    "nonetheless , in some situations synchronized updates can be considered optimal : e.g. , consider the case in fig .",
    "[ fig : move up - swan ] where two unsplittable flows need to be swapped  @xcite , with no alternative paths in the network available for the final links",
    ". then , synchronizing the new flow paths can minimize the induced congestion  @xcite .",
    "still , timed updates can not guarantee packet consistency on their own , as packets that are currently on - route will encounter changed forwarding rules at the next switch . in  @xcite some additional methods",
    "are discussed how to still guarantee packet consistency by , e.g. , temporarily storing traffic at the switches .",
    "time can be used similarly to a 2-phase commit though , by analogously using timestamps in the packet header as tags during the update  @xcite , with  @xcite also showing an efficient implementation using timestamp - based tcam ranges .",
    "additional memory , as in the 2-phase commit approach of reitblatt _ et al . _",
    "@xcite , will be used for this method , but packets only need to be tagged implicitly by including the timestamp ( where often 1 bit suffices  @xcite ) .",
    "as a complement to the previously - described theoretical and algorithmic results , we now provide an overview on practical challenges to ensure consistent network updates .",
    "we also describe how previous works tackled those challenges in order to build automated systems that can automatically carry out consistent updates .    1 .",
    "* ensuring basic communication with network devices : * automated update systems classically rely on a logically - centralized coordinator , which must interact with network devices to both instruct them to apply operations ( in a given order ) .",
    "such a device - coordinator interaction requires a communication channel .",
    "update coordinators in traditional networks typically exploit the command line interface of devices  @xcite . in sdn networks ,",
    "the interaction is simplified by their very architecture , since the coordinator is typically embodied by the sdn controller which must be already able to program ( e.g. , through openflow  @xcite or similar protocols ) and monitor ( e.g. , thanks to a network information base  @xcite ) the controlled devices .",
    "2 .   * applying operational sequences , step by step : * both devices and the device - coordinator communication are not necessarily reliable .",
    "for example , messages sent by the coordinator may be lost or not be applied by all devices upon reception  @xcite .",
    "those possibilities are typically taken into account in the computation of the update sequence ( see  [ sec : taxo ] ) .",
    "however , an effective update system must also ensure that operations are actually applied as in the computed sequences , e.g. , before sending operations in the next update step . to this end",
    ", a variety of strategies are applied in the literature , from dedicated monitoring approaches ( based on available network primitives like status - checking commands and protocols  @xcite or lower - level packet cloning mechanisms  @xcite ) of traditional networks to acknowledgement - based protocols implemented by sdn devices  @xcite .",
    "3 .   * working around device limitations : * applying carefully - computed operational sequences ensures update consistency but not necessarily performance ( e.g. , speed ) , as the latter also depends on device efficiency in executing operations .",
    "this aspect has been analyzed by several works , especially focused on sdn updates which are more likely to be applied in real - time ( e.g. , even to react to a failure ) .",
    "it has been pointed out that sdn device limitations impact update performance in two ways .",
    "first , sdn switches are not yet fast to change their packet - processing rules , as highlighted by several measurement studies .",
    "for example , in the devoflow  @xcite paper , the authors showed that the rate of statistics gathering is limited by the size of the flow table and is negatively impacted by the flow setup rate . in 2015 , he _",
    "et al . _",
    "@xcite experimentally demonstrated the high rule installation latency of four different types of production sdn switches .",
    "this confirmed the results of independent studies  @xcite providing a more in - depth look into switch performance across various vendors .",
    "second , rule installation time can highly vary over time , independently on any switch , because it is a function of runtime factors like already - installed rules and data - plane load .",
    "the measurement campaign on real openflow switches performed in dionysus  @xcite indeed shows that rule installation delay can vary from seconds to minutes .",
    "update systems are therefore engineered to mitigate the impact of those limitations  despite not avoiding per - rule update bottlenecks .",
    "prominently , dionysus  @xcite significantly reduces multi - switch update latency by carefully scheduling operations according to dynamic switch conditions .",
    "covisor  @xcite and  @xcite minimize the number of rule updates sent to switches through eliminating redundant updates .",
    "* avoiding conflicts between multiple control - planes : * for availability , performance , and robustness , network control - planes are often physically - distributed , even when logically centralized as in the cases of replicated sdn controllers or loosely sdn controller applications . for updates of traditional networks ,",
    "the control - plane distribution is straightforwardly taken into account , since it is encompassed in the update problem definition ( see  [ sec : history ] ) .",
    "in contrast , additional care must be applied to sdn networks with multiple controllers : if several controllers try to update network devices at the same time , one controller may override rules installed by another , impacting the correctness of the update ( both during and after the update itself ) .",
    "this requires to solve potential conflicts between controllers , either by pro - actively specifying how the final rules have to computed ( e.g. ,  @xcite ) or by reactively detecting and possibly resolving conflicts ( e.g. ,  @xcite ) .",
    "a generalization of the above setting consists in considering multiple control - planes that may be either all distributed , all centralized , or mixed ( some distributed and some centralized ) .",
    "potential conflicts and general meta - algorithms to ensure consistent updates in those cases are described in  @xcite .",
    "* updating the control - plane : * in traditional networks , data - plane changes can only be enforced by changing the configuration of control - plane protocols ( e.g. , igps ) .",
    "in contrast , the most studied case for sdn updates considers an unmodified controller that has to change the packet - processing rules on network switches .",
    "nevertheless , a few works also considered the problem of entirely replacing the sdn controller itself , e.g. , upgrading it to a new version or replacing the old controller with a newer one .",
    "prominently , hotswap  @xcite describes an architecture that enable the replacement of an old controller with a new one , by relying on a hypervisor that maintains a history of network events . as an alternative ,",
    "explicit state transfer is used to design and implement the morpheus controller platform in  @xcite .",
    "dealing with events occurring during an update : * operational sequences computed by network update algorithms forcedly assume stable conditions . in practice , however , unpredictable concurrent events like failures can modify the underlying network independently from the operations performed to update the network .",
    "while concurrent events can be very unlikely ( especially for fast updates ) , by definition they can not be prevented .",
    "a few contributions assessed the impact of such unpredictable events on the update safety . for instance , the impact of link failures on sitn - based igp reconfigurations is experimentally evaluated in  @xcite .",
    "another example is represented by the recent foum work  @xcite , that aims at guaranteeing per - packet consistency in the presence of an adversary able to perform packet - tampering and packet - dropping attacks .",
    "while we have already identified specific open research questions in the corresponding sections , we now discuss more general areas which we believe deserve more attention by the research community in the future .    1 .",
    "* charting the complexity landscape : * researchers have only started to understand the computational complexities underlying the network update problem .",
    "in particular , many np - hardness results have been derived for general problem formulations for all three of our consistency models : connectivity consistency , policy consistency , and performance consistency .",
    "so far , only for a small number of specific models polynomial - time optimal algorithms are known .",
    "even less is known about approximation algorithms .",
    "accordingly , much research is required to chart a clearer picture of the complexity landscape of network update problems .",
    "we expect that some of these insights will also have interesting implications on classic optimization problems",
    "* refining our models : * while we believe that today s network models capture well the fundamental constraints and tradeoffs in consistent network update problems , these models are still relatively simple . in partiular",
    ", we believe that there is room and potential for developing more refined models .",
    "such models could for example account for additional performance aspects ( e.g. , the impact of packet reorderings on throughput ) .",
    "moreover , they could e.g. , better leverage predictable aspects and models , e.g. , empirical knowledge of the network behavior .",
    "for example , the channel between sdn controller and openflow switches may not be completely asynchronous , but it is reasonable to make assumptions on the upper and lower bound of switch update times .",
    "* considering new update problems : * we expect future update techniques to ensure consistency of higher - level network requirements ( like nfv , path delay , etc . ) , the same way as recent sdn controllers are supporting them .",
    "dealing with distributed control planes : * we believe that researchers have only started to understand the design and implication of more distributed sdn control planes .",
    "in particular , while for dependability and performance purposes , future sdn control planes are likely to be distributed , this also introduces additional challenges in terms of consistent network updates and controller coordination .",
    "the purpose of this survey was to provide researchers active in or interested in the field of network update problems with an overview of the state - of - the - art , including models , techniques , impossibility results as well as practical challenges .",
    "we also presented a historical perspective and discussed the fundamental new challenges introduced in software - defined networks , also relating them to classic graph - theoretic optimization problems .",
    "finally , we have identified open questions for future research .",
    "p.  bosshart , d.  daly , g.  gibb , m.  izzard , n.  mckeown , j.  rexford , c.  schlesinger , d.  talayco , a.  vahdat , g.  varghese , and d.  walker .",
    "p4 : programming protocol - independent packet processors . ,",
    "44(3):8795 , july 2014 .",
    "f.  clad , p.  merindol , j .- j .",
    "pansiot , p.  francois , and o.  bonaventure .",
    "graceful convergence in link - state ip networks : a lightweight algorithm ensuring minimal operational impact .",
    ", 22(1):300312 , february 2014 .",
    "t.  koponen , m.  casado , n.  gude , j.  stribling , l.  poutievski , m.  zhu , r.  ramanathan , y.  iwata , h.  inoue , t.  hama , and s.  shenker .",
    "onix : a distributed control platform for large - scale production networks . in _ proc .",
    "usenix osdi _ , 2010 ."
  ],
  "abstract_text": [
    "<S> computer networks have become a critical infrastructure . </S>",
    "<S> designing dependable computer networks however is challenging , as such networks should not only meet strict requirements in terms of correctness , availability , and performance , but they should also be flexible enough to support fast updates , e.g. , due to a change in the security policy , an increasing traffic demand , or a failure . the advent of software - defined networks ( sdns ) promises to provide such flexiblities , allowing to update networks in a fine - grained manner , also enabling a more online traffic engineering .    in this paper , we present a structured survey of mechansims and protocols to update computer networks in a fast and consistent manner . in particular , we identify and discuss the different desirable update consistency properties a network should provide , the algorithmic techniques which are needed to meet these consistency properties , their implications on the speed and costs at which updates can be performed . </S>",
    "<S> we also discuss the relationship of consistent network update problems to classic algorithmic optimization problems . </S>",
    "<S> while our survey is mainly motivated by the advent of software - defined networks ( sdns ) , the fundamental underlying problems are not new , and we also provide a historical perspective of the subject .    /`null </S>",
    "<S> `    copyrightspace </S>"
  ]
}