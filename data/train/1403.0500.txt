{
  "article_text": [
    "he scale of resources and computations required for executing large - scale biological jobs are significantly increasing @xcite . with this increase",
    "the resultant number of failures while running these jobs will also increase and the time between failures will decrease @xcite .",
    "it is not desirable to have to restart a job from the beginning if it has been executing for hours or days or months @xcite .",
    "a key challenge in maintaining the seamless ( or near seamless ) execution of such jobs in the event of failures is addressed under research in fault tolerance @xcite .",
    "many jobs rely on fault tolerant approaches that are implemented in the middleware supporting the job ( for example @xcite ) .",
    "the conventional fault tolerant mechanism supported by the middleware is checkpointing @xcite , which involves the periodic recording of intermediate states of execution of a job to which execution can be returned if a fault occurs .",
    "such traditional fault tolerant mechanisms , however , are challenged by drawbacks such as single point failures @xcite , lack of scalability @xcite and communication overheads @xcite , which pose constraints in achieving efficient fault tolerance when applied to high - performance computing systems . moreover , many of the traditional fault tolerant mechanisms are manual methods and require human administrator intervention for isolating recurring faults .",
    "this will place a cost on the time required for maintenance .",
    "self - managing or automated fault tolerant approaches are therefore desirable , and the objective of the research reported in this paper is the development of such approaches . if a failure is likely to occur on a computing core on which a job is being executed , then it is necessary to be able to move ( migrate ) the job onto a reliable core @xcite",
    ". such mechanisms are not readily available . at the heart of this concept",
    "is mobility , and a technique that can be employed to achieve this is using multi - agent technologies @xcite .",
    "two approaches are proposed and implemented as the means of achieving both the computation in the job and self - managing fault tolerance ; firstly , an approach incorporating agent intelligence , and secondly , an approach incorporating core intelligence . in the first approach ,",
    "automated fault tolerance is achieved by a collection of agents which can freely traverse on a network of computing cores .",
    "each agent carries a portion of the job ( or sub - job ) to be executed on a computing core in the form of a payload .",
    "fault tolerance in this context can be achieved since an agent can move on the network of cores , effectively moving a sub - job from one computing core which may fail onto another reliable core .    in the second approach ,",
    "automated fault tolerance is achieved by considering the computing cores to be an intelligent network of cores .",
    "sub - jobs are scheduled onto the cores , and the cores can move processes executed on them across the network of cores .",
    "fault tolerance in this context can be achieved since a core can migrate a process executing on it onto another core .",
    "a third approach is proposed which combines both agent and core intelligence under a single umbrella . in this approach ,",
    "a collection of agents freely traverse on a network of virtual cores which are an abstraction of the actual hardware cores .",
    "the agents carry the sub - jobs as a payload and situate themselves on the virtual cores .",
    "fault tolerance is achieved either by an agent moving off one core onto another core or the core moving an agent onto another core when a fault is predicted .",
    "rules are considered to decide whether an agent or a core should initiate the move .",
    "automated fault tolerance can be beneficial in areas such as molecular dynamics @xcite .",
    "typical molecular dynamics simulations explore the properties of molecules in gaseous , liquid and solid states .",
    "for example , the motion of molecules over a time period can be computed by employing newton s equations if the molecules are treated as point masses .",
    "these simulations require large numbers of computing cores that run sub - jobs of the simulation which communicate with each other for hours , days and even months .",
    "it is not desirable to restart an entire simulation or to loose any data from previous numerical computations when a failure occurs .",
    "conventional methods like periodic checkpointing keep track of the state of the sub - jobs executed on the cores , and helps in restarting a job from the last checkpoint . however , overzealous periodic checkpointing over a prolonged period of time has large overheads and contributes to the slowdown of the entire simulation @xcite .",
    "additionally , mechanisms will be required to store and handle large data produced by the checkpointing strategy .",
    "further , how wide the failure can impact the simulation is not considered in checkpointing .",
    "for example , the entire simulation is taken back to a previous state irrespective of whether the sub - jobs running on a core depend or do not depend on other sub - jobs .",
    "one potential solution to mitigate the drawbacks of checkpointing is to proactively probe the core for failures .",
    "if a core is likely to fail , then the sub - job executing on the core is migrated automatically onto another core that is less likely to fail .",
    "this paper proposes and experimentally evaluates multi - agent approaches to realising this automation .",
    "genome searching is considered as an example for implementing the multi - agent approaches .",
    "the results indicate the feasibility of the multi - agent approaches ; they require only one - fifth the time compared to that required by manual approaches .",
    "the remainder of this paper is organised as follows .",
    "the methods section presents the three approaches proposed for automated fault tolerance .",
    "the results section highlights the experimental study and the results obtained from it .",
    "the discussion section presents a discussion on the three approaches for automating fault tolerance .",
    "the conclusions section summarises the key results from this study .",
    "three approaches to automate fault tolerance are presented in this section .",
    "the first approach incorporates agent intelligence , the second approach incorporates core intelligence , and in the third a hybrid of both agent and core intelligence is incorporated .      a job , @xmath0 , which needs to be executed on a large - scale system is decomposed into a set of sub - jobs @xmath1 .",
    "each sub - job @xmath1 is mapped onto agents @xmath2 that carry the sub - jobs as payloads onto the cores , @xmath3 as shown in figure 1 . the agents and the sub - job are independent of each other ; in other words , an agent acts as a wrapper around a sub - job to situate the sub - job on a core .",
    "there are three computational requirements of the agent to achieve successful execution of the job : ( a ) the agent needs to know the overall job , @xmath0 , that needs to be achieved , ( b ) the agent needs to access data required by the sub - job it is carrying and ( c ) the agent needs to know the operation that the sub - job needs to perform on the data .",
    "the agents then displace across the cores to compute the sub - jobs .",
    "intelligence of an agent can be useful in at least four important ways for achieving fault tolerance while a sub - job is executed .",
    "firstly , an agent knows the landscape in which it is located .",
    "knowledge of the landscape is threefold which includes ( a ) the knowledge of the computing core on which the agent is located , ( b ) knowledge of other computing cores in the vicinity of the agent and ( c ) knowledge of agents located in the vicinity .",
    "secondly , an agent identifies a location to situate within the landscape .",
    "this is possible by gathering information from the vicinity using probing processes and is required when the computing core on which the agent is located is anticipated to fail .",
    "thirdly , an agent predicts failures that are likely to impair its functioning .",
    "the prediction of failures ( for example , due to the failure of the computing core ) is along similar lines to proactive fault tolerance .",
    "fourthly , an agent is mobile within the landscape . if the agent predicts a failure then the agent can relocate onto another computing core thereby moving off the job from the core anticipated to fail ( refer figure 2 ) .     and",
    "@xmath4 are situated on cores @xmath5 and @xmath6 respectively .",
    "a failure is predicted on core @xmath7 .",
    "the agent @xmath8 moves onto core @xmath9.,scaledwidth=40.0% ]    the intelligence of agents is incorporated within the following sequence of steps that describes an approach for fault tolerance :    ' '' ''    _ agent intelligence based fault tolerance _ +    ' '' ''    1 .   decompose a job , @xmath0 , to be executed on the landscape into sub - jobs , @xmath1 2 .   each sub - job provided as a payload to agents , @xmath2 3 .",
    "agents carry jobs onto computing cores , @xmath3 4 .   for each agent , @xmath10 located on computing core @xmath11 , where @xmath12 to @xmath13 1 .",
    "periodically probe the computing core @xmath11 2 .",
    "if @xmath11 predicted to fail , then 1",
    ".   agent , @xmath10 moves onto an adjacent computing core , @xmath9 2 .",
    "notify dependent agents 3 .",
    "agent @xmath10 establishes dependencies 5 .",
    "collate execution results from sub - jobs    ' '' ''      a failure scenario is considered for the agent intelligence based fault tolerance concept . in this scenario , while a job is executed on a computing core that is anticipated to fail any adjacent core onto which the job needs to be reallocated can also fail .",
    "the communication sequence shown in figure 3 is as follows .",
    "the hardware probing process on the core anticipating failure , @xmath14 notifies the failure prediction to the agent process , @xmath15 , situated on it .",
    "since the failure of a core adjacent to the core predicted to fail is possible it is necessary that the predictions of the hardware probing processes on the adjacent cores be requested .",
    "once the predictions are gathered , the agent process , @xmath15 , creates a new process on an adjacent core and transfers data it was using onto the newly created process .",
    "then the input dependent ( @xmath16 ) and output dependent ( @xmath17 ) processes are notified .",
    "the agent process on @xmath14 is terminated thereafter . the new agent process on the adjacent core establishes dependencies with the input and output dependent processes .          a job , @xmath0 , which needs to be executed on a large - scale system is decomposed into a set of sub - jobs @xmath1 .",
    "each sub - job @xmath1 is mapped onto the virtual cores , @xmath18 , an abstraction over @xmath3 respectively as shown in figure 4 .",
    "the cores referred to in this approach are virtual cores which are an abstraction over the hardware computing cores .",
    "the virtual cores are a logical representation and may incorporate rules to achieve intelligent behaviour .     and",
    "@xmath19 are situated on virtual cores @xmath20 and @xmath21 respectively .",
    "a failure is predicted on core @xmath7 and @xmath22 moves the job @xmath23 onto virtual core @xmath24.,scaledwidth=40.0% ]    intelligence of a core is useful in a number of ways for achieving fault tolerance .",
    "firstly , a core updates knowledge of its surrounding by monitoring adjacent neighbours .",
    "independent of what the cores are executing , the cores can monitor each other .",
    "each core can ask the question ` are you alive ? ' to its neighbours and gain information .",
    "secondly , a core periodically updates information of its surrounding .",
    "this is useful for the core to know which neighbouring cores can execute a job if it fails .",
    "thirdly , a core periodically monitors itself using a hardware probing process and predicts if a failure is likely to occur on it .",
    "fourthly , a core can move a job executing on it onto an adjacent core if a failure is expected and adjust to failure as shown in figure 4 .",
    "once a job has relocated all data dependencies will need to be re - established .",
    "the following sequence of steps describe an approach for fault tolerance incorporating core intelligence :    ' '' ''    _ core intelligence based fault tolerance _",
    "+    ' '' ''    1 .",
    "decompose a job , @xmath0 , to be executed on the landscape into sub - jobs , @xmath1 2 .",
    "each sub - job allocated to cores , @xmath18 3 .   for each core , @xmath25 , where @xmath12 to @xmath13 until sub - job @xmath26 completes execution 1 .",
    "periodically probe the computing core @xmath11 2 .",
    "if @xmath11 predicted to fail , then 1 .",
    "migrate sub - job @xmath26 on @xmath25 onto an adjacent computing core , @xmath24 4 .",
    "collate execution results from sub - jobs    ' '' ''      figure 5 shows the communication sequence of the core failure scenario considered for the core intelligence based fault tolerance concept . the hardware probing process on the core predicted to fail , @xmath14 notifies a predicted failure to the core .",
    "the job executed on @xmath27 is then migrated onto an adjacent core @xmath28 once a decision based on failure predictions are received from the hardware probing processes of adjacent cores .",
    "the hybrid approach acts as an umbrella bringing together the concepts of agent intelligence and core intelligence .",
    "the key concept of the hybrid approach lies in the mobility of the agents on the cores and the cores collectively executing a job .",
    "decision - making is required in this approach for choosing between the agent intelligence and core intelligence approaches when a failure is expected .    a job , @xmath0 , which needs to be executed on a large - scale system is decomposed into a set of sub - jobs @xmath1 .",
    "each sub - job @xmath1 is mapped onto agents @xmath2 that carry the sub - jobs as payloads onto the virtual cores , @xmath18 which are an abstraction over @xmath3 respectively as shown in figure 1 .    the following sequence of steps describe the hybrid approach for fault tolerance incorporating both agent and core intelligence :    ' '' ''    _ hybrid intelligence based fault tolerance _ +    ' '' ''    1 .",
    "decompose a job , @xmath0 , to be executed on the landscape into sub - jobs , @xmath1 2 .   each sub - job provided as a payload to agents , @xmath2 3 .",
    "agents carry jobs onto virtual cores , @xmath18 4 .   for each agent , @xmath10 located on virtual core @xmath25 , where @xmath12 to @xmath13 1 .",
    "periodically probe the computing core @xmath11 2 .",
    "if @xmath11 predicted to fail , then 1 .",
    "if ` agent intelligence ' is a suitable mechanism , then 1 .",
    "agent , @xmath10 , moves onto an adjacent computing core , @xmath24 2 .",
    "notify dependent agents 3 .",
    "agent @xmath10 establishes dependencies 1 .",
    "else if ` core intelligence ' is a suitable mechanism , then 1 .",
    "core @xmath25 migrates agent , @xmath10 onto an adjacent computing core , @xmath24 5 .",
    "collate execution results from sub - jobs    ' '' ''",
    "when a core failure is anticipated both an agent and a core can make decisions which can lead to a conflict .",
    "for example , an agent can attempt to move onto an adjacent core while the core on which it is executing would like to migrate it to an alternative adjacent core .",
    "therefore , an agent and the core on which it is located need to negotiate before either of them initiate a response to move ( see figure 6 ) .",
    "the rules for the negotiation between the agent and the core in this case are proposed from the experimental results presented in this paper ( presented in the decision making rules sub - section ) .     and",
    "@xmath4 are situated on virtual cores @xmath20 and @xmath21 which are mapped onto computing cores @xmath5 and @xmath6 respectively .",
    "a failure is predicted on core @xmath7 .",
    "the agent @xmath8 and @xmath22 negotiate to decide who moves the sub - job onto core @xmath24.,scaledwidth=40.0% ]",
    "in this section , the experimental platform is considered followed by the experimental studies and the results obtained from experiments .",
    "four computer clusters were used for the experiments reported in this paper .",
    "the first was a cluster available at the centre for advanced computing and emerging technologies ( acet ) , university of reading , uk .",
    "thirty three compute nodes connected through gigabit ethernet were available , each with pentium iv processors and 512 mb-2 gb ram .",
    "the remaining three clusters are compute resources , namely brasdor , glooscap and placentia , all provided by the atlantic computational excellence network ( acenet ) @xcite , canada .",
    "brasdor comprises 306 compute nodes connected through gigabit ethernet , with 932 cores and 1 - 2 gb ram .",
    "glosscap comprises 97 nodes connected through infiniband , with 852 cores and 1 - 8 gb ram .",
    "placentia comprises 338 compute nodes connected through infiniband , with 3740 cores and 2 - 16 gb ram .",
    "the cluster implementations in this paper are based on the message passing interface ( mpi ) .",
    "the first approach , incorporating agent intelligence , is implemented using open mpi @xcite , an open source implementation of mpi 2.0 . the dynamic process model which supports dynamic process creation and management facilitates control over an executing process .",
    "this feature is useful for implementing the first approach .",
    "the mpi functions useful in the implementation are ( i ) mpi_comm_spawn which creates a new mpi process and establishes communication with an existing mpi application and ( ii ) mpi_comm_accept and mpi_comm_connect which establishes communication between two independent processes .    the second approach , incorporating core intelligence ,",
    "is implemented using adaptive mpi ( ampi ) @xcite , developed over charm++ @xcite , a c++ based parallel programming language .",
    "the aim of ampi is to achieve dynamic load balancing by migrating objects over virtual cores and thereby facilitating control over cores .",
    "core intelligence harnesses this potential of ampi to migrate a job from a core onto another core .",
    "a strategy to migrate a job using the concepts of processor virtualisation and dynamic job migration in ampi and charm++ is reported in @xcite .",
    "parallel reduction algorithms @xcite which implement the bottom - up approach ( i.e. , data flows from the leaves to the root ) are employed for the experiments .",
    "these algorithms are of interest for three reasons .",
    "firstly , the algorithm is used in a large number of scientific applications including computational biological applications in which optimizations are performed ( for example , bootstrapping ) . incorporating self - managing fault tolerant approaches",
    "can make these algorithms more robust and reliable @xcite .",
    "secondly , the algorithm lends itself to be easily decomposed into a set of sub - jobs .",
    "each sub - job can then be mapped onto a computing core either by providing the sub - job as a payload to an agent in the first approach or by providing the job onto a virtual core incorporating intelligent rules .",
    "thirdly , the execution of a parallel reduction algorithm stalls and produces incorrect solutions if a core fails .",
    "therefore , parallel reduction algorithms can benefit from local fault - tolerant techniques .",
    "figure 7 is an exemplar of a parallel reduction algorithm . in the experiments reported in this paper , a generic parallel summation algorithm with three sets of input",
    "is employed .",
    "firstly , @xmath29 , @xmath30 @xmath31 @xmath32 , secondly , @xmath33 , @xmath34 @xmath31 @xmath35 , and thirdly , @xmath36 @xmath31 @xmath37 . the first level nodes which receive the three sets of input comprise three set of nodes .",
    "firstly , @xmath38 , @xmath39 @xmath31 @xmath40 , secondly , @xmath41 , @xmath42 @xmath31",
    "@xmath43 , and thirdly , @xmath44 , @xmath45 @xmath31 @xmath46 . the next level of nodes , @xmath47 , @xmath48 and @xmath49 receive inputs from the first level nodes . the resultant from the second level nodes is fed in to the third level node @xmath50 .",
    "the nodes reduce the input through the output using the parallel summation operator ( @xmath51 ) .     and",
    "the three levels of nodes are denoted by @xmath52 .",
    "the inputs are passed to the nodes @xmath53 which are then reduced and passed to nodes @xmath54 and finally onto @xmath55 for the output.,scaledwidth=45.0% ]    the parallel summation algorithm can benefit from the inclusion of fault tolerant strategies .",
    "the job , @xmath0 , in this case is summation , and the sub - jobs , @xmath1 are also summations . in the first fault tolerant approach , incorporating mobile agent intelligence , the data to be summed along with the summation operator is provided to the agent .",
    "the agents locate on the computing cores and continuously probe the core for anticipating failures . if an agent is notified of a failure , then it moves off onto another computing core in the vicinity , thereby not stalling the execution towards achieving the summation job . in the second fault",
    "tolerant approach , incorporating core intelligence , the sub - job comprising the data to be summed along with the summation operator is located on the virtual core .",
    "when the core anticipates a failure , it migrates the sub - job onto another core .",
    "a failure scenario is considered for experimentally evaluating the fault tolerance strategies . in the scenario ,",
    "when a core failure is anticipated the sub - job executing on it is relocated onto an adjacent core .",
    "of course this adjacent core may also fail .",
    "therefore , information is also gathered from adjacent cores as to whether they are likely to fail or not .",
    "this information is gathered by the agent in the agent - based approach and the virtual core in the core - based approach and used to determine which adjacent core the sub - job needs to be moved to .",
    "this failure scenario is adapted to the two strategies giving respectively the agent intelligence failure scenario and the core intelligence failure scenario ( described in the methods section ) .",
    "figures 8 through 13 are a collection of graphs plotted using the parallel reduction algorithm as a case study for both the first ( agent intelligence - figure 8 , figure 10 and figure 12 ) and second ( core intelligence - figure 9 , figure 11 and figure 13 ) fault tolerant approaches .",
    "each graph comprises four plots , the first representing the acet cluster and the other three representing the three acenet clusters .",
    "the graphs are also distinguished based on the following three factors that can affect the performance of the two approaches :                            * the number of dependencies of the sub - job being executed denoted as @xmath56 .",
    "if the total number of input dependencies is @xmath57 and the total number of output dependencies is @xmath58 , then @xmath59 .",
    "for example , in a parallel summation algorithm incorporating binary trees , each node has two input dependencies and one output dependency , and therefore @xmath60 . in the experiments",
    ", the number of dependencies is varied between 3 and 63 , by changing the number of input dependencies of an agent or a core .",
    "the results are presented in figure 8 and figure 9 . *",
    "the size of the data communicated across the cores denoted as @xmath61 . in the experiments ,",
    "the input data is a matrix for parallel summation and its size is varied between @xmath62 to @xmath63 kb .",
    "the results are presented in figure 10 and figure 11 . * the process size of the distributed components of the job denoted as @xmath64 . in the experiments",
    ", the process size is varied between @xmath62 to @xmath63 kb which is proportional to the input data .",
    "the results are presented in figure 12 and figure 13 .",
    "figure 8 is a graph of the time taken in seconds for reinstating execution versus the number of dependencies in the agent intelligence failure scenario . the mean time taken to reinstate execution for 30 trials , @xmath65 ,",
    "is computed for varying numbers of dependencies , @xmath56 ranging from 3 to 63 .",
    "the size of the data on the agent is @xmath66 kilo bytes .",
    "the approach is slowest on the acet cluster and fastest on the placentia cluster . in all cases the communication overheads result in a steep rise in the time taken for execution until @xmath67 .",
    "the time taken on the acet cluster rises once again after @xmath68 .",
    "figure 9 is a graph of the time taken in seconds for reinstating execution versus the number of dependencies in the core intelligence failure scenario . the mean time taken to reinstate execution for 30 trials , @xmath69 ,",
    "is computed for varying number of dependencies , @xmath56 ranging from 3 to 63 .",
    "the size of the data on the core is @xmath66 kilo bytes .",
    "the approach requires almost the same time on the four clusters for reinstating execution until @xmath67 , after which there is divergence in the plots .",
    "the approach lends itself well on placentia and glooscap .    figure 10",
    "is a graph showing the time taken in seconds for reinstating execution versus the size of data in kilobytes ( kb ) , @xmath70 , where @xmath71 , carried by an agent in the agent intelligence failure scenario . the mean time taken to reinstate execution for 30 trials , @xmath65 ,",
    "is computed for varying sizes of data ranging from @xmath62 to @xmath63 kb .",
    "the number of dependencies @xmath56 is 10 for the graph plotted .",
    "placentia and glooscap outperforms acet and brasdor in the agent approach for varying size of data .",
    "figure 11 is a graph showing the time taken in seconds for reinstating execution versus the size of data in kilobytes ( kb ) , @xmath70 , where @xmath71 , on a core in the core intelligence failure scenario . the mean time taken to reinstate execution for 30 trials , @xmath69 ,",
    "is computed for varying sizes of data ranging from @xmath62 to @xmath63 kb .",
    "the number of dependencies @xmath56 is 10 for the graph plotted . in this graph ,",
    "nearly similar time is taken by the approach on the four clusters with the acet cluster requiring more time than the other clusters for @xmath72 .",
    "figure 12 is a graph showing the time taken in seconds for reinstating execution versus process size in kilobytes ( kb ) , @xmath73 , where @xmath71 , in the agent intelligence failure scenario . the mean time taken to reinstate execution for 30 trials , @xmath65 ,",
    "is computed for varying process sizes ranging from @xmath62 to @xmath63 kb .",
    "the number of dependencies @xmath56 is 10 for the graph plotted .",
    "the second scenario performs similar to the first scenario .",
    "the approach takes almost similar times to reinstate execution after a failure on the four clusters , but there is a diverging behaviour after @xmath74 .",
    "figure 13 is a graph showing the time taken in seconds for reinstating execution versus process size in kilobytes ( kb ) , @xmath73 , where @xmath71 , in the core intelligence failure scenario . the mean time taken to reinstate execution for 30 trials , @xmath69 ,",
    "is computed for varying process sizes ranging from @xmath62 to @xmath63 kb .",
    "the number of dependencies @xmath56 is 10 for the graph plotted .",
    "the approach has similar performance on the four clusters , though placentia performs better than the other three clusters for a process size of more than @xmath75 kb .",
    "parallel simulations in molecular dynamics model atoms or molecules in gaseous , liquid or solid states as point masses which are in motion .",
    "such simulations are useful for studying the physical and chemical properties of the atoms or molecules .",
    "typically the simulations are compute intensive and can be performed in at least three different ways @xcite .",
    "firstly , by assigning a group of atoms to each processor , referred to as atom decomposition .",
    "the processor computes the forces related to the group of atoms to update their position and velocities .",
    "the communication between atoms is high and effects the performance on large number of processors .",
    "secondly , by assigning a block of forces from the force matrix to be computed to each processor , referred to as force decomposition .",
    "this technique scales better than atom decomposition but is not a best solution for large simulations .",
    "thirdly , by assigning a three dimensional space of the simulation to each processor , referred to as spatial decomposition .",
    "the processor needs to know the positions of atoms in the adjacent space to compute the forces of atoms in the space assigned to it .",
    "the interactions between the atoms are therefore local to the adjacent spaces . in the first and second decomposition techniques interactions",
    "are global and thereby dependencies are higher .",
    "agent and core based approaches to fault tolerance can be incorporated within parallel simulations in the area of molecular dynamics . however , which of the two approaches , agent or core intelligence , is most appropriate ?",
    "the decomposition techniques considered above establish dependencies between blocks of atoms and between atoms .",
    "therefore the degree of dependency affects the relocation of a sub - job in the event of a core failure and reinstating it .",
    "the dependencies of an atom in the simulation can be based on the input received from neighbouring atoms and the output propagated to neighbouring atoms .",
    "based on the number of atoms allocated to a core and the time step of the simulation the intensity of numerical computations and the data managed by a core vary .",
    "large simulations that extend over long periods of time generate and need to manage large amounts of data ; consequently the process size on a core will also be large .    therefore , ( i ) the dependency of the job , ( ii ) the data size and ( iii ) the process size are factors that need to be taken into consideration for deciding whether an agent - based approach or a core - based approach needs to come into play .",
    "along with the observations from parallel simulations in molecular dynamics , the experimental results provide an insight into the rules for decision - making for large - scale applications .    from the experimental results graphed in figure 8 and figure 9 , where dependencies are varied , core intelligence is superior to agent intelligence if the total dependencies @xmath56 is less than or equal to 10",
    "therefore ,    1 .   if the algorithm needs to incorporate fault tolerance based on the number of dependencies , then if @xmath76 use core intelligence , else use agent or core intelligence .    from the experimental results graphed in figure 10 and figure 11 , where the size of data is varied , agent intelligence is more beneficial than core intelligence if the size of data @xmath61 is less than or equal to @xmath77 kb .",
    "therefore ,    1 .   if the algorithm needs to incorporate fault tolerance based on the size of data , then if @xmath78 kb , then use agent intelligence , else use agent or core intelligence .    from the experimental results graphed in figure 12 and figure 13 , where the size of the process is varied , agent intelligence is more beneficial than core intelligence if the size of the process @xmath64 is less than or equal to @xmath77 kb .",
    "therefore ,    1 .   if the algorithm needs to incorporate fault tolerance based on process size , then if @xmath79 kb , then use agent intelligence , else use agent or core intelligence .",
    "the number of dependencies , size of data , and process size are the three factors taken into account in the experimental results .",
    "the results indicate that the approach incorporating core intelligence takes lesser time than the approach incorporating agent intelligence .",
    "there are two reasons for this .",
    "firstly , in the agent approach , the agent needs to establish the dependency with each agent individually , where as in the core approach as a job is migrated from a core onto another its dependencies are automatically established .",
    "secondly , agent intelligence is a software abstraction of the sub - job , thereby adding a virtualised layer in the communication stack .",
    "this increases the time for communication .",
    "the virtual core is also an abstraction of the computing core but is closer to the computing core in the communication stack .    the above rules can be incorporated to exploit both agent - based and core - based intelligence in a third , hybrid approach .",
    "the key concept of the hybrid approach combines the mobility of the agents on the cores and the cores collectively executing a job .",
    "the approach can select whether the agent - based approach or the core - based approach needs to come to play based on the rules for decision - making .",
    "the key observation from the experimental results is that the cost of incorporating intelligence at the job and core levels for automating fault tolerance is less than a second , which is smaller than the time taken by manual methods which would be in the order of minutes .",
    "for example , in the first approach , the time for reinstating execution with over 50 dependencies is less than 0.55 seconds and in the second approach , is less than 0.5 seconds .",
    "similar results are obtained when the size of data and the process are large .      the proposed multi - agent approaches and the decision making rules considered in the above sections",
    "are validated using a computational biology job .",
    "a job that fits the criteria of reduction algorithms is considered . in reduction algorithms ,",
    "a job is decomposed to sub - jobs and executed on multiple nodes and the results are further passed onto other node for completing the job . one popular computational biology job that fits this criteria is searching for a genome pattern .",
    "this has been widely studied and fast and efficient algorithms have been developed for searching genome patterns ( for example , @xcite , @xcite and @xcite ) . in the genome searching experiment performed in this research multiple nodes of a cluster execute the search operation and the output produced by the search nodes are then combined by an additional node .",
    "the focus of this experimental study is not parallel efficiency or scalability of the job but to validate the multi - agent approaches and the decision making rules in the context of computational biology .",
    "hence , a number of assumptions are made for the genome searching job .",
    "first , redundant copies of the genome data are made on the same node to obtain a sizeable input .",
    "secondly , the search operation is run multiple times to span long periods of time .",
    "thirdly , the jobs are executed such that they can be stopped intentionally by the user at any time and gather the results of the preceding computations until the execution was stopped .",
    "the placentia cluster is chosen for this validation study since it was the best performing cluster in the empirical study presented in the previous sections .",
    "the job is implemented using r programming which uses mpi for exploiting computation on multiple nodes of the placentia cluster .",
    "bioconductor packages are required for supporting the job .",
    "the job makes use of bsgenome.celegans.ucsc.ce2 , bsgenome.celegans.ucsc.ce6 and bsgenome.celegans.ucsc.ce10 as input data which are the ce2 , ce6 and ce10 genome for chromosome i of caenorhabditis elegans @xcite . a list of 5000 genome patterns each of which is a short nucleotide sequence of 15 to 25 bases is provided to be searched against the input data .",
    "the forward and reverse strands of seven caenorhabditis elegans chromosomes named as chri , chrii , chriii , chriv , chrv , chrx , chrm are the targets of the search operation .",
    "when there is a target hit the search nodes provide to the node that gathers the results the name of the chromosome where the hit occurs , two integers giving the starting and ending positions of the hit , an indication of the hit either in the forward or reverse strand , and unique identification for every pattern in the dictionary .",
    "the results are tabulated in an output file in the combining node .",
    "a sample of the output is shown in figure 14 .",
    "redundant copies of the input data are made to obtain 512 mb ( which is @xmath62 kb ) and the job is executed for one hour . in a typical experiment the number of dependencies , @xmath56 was set to 4 ; three nodes of the cluster performed the search operation while the fourth node combined the results passed on to it from the three search nodes . in the agent intelligence based approach the time for predicting the fault is 38 seconds , the time for reinstating execution is 0.47 seconds , the overhead time is over 5 minutes and the total time when one failure occurs per hour is 1 hour , 6 minutes and 17 seconds . in the core intelligence based",
    "approach the time for predicting the single node failure is similar to the agent intelligence approach ; the time for reinstating execution is 0.38 seconds , the overhead time is over 4 minutes and the total time when one failure occurs per hour is 1 hour , 5 minutes and 8 seconds .    in another experiment for 512 mb size of input data the number of dependencies was set to 12 ; eleven nodes for searching and one node for combining the results provided by the eleven search nodes .",
    "in the agent intelligence based approach the time for reinstating execution is 0.54 seconds , the overhead time is over 6 minutes and the total time when one failure occurs per hour is 1 hour , 7 minutes and 34 seconds . in the core intelligence based",
    "approach the time for reinstating execution is close to 0.54 seconds , the overhead time is over 6 minutes and the total time when one failure occurs per hour is 1 hour , 7 minutes and 48 seconds .",
    "the core intelligence approach requires less time than the agent intelligence approach when @xmath80 , but the times are comparable when @xmath81 .",
    "so , the above two experiments validate rule 1 for decision making considered in the previous section .",
    "experiments were performed for different input data sizes ; in one case @xmath82 kb and in the other @xmath83 kb . the agent intelligence approach required less time in the former case than the core intelligence approach .",
    "the time was comparable for the latter case .",
    "hence , the genome searching job in the context of the experiments validated rule 2 for decision making . similarly , when process size was varied rule 3 was found to be validated .",
    "the genome searching job is used as an example to validate the use of the multi - agent approaches for computational biology jobs .",
    "the decision making rules empirically obtained were satisfied in the case of this job .",
    "the results obtained from the experiments for the genome searching job along with comparisons against traditional fault tolerance approaches , namely centralised and decentralised checkpointing are considered in the next section .",
    "all fault tolerance approaches initiate a response to address a failure . based on",
    "when a response is initiated with respect to the occurrence of the failure , approaches can be classified as proactive and reactive .",
    "proactive approaches predict failures of computing resources before they occur and then relocate a job executing on resources anticipated to fail onto resource that are not predicted to fail ( for example @xcite ) .",
    "reactive approaches on the other hand minimise the impact of failures after they have occurred ( for example checkpointing @xcite , rollback recovery @xcite and message logging @xcite ) . a hybrid of proactive and reactive , referred to as adaptive approaches , is implemented so that failures that can not be predicted by proactive approaches are handled by the reactive approaches @xcite .    the control of a fault tolerant approach can be either centralised or distributed . in approaches",
    "where the control is centralised , one or more servers are used for backup and a single process responsible for monitoring jobs that are executed on a network of nodes . the traditional message logging and checkpointing approach involves the periodic recording of intermediate states of execution of a job to which execution can be returned if faults occur .",
    "such approaches are susceptible to single point failure , lack scalability over a large network of nodes , have large overheads , and require large disk storage .",
    "these drawbacks can be minimised or avoided when the control of the approaches is distributed ( for example , distributed diagnosis @xcite , distributed checkpointing @xcite and diskless checkpointing @xcite ) .    in this paper two",
    "distributed proactive approaches towards achieving fault tolerance are proposed and implemented . in both approaches a job to be computed is decomposed into sub - jobs which are then mapped onto the computing cores .",
    "the two approaches operate at the middle levels ( between the sub - jobs and the computing cores ) incorporating agent intelligence . in the first approach ,",
    "the sub - jobs are mapped onto agents which are released onto the cores .",
    "if an agent is notified of a potential core failure during execution of the sub - job mapped onto it , then the agent moves onto another core thereby automating fault tolerance .",
    "in the second approach the sub - jobs are scheduled on virtual cores , which are an abstraction of the computing cores .",
    "if a virtual core anticipates a core failure then it moves the sub - job on it to another virtual core , in effect onto another computing core .",
    "the two approaches achieve automation in fault tolerance using intelligence in agents and using intelligence in cores respectively .",
    "a third approach is proposed which brings together the concepts of both agent intelligence and core intelligence from the first two approaches .      the conventional approaches to fault tolerance such as checkpointing have large communication overheads based on the periodicity of checkpointing .",
    "high frequencies of checkpointing can lead to heavy network traffic since the available communication bandwidth will be saturated with data transferred from all computing nodes to the a stable storage system that maintains the checkpoint .",
    "this traffic is on top of the actual data flow of the job being executed on the network of cores .",
    "while global approaches are useful for jobs which are less memory and data intensive and can be executed over short periods of time , they may constrain the efficiency for jobs using big data in limited bandwidth platforms . hence , local approaches can prove useful . in the case of the agent based approaches",
    "there is high periodicity for probing the cores in the background but very little data is transferred while probing unlike in checkpointing .",
    "hence , communication overhead times will be significantly lesser .",
    "lack of scalability is another issue that affects efficient fault tolerance .",
    "many checkpointing strategies are centralised ( with few exceptions , such as @xcite ) thereby limiting the scale of adopting the strategy .",
    "this can be mitigated by using multiple centralised checkpointing servers but the distance between the nodes and the server discounts the scalability issue . in the agent",
    "based approaches , all communications are short distance since the cores only need to communicate with the adjacent cores .",
    "local communication therefore increases the scale to which the agent based approaches can be applied .",
    "checkpointing is susceptible to single point failures due to the failure of the checkpoint servers .",
    "the job executed will have to be restarted .",
    "the agent - based approaches are also susceptible to single point failures .",
    "while they incorporate intelligence to anticipate hardware failure the processor core may fail before the sub - job it supports can be relocated to an adjacent processor core , before the transfer is complete , or indeed the core onto which it is being transferred may also fail .",
    "however , the incorporation of intelligence on the processor core , specifically the ability to anticipate hardware failure locally , means that the numbers of these hardware failures that lead to job failure can be reduced when compared to traditional checkpointing .",
    "but since there is the possibility of agent failure the retention of some level of human intervention is still required .",
    "therefore , we propose combining checkpointing with the agent - based approaches , the latter acting as a first line of anticipatory response to hardware failure backed up by traditional checkpointing as a second line of reactive response .",
    "figure 15 shows the execution of a job between two checkpoints , @xmath84 and @xmath85 , where @xmath86 is the predicted failure and @xmath87 is the actual failure of the node on which a sub - job is executing .",
    "figure 15(a ) shows when there are no predicted failures or actual failures that occur on the node .",
    "figure 15(b ) shows when a failure occurs but could not be predicted . in this case",
    ", the system fails if the multi - agent approaches are solely employed .",
    "one way to mitigate this problem is by employing the multi - agent approaches in conjunction with checkpointing as shown in the next section .",
    "figure 15(c ) shows when the approaches predict a failure which does not happen .",
    "if a large number of such predictions occur then the sub - job needs to be shifted often from one node to the other which adds to the overhead time for executing the job .",
    "this is not an ideal case and makes the job unstable .",
    "figure 15(d ) shows the ideal case in which a fault is predicted before it occurs .     and @xmath85 .",
    "( a ) ideal state of the job when no faults occur .",
    "( b ) failure state of the job when a fault occurs but is not predicted .",
    "( c ) unstable state of the job when a fault is predicted but does not occur .",
    "( d ) ideal prediction state of the job when a fault is predicted and occurs thereafter.,scaledwidth=40.0% ]    failure prediction is based on a machine learning approach that is incorporated within multi - agents .",
    "this prediction is based on a log that is maintained on the health of the node and its adjacent nodes .",
    "each agent sends out are you alive signals to adjacent nodes to gather the state of the adjacent node .",
    "the machine learning approach is constantly evaluating the state of the system against the log it maintains , which is different across the nodes .",
    "the log can contain the state of the node from past failures , work load of the nodes when it failed previously and even data related to patterns of periodic failures .",
    "however , this prediction method can not predict a range of faults due to deadlocks , hardware and power failures and instantaneously occurring faults .",
    "hence , the multi - agent approaches are most useful when used along with checkpointing .",
    "it was observed that nearly 29% of all faults occurring in the cluster could be predicted .",
    "although this number is seemingly small it is helpful to not have to rollback to a previous checkpoint when a large job under time constraints is executed .",
    "accuracy of the predictions were found to be 64% ; the system was found to be stable in 64 out of the 100 times a prediction was made . to increase",
    "the impact of the multi - agent approaches more faults will need to be captured .",
    "for this extensive logging and faster methods for prediction will need to be considered .",
    "these approaches will have to be used in conjunction with checkpointing for maximum effectiveness .",
    "the instability due to the approaches shifting jobs between nodes when there is a false prediction will need to be reduced to improve the overall efficiency of the approaches . for this",
    ", the state of the node can be compared with other nodes so that a more informed choice is made by the approaches .",
    "table 1 shows a comparison between a number of fault tolerant strategies , namely centralised and decentralised checkpointing and the multi - agent approaches .",
    "an experiment was run for a genome searching job that was executed multiple times on the placentia cluster .",
    "data in the table was obtained to study the execution of the genome searching job between two checkpoints ( @xmath84 and @xmath85 ) which are one hour apart .",
    "the execution is interrupted by failure @xmath87 as shown in figure 16 .",
    "two types of single node failure are simulated in the execution .",
    "the first is a periodic node failure which occurs at 15 minutes after @xmath84 and 45 minutes before @xmath85 ( refer figure 16(a ) ) , and the second is a random node failure which occurs @xmath88 minutes after @xmath84 and @xmath89 minutes before @xmath85 ( refer figure 16(b ) ) .",
    "the average time when a random failure occurs is found to be 31 minutes and 14 seconds for 5000 trials .",
    "the size of data , @xmath82 kb and the number of dependencies , @xmath90 .        in table 1 , the average time taken for reinstating execution , for the overheads and for executing the job between the checkpoints is considered . the time taken for reinstating execution is for bringing execution back to normal after a failure has occurred .",
    "the reinstating time is obtained for one periodic single node failure and one random single node failure .",
    "the overhead time is for creating the checkpoints and transferring data for the checkpoint to the server .",
    "the overhead time is obtained for one periodic single node failure and one random single node failure .",
    "the execution time without failures , when one periodic failure occurs per hour and when five random failures occur per hour is obtained .",
    "centralised checkpointing using single and multiple servers is considered when the frequency of checkpointing is once every hour . in the case of both single and multiple server checkpointing the time taken for reinstating execution",
    "regardless of whether it was a periodic or random failure is 14 minutes and 8 seconds . on a single server",
    "the overhead is 8 minutes and 5 seconds where as the overhead to create the checkpoint is 9 minutes and 14 seconds which is higher than overheads on a single server and is expected .",
    "the average time taken for executing the job when one failure occurs includes the elapsed execution time ( 15 minutes for periodic failure and 31 minutes and 14 seconds for random failure ) until the failure occurred and the combination of the time for reinstating execution after the failures and the overhead time .",
    "for one periodic failure that occurs in one hour the penalty of execution when single server checkpointing is 62% more than executing without a failure ; in the case of a random failure that occurs in one hour the penalty is 89% more than executing without a failure .",
    "if five random failure occur then the penalty is 445% , requiring more than five times the time for executing the job without failures .",
    "centralised checkpointing with multiple servers requires more time than with a single server .",
    "this is due to the increase in the overhead time for creating checkpoints on multiple servers .",
    "hence , checkpointing with multiple servers requires 64% and 91% more time than the time for executing the job without any failures for one periodic and one random failure per hour respectively . on the other hand executing jobs when decentralised checkpointing on multiple servers is employed requires similar time to that taken by centralised checkpointing on a single server .",
    "the time for reinstating execution is higher than centralised checkpointing methods due to the time required for determining the server closest to the node that failed .",
    "however , the overhead times are lower than other checkpoint approaches since the server closest to the node that failed is chosen for creating the checkpoint which reduces data transfer times .",
    "the multi - agent approaches are proactive and therefore the average time taken for predicting single node failures are taken into account which is nearly 38 seconds .",
    "the time taken for reinstating execution after one periodic single node failure for the agent intelligence approach is 0.47 seconds and for the core intelligence approach is 0.38 seconds . since @xmath76 the core intelligence approach is selected . in this case",
    ", the core intelligence approach is faster than the agent intelligence approach in the total time it takes for executing the job when there is one periodic or random fault and when there are five faults that occur in the job .",
    "the multi - agent approaches only require one - fifth the time taken by the checkpointing methods for completing execution .",
    "this is because the time for reinstating and the overhead times are significantly lower than the checkpointing approaches .",
    "table 2 shows a comparison between centralised and decentralised checkpointing and the multi - agent approaches for a genome searching job that is executed on the placentia cluster for five hours .",
    "the checkpoint periodicity is once every one , two and four hours as shown in figure 17 . similar to table 1 periodic and random failures are simulated .",
    "figure 17(a ) shows the start and completion of the job without failures or checkpoints .",
    "when the checkpoint periodicity is one hour there are four checkpoints , @xmath7 , @xmath91 , @xmath6 and @xmath92 ( refer figure 17(b ) ) ; a periodic node failure is simulated after 14 minutes from a checkpoint and the average time at which a random node failure occurs is found to be 31 minutes and 14 seconds from a checkpoint for 5000 trials .",
    "when checkpoint periodicity is two hours there are two checkpoints , @xmath7 and @xmath91 ( refer figure 17(c ) ) ; a periodic node failure is simulated after 28 minutes from a checkpoint and the average time a random node failure occurs is found to be after 1 hour , 3 minutes and 22 seconds from a checkpoint for 5000 trials . when checkpoint periodicity is four hours there is only one checkpoint @xmath7 ( refer figure 17(d ) ) ; a periodic node failure is simulated after 56 minutes from a checkpoint and the average time at which a random failure occurs is found to be after 2 hours , 8 minutes and 47 seconds from each checkpoint for 5000 trials .",
    "similar to table 1 , in table 2 , the average time taken for reinstating execution , for the overheads and for executing the job from the start to finish with and without checkpoints is considered . the time to bring execution back to normal after a failure has occurred",
    "is referred to as reinstating time . the time to create checkpoints and transfer checkpoint data to the server",
    "is referred to as the overhead time .",
    "the execution of the job when one periodic and one random failure occurs per hour and when five random failures occur per hour is considered .    without checkpointing the genome searching job",
    "is run such that a human administrator monitors the job from its start until completion . in this case , if a node fails then the only option is to restart the execution of the job . each time the job fails and given that the administrator detected it using cluster monitoring tools as soon as the node failed approximately , then at least ten minutes are required for reinstating the execution . if a periodic failure occurred once every hour from the 14th minute from execution then there are five periodic faults .",
    "once a failure occurs the execution will always have to come back to its previous state by restarting the job .",
    "hence , the five hour job , with just one periodic failure occurring every hour will take over 21 hours . similarly ,",
    "if a random failure occurred once every hour ( average time of occurrence is 31 minutes and 14 seconds after execution starts ) , then there are five failure points , and over 23 hours are required for completing the job .",
    "when five random failures occur each hour of the execution then more than 80 hours are required ; this is nearly 16 times the time for executing the job without a failure .",
    "centralised checkpointing on a single server and on multiple servers and decentralised checkpointing on multiple servers for one , two and four hour periodicity in the network are then considered in table 2 . for checkpointing methods when one hour frequency is chosen more than five times the time taken for executing the job without failures is required . when the frequency of checkpointing is every",
    "two hours then just under four times the time taken for executing the job without failures is required . in the case",
    "when the checkpoint is created every four hours just over 3 times the time taken for executing the job without failures is required .",
    "the multi - agent approaches on the other hand take only one - fourth the time taken by traditional approaches for the job with five single node faults that occur each hour .",
    "this is significant time saving for running jobs that require many hours for completing execution .",
    "the agent and core intelligence approaches are similar in at least four ways .",
    "firstly , the objective of both the approaches is to automate fault tolerance .",
    "secondly , the job to be executed is broken down into sub - jobs which are executed .",
    "thirdly , fault tolerance is achieved in both approaches by predicting faults likely to occur in the computing core .",
    "fourthly , technology enabling mobility is required by both the approaches to carry the sub - job or to push the sub - job from one core onto another .",
    "these important similarities enable both the agent and core approaches to be brought together to offer the advantages as a hybrid approach .    while there are similarities between the agent and core intelligence approaches there are differences that reflect in their implementation .",
    "these differences are based on : ( i ) where the job is situated - in the agent intelligence approach , the sub - job becomes the payload of an agent situated on a computing core . in the core intelligence approach ,",
    "the sub - job is situated on a virtual core , which is an abstraction of the computing core .",
    "( ii ) who predicts the failures - the agent constantly probes the compute core it is situated on and predicts failure in the agent approach , whereas in the core approach the virtual core anticipates the failure .",
    "( iii ) who reacts to the prediction - the agent moves onto another core and re - establishes its dependencies in the agent approach , whereas the virtual core is responsible for moving a sub - job onto another core in the core approach .",
    "( iv ) how dependencies are updated - an agent requires to carry information of its dependencies when it moves off onto another core and establishes its dependencies manually in the agent approach , whereas the dependencies of the sub - job on the core do not require to be manually updated in the core approach . ( v ) what view is obtained - in the agent approach , agents have a global view as they can traverse across the network of virtual cores , which is in contrast to the local view of the virtual cores in the core approach .",
    "the agent based approaches described in this paper offer a candidate solution for automated fault tolerance or in combination with checkpointing as proposed above offer a means of reducing current levels of human intervention .",
    "the foundational concepts of the agent and core based approaches were validated on four computer clusters using parallel reduction algorithms as a test case in this paper .",
    "failure scenarios were considered in the experimental studies for the two approaches .",
    "the effect of the number of dependencies of a sub - job being executed , the volume of data communicated across cores , and the process size are three factors considered in the experimental studies for determining the performance of the approaches .",
    "the approaches were studied in the context of parallel genome searching , a popular computational biology job , that fits the criteria of a parallel reduction algorithm .",
    "the experiments were performed for both periodic and random failures .",
    "the approaches were compared against centralised and decentralised checkpointing approaches . in a typical experiment in which the fault tolerant approaches are studied in between two checkpoints one hour apart when one random failure occurs , centralised and decentralised checkpointing on an average add 90% to the actual time for executing the job without any failures . on the other hand , in the same experiment",
    "the multi - agent approaches add only 10% to the overall execution time .",
    "the multi - agent approaches can not predict all failures that occur in the computing nodes .",
    "hence , the most efficient way of incorporating these approaches is to use them on top of checkpointing .",
    "the experiments demonstrate the feasibility of such approaches for computational biology jobs .",
    "the key result is that a job continues execution after a core has failed and the time required for reinstating execution is lesser than checkpointing methods .",
    "future work will explore methods to improve the accuracy of prediction as well as increase the number of faults that can be predicted using the multi - agent approaches . the challenge to achieve this will be to mine log files for predicting a wide range of faults and predict them as quickly as possible before the fault occurs .",
    "although the approaches can reduce human administrator intervention they can be used independently only if a wider range of faults can be predicted with greater accuracy .",
    "until then the multi - agent approaches can be used in conjunction with checkpointing for improving fault tolerance .",
    "the authors would like to thank the administrators of the compute resources at the centre for advanced computing and emerging technologies ( acet ) , university of reading , uk and the atlantic computational excellence network ( acenet ) .",
    "cappello f ( 2009 ) fault tolerance in petascale / exascale systems : current knowledge , challenges and research opportunities . international journal of high performance computing supplications , 23(3 ) : 212 - 226 .",
    "engelmann c , vallee gr , naughton t and scott sl ( 2009 ) proactive fault tolerance using preemptive migration .",
    "proceedings of the 17th euromicro international conference on parallel , distributed and network - based processing .",
    "252 - 257 .",
    "vallee g , engelmann c , tikotekar a , naughton t , charoenpornwattana k , leangsuksun c and scott sl ( 2008 ) a framework for proactive fault tolerance .",
    "proceedings of the 3rd international conference on availability , reliability and security .",
    "659 - 664 .",
    "fagg ge , gabriel e , chen z , angskun t , bosilca g , grbovic jp , dongarra j ( 2005 ) process fault - tolerance : semantics , design and applications for high performance computing .",
    "international journal for high performance applications and supercomputing .",
    "19(4 ) : 465 - 477 .",
    "yeh ch ( 2003 ) the robust middleware approach for transparent and systematic fault tolerance in parallel and distributed systems .",
    "proceedings of the international conference on parallel processing .",
    "61 - 68 .",
    "mourino jc , martin mj , gonzalez p and doallo r ( 2007 ) fault - tolerant solutions for a mpi compute intensive application .",
    "proceedings of the 15th euromicro international conference on parallel , distributed and network - based processing .",
    "246 - 253 .",
    "tsai j , kuo sy and wang ym ( 1998 ) theoretical analysis for communication - induced checkpointing protocols with rollback - dependency trackability .",
    "ieee transactions on parallel and distributed systems .",
    "9(10 ) : 963 - 971 .",
    "chtepen m , claeys fha , dhoedt b , de turuck f , demeester p and vanrolleghem pa ( 2009 ) adaptive task checkpointing and replication : toward efficient fault - tolerant grids .",
    "ieee transactions on parallel and distributed systems .",
    "20(2 ) : 180 - 190 .",
    "sankaran s , squyres jm , barrett b , sahay v , lumsdaine a , duell j , hargrove p and roman e ( 2005 ) the lam / mpi checkpoint / restart framework : system - initiated checkpointing",
    ". international journal of high performance computing applications .",
    "19(4 ) : 479 - 493 .",
    "hursey j , squyres jm , mattox ti , and lumsdaine a ( 2007 ) the design and implementation of checkpoint / restart process fault tolerance for open mpi .",
    "proceedings of the 12th ieee workshop on dependable parallel , distributed and network - centric systems .",
    "bowers kj , chow e , xu h , dror ro , eastwood mp , gregersen ba , klepeis jl , kolossvary i , moraes ma , sacerdoti fd , salmon jk , shan y and shaw de ( 2006 ) scalable algorithms for molecular dynamics simulations on commodity clusters .",
    "proceedings of the acm / ieee conference on supercomputing .",
    "je , tobias dj , brooks iii cl and singh uc ( 1991 ) vector and parallel algorithms for the molecular dynamics simulation of macromolecules on shared - memory computers .",
    "journal of computational chemistry .",
    "12(10 ) : 1270 - 1277 .",
    "oliner aj , sahoo rk , moreira je , gupta m ( 2005 ) perfomance implications of periodic checkpointing on large - scale cluster systems . proceedings of the 19th ieee international parallel and distributed processing symposium , 2005 .",
    "gabriel e , fagg ge , bosilca g , angskun t , dongarra j , squyres jm , sahay v , kambadur p , barrett b , lumsdaine a , castain rh , daniel dj , graham rl , woodall ts ( 2004 ) open mpi : goals , concept , and design of a next generation mpi implementation .",
    "proceedings of the 11th european pvm / mpi users group meeting .",
    "97 - 104 .",
    "chakravorty s , mendes cl and kale lv ( 2006 ) proactive fault tolerance in mpi applications via task migration .",
    "proceedings of ieee international conference on high performance computing , springer .",
    "lncs 4297 : 485 - 496 .",
    "janakiraman g , santos jr and subhraveti d ( 2005 ) cruz : application - transparent distributed checkpoint - restart on standard operating systems .",
    "proceedings of the international conference on dependable systems and networks .",
    "260 - 269 .",
    "valle g , charoenpornwattana k , engelmann c , tikotekar a , leangsuksun c , naughton t and scott sl ( 2008 ) a framework for proactive fault tolerance .",
    "proceedings of the 3rd ieee international conference on availability , reliability and security .",
    "659 - 664 .",
    "& predicting one single node failure & reinstating execution after one periodic single node failure & reinstating execution after one random single node failure & overheads related to one periodic single node failure & overheads related to one random single node failure & + & & & & & & without failures and checkpoints & with one periodic failure per hour & with one random failure per hour & with five random failures per hour +   + 1 hour periodicity & - & 00:14:08 & 00:14:08 & 00:08:05 & 00:08:05 & 01:00:00 & 01:37:13 & 01:53:27 & 05:27:15 +   + 1 hour periodicity & - & 00:14:08 & 00:14:08 & 00:09:14 & 00:09:14 & 01:00:00 & 01:38:22 & 01:54:36 & 05:33:00 +   + 1 hour periodicity & - & 00:15:27 & 00:15:27 & 00:06:44 & 00:06:44 & 01:00:00 & 01:37:11 & 01:53:25 & 05:27:05 +   + agent intelligence & 00:00:38 & 00:00:0.47 & 00:00:0.47 & 00:05:14 & 00:05:14 & & 01:06:17 & 01:06:17 & 01:32:27 + core intelligence & 00:00:38 & 00:00:0.38 & 00:00:0.38 & 00:04:27 & 00:04:27 & & 01:05:08 & 01:05:08 & 01:25:42 + hybrid intelligence & 00:00:38 & 00:00:0.38 & 00:00:0.38 & 00:04:27 & 00:04:27 & & 01:05:08 & 01:05:08 & 01:25:42 +        & predicting one single node failure & reinstating execution after one periodic single node failure & reinstating execution after one random single node failure & all overheads related to one periodic single node failure & all overheads related to one random single node failure & + & & & & & & without failures & with one periodic failure per hour & with one random failure per hour & with five random failures per hour +    cold restart with no failure tolerance & - & 00:10:00 & 00:10:00 & - & - & 05:00:00 & 21:15:17 & 23:01:00 & 80:31:04 +   + 1 hour periodicity & - & 00:14:08 & 00:14:08 & 00:08:05 & 00:08:05 & & 08:01:05 & 09:27:15 & 27:16:15 + 2 hour periodicity & - & 00:15:40 & 00:15:40 & 00:10:17 & 00:10:17 & & 07:41:51 & 07:58:38 & 19:53:10 + 4 hour periodicity & - & 00:16:27 & 00:16:27 & 00:11:53 & 00:11:53 & & 06:24:20 & 07:37:07 & 18:05:35 +   + 1 hour periodicity & - & 00:14:08 & 00:14:08 & 00:09:14 & 00:09:14 & & 08:07:14 & 09:33:23 & 27:45:00 + 2 hour periodicity & - & 00:15:40 & 00:15:40 & 00:12:22 & 00:12:22 & & 07:47:52 & 08:07:18 & 20:01:16 + 4 hour periodicity & - & 00:16:27 & 00:16:27 & 00:13:57 & 00:13:57 & & 07:04:28 & 07:52:27 & 18:45:22 +   + 1 hour periodicity & - & 00:15:27 & 00:15:27 & 00:06:44 & 00:06:44 & & 08:00:55 & 09:27:05 & 27:15:25 + 2 hour periodicity & - & 00:17:23 & 00:17:23 & 00:09:46 & 00:09:46 & & 07:40:18 & 07:57:36 & 19:48:00 + 4 hour periodicity & - & 00:18:33 & 00:18:33 & 00:13:03 & 00:13:03 & & 06:27:36 & 07:40:23 & 18:21:55 +   + 1 hour periodicity & & & & 00:05:14 & 00:05:14 & & 05:31:14 & 05:31:14 & 07:37:44 + 2 hour periodicity & & & & 00:06:38 & 00:06:38 & & 05:20:34 & 05:20:34 & 06:42:41 + 4 hour periodicity & & & & 00:07:41 & 00:07:41 & & 05:16:27 & 05:16:27 & 05:39:16 +   + 1 hour periodicity & & & & 00:04:27 & 00:04:27 & & 05:26:13 & 05:26:13 & 07:11:37 + 2 hour periodicity & & & & 00:05:37 & 00:05:37 & & 05:16:22 & 05:16:22 & 06:22:34 + 4 hour periodicity & & & & 00:06:29 & 00:06:29 & & 05:13:32 & 05:13:32 & 05:31:21 +"
  ],
  "abstract_text": [
    "<S> background : large - scale biological jobs on high - performance computing systems require manual intervention if one or more computing cores on which they execute fail . </S>",
    "<S> this places not only a cost on the maintenance of the job , but also a cost on the time taken for reinstating the job and the risk of losing data and execution accomplished by the job before it failed . </S>",
    "<S> approaches which can proactively detect computing core failures and take action to relocate the computing core s job onto reliable cores can make a significant step towards automating fault tolerance . </S>",
    "<S> + method : this paper describes an experimental investigation into the use of multi - agent approaches for fault tolerance . </S>",
    "<S> two approaches are studied , the first at the job level and the second at the core level . </S>",
    "<S> the approaches are investigated for single core failure scenarios that can occur in the execution of parallel reduction algorithms on computer clusters . </S>",
    "<S> a third approach is proposed that incorporates multi - agent technology both at the job and core level . </S>",
    "<S> experiments are pursued in the context of genome searching , a popular computational biology application . </S>",
    "<S> + result : the key conclusion is that the approaches proposed are feasible for automating fault tolerance in high - performance computing systems with minimal human intervention . in a typical experiment in which the fault tolerance is studied , centralised and decentralised </S>",
    "<S> checkpointing approaches on an average add 90% to the actual time for executing the job . </S>",
    "<S> on the other hand , in the same experiment the multi - agent approaches add only 10% to the overall execution time . </S>"
  ]
}