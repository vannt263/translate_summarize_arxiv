{
  "article_text": [
    "in data storage applications , besides resilience against disk failures and data protection against illegitimate users , the privacy of the data retrieval query may also be of concern .",
    "for instance , one may be interested in designing a storage system in which a file can be downloaded without revealing any information of which file is actually downloaded to the servers storing it .",
    "this form of privacy is usually referred to as _ private information retrieval _ ( pir ) .",
    "pir is important to , e.g. , protect users from surveillance and monitoring .",
    "pir protocols were first studied by chor _",
    "in@xcite , which introduced the concept of an @xmath1-server pir protocol , where a binary database is replicated among @xmath1 non - colluding servers ( referred to as nodes ) and the aim is to privately retrieve a single bit from the database while minimizing the total upload and download communication cost .",
    "the communication cost in @xcite was further reduced in @xcite . since then , coded pir schemes have been introduced , where the database is encoded ( as opposed to simply being replicated ) across several nodes @xcite . with the advent of distributed storage systems ( dsss ) , where the database is encoded and then stored on @xmath1 nodes ,",
    "there has been an increasing interest in implementing coded pir protocols for these systems .",
    "pir protocols for dsss , where data is stored using codes from two explicit linear code constructions ( one protocol for each code construction ) , were presented in @xcite , and information - theoretic lower bounds on the tradeoff between the storage cost and the retrieval cost were provided in @xcite . in @xcite ,",
    "the authors introduced pir codes which when used in conjunction with traditional @xmath1-server pir protocols allow to achieve pir on dsss .",
    "these codes achieve high code rates without sacrificing on the communication cost of an @xmath1-server pir protocol .",
    "recently , the authors in @xcite proposed a coded pir protocol for dsss that use maximum distance separable ( mds ) codes to store data .",
    "the proposed protocol achieves privacy in the presence of at most two colluding nodes .",
    "in addition , when there are no colluding nodes , the protocol achieves the lowest possible amount of downloaded data per unit of stored data , referred to as the _ communication price of privacy _ ( cpop ) .    in the storage community",
    ", it is well known that mds codes are inefficient in the repair of failed nodes .",
    "repair is essential to maintain the initial state of reliability of the dss . to address efficient repair , pyramid codes @xcite and locally repairable codes ( lrcs ) @xcite ,",
    "have been proposed .",
    "they achieve low locality , i.e. , a low number of nodes need to be contacted to repair a node . in this paper , for the scenario with no colluding nodes ( i.e. , a single spy node )",
    ", we extend the pir protocol from @xcite to a more general case where data is stored using an arbitrary systematic linear storage code of rate @xmath0 .",
    "we show that the cpop can be optimized using the structure of the code , and we provide an algorithm to search for an optimal ( in terms of the lowest possible cpop ) protocol .",
    "we present the optimal cpop that can be achieved for various linear codes , including lrcs and pyramid codes .",
    "interestingly , our numerical results show that non - mds codes can also achieve the lower bound on the cpop .",
    "( user ) at ( 5.5,10.5 ) ; iin 1,4,7,10 ( 5.5,1.5)(5.5,7.5 ) ; at ( 2.55,4.5 ) @xmath2 ; at ( 8.55,4.5 ) @xmath2 ; at ( 10,3.1 ) @xmath3 ; at ( 7,3.1 ) @xmath3 ; iin 2,3,3.5,4,4.5,5,5.5,6 at ( 10,i+0.5 ) ; at ( 7,i+0.5 ) ; ( f ) at ( 12.25,9.25 ) ; i / in 7.5/3,9/2,10/1 at ( 12.25,8.85 ) ; ( ell ) at ( 10,6 ) ; ( ell.east ) to[in=270,out=0 ] ( f.south ) ;    ( 6,2)rectangle(8,7.5 ) ; at ( 7,4.5 ) ;    ( 0,0.5)rectangle(1.5,1.5 ) ; ( 0,0.5)rectangle(1.5,0.75 ) ; ( 2,0.25)rectangle(2.65,1.5 ) ; ( 2,0.35)rectangle(2.65,1.4 ) ; ( 2.325,0.65 ) circle ( 1pt ) ; ( 0.65,0.25)rectangle(0.85,0.5 ) ; ( 0.5,0.25)(1,0.25 ) ;    ( n1.east )  ( user.south west ) ; ( n4.east )  ( user.south ) ; ( n7.east )  ( user.south ) ; ( n10.east )  ( user.south east ) ; at ( n1.east ) @xmath4 ; at ( n4.east ) @xmath5 ; at ( n7.east ) @xmath6 ; at ( n10.east ) @xmath7 ;    at ( user.south west ) @xmath8 ; at ( user.south ) @xmath9 ; at ( user.south ) @xmath10 ; at ( user.south east ) @xmath11 ;    ( 0,2)node[below]@xmath12 systematic nodes(5,2 ) ; ( 6,2)node[below]@xmath13 parity nodes(11,2 ) ; at ( 5.5,1 ) ( a ) ; at ( 12.25,11.5 ) ( b ) ; at ( 5.5,11.5 ) ( c ) ;    -3ex    we consider a dss that stores @xmath14 files @xmath15 , where each file @xmath16 $ ] , @xmath17 , is a @xmath18 matrix over @xmath19 , with @xmath20 and @xmath21 being positive integers and @xmath22 some prime power .",
    "each file is divided into @xmath20 stripes ( blocks ) and encoded using a linear code as follows .",
    "let @xmath23 , @xmath24 , be a message vector ( corresponding to the @xmath25-th row of @xmath26 ) that is encoded by an @xmath27 linear code @xmath28 , having _ subpacketization _",
    "@xmath21 , into a length-@xmath1 codeword @xmath29 , where @xmath30 .",
    "when @xmath31 , the code @xmath28 is referred to as a _ scalar _ code .",
    "otherwise , the code is called a _ vector _ code @xcite .",
    "the @xmath32 generated codewords @xmath33 are then arranged in the array @xmath34 of dimension @xmath35 , where @xmath36 denotes the transpose of its argument and @xmath37 denotes the concatenation of column vectors @xmath38 . for a given column @xmath39 of @xmath40 ,",
    "we denote the vector @xmath41 as a coded chunk pertaining to file @xmath42 .",
    "then the @xmath14 coded chunks in column @xmath39 are stored on the @xmath39-th node as shown in [ fig : system model](a ) .",
    "we also assume that the @xmath27 code @xmath43 is systematic and that the first @xmath12 code symbols of @xmath33 are message symbols .",
    "accordingly , we say that the first @xmath12 nodes are systematic nodes and the remaining nodes are parity nodes .",
    "we consider a dss where any single node may act as a spy node .",
    "let @xmath44 denote the spy node in the dss .",
    "the role of the spy node is to determine which file , @xmath42 , is accessed by the user .",
    "we assume that the user does not know @xmath45 , since otherwise it can trivially achieve pir by avoiding contacting the spy node .",
    "in addition , the remaining non - spy nodes do not collaborate with the spy node . to retrieve file @xmath46 from the dss",
    ", the user sends a @xmath47 matrix query @xmath48 $ ] over @xmath19 to the @xmath39-th node for all @xmath49 . depending on the queries received , node @xmath39 sends the length-@xmath50 column vector @xmath51 referred to as the response vector , back to the user as illustrated in [ fig : system model](c ) .",
    "the following definition shows how such a scheme can achieve perfect information - theoretic pir .",
    "consider a dss with @xmath1 nodes storing @xmath14 files in which a node @xmath44 acts as a spy .",
    "a user who wishes to retrieve the @xmath42-th file sends the queries @xmath52 , @xmath53 , to all storage nodes , which return the responses @xmath54 .",
    "this scheme achieves perfect information - theoretic pir if and only if    [ def : cond ] @xmath55    where @xmath56 denotes the entropy function .",
    "queries satisfying [ def : cond1 ] ensure that the spy node is not able to determine which file is being downloaded by the user .",
    "the recovery constraint in [ def : cond2 ] ensures that the user is able to recover the requested file from the responses sent by the dss .",
    "the efficiency of a pir scheme is defined as the total amount of downloaded data per unit of retrieved data .",
    "the cpop of a pir scheme , denoted by @xmath57 , is the total amount of downloaded data per unit of retrieved data , @xmath58    it was shown in ( * ? ?",
    "3 ) that the cpop for a dss with a single spy node is lowerbounded by @xmath59 , where @xmath60 is the rate of the linear code used to store the data in the dss . in the case of more than one spy node , an explicit lower bound is currently unknown .",
    "in this section , we present a pir scheme for a dss where any node may be a spy node and there are no colluding nodes .",
    "the dss uses an @xmath27 systematic linear code over gf@xmath61 , of rate @xmath62 and subpacketization @xmath21 .",
    "the code is defined by its parity - check matrix , @xmath63 , of size @xmath64 , and its minimum distance is denoted by @xmath65 . since the code is systematic , @xmath63 can be written as @xmath66 , where @xmath67 is an @xmath68 identity matrix and @xmath69 is an @xmath70 parity matrix . in the following ,",
    "let @xmath71 denote the minimum distance of the @xmath72 code , denoted by @xmath73 , defined by the parity - check matrix @xmath74 .",
    "we choose @xmath75 and design the @xmath1 queries as @xmath76 where @xmath77 $ ] is a @xmath78 matrix whose elements @xmath79 are chosen independently and uniformly at random from gf@xmath61 , and @xmath80 $ ] is a @xmath81 deterministic matrix over @xmath82 .",
    "note that each @xmath83 query matrix @xmath84 represents @xmath12 subqueries , where each subquery corresponds to a row of @xmath84 , and where @xmath85 means that the @xmath39-th symbol in node @xmath86 is accessed by the @xmath25-th subquery of @xmath84 .",
    "let @xmath87 $ ] be a @xmath88 binary matrix , where @xmath89 represents the @xmath25-th subquery of the @xmath39-th query accessing a message symbol .",
    "the design of @xmath90 depends on the structure of @xmath91 .",
    "matrix @xmath91 must satisfy the following conditions .",
    "= 1.5em    the user should be able to recover @xmath20 unique symbols of the requested file @xmath92 from the @xmath25-th subquery of all @xmath12 queries , i.e. , each row of @xmath91 should have exactly @xmath20 ones .",
    "[ item:1 ]    the user should be able to recover @xmath20 unique symbols of the requested file @xmath46 from each query ( consisting of @xmath12 subqueries ) , i.e. , each column in @xmath91 should have @xmath20 ones .",
    "[ item:2 ]    the user should be able to recover all @xmath93 symbols of the requested file @xmath46 .",
    "this means that all rows of @xmath91 ( considered here as length-@xmath12 erasure patterns , with a one indicating an erasure ) should be correctable by a maximum likelihood ( ml ) decoder for the @xmath72 code @xmath73 on the binary erasure channel ( bec ) , i.e. , the rows of @xmath91 considered as erasure patterns are ml - correctable by @xmath73 .",
    "[ item:3 ]    from conditions 1 ) and 2 ) it follows that @xmath91 is a regular matrix with @xmath20 ones in each row and column .",
    "condition 3 ) ensures the recovery condition ( see ( [ def : cond2 ] ) ) .",
    "details are given in the proof of [ th : pir ] .",
    "given @xmath91 , @xmath90 has the following structure @xmath94 where @xmath95 denotes the @xmath96 all - zero matrix and @xmath97 is a @xmath98 binary matrix . for @xmath99 , @xmath100 where @xmath101 is an arbitrary permutation of size @xmath102 with a fixed point at zero ,",
    "i.e. , @xmath103 , @xmath104 , @xmath105 , is the @xmath106-th @xmath20-dimensional unit vector , i.e. , a length-@xmath20 weight-@xmath107 binary vector with a single @xmath107 at the @xmath106-th position , @xmath108 is the all - zero vector of length @xmath20 , and @xmath109 where @xmath110 and @xmath111 for @xmath112 , @xmath113 . in the following lemma , we show that such a construction of the queries ensures that the _ privacy _ condition [ def : cond1 ] is satisfied .",
    "[ lem : privacy ] consider a dss that uses an @xmath27 linear code with subpacketization @xmath21 to store @xmath14 files , each divided into @xmath20 stripes , and assume the privacy model with a single spy node .",
    "then , the queries @xmath52 , @xmath53 , designed as in [ eq : query_design ] satisfy @xmath114 , where @xmath44 is the spy node .",
    "the queries @xmath52 , @xmath115 , are a sum of a random matrix @xmath116 and a deterministic matrix @xmath117 .",
    "the resulting queries have elements that are independently and uniformly distributed at random from gf@xmath61 .",
    "the same holds for the remaining queries as they are equal to @xmath116 .",
    "hence , any @xmath52 obtained by the spy node is statistically independent of @xmath42 .",
    "this ensures that @xmath114 .    in order to show that the proposed pir protocol achieves perfect information - theoretic pir",
    ", it remains to be proved that from the responses @xmath54 in [ eq : response ] sent by the nodes back to the user , one can recover the requested file , i.e. , that the constructed pir scheme satisfies the _ recovery _ condition in [ def : cond2 ] .",
    "we call each symbol of the response @xmath54 a subresponse symbol generated from the corresponding subquery .",
    "[ th : pir ] consider a dss that uses an @xmath27 linear code with subpacketization @xmath21 to store @xmath14 files , each divided into @xmath20 stripes . in order to retrieve the file @xmath46 , @xmath17 , from the dss",
    ", the user sends the queries @xmath52 , @xmath53 , in [ eq : query_design ] to the @xmath1 storage nodes .",
    "then , for the responses @xmath54 in [ eq : response ] received by the user , @xmath118 .",
    "see appendix .",
    "[ th : pir ] generalizes ( * ? ? ?",
    "* th .  1 ) to any linear code with rate @xmath119",
    ". we remark that for the theorem to hold there is an implicit assumption that the three requirements for the matrix @xmath91 mentioned above are all satisfied ( @xmath91 is used in the construction of the queries @xmath52 ) .",
    "thus , the parameter @xmath20 ( which is not explicitly mentioned in the theorem ) has to be carefully selected such that a @xmath20-regular matrix @xmath91 ( satisfying the third requirement ) actually exists . in the following corollary",
    ", we provide such a particular value of @xmath20 .",
    "[ cor : pir ] for @xmath120 , it holds that @xmath121 and the cpop becomes @xmath122",
    ".    follows directly from [ th : pir ] , since all erasure patterns of weight less than @xmath123 are ml - correctable , and @xmath124 follows also from @xmath75 .    [ ex:5_3_code ] consider a dss that uses a @xmath125 scalar ( @xmath31 ) linear code to store a single file by dividing it into @xmath20 stripes .",
    "the code is defined by the parity - check matrix @xmath126 to determine the value of the parameter @xmath20 , we compute the minimum distance @xmath127 of the @xmath128 linear code with parity - check matrix @xmath74 . from @xmath129",
    "it follows that @xmath130 .",
    "hence , from [ cor : pir ] , @xmath131 .",
    "let the file to be stored be denoted by the @xmath132 matrix @xmath133 $ ] , where the message symbols @xmath134 .",
    "then , @xmath135 the user wants to download the file @xmath136 from the dss and sends a query @xmath52 , @xmath137 , to the @xmath39-th storage node .",
    "the queries take the form shown in [ eq : query_design ] .",
    "for @xmath138 , we construct the matrix @xmath139 by choosing an appropriate @xmath91 .",
    "the only condition in the choice of @xmath91 is that it is @xmath20-regular .",
    "we choose @xmath140 and construct @xmath141 according to [ eq : delta_design ] .",
    "focusing on the first column of @xmath91 , we can see that the first two rows have a one in the first position .",
    "thus , we choose @xmath142 , @xmath143 , and @xmath144 , since @xmath145 , @xmath146 , and @xmath147 , and take the permutation @xmath148 , @xmath149 , and @xmath150 as @xmath151 to get @xmath152 in a similar fashion , we construct @xmath153 the queries @xmath52 are sent to the respective nodes and the responses @xmath154",
    "@xmath155 @xmath156 @xmath157 @xmath158 where @xmath159 and @xmath160 , with @xmath161 , are collected by the user . notice that each storage node sends back @xmath162 symbols .",
    "the user obtains the requested file as follows . knowing @xmath163 , the user obtains @xmath164 and @xmath165 from the first components of @xmath166 and @xmath167 .",
    "this allows the user to obtain @xmath168 and @xmath169 . in a similar fashion , knowing @xmath170 the user gets @xmath171 from the second component of @xmath167 , then uses this to obtain @xmath172 from the second component of @xmath166 .",
    "this allows the user to obtain @xmath173 and @xmath174 .",
    "similarly , knowing @xmath175 allows the user to get @xmath176 from the third component of @xmath166 . knowing @xmath176 allows the user to obtain @xmath177 from the third component of @xmath167 , which then allows to recover the symbols @xmath178 and @xmath179 . in this way , the user recovers all symbols of the file and hence recovers @xmath136 .",
    "note that @xmath180 , which is equal to the lower bound @xmath181 .",
    "in the previous section , we provided a construction of a pir scheme for dsss that uses an arbitrary linear systematic code to store data and showed that a cpop of @xmath182 is achievable while maintaining information - theoretic pir ( see [ th : pir ] and [ cor : pir ] ) . in this section",
    ", we provide an algorithm ( based on [ th : pir ] ) to further lower the cpop taking the structure of the underlying code into consideration .",
    "the algorithm is outlined in [ alg : cpop ] .",
    "@xmath183 + @xmath184 +    the main issues that need to be addressed are the efficient computation of the matrix @xmath91 and the efficient enumeration of the set of erasure patterns of a given weight @xmath20 that can be corrected under ml decoding of @xmath73 .",
    "such ml - correctable erasure patterns are binary vectors ( of length @xmath185 ) which can be ml - decoded on the bec when the positions corresponding to the entries @xmath107 are erased by the channel .",
    "these issues are addressed by the subprocedures ` computeerasurepatternlist`(@xmath186 ) and ` computematrix`(@xmath187 ) , in [ algcpop : subprocedure1,algcpop : subprocedure2 ] , respectively , of [ alg : cpop ] .",
    "they are discussed below in [ sec : computelist , sec : computee ] .",
    "we remark that the algorithm will always return @xmath188 , since initially @xmath189 .",
    "then , in the first iteration of the main loop , the list @xmath187 will contain all length-@xmath12 binary vectors of weight @xmath190 .",
    "thus , any vector that is shift - variant ( i.e. , the @xmath12 cyclic shifts are all different ) can be chosen for the first row of @xmath91 .",
    "the remaining rows of @xmath91 are obtained by cyclically shifting the first row ( the @xmath25-th row is obtained by cyclically shifting the first row @xmath25 times ) . in the particular case of @xmath28 being an mds code , @xmath191",
    ", the algorithm will do exactly one iteration of the main loop , and the overall pir scheme reduces to the one described in ( * ? ? ?",
    "iv ) .      computing a list of erasure patterns that are correctable under ml decoding for a given short code can be done using any ml decoding algorithm . for small codes",
    "@xmath73 , all length-@xmath12 binary vectors of weight @xmath20 that are ml - correctable can be found using an exhaustive search , while for longer codes a random search can be performed , in the sense of picking length-@xmath12 binary vectors of weight @xmath20 at random , and then verifying whether or not they are ml - correctable .",
    "alternatively , one can apply a random permutation @xmath151 to the columns of @xmath129 , apply the gauss - jordan algorithm on the resulting matrix to transform it into _ row echelon form _",
    ", collect a subset of size @xmath20 of the column indices of _ leading - one - columns _ , and finally apply the inverse permutation of @xmath151 to this subset of column indices .",
    "the leading - one - columns are the columns containing a _ leading one _ , where the first nonzero entry in each matrix row of a matrix in row echelon form is called a leading one",
    ". this will give the support set of an ml - correctable erasure pattern of weight @xmath20 that can be added to @xmath187 .",
    "finally , one can check whether all cyclic shifts of the added erasure pattern are ml - correctable or not and add the ml - correctable cyclic shifts to @xmath187 .",
    "given the list @xmath187 of erasure patterns that are correctable under ml decoding , we construct a @xmath192 matrix , denoted by @xmath193 $ ] , in which each row is one of these patterns .",
    "the problem is now to find a @xmath194 submatrix of constant column weight @xmath20 ( and constant row weight @xmath20 ) .",
    "this can be formulated as an integer program ( in the integer variables @xmath195 ) in the following way , @xmath196 a valid @xmath194 submatrix of @xmath197 is constructed from the rows of @xmath197 with corresponding @xmath198-values of one in any feasible solution of ( [ eq : lip ] ) .",
    "when @xmath199 is large , solving ( [ eq : lip ] ) may become impractical ( solving a general integer program is known to be np - hard ) , in which case one can take several random subsets of the list @xmath187 of some size , construct the corresponding matrices @xmath197 , and try to solve the program in ( [ eq : lip ] ) . finally , before solving ( [ eq : lip ] ) , one may check whether there are erasure patterns in @xmath187 with all its cyclic shifts ( assuming they are all different ) also in @xmath187 , in which case the corresponding submatrix of @xmath197 will be a valid @xmath194 matrix @xmath91 .",
    "we present optimized values for the cpop for different systematic linear codes .",
    "the results are tabulated in [ table_of_codes ] , where @xmath200 is the lower bound on the cpop taken from ( * ? ? ?",
    "* th .  5 ) , @xmath201 is the optimized value computed from [ alg : cpop ] , and @xmath202 .",
    "the code @xmath203 in the table is from [ ex:5_3_code ] , @xmath204 is an @xmath205 binary linear code with optimum minimum distance , while codes @xmath206 and @xmath207 are pyramid codes , taken from @xcite , of locality of @xmath208 and @xmath209 , respectively .",
    "@xmath210 is an lrc obtained from @xcite and has a locality of @xmath211 . in @xcite ,",
    "a construction of optimal ( in terms of minimum distance ) binary lrcs with multiple repair groups was given .",
    "in particular , in ( * ? ? ? * constr .",
    "3 ) , a construction based on array low - density parity - check ( ldpc ) codes @xcite was provided .",
    "the parity part ( or the @xmath69 matrix ) of the parity - check matrix @xmath63 of the optimal lrc is the parity - check matrix of an array - based ldpc code .",
    "the minimum distance of array ldpc codes is known for certain sets of parameters ( see , e.g. , @xcite , and references therein ) .",
    "codes @xmath212 and @xmath213 in [ table_of_codes ] are _ optimal _ lrcs based on array ldpc codes constructed using ( * ? ? ?",
    "* constr .  3 ) and having a locality of @xmath214 .    for all codes",
    ", @xmath201 is close to the lower bound on the cpop , @xmath215 .",
    "remarkably , the codes @xmath203 , @xmath206 , and @xmath207 achieve the lower bound on the cpop despite the fact that these codes are not mds codes .",
    "the remaining codes ( @xmath204 , @xmath210 , @xmath216 , and @xmath217 ) achieve a cpop of @xmath218 , which is the lowest possible value given the parameters of @xmath73 .",
    "the strict inequality is due to the fact that @xmath129 is not full rank for these codes .",
    "-2.0ex    @lccccc@ + [ -2.0ex ] code & @xmath219 & @xmath220 & @xmath221 & @xmath201 & @xmath215 +   + [ -2.0ex ] + [ -2.0ex ] @xmath222 ( [ ex:5_3_code ] ) & @xmath223 & @xmath224 & @xmath225 & @xmath225 & @xmath225 + @xmath226 & @xmath208 & @xmath208 & @xmath227 & @xmath228 & @xmath229 + @xmath230 pyramid & @xmath208 & @xmath208 & @xmath208 & @xmath224 & @xmath224 + @xmath231 lrc & @xmath211 & @xmath211 & @xmath208 & @xmath232 & @xmath233 + @xmath234 pyramid & @xmath211 & @xmath211 & @xmath235 & @xmath224 & @xmath224 + @xmath236 lrc & @xmath208 & @xmath209 & @xmath237 & @xmath238 & @xmath239 + @xmath240 lrc & @xmath241 & @xmath242 & @xmath243 & @xmath244 & @xmath245 +    -2ex",
    "we generalized the pir protocol proposed in @xcite for a dss with a single spy node and where data is stored using an mds code to the case where an arbitrary systematic linear code of rate @xmath119 is used to store data .",
    "we also presented an algorithm to optimize the cpop of the protocol .",
    "the optimization leads to a cpop close to its theoretical lower bound .",
    "interestingly , for certain codes , the lower bound on the cpop can be achieved .",
    "consider the @xmath106-th subresponse of each response @xmath54 . out of the @xmath12 subresponses generated from the systematic nodes , there are @xmath20 subresponses originating from a subset of systematic nodes @xmath246 , of the form @xmath247 where @xmath248 , @xmath249 , and @xmath250 is the interference symbol .",
    "the subresponses from the remaining @xmath251 systematic nodes in @xmath252 are @xmath253 where @xmath254 and @xmath255 is the interference symbol .",
    "it is trivial to see that [ eq : p1e1 ] and [ eq : p1e2 ] result in a system of linear equations that is underdetermined in the unknowns @xmath256 , @xmath257 , and @xmath258 . in order to retrieve the @xmath20 message symbols , we require the knowledge of the interference symbols @xmath256 ( see [ eq : p1e1 ] ) . the subresponses from the parity nodes",
    "are given by @xmath259 where @xmath260 and @xmath261 is the coefficient associated to the message symbol in the @xmath25-th node that is used in the weighted sum of the code ( parity ) symbol in the @xmath39-th node .",
    "@xmath262 is an interference symbol used in either [ eq : p1e1 ] or [ eq : p1e2 ] .",
    "we can interpret [ eq : p1e3 ] as a parity - check equation of the @xmath72 code @xmath73 , where the interference symbols @xmath262 form the message symbols .",
    "since the @xmath251 interference symbols @xmath257 from ( [ eq : p1e2 ] ) are known , [ eq : p1e3 ] reduces to @xmath263 solving the system of linear equations in [ eq : p1e4 ] in the unknowns @xmath262 , @xmath264 , is now just a decoding problem of the aforementioned code .",
    "since there are @xmath20 unknowns and [ eq : p1e4 ] corresponds to an ml - corretable erasure pattern ( from the third requirement for @xmath91 in [ sec : constr ] ) , [ eq : p1e4 ] becomes a full - rank linear system of equations .",
    "hence , knowing the interference symbols allows the recovery of @xmath20 _ unique _ ( from the first requirement for @xmath91 in [ sec : constr ] ) message symbols in the @xmath106-th subquery .",
    "combined with the second requirement for @xmath91 in [ sec : constr ] , it follows that all @xmath12 subqueries yield @xmath265 _ unique _ message symbols of the requested file @xmath46 , from which it follows that @xmath118 .",
    "a.  beimel , y.  ishai , e.  kushilevitz , and j .- f .",
    "raymond , `` breaking the @xmath266 barrier for information - theoretic private information retrieval , '' in _ proc .",
    "annual ieee symp .",
    "foundations comp .",
    "( focs ) _ , vancouver ,",
    "bc , canada , nov .",
    "2002 , pp . 261270 .",
    "n.  b. shah , k.  v. rashmi , and k.  ramchandran , `` one extra bit of download ensures perfectly private information retrieval , '' in _ proc .",
    "inf . theory ( isit ) _ , honolulu , hi , jun./jul .",
    "2014 , pp . 856860 .",
    "r.  tajeddine and s.  el rouayheb , `` private information retrieval from mds coded data in distributed storage systems , '' in _ proc .",
    "theory ( isit ) _ , barcelona , spain , jul .",
    "2016 , pp . 14111415 .    c.  huang , m.  chen , and j.  li , `` pyramid codes : flexible schemes to trade space for access efficiency in reliable data storage systems , '' in _ proc .",
    "net . comp . appl .",
    "( nca ) _ , cambridge , ma , jul .",
    "2007 , pp . 7986 .",
    "m.  sathiamoorthy , m.  asteris , d.  papailiopoulos , a.  g. dimakis , r.  vadali , s.  chen , and d.  borthakur , `` xoring elephants : novel erasure codes for big data , '' in _ proc .",
    "39th very large data bases endowment _ , trento , italy , aug .",
    "2013 , pp . 325336 ."
  ],
  "abstract_text": [
    "<S> we propose an information - theoretic private information retrieval ( pir ) scheme for distributed storage systems where data is stored using a linear systematic code of rate @xmath0 . </S>",
    "<S> the proposed scheme generalizes the pir scheme for data stored using maximum distance separable codes recently proposed by tajeddine and el rouayheb for the scenario of a single spy node . </S>",
    "<S> we further propose an algorithm to optimize the communication price of privacy ( cpop ) using the structure of the underlying linear code . </S>",
    "<S> as an example , we apply the proposed algorithm to several distributed storage codes , showing that the cpop can be significantly reduced by exploiting the structure of the distributed storage code . </S>"
  ]
}