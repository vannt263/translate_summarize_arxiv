{
  "article_text": [
    "a word of the form @xmath6 is called a square , which is the simplest type of repetition . the study on repetitions in words",
    "has been started at least as early as thue s work @xcite in the early 1900 s . since then , there are many work in the literature on finding repetitions ( periodicities ) , which is an important topic in combinatorics on words . in the early 1980 s ,",
    "slisenko @xcite described a linear - time algorithm for finding all syntactically distinct maximal repetitions in a word .",
    "crochemore @xcite , main and lorentz described a linear - time algorithm for testing whether a word contains a square and thus testing whether a word contains any repetition . since a word @xmath3 of length @xmath7 may have @xmath8 square factors ( for example , let @xmath9 ) , usually only primitively - rooted or maximal repetitions are computed .",
    "crochemore @xcite described an @xmath10-time algorithm for finding all maximal primitively - rooted integer repetitions , where maximal means that a @xmath1th power can not be extend by either direction to obtain a @xmath11th power . the @xmath10-time is optimal since a word @xmath3 of length @xmath7 may have @xmath12 primitively - rooted repetitions ( for example , let @xmath3 be a fibonacci word ) .",
    "apostolico and preparata described an @xmath10-time algorithm for finding all right - maximal repetitions , which means a repetition @xmath13 can not be extend to the right to obtain a repetition @xmath14 such that @xmath15 .",
    "main and lorentz described an @xmath10-time algorithm for finding all maximal repetitions .",
    "gusfield and stoye also described several algorithms on finding repetitions .",
    "we know that both the number of distinct squares and the number of maximal repetitions ( also called runs ) in a words are in @xmath16 .",
    "this fact suggests the existence of linear - time algorithms on repetitions that are distinct ( respectively , maximal ) .",
    "main @xcite described a linear - time algorithm for finding all leftmost occurrences of distinct maximal repetitions .",
    "kolpakov and kucherov described a linear - time algorithm for finding all occurrences of maximal repetitions . for a most - recently survey on the topic of repetitions in words ,",
    "see the paper .    instead of considering repetitions from a global point of view , there are works on a local point of view , which means repetitions at each positions in a word .",
    "kosaraju in a five - pages extended abstract @xcite briefly described a linear - time algorithm for finding the minimal square starting at each position of a given word .",
    "his algorithm is based on an alternation of weiner s linear - time algorithm for suffix - tree construction . in the same flavor ,",
    "duval , kolpakov , kucherov , lecroq , and lefebvre described a linear - time algorithm for finding the local periods ( squares ) centered at each position of a given word .",
    "there may be @xmath17 primarily - rooted maximal repetitions starting at the same position ( for example , consider the left - most position in fibonacci words ) .",
    "so , neither of the two results can be obtained with the same efficiency by directly applying linear - time algorithms on finding maximal - repetitions .    in this paper , we generalize kosaraju s algorithm @xcite for computing minimal squares . instead of squares , we discuss arbitrary @xmath1th powers and show kosaraju s algorithm with proper modification can in fact compute minimal @xmath1th powers . using the same construction of suffix trees , for arbitrary integers @xmath4 and @xmath5 ,",
    "we describe in details a @xmath0-time algorithm for finding the minimal @xmath1th power , with period of length larger than @xmath2 , starting at each position of a given word @xmath3 . `` _ _ the absence of a complete proof prevents the comprehension of the algorithm _ _ ( kosaraju s algorithm ) _ in full details  _ . '' in this paper , we provide a complete proof of correctness of the modified algorithm . at the end ,",
    "we show how this @xmath0-time algorithm can be used as a sub - routine to detect certain types of pseudo - patterns in words , which is the original intention why we study this algorithm .",
    "let @xmath18 be a word .",
    "the _ length _ @xmath19 of @xmath3 is @xmath7 .",
    "a _ factor _ @xmath20 of @xmath3 is the word @xmath21 if @xmath22 ; otherwise @xmath20 is the _ empty word _ @xmath23 . in particular ,",
    "@xmath24 and @xmath25 are called _ prefix _ and _ suffix _ , respectively .",
    "the _ reverse _ of @xmath3 is the word @xmath26 .",
    "word @xmath3 is called a _",
    "@xmath1th power _ for integer @xmath4 if @xmath27 for some non - empty word @xmath28 , where @xmath1 is called _ exponent _ and @xmath28 is called _",
    "period_. the @xmath29nd power and the @xmath30rd power are called _ square _ and _ cube _ , respectively .    the _ minimal ( local ) period _ @xmath31 larger than @xmath2 of word @xmath3 with respect to exponent @xmath1 is the smallest integer @xmath32 such that @xmath33 is a @xmath1th power , if there is such one , or otherwise @xmath34 .",
    "for example , @xmath35 and @xmath36 .",
    "the following results follow naturally by the definition of minimal period .",
    "[ lemma : mpexpd ] let @xmath4 and @xmath5 be two integers and @xmath37 be a word .",
    "if @xmath38 , then for any word @xmath39 , @xmath40    suppose @xmath41 .",
    "we can write @xmath42 for some words @xmath43 with @xmath44",
    ". then @xmath45 and thus @xmath13 is also a prefix of @xmath37 .",
    "so @xmath46 , which contradicts to our hypothesis .",
    "so @xmath47 .",
    "on the other hand , if any word @xmath13 is a prefix of @xmath37 , the word @xmath13 is also a prefix of @xmath48 .",
    "so @xmath49 .",
    "therefore , @xmath50 .",
    "[ lemma : mpshrk ] let @xmath4 and @xmath5 be two integers and @xmath37 be a word .",
    "for any word @xmath39 , @xmath51    suppose @xmath38 . by lemma  [ lemma : mpexpd ]",
    ", it follows that @xmath50 and @xmath52 .",
    "so , by contraposition , @xmath53 when @xmath54 . on the other hand , when @xmath55 , we can write @xmath56 for some words @xmath57 such that @xmath58",
    ". then @xmath13 is also a prefix of @xmath37 and thus @xmath38 .",
    "so , by lemma  [ lemma : mpexpd ] , @xmath59 .",
    "the _ right minimal period array _ of word @xmath3 with respect to exponent @xmath1 and period larger than @xmath2 is defined by @xmath60=mp_s^k(\\subw{w}{i}{n})$ ] for @xmath61 and the _ left minimal period array _ of word @xmath3 with respect to exponent @xmath1 and period larger than @xmath2 is defined by @xmath62=mp_s^k(\\subw{w}{1}{i}^r)$ ] for @xmath61 .",
    "for example , @xmath63,\\textrm { and } \\\\    { } _ 0 ^ 2lmp_{\\tt0100101001}&=[+\\infty,+\\infty,+\\infty,1,+\\infty,3,2,2,1,5].\\end{aligned}\\ ] ]    a _ suffix tree _ @xmath64 for a word @xmath65 is a rooted tree with each edge labeled by a non - empty word that satisfies    _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 1 .",
    "each internal node , other than the root , has at least two children , 2 .",
    "each label on edge from the same node begins with a different letter , and 3 .",
    "there are exactly @xmath7 leaves @xmath66 and @xmath67 for @xmath61 , _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _    where character @xmath68 is a special letter not in the alphabet of @xmath3 and function @xmath69 is defined at each node @xmath39 as the concatenation of the labels on edges along the path from the root to the node @xmath39 . by definition , a suffix tree for a word @xmath3 is unique up to renaming nodes and reordering among children .",
    "a suffix tree for the word @xmath70 is illustrated in figure  [ figure : suffixtree ] .",
    "for more details on suffix tree , see the book ( * ? ? ?",
    "@xmath71_{\\tt0}\\ar[dr]^{\\tt1 } & & \\\\    & & + \\infty\\ar[dl]_{\\tt01}\\ar[dr]^{\\tt1 } & & + \\infty\\ar[dr]^{\\tt0}\\ar[d]_{\\$ } & \\\\    & 1\\ar[dl]_{\\tt01001\\$}\\ar[d]^{\\$ } & & + \\infty\\ar[dl]_{\\tt0}\\ar[d]^{\\$ } & + \\infty , leaf_{10 } & + \\infty\\ar[dl]_{\\tt01}\\ar[d]^{\\tt1001\\$ } \\\\    1,leaf_3 & 1,leaf_8 & + \\infty\\ar[dl]_{\\tt01}\\ar[d]^{\\tt1001\\$ } & + \\infty ,",
    "leaf_9 & + \\infty\\ar[dl]_{\\tt01001\\$}\\ar[d]^{\\$ } & 2,leaf_5 \\\\    & + \\infty\\ar[dl]_{\\tt01001\\$}\\ar[d]^{\\$ } & 2,leaf_4 & + \\infty , leaf_2 & + \\infty , leaf_7 & \\\\",
    "3,leaf_1 & + \\infty , leaf_6 & & & &    } \\ ] ]    we denote by @xmath72 , or more specifically by @xmath73 , the father of node @xmath39 in the tree @xmath64 .",
    "node @xmath28 is called an _ ancestor _ of node @xmath74 if either @xmath28 is the father of @xmath74 or @xmath28 is an ancestor of @xmath74 s father .",
    "when node @xmath28 is an ancestor of node @xmath74 , node @xmath74 is called a _ descendent _ of node @xmath28 . if node @xmath28 is a common ancestor of nodes @xmath74 and @xmath75 in @xmath64 , by the definition of suffix tree , then @xmath76 is a common prefix of @xmath77 and @xmath78 .",
    "we denote by @xmath79 the _ node - depth _ of node @xmath39 in @xmath64 , which is the number of edges along the path from the root to the node @xmath39 .",
    "the node - depth of the root is @xmath80 and , for any node @xmath39 , the node - depth @xmath79 is less than or equal to @xmath81 , which is called the _ depth _ of node @xmath39 in @xmath64 and is denoted by @xmath82 .",
    "we denote by @xmath83 the lowest common ancestor of nodes @xmath37 and @xmath39 in a tree , which is the common ancestor of @xmath37 and @xmath39 with the largest node - depth . after a linear - time preprocessing ,",
    "the lowest common ancestor of any pair of nodes in a tree can be found in constant time .",
    "[ lemma : lastedge ] let @xmath64 be the suffix tree of word @xmath3 .",
    "if @xmath66 and @xmath84 are two leaves such that @xmath85 , then the label on the edge from @xmath86 to @xmath66 is not longer than the label on the edge from @xmath87 to @xmath84 .",
    "let @xmath88 and words @xmath89 be the labels on the edges from @xmath86 to @xmath66 and from @xmath87 to @xmath84 , respectively .",
    "we now prove @xmath90 .",
    "since @xmath85 , by definitions , we can write @xmath91 for some word @xmath28 and thus @xmath92 if @xmath93 , then @xmath94 . otherwise , we can write @xmath95 for some word @xmath74 and thus @xmath96",
    ". let @xmath97 be another leaf that is a descendent of @xmath87 .",
    "then we can write @xmath98 for some word @xmath75 such that @xmath75 and @xmath99 are different at the first letter . the word @xmath100 is a suffix of @xmath3 and the longest common prefix of the two words @xmath95 and @xmath100 is @xmath74 .",
    "so there is an ancestor @xmath39 of @xmath66 such that @xmath101 and thus @xmath102 . but @xmath103 .",
    "therefore , @xmath90 .",
    "a suffix tree for a given word @xmath3 can be constructed in linear time @xcite .",
    "both kosaraju s algorithm @xcite for computing @xmath104 and our modification on his algorithm for computing @xmath105 and @xmath106 for arbitrary @xmath4 and @xmath5 are based on weiner s linear - time algorithm @xcite for constructing the suffix tree @xmath64 .",
    "so we briefly describe weiner s algorithm here .",
    "weiner s algorithm extends the suffix tree by considering the suffix @xmath107 ,  , @xmath108 , @xmath109 and adding @xmath110 ,  , @xmath111 , @xmath112 into the suffix tree incrementally . after each extension by @xmath113 ,",
    "the new tree is precisely the suffix tree @xmath114 .",
    "the algorithm is outlined in algorithm  [ figure : weiner ] . by using indicator vectors and inter - node links , the total time to locate each proper position @xmath74 at lines",
    "910 can be in @xmath16 . since how to locate the @xmath74",
    "is not quite relevant to the algorithm we will present later , we omit the details here .",
    "( function ) construct @xmath115 ( function ) find the proper position @xmath74 in @xmath116 to insert the new node @xmath66 if needed , split an edge @xmath117 to two @xmath118 by adding a new node @xmath74 create and label the edge @xmath119 by @xmath120    once a node @xmath39 is created , although the node - depth @xmath79 may change in later extensions by splitting on an edge in the path from the root to node @xmath39 , the depth @xmath82 will never change in later extensions in a suffix tree .",
    "so we assume the depth @xmath82 is also stored on the node @xmath39 in the suffix tree and can be accessed in constant time .",
    "the update of @xmath82 only happens when @xmath39 is created and can be computed by @xmath121 , where @xmath37 is the label on the edge from @xmath72 to @xmath39 .",
    "so computing and storing the information @xmath122 will not increase the computational complexity of the construction of a suffix tree .",
    "first we show that how the minimal period @xmath31 can be obtained from the suffix tree @xmath64 in linear time @xmath124 .",
    "in particular , if @xmath125 and @xmath3 satisfies @xmath126 , then the algorithm compute @xmath31 in constant time , which is one of the essential idea in the computing of @xmath105 and @xmath123 .",
    "[ lemma : mpcret ] let @xmath4 and @xmath5 be two integers and @xmath64 be the suffix tree of a word @xmath3 . then @xmath31 can be computed in @xmath127 time .",
    "let @xmath88 .",
    "there is an @xmath128-time algorithm to compute @xmath31 .",
    "first along the path from the @xmath112 to the root , we find the highest ancestor @xmath129 of @xmath112 such that @xmath130 .",
    "since @xmath131 , node @xmath129 always has a father and @xmath132 .",
    "then we find the least common ancestor of @xmath112 with any other leaf @xmath66 that is a descendent of @xmath129 and check whether the equation @xmath133 holds . if no @xmath66 satisfies (",
    "[ equation : mp ] ) , then @xmath134 ; otherwise , @xmath135 , where @xmath136 is the smallest @xmath136 that satisfies ( [ equation : mp ] ) . the algorithm is presented in algorithm  [ figure : mp ] .",
    "( function ) @xmath137 preprocessing the tree rooted at @xmath129 for @xmath138    now we prove the correctness of this algorithm .",
    "first we observe that @xmath139 for some non - empty word @xmath28 , if and only if the common prefix of @xmath109 and @xmath140 is of length at least @xmath141 , which means the leaf @xmath142 satisfies ( [ equation : mp ] ) .",
    "furthermore , @xmath143 , if and only if @xmath142 satisfies @xmath144 , which means that @xmath142 is a descendent of @xmath129 .",
    "( since @xmath129 has two descendents , @xmath129 is not a leaf and thus @xmath145 . )",
    "so each time line  8 is executed , if and only if there is a corresponding prefix of @xmath3 that is a @xmath1th power with period of length @xmath146 .",
    "the minimal length of such period , if any , is returned and the correctness is ensured .",
    "now we discuss the computational complexity of this algorithm .",
    "let @xmath147 be the sub - tree rooted at @xmath129 and @xmath148 be the number of leaves in @xmath147 . by the definition of suffix tree , each internal node has at least two children in @xmath147 and",
    "thus the number of internal nodes in @xmath147 is less than @xmath148 .",
    "furthermore , the node - depth of any leaf in @xmath147 is also less than @xmath148 .",
    "so the computational time of the algorithm is linear in @xmath148 .",
    "( for details on constant - time algorithm finding lowest common ancestor with linear - time preprocessor , see . ) in order to show the computation is in @xmath149-time , it remains to see @xmath150 .",
    "we prove @xmath151 by contradiction .",
    "suppose @xmath152 .",
    "since there are @xmath148 leaves @xmath153 with the same ancestor @xmath129 , there are @xmath148 factors of length @xmath154 such that @xmath155 since @xmath156 for @xmath157 , by the pigeon hole principle , there are two indices , say @xmath158 and @xmath159 , such that @xmath160",
    ". then the common prefix of @xmath161 and @xmath162 is of length at least @xmath163 , which means there is a prefix of @xmath164 that is a @xmath1th power with period of length @xmath165",
    ". then @xmath166 , a contradiction .",
    "so the number of leaves in @xmath147 is @xmath167 and thus the algorithm is in @xmath149-time .    for a word @xmath65 , by definitions , the left minimal period array and the right minimal period array satisfy the equation @xmath168={}_s^krmp_{w^r}[n+1-i],\\textrm { for } 1\\leq i\\leq n.\\ ] ]",
    "so the left minimal period array of @xmath3 can be obtained by computing the right minimal period array of @xmath169 .",
    "hence in what follows we only discuss the algorithm for computing the right minimal period array of @xmath3 ; the algorithm for computing the left minimal period array of @xmath3 follows immediately .",
    "a _ suffix tree with minimal periods _ @xmath170 for a word @xmath3 is a suffix tree @xmath64 with a function @xmath171 , which is defined at each node @xmath39 such that @xmath172 . by definitions ,",
    "once @xmath173 is created for a word @xmath65 , the @xmath105 can be obtained by reading the value @xmath171 at each leaf in order as follows : @xmath174.\\ ] ] the suffix tree with minimal periods satisfies the following property .",
    "[ lemma : mpbond ] let @xmath4 and @xmath5 be two integers and @xmath3 be a word . for any node @xmath39 in the suffix tree with minimal periods @xmath173 such that @xmath175 , then either @xmath176 or @xmath177 is between @xmath178    let @xmath39 be a node in @xmath173 such that @xmath175 . since @xmath179 is a prefix of @xmath180 and @xmath175 , by lemma  [ lemma : mpshrk ] , it follows that @xmath181 suppose @xmath182 .",
    "the common prefix of @xmath183 and @xmath184 is of length at least @xmath185 .",
    "then @xmath186 , since @xmath72 is the lowest ancestor of @xmath39 in @xmath173 .",
    "therefore , either @xmath176 or @xmath187 .    in what follows",
    ", we will show how to construct the @xmath173 for a word @xmath3 with fixed @xmath1 in linear time by a modified version of kosaraju s algorithm @xcite .",
    "kosaraju s algorithm constructs only @xmath188 but our modification can construct @xmath173 for arbitrary @xmath5 and @xmath189 .",
    "both algorithms are based on the alternation of weiner s algorithm @xcite for constructing suffix tree @xmath64 .",
    "our modified algorithm for computing @xmath173 is illustrated in algorithm  [ figure : rmp ] , where the added statements for updating @xmath171 are underlined .",
    "in addition to the suffix tree @xmath190 , auxiliary suffix tree @xmath191 for some proper indices @xmath192 is used .",
    "the main idea is that we use the classic weiner s algorithm to construct the underlying suffix tree @xmath193 step by step . at each step , at most two nodes are created and we update the @xmath194 values on those new nodes . one possible new node @xmath74 is between two nodes @xmath195 when a split on the edge from @xmath28 to @xmath75 happens .",
    "since @xmath196 is already computed , we update @xmath197 directly .",
    "the other new node is the new leaf @xmath66 .",
    "when @xmath198 , we update @xmath199 directly .",
    "otherwise , we compute @xmath199 by constructing auxiliary suffix trees .",
    "the nave way is to construct @xmath193 and then to compute @xmath200 , both of which run in @xmath201 time .",
    "we instead construct a series of trees @xmath202 for some @xmath203 in such a way that @xmath204 .",
    "in addition , the total cost of constructing the trees @xmath205 is in @xmath16 and each cost of computing @xmath206 in each @xmath205 is in @xmath207 .",
    "( function ) construct @xmath208 by constructing @xmath209    [ theorem : correctness ] let @xmath4 and @xmath5 be two integers .",
    "function computermp in algorithm  [ figure : rmp ] correctly computes the right minimal period array @xmath105 for the word @xmath3 .",
    "since each element @xmath60 $ ] is assigned by the value @xmath199 on the leaves of suffix tree @xmath210 with minimal periods , the correctness of the algorithm relies on the claim @xmath211 .",
    "the algorithm is based on weiner s algorithm and the only change is to update the @xmath171 values .",
    "so the underlying suffix tree of @xmath210 correctly presents the suffix tree @xmath114 .",
    "the update to @xmath177 only happens when the node @xmath39 is created in some @xmath114 . by definitions ,",
    "@xmath172 in any expanded suffix tree @xmath212 for @xmath213 is equal to @xmath177 in the suffix tree @xmath214 in which @xmath39 is created .",
    "so in order to prove @xmath211 , it remains to see that the assignment of @xmath177 for @xmath39 is correct when node @xmath39 is created .    at the beginning , @xmath215 is a tree of two nodes , the root and one leaf @xmath110 .",
    "we have @xmath216 and @xmath217 .",
    "so the assignments on line  2 of algorithm  [ figure : rmp ] is valid and @xmath218 .",
    "suppose it is true that @xmath219 for some @xmath136 , @xmath220 , at the beginning of the execution of lines  525 .",
    "then on the next execution within the loop at lines  525 , there are at most two nodes being created .",
    "one possible new node is @xmath74 , the father of @xmath66 , and the other is the @xmath66 .",
    "for @xmath221 on line  8 : if some split happens on an edge from @xmath28 to @xmath75 by adding a new node @xmath74 and two new edges from @xmath28 to @xmath74 , from @xmath74 to @xmath75 , respectively , then we have @xmath222 for some @xmath223 . by lemma  [ lemma : mpshrk ] ,",
    "@xmath224 , if @xmath225 ; otherwise @xmath226 .",
    "so the assignments on line  8 of algorithm  [ figure : rmp ] is valid .    for @xmath227 on line  23 :",
    "consider the value @xmath171 on the new leaf @xmath66 .",
    "since @xmath228 , we have @xmath229 for some @xmath230 .",
    "if @xmath231 , by lemma  [ lemma : mpexpd ] , it follows that @xmath232 and thus the assignment in line  13 of algorithm  [ figure : rmp ] is valid .",
    "if @xmath226 , then @xmath233 is computed with the assistant of the auxiliary suffix tree @xmath202 by the function computemp in algorithm  [ figure : mp ] .",
    "since @xmath228 , by lemma  [ lemma : mpbond ] , @xmath234 and thus the arguments in calling computemp is valid . to show the assignment on line  23 of algorithm  [ figure : rmp ] is valid , the only thing remains to prove is that @xmath204 .",
    "first we claim that @xmath235 , where the subscript of @xmath236 specifies in which tree the parent is discussed .",
    "if @xmath237 , then there is a split on the edge from @xmath238 to @xmath239 and leaves @xmath240 has the same father in @xmath210 .",
    "so leaves @xmath241 has the same father in @xmath242 and thus @xmath243 if @xmath244 , then by lemma  [ lemma : lastedge ] , it follows that @xmath245 then we claim @xmath246 holds right before line  23 , where @xmath228 .",
    "consider the last created suffix tree @xmath205 , then @xmath247 .",
    "if @xmath205 is newly created , then @xmath248 and @xmath249 .",
    "so @xmath250 .",
    "now we assume @xmath205 extends from a previous one . in the procedure of extending @xmath205 ,",
    "both @xmath203 and @xmath251 remain the same , exponent @xmath1 is a constant , the index @xmath136 increase by @xmath252 , and the depth @xmath253 increases at most by @xmath252 .",
    "so @xmath254 still holds .",
    "now we prove @xmath204 .",
    "if @xmath255 , by lemma  [ lemma : mpshrk ] , it follows that @xmath256 .",
    "now we assume @xmath257 . by lemma  [ lemma : mpbond ]",
    ", it follows that @xmath258 .",
    "in addition , @xmath259 always holds when @xmath247 .",
    "so the following holds @xmath260 and thus by lemma  [ lemma : mpshrk ] again @xmath261 .",
    "this finishes the proof @xmath190 .",
    "[ theorem : complexity ] let @xmath4 and @xmath5 be two integers .",
    "the time complexity of computing the right minimal period array @xmath105 for input word @xmath3 in algorithm  [ figure : rmp ] is @xmath0 .",
    "let @xmath88 .",
    "each assignment to elements in array @xmath262 at lines  25,27 of algorithm  [ figure : rmp ] can be done in constant time .",
    "so the total time of computing @xmath263 from the suffix tree @xmath264 with minimal periods is in @xmath16 .",
    "the lines  2,5,7,10 of algorithm  [ figure : rmp ] constitute exactly the weiner s algorithm for constructing the suffix tree @xmath64 , which is in @xmath16-time .",
    "most of the underlined statements , except lines  15,19,21,23 , in algorithm  [ figure : rmp ] can be done in constant time in a unit - cost model , where we assume the arithmetic operations , comparison and assignment of integers with @xmath265-bit can be done in constant time .",
    "the number of executions of lines  525 is @xmath266 and thus the total cost of those underlined statements is in @xmath16 .",
    "now we consider the computation of line  23 . by lemma  [ lemma : mpcret ] , since @xmath202 , the cost of each calling to computemp in algorithm  [ figure : mp ] is in time linear in @xmath267 we already showed in the proof of theorem  [ theorem : correctness ] that @xmath268 .",
    "by lemma  [ lemma : mpbond ] , @xmath269 .",
    "in addition , @xmath259 and @xmath270 always hold when @xmath247 .",
    "so we have @xmath271 the number of executions of lines  525 is @xmath266 and thus the total cost on line  23 is @xmath272 .",
    "now we consider the computation of lines  15,19,21 .",
    "those statements construct a series of suffix trees @xmath202 by calling to makesuffixtree and extend in algorithm  [ figure : weiner ] .",
    "each suffix tree is initialized at line  19 , extended at lines  15,21 , and destroyed at line  11 .",
    "suppose there are in total @xmath148 such trees , and suppose , for @xmath273 , they are initialized by @xmath274 with @xmath275 and destroyed when @xmath276 such that @xmath277 or @xmath278 .",
    "in addition , when @xmath247 , the inequality @xmath279 always holds for @xmath280 . since the construction of suffix tree in algorithm  [ figure : weiner ] is in linear time , the total cost on lines  15,19,21 is in time linear in @xmath281 first , we consider those trees @xmath205 destroyed by the condition @xmath277 .",
    "then @xmath282 and @xmath283 hold , and thus the decrease of @xmath136 is @xmath284 hence the total cost in this case is @xmath285 second , we consider those trees @xmath205 destroyed by the condition @xmath278",
    ". then @xmath286 . in the proof of theorem  [",
    "theorem : correctness ] , we showed @xmath287 . since @xmath288",
    ", it follows that the total cost in this case is @xmath289 the only remaining case is that the suffix tree @xmath205 is not destroyed even after the construction of @xmath290 .",
    "this can be avoided by adding a special character @xmath291 not in the alphabet of @xmath3 at the beginning of @xmath3 .",
    "then for @xmath292 the father of the @xmath112 is the root and thus @xmath205 is destroyed by the condition @xmath293 . in addition , @xmath294 and thus this modification do not change the computational complexity of this algorithm .",
    "so , the total cost on lines  15,19,21 is @xmath16 .",
    "therefore , the total cost of the algorithm is @xmath295 and thus is in time @xmath272 .",
    "the algorithm is in linear time when exponent @xmath1 is fixed .",
    "in this section , we discuss how the linear algorithm for computing @xmath105 and @xmath123 for fixed exponent @xmath1 can be applied to test whether a word @xmath3 contains a particular type of repetition , called pseudo - powers .",
    "let @xmath296 be the alphabet .",
    "a function @xmath297 is called an _ involution _ if @xmath298 for all @xmath299 and called an _ antimorphism _ if @xmath300 for all @xmath301 .",
    "we call @xmath302 an _ antimorphic involution _ if @xmath302 is both an involution and an antimorphism . for example , the classic watson - crick complementarity in biology is an antimorphic involution over four letters @xmath303 such that @xmath304 , @xmath305 , @xmath306 , @xmath307 . for integer @xmath1 and antimorphism @xmath302 , we call word @xmath3 a _ pseudo @xmath1th power _",
    "( with respect to @xmath302 ) if @xmath3 can be written as @xmath308 such that either @xmath309 or @xmath310 for @xmath311 .",
    "in particular , we call pseudo 2nd power by _ pseudo square _ and pseudo 3rd power by _ pseudo cube_. for example , over the four letters @xmath312 , word @xmath313 is a pseudo square and @xmath314 is a pseudo cube with respect to the watson - crick complementarity .",
    "pseudo @xmath1th power is of particular interest in bio - computing since a single strand of dna sequence of this form can itself make a hair - pin structure as illustrated in figure  [ figure : dna ] .",
    "a variation on pseudo @xmath1th power has also appeared in tiling problems ( see ) .",
    "@xmath315 & a\\ar@{-}[r ] & c\\ar@{-}[r ] & g\\ar@{-}[r ] & a\\ar@{-}[r ] & c\\ar@{-}[r ] & g\\ar@{-}[r ] & a\\ar@{-}[r ] & c\\ar@{-}[ld ] \\\\    \\ar@{-}[r ] & g\\ar@{-}[r ] & c\\ar@{-}[r ] & a\\ar@{-}[r ] & t\\ar@{-}[r]\\ar@{--}[u ] & g\\ar@{-}[r]\\ar@{--}[u ] & c\\ar@{-}[r]\\ar@{--}[u ] & g \\\\    &    &    & \\ar@{-}[r ] & a\\ar@{-}[r]\\ar@{--}[d ] & c\\ar@{-}[r]\\ar@{--}[d ] & g\\ar@{-}[r]\\ar@{--}[d ] & a\\ar@{-}[r ] & c\\ar@{-}[r ] & g \\\\",
    "\\ar@{-}[r ] & g\\ar@{-}[r ] & c\\ar@{-}[r ] & a\\ar@{-}[r ] & t\\ar@{-}[r ] & g\\ar@{-}[r ] & c\\ar@{-}[r ] & g\\ar@{-}[r ] & c\\ar@{-}[r ] & a\\ar@{-}[u ]    } \\ ] ]    chiniforooshan , kari and xu @xcite discussed the problem of testing whether a word @xmath3 contains a pseudo @xmath1th power as a factor .",
    "there is a linear - time algorithm and a quadratic - time algorithm for testing pseudo squares and pseudo cubes , respectively .",
    "but for general exponent @xmath1 , the known algorithm for testing pseudo @xmath1th powers is in @xmath316 .",
    "we will show that the particular type of pseudo @xmath1th powers , @xmath317 , @xmath318 , and @xmath319 ( or @xmath320 , if @xmath1 is odd ) can be tested faster .",
    "first we need the following concept .",
    "the _ centralized maximal pseudo - palindrome array _",
    "@xmath321 of word @xmath3 with respect to an antimorphic involution @xmath302 is defined by @xmath322 = \\max\\{m:0\\leq m\\leq\\min\\{i,\\abs{w}-i\\},\\phi(\\subw{w}{i - m+1}{i})=\\subw{w}{i+1}{i+m}\\}\\textrm { for } 0\\leq i\\leq\\abs{w}.\\ ] ] for example , @xmath323 $ ] .",
    "[ lemma : cmp ] let @xmath302 be an antimorphic involution .",
    "the centralized maximal pseudo - palindrome array @xmath321 of word @xmath3 with respect to @xmath302 can be computed in @xmath324 time .",
    "all maximal palindromes can be found in linear time ( for example , see @xcite ) . in exactly the same manner , by constructing suffix tree @xmath325 , where @xmath291 is a special character not in the alphabet of @xmath3 , the array @xmath321 can be computed in linear time .",
    "more precisely , the algorithm is outlined in algorithm  [ figure : cmp ] .",
    "now we prove the correctness of algorithm  [ figure : cmp ] .",
    "let @xmath88 and @xmath326",
    ". then @xmath327 . by the definition of suffix tree @xmath328 ,",
    "word @xmath329 is the longest common prefix of @xmath330 and @xmath331 . since the character @xmath291 does not appear in word @xmath332 and @xmath333 , it follows that @xmath329 is the longest word @xmath37 such that @xmath37 is a prefix of @xmath334 and @xmath335 is a suffix of @xmath336 .",
    "( here @xmath302 is an antimorphism , so when apply @xmath302 , suffix and prefix relations exchange each other . )",
    "this proves the correctness .",
    "both the construction of suffix tree @xmath328 and the preprocessing for fast finding @xmath138 is in linear time . in addition , the computation of @xmath138 for any pair of leaves is constant after the proprocessing .",
    "so the total running time of algorithm  [ figure : cmp ] is in @xmath324 .",
    "( function ) @xmath337 ; linear - time preprocessing the tree @xmath338 for constant - time finding @xmath138 @xmath339\\longleftarrow0 $ ] and @xmath340\\longleftarrow0 $ ]    let @xmath189 and @xmath341 be integers and @xmath302 be an antimorphic involution . whether a word @xmath3 contains any factor of the form @xmath318 ( respectively , @xmath317 ) with @xmath143 can be tested in @xmath0 time .",
    "the main idea is first to compute @xmath342 ( respectively , @xmath343 ) and @xmath321 , and then to compare the two arrays .",
    "there is a factor of the form @xmath318 ( respectively , @xmath317 ) with @xmath143 if and only if there is an index @xmath136 such that @xmath344\\leq{}^{\\phi}cmp[i]$ ] ( respectively , @xmath345\\leq{}^{\\phi}cmp[i-1]$ ] ) .",
    "more details of detecting @xmath318 is given in algorithm  [ figure : pp1 ] , and the case of @xmath317 is similar .    to see the correctness of algorithm  [ figure : pp1 ] , we prove that word @xmath3 contains any factor of the form @xmath318 with @xmath143 if and only if @xmath344\\leq{}^{\\phi}cmp[i]$ ] holds for some @xmath346 , where @xmath88 .",
    "suppose the inequality @xmath347\\leq{}^{\\phi}cmp[i]$ ] holds for some @xmath136 .",
    "then @xmath3 contains word @xmath348 of the form @xmath318 as a factor and @xmath143 .",
    "now suppose @xmath3 contains a factor @xmath349 of the form @xmath318 for @xmath350 .",
    "then by definitions , @xmath351\\leq p$ ] and @xmath352\\geq p$ ] .",
    "so @xmath347\\leq{}^{\\phi}cmp[i]$ ] holds for @xmath353 .",
    "the computation of @xmath342 is @xmath0-time and the computation of @xmath354 is @xmath324-time",
    ". there are @xmath324 comparisons of integers .",
    "so the total running time of algorithm  [ figure : pp1 ] is in @xmath0 .",
    "let @xmath189 and @xmath341 be integers and @xmath302 be an antimorphicc involution . whether a word @xmath3 contains any factor of the form @xmath355 ( or @xmath356 if @xmath1 is odd ) with @xmath143 can be tested in @xmath357 time .    the main idea is first to compute @xmath321 and then to enumerate all possible indices and periods .",
    "there is a factor of the specified form as in the theorem if and only if there are @xmath358 consecutive terms greater than @xmath2 in @xmath321 with indices being arithmetic progression with difference greater than @xmath2 .",
    "the algorithm is given in algorithm  [ figure : pp2 ] .    to see the correctness of algorithm  [ figure : pp2 ]",
    ", we observe that @xmath3 contains a factor of the form @xmath359 with @xmath350 if and only if there are @xmath1 consecutive terms @xmath360,{}^\\phi cmp_w[i+2p-1],\\ldots,{}^\\phi cmp_w[i+(k-1)p-1]$ ] that are @xmath361 .",
    "the computation of @xmath321 is @xmath324-time and obviously the remaining part is @xmath357-time .",
    "so the total running time of algorithm  [ figure : pp2 ] is in @xmath357 .",
    "we generalized kosaraju s linear - time algorithm for computing minimal squares that start at each position in a word , which by our definition is denoted by the array @xmath104 .",
    "we showed a modified version of his algorithm that can compute , for arbitrary integers @xmath362 , the minimal @xmath1th powers , with period larger than @xmath2 , that starts at each position ( to the left and to the right ) in a word , which by our definition is denoted by the right minimal period array @xmath105 and the left minimal period array @xmath123 .",
    "the algorithm is in @xmath0-time .",
    "the algorithm is based on the frame of weiner s suffix tree construction .",
    "although there are other linear - time suffix tree construction algorithms , such as mccreight s algorithm and ukkonen s algorithm , none of the two can be altered to compute minimal period arrays with the same efficiency , due to the special requirements that the suffices of the given word are added from the short to the long and @xmath177 is only updated when @xmath39 is created .",
    "we showed the @xmath0-time algorithm for computing minimal period arrays can be used to test whether a given word @xmath3 contains any factor of the form @xmath363 ( respectively , @xmath364 ) with @xmath143 .",
    "we also discussed an @xmath357-time algorithm for testing whether a given word @xmath3 contains any factor of the form @xmath355 ( or @xmath356 if @xmath1 is odd ) with @xmath143 .",
    "all the word @xmath365 , @xmath366 , @xmath367 are pseudo - powers .",
    "there are possibilities that some particular type of pseudo - powers other than the ones we discussed can also be detected faster than the known @xmath316-time algorithm .",
    "j.  stoye and d.  gusfield .",
    "simple and flexible detection of contiguous repeats using a suffix tree preliminary version . in m.  farach - colton ,",
    "9th combinatorial pattern matching '' _ , pages 140152 .",
    "springer verlag , 1998 ."
  ],
  "abstract_text": [
    "<S> kosaraju in `` computation of squares in a string '' briefly described a linear - time algorithm for computing the minimal squares starting at each position in a word . using the same construction of suffix trees , </S>",
    "<S> we generalize his result and describe in detail how to compute in @xmath0-time the minimal @xmath1th power , with period of length larger than @xmath2 , starting at each position in a word @xmath3 for arbitrary exponent @xmath4 and integer @xmath5 . </S>",
    "<S> we provide the complete proof of correctness of the algorithm , which is somehow not completely clear in kosaraju s original paper . </S>",
    "<S> the algorithm can be used as a sub - routine to detect certain types of pseudo - patterns in words , which is our original intention to study the generalization . </S>"
  ]
}