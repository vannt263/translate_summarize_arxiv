{
  "article_text": [
    "l_auto - stabilisation _ @xcite est une proprit des systmes distribus permettant de tolrer des fautes transitoires ( _ i.e. _ de dure finie ) de type arbitraire . plus prcisment , un systme est dit auto - stabilisant sil garantit que toute excution issue dune configuration arbitraire retrouve en un temps fini un comportement conforme  la spcification du systme et ceci sans aide extrieure ( humaine ou autre ) .    [ [ motivations ] ] motivations + + + + + + + + + + +    tant donn que lauto - stabilisation est une proprit non triviale  satisfaire , une large part des travaux traitant de ce domaine se placent dans un modle",
    "de communication trs simple dans lequel tous les processeurs peuvent dterminer de manire atomique ltat de tous leurs voisins ( ce modle de calcul est connu sous le nom de modle  tats ) .",
    "il est cependant vident que ce modle nest pas raliste et quun modle plus classique comme le modle asynchrone  passage de messages est plus proche dun systme rel .",
    "dans un tel modle , les processeurs voisins communiquent par envoi et rception de messages  travers le canal de communication qui les spare .",
    "il existe des transformateurs permettant de passer de manire automatique du premier modle au second @xcite ainsi que des algorithmes crits directement pour le modle  passage de messages @xcite mais ceux - ci supposent lexistence dun protocole de communication entre processeurs voisins .",
    "le protocole de communication ( entre voisins ) le plus connu est le protocole du bit altern ( pba ) . il a t prouv que ce protocole fournit des proprits de stabilisation @xcite . en effet ,",
    "pour toute excution du pba , il existe un suffixe qui satisfait la spcification ( _ i.e. _ le pba est pseudo - stabilisant @xcite ) .",
    "aprs les rsultats de @xcite qui montrent quil est impossible de fournir un protocole de communication avec une mmoire borne si les canaux sont de capacit non borne , les travaux rcents se sont concentrs sur des systmes avec des canaux de capacit borne .",
    "il existe diffrents protocoles de communication stabilisants  travers des canaux de capacit borne qui diffrent par les hypothses faites sur le systme ( mmoire borne , canaux , etc . )",
    "mais toutes les solutions connues @xcite considrent des canaux fifo .",
    "un dfaut commun  tous les protocoles de communication prcdents est quils ne fournissent aucune mesure de limpact quantitatif des fautes transitoires sur les messages transmis .",
    "partant dune configuration initiale arbitraire , le contenu initial des canaux est lui aussi arbitraire , ce qui peut conduire le protocole  perdre , dupliquer des messages ou bien dlivrer de faux messages ( qui nont pas t envoys mais rsultent des fautes initiales ) .",
    "du point de vue de lapplication qui utilise le protocole de communication , il est primordial de connatre des bornes sur le nombre de messages pouvant subir de tels alas .",
    " notre connaissance , seuls @xcite traitent de ce problme dans une certaine mesure .",
    "en effet , ils peuvent tre adapts pour obtenir des protocoles de communication instantannement stabilisants .",
    "la stabilisation instantane assure que tout message envoy sera dlivr en un temps fini , mais le nombre de messages dupliqus ou de faux messages cres nest pas tudi .",
    "[ [ contributions ] ] contributions + + + + + + + + + + + + +    notre contribution dans cet article est double .",
    "dans un premier temps , nous dfinissons un ensemble de mtriques pour mesurer la performance dun protocole de communication stabilisant et nous donnons des bornes infrieures pour plusieurs dentre elles .",
    "en particulier , nous montrons que tout protocole de communication stabilisant  travers des canaux de capacit borne non fiables et non fifo peut tre contraint  dupliquer un message ,  dlivrer un faux message ou  r - ordonner un message .",
    "dans un second temps , nous proposons un protocole optimal par rapport aux bornes infrieures voques prcdement .",
    "[ [ spcification ] ] spcification + + + + + + + + + + + + +    nous considrons ici un systme distribu  passage de messages rduit  deux processeurs : @xmath0 qui sera considr comme metteur de messages et @xmath1 qui sera considr comme rcepteur de messages .",
    "le canal de communication sparant @xmath0 et @xmath1 est constitu de deux canaux virtuels de directions opposes .",
    "le premier , @xmath2 , permet  @xmath0 denvoyer des messages  @xmath1 tandis que le second , @xmath3 , permet  @xmath1 denvoyer des acquittements  @xmath0 .",
    "chacun de ces canaux virtuels est asynchrone ( le temps de livraison de tout message est fini mais non born ) , a une capacit borne de @xmath4 messages ( tout envoi de messages lorsque cette borne est atteinte conduit  la perte dun message arbitraire ) , non fiable ( tout message peut tre perdu  un moment arbitraire ) mais quitable ( tout message envoy infiniment souvent est reu infiniment souvent ) et non - fifo ( lordre darrive des messages est indpendant de lordre denvoi ) .",
    "il faut noter que , en raison du contexte auto - stabilisant , chaque canal virtuel contient initialement jusqu @xmath4 messages de contenu arbitraire .",
    "la spcification que nous prsentons  prsent est inspire de celle de @xcite mais elle est adapte au contexte auto - stabilisant .",
    "supposons que nous avons une application distribue qui souhaite envoyer des messages de @xmath0  @xmath1 .",
    "notre objectif est de fournir un protocole de communication  cette application qui remplit cette tche de manire transparente malgr les caractristiques du canal de communication .",
    "cette application _ envoit _",
    "un message lorsquelle demande au protocole de communication de faire parvenir un message depuis @xmath0 vers @xmath1 .",
    "un message est _ dlivr _",
    " @xmath1 lorsque le protocole de communication fournit ce message  lapplication sexcutant sur @xmath1 .",
    "un message _ fantme _ est un message dlivr  @xmath1 alors quil na pas t envoy par @xmath0 .",
    "un message _ dupliqu _ est un message dlivr plusieurs fois  @xmath1 alors quil na t envoy quune fois par @xmath0 .",
    "un message _ perdu _ est un message envoy par @xmath0 mais jamais dlivr  @xmath1 .",
    "un message @xmath5 est _ r - ordonn _",
    "lorsquil dlivr  @xmath1 avant un message @xmath6 alors que @xmath5 a t envoy aprs @xmath6 par @xmath0 .",
    "le but dun protocole de communication stabilisant est alors de fournir des proprits sur le nombre de messages perdus , dupliqus , fantmes et r - ordonns .",
    "nous spcifions notre problme comme suit :    un protocole de communication est @xmath7-stabilisant sur des canaux @xmath4-borns sil remplit les conditions suivantes pour toute excution issue dune configuration arbitraire : + - dans le pire cas , seuls les @xmath8 premiers messages envoys par @xmath0 peuvent tre perdus .",
    "+ - dans le pire cas , seuls les @xmath9 premiers messages dlivrs  @xmath1 peuvent tre des messages dupliqus .",
    "+ - dans le pire cas , seuls les @xmath10 premiers messages dlivrs  @xmath1 peuvent tre des messages fantmes .",
    "+ - dans le pire cas , seuls les @xmath11 premiers messages dlivrs  @xmath1 peuvent tre des messages r - ordonns .",
    "tant donn que tout protocole de communication doit avoir dans son code une instruction pour dlivrer les messages  lapplication et que , dans un contexte auto - stabilisant , le compteur ordinal peut tre arbitrairement corrompu dans la configuration initiale , il est possible que la premire instruction execute par le processeur rcepteur soit la livraison dun message qui na jamais t envoy ,",
    "_ i.e. _ un message fantme .",
    "si , de plus , ce message fantme est identique  un autre message envoy par @xmath0 dans lexcution considre , ce message peut devenir un message dupliqu ou r - ordonn .",
    "nous obtenons les rsultats suivants .",
    "il nexiste pas de protocole de communication @xmath7-stabilisant sur des canaux @xmath4-borns avec @xmath12 , @xmath13 ou @xmath14 .",
    "nous sommes maintenant en mesure de prsenter notre protocole de communication .",
    "celui - ci est compos de deux fonctions : * send(@xmath5 ) * qui est excute par @xmath0  chaque fois quil souhaite envoyer un message @xmath5 ( * send * est bloquant , _ i.e. _ @xmath0 doit attendre la fin de son excution avant de commencer  envoyer le message suivant ) et * receive ( ) * qui est excute par @xmath1 en continu .",
    "[ [ ide - gnrale ] ] ide gnrale + + + + + + + + + + + + +    lide de base de notre protocole est de modifier le pba de manire  amliorer ses proprits de tolrance .",
    "si le processeur @xmath0 souhaite envoyer un message @xmath5 , il envoie celui - ci de manire priodique et @xmath1 acquitte chaque copie de @xmath5 quil reoit . le processeur @xmath1 nest autoris  dlivrer le message @xmath5 que lorsquil en a reu @xmath16 copies ( pour assurer quau moins",
    "lune dentre elles a bien t envoye par @xmath0 ) . de plus , @xmath5 nest dlivr que si la valeur du bit altern qui lui est associe est diffrente de celle du dernier message dlivr par @xmath1 ( de manire  assurer que le message ne soit pas dupliqu car @xmath0 continue denvoyer @xmath5 tant quil na pas reu suffisament dacquittements ) .",
    "afin dassurer que @xmath1 a reu au moins @xmath16 copies du message , @xmath0 attend davoir reu @xmath17 acquittements avant darrter denvoyer @xmath5 ( en effet , au plus @xmath16 acquittements sont ds  la configuration initiale tandis que au plus @xmath4 sont ds  la prsence initiale de messages erronns dans le canal @xmath2 ) .",
    " ce stade , notre protocole ne garantit pas encore labsence de pertes de messages  cause de lutilisation du bit altern ( en effet , si le bit altern du message et du rcepteur ne sont pas initialement synchroniss , le premier message envoy par @xmath0 peut tre perdu ) . pour viter cela , @xmath0 alterne entre lenvoi de messages de synchronisation et de @xmath5 . plus",
    "prcisment , pour envoyer un message @xmath5 , @xmath0 commence par envoyer un message de synchronisation ( not @xmath18 ) jusqu recevoir @xmath17 acquittements avant denvoyer le message @xmath5 lui - mme jusqu en recevoir @xmath17 acquittements .",
    "il sensuit que seul le message de synchronisation est perdu dans le pire des cas .",
    "[ [ prsentation - dtaille ] ] prsentation dtaille",
    "+ + + + + + + + + + + + + + + + + + + + + +    notre protocole est prsent en figure 1 .",
    "la procdure * send * se contente denvoyer un message de synchronisation puis le message reu en paramtre (  laide de la fonction auxilliaire * sendmessage * ) aprs avoir altern la valeur du bit associ .",
    "finalement , elle dlivre un acquittement  lapplication  laide de la fonction * deliverack*. la fonction auxilliaire * sendmessage * envoit priodiquement le message  laide de la fonction * sendpacket * ( qui permet denvoyer un paquet sur le canal @xmath2 ) et compte le nombre dacquittement reus en faisant appel  la fonction * receivepacket * ( qui permet de rcuprer un message dans le canal @xmath3 ) .",
    "celle - ci sarrte lorsquelle a compt @xmath17 acquittements .",
    "[ cols= \" < , < \" , ]      chaque rception de message ( ralise grce  la fonction * receivepacket * ) , la procdure * receive * incrmente le compteur associ au message quelle vient de recevoir .",
    "dans le cas o le message a t reu @xmath16 fois , la file servant  stocker les messages reus est vide .",
    "si , de plus , la valeur du bit altern est diffrente de celle du dernier message reu au moins @xmath16 fois , alors le message est soit dlivr  lapplication  laide de * delivermessage * ( sil sagit dun message normal ) ou bien dtruit  laide de la fonction * dropmessage * ( sil sagit dun message de synchronisation qui est donc sans intrt pour lapplication ) .",
    "dans les deux cas , le bit du rcepteur est altern .",
    "tout message reu est acquitt (  laide de la fonction * sendpacket * ) avant de traiter le suivant .",
    "[ [ proprits ] ] proprits + + + + + + + + + +    nous avons vu prcdement que @xmath0 attend de recevoir @xmath17 acquittements de chaque message pour arrter de lenvoyer , ce qui garantit que @xmath1 a reu au moins @xmath19 copies de ce message ( do nt au moins @xmath16 rellement envoyes par @xmath0 ) et donc que ce message a bien t dlivr  @xmath1 si @xmath20 .",
    "si ce nest pas le cas , lusage du message de synchronisation nous garantit que notre protocole ne perd aucun message envoy par @xmath0 .",
    "lusage du bit altern nous garantit labsence de duplication aprs la premire rception ( si le premier message reu est un message fantme , celui - ci peut tre la copie dun message valide ultrieur , ce qui cause au pire une duplication ) .",
    "le fait dattendre de recevoir @xmath16 copies de chaque message avant de le dlivrer garantit que seul le premier message dlivr peut tre un message fantme .",
    "enfin , le fait quun message @xmath5 soit dlivr  @xmath1 entre le dbut et la fin de lexcution de * send(m ) * par @xmath0 et que les appels  cette fonction soient bloquants pour @xmath0 implique que seul le premier message peut tre r - ordonn ( si le premier message reu est un message fantme , celui - ci peut tre la copie dun message valide ultrieur , ce qui cause au pire un r - ordonnancement ) . en conclusion , nous avons le rsultat suivant :    @xmath21 est un protocole de communication @xmath15-stabilisant  travers des canaux de communication de capacit borne mais non fiables et non fifo .",
    "dans cet article , nous avons introduit des mesures de leffet de fautes transitoires sur les performances des protocoles de communication entre voisins dans un systme  passage de messages .",
    "nous avons ensuite fourni un protocole optimal par rapport  ces mesures dans le cas o les canaux de communications ont une capacit borne , sont non fiables et non fifo .",
    "toutefois , notre protocole induit un surcot de communication  ; la question de savoir sil est possible de conserver cette tolrance optimale aux fautes transitoires en baissant ce surcot de communication de manire significative est toujours ouverte ."
  ],
  "abstract_text": [
    "<S> un protocole auto - stabilisant a la capacit de converger vers un comportement correct quel que soit son tat initial . </S>",
    "<S> la grande majorit des travaux en auto - stabilisation supposent une communication par mmoire partage ou bien  travers des canaux de communication fiables et fifo . </S>",
    "<S> dans cet article , nous nous intressons aux systmes auto - stabilisants  passage de messages  travers des canaux de capacit borne mais non fiables et non fifo . </S>",
    "<S> nous proposons un protocole de communication ( entre voisins ) stabilisant et offrant une tolrance optimale . plus prcisment , ce protocole simule un canal de communication fiable et fifo garantissant un nombre minimal de pertes , de duplications , de crations et de r - ordonnancements de messages . </S>"
  ]
}