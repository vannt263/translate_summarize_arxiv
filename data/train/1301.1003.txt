{
  "article_text": [
    "primary key violations are a natural way for modeling uncertainty in the relational model . if two distinct tuples have the same primary key value , then at least one of them must be mistaken , but we do not know which one .",
    "this representation of uncertainty is also used in probabilistic databases , where each tuple is associated with a probability and distinct tuples with the same primary key value are disjoint probabilistic events  @xcite .    in this paper , the term _ uncertain database _ is used for databases with primary key constraints that need not be satisfied .",
    "a repair ( or possible world ) of an uncertain database @xmath2 is a maximal subset of @xmath2 that satisfies all primary key constraints .",
    "semantics of querying follows the conventional paradigm of _ consistent query answering _",
    "@xcite : given a boolean query @xmath0 , the decision problem @xmath1 takes as input an uncertain database @xmath2 and asks whether @xmath0 is satisfied by every repair of @xmath2 .",
    "notice that @xmath0 is not part of the input , so the complexity of the problem is data complexity .",
    "the restriction to boolean queries simplifies the technical treatment , but is not fundamental .",
    "c|*3l @xmath3 & @xmath4 & @xmath5 & @xmath6 + & pods & 2016 & rome + & pods & 2016 & paris + & kdd & 2017 & rome +    [ cols=\"^,<,^ \" , ]     primary keys are underlined in the conference planning database of fig .",
    "[ fig : planning ] .",
    "maximal sets of tuples that agree on their primary key , called _ blocks _ , are separated by dashed lines .",
    "there is uncertainty about the city of pods  2016 , and about the rank of kdd .",
    "the database has four repairs .",
    "the query @xmath7 ( will rome host some a conference ? ) is true in only three repairs .",
    "the problem @xmath1 is in  for first - order queries @xmath0 ( a  no \" certificate is a repair falsifying @xmath0 ) . its complexity for conjunctive queries has attracted the attention of several authors , also outside the database community  @xcite . a major research objective is to find an effective method that takes as input a conjunctive query @xmath0 and decides to which complexity classes @xmath1 belongs , or does not belong .",
    "complexity classes of interest are the class of first - order expressible problems ( or @xmath8 ) , , and -complete .    unless specified otherwise , whenever we say  query \" in the remainder of this paper , we mean a boolean conjunctive query without self - join ( i.e. , without repeated relation names ) .",
    "such queries are called acyclic if they have a join tree  @xcite .",
    "our previous work  @xcite has revealed the frontier between first - order expressibility and inexpressibility of @xmath1 for acyclic queries @xmath0 . in the current work ,",
    "we study the frontier between tractability and intractability of @xmath1 for the same class of queries .",
    "that is , we aim at an effective method that takes as input a query @xmath0 and decides whether @xmath1 is in  or -complete ( or neither of the two , which is theoretically possible if @xmath9  @xcite ) . for queries with exactly two atoms ,",
    "such a method was recently found by kolaitis and pema  @xcite , but moving from two to more than two atoms is a major challenge .",
    "uncertain databases become probabilistic by assuming that the probabilities of all repairs are equal and sum up to  @xmath10 . in probabilistic terms , distinct tuples of the same block represent disjoint ( i.e. , exclusive ) events , while tuples of distinct blocks are independent .",
    "such probabilistic databases have been called _ block - independent - disjoint _ ( bid ) .",
    "the tractability / intractability frontier of query evaluation on bid probabilistic databases has been revealed by dalvi et al .",
    "@xcite . here , evaluating a boolean query is a function problem that takes as input a bid probabilistic database and asks the probability ( a real number between @xmath11 and @xmath10 ) that @xmath0 is true .",
    "the decision problem @xmath1 , on the other hand , simply asks whether this probability is equal to @xmath10 .    in previous work  @xcite",
    ", we introduced the ( directed ) attack graph of an acyclic query , and showed that @xmath1 is first - order expressible if and only if @xmath0 s attack graph is acyclic .",
    "in the current paper , we study attack graphs in more depth .",
    "we will classify cycles in attack graphs as either weak or strong .",
    "the main contributions can then be summarized as follows .    1 .",
    "if the attack graph of an acyclic query @xmath0 contains a strong cycle , then @xmath1 is -complete",
    ". this will be theorem  [ the : strongcycle ] .",
    "if the attack graph of an acyclic query @xmath0 contains no strong cycle and all weak cycles of it are terminal ( i.e. , no edge leads from a vertex in the cycle to a vertex outside the cycle ) , then @xmath1 is in",
    ". this will be theorem  [ the : outdegree ] .",
    "the only acyclic queries @xmath0 not covered by the two preceding results have an attack graph with some nonterminal cycle and without strong cycle .",
    "we provide supporting evidence for our conjecture that @xmath1 is tractable for such queries .",
    "our results imply that @xmath1 is tractable for  cycle \" queries @xmath0 of the form @xmath12 @xmath13 @xmath14 @xmath15 .",
    "these queries arise in the work of fuxman and miller  @xcite .",
    "the case @xmath16 was solved in  @xcite , but the case @xmath17 was open and will be settled by corollary  [ cor : fuxman ] .",
    "4 .   theorem  [ the : prob ] and its corollary  [ cor : prob ] will establish a relationship between the tractability frontiers of @xmath1 and query evaluation on probabilistic databases .",
    "our work significantly extends and generalizes known results in the literature .",
    "the remainder of this paper is organized as follows .",
    "the next section further discusses related work .",
    "section  [ sec : preliminaries ] defines the basic notions of certain conjunctive query answering .",
    "section  [ sec : attackgraph ] defines the notion of attack graph .",
    "sections  [ sec : intractability ] and  [ sec : tractability ] show our main intractability and tractability results respectively . section  [ sec : bid ] establishes a relationship between the complexities of @xmath1 and evaluating query @xmath0 on probabilistic databases .",
    "section  [ sec : discussion ] concludes the paper and raises challenges for future research .",
    "several proofs have been moved to an appendix .",
    "the investigation of @xmath1 was pioneered by fuxman and miller  @xcite , who defined a class of queries @xmath0 for which @xmath1 is first - order expressible .",
    "this class has later on been extended by wijsen  @xcite , who developed an effective method to decide whether @xmath1 is first - order expressible for acyclic queries @xmath0 . in their conclusion ,",
    "fuxman and miller  @xcite raised the question whether there exist queries @xmath0 , without self - join , such that @xmath1 is in  but not first - order expressible .",
    "the first example of such a query was identified by wijsen  @xcite .",
    "the current paper identifies a large class of such queries ( all acyclic queries with a cyclic attack graph in which all cycles are weak and terminal ) .",
    "kolaitis and pema  @xcite recently showed that for every query @xmath0 with exactly two atoms , @xmath1 is either in  or -complete , and it is decidable which of the two is the case .",
    "if @xmath1 is in  and not first - order expressible , then it can be reduced in polynomial time to the problem of finding maximal ( with respect to cardinality ) independent sets of vertices in claw - free graphs .",
    "the latter problem can be solved in polynomial time by an ingenious algorithm of minty  @xcite .",
    "unfortunately , the proposed reduction is not applicable on queries with more than two atoms .",
    "the counting variant of @xmath1 , which has been denoted @xmath18 , takes as input an uncertain database @xmath2 and asks to determine the number of repairs of @xmath2 that satisfy query @xmath0 .",
    "maslowski and wijsen  @xcite have recently showed that for every query @xmath0 , the counting problem @xmath18 is either in  or -complete , and it is decidable which of the two is the case .    as observed in section  [ sec : intro ] , uncertain databases are a restricted case of block - independent - disjoint ( bid ) probabilistic databases  @xcite .",
    "this observation will be elaborated in section  [ sec : bid ] .",
    "all aforementioned results assume queries without self - join . for queries",
    "@xmath0 with self - joins , only fragmentary results about the complexity of @xmath1 are known  @xcite . the extension to unions of conjunctive queries",
    "has been studied in  @xcite .",
    "we assume disjoint sets of _ variables _ and _ constants_. if @xmath19 is a sequence containing variables and constants , then @xmath20 denotes the set of variables that occur in @xmath19 , and @xmath21 denotes the length of @xmath19 .",
    "let @xmath22 be a set of variables .",
    "valuation over @xmath22 _ is a total mapping @xmath23 from @xmath22 to the set of constants .",
    "such valuation @xmath23 is extended to be the identity on constants and on variables not in @xmath22 .",
    "every _ relation name _",
    "@xmath24 has a fixed _ signature _ , which is a pair @xmath25}$ ] with @xmath26 : the integer @xmath27 is the _ arity _ of the relation name and @xmath28 is the _",
    "primary key_. the relation name @xmath24 is _ all - key _ if @xmath29 .",
    "if @xmath24 is a relation name with signature @xmath25}$ ] , then @xmath30 is an _",
    "@xmath24-atom _ ( or simply atom ) , where each @xmath31 is either a constant or a variable ( @xmath32 ) .",
    "such atom is commonly written as @xmath33 where the primary key value @xmath34 is underlined and @xmath35 .",
    "a _ fact _ is an atom in which no variable occurs .",
    "two facts @xmath36 are _ key - equal _ if @xmath37 and @xmath38 .",
    "we will use letters @xmath39 for atoms , and @xmath40 for facts of an uncertain database . for atom @xmath41 ,",
    "we denote by @xmath42 the set of variables that occur in @xmath19 , and by @xmath43 the set of variables that occur in @xmath44 , that is , @xmath45 and @xmath46 .",
    "a _ database schema _ is a finite set of _ relation names_. all constructs that follow are defined relative to a fixed database schema .",
    "an _ uncertain database _ is a finite set @xmath2 of facts using only the relation names of the schema .",
    "block _ of @xmath2 is a maximal set of key - equal facts of @xmath2 . if @xmath47 , then @xmath48 denotes the block of @xmath2 containing @xmath49 .",
    "an uncertain database @xmath2 is _ consistent _ if it does not contain two distinct facts that are key - equal ( i.e. , if every block of @xmath2 is a singleton ) .",
    "repair _ of @xmath2 is a maximal consistent subset of @xmath2 .",
    "a _ boolean conjunctive query _ is a finite set @xmath50 , @xmath51 , @xmath52 of atoms .",
    "by @xmath53 , we denote the set of variables that occur in @xmath0 .",
    "the set @xmath0 represents the first - order sentence @xmath54 where @xmath55 .",
    "the query @xmath0 is _ satisfied _ by uncertain database @xmath2 , denoted @xmath56 , if there exists a valuation @xmath23 over @xmath53 such that for each @xmath57 , @xmath58 .",
    "we say that @xmath0 has a _ self - join _ if some relation name occurs more than once in @xmath0 ( i.e. , if @xmath59 for some @xmath60 ) .",
    "the restriction to boolean queries simplifies the technical treatment , but is not fundamental .",
    "since every relation name has a fixed signature , relevant primary key constraints are implicitly present in all queries ; moreover , primary keys will be underlined .",
    "the notions of join tree and acyclicity  @xcite are recalled next .",
    "a _ join tree _ for a conjunctive query @xmath0 is an undirected tree whose vertices are the atoms of @xmath0 such that the following condition is satisfied :    _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ connectedness condition .",
    "_ whenever the same variable @xmath61 occurs in two atoms @xmath44 and @xmath62 , then @xmath61 occurs in each atom on the unique path linking @xmath44 and @xmath62 . _",
    "_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _    commonly , an edge between atoms @xmath44 and @xmath62 is labeled by the ( possibly empty ) set @xmath63 .",
    "the term _ connectedness condition _ appears in  @xcite and refers to the fact that the set of vertices in which @xmath61 occurs induces a connected subtree .",
    "a conjunctive query @xmath0 is _ acyclic _ if it has a join tree .",
    "the symbol @xmath64 will be used for join trees .",
    "we write @xmath65 to denote an edge between @xmath44 and @xmath62 with label @xmath66 .",
    "a join tree is shown in fig .",
    "[ fig : ax ] ( left ) .    given a boolean conjunctive query @xmath0 ,",
    "@xmath1 is ( the complexity of ) the following set .",
    "@xmath1 is said to be _ first - order expressible _ if there exists a first - order sentence @xmath68 such that for every uncertain database @xmath2 , @xmath69 if and only if @xmath70 .",
    "the formula @xmath68 , if it exists , is called a _ certain first - order rewriting of _ @xmath0 .",
    "let @xmath0 be a boolean conjunctive query .",
    "an uncertain database @xmath2 is said to be _ purified relative to @xmath0 _ if for every fact @xmath47 , there exists a valuation @xmath23 over @xmath53 such that @xmath71 . intuitively , every fact in a purified uncertain database is relevant for the query .",
    "this notion of purified database is new and illustrated next .",
    "the uncertain database @xmath72 , @xmath73 , @xmath74 is not purified relative to query @xmath75 because it contains no @xmath24-fact that  joins \" with @xmath76 .",
    "the following lemma implies that in the study of tractability of @xmath1 , we can assume without loss of generality that uncertain databases are purified ; this assumption will simplify the technical treatment .",
    "notice that the query @xmath0 in the lemma s statement is not required to be acyclic .",
    "[ lem : purified ] let @xmath0 be a boolean conjunctive query .",
    "let @xmath77 be an uncertain database .",
    "it is possible to compute in polynomial time an uncertain database @xmath2 that is purified relative to @xmath0 such that    @xmath78 .",
    "the primary key of an atom @xmath44 gives rise to a functional dependency among the variables that occur in @xmath44 .",
    "for example , @xmath79 gives rise to @xmath80 , which will be abbreviated as @xmath81 ( and which is equivalent to @xmath82 ) .",
    "the set @xmath83 defined next collects all functional dependencies that arise in atoms of @xmath0 .",
    "let @xmath0 be a boolean conjunctive query .",
    "we define @xmath83 as the following set of functional dependencies .",
    "@xmath84    concerning the following definition , recall from relational database theory  @xcite that if @xmath85 is a set of functional dependencies over a set @xmath22 of attributes and @xmath86 , then the attribute closure of @xmath87 ( with respect to @xmath85 ) is the set @xmath88 .",
    "let @xmath0 be a boolean conjunctive query .",
    "for every @xmath89 , we define @xmath90 as the following set of variables .",
    "@xmath91    in words , @xmath90 is the attribute closure of the set @xmath42 with respect to the set of functional dependencies that arise in the atoms of @xmath92 . note that variables play the role of attributes in our framework .",
    "[ ex : keycl ] let @xmath93 , @xmath94 , @xmath95 , @xmath96 . a join tree for this query",
    "is shown in fig .",
    "[ fig : ax ] ( left ) . to shorten notation ,",
    "let @xmath97 , @xmath98 , @xmath99 , and @xmath100 , as indicated in the figure .",
    "we have the following .    @xmath101{l@{\\mbox{\\ and\\ } } l } \\multicolumn{2}{l } { { { \\mathcal{k}}({q_{{1}}\\setminus\\{f\\}})}=\\{{{y}\\rightarrow{xyz } } , { { x}\\rightarrow{xy } } , { { x}\\rightarrow{xz}}\\}}\\\\[0.6ex ] { { \\mathsf{key}}({f})}=\\{u\\ } & { { f}^{+,{q_{{1}}}}}=\\{u\\}\\\\[1.5ex ] \\multicolumn{2}{l } { { { \\mathcal{k}}({q_{{1}}\\setminus\\{g\\}})}=\\{{{u}\\rightarrow{ux } } , { { x}\\rightarrow{xy } } , { { x}\\rightarrow{xz}}\\}}\\\\[0.6ex ] { { \\mathsf{key}}({g})}=\\{y\\ } & { { g}^{+,{q_{{1}}}}}=\\{y\\}\\\\[1.5ex ] \\multicolumn{2}{l } { { { \\mathcal{k}}({q_{{1}}\\setminus\\{h\\}})}=\\{{{u}\\rightarrow{ux } } , { { y}\\rightarrow{xyz } } , { { x}\\rightarrow{xz}}\\}}\\\\[0.6ex ] { { \\mathsf{key}}({h})}=\\{x\\ } & { { h}^{+,{q_{{1}}}}}=\\{x , z\\}\\\\[1.5ex ] \\multicolumn{2}{l } { { { \\mathcal{k}}({q_{{1}}\\setminus\\{i\\}})}=\\{{{u}\\rightarrow{ux } } , { { y}\\rightarrow{xyz } } , { { x}\\rightarrow{xy}}\\}}\\\\[0.6ex ] { { \\mathsf{key}}({i})}=\\{x\\ } & { { i}^{+,{q_{{1}}}}}=\\{x , y , z\\ } \\end{array } $ ]    let @xmath0 be an acyclic boolean conjunctive query .",
    "let @xmath64 be a join tree for @xmath0 .",
    "the _ attack graph _ of @xmath64 is a directed graph whose vertices are the atoms of @xmath0 .",
    "there is a directed edge from @xmath44 to @xmath62 if @xmath102 are distinct atoms such that for every label @xmath66 on the unique path that links @xmath44 and @xmath62 in @xmath64 , we have @xmath103",
    ".    we write @xmath104 if the attack graph of @xmath64 contains a directed edge from @xmath44 to @xmath62 . the directed edge @xmath104",
    "is also called an _ attack from @xmath44 to @xmath62_. if @xmath104 , we say that @xmath44 _ attacks _ @xmath62 ( or that @xmath62 is attacked by @xmath44 ) .",
    "this is a continuation of example  [ ex : keycl ] .",
    "[ fig : ax ] ( left ) shows a join tree @xmath105 for query @xmath106 .",
    "the attack graph of @xmath105 is shown in fig .",
    "[ fig : ax ] ( right ) and is computed as follows .",
    "let us first compute the attacks outgoing from @xmath44 .",
    "the path from @xmath44 to @xmath62 in the join tree is @xmath107 .",
    "since the label @xmath108 is not contained in @xmath109 , the attack graph contains a directed edge from @xmath44 to @xmath62 , i.e. , @xmath110 .",
    "the path from @xmath44 to @xmath111 in the join tree is @xmath112 .",
    "since no label on that path is contained in @xmath109 , the attack graph contains a directed edge from @xmath44 to @xmath111 . in the same way",
    ", one finds that @xmath44 attacks @xmath113 .",
    "let us next compute the attacks outgoing from @xmath111 .",
    "the path from @xmath111 to @xmath62 in the join tree is @xmath114 .",
    "since the label @xmath115 is not contained in @xmath116 , the attack graph contains a directed edge from @xmath111 to @xmath62 , .i.e . , @xmath117 .",
    "the path from @xmath111 to @xmath44 in the join tree is @xmath118 .",
    "since the label @xmath108 is contained in @xmath119 , the attack graph contains no directed edge from @xmath111 to @xmath44 . and so on .",
    "the complete attack graph is shown in fig .  [",
    "fig : ax ] ( right ) .",
    "remarkably , it was shown in  @xcite that if @xmath120 and @xmath121 are distinct join trees for the same acyclic query @xmath0 , then the attack graph of @xmath120 is identical to the attack graph of @xmath121 .",
    "this motivates the following definition .",
    "let @xmath0 be an acyclic boolean conjunctive query .",
    "the attack graph of @xmath0 is the attack graph of @xmath64 for any join tree @xmath64 for @xmath0 .",
    "we write @xmath122 ( or simply @xmath123 if @xmath0 is clear from the context ) to indicate that the attack graph of @xmath0 contains a directed edge from @xmath44 to @xmath62 .",
    "we write @xmath124 if it is not the case that @xmath122 .",
    "the attack graph of an acyclic query @xmath0 can be computed in quadratic time in the length of @xmath0  @xcite .",
    "figures  [ fig : threecycles ] and  [ fig : acqthree ] show attack graphs , but omit join trees .",
    "the main result in  @xcite is the following .",
    "[ the : acyclic ] the following are equivalent for all acyclic boolean conjunctive queries @xmath0 without self - join :    1 .",
    "the attack graph of @xmath0 is acyclic .",
    "@xmath1 is first - order expressible .    finally , we provide two lemmas that will be useful later on .",
    "[ lem : rsu ] let @xmath0 be an acyclic boolean conjunctive query .",
    "let @xmath102 be distinct atoms of @xmath0 .",
    "if @xmath123 , then @xmath125 and @xmath126 .",
    "[ lem : a2 ] let @xmath0 be an acyclic boolean conjunctive query .",
    "let @xmath127 be distinct atoms of @xmath0 .",
    "if @xmath123 and @xmath128 , then @xmath129 or @xmath130 .",
    "the following definition classifies cycles in attack graphs as either strong or weak .",
    "the main result of this section is that @xmath1 is -complete for acyclic queries @xmath0 whose attack graph contains a strong cycle .",
    "let @xmath0 be an acyclic boolean conjunctive query .",
    "for every @xmath89 , we define @xmath131 as the following set of variables . @xmath132",
    "an attack @xmath123 in the attack graph of @xmath0 is called _ weak _ if @xmath133 .",
    "an attack that is not weak , is called _",
    "strong_.    a ( directed ) _ cycle of size @xmath27 _ in the attack graph of @xmath0 is a sequence of edges @xmath134 such that @xmath135 implies @xmath136 .",
    "thus , _ cycle _ means elementary cycle .",
    "a cycle in the attack graph of @xmath0 is called _ strong _ if at least one attack in the cycle is strong . a cycle that is not strong ,",
    "is called _",
    "weak_.    it is straightforward that @xmath137 .",
    "[ ex : cycles ] for the query @xmath106 in fig .",
    "[ fig : ax ] , we have the following .",
    "@xmath138 the attack @xmath139 is weak , because @xmath140 . the attack @xmath141 is strong , because @xmath142 .",
    "one can verify that the attack from @xmath62 to @xmath44 is the only strong attack in the attack graph of @xmath106 .",
    "the attack cycle @xmath143 is weak .",
    "the attack cycle @xmath144 is strong , because it contains the strong attack @xmath141 .",
    "for the same reason , the attack cycle @xmath145 is strong .",
    "example  [ ex : cycles ] showed that the attack graph of @xmath106 has a strong cycle of length  @xmath146 , and a strong cycle of length  @xmath147 .",
    "this is no coincidence , as stated by the following lemma .",
    "[ lem : two ] let @xmath0 be an acyclic boolean conjunctive query . if the attack graph of @xmath0 contains a strong cycle , then it contains a strong cycle of length @xmath147 .    .",
    "]    the following proof establishes that for every acyclic query @xmath0 whose attack graph contains a strong cycle , there exists a polynomial - time many - one reduction from @xmath148 to @xmath1 , where @xmath149 .",
    "since @xmath148 was proved -hard by kolaitis and pema  @xcite , we obtain the desired -hard lower bound for @xmath1 .",
    "as the proof is rather involved , we provide in fig .  [",
    "fig : schema ] a mnemonic for the construction in the beginning of the proof . to further improve readability ,",
    "some parts of the proof will be stated as sublemmas .    [",
    "the : strongcycle ] let @xmath0 be an acyclic boolean conjunctive query without self - join .",
    "if the attack graph of @xmath0 contains a strong cycle , then @xmath1 is * conp*-complete .",
    "since @xmath1 is obviously in , it suffices to show that it is -hard .",
    "assume that the attack graph of @xmath0 contains a strong cycle .",
    "by lemma  [ lem : two ] , we can assume @xmath150 such that @xmath151 and the attack @xmath123 is strong . for every valuation @xmath23 over @xmath152 , we define @xmath153 as the following valuation over @xmath53 .    1 .   if @xmath154 , then @xmath155 for some fixed constant @xmath156 ; 2 .   if @xmath157 , then @xmath158 ; 3 .   if @xmath159 , then @xmath160 ; 4 .",
    "if @xmath161 , then @xmath162 ; 5 .   if @xmath163 , then @xmath164 ; and 6 .   if @xmath165 , then @xmath166 .    notice that @xmath167 can be a sequence of length two or three ; two sequences of the same length are equal if they contain the same elements in the same order .",
    "the venn diagram of fig .",
    "[ fig : schema ] will come in handy : every region contains a boxed label that indicates how @xmath167 is computed for variables @xmath168 in that region .",
    "for example , assume @xmath168 belongs to the region with label @xmath169 ( i.e. , @xmath163 ) , then @xmath164 .",
    "we show three sublemmas that will be used later on in the proof .",
    "[ prop : h ] let @xmath170 be two valuations over @xmath152 . if @xmath171 such that @xmath172 , then @xmath173 is consistent .",
    "let @xmath171 such that @xmath172 .",
    "assume the following .",
    "@xmath174 it suffices to show the following .",
    "@xmath175 we consider four cases .",
    "if @xmath176 , then @xmath177 , and  ( [ eq : showeq ] ) holds vacuously . assume next @xmath178 .",
    "then it follows from  ( [ eq : assumekeyeq ] ) that no variable of @xmath179 belongs to a region of the venn diagram ( see fig .",
    "[ fig : schema ] ) that contains @xmath180 .",
    "since @xmath180 occurs in all regions outside @xmath131 , we conclude @xmath181 .",
    "since @xmath83 contains @xmath182 , it follows @xmath183 .",
    "since @xmath180 does not occur inside @xmath131 in the venn diagram , we conclude  ( [ eq : showeq ] ) .    by  ( [ eq : assumekeyeq ] )",
    ", no variable of @xmath179 belongs to a region of the venn diagram that contains @xmath184 .",
    "it follows @xmath185 . consequently , @xmath186 .",
    "since neither @xmath184 nor @xmath180 occurs inside @xmath90 in the venn diagram , we conclude  ( [ eq : showeq ] ) .",
    "first assume @xmath176 .",
    "by  ( [ eq : assumekeyeq ] ) , no variable of @xmath179 belongs to a region of the venn diagram that contains @xmath61 .",
    "consequently , @xmath187 .",
    "it follows @xmath188 .",
    "since @xmath61 does not occur inside @xmath189 in the venn diagram , we conclude  ( [ eq : showeq ] ) .",
    "next assume @xmath178 . by  ( [ eq : assumekeyeq ] )",
    ", no variable of @xmath179 belongs to a region of the venn diagram that contains @xmath61 or @xmath180 .",
    "consequently , @xmath190 .",
    "it follows @xmath191 .",
    "since neither @xmath61 nor @xmath180 occurs inside @xmath192 in the venn diagram , we conclude  ( [ eq : showeq ] ) .    by  ( [ eq : assumekeyeq ] ) , no variable of @xmath179 belongs to a region of the venn diagram that contains @xmath61 or @xmath184 .",
    "consequently , @xmath193 .",
    "it follows @xmath194 .",
    "since none of @xmath61 , @xmath184 , or @xmath180 occurs inside @xmath195 in the venn diagram , we conclude  ( [ eq : showeq ] ) .",
    "this concludes the proof of sublemma  [ prop : h ] .",
    "[ prop : f ] let @xmath170 be two valuations over @xmath152 .    1",
    ".   @xmath196 and @xmath197 are key - equal @xmath198 @xmath199 .",
    "2 .   @xmath200 @xmath198 @xmath199 and @xmath201 .",
    "[ prop : g ] let @xmath170 be two valuations over @xmath152 .    1",
    ".   @xmath202 and @xmath203 are key - equal @xmath198 @xmath201 and @xmath176 .",
    "2 .   @xmath204 @xmath198 @xmath177 .",
    "we continue the proof of theorem  [ the : strongcycle ] .",
    "let @xmath205 , @xmath206 . the signatures of @xmath207 and @xmath208 are @xmath209}$ ] and @xmath210}$ ] respectively .",
    "let @xmath211 and @xmath212 . in the remainder of the proof ,",
    "we establish a polynomial - time many - one reduction from @xmath148 to @xmath1 .",
    "-hardness of @xmath1 then follows from -hardness of @xmath148 , which was established in  @xcite .",
    "let @xmath77 be an uncertain database .",
    "by lemma  [ lem : purified ] , we can assume that @xmath77 is purified relative to @xmath213 .",
    "let @xmath214 be the set of valuations @xmath23 over @xmath152 such that @xmath215 .",
    "since @xmath77 is purified , the following holds .",
    "@xmath216 let @xmath217 .",
    "since @xmath214 can be computed in polynomial time in the size of @xmath77 , the reduction from @xmath77 to @xmath2 is in polynomial time .",
    "since @xmath0 contains no self - join , the set @xmath2 is partitioned by the three disjoint subsets defined next .",
    "@xmath218 since @xmath219 is consistent by sublemma  [ prop : h ] , every repair of @xmath2 is the disjoint union of @xmath219 , a repair of @xmath220 , and a repair of @xmath221 . in the next step of the proof ,",
    "we establish a one - to - one relationship between repairs of @xmath77 and repairs of @xmath2 .",
    "the function @xmath222 will map repairs of @xmath77 to repairs of @xmath2 .",
    "for every repair @xmath223 of @xmath77 , @xmath224 is the disjoint union of three sets , as follows .",
    "@xmath225 clearly , the first of these three sets is contained in @xmath220 , and the second in @xmath221 . by sublemmas  [ prop : f ] and",
    "[ prop : g ] , for every @xmath226 , @xmath227 to prove the @xmath228-direction of ( [ eq : f ] ) ( the other implications are straightforward ) , assume @xmath229 with @xmath230 . by the definition of @xmath222 , we can assume @xmath231 such that @xmath232 and @xmath233 . from @xmath234",
    ", it follows by sublemma  [ prop : f ] that @xmath235 , hence @xmath236 .",
    "the following sublemma states that @xmath222 is a bijection from the set of repairs of @xmath77 to the set of repairs of @xmath2 .",
    "[ prop : bijection ]    1 .",
    "if @xmath223 is a repair of @xmath77 , then @xmath224 is a repair of @xmath2 .",
    "2 .   for every repair @xmath237 of @xmath2",
    ", there exists a repair @xmath223 of @xmath77 such that @xmath238 .",
    "3 .   if @xmath239 are distinct repairs of @xmath77 , then @xmath240 .    to conclude the proof of theorem  [ the : strongcycle ] ,",
    "we show : @xmath241 by sublemma  [ prop : bijection ] , it is sufficient to prove that for every repair @xmath223 of @xmath77 , @xmath242 assume @xmath243 .",
    "we can assume @xmath226 such that @xmath244 .",
    "obviously , @xmath245 .",
    "assume @xmath246 .",
    "we can assume a valuation @xmath247 over @xmath53 such that @xmath248 .",
    "let @xmath64 be a join tree for @xmath0 .",
    "let @xmath249 be the unique path in @xmath64 between @xmath44 and @xmath62 , where @xmath250 and @xmath251 . for @xmath252",
    ", we can assume @xmath253 such that @xmath254 .",
    "let @xmath255 .",
    "we show @xmath256 and @xmath257 .",
    "since @xmath151 , the label @xmath258 contains a variable @xmath259 such that @xmath260 and a variable @xmath261 such that @xmath262 ( possibly @xmath263 ) .    since @xmath264",
    ", it must be the case that @xmath265 . since @xmath184 occurs in every region outside @xmath90 in the venn diagram ( fig .",
    "[ fig : schema ] ) and @xmath260 , it is correct to conclude @xmath257 .    likewise , since @xmath266 , it must be the case that @xmath267 . since @xmath61 occurs in every region outside @xmath189 in the venn diagram and @xmath262 , it is correct to conclude @xmath256 .    consequently , @xmath268 and @xmath269 . from @xmath270 , @xmath250 , and @xmath251",
    ", it follows @xmath271 by  ( [ eq : f ] ) and  ( [ eq : g ] ) .",
    "since @xmath272 and @xmath273 agree on each variable in @xmath274 , it follows @xmath243 .",
    "this concludes the proof of theorem  [ the : strongcycle ] .",
    "we conjecture that if the attack graph of an acyclic query @xmath0 contains no strong cycle , then @xmath1 is in .",
    "[ con : weak ] let @xmath0 be an acyclic boolean conjunctive query without self - join .",
    "if all cycles in the attack graph of @xmath0 are weak , then @xmath1 is in .",
    "notice that by theorem  [ the : acyclic ] , we know that conjecture  [ con : weak ] holds in the special case where @xmath0 s attack graph contains no cycle at all .",
    "theorem  [ the : strongcycle ] and conjecture  [ con : weak ] together imply that for every acyclic query @xmath0 , @xmath1 is either in  or -complete . in the following section , a somewhat weaker version of conjecture  [ con : weak ]",
    "is proved .",
    "we show a weaker version of conjecture  [ con : weak ] . in this weaker version",
    ", the premise  all cycles are weak \" is strengthened into  all cycles are weak and terminal . \"    a cycle in a directed graph is called _ terminal _ if the graph contains no directed edge from a vertex in the cycle to a vertex outside the cycle .",
    "a cycle is _ nonterminal _ if it is not terminal .",
    "figure  [ fig : threecycles ] shows the attack graph of the acyclic query @xmath275 , @xmath276 , @xmath277 , @xmath278 , @xmath279 , @xmath280 .",
    "all attack cycles are terminal and weak .    in the attack graph of fig .",
    "[ fig : acqthree ] , all cycles are weak , but no cycle is terminal .    [",
    "the : outdegree ] let @xmath0 be an acyclic boolean conjunctive query without self - join .",
    "if all cycles in the attack graph of @xmath0 are weak and terminal , then @xmath1 is in .",
    "notice that if a query @xmath0 has exactly two atoms , then @xmath0 is acyclic and every cycle in @xmath0 s attack graph must be terminal",
    ". therefore theorems  [ the : strongcycle ] and  [ the : outdegree ] together imply the dichotomy theorem of kolaitis and pema  @xcite .",
    "to prove theorem  [ the : outdegree ] , we need four helping lemmas . in simple words ,",
    "the first lemma states that if we replace a variable with a constant in an acyclic query , then no new attacks are generated , and weak attacks can not become strong .",
    "let @xmath0 be a boolean conjunctive query .",
    "if @xmath281 is a sequence of distinct variables and @xmath282 a sequence of constants , then @xmath283}}$ ] denotes the query obtained from @xmath0 by replacing each occurrence of @xmath284 with @xmath285 , for all @xmath286 .",
    "if @xmath23 is a valuation , then @xmath287}}$ ] is the valuation such that @xmath287}}(\\vec{x})=\\vec{a}$ ] and @xmath287}}(y)=\\theta(y)$ ] if @xmath288 .",
    "[ lem : weakweak ] let @xmath0 be an acyclic boolean conjunctive query without self - join .",
    "let @xmath150 .",
    "let @xmath289 and let @xmath290 be a constant .",
    "let @xmath291}}$ ] , @xmath292}}$ ] , and @xmath293}}$ ] . then , the following hold .    1",
    ".   @xmath294 is acyclic .",
    "2 .   if @xmath295 , then @xmath122 .",
    "if @xmath295 and @xmath122 is a weak attack , then @xmath295 is a weak attack .",
    "[ lem : terminalcycles ] let @xmath0 be an acyclic boolean conjunctive query .",
    "if each cycle in the attack graph of @xmath0 is terminal , then each cycle in the attack graph has length @xmath147 .",
    "[ lem : sharedvariables ] let @xmath0 be an acyclic boolean conjunctive query such that each cycle of the attack graph of @xmath0 is terminal and each atom of @xmath0 belongs to a cycle of the attack graph .    1 .   if the same variable @xmath61 occurs in two distinct cycles of the attack graph , then for each atom @xmath44 in these cycles , @xmath296 .",
    "2 .   if @xmath122 is a weak attack , then @xmath297 .",
    "the following lemma applies to queries with an atom whose primary key contains no variables .    [",
    "lem : se3 ] let @xmath0 be a boolean conjunctive query without self - join .",
    "let @xmath89 such that @xmath298 .",
    "let @xmath299 .",
    "let @xmath300 be a sequence of distinct variables such that @xmath301 .",
    "let @xmath2 be an uncertain database that is purified relative to @xmath0 , and let @xmath302 be the active domain of @xmath2 .",
    "then the following are equivalent :    1 .",
    "2 .   @xmath303 and for all @xmath304 , if @xmath305}}\\in{{\\mathbf{db}}}$ ] , then @xmath306}}})}$ ] .",
    "the proof of theorem  [ the : outdegree ] can now be given .",
    "given uncertain database @xmath2 , we need to show that it can be decided in polynomial time ( in the size of @xmath2 ) whether @xmath69 .",
    "let @xmath302 be the active domain of @xmath2 . by lemma  [ lem : purified",
    "] , we can assume that @xmath2 is purified relative to @xmath0 .",
    "the proof runs by induction on the length of @xmath0 . for the base of the induction",
    ", we consider the case where the attack graph of @xmath0 contains no unattacked atom ( i.e. , no atom has zero indegree ) .",
    "@xmath1 is obviously in  if @xmath307 .",
    "assume next that @xmath0 is nonempty .",
    "since all cycles of @xmath0 s attack graph are terminal and every atom has an incoming attack , every atom of @xmath0 belongs to some cycle of the attack graph . by lemma  [ lem : terminalcycles ] ,",
    "the attack graph of @xmath0 is a set of disjoint weak cycles @xmath308 , ",
    ", @xmath309 for some @xmath310 . for @xmath286 ,",
    "let @xmath311 , and let @xmath312 be a sequence of distinct variables that contains every variable @xmath313 such that for some @xmath314 , @xmath315 .",
    "by lemma  [ lem : sharedvariables ] , @xmath316 .    for @xmath286 ,",
    "let @xmath317 be the subset of @xmath2 containing every fact @xmath49 with the same relation name as @xmath318 or @xmath319 . call a _ partition _ of @xmath317 a maximal subset @xmath320 of @xmath317 such that for some @xmath321",
    ", for all @xmath322 , there exists a valuation @xmath23 such that @xmath323}}(f_{i})$ ] or @xmath323}}(g_{i})$ ] .",
    "the sequence @xmath324 is called the _ vector _ of partition @xmath320 .    in words , each partition of @xmath317 groups facts that can be obtained from @xmath318 or @xmath319 by replacing the variables of @xmath312 with the same fixed constants .",
    "for example , the attack graph in fig .",
    "[ fig : threecycles ] contains an attack cycle involving @xmath277 and @xmath278 .",
    "the sequence @xmath325 contains the variables that also occur in other cycles . the facts @xmath326 and @xmath327 both belong to the partition with vector @xmath328 .",
    "clearly , two facts that belong to distinct partitions of @xmath317 can not be key - equal .",
    "it follows that each repair of @xmath317 is a disjoint union of repairs , one for each partition of @xmath317 .",
    "let @xmath329 be the smallest subset of @xmath317 that contains every partition @xmath320 satisfying @xmath330 .",
    "by lemma  [ lem : sharedvariables ] and  ( * ? ? ?",
    "* theorem  2 ) , @xmath331 is in  for @xmath332 . from the following sublemma , it follows that @xmath1 is in .",
    "[ prop : shared ] the following are equivalent :    1 .",
    "2 .   @xmath333 .    for",
    "the step of the induction , assume that @xmath44 is an unattacked atom in @xmath0 s attack graph .",
    "let @xmath19 be a sequence of distinct variables such that @xmath334 . by corollary  8.11 in  @xcite , the following are equivalent .",
    "1 .   @xmath69 .",
    "2 .   for some @xmath335 , @xmath336}}})}$ ] .    let @xmath300 be a sequence of distinct variables such that @xmath337 .",
    "let @xmath299 .",
    "by lemma  [ lem : purified ] , it is possible to compute in polynomial time a database @xmath338 that is purified relative to @xmath283}}$ ] such that @xmath339}}})}\\iff{{\\mathbf{db}}}'\\in{{\\mathsf{certainty}}({{{q}_{[{{\\vec{x}}\\mapsto{\\vec{a}}}]}}})}.\\ ] ] by lemma  [ lem : se3 ] , the following are equivalent :    1 .",
    "@xmath340}}})}$ ] .",
    "2 .   @xmath341 and for all @xmath304 , if @xmath342}}\\in{{\\mathbf{db}}}'$ ] , then @xmath343}}})}$ ] .    by lemma  [ lem : weakweak ] ,",
    "all cycles in the attack graph of @xmath344}}$ ] are weak and terminal . by the induction hypothesis",
    ", it follows that @xmath345}}})}$ ] is in . since the sizes of @xmath346 and @xmath347 are polynomially bounded in the size of @xmath2 , it is correct to conclude that @xmath1 is in .",
    "theorems  [ the : strongcycle ] and  [ the : outdegree ] leave open the complexity of @xmath1 when the attack graph of @xmath0 contains one or more nonterminal weak cycles and no strong cycle . in this section ,",
    "we zoom in on acyclic queries @xmath348 , defined next for @xmath349 , whose attack graph contains @xmath350 nonterminal weak cycles and no strong cycle . by showing tractability of @xmath351 , we obtain more supporting evidence for conjecture  [ con : weak ] . as a side result",
    ", we will solve a complexity issue raised by fuxman and miller  @xcite .    for @xmath352 ,",
    "let @xmath353 and @xmath348 denote the following boolean conjunctive queries without self - join .",
    "@xmath354 where @xmath355 are distinct variables and @xmath356 distinct relation names . for @xmath357 , relation name @xmath358 is of signature  @xmath209}$ ] , and @xmath359 is of signature  @xmath360}$ ] .",
    "obviously , a query @xmath0 is acyclic if it contains an atom @xmath44 such that @xmath361 .",
    "therefore , @xmath348 is acyclic because the @xmath359-atom contains all variables that occur in the query . on the other hand",
    ", @xmath353 is acyclic if @xmath16 and cyclic if @xmath362 .    for @xmath357 ,",
    "the attack graph of @xmath348 contains attacks from the @xmath358-atom to every other atom .",
    "figure  [ fig : acqthree ] shows the attack graph of @xmath363 .",
    "all attack cycles are weak , but theorem  [ the : outdegree ] does not apply because the cycles are nonterminal .",
    "@xmath364 was claimed -hard for all @xmath352 in  @xcite .",
    "later , however , wijsen  @xcite found a mistake in the proof of that claim and showed that @xmath364 is tractable if @xmath16 .",
    "the complexity of @xmath364 for @xmath362 will be settled by corollary  [ cor : fuxman ] .    .",
    "all cycles are weak and nonterminal ]    . at the right : graph representation of @xmath365 .",
    "note that the three cycles encoded in @xmath366 are clockwise . ]    ) that falsify @xmath363 .",
    "the left cycle is anticlockwise and not encoded in @xmath366 . ]",
    "[ the : acq ] for @xmath352 , @xmath351 is in .",
    "( _ extended sketch .",
    "_ ) let @xmath2 be an uncertain database with schema @xmath367 ,  , @xmath368 , @xmath369 . by lemma  [ lem : purified",
    "] , we can assume without loss of generality that @xmath2 is purified relative to @xmath348 .",
    "let @xmath302 be the active domain of @xmath2 .",
    "for every @xmath357 , define @xmath370 as the subset of @xmath302 that contains @xmath371 if for some valuation @xmath247 , @xmath372}}({{\\mathsf{ac}}({k})})\\subseteq{{\\mathbf{db}}}$ ] .",
    "since @xmath348 has no self - join , we can assume without loss of generality that @xmath135 implies @xmath373 .",
    "for example , assume @xmath374 with @xmath375 .",
    "since @xmath376 , @xmath377 , and @xmath378 , it follows that @xmath379 and that @xmath380 implies @xmath381 .",
    "the @xmath358-facts of @xmath2 can be viewed as edges of a directed graph ( @xmath382 ) .",
    "this is illustrated in fig .",
    "[ fig : acq ] for @xmath383 .",
    "let @xmath384 be the directed graph such that @xmath385 and @xmath386 .",
    "then , @xmath62 is @xmath387-partite with vertex classes @xmath388 ,  , @xmath389 . furthermore ,",
    "whenever @xmath390 and @xmath376 , then @xmath377 if @xmath391 ( and @xmath392 if @xmath393 ) .",
    "it follows that the length of every elementary cycle in @xmath62 must be a multiple of @xmath387 .",
    "since @xmath2 is purified , no vertex has zero outdegree .",
    "we define @xmath394 as the set of cycles of length @xmath387 such that if @xmath2 contains @xmath395 , then @xmath394 contains the cycle @xmath396 .",
    "since @xmath2 is purified , @xmath62 is a vertex - disjoint union of strong components @xmath397 ( for some @xmath398 ) such that for @xmath135 , no edge leads from a vertex in @xmath399 to a vertex in @xmath400 .",
    "is a maximal strongly connected subgraph of @xmath62 .",
    "a graph is strongly connected if there is a path from any vertex to any other . ]    in what follows , some vertices and edges of @xmath62 will be _ marked_. it is straightforward that @xmath401 is equivalent to the following .",
    "we provide a polynomial - time algorithm for testing condition  ( [ eq : nocalc ] ) .",
    "marking one outgoing edge for each vertex will create a cycle of marked edges in each strong component .",
    "for each strong component @xmath399 , consider the following cases successively and execute the first one that applies .",
    "such a cycle is illustrated by fig .  [",
    "fig : acqrep ] ( left ) .",
    "mark all vertices and edges of the cycle .",
    "notice that the number of cycles of length @xmath387 is at most @xmath403 , which is polynomial in the size of @xmath2 .",
    "such a cycle is illustrated by fig .  [ fig : acqrep ] ( right ) .",
    "mark all vertices and edges of the cycle . to see that this step is in polynomial time , notice that the following are equivalent :    * @xmath399 contains an elementary cycle of length greater than @xmath387 .",
    "* @xmath399 contains a path @xmath404 such that @xmath405 and @xmath399 contains a path from @xmath406 to @xmath407 that contains no edge from @xmath408 .",
    "the latter condition can be tested in polynomial time , because there are at most @xmath409 distinct choices for @xmath404 and paths can be found in polynomial time .",
    "conclude that  ( [ eq : nocalc ] ) is false .",
    "if after the previous step every strong component contains a cycle of marked edges , then it is correct to conclude that  ( [ eq : nocalc ] ) is true .",
    "notice that every cycle of @xmath394 now contains at least one unmarked edge .",
    "we can achieve  ( [ eq : nocalc ] ) by marking , for each yet unmarked vertex , the vertices and edges on a shortest path to some marked vertex .",
    "this can be done without creating new cycles of marked edges .    since query @xmath353 is acyclic if @xmath362 , attack graphs are not defined for @xmath353 if @xmath362 .",
    "nevertheless , the following lemma immediately implies that if @xmath351 is tractable , then so is @xmath364 .",
    "[ lem : cq ] let @xmath0 be a boolean conjunctive query without self - join .",
    "if @xmath410 and every atom in @xmath411 is all - key , then there exists an @xmath8  many - one reduction from @xmath412 to @xmath1 .",
    "[ cor : fuxman ] for @xmath352 , @xmath364 is in .",
    "unsurprisingly , there exist acyclic queries @xmath413 whose attack graph contains some nonterminal cycle and no strong cycle .",
    "the complexity of @xmath1 for such queries @xmath0 is open .",
    "in this section , we study the relationship between the complexities of @xmath1 and evaluating @xmath0 on probabilistic databases .",
    "the motivation is that , on input of an uncertain database @xmath2 , the problem @xmath1 is solved if we can determine whether query @xmath0 evaluates to probability  @xmath10 on the probabilistic database obtained from @xmath2 by assuming a uniform probability distribution over the set of repairs of @xmath2 .",
    "we show , however , that this approach provides no new insights in the tractability frontier of @xmath1 .",
    "in this section , we review an important result from probabilistic database theory .",
    "a _ possible world _ @xmath414 of uncertain database @xmath2 is a consistent subset of @xmath2 .",
    "the set of possible worlds of @xmath2 is denoted @xmath415 .",
    "notice that possible worlds , unlike repairs , need not be maximal consistent .",
    "a _ probabilistic database _ is a pair @xmath416 where @xmath2 is an uncertain database and @xmath417}$ ] is a total function such that @xmath418 .",
    "we will assume that the numbers in the codomain of @xmath419 are rational .",
    "the following definition extends the function @xmath419 to boolean first - order queries @xmath0 .",
    "[ def : extpr ] let @xmath416 be a probabilistic database .",
    "let @xmath0 be a boolean first - order query .",
    "we define @xmath420 in words , @xmath421 sums up the probabilities of the possible worlds that satisfy @xmath0 .    of special interest is the application of definition  [ def : extpr ] in case @xmath0",
    "is a single fact , or a boolean combination of facts .",
    "notice that if @xmath416 is a probabilistic database and @xmath422 are distinct facts belonging to a same block of @xmath2 , then @xmath423 , because no possible world can contain two distinct facts that belong to a same block .",
    "probabilistic database @xmath416 is called _ block - independent - disjoint _ ( bid ) if the following holds : whenever @xmath422 are facts of @xmath2 taken from @xmath27 distinct blocks ( for some @xmath424 ) , then @xmath425 .",
    "theorem  2.4 in  @xcite implies that every bid probabilistic database @xmath416 is uniquely determined if @xmath426 is given for every fact @xmath47 .",
    "this allows for an efficient encoding : rather than specifying @xmath427 for every @xmath428 , it suffices to specify @xmath426 for every @xmath47 . in the complexity results that follow ,",
    "this efficient encoding is assumed .",
    "notice that we can turn an uncertain database @xmath2 into a bid probabilistic database by assuming that the probabilities of all repairs are equal and sum up to @xmath10 .",
    "a consistent subset of @xmath2 that is not maximal , would then have zero probability .",
    "given a boolean query @xmath0 , @xmath429 is the following function problem : on input of a bid probabilistic database @xmath416 , determine the value of @xmath421 .    a boolean conjunctive query @xmath0 , without self - join ,",
    "is called _ safe _ if algorithm  [ algo : issafe ] returns @xmath430 .",
    "the following result establishes a dichotomy in the complexity of @xmath429 .    [",
    "the : suciu ] let @xmath0 be a boolean conjunctive query without self - join .    1 .",
    "if @xmath0 is safe , then @xmath429 is in . 2 .",
    "if @xmath0 is not safe , then @xmath429 is -hard .",
    "the following proposition establishes a straightforward relationship between the problems @xmath429 and @xmath1 .",
    "the only subtlety is that a repair contains a fact of each block , while a possible world and a block may have an empty intersection ( recall that possible worlds , unlike repairs , need not be maximal consistent ) . in the statement of this proposition , @xmath338 restricts @xmath2 to the set of blocks whose probabilities sum up to  @xmath10 .",
    "[ prop : bid ] let @xmath416 be a bid probabilistic database .",
    "let @xmath338 be the smallest subset of @xmath2 that contains every block @xmath431 of @xmath2 such that @xmath432 .",
    "let @xmath0 be a boolean conjunctive query .",
    "then the following are equivalent :    1 .",
    "2 .   on input @xmath416 , the answer to the function problem",
    "@xmath429 is @xmath10 .",
    "the following theorem establishes a nontrivial relationship between the complexities of @xmath1 and @xmath429 .",
    "notice that the query @xmath0 in the theorem s statement is not required to be acyclic .",
    "[ the : prob ] let @xmath0 be a boolean conjunctive query without self - join . if @xmath0 is safe , then @xmath1 is first - order expressible .",
    "the proof runs by induction on the execution of algorithm  [ algo : issafe ] .",
    "since @xmath0 is safe , some rule of [ algo : issafe ] applies to @xmath0 .    if @xmath0 consists of a single fact , then @xmath1 is obviously first - order expressible .",
    "let @xmath434 with @xmath435 and @xmath436 . since @xmath0 is safe , @xmath437 and @xmath438 are safe by definition of safety .",
    "by the induction hypothesis , there exists a certain first - order rewriting @xmath439 of @xmath437 , and a certain first - order rewriting @xmath440 of @xmath438 .",
    "obviously , @xmath441 is a certain first - order rewriting of @xmath0",
    ".    assume variable @xmath61 such that for every @xmath89 , @xmath296 . by definition of safety",
    ", @xmath442}}$ ] is safe .",
    "it can be easily seen that @xmath69 if and only if for some constant @xmath371 , @xmath443}}})}$ ] . by the induction hypothesis , @xmath444}}})}$ ]",
    "is first - order expressible .",
    "let @xmath68 be a certain first - order rewriting of @xmath445}}$ ] , where we assume without loss of generality that @xmath290 is a constant that does not occur in @xmath0 .",
    "let @xmath446 be the first order formula obtained from @xmath68 by replacing each occurrence of @xmath290 with @xmath61 . then , @xmath447 of a certain first - order rewriting of @xmath0 .",
    "assume @xmath89 such that @xmath298 and @xmath448 .",
    "let @xmath19 be a sequence of distinct variables such that @xmath449 .",
    "let @xmath450 be a sequence of length @xmath21 . by definition of safety , @xmath283}}$ ]",
    "is safe . by the induction hypothesis , @xmath451}}})}$ ] is first - order expressible . from lemma  8.6 in  @xcite",
    ", it follows that @xmath1 is first - order expressible    [ cor : prob ] let @xmath0 be a boolean conjunctive query without self - join . if @xmath1 is not first - order expressible , then the function problem @xmath429 is -hard .    for acyclic queries ,",
    "the only complexities of @xmath1 left open by theorems  [ the : acyclic ] , [ the : strongcycle ] , and  [ the : outdegree ] concern queries @xmath0 with a cyclic attack graph ( in particular , an attack graph without strong cycle and with at least one nonterminal weak cycle ) .",
    "for such a query @xmath0 , @xmath1 is not first - order expressible ( by theorem  [ the : acyclic ] ) , hence @xmath429 is -hard ( by corollary  [ cor : prob ] ) .",
    "consequently , the probabilistic database approach fails to provide further insight into the tractability frontier of @xmath1 .",
    "it turns out that the queries @xmath0 for which @xmath429 is tractable is a very restricted subset of the queries for which @xmath1 is tractable ( assuming @xmath452 and @xmath453 ) .",
    "in the following , we say that a class @xmath454 of function problems _ exhibits an effective --dichotomy _ if all problems in @xmath454 are either in  or -hard and it is decidable whether a given problem in @xmath454 is in  or -hard .",
    "likewise , we say that a class @xmath454 of decision problems _ exhibits an effective --dichotomy _",
    "if all problems in @xmath454 are either in  or -hard and it is decidable whether a given problem in @xmath454 is in  or -hard .",
    "recall from section  [ sec : related ] that @xmath18 is the counting variant of @xmath1 , which takes as input an uncertain database @xmath2 and asks how many repairs of @xmath2 satisfy query @xmath0 . for the probabilistic and counting variants of @xmath1 , the following dichotomies have been established .",
    "[ the : dichotomy ] the following classes exhibit an effective --dichotomy :    1 .",
    "the class containing @xmath429 for all boolean conjunctive queries @xmath0 without self - join ; and 2 .",
    "the class containing @xmath18 for all boolean conjunctive queries @xmath0 without self - join .    theorem  [ the : strongcycle ] and conjecture  [ con : weak ] imply the following conjecture , which is thus weaker than conjecture  [ con : weak ] .",
    "[ con : dichotomy ] the class containing @xmath1 for all acyclic boolean conjunctive queries @xmath0 without self - join exhibits an effective --dichotomy .    from theorems  [ the : strongcycle ] and  [ the : outdegree ]",
    ", it follows that in order to prove conjecture  [ con : dichotomy ] , it suffices to show that an effective --dichotomy is exhibited by the class containing @xmath1 for all queries @xmath0 whose attack graph contains some nonterminal cycle and no strong cycle .",
    "we confidently believe that the -dichotomy of conjecture  [ con : dichotomy ] ( if true ) will be harder to prove than the -dichotomies established by theorem  [ the : dichotomy ] , for the following reasons .",
    "all problems @xmath429 that are in  can be solved by a single , fairly simple polynomial - time algorithm which appears in  @xcite .",
    "likewise , all problems @xmath18 in  can be solved by a single , fairly simple polynomial - time algorithm  @xcite . on the other hand ,",
    "@xmath1 problems in  seem to ask for sophisticated polynomial - time algorithms . in their proof that conjecture  [ con : dichotomy ] holds for queries with exactly two atoms , kolaitis and pema  @xcite made use of an ingenious polynomial - time algorithm of minty  @xcite .",
    "our proof of theorem  [ the : acq ] uses algorithms from ( directed ) graph theory . despite their sophistication ,",
    "these polynomial - time algorithms only solve restricted cases of @xmath1 .",
    "notice also that by corollary  [ cor : prob ] and theorem  [ the : acyclic ] , the function problem @xmath429 is intractable for all acyclic queries @xmath0 with a cyclic attack graph . on the other hand ,",
    "cycles in attack graphs are exactly what makes conjecture  [ con : dichotomy ] hard to prove .",
    "0.9    10    .",
    "addison - wesley , 1995 .",
    "consistent query answers in inconsistent databases . in",
    "_ pods _ ( 1999 ) , acm press , pp .",
    "6879 .    on the desirability of acyclic database schemes . , 3 ( 1983 ) , 479513 .",
    "synthesis lectures on data management .",
    "morgan & claypool publishers , 2011 .",
    "inconsistency - tolerant conjunctive query answering for simple ontologies . in _ description logics _ ( 2012 ) , y.  kazakov , d.  lembo , and f.  wolter , eds .",
    "846 of _ ceur workshop proceedings _ , ceur-ws.org .",
    "minimal - change integrity maintenance using tuple deletions .",
    ", 1 - 2 ( 2005 ) , 90121 .",
    "probabilistic databases : diamonds in the dirt .",
    ", 7 ( 2009 ) , 8694 .",
    "queries and materialized views on probabilistic databases . , 3 ( 2011 ) , 473490 .",
    "first - order query rewriting for inconsistent databases . in",
    "_ icdt _ ( 2005 ) , t.  eiter and l.  libkin , eds . ,",
    "3363 of _ lecture notes in computer science _ ,",
    "springer , pp .",
    "337351 .",
    "first - order query rewriting for inconsistent databases . , 4 ( 2007 ) , 610635 .",
    "hypertree decompositions and tractable queries . , 3 ( 2002 ) , 579627 .",
    "consistent query answering under key and exclusion dependencies : algorithms and experiments . in _",
    "cikm _ ( 2005 ) , o.  herzog , h .- j .",
    "schek , n.  fuhr , a.  chowdhury , and w.  teiken , eds . ,",
    "acm , pp .",
    "792799 .    a dichotomy in the complexity of consistent query answering for queries with two atoms .",
    ", 3 ( 2012 ) , 7785 .    on the structure of polynomial time reducibility . , 1 ( 1975 ) , 155171 .    a dichotomy in the complexity of counting database repairs .",
    ". in press .    on counting database repairs . in _ lid _ ( 2011 ) , g.  h.  l. fletcher and s.  staworko , eds . , acm , pp .  1522",
    ".    on maximal independent sets of vertices in claw - free graphs . , 3 ( 1980 ) , 284304 .    . synthesis lectures on data management .",
    "morgan & claypool publishers , 2011 .",
    ". computer science press , 1988 .",
    "on the consistent rewriting of conjunctive queries under primary key constraints . , 7 ( 2009 ) , 578601 .    on the first - order expressibility of computing certain answers to conjunctive queries over uncertain databases . in",
    "_ pods _ ( 2010 ) , j.  paredaens and d.  v. gucht , eds . ,",
    "acm , pp .",
    "179190 .    a remark on the complexity of consistent conjunctive query answering under primary key violations . ,",
    "21 ( 2010 ) , 950  955 .    certain conjunctive query answering in first - order logic . , 2 ( 2012 ) , 9",
    "in polynomial time , we can construct a maximal sequence @xmath455 such that for @xmath456 ,    1 .",
    "@xmath457 ; 2 .",
    "there exists no valuation @xmath23 such that @xmath458 ; and 3 .",
    "@xmath459 .",
    "clearly , @xmath460 is purified relative to @xmath0 .",
    "we show that for @xmath456 , @xmath461 by contraposition .",
    "assume that @xmath237 is a repair of @xmath317 such that @xmath462 .",
    "then , @xmath463 is a repair of @xmath464 that falsifies @xmath0 . by contraposition .",
    "assume that @xmath237 is a repair of @xmath464 such that @xmath462 .",
    "obviously , @xmath465 is a repair of @xmath317 that falsifies @xmath0 .",
    "assume @xmath123 . let @xmath64 be a join tree for @xmath0 .",
    "let @xmath466 be the path in @xmath64 between @xmath44 and @xmath62 ( @xmath467 ) .",
    "we have @xmath468 .",
    "since @xmath469 and @xmath470 ( because @xmath123 ) , it must be the case that @xmath471 , hence @xmath125 .",
    "we have @xmath472 .",
    "since @xmath473 ( because @xmath123 ) , it must be the case that @xmath126 .",
    "we show that if the attack graph of @xmath0 contains a strong cycle of length @xmath27 with @xmath474 , then it contains a strong cycle of some length @xmath475 with @xmath476 .",
    "let @xmath477 be a strong cycle of length @xmath27 ( @xmath474 ) in the attack graph of @xmath0 , where @xmath135 implies @xmath478 .",
    "assume without loss of generality that the attack @xmath479 is strong .",
    "thus , @xmath480 .",
    "we write @xmath481 as shorthand for for @xmath482 .",
    "if @xmath483 , then @xmath484 is a strong cycle of length @xmath485 , and the desired result holds .",
    "assume next @xmath486 .",
    "by lemma  [ lem : a2 ] , @xmath487 .",
    "we distinguish two cases .",
    "then @xmath488 is a strong cycle of length @xmath489 .",
    "if @xmath490 , then @xmath491 is a strong cycle of length @xmath489 .",
    "assume next @xmath492 .",
    "then , from @xmath493 and lemma  [ lem : a2 ] , it follows @xmath494 .",
    "the cycle @xmath495 has length @xmath485 .",
    "it suffices to show that the attack @xmath496 is strong .",
    "assume towards a contradiction that the attack @xmath496 is weak .",
    "then , @xmath497 . since @xmath487 is a weak attack , @xmath498 . by transitivity , @xmath499 , a contradiction .",
    "this concludes the proof .",
    "obviously , @xmath500 . from @xmath130 and lemma  [ lem : rsu ] , it follows @xmath501 .",
    "thus , we can assume @xmath502 such that @xmath157 .",
    "hence , @xmath503 and @xmath504 .",
    "since @xmath196 and @xmath197 are key - equal by the premise , @xmath505 and @xmath506 agree on all variables of @xmath42 .",
    "in particular , @xmath507 . it follows @xmath199 .",
    "assume @xmath199 .",
    "since @xmath500 , and since neither @xmath184 nor @xmath180 occurs inside @xmath90 in the venn diagram of fig .",
    "[ fig : schema ] , it is correct to conclude that @xmath196 and @xmath197 are key - equal .    from @xmath123 and",
    "lemma  [ lem : rsu ] , it follows @xmath126 . since @xmath500",
    ", we can assume a variable @xmath508 such that @xmath509 .",
    "from the premise @xmath200 , it follows @xmath507 .",
    "since @xmath184 occurs in all regions outside @xmath90 in the venn diagram , we conclude @xmath201 .",
    "finally , @xmath199 follows from item  @xmath10 proved before .",
    "assume @xmath199 and @xmath201 .",
    "since @xmath510 , and since @xmath180 does not occur inside @xmath131 in the venn diagram , it is correct to conclude @xmath200 .",
    "this concludes the proof of sublemma  [ prop : f ] .",
    "obviously , @xmath511 .",
    "since @xmath123 is a strong attack , @xmath512 .",
    "we can assume @xmath513 such that @xmath159 .",
    "consequently , @xmath514 and @xmath515 .",
    "since @xmath196 and @xmath197 are key - equal by the premise , @xmath505 and @xmath506 agree on all variables of @xmath516 .",
    "in particular , @xmath507 .",
    "it follows @xmath201 and @xmath176 .",
    "assume @xmath201 and @xmath176 . since @xmath511 , and since @xmath61 does not occur inside @xmath189 in the venn diagram , it is correct to conclude that @xmath202 and @xmath203 are key - equal .    from @xmath130 and",
    "lemma  [ lem : rsu ] , it follows @xmath517 . since @xmath511",
    ", we can assume a variable @xmath518 such that @xmath519 .",
    "from the premise @xmath204 , it follows @xmath507 .",
    "since @xmath61 occurs in all regions outside @xmath189 in the venn diagram , we conclude @xmath199 .",
    "finally , @xmath201 and @xmath176 follow from item  @xmath10 proved before .",
    "this concludes the proof of sublemma  [ prop : g ] .",
    "assume @xmath223 is a repair of @xmath77 .",
    "we first show that @xmath520 contains no two distinct key - equal facts .",
    "let @xmath521 .",
    "we can assume @xmath522 such that @xmath523 , @xmath524 , and @xmath525 .",
    "by sublemma  [ prop : f ] , if @xmath49 and @xmath526 are key - equal and distinct , then @xmath527 and @xmath528 are key - equal and distinct , contradicting that @xmath223 is a repair .",
    "we conclude by contradiction that @xmath520 contains no distinct key - equal facts .    in an analogous way",
    ", one can use sublemma  [ prop : g ] to show that @xmath529 contains no distinct key - equal facts . since @xmath219 is consistent",
    ", it follows that @xmath224 is consistent .",
    "we next show that @xmath224 is a maximal consistent subset of @xmath2 .",
    "let @xmath530 .",
    "we need to show that @xmath224 contains a fact that is key - equal to @xmath49 .",
    "we can assume @xmath226 such that @xmath230 .",
    "since @xmath77 contains @xmath531 ( by definition of @xmath214 ) , @xmath223 contains @xmath532 for some @xmath231 with @xmath533 .",
    "consequently , @xmath224 contains @xmath534 . by sublemma  [ prop : f ] , @xmath49 and @xmath534 are key - equal .",
    "we conclude that @xmath224 contains a fact that is key - equal to @xmath49 .    in an analogous way",
    ", one can use sublemma  [ prop : g ] to show that for every @xmath535 , @xmath224 contains a fact that is key - equal to @xmath49 .    let @xmath237 be a repair of @xmath2 .",
    "let @xmath223 be the following subset of @xmath77 .",
    "@xmath536 we show @xmath238 .",
    "since @xmath537 , it suffices to show @xmath538 and @xmath539 .",
    "let @xmath540 .",
    "let @xmath230 , @xmath226 ( the case where @xmath541 is analogous ) .",
    "then by definition of @xmath223 , @xmath236 , hence @xmath542 .",
    "conversely , let @xmath543 .",
    "let @xmath230 , @xmath226 ( the case where @xmath541 is analogous ) . by  ( [ eq : f ] ) , @xmath236 .",
    "we can assume @xmath231 such that @xmath544 and @xmath545 .",
    "by sublemma  [ prop : f ] , @xmath545 implies @xmath546 , hence @xmath547 .",
    "using sublemmas  [ prop : f ] and  [ prop : g ] , it is straightforward to show that @xmath223 is a repair of @xmath77 .",
    "let @xmath239 be distinct repairs of @xmath77 .",
    "then there exist distinct key - equal facts @xmath548 such that @xmath549 and @xmath550 .",
    "assume @xmath548 are @xmath207-facts ( the case where @xmath548 are @xmath208-facts is analogous ) .",
    "there exist valuations @xmath522 such that @xmath551 and @xmath552 . by sublemma  [ prop : f ] , @xmath196 and @xmath197 are distinct and key - equal . since @xmath553 and @xmath554 , and since @xmath224 , @xmath555 are consistent by property  1 shown earlier , it follows @xmath240 .",
    "this concludes he proof of sublemma  [ prop : bijection ] .",
    "let @xmath64 be a join tree for @xmath0 .",
    "let @xmath556 be the graph obtained from @xmath64 by replacing each vertex @xmath111 with @xmath557}}$ ] , and by adjusting edge labels ( that is , every label @xmath66 is replaced with @xmath558 ) . clearly , @xmath556 is a join tree for @xmath294",
    ".    let @xmath559 .",
    "let @xmath560 .",
    "let @xmath561}}$ ] . in the next paragraph , we show that @xmath562 implies @xmath563 .    the computation of the attribute closure @xmath564 by means of a standard algorithm  @xcite corresponds to constructing a maximal sequence @xmath565 where    1 .",
    "@xmath566 ; and 2 .   for every @xmath567 , 1",
    ".   @xmath568 .",
    "thus , @xmath569 contains the functional dependency @xmath570 .",
    "2 .   @xmath571 and @xmath572 .",
    "then , @xmath573 .",
    "consider now the following sequence .",
    "@xmath574}}\\\\                   &    & s_{1}\\setminus\\{z\\ }    & { { h_{2}}_{[{{z}\\mapsto{c}}]}}\\\\                   &    & \\multicolumn{1}{c}{\\vdots } & \\multicolumn{1}{c}{\\vdots}\\\\                   &    & s_{k-1}\\setminus\\{z\\ } & { { h_{k}}_{[{{z}\\mapsto{c}}]}}\\\\                   &    & s_{k}\\setminus\\{z\\ } \\end{array}\\ ] ] clearly , for every @xmath567 ,    1",
    ".   @xmath575}}\\in q'$ ] .",
    "thus , @xmath576 contains the functional dependency @xmath577}}})}}\\rightarrow{{{\\mathsf{vars}}({{{h_{i}}_{[{{z}\\mapsto{c}}]}}})}}}$ ] .",
    "@xmath578}}})}\\subseteq s_{i-1}\\setminus\\{z\\}$ ] and @xmath579}}})}$ ] .",
    "it follows that if @xmath580 and @xmath581 , then @xmath582 .    to prove  2 ,",
    "assume @xmath124 .",
    "then , the unique path in @xmath64 between @xmath44 and @xmath62 contains an edge with label @xmath66 such that @xmath583 .",
    "it follows @xmath584 .",
    "since @xmath558 is a label on the unique path in @xmath556 between @xmath585 and @xmath586 , it follows @xmath587 .    to prove  3 , assume the attack @xmath122 is weak .",
    "then @xmath588 , hence @xmath589 .",
    "it follows that the attack @xmath295 , if it exists , is weak .",
    "assume each cycle in the attack graph of @xmath0 is terminal .",
    "assume towards a contradiction that three distinct atoms @xmath127 of @xmath0 belong to a same cycle such that @xmath123 and @xmath128 .",
    "by lemma  [ lem : a2 ] , @xmath129 or @xmath130 .",
    "in both cases , the attack graph contains a nonterminal cycle , a contradiction .",
    "let @xmath64 be a join tree for @xmath0 .",
    "by lemma  [ lem : terminalcycles ] , every cycle in @xmath0 s attack graph is of the form @xmath590 .",
    "we show that if @xmath590 , then @xmath64 contains an edge @xmath591 .",
    "assume towards a contradiction that @xmath590 and there exists @xmath592 such that @xmath593 and @xmath113 lies on the ( unique ) path in @xmath64 between @xmath111 and @xmath594 .",
    "from @xmath595 , it follows @xmath596",
    ". then the cycle @xmath590 is not terminal , a contradiction",
    ".    assume variable @xmath61 occurs in two distinct cycles of @xmath0 s attack graph .",
    "we can assume disjoint cycles @xmath597 and @xmath598 such that @xmath599 and @xmath600 .",
    "assume towards a contradiction @xmath601 . by the _ connectedness condition _",
    ", if @xmath602 is an edge on the unique path in @xmath64 between @xmath44 and @xmath62 and @xmath603 , then the edge label of @xmath602 contains @xmath61 .",
    "since the cycle @xmath597 is terminal , @xmath604 .",
    "it follows @xmath605 . since @xmath601",
    ", we can assume an atom @xmath171 such that @xmath606 and @xmath607 . from @xmath608 and",
    "lemma  [ lem : rsu ] , it follows @xmath609 . by the premise of the lemma",
    ", we can assume @xmath610 such that @xmath590 . by the _ connectedness condition _",
    ", every edge label on the path in @xmath64 between @xmath44 and @xmath111 contains @xmath179 .",
    "let @xmath611 with @xmath612 be the unique path in @xmath64 between @xmath111 and @xmath44 .",
    "two cases can occur .",
    "case @xmath613 .",
    ": :    from @xmath614 , it follows    @xmath615 . since    @xmath616 ,    @xmath617 .",
    "case @xmath618 .",
    ": :    since @xmath619 and    @xmath620 , it follows    @xmath621 . since    @xmath622 ,    @xmath617 .    hence , @xmath617 . then by lemma  [ lem : rsu ] , @xmath623 , a contradiction .",
    "we conclude by contradiction @xmath296 .",
    "assume @xmath122 is a weak attack .",
    "let @xmath624 . by property 1",
    "proved above , for all @xmath625 , @xmath626 . since the attack @xmath122 is weak ,",
    "since @xmath61 does not occur in @xmath628 , it must be the case that @xmath629 .",
    "it follows @xmath297 .",
    "assume that @xmath44 is an @xmath24-atom .",
    "since @xmath2 is purified relative to @xmath0 , we can assume that the set of @xmath24-facts of @xmath2 is @xmath630}},\\dots$ ] , @xmath631}}\\}$ ] for some @xmath398 and @xmath632 .",
    "since @xmath298 , all facts of @xmath633 are key - equal .    since @xmath56 , we have @xmath310 , hence @xmath303 .",
    "let @xmath237 be a repair of @xmath2 and @xmath286 .",
    "we need to show that @xmath634}}$ ] .",
    "since @xmath635}}\\}$ ] is a repair of @xmath2 , it follows from the premise that @xmath635}}\\}\\models q$ ] .",
    "since @xmath0 contains no self - join , it follows @xmath636}}$ ] , hence @xmath634}}$ ] .",
    "let @xmath237 be a repair of @xmath2 . by the premise , for every @xmath637 , @xmath638}}$ ] .",
    "we can assume @xmath286 such that @xmath639}}\\in{{\\mathbf{r}}}$ ] . from @xmath634}}$",
    "] , it follows @xmath640 .",
    "let @xmath641 be a repair of @xmath2 such that for all @xmath286 , for all partitions @xmath320 of @xmath317 ,    * if @xmath642 , then @xmath643 contains a repair of @xmath320 falsifying @xmath644 ; and * if @xmath330 , then @xmath645 contains a repair of @xmath320 .    since @xmath69 by the premise , we have @xmath640 . for all @xmath286 , for every valuation @xmath23 , if @xmath646 , then @xmath647 must belong to the same partition of @xmath317 , hence @xmath648 .",
    "consequently , @xmath649 . since @xmath650 , we have @xmath333 .",
    "let @xmath237 be a repair of @xmath2 .",
    "let @xmath19 be a sequence of distinct variables containing every variable @xmath61 such that for some @xmath651 , @xmath652 . by the premise",
    ", we can assume @xmath335 such that @xmath653}}$ ] .",
    "let @xmath23 be the valuation over @xmath20 such that @xmath654 . for @xmath332 , @xmath655 . for @xmath332",
    ", define @xmath656 as the sequence of constants such that @xmath657 .",
    "then , for each @xmath286 , @xmath658}}$ ]",
    ". since @xmath329 contains a partition with vector @xmath659 which belongs to @xmath331 ( by construction ) , every repair of @xmath329 satisfies @xmath660}}$ ] .",
    "since @xmath237 contains a repair of @xmath329 , we conclude @xmath661}}$ ] . since @xmath19 contains all variables that occur in two distinct queries among @xmath662 , it is correct to conclude @xmath663}}$ ] . since @xmath237 is an arbitrary repair of @xmath2 , @xmath69 .",
    "let @xmath664 be the set of uncertain databases .",
    "we define a mapping @xmath665 as follows . if @xmath2 is an uncertain database with active domain @xmath302 , then @xmath666 is the smallest set such that    * for every fact @xmath47 , if the relation name of @xmath49 occurs in @xmath294 , then @xmath667 ; and * whenever @xmath668 in @xmath411 and @xmath335 , then @xmath666 contains @xmath669 .",
    "it is straightforward that @xmath670 is first - order expressible and @xmath671 .    by lemma  [ lem : cq ]",
    ", there exists an @xmath8  many - one reduction from @xmath364 to @xmath351 .",
    "then by theorem  [ the : acq ] , @xmath364 is in .",
    "let @xmath428 such that @xmath672 . we need to show @xmath673 . from @xmath672",
    ", it follows that for every block @xmath431 of @xmath2 , if @xmath432 , then @xmath414 contains a fact of @xmath431 .",
    "consequently , there exists a repair @xmath237 of @xmath338 such that @xmath674 . since @xmath640 by the premise",
    ", it follows @xmath673 .",
    "let @xmath237 be a repair of @xmath338 , hence @xmath675 .",
    "we have @xmath676 , because for every block @xmath431 of @xmath2 , if @xmath432 , then @xmath237 contains a fact of @xmath431 . by the premise , @xmath640"
  ],
  "abstract_text": [
    "<S> an uncertain database is defined as a relational database in which primary keys need not be satisfied . </S>",
    "<S> a repair ( or possible world ) of such database is obtained by selecting a maximal number of tuples without ever selecting two distinct tuples with the same primary key value . for a boolean query @xmath0 , </S>",
    "<S> the decision problem @xmath1 takes as input an uncertain database @xmath2 and asks whether @xmath0 is satisfied by every repair of @xmath2 . </S>",
    "<S> our main focus is on acyclic boolean conjunctive queries without self - join . </S>",
    "<S> previous work  @xcite has introduced the notion of ( directed ) attack graph of such queries , and has proved that @xmath1 is first - order expressible if and only if the attack graph of @xmath0 is acyclic . the current paper investigates the boundary between tractability and intractability of @xmath1 . </S>",
    "<S> we first classify cycles in attack graphs as either weak or strong , and then prove among others the following . if the attack graph of a query @xmath0 contains a strong cycle , then @xmath1 is -complete . </S>",
    "<S> if the attack graph of @xmath0 contains no strong cycle and every weak cycle of it is terminal ( i.e. , no edge leads from a vertex in the cycle to a vertex outside the cycle ) , then @xmath1 is in . </S>",
    "<S> we then partially address the only remaining open case , i.e. , when the attack graph contains some nonterminal cycle and no strong cycle . </S>",
    "<S> finally , we establish a relationship between the complexities of @xmath1 and evaluating @xmath0 on probabilistic databases . </S>"
  ]
}