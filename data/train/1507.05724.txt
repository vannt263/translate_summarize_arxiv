{
  "article_text": [
    "recent revelations about global - scale pervasive surveillance  @xcite programs have demonstrated that the privacy of internet users worldwide is at risk .",
    "these revelations suggest massive amounts of private traffic , including web browsing activities , location information , and personal communications are being harvested in bulk by domestic and foreign intelligence agencies .    to protect against these threats , several anonymity protocols , tools , and architectures have been proposed . among the most secure schemes for anonymous communications are mix networks  @xcite , which provide high - latency asynchronous messaging .",
    "onion routing networks ( most notably tor  @xcite ) , offer a balance between security and performance , enabling low - latency anonymous communication suitable for typical internet activities ( e.g.,web browsing , instant messaging , etc . ) .",
    "tor is the system of choice for over 2 million daily users  @xcite , but its design as an overlay network suffers from performance and scalability issues .",
    "tor s design requires per - connection state to be maintained by intermediate nodes , limiting the total number of concurrent anonymous connections that can take place simultaneously .",
    "the scalability and performance limitations of anonymous networks have been partially addressed by building protocols into the network layer rather than implementing them as overlays . among these high - performing schemes",
    "are lap  @xcite and dovetail  @xcite , which offer network - level low - latency anonymous communication on next - generation network architectures .",
    "the high performance of both schemes , however , results in significantly degraded security guarantees ; endpoints have little to no protection against adversaries that are not confined to a single network location , and payload protection relies on upper layer protocols which increases complexity .    in this paper , we present hornet(high - speed onion routing at the network layer ) , a highly - scalable anonymity system that leverages next - generation internet architecture design . hornetoffers payload protection by default , and can defend against attacks that exploit multiple network observation points .",
    "hornetis designed to be highly efficient : it can use short paths offered by underlying network architectures , rather than the long paths due to global redirection ; additionally , instead of keeping state at each relay , connection state ( including , e.g.,onion layer decryption keys ) is carried within packet headers , allowing intermediate nodes to quickly forward traffic without per - packet state lookup .",
    "while this paper proposes and evaluates a concrete anonymity system , a secondary goal herein is to broadly re - think the design of low - latency anonymity systems by envisioning networks where anonymous communication is offered as an in - network service to all users .",
    "for example , what performance trade - offs exist between keeping anonymous connection state at relays and carrying state in packets ?",
    "if routers perform anonymity - specific tasks , how can we ensure that these operations do not impact the processing of regular network traffic , especially in adversarial circumstances ? and if the network architecture should provide some support for anonymous communication , what should that support be ? throughout the paper we consider these issues in the design of our own system , and provide intuition for the requirements of alternative network - level anonymity systems .",
    "specifically , our contributions are the following :    * we design and implement hornet , an anonymity system that uses source - selected paths and shared keys between endpoints and routers to support onion routing . unlike other onion routing implementations , hornetrouters do not keep per - flow state or perform computationally expensive operations for data forwarding , allowing the system to scale . *",
    "we analyze the security of hornet , showing that it can defend against passive attacks , and certain types of active attacks .",
    "hornetprovides stronger security guarantees than existing network - level anonymity systems . *",
    "we evaluate the performance of hornet , showing that its anonymous data processing speed is close to that of lap and dovetail ( up to 93.5 gb / s on a 120 gb / s software router ) .",
    "this performance is comparable with that of today s high - end commodity routers  @xcite .",
    "we aim to design a network - level anonymity system to frustrate adversaries with mass surveillance capabilities .",
    "specifically , an adversary observing traffic traversing the network should be unable to link ( at large scale ) pairs of communicating hosts .",
    "this property is known as relationship anonymity  @xcite .",
    "we define _ sender anonymity _ as a communication scenario where anonymity is guaranteed for the source , but the destination s location is public ( e.g.,web sites for the guardian or der spiegel ) .",
    "we define _ sender - receiver anonymity _ as a scenario where the anonymity guarantee is extended to the destination ( e.g.,a hidden service that wishes to conceal its location ) .",
    "sender - receiver anonymity therefore offers protection for both ends , implying sender anonymity . depending on users needs , hornetcan support either sender anonymity or sender - receiver anonymity .",
    "since our scheme operates at the network layer , network location is the only identity feature we aim to conceal .",
    "exposure of network location or user identity at upper layers ( e.g.,through tcp sessions , login credentials , or browser cookies ) is out of scope for this work .",
    "we consider that provisioning anonymous communication between end users is a principal task of the network infrastructure .",
    "the network s anonymity - related infrastructures , primarily routers , assist end users in establishing temporary _ anonymous sessions _ for anonymous data transmission .",
    "we assume that the network layer is operated by a set of nodes .",
    "each node cooperates with sources to establish anonymous sessions to the intended destinations , and processes anonymous traffic within the created sessions .",
    "we require that the routing state of a node allows it to determine only the next hop .",
    "in particular , the destination is only revealed to the last node and no others .",
    "this property can be satisfied by ip segment routing  @xcite , future internet architectures ( fias ) like nira  @xcite and scion  @xcite , or pathlets  @xcite . in practice ,",
    "our abstract notion of a node could correspond to different entities depending on the architecture on which hornetis built . for instance , in niraand scion , a node corresponds to an autonomous system ( as ) ; in pathlets , a node maps to a _ vnode_.    [ [ path - and - certificate - retrieval ] ] path and certificate retrieval + + + + + + + + + + + + + + + + + + + + + + + + + + + + + +    a path is the combination of routing state of all nodes between the source and the intended destination .",
    "we assume the underlying network architecture provides a mechanism for a source to obtain such a path to a given destination .",
    "additionally , we assume that the same mechanism allows the source to fetch the public keys and certificates of on - path nodes .",
    "note that the mechanism should be privacy - preserving : the source should not reveal its network location or intent to communicate with a destination by retrieving paths , public keys , and certificates . in section  [ sec :",
    "discussion : retrieve_path ] , we further discuss how to obtain required information anonymously in selected fias . while a general solution represents an important avenue for future work , it remains outside of our present scope .",
    "[ [ public - key - verification ] ] public key verification + + + + + + + + + + + + + + + + + + + + + + +    we assume that end hosts and on - path nodes have public keys accessible and verifiable by all entities .",
    "end hosts can retrieve the public keys of other end hosts through an out - of - band channel ( e.g. , websites ) and verify them following a scheme like hip  @xcite , in which the end hosts can publish hashes of their public keys as their service names .",
    "public keys of on - path nodes are managed through a public - key infrastructure ( pki ) .",
    "for example , the source node can leverage resource public key infrastructure ( rpki )  @xcite to verify the public keys of on - path nodes .",
    "we consider an adversary attempting to conduct mass surveillance .",
    "specifically , the adversary collects and maintains a list of `` selectors '' ( e.g.,targets network locations , or higher - level protocol identifiers ) , which help the adversary trawl intercepted traffic and extract parts of it for more extensive targeted analysis  @xcite .",
    "an anonymity system should prevent an adversary from leveraging bulk communication access to select traffic that belongs to the targets .",
    "thus an adversary has to collect and analyze all traffic and can not reliably select traffic specific to targets unless it has access to the physical links adjacent to the targets .",
    "we consider an adversary that is able to compromise a fraction of nodes on the path between a source and a destination . for sender anonymity , the adversary can also compromise the destination . for sender - receiver anonymity ,",
    "the adversary can compromise at most one of the two end hosts . by compromising a node",
    ", the adversary learns all keys and settings , observes all traffic that traverses the compromised node , and is able to control how the nodes behave including redirecting traffic , fabricating , replaying , and modifying packets .",
    "however , we do not aim to prevent targeted de - anonymization attacks where an adversary invests a significant amount of resources on a single or a small set of victims .",
    "like other low - latency schemes , we can not solve targeted confirmation attacks based on the analysis of flow dynamics  @xcite . defending against such attacks using dynamic link padding",
    "@xcite would be no more difficult than in onion routing , although equally expensive .",
    "we defer the discussion and analysis of such measures to future work .",
    "hornetis designed to achieve the following anonymity and security properties :    1 .",
    "* path information integrity and secrecy*. an adversary can not modify a packet header to alter a network path without detection .",
    "the adversary should not learn forwarding information of uncompromised nodes , node s positions , or the total number of hops on a path .",
    "* no packet correlation . * an adversary who can eavesdrop on multiple links in the network can not correlate packets on those links by observing the bit patterns in the headers or payloads .",
    "this should hold regardless of whether the observed traffic corresponds to the same packet ( at different points on the network ) , or corresponds to different packets from a single session .",
    "* no session linkage .",
    "* an adversary can not link packets from different sessions , even between the same source and destination .",
    "* payload secrecy and end - to - end integrity*. without compromising end hosts , an adversary can not learn any information from the data payload except for its length and timing among sequences of packets .",
    "the basic design objectives for hornetare _ scalability _ and _ efficiency_. to enable internet - scale anonymous communication , hornetintermediate nodes must avoid keeping per - session state ( e.g.,cryptographic keys and routing information ) . instead , session state is offloaded to end hosts , who then embed this state into packets such that each intermediate node can extract its own state as part of the packet forwarding process .",
    "offloading the per - session state presents two challenges .",
    "first , nodes need to prevent their offloaded state from leaking information ( e.g.,the session s cryptographic keys ) . to address this ,",
    "each hornetnode maintains a local secret to encrypt the offloaded per - session state .",
    "we call this encrypted state a _ forwarding segment _ ( fs ) .",
    "the fs allows its creating node to dynamically retrieve the embedded information ( i.e.,next hop , shared key , session expiration time ) , while hiding this information from unauthorized third parties .",
    "the second challenge in offloading the per - session state is to combine this state ( i.e.,the fses ) in a packet in such a way that each node is able to retrieve its own fs , but no information is leaked about the network location of the end hosts , the path length , or a specific node s position on the path .",
    "learning any of this information could assist in de - anonymization attacks ( see section  [ sec : ilt ] ) . to address this challenge",
    ", the source constructs an _ anonymous header _ ( ahdr ) by combining multiple fses , and prepends this header to each packet in the session .",
    "an ahdrgrants each node on the path access to the fs it created , without divulging any information about the path except for a node s previous and next nodes ( see section  [ sec : aheader ] ) .    for efficient packet processing ,",
    "each hornetnode performs one diffie - hellman ( dh ) key exchange operation once per session during setup . for all data packets within the session ,",
    "hornetnodes use only symmetric cryptography to retrieve their state , process the ahdrand onion - decrypt ( or encrypt ) the payload . to reduce setup delay ,",
    "hornetuses only two setup packets within a single round trip between the source and the destination .",
    "therefore , session setup only incurs @xmath0 propagation delay in comparison to @xmath1 by the telescopic setup method used in tor ( where @xmath2 is the number of anonymity nodes traversed on the path ) . while for tor the default value of @xmath2 is 3 , for hornet@xmath2 might be as large as 14 ( 4.1 in the average case , and less or equal to 7 in over 99% of cases",
    "@xcite ) , which emphasizes the need to optimize setup propagation delay .",
    "anonymous sessions between a source and a destination require the source to establish state between itself and every node on the path .",
    "the state will be carried in subsequent data packets , enabling intermediate nodes to retrieve their corresponding state and forward the packet to the next hop .",
    "we now describe how the state is collected without compromising the sender s anonymity , and how this state is used to forward data packets .",
    "[ [ setup - phase ] ] setup phase + + + + + + + + + + +    to establish an anonymous session between a source @xmath3 and a public destination @xmath4 , @xmath3 uses a single round of sphinx  @xcite , a provably secure mix protocol ( an overview of sphinx is given in section  [ sec : sphinx ] ) .",
    "this round consists of two sphinx packets ( one for the forward path and one for the backward path ) each of which will anonymously establish shared symmetric keys between @xmath3 and every node on that path . for hornet",
    ", we extend the sphinx protocol to additionally anonymously collect the forwarding segments ( fses ) for each node .",
    "our modified sphinx protocol protects the secrecy and integrity of these fses , and does not reveal topology information to any node on the path .",
    "we note that using sphinx also for data forwarding would result in low throughput due to prohibitively expensive per - hop asymmetric cryptographic operations .",
    "therefore , we use sphinx only for session setup packets , which are amortized over the subsequent data transmission packets . we explain the details of the setup phase in section  [ sec : setupphase ] .    [ [ data - transmission - phase ] ] data transmission phase + + + + + + + + + + + + + + + + + + + + + + +    having collected the fses , the source is now able to construct a forward ahdrand a backward ahdrfor the forward and backward paths , respectively .",
    "ahdrs carry the fses which contain all state necessary for nodes to process and forward packets to the next hop . when sending a data packet , the source onion - encrypts the data payload using the session s shared symmetric keys , and prepends the ahdr .",
    "each node then retrieves its fs from the ahdr , onion - decrypts the packet and forwards it to the next hop , until it reaches the destination .",
    "the destination uses the backward ahdr(received in the first data packet ) . ] ) to send data back to @xmath3 , with the only difference being that the payload is encrypted ( rather than decrypted ) at each hop .",
    "we present the details of the data transmission phase in section  [ sec : datatransmission ] .",
    "sender - receiver anonymity , where neither @xmath3 nor @xmath4 knows the other s location ( e.g.,a hidden service ) , presents a new challenge : since @xmath3 does not know @xmath4 s location ( and vice versa ) , @xmath3 can not retrieve a path to @xmath4 , precluding the establishment of state between @xmath3 and nodes on the path to @xmath4 as described in section  [ sec : senderanonymity ] .    a common approach to this problem ( as adopted by tor to negotiate a rendezvous point with @xmath4 .",
    "this design provides additional scalability and attack resistance  @xcite , but increases the delay of setting up a session .",
    "hornet s design favors simplicity and performance , but nothing fundamentally prevents hornetfrom using tor s approach . ] , lap , and dovetail ) is to use a public _ rendezvous point _ ( rp ) to forward traffic between @xmath3 and @xmath4 without knowing either @xmath3 or @xmath4 .",
    "this solution would also work for hornet , but would require rps to maintain per - session state between sources and destinations .",
    "for instance , when receiving a packet from @xmath3 , an rp needs the state to determine how to send the packet to @xmath4 .",
    "maintaining per - session state on rps increases complexity , bounds the number of receivers , and introduces a state exhaustion denial - of - service attack vector .    *",
    "nested ahdrs . *",
    "our proposal for sender - receiver anonymity requires no state to be kept at the rp by nesting the necessary state for rps to forward a packet within the packet s header : a forward ahdrfrom @xmath3 to a rp will include the ahdrfrom the rp to @xmath4 ; a backward ahdrfrom @xmath4 to a rp will include the ahdrfrom the rp back to @xmath3 .",
    "briefly , to establish a hornetsession between @xmath3 and @xmath4 keeping both parties hidden from each other , @xmath4 selects a public rendezvous point @xmath5 and completes a hornetsession setup between @xmath4 and @xmath5 .",
    "@xmath4 publishes @xmath6 to a public directory .",
    "note that this ahdrleaks no information about @xmath4 s location and can only be used to send data to @xmath4 through @xmath5 within a specific time window .",
    "when @xmath3 wants to send traffic to @xmath4 , @xmath3 retrieves ( from a public directory ) @xmath6 .",
    "@xmath3 then establishes a hornetsession between @xmath3 and @xmath5 and constructs a nested ahdrwith @xmath6 inside @xmath7 .",
    "thus , when @xmath5 receives a packet from @xmath3 , @xmath5 can retrieve @xmath6 from @xmath7 and forward the packet to @xmath4 .",
    "@xmath3 also includes @xmath8 in the data payload of the first data packet to @xmath4 , allowing @xmath4 to create a return path to @xmath3 .",
    "one of the advantages of our scheme is that any node on the network can serve as a rendezvous point .",
    "in fact , multiple points can be selected and advertised , allowing the source to pick the rp closest to it . moreover , once a hornetsession has been established , @xmath3 and @xmath4 can negotiate a better ( closer ) rp ( e.g.,using private set intersection  @xcite ) . a disadvantage of the nested ahdrtechnique",
    "is that it doubles the size of the header .",
    "hornetuses two types of packets : _ setup packets _ and _ data packets _ ( see figure  [ fig : setup_pkts ] )",
    ". both types of packets begin with a common header ( @xmath9 ) which describes the packet type , the length of the longest path that the session supports , and a type - specific field . for session setup packets ,",
    "the type - specific field contains a value @xmath10 which indicates the intended expiration time of the session . for data packets , the specific value is a random nonce generated by the sender used by intermediate nodes to process the data packet .",
    "session setup packets include a nested sphinxpacket and an fs payload .",
    "data packets carry an ahdrand an onion - encrypted data payload .",
    "we explain each field in detail in section  [ sec : protocol ] .    )",
    "we now describe the details of our protocol , focusing on sender anonymity . we begin with notation ( section  [ sec : notation ] ) and initialization requirements ( section  [ sec : initialization ] ) .",
    "we then describe the establishment of anonymous communication sessions ( section  [ sec : setupphase ] ) and data transmission ( section  [ sec : datatransmission ] ) .",
    "let @xmath11 be the security parameter used in the protocol . for evaluation purposes we consider @xmath12 .",
    "@xmath13 is a prime order cyclic group of order @xmath14 ( @xmath15 ) , which satisfies the decisional diffie - hellman assumption .",
    "@xmath16 is the set of non - identity elements in @xmath13 and @xmath17 is a generator of @xmath13 . throughout this section",
    "we use the multiplicative notation for @xmath13 .",
    "let @xmath18 be the maximum length of a path , i.e.,the maximum number of nodes on a path , including the destination .",
    "we denote the length of an fs as @xmath19 and the size of an block , containing an fs and a mac of size @xmath11 , as @xmath20 .",
    "hornetuses the following cryptographic primitives :    * @xmath21 : message authentication code ( mac ) function .",
    "* @xmath22 : three cryptographic pseudo - random generators .",
    "* @xmath23 : a pseudo - random permutation , implementable as a block cipher .",
    "the value of @xmath24 will be clear from the context .",
    "* @xmath25 : encryption function , with the second parameter being the initialization vector ( iv ) ( e.g.,stream cipher in cbc mode ) .",
    "@xmath26 is a positive integer denoting the number of encrypted blocks .",
    "* @xmath27 : decryption function , inverse of @xmath28 .",
    "* @xmath29 : a family of hash functions used to key @xmath30 , with @xmath31 .",
    "we denote by rand@xmath32 a function that generates a new uniformly random string of length @xmath24 .",
    "furthermore , we define the notation for bit strings .",
    "@xmath33 stands for a string of zeros of length @xmath24 .",
    "@xmath34 is the length of the bit string @xmath35 .",
    "@xmath36}$ ] represents a substring of @xmath35 from bit @xmath24 to bit @xmath37 , with sub - index @xmath24 starting from 0 ; @xmath38}$ ] indicates the substring of @xmath35 from bit @xmath24 till the end .",
    "@xmath39 is the empty string .",
    "@xmath40 is the concatenation of string @xmath35 and string @xmath41 .",
    "we summarize protocol notation and typical values for specific parameters in table  [ tab : notation ] .    in the following protocol description ,",
    "we consider a source @xmath3 communicating with a destination @xmath4 using forward path @xmath42 traversing nodes @xmath43 and backward path @xmath44 traversing nodes @xmath45 , with @xmath46 , where @xmath47 and @xmath48 are the nodes closest to the source . without loss of generality , we let the last node on the forward path @xmath49 and refer to the destination by these two notations interchangeably .",
    "in general we use @xmath50 as superscripts to distinguish between notation referring to the forward and backward path , respectively . finally , to avoid redundancy , we use @xmath51 to denote @xmath52 , where @xmath53 can be any symbol .",
    "c|m6.5 cm term & definition + @xmath11 & security parameter ( length of keys and macs ) .",
    "@xmath54 bits ( 16 b ) .",
    "+ @xmath19 & length of a forwarding segment ( fs ) .",
    "@xmath55 bits ( 32 b ) .",
    "+ @xmath56 & length of a typical block made of an fs and a mac .",
    "@xmath57 bits ( 48 b ) .",
    "+ @xmath18 & maximum path length , including the destination . from our evaluation , @xmath58 .",
    "+ @xmath59 & source and destination .",
    "+ @xmath60 & the forward path ( from s to d ) and the backward path ( from d to s ) . + @xmath61 & lengths of the forward and backward path ( @xmath62 , when it is clear from the context to which path it refers ) . from our evaluation , @xmath63 .",
    "+ @xmath64 & the @xmath65-th node on the forward path and the @xmath66-th node on the backward path , with @xmath67 and @xmath68 .",
    "+ @xmath69 & public / private key pair of node @xmath2",
    ". + @xmath70 & secret key established between s and node @xmath71 .",
    "+ @xmath5 & routing information , which allows a node to forward a packet to the next hop . + @xmath9 & common header .",
    "first three fields of both setup packets and data packets ( see figure  [ fig : setup_pkts ] ) .",
    "+ @xmath72 & sphinx header and payload . + @xmath73 & fs payload , used to collect the fses during the setup phase .",
    "+ @xmath74 & anonymous header , used for every data packet .",
    "it allows each node on the path to retrieve its fs .",
    "+ @xmath75 & onion payload , containing the data payload of data packets .",
    "+ @xmath10 & expiration time , included in each fs .",
    "+      suppose that a source @xmath3 wishes to establish an anonymous session with a public destination @xmath4 .",
    "first , @xmath3 anonymously obtains ( from the underlying network ) paths in both directions : a forward path @xmath76 from @xmath3 to @xmath4 and a backward path @xmath77 from @xmath4 to @xmath3 .",
    "@xmath78 denotes the routing information needed by the node @xmath79 to forward a packet .",
    "@xmath3 also anonymously retrieves and verifies a set of public keys @xmath80 for the node @xmath81 on path @xmath82 ( see section  [ sec : network_model ] ) .",
    "note that @xmath83 is also included in the above set ( as @xmath84 ) .",
    "finally , @xmath3 generates a random dh public / private key pair for the session : @xmath85 and @xmath86 .",
    "the per - session public key @xmath86 is used by the source to create shared symmetric keys with nodes on the paths later in the setup phase . @xmath3",
    "locally stores @xmath87 , and uses these values for the setup phase .      as discussed in section  [ sec : overview ] , in the setup phase ,",
    "hornetuses two sphinxpackets , which we denote by and , to traverse all nodes on both forward and backward paths and establish per - session state with every intermediate node , without revealing @xmath3 s network location . for @xmath3 to collect the generated per - session state from each node , both sphinxpackets contain an empty fs payload into which each intermediate node can insert its fs , but is not able to learn anything about , or modify , previously inserted fses .",
    "sphinx  @xcite is a provably - secure mix protocol .",
    "each sphinxpacket allows a source node to establish a set of symmetric keys , one for each node on the path through which packets are routed .",
    "these keys enable each node to check the header s integrity , onion - decrypt the data payload , and retrieve the information to route the packet .",
    "processing sphinxpackets involves expensive asymmetric cryptographic operations , thus sphinxalone is not suitable to support high - speed anonymous communication .    [ [ sphinxpackets ] ] sphinxpackets + + + + + + + + + + + + +    a sphinxpacket is composed of a sphinxheader @xmath88and a sphinxpayload @xmath89 .",
    "the @xmath88contains a group element @xmath90 that is re - randomized at each hop .",
    "each @xmath90 is used as @xmath3 s ephemeral public key in a dh key exchange with node @xmath79 . from this dh exchange ,",
    "node @xmath79 derives a shared symmetric key @xmath91 , which it uses to process the rest of the @xmath88and mutate @xmath90 .",
    "the rest of the @xmath88is an onion - encrypted data structure , with each layer containing routing information and a mac .",
    "the routing information indicates to which node the packet should be forwarded to next , and the mac allows to check the header s integrity at the current node .",
    "the sphinxpayload @xmath89allows end hosts to send confidential content to each other .",
    "each intermediate node processes @xmath89by using a pseudo - random permutation .",
    "[ [ sphinxcore - functions ] ] sphinxcore functions + + + + + + + + + + + + + + + + + + + +    we abstract the sphinxprotocol into the following six functions :    * .",
    "the source uses this function to generate two sphinxheaders , @xmath92and @xmath93 , for the forward and backward path , respectively .",
    "it also outputs the symmetric keys @xmath94 , each established with the corresponding node s public key @xmath95 . * .",
    "the function allows the source to generate an onion - encrypted payload @xmath96encapsulating confidential data to send to the destination .",
    "* @xmath97 .",
    "the function removes the last encryption layer added by @xmath98 , and allows the destination to decrypt the @xmath96 . * .",
    "the function enables the destination to cryptographically wrap a data payload into @xmath99before sending it to the source .",
    "* @xmath100 .",
    "the function allows the source to recover the plaintext of the payload that the destination sent . * .",
    "intermediate nodes use this function to process a sphinxpacket , and establish symmetric keys shared with the source .",
    "the function takes as inputs the packet @xmath101 , and the node s dh public key @xmath80 .",
    "the function outputs the processed sphinxpacket @xmath102 and the established symmetric key @xmath103 .",
    "we extend sphinx to allow each node to create a forwarding segment ( fs ) and add it to a data structure we name fs payload ( see below ) .",
    "an fs contains a node s per - session state , which consists of a secret key @xmath104 shared with the source , a routing segment @xmath5 , and the session s expiration time @xmath10 . to protect these contents ,",
    "the fs is encrypted with a prp keyed by a secret value @xmath105 known only by the node that creates the fs . a node seals and unseals its state using two opposite functions : @xmath106and @xmath107 .",
    "they are defined as follows : @xmath108    @xmath109      at the end of each hornetsetup packet is a data structure we call fs payload ( see figure  [ fig : setup_pkts ] ) .",
    "the fs payload is an onion - encrypted construction that allows intermediate nodes to add their fses as onion - layers .    processing the fs payload leaks no information about the path s length or about an intermediate node s position on the path .",
    "all fs payloads are padded to a fixed length , which is kept constant by dropping the right number of trailing bits of the fs payload before an fs is added to the front . moreover , new fses are always added to the beginning of the fs payload , eliminating the need for intermediate nodes to know their positions in order to process fs payloads .",
    "an fs payload also provides both secrecy and integrity for the fses it contains .",
    "each node re - encrypts the fs payload after inserting a new fs and computes a mac over the resulting structure . only the source ,",
    "with symmetric keys shared with each node on a path , can retrieve all the fses from the fs payload and verify their integrity .",
    "[ [ functions ] ] functions + + + + + + + + +    there are three core functions for the fs payload : @xmath110 , @xmath111 , and @xmath112 .    _",
    "@xmath110_. a node initializes an fs payload by using a pseudo - random generator keyed with a symmetric key @xmath104 to generate @xmath113 random bits : @xmath114 where @xmath20 is the size of a basic block of the fs payload ( consisting of an fs and a mac ) .    _",
    "@xmath111_. each intermediate node uses @xmath111to insert its fs into the payload , as shown in algorithm  [ alg : add_fs ] .",
    "first , the trailing @xmath56 bits of the current fs payload , which are padding bits containing no information about previously added fses , are dropped , and then the fs is prepended to the shortened fs payload .",
    "the result is encrypted using a stream cipher ( line  [ alg : add_fs : encrypt ] ) and maced ( line  [ alg : add_fs : mac ] ) .",
    "note that no node - position information is required in @xmath111 , and verifying that the length of the fs payload remains unchanged is straightforward .",
    "input : @xmath104 , @xmath115 , @xmath116 output : @xmath117 @xmath118}\\right\\}$ ] [ alg : add_fs : encrypt ] tempdima 3tempdima @xmath119}$ ] @xmath120 @xmath121 [ alg : add_fs : mac ]    _ @xmath112_. the source uses this function to recover all fses @xmath122 inserted into an fs payload @xmath73 .",
    "@xmath112starts by recomputing the discarded trailing bits ( line  [ alg : retrieve_fses : pad ] ) and obtaining a complete payload @xmath123 .",
    "thus , intuitively , this full payload is what would remain if no nodes dropped any bits before inserting a new fs .",
    "afterwards , the source retrieves the fses from @xmath123 in the reverse order in which they were added by @xmath111(see lines  [ alg : retrieve_fses : mac ] and [ alg : retrieve_fses : decrypt ] ) .",
    "input : @xmath73 , @xmath104 , @xmath124 output : @xmath122 @xmath125 @xmath126}$ ] tempdima 2tempdima @xmath127 } { \\ensuremath{\\mathbin{\\|}}}0^{c}$ ] tempdima 2tempdima @xmath128 } { \\ensuremath{\\mathbin{\\|}}}0^{2c}$ ] tempdima 3tempdima @xmath129 tempdima 2tempdima @xmath130 } { \\ensuremath{\\mathbin{\\|}}}0^{(l-1)c}$ ] [ alg : retrieve_fses : pad ] @xmath131 * check * @xmath132 } = \\vphantom{0}$ ] [ alg : retrieve_fses : mac ] tempdima 5tempdima @xmath133})$ ] @xmath134 @xmath135}$ ] [ alg : retrieve_fses : decrypt ] @xmath136}$ ]      [ [ source - processing ] ] source processing + + + + + + + + + + + + + + + + +    with the input @xmath137 the source node @xmath3 bootstraps a session setup in 5 steps :    1 .",
    "@xmath3 selects the intended expiration time @xmath10for the session and specifies it in the common header @xmath9(see section  [ sec : packetstructure]).must not become an identifier that allows matching packets of the same flow across multiple links . since @xmath10does not change during setup packet forwarding , a coarser granularity ( e.g. , 10s ) is desirable .",
    "in addition , the duration of the session should also have only a restricted set of possible values ( e.g.,10s , 30s , 1min , 10min ) to avoid matching packets within long sessions . for long - lived connections ,",
    "the source can create a new session in the background before expiration of the previous one to avoid additional latency . ]",
    "@xmath3 generates the send and the reply sphinxheaders by : @xmath138 the common header @xmath9(see figure  [ fig : setup_pkts ] ) is passed to the function to extend the per - hop integrity protection of sphinx over it .",
    "@xmath139also produces the symmetric keys shared with each node on both paths @xmath94 .",
    "3 .   in order to enable the destination @xmath4 to reply",
    ", @xmath3 places the reply sphinxheader @xmath93into the sphinxpayload : @xmath140 4 .",
    "@xmath3 creates an initial fs payload @xmath141 .",
    "5 .   @xmath3 composes @xmath142 and sends it to the first node on the forward path @xmath143 .",
    "[ [ intermediate - node - processing ] ] intermediate node processing + + + + + + + + + + + + + + + + + + + + + + + + + + + +    an intermediate node @xmath144 receiving a packet @xmath145 processes it as follows :    @xmath144 first processes @xmath92 and @xmath146 in according to the sphinxprotocol ( using ) . as a result @xmath144 obtains the established symmetric key @xmath70 shared with @xmath3 , the processed header and payload @xmath147 as well as the routing information @xmath148 . during this processing the integrity of",
    "the @xmath9is verified .",
    "@xmath71 obtains @xmath10 from @xmath9and checks that @xmath10 is not expired .",
    "@xmath71 also verifies that @xmath148 is valid .",
    "@xmath71 generates its forwarding segment @xmath149 by using its local symmetric key @xmath150 to encrypt @xmath70 , @xmath148 , and @xmath10 ( see equation  [ eq : fs_definition ] ) : @xmath151    @xmath71 adds its @xmath152 into the fs payload @xmath153 .",
    "@xmath154    finally node @xmath71 assembles the processed packet @xmath155 and routes it to the next node according to the routing information @xmath156 .",
    "[ [ sec : dst_proc ] ] destination processing + + + + + + + + + + + + + + + + + + + + + +    as the last node on the forward path , @xmath4 processes in the same way as the previous nodes .",
    "it first processes the sphinxpacket in and derives a symmetric key @xmath157 shared with @xmath3 , and then it encrypts per - session state , including @xmath158 , into @xmath159 , and inserts @xmath159 into the fs payload .",
    "after these operations , however , @xmath4 moves on to create the second setup packet as follows :    1 .",
    "@xmath4 retrieves the sphinxreply header using the symmetric key @xmath158 : @xmath160 2 .",
    "@xmath4 places the fs payload @xmath161 of into the sphinxpayload @xmath99of ( this will allow @xmath3 to get the fses @xmath162 ) : @xmath163 note that since @xmath4 has no knowledge about the keys @xmath164 except for @xmath158 , @xmath4 learns nothing about the other fses in the fs payload .",
    "@xmath4 creates a new fs payload @xmath165 to collect the fses along the backward path .",
    "4 .   @xmath4 composes @xmath166 and sends it to the first node on the backward path , @xmath167 .    the nodes on the backward path process in the exact same way nodes on the forward path processed .",
    "finally reaches the source @xmath3 with fses @xmath168 added to the fs payload .    [ [ post - setup - processing ] ] post - setup processing + + + + + + + + + + + + + + + + + + + + +    once @xmath3 receives it extracts all fses , i.e.,@xmath162 and @xmath169 , as follows :    1 .",
    "@xmath3 recovers the fs payload for the forward path @xmath170 from @xmath99 : @xmath171 2 .",
    "@xmath3 retrieves the fses for the nodes on the forward path @xmath162 : @xmath172 3 .",
    "@xmath3 directly extracts from @xmath173the fses for the nodes on the backward path @xmath168 : @xmath174    with the fses for all nodes on both paths , @xmath175 and @xmath176 , @xmath3 is ready to start the data transmission phase .",
    "each hornetdata packet contains an anonymous header @xmath74and an onion - encrypted payload @xmath75as shown in figure  [ fig : setup_pkts ] .",
    "figure  [ fig : a_header ] illustrates the details of an @xmath74 .",
    "the @xmath74allows each intermediate node along the path to retrieve its per - session state in the form of an fs and process the onion - encrypted data payload .",
    "all processing of data packets in hornetonly involves symmetric - key cryptography , therefore supporting fast packet processing .        at the beginning of the data transmission phase ,",
    "@xmath3 creates two s , one for the forward path ( @xmath177 ) and one for the backward path ( @xmath178 ) , by using fses collected during the setup phase .",
    "@xmath177enables @xmath3 to send data payloads to @xmath4 . to enable @xmath4 to transmit data payloads back",
    ", @xmath3 sends @xmath178as payload in the first data packet .",
    "if this packet is lost , the source would notice from the fact that no reply is seen from the destination .",
    "if this happens the source simply resends the backward using a new data packet .      like an fs payload ,",
    "an is an onion - encrypted data structure that contains fses .",
    "it also offers the same guarantees , i.e.,secrecy and integrity , for the individual fses it contains , for their number and for their order .",
    "its functionalities , on the other hand , are the inverse : while the fs payload allows the source to collect the fses added by intermediate nodes , the enables the source to re - distribute the fses back to the nodes for each transmitted data packet .",
    "[ [ functions-1 ] ] functions + + + + + + + + +    the life cycle of s consists of two functions : the header construction ( @xmath179 ) and the header processing ( @xmath180 ) .",
    "we begin with the description of @xmath180since it is simpler , and its helps understand the construction of @xmath179.@xmath180allows each intermediate node to verify the integrity of an incoming , and to check that the corresponding session has not expired .",
    "@xmath180also retrieves the key @xmath104 shared with the source , as well as the routing information @xmath5 , from the fs of the node invoking the function .",
    "finally , @xmath180also returns the processed header @xmath181 , which will be used by the next hop .",
    "the details of this function can be seen in algorithm  [ alg : get_fs ] .",
    "input : @xmath105 , @xmath74 output : @xmath104 , @xmath5 , @xmath181 @xmath182 [ alg : get_fs : fs ] @xmath183 [ alg : get_fs : key ] * check * @xmath184 * check * @xmath185 @xmath186 [ alg : get_fs : decrypt ]    our construction resembles the sphinxpacket header construction  @xcite . for each path",
    "( forward and backward ) , @xmath179enables @xmath3 to create an given the keys @xmath124 shared with each node on that path , and given the forwarding segments @xmath122 of those nodes . all these keys and fses",
    "are obtained during the setup phase ( see section  [ sec : setupphase ] ) .",
    "the details are shown in algorithm  [ alg : construct_aheader ] .",
    "in essence , @xmath179is equivalent to a series of @xmath180iterations performed in reverse .",
    "initially , the paddings @xmath187 are computed , each of which is the leftmost part of an that results from the successive encryptions of the zero - paddings added in @xmath180(@xmath188 is the empty string since no padding has been added yet ) . once the last padding is computed ( the one for the received by the last hop , @xmath189 ) , the operations in @xmath180are reversed , obtaining at each step the s as will be received by the nodes , from the last to the first .",
    "this also allows the computation of the per - hop macs .",
    "input : @xmath124 , @xmath122 output : @xmath190 @xmath191 @xmath192 tempdima 4tempdima @xmath193 } \\right\\}$ ] @xmath194 [ alg : create_aheader_start ] @xmath195 @xmath196}\\right\\ } $ ] tempdima 4tempdima @xmath197 } $ ] [ alg : create_aheader : beta ] @xmath198 [ alg : create_aheader : gamma ]      hornetdata payloads are protected by onion encryption . to send a data payload to the destination",
    ", the source adds a sequence of encryption layers on top of the data payload , one for each node on the forward path ( including the destination ) .",
    "as the packet is forwarded , each node removes one layer of encryption , until the destination removes the last layer and obtains the original plaintext .    to send a data payload back to the source",
    ", the destination adds only one layer of encryption with its symmetric key shared with the source .",
    "as the packet is forwarded , each node on the backward path re - encrypts the payload until it reaches the source . with all the symmetric keys shared with nodes on the backward path ,",
    "the source is capable of removing all encryption layers , thus obtaining the original data payload sent by the destination .",
    "[ [ functions-2 ] ] functions + + + + + + + + +    processing onion payloads requires the following two functions : @xmath199and @xmath200 .",
    "_ @xmath199_. the function s full form is : @xmath201 given a symmetric key @xmath104 , an initial vector @xmath202 , and an input onion payload @xmath203 , @xmath199performs two tasks .",
    "first , @xmath199encrypts @xmath203 with @xmath104 and @xmath202 : @xmath204 then , to avoid making the iv an identifier across different links , @xmath199mutates the @xmath202 for the next node : @xmath205    _ @xmath200_. the function is the inverse of @xmath199 , decrypting the onion payload at each step , and mutating the @xmath202 using the inverse permutation @xmath206 keyed with @xmath207 .",
    "its full form is the following : @xmath208      to start the data transmission session , @xmath3 generates @xmath177and @xmath178as follows:@xmath209 @xmath3 then sends @xmath178 to @xmath4 as payload of the first data packet ( which uses @xmath177 ) , as specified in the following section .",
    "[ [ source - processing-1 ] ] source processing + + + + + + + + + + + + + + + + +    with @xmath177 , @xmath3 can send a data payload @xmath210 with the following steps :    1 .",
    "@xmath3 ensures that the session is not expired by checking that the current time @xmath211 .",
    "2 .   @xmath3 creates an initial @xmath202 . with the shared keys",
    "@xmath164 , @xmath3 onion encrypts the data payload @xmath210 by setting @xmath212 and @xmath213 and computing the following for @xmath214 : @xmath215 3 .",
    "@xmath3 places @xmath216 in the common header @xmath9 .",
    "@xmath3 sends out the resulting data packet @xmath217 .",
    "[ [ processing - by - intermediate - nodes ] ] processing by intermediate nodes + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + +    each intermediate node @xmath71 on the forward path processes a received data packet of the form @xmath218 with its local secret key @xmath150 as follows :    1 .",
    "@xmath71 retrieves the key @xmath219 shared with @xmath3 and the routing information @xmath156 from @xmath177 : @xmath220 @xmath180also verifies the integrity of @xmath74 , and checks that the session has not expired .",
    "2 .   @xmath71 obtains @xmath202 from @xmath9 and removes one layer of encryption from the data payload : @xmath221 3 .",
    "@xmath71 updates the iv field in @xmath9with @xmath222 .",
    "4 .   @xmath71 sends the resulting packet @xmath223 to the next node according to @xmath148 .",
    "the above procedures show that the intermediate node processing requires only symmetric - cryptography operations .",
    "[ [ destination - processing ] ] destination processing + + + + + + + + + + + + + + + + + + + + + +    @xmath4 processes incoming data packets as the intermediate nodes . removing the last encryption layer from the onion payload @xmath4 obtains the original data payload @xmath210 sent by @xmath3 .",
    "additionally , for the first data packet @xmath4 retrieves @xmath178from the payload , and stores the @xmath224 locally so that @xmath4 can retrieve @xmath178when it wishes to send packets back to @xmath3 .    [",
    "[ processing - for - the - backward - path ] ] processing for the backward path + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + +    sending and processing a hornetpacket along the backward path is the same as that for the forward path , with the exception of processing involving the data payload .",
    "because @xmath4 does not possess the symmetric keys that each node on the backward path shares with @xmath3 , @xmath4 can not onion - encrypt its payload .",
    "therefore , instead of @xmath200 , @xmath4 and the intermediate nodes use @xmath199to process the data payload , and the source node recovers the data with @xmath200 .      as discussed in section  [ sec : recv_anonymity ] , the main difference of the protocols between sender anonymity and sender - receiver anonymity is that the latter requires nested s. we present in detail the process of composing an with a nested in algorithm  [ alg : create_nested_aheader ] .    constructing a new based on a nested @xmath225 has essentially the same procedures as constructing a normal from ases , except for the initialization process and the size of the resulted . for the initialization in line  [ alg : line : init ] in algorithm  [ alg : create_nested_aheader ] , the nested @xmath225 is perpended to the random bits generated .",
    "thus , when the last node @xmath226 ( rp ) decrypts the , @xmath225 is revealed to the node . for the size of the resulting , instead of @xmath18 for a normal ,",
    "the length of the generated with a nested is @xmath227 , doubling the bandwidth cost incurred by the protocol headers .",
    "input : @xmath124 , @xmath18 output : @xmath189 @xmath191 @xmath228 @xmath229 @xmath230 } \\right\\}$ ]    input : @xmath124 , @xmath122 , @xmath225 output : @xmath231 @xmath190 @xmath232 create_padding_string_nested@xmath233 @xmath234 tempdima 3tempdima @xmath235 } \\big\\ } { \\ensuremath{\\mathbin{\\|}}}\\phi_{l-1}$ ] [ alg : line : init ] @xmath195 @xmath236}\\right\\ } $ ] tempdima 4tempdima @xmath237 } } $ ] @xmath198",
    "in this section , we first present formal proofs showing that hornetsatisfies the correctness , security , and integrity properties defined by camenisch and lysyanskaya  @xcite .",
    "then , we describe how hornetdefends against well - known de - anonymization attacks and meets the design goals of section  [ sec : desired_properties ] .",
    "we also present defenses against denial of service attacks .",
    "we prove hornet s data transmission phase realizes ideal onion routing functionalities in the universal composability ( uc ) framework  @xcite .",
    "conceptually , with an ideal onion routing protocol , adversaries have no access to the routing information or the message within packets except for opaque identifiers that vary across links .    as demonstrated by camenisch and lysyanskaya  @xcite , to prove that a protocol conforms to an ideal onion routing model , it is sufficient to show that the protocol provides four properties : _ correctness _ , _ integrity _ , _ wrap - resistance _ , and _",
    "security_.      proving the correctness property requires that hornetprotocol functions correctly in the absence of adversaries . a scrutiny of protocol description in section  [ sec : protocol ] should suffice",
    ".      to prove the integrity property , we need to prove that an adversary can not forge a message that can traverse more than @xmath238 uncompromised nodes , where @xmath239 is a fixed upper bound for hornet .",
    "equivalently , we demonstrate that an adversary , with significantly less than @xmath240 computation , can only produce a requisite message with a negligible probability . in our proof",
    ", we choose @xmath241 .",
    "suppose that an adversary can construct a hornet(@xmath242 , @xmath243 , @xmath244 ) that can succeed in traversing @xmath245 honest nodes @xmath246 , @xmath247 , @xmath248 , @xmath249 , without knowing secrets @xmath250 , @xmath248 , @xmath251 . according to algorithm  [ alg : construct_aheader ] , @xmath252 , @xmath253 , and @xmath254",
    "satisfy : @xmath255 } ) ; \\beta_r ) \\label{eq : int_cond_1}\\end{aligned}\\ ] ]    for convenience , for @xmath256 , we introduce the following notation : @xmath257}\\\\      \\rho^{\\gamma}_i & = & \\left\\{\\rho_i\\right\\}_{[c(r-1-i ) + l_{fs }   .. c(r - i)-1]}\\\\      \\rho^{\\beta}_i & = & \\left\\{\\rho_i\\right\\}_{[0 .. c(i+1)-1 ] } || 0^{c(r-1-i)}\\\\      \\rho^{c}_{i , j } & = & \\left\\{\\rho_i\\right\\}_{[jc .. ( j+1)c-1 ] } \\label{eq : rho_c}\\end{aligned}\\ ] ] where @xmath258 are defined recursively as follows : @xmath259}\\label{eq : fs_start}\\end{aligned}\\ ] ] we observe that @xmath258 is a function of @xmath260 and @xmath261 .",
    "accordingly , @xmath262 , @xmath263 , and @xmath264 are all functions of @xmath260 and @xmath261 .    with a detailed inspection of algorithm  [ alg : construct_aheader ]",
    ", we can express @xmath252 , @xmath253 , and @xmath254 : @xmath265    with equation  [ eq : fs_r ] , [ eq : gamma_r ] , [ eq : beta_r ] and [ eq : int_cond_1 ] , we can prove the following lemma :    [ lem:1 ] with less than @xmath240 work , an adversary can only distinguish @xmath266 } ) ; \\beta_r)$ ] from a random oracle with negligible probability .",
    "[ [ proof ] ] proof + + + + +    ( sketch ) we will show that an adversary can not find two sets of @xmath267 that lead to the same value of @xmath266 } ) ; \\beta_r)$ ] with significant less than @xmath240 work .",
    "assume that the adversary , with much less than @xmath240 work , finds two sets , @xmath268 that results in the same value of @xmath269 } ) ; \\beta_r)\\ ] ] we will show the assumption leads to a contradiction .    because @xmath270 is a random oracle , the only way for an attacker to distinguish the target function from a random oracle with much less than @xmath240 work is to ensure @xmath271}= \\phi(sv_r ' , fs_r')_{[0 .. c]}\\ ] ] and @xmath272 . because @xmath273 is a pseudo - random permutation and @xmath274 is collision resistant",
    ", we have @xmath275 .",
    "note that the last @xmath56 bits of @xmath253 and @xmath276 are @xmath277 and @xmath278 respectively .",
    "therefore , we have @xmath279 . according to equation  [ eq : rho_c ] , because @xmath280 is a pseudo - random generator , we have @xmath281 and @xmath282 . hence , @xmath283 , @xmath284 .",
    "a careful calculation shows that the @xmath56 bits before the last @xmath56 bits in @xmath253 and @xmath276 are @xmath285 and @xmath286 .",
    "similarly , we have @xmath287 and @xmath288 .    continuing the logic as above",
    ", we finally have @xmath289 and @xmath290 , @xmath291 .",
    "however , given equation  [ eq : fs_start ] , @xmath289 , and @xmath292 , we have @xmath293 , @xmath291 .",
    "this results in @xmath294 therefore , we obtain a contradiction .",
    "we can substitute equation  [ eq : fs_r ] , [ eq : gamma_r ] , and [ eq : beta_r ] into equation  [ eq : int_cond_1 ] , and rewrite the equation into : @xmath295 } ) ; \\beta_r ) \\oplus \\bigoplus_{i=1}^{r-1}\\rho^{\\gamma}_i \\label{eq : wrap_contradict}\\end{aligned}\\ ] ] because @xmath270 is not used in @xmath263 , the right side of equation  [ eq : wrap_contradict ] is a random oracle with respect to @xmath296 and @xmath297 , @xmath298 .",
    "we can further simplify the notation by denoting @xmath299 as @xmath300 and the right side of equation  [ eq : wrap_contradict ] as @xmath301 both @xmath302 and @xmath303 are random oracles with range @xmath304 . as a result , by creating a traversing @xmath245 honest nodes , the adversary equivalently finds a solution to @xmath305 which can only be solved with negligible probability with significantly less than @xmath240 work .",
    "hence , with much less than @xmath240 work , the adversary can only generate a packet that traverse @xmath245 hops with negligible probability .      to prove the wrap - resistance property ,",
    "we show that given a data packet @xmath306 , an adversary , with significant less than @xmath240 work , can not generate a message @xmath307 so that processing @xmath307 on an uncompromised node yields data packet @xmath306 .",
    "to succeed , it is necessary that : @xmath308 consider the last @xmath56 bits of the left side of equation  [ eq : wrap_resistance_1 ] , we have : @xmath309 } = \\rho(sv ' , fs')_{[c(r-1) .. cr-1 ] }      \\label{eq : wrap_resistance_2}\\end{aligned}\\ ] ] because @xmath280 , @xmath273 , @xmath310 , and @xmath274 are all random oracles , an adversary could generate @xmath311 and @xmath312 that satisfy equation  [ eq : wrap_resistance_2 ] only with negligible probability if the adversary performs much less than @xmath240 work .      to demonstrate the security property , we need to prove that an adversary with control over all nodes on a path except one node @xmath238 , can not distinguish among data packets entering @xmath238 .",
    "the adversary is able to select paths for the packets traversing @xmath238 and payloads of the packets .",
    "the adversary can also observe packets entering and leaving node @xmath238 except for packets whose headers match the challenge packets .",
    "we construct the following game @xmath313 .",
    "the adversary picks two paths @xmath314 @xmath315 and @xmath316 @xmath317 , where @xmath318 and @xmath319 .",
    "note that the nodes after @xmath238 in both paths are not necessarily the same set of nodes , and the lengths of the paths can also be different .",
    "the adversary chooses the public / private key pairs and @xmath296(@xmath320 ) for all nodes except @xmath238 and can arbitrarily select payload @xmath210 .",
    "the challenger picks randomly a bit @xmath37 and proceeds in one of the following two ways :    * @xmath321 * : the challenger creates an @xmath322 through the hornetsetup phase using the path @xmath314 and uses it to construct a data packet with onion encrypted payload @xmath323 from @xmath210 .",
    "the challenger outputs @xmath324 , which could be sent to @xmath246 .    *",
    "@xmath325 * : the challenger creates an @xmath322 using the alternative path @xmath326 instead and outputs + @xmath324 , which could be sent to @xmath327 .",
    "given the output @xmath322 , the adversary s goal is to determine @xmath37 .",
    "the adversary can also input any messages @xmath328 to the honest node @xmath238 and observes the output messages as long as @xmath329 .",
    "we define the adversary s advantage as the difference between @xmath330 and the probability that the adversary succeeds .",
    "we will show that the adversary s advantage is negligible .",
    "therefore , the adversary has no better chance to determine @xmath37 than random guessing .",
    "[ [ proof-1 ] ] proof + + + + +    ( sketch ) we adopt the hybrid - game method .",
    "first , we construct a modified game @xmath331 with exactly the same definition , except that we require @xmath332 . an adversary who can win @xmath313",
    "can thus immediately win @xmath331 .",
    "on the other hand , because the adversary controls nodes @xmath333 ( @xmath334 ) and can thus emulate their processing , the adversary can also win game @xmath313 if he / she can win game @xmath331 .",
    "therefore , the adversary can win game @xmath313 if and only if the adversary can win game @xmath331 .",
    "we create a second game @xmath335 , which is the same as @xmath331 except that @xmath242 , @xmath336 , and @xmath337 are all randomly generated from their corresponding domains .",
    "if the adversary can distinguish @xmath335 from @xmath331 , we have :    1 .",
    "the adversary can distinguish @xmath338 from randomness",
    ". then it must be that the adversary is able to tell the output of a pseudo - random permutation with a random key ( @xmath339 ) from random bits .",
    "the probability of success for the adversary is negligible . 2 .",
    "the adversary can distinguish @xmath340 from randomness",
    ". then it must be the adversary is able to distinguish the output of a secure pseudo - random number generator with a random key ( @xmath341 ) from randomness .",
    "the probability that the adversary succeeds is negligible .",
    "the adversary can distinguish @xmath342 from randomness",
    ". then it must be the adversary is able to distinguish the output of @xmath270 with a random key @xmath343 from randomness . under our random oracle assumption for @xmath270 ,",
    "the probability of success is negligible .",
    "therefore , the adversary can not distinguish @xmath335 from @xmath331 .",
    "lastly , because in @xmath335 , @xmath322 are all random , the adversary s advantage is 0 .",
    "moreover , in our chain of game @xmath344 , the adversary can only distinguish a game from its previous game with negligible probability . as a result ,",
    "the adversary s advantage in game @xmath313 is negligible .",
    "[ [ session - linkage ] ] session linkage + + + + + + + + + + + + + + +    each session is established independently from every other session , based on fresh , randomly generated keys .",
    "sessions are in particular not related to any long term secret or identifier of the host that creates them .",
    "thus , two sessions from the same host are unlinkable , i.e.,they are cryptographically indistinguishable from sessions of two different hosts .",
    "[ [ forwardbackward - flow - correlation ] ] forward / backward flow correlation + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + +    the forward and backward headers are derived from distinct cryptographic keys and therefore can not be linked .",
    "only the destination is able to correlate forward and backward traffic , and could exploit this to discover the round - trip time ( rtt ) between the source and itself , which is common to all low - latency anonymity systems .",
    "sources willing to thwart such rtt - based attacks from malicious destinations could introduce a response delay for additional protection .    [",
    "[ packet - correlation ] ] packet correlation + + + + + + + + + + + + + + + + + +    hornetobfuscates packets at each hop .",
    "this prevents an adversary who observes packet bit patterns at two points on a path from linking packets between those two points .",
    "in addition to onion encryption , we also enforce this obfuscation by padding the header and the payload to a fixed length , thwarting packet - size - based correlation .",
    "while this does not prevent the adversary from discovering that the same flow is passing his observation points using traffic analysis , it makes this process non - trivial , and allows upper - layer protocols to take additional measures to hide traffic patterns .",
    "the hop - by - hop encryption of the payload also hides the contents of the communication in transit , protecting against information leaked by upper layer protocols that can be used to correlate packets .",
    "[ [ path - length - and - node - position - leakage ] ] path length and node position leakage + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + +    hornetprotects against the leakage of a path s length and of the nodes positions on the path ( i.e.,the relative distance , in hops , to the source and the destination ) . in the setup phase , this protection is guaranteed by sphinx , so only the common header and fs payload are subject to leakage ( see section  [ sec : packetstructure ] for the exact structure of the packets ) .",
    "it is straightforward to see that the common header does not contain path or position information .",
    "the fs payload length is padded to the maximum size , and remains constant at each hop ( see algorithm  [ alg : add_fs ] ) . after adding its fs to the front of the fs payload , each node re - encrypts the fs payload , making it infeasible for the next nodes to see how many fses have previously been inserted .    during data transmission ,",
    "neither the common header nor the data payload contain information about path length or node position , so only the ( anonymous header ) needs to be analyzed .",
    "the is padded to a maximum length with random bytes , and its length remains constant as it traverses the network ( see algorithm  [ alg : get_fs ] ) .",
    "the fses contained in the are onion encrypted , as is the padding added at each hop .",
    "thus , it is not possible to distinguish the initial random padding from the encrypted fses , and neither of these from encrypted padding added by the nodes .",
    "[ [ timing - for - position - identification ] ] timing for position identification + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + +    a malicious node could try to learn its position on the path of a session by measuring timing delays between itself and the source ( or the destination ) of that session .",
    "hornetoffers two possible countermeasures . in the first",
    ", we assume that the malicious node wishes to measure the network delay between itself and the source . to perform such a measurement , the node must observe a packet directed to the source ( i.e.,on the backward path ) and then observe a response packet from the source ( on the forward path ) .",
    "however , hornetcan use asymmetric paths  @xcite , making this attack impossible if the single node is not on both forward and backward paths .",
    "the second countermeasure is that , even if the node is on both paths , it is still non - trivial to discover that a specific forward flow corresponds to a certain backward flow , since the forwarding segments for the two paths are independent . to link the forward and backward flows together",
    "the node would need to rely on the traffic patterns induced by the upper - layer protocols that are running on top of hornetin that session .",
    "[ [ session - state - modification ] ] session state modification + + + + + + + + + + + + + + + + + + + + + + + + + +    the state of each node is included in an encrypted fs . during the session setup ,",
    "the fses are inserted into the fs payload , which allows the source to check the integrity of these fses during the setup phase . during data transmission , fses are integrity - protected as well through per - hop macs computed by the source . in this case , each mac protecting an fs is computed using a key contained in that fs .",
    "this construction is secure because every fs is encrypted using a prp keyed with a secret value known only to the node that created the fs : if the fs is modified , the authentication key that the node obtains after decryption is a new pseudo - random key that the adversary can not control . thus , the probability of the adversary being able to forge a valid mac is still negligible .    [ [ path - modification ] ] path modification + + + + + + + + + + + + + + + + +    the two hornetdata structures that hold paths ( i.e.,fs payloads in the setup phase and s ) , use chained per - hop macs to protect path integrity and thwart attacks like inserting new nodes , changing the order of nodes , or splicing two paths .",
    "the source can check such chained per - hop macs to detect the modifications in the fs payload before using the modified fs payload to construct s , and similarly intermediate nodes can detect modifications to s and drop the altered packets .",
    "these protections guarantee path information integrity as stated in section  [ sec : desired_properties ] .",
    "[ [ replay - attacks ] ] replay attacks + + + + + + + + + + + + + +    replaying packets can facilitate some types of confirmation attacks  @xcite .",
    "for example , an adversary can replay packets with a pre - selected pattern and have a colluding node identify those packets downstream .",
    "hornetoffers replay protection through session expiration ; replayed packets whose sessions have expired are immediately dropped .",
    "replay of packets whose sessions are not yet expired is possible , but such malicious behavior can be detected by the end hosts . storing counters at the end hosts and including them in the payload ensures that replays are recognizable .",
    "the risk of detection helps deter an adversary from using replays to conduct mass surveillance .",
    "furthermore , volunteers can monitor the network , to detect malicious activity and potentially identify which nodes or group of nodes are likely to be misbehaving .",
    "honest ases could control their own nodes as part of an intrusion detection system .",
    "[ [ payload - secrecy ] ] payload secrecy + + + + + + + + + + + + + + +    data packet payloads are wrapped into one layer of encryption using the key shared between the source and the destination , both for packets sent by the source on the forward and for packets sent by the destination on the backward path ( see section  [ sec : datatransmissionprotocoldescription ] ) .",
    "assuming that the cryptographic primitives used are secure , the confidentiality of the payload is guaranteed as long as the destination is honest . in section  [ sec : limitations ] we discuss the guarantees for perfect forward secrecy for the data payload .",
    "[ [ payload - tagging - or - tampering ] ] payload tagging or tampering + + + + + + + + + + + + + + + + + + + + + + + + + + + +    hornetdoes not use per - hop macs on the payload of data packets for efficiency and because the destination would not be able to create such macs for the packets it sends ( since the session keys of the nodes are known only to the source ) .",
    "the lack of integrity protection allows an adversary to tag payloads .",
    "admittedly , the use of tagging , especially in conjunction with replay attacks , allows the adversary to improve the effectiveness of confirmation attacks .",
    "however , end - to - end macs protect the integrity of the data , making such attacks ( at a large scale ) detectable by the end hosts .      [ [ computational - dos ] ] computational dos + + + + + + + + + + + + + + + + +    the use of asymmetric cryptography in the setup phase makes hornetvulnerable to computational dos attacks , where adversaries can attempt to deplete a victim node s computation capability by initiating a large number of sessions through this node . to mitigate this attack",
    ", hornetnodes can require each client that initiates a session to solve a cryptographic puzzle  @xcite to defend against attackers with limited computation power .",
    "alternatively , isps offering hornetas a service can selectively allow connections from customers paying for the anonymity service .",
    "[ [ state - based - dos ] ] state - based dos + + + + + + + + + + + + + + +    hornetis not vulnerable to attacks where adversaries maintain a large number of active sessions through a victim node .",
    "one of hornet s key features is that all state is carried within packets , thus no per - session memory is required on nodes or rendezvous points .      unlike onion routing protocols that use global re - routing through overlay networks ( e.g.,tor  @xcite and i2p  @xcite ) , hornetuses short paths created by the underlying network architecture to reduce latency , and is therefore bound by the network s physical interconnection and isp relationships",
    "this is an unavoidable constraint for onion routing protocols built into the network layer  @xcite .",
    "thus , knowledge of the network topology enables an adversary to reduce the number of possible sources ( and destinations ) of a flow by only looking at the previous ( and next ) hop of that flow .",
    "for example , in figure  [ fig : as_position ] , assume that as0 is controlled by a passive adversary .",
    "the topology indicates that any packet received from as1 must have originated from a source located at one of \\{as1 , as2 , as3 , as4 , as5}.    we evaluate the information leakage due to the above topology constraints in the scenario where a single as is compromised .",
    "we derive as - level paths from iplane trace - route data  @xcite , and use as - level topology data from caida  @xcite . for each as on each path",
    "we assume that the as is compromised and receives packets from a victim end host through that path .",
    "we compute the end host s anonymity set size learned by the adversary according to the topology .",
    "for instance , in figure  [ fig : as_position ] , if as0 is compromised and receives from as1 packets originally sent by a user in as4 , we compute the size of the anonymity set composed of all the ases that can establish valley - free paths traversing the link from as1 to as0 . in this example",
    ", the anonymity set size would be the sum of the sizes of as1 , as2 , as3 , as4 , and as5 .",
    "similar to hsiao et  al .",
    "@xcite , we use the number of ipv4 addresses to estimate the size of each as .",
    "figure  [ fig : anonymityset_subtree_cdf ] plots the cdf of the anonymity set size for different distances ( in number of as hops ) between the adversary and the victim end host . for adversarial ases that are 4 hops away , the anonymity set size is larger than @xmath345 in 80% of the cases .",
    "note that the maximum anonymity set size is @xmath346 in our analysis , because we consider only ipv4 addresses .",
    "[ [ implications - of - path - knowledge ] ] implications of path knowledge + + + + + + + + + + + + + + + + + + + + + + + + + + + + + +    knowledge about the path , including the total length of the path and an adversarial node s position on the path , significantly downgrades the anonymity of end hosts . considering again figure  [ fig : as_position ] , if the adversary controlling as0 sees a packet incoming from as1 and knows that it is 4 hops away from the source host , he learns that the source host is in as4 .",
    "compared with the previous case , we see that the anonymity set size is strongly reduced .",
    "we quantify additional information leakage in the same setting as the previous evaluation .",
    "figure  [ fig : anonymityset_subtree_hops_cdf ] represents the cdfs of the anonymity set sizes of end hosts according to the distance to the compromised as .",
    "the anonymity set sizes are below @xmath347 in 90% of the cases when the adversarial ases are 4 hops away , with an average size of @xmath348 .",
    "this average size decreases to @xmath349 for the cases where the adversarial ases are 7 hops away from the target hosts .",
    "previous path - based anonymity systems designed for the network layer either fail to hide knowledge about the path  @xcite or only partially obscure the information  @xcite . in comparison , hornetprotects both the path length and the position of each node on the path , which significantly increases the anonymity - set size .",
    "we implemented the hornetrouter logic in an intel software router using the data plane development kit ( dpdk )  @xcite . to our knowledge",
    ", no other anonymity protocols have been implemented in a router sdk .",
    "we also implemented the hornetclient in python .",
    "furthermore , we assembled a custom crypto library based on the intel aesni cryptographic library  @xcite , the curve25519-donna library  @xcite , and the polarssl libraries  @xcite .",
    "we use ip forwarding in dpdk as our performance baseline . for comparison",
    ", we implemented the data forwarding logic from sphinx , lap , dovetail , and torusing dpdk and our cryptographic library .    fairly comparing the performance of anonymity systems at the application layer with those that operate at the network layer is challenging . to avoid",
    "penalizing torwith additional propagation delay caused by longer paths and processing delay from the kernel s network stack , we implemented torat the network layer ( as suggested by liu et  al .",
    "tor s design requires relay nodes to perform ssl / tls and transport control .",
    "ssl / tls between neighboring relays at the application layer maps to link encryption between neighboring nodes at the network layer , which we consider orthogonal but complementary to hornet(see section  [ sec : comp_other_protocol ] ) .",
    "hence , for fair comparison , we implemented the network - layer torwithout ssl / tls or transport control logic . throughout our evaluation",
    "we refer to this implementation of toras l3 tor .",
    "our testbed contains an intel software router connected to a spirent testcenter packet generator and analyzer  @xcite .",
    "the software router runs dpdk 1.7.1 and is equipped with an intel xeon e5 - 2680 processor ( 2.70 ghz , 2 sockets , 16 logical cores / socket ) , 64 gb dram , and 3 intel 82599es 40 gb / s network cards ( each with 4 10 gb / s ports ) .",
    "we configured dpdk to use 2 receiving queues for each port with 1 adjacent logical core per queue .",
    "[ [ forwarding - latency ] ] forwarding latency + + + + + + + + + + + + + + + + + +    we measure the cpu cycles consumed to forward a data packet in all schemes .",
    "figure  [ fig : latency ] shows the average latency ( with error bars ) to process and forward a single data packet in all schemes ( except sphinx ) when payload sizes vary .",
    "we observe that hornet , even with onion encryption / decryption over the entire payload and extensive header manipulation , is only 5% slower than lapand dovetailfor small payloads ( 64 bytes ) .",
    "for large payloads ( 1200 bytes ) , hornetis 71% slower ( about 400 nanoseconds slower per packet when using a single core ) than lapand dovetail .",
    "however , the additional processing overhead enables stronger security guarantees .",
    "[ [ header - overhead ] ] header overhead + + + + + + + + + + + + + + +    .comparison between the length of different packet header formats in bytes .",
    "@xmath104 is the length of symmetric elements and @xmath18 is the maximum as path length . for the sample length , we select @xmath350  bytes and @xmath58 .",
    "analysis of iplane paths shows that more than 99% of all paths have fewer than @xmath351 as hops . [",
    "cols=\"^,^,^,^\",options=\"header \" , ]      [ [ distribution - of - as - level - path - length ] ] distribution of as - level path length + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + +    the bandwidth overhead of a hornetpacket depends on the number of ases traversed by the packet .",
    "figure  [ fig : as_path_len ] demonstrates the cdf of as - level path lengths of the paths extracted from our data source .",
    "we observe that 99% of the paths have a path length smaller than 7 , and the mean as - level path length is 4.2 .",
    "thus , to achieve 128 bits of security , 48 bytes per as hop are required , leading to an average overhead of 201.6 bytes .",
    "[ [ non - scalability - of - a - stateful - design ] ] non - scalability of a stateful design + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + +    we evaluate the memory capacity needed to maintain state required by a stateful design to support internet - scale anonymous communication .",
    "we consider the design of tor , one of the most popular onion routing systems today  @xcite , and assume that each tor node ( _ onion router _ or or ) would correspond to an autonomous system ( as ) , as proposed by liu et  al .",
    "@xcite . analyzing",
    "the caida internet traces  @xcite , we found that a 10 gbe backbone link handles about 1 m new flows every minute under normal operating conditions .",
    "since the largest inter - as links today have up to ten times that capacity ( 100 gbps ) , this means that at the core of the network there are edge routers of ases that handle about 10 m new flows per minute .",
    "if we assume that half of these flows would use a tor circuit , because of the default lifetime of circuits of 10 minutes we obtain that ors on such edge routers would need to store state for approximatively 50 m circuits at any given time .",
    "since tor stores at least 376 bytes per circuit , this translates to almost 20 gb of memory",
    ". this might still be acceptable for high - end devices , but there are a number of additional factors that make keeping state unfeasible , even for ases handling less traffic :    * the growing number of users on the internet and the increasing number of devices per user result in an increasing number of traffic flows ; * the state for each circuit would actually be larger , as for active circuits the ors need to store the packets being transmitted until they are acknowledged by the next hop ; * a ddos attack could force an or to store much more state by opening a large number of new circuits through that or .",
    "hornetassumes that the source can obtain a forward path and a backward path to an intended destination anonymously in fias .",
    "we briefly discuss how a source host using hornetcan retrieve two such paths in nira , scionand pathlets .",
    "scionhosts rely on path servers to retrieve paths . in scion , each destination node registers on a central server its `` half '' path : the path to / from the network `` core '' . to compose full paths ( forward and backward paths ) between a source and a destination",
    ", the source only needs to anonymously fetch the destination s half paths from / to the network core and combine them with its own half paths .    to anonymously retrieve a destination s half paths , the source can use one of the following two methods . as a first method , the source can obtain the path to / from a path server through an unprotected query using other schemes , from resolver configuration , or from local services similar to dhcp .",
    "the source then establishes an anonymous hornetsession to the server .",
    "once a hornetsession is created , the source can proceed to anonymously request half paths of the destination . though it is possible to reuse the established hornetsession to a path server to query multiple paths ( for different destinations ) for better efficiency , using a separate session to retrieve each path",
    "is more secure because it prevents profiling attacks .",
    "alternatively , the source can leverage a private information retrieval ( pir ) scheme  @xcite to retrieve the path anonymously from the path server , so that the path server can not distinguish which destination the source connects to .",
    "however , a pir scheme will inevitably add bandwidth and computational overhead to both the source and the path server , increasing session setup phase latency  @xcite .    in niraand pathlets ,",
    "the situation is different because routing information ( i.e.,inter - domain addresses and route segments , and pathlets , respectively ) is disseminated to users .",
    "the source can therefore keep a database local path database , querying it ( locally ) on demand .      at the network layer ,",
    "hornetcan benefit from ases that offer traffic redirection to mitigate topology - based attacks ( see section  [ sec : ilt ] ) .",
    "for instance , ases can allow paths that deviate from the valley - freeness policy to increase the anonymity set size of end hosts .",
    "this enables a trade - off between path length and anonymity , as described by sankey and wright  @xcite .",
    "in addition , upper - layer anonymity protocols can be used in conjunction with hornetto provide stronger anonymity guarantees .",
    "for example , to entirely remove the concerns of topology - based attacks , a single - hop proxy or virtual private network ( vpn ) could be used to increase the size of the anonymity sets of end hosts .",
    "similar solutions could also protect against upper - layer de - anonymization attacks , in particular fingerprinting attacks on the transport protocol  @xcite .    at lower layers ,",
    "hornetis also compatible with link - layer protection such as link - level encryption .",
    "the role of link - level encryption in hornetis comparable to ssl / tls in tor .",
    "link encryption prevents an adversary eavesdropping on a link from being able to distinguish individual sessions from each other , therefore making confirmation attacks much harder for this type of adversary .",
    "[ [ targeted - confirmation - attacks ] ] targeted confirmation attacks + + + + + + + + + + + + + + + + + + + + + + + + + + + + +    when for a certain session an adversary controls both the node closest to the source and the node closest to the destination ( or the destination itself ) , it can launch confirmation attacks by analyzing flow dynamics.these attacks can be made more effective by replaying packets .",
    "hornet , like other low - latency onion routing schemes  @xcite , can not prevent such confirmation attacks targeting a small number of specific users  @xcite .",
    "however , hornetraises the bar of deploying such attacks at scale : the adversary must be capable of controlling a significant percentage of isps often residing in multiple geopolitical areas .",
    "in addition , the packet obfuscation measures built into hornet(discussed in section  [ sec : security ] ) make it non - trivial to link two flows , since it is not possible to simply match packets through bit patterns .",
    "timing intervals for packet sequences need to be stored and compared , thus performing such operations for a large fraction of the observed flows is expensive .",
    "furthermore , it is difficult for attackers to perform active attacks ( e.g. , packet replay ) at scale while remaining undetected .",
    "for instance , a downstream benign as can detect replayed packets by a compromised upstream as ; end hosts can also detect and report packet tagging attacks when ( a threshold number of ) end - to - end macs do not successfully verify .    [ [ perfect - forward - secrecy ] ] perfect forward secrecy + + + + + + + + + + + + + + + + + + + + + + +    a drawback of hornet s efficiency - driven design is that it does not provide perfect forward secrecy for the link between communicating parties .",
    "this means that an adversary could record the observed traffic ( the setup phases , in particular ) , and if it later compromises a node , it learns which node was next on the path for each recorded session .",
    "this is an unavoidable limitation of having a setup that consists of a single round - trip .",
    "other systems ( e.g. , tor ) use a telescopic setupth - hop as through the channel through 1st - hop as to @xmath352th - hop as .",
    "] , which achieves perfect forward secrecy at the cost of diminished performance ( in particular higher latency , and also an additional asymmetric cryptographic operation per node ) .",
    "using a telescopic setup is also possible for hornet , but in addition to the performance cost it also requires that all paths be reversible .",
    "however , this requirement does not hold in today s internet , where a significant fraction of as - level paths are asymmetric  @xcite .",
    "it is important to note that in hornetit is still possible to achieve perfect forward secrecy for the contents of the communication , i.e. , for the data exchanged between sources and destinations .",
    "the destination needs to generate an ephemeral diffie - hellman key pair , and derive an additional shared key from it . for simplicity , is part of our implementation .",
    "it is done in such a way that the forward secret shared key is included in the destination s fs during the setup , without any additional packet being required . ]",
    "destinations also need to generate a new local secret @xmath105 frequently , so in the event of a destination being compromised it is not possible for the adversary to decrypt fses used in expired sessions .",
    "[ [ anonymity - systems - as - overlays ] ] anonymity systems as overlays + + + + + + + + + + + + + + + + + + + + + + + + + + + + +    the study of anonymous communication began with chaum s proposal for mix networks  @xcite .",
    "a number of message - based mix systems have been proposed and deployed since  @xcite .",
    "these systems can withstand an active adversary and a large fraction of compromised relays , but rely on expensive asymmetric primitives , and message batching and mixing .",
    "thus , they suffer from large computational overhead and high latency .",
    "onion routing systems  @xcite were proposed to efficiently support interactive traffic . in general , low - latency onion routing systems are vulnerable to end - to - end confirmation attacks  @xcite , and may fail to provide relationship anonymity when two routers on the path are compromised  @xcite . hornetshares these limitations .",
    "one specific onion routing system , tor , has a number of security advantages over hornet .",
    "tor can prevent replays and has perfect forward secrecy for its sessions .",
    "additionally , due to its overlay design which uses global redirection , tor is not constrained by the underlying network topology . however",
    ", global redirection enables the attack vector that allows even single compromised ases to perform confirmation attacks  @xcite , as one as can be traversed multiple times .",
    "this attack is not possible in hornetsince packets traverse each as on the path only once .",
    "in addition , hornet s performance also distinguishes it from all existing schemes based on overlay networks : first , hornetcan directly use short paths provided by underlying network architectures , reducing propagation latency ; second , hornetrequires only a single round trip to establish a session , reducing the setup delay ; third , horneteliminates the processing and queuing delays both on relay nodes and in the kernel s network stack ; finally , edge routers in hornetoffer higher throughput compared to voluntarily - contributed end hosts , increasing the total throughput of anonymous traffic .",
    "[ [ anonymity - systems - in - fias ] ] anonymity systems in fias + + + + + + + + + + + + + + + + + + + + + + + + +    hsiao et  al .",
    "@xcite explored the design space of efficient anonymous systems with a relaxed adversary model . in their scheme ,",
    "lap , the adversary can compromise only a single node , and the first hop must always be honest . sankey and wright proposed dovetail  @xcite ( based on pathlets  @xcite and scion  @xcite ) which has the same attacker model as lap , except it allows the first hop to be compromised .",
    "moreover , neither lapnor dovetailcan support asymmetric paths where packets traverse different sets of nodes in different directions .",
    "hornetoffers three improvements over lapand dovetail : 1 ) hornetfully hides path information , i.e.,total path length and nodes positions , in packet headers ; 2 ) hornetprotects and obfuscates packet contents by onion - encryption / decryption , thwarting correlating packets of the same flow by selectors ; 3 ) hornetsupports asymmetric paths and allows the first hop ases to be compromised .",
    "though hornetintroduces additional overhead in comparison with lapand dovetail , our evaluation results show that hornetcan still support high - speed packet forwarding at nearly 80% of line rate",
    ".    the research community has also explored applying onion routing to fias .",
    "liu et  al .",
    "@xcite proposed tor instead of ip as an fia that regards anonymity as the principal requirement for the network architecture .",
    "however , details on how to scale tor s current design ( requiring per - circuit state ) to internet scale were not addressed .",
    "dibenedetto et  al .",
    "@xcite proposed andana , to enable onion routing in named data networking ( ndn )  @xcite .",
    "ndn focuses on content delivery and thus inherently different from the fias we considered .",
    "in this paper , we address the question of `` what minimal mechanism can we use to frustrate pervasive surveillance ? '' and study the design of a high - speed anonymity system supported by the network architecture .",
    "we propose hornet , a scalable and high - speed onion routing scheme for future internet architectures .",
    "hornetnodes can process anonymous traffic at over 93 gb / s and require no per - flow state , paving the path for internet - scale anonymity .",
    "our experiments show that small trade - offs in packet header size greatly benefit security , while retaining high performance .",
    "we are grateful for insightful discussions with ian goldberg , michael markus , and the members of the eth zrich network security group for their discussions and feedback .    the research leading to these results received funding from the european research council under the european union s seventh framework programme ( fp7/2007 - 2013 ) / erc grant agreement 617605 .",
    "george danezis is supported by the eu h2020 project panoramix ( 653497 ) and epsrc project on `` strengthening anonymity in messaging systems '' ( ep / m013286/1 ) .",
    "we also gratefully acknowledge support by eth zrich , and by intel for their equipment donation that enabled the high - performance experiments ."
  ],
  "abstract_text": [
    "<S> we present hornet , a system that enables high - speed end - to - end anonymous channels by leveraging next - generation network architectures . </S>",
    "<S> hornet is designed as a low - latency onion routing system that operates at the network layer thus enabling a wide range of applications . </S>",
    "<S> our system uses only symmetric cryptography for data forwarding yet requires no per - flow state on intermediate routers . </S>",
    "<S> this design enables hornet routers implemented on off - the - shelf hardware to process anonymous traffic at over 93  gb / s . </S>",
    "<S> hornetis also highly scalable , adding minimal processing overhead per additional anonymous channel .    [ security and protection ] </S>"
  ]
}