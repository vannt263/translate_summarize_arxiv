{
  "article_text": [
    "for the design of embedded systems that support real - time applications , it is required to guarantee the satisfaction of real - time constraints .",
    "after applications are mapped to a candidate architecture , we check the feasibility of the architecture by estimating the performance .",
    "fast estimation enables us to explore the wider design space of architecture selection and application mapping .",
    "more accurate estimation will reduce the system cost .",
    "the performance analysis problem addressed in this paper is to estimate the worst case response time ( wcrt ) of an application that is executed on a distributed embedded system .",
    "a good example can be found in an intelligent safety application in a car where there is a tight requirement on the worst case response time from the sensor input to the actuator output .    despite a long history of research over two decades",
    ", it still remains a challenging problem to tightly estimate the wcrt of an application in a distributed embedded system based on a fixed priority scheduling policy .",
    "since the response time of an application is affected by interference between applications as well as execution time variation of tasks , all possible execution scenarios should be considered to obtain the exact wcrt .",
    "there are some approaches proposed , such as a model checking approach [ brekling et al .",
    "2008 ]    and an ilp - based approach [ kim et al . 2012 ]    , to find the accurate wcrt .",
    "however , they require exponential time complexity .",
    "the exact wcrt analysis problem is known to be np - complete [ yen and wolf 1998 ]    .",
    "analytical techniques have been extensively researched to obtain a tight upper bound of the wcrt with diverse assumptions on target architectures and applications .",
    "this paper assumes that an application is given as a task graph that represents data dependency between tasks and the execution time of a task may vary .",
    "it is assumed that each task has a fixed priority .",
    "in addition , we support arbitrary mixture of preemptive and non - preemptive processing elements in the system . to analyze the wcrt of an application ,",
    "this paper proposes a performance analysis technique , called hybrid performance analysis ( hpa ) , combining a scheduling time bound analysis and a response time analysis ( rta ) .",
    "the proposed technique is proven to be conservative and experimental results show that it provides a tighter bound of wcrt than the other state - of - the - art techniques .",
    "the rest of this paper is organized as follows . in section [ sec : related ] we overview the related work and highlight the contributions of this work . in section [ sec : problem_def ] ,",
    "the application model and the system model assumed in this paper are formally described .",
    "section [ sec : yw_review ] reviews the y&w method and proves that it is not conservative by showing some counter examples .",
    "the proposed technique and some optimization techniques are explained in sections [ sec : hpa ] and [ sec : enhanced_hpa ] respectively .",
    "we summarize the overall algorithm in section [ sec : overall_alg ] .",
    "experimental results are discussed in section [ sec : experiment ] .",
    "finally , we conclude this paper in section [ sec : conclusion ] .",
    "response time analysis ( rta ) was first introduced for a single processor system based on preemptive scheduling of independent tasks that have fixed priorities , fixed execution times , and relative deadline constraints equal to their periods [ lehoczky et al . 1989 ]    .",
    "extensive research efforts [ lehoczky 1990 , audsley et al .",
    "1993 ]    have been performed to release the restricted assumptions .",
    "pioneered by k. tindell et al .",
    "[ tindell and clark 1994 ]    , a group of researchers extended the schedulability analysis technique to distributed systems ; for example , dynamic offset of tasks [ palencia and harbour 1998 ]    , communication scheduling [ tindel et all .",
    "1995 ]    , partitioned scheduling with shared resources [ schliecker and ernst 2010 ]    , and earliest deadline first ( edf ) scheduling [ pellizzoni and lipari 2007 ]    .",
    "there exist some researches that consider precedence constraints between tasks , by assigning the offset and deadline of each task conservatively considering every possible execution ordering between tasks [ palencia and harbour 1998 , tindel et all .",
    "1995 , pellizzoni and lipari 2007 ] , which usually incur significant overhead of overestimation and computation complexity .",
    "on the other hand , we handle the dependent tasks directly , assuming that a task is released immediately after all predecessors complete .    to the best of our knowledge ,",
    "the state of the art rta method for dependent tasks was proposed by yen and wolf [ yen and wolf 1998 ] , denoted as the y&w method hereafter .",
    "it considers data dependencies between tasks and variable execution times of tasks directly in the response time analysis but supports only preemptive systems .",
    "several extensions have been made to the y&w method , with considering communication [ yen and wolf 1995 ]    and control dependencies [ pol et al .",
    "2000 ]    .",
    "unfortunately , the conservativeness has not been proven for the y&w method .",
    "this paper discovers that the y&w method is actually not conservative by showing counter - examples for which the y&w method produces a shorter response time than the worst case response time in section [ sec : yw_review ] .",
    "non - preemptive processing elements are supported in the mast suite [ harbour 2001 ]    that includes several schedulability analysis techniques .",
    "but they support only chain - structured graphs where a task has a single input and/or a single output port .",
    "there is a compositional approach distinguished from the holistic rta - based approaches .",
    "symta / s [ henia et al .",
    "2005 ]    which is a well - known compositional analysis , performs the analysis in a modular manner .",
    "it analyzes the performance for each processing component and abstracts its result as an event stream at the component boundary .",
    "while the compositional approach achieves scalability , it sacrifices estimation accuracy by ignoring the release time constraint coming from data dependencies between tasks running on different processing elements .",
    "recently , a holistic wcrt analysis approach , called scheduling time bound analysis ( stba ) , has been proposed [ kim et al .",
    "2013 ]    .",
    "it computes the conservative time bound for each task within which the task will be scheduled , considering all possible scheduling patterns . in the stba approach , however , the task graphs should be expanded up to the least common multiple ( lcm ) of their periods , which limits the scalability of the technique . while the proposed technique adopts the basic time bound idea of the stba method to analyze how data dependencies",
    "affect the release times of tasks in the same application , it considers inter - application interference analytically , based on the response time analysis .",
    "we formally describe the application model and the system model assumed in this paper .",
    "an input application , @xmath0 , is represented as an acyclic task graph as illustrated in fig .",
    "[ fig : problem ] ( a ) . in a task graph , @xmath1",
    ", @xmath2 represents a set of tasks and @xmath3 a set of edges to represent execution dependencies between tasks . if a task has more than one input edge , it is released after all predecessor tasks are completed .",
    "an application @xmath4 can be initiated periodically or sporadically , characterized by a tuple @xmath5 where @xmath6 and @xmath7 represent the period and the maximum jitter , respectively . for sporadic activation",
    ", @xmath6 denotes the minimum initiation interval .",
    "task graph @xmath4 is given a relative deadline @xmath8 to meet once activated .",
    "we assume that @xmath8 is not greater than @xmath6 in this paper .",
    "the task graph that task @xmath9 belongs to is denoted by @xmath10 .",
    "a system consists of a set of processing elements ( pes ) as shown in fig .",
    "[ fig : problem ] ( c ) .",
    "a task is a basic mapping unit onto a processing element .",
    "we assume that task mapping is given and fixed .",
    "the processing element that the task @xmath11 is mapped to is denoted by @xmath12 . for each task",
    "@xmath11 , the varying execution time is represented as a tuple @xmath13 $ ] indicating the lower and the upper bound on the mapped pe .",
    "note that a communication network can be modeled as a separate pe .",
    "for instance , the pe graph of fig .",
    "[ fig : problem ] ( c ) represents a system that consists of two processors ( pe0 and pe2 ) connected to a bus ( pe1 ) .",
    "tasks mapped to a communication network deliver messages between two computation tasks ; for example @xmath14 indicates message communication between two computation tasks , @xmath15 and @xmath16 .",
    "we assume that the scheduling policy of a pe can be either a fixed - priority preemptive scheduling or a fixed - priority non - preemptive scheduling .",
    "@xmath17 denotes a set of pes that have preemptive scheduling policy , and @xmath18 denotes a set of pes with non - preemptive scheduling policy .",
    "a pe belongs to either @xmath17 or @xmath18 . in fig .",
    "[ fig : problem ] , pe0 and pe2 use preemptive scheduling while pe1 serves the communication tasks in a non - preemptive fashion ; a higher - priority message can not preempt the current message delivery .",
    "we assume that all tasks mapped to each pe have distinct priorities to make the scheduling order deterministic .",
    "the priority of the task @xmath11 is denoted by @xmath19 .",
    "the wcrt of task graph @xmath4 , denoted by @xmath20 , is defined as the time difference between the latest finish time and the earliest release time among tasks in the task graph .",
    "since the y&w method is known as a state - of - the art schedulability analysis technique that considers dependency between tasks directly , we select it as the reference technique for comparison in this paper . in this section we review the key ideas of the y&w method and prove that it fails to find a conservative upper bound of the wcrt .",
    "since dependency between tasks constrains the release times of tasks , the y&w method proposed three techniques : _ separation analysis _ , _ phase adjustment _ , and _ period shifting_.        the baseline response time analysis for independent tasks defines the response time @xmath21 of a task @xmath9 as an iterative form :    @xmath22    where set @xmath23 represents the set of higher priority tasks that may preempt task @xmath9 . note that the second term subsumes all possible preemption delays by higher priority tasks for conservative estimation .",
    "when the baseline rta is directly applied to tasks with dependency , the analytical wcrt of a task graph may become much larger than the actual wcrt .",
    "consider an example in fig .",
    "[ fig : ex_baserta ] .",
    "unless the task dependency is considered , @xmath15 can preempt both @xmath14 and @xmath16 , and @xmath14 can preempt @xmath16 .",
    "therefore , wcrt becomes @xmath24 as shown in fig .",
    "[ fig : ex_baserta ] ( a ) while the tight wcrt is @xmath25 . if the dependency is considered , @xmath15 can preempt either @xmath14 or @xmath16 but not both , and @xmath14 can not preempt @xmath16 , as shown in fig . [",
    "fig : ex_baserta ] ( b ) .    in the y&w method , the release times and the finish times of tasks are computed , considering data dependencies between tasks .",
    "if the earliest release time ( @xmath26 ) of a higher priority task @xmath27 is larger than the latest finish time ( @xmath28 ) of a given task @xmath9 , @xmath27 can not preempt @xmath9 . and",
    "if there is a direct path between a higher priority task and a given task , no preemption will occur .",
    "these cases are identified in the _ separation analysis _ to check the preemption possibility between two tasks in the same task graph ; the _ separation analysis _ finds that @xmath14 can not preempt @xmath16 in the example of fig .",
    "[ fig : ex_baserta ] .",
    "the _ phase adjustment _ technique in the y&w method computes the distance , called phase , between the release times of the preempting and the preempted tasks to identify the impossible preemptions along dependent tasks .",
    "the request phase @xmath29 means the minimum distance from the request(release ) time of @xmath9 to the next release time of @xmath27 .",
    "note that if the dependency is not considered , the request phase will be 0 since the worst case preemption occurs when the preempting task is released at the same time as the preempted task .",
    "the request phase is dependent on the finish phase of its predecessors .",
    "the finish phase @xmath30 means the minimum distance from the finish time of @xmath9 to the next release time of @xmath27 . the _ phase adjustment _ technique modifies the response time formula of equation ( [ eq : eq1 ] ) as follows :    @xmath31    @xmath32}}{\\bigg\\lceil\\frac{\\max(0 , r_i-{\\phi_{i , j}^r})}{{\\mathcal{t}_{{\\tau_{j}}}^{p}}}\\bigg\\rceil\\cdot{\\tau_{j}^{wcet}}}\\ ] ]    @xmath33}$}\\\\      ( { \\phi_{i , j}^r}-r_i ) \\bmod { \\mathcal{t}_{j}^{p } } & \\textrm{otherwise}\\\\ \\end{array } \\right.\\ ] ]    where @xmath34 $ ] is a set of higher priority tasks excluded in the preemption delay computation by the _ separation analysis _ , and @xmath35 is the immediate predecessor set of task @xmath9 . in the modified formula ,",
    "the request phase is subtracted from the response time in the preemption count computation . for conservative computation ,",
    "the request phase and the finish phase are made non - negative . for detailed explanation of the formula ,",
    "refer to [ yen and wolf 1998 ]    .    for a preempting task @xmath27 ,",
    "we compute the request phase and the finish phase for each task @xmath9 of a task graph . for a source task @xmath9 , @xmath29",
    "is set to 0 , meaning that the preempting task can be released at the same time to make @xmath9 experience the maximum number of preemptions by @xmath27 .",
    "after computing the response time , finish phase @xmath30 is updated .",
    "the request phase for a non - source task is updated in turn based on the finish phases of its predecessors . in the example of fig .",
    "[ fig : ex_baserta ] , the request phase @xmath36 is initialized to 0 and the response time of @xmath14 is 20 .",
    "the finish phase @xmath37 is updated to @xmath38 , and the request phase @xmath39 is inherited from @xmath37 . since @xmath14 and @xmath16 are separated , the response time of @xmath16 becomes @xmath40 .",
    "if we sum the response times of @xmath14 and @xmath16 , we obtain the actual wcrt that is 30 .",
    "consider a preempting task with varying release time .",
    "the release time may vary due to finish time variation of its predecessor .",
    "then , the preempting task will not be scheduled periodically , but in a bursty fashion , which increases the preemption count .",
    "the _ period shifting _ technique is used in the y&w method to account for this effect .",
    "let @xmath27 be a task that may preempt @xmath9 and of which release time varies between @xmath26 and @xmath41 that indicate the minimum and maximum release time of @xmath27 respectively . to compute the maximum number of preemptions by @xmath27 onto @xmath9",
    ", we need to consider the release time difference .",
    "the authors of the y&w method did not clarify how to integrate the _ period shifting _ technique and the _ phase adjustment _ technique in a single formula .",
    "if both techniques are applied separately in sequence , the conventional rta equation is modified to the following formula , which is used as the y&w method in this paper .",
    "@xmath42}}{\\bigg\\lceil\\frac{\\max(0 , r_i-{\\phi_{i , j}^r}+{\\tau_{j}^{maxr}}-{\\tau_{j}^{minr}})}{{\\mathcal{t}_{{\\tau_{j}}}^{p}}}\\bigg\\rceil\\cdot{\\tau_{j}^{wcet}}}\\ ] ]      unfortunately , the y&w method fails to find the maximum preemption count .",
    "consider a simple example of fig .",
    "[ fig : ex_underestimation1 ] .",
    "since @xmath16 has no predecessor and a zero jitter , release time is always 0 .",
    "then the response time of @xmath14 from the y&w method becomes @xmath43 as shown in fig .",
    "[ fig : ex_underestimation1 ] ( a ) , in which @xmath14 can be preempted once by @xmath16 . but",
    "@xmath16 can preempt @xmath14 twice and the response time of @xmath14 can be as large as 30 as shown in fig .",
    "[ fig : ex_underestimation1 ] ( b ) when the start of @xmath16 is delayed by the preemption of @xmath15 .",
    "since the y&w method only considers the release time variation by predecessors but not the start time variation by preemption , it fails to obtain a conservative wcrt .",
    "another under - estimate example of fig .",
    "[ fig : ex_underestimation2 ] shows that period shifting and phase adjustment are inter - dependent while the y&w method treats them separately . in the y&w method ,",
    "@xmath44 and @xmath45 are 60 assuming that task @xmath46 is first released at time 50 simultaneously with @xmath14 and the next release will be 100 time units after ignoring the period shifting effect . but the worst case of preemption occurs when @xmath46 is first released at time 0 .",
    "then the next release of @xmath46 can appear after @xmath16 executes 10 time units as shown in fig .",
    "[ fig : ex_underestimation2 ] .",
    "so , the wcrt of @xmath47 is 110 since @xmath46 appears once per @xmath47 execution in the y&w method while it is 130 since @xmath46 appears twice per @xmath47 execution in the worst case .",
    "motivated from this example , the proposed technique considers period shifting and phase adjustment holistically , which will be explained in the next section .              in the period shifting technique , the release time difference is added to the response time in the preemption delay computation .",
    "it should be applied only once in a sequence of releases of the preempting task .",
    "but the y&w method applies period shifting to all tasks independently , as shown in the example of fig .",
    "[ fig : ex_overestimation1 ] where period shifting is applied to all tasks , @xmath15 to @xmath16 , in @xmath47 . as a result @xmath48 makes 5 preemptions in total to make the wcrt of the task graph be 150 .",
    "but the actual wcrt is 140 as shown in fig .",
    "[ fig : ex_overestimation1 ] ( b ) since @xmath48 can make 4 preemptions at most . in the y&w method , period shifting value for @xmath48 is 40 because of the execution time variation of its predecessor @xmath46 .",
    "then @xmath48 preempts @xmath15 twice to make the wcrt of @xmath15 be @xmath49 .",
    "@xmath50 is computed to @xmath51 , and the wcrt of @xmath14 is @xmath52 .",
    "since @xmath53 becomes @xmath54 , the wcrt of @xmath16 is @xmath55 , experiencing two preemptions .",
    "by integrating period shifting into phase adjustment we could improve the tightness of the wcrt by removing the problem of redundant application of period shifting , which will be explained in the next section .",
    "another cause of overestimation comes from the fact that the y&w method does not consider partial preemptions . in the example of fig .",
    "[ fig : ex_overestimation2 ] , @xmath14 can not preempt @xmath48 since two tasks are separated . on the other hand , @xmath16 and @xmath46",
    "are not separated because @xmath46 can be released during the execution of @xmath16 . in the y&w method , however , the wcet of @xmath46 is wholly added to the preemption delay of @xmath16 .",
    "partial preemption may occur between tasks in the same task graph as shown in this example , which is not considered in the baseline response time analysis .",
    "in the proposed analysis , however , we perform scheduling of tasks in the same task graph so that we could detect this kind of partial preemption precisely .",
    "the proposed technique called hpa ( hybrid performance analysis ) extends and combines the stba approach and the rta method : the former is to account for interference between tasks in a same task graph and the latter for interference from the other task graphs .",
    "[ fig : hpa_overallflow ] shows the algorithm flow of the proposed technique .",
    "first , we compute three pairs of time bound information for each task : release time bound(@xmath56 , @xmath57 ) , start time bound ( @xmath58 , @xmath59 ) , and finish time bound ( @xmath60 , @xmath28 ) . unlike the stba technique [ kim et al .",
    "2013 ]    that assumes to schedule all task graphs together , the proposed technique schedules each task graph separately at the time bound computation step .",
    "the interference from the other task graphs is considered by the holistic phase adjustment technique based on the period shifting amount computed in the previous iteration .",
    "a period shifting amount is updated after time bound computation .",
    "this process is repeated until every value is converged .        in this section",
    ", we explain the key techniques of the proposed analysis and discuss how to achieve a safe and tighter bound of the wcrt . at first , how to compute time bounds is explained .",
    "secondly , we derive and optimize a conservative bound of a period shifting amount from @xmath9 to @xmath61 which bounds the maximum preemption count of @xmath9 between release time and the maximum start time of @xmath61 . finally , _ period shifting _ is combined with _",
    "phase adjustment _ technique in the proposed _ holistic phase adjustment _ technique .",
    "let @xmath62 , @xmath63 , and @xmath64 denote the actual release time , start time , and finish time of task @xmath61 . in our task graph model , the release time of a task is the maximum finish time of its immediate predecessors , as summarized in the following definition .",
    "@xmath65    where @xmath66 denotes the release time of the task graph .",
    "then the minimum ( @xmath67 ) and maximum ( @xmath68 ) release time bound pair is computed as follows :    @xmath69    @xmath70    the earliest and the latest release times of a non - source task are defined as the maximum value among the earliest and the latest finish times of predecessors , respectively since it becomes executable only after all predecessor tasks are finished .",
    "[ theorem3 ] @xmath67 and @xmath68 are conservative , or _ @xmath71_.    if @xmath61 is a source task , @xmath72 since @xmath73 .",
    "for non - source task @xmath61 , assume that it holds for all predecessor tasks of @xmath61 .",
    "since @xmath74 , @xmath71 .    by induction",
    ", the lemma holds .",
    "q.e.d .    for task @xmath61 to start ,",
    "it should be already released and the processor must be available : the start time of @xmath61 is not smaller than the release time and the maximum time among finish times of tasks that have higher priority , start earlier , and finish after task @xmath61 is released .",
    "formally , the start time is defined as follows :    @xmath75    where set @xmath76 is defined as @xmath77 for the preemptive scheduling policy , and @xmath78 for the non - preemptive scheduling policy .",
    "one the other hand , the earliest start time @xmath79 is formulated as follows :    @xmath80    where set @xmath81 for the preemptive scheduling policy is defined as @xmath82 and for the non - preemptive scheduling policy as @xmath83 .",
    "if higher priority task @xmath84 always starts before @xmath79 and the earliest finish time of @xmath84 is later than @xmath67 , @xmath61 should wait for the completion of @xmath84 . in case a non - preemptive scheduling",
    "is used , a lower priority task that starts before @xmath67 is included .",
    "note that we only consider the tasks in the same task graph since the other tasks can appear at any time , so they should be ignored for conservative estimation of the minimum start time .    to estimate the maximum start time @xmath85 for conservative estimation",
    ", we should consider all possible preemptions .",
    "@xmath86    where @xmath87 and @xmath88 denote the amounts of preemption between the release time and the start time by lower and higher priority tasks respectively .",
    "for the premeptive scheduling policy , @xmath87 is zero . in case",
    "a lower priority task is running when @xmath61 is released , @xmath61 should wait until the current lower priority task finishes in the non - preemptive scheduling policy , which is accounted as follows :    @xmath89    where @xmath90 and @xmath91 .",
    "set @xmath92 includes lower priority tasks in the same task graph that may start earlier than @xmath61 and delay the start time of @xmath61 .",
    "note that partial blocking is considered in the formula by @xmath93 , which can be smaller than @xmath94 . on the other hand , set",
    "@xmath95 includes all lower priority tasks in the other task graphs .",
    "since they can appear at any time , we take the maximum wcet for conservative estimation . in case",
    "every predecessor is mapped to the same pe , @xmath87 is zero .",
    "@xmath88 is commonly formulated for both scheduling policies as follows :    @xmath96    where @xmath97 and @xmath98 . set @xmath99 includes higher priority tasks in the same task graph that can possibly delay the start time of @xmath61 .",
    "partial preemption is considered similarly to @xmath87 formulation .",
    "for the example of fig .",
    "[ fig : ex_overestimation2 ] , we precisely compute the preemption delay from @xmath16 to @xmath46 as @xmath100 , which is less that @xmath101 .",
    "for the higher priority tasks in the other task graphs , we use a similar formula as the response time analysis to compute the maximum preemption delay .",
    "the notation @xmath102 corresponds to the request phase adjustment that computes the minimum distance from the release time of @xmath61 to the next release time of a preempting task @xmath84 .",
    "how to formulate the request phase @xmath102 will be explained in the next subsection .",
    "[ theorem4 ] @xmath79 and @xmath85 are conservative , or _",
    "@xmath103_.    first we prove that @xmath104 .",
    "since @xmath105 , we need to prove @xmath106 .",
    "@xmath107 since @xmath108 for both preemptive and nonpreemptive cases , and @xmath109 , @xmath110 .",
    "@xmath111    next , we prove that @xmath112 by showing that no task will delay the start of @xmath61 without being considered in @xmath87 or @xmath88 computation .    1 .",
    "suppose actual preemption amount by lower priority tasks is larger than @xmath87 . for preemptive scheduling policy ,",
    "it is impossible because a lower priority task can not preempt @xmath61 . for nonpreemptive scheduling policy ,",
    "only one lower priority task can delay the execution of @xmath61 . for @xmath113 , since @xmath95 includes all lower priority tasks , it is not possible for the preemption amount to be larger than the maximum worst case execution time of tasks in @xmath95 .",
    "+ consider @xmath114 .",
    "@xmath84 can delay @xmath61 by @xmath115 at most if @xmath84 starts before @xmath61 is released or @xmath116 .",
    "@xmath117 @xmath118 @xmath119 since @xmath120 and @xmath121 , @xmath122 since @xmath84 can not be executed longer than @xmath94 , @xmath123 finally , consider the case when all predecessors are mapped to the same processor .",
    "since there is no time interval between the finish time of the latest predecessor task @xmath124 and the release time of @xmath61 , no lower prioirty task can start after @xmath124 finishes and before @xmath61 is released .",
    "[ theorem3_2_1 ] 2 .",
    "consider higher priority tasks that may preempt @xmath61 .",
    "for @xmath125 and @xmath126 , the preemption amount is bounded by @xmath127 similarly to the proof of the case @xmath125 and @xmath128 in [ theorem3_2_1 ] .",
    "+ suppose there is a task @xmath84 which can preempt @xmath61 such that @xmath125 and @xmath129 . then @xmath130 or @xmath131 .",
    "@xmath84 always starts later than @xmath61 since @xmath132 , or @xmath84 finishes earlier than @xmath61 since @xmath131 .",
    "no preemption may be occurred so that there exists no such task .",
    "+ for @xmath113 , the proof is trivial if the request phase is conservatively given .",
    "the conservativeness of the request phase , @xmath102 will be proven in lemma [ theorem2 ] .",
    "[ theorem3_2_2 ]    by [ theorem3_2_1 ] and [ theorem3_2_2 ] , @xmath133 .",
    "the minimum finish time @xmath134 is formulated as follows :    @xmath135    where @xmath136 represents the unavoidable ( best - case ) preemption delay that is zero for the non - preemptive scheduling policy . for the preemptive scheduling policy ,",
    "@xmath136 becomes    @xmath137    where @xmath138 .",
    "@xmath139 is a set of higher priority tasks which always start to execute and preempt @xmath61 during @xmath61 is running from @xmath79 to @xmath134 .",
    "the maximum finish time @xmath140 is formulated as follows :",
    "@xmath141    where @xmath142 represents the worst - case preemption delay that is zero for the non - preemptive scheduling policy .",
    "@xmath142 for the preemptive scheduling policy is formulated as follows :    @xmath143    where @xmath144 , indicating a set of higher priority tasks which can appear during the execution of @xmath61 .",
    "the notation @xmath145 is the start phase that is the the minimum distance from the start time of @xmath61 to the next release time of a preempting task @xmath84 . for tasks in the other task graphs ,",
    "the maximum possible preemption delay is computed similarly to ( [ eq : eq15 ] ) .",
    "the start phase will be explained in the next subsection .",
    "[ theorem5 ] @xmath134 and @xmath140 are conservative , or _",
    "@xmath146_.    ( nonpreemptive ) if non - preemptive scheduling is used then no task may preempt @xmath61 .",
    "hence the finish time is the sum of the start time and the execution time .",
    "( preemptive ) first , we prove that @xmath147 .",
    "let @xmath148 be @xmath149 .",
    "@xmath150 where the last term accounts for tasks that start to execute during @xmath61 is running , and preempt @xmath61 .",
    "since @xmath151 , + and @xmath152 , @xmath153 @xmath154 @xmath155 since @xmath156 @xmath157 second , we prove that @xmath158 by contradiction .    for @xmath125 ,",
    "suppose there is some @xmath159 that satisfies @xmath125 and can preempt @xmath61",
    ". then @xmath160 or @xmath161 .",
    "the tasks that satisfies @xmath162 belongs to the @xmath99 , so that the amount of preemption from those tasks are already included in @xmath85 and so in @xmath140 .",
    "the tasks that satisfies @xmath163 can not preempt @xmath61 since @xmath84 finishes before @xmath68 .",
    "the tasks that satisfies @xmath164 can not preempt @xmath61 since @xmath84 starts after @xmath140 . for @xmath113 , the proof is trivial since we assume that the start phase is conservatively given .",
    "the conservativeness of the start phase , @xmath145 will be proven in lemma [ theorem2 ] .",
    "q.e.d .    after determining all time bounds of tasks ,",
    "we compute the wcrt of each task graph @xmath4 as follows :    @xmath165    [ theorem6 ] the hpa technique guarantees the conservativeness of every schedule time bound when it is converged .",
    "theorem [ theorem6 ] is proved by lemma [ theorem3 ] , lemma [ theorem4 ] , and lemma [ theorem5 ] .",
    "q.e.d .       to @xmath61,width=340 ]    when computing the maximum time bounds , we have to consider the worst case scenario of preemptions in the rta analysis .",
    "[ fig : app_periodshifting ] shows this scenario .",
    "suppose that the target task @xmath61 is released at @xmath68 .",
    "the worst case preemptions of a higher priority task @xmath9 occur when its start time is aligned with the release time of @xmath61 and the second request appears with the shortest interval from @xmath68 , followed by later requests that appear periodically from the second request .",
    "if the period shifting amount is denoted by @xmath166 , the next start time of @xmath9 will be @xmath167 .     between @xmath168 and @xmath169 , ( b )",
    "estimated wcrt of @xmath47 with period shifting @xmath170 , and ( c ) actual wcrt of @xmath47,width=415 ]    recall that the y&w method defines @xmath166 as @xmath171 and it fails to find the worst case behavior as shown in the example of fig .",
    "[ fig : ex_underestimation1 ] .",
    "a naive revision is to define @xmath166 as @xmath172 , by aligning the maximum start time of @xmath9 with the maximum release time of @xmath61 .",
    "the worst case bursty requests occurs when the preempting task is released at @xmath173 . in the example of fig .",
    "[ fig : ex_underestimation1 ] , we can obtain the actual wcrt if @xmath174 is aligned at @xmath175 , which makes @xmath176 .",
    "however , it generates a loose bound for the example of fig .",
    "[ fig : ex_periodshifting1 ] . fig .",
    "[ fig : ex_periodshifting1 ] ( a ) shows the worst case preemption of @xmath46 , considering all possible preemptions from the other tasks . from fig .",
    "[ fig : ex_periodshifting1 ] ( a ) , it is known that @xmath170 is 30 .",
    "if this value is used as period shifting , a loose wcrt is obtained as shown in fig .",
    "[ fig : ex_periodshifting1 ] ( b ) .",
    "the actual wcrt is computed when @xmath177 is equal to @xmath178 , as shown in the fig .",
    "[ fig : ex_periodshifting1 ] ( c ) , which confirms that more elaborate preemption analysis is needed between @xmath168 and @xmath169 . for the conservative but tight bound computation of period",
    "shifting amount , we classify possible preemptions between @xmath168 and @xmath169 into three categories .",
    "the first is the preemptions that affect the start times of both @xmath46 and @xmath14 , which is the amount of @xmath179 in fig .",
    "[ fig : ex_periodshifting1 ] .",
    "these preemptions can be ignored for @xmath177 since those are considered in the computation of @xmath180 .",
    "the second is the preemptions from the tasks that finish earlier than @xmath14 such as @xmath15 in fig .",
    "[ fig : ex_periodshifting1 ] , which should be considered for the @xmath177 .",
    "the last is the preemptions from the task that starts later than @xmath14 such as @xmath16 that is a descendant of @xmath14 .",
    "these also can be ignored since they can not appear before @xmath180 .",
    "based on these observations , we conservativley consider the tasks in the second category in the period shifting computation to get a tighter bound than @xmath172 : that is    @xmath181    where @xmath182 , and @xmath183 .",
    "[ theorem1 ] period shifting is conservative , which means that @xmath184 is an upper bound of preemption counts of @xmath9 in time window @xmath185 $ ] .",
    "conservativeness of period shifting is achieved if @xmath186 of equation ( [ eq : eq6 ] ) includes all tasks in the second category of tasks preempting @xmath9 before @xmath68 .    at first , consider the contribution from @xmath113 to @xmath186 . since the maximum preemption count of @xmath61 by @xmath187 is @xmath188 for @xmath189 time duration , @xmath84 appears @xmath190 times during @xmath191 . on the other hand",
    ", @xmath192 is the number of preemptions during @xmath193 , which is considered in @xmath85 computation .",
    "therefore the appearance of @xmath84 is bounded by @xmath194 times during @xmath186 .",
    "second , consider @xmath195 . if @xmath196 then @xmath84 either preempts @xmath61 as well as @xmath9 ( the first category ) or is scheduled later than @xmath61 ( the third category ) .",
    "so we need to consider only @xmath84 that is released between @xmath197 and @xmath68 .",
    "so the worst case is to consider @xmath84 such that @xmath199 .",
    "if @xmath200 becomes negative , , the previous instance of @xmath84 should be considered with the following condition : @xmath201 . q.e.d .",
    "consider fig .",
    "[ fig : ex_underestimation1 ] .",
    "@xmath202 since @xmath15 satisfies the condition of the second term of @xmath203 , @xmath204 .",
    "hence @xmath205 .",
    "consider fig .",
    "[ fig : ex_periodshifting1 ] . @xmath206 . since @xmath207 , @xmath15",
    "is included in the second term of @xmath208 .",
    "on the other hand , @xmath16 is excluded in @xmath208 since @xmath209 .",
    "@xmath210 has no contribution to @xmath186 since @xmath211 .",
    "hence @xmath212 .      in this section ,",
    "we describe how we combine the _ period shifting _ technique and the _ phase adjustment _ technique .",
    "there are three phase types considered in the phased adjustment technique ; request phase @xmath213 , start phase @xmath214 , and finish phase @xmath215 .",
    "the main difference between our _ holistic phase adjustment _ and the _ phase adjustment _ of the y&w method is that the phases in our technique can be negative : if phase is negative , it acts like a period shifting .",
    "if @xmath61 is a source task , request phase @xmath213 for each task @xmath216 is initialized to @xmath217 , which means that the start time of @xmath61 is maximally postponed by preemption of @xmath9 . in this way",
    ", period shifting is merged with phase adjustment so that the request phase can be negative .",
    "if @xmath61 is a non - source task , the request phase @xmath213 depends on the finish phases of predecessors .",
    "if it is positive , it means the minimum distance from the release of @xmath61 to the next release time of a preempting task @xmath9 ; fig .",
    "[ fig : ex_phase ] illustrates the case where task @xmath61 has two predecessors @xmath218 and @xmath219 .",
    "since the phase computation is performed per task independently , the finish phases of the predecessor tasks may be different from each other .",
    "when we compute the request phase @xmath213 and the predecessor tasks see different next request times of @xmath9 , we have to take the earliest next request time of @xmath9 among predecesors for the conservative computation . in fig .",
    "[ fig : ex_phase ] , two predecessors @xmath218 and @xmath219 of @xmath61 see different next request times of @xmath9 : @xmath220 and @xmath221 . since @xmath222 ,",
    "we take @xmath220 as the next request time of @xmath9 seen by @xmath61 , and @xmath213 becomes @xmath223 , which means the distance from @xmath68 to the next request time of @xmath9 .",
    "note that the inherited phase adjustment can be negative .",
    "the negative phase , which acts like a period shifing , can not be smaller than @xmath217 .",
    "thus we choose the maximum among the phase adjustment inherited from its predecessors and @xmath217 .",
    "we formulate @xmath213 as follows ;    @xmath224    where @xmath225 is the immediate predecessor set of task @xmath61 . in case",
    "there is a predecessor mapped to a different processor , @xmath213 is set to @xmath217 for conservative computation .",
    "based on @xmath213 and @xmath85 , before computing @xmath140 , the start phase @xmath214 for each task @xmath216 is computed as follows :    @xmath226    when @xmath9 belongs to @xmath227 , or @xmath228 , the start phase is made positive by modulo operation to find the distance to the earliest future invocation of @xmath9 .",
    "otherwise , the start phase @xmath214 can be negative as @xmath213 .",
    "similarly , the finish phase @xmath215 is formulated based on @xmath214 and @xmath140 as follows :    @xmath229    since there is no preemption during the execution of @xmath61 when @xmath230 , finish phase refers to the same invocation of the preempting task as the start phase .",
    "the finish phase @xmath215 is computed after @xmath140 computation and will be used for the request phases of successors . in the example of fig . [",
    "fig : ex_phase ] , @xmath213 and @xmath214 see the same invocation since the difference @xmath231 is yet positive . on the other hand",
    ", @xmath215 sees the next invocation of @xmath9 , since the invocation of @xmath9 seen by @xmath214 appears during the execution of @xmath61 . in that case , the time difference from @xmath140 becomes negative and the modulo operation finds the positive distance to the next invocation .",
    "[ theorem2 ] phase adjustments @xmath213 , @xmath214 , and @xmath215 are conservative .",
    "we prove it by induction .",
    "first , when task @xmath61 is a source task , @xmath213 is @xmath217 and it is conservative according to lemma [ theorem1 ] . when @xmath232 , @xmath214 and @xmath215 are computed directly from @xmath213 by changing the time reference from the release time to the start time ( @xmath85 ) and ( @xmath140 ) respectively in equations ( [ eq : eq8 ] ) and ( [ eq : eq9 ] ) .",
    "so the consevativeness of the request phase is inherited to the start phase and the finish phase . when @xmath228 , @xmath214 and @xmath215 are computed referring to the next release time of @xmath9 from @xmath85 and @xmath140 . since the worst case preemption scenario to the preempted task is the periodic invocation of the preempting task after the worst case request phase , mod @xmath233 operations in ( [ eq : eq8 ] ) and ( [ eq : eq9 ] ) find the closest request time of @xmath9 from @xmath85 and @xmath140 once the request phase is decided .",
    "it completes the initial step of the induction process .",
    "second , we prove the conservativeness of @xmath213 , @xmath214 , and @xmath215 of non - source task @xmath61 , assuming that for all @xmath234 , @xmath235s are conservative . if @xmath236 , then @xmath213 is @xmath217 and it is conservative . otherwise , we find the closest release time of @xmath9 from the finish phase @xmath235s of predecessors , by ( [ eq : eq7 ] ) .",
    "hence @xmath213 is conservative since @xmath235s are all conservative and the minimum value is chosen .",
    "the proof for @xmath214 , and @xmath215 is similar to the case that task @xmath61 is a source task .",
    "in this section , we describe two optimization techniques to tighten the time bounds by removing infeasible preemptions .",
    "the exclusion technique manages for each task @xmath9 a set @xmath237 which includes tasks that are guaranteed to have no possibility of preempting @xmath9 .",
    "it is obvious that successor tasks belong to this set .",
    "if @xmath9 always preempts one of the predecessors of @xmath84 , @xmath84 can not preempt @xmath9 since it will always be scheduled after @xmath9 .",
    "in addition , if @xmath27 is excluded by @xmath9 , then all @xmath238 are also excluded by @xmath9 . in summary ,",
    "the exclusion set @xmath237 becomes    @xmath239    where @xmath240 is a set of ancestors of @xmath84 and @xmath241 is a set of descendants of @xmath9 .",
    "since there is a cyclic dependency in ( [ eq : eq21 ] ) , iterative computation is required for @xmath237 , initially defined by @xmath241 . after time bound computation ,",
    "it is updated using @xmath242 and @xmath243 .",
    "sets @xmath81 , @xmath92 , @xmath99 , @xmath139 and @xmath244 are modified to have an additional condition @xmath245 .",
    "it is obvious that the exclusion technique does not affect the conservativeness of the proposed technique .      in our baseline technique",
    ", preemptions may occur redundantly ; fig .",
    "[ fig : ex_redundant ] ( a ) shows an elaborated example that experiences two types of duplicate preemptions . the first type of duplicate preemption may occur between tasks in the same task graph in case a higher priority task has large release time variation . in the scheduling time",
    "bound analysis , we detect the preemption possibility by checking if a higher priority task can be released during task execution . in fig .",
    "[ fig : ex_redundant ] ( a ) , @xmath246 can preempt both @xmath48 and @xmath247 because its release time varies between 20 and 75 .",
    "the second type of duplicate preemption occurs between tasks in different task graphs . in the phase adjustment technique",
    ", it is assumed that a preempting task preempts a predecessor task first . in the example of fig .",
    "[ fig : ex_redundant ] , @xmath15 preempts @xmath48 and phase adjustment is performed afterwards .",
    "the request phase of @xmath248 to @xmath15 is reset to @xmath249 since @xmath248 and @xmath15 are assigned to different processors , according to equation ( [ eq : eq7 ] ) .",
    "since the request phase of @xmath247 is inherited from @xmath248 , @xmath247 experiences another preemption by @xmath15 .    as a result , the wcrt is overestimated as illustrated in fig .",
    "[ fig : ex_redundant ] ( a ) that contains both types of duplicate preemptions .        to avoid duplicate preemptions",
    ", we devised an optimization that traces back the schedule and moves duplicate preemptions from ancestors to a target task .",
    "the proposed optimization heuristic is based on the abstruse fact that later preemption gives worse response time than earlier preemption when there are duplicate preemptions , which is stated in theorem [ theorem8 ] below .",
    "algorithm [ alg : commonpreemption ] presents the psuedo code of the proposed heuristic .",
    "it is invoked by @xmath250 ( lines 1 - 7 ) where @xmath61 is the task whose schedule time bound is computed .",
    "@xmath251 represents how much the release time of @xmath61 is reduced by removing duplicate preemptions , and @xmath252 represents how much preemption delay caused by other task graphs should be moved from predecessors to @xmath61 .",
    "we recursively trace back the schedule of critical path ( lines 9 and 22 ) where @xmath253 and @xmath254 represent currently visited task and the parent task of @xmath253 on the critical path , respectively .",
    "we initialize @xmath251 to zero and repeat @xmath255 until @xmath251 is converged .    in algorithm",
    "[ alg : commonpreemption ] , @xmath256 means the preemption count from @xmath9 to @xmath61 .",
    "boolean flag @xmath257 checks if the release time of task @xmath61 can not be reduced as much as the removed preemption time due to a predecessor mapped to a different pe .",
    "the boolean flag is inherited to the successors .",
    "let the currently visited task be @xmath253 in the recursive call , @xmath255 .",
    "at first , we compute the amount of duplicate preemptions from tasks in the same task graph which can preempts both @xmath253 and @xmath61 ( lines 13 - 14 ) , where those tasks belong to set @xmath258 .",
    "even though preemption from the same task can be seen several times on the critical path , we need to consider only the recent preemption in this recursive function .",
    "thus we manage task set @xmath259 while traversing the critical path in order to consider only the recent preemption .",
    "if @xmath260 value for @xmath61 is true , we also move the duplicate preemptions from tasks in the other task graphs to @xmath61 ( lines 15 - 18 ) , where those tasks belong to set @xmath261 .",
    "after computation of the amount of duplicate preemptions , @xmath255 is called recursively for the critical path predecessor @xmath254 , and we get the returned value as @xmath262 ( line 22 ) , which is the possible release time reduction of @xmath253",
    ". however , there can be additional preemptions if @xmath253 is released at @xmath263 .",
    "we conservatively find the amount of additional preemptions and reduce @xmath262 ( line 23 ) , where a task that incurs additional preemption belongs to set @xmath264 .",
    "for the non - preemptive scheduling policy , the condition @xmath265 is removed in @xmath266 . note that release time reduction can be bounded by the other predecessors . if there is more than two predecessors of @xmath253 , we bound the reduced release time with the second largest finish time among the predecessors ( lines 25 - 26 ) .",
    "note that @xmath251 is used in the formula of @xmath267 .",
    "hence we set @xmath251 to zero initially and repeat @xmath268 until @xmath251 is converged .",
    "refer to the example in fig .",
    "[ fig : ex_redundant ] . for task @xmath247 ,",
    "we trace back the schedule of tasks @xmath248 , @xmath48 , @xmath46 , and @xmath14 in order when we call @xmath269 .",
    "when @xmath48 is visited , we find out that @xmath270 and @xmath271 , and both task can preempt @xmath247 .",
    "we remove those duplicate preemptions , then the maximum release time of @xmath248 is reduced to @xmath272",
    ". when returning to @xmath248 , we can know that @xmath273 so that the start time of @xmath248 can not be earlier than the maximum finish time of @xmath274 , which is @xmath275 . finally , we know that @xmath247 can be released at @xmath276 after removing all duplicate preemptions of its predecessors , which is the actual worst case .",
    "the hpa equations need to be modified after algorithm [ alg : commonpreemption ] is applied .",
    "we call @xmath250 after @xmath68 computation and set the reduced maximum release time @xmath277 to @xmath278",
    ". then @xmath68 is replaced by @xmath277 in equations ( [ eq : eq13]),([eq : eq14 ] ) , and sets @xmath92 and @xmath99 .",
    "the terms @xmath93 and @xmath279 in the formula of @xmath88 is changed to @xmath280 and @xmath281 respectively .",
    "and the request phase is not reset to the period shifting value in equation ( [ eq : eq7 ] ) when there is a predecessor mapped to different processors .",
    "the sets @xmath92 and @xmath99 have an additional condition @xmath282 since @xmath277 can be smaller than the finish times of predecessors .",
    "@xmath85 is changed to have the initial value of @xmath277 and is bounded by @xmath68 . and @xmath85 is changed to add @xmath252 that is the sum of removed preemptions from the tasks in the other task graphs as follows :    @xmath283    [ theorem8 ] algorithm [ alg : commonpreemption ] that removes the duplicate preemptions from the ancestors in the critical path preserves the conservativeness of the schedule time bound .",
    "refer to the electronic appendix for the proof .",
    "now we ready to summarize the overall algorithm of the proposed technique .",
    "we compute the schedule time bounds of tasks and phase adjustment values until all time bounds are converged .",
    "the algorithm [ alg : overallalg ] shows the outermost iterative routine that integrates all computations .    at first ,",
    "period shifting and exclusion set are initialized ( lines 2 - 3 ) .",
    "then we iteratively compute the time bounds of tasks ( lines 5 - 8 ) .",
    "tasks are visited according to the topological order first and priority descending order among independent tasks .",
    "each time bound and phase is computed in the written order . after the time bound computation , period shifting and exclusion set set are updated ( lines 9 - 10 ) .",
    "this process is repeated until every value is converged .",
    "if there is a task graph that violates its deadline , we stop the iteration since it is not schedulable ( line 11 ) .",
    "as the reference rta technique , we implemented the y&w method following the pseudo code in [ yen and wolf 1998 ]    . for comparison with mast and symta / s , we use available tools ; mast suite [ harbour 2001 ]    and pycpa [ diemer and axer 2012 ]    that is a freely available compositional performance analysis tool similar to symta / s .",
    "the actual wcrt , which is denoted as optimal , was obtained by an ilp - based approach [ kim et al .",
    "2012 ]    .",
    "the proposed hpa technique is available on - line [ choi et al .",
    "2014 ]    .",
    "table [ tbl : table1 ] shows the comparison results for the examples shown in this paper .",
    "as discussed in section [ sec : yw_review ] , the y&w method fails to find the wcrt for the examples of fig .",
    "[ fig : ex_underestimation1 ] and fig .",
    "[ fig : ex_underestimation2 ] .",
    "mast gives tight wcrt results for linear graphs , but no result for fig .",
    "[ fig : ex_overestimation2 ] and fig .",
    "[ fig : ex_redundant ] since it supports only chain - structured graphs , and pycpa provides highly overestimated results for all examples , since it pessimistically uses response time analysis ignoring the task dependency between processing elements .",
    "note that the proposed hpa technique gives the optimal wcrt results for all these examples .    for extensive comparison ,",
    "we generate graphs randomly ; the number of task graphs varies from 3 to 5 , the number of total tasks from 30 to 50 , and the number of processing elements from 3 to 5 .",
    "the @xmath284 and @xmath285 of each task are randomly selected in the range of [ 500 , 1000 ] and [ @xmath284,@xmath286 respectively . the period and jitter of task graphs are randomly chosen but repaired to be schedulable if needed .",
    "note that the problem size is too big to find optimal wcrts with an ilp - based approach .",
    "table [ tbl : table2 ] shows the comparison results with the y&w method and pycpa . for the comparison with the y&w method",
    ", we assume that all processing elements use the preemptive scheduling policy , and there is no jitter of input arrival .",
    "since tasks may have multiple predecessors or successors , mast is excluded in this comparison .",
    "the total number of task graphs is 394 in 100 randomly generated examples .",
    "the first column shows how many cases the hpa technique produces a tighter bound than the other methods .",
    "similarly , the second and the third columns show how many cases hpa technique produces an equivalent bound and a looser bound .",
    "columns max , min , and avg indicate the maximum , minimum , and average wcrt estimation gaps between hpa and the other approaches .",
    "hpa gives tighter bounds than the y&w method for almost half of task graphs .",
    "a looser bound than the y&w method was found for one task graph only with very small estimation gap , 0.69% .",
    "pycpa provides highly overestimated wcrt results for all task graphs , which are on average 2.57 times larger than the results of hpa .    for the comparison with mast",
    ", we create another 100 random examples that are restricted to chain - structured graphs .",
    "in contrast to the previous experiment , random examples can have arbitrary mixture of preemptive and non - preemptive processing elements , and the jitter of input arrival is allowed .",
    "the number of total task graphs is 407 .",
    "as shown in table [ tbl : table3 ] , hpa shows remarkable performance advantage over the other methods .",
    "hpa provides tighter bounds than mast and pycpa in most cases .",
    "experiments are futher conducted to examine how the performance of the proposed hpa technique scales as the number of tasks , the number of graphs , and the execution time variation increases , compared with the other methods .",
    "the results are depicted in fig .",
    "[ fig : exp_taskvariation ] , [ fig : exp_graphvariation ] , and [ fig : exp_execvariation ] , respectively . in these experiments ,",
    "the default ranges of the number of processing elements , the number of task graphs , and the number of total tasks are set to [ 5,10 ] , [ 5,7 ] , and [ 30,50 ] respectively .",
    "for the left graphs in three figures , random examples are generated to have no jitter and only preemptive processing elements to compare with the y&w method and pycpa .",
    "for the right graphs , the task graphs in random examples are restricted to chain - structed graph but non - preemptive processing elements are allowed to compare with mast and pycpa .",
    "for all graphs in three figures , right y axis indicates the average wcrt estimation gap between hpa and pycpa . for left(right )",
    "graphs , left y axis indicates the average wcrt estimation gap between hpa and the y&w method(mast ) . for each data point , the average value is obtained from 100 random examples .",
    "[ fig : exp_taskvariation ] shows the change of estimation gap while varing the number of total tasks from 10 to 100 .",
    "the estimation gap increases by the number of total tasks .",
    "for the right graph that uses chain - structed graph , the estimation gap is increased linearly , which confirms that hpa handles the effect of dependency effectively .",
    "[ fig : exp_graphvariation ] shows the result of experiment that varies the number of task graph from 2 to 10 while fixing the number of total tasks to 100 . in this experiment ,",
    "the estimation gap decreases .",
    "it is because that as the task dependency decreases as well , the inter - application interference considered by the rta analysis becomes dominant over intra - application interference that is computed by the schedule time bound analysis .",
    "ratio , width=521 ]    the performance variation over the @xmath287 ratio from 1 to 10 is shown in fig .",
    "[ fig : exp_execvariation ] .",
    "the figure shows that the execution time variation does not incurs any meaningful change in the performance gap .",
    "[ fig : exp_distribution ] shows the distribution of the estimated wcrts from hpa with 300 randomly generated examples that have arbitrary mixture of preemptive and non - preemptive scheduling policies and no restriction on the graph topology .",
    "[ fig : exp_distribution ] ( a ) shows the distribution with small size examples and fig .",
    "[ fig : exp_distribution ] ( b ) with large size examples . for small(large ) size examples , the ranges of the number of processing elements ,",
    "the number of task graphs , and the number of total tasks are set to [ 2,3]([5,10 ] ) , [ 1,3]([5,7 ] ) , and [ 10,15](60,100 ) , respectively .",
    "we also performed monte - carlo simulation to obtain the wcrt empirically by sampling graph instances 200 million times for each example .",
    "optimal wcrts are found with an ilp - based approach only for small size examples .",
    "[ fig : exp_distribution ] ( a ) depicts the distribution of the wcrts obtained from monte - carlo simulation and hpa , normalized by optimal wcrts .",
    "the x axis indicates the normalized value ( % ) and the y axis presents the number of examples . note that both monte - carlo simulation and hpa provide results close to the actual wcrt in majority cases .",
    "but monte - carlo simulation may not find the true wcrt despite 200 million times of simulation , which confirms the need of conservative estimation techniques . for large size examples ,",
    "the distribution results from hpa are normalized by the near - wcrts obtained from monte - carlo simulation in fig .",
    "[ fig : exp_distribution ] ( b ) since optimal wcrts can not be obtained .",
    "since monte - carlo simulation gives underestimated wcrts , the amount of overestimation might be quite exaggerated .",
    "it shows that the estimated wcrt from hpa may have about 100% overestimation on average .",
    "finally , we measure the running time of hpa on 3.4 ghz i7 machine with 8 gb main memory and the iteration number of convergence to verify the scalability of the proposed technique .",
    "we vary the number of total tasks from 10 to 150 and use 100 randomly generated examples for each number of total tasks .",
    "the average values are plotted in fig .",
    "[ fig : exp_performance ] , where the left y - axis and the right y - axis indicate the running time of hpa and y&w in micro seconds , respectively .",
    "the numbers labeled to the graph of the hpa indicate the average numbers of iterations for convergence .",
    "every example was converged within maximum 20 iterations .",
    "although hpa is slower than the y&w method by an order of magnitude , both methods show similar scalability as shown in fig .",
    "[ fig : exp_performance ] .",
    "in this paper , we addressed a very challenging problem that is to tightly estimate the worst case response time of an application in a distributed embedded system .",
    "it is shown that a state - of - the - art technique , y&w method , fails to find a conservative wcrt bound .",
    "thus we propose a hybrid performance analysis ( hpa ) method that combines the scheduling time bound analysis and the response time analysis to consider inter - task interference between different tasks .",
    "it finds a conservative and tight wcrt bound , considering task dependency , execution time variation , arbitrary mixture of fixed - priority preemptive and non - preemptive processing elements , and input jitters .",
    "experimental results show that it produces tighter bounds than the y&w method , mast , and pycpa .",
    "convergence and scalability of the proposed technique are confirmed empirically .",
    "since it is an iterative technique with tens of non - linear formulas , it is a very difficult problem to prove the convergence formally , which is left as a future work .",
    "00 aske brekling , michael r. hansen , and jan madsen . 2008 . models and formal verification of multiprocessor system - on - chips .",
    "_ j. logic algebraic program .",
    "_ 77(1 - 2 ) .",
    "jinwoo kim , hyunok oh , hyojin ha , shin - haeng kang , junchul choi , and soonhoi ha .",
    "an ilp - based worst - case performance analysis technique for distributed real - time embedded systems .",
    "_ proceedings of the 2012 ieee 33rd real - time systems symposium(rtss12)_. 363 - 372 .",
    "ti - yen yen and wayne wolf . 1998 .",
    "performance estimation for real - time distributed embedded systems . _",
    "parallel and distributed systems , ieee transactions on_. 9(11 ) . 11251136 .",
    "john lehoczky , lui sha , and ye ding . 1989 .",
    "the rate monotonic scheduling algorithm : exact characterization and average case behavior .",
    "_ proceedings of 1989 ieee real - time systems symposium_. 166 - 171 .",
    "jinwoo kim , hyunok oh , junchul choi , hyojin ha , and soonhoi ha .",
    "a novel analytical method for worst case response time estimation of distributed embedded systems .",
    "_ proceedings of the the 50th annual design automation conference on design automation conference(dac13)_. 1 - 10 .",
    "john lehoczky .",
    "fixed priority scheduling of periodic task sets with arbitrary deadlines .",
    "_ proceedings of 11th ieee real - time systems symposium(rtss90)_. 201 - 209 .",
    "neil audsley , alan burns , ken tindell , m. richardson and andrew j. wellings . 1993 .",
    "applying new scheduling theory to static priority pre - emptive scheduling . _ software engineering journal_. 8(5 ) .",
    "284 - 292 .",
    "ken tindell and john clark .",
    "holistic schedulability analysis for distributed hard real - time systems .",
    "_ microprocessing and microprogramming - parallel processing in embedded real - time systems_. 40(2 - 3 ) .",
    "117 - 134 .",
    "jos carlos palencia and medina gonzlez harbour .",
    "1998 . schedulability analysis for tasks with static and dynamic offsets .",
    "_ proceedings of the 1998 ieee 19th real - time systems symposium(rtss98)_. 26 - 37 .",
    "ken tindell , alan burns , and andrew j. wellings .",
    "analysis of hard real - time communications .",
    "_ real - time systems_. 9(2 ) .",
    "147 - 171 .",
    "simon schliecker and rolf ernst .",
    "real - time performance analysis of multiprocessor systems with shared memory .",
    "_ acm transactions on embedded computing systems_. 10(2 ) .",
    "rodolfo pellizzoni and giuseppe lipari . 2007 .",
    "holistic analysis of asynchronous real - time transactions with earliest deadline scheduling .",
    "_ journal of computer and system sciences_. 73(2 ) .",
    "186 - 206 .",
    "ti - yen yen and wayne wolf . 1995 . communication synthesis for distributed embedded system .",
    "_ proceedings of ieee / acm international conference on computer - aided design(iccad95)_. 288 - 294 .",
    "paul pop , petru eles , and zebo peng .",
    "schedulability analysis for systems with data and control dependencies .",
    "_ proceedings of the 12th euromicro conference on real - time systems(ecrts00)_. 201 - 208 .",
    "rafik henia , arne hamann , marek jersak , razvan racu , kai richter , and rolf ernst .",
    "2005 . system level performance analysis - the symta / s approach .",
    "_ iee proceedings - computers and digital techniques_. 152(2 ) .",
    "148 - 166 .",
    "michael gonzlez harbour .",
    "2001 . mast suite .",
    "retrieved from http://mast.unican.es/ jonas diemer and philip axer .",
    "python implementation of compositional performance analysis .",
    "retrieved from http://pycpa.readthedocs.org/en/latest/ junchul choi , hyunok oh , and soonhoi ha .",
    "swat : a suite of worst case response time analysis tools for distributed hard real - time systems .",
    "retrivable from http://iris.snu.ac.kr/xe/swat    [ section ]",
    "we prove that the optimization technique of duplicate preemption elimination preserves the conservativeness of the hpa technique .",
    "it is a rather long proof .",
    "we will make several definitions , lemmas , and theorems in this section .",
    "[ theorem4_2 ] @xmath288 $ ] is defined as the sum of execution time of tasks of which priority is higher than @xmath61 from time @xmath289 to time @xmath290 .",
    "@xmath291 = \\sum_{{\\tau_{s}}\\in{s_{pe({\\tau_{t}})[x , y]}}}{\\min(y,{\\tau_{s}^{finish}})-\\max(x,{\\tau_{s}^{start}})}\\ ] ] where @xmath292}=\\{{\\tau_{s}}|{\\tau_{s}^{pri}}>{\\tau_{t}^{pri } } , ( x \\le { \\tau_{s}^{start}}<y ~or~ x < { \\tau_{s}^{finish } } \\le y)\\}$ ] for preemptive scheduling and @xmath292}=\\{{\\tau_{s}}|({\\tau_{s}^{pri}}>{\\tau_{t}^{pri } } ~or~ { \\tau_{s}^{start } } < { \\tau_{t}^{start } } ) , ( x \\le { \\tau_{s}^{start}}<y ~or~ x < { \\tau_{s}^{finish } } \\le y)\\}$ ] for nonpreemptive scheduling",
    ".            we prove it by contradiction .",
    "suppose that @xmath64 exists such that @xmath297 $ ] where @xmath295 .",
    "it is obvious that @xmath298 $ ] and @xmath299 $ ] , by definition [ theorem4_2 ] .",
    "@xmath300\\ ] ] @xmath301 - \\delta + pe({\\tau_{t}})[{\\tau_{t}^{maxr}}-\\delta,{\\tau_{t}^{maxr}}]\\ ] ] @xmath302.\\ ] ] thus , @xmath303 > { \\tau_{t}^{maxr } } + { \\tau_{t}^{wcet } } - \\delta + pe({\\tau_{t}})[{\\tau_{t}^{maxr}}-\\delta,{\\tau_{t}^{maxf}}].\\ ] ] @xmath304 + pe({\\tau_{t}})[{\\tau_{t}^{maxr}}-\\delta,{\\tau_{t}^{finish}}]\\ ] ] @xmath305.\\ ] ]    @xmath306 > { \\tau_{t}^{maxr } } - \\delta $ ] since @xmath307 \\ge pe({\\tau_{t}})[{\\tau_{t}^{maxr}}-\\delta,{\\tau_{t}^{finish}}]$ ] .",
    "+ @xmath308 \\le { \\tau_{t}^{maxr } } -\\delta$ ] since @xmath309 \\le { \\tau_{t}^{maxr}}-\\delta - { \\tau_{t}^{release}}$ ] . + it is a contradiction .",
    "hence @xmath296 $ ] .",
    ".    theorem  [ theorem4_5 ] explains how much the maximum finish time can be reduced if the maximum release time decreases .",
    "since the release time depends on the finish times of predecessor tasks , the theorem presents the effect of the finish time of predecessor tasks onto the finish time of the target task .",
    "this theorem will be generalized later in theorem  [ theorem4_12 ] .",
    "now we will examine the effect of the early finish time of an ancestor task to the finish time of the target task . in theorem  [ theorem4_5",
    "] , we examine the relation between the release time and the finish time which also explains the finish times between predecessor tasks and the target task .",
    "we will extend it to the effect between an ancestor task and the target task .",
    "if we apply theorem  [ theorem4_5 ] repeatedly , we can compute how much the maximum finish time reduction is inherited from an ancestor task to the target task .",
    "theorem  [ theorem4_12 ] tells us that the contribution of the maximum finish time reduction of an ancestor task diminishes as it propagates to the child tasks . to utilize theorem  [ theorem4_12 ]",
    ", we define the new reduced finish time @xmath342 by reducing the finish time of a task @xmath343 by @xmath344 as following :            [ theorem4_15 ] if a common preemptor @xmath356 can preempt ancestor task @xmath353 and target task @xmath354 completely , then always it produces no smaller finish time of @xmath354 when @xmath356 preempts @xmath354 than @xmath353 .",
    "the reduced maximum finish time of @xmath354 is @xmath357 when @xmath356 does not preempt @xmath353 but preempts @xmath354 .",
    "it is @xmath358 when @xmath356 does not preempt @xmath354 but preempts @xmath353 . since @xmath353 is an ancestor of @xmath354 , @xmath359 .",
    "hence , it produces no smaller finish time to preempt @xmath354 than @xmath353 . q.e.d .",
    "let us consider a case that a preemption task @xmath356 can preempt @xmath353 and @xmath354 , but @xmath354 partially . even in this case",
    ", @xmath356 can always preempt @xmath353 fully since @xmath360 .",
    "then we may need to compare @xmath357 with @xmath361 where @xmath362 indicates the maximum partial preemption time of @xmath354 by @xmath356 . even in this case , surprisingly , preempting @xmath354 always provides larger finish time than the partial preemption case , which is stated by theorem  [ theorem4_16 ] .",
    "[ theorem4_16 ] if a common preemptor @xmath356 can preempt an ancestor task @xmath353 fully and the target task @xmath354 partially , it always produces no smaller finish time bound of @xmath354 when @xmath356 preempts @xmath354 rather than @xmath353 .      1 .",
    "if @xmath356 preempts @xmath353 then @xmath354 finishes earlier than @xmath365 .",
    "2 .   if @xmath356 preempts @xmath354 then assume that @xmath366 . then @xmath367",
    ". 1 .   if @xmath368 then @xmath369 , and @xmath370 .",
    "[ theorem4_16_1 ] 2 .   if @xmath371 then @xmath372 .",
    "since @xmath373 by theorem  [ theorem4_12 ] , @xmath374 .",
    "[ theorem4_16_2 ]      now , we consider multiple ancestor tasks which have multiple common preemption tasks .",
    "we define a unique common preemptor set , @xmath375 , to indicate the closest ancestor with the common preemption task as following",
    ".      then multiple ancestors may have different common preemption tasks . to consider the cascaded scheduling effect as a whole , we redefine @xmath347 .",
    "we introduce @xmath377 which denotes the reduced time by moving common preemption tasks from @xmath353 to @xmath354 .",
    "@xmath377 is statically computed .",
    "@xmath347 indicates a variable used in definition  [ theorem4_13 ] .",
    "the finish time of @xmath378 is contributed by the early finish time of ancestor tasks of @xmath378 and @xmath379 .",
    "the total @xmath380 is defined as following :      finally , we define @xmath383 which indicates the occupied time from @xmath384 to @xmath385 . although @xmath383 shows the exact time , it is varying at run time .",
    "therefore , we need to compute its bound .",
    "although we use its bound , the previous theorems hold .",
    "since @xmath386)$ ] where @xmath387 = \\sum_{\\tau_s^{pri } > \\tau_t^{pri } , \\tau_s^{maxf } \\ge x , \\tau_s^{mins } \\le y}{\\min(\\tau_s^{wcet } , y-\\tau_s^{mins } , \\tau_s^{maxf } - x)}$ ] , @xmath388)$ ] is used as the bound of @xmath383 .        by replacing variables in definition  [ theorem4_13 ] by definitions  [ theorem4_18 ] and  [ theorem4_19 ]",
    ", we can compute the tighter time bound with moving the common preemption tasks from the ancestors .",
    "the conservativeness is guaranteed by theorems [ theorem4_15 ] and [ theorem4_16 ] since preempting @xmath61 rather than ancestor @xmath343 produces a larger time bound . the difference between",
    "the proof and the actual technique is that _ duplicate preemption elimination _",
    "technique traverses only the critical path , not all ancestors . even though common preemptions of the ancestors not in the critical path remain , our technique is still conservative . q.e.d ."
  ],
  "abstract_text": [
    "<S> it remains a challenging problem to tightly estimate the worst case response time of an application in a distributed embedded system , especially when there are dependencies between tasks . </S>",
    "<S> we discovered that the state - of - the art techniques considering task dependencies either fail to obtain a conservative bound or produce a loose upper bound . </S>",
    "<S> we propose a novel conservative performance analysis , called hybrid performance analysis , combining the response time analysis technique and the scheduling time bound analysis technique to compute a tighter bound fast . through extensive experiments with randomly generated graphs , superior performance of our proposed approach </S>",
    "<S> compared with previous methods is confirmed .    </S>",
    "<S> author s addresses : j. choi , department of computer science and engineering , seoul national university ; h. oh , department of information systems , hanyang university ; s. ha , department of computer science and engineering , seoul national university . </S>"
  ]
}