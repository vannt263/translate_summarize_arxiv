{
  "article_text": [
    "let @xmath6 be an undirected graph , in which @xmath7 is a positive edge length function . for @xmath8 ,",
    "an @xmath3-path is a simple path from @xmath1 to @xmath2 , in which `` simple '' means there is no repeated vertex in the path . in this paper , a path always means a simple path .",
    "the length of a path is the total length of all edges in the path .",
    "an @xmath3-path is a shortest @xmath3-path if its length is minimum amongst all possible @xmath3-paths .",
    "the shortest path length from @xmath1 to @xmath2 is denoted by @xmath9 which is the length of their shortest path .",
    "next - to - shortest _",
    "@xmath3-path is an @xmath3-path which length is minimum amongst those the path lengths _ strictly larger _ than @xmath9 . and the next - to - shortest path problem is to find a next - to - shortest @xmath3-path for given @xmath10 , @xmath1 and @xmath2 .",
    "while the shortest path problem has been widely studied and efficient algorithms have been proposed , the next - to - shortest path problem attracts researchers just in the last decade .",
    "the problem was first studied by lalgudi and papaefthymiou in the directed version with no restriction to positive edge weight @xcite .",
    "they showed that the problem is intractable for path and can be efficiently solved for walk ( allowing repeated vertices ) .",
    "algorithms for the problem on special graphs were also studied @xcite .",
    "the first polynomial algorithm for undirected positive version , i.e. , the next - to - shortest path defined in this paper , was developed by krasikov and noble , and their algorithm takes @xmath11 time @xcite , in which @xmath12 and @xmath13 are the number of vertices and edges , respectively .",
    "the time complexity was then reduced to @xmath14 by li et al .",
    "recently , kao et al . further improved the time complexity to @xmath15 @xcite . in this paper , we show that the problem can be solved in linear time if the distances from @xmath1 and @xmath2 to all other vertices are given .",
    "let @xmath16 be the union of all shortest @xmath3-paths .",
    "for convenience let @xmath17 be the digraph obtained from @xmath16 by orientating all edges toward @xmath2 .",
    "apparently @xmath1 and @xmath2 are in @xmath18 and , for any @xmath19 , any ( directed ) @xmath20-path in @xmath17 is a shortest @xmath20-path ( undirected ) in @xmath10 .",
    "an outward subpath of an @xmath3-path is a path consisting of edges in @xmath21 and the both endpoints are in @xmath22 ; and a backward subpath is a maximal subpath using edges in @xmath23 but with reverse direction . since a next - to - shortest path either contains an edge in @xmath21 or not , we divide the problem into two subproblems , and the better of the solutions of the two subproblems is the optimal path .",
    "the first subproblem looks for a shortest path using at least one edge not in @xmath24 , and the second subproblem looks for a shortest path consisting of only edges in @xmath24 but with length larger than @xmath9 . following the previous names in @xcite , we name the optimal paths of the first and the second subproblems as `` optimal outward path '' ( optimal path with an outward subpath ) and `` optimal backward path '' ( optimal path with a backward subpath ) , respectively .",
    "since any @xmath3-path in @xmath17 has length @xmath9 , the optimal backward path uses at least one edge with reverse direction . by the optimality",
    "the following result was shown in @xcite and it is the basis of the algorithms in the previous and this papers .",
    "[ c1 ] the optimal outward path contains exactly one outward subpath and no backward subpath .",
    "the optimal backward path contains exactly one backward subpath .",
    "the reason for the two observations is the same : if there are two non - consecutive backward or outward subpaths , we can replace one of them with a subpath in @xmath17 to obtain a better one . due to @xcite",
    ", the optimal outward path subproblem can be solved in @xmath25 time .",
    "but , for the optimal backward subproblem , they only gave an @xmath15 time algorithm .",
    "the contribution of this paper is as follows .",
    "* we give an @xmath25 time algorithm for the optimal backward subproblem , which also reduces the total time complexity of the whole algorithm for sparse graphs . *",
    "we give an algorithm for finding an optimal outward path .",
    "the time complexity is the same as kao s algorithm for general graphs but the new algorithm is simpler and avoids the sorting step in kao s algorithm .",
    "* more precisely , if the distances from @xmath1 and @xmath2 to all other vertices are given , both our new algorithms take only linear time .",
    "that is , for graphs on which the _ single source shortest paths _",
    "( sssp ) problem can be solved in @xmath26 time , the next - to - shortest path problem can be solved in @xmath27 time . consequently the next - to - shortest path problem can be solved in linear time for undirected unweighted graph , for undirected planar graph with positive edge weights , and for undirected graph with positive integral edge weights .",
    "the remaining sections are organized as follows .",
    "we introduce notations and derive some basic properties in section 2 . the algorithm for the optimal backward path",
    "is shown in section 3 , and in section 4 , we give a simpler algorithm for the outward path problem .",
    "finally concluding remarks are given in section 5 .",
    "throughout this paper , we shall assume that @xmath28 is the instance of the problem , in which @xmath6 is the input graph with vertex set @xmath29 , edge set @xmath30 and edge length @xmath7 .",
    "@xmath1 and @xmath2 are two vertices in @xmath29 .",
    "the graph @xmath10 is simple , connected and undirected , and the edge lengths are all positive",
    ". we shall use @xmath31 and @xmath32 .    for a graph @xmath33 , @xmath34 and",
    "@xmath35 denote the vertex and edge sets , respectively . for two vertices @xmath36 and @xmath37 on a path @xmath38 , let @xmath39 $ ] denote the subpath from @xmath36 to @xmath37 and @xmath40 denote the length of the path .",
    "let @xmath41 denote the shortest path length from @xmath36 to @xmath37 in @xmath10 , which is also called as the distance from @xmath36 to @xmath37 . for convenience ,",
    "let @xmath42 and @xmath43 .    to show the time complexities",
    "more precisely , we shall assume the distances from @xmath1 and @xmath2 to all other vertices are given .",
    "these distances can be found by solving the single source shortest paths ( sssp ) problem . for general undirected and positive weight graphs ( the most general setting of the problem discussed in this paper ) , the sssp problem can be solved in @xmath25 time @xcite , and more efficient algorithms exist for special graphs or graphs with restrictions on edge lengths .",
    "as defined in the introduction , let @xmath16 be the union of all shortest @xmath3-paths and @xmath17 is obtained from @xmath16 by orientating all edges toward @xmath2 . constructing @xmath16 and @xmath17 can be done in linear time as follows .",
    "a vertex @xmath44 is in @xmath22 iff @xmath45 , and , for both @xmath46 and @xmath44 in @xmath22 , a directed edge @xmath47 iff @xmath48 .",
    "similarly a shortest path tree rooted at @xmath1 can also be constructed in linear time if the distances from @xmath1 to all others are given .    since all edge lengths are positive , @xmath17 is a directed acyclic graph ( dag ) and we may use the terms such as parent , child , ancestor and descendant as in a rooted tree . also , for convenience , we abuse the notation @xmath41 for the distance from @xmath36 to @xmath37 in @xmath16 and @xmath17 as long as @xmath36 is an ancestor of @xmath37 .",
    "we shall use _ immediate dominators _ in our algorithm .",
    "a vertex @xmath49 is an @xmath1-dominator of another vertex @xmath36 iff all paths from @xmath1 to @xmath36 contain @xmath44 .",
    "an @xmath1-dominator @xmath44 is an @xmath1-immediate - dominator of @xmath36 , denoted by @xmath50 , if it is the one closest to @xmath36 , i.e. , any other @xmath1-dominator of @xmath36 is an @xmath1-dominator of @xmath44 .",
    "we remind that , for any vertex @xmath51 , there exist a path from @xmath1 to @xmath36 and also a path from @xmath36 to @xmath2 .",
    "apparently any vertex has a unique @xmath1-immediate - dominator and all @xmath1-dominators , as well as the @xmath1-immediate - dominator , are ancestors of the vertex .",
    "similarly we define the @xmath2-dominator , i.e. , @xmath44 is a @xmath2-dominator of @xmath36 iff any @xmath52-path contains @xmath44 , and @xmath53 is the @xmath2-dominator closest to @xmath36 .",
    "note that @xmath1 is an @xmath1-dominator and @xmath2 is a @xmath2-dominator for any other vertex in @xmath22 .",
    "finding immediate dominator is one of the most fundamental problems in the area of global flow analysis and program optimization .",
    "the first algorithm for the problem was proposed in 1969 , and then had been improved several times . a linear time algorithm for finding the immediate dominator for each vertex",
    "was given in @xcite .",
    "we define a binary relation on @xmath18 : @xmath54 iff @xmath36 is an ancestor of @xmath37 . in our definition ,",
    "a vertex is not an ancestor of itself . also define @xmath55 iff @xmath36 is an ancestor of @xmath37 or @xmath56 .",
    "we derive some properties used in this paper .",
    "[ idom1 ] for any vertices @xmath36 and @xmath37 in @xmath17 and @xmath57 , either @xmath58 or @xmath59 . similarly either @xmath60 or @xmath61 .",
    "we show the first statement and the second statement is similar .",
    "if neither of the two conditions holds , there is an @xmath62-path passing through @xmath37 and avoiding @xmath50 , which contradicts the definition of dominator .",
    "the following corollary comes from lemma  [ idom1 ] .",
    "[ idom2 ] if @xmath57 and @xmath63 , then @xmath64 .",
    "similarly , if @xmath57 and @xmath65 , then @xmath61 .",
    "in this section we show an efficient algorithm for finding an optimal backward path . for this problem , only vertices and edges in @xmath17 need considering and any vertex is assumed in @xmath17 in this section . since the numbers of vertices and edges of @xmath17 are also bounded by @xmath12 and @xmath13 respectively , we shall neither distinguish @xmath66 and @xmath67 , nor @xmath68 and @xmath69 .      by the previous result shown in the introduction",
    ", an optimal backward path has the form @xmath70 , in which `` @xmath71 '' means concatenation , @xmath72 are paths in @xmath17 and @xmath73 means the reverse path of @xmath74 . since the optimal path is required to be simple , the three subpaths must be simple and internally disjoint , in which two paths are internally disjoint if they have no common vertex except for their endpoints .",
    "therefore our goal is to find @xmath75 minimizing @xmath76 subject to that there are an @xmath62-path , a @xmath77-path and a @xmath78-path in @xmath17 which are mutually internally disjoint . if @xmath36 and @xmath37 satisfy the constraint , we say @xmath79 is valid .",
    "since all paths in @xmath17 are shortest , we have @xmath80 and @xmath81 , and the objective function can be simplified to @xmath82 and also equivalent to @xmath41 since @xmath9 is independent on @xmath36 and @xmath37 .    for any vertex @xmath36 ,",
    "let @xmath83 .",
    "the vertices in @xmath84 form a closed region in the sense that no path can enter this region without passing through @xmath50 , and it is easy to see that , for any vertex @xmath85 , @xmath86 iff @xmath36 has only one parent .",
    "the most important thing is that , as shown later , the vertices which are valid for @xmath36 must be in @xmath84 .",
    "[ hier ] for any @xmath87 , @xmath88 .",
    "since @xmath64 , we have @xmath88 or @xmath89 by lemma  [ idom1 ] . by the definition of @xmath50 ,",
    "the in - neighbors of @xmath84 are contained in @xmath90 .",
    "therefore it is impossible that @xmath89 .",
    "[ close ] if @xmath87 , there are two internally disjoint paths from @xmath50 , and @xmath37 respectively , to @xmath36 .",
    "let @xmath91 . by the definition of immediate dominator ,",
    "no vertex in @xmath84 is a @xmath92-cut and therefore there are two internally disjoint @xmath92-paths , said @xmath93 and @xmath94 .",
    "if @xmath37 is on one of them , we have done .",
    "otherwise , let @xmath95 be any @xmath77-path and @xmath96 be the first vertex on @xmath95 and also in @xmath97 .",
    "w.l.o.g . let @xmath98 .",
    "then , the path @xmath99\\circ p_1[q , x]$ ] is a @xmath77-path disjoint to @xmath94 .",
    "next we derive the objective function and its constraints .",
    "[ cand ] if the pair @xmath79 is valid , then @xmath87 and @xmath61 .    by definition , @xmath57 . by lemma  [ idom1 ] , either @xmath64 or @xmath100 .",
    "if @xmath100 , by the definition of immediate dominator , any @xmath62-path and @xmath77-path contain @xmath50 simultaneously and can not be disjoint .",
    "therefore we have @xmath64 .",
    "the relation @xmath61 can be shown similarly .",
    "define @xmath101 and let @xmath102 .",
    "[ suff ] if @xmath103 and @xmath104 , then @xmath105 is valid .    by lemma  [ close ] , since @xmath106 , there are two disjoint paths from @xmath50 , and @xmath107 respectively , to @xmath36 .",
    "therefore we have a simple path , said @xmath93 , from @xmath1 , passing through @xmath50 to @xmath36 , and then from @xmath36 to @xmath107 by backward edges .",
    "since @xmath108 , there must be a path , said @xmath94 , from @xmath107 to @xmath2 and avoiding @xmath36 .",
    "we shall show that @xmath93 and @xmath94 are disjoint , which completes the proof .",
    "suppose to the contrary that @xmath109 is the last common vertex of @xmath93 and @xmath94 , i.e. , any other common vertex precedes @xmath110 in @xmath94 ( figure  [ backfig].(a ) ) .",
    "since @xmath111 , we have @xmath112 , and @xmath113 because @xmath114 .",
    "so , we have @xmath115 . since @xmath116 $ ] is a path avoiding @xmath36 and @xmath117",
    ", we have @xmath118 .",
    "therefore @xmath119 and @xmath120 since @xmath107 is an ancestor of @xmath110 , a contradiction to the optimality of @xmath107 .",
    "that is , @xmath93 and @xmath94 must be disjoint .",
    "the proof of lemma  [ suff ] is constructive , and it implies an algorithm for finding a corresponding backward path for given @xmath36 and @xmath107 . furthermore the time complexity is apparently linear . for the simplicity , in the following , we only focus on finding the length of the optimal backward path . by lemmas  [ cand ] and [ suff ] ,",
    "our goal is to find @xmath36 and @xmath37 minimizing @xmath121 , i.e. , @xmath122 or , by corollary  [ idom2 ] , it can be also written as @xmath123 the convenience of the latter form is that we can easily determine the ancestor relation by simply comparing their @xmath124 values .",
    "the above formula provides us a way to find the optimal backward path : for each vertex @xmath36 , checking each vertex @xmath87 .",
    "but the naive method takes at least @xmath125 time in worst case since @xmath126 may be linear in @xmath12 .",
    "we say `` the pair @xmath79 is feasible '' or `` @xmath37 is feasible for @xmath36 '' if @xmath127 .",
    "we also say `` @xmath36 is feasible '' if there exists @xmath37 which is feasible for @xmath36 .",
    "note that a feasible @xmath79 may be not valid .",
    "however , our algorithm find the @xmath79 minimizing function @xmath121 , and by lemma  [ suff ] it must be valid .    let @xmath128 be the set of parents of @xmath36 .",
    "our algorithm basically finds @xmath129 for each @xmath36 according to the following formula : @xmath130 and @xmath131 .",
    "we denote by @xmath132 the set of all the feasible vertices , i.e. , @xmath133    to make the algorithm efficient , we derive some properties to avoid non - necessary searches .",
    "[ fp ] if @xmath57 and @xmath134 , then @xmath135 for any @xmath136 .    if @xmath100 , @xmath137 and the result holds since @xmath134 .",
    "we only need to consider the remaining case that @xmath64 .",
    "let @xmath136 and @xmath138 . by definition , @xmath139 and @xmath140 .",
    "since @xmath87 , by lemma  [ hier ] , @xmath88 .",
    "if @xmath141 , @xmath46 is also feasible for @xmath37 and @xmath142 .",
    "otherwise @xmath143 .",
    "since @xmath134 , by definition @xmath144 .",
    "[ nfp ] if @xmath57 and @xmath145 , then @xmath146 for any @xmath147 .",
    "since @xmath145 , for any vertex @xmath147 , i.e. , @xmath148 , we have @xmath149 . since @xmath57 , @xmath150 and @xmath46 can not be feasible for @xmath36 .",
    "[ desf ] let @xmath151 and @xmath152 be two descendants of @xmath37 and @xmath153 .",
    "if @xmath154 , @xmath155 .",
    "if there exists @xmath46 such that @xmath156 and @xmath157 , then @xmath158 . since @xmath46 is also an ancestor of @xmath151 , @xmath159 by corollary  [ idom2 ] .",
    "therefore @xmath160 . for",
    "otherwise there is no such @xmath46 , and we have @xmath161 .    [ black ]",
    "let @xmath151 and @xmath152 be two vertices and @xmath153 . if @xmath162 and @xmath151 is not an ancestor of @xmath152 , then @xmath154 and @xmath155 .    since @xmath162",
    ", @xmath37 is a common ancestor of @xmath151 and @xmath152 .",
    "let @xmath163 be a lowest common ancestor of them and @xmath164 . since @xmath151 is not an ancestor of @xmath152 , we have @xmath165 and there is a path from @xmath163 to @xmath152 avoiding @xmath151 . by definition @xmath166 and @xmath154 ( figure  [ backfig].(b ) ) .",
    "the inequality follows directly from lemma  [ desf ] .",
    "our algorithm for the optimal backward path is as follows .",
    "= = = = = + * algorithm * bk_n2sp + * input : * the digraph @xmath17 . + * output : * the length of the optimal backward path . +",
    "* 1:*find a topological order of @xmath17 and label the vertices such that + if @xmath167 , @xmath168 ; + * 2:*find @xmath169 and @xmath170 for each @xmath44 ; + * 3:*@xmath171 ; + @xmath172 , @xmath173 ; + @xmath174 ; + * 4:*for @xmath175 to @xmath176 do + * 5:*for each parent @xmath110 of @xmath152 do + * 6:*@xmath177 ; + * 7:*while @xmath178 and @xmath179 and @xmath180 do + * 8:*@xmath181 ; @xmath182 ; + * 9:*if @xmath183 then + * 10:*@xmath184 ; + @xmath185 ; @xmath181 ; + * 11:*end for next parent ; + * 12:*end for next @xmath186 ; + * 13:*output @xmath187 +    in the algorithm , each vertex @xmath44 is associated with a color , which is white initially and may be set to black as the algorithm runs .",
    "the algorithm begins with a preprocessing stage at steps 13 .",
    "we first arrange the vertices according to a topological order in @xmath17 .",
    "note that @xmath188 and @xmath189 .",
    "then we find the @xmath1- and @xmath2-immediate dominators for each vertex .",
    "all vertices are assigned white color except that @xmath1 is colored black .",
    "the variable @xmath190 is used to keep the objective value of the best solution found so far .",
    "in the main loop from steps 4 to 12 , we deal with all the vertices one by one except for @xmath1 and @xmath2 . in the @xmath186-th iteration",
    ", we try to find any feasible @xmath191 for @xmath152 from each parent of @xmath152 ( steps 511 ) .",
    "we shall show the correctness of the algorithm by examining the feasibility and the optimality .",
    "the algorithm finds solutions only at step 10 .",
    "by lemma  [ suff ] , the final solution is feasible as long as its minimality can be ensured .",
    "apparently neither @xmath1 nor @xmath2 can be a feasible vertex . by eq .",
    "( [ allp ] ) what we need to show is that the solutions we skipped are really not better . by eq .",
    "( [ obj1 ] ) , we should check all @xmath191 for each @xmath152 .",
    "there are two kinds of solutions skipped by the algorithm .    * * type 1 : * the first kind of possible solutions ignored by the algorithm is at step 8 where we look for feasible solution @xmath192 for any @xmath193 but do not try all such @xmath37 .",
    "instead , we jump to @xmath194 after checking @xmath37 and skip the vertices in @xmath195 . if @xmath37 is feasible , by lemma  [ fp ]",
    ", we do not need to check @xmath196 for any ancestor @xmath46 of @xmath37 ; and if @xmath37 is not feasible , by lemma  [ nfp ] , ignoring @xmath197 for any @xmath147 does not affect the optimality . *",
    "* type 2 : * the second kind of skipped solutions is due to the conditions of the while - loop at step 7 .",
    "the while - loop stops when @xmath198 or @xmath183 or @xmath199 . except for the first condition , the loop may terminate before reaching @xmath200 . for the second condition ,",
    "if @xmath183 , the optimality is ensured by lemma  [ fp ] ; and we divide the third condition @xmath199 into two sub - cases according to when it turns black . * * if @xmath37 is colored black in this iteration , @xmath37 must have been checked at this iteration from another parent of @xmath152 .",
    "therefore , if there exists any ancestor of @xmath37 we need checking , it must have already been checked from that parent . *",
    "* otherwise @xmath37 is colored black before the @xmath186-th iteration , and this implies that @xmath201 for some @xmath202 or @xmath37 is feasible ( marked black at step 10 in the iteration checking @xmath37 with its ancestor ) . if @xmath37 is feasible , we can safely skip any ancestor of @xmath37 by lemma  [ fp ] . otherwise , if @xmath151 is not an ancestor of @xmath152 , we have that @xmath152 or @xmath151 must be feasible and @xmath203 by corollary  [ black ] .",
    "note that we still need to and do check @xmath192 at step 9 because @xmath204 may be smaller than @xmath205 .",
    "+ the remaining case is that @xmath206 and @xmath201 .",
    "let @xmath207 be the sequence of vertices checked at the while - loop .",
    "since @xmath208 for @xmath209 and @xmath210 , we have that @xmath151 does not appear in the sequence .",
    "hence , there exists @xmath211 which is in @xmath212 and has a path to @xmath152 avoiding @xmath151 .",
    "therefore @xmath151 is feasible , and then similar to corollary  [ black ] , it is not necessary to check any ancestor of @xmath37 for @xmath152 .    by the above explanation",
    ", we conclude the correctness of the algorithm .",
    "[ correct ] algorithm bk_n2sp computes the optimal backward path length correctly .      we show that the time complexity of our algorithm is @xmath213 . step 1 takes linear time for finding a topological order and step 2 takes @xmath214 time @xcite .",
    "step 3 takes @xmath215 time . the inner loop ( steps 610 )",
    "is entered @xmath214 times since the total number of parents of all vertices is bounded by the number of edges . since @xmath37 is always an ancestor of @xmath152 , the conditions `` @xmath178 '' and `` @xmath179 '' , as well as to compute @xmath192 , can all be done in constant time by checking the @xmath124 values . the remaining question is how many times step 8 is executed . by the condition of the while loop ,",
    "only white vertices will be colored black at step 8 , and therefore it is executed at most @xmath12 times in total .",
    "the algorithm assumes that @xmath17 is the input .",
    "it does not matter since @xmath17 can be constructed in linear time if the distances @xmath216 and @xmath217 are given for all @xmath44 .",
    "[ backtime ] the time complexity of the algorithm bk_n2sp is @xmath218 .    by lemmas  [ correct ] and [ backtime ]",
    ", we have the next result .",
    "[ thm : back ] the optimal backward path problem on undirected graphs with positive edge lengths can be solved in linear time if the distances from @xmath1 and @xmath2 to all the others are given .    for general undirected graph with positive edge weights ,",
    "the sssp problem can be solved in @xmath219 time by the dijkstra s algorithm using a fibonacci heap @xcite .",
    "therefore the next corollary directly comes from theorem  [ thm : back ] and the result of the outward path in @xcite .",
    "[ cor : back ] the next - to - shortest path problem on undirected graphs with positive edge lengths can be solved in @xmath219 time .",
    "in this section we show an efficient algorithm for finding an optimal outward path .",
    "as described in the introduction , an optimal outward path contains exactly one outward subpath and has no backward subpath , in which an outward subpath is a path @xmath38 such that @xmath220 and both endpoints of @xmath38 are in @xmath22 .",
    "an outward path must be strictly longer than a shortest path between its endpoints .",
    "otherwise it should be entirely in @xmath16 .",
    "therefore the length of an outward @xmath3-path must be strictly larger than @xmath9 .",
    "our goal is to find an minimum length @xmath3-path with an outward subpath .",
    "let @xmath221 be any shortest - path tree of @xmath10 rooted at @xmath1 and @xmath222 denote the graph obtained by removing edges in @xmath223 from @xmath221 .",
    "apparently @xmath224 is a forest consisting of subtrees of @xmath221 and @xmath225 . by the definition of @xmath16 , any shortest path between two vertices in @xmath16",
    "must be included in @xmath24 . for any @xmath226",
    ", the path from @xmath1 to @xmath44 on @xmath221 must be entirely within @xmath24 and therefore @xmath44 must be a root of a subtree of @xmath224 .",
    "furthermore , the root of any subtree of @xmath224 must be in @xmath22 because the edge between it and its parent is removed and we only remove edges between two vertices in @xmath22 .",
    "let @xmath227 denote the set of edges @xmath79 such that @xmath228 and @xmath36 and @xmath37 are in different subtrees of @xmath224 .",
    "we show the next lemma .",
    "[ out1 ] an optimal outward path @xmath38 contains one edge in @xmath227 .    by definition @xmath38",
    "contains an outward subpath .",
    "since the both endpoints of this outward subpath are in @xmath22 , they must be in different subtrees of @xmath224 , and @xmath38 must have an edge in @xmath227 .",
    "define @xmath229 note that , since @xmath10 is undirected , both @xmath79 and @xmath230 denote the same edge .",
    "but @xmath231 in general .",
    "the following lemma is crucial for our result .",
    "[ outopt ] if @xmath79 minimizes function @xmath232 and @xmath233 , then there exists a simple @xmath3-path of length @xmath234 and with one edge in @xmath227 .",
    "such a path is an optimal outward path .",
    "we shall show the existence of such a simple path , and then it is an optimal outward path by lemma  [ out1 ] .",
    "let @xmath93 be the shortest path from @xmath1 to @xmath36 on @xmath221 and @xmath94 any shortest path from @xmath37 to @xmath2 .",
    "if @xmath93 and @xmath94 are disjoint , @xmath235 is a desired path since @xmath79 is an edge in @xmath227 .",
    "otherwise let @xmath236 . by the triangle inequalities , seeing figure  [ outf].(a )",
    ", we have @xmath237\\circ p_2[q , y])+w(x , y)+w(p_1[x , q]\\circ p_2[q , t])\\\\ & = & w(p_1)+w(x , y)+w(p_2)=f(x , y ) \\end{aligned}\\ ] ] and the equality holds when @xmath238\\circ p_2[q , y])\\label{outeq1}\\end{aligned}\\ ] ] and @xmath239\\circ p_2[q , t ] ) \\label{outeq2}\\end{aligned}\\ ] ]    let @xmath240 be the root of the subtree which @xmath36 belongs to . if @xmath96 is an internal node of @xmath241 $ ] , i.e. , @xmath96 is a ancestor of @xmath240 on @xmath221 , since @xmath242 , we have @xmath243)+d_t(r)\\\\ & = & w(p_1[x , r])+d_t(q)-d(q , r)\\\\ & = & w(p_1[x , q]\\circ p_2[q , t])-2d(q , r)\\\\ & < & w(p_1[x , q]\\circ p_2[q , t ] ) . \\end{aligned}\\ ] ] that is , the equality of eq .",
    "( [ outeq2 ] ) can not hold and we have @xmath244 , which contradicts to the minimality of @xmath234 .",
    "therefore @xmath96 is on @xmath245 $ ] . in the following",
    "we assume that @xmath96 is the last vertex of @xmath94 which is also in @xmath93 if @xmath94 intersects @xmath93 at more than one vertices , i.e. , @xmath246 $ ] intersects @xmath93 only at @xmath96 .",
    "let @xmath95 be the path from @xmath1 to @xmath37 on @xmath221 .",
    "since @xmath36 and @xmath37 are at different subtrees of @xmath224 , the path @xmath95 is disjoint with the path @xmath245 $ ] .",
    "if @xmath95 is disjoint to @xmath246 $ ] , the path @xmath247\\circ p_2[q , t]$ ] is a simple path and its length is @xmath248 and also equals to @xmath234 by eq .",
    "( [ outeq2 ] ) , seeing figure  [ outf].(a ) .",
    "otherwise , let @xmath44 be the vertex in @xmath249)$ ] and closest to @xmath37 .",
    "we shall show that @xmath93 is disjoint to @xmath250 $ ] , and then @xmath251\\circ p_2[v , t]$ ] is a simple path ( figure  [ outf].(b ) ) and its length is @xmath252)+w(p_2[v , t]),\\ ] ] which is at most @xmath234 since @xmath253)=d(y , v)\\leq w(p_2[y , v])$ ] .    to see @xmath93",
    "must be disjoint to @xmath250 $ ] , we first note that @xmath250 $ ] is disjoint to @xmath245 $ ] or otherwise @xmath37 and @xmath36 would be in the same subtree of @xmath224 .",
    "next , similar to that @xmath96 can not be an ancestor of @xmath240 , since @xmath44 is also a vertex on @xmath94 , we have that @xmath44 can not be an ancestor of @xmath240 on @xmath221 .",
    "that is , @xmath44 must be below the lowest common ancestor of @xmath36 and @xmath37 on @xmath221 , and therefore @xmath250 $ ] is disjoint to @xmath93 .",
    "[ thm : out ] for an undirected graph with positive edge lengths , the optimal outward path problem can be solved in @xmath218 time if @xmath216 and @xmath217 are given for all @xmath44 .    by lemma  [ outopt ] ,",
    "the length of the optimal outward @xmath3-path is the minimum value of function @xmath232 . to compute @xmath79 minimizing @xmath232 , we first construct @xmath16 and a shortest path tree @xmath221 , and then find the edge set @xmath227 .",
    "the minimum can be found by checking both @xmath234 and @xmath248 for all edges @xmath254 .",
    "the time complexity is linear if the distances @xmath216 and @xmath217 for all @xmath44 are given .",
    "once @xmath79 is found , by the method in the proof of lemma  [ outopt ] , the corresponding path can be constructed in linear time .    by theorems  [ thm : back ] and [ thm : out ] , we have the next result .",
    "for undirected graphs with positive edge lengths , if the single source shortest path problem can be solved in @xmath255 time , the next - to - shortest path problem can be solved in @xmath27 time .",
    "important graph classes for which the single source shortest path problem can be solved in linear time include unweighted graphs ( by bfs @xcite ) , planar graphs @xcite , and integral edge length graphs @xcite .",
    "it is easy to show that the next - to - shortest path problem is at least as hard as the shortest path problem .",
    "given an instance of the shortest path problem , we add a dummy edge between @xmath1 and @xmath2 with sufficient small weight .",
    "then if there is an algorithm for the next - to - shortest path problem , we can solve the shortest path problem with the same time complexity since the above reduction is linear time .    in this paper",
    ", we show that the next - to - shortest path problem can be solved with the same time complexity as the single source shortest paths problem .",
    "interesting future works include the directed version and the undirected case with nonnegative edge weights .",
    "allowing zero - length edges makes the next - to - shortest path problem more involved . particularly , lemma  [ suff ] no more holds , and there seems no obvious modification to generalize the lemma to the nonnegative case .",
    "another open problem is if we can find the single source all destinations next - to - shortest paths in the same time complexity .      99 alstrup , s. , harel , d. , lauridsen , p.w . ,",
    "thorup , m. : dominators in linear time .",
    "siam j. comput .",
    "28(6 ) , 21172132 ( 1999 ) barman , s.c . , mondal s. , pal , m. : an efficient algorithm to find next - to - shortest path on trapezoid graphs . adv .",
    "anal . 2 , 97107 ( 2007 ) cormen , t.h . ,",
    "leiserson , c.e . ,",
    "rivest , r.l . ,",
    "stein , c. : introduction to algorithms . mit press and mcgraw - hill ( 2001 ) fredman , m.l . ,",
    "tarjan , r.e .",
    ": fibonacci heaps and their uses in improved network optimization algorithms .",
    "j. acm 34 , 209221 ( 1987 ) henzinger , m.r . ,",
    "klein , p. , rao , s. , subramanian , s. : faster shortest - path algorithms for planar graphs .",
    "j. comput .",
    "53 , 223 ( 1997 ) .",
    "krasiko , i. , noble , s.d . : finding next - to - shortest paths in a graph .",
    "inf . process .",
    "92 , 117119 ( 2004 ) lalgudi , k.n . ,",
    "papaefthymiou , m.c . : computing strictly - second shortest paths .",
    "inf . process .",
    "63 , 177181 ( 1997 ) li , s. , sun , g. , chen , g. : improved algorithm for finding next - to - shortest paths",
    ". inf . process .",
    "99 , 192194 ( 2006 ) mondal , s. , pal , m. : a sequential algorithm to solve next - to - shortest path problem on circular - arc graphs .",
    "10 , 201217 ( 2006 ) kao , k .- h . , chang , j .-",
    "m . , wang , y .- l . , juan , j.s .- t . : a quadratic algorithm for finding next - to - shortest paths in graphs .",
    "algorithmica ( 2010 ) .",
    "doi:10.1007/s00453 - 010 - 9402 - 4 thorup , m. : undirected single - source shortest paths with positive integer weights in linear time",
    ". j. acm 46 , 362394 ( 1999 )"
  ],
  "abstract_text": [
    "<S> given an undirected graph @xmath0 with positive edge lengths and two vertices @xmath1 and @xmath2 , the next - to - shortest path problem is to find an @xmath3-path which length is minimum amongst all @xmath3-paths strictly longer than the shortest path length . in this paper </S>",
    "<S> we show that the problem can be solved in linear time if the distances from @xmath1 and @xmath2 to all other vertices are given . </S>",
    "<S> particularly our new algorithm runs in @xmath4 time for general graphs , which improves the previous result of @xmath5 time for sparse graphs , and takes only linear time for unweighted graphs , planar graphs , and graphs with positive integer edge lengths .    </S>",
    "<S> example.eps gsave newpath 20 20 moveto 20 220 lineto 220 220 lineto 220 20 lineto closepath 2 setlinewidth gsave .4 setgray fill grestore stroke grestore </S>"
  ]
}