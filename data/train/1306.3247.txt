{
  "article_text": [
    "quantum wave - packet dynamics , that is , the evolution of the spatial distribution of a quantum particle , is an important part of the simulation of many quantum systems .",
    "it can be used for studying problems as diverse as scattering , surface adsorption , and laser control , just to name a few .",
    "we propose here a general - purpose program to solve the spatial part of the time - dependent schrdinger equation ( tdse ) , aimed particularly at a quantum particle interacting with a time - dependent potential .",
    "our interest mainly concerns such applications as laser control of quantum systems  @xcite , but the program can be used with any user - supplied potential function .",
    "the program is based on the split - operator method  @xcite , which has successfully been used to solve the time - dependent schrdinger equation in many different settings , from the calculation of vibrational bound states ( see , _ e.g. _ , @xcite ) and the simulation of high - power laser - matter interactions ( see , _ e.g. _ , @xcite ) , to the laser control of chemical reactions ( see , _",
    "e.g. _ , @xcite ) .",
    "the method can also be applied to schrdinger - like equations , such as the gross - pitaevskii  @xcite and dirac  @xcite equations .",
    "in this section , we present a detailed description of the split - operator method to solve the time - dependent schrdinger equation . while everything presented here can be found in the original works developing the method  @xcite , we think it useful to review all the elements necessary to understand the inner workings of the program .",
    "we consider the time - dependent schrdinger equation , @xmath0 with @xmath1 the hamiltonian for the motion of a particle interacting with an external time - dependent potential @xmath2 , _ i.e. _ , @xmath3 where @xmath4 and @xmath5 are the kinetic and potential energy operators , respectively , @xmath6 is the momentum operator , and @xmath7 the mass of the particle .",
    "( the same hamiltonian is obtained for a vibrating diatomic molecule , where the spatial coordinate is replaced by the internuclear distance , and the potential @xmath2 is the sum of the internal potential energy and an external , time - dependent potential , as will be shown in sec .",
    "[ sec : vib ] . )",
    "the formal solution to eq .",
    "( [ eq : tdse ] ) is given by the time evolution operator @xmath8 , itself a solution of the time - dependent schrdinger equation  @xcite , @xmath9 such that , given an initial wave function at time @xmath10 , @xmath11 , the solution at any time @xmath12 is obtained from @xmath13 as the hamiltonian is time dependent , we have that  @xcite @xmath14 \\nonumber \\\\    & = \\hat{t } \\exp \\left\\ { -\\frac{{\\mathrm{i}}}{\\hbar } \\int_{t_0}^{t } \\left [        \\hat{k } + \\hat{v}(t ' ) \\right ] { \\mathrm{d}}t ' \\right\\}. \\label{eq : ut0t}\\end{aligned}\\ ] ] in eq .",
    "( [ eq : ut0 t ] ) , the time - ordering operator @xmath15 ensures that the hamiltonian is applied to the wave function in order of increasing time , as in general the hamiltonian does not commute with itself at a different time , _",
    "i.e. _ , @xmath16 \\neq 0 $ ] iff @xmath17  @xcite . by considering a small time increment @xmath18 , we can do without the time - ordering operator by considering the approximate short - time evolution operator  @xcite , @xmath19 { \\mathrm{d}}t ' \\right\\}.    \\label{eq : short - time}\\ ] ]    we are concerned here with time - dependent potentials that also have a spatial dependence , @xmath20 , such as those produced by ion traps or focused laser pulses , such that @xmath21 , in which case @xmath4 and @xmath5 do not commute . for two non - commuting operators @xmath22 and @xmath23 , @xmath24 , but the split - operator method  @xcite allows the approximation of the evolution operator with minimal error , @xmath25 \\exp \\left [ -\\frac{{\\mathrm{i}}}{\\hbar } \\int_{t}^{t+\\delta        t } \\hat{v}(t ' ) { \\mathrm{d}}t ' \\right ] \\nonumber \\\\    & \\quad \\times \\exp \\left [ -\\frac{{\\mathrm{i}}\\delta t}{2 \\hbar } \\hat{k }    \\right ] + o(\\delta t^3 ) .",
    "\\end{aligned}\\ ] ] using the midpoint formula  @xcite for the integral of the potential , @xmath26 we get @xmath27 \\exp \\left [ -\\frac{{\\mathrm{i}}\\delta t}{\\hbar }      v(t+ \\frac{\\delta t}{2 } ) \\right ] \\exp \\left [ -\\frac{{\\mathrm{i}}\\delta        t}{2 \\hbar } \\hat{k } \\right ] ,    \\label{eq : splitop}\\ ] ] where the global error is @xmath28 .",
    "the choice of the order of the operators @xmath4 and @xmath5 in the above equations is arbitrary , but the choice we make here allows for a faster execution in the majority of cases , _",
    "i.e. _ , when the intermediate value of the wave function is not needed at all time steps .",
    "we can then link together @xmath29 consecutive time steps into @xmath30    \\delta t ) \\hat{u}(t + [ n-1 ] \\delta t , t + [ n-2 ] \\delta t ) \\nonumber    \\\\    & \\quad \\times \\cdots \\times    \\hat{u}(t + \\delta t , t )    \\nonumber \\\\    & = \\exp \\left [ -\\frac{{\\mathrm{i}}\\delta t}{2        \\hbar } \\hat{k } \\right ] \\exp \\left [ -\\frac{{\\mathrm{i}}\\delta t}{\\hbar }      \\hat{v } ( t + \\frac{2n-1}{2}\\delta t ) \\right ] \\nonumber \\\\    & \\quad \\times \\left\\ { \\prod_{j = n-1}^{1 } \\exp \\left [ -\\frac{{\\mathrm{i}}\\delta t}{\\hbar }         \\hat{k } \\right ]       \\exp \\left [ -\\frac{{\\mathrm{i}}\\delta t}{\\hbar }      \\hat{v } ( t + \\frac{2j-1}{2}\\delta t ) \\right ] \\right\\ } \\nonumber \\\\   & \\quad \\times \\exp \\left [ -\\frac{{\\mathrm{i}}\\delta t}{2        \\hbar } \\hat{k } \\right],\\end{aligned}\\ ] ] where two sequential operations of @xmath4 are combined into one . the same is not possible with @xmath5 due to its time dependence .",
    "we choose to discretize the problem on a finite spatial grid , _",
    "i.e. _ , @xmath31 is restricted to the values @xmath32 where the number of grid points @xmath33 are ( integer ) parameters , as is the size of the grid , with bounds @xmath34 $ ] and where @xmath35 with equivalent expressions in @xmath36 and @xmath37 .",
    "the problem now becomes that of calculating the exponential of matrices @xmath38 and @xmath39 , which is only trivial for a diagonal matrix  @xcite . in the original implementation of the split - operator method  @xcite , this is remedied by considering that while the matrix for @xmath5 is diagonal for a spatial representation of the wave function , @xmath4 is diagonal in momentum space . by using a fourier transform ( here represented by the operator @xmath40 ) and its inverse ( @xmath41 )",
    ", we can write @xmath42 \\psi(\\mathbf{x } ) =    \\mathcal{f}^{-1 } \\exp \\left [ -\\frac{{\\mathrm{i}}\\delta t}{2        \\hbar } \\hat{k}(\\mathbf{p } ) \\right ] \\mathcal{f } \\psi(\\mathbf{x } ) ,    \\label{eq : ft}\\ ] ] where , considering that @xmath43 , @xmath44 since the operators transform as @xmath45 when going from position to momentum space  @xcite .",
    "equation  ( [ eq : ft ] ) is efficiently implemented numerically using a fast fourier transform ( fft )  @xcite .",
    "after the forward transform , the momentum grid , obtained from the wave vector @xmath46 , is discretized according to  @xcite @xmath47 care must be taken to associate the appropriate momentum value to each element of the fourier - transformed wave function , considering the order of the output from fft routines  @xcite .",
    "algorithm  [ algo : split ] summarizes the split - operator method as presented here .",
    "@xmath48      we consider now the implementation of the algorithm described above on a multi - processor architecture with distributed memory .",
    "the `` natural '' approach to parallelizing the problem is to divide the spatial grid , and therefore the wave function , among the processors .",
    "each processor can work on its local slice of the wave function , except for the fourier transform , which requires information across slices .",
    "this functionality is pre - built into the parallel implementation of the fft package fftw  @xcite , of which we take advantage .",
    "the communications themselves are implemented using the message passing interface ( mpi ) library  @xcite .    for a 3d ( or 2d )",
    "problem , the wave function is split along the @xmath49 direction , with each processor having a subset of the grid in @xmath49 , but with the full extent in @xmath36 and @xmath37 . to minimize the amount of communication after the forward fft , we use the intermediate transposed function , where the split is now along the @xmath36 dimension .",
    "the original arrangement is recovered after the backward function , so this is transparent to the user of our program .",
    "in addition , fftw offers the possibility of performing a 1d transform in parallel , which we also implement here .    the only constrain this imposes on the user is that a 1d problem may only be defined along @xmath49 , and a 2d problem in the @xmath50-plane ( in order to simplify the concurrent implementation of serial and parallel versions , this constraint also applies to the serial version ) .",
    "in addition to the total number of grid points along @xmath49 , @xmath51 , each processor has access to @xmath52 , the number of grid points in @xmath49 for this processor , along with @xmath53 , the corresponding initial index . in other words ,",
    "each processor has a grid in @xmath49 defined by @xmath54 with the grids in @xmath36 and @xmath37 still defined by eq .",
    "( [ eq : grid ] ) .",
    "having defined the physical problem to be simulated , namely by setting up the potential @xmath55 and initial wave function @xmath56 , the following routines must be coded ( see section  [ sec : user - def ] for details ) :    * ` initialize_potential ` * ` potential ` * ` initialize_wf ` * ` initialize_user_observe ` ( can be empty ) * ` user_observe ` ( can be empty )    the files containing these functions must include the header file ` wavepacket.h ` .",
    "the program can then be compiled according to the instructions in section  [ sec : compiling ] .",
    "a parameter file must then be created , see section  [ sec : parameters ] .",
    "the program can then be executed using a command similar to    .... wavepacket parameters.in ....      the physical problem that is actually simulated by the program depends on two principal elements , the time - dependent potential @xmath57 and the initial wave function @xmath58 .",
    "in addition , the user may be interested in observables that are not calculated by the main program ( the list a which is given in sec .",
    "[ sec : parameters ] ) .",
    "the user _ must _ supply functions which define those elements , which are linked to at compile time . how these functions are declared and what they are expected to perform",
    "is described in what follows , along with the data structure that is passed to those functions .",
    "the data structure ` parameters ` is defined in the header file ` wavepacket.h ` , which must be included at the top of the users own c files to be linked to the program .",
    "a variable of type ` parameters ` is passed to the user s functions , and contains all parameters the main program is aware of and that are useful / necessary for the execution of the tasks of the user - supplied routines .",
    "the structure reads    .... typedef struct {    / * parameters and grid * /    int size , rank ;    size_t nx , ny , nz , n , nx_local , nx0 , n_local ;    double x_min , y_min , z_min , x_max , y_max , z_max , dx , dy , dz ;    double * x , * y , * z , * x2 , * y2 , * z2 ;    double mass , dt , hbar ; } parameters ; ....    where the different variables are :    * ` size ` : number of processors on which the program is running .",
    "* ` rank ` : rank of the local processor , with a value in the range @xmath59 $ ] . in the serial version ,",
    "the value is therefore ` rank = 0 ` .",
    "( _ note : _ all input and output to / from disk is performed by the processor of ` rank ` 0 . ) * ` nx , ny , nz ` : number of grid points along @xmath49 , @xmath36 , and @xmath37 , respectively . in the parallel version",
    ", this refers to the full grid , which is then split among the processors . for a one or two - dimensional problem ,",
    "` ny ` and/or ` nz ` should be set to 1 .",
    "( @xmath49 is always the principal axis in the program . ) for best performance , these should be set to a product of powers of small prime integers , _",
    "e.g. _ , @xmath60 see the documentation of fftw for more details  @xcite .",
    "* @xmath61 . * ` nx_local ` : number of grid points in @xmath49 on the local processor , see sec .",
    "[ sec : parallel ] . in the serial version , ` nx_local = nx ` . * ` nx0 ` : index of the first local grid point in @xmath49 , see sec .",
    "[ sec : parallel ] . in the serial version , @xmath62 .",
    "* ` x_min , y_min , z_min , x_max , y_max , z_max ` : values of the first and last grid points along @xmath49 , @xmath36 , and @xmath37 . * ` dx , dy , dz ` : grid spacings @xmath63 , @xmath64 , and @xmath65 , respectively , see eq .",
    "( [ eq : deltax ] ) . * ` x , y , z ` : arrays of size ` nx_local ` , ` ny ` , and ` nz ` , respectively , containing the value of the corresponding coordinate at the grid point . * ` x2 , y2 , z2 ` : arrays of size ` nx_local ` , ` ny ` , and ` nz ` , respectively , containing the square of the value of the corresponding coordinate at the grid point . * ` mass ` : mass of the particle .",
    "* ` dt ` : time step @xmath18 of the time evolution , see eq .",
    "( [ eq : short - time ] ) . * ` hbar ` : value of @xmath66 , planck s constant over @xmath67 , in the proper units .",
    "( see sec .",
    "[ sec : parameters ] . )      in the initialization phase of the program , before the time evolution , the function    .... void   initialize_potential ( const parameters params , const int argv ,                         char * * const argc ) ; ....    is called , with the constant variable ` params ` containing all the values specified in sec .  [",
    "sec : struct_params ] . ` argv ` and ` argc ` are the variables relating to the command line arguments , as passed to the main program :    .... int main ( int argv , char * * argc ) ; ....    this function should perform all necessary pre - calculations and operations , including reading from a file additional parameters , for the potential function . the objective is to reduce as most as possible the time necessary for a call to the ` potential ` function .",
    "the function    .... double   potential ( const parameters params , const double t ,              double * const pot ) ; ....    should return the value of the potential @xmath68 , for all ( local ) grid points at time ` t ` , in the array ` pot ` , of dimension ` pot[nx_local][ny][nz ] ` .",
    "the initial wave function @xmath69 is set by the function    .... void   initialize_wf ( const parameters params , const int argv ,                  char * * const argc , double complex * psi ) ; ....    where ` psi ` is a 3d array of dimension ` psi[nx_local][ny][nz ] ` .",
    "if the wave function is to be read from a file , users can make use of the functions ` read_wf_text ` and ` read_wf_bin ` , described in sec .",
    "[ sec : useful ] .",
    "in addition to the observables that are built in , which are described in sec .  [",
    "sec : parameters ] , users may define additional observables , such as the projection of the wave function on eigenstates .    the function    .... void   initialize_user_observe ( const parameters params , const int argc ,                            char * * const argv ) ; ....    is called once at the beginning of the execution .",
    "it should perform all operations needed before any call to ` user_observe ` .",
    "the arguments passed to the function are the same as those of ` initialize_potential ` , see sec .",
    "[ sec : init_pot ] .    during the time evolution ,",
    "every ` nprint ` time step , the function    .... void   user_observe ( const parameters params , const double t ,                 const double complex * const psi ) ; ....    is called , with the current time ` t ` and wave function ` psi ` .",
    "the printing out of the results , as well as the eventual opening of a file , is to be performed within these user - supplied functions . in a parallel implementation , only the processor of ` rank ` 0 should be responsible for these tasks , and proper communication must be set up to ensure the full result is available to this processor .",
    "note that these functions _ must _ be present in the source file that will be linked with the main program , even if additional observables are not desired . in this case , the function body can be left blank .      a series of functions declared in the header file ` wavepacket.h ` and that are part of the main program are also available for use within the user - defined functions described above .    * .... double   norm ( const parameters params ,         const double complex * const psi ) ; .... + calculates @xmath70 .",
    "* .... double complex   integrate3d ( const parameters params ,                const double complex * const f1 ,               const double complex * const f2 ) ; .... + given @xmath71 and @xmath72 , calculates @xmath73 ( correct results are also obtained for 1d and 2d systems . ) * .... double   expectation1d ( const parameters params , const int dir ,                  const double * const f ,                  const double complex * const psi ) ; .... + given @xmath74 and @xmath75 , calculates @xmath76 where @xmath77 for @xmath78 , respectively . * .... void   read_wf_bin ( const parameters params ,                const char * const wf_bin ,               double complex * const psi ) ; .... + opens the file with filename ` wf_bin ` and reads the wave function into ` psi ` . the file must be in a binary format , as written when the keyword ` wf_output_binary ` is present in the parameter file , see sec .  [",
    "sec : parameters ] . in the parallel version ,",
    "the file is read by the processor of rank 0 , and each processor is assigned its local part of the wave function of size ` psi[nx_local][ny][nz ] ` . * .... void distribute_wf ( const parameters params ,                  double complex * const psi_in ,                 double complex * const psi_out ) ; .... + given the wave function ` psi_in[nx][ny][nz ] ` located on the processor of rank 0 , returns in ` psi_out[nx_local][ny][nz ] ` the local part of the wave function on each processor . intended only to be used in the parallel version , the function will simply copy ` psi_in ` into ` psi_out ` in the serial version . * .... void abort ( ) .... + terminates the program . this is the preferred method for exiting the program ( _ e.g. _ , in case of error ) in user - supplied routines , especially in the parallel version .",
    "a sample makefile is supplied with the program , which should be straightforward to adapt to one s needs . without a makefile , a typical command - line compilation would look something like    .... gcc -o3 -std = c99 -o wavepacket wavepacket.c user_defined.c \\",
    "-lfftw3 -lm   ....    where the file ` user_defined.c ` contains all the routines specified in section  [ sec : user - def ] .    by default , the compiling will produce the serial version of the program . to compile the mpi parallel version",
    "requires defining the macro ` mpi ` , _",
    "i.e. _ , by adding ` -dmpi ` as an argument to the compiler ( through ` cflags ` in the makefile ) .",
    "in addition , mpi libraries must be linked to , including ` -lfftw3_mpi ` .",
    "when executing the program , it will expect the first command - line argument to consist of the name of the parameter file .",
    "this file is expected to contain a series of statements of the type _key _ = _ value_ , each on a separate line .",
    "the order of these statements is not important , and blank lines are ignored , but white space must separate _ key _ and _ value _ from the equal sign .",
    "note that the program does not check for duplicate keys , such that the last value found will be used ( except for the key ` output ` , see below ) .",
    "table  [ tab : param_keys ] presents the keys recognized by the program .",
    "if a key listed with a default value of `` _ _ none _ _ '' is absent from the parameter file , the program will print out a relevant error message and the execution will be aborted .",
    "the key ` units ` can take the value ` si ` if the _",
    "systme international _ set of units is desired ( kg , m , s ) , with ` au ` ( the default ) corresponding to atomic units , where @xmath79 , with @xmath80 and @xmath81 the mass and the charge of the electron , respectively .",
    "some equivalences between the two sets are given in tab .",
    "[ tab : units ] .",
    "all parameters with units ( mass , grid limits , time step ) must be consistent with the set of units chosen .",
    ".[tab : param_keys]recognized parameters to be found in the parameter file .",
    "parameters with no default value must be present , with the exception of those indicated as _",
    "none*_. [ cols=\"<,<,<,^\",options=\"header \" , ]     these values will be printed out in the file designated by the ` results_file ` key , for the initial wave function and every ` nprint ` iteration of the time step @xmath18",
    ". the program will abort with an error message if @xmath82 .",
    "note that if @xmath83 , the values for the final wave function will not be calculated .",
    "the key ` nprint ` needs only be present if any of the output flags is set .",
    "calculating the exact memory usage is a bit tricky , but as the main use of memory is to store the wave function and some work arrays , we can estimate a minimum amount of memory necessary according to the grid size . considering that a double precision real takes up 8 bytes of memory , the program requires at least @xmath84 bytes _ per processor _ , where @xmath85 is the number of processors used .",
    "this value holds when the autocorrelation function is not calculated ; otherwise , the initial wave function must be stored and the factor @xmath86 above changes to @xmath87 .",
    "obviously , this estimate does not include any memory allocated within user - supplied routines .",
    "as a first example , let us consider a vibrating diatomic molecule , with the hamiltonian @xmath88 for a wave function @xmath89 in spherical coordinates , with @xmath7 the reduced mass and @xmath90 the molecular potential  @xcite .",
    "we neglect here the rotation of the molecule , and only look at the radial part of the wave function , @xmath91 . setting @xmath92 , and substituting @xmath49 for @xmath93 , we get the one - dimensional schrdinger equation @xmath94      \\psi(x , t),\\ ] ] which is the one - dimensional equivalent of eq .",
    "( [ eq : tdse ] ) with hamiltonian eq .",
    "( [ eq : hamiltonian ] ) and with the full potential @xmath95 taken as a sum of the molecular potential @xmath96 and the coupling of the molecule to a laser pulse , @xmath97 .",
    "we note that recovering an operator of the form @xmath98 is a very special case obtained here for a diatomic molecule , and that in general the kinetic energy operator for the internal motion of a molecule can be quite different , such that this program may not be used to study the internal dynamics of molecules in general .    for the molecular potential , we take a morse potential  @xcite , @xmath99 ^ 2,\\ ] ] and from the data of ref .",
    "@xcite , we derive the parameters for @xmath100c@xmath101o in the ground electronic state : @xmath102 with @xmath103 the reduced mass , and all values expressed in atomic units ( see tab .",
    "[ tab : units ] ) .    using a classical model for the laser field and the dipole approximation ,",
    "the laser - molecule coupling is given by  @xcite @xmath104 where @xmath105 is the dipole moment of the molecule and @xmath106 the electric field of the laser .",
    "we approximate the internuclear - separation - dependent permanent dipole moment of the molecule as the linear function @xmath107 with the values ( in atomic units ) @xmath108 and @xmath109  @xcite . for the laser pulse , we take @xmath110 with @xmath111 and @xmath112 the amplitude and frequency of the field , respectively , and the envelope function @xmath113 in this sample simulation , we take the following values ( in atomic units ) : @xmath114 this corresponds to a 1  ps pulse at an irradiance of @xmath115 , resonant with the @xmath116 transition .",
    "using a dvr method  @xcite , we precomputed the first five vibrational eigenstates @xmath117 of the morse potential for @xmath100c@xmath101o on a grid of 4000 points , from @xmath118 to @xmath119 . the data , stored in file `",
    "co_vib.txt ` , are read when the wave function is initialized in the function ` initialize_wf ` , and the initial wave function is set to @xmath120 . the function ` user_observe ` is programmed to calculate the projection of the wave function on the first five eigenstates , _",
    "i.e. _ , @xmath121    using the same grid as the one described above for the calculation of the vibrational states , we run the simulation for @xmath122 time steps of length @xmath123 , and calculate the projection of the wave function on the vibrational eigenstates every @xmath124 time steps .",
    "the result is shown in fig .",
    "[ fig : co_proj ] .",
    "projection of the time - dependent vibrational wave function of the co molecule , interacting with a resonant laser pulse , on the first five vibrational eigenstates . ]",
    "let us now consider the three - dimensional problem of the motion of a charged atomic ion in a paul trap  @xcite .",
    "these create a time - dependent quadrupolar field allowing , under the right conditions , the confinement of an ion .",
    "the electric potential inside a paul trap is of the form  @xcite @xmath125 where @xmath126 is a static electric potential , @xmath127 the amplitude of an ac potential of frequency @xmath128 , and @xmath129 .",
    "the scale factor @xmath130 is obtained from @xmath131 , with @xmath132 the radial distance from the center of the trap to the ring electrode and @xmath133 the axial distance to an end cap ( see refs .",
    "@xcite for more details ) . considering an atomic ion of charge @xmath134 , where @xmath81 is the elementary charge  @xcite",
    ", we get the potential energy @xmath135    for the simulation , we consider conditions similar to those of refs .",
    "@xcite and take a @xmath136ba@xmath137 ion , @xmath138  @xcite , in a trap with characteristics : @xmath139 the initial state is taken as a gaussian wave packet , @xmath140",
    "\\exp \\left[-      \\frac{\\left ( \\xi-\\xi_0         \\right)^2}{\\sigma_\\xi^2 } \\right],\\ ] ] and we set @xmath141 using @xmath142 grid points , with the grid defined from @xmath143 to @xmath144 along each cartesian coordinate , we run the simulation for @xmath145 time steps of length @xmath146 , measuring the wave function every 10 time steps . the resulting trajectory of the ion is shown in fig .  [ fig : traj ] .",
    "( a ) sample trajectory of the wave packet of a ba@xmath147 ion in a paul trap .",
    "the simulation is carried in three dimensions , and the expectation value of the position is plotted individually for each cartesian coordinate .",
    "( b ) enlargement of panel ( a ) , evidencing the micromotion of the ion at the frequency of the trapping potential . ]",
    "this research was conducted using the resources of the high performance computing center north ( hpc2n ) .",
    "funding from ume university is gratefully acknowledged .",
    "m.  d. feit , j.  a. fleck , jr . ,",
    "http://link.aip.org/link/?jcp/78/301/1[solution of the schrdinger equation by a spectral method ii : vibrational energy levels of triatomic molecules ] , j. chem .",
    "78  ( 1 ) ( 1983 ) 301308 .",
    "a.  d. bandrauk , h.  shen , http://www.sciencedirect.com/science/article/pii/000926149190232x[improved exponential split operator method for solving the time - dependent schrdinger equation ] , chem .",
    "176  ( 5 ) ( 1991 ) 428432 .",
    "y.  i. salamin , s.  hu , k.  z. hatsagortsyan , c.  h. keitel , http://www.sciencedirect.com/science/article/pii/s0370157306000093[relativistic high - power laser - matter interactions ] , phys . rep .",
    "427  ( 2 - 3 ) ( 2006 ) 41155 .",
    "g.  r. mocken , c.  h. keitel , http://www.sciencedirect.com/science/article/pii/s0010465508000611[fft-split-operator code for solving the dirac equation in 2 + 1 dimensions ] , comput .",
    "178  ( 11 ) ( 2008 ) 868882 .",
    "j.  e. gready , g.  b. bacskay , n.  s. hush , finite - field method calculations .",
    "iv . higher - order moments , dipole moment gradients , polarisability gradients and field - induced shifts in molecular properties : application to n@xmath148 , co , cn@xmath149 , hcn and hnc , chem .",
    "( 1978 ) 467483 .",
    "w.  neuhauser , m.  hohenstatt , p.  toschek , h.  dehmelt , http://link.aps.org/doi/10.1103/physrevlett.41.233[optical-sideband cooling of visible atom cloud confined in parabolic well ] , phys .",
    "41 ( 1978 ) 233236 ."
  ],
  "abstract_text": [
    "<S> we present a program to simulate the dynamics of a wave packet interacting with a time - dependent potential . </S>",
    "<S> the time - dependent schrdinger equation is solved on a one- , two- , or three - dimensional spatial grid using the split operator method . </S>",
    "<S> the program can be compiled for execution either on a single processor or on a distributed - memory parallel computer .    </S>",
    "<S> wave - packet dynamics , time - dependent schrdinger equation , ion traps , laser control    * program summary *    _ manuscript title : _ program for quantum wave - packet dynamics with time - dependent potentials + _ authors : _ c. m. dion , a. hashemloo , and g. rahali + _ program title : _ wavepacket + _ journal reference : _ </S>",
    "<S> + _ catalogue identifier : _ </S>",
    "<S> + _ licensing provisions : _ none + _ programming language : _ c ( iso c99 ) + _ computer : _ any computer with an iso c99 compiler ( _ e.g. _ , gcc  @xcite ) + _ operating system : _ any + _ ram : _ strongly dependent on problem size . </S>",
    "<S> see text for memory estimates . </S>",
    "<S> + _ number of processors used : _ any number from 1 to the number of grid points along one dimension . + _ supplementary material : _ + _ keywords : _ wave - packet dynamics , time - dependent schrdinger equation , ion trap , laser control + _ classification : _ 2.7 wave functions and integrals + _ external routines / libraries : _ fftw  @xcite , mpi ( optional )  @xcite + _ subprograms used : _ user - supplied potential function and routines for specifying the initial state and optional user - defined observables . </S>",
    "<S> + _ nature of problem : _ + solves the time - dependent schrdinger equation for a single particle interacting with a time - dependent potential . </S>",
    "<S> + _ solution method : _ + the wave function is described by its value on a spatial grid and the evolution operator is approximated using the split - operator method  @xcite , with the kinetic energy operator calculated using a fast fourier transform . </S>",
    "<S> + _ restrictions : _ +   + _ unusual features : </S>",
    "<S> _ + simulation can be in one , two , or three dimensions . </S>",
    "<S> serial and parallel versions are compiled from the same source files . </S>",
    "<S> + _ additional comments : _ +   + _ running time : _ </S>",
    "<S> + strongly dependent on problem size . +    0 ` http://gcc.gnu.org ` ` http://www.fftw.org ` ` http://www.mpi-forum.org ` m.  d. feit , j.  a. fleck , jr . </S>",
    "<S> , a.  steiger , solution of the schrdinger equation by a spectral method , j. comput . </S>",
    "<S> phys . </S>",
    "<S> 47 ( 1982 ) 412433 . </S>",
    "<S> m.  d. feit , j.  a. fleck , jr . </S>",
    "<S> , solution of the schrdinger equation by a spectral method ii : vibrational energy levels of triatomic molecules , j. chem . </S>",
    "<S> phys . </S>",
    "<S> 78  ( 1 ) ( 1983 ) 301308 . </S>"
  ]
}