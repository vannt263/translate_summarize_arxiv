{
  "article_text": [
    "component - based development is a technology that has been widely used for many years during the implementation phase of the software life cycle .",
    "this technology has also been adapted to the design phase .",
    "design patterns expressed in uml are frequently reused in order to simplify the design of new applications .",
    "the most famous design patterns are called the gang of four ( or gof ) patterns @xcite . during the development of a new application",
    ", most designers refer to the gof patterns , even if there is no precise definition of these patterns .",
    "this lack of a formal definition allows designers to adapt freely the gof patterns to their needs and has contributed to the success of the gof patterns .",
    "as formal specifications are now well - known in industry , the reuse of formal specifications based on design patterns becomes a challenging issue .",
    "reusing a formal specification means firstly to formally define components of formal specifications ( or specification patterns ) .",
    "secondly , it means to define how to combine components together in order to build a new application .",
    "other problems such as the definition of a library for storing the components must also be solved .",
    "a few works address the problem of defining specification patterns .",
    "each of these works define also a specific way to combine specification patterns together but there is no consensus on the definition of a specification pattern or on the combination of patterns .",
    "we use the b language to formally specify the notion of specification pattern , and several ways to combine specification patterns together .",
    "our approach aims at helping the designer to firstly formally specify a new application that reuses design patterns and secondly to assist him with a tool .",
    "we have chosen the b language for the following reasons :    * where b is already being used , then there is no need to learn a new formalism to define and reuse specification patterns .",
    "* b is supported by tools that validate the specification .",
    "we will use them to validate the definition of specification patterns and the different reuse mechanisms .",
    "a designer will thus reuse not only pieces of formal specifications but also proofs concerning these pieces of formal specifications .",
    "this paper describes our approach through examples and is organised as follows .",
    "the next section is an introduction to patterns .",
    "section 3 deals with a state of the art about the reuse of specification patterns with formal methods .",
    "section 4 is a discussion of the notion of reuse in b : our approach is presented and illustrated by an example .",
    "finally , we conclude this work in sect .",
    "5 with the perspectives and the limits of this approach .",
    "the aim of this section is to present in an informal way how to specify an application with uml patterns .",
    "this section identifies also several ways to reuse the patterns .",
    "two examples of design patterns are presented in this section .",
    "they will be used in the remainder of the paper .",
    "figure 1 presents with the uml notation the class diagram of the * composite * design pattern @xcite .",
    "this pattern is a solution to describe the tree structure of a composite , which is an object composed of several other objects .",
    "two classes are defined to represent composite objects ( ` composite ` class ) and basic objects ( ` leaf ` class ) .",
    "an abstract class called ` component ` represents both composite and basic objects .",
    "an association is defined between ` composite ` and ` component ` classes with the ` father ` and ` children ` roles . a `",
    "composite ` can have several ` component ` children which can be ` leaf ` or ` composite ` objects .",
    "operations ( methods ) are defined in the different classes .",
    "the set of components of a composite object is given by the ` getchild ` method .",
    "` operation ` is a generic operation and deals with both leaf and composite objects .",
    "this operation is redefined in the ` composite ` and ` leaf ` classes by ` operation_composite ` and ` operation_leaf ` .",
    "figure 2 presents the class diagram of the * resource allocation * pattern described in @xcite .",
    "four classes are defined .",
    "the ` resource ` class represents a resource to allocate .",
    "a resource provides facilities , represented in this pattern by the ` resourcefacility ` class .",
    "a resource is allocated to job occurrences represented by the ` joboccurrence ` class . finally , `",
    "jobcategory ` , which stands for the job categories , is linked to the last two classes .",
    "the requirements of the resource facilities are supported only by specific job categories . a job is represented by an association between ` joboccurrence ` and ` jobcategory ` .      to motivate the need for reuse of specification patterns , we use the simple example of designing in uml the allocation of directories to secretaries .",
    "a directory is composed of files and other directories .",
    "figure 3 gives a solution obtained by `` instantiating '' both patterns * composite * and * resource allocation*. in the first pattern , a directory is considered as a ` composite ` object and a file as a ` leaf ` object .",
    "the ` component ` class is renamed as ` element ` ( note that we could have kept the name ` component ` ) . in the pattern * resource allocation * ,",
    "an element is considered as a ` resource ` object and a secretary as a ` jobcategory ` object .    compared to both original patterns ,",
    "some operations are renamed .",
    "for instance , ` add_composite ` becomes ` add_directory ` in fig .",
    "3 . other operations such as ` protect_element ` and ` write_mode ` are created once the patterns have been instantiated .",
    "new variables called ` state ` and ` usable ` are introduced to describe the protection mode of a file or a directory which is declared as usable .",
    "two kinds of operations can be distinguished : pattern definition and mechanisms for reusing patterns .",
    "[ [ pattern - definition . ] ] pattern definition .",
    "+ + + + + + + + + + + + + + + + + + +    two ways exist to define a new pattern .",
    "the pattern can either be defined `` ex nihilo '' or it can be deduced from existing patterns : this kind of reuse is aiming to create new patterns . in this case , mechanisms are defined at the pattern level in order to link and compare several patterns .    [",
    "[ reuse - mechanisms . ] ] reuse mechanisms .",
    "+ + + + + + + + + + + + + + + + +    three basic mechanisms exist for reusing patterns in order to design an application : instantiation , composition and extension @xcite .",
    "they allow patterns to be adapted to the design in progress .    *",
    "the _ instantiation _ , also called imitation , is a mechanism which allows different elements of a pattern to be renamed . *",
    "the _ composition _ mechanism , also called integration mechanism , associates two or more patterns . different kinds of association may be defined . *",
    "the last reuse mechanism , called _ extension _ , allows new elements to be added to existing patterns or existing elements to be removed or modified .",
    "formal specification languages are very well adapted to define all these mechanisms . in the following sections , we present different existing propositions , before describing our solution .",
    "up to now , our research works deal with the use of formal methods in order to verify functional properties of systems ( especially information systems @xcite ) . taking into account dynamic properties",
    "is a work in progress @xcite .",
    "therefore , in this paper , we do not consider event or temporal logic based formal methods such as @xcite .",
    "we have chosen to present four examples of formal methods that have been used to formalise design patterns and their reuse .",
    "for each of them , the following criteria are studied : presentation of the approach , pattern definition , available reuse mechanisms and their definition , existence of tools , usability of the approach , in particular the required mathematical background and the level of abstraction patterns that are defined and reused .",
    "more details can be found in @xcite .      in @xcite ,",
    "design patterns are specified in both uml and b.    [ [ pattern - definition.-1 ] ] pattern definition .",
    "+ + + + + + + + + + + + + + + + + + +    patterns are defined in two ways . in @xcite , patterns are defined `` ex nihilo '' .",
    "the uml diagram of a gof pattern is translated from uml to b using a set of rules .",
    "thus the b specification can be proved , using a b tool . in @xcite",
    ", a pattern can be defined as a refinement ( also called specialisation ) of a more generic pattern , thanks to the refinement mechanism of the b method .",
    "[ [ reuse - mechanisms.-1 ] ] reuse mechanisms .",
    "+ + + + + + + + + + + + + + + + +    the instantiation of a pattern is defined on the uml description of a pattern .",
    "the resulting diagram is again translated to b with the set of rules .",
    "this process has not been formalised , so the resulting b specification must be proved again .",
    "[ [ tools . ] ] tools .",
    "+ + + + + +    a tool based on the b and uml environments has been developed .",
    "no specific tools are defined to implement the reuse .",
    "[ [ usability . ] ] usability .",
    "+ + + + + + + + + +    this approach requires knowledge of uml and b. pattern reuse is defined on the uml representation .",
    "consequently , reuse mechanisms can not be formally defined .",
    "proofs associated with a pattern can not be directly reused to achieve the proofs of its instantiation .",
    "however the definition of patterns by refinement of other patterns is quite interesting and original .",
    "catalysis @xcite is a component - based specification method .",
    "framework is the name used for pattern in catalysis .",
    "the idea is to formally specify the frameworks by adapting the existing catalysis features .",
    "[ [ pattern - definition.-2 ] ] pattern definition .",
    "+ + + + + + + + + + + + + + + + + + +    a specification framework is defined with algebraic specifications using many - sorted first order logic .",
    "axioms concerning the framework are specified in catalysis with first order logic predicates . rather than considering the initial model traditionally used in algebraic specifications as the referring model for the framework semantics , the theory is here represented by an isoinitial model which is very interesting , especially for proving formulas using negation ,",
    "because it preserves the negation property contrary to the initial model corresponds to the non - provability of @xmath0 , while in an isoinitial theory , it corresponds to the provability of @xmath1 . ] .",
    "nevertheless , the existence of the isoinitial model can not be always guaranteed and axioms must be added to ensure its existence .    [ [ reuse - mechanisms.-2 ] ] reuse mechanisms . + + + + + + + + + + + + + + + + +    the instantiation is implemented by parameterisation .",
    "a parameter is a sort or a relation between sorts .",
    "additional axioms involving parameters are defined .",
    "the axioms must be satisfied by the instantiation of parameters .",
    "the frameworks composition is likewise .",
    "a parameterised framework @xmath2 may be composed with a parameterised framework @xmath3 if the involved axioms are satisfied .",
    "firstly , a renaming map is defined from @xmath2 to @xmath3 .",
    "the aim is to link each element of the @xmath3 signature to one element of the @xmath2 signature .",
    "then the framework resulting from the composition of @xmath2 and @xmath3 is characterised as follows  : its signature is the renamed signature of @xmath2 and its axioms are the union of the axioms of @xmath2 and @xmath3 .",
    "note that this composition is associative but not commutative .",
    "[ [ tools.-1 ] ] tools .",
    "+ + + + + +    no other tools than those existing in the catalysis approach are used .",
    "[ [ usability.-1 ] ] usability .",
    "+ + + + + + + + + +    this approach formally defines the notions of framework specification , instantiation and composition .",
    "the choice of adapting an existing approach ( catalysis ) is interesting because it avoids the introduction of new languages or tools .",
    "the isoinitial theory chosen for the framework semantics simplifies the soundness proof .",
    "however , additional axioms must be defined in order to ensure that an isoinitial model exists .",
    "furthermore , it requires knowledge about algebraic specification and about isoinitial theories .",
    "the idea of this approach is to formalise with rsl ( raise specification language ) @xcite design patterns described by uml diagrams .",
    "rsl is based on vdm and an algebraic specification language .",
    "[ [ pattern - definition.-3 ] ] pattern definition .",
    "+ + + + + + + + + + + + + + + + + + +    a formal model of pattern is defined .",
    "it represents a pattern as a head , a structure and a list of collaborations .",
    "the head section describes the name , purpose and scope of the pattern .",
    "the pattern structure specifies the classes and associations in rsl . in the last section",
    ", the list of collaborations specifies constraints on the order of operation calls .",
    "[ [ reuse - mechanisms.-3 ] ] reuse mechanisms .",
    "+ + + + + + + + + + + + + + + + +    the instantiation mechanism is implemented by a renaming map .",
    "however , a pattern can be instantiated only once . the resulting rsl specification",
    "can then be extended by new elements .",
    "the composition mechanism is only illustrated through examples .",
    "[ [ tools.-2 ] ] tools .",
    "+ + + + + +    to our knowledge , no tool has been implemented .",
    "[ [ usability.-2 ] ] usability .",
    "+ + + + + + + + + +    patterns for oriented - object programming have been studied extensively in this approach .",
    "that is why a lot of oriented - object programming features have been specified , thus giving specifications described at a low level of abstraction .",
    "the idea in this approach is the definition of a new formal language , lepus ( language for patterns uniform specification ) @xcite , dedicated to the specification of patterns .",
    "this language is based on higher order monadic logic ( homl ) .",
    "[ [ pattern - definition.-4 ] ] pattern definition .",
    "+ + + + + + + + + + + + + + + + + + +    the aim is to formalise the gof patterns .",
    "the main properties of these patterns are expressed by higher order predicates built on higher order sets of classes and methods . a pattern",
    "is then represented by a conjunction of predicates .",
    "new patterns can be defined from existing ones by projection of the higher order sets . roughly speaking , a projection consists in reducing the order of a set .",
    "thus , these patterns are more concrete than the original ones .",
    "[ [ reuse - mechanisms.-4 ] ] reuse mechanisms .",
    "+ + + + + + + + + + + + + + + + +    the instantiation of a pattern consists in instantiating the sets involved in the pattern predicate .",
    "[ [ tools.-3 ] ] tools .",
    "+ + + + + +    to our knowledge , no tool has been implemented .",
    "[ [ usability.-3 ] ] usability .",
    "+ + + + + + + + + +    this approach needs a strong background in mathematics .",
    "moreover , this very formal method is difficult to apply , because the user must exhibit classes , methods and higher order sets in order to define an instance of a pattern . defining a higher order set means defining all the sets with a lower order level and so on up to classes and methods .",
    "table 1 is a comparison between the four above - mentioned approaches and our approach , presented in the next section .",
    "llllll approach & uml - b & framework & rsl & lepus & ours + section & 3.1 & 3.2 & 3.3 & 3.4 & 4 + specification & uml and & algebraic & vdm & homl & b + models : & b machines & specification & & & + direct & uml to b & isoinitial & rsl & conjunction & b machine + definition & translation & theory & formal & of predicates & + of pattern : & & & model & & + pattern & refinement & no & no & projection & no + definition & & & & & + by reuse : & & & & & + instantiation : & uml & parameters & map & parameters & inclusion + & & & & & and renaming + composition : & uml & not & no & no & inclusion and + & & commutative & & & new invariant + extension : & uml & no & yes & no & inclusion and + & & & & & refinement + tools : & uml and & catalysis & no & no & b tools + & b tools & & & + usability & @xmath4 & @xmath4 & @xmath5 & @xmath6 & @xmath4 +    the lepus approach is the most advanced specification method for defining and instantiating design patterns , but it is also the most difficult to apply . the instantiation notion is defined in all the approaches : by the uml instantiation mechanism for uml - b , by parameterised frameworks for catalysis , by a renaming map for rsl and by an instantiation of parameters for lepus .",
    "the composition mechanism seems to be more difficult to define , since only a non commutative operation is defined for frameworks .",
    "the extension is only treated by rsl and uml - b . even if the uml - b approach seems to be close to our work ,",
    "it differs significantly since the reuse mechanisms are not formally defined .",
    "the aim of this section is to investigate the ability of b to specify patterns and the different reuse mechanisms .",
    "we have chosen to consider the b language as it is .",
    "this means that we want to define the reuse mechanisms only with the different b mechanisms such as refinement , inclusion , and so on .",
    "thus , the proofs generated during the reuse process are only those generated by the corresponding b mechanisms .    for each mechanism , we present an implementation in b and its limits .",
    "we refer to the example presented in sect .",
    "the b specification is introduced step by step , the complete specification is given in @xcite .",
    "the last subsection presents a summary of the proof activity generated by the approach .",
    "the way a pattern is defined is strongly dependent on how the reuse mechanisms are defined .",
    "ideally , a pattern should be specified by several machines ( for instance , one machine for each class of the uml diagram ) , all included in a machine which stands for an interface of the pattern ( see uml - b approach in sect",
    ". 3.1 and @xcite ) .    for technical reasons , some b mechanisms such as refinement require the use of a single abstract machine .",
    "consequently , a pattern is specified by a single abstract machine .",
    "this is a first limit of our approach , and perhaps the more annoying one .    in order to implement the composition mechanism ( see sect .",
    "4.3 ) , the given sets of the pattern must be specified as parameters of the machine .",
    "for instance , the * composite * pattern is specified with the following ` composite_pattern ` machine :    composite_pattern(component )    component , composite , leaf , father    component @xmath7 component @xmath8    composite @xmath7 component @xmath8    leaf @xmath7 component @xmath8    father @xmath9 component @xmath10 composite @xmath8    leaf @xmath11 composite @xmath12 component @xmath8    leaf @xmath13 composite @xmath12 @xmath14    ...    children @xmath15 getchild(father ) @xmath12 ...    cpt @xmath15 new_composite(comp ) @xmath12 ...    add_composite(cpt , comp ) @xmath12 ...    leaf @xmath15 new_leaf @xmath12 ...    add_leaf(leaf ) @xmath12 ...    remove_composite(cpt ) @xmath12 ...",
    "remove_leaf(leaf ) @xmath12    * pre * + leaf @xmath9 leaf @xmath8 + leaf @xmath9",
    "dom(father )    * then * + ...    * end *    operation(cpt ) @xmath12 ...    the variables ` component ` , ` composite ` and ` leaf ` represent three classes , while the variable ` father ` stands for the association link between the uml classes ` component ` and ` composite ` ( see sect . 2.1 ) .",
    "the types of the classes and associations are formally specified in the b invariants . in the same way ,",
    "the * resource allocation * pattern is specified in b.    resource_allocation(jobs , category , + facility , resource )    date    joboccurrence , when , jobcategory , resource , resourcefacility ,    job , requirements , provides , allocated    joboccurrence @xmath7 jobs @xmath8    when @xmath9 joboccurence @xmath16 date @xmath8    ...    add_resource(res ) @xmath12 ...    remove_resource(res ) @xmath12    * pre * + res @xmath9 resource    * then * + resource @xmath17 resource @xmath5 @xmath18res@xmath19 @xmath20 + provides @xmath17 @xmath18res@xmath19 @xmath21 provides @xmath20 + allocated @xmath17 allocated @xmath22 @xmath18res@xmath19    * end *    ...      the instantiation mechanism is implemented in b by the inclusion of machines .",
    "the machine corresponding to the pattern is included in the machine corresponding to the instantiation of the pattern .    in the example , the machine ` directory_renaming ` includes the machine of the * composite * pattern .",
    "the given sets , defined as parameters of the machine , can be renamed by instantiation of the parameters . in our example , ` component ` is renamed by ` element ` :    directory_renaming    element    composite_pattern(element )    ...    the * definitions * clause allows us to rename variables from the included machine . `",
    "composite ` and ` leaf ` are respectively renamed by ` directory ` and ` file ` .",
    "directory @xmath23 composite    file @xmath23 leaf    renaming operations is not so straightforward .",
    "there are two cases .",
    "firstly , if an operation is directly reused without renaming we use the * promotes * clause .",
    "secondly , a renamed operation is specified in the * operations * clause .",
    "it consists of a call statement to the corresponding pattern operation . in our example , the ` remove_leaf ` operation is renamed by ` remove_file ` :    remove_file(file ) @xmath12    * pre * + file @xmath9 file @xmath8 + file @xmath9 dom(father )    * then * + remove_leaf(file ) /@xmath24 operation defined in composition_pattern @xmath24/    * end *    the preconditions must be the same as those of the called operation , except that the variables and sets are the renamed ones .",
    "a first step is to precisely define the composition mechanism .",
    "we distinguish three levels of composition according to whether or not there exist links between the composed patterns . in the three cases ,",
    "composition is achieved by the inclusion mechanism of b : all the machines representing the composed patterns are included in the machine representing the composition , called the composition machine .    [",
    "[ juxtaposition . ] ] juxtaposition .",
    "+ + + + + + + + + + + + + +    patterns are composed without defining any link between them .",
    "this composition is only a juxtaposition of each pattern .",
    "we use the * extends * mechanism which allows all the operations of the two composed patterns to be considered as genuine operations of the composition machine :    composition_by_juxtaposition    component ; jobs ; category ; facility ; resource    composite_pattern(component ) ,    resource_allocation(jobs , category , facility , resource )    ...    [ [ composition - with - inter - patterns - links . ] ] composition with inter - patterns links .",
    "+ + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + +    new relations between variables of the composed patterns can be added .",
    "for instance , a bijection called ` compres ` may be defined between ` component ` ( from ` composite_pattern ` ) and ` resource ` ( from ` resource_allocation ` ) .",
    "composition_by_interpatterns_links    component ; jobs ; category ; facility ; resource    composite_pattern(component ) ,    resource_allocation(jobs , category , facility , resource )    compres    compres @xmath9 component @xmath25 resource    according to the type of the new variables , the operations of the composed patterns involving the linked variables must be modified .",
    "for instance , the operation ` remove_leaf ` from ` composite_pattern ` removes a ` leaf ` from ` component ` .",
    "this operation can not be only renamed in the machine ` composition_by_interpatterns_links `",
    ". it must be composed with the operation ` remove_resource ` from ` resource_allocation ` and with a substitution on the variable ` compres ` in order to preserve the new invariant .",
    "the resulting operation is ` remove_thing_1 ` :    remove_thing_1(thing ) @xmath12    * pre * + thing @xmath9 leaf @xmath8 + thing @xmath9",
    "dom(father )    * then * + remove_leaf(thing ) @xmath20 + remove_resource(compres(thing ) ) @xmath20 + compres @xmath17",
    "@xmath18thing@xmath19 @xmath21 compres    * end *    a composition mechanism between operations must be defined .",
    "it could be automated provided that each composed pattern specifies the elementary operations to be composed on each variable .",
    "other operations of the composed patterns can be promoted to become genuine operations of the composition machine .",
    "[ [ unification . ] ] unification .",
    "+ + + + + + + + + + + +    this composition allows some variables of the composed patterns to be merged . up to now",
    ", only variables corresponding to classes or associations in the patterns may be unified .",
    "this property is specified in the * invariant * clause of the composition machine .",
    "two variables may be unified only if they have the same type , that is why we need to define the given sets as parameters of a pattern machine ( see sect .",
    "4.1 ) . for example",
    ", we can compose the two patterns ` composite_pattern ` and ` resource_allocation ` by unifying the variables ` component ` and ` resource ` .",
    "this yields the following machine :    composition_by_unification    element ; jobs ; category ; facility    composite_pattern(element ) ,    resource_allocation(jobs , category , facility , element )    component @xmath12 resource    let us note that the parameters ` component ` and ` resource ` are now replaced by the same set called ` element ` .    as in the composition by inter - patterns links , operations of the composed patterns involving the unified variables must be redefined .",
    "the operation ` remove_leaf ` involves the variable ` component ` which is now unified with ` resource ` .",
    "then the operation resulting from the composition is :    remove_thing_2(thing ) @xmath12    * pre * + thing @xmath9 leaf @xmath8 + thing @xmath9 dom(father )    * then * + remove_leaf(thing ) @xmath20 + remove_resource(thing )    * end *    from a methodological point of view , an instantiation and a composition can be achieved in one step , before applying the extension mechanism . for the next subsection , we assume that firstly we have composed the two patterns ` composite_pattern ` and ` resource_allocation ` by unifying the variables ` component ` and ` resource ` and secondly instantiated them by renaming elements with the names used in the class diagram of fig .",
    "the resulting b machine is called ` comp_by_unif_inst ` :    comp_by_unif_inst    element ; jobs ; category ; facility    composite_pattern(element ) ,    resource_allocation(jobs , category , facility , element )    directory @xmath23 composite ;    file @xmath23 leaf ;    secretaryjobs @xmath23 joboccurrence ;    secretary @xmath23 jobcategory ;    filefacility @xmath23 resourcefacility ;    filerequirements @xmath23 requirements ;    element @xmath23 resource    component @xmath12 resource    ...    getchild    dir @xmath15 add_directory(files ) @xmath12 ...    file @xmath15 add_file @xmath12 ...    remove_directory(dir ) @xmath12 ...    remove_file(file ) @xmath12 ...    ...    in this machine , the above - mentioned operation ` remove_thing_2 ` is renamed by ` remove_file ` .",
    "most often an extension consists in defining new variables , modifying existing operations to take into account these new variables and adding new operations , in the result of a composition and/or an instantiation , specified in a b machine called the before - extension machine .",
    "two solutions exist to implement this mechanism in b , with arguments on both sides .",
    "the first solution consists in including the before - extension machine into a new machine .",
    "the main drawback is that we can not modify an included operation .",
    "then , if we want to modify an operation of the before - extension machine , we need to rename it .",
    "we prefer using the refinement mechanism with the idea of adding more details to a specification .",
    "we will see later the limits of the refinement mechanism .",
    "let us take our example : the machine ` comp_by_unif_inst ` which is the before - extension machine is refined by the machine ` extension ` .",
    "extension    comp_by_unif_inst    element ; jobs ; secretary ; filefacility ; + state @xmath12 @xmath18write , protected@xmath19    composite_pattern(element ) ,    resource_allocation(jobs , secretary , filefacility , + element )    state , usable    usable @xmath7 element @xmath8    state @xmath9 usable @xmath26 state    usable , state @xmath17 @xmath14,@xmath14    ...    existing operations may be extended in only one way : new substitutions using the new variables can be specified .",
    "for instance , ` remove_file ` is refined by :    remove_file(file ) @xmath12    * pre * + file @xmath9 file @xmath8 + file @xmath9 dom(father )    * then * + remove_leaf(file ) @xmath20 remove_resource(file ) @xmath20 + usable @xmath17 usable @xmath5 @xmath18file@xmath19 @xmath20 state @xmath17 @xmath18file@xmath19 @xmath21 state    * end *    new operations can not be added during the refinement process .",
    "thus , in order to define a new operation , two solutions are possible . either the before - extension machine is extended with the * extends * clause , to add new operations , specified as `` skip '' . or the before - extension machine is modified by adding these new operations also specified as `` skip '' . for the sake of concision",
    ", we present the second option . then , in both cases , each new operation is refined with new substitutions involving only new variables that are not related to variables in the gluing invariant and with calls to operations of the included machines .",
    "the refinement is then correct .    in our example , the new operation ` protect_element ` sets the state of an element to ` protected ` .",
    "this operation is defined in the ` comp_by_unif_inst ` machine by :    protect_element(el ) @xmath12    * pre * + el @xmath9 element    * then * + skip    * end *    the operation is then refined in the machine ` extension ` by :    protect_element(el ) @xmath12    * pre * + el @xmath9 element    * then * + state(el ) @xmath17 protected @xmath20 usable @xmath17 usable @xmath11 @xmath18el@xmath19    * end *      the machines corresponding to the different patterns ( ` composite_pattern ` and ` resource_allocation ` ) have been proved with the atelier b @xcite ( see tab .",
    "2 ) . we will now present a summary of the proofs generated by the reuse mechanisms .",
    "the instantiation mechanism does not generate new proof obligations since nothing new has been specified . by construction ,",
    "operations are automatically proved .",
    "thus the proofs of the machine corresponding to an instantiation are obvious : they have already been proved in the included machine .",
    "the composition by juxtaposition of different machines gives a machine which is automatically proved , since nothing new has been specified .",
    "the compositions with inter - patterns links and by unification generate proof obligations which are to be automatically discharged if the composition of operations has been correctly elaborated .    for the extension mechanism , the new proof obligations concern , on one hand , the invariants and operations which have been added and , on the other hand , the refinement of the modified operations .",
    "table 2 summarises the proofs of the example described in sect . 4.4 .",
    "* nobv * is the number of obvious proofs generated and trivially discharged by the atelier b. * npo * represents the number of proof obligations ( po ) to discharge .",
    "* naut * represents the number of pos automatically discharged and * nint * the number of pos interactively discharged .",
    "all the interactive proofs have been discharged .",
    ".proofs result [ cols=\"<,>,>,>,>\",options=\"header \" , ]     for the same example , the ` direct_example ` machine obviously requires less proof activity than with our pattern reuse method , since only one abstract specification is used compared to the two specification patterns , the before - extension machine and the refinement used in our approach .",
    "however , if we assume that the two specification patterns are previously specified and proved , our approach requires only forty - three pos ( @xmath27 ) which have to be compared to the eighty - seven for the direct specification .",
    "moreover , once pos have been automatically discharged , only ten pos ( @xmath28 ) must be interactively proved in our approach by pattern reuse , compared to the twenty pos that must be interactively discharged for the ` direct_example ` machine .    in conclusion , since four pos are `` reusable '' in our approach , the reuse of specification patterns to specify the example described in sect .",
    "2.2 allows us to save fourteen pos to interactively discharge , provided that the two specification patterns ` composite_pattern ` and ` resource_allocation ` are previously specified and proved .",
    "let us note that the ` direct_example ` machine is inspired by the result of the specification by pattern reuse described in fig .",
    "one would have undoubtedly specified the same example differently and consequently the generated proofs could be different .",
    "in this paper , we have presented an approach for reusing patterns with the b method .",
    "we have implemented the different mechanisms linked to the reuse of patterns by using only the b mechanisms .",
    "it is interesting because the mechanisms are formally defined and we can benefit from the advantages of the b method , especially the `` reuse '' of proofs and the tool .",
    "there are two major drawbacks .",
    "the first one is that a pattern is defined in one machine , which can produce a big machine , difficult to read and maintain .",
    "the second one is the obligation of defining the new operations of an extension before actually applying the extension mechanism .    concerning the pattern reuse mechanisms ,",
    "the composition of several instances of the same pattern has not been studied .",
    "we also have to precisely define the mechanism of operations composition .",
    "the following necessary step will be the development of a tool to assist the designer during the specification of an application by pattern reuse .",
    "the example presented in this paper is rather simple .",
    "however , the used patterns are those described in @xcite , which are patterns largely tested in real designs .",
    "a more complex example just involves more patterns but the method presented in the paper is still applicable , provided that a tool is available .    in this paper ,",
    "we have introduced the notion of reuse of proofs .",
    "the aim is to define the notion of proof linked to a machine and to specify the reuse of proofs with the b method .",
    "this perspective is new , since the reuse of proofs is not possible with a formal method like b. however , such a possibility requires several works on new examples in order to analyse the consequences on the proof obligations .",
    "blazy , s. , gervais , f. , laleau , r. : un exemple de rutilisation de patterns de spcification avec la mthode b. techn . rep . *",
    "395 * , cedric laboratory , vry , france , 2002 .",
    "available at ` http://cedric.cnam.fr/publis/rc395.ps.gz `                  laleau , r. , mammar , a. : an overview of a method and its support tool for generating b specifications from uml notations .",
    "ase : 15th ieee conference on automated software engineering , ieee computer society press , grenoble , france , september 2000 .",
    "lau , k. , ornaghi , m. : ood frameworks in component - based software development in computational logic .",
    "lopstr98 , lncs * 1559 * , pages 101123 , springer - verlag , 1999 , manchester , united kingdom , june 15 - 19 , 1998 .",
    "marcano , r. , meyer , e. , levy , n. , souquieres , j. : utilisation de patterns dans la construction de spcifications en uml et b. proc .",
    "afadl2000 : approches formelles dans lassistance au dveloppement de logiciels , tech .",
    "* a00-r-009 * , lsr laboratory , grenoble , france , january 26 - 28 , 2000 .",
    "marcano - kamenoff , r. , levy , n. , losavio , f. : spcification et spcialisation de patterns en uml et b. proc .",
    "lmo2000 : langages et modles  objets , herms science publications , mont saint - hilaire , qubec , canada , january 25 - 27 , 2000 .",
    "nguyen , h.p .",
    ": drivation de spcifications formelles b  partir de spcifications semi - formelles . ph.d .",
    "thesis , cedric laboratory , cnam , vry , france , 1998 .",
    "available at ` http://www.iie.cnam.fr/~laleau/ `"
  ],
  "abstract_text": [
    "<S> this paper describes an approach for reusing specification patterns . </S>",
    "<S> specification patterns are design patterns that are expressed in a formal specification language . reusing a specification pattern means instantiating it or composing it with other specification patterns . </S>",
    "<S> three levels of composition are defined : juxtaposition , composition with inter - patterns links and unification . </S>",
    "<S> this paper shows through examples how to define specification patterns in b , how to reuse them directly in b , and also how to reuse the proofs associated with specification patterns .    </S>",
    "<S> * keywords : * design pattern , specification pattern , reuse , b. </S>"
  ]
}