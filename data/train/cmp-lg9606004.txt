{
  "article_text": [
    "recent computational linguistics research of natural language lexicons has gone beyond simply listing idiosyncratic information about words .",
    "many researchers are adding structure to their lexicons to replace the old practice of simply listing , in an entry for a word , all its properties .",
    "this structure often takes the form of feature - based default inheritance hierarchies (  @xcite ) .",
    "after such hierarchies have been designed , the task of placing word entries under the appropriate classes begins .",
    "the problem we address in this paper is deciding where to place a new object in an inheritance hierarchy  we will call this ` the insertion problem . '",
    "this problem has received little attention in the literature ; to our knowledge this paper is the first to formalize the problem and to provide a general algorithm for it .",
    "an example of the insertion problem is the task of placing a verb into the hierarchy presented in fig.[flick ] .",
    "the upper case symbols ( , control ) are class names and the pairs written directly below these names represent features that can be inherited from them . for example , all the features of incomplete are inherited by equi  unless overridden by features in control or in equi .",
    "consider the form of _ give _ exemplified in _",
    "she gave him the ball _ and assume that it has the following features .",
    "[ givefeats ]    aaa= [ subj / cat , n ] [ subj / case , nom ] [ subj / complete,+ ] [ dobj / cat , n ] + [ dobj / case , acc ] [ dobj / complete,+ ] [ iobj / cat , n ] [ iobj / case , acc ] [ iobj / complete,+ ]    a solution to this instance of the insertion problem would be to place _ give _ under the transitive and 3 - 1 classes . by doing so ,",
    "all of the features listed above could be inherited except [ iobj / cat , n ] .",
    "this feature would have to be listed directly in the entry for _ give _ so that the incorrect default inheritance of [ iobj / cat , p ] from the 3 - 1 class would be blocked .",
    "thus , only three pieces of information need to be listed in the entry for _ give _ : it inherits from transitive , it inherits from 3 - 1 , and it has the feature [ iobj / cat , n ] . notice that if we had inserted the entry under any other set of classes , more information would have had to be listed in the entry .",
    "a central characteristic of a good insertion is that it minimizes the amount of information that needs to be listed in the entry .    in this paper",
    ", we will focus on feature - based default inheritance hierarchies : feature - based in that attribute / value pairs are used to encode characteristics of a class and default in that all inheritance relationships are defeasible .",
    "we will also assume that multiple inheritance is allowed : classes can inherit from more that one superclass .",
    "however , the results described in this paper are relevant to * any * system that utilizes defaults and for which inconsistency between two elements that are inherited can be discovered efficiently .",
    "the rest of this paper is structured as follows .",
    "first , we give an informal characterization of the insertion problem and argue that this characterization captures the relevant aspects of the problem .",
    "second , we formalize this characterization",
    ". the problem , so defined , is np - complete @xcite and , thus , it is unlikely that a computationally tractable algorithm for its solution will be found .",
    "next , we describe an approximation algorithm for the problem and through complexity analysis and discussion of preliminary experimentation , we argue that this algorithm produces reasonable results in an acceptable amount of time and space .",
    "the algorithm has been implemented and has produced good results in experiments involving inserting words into lexical hierarchies .",
    "as mentioned above , a good insertion places an object under classes from which it can inherit most of its features .",
    "in addition , it should use as few classes as possible to achieve this goal .",
    "these two requirements are aspects of a basic principle of classification schemes : reduce redundancy .",
    "a corollary of this principle is that a good insertion should minimize the amount of information stored in the entry for the object being inserted and thereby maximize the use of the information contained in the inheritance relationships .",
    "three types of information are stored in an entry : its superclass(es ) , the features that are not inherited from any superclass , and the features that are needed to block an incorrect inheritance .",
    "thus , an optimal insertion has the smallest possible value for the following sum ( which we will refer to as the cost of the insertion or solution ) .",
    "[ informsum ]    aaa= number of superclasses + number of object features not in these superclasses + + the number of object features that must be listed to block incorrect inheritance    at first glance , one might think that one easy way to find an optimal solution is to start at the roots of the hierarchies that make up a structured lexicon and simply walk down these hierarchies , pruning off the branches below a class that contains a feature that the object does not have ( since all classes below this class will also have this feature ) .",
    "this approach will work for _ strict _ inheritance hierarchies .",
    "strict hierarchies do not allow default inheritance  all the subclasses below a given class have to inherit all its features .",
    "the algorithm outlined above uses this characteristic to cut down the search space for superclasses .",
    "however , default hierarchies do not have this characteristic : if a class a inherits from a class b , the set of features associated with a might not be a superset of the set associated with b. thus , an insertion algorithm for default hierarchies can not ignore a as a possible superclass for an object simply because it has decided b is unsuitable ; a might be an exception to b in just the right ways .",
    "because of these considerations , for the purposes of insertion , we make the following claim : each class in a default hierarchy should be viewed as the set of features that can be inherited from this class .",
    "this claim is central to the approach to insertion taken in this paper .",
    "it amounts to ` compiling out ' the inheritance relationships so that a hierarchy becomes a set of sets of features .",
    "compiling out the inheritance relationships is a process of pushing features down the inheritance links to the classes below so that all the features of a class are _ explicitly _ listed in the data structure for the class .",
    "for example , compiling out the hierarchy in fig .  [ flick ] would produce the set of sets listed in ( [ compn ] ) .",
    "the first set corresponds to the complementation class , the second to incomplete , the third to complete , and the fourth to transitive .    [ compn ]    aaa= a= a= \\{\\ { } + \\{[complete,- ] [ subj / cat , n ] [ subj / case , nom ] [ subj / complete,+ ] } + \\{[complete,+ ] } + \\{[complete,- ] [ subj / cat , n ] [ subj / case , nom ] [ subj / complete,+ ] + [ dobj / cat , n ] [ dobj / case , acc ] [ dobj / complete,+ ] } .... }    by compiling out a hierarchy , one loses inheritance relationships between classes . however , since a good insertion minimizes the space needed to store the properties of the object being inserted , with respect to insertion , a class is simply a chance to save space by storing one class name instead of a number of features . thus ,",
    "what features can be inherited from a class is the only characteristic of a class relevant to insertion . as a result ,",
    "when dealing with the insertion problem in default hierarchies , one should think of the hierarchy as a set of sets , each of which corresponds to a possible superclass of the object being inserted .",
    "the insertion problem , then , amounts to picking an optimal subset of this set of sets ; the definition of optimal remains the same .",
    "in this section , we will formalize the intuitive characterization of the previous section .",
    "the first task is to give a formal characterization of the features we have been discussing informally in the previous section .",
    "a feature is a pair of atomic symbols (   [ a , v ] ) .",
    "the first element is taken from a set of attributes ( attributes ) and the second from a set of values ( values ) ; these sets may be infinite .",
    "the set values includes a symbol ? which intuitively specifies that the corresponding attribute is undefined or unknown for the object with the feature , more on this later .",
    "two features clash ( , are inconsistent ) if their attributes are the same but their values are different ; this definition also holds for the value ? .",
    "note that testing if two features clash can be done in constant time .",
    "we will use _ clash _ to denote a binary function on sets of features that produces the subset of features from the first set that are in conflict with a feature of the second ( see below ) .",
    "[ clash ]    aaa= a = \\{[a1,v1][a2,v2][a3,v3][a4,v4 ] } + b = \\{[a1,v5][a2,v2][a3,v20][a7,v7][a9,v12 ] } + ( a , b ) = \\{[a1,v1][a3,v3 ] }    we assume that the sets of features are internally consistent , , each set contains at most one feature per attribute .",
    "@xmath1 can be computed for the finite sets @xmath2 and @xmath3 in @xmath4 time by simply testing every pair formed from an element from @xmath2 and an element of @xmath5 for a clash .",
    "although we will work with this specific feature system , the algorithms and proofs that we present here , generalize to any system for representing _ what _ is inherited with the following property : whether two inheritable elements clash can be computed in time polynomial in the size of the elements .",
    "features systems used in natural language processing often have this property ( polynomial - time unification algorithm ) .",
    "the next task is to further specify the hierarchies to be used . as mentioned above",
    ", we are concerned with feature - based default multiple inheritance hierarchies .",
    "in addition , we assume that the hierarchies are unambiguous : for any given attribute , a node only inherits one value for it .",
    "we will discuss the issue of ambiguity with respect to insertion below .",
    "we also assume , for expository reasons , that the feature sets inheritable from the classes are unique : that a given set of features can not be inherited from more than one class in a hierarchy .",
    "further , we are concerned with cautious insertion : only the known features of the object being inserted should be inherited .",
    "an adventurous insertion would allow an object class to inherit extra features from its superclasses . in order to deal with the problem of inheriting extra features from superclasses",
    ", we will use the value ? in features to block unwanted inheritance .",
    "we will call such features ` ? -features . '",
    "only object classes are allowed to contain ?",
    "fig.[advcau ] illustrates both forms of insertion and the use of the ? value . in adventurous insertion",
    ", object1 would have the feature [ a3,v3 ] whereas with cautious insertion , its inheritance would be blocked by [ a3 , ? ] .    in the previous section , we defined the insertion problem so that solutions could be incomplete : not all the features of the object being inserted need be inherited . of course , a solution pays a price for forcing a feature to be listed in the object class .",
    "the second term of the sum in ( [ informsum ] ) specifies the price paid . because of the possible existence of clashes ( the third term )",
    ", an optimal solution may be incomplete .",
    "such incomplete insertions complicate the reduction needed to prove np - completeness and the statement of the insertion algorithm . to circumvent this difficulty ,",
    "we assume that all hierarchies contain a singleton class for each non-?-feature of the object being inserted .",
    "( we will leave these sets out of the figures of this paper . )",
    "a singleton class is a class from which exactly one feature can be inherited and which has no superclasses and no subclasses other than object classes . listing a singleton class as a superclass in an object class is equivalent to simply listing the feature of the singleton class .",
    "this assumption allows us to require complete insertions while still being able to represent the notion of incomplete insertion .",
    "an instance of the insertion problem ( ) is a pair made up of a set @xmath6 and a set @xmath7 as defined below .",
    "note that only a finite number of features is needed to specify @xmath6 and that there is a one - to - one mapping between the sets in @xmath7 and the classes of the hierarchy .",
    "if we return to our discussion of the hierarchy in fig.[flick ] , we see that the set of features of _ give _ , listed in ( [ givefeats ] ) , plus the appropriate ?",
    "-features , is @xmath8 for this hierarchy .",
    "the set of sets of features in ( [ compn ] ) that resulted from compiling out the hierarchy , plus singleton sets for the features of @xmath8 , is @xmath9 .",
    "a solution is a set @xmath10 .",
    "@xmath0 represents the superclasses for the object whose features are @xmath11 .",
    "every non-?-feature in @xmath6 must be an element of either a set in @xmath0 or @xmath12 . where @xmath13 is a set of sets @xmath14 is equal to @xmath15 . ] the features in this latter set have to be listed explicitly for the object in order to override incorrect inheritance .",
    "an optimal solution minimizes the number of superclasses together with the number of clashes between these superclasses and @xmath6 : @xmath16 an approximation algorithm for -------------------------------    as mentioned above ,  is np - complete .",
    "thus , the best one should hope for is a computationally tractable algorithm that produces _ near _ optimal solutions .",
    "part of the np - completeness proof is a relatively straightforward reduction of the np - complete set covering ( ) problem .  is defined as follows    _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ `` ... the set - covering problem consists of a finite set @xmath6 and a family @xmath7 of subsets of @xmath6 , such that every element of @xmath6 belongs to at least one subset of @xmath17 ... we say that a subset @xmath18 @xmath19 @xmath7 covers its elements . the problem is to find a minimum - size subset @xmath20",
    "whose members cover all of @xmath6 . ''",
    "( @xcite , p.974 , we have substituted variable names analogous to those in ) . _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _    can be viewed as extending  in two ways .",
    "first , it substitutes features for integers .",
    "features introduce the possibility of clashes between elements .",
    "this makes the process of choosing @xmath21 more complex since one must take into account features clashed with as well as features covered .",
    "second , intuitively ,   loosens the restriction that all non-?-elements in @xmath8 must be covered .",
    "however , our formalization technically requires complete coverage but retains the ability to represent incomplete covers since listing a singleton set in the object class is equivalent to listing an uncovered feature .",
    "a polynomial time approximation algorithm exists for  and the solutions it produces are guaranteed to be close to the optimal solution .",
    "more formally , the ratio of the size of the approximate solution produced by the algorithm to the optimal solution is bounded by the natural logarithm of the size of the set being covered @xcite : @xmath22 .",
    "this approximation algorithm is greedy : at any given point , it picks the subset that can cover the most features at that time and it never goes back on this choice .",
    "greedy algorithms tend to be fast but , since they can not backtrack , they can make local choices that prevent globally optimal solutions .",
    "because of the similarities between  and , it seems likely that a greedy approximation algorithm will produce good solutions for .",
    "just such an algorithm , , is listed below",
    ".  takes as input the set of features of the object being inserted , @xmath6 , and a set of sets of features , @xmath7 , that represents the classes of the hierarchies .",
    "it produces as output , a list of superclasses and a list of features that must be listed locally for the object . during each iteration of its main loop ( lines  4 - 9 )",
    ", it picks the most suitable superclass ( line  5 ) .",
    "the features from @xmath6 that can be inherited from the new superclass @xmath18 combined with those that must be listed to block incorrect inheritance are subtracted from @xmath6 .",
    "this loop is repeated until there is no class in @xmath7 from which more features can be inherited than must be listed to block incorrect inheritance .",
    "the algorithm returns the superclasses along with features that must be listed to block incorrect inheritance . to pick the most suitable superclass",
    ", a subroutine is called for each class remaining in @xmath7 that computes the difference between the number of features remaining in @xmath6 that can be inherited from the class and the number of new features that would be incorrectly inherited .",
    "as expected ,  runs in time polynomial in the size of the encoding of the input pair @xmath6,@xmath7 , more specifically , @xmath23 where @xmath24 represents the set of non-?-features in @xmath6 . the space complexity is also polynomial in the size of the input : @xmath25 where @xmath26 is the largest element of @xmath7 .    has been implemented and tested on a number of datr @xcite lexical hierarchies .",
    "testing consisted of enumerating the features of a small number of words by hand , inserting the words into the hierarchies by hand , running  on the words , and then comparing the insertions .",
    "was extremely fast and produced insertions that in most cases were very close to those done by hand .",
    "although these results are encouraging , we can , at this point , offer neither extensive experimental results showing good performance nor a theoretical proof of a logarithmic ratio bound for .",
    "instead , we will discuss the basic situation that causes sub - optimal results to be produced by greedy algorithms .",
    "in addition , we will discuss how the algorithm performs with respect to two standard problems for default inheritance hierarchies taken from @xcite : redundant links and nixon diamonds . a system that utilizes default inheritance hierarchies must address these problems since , if left unattended , they can produce inconsistencies and/or unexpected behavior in the system .",
    "an example of the basic sub - optimal solution producing situation is presented below .",
    "[ basic ]    aaa= a : [ a1,v1][a2,v2][a3,v3][a4,v4 ] + b : [ a1,v5][a2,v2][a3,v20][a7,v7][a9,v12 ] + c : [ a3,v3][a4,v4][a6,v6 ] + @xmath6 = \\{[a1,v1][a2,v2][a3,v3][a4,v4][a5,v5][a6,v6 ] }    the problem here is that class a is seductive ; it covers a large number of features from @xmath6 , more than b or c. however , if a is chosen it is still necessary to pick b and c or the two appropriate singleton sets to cover the features not covered by a : [ a5,v5 ] and [ a6,v6 ] .",
    "if an algorithm can withstand the temptation of class a and instead go with b or c , this algorithm is rewarded by simply choosing the other class ( either b or c ) to cover the rest of @xmath6 .",
    "however ,  falls for sets like a every time .",
    "one can tweak the selection criteria for the winning node ( line  5 ) to produce an optimal solution for any given instance .",
    "however , in general , it is always possible to come up with an instance for which these new criteria produce a sub - optimal result .",
    "this is due to the fact that the central characteristic of the algorithm stays the same : decisions are made with only local information and no backtracking is performed .",
    "note that such problematic instances do not seem to cause  to produce wildly incorrect solutions , simply slightly sub - optimal ones .",
    "another situation that is problematic for  is illustrated in fig.[redun1 ] .",
    "the compiled - out set , @xmath7 , ( minus the singleton sets ) for this hierarchy is listed in ( [ redunn ] ) where the first set corresponds to a and the second to b.    [ redunn ]    aaaaaa@xmath7 = \\{\\{[a1,v1 ] [ a2,v2 ] [ a3,v3 ] [ a4,v4 ] [ a5,v5 ] [ a6,v6 ] [ a7,v7 ] } + \\{[a1,v1 ] [ a2,v2 ] [ a3,v3 ] [ a4,v4 ] [ a5,v12 ] [ a6,v13 ] [ a7,v14 ] + [ a8,v8 ] [ a9,v9 ] [ a10,v10 ] [ a11,v11 ] [ a12,v12 ] } }    during the first iteration of the main loop of , a will be selected to be a superclass since it will have a score of 7 whereas b will only have a score of 6 . in the next round , however ,",
    "b will be chosen since it will then have a score of 2 which is higher than the scores obtained by the singleton sets . at this point all the features of @xmath6 will be covered .",
    "thus , the insertion for the object will list a and b as parents and the following features [ a5,v5 ] , [ a6,v6 ] , [ a7,v7 ] .",
    "the link from the object class to a is known as a redundant link because there is already a path to a through b. however , notice that the features that end up on the object class are the correct ones ; no inconsistencies exist .",
    "this is a result of the way clashes are handled .",
    "notice also that the solution is sub - optimal .",
    "the optimal insertion would list the same three features but only inherit from b ; the link to a could be removed without changing the features of the object class .",
    "contrary to our earlier claim that each class in a default hierarchy should be viewed as the set of features that can be inherited from this class , it appears that fig.[redun1 ] illustrates a case where the inheritance links between classes are relevant for insertion .",
    "one approach to this problem is to use weights on features in the sets of @xmath7 to encode the relevant hierarchical structure of the classes .",
    "these weights would be added during the compilation process ; the weight of a feature would start at 1 in the class where it originates and would then increase slightly each time it is passed down to a lower class . in line  5 of the algorithm , the weights would cause lower classes would be favored over higher ones . alternatively",
    ", a post - processing algorithm could be used to search for and eliminate redundant links . in any case ,",
    "redundant links are a problem for  as it currently stands .",
    "the second standard problem for default inheritance hierarchies occurs when an object class inherits from two classes each of which has a different value for the same attribute .",
    "this problem is known as the nixon diamond and the standard example is that richard nixon was both a republican and a quaker .",
    "republicans believe military force has to be used sometimes whereas quakers do not .",
    "thus , it is unclear what features the object class nixon should have .",
    "the question here is whether  ever produces such situations .",
    "the answer is no . because clashes are handled by listing locally the correct feature and because @xmath6 is filled out by ?",
    "-features , it is not possible for a nixon diamond to result from a  insertion : when inserting nixon , regardless of which class is chosen first , [ miluse , ? ] will be listed in the nixon object class , thereby blocking any inheritance of a feature with the miluse attribute .",
    "we started this paper by discussing informally the problem of deciding where an object belongs in a feature - based default inheritance hierarchy .",
    "this is an important problem but one that has , to our knowledge , received little attention in the literature .",
    "we formalized this problem as .",
    "a crucial aspect of this formalization is that the hierarchy is viewed as a set of unrelated sets of features .",
    "two facts combine to support this claim : i ) a good insertion minimizes the space needed to store the object and thus , a class is seen as an opportunity to replace the listing of a number of features by a single superclass , ii ) the structure of a default hierarchy can not be used to reduce the search space of potential superclasses . because  is np - complete , we designed an approximation algorithm for it .",
    "we showed that this algorithm is efficient and that it performs well with respect to a pair of standard problems for default inheritance .",
    "the ideas about insertion discussed here grew out of the need for a way to move data from the elwis database to inheritance hierarchies .",
    "the insyst project prototype mentioned above is a first attempt at implementing such a system .",
    "the insyst project was a joint effort between sabine reinhard , marie boyle - hinrichs , and myself .",
    "marie boyle - hinrichs was responsible for the implementation of the insyst prototype .",
    "i would like to thank both of them for their efforts and their support of my own .",
    "both elwis and insyst were developed at the university of tbingen under the supervision of erhard hinrichs .",
    "i would like to thank him for the opportunity to spend a summer in tbingen working on these projects .",
    "i would like to thank lenhart schubert for reading many versions of this report and providing invaluable comments .",
    "i would also like to thank chris barker , george ferguson , dafydd gibbon , sabine reinhard , and mark young for their comments on earlier versions of this report .",
    "finally , i would like to thank yenjo han , leonidas kontothanassis , jeff schneider , and paul dietz for their help with the initial design and analysis of ."
  ],
  "abstract_text": [
    "<S> increasingly , inheritance hierarchies are being used to reduce redundancy in natural language processing lexicons . </S>",
    "<S> systems that utilize inheritance hierarchies need to be able to insert words under the optimal set of classes in these hierarchies . in this paper </S>",
    "<S> , we formalize this problem for feature - based default inheritance hierarchies . </S>",
    "<S> since the problem turns out to be np - complete , we present an _ approximation _ algorithm for it . </S>",
    "<S> we show that this algorithm is efficient and that it performs well with respect to a number of standard problems for default inheritance . </S>",
    "<S> a prototype implementation has been tested on lexical hierarchies and it has produced encouraging results . </S>",
    "<S> the work presented here is also relevant to other types of default hierarchies .    </S>",
    "<S> @xmath0 [ example ] </S>"
  ]
}