{
  "article_text": [
    "the wfcam science archive (; hambly et al .",
    "2007 , collins et al . 2006 ) holds the image and catalogue data products generated by the wide field camera ( wfcam ) on ukirt ( united kingdom infrared telescope ) .",
    "the data comprise pipeline processed multi - extension fits files ( multiframes ) containing pixel / image and catalogue data for four detectors at one pointing .",
    "the latter contains all detections of stacked multiframes .",
    "the data are pipeline processed at the cambridge astronomical survey unit ( casu ) and transferred to edinburgh where the wide field astronomy unit ( wfau ) processes it for ingestion into the database . since the release database contains advanced products which can take a lot of cpu time to produce , it is preferable to carry out the ingest procedure as fast as possible .",
    "another aspect is that the pixel / image and catalogue data need to be ingested completely before further processing is done .",
    "another constraint is the uniqueness of multiframes and detections .",
    "each multiframe has to have a unique identifier across the whole database and each detection must be unique for a given survey .",
    "to ingest the large amount of data into the wsa as the first stage in building a release database , a set of curation usecases ( cus ) have been designed . they are coded in a python / c++ environment , where c++ is used where high performance is needed and python to facilitate an easy to use object - oriented environment .",
    "table  [ tab : p4.1_tab1 ] shows an overview of the ingest cus and the average volume of data to be processed per observing night .",
    "lll 1 & data transfer from casu to wfau & @xmath0  gbyte + 2 & creation of compressed images ( jpegs ) & @xmath1  jpegs + 3 & & @xmath2  files + 4 & & @xmath3  detections +    in the following we will concentrate on cus 2 to 4 , as the data transfer ( cu1 ) is described in detail in bryant et al .",
    "after transfer the data are split into daily chunks and then processed on multiple computers .",
    "+ the following dependencies need to be observed to avoid duplicate entries or missing data .",
    "each fits file gets assigned a unique multiframe i d associating data across the database with its source .",
    "also each object in a catalogue gets assigned a unique object i d associating data across the database with its original detection . to update the database with the paths to compressed images ( cu2 ) , the general fits file metadata has to be ingested beforehand ( cu3 ) . and",
    "finally catalogue data can only be processed ( cu4 ) if the corresponding image metadata is available ( cu3 ) .",
    "the normal procedure of executing the cus for small amounts of data would comprise of a run of each cu followed by an ingest as shown in figure  [ fig : p4.1_fig1 ] .",
    "this might then be followed again by the whole procedure for the next batch of data .",
    "as the creation of compressed images ( cu2 ) itself can be done independently , it can be decoupled from image and catalogue data processing . since",
    "this procedure is linear , unique ids for pixel files and catalogue detections are applied during cu3 and cu4 , respectively .",
    "+    to improve cpu usage and speed up the process for a whole cycle the following enhancements were applied :    1 .",
    "files get multiframe ids depending on the largest mulitframe i d in the database directly after transfer ( cu1 ) .",
    "the database is accordingly updated .",
    "the cu4 object i d is turned into a temporary negative , only per day unique i d . this way we avoid overlaps with already in the database existing ( positive )",
    "object ids .",
    "it can be translated into a global unique i d directly after ingest with a simple addition to the last maximal object i d .",
    "the ingest process is completely de - coupled from extraction and processing .",
    "the first two steps allow us to process metadata simultaneously on different computers .",
    "the last one allows the ingest to be run on available ingestable data while new data is processed . since ingest can take as much time as processing , this can nearly halve the run time of the full cycle .",
    "figure  [ fig : p4.1_fig2 ] shows the flow chart for the final design .",
    "a data daemon has been created that checks the available computers , their load , and the tasks that need to be executed as well as tasks already running . at the moment",
    "it suggests the distribution of these tasks to enhance usage of cpus on the pixel servers .",
    "the database operator then takes the final decision in running the tasks .",
    "in addition to the data daemon the ingester daemon can be run , checking automatically for ingestable data and ingesting them into the database .",
    "this maximises cpu usage on the database server .",
    "+ since these daemons can be run automatically , we are investigating the best way to run individual tasks remotely from a master computer .",
    "a number of python - related solutions exist and are described in the .",
    "running each of the cus 2 to 4 for 30 nights of data on five computers at the same time and ingesting the data as soon as it was available improved the total run times as follows :"
  ],
  "abstract_text": [
    "<S> one of the major challenges providing large databases like the wfcam science archive ( wsa ) is to minimize ingest times for pixel / image metadata and catalogue data . in this article </S>",
    "<S> we describe how the pipeline processed data are ingested into the database as the first stage in building a release database which will be succeeded by advanced processing ( source merging , seaming , detection quality flagging etc . ) . to accomplish the ingestion procedure as fast as possible </S>",
    "<S> we use a mixed python / c++ environment and run the required tasks in a simple parallel modus operandi where the data are split into daily chunks and then processed on different computers . </S>",
    "<S> the created data files can be ingested into the database immediately as they are available . this flexible way of handling the data allows the most usage of the available cpus as the comparison with sequential processing shows . </S>"
  ]
}