{
  "article_text": [
    "in the seminal paper @xcite , they introduced a morphing algorithm called the as - rigid - as - possible ( arap , for short ) shape interpolation .",
    "since then , the technique has been successfully applied to various shape deformation applications . in their original paper ,",
    "tetrahedral volume meshes are used to produce interpolation of shapes . however , in most computer graphic systems it is common to represent shapes by surface meshes . to convert a surface mesh to a volume mesh",
    "is a non - trivial task ( see , for example , @xcite ) and the resulting volume mesh tends to have many extra internal vertices , which makes applications inefficient .",
    "instead of considering volume meshes , one can `` fatten '' surface meshes .",
    "a common practice is to associate a tetrahedral structure to a triangular surface mesh by adding the normal vector for every triangle ( see , for example , @xcite ) .",
    "although this simple trick has been widely used , it does not capture important geometric features of the mesh .",
    "for example , the relation between adjacent triangles is neglected .",
    "one of the main purposes of this paper is to introduce a new construction to associate a tetrahedral structure to a triangular mesh , which we call _ tetrisation _ (  [ sec : tetrisation ] ) .",
    "our method encodes inter - triangular properties such as the angle between adjacent triangles so that one can keep track of global geometry such as curvature while working locally on tetrahedra .",
    "we also discuss an improvement of the arap (  [ sec : arap ] ) in how to interpolate local transformations (  [ sec : blend ] ) and how to stitch fragmented tetrahedra by a new error function (  [ sec : error ] ) .",
    "we demonstrate our improvement by a shape blending application ( fig .",
    "[ fig : penguins ] ) . given an arbitrary number of isomorphic surfaces , our algorithm produces inter / extrapolation of the shapes according to the weights given by the user . roughly speaking",
    ", we define a `` linear combination '' of shapes @xmath0 where @xmath1 are weights and @xmath2 are shapes .",
    "in particular , when the number of shapes is two , @xmath3 for @xmath4 gives a morphing between them . note that our algorithm is highly non - linear although we described the procedure as taking the linear combination of shapes .",
    "we implemented the algorithm as the autodesk maya plugin . its mit licensed source code is available at @xcite .     or @xmath5 ) is possible .",
    "the top - left shape is obtained by extrapolating the two yellow shapes in the top row . ]",
    "we begin with listing some notation .",
    "we assume all tranformations are represented by real matrices , acting on real column vectors by the multiplication from the left .",
    "* @xmath6 : the group of 3d rotations .",
    "its element is a @xmath7 special orthogonal matrix .",
    "* @xmath8 : the set of 3d shears .",
    "its element is a @xmath7 positive definite symmetric matrix .",
    "* @xmath9 : the group of ( invertible ) 3d linear transformations consisting of compositions of rotation , shear , and reflection .",
    "its element is a @xmath7 regular matrix . *",
    "@xmath10 : the group of ( invertible ) 3d affine transformations consisting of compositions of rotation , shear , reflection , and translation .",
    "its element is a @xmath11 regular homogeneous matrix .",
    "* @xmath12 : the subgroups of the reflection free ( positive determinant ) elements in the corresponding groups .",
    "* @xmath13 : the linear part ( @xmath7 upper - left corner ) of @xmath14 .",
    "* @xmath15 : the transpose of a matrix @xmath16 .",
    "* @xmath17 : the squared frobenius norm of a matrix @xmath16 . *",
    "@xmath18 : the cardinality of a set @xmath19 .",
    "in this section , we recall the arap framework by describing an algorithm for shape blending . note that although we discuss shape blending as the primary application , the framework and our improvement is not limited to it .",
    "indeed , after being introduced in @xcite initially as a morphing algorithm , the arap technique has been serving as one of the fundamental frameworks for various kinds of shape deformation applications ( see , for example , @xcite ) .",
    "our problem setting is as follows .",
    "we are given a rest shape @xmath20 and @xmath21 its deformations @xmath22 .",
    "that is , a vertex correspondence between @xmath20 and each of @xmath22 is assumed .",
    "we would like to compute the deformation @xmath23 by blending the given shapes @xmath24 according to the user specified weights @xmath25 .",
    "we insist that it interpolates the given shapes , i.e. , @xmath26 , and @xmath27 when @xmath28 .",
    "notice we allow negative weights and weights greater than one so that the system can not only interpolate but also extrapolate .    a basic shape blending is achieved by simply taking the linear combination of the coordinates of the vertices .",
    "this method is very fast and widely used to produce variations of shapes , in particular , facial expressions . however , since the geometry of shapes is disregarded , it does not always produce plausible outputs ( fig .",
    "[ fig : linear - blendshape ] ) .",
    "the arap based method which we will describe below takes geometry into account to obtain better results .",
    "we assume that the rest shape is equipped with a non - degenerate _ tetrahedral structure _ @xmath29 .",
    "we will discuss in  [ sec : tetrisation ] a method to associate one to a triangular mesh .",
    "a tetrahedral structure is a pair @xmath30 , where the vertex set @xmath31 consists of three dimensional vectors and the set of tetrahedra @xmath32 consists of ordered tuples of four distinct vertices @xmath33 .",
    "each vertex in @xmath31 must be contained in at least one tetrahedron . a tetrahedral structure is said to be non - degenerate when the vertices of each tetrahedron are not co - planar .",
    "we emphasise that a triangle can be shared by three or more tetrahedra , and for this reason , we use the terminology `` tetrahedral structure '' rather than tetrahedral mesh .",
    "the information of a tetrahedral structure @xmath30 can be packed into a collection of @xmath11-matrices : @xmath34 where @xmath35 is the vector representing the position of the vertex @xmath36 .",
    "we denote by @xmath37 the matrices associated to the rest shape @xmath29 . since @xmath29 is assumed to be non - degenerate , all the @xmath38 are regular . for each deformation @xmath39",
    ", we use the same set of tetrahedra @xmath40 to obtain @xmath41 .",
    "note that @xmath42 need not be regular . we define a series of affine transformations @xmath43 which maps the vertices @xmath20 of the rest shape to the ones @xmath39 in the deformed shape .",
    "obviously , @xmath44 when @xmath45 is contained in two tetrahedra @xmath46 and @xmath47 .",
    "thus , @xmath41 can be considered as a _",
    "piecewise linear map _ defined on @xmath29 with @xmath48 as its image .",
    "now , we have @xmath21 piecewise linear maps @xmath49 and the problem is rephrased as to blend them according to the user specified weights @xmath50 .",
    "we first consider locally and blend @xmath51 for a single tetrahedron @xmath46 to obtain @xmath52 .",
    "intuitively , @xmath53 stipulates the local transformation for the tetrahedron @xmath46 .",
    "we discuss a method to compute @xmath53 in  [ sec : blend ] .",
    "the last step is to find a global piecewise linear map on @xmath29 , whose image we take as the output .",
    "since we can not assume @xmath54 agrees with @xmath55 for a vertex @xmath45 which is contained in two tetrahedra @xmath46 and @xmath47 , we have to `` stitch '' them .",
    "what we do is to find a piecewise linear map which is closest to the collection @xmath56 with respect to an _ error function_. we discuss different error functions in  [ sec : error ] . the deformed shape @xmath23 is computed as the minimiser of the error function .    in the following sections , we discuss each step in detail",
    "in computer graphics systems , shapes are usually represented by surface meshes .",
    "to apply the arap technique described in the previous section , we have to have a tetrahedral structure . here",
    ", we consider a method to build a tetrahedral structure from a given triangular surface mesh .",
    "[ def : triangular - mesh ] for a triangular mesh , we denote an element of the vertex set @xmath31 by a three dimensional vector and an element of the set of ( face ) triangles @xmath57 by an ordered tuple of three vertices @xmath58 . for @xmath59 , we call the ordered tuples @xmath60 and @xmath61 the _ oriented edges_. a triangular mesh is said to be _ non - degenerate _ when the vertices of each triangle are not co - linear .",
    "given a triangular mesh , we would like to associate a tetrahedral structure which we can apply the arap framework to .    given a non - degenerate triangular mesh @xmath62 .",
    "a _ tetrisation _ of @xmath62 is a tetrahedral structure which consists of the vertex set @xmath63 and the set of tetrahedra @xmath40 .",
    "we require @xmath64 to satisfy the following conditions :    1 .   @xmath65 .",
    "that is , @xmath63 is obtained by adding _",
    "ghost vertices _ to @xmath31 .",
    "2 .   each triangle in @xmath57 has to be contained in at least one tetrahedron in @xmath40 .",
    "each tetrahedron is non - degenerate , that is , the four vertices are not co - planar .",
    "these conditions are exactly what are required in the arap framework .",
    "we give three methods to produce tetrisation in the following .",
    "recall that the unit normal vector @xmath66 of a triangle @xmath67 is computed by @xmath68 , where the denominator @xmath69 is twice the area @xmath70 of @xmath71 .",
    "we begin with a simple method which has been commonly used in various applications . for each triangle @xmath67 in @xmath57 ,",
    "add the ghost vertex @xmath72 and form a tetrahedron @xmath73 .",
    "the resulting tetrahedral structure has @xmath74 and @xmath75 .",
    "a problem with this tetrisation when applied to the arap framework is that this does not capture the relation between adjacent triangles .",
    "for example , consider two triangles sharing an edge as in fig .",
    "[ fig : face - normal ]",
    ". any rotation invariant error function ( see  [ sec : error ] ) with @xmath76 will be minimised regardless of the angle between the two triangles . in other words , folds do not cause any penalty in the error function .",
    "we assume each oriented edge appears only once among all the triangles .",
    "in other words , an unoriented edge should be contained at most two triangles with opposite orientations .",
    "also , we assume all the triangles have at least one shared edge , that is , there is no `` lone '' triangle .",
    "( we can remove this assumption by adding ghost vertices not only for shared edges but also for all edges .",
    "however , this is inefficient and makes no sense . )    for each shared edge @xmath77 , denote by @xmath78 and @xmath79 the two triangles adjacent to it . add a ghost vertex @xmath80 and form two tetrahedra @xmath73 and @xmath81 .",
    "the resulting tetrahedral structure has @xmath82 and @xmath83 .",
    "the idea of this tetrisation is to encode the angle between adjacent triangles , which is neglected by the face - normal tetrisation .",
    "we assume that every vertex has a neighbourhood homeomorphic to the plane or the half plane .",
    "in other words , the mesh is a manifold ( with boundary ) .",
    "also , we assume all the triangles have at least one shared vertex .",
    "( again , we can remove this assumption as in the previous subsection . )    for each shared vertex @xmath84 , denote the adjacent triangles by @xmath85 and @xmath86 .",
    "add a ghost vertex @xmath87 and form @xmath88 tetrahedra by adding @xmath89 to the triangles @xmath90 .",
    "the resulting tetrahedral structure has @xmath91 and @xmath92 .",
    "an advantage of this method is that it extends straightforwardly to general polyhedral meshes .",
    "the idea of this tetrisation is to encode the angle around internal vertices , which is neglected by the face - normal tetrisation .",
    "in this section , we discuss how to blend local transformations @xmath93 with regard to the weights @xmath94 to obtain the blended local transformation @xmath95 . for this purpose , we use a function @xmath96 which satisfies the obvious requirement for interpolation .",
    "then , we set @xmath97 we investigate two such interpolation functions",
    ".    first , decompose each @xmath98 by the polar decomposition ( see , for example , @xcite ) @xmath99 where @xmath100 is the rotation and @xmath101 is the shear . in @xcite , they suggest @xmath102 where @xmath103 is the principal matrix logarithm and @xmath104 is the identity matrix is for normalisation and it enforces @xmath105 . ] .",
    "this coincides with the one used in @xcite when @xmath106 . on the other hand",
    ", we suggest @xmath107 where @xmath108 is the `` continuous '' logarithm such that it chooses the nearest branch of logarithm to the adjacent tetrahedra when @xmath109 varies ( see @xcite for details ) .",
    "the indeterminacy of @xmath103 for @xmath6 is in the rotation angle and @xmath108 chooses the angle continuously for adjacent tetrahedra .",
    "note that @xcite provides a direct and fast formula for @xmath110 which does not require the polar decomposition .",
    "they look similar but there are two significant differences ; blending for the shear part and logarithm for @xmath6 .",
    "the value of @xmath111 can fall out of @xmath112 due to the linear blending of the shear part , which causes distortion in the output ( fig .",
    "[ fig : sym - linear ] ) .",
    "the use of the continuous logarithm enables the system to produce a smoother morph among shapes which performs large rotation in between ( fig .",
    "[ fig : large - rotation ] ) .",
    "note that in @xcite which discusses morphing of two shapes , they suggest to use the quaternions and slerp ( @xcite ) to interpolate the rotation part and the linear interpolation for the shear part .",
    "( with three or more shapes , one can use the linear blending of the quaternions for the rotation part as in @xcite . )",
    "however , this method shows similar deficiency as @xmath111 .",
    "function in @xcite , the extrapolated shape on the left is degenerate .",
    "right : with our @xmath110 function , the extrapolated shape is non - degenerate .",
    ", title=\"fig:\",height=83 ]   function in @xcite , the extrapolated shape on the left is degenerate .",
    "right : with our @xmath110 function , the extrapolated shape is non - degenerate .",
    ", title=\"fig:\",height=83 ]     function in @xcite , some parts try to rotate inconsistently .",
    "right : with our @xmath110 function , local rotations are appropriately handled to produce a smooth interpolation , title=\"fig:\",height=83 ]   function in @xcite , some parts try to rotate inconsistently .",
    "right : with our @xmath110 function , local rotations are appropriately handled to produce a smooth interpolation , title=\"fig:\",height=83 ]",
    "in this section , we consider error functions to stitch fragmented tetrahedra .",
    "fix the vertex positions @xmath20 of the rest shape and the local transformations @xmath113 of the tetrahedra .",
    "an error function is a function of the deformed vertex positions @xmath114 . by equation ,",
    "a piecewise linear map @xmath115 and @xmath114 are linearly related and we identify them . in @xcite , they introduced @xmath116 and it has been used in many of the arap based shape deformation applications including @xcite .",
    "note that the function is translation invariant but not rotation invariant .",
    "rotation invariance is sometimes preferable in shape deformation ( see , for example , @xcite and fig . [",
    "fig : comparison ] ) .",
    "we propose an alternative error function which is rotation and translation invariant : @xmath117 where @xmath118 for @xmath119 is the shear factor of the polar decomposition of @xmath120 ( see @xcite ) . intuitively , this error function measures how much each tetrahedron is distorted . despite the simplicity and its invariance property ,",
    "@xmath121 has not been considered in the literature as far as the author is aware .",
    "we believe this error function gives a good alternative to @xmath122 in some applications ( see fig .",
    "[ fig : comparison ] ) .    we can assign a weight @xmath123 to each tetrahedron @xmath46 to specify its contribution to the error function .",
    "it is done simply by replacing the summation @xmath124 with the weighted one @xmath125 in the definitions of the error functions . for notational simplicity ,",
    "we omit them in this paper .    as we described in ",
    "[ sec : arap ] , we define the output as the minimiser of the error function . in other words , we compute the piecewise linear function @xmath115 which is closest to @xmath113 with respect to the error function . computing the minimiser for @xmath122",
    "is reduced to solving a sparse linear system ( see @xcite ) . for @xmath121 ,",
    "the computation is not linear . an iterative way similar to @xcite is given as follows :    1 .",
    "compute the minimiser of @xmath126 and set @xmath127 .",
    "2 .   compute the polar decomposition @xmath128 .",
    "3 .   compute the minimiser of @xmath129 to update @xmath130 .",
    "4 .   repeat ( 2 ) and ( 3 ) until @xmath130 converge .",
    "note that there is some indeterminacy of the minimiser coming from the symmetry of the error function .",
    "for example , any translation of a minimiser is also a minimiser . to obtain a unique minimiser",
    ", one can impose additional constraints ; for @xmath122 fixing the position of the barycentre and for @xmath121 fixing the position of the barycentre and the orientation of some tetrahedra .",
    "we implemented our algorithm as the autodesk maya plugin ( @xcite ) . in our system , the user can specify the weight for each shape with sliders , or the ball controller which computes the weights by @xcite from the configuration of the balls representing the shapes ( fig . [",
    "fig : maya ] ) .",
    "the arap framework was also applied to shape blending in @xcite in the 2d setting and in @xcite in the 3d setting .",
    "we demonstrate our improvement discussed in  [ sec : tetrisation ] and  [ sec : error ] by comparing with @xcite .",
    "first , we note that in @xcite , ( i ) the face - normal tetrisation , ( ii ) the error function @xmath122 , ( iii ) and the blending function @xmath111 are used .",
    "we have already seen the difference between the blending functions @xmath111 and @xmath110 at the end of  [ sec : blend ] .",
    "we will turn our attention to ( i ) and ( ii ) .",
    "[ fig : comparison ] visually compares different tetrisations in  [ sec : tetrisation ] and the error functions @xmath122 and @xmath121 in  [ sec : error ] .",
    "we observe that @xmath121 produces more natural results than @xmath122 but much slower as we see in table [ table : timing ] . with @xmath121 ,",
    "the face - normal tetrisation causes extra wrinkles compared to the edge - normal and the vertex - normal tetrisations .",
    "as far as we experimented , it depends on the character of shapes to be blended which tetrisation gives the best result .",
    "in general , with @xmath122 the output is more or less similar regardless of the choice of tetrisation . with @xmath121 ,",
    "the vertex - normal tetrisation seems to be a good choice .     and its two deformations @xmath131 and @xmath132 to be blended with weights @xmath133 and @xmath134 .",
    "second row from left to right : results obtained by face - normal , edge - normal , and vertex - normal tetrisation with @xmath122 , third row : same as the second row but with @xmath121.,title=\"fig:\",height=83 ] +   and its two deformations @xmath131 and @xmath132 to be blended with weights @xmath133 and @xmath134 .",
    "second row from left to right : results obtained by face - normal , edge - normal , and vertex - normal tetrisation with @xmath122 , third row : same as the second row but with @xmath121.,title=\"fig:\",height=98 ]   and its two deformations @xmath131 and @xmath132 to be blended with weights @xmath133 and @xmath134 .",
    "second row from left to right : results obtained by face - normal , edge - normal , and vertex - normal tetrisation with @xmath122 , third row : same as the second row but with @xmath121.,title=\"fig:\",height=98 ]   and its two deformations @xmath131 and @xmath132 to be blended with weights @xmath133 and @xmath134 .",
    "second row from left to right : results obtained by face - normal , edge - normal , and vertex - normal tetrisation with @xmath122 , third row : same as the second row but with @xmath121.,title=\"fig:\",height=98 ] +   and its two deformations @xmath131 and @xmath132 to be blended with weights @xmath133 and @xmath134 .",
    "second row from left to right : results obtained by face - normal , edge - normal , and vertex - normal tetrisation with @xmath122 , third row : same as the second row but with @xmath121.,title=\"fig:\",height=98 ]   and its two deformations @xmath131 and @xmath132 to be blended with weights @xmath133 and @xmath134 .",
    "second row from left to right : results obtained by face - normal , edge - normal , and vertex - normal tetrisation with @xmath122 , third row : same as the second row but with @xmath121.,title=\"fig:\",height=98 ]   and its two deformations @xmath131 and @xmath132 to be blended with weights @xmath133 and @xmath134 .",
    "second row from left to right : results obtained by face - normal , edge - normal , and vertex - normal tetrisation with @xmath122 , third row : same as the second row but with @xmath121.,title=\"fig:\",height=98 ]    table [ table : timing ] shows a timing comparison for different tetrisations and error functions .",
    "we blended two 3d models each with 26k triangles on a macbook air with 1.7ghz intel core i7 and 8 gb memory .",
    "initialisation part involves the cholesky decomposition of the space matrix necessary to solve the minimiser of the error functions .",
    "this is computed only once in the initialisation process .",
    "note that the matrix is dependent on the tetrahedral structure but independent of the choice of the error function .",
    "runtime part consists of finding the minimiser of the error functions and the computation of @xmath135 functions .",
    "c|ccc|ccc & face @xmath122 & edge @xmath122 & vertex @xmath122 & face @xmath121 & edge @xmath121 & vertex @xmath121 + initialisation ( sec ) & 0.1976 & 0.3080 & 0.3556 & 0.1976 & 0.3080 & 0.3556 + runtime with @xmath111 & 45.45 fps & 27.43 fps & 30.86 fps & 11.66 fps & 4.132 fps & 4.762 fps + runtime with @xmath110 & 48.46 fps & 29.31 fps & 31.46 fps & 12.19 fps & 4.576 fps & 5.037 fps +      this work was partially supported by the core research for evolutional science and technology ( crest ) program titled `` mathematics for computer graphics '' of the japan science and technology agency ( jst ) , by kakenhi grant - in - aid for young scientists ( b ) 26800043 , and by jsps postdoctoral fellowships for research abroad .",
    "k. shoemake and t. duff , _ matrix animation and polar decomposition _ , proc .",
    "graphics interface 92 , kellogg s. booth and alain fournier ( eds . ) .",
    "morgan kaufmann publishers inc .",
    ", san francisco , ca , usa , 258264 ( 1992 )"
  ],
  "abstract_text": [
    "<S> the as - rigid - as - possible ( arap ) shape deformation framework is a versatile technique for morphing , surface modelling , and mesh editing . </S>",
    "<S> we discuss an improvement of the arap framework in a few aspects : 1 . given a triangular mesh in 3d space , we introduce a method to associate a tetrahedral structure , which encodes the geometry of the original mesh . </S>",
    "<S> 2 . </S>",
    "<S> we use a lie algebra based method to interpolate local transformation , which provides better handling of rotation with large angle . </S>",
    "<S> 3 . </S>",
    "<S> we propose a new error function to compile local transformations into a global piecewise linear map , which is rotation invariant and easy to minimise . </S>",
    "<S> we implemented a shape blender based on our algorithm and its mit licensed source code is available online . </S>"
  ]
}