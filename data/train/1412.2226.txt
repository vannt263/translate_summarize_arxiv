{
  "article_text": [
    "efficient and fair allocation of resources is a pressing problem within society today .",
    "one important and challenging case is the fair allocation of indivisible items  @xcite .",
    "this covers a wide range of problems including the allocation of classes to students , landing slots to airlines , players to teams , and houses to people .",
    "a simple but popular mechanism to allocate indivisible items is _ sequential allocation _ @xcite . in sequential allocation",
    ", agents simply take turns to pick the most preferred item that has not yet been taken . besides its simplicity",
    ", it has a number of advantages including the fact that the mechanism can be implemented in a distributed manner and that agents do not need to submit cardinal utilities .",
    "well - known mechanisms like serial dictatorship  @xcite fall under the umbrella of sequential mechanisms .",
    "the sequential allocation mechanism leaves open the particular order of turns ( the so called `` policy '' )  @xcite .",
    "should it be a _ balanced _",
    "policy i.e. , each agent gets the same total number of turns ? or should it be _ recursively balanced _",
    "so that turns occur in rounds , and each agent gets one turn per round ? or perhaps it would be fairer to alternate but reverse the order of the agents in successive rounds : @xmath0 so that agent @xmath1 takes the first and sixth turn ?",
    "this particular type of policy is used , for example , by the harvard business school to allocate courses to students  @xcite and is referred to as a _ balanced alternation _ policy .",
    "another class of policies is _ strict alternation _ in which the same ordering is used in each round , such as @xmath2 .",
    "the sets of balanced alternation and strict alternation policies are subsets of the set of recursively balanced policies which itself is a subset of the set of balanced policies ( see figure  [ fig : inclfigure ] ) .",
    "we consider here the situation where a policy is chosen from a family of such policies .",
    "for example , at the harvard business school , a policy is chosen at random from the space of all balanced alternation policies . as a second example",
    ", the policy might be left to the discretion of the chair but , for fairness , it is restricted to one of the recursively balanced policies . despite uncertainty in the policy",
    ", we might be interested in the possible or necessary outcomes .",
    "for example , can i get my three most preferred courses ?",
    "do i necessarily get my two most preferred courses ? we examine the complexity of checking such questions .",
    "there are several high - stake applications for these results .",
    "for example , sequential allocation is used in professional sports ` drafts '  @xcite .",
    "the precise policy chosen from among the set of admissible policies can critically affect which teams ( read agents ) get which players ( read items ) .",
    "the problems of checking whether an agent can get some item or set of items in a policy or in all policies is closely related to the problem of ` control ' of the central organizer .",
    "for example , if an agent gets an item in all feasible policies , then it means that the chair can not ensure that the agent does not get the item .",
    "apart from strategic motivation , the problems we consider also have a design motivation .",
    "the central designer may want to consider all feasible policies uniformly at random ( as is the case in random serial dictatorship  @xcite ) and use them to find the probability that a certain item or set of item is given to an agent .",
    "the probability can be a suggestion of time sharing of an item .",
    "the problem of checking whether an agent gets a certain item or set of items in some policy is equivalent to checking whether an agent gets a certain item or set of items with non - zero probability .",
    "similarly , the problem of checking whether an agent gets a certain item or set of items in all policy is equivalent to checking whether an agent gets a certain item or set of items with probability one .",
    "= [ draw , inner xsep=1.5em ] ( -13,-8 ) rectangle ( 13,8 ) ;    ( 0,0 ) ellipse ( 35em and 22em ) ;    ( 0,1 ) ellipse ( 26em and 13em ) ;    ( 3,1 ) ellipse ( 15em and 8em ) ;    ( -3,1 ) ellipse ( 15em and 8em ) ;    ( -10,-7 ) node arbitrary ; ( 7,6 ) node balanced ;    ( 0,4.5 ) node rec - balanced ;",
    "( -5,1 ) node strict - alt ; ( 5,1 ) node bal - alt ;    we let @xmath3 denote a set of @xmath4 agents , and @xmath5 denote the set of @xmath6 items .",
    "@xmath7 is the profile of agents preferences where each @xmath8 is a linear order over @xmath5 .",
    "let @xmath9 denote an assignment of all items to agents , that is , @xmath10 .",
    "we will denote a class of policies by @xmath11 .",
    "any policy @xmath12 specifies the @xmath13 turns of the agents .",
    "when an agent takes her turn , she picks her most preferred item that has not yet been allocated .",
    "we leave it to future work to consider agents picking strategically .",
    "sincere picking is a reasonable starting point as when the policy is uncertain , a risk averse agent is likely to pick sincerely .    consider the setting in which @xmath14 , @xmath15 , the preferences of agent @xmath1 are @xmath16 and of agent @xmath17 are @xmath18 .",
    "then for the policy @xmath19 , agent @xmath1 gets @xmath20 whilst @xmath17 gets @xmath21 .",
    "we consider the following natural computational problems .    1 .",
    "possibleassignment : given @xmath22 and policy class @xmath11 , does there exist a policy in @xmath11 which results in @xmath9 ?",
    "necessaryassignment : given @xmath22 , and policy class @xmath11 , is @xmath9 the result of all policies in @xmath11 ? 3 .",
    "possibleitem : given @xmath23 where @xmath24 and @xmath25 , and policy class @xmath11 , does there exist a policy in @xmath11 such that agent @xmath26 gets item @xmath27 ?",
    "necessaryitem : given @xmath23 where @xmath24 and @xmath25 , and policy class @xmath11 , does agent @xmath26 get item @xmath27 for all policies in @xmath11 ? 5 .",
    "possibleset : given @xmath28 where @xmath24 and @xmath29 , and policy class @xmath11 , does there exist a policy in @xmath11 such that agent @xmath26 gets exactly @xmath30 ? 6 .",
    "necessaryset : given @xmath28 where @xmath24 and @xmath29 , and policy class @xmath11 , does agent @xmath26 get exactly @xmath30 for all policies in @xmath11 ? 7 .",
    "possiblesubset : given @xmath28 where @xmath24 and @xmath29 , and policy class @xmath11 , does there exist a policy in @xmath11 such that agent @xmath26 gets @xmath30",
    "necessarysubset : given @xmath28 where @xmath24 and @xmath29 , and policy class @xmath11 does agent @xmath26 get @xmath30 for all policies in @xmath11 ?",
    "we will consider problems top-@xmath31 possiblesetand top-@xmath31 necessarysetthat are restrictions of possiblesetand necessarysetin which the set of items @xmath30 is the set of top @xmath31 items of the distinguished agent . when policies are chosen at random , the possible and necessary allocation problems we consider are also fundamental to understand more complex problems of computing the probability of certain allocations .    [ [ contributions . ] ] contributions .",
    "+ + + + + + + + + + + + + +    our contributions are two fold .",
    "first , we provide necessary and sufficient conditions for an allocation to be the outcome of balanced policies , recursively balanced policies , and balanced alternation policies , respectively .",
    "previously @xcite characterized the outcomes of arbitrary policies . in a similar vein , we provide sufficient and necessary conditions for more interesting classes of policies such as recursively balanced and balanced alternation .",
    "second , we provide a detailed analysis of the computational complexity of possible and necessary allocations under sequential policies . table  [ table : summaryseq ] summarizes our complexity results .",
    "our np / conp - completeness results also imply that there exists no polynomial - time algorithm that can approximate within any factor the number of admissible policies which do or do not satisfy the target goals .",
    "[ [ related - work . ] ] related work .",
    "+ + + + + + + + + + + + +    sequential allocation has been considered in the operations research and fair division literature ( e.g. @xcite ) .",
    "it was popularized within the ai literature as a simple yet effective distributed mechanism  @xcite and has been studied in more detail subsequently @xcite . in particular , the complexity of manipulating an agent s preferences has been studied  @xcite supposing that one agent knows the preferences of the other agents as well as the policy . similarly in the problems we consider ,",
    "the central authority knows beforehand the preferences of all agents .",
    "the problems considered in the paper are similar in spirit to a class of control problems studied in voting theory : if it is possible to select a voting rule from the set of voting rules , can one be selected to obtain a certain outcome  @xcite .",
    "they are also related to a class of control problems in knockout tournaments : does there exist a draw of a tournament for which a given player wins the tournament  @xcite .",
    "possible and necessary winners have also been considered in voting theory for settings in which the preferences of the agents are not fully specified  @xcite .",
    "when @xmath32 , serial dictatorship is a well - known mechanism in which there is an ordering of agents and with respect to that ordering agents pick the most preferred unallocated item in their turns  @xcite .",
    "we note that serial dictatorship for @xmath32 is a balanced , recursively balanced and balanced alternation policy .",
    "in this section we provide necessary and sufficient conditions for a given allocation to be the outcome of a balanced policy , recursively balanced policy , or balanced alternation policy .",
    "we first define conditions on an allocation @xmath9 .",
    "an allocation is _ pareto optimal _ if there is no other allocation in which each item of each agent is replaced by at least as preferred an item and at least one item of some agent is replaced by a more preferred item .    [ cond:1 ] @xmath9 is pareto optimal .",
    "[ cond:2 ] @xmath9 is balanced .",
    "it is well - known that condition  [ cond:1 ] characterizes outcomes of all sequential allocation mechanisms ( without constraints ) .",
    "@xcite proved that an assignment is achievable via sequential allocation iff it satisfies condition  [ cond:1 ] .",
    "the theorem of @xcite generalized the characterization of @xcite of pareto optimal assignments as outcomes of serial dictatorships when @xmath33 .",
    "we first observe the following simple adaptation of the characterization of @xcite to characterize possible outcomes of balanced policies :    [ thm : pab ] given a profile @xmath34 , an allocation @xmath9 is the outcome of a balanced policy if and only if @xmath9 satisfies conditions  [ cond:1 ] and  [ cond:2 ] .    given a balanced allocation @xmath9 , for each agent @xmath24 and each @xmath35 , let @xmath36 denote the item that is ranked at the @xmath37-th position by agent @xmath26 among all items allocated to agent @xmath26 by @xmath9 .",
    "the third condition requires that for all @xmath38 , no agent prefers the @xmath39-th ranked item allocated to any other agent to the @xmath40-th ranked item allocated to her .",
    "[ cond:3 ] for all @xmath38 and all pairs of agent @xmath41 , agent @xmath26 prefers @xmath42 to @xmath43 .",
    "the next theorem states that conditions 1 through 3 characterize outcomes of recursively balanced policies .",
    "[ thm : passrb ] given a profile @xmath34 , an allocation @xmath9 is the outcome of a recursively balanced policy if and only if it satisfies conditions  [ cond:1 ] , [ cond:2 ] , and [ cond:3 ] .",
    "to prove the `` only if '' direction , clearly if @xmath9 is the outcome of a recursively balanced policy then condition  [ cond:1 ] and  [ cond:2 ] are satisfied .",
    "if condition  [ cond:3 ] is not satisfied , then there exists @xmath38 and a pair of agents @xmath41 such that agent @xmath26 prefers @xmath43 to @xmath42 .",
    "we note that in the round when agent @xmath26 is about to choose @xmath42 according to @xmath9 , @xmath43 is still available , because it is allocated by @xmath9 in a later round .",
    "however , in this case agent @xmath26 will not choose @xmath42 because it is not her top - ranked available item , which is a contradiction .    to prove the `` if '' direction , for any allocation @xmath9 that satisfies the three conditions we will construct a recursively balanced policy @xmath44 .",
    "for each @xmath45 , we let * phase * @xmath37 denote the @xmath46-th round through @xmath47-th round .",
    "it follows that for all @xmath35 , @xmath48 are allocated in phase @xmath37 . because of condition  [ cond:3 ] , @xmath48 is a pareto optimal allocation when all items in @xmath49 are removed .",
    "therefore there exists an order @xmath50 over @xmath51 that gives this allocation .",
    "let @xmath52 .",
    "it is not hard to verify that @xmath44 is recursively balanced and @xmath9 is the outcome of @xmath44 .    given a profile @xmath34 and an allocation @xmath9 that is the outcome of a recursively balanced policy , that is , it satisfies the three conditions as proved in theorem  [ thm : passrb ] , we construct a directed graph @xmath53 , where the vertices are the agents , and we add the edges in the following way . for each odd @xmath35 , we add a directed edge @xmath54 if and only if agent @xmath26 prefers @xmath55 to @xmath56 and the edge is not already in @xmath57 ; for each even @xmath35 , we add a directed edge @xmath58 if and only if agent @xmath26 prefers @xmath55 to @xmath56 and the edge is not already in @xmath57 .",
    "[ cond:4 ] suppose @xmath9 is the outcome of a recursively balanced policy . there is no cycle in @xmath57 .",
    "[ thm : paa ] an allocation @xmath9 is achievable by a balanced alternation policy if and only if satisfies conditions  [ cond:1 ] , [ cond:2 ] , [ cond:3 ] , and [ cond:4 ] .    the `` only if '' direction : suppose @xmath9 is achievable by a balanced alternation policy @xmath44 .",
    "let @xmath59 denote the suborder of @xmath44 from round @xmath60 to round @xmath4 .",
    "let @xmath61 denote the directed graph where the vertices are the agents and there is an edge @xmath54 if and only if @xmath62 .",
    "it is easy to see that @xmath63 is acyclic and complete .",
    "we claim that @xmath57 is a subgraph of @xmath63 . for the sake of contradiction",
    "suppose there is an edge @xmath58 in @xmath57 but not in @xmath63 .",
    "if @xmath58 is added to @xmath57 in an odd round @xmath37 , then it means that agent @xmath64 prefers @xmath36 to @xmath55 . because @xmath58 is not in @xmath63 , @xmath62 .",
    "this means that right before @xmath65 choosing @xmath55 in @xmath9 , @xmath36 is still available , which contradicts the assumption that @xmath65 chooses @xmath55 in @xmath9 .",
    "if @xmath58 is added to @xmath57 in an even round , then following a similar argument we can also derive a contradiction .",
    "therefore , @xmath57 is a subgraph of @xmath63 , which means that @xmath57 is acyclic .",
    "the `` if '' direction : suppose the four conditions are satisfied . because @xmath57 has no cycle",
    ", we can find a linear order @xmath59 over @xmath51 such that @xmath57 is a subgraph of @xmath63 .",
    "we next prove that @xmath9 is achievable by the balanced alternation policy @xmath44 whose first @xmath4 rounds are @xmath59 . for the sake of contradiction suppose this is not true and let @xmath40 denote the earliest round that the allocation in @xmath44 differs the allocation in @xmath9 .",
    "let @xmath26 denote the agent at the @xmath40-th round of @xmath44 , let @xmath66 denote the item she gets at round @xmath40 in @xmath44 , and let @xmath36 denote the item that she is supposed to get according to @xmath9 .",
    "due to condition  [ cond:3 ] , @xmath67 .",
    "if @xmath68 then agent @xmath65 did nt get item @xmath66 in a previous round , which contradicts the selection of @xmath40 . therefore @xmath69 . if @xmath37 is odd , then there is an edge @xmath54 in @xmath57 , which means that @xmath62 .",
    "this means that @xmath65 would have chosen @xmath55 in a previous round , which is a contradiction .",
    "if @xmath37 is even , then a similar contradiction can be derived .",
    "therefore @xmath9 is achievable by @xmath44 .    given a profile @xmath34 and an allocation @xmath9 that is the outcome of a recursively balanced policy , that is , it satisfies the three conditions as proved in theorem  [ thm : passrb ] , we construct a directed graph @xmath70 , where the vertices are the agents , and we add the edges in the following way .",
    "for each @xmath71 and @xmath35 , we let @xmath36 denote the item that is ranked at the @xmath37-th position among all items allocated to agent @xmath72 . for each @xmath35 , if we add a directed edge @xmath54 if @xmath72 prefers @xmath55 to @xmath56 if the edge is not already there .",
    "[ cond : h_m ] suppose @xmath9 is the outcome of a recursively balanced policy . there is no cycle in @xmath73 .",
    "[ thm : sa - charac ] an allocation @xmath9 is achievable by a strict alternation policy if and only if satisfies condition  [ cond:1 ] , [ cond:2 ] , [ cond:3 ] , and [ cond : h_m ] .    the `` only if '' direction : if @xmath9 is an outcome of a recursively balanced policy but does not satisfy [ cond : h_m ] , then this means that there is a cycle in @xmath73 .",
    "let agents @xmath74 and @xmath26 be in the cycle .",
    "this means that @xmath74 is before @xmath26 in one round and @xmath26 is before @xmath74 in some other round .",
    "the `` if '' direction : now assume that @xmath9 is an outcome of a recursively balanced policy but is not alternating .",
    "this means that there exist at least two agents @xmath74 and @xmath26 such that @xmath74 comes before @xmath26 in one round and @xmath26 comes before @xmath74 in some other round .",
    "but this means that there is cycle @xmath75 in graph @xmath73 .",
    "before we delve into the complexity results , we observe the following reductions between various problems .    [",
    "lem : reduction ] fixing the policy class to be one of \\{all , balanced policies , recursively balanced policies , balanced alternation policies } , there exist polynomial - time many - one reductions between the following problems : possiblesetto possiblesubset ; possibleitemto possiblesubset ; top-@xmath31 possiblesetto possibleset ; necessarysetto necessarysubset ; necessaryitemto necessarysubset ; and top-@xmath31 necessarysetto necessaryset .",
    "a polynomial - time many - one reduction from problem @xmath76 to problem @xmath77 means that if @xmath76 is np(conp)-hard then @xmath77 is also np(conp)-hard , and if @xmath77 is in p then @xmath76 is also in p. we also note the following .    for @xmath78 , possibleassignmentand possiblesetare equivalent for any type of policies .",
    "since @xmath78 , the allocation of one agent completely determines the overall assignment .    for @xmath33 , checking whether there is a serial dictatorship under which each agent gets exactly one item and a designated agent @xmath26 gets item @xmath27 is np - complete  ( theorem 2 , * ? ? ? * ) .",
    "they also proved that for @xmath33 , checking if for all serial dictatorships , agent @xmath26 gets item @xmath27 is polynomial - time solvable .",
    "hence , we get the following statements .    [",
    "th : saban ] possibleitemand possiblesetis np - complete for balanced , recursively balanced as well as balanced alternation policies .    for @xmath33 , necessaryitemand necessarysetis polynomial - time solvable for balanced ,",
    "recursively balanced , and balanced alternation policies",
    ".    theorem  [ th : saban ] does not necessarily hold if we consider the top element or the top @xmath31 elements .",
    "therefore , we will especially consider top-@xmath31 possibleset .",
    "we first observe that for arbitrary policies , possibleitem , necessaryitemand necessarysetare trivial : possibleitemalways has a yes answer ( just give all the turns to that agent ) and necessaryitemand necessarysetalways have a no answer ( just do nt give the agent any turn ) .",
    "similarly , necessaryassignmentalways has a no answer .",
    "[ th : trivial - arbitrary ] possibleitem , necessaryitem , necessaryset , and necessaryassignmentare polynomial - time solvable for arbitrary policies .",
    "possibleassignmentis polynomial - time solvable for arbitrary policies .    by the characterization of @xcite , all we need to do is to check whether the assignment is pareto optimal .",
    "it can be checked in polynomial time @xmath79 whether a given assignment is pareto optimal via an extension of a result @xcite .",
    "there is also a polynomial - time algorithm for possiblesetfor arbitrary policies .",
    "[ prop : getalloc - arbitrary ] possiblesetis polynomial - time solvable for arbitrary policies .    the following algorithm works for possibleset .",
    "let the target allocation of agent @xmath74 be @xmath80 .",
    "if there is any agent @xmath81 who wants to pick an item @xmath82 , let him pick it .",
    "if no agent in @xmath83 wants to pick an item @xmath82 , and @xmath37 does not want to pick an item from @xmath84 return no .",
    "if no agent in @xmath83 wants to pick an item @xmath82 , and @xmath37 wants to pick an item @xmath85 , let @xmath74 pick @xmath27 . if some agent in @xmath83 wants to pick an item @xmath86 , and also @xmath37 wants to pick @xmath85 , then we let @xmath74 pick @xmath27 .",
    "repeat the process until all the items are allocated or we return no at some point .",
    "in contrast to arbitrary policies , possibleitem , necessaryitem , necessaryset , and necessaryassignmentare more interesting for balanced policies since we may be restricted in allocating items to a given agent to ensure balance . before we consider them , we get the following corollary of remark  [ thm : pab ] .",
    "[ coro : pab]possibleassignmentfor balanced assignments is in p.    note that an assignment is achieved via all balanced policies iff the assignment is the unique balanced assignment that is pareto optimal .",
    "this is only possible if each agent gets his top @xmath31 items .",
    "hence , we obtain the following .",
    "[ thm : nassb ] necessaryassignmentfor balanced assignments is in p.    compared to necessaryassignment , the other ` necessary ' problems are more challenging .",
    "[ thm : nib ] for any constant @xmath31 , necessaryitem for balanced policies is in p.    given a necessaryiteminstance @xmath87 , if @xmath27 is ranked below the @xmath31-th position by agent @xmath1 then we can return `` no '' , because by letting agent @xmath1 choose in the first @xmath31 rounds she does not get item @xmath27 .",
    "suppose @xmath27 is ranked at the @xmath88-th position by agent @xmath1 with @xmath89 , the next claim provides an equivalent condition to check whether the necessaryiteminstance is a `` no '' instance .",
    "[ claim : nib ] suppose @xmath27 is ranked at the @xmath88-th position by agent @xmath1 with @xmath89 , the necessaryiteminstance @xmath87 is a `` no '' instance if and only if there exists a balanced policy @xmath44 such that ( i ) agent @xmath1 picks items in the first @xmath90 rounds and the last @xmath91 rounds , and ( ii ) agent @xmath1 does not get @xmath27 .",
    "let @xmath92 denote agent @xmath1 s top @xmath90 items .",
    "in light of claim  [ claim : nib ] , to check whether the @xmath87 is a `` no '' instance , it suffices to check for every set of @xmath91 items ranked below the @xmath88-th position by agent @xmath1 , denoted by @xmath30 , whether it is possible for agent @xmath1 to get @xmath92 and @xmath30 by a balanced policy where agent @xmath1 picks items in the first @xmath90 rounds and the last @xmath91 rounds . to this end , for each @xmath93 with @xmath94 , we construct the following maximum flow problem @xmath95 , which can be solved in polynomial - time by e.g.  the ford - fulkerson algorithm .    *",
    "* vertices : * @xmath96 , @xmath97 , @xmath98 . * * edges and weights : * for each @xmath99 , there is an edge @xmath100 with weight @xmath31 ; for each @xmath99 and @xmath101 such that agent @xmath102 ranks @xmath103 above all items in @xmath30 , there is an edge @xmath104 with weight @xmath60 ; for each @xmath101 , there is an edge @xmath105 with weight @xmath60 . *",
    "* we are asked * whether the maximum amount of flow from @xmath39 to @xmath40 is @xmath106 ( the maximum possible flow from @xmath39 to @xmath40 ) .",
    "@xmath87 is a `` no '' instance if and only if there exists @xmath93 with @xmath94 such that @xmath95 has a solution .    because @xmath31 is a constant , the number of @xmath30 we will check is a constant .",
    "algorithm  [ alg : ni ] is a polynomial algorithm for necessaryitem with balanced policies .",
    "let @xmath92 denote agent @xmath26 s top @xmath90 items .",
    "`` yes '' .",
    "[ thm : nallb ] for any constant @xmath31 , necessarysetand necessarysubset for balanced policies are in p.    w.l.o.g .  given a necessarysetinstance @xmath107 ,",
    "if @xmath30 is not the top - ranked @xmath31 items of agent @xmath1 then it is a `` no '' instance because we can simply let agent @xmath1 choose items in the first @xmath31 rounds .",
    "when @xmath30 is top - ranked @xmath31 items of agent @xmath1 , @xmath107 is a `` no '' instance if and only if @xmath87 is a `` no '' instance for some @xmath108 , which can be checked in polynomial time by theorem  [ thm : nib ] . a similar algorithm works for necessarysubset .",
    "[ thm : nibunfixed ] necessaryitemand necessarysubsetfor balanced policies where @xmath31 is not fixed is conp - complete .",
    "membership in conp is obvious . by lemma  [ lem : reduction ]",
    "it suffices to prove that necessaryitemis conp - hard , which we will prove by a reduction from possibleitemfor @xmath109 , which is np - complete @xcite .",
    "let @xmath87 denote an instance of the possible allocation problem for @xmath109 , where @xmath110 , @xmath111 , @xmath25 , @xmath7 is the preference profile of the @xmath4 agents , and we are asked whether it is possible for agent @xmath1 to get item @xmath27 in some sequential allocation . given @xmath87 , we construct the following necessaryiteminstance .",
    "* agents : * @xmath112 .",
    "* items : * @xmath113 , where @xmath114 and for each @xmath24 , @xmath115 .",
    "we have @xmath116 and @xmath117 .",
    "* preferences : *    * the preferences of @xmath1 is @xmath118 $ ] . *",
    "for any @xmath71 , the preferences of @xmath26 are obtained from @xmath119 $ ] by replacing @xmath27 by @xmath120 , and then add @xmath27 to the bottom position . *",
    "the preferences for @xmath121 is @xmath122 $ ] .",
    "* we are asked * whether agent @xmath121 always gets item @xmath27 .",
    "if @xmath87 has a solution @xmath44 , we show that the necessaryiteminstance is a `` no '' instance by considering @xmath123 . in the first @xmath124 rounds",
    "all @xmath125 s are allocated to agent @xmath26 s . in the following @xmath4 rounds @xmath27",
    "is allocated to @xmath1 , which means that @xmath121 does not get @xmath27 .",
    "suppose the necessaryiteminstance is a `` no '' instance and agent @xmath126 does not get @xmath27 in a balanced policy @xmath59 . because agent @xmath17 through @xmath127 rank @xmath27 in their bottom position , @xmath27 must be allocated to agent @xmath1 .",
    "clearly in the first @xmath128 times when agent @xmath1 through @xmath127 choose items , they will choose @xmath129 through @xmath130 respectively .",
    "let @xmath44 denote the order over which agents @xmath1 through @xmath127 choose items for the last time .",
    "we obtain another order @xmath131 over @xmath51 from @xmath44 by moving all agents who choose an item in @xmath120 after agent @xmath1 while keeping other orders unchanged .",
    "it is not hard to see that the outcomes of running @xmath44 and @xmath131 are the same from the first round until agent @xmath1 gets @xmath27 .",
    "this means that @xmath131 is a solution to @xmath87 .",
    "[ thm : knsb]necessarysetand top-@xmath31 necessarysetfor balanced policies are in p even when @xmath31 is not fixed .    given an instance of necessaryset ,",
    "if the target set is not top-@xmath31 then the answer is `` no '' because we can simply let the agent choose @xmath31 items in the first @xmath31 rounds .",
    "it remains to show that top-@xmath31 necessarysetfor balanced policies is in p. that is , given @xmath132 , we can check in polynomial time whether there is a balanced policy @xmath44 for which agent @xmath1 does not get exactly her top @xmath31 items .",
    "for necessaryset , suppose agent @xmath1 does not get her top-@xmath31 items under @xmath44 .",
    "let @xmath59 denote the order obtained from @xmath44 by moving all agent @xmath1 s turns to the end while keeping the other orders unchanged .",
    "it is easy to see that agent @xmath1 does not get her top-@xmath31 items under @xmath59 either .",
    "therefore , necessarysetis equivalent to checking whether there exists an order @xmath44 where agent @xmath1 picks item in the last @xmath31 rounds so that agent @xmath1 does not get at least one of her top-@xmath31 items .",
    "we consider an equivalent , reduced allocation instance where the agents are @xmath133 , and there are @xmath134 items @xmath135 , where @xmath92 is agent @xmath1 s top-@xmath31 items .",
    "agent @xmath26 s preferences over @xmath30 are obtained from @xmath8 by replacing the first occurrence of items in @xmath92 by @xmath103 , and then removing all items in @xmath92 while keeping the order of other items the same .",
    "we are asked whether there exists an order @xmath44 where agent @xmath1 is the last to pick and @xmath1 picks a single item , and each other agents picks @xmath31 times , so that agent @xmath1 does not get item @xmath103 .",
    "this problem can be solved by a polynomial - time algorithm based on maximum flows that is similar to the algorithm for necessaryitemfor balanced policies in theorem  [ thm : nib ] .",
    "in this section , we consider recursively balanced policies . from theorem  [ thm :",
    "passrb ] , we get the following corollary .",
    "[ coro : passrb ] possibleassignmentfor recursively balanced policies is in p.    we also report computational results for problems other than possibleassignment    [ thm : nassrb ] necessaryassignmentfor recursively balanced policies is in p.    we initialize @xmath40 to @xmath60 i.e. , focus on the first round .",
    "we check if there is an agent whose turn has not come in the round whose most preferred unallocated item is not @xmath136 . in this case",
    "return `` no '' .",
    "otherwise , we complete the round in any order .",
    "if all the items are allocated , we return `` yes '' . if @xmath137 , we increment @xmath40 by one and repeat .",
    "the other ` necessary problems ' turn out to be computationally intractable .",
    "[ thm : nirb ] for @xmath138 , necessaryitem , necessaryset , top-@xmath31 necessaryset , and necessarysubsetfor recursively balanced policies are conp - complete .    [ thm : topkpossibleset - rec - bal ] top-@xmath31 possiblesetfor",
    "recursively balanced policies is in p for @xmath139 .",
    "let the agent under question be @xmath1 .",
    "we give agent @xmath1 the first turns in each round with @xmath140 @xmath1 s top two items .",
    "the agent is guaranteed to get @xmath141 .",
    "we now construct a bipartite graph @xmath142 in which each @xmath143 iff iff @xmath74 prefers @xmath27 to @xmath144 .",
    "we check whether @xmath145 admits a matching that perfectly matches the agent nodes .",
    "if @xmath145 does not , we return no . otherwise , there exists a recursively balanced policy for which agent @xmath1 gets @xmath141 and @xmath144 .",
    "finally , top-@xmath31-possiblesetis np - complete iff @xmath146 .",
    "[ thm : kpsrb ] for all @xmath146 , top-@xmath31 possibleset for balanced policies is np - complete .",
    "the proof is given in the appendix .",
    "as for balanced alternation polices , there are @xmath147 possible strict alternation policies , so if @xmath4 is constant , then all problems can be solved in polynomial time by brute force search .    if the number of agents is constant , then possibleitem , possibleset , necessaryitem , necessaryset , possibleassignment , and necessaryassignmentare polynomial - time solvable for strict alternation policies .    as a result of our characterization of strict alternation outcomes ( theorem  [ thm : sa - charac ] ) , we get the following .    [",
    "coro : pasa ] possibleassignmentfor strict alternation polices is in p.    we also present other computational results .",
    "[ thm : pasa ] necessaryassignmentfor strict alternation polices is in p.    [ thm : psk2strict ] top-@xmath31 possiblesetfor strict alternation policies is in p for @xmath139 .    for theorem  [ thm : psk2strict ]",
    ", the polynomial - time algorithm is similar to the algorithm for theorem  [ thm : topkpossibleset - rec - bal ] .",
    "the next theorems state that the remaining problems are hard to compute .",
    "both theorems are proved by reductions from the possibleitemproblem .",
    "[ thm : pastrict ] for all @xmath148 , top-@xmath31 possiblesetis np - complete for strict alternation policies .",
    "[ thm : knstrict ] for all @xmath138 , necessaryitem , necessaryset , top-@xmath31 necessaryset , and necessarysubsetare conp - complete for strict alternation policies .",
    "balanced alternation policies and strict alternation policies are the most constrained class among all policy classes we study .",
    "there are @xmath147 possible balanced alternation policies , so if @xmath4 is constant , then all problems can be solved in polynomial time by brute force search .",
    "note that such an argument does not apply to recursively balanced policies",
    ".    if the number of agents is constant , then possibleitem , possibleset , necessaryitem , necessaryset , possibleassignment , and necessaryassignmentare polynomial - time solvable for balanced alternation policies .    as a result of our characterization of balanced alternation outcomes ( theorem  [ thm : paa ] )",
    ", we get the following .",
    "[ coro : passa ] possibleassignmentfor balanced alternation polices is in p.    necessaryassignmentcan be solved efficiently as well :    [ thm : nassa ] necessaryassignmentfor balanced alternation polices is in p.    we first check whether it is possible to find @xmath44 over @xmath51 such that after running @xmath44 there exists an agent @xmath72 that does not get item @xmath149 . if so then we return `` no '' .",
    "otherwise , we remove all items in @xmath150 and check whether it is possible to find @xmath44 over @xmath51 such that after running @xmath44 on the reduced instance , there exists an agent @xmath26 that does not get item @xmath151 . if so then we return `` no '' . otherwise , we iterate until all items are removed in which case we return `` yes '' .",
    "we already know that for @xmath152 , top-@xmath31 possible and necessary problems can be solved in polynomial time .",
    "the next theorems state that for any other @xmath31 , they are np - complete for balanced alternation policies",
    ". theorem  [ thm : palla ] is proved by a reduction from the exact 3-cover problem and theorem  [ thm : knsa ] is proved by a reduction from the possibleitemproblem .",
    "[ thm : palla ] for all @xmath153 , top-@xmath31 possiblesetis np - complete , necessaryitemis conp - complete , and necessarysubsetis conp - complete for balanced alternation policies .",
    "[ thm : knsa ] for all @xmath138 , top-@xmath31 necessaryset for balanced alternation policies is conp - complete .",
    "we have studied sequential allocation mechanisms like the course allocation mechanism at harvard business school where the policy has not been fixed or has been fixed but not announced .",
    "we have characterized the allocations achievable with three common classes of policies : recursively balanced , strict alternation , and balanced alternation policies .",
    "we have also identified the computational complexity of identifying the possible or necessary items , set or subset of items to be allocated to an agent when using one of these three policy classes as well as the class of all policies .",
    "there are several interesting future directions including considering other common classes of policies , as well as other properties of the outcome like the possible or necessary welfare .",
    "29 [ 1]#1 [ 1]`#1 ` urlstyle [ 1]doi : # 1    a.  abdulkadirolu and t.  snmez .",
    "random serial dictatorship and the core from random endowments in house allocation problems .",
    "_ econometrica _ , 660 ( 3):0 689702 , 1998 .",
    "d.  j. abraham , k.  cechlrov , d.  manlove , and k.  mehlhorn .",
    "pareto optimality in house allocation problems . in _ proc .  of the 16th international symposium on algorithms and computation ( isaac )",
    "_ , volume 3341 of _ lncs _ , pages 11631175 , 2005 .",
    "h.  aziz . a note on the undercut procedure . in _ proc .",
    "of the 13th aamas conference _ , pages 13611362 , 2014 .",
    "h.  aziz , m.  brill , f.  fischer , p.  harrenstein , j.  lang , and h.  g. seedig .",
    "possible and necessary winners of partial tournaments . in _ proc .  of the 11th aamas conference _ , pages 585592 .",
    "ifaamas , 2012 .",
    "h.  aziz , f.  brandt , and m.  brill .",
    "the computational complexity of random serial dictatorship . _ economics letters _ , 1210 ( 3):0 341345 , 2013 .",
    "h.  aziz , s.  gaspers , s.  mackenzie , n.  mattei , p.  stursberg , and t.  walsh .",
    "fixing a balanced knockout tournament . in _ proc .",
    "of the 28th aaai conference _ , pages 552558 , 2014 .",
    "h.  aziz , s.  gaspers , s.  mackenzie , and t.  walsh .",
    "fair assignment of indivisible objects under ordinal preferences . in _ proc .  of the 13th aamas conference _ , pages 13051312 , 2014 .",
    "y.  bachrach , n.  betzler , and p.  faliszewski .",
    "probabilistic possible winner determination . in _ proceedings of the national conference on artificial intelligence ( aaai ) _ , pages 697702 , 2010 .",
    "d.  baumeister and j.  rothe . taking the final step to a full dichotomy of the possible winner problem in pure scoring rules . in _ proceedings of the 19th european conference on artificial intelligence ( ecai ) _ , 2010 .",
    "n.  betzler and b.  dorn . towards a dichotomy for the possible winner problem in elections based on scoring rules . _ journal of computer and system sciences _ , 760 ( 8):0 812836 , 2010 .",
    "s.  bouveret and j.  lang .",
    "efficiency and envy - freeness in fair division of indivisible goods : logical representation and complexity .",
    "_ journal of artificial intelligence research _ , 320 ( 1):0 525564 , 2008 .",
    "s.  bouveret and j.  lang . a general elicitation - free protocol for allocating indivisible goods . in _ proc .",
    "of the 22 ijcai _ , pages 7378 , 2011 .",
    "s.  bouveret and j.  lang . manipulating picking sequences . in _ in proceedings of the 21st european conference on artificial intelligence ( ecai14 ) _ , pages 141146 , 2014 .",
    "s.  bouveret , u.  endriss , and j.  lang .",
    "fair division under ordinal preferences : computing envy - free allocations of indivisible goods . in _ proc .  of the 19th european conference on artificial intelligence ( ecai ) _ , pages 387392 , 2010 .",
    "s.  j. brams and d.  l. king .",
    "efficient fair division : help the worst off or avoid envy ?",
    "_ rationality and society _ , 170 ( 4):0 387421 , 2005 .    s.  j. brams and p.  d. straffin .",
    "prisoners dilemma and professional sports drafts .",
    "_ the american mathematical monthly _ , 860 ( 2):0 8088 , 1979 .    s.  j. brams and a.  d. taylor . _ fair division : from cake - cutting to dispute resolution_. cambridge university press , 1996 .",
    "e.  budish and e.  cantillion .",
    "the multi - unit assignment problem : theory and evidence from course allocation at harvard . _ american economic review _ , 1020 ( 5):0 22372271 , 2012",
    ".    y.  chevaleyre , p.  e. dunne , u.  endriss , j.  lang , m.  lematre , n.  maudet , j.  padget , s.  phelps , j.  a. rodrguez - aguilar , and p.  sousa .",
    "issues in multiagent resource allocation .",
    "_ informatica _ , 30:0 331 , 2006 .",
    "g.  erdlyi and e.  elkind .",
    "manipulation under voting rule uncertainty . in _ proc .",
    "of the 11th aamas conference _ , pages 627634 , 2012 .",
    "t.  kalinowski , n.  narodytska , and t.  walsh .",
    "a social welfare optimal sequential allocation procedure . in _ proc .  of the 22nd ijcai _ , pages 227233 , 2013 .",
    "t.  kalinowski , n.  narodytska , t.  walsh , and l.  xia .",
    "strategic behavior when allocating indivisible goods sequentially . in _ proc .  of the 27th aaai conference",
    "_ , pages 452458 , 2013 .",
    "d.  a. kohler and r.  chandrasekaran . a class of sequential games .",
    "_ operations research _ , 190 ( 2):0 270277 , 1971 .    k.  konczak and j.  lang .",
    "voting procedures with incomplete preferences . in _",
    "multidisciplinary workshop on advances in preference handling _ ,",
    "l.  levine and k.  e. stange . how to make the most of a shared meal : plan the last bite first .",
    "_ the american mathematical monthly _ , 1190 ( 7):0 550565 , 2012 .",
    "d.  saban and j.  sethuraman .",
    "the complexity of computing the random priority allocation matrix . in y.",
    "chen and n.  immorlica , editors , _ proc .  of the 9th wine _ , lncs , 2013 .",
    "l - g svensson .",
    "strategy - proof allocation of indivisible goods .",
    "_ social choice and welfare _ , 160 ( 4):0 557567 , 1999",
    ".    t.  vu , a.  altman , and y.  shoham . on the complexity of schedule control problems for knockout tournaments . in _ proc .  of the 8th aamas conference _ ,",
    "pages 225232 , 2009 .",
    "l.  xia and v.  conitzer .",
    "determining possible and necessary winners under common voting rules given partial orders .",
    "_ jair _ , 410 ( 2):0 2567 , 2011 .",
    "[ lemma : ttc ] it can be checked in polynomial time @xmath79 whether a given assignment is pareto optimal .",
    "the set of assignments achieved via arbitrary policies is characterized by pareto optimal assignments . for any given assignment setting and an assignment ,",
    "the _ corresponding cloned setting _ is one in which for each item @xmath27 that is owned by agent @xmath37 , we make a copy @xmath154 of agent @xmath37 so that each agent copy owns exactly one item .",
    "each copy @xmath154 has exactly the same preferences as agent @xmath37 .",
    "the assignment in which copies of agents get a single item is called the _ cloned transformation _ of the original assignment .",
    "[ lemma : cloned ] an assignment is pareto optimal iff its cloned transformation is pareto optimal for the cloned setting .",
    "if an assignment is not pareto optimal for the cloned setting , then there exists another assignment in which each of the cloned agents get at least as preferred an item and at least one agent gets a strictly more preferred item .",
    "but if the new assignment for the cloned setting is transformed to the assignment for the original setting , then the new assignment pareto dominates the prior assignment for the original setting .",
    "if an assignment is not pareto optimal ( with respect to responsive preferences ) then there exists another assignment that pareto dominates it . but",
    "this implies that the new assignment also pareto dominates the old assignment in the cloned setting .",
    "we are now ready to prove lemma  [ lemma : ttc ] .    by lemma  [ lemma : cloned ] , the problem is equivalent to checking whether the cloned transformation of the assignment is pareto optimal in the cloned setting .",
    "pareto optimality of an assignment in which each agent has one item can be checked in time @xmath155  ( see e.g. , * ? ? ?",
    "* ) where @xmath156 is the number of items .",
    "firstly , for each item @xmath27 that is owned by agent @xmath37 , we make a copy @xmath154 of agent @xmath37 so that each agent copy owns exactly one item .",
    "each copy @xmath154 has exactly the same preferences as agent @xmath37 .",
    "based on the ownership information of each the @xmath156 agent copies , and the preferences of the agent copies , we construct a _ trading graph _ in which each copy @xmath154 points to each of the items more preferred than @xmath27 .",
    "also each @xmath27 points to its owner @xmath154 .",
    "then the assignment in the cloned transformation is pareto optimal iff the trading graph is acyclic  ( * ? ? ?",
    "* see e.g. , ) .",
    "acyclicity of a graph can be checked in time linear in the size of the graph via depth - first search .",
    "let the target allocation of agent @xmath74 be @xmath80 .",
    "if there is any agent @xmath81 who wants to pick an item @xmath82 , let him pick it .",
    "if no agent in @xmath157 wants to pick such an item @xmath82 , and @xmath37 does not want to pick an item from @xmath84 return no .",
    "if no agent in @xmath83 wants to pick such an item @xmath82 , and @xmath74 wants to pick an item @xmath85 , let @xmath74 pick @xmath27 . if some agents in @xmath83 wants to pick such an item @xmath86 , and also @xmath37 wants to pick @xmath85 , then we let @xmath74 pick @xmath27 .",
    "repeat the process until all the items are allocated or we return no at some point .",
    "we now argue for the correctness of the algorithm .",
    "observe the order in which agent @xmath1 picks items in @xmath80 is exactly according to his preferences .",
    "[ claim : o ] let us consider the first pick in the algorithm . if agent @xmath1 picks an item @xmath158 ,",
    "then if there exists a policy @xmath12 in which agent @xmath74 gets @xmath80 , then there also exists a policy @xmath159 in which agent @xmath1 first picks @xmath27 and agent @xmath37 gets @xmath80 overall .    in @xmath12 , by the time agent @xmath74",
    "picks his second most preferred item from @xmath80 , all items more preferred have already been allocated . in @xmath12 , if @xmath160 , then we can obtain @xmath159 by bringing @xmath74 to the first place and having all the other turns in the same order . note that in @xmath159 , for any agent s turn the set of available items are either the same or @xmath27 is the extra item missing .",
    "however since @xmath27 was not even chosen by the latter agents , the picking outcomes of @xmath12 and @xmath159 are identical .",
    "[ claim : o ] let us consider the first pick in the algorithm .",
    "if some agent @xmath26 picks an item @xmath161 in the algorithm , then if there exists a policy in which agent @xmath74 gets @xmath80 , then there also exists a policy in which agent @xmath26 first picks @xmath162 and agent @xmath74 gets @xmath80 overall .",
    "in @xmath12 , if @xmath163 , then we can obtain @xmath159 by bringing @xmath26 to the first place and having all the other turns in the same order .",
    "if @xmath72 does not get @xmath162 in @xmath12 , then when we construct @xmath159 we simply delete the turn of the agent who got @xmath162 .",
    "note that in @xmath159 , for any agent s turn the set of available items are either the same or @xmath162 is the extra item missing .",
    "however since @xmath162 was not even chosen by the latter agents , the picking outcomes of @xmath12 and @xmath159 are identical .    by inductively",
    "applying claims  [ claim : o ] and [ claim : o ] , we know that as long as a policy exists in which @xmath37 gets allocation @xmath80 , our algorithm can construct a policy in which @xmath37 gets allocation @xmath80 .",
    "in a necessaryiteminstance we can assume the distinguished agent is @xmath1 .",
    "given @xmath87 , if @xmath27 is ranked below the @xmath31-th position by agent @xmath1 then it we can return `` no '' , because by letting agent @xmath1 choose in the first @xmath31 rounds she does not get item @xmath27 .",
    "suppose @xmath27 is ranked at the @xmath88-th position by agent @xmath1 with @xmath89 , the next claim provides an equivalence condition to check whether the necessaryiteminstance is a `` no '' instance .",
    "[ claim : nib ] suppose @xmath27 is ranked at the @xmath88-th position by agent @xmath1 with @xmath89 , the necessaryiteminstance @xmath87 is a `` no '' instance if and only if there exists a balanced policy @xmath44 such that ( i ) agent @xmath1 picks items in the first @xmath90 rounds and the last @xmath91 rounds , and ( ii ) agent @xmath1 does not get @xmath27 .",
    "suppose there exists a balanced policy @xmath59 such that agent @xmath1 does not get item @xmath27 , then we obtain @xmath131 from @xmath59 by moving the first @xmath90 occurrences of agent @xmath1 to the beginning of the sequence while keeping other positions unchanged .",
    "when preforming @xmath131 , in the first @xmath90 rounds agent @xmath1 gets her top @xmath90 items .    by the next time agent @xmath1 picks an item in @xmath131 , @xmath27 must have been chosen by another agent . to see why this is true , for each agent from the @xmath88-th round until agent @xmath1 s next turn in @xmath131 , we compare side by side the items allocated before this agent s turn by @xmath131 and by @xmath59 .",
    "it is not hard to see by induction that the item allocated by @xmath131 before agent @xmath1 s next turn is a superset of the item allocated by @xmath59 before agent @xmath1 s @xmath88-th turn .",
    "because the latter contains @xmath27 , agent @xmath1 does not get @xmath27 in @xmath131 .",
    "then , we obtain @xmath44 from @xmath131 by moving the @xmath88-th through the @xmath31-th occurrence of agent @xmath1 to the end of the sequence while keeping other positions unchanged . it is easy to see that agent @xmath1 does not get @xmath27 in @xmath44 .",
    "this completes the proof .",
    "let @xmath92 denote agent @xmath1 s top @xmath90 items . in light of claim  [ claim : nib ] , to check whether the @xmath87 is a `` no '' instance , it suffices to check for every set of @xmath91 items ranked below the @xmath88-th position by agent @xmath1 , denoted by @xmath30 , whether it is possible for agent @xmath1 to get @xmath92 and @xmath30 by a balanced policy where agent @xmath1 picks items in the first @xmath90 rounds and the last @xmath91 rounds . to this end , for each @xmath93 with @xmath94 , we construct the following maximum flow problem @xmath95 , which can be solved in polynomial - time by e.g.  the ford - fulkerson algorithm .    *",
    "* vertices : * @xmath96 , @xmath97 , @xmath98 . * * edges and weights : * for each @xmath99 , there is an edge @xmath100 with weight @xmath31 ; for each @xmath99 and @xmath101 such that agent @xmath102 ranks @xmath103 above all items in @xmath30 , there is an edge @xmath104 with weight @xmath60 ; for each @xmath101 , there is an edge @xmath105 with weight @xmath60 . * * we are asked * whether the maximum amount of flow @xmath39 to @xmath40 is @xmath106 ( the maximum possible flow from @xmath39 to @xmath40 ) .",
    "@xmath164 is a `` no '' instance if and only if there exists @xmath93 with @xmath94 such that @xmath95 has a solution",
    ".    if @xmath164 is a `` no '' instance , then by claim  [ claim : nib ] there exists @xmath44 such that agent @xmath1 picks items in the first @xmath90 rounds and the last @xmath91 rounds , and agent @xmath1 gets @xmath165 for some @xmath93 . for each agent",
    "@xmath26 with @xmath166 , let there be a flow of amount @xmath31 from @xmath39 to @xmath26 and a flow of amount @xmath60 from @xmath26 to all items that are allocated to her in @xmath44 .",
    "moreover , let there be a flow of amount @xmath60 from any @xmath167 to @xmath40 .",
    "it is easy to check that the amount of flow is @xmath106 .",
    "if @xmath95 has a solution , then there exists an integer solution because all weights are integers .",
    "this means that there exists an assignment of all items in @xmath98 to agent @xmath168 through @xmath4 such that no agent gets an item that is ranked below any item in @xmath92 . starting from this allocation , after implementing all trading cycles we obtain a pareto optimal allocation where @xmath98 are allocated to agent @xmath168 through @xmath4 , and still no agent gets an item that is ranked below any item in @xmath92 . by proposition  1 in brams and king , there exists a balanced policy @xmath131 that gives this allocation .",
    "it follows that agent @xmath1 does not get @xmath27 under the balanced policy @xmath169 .    because @xmath31 is a constant ,",
    "the number of @xmath30 we will check is a constant .",
    "the polynomial algorithm for necessaryitemfor balanced policies is presented as algorithm  [ alg : ni ] .",
    "in the allocation @xmath170 , let @xmath171 be the @xmath72-th most preferred item for agent @xmath37 among his set of @xmath31 allocated items .    if there exists a recursively balanced policy achieving the target allocation .",
    "then , in any such recursively balanced policy , we know that in each @xmath40-th round , each agent gets item @xmath172 .",
    "we initialize @xmath40 to @xmath60 i.e. , focus on the first round .",
    "we check if there is an agent whose turn has not come in the round whose most preferred unallocated item is not @xmath172 . in this case",
    "return `` no '' .",
    "otherwise , we complete the round in any arbitrary order . if all the items are allocated , we return `` yes '' . if @xmath137 , we increment @xmath40 by one and repeat the process .",
    "we now argue for correctness .",
    "if the algorithm returns no , then we know that there is a recursively balanced policy that does not achieve the allocation .",
    "this policy was partially built during the algorithm and can be completed in an arbitrary way to get an allocation that is not the same as the target allocation .",
    "now assume for contradiction that there is a policy which does not achieve the allocation but the algorithm incorrectly returns yes . consider the first round where the algorithm makes a mistake .",
    "but in each round , each agent had a unique and mutually exclusive most preferred unallocated item .",
    "hence no matter which policy we implement in the round , the allocation and the set of unallocated items after the round stays the same . hence a contradiction .",
    "membership in conp is obvious . by lemma  [ lem : reduction ]",
    "it suffices to show conp - hardness for necessaryitemand top-@xmath31 necessaryset .",
    "we will prove the co - np - hardness for them for @xmath139 by the same reduction from possibleitemfor @xmath109 , which is np - complete  @xcite .",
    "the proof for other @xmath138 can be done similarly by constructing preferences so that the distinguished agent always get her top @xmath173 items .",
    "let @xmath87 denote an instance of possibleitemfor @xmath109 , where @xmath110 , @xmath111 , @xmath25 , @xmath7 is the preference profile of the @xmath4 agents , and we are asked wether it is possible for agent @xmath1 to get item @xmath27 in some sequential allocation . given @xmath87 , we construct the following necessary allocation instance .",
    "* agents : * @xmath112 .    *",
    "items : * @xmath174 , where @xmath175 .",
    "* preferences : *    * the preferences of @xmath1 is obtained from @xmath176 by inserting @xmath177 right before @xmath27 , and append the other items such that the bottom item is @xmath103 . * for any @xmath178 , the preferences of @xmath26 is obtained from @xmath8 by replacing @xmath27 by @xmath120 and then appending the remaining items such that the bottom items are @xmath179 . *",
    "the preferences for @xmath121 is @xmath180 $ ] .    for necessaryitem",
    ", we are asked whether agent @xmath121 always get item @xmath27 ; for top-@xmath31 necessaryset , we are asked whether agent @xmath121 always get @xmath181 , which are her top-2 items .",
    "suppose the @xmath87 has a solution , denoted by @xmath44 .",
    "we claim that @xmath182 is a `` no '' answer to the necessaryitemand top-@xmath31 necessarysetinstance . following @xmath59 , in the first round @xmath121 gets @xmath103 . in the next @xmath4 rounds @xmath1 gets @xmath177 .",
    "then in the @xmath183-th round agent @xmath1 gets item @xmath27 , which means that @xmath121 does not get item @xmath27 after all items are allocated .",
    "we note that @xmath121 always get item @xmath103 for any recursively balanced policy .",
    "we next show that if necessaryitemor top-@xmath31 necessarysetinstance is a `` no '' instance , then the possibleiteminstance is a `` yes '' instance .",
    "suppose @xmath59 is a recursively balanced policy such that @xmath121 does not get @xmath27 .",
    "we let * phase 1 * denote the first @xmath126 rounds , and let * phase 2 * denote the @xmath183-th through @xmath184-th round .    because @xmath27 is the least preferred item for all agents except @xmath1 and @xmath121 , if @xmath121 does not get @xmath27 in the second phase , then @xmath27 must be allocated to @xmath1 .",
    "this is because for the sake of contradiction suppose @xmath27 is allocated to agent @xmath26 with @xmath185 , then @xmath26 must be the last agent in @xmath59 and @xmath27 is not chosen in any previous round .",
    "however , when it is @xmath127 s turn in the second phase , @xmath27 is still available , which means that @xmath127 would have chosen @xmath27 and contradicts the assumption that @xmath26 gets @xmath27 .",
    "if @xmath1 gets @xmath27 under @xmath59 , then @xmath1 gets @xmath177 in the first phase .    for the sake of contradiction , suppose in the first phase @xmath1",
    "does not get @xmath177 , then either she gets an item before @xmath177 , or she gets @xmath27 , because it is impossible for @xmath1 to get an item after @xmath27 otherwise another agent must get @xmath27 in the first phase , which is impossible as we just argued above .    *",
    "if @xmath1 gets an item before @xmath177 in the first phase , then in order for @xmath1 to get @xmath27 in the second phase , @xmath177 must be chosen by another agent .",
    "clearly @xmath177 can not be chosen by @xmath121 before @xmath1 gets @xmath27 , because @xmath177 is the bottom item by @xmath121 , which means that the only possibility for @xmath121 to get @xmath177 is that @xmath121 is the last agent in @xmath59 .",
    "if @xmath177 is chosen by @xmath26 with @xmath71 , then because @xmath186 are the bottom two items by @xmath26 , the last two agents in @xmath59 must be @xmath187 .",
    "therefore , when @xmath121 chooses an item in the second phase , @xmath27 is still available , which means that @xmath121 gets @xmath27 in @xmath59 , a contradiction to the assumption that @xmath121 does not get her top-@xmath168 items .",
    "* if @xmath1 gets @xmath27 in the first phase , then it means that another agent must get @xmath177 in the first phase , which is impossible because all other agents rank @xmath177 within their bottom two positions , which means that the earliest round that any of them can get @xmath177 is @xmath188 .",
    "let @xmath44 denote the order over @xmath51 that is obtained from the first phase of @xmath59 by removing @xmath121 , and them moving all agents who get an item in @xmath120 after @xmath1 .",
    "we claim that @xmath44 is a solution to @xmath87 , because when it is @xmath1 s round all items before @xmath27 must be chosen and @xmath27 has not been chosen ( if another agent gets @xmath27 before @xmath1 in @xmath44 then the same agent must get an item in @xmath120 in the first phase of @xmath59 , which contradicts the construction of @xmath44 ) .",
    "this proves the co - np - completeness of the allocation problems mentioned in the theorem .",
    "we give agent @xmath1 the first turns in each round .",
    "he is guaranteed to get @xmath141 .",
    "we now construct a bipartite graph @xmath142 in which each @xmath189 iff @xmath27 is strictly more preferred for @xmath37 than @xmath144 .",
    "we check whether @xmath145 admits a perfect matching .",
    "if @xmath145 does not admit a perfect matching , we return no .",
    "otherwise , there exists a recursively balanced policy for which agent @xmath1 gets @xmath141 and @xmath144 .",
    "@xmath145 admits a perfect matching if and only if there a recursively balanced policy for which @xmath1 gets @xmath190 .",
    "if @xmath145 admits a perfect matching , then each agent in @xmath191 can get a more preferred item than @xmath144 in the first round .",
    "if this particular allocation is not pareto optimal for agents in @xmath191 for items among @xmath192 , we can easily compute a pareto optimal pareto improvement over this allocation by implementing trading cycles as in setting of house allocation with existing tenants .",
    "this takes at most @xmath193 .",
    "hence , we can compute an allocation in which each agent in @xmath191 gets a strictly more preferred item than @xmath144 and this allocation for agents in @xmath191 is pareto optimal . since the allocation is pareto optimal",
    ", we can easily build up a policy which achieves this pareto optimal allocation via the characterization of brams . in the second round",
    ", @xmath1 gets @xmath144 and then subsequently we do nt care who gets what because agent @xmath1 has already got @xmath141 and @xmath144 .",
    "if @xmath145 does not admit a perfect matching , then there is no allocation in which each agent in @xmath191 get a strictly better item than @xmath144 in @xmath192 . hence in each policy in the first round , some agent in @xmath191 will get @xmath144 .",
    "membership in np is obvious . we prove that top-@xmath31 possiblesetfor @xmath194 is np - hard by a reduction from possibleitemfor @xmath109 , which is np - complete  @xcite .",
    "hardness for other @xmath31 s can be proved similarly by constructing preferences so that the distinguished agent always get her top @xmath173 items .",
    "let @xmath87 denote an instance of possibleitemfor @xmath109 , where @xmath110 , @xmath111 , @xmath25 , @xmath7 is the preference profile of the @xmath4 agents , and we are asked wether it is possible for agent @xmath1 to get item @xmath27 in some sequential allocation . given @xmath87 , we construct the following possiblesetinstance .",
    "* agents : * @xmath195 .",
    "* items : * @xmath196 , where @xmath197 and @xmath198 .",
    "we have @xmath199 .",
    "* preferences : *    * the preferences of @xmath1 is @xmath200 $ ] . * for any @xmath178 , the preferences of @xmath26 is obtained from @xmath201 $ ] by switching @xmath27 and @xmath202 . *",
    "the preferences for @xmath121 is @xmath203 $ ] .",
    "* for all @xmath204 , the preferences for @xmath205 is @xmath206 $ ] .",
    "* we are asked * whether agent @xmath121 can get items @xmath207 , which are her top-@xmath208 items .    if @xmath87 has a solution @xmath44 , we show that the top-@xmath208 possiblesetinstance is a `` yes '' instance by considering @xmath209 @xmath210 . in the first phase @xmath121",
    "gets @xmath211 ; @xmath212 s get @xmath120 @xmath1 gets @xmath27 and other agents in @xmath51 get @xmath213 items in @xmath214 . in the second phase @xmath121",
    "gets @xmath215 ; @xmath212 s get the remaining @xmath213 items in @xmath214 ; agents in @xmath51 get @xmath4 items in @xmath216 . in the third phase @xmath121",
    "gets @xmath217 .",
    "suppose the top-@xmath208 possiblesetinstance is a `` yes '' instance and agent @xmath121 gets @xmath207 in a recursively balanced policy @xmath59 .",
    "let @xmath44 denote the order over which agents @xmath1 through @xmath4 choose items in the first phase of @xmath59 .",
    "we obtain another order @xmath131 over @xmath51 from @xmath44 by moving all agents who choose an item in @xmath120 after agent @xmath1 without changing the order of other agents .",
    "we claim that @xmath131 is a solution to @xmath87 . for the sake of contradiction",
    "suppose @xmath131 is not a solution to @xmath87 .",
    "it follows that in the first phase of @xmath59 agent @xmath1 gets an item she ranks higher than @xmath27 , because no other agents can get @xmath27 .",
    "this means that in the first phase @xmath4 items in @xmath214 are chosen by @xmath51 .",
    "we note that in the first phase @xmath212 s must chose items in @xmath120 . then in the second phase at least one @xmath212 will choose @xmath218 , because there are @xmath213 of them and only @xmath219 items available before @xmath218 .",
    "this contradicts the assumption that @xmath121 gets @xmath217 .",
    "we prove that an assignment @xmath9 is the outcome of all strict alternating policies iff in each round , each agent has a unique most preferred item from among the unallocated items from the previous round .",
    "if in each round , each agent gets the most preferred item from among the unallocated items from the previous round , the order does not matter in any round .",
    "hence all alternating policies result in @xmath9 .",
    "now assume that it is not the case that in each round , each agent gets the most preferred item from among the unallocated items from the previous round .",
    "then , there exist at least two agent who have the same most preferred item from among the remaining items .",
    "therefore , a different relative order among such agents results in different allocations which means that @xmath9 is not the unique outcome of all strict alternating policies .",
    "membership in np is obvious . we prove that top-@xmath31 possiblesetfor @xmath194 is np - hard by a reduction from possibleitemfor @xmath109 , which is np - complete  @xcite .",
    "the reduction is similar to the proof of theorem  [ thm : kpsrb ] .",
    "hardness for other @xmath31 s can be proved similarly by constructing preferences so that the distinguished agent always get her top @xmath173 items .",
    "let @xmath87 denote an instance of possibleitemfor @xmath109 , where @xmath110 , @xmath111 , @xmath25 , @xmath7 is the preference profile of the @xmath4 agents , and we are asked wether it is possible for agent @xmath1 to get item @xmath27 in some sequential allocation . given @xmath87 , we construct the following possiblesetinstance .",
    "* agents : * @xmath195 .",
    "* items : * @xmath196 , where @xmath197 and @xmath198 .",
    "we have @xmath199 .",
    "* preferences : *    * the preferences of @xmath1 is @xmath200 $ ] . * for any @xmath178 , the preferences of @xmath26 is obtained from @xmath201 $ ] by switching @xmath27 and @xmath202 . *",
    "the preferences for @xmath121 is @xmath203 $ ] .",
    "* for all @xmath204 , the preferences for @xmath205 is @xmath206 $ ] .",
    "* we are asked * whether agent @xmath121 can get items @xmath207 , which are her top-@xmath208 items .",
    "if @xmath87 has a solution @xmath44 , we show that the top-@xmath208 possiblesetinstance is a `` yes '' instance by considering @xmath220 @xmath221 . in the first phase @xmath121",
    "gets @xmath211 , @xmath1 gets @xmath27 ; other agents in @xmath51 get @xmath213 items in @xmath214 ; @xmath212 s get @xmath120 .",
    "in the second phase @xmath121 gets @xmath215 ; @xmath212 s get the remaining @xmath213 items in @xmath214 ; agents in @xmath51 get @xmath4 items in @xmath216 . in the third phase @xmath121",
    "gets @xmath217 .",
    "suppose the top-@xmath208 possiblesetinstance is a `` yes '' instance and agent @xmath121 gets @xmath207 in a strict alternation policy @xmath59 .",
    "let @xmath44 denote the order over which agents @xmath1 through @xmath4 choose items in the first phase of @xmath59 .",
    "we obtain another order @xmath131 over @xmath51 from @xmath44 by moving all agents who choose an item in @xmath120 after agent @xmath1 without changing the order of other agents .",
    "we claim that @xmath131 is a solution to @xmath87 . for the sake of contradiction",
    "suppose @xmath131 is not a solution to @xmath87 .",
    "it follows that in the first phase of @xmath59 agent @xmath1 gets an item she ranks higher than @xmath27 , because no other agents can get @xmath27 .",
    "this means that in the first phase @xmath4 items in @xmath214 are chosen by @xmath51 .",
    "we note that in the first phase @xmath212 s must chose items in @xmath120 . then in the second phase",
    "at least one @xmath212 will choose @xmath218 , because there are @xmath213 of them and only @xmath219 items available before @xmath218 .",
    "this contradicts the assumption that @xmath121 gets @xmath217 .",
    "the proof is similar to the proof of theorem  [ thm : nirb ] .",
    "membership in conp is obvious . by lemma  [ lem : reduction ] it suffices to show conp - hardness for necessaryitemand top-@xmath31 necessaryset .",
    "we will prove the co - np - hardness for them for @xmath139 by the same reduction from possibleitemfor @xmath109 , which is np - complete  @xcite .",
    "the proof for other @xmath138 can be done similarly by constructing preferences so that the distinguished agent always get her top @xmath173 items .",
    "let @xmath87 denote an instance of possibleitemfor @xmath109 , where @xmath110 , @xmath111 , @xmath25 , @xmath7 is the preference profile of the @xmath4 agents , and we are asked wether it is possible for agent @xmath1 to get item @xmath27 by some strict alternation policy . given @xmath87 , we construct the following necessary allocation instance .",
    "* agents : * @xmath112 .",
    "* items : * @xmath174 , where @xmath175 .",
    "* preferences : *    * the preferences of @xmath1 is obtained from @xmath176 by inserting @xmath177 right before @xmath27 , and append the other items such that the bottom item is @xmath103 .",
    "* for any @xmath178 , the preferences of @xmath26 is obtained from @xmath8 by replacing @xmath27 by @xmath120 and then appending the remaining items such that the bottom items are @xmath179 . *",
    "the preferences for @xmath121 is @xmath180 $ ] .    for necessaryitem",
    ", we are asked whether agent @xmath121 always get item @xmath27 ; for top-@xmath31 necessaryset , we are asked whether agent @xmath121 always get @xmath181 , which are her top-2 items .",
    "suppose the @xmath87 has a solution , denoted by @xmath44 .",
    "we claim that @xmath222 is a `` no '' answer to the necessaryitemand top-@xmath31 necessarysetinstance .",
    "following @xmath59 , in phase @xmath1 gets @xmath177 gets @xmath177 and @xmath121 gets @xmath103 . in phase 2 @xmath1",
    "gets @xmath27 , which means that @xmath121 does not get item @xmath27 after all items are allocated .",
    "we next show that if necessaryitemor top-@xmath31 necessarysetinstance is a `` no '' instance , then the possibleiteminstance is a `` yes '' instance .",
    "we note that @xmath121 always get item @xmath103 in the first phase of any strict alternation policy .",
    "let @xmath59 denote a strict alternation policy where @xmath121 does not get @xmath27 .",
    "if @xmath1 does not get @xmath177 in the first phase , then following a similar argument in the proof of theorem  [ thm : nirb ] , we have that @xmath121 gets @xmath27 in the second phase , which is a contradiction",
    ". therefore , @xmath1 must get @xmath177 in the first phase .",
    "let @xmath44 denote the order over @xmath51 that is obtained from the first phase of @xmath59 by removing @xmath121 , and them moving all agents who get an item in @xmath120 after @xmath1 .",
    "we claim that @xmath44 is a solution to @xmath87 , because when it is @xmath1 s round all items before @xmath27 must be chosen and @xmath27 has not been chosen ( if another agent gets @xmath27 before @xmath1 in @xmath44 then the same agent must get an item in @xmath120 in the first phase of @xmath59 , which contradicts the construction of @xmath44 ) .",
    "this proves the co - np - completeness of the allocation problems mentioned in the theorem .",
    "membership in np and conp are obvious . by lemma  [ lem : reduction ] , if necessaryitemis conp - hard then necessarysubsetis conp - hard .",
    "we show the np - hardness of top-@xmath31 possiblesetand conp - hardness of necessaryitemby the same reduction from exact 3-cover ( x3c ) for @xmath139 .",
    "hardness for other @xmath31 can be proved similarly by constructing preferences so that the distinguished agent always get her top @xmath173 items . in an x3c instance @xmath223 , we are given @xmath224 and @xmath225 , such that @xmath226 is a multiple of @xmath208 and for all @xmath227 , @xmath228 and @xmath229 ; we are asked whether there exists a subset of @xmath230 elements of @xmath231 whose union is exactly @xmath232 .    given an x3c instance @xmath223 , we construct the following agents , items , and preferences .",
    "* agents * : @xmath233 , where @xmath234 and @xmath235 such that @xmath227 , @xmath236 are the indices of elements @xmath237 .",
    "that is , @xmath238 .",
    "we note that @xmath239 .    *",
    "items * : @xmath240 items are defined as follows .",
    "let @xmath241 , where @xmath242 , @xmath243 , and @xmath244 .",
    "we note that @xmath245 . for each @xmath246 , we let @xmath247 denote the sets in @xmath231 that cover @xmath248 . that is , @xmath249 .    *",
    "preferences * are illustrated in table  [ tab : pref ] .",
    ".agents preferences , where @xmath249.[tab : pref ] [ cols=\">,<\",options=\"header \" , ]     for top-@xmath168 possibleset , we are asked whether agent @xmath102 can get @xmath250 . for necessaryitem , we are asked whether agent @xmath102 always get item @xmath103 .    if the x3c instance has a solution , w.l.o.g .",
    "@xmath251 , we show that there exists a solution to the constructive control problem and destructive control problem described above . for each @xmath227",
    ", we let @xmath252 .",
    "let the order @xmath44 over agents be the following .",
    "@xmath253 the balanced alternation policy is thus @xmath254 , where @xmath255 is the inverse order of @xmath44 .",
    "it is not hard to verify that in the first round the allocation w.r.t .",
    "@xmath44 is as follows :    * for each @xmath256 , agent @xmath237 gets item @xmath237 and agent @xmath257 gets item @xmath257 ; * for each @xmath246 , agent @xmath248 get @xmath258 for the ( only ) @xmath259 such that @xmath260 ; * agent @xmath102 gets item @xmath102 ; * for each @xmath261 , agent @xmath262 gets item @xmath263 ; * for each @xmath259 and @xmath264 , agent @xmath237 gets an item in @xmath120 and agent @xmath257 gets an item in @xmath120 .    in the second round , the allocation w.r.t .",
    "@xmath255 is as follows :    * for each @xmath259 and @xmath264 , agent @xmath237 gets an item in @xmath120 and agent @xmath257 gets an item in @xmath120 ; all items in @xmath120 ( @xmath242 ) are allocated ; * for each @xmath261 , agent @xmath262 gets an item in @xmath202 ; all items in @xmath202 are allocated ( @xmath265 ) .",
    "* agent @xmath102 gets item @xmath266 ; * other agents get the remaining items .",
    "specifically , agent @xmath102 gets @xmath250 .",
    "now suppose the constructive control has a solution , namely there exists an order @xmath44 over @xmath51 such that in the sequential allocation w.r.t .",
    "@xmath254 agent @xmath102 gets @xmath250 . we next show that the x3c instance has a solution . for convenience ,",
    "we divide the sequential allocation of @xmath254 into three stages :    * * stage 1 : * turns before agent @xmath102 s first turn , where each agent ranked before agent @xmath102 in @xmath44 chooses an item ; * * stage 2 : * turns between agent @xmath102 s first turn and agent @xmath102 s second turn , where each agent ranked after agent @xmath102 in @xmath44 chooses two items ; * * stage 3 : * turns after agent @xmath102 s second turn , where each agent ranked before agent @xmath102 in @xmath44 chooses an item .",
    "[ claim : c ] agents in @xmath267 must be after agent @xmath102 in @xmath44 , and they get at least @xmath230 items in @xmath231 .",
    "because any agent in @xmath267 ranks item @xmath102 at their top , all of them must be after agent @xmath102 in @xmath44 .",
    "we note that @xmath268 , @xmath265 , and each agent in @xmath267 will choose two items before agent @xmath102 s second turn .",
    "therefore , agents in @xmath267 must get at least @xmath230 items in @xmath231 , otherwise one of them will choose @xmath266 , which contradicts the assumption that agent @xmath102 gets @xmath266 .",
    "w.l.o.g .",
    "let @xmath269 ( for some @xmath270 ) be the items in @xmath231 that are chosen by agents in @xmath267 .",
    "[ claim : s ] @xmath271 . for all @xmath259 ,",
    "agents in @xmath272 are ranked after agent @xmath102 in @xmath44 , and for all @xmath256 , agents in @xmath272 are ranked before agent @xmath102 in @xmath44 .",
    "let @xmath273 denote the set of @xmath274 items .",
    "the crucial observation is that for any agent @xmath275 , if @xmath39 is ranked before @xmath102 in @xmath44 , then in the sequential allocation she will get at least one item in @xmath276 , because she picks an item in @xmath276 in stage @xmath60 , and maybe another item in @xmath276 in stage @xmath208 ; and if @xmath39 is ranked after @xmath102 in @xmath44 , then in the sequential allocation she will get exactly two items in @xmath276 in stage 2 .",
    "moreover , each agent in @xmath232 must get at least one item in @xmath276 and agents in @xmath267 must get at least @xmath230 items in @xmath276 .",
    "therefore , agents in @xmath277 get no more than @xmath278 items in @xmath276 . because @xmath279 , at most @xmath280 of these agents are ranked after @xmath102 in @xmath44 .",
    "on the other hand , for all @xmath281 , agents in @xmath272 must be ranked after all agents in @xmath267 in @xmath44 , otherwise some item @xmath237 would have been allocated to an agent in @xmath272 ( because all of them rank item @xmath237 at the top ) . by claim  [ claim : c ] all agents in @xmath267 must be ranked after agent @xmath102 in @xmath44 , which means that for all @xmath281 , all agents in @xmath272 are ranked after agent @xmath102 in @xmath44 . because @xmath270 , we must have that @xmath271 and for all @xmath259 , agents in @xmath272 are ranked after agent @xmath102 in @xmath44 , and for all @xmath256 , agents in @xmath272 are ranked before agent @xmath102 in @xmath44",
    ".    finally , we are ready to show that @xmath282 is an exact cover of @xmath232 . for the sake of contradiction suppose @xmath248 is not covered .",
    "let @xmath258 ( with @xmath283 ) denote an item that agent @xmath248 gets in the sequential allocation .",
    "because agents in @xmath272 are before @xmath102 in @xmath44 , it follows that agent @xmath258 must get item @xmath237 ( because her top - ranked items are @xmath284 )",
    ". however , in this case agent @xmath237 must be allocated item @xmath102 , which contradicts the assumption that agent @xmath102 gets item @xmath102 .",
    "therefore , @xmath282 is an exact cover of @xmath232 .",
    "this proves the top-@xmath168 possiblesetis np - complete .",
    "we note that item @xmath103 is the most undesirable item for all agents except agent @xmath102 , which means that agent @xmath102 gets item @xmath103 if and only if she does not get item @xmath102 and @xmath266 .",
    "this proves that the necessaryitemis conp - complete .",
    "membership in conp is obvious . we prove that top-@xmath31 necessarysetfor @xmath139 is conp - hard by a reduction from possibleitemfor @xmath109 , which is np - complete  @xcite .",
    "hardness for other @xmath31 s can be proved similarly by constructing preferences so that the distinguished agent always get her top @xmath173 items .",
    "let @xmath87 denote an instance of possible allocation problem for @xmath109 , where @xmath110 , @xmath111 , @xmath25 , @xmath7 , and we are asked wether it is possible for agent @xmath1 to get item @xmath27 in some sequential allocation .",
    "given @xmath87 , we construct the following top-@xmath168 necessarysetinstance .          *",
    "the preferences of @xmath1 is obtained from @xmath176 by inserting @xmath215 right after @xmath27 , and then append @xmath288 . * for any @xmath71 , the preferences of @xmath26 is obtained from @xmath289 $ ] by switching @xmath27 and @xmath120 . *",
    "the preferences for @xmath121 is @xmath290 $ ] .",
    "if @xmath87 has a solution @xmath44 , we show that the top-@xmath168 necessarysetinstance is a `` no '' instance by considering @xmath292 . in the first phase of @xmath59",
    ", @xmath121 gets @xmath211 and @xmath1 gets @xmath27 . in the third phase @xmath293 gets @xmath215 .",
    "suppose the top-@xmath168 necessarysetinstance is a `` no '' instance and agent @xmath121 does not get @xmath291 in an balanced alternation policy @xmath59 .",
    "it is easy to see that @xmath121 must get @xmath211 in the first phase .",
    "suppose @xmath1 does not get @xmath27 in the first phase , then in the beginning of the second phase both @xmath27 and @xmath215 are still available .",
    "in this case @xmath121 must get @xmath215 , because clearly none of @xmath17 through @xmath127 can get @xmath215 , which means that @xmath1 must get @xmath215 in the second phase .",
    "however , this means that @xmath27 must be chosen by another agent before , which is impossible since it is ranked in the bottom position after @xmath211 and @xmath215 are removed by all other agents .",
    "let @xmath131 denote a linear order over @xmath51 obtained from the restriction of the first phase of @xmath59 on @xmath51 by moving all agents who choose an item in @xmath120 after agent @xmath1 without changing other orders .",
    "it is not hard to see that @xmath131 is a solution to @xmath87 ."
  ],
  "abstract_text": [
    "<S> a simple mechanism for allocating indivisible resources is sequential allocation in which agents take turns to pick items . </S>",
    "<S> we focus on _ possible _ and _ necessary allocation _ problems , checking whether allocations of a given form occur in _ some _ or _ all _ mechanisms for several commonly used classes of sequential allocation mechanisms . </S>",
    "<S> in particular , we consider whether a given agent receives a given item , a set of items , or a subset of items for five natural classes of sequential allocation mechanisms : balanced , recursively balanced , balanced alternating , strictly alternating and all policies . </S>",
    "<S> we identify characterizations of allocations produced balanced , recursively balanced , balanced alternating policies and strictly alternating policies respectively , which extend the well - known characterization by  @xcite for policies without restrictions . </S>",
    "<S> in addition , we examine the computational complexity of possible and necessary allocation problems for these classes . </S>"
  ]
}