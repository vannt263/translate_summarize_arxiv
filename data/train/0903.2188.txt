{
  "article_text": [
    "one of the reasoning models that is more useful to represent real situations is fuzzy reasoning .",
    "indeed , world information is not represented in a crisp way .",
    "its representation is imperfect , fuzzy , etc .",
    ", so that the management of uncertainty is very important in knowledge representation .",
    "there are multiple frameworks for incorporating uncertainty in logic programming :    * fuzzy set theory @xcite , * probability theory @xcite , * multi - valued logic @xcite , * possibilistic logic @xcite    despite of the multitude of theoretical approaches to this issue , few of them resulted in actual practically usable tools . since logic programming is traditionally used in knowledge representation and reasoning ,",
    "we argue it is perfectly well - suited to implement a fuzzy reasoning tool as ours .",
    "the result of introducing fuzzy logic into logic programming has been the development of several fuzzy systems over prolog .",
    "these systems replace the inference mechanism of prolog , sld - resolution , with a fuzzy variant that is able to handle partial truth .",
    "most of these systems implement the fuzzy resolution introduced by lee in @xcite , as the prolog - elf system @xcite , the fril prolog system @xcite and the f - prolog language @xcite . however , there is no common method for fuzzifying prolog , as has been noted in @xcite .",
    "some of these fuzzy prolog systems only consider the predicates fuzziness whereas other systems consider fuzzy facts or fuzzy rules .",
    "there is no agreement about which fuzzy logic should be used .",
    "most of them use min - max logic ( for modelling the conjunction and disjunction operations ) but other systems just use lukasiewicz logic @xcite .",
    "furthermore , logic programming is considered a useful tool for implementing methods for reasoning with uncertainty in @xcite .",
    "there is also an extension of constraint logic programming @xcite , which can model logics based on semiring structures .",
    "this framework can model min - max fuzzy logic , which is the only logic with semiring structure .",
    "another theoretical model for fuzzy logic programming without negation has been proposed by vojtas in @xcite , which deals with many - valued implications .",
    "one of the most promising fuzzy tools for prolog was the `` fuzzy prolog '' system @xcite .",
    "the most important advantages against the other approaches are :    1",
    ".   a truth value will be a finite union of sub - intervals on @xmath0 $ ] .",
    "an interval is a particular case of union of one element , and a unique truth value is a particular case of having an interval with only one element .",
    "a truth value is propagated through the rules by means of an _",
    "aggregation operator_. the definition of this _ aggregation operator _ is general and it subsumes conjunctive operators ( triangular norms @xcite like min , prod , etc . ) , disjunctive operators @xcite ( triangular co - norms , like max , sum , etc . ) , average operators ( averages as arithmetic average , quasi - linear average , etc ) and hybrid operators ( combinations of the above operators @xcite ) .",
    "crisp and fuzzy reasoning are consistently combined @xcite .",
    "fuzzy prolog adds fuzziness to a prolog compiler using clp(@xmath1 ) instead of implementing a new fuzzy resolution , as other former fuzzy prologs do .",
    "it represents intervals as constraints over real numbers and _ aggregation operators _ as operations with these constraints , so it uses prolog s built - in inference mechanism to handle the concept of partial truth .      over the last few years",
    "several papers have been published by medina et al .",
    "( @xcite ) about multi - adjoint programming , which describe a theoretical model , but no means of serious implementations apart from promising prototypes @xcite .    indeed , that was the reason for developing fuzzy prolog @xcite .",
    "fuzzy prolog is a very expressive tool which allows the user to program almost everything , but we have to pay for this expressiveness .",
    "the cost is a complex syntax difficult to understand .",
    "the motivation for developing rfuzzy is mainly focused on reducing this complex syntax .",
    "this reduction is based on three ideas :    1 .",
    "use real numbers instead of intervals between real numbers to represent truth values .",
    "fuzzy prolog answers to user queries are intervals like + _",
    "it_will_rain  ( tonight , [ 0 ,  1])_. this is a bit difficult to understand by normal users .",
    "truth value of this example is between 0 and 1 , and this means that program can not conclude anything about the predicate truth value .",
    "2 .   whenever it is possible , do not answer user queries using constraints .",
    "a fuzzy prolog answer to an user query can be a constraint , like + _",
    "it_will_rain  ( tomorrow , [ x ,  y ] ) , x @xmath2 0 , x @xmath3 1 , y @xmath2 0 , y @xmath3 1_. the meaning of this example is exactly the same as the meaning of the previous one , but it is slightly more difficult to understand it .",
    "truth value variables do not need to be coded .",
    "taking care of variables to manage the predicates truth value introduces errors and makes the code illegible , without giving us any advantage .",
    "rfuzzy uses real numbers to represent truth values and its replies are never constraints . besides , it is able to distinguish between crisp and fuzzy predicates and it manages the introduction of truth value variables , so the user does not need to take care of them .",
    "truth variables are always introduced at the end of the predicate arguments list , so it can be seen as some syntactic sugar .",
    "we explain this in subsection [ doing - queries - with - truth - values ] .    from the point of view of expressiveness",
    ", we can remark that rfuzzy offers to the user the ability to define types , general and conditioned default values and truth value representations by means of facts , functions or rules .",
    "besides , it implements multi - adjoint logic with representation of the concept of credibility of the rules , so it is one of the first tools that are actually modelling multi - adjoint logic .",
    "in this section we are going to describe rfuzzy s syntax .",
    "rfuzzy defines the syntax of a new subset of prolog predicates to work with truth values and to assign credibility to rules .",
    "the extensions that we have added to provide fuzziness of predicates are : type information , truth values ( for facts , functions and rules ) and default truth values .",
    "rfuzzy shares with fuzzy prolog most of its nice expressive characteristics : prolog - like syntax ( based on using facts and clauses ) , use of any aggregation operator , flexibility of query syntax , constructivity of the answers , etc . nevertheless , rfuzzy is simpler than fuzzy prolog for the user because the truth values are simple real numbers instead of the general structures of fuzzy prolog .",
    "prolog does not have types .",
    "prolog code are formulas and at execution time it looks for all of them to be true .",
    "to do that , it generates a herbrand universe and tries to substitute every variable with a herbrand term . as we do not want programs to look for an answer infinitely",
    ", we offer the user a facility to restrict the set of possible solutions .",
    "this extension is named `` types '' and its syntax is shown in ( [ eq - def - type ] ) .",
    "\\label{eq - def - type}\\ ] ] where _",
    "set_prop _ is a reserved word , _ pred _ is the name of the typed predicate , _ ar _ is its arity and _ type_pred_\\{n } _ is the predicate used to assure that the value given to the argument in the position _",
    "n _ of a call to _ pred / ar _ is correctly typed .",
    "type_pred_\\{n } _ must have arity 1 .",
    "the example below shows that the two arguments of the predicate _ has_lower_price/2 _ have to be of type _",
    "car/1 _ and which individuals belong to that type .",
    ".... : - set_prop has_lower_price/2 = > car/1 , car/1 .",
    "car(vw_caddy ) .",
    "car(alfa_romeo_gt ) . car(aston_martin_bulldog ) .",
    "car(lamborghini_urraco ) . ....      fuzzy facts are facts to which we assign a truth value . to code them in programs",
    "we offer a special syntax , so prolog can distinguish between normal facts and fuzzy facts .",
    "this syntax is shown in ( [ eq - def - fact ] ) .",
    "@xmath5    arguments ( _ args _ ) should be ground and the truth value ( _ truth_val _ ) must be a real number between 0 and 1 .",
    "the example below defines that the car _",
    "_ is an _ expensive_car _ with a truth value 0.6 .    ....",
    "expensive_car(alfa_romeo_gt ) value 0.6 . ....      fact truth value definition ( see subsection [ fact - truth - value ] ) is worth for a finite ( and relative small ) number of individuals . as we may want to define a big amount of individuals , we need more than this .    fuzzy truth values are usually represented using continuous functions .",
    "[ fig : teenager_credibility ] shows an example in which the truth value function assigns the truth value of being _ teenager _ from the person s age value .",
    "a function can be defined in several ways , but the easiest one is via a sequence of ordered pairs whose first element is the fact and the second element is the truth value assigned to that fact .    functions used to define the truth value of some group of facts are usually continuous and linear over intervals . to define those functions",
    "there is no necessity to write down the value assigned to each element in their domains .",
    "a better way to define them is by means of their inflexion points , so function values for the elements between the inflexion points are determined by means of interpolation .",
    "rfuzzy provides the syntax for defining functions by stretches .",
    "this syntax is shown in ( [ eq - def - function ] ) .",
    "external brackets represent the prolog list symbols and internal brackets represent cardinality in the formula notation .",
    "_ arg1 , ... , argn _ should be ground terms ( numbers ) and _ truth_val1 , ... , truth_valn",
    "_ should be border truth values .",
    "the truth value of the rest of the elements ( apart from the border elements ) is obtained by interpolation . @xmath6^ * ] ) \\ .",
    "\\label{eq - def - function}\\ ] ]    .... : - set_prop teenager/1 = > people_age/1 . : - default(teenager/1 , 0 ) .",
    "teenager : # ( [ ( 9 , 0 ) , ( 10 , 1 ) , ( 19 , 1 ) , ( 20 , 0 ) ] ) . ....      a tool which only allows the user to define truth values through functions and facts leaks on allowing him to combine those truth values for representing more complex situations . a rule is the perfect tool to combine the truth values of facts , functions , and other rules .",
    "rules allow the user to combine truth values in the correct way ( by means of aggregation operators , like _ maximum _ or _ product _ ) .",
    "besides this combination truth value for the body of the rule , the rule can be given an overall credibility truth value .",
    "credibility is used to express how much we trust the rule we write .",
    "suppose a small weather example in which we have the rule _ it will rain if it is cloudy and it is hot_. as it might rain but it might not , we can assign the rule a credibility of 0.7 .",
    "as expected , the truth value obtained from the body is combined with the credibility value of the rule to obtain a final truth value .",
    "_ rfuzzy _ offers the user a concrete syntax to define combinations of truth values by means of aggregation operations , and assign to that rules a credibility .",
    "this syntax extension is defined in ( [ eq - def - predicate ] ) .",
    "indeed , the user can choose two aggregation operators : _",
    "op2 _ for combining the truth values of the subgoals of the rule s body and _ op1 _ for combining the previous result with the credibility of the rule .",
    "@xmath7^*\\ ) \\ [ \\ \\textbf{cred\\ ( } op1 , value1\\textbf{)}\\ ] ^{0,1 } \\textbf { : } \\thicksim   op2~ pred1(arg1\\ [ , \\ arg2]^*\\ ) \\nonumber \\\\ \\ [ , \\ pred2(arg1\\ [ , \\ arg2]^*\\ ) ] \\ .\\",
    "\\label{eq - def - predicate}\\end{aligned}\\ ] ]    the following examples show its usage .",
    "the second one uses the operator _",
    "prod _ for aggregating truth values of the subgoals of the body and the operator _",
    "min _ to aggregate the result with the credibility of the rule , 0.8 . as can be deduced from syntax and examples , _ cred _ and _ : @xmath8 _",
    "are reserved words .    ....",
    "tempting_restaurant(r ) : ~ prod low_distance(r ) , cheap(r ) ,                                  traditional(r ) . ....    .... good_player(j ) cred ( min,0.8 ) : ~ prod swift(j ) , tall(j ) ,                                         experience(j ) . ....",
    "unfortunately , information provided by the user is not complete in general .",
    "so there are many cases in which we have no information about the truth value of an individual or a set of them . nevertheless , it is interesting not to stop a complex query evaluation just because we have no information about one or more subgoals if we can use a reasonable approximation .",
    "the solution to this problem is using default truth values for these cases .",
    "the rfuzzy extension to define a default truth value for a predicate when applied to individuals for which the user has not defined an explicit truth value is named _ general default truth value_.    _ conditioned default truth value _ is used when the default truth value only applies to a subset of the function s domain .",
    "this subset is defined by a membership predicate which is true only when an individual belongs to the subset .",
    "the membership predicate ( _ membership_predicate / ar _ ) and the predicate to which it is applied ( _ pred / ar _ ) need to be have the same arity ( _ ar _ ) . if not , an error message will be shown at compilation time .",
    "the syntax for defining a general default truth value is shown in ( [ eq - def - defaults ] ) , and the syntax for assigning a conditioned default truth value is shown in ( [ eq - def - default - with - conditions ] ) .",
    "_ pred / ar _ is in both cases the predicate to which we are defining default values .",
    "as expected , when defining the three cases ( explicit , conditioned and default truth value ) only one will be given back when doing a query .",
    "the precedence when looking for the truth value goes from the most concrete to the least one .",
    "@xmath9 @xmath10    the example below shows how to assign a default truth value of 0.5 to all cars that do not have an explicit truth value nor have a default conditioned truth value .",
    "besides , it shows how to assign a conditioned default truth value to all cars belonging to a small subset and not having an explicit truth value .",
    "this subset is determined by the membership predicate _",
    "expensive_type/1 _ , and default truth value for its elements is 0.9 .",
    "lamborghini_urraco _ is an _ expensive_car _ with truth value 0.9 but _",
    "vw_caddy _ is an _",
    "expensive_car _ with truth value 0.5 .",
    "both values are default approximations because we have no direct declaration ( as for _ alfa_romeo_gt _ that is an _",
    "expensive_car _ with a truth value 0.6 as we show above ) .",
    ".... : - set_prop expensive_car/1 = > car/1 .",
    ": - default(expensive_car/1 , 0.9 ) = >",
    "expensive_type/1 . : - default(expensive_car/1 , 0.5 ) .    expensive_type(lamborghini_urraco ) .",
    "expensive_type(aston_martin_bulldog ) . ....",
    "indeed the program has to be run . when compiling , _",
    "rfuzzy  _ adds a new argument to the arguments list of each fuzzy predicate .",
    "this argument serves for querying about the predicate truth value .",
    "it can be seen as syntactic sugar , as truth value is not part of the predicate arguments , but metadata information .",
    "truth value argument is added to the predicates in a uniform way : it is always a new argument at the end of the arguments list of the predicate . in the previous example we wrote _",
    ", so to query the system we have to give the predicate two arguments instead of only one where the second one will represent the query s truth value",
    ". this can be seen in the first example of subsection [ constructive - answers ] .",
    "a fuzzy tool should be able to provide constructive answers for queries .",
    "the regular ( easy ) questions are asking for the truth value of an element .",
    "for example , how expensive is an _",
    "alfa_romeo_gt _ ?",
    "- expensive_car(alfa_romeo_gt , v ) .",
    "v = 0.6 ? ; no ....    but the really interesting queries are the ones that ask for values that satisfy constraints over the truth value .",
    "for example , which cars are very expensive ? .",
    "rfuzzy provides this constructive functionality .    .... ?",
    "- expensive_car(x , v ) , v > 0.8 .",
    "v = 0.9 , x = aston_martin_bulldog ? ; v = 0.9 , x = lamborghini_urraco ? ; no ....    the rfuzzy package implements a meta - translation of the rfuzzy syntax to iso prolog , via clp(r ) , this is the reason for its constructivity .",
    "rfuzzy is mainly suitable for expert systems applications . as mentioned before ,",
    "its main advantages in comparison to fuzzy prolog are its simpler syntax , the use of real numbers instead of intervals between them and the implicit handling of truth values .",
    "besides , it presents facts truth values ( explicit , default or conditioned default truth value ) , functions truth values and rules ( with or without credibility ) which simplifies the user development process a lot .    although a medical expert system development were the best example of using rfuzzy , due to lack of space we prefer to show here one in which we decide which is the best restaurant for going out .    in the example",
    "we can see that we know the distance to all the restaurants in a crisp way .",
    "this crisp value is translated by means of _ low_distance _ and _ low_distance_aux _ into a fuzzy one which is used into _ tempting_restaurant _ to determine its truth value .",
    "this allows us to ask which is the truth value of each tempting restaurant , which restaurant is a tempting restaurant with a truth value of , for example , 0.7 or list all tempting restaurants with their truth values .",
    "the rfuzzy module with installation instructions and examples can be downloaded from http://babel.ls.fi.upm.es / software / rfuzzy/.",
    "rfuzzy is a logic programming language that is able to model all the extensions that are described in section [ rfuzzy : syntax ] .",
    "it is implemented as a ciao prolog @xcite package because ciao prolog offers the possibility of dealing with a higher order compilation through the implementation of ciao packages .",
    "those packages serve as input for the _ `` ciao system preprocessor '' _ ( ciaopp ) @xcite , a tool able to perform source - to - source transformations .",
    "the reason beyond the implementation of _ rfuzzy _ as a ciao prolog package is that the resultant code has to deal with two kinds of queries :    * queries in which the user asks for the truth value of an individual , and * queries in which the user asks for an individual with a concrete truth value .",
    "as can be seen in the following example , this is not an easy task .    .... ? - a is 1 , b is 2 , c is a + b.    a = 1 , b = 2 , c = 3 ? .",
    "- c is 3 , c is a + b. { error : illegal arithmetic expression } { error : illegal arithmetic expression } no",
    "? -   ....    formula _",
    "c is a + b _ only works if variables a and b are bound .",
    "almost all predicates that are problematic with non - bound variables have inside comparisons and/or assignments .",
    "this aims us to translate rfuzzy programs into clp(@xmath1 ) programs .",
    "clp(@xmath1 ) is a ciao prolog package which translates real number operations into constraints applied to the variables involved in those operations .    taking advantage of rfuzzy and clp(@xmath1 ) transformations",
    ", our tool compiles rfuzzy programs into iso prolog programs , so the interpreter is able to work with them as it normally does . as a result ,",
    "the global compilation process has two preprocessor steps : ( 1 ) the rfuzzy program is translated into clp(@xmath1 ) constraints by means of the rfuzzy package and ( 2 ) those constraints are translated into iso prolog by using the clp(@xmath1 ) package .",
    "[ fig : rfuzzy_architecture ] shows the whole process .        in the following example the predicate _ tempting_restaurant _",
    "is translated from rfuzzy syntax into iso prolog syntax . in the first step , the rfuzzy package inserts truth value variables , the _ inject _ metapredicate call ( one of its arguments is the aggregation operator to be used , _ prod _ ) and inserts rfuzzy comparisons to take care at execution time that the rule s truth value is always between zero and one . in the second step , clp(@xmath1 )",
    "converts comparisons into constraints ( via predicate calls ) .",
    ".... % rfuzzy program tempting_restaurant(r ) : ~ prod low_distance(r ) , cheap(r ) ,                                  traditional(r ) .",
    "....    .... % clp(r ) program rfuzzy_rule_tempting_restaurant(r,_1 ) : -          low_distance(r,_2 ) ,          cheap(r,_3 ) ,          traditional(r,_4 ) ,          inject([_2,_3,_4],prod,_1 ) ,          _ 1 .>=. 0 ,           _ 1 .=<. 1 .",
    "....    .... % iso prolog program rfuzzy_rule_tempting_restaurant(r,_1 ) : -          low_distance(r,_2 ) ,          cheap(r,_3 ) ,          traditional(r,_4 ) ,          inject([_2,_3,_4],prod,_1 ) ,          solve_generic_1(le,0,_1,-1 ) ,          solve_generic_1(le,-1,_1,1 ) . ....    internally , rfuzzy package unifies and translates all the information given by the user to each predicate ( types , default values with and without condition , truth values defined in facts and rules with and without credibility ) into a single predicate body",
    ". a simplified version of the skeleton used for that predicate is shown below .    _",
    "rfuzzy package simplified skeleton _    ....    main : - types , ( normal ; default )    normal : - ( fact ;               ( \\+(fact_aux ) , function ) ;                ( \\+(fact_aux ) , \\+(function_aux ) , rule )             )    default : - \\+(fact_aux ) , \\+(function_aux ) , \\+(rule_aux ) ,",
    "( cl_with_cond ;                  ( \\+(cl_with_cond_aux ) , cl_with_no_cond )                ) ....    the skeleton has three different parts : the one which takes care of allowing only queries or answers with the expected individuals , the one which looks for a concrete truth value ( it can be defined by means of a fact , a function or a rule ) and the one which looks for a default truth value ( conditioned or not ) .",
    "predicates ending in _ aux do not take care on the truth value argument .",
    "the first part is obtained from the type definitions ( see [ type - definition ] ) , translating all types into a predicate which is called at first ( types ) so we assure we only work with the expected individuals .",
    "the second part looks for a concrete value whose arguments have to unify with the parameters the user has given .",
    "precedence when looking for it is :    1 .   a fact ( see subsection [ fact - truth - value ] ) 2 .",
    "a function ( see subsection [ functional - truth - value ] ) 3 .   a rule ( see subsection [ rule - truth - value ] )",
    "the third part is only called when the second one ( searching for a truth value ) fails , and looks for a conditioned or default truth value .",
    "_ rfuzzy _ offers to the users a new framework to represent fuzzy problems over real numbers . _ fuzzy prolog _",
    "@xcite is an existing framework for dealing with fuzzy problems representation .",
    "advantages over _ fuzzy prolog _ are a simpler syntax and the elimination of answers with constraints , and _",
    "is one of the first tools modelling multi - adjoint logic , as explained in subsection [ subsec : motivation ] .",
    "_ rfuzzy _ syntax is simpler that _ fuzzy prolog _ syntax .",
    "its fuzzy values are simple real numbers instead of intervals between real numbers , and it hides the management of truth value variables . as normal fuzzy problems do not use intervals to represent fuzziness and do not need to code an uncommon behaviour of fuzzy variables , this syntax reduction is an advantage .",
    "programs written in _ rfuzzy _ syntax are more legible and more easy to understand than _ fuzzy prolog _ programs .",
    "_ fuzzy prolog _ answers to user queries are difficult to understand due to the existence of constraints . as normal replies to final users are ground terms , the programmer has to code by hand how to reach them . to eliminate those constraints and",
    "answer queries with ground terms the programmer tries to substitute variables with ground terms until one makes true all of them .",
    "_ rfuzzy _ offers a powerful tool to deal with this task : _ type definition_. _ type definition _ ( see subsection [ type - definition ] ) allows the user to define which terms are suitable for being substituted into a variable , so she does not have to code this behaviour again .",
    "besides , the elimination of answers with constraints provides more human readable answers and more easy to test programs ( because answers we test do not have constraints , just ground terms ) .",
    "there is also an extension to introduce default truth values . as world information is sometimes incomplete , _ rfuzzy _ offers to the user the possibility to define default truth values and default conditioned truth values ( see subsection [ general - and - conditioned - default - truth - values ] ) .",
    "this allows us to make inference with default truth values when we do not know anything about the truth of some fact .",
    "extensions added to _ prolog _ by _ rfuzzy _ are : types , default truth values ( conditioned or not ) , assignment of truth values to individuals by means of facts , functions or rules , and assignment of credibility to the rules .",
    "there are countless applications and research lines which can benefit from the advantages of using the fuzzy representations offered by rfuzzy .",
    "some examples are : search engines , knowledge extraction ( from databases , ontologies , etc . ) , semantic web , business rules , and coding rules ( where the violation of one rule can be given a truth value ) .",
    "current work on rfuzzy tries to apply constructive negation to the engine .",
    "rfuzzy needs to define types in a constructive way ( by means of predicates that are able to generate all their individuals by backtracking ) so we can not use constraints .",
    "future research will be done in this line for widening the definition of types .",
    "abietar , p.j .",
    "morcillo , and g.  moreno . designing a software tool for fuzzy logic programming . in t.e .",
    "simos and g.  maroulis , editors , _ proc . of the int .",
    "conf . of computational methods in sciences and engineering .",
    "iccmse07 _ ,",
    "volume  2 of _ computation in mordern science and engineering _ , pages 11171120 .",
    "american institute of physics , 2007 .",
    "distributed by springer .",
    "f.  bueno , p.  lpez - garca , g.  puebla , and m.  hermenegildo .",
    "he ciao prolog preprocessor .",
    "technical report clip8/95.0.7.20 , technical university of madrid ( upm ) , facultad de informtica , 28660 boadilla del monte , madrid , spain , 1999 .",
    "s.  munoz - hernandez , c.  vaucheret , and s.  guadarrama .",
    "combining crisp and fuzzy logic in a prolog compiler . in j.  j. moreno - navarro and j.  mario , editors , _ joint conf . on declarative programming : appia - gulp - prode 2002 _ , pages 2338 , madrid , spain , september 2002 .                    c.  vaucheret , s.  guadarrama , and s.  munoz - hernandez .",
    "fuzzy prolog : a simple general implementation using clp(r ) . in m.",
    "baaz and a.  voronkov , editors , _ logic for programming , artificial intelligence , and reasoning , lpar 2002 _ , number 2514 in lnai , pages 450463 , tbilisi , georgia , october 2002 .",
    "springer - verlag .    c.  vaucheret , s.  guadarrama , and s.  munoz - hernandez .",
    "fuzzy prolog : a simple general implementation using clp(r ) . in p.j .",
    "stuckey , editor , _ int .",
    "conf . in logic programming ,",
    "iclp 2002 _ , number 2401 in lncs , page 469 , copenhagen , denmark , july / august 2002 .",
    "springer - verlag ."
  ],
  "abstract_text": [
    "<S> fuzzy reasoning is a very productive research field that during the last years has provided a number of theoretical approaches and practical implementation prototypes . </S>",
    "<S> nevertheless , the classical implementations , like fril , are not adapted to the latest formal approaches , like multi - adjoint logic semantics .    </S>",
    "<S> some promising implementations , like fuzzy prolog , are so general that the regular user / programmer does not feel comfortable because either representation of fuzzy concepts is complex or the results difficult to interpret .    </S>",
    "<S> in this paper we present a modern framework , _ rfuzzy _ , that is modelling multi - adjoint logic . </S>",
    "<S> it provides some extensions as default values ( to represent missing information , even partial default values ) and typed variables . </S>",
    "<S> rfuzzy represents the truth value of predicates through facts , rules and functions . </S>",
    "<S> rfuzzy answers queries with direct results ( instead of constraints ) and it is easy to use for any person that wants to represent a problem using fuzzy reasoning in a simple way ( by using the classical representation with real numbers ) .    reasoning , implementation tool , fuzzy logic , multi - adjoint logic , logic programming application </S>"
  ]
}