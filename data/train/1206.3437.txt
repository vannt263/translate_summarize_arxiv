{
  "article_text": [
    "given a @xmath0 node , @xmath1 arc complete directed weighted graph @xmath2 , the asymmetric traveling salesman problem  @xcite ( atsp ) consists in finding a partial subgraph @xmath3 of @xmath4 which forms a hamiltonian circuit of minimum cost .",
    "this np - hard problem is one of the most studied by the operation research community .",
    "it has various practical applications such as vehicle routing problems of logistics , microchips production optimization or even scheduling .    the symmetric tsp is well handled by linear programming techniques @xcite .",
    "however , such methods suffer from the addition of side constraints and asymmetric cost matrix , whereas constraint programming models do not .",
    "since the real world is not symmetric and industrial application often involve constraints such as time windows , precedences , loading capacities and several other constraints , improving the cp general model for solving the atsp leads to make cp more competitive on real world routing problems .",
    "recent improvements on cost based relaxations  @xcite had a very strong impact on the ability of cp technologies to solve the tsp . in this paper",
    ", we investigate how the graph structure can contribute to the resolution process , in order to tackle larger instances . for this purpose",
    ", we developed usual and original filtering algorithms using classical graph structures , such as strongly connected components or dominators .",
    "we analyzed their behavior both from a quantitative ( time complexity ) and a qualitative ( consistency level ) point of view .",
    "also , we experimentally show that such implied propagators bring robustness to hard instances , and highlight the fact that the graph structure can significantly improve the behavior of search heuristics .",
    "our main contribution is both a theoretical and an experimental study which lead to a robust model that outperforms state of the art results in cp .",
    "this paper is divided into six main parts .",
    "section  [ definitions ] provides some vocabulary and notations .",
    "section  [ sota ] discusses the state of the art implied constraints .",
    "next , we show in section  [ rg ] how the reduced graph can provide useful information for pruning and improving existing models . in section  [ hk ]",
    "we provide some improvements about the implementation of the held and karp method within a directed context .",
    "section  [ xp ] shows an experimental study on the atsp and some openings about its symmetric version ( tsp ) .",
    "section  [ conclusion ] concludes the paper with several perspectives .",
    "let us consider a directed graph @xmath5 .",
    "a _ strongly connected component _ ( scc ) is a maximal subgraph of @xmath4 such that for each pair of nodes @xmath6 , a path exists from @xmath7 to @xmath8 and from @xmath8 to @xmath7 .",
    "a _ reduced graph _",
    "@xmath9 of a directed graph @xmath4 represents the scc of @xmath4 .",
    "this graph is obtained by merging the nodes of @xmath4 which are in the same scc and removing any loop .",
    "such a graph is unique and contains no circuit .",
    "we link @xmath4 and @xmath10 with two functions : @xmath11  @xmath12 and @xmath13  @xmath14 .",
    "the method @xmath11  can be represented by one @xmath0-size integer array . also , since each node of @xmath15 belongs to exactly one scc of @xmath16 , the method @xmath13  can be represented by two integer arrays : the first one represents the canonical element of each scc while the second one links nodes of the same scc , behaving like a linked list .",
    "those two arrays have respectively size of @xmath17 and @xmath0 , where @xmath18 .",
    "the _ transitive closure _ of @xmath4 is a graph @xmath19 representing node reachability in @xmath4 , i.e. such that @xmath20 if and only if a path from @xmath21 to @xmath22 exists in @xmath4 .    in a cp context",
    "a _ graph variable _ can be used to model a graph .",
    "such a concept has been introduced by le pape et al .",
    "@xcite and detailed by rgin @xcite and dooms et al .",
    "we define a graph variable @xmath23 by two graphs : the graph of _ potential _ elements , @xmath24 , contains all the nodes and arcs that potentially occur in at least one solution whereas the graph of _ mandatory _ elements , @xmath25 , contains all the nodes and arcs that occur in every solution .",
    "it has to be noticed that @xmath26 . during resolution",
    ", decisions and filtering rules will remove nodes / arcs from @xmath27 and add nodes / arcs to @xmath28 until the graph variable is instantiated , i.e. when @xmath29 .",
    "it should be noticed that , regarding the tsp , @xmath30 , so resolution will focus on @xmath31 and @xmath32 : branching strategies and propagators will remove infeasible arcs from @xmath32 and add mandatory arcs of @xmath32 into @xmath31 .",
    "this section describes the state of the art of existing approaches for solving atsp with cp .",
    "we distinguish the structural filtering , which ensures that a solution is a hamiltonian path , from cost based pruning , which mainly focus on the solution cost .",
    "then , we study a few representative branching heuristics .    given , a directed weighted graph @xmath33 , and a function @xmath34 the atsp consists in finding a partial subgraph @xmath3 of @xmath4 which forms a hamiltonian circuit of minimum cost .",
    "a simple atsp model in cp , involving a graph variable @xmath23 , can basically be stated as minimizing the sum of costs of arcs in the domain of @xmath23 and maintaining @xmath23 to be a hamiltonian circuit with a connectivity constraint and a degree constraint ( one predecessor and one successor for each node ) . however , it is often more interesting to convert such a model in order to find a path instead of a circuit  @xcite .",
    "our motivation for this transformation is that it brings graph structure that is more likely to be exploited .    in this paper",
    ", we consider the atsp as the problem of finding a minimum cost hamiltonian path with fixed start and end nodes in a directed weighted graph . in the following , @xmath35",
    "respectively denote the start and the end of the expected path . @xmath36 and @xmath37 are supposed to be known .",
    "they can be obtained by duplicating any arbitrary node , but it makes more sense to duplicate the node representing the salesman s home .",
    "our formulation of the atsp involves the search of a path instead of a circuit , the _ degree constraints _ has thus to be stated as follows : for all @xmath38 and for any @xmath39 , where @xmath40 ( respectively @xmath41 ) denotes the number of successors ( respectively predecessors ) of @xmath42 .",
    "extremal conditions , being @xmath43 , are ensured by the initial domain of the graph variable .",
    "an efficient filtering can be obtained with two special purpose incremental propagators .",
    "one reacts on mandatory arc detections : whenever arc @xmath44 is enforced , other outgoing arc of @xmath45 and ingoing arcs of @xmath42 can be pruned .",
    "the other reacts on arc removals : whenever a node has only one outgoing ( or ingoing ) potential arc left , this arc is mandatory and can be enforced . a higher level of consistency can be achieved by using a graph - based @xmath46  constraint maintaining a node - successor perfect matching  @xcite . _ deleting circuits _",
    "is the second important structural aspect of the tsp .",
    "caseau and laburthe @xcite suggested the simple and efficient @xmath47  constraint to remove circuits of the graph .",
    "their fast incremental algorithm is based on the subpaths fusion process .",
    "it runs in constant time per arc enforcing event .",
    "the conjunction of this circuit elimination constraint and the above degree constraints is sufficient to guarantee that the solution is a hamiltonian path from @xmath36 to @xmath37 .",
    "however , other implied constraints provide additional filtering that may help the resolution process . for instance",
    ", quesada  @xcite suggested the general propagator @xmath48  which maintains the transitive closure and the dominance tree of the graph variable .",
    "however , its running time , @xmath49 in the worst case , makes it unlikely to be profitable in practice .",
    "a faster constraint , also based on the concept of dominance , is the @xmath50  constraint .",
    "it is nothing else but a simplification of the @xmath51  constraint @xcite recently improved to a @xmath52 worst case time complexity @xcite .",
    "given a graph variable @xmath23 and a node @xmath36 , such a constraint ensures that @xmath23 is an arborescence rooted in node @xmath36 .",
    "more precisely , it enforces gac over the conjunction of the following properties : @xmath27 has no circuit , each node is reachable from @xmath36 and , each node but @xmath36 has exactly one predecessor .",
    "such a filtering can also be used to define the @xmath53  by switching @xmath36 with @xmath37 and predecessors with successors .",
    "a dual approach consists in assigning to each node its position in the path .",
    "in such a case , the position of a node is represented by an integer variable with initial domain @xmath54 $ ] .",
    "positions are different from a node to another , which can be ensured by an @xmath46  constraint .",
    "since the number of nodes is equal to the number of positions , the bound consistency algorithm of @xmath46  constraint only requires @xmath55 time . plus , a channeling has to be done between the graph variable and position variables .",
    "such a channeling requires @xmath52 worst case time . in particular , lower bounds of positions",
    "are adjusted according to a single breadth first search ( bfs ) of @xmath56 while upper bounds of positions are shortened by a bfs of @xmath57 .",
    "it has to be noticed that this approach is related to disjunctive scheduling @xcite : nodes are tasks of duration 1 which are executed on the same machine .",
    "the structure of the input graph creates implicit precedence constraints .",
    "finally , some greedy procedures based on the finding of cuts have been suggested in the literature : benchimol et al .",
    "enforce some cut - sets of size two @xcite while kaya and hooker use graph separators for pruning @xcite .",
    "the drawback of such methods is that they provide no level of consistency .",
    "cp models often embed relaxation based constraints , to provide inference from costs .",
    "fischetti and toth @xcite suggested a general bounding procedure for combining different relaxations of the same problem .",
    "the most natural relaxation is obtained by considering the cheapest outgoing arc of each node : @xmath58 .",
    "such a lower bound can be computed efficiently but it is in general relatively far from the optimal value .",
    "a stronger relaxation is the weighted version of the @xmath46  constraint , corresponding to the minimum assignment problem ( map ) .",
    "it requires @xmath59 time  @xcite to compute a first minimum cost assignment but then @xmath60 time  @xcite to check consistency and filter incrementally .",
    "some interesting evaluations are provided by  @xcite , but are mainly related to the tsp with time windows constraints .",
    "a widely exploited subproblem of the atsp is the minimum spanning tree ( mst ) problem where the degree constraint and arc direction are relaxed .",
    "we remark that a hamiltonian path is a spanning tree and that it is possible to compute a mst with a degree restriction at one node  @xcite .",
    "a mst can be computed in two ways .",
    "the first one is kruskal s algorithm , which runs in @xmath61 worst case time , where @xmath62 is the inverse ackermann function , but requires edges to be sorted according to their weights . sorting edges can be done once and for all in @xmath63 time .",
    "the second option is to use prim s algorithm which requires @xmath64 time with fibonacci heaps  @xcite or @xmath65 time if binomial heaps are used instead .",
    "based on kruskal s algorithm , rgin et al .",
    "@xcite made the @xmath66  constraint which ensures consistency , provides a complete pruning and detects mandatory arcs incrementally , within @xmath61 time .",
    "dooms and katriel  @xcite presented a more complex @xmath67  constraint which maintains a graph and its spanning tree , pruning according to king s algorithm  @xcite .",
    "an improvement of the mst relaxation is the approach of held and karp  @xcite , adapted for cp by benchimol et al.@xcite .",
    "it is the lagrangian mst relaxation with a policy for updating langrangian multipliers that provides a fast convergence .",
    "the idea of this method is to iteratively compute mst that converge towards a path by adding penalties on arc costs according to degree constraints violations .",
    "it must be noticed that since arc costs change from one iteration to another , prim s algorithm is better than kruskal s which requires to sort edges .",
    "moreover , to our knowledge neither algorithm can be applied incrementally .",
    "a more accurate relaxation is the minimum spanning arborescence ( msa ) relaxation , since it does not relax the orientation of the graph . this relaxation has been studied by  @xcite who provide a @xmath60 time filtering algorithm based on primal / dual linear programs .",
    "the best algorithm for computing a msa has been provided by gabow et al .",
    "their algorithm runs in @xmath68 worst case time , but it does not provide reduced costs that are used for pruning .",
    "thus , it could be used to create a @xmath69  constraint with a @xmath68 time consistency checking but the complete filtering algorithm remains in @xmath60 time .",
    "the lagrangian msa relaxation , with a msa computation based on edmonds algorithm , has been suggested in  @xcite .",
    "this method was very accurate but unfortunately unstable .",
    "also , benchimol et al .",
    "@xcite report that the msa based held and karp scheme lead to disappointing results .      branching strategies forms a fundamental aspect of cp which can drastically reduce the search space .",
    "we study here dedicated heuristics , because the literature is not clear about which branching heuristic should be used .",
    "pesant et al . have introduced _",
    "heuristic  @xcite which has the singularity of considering occurrences of successors and ignoring costs . in this way",
    ", this heuristic is based on the graph structure",
    ". it behaves as following : first , it selects the set of nodes @xmath70 with no successor in @xmath28 and the smallest set of successors in @xmath27 .",
    "second , it finds the node @xmath71 which maximize @xmath72 .",
    "the heuristic then iterates on @xmath73 s successors .",
    "this process is optimized by performing a dichotomic exploration of large domains .",
    "however , very recently , benchimol et al .",
    "@xcite suggested a binary heuristic , based on the mst relaxation , that we call  _ removemaxrc_. it consists in removing from @xmath27 the tree arc of maximum replacement cost , i.e. the arc which would involve the highest cost augmentation if it was removed .",
    "by tree arc , we mean the fact that it appears in the mst of the last iteration of the held and karp procedure .",
    "acutally , as shown in section [ xp ] , this branching leads to poor results and should not be used .",
    "finally , focacci et al .",
    "solve the tsptw @xcite by guiding the search with time windows , which means that the efficiency of cp for solving the atsp should not rely entirely on its branching heuristic .",
    "in this section , we consider a subproblem which is not a subset of constraints , as usual , but consists in the whole atsp itself applied to a more restrictive scope : the reduced graph of @xmath27 .",
    "the structure of the reduced graph has already been considered in a similar way for path partitioning problems @xcite . in this section ,",
    "we first study structural properties that arise from considering the reduced graph .",
    "second , we show how to adapt such information to some state of the art implied models , including cost based reasonings .",
    "we introduce a propagator , the @xmath74  propagator , which makes the reduced graph a ( hamiltonian ) simple path and ensures by the way that each node is reachable from @xmath36 and can reach @xmath37 .",
    "it is a monotonic generalization of the algorithm depicted in @xcite .",
    "necessary conditions for this propagator have already been partially highlighted in @xcite .",
    "we first modify them in order to fit with the tsp and our model .",
    "next , we provide a linear time incremental algorithm",
    ".    reduced path guarantees that any arc in @xmath27 that connects two scc , is part of a simple path which go through every scc of @xmath27 .",
    "[ rgunicity ] given any directed graph @xmath4 , its reduced graph @xmath10 contains at most one hamiltonian path .",
    "let us consider a graph @xmath4 such that @xmath10 contains at least two hamiltonian paths @xmath75 and @xmath76 , @xmath77 .",
    "since both @xmath75 and @xmath76 are hamiltonian then there exists at least two nodes @xmath78 , @xmath79 , such that @xmath73 is visited before @xmath80 in @xmath75 and after @xmath80 in @xmath76 .",
    "thus , the graph @xmath81 contains a path from @xmath73 to @xmath80 and from @xmath80 to @xmath73 .",
    "this is a circuit . as @xmath82",
    ", @xmath10 also contains a circuit , which is a contradiction .",
    "we note @xmath10 the reduced graph of @xmath27 .",
    "we remark that , as @xmath36 has no predecessor then its scc is the node @xmath36 itself . also , as @xmath37 has no successor then @xmath83@xmath84 .",
    "to distinguish nodes of @xmath15 from nodes of the reduced graph , we note @xmath85@xmath86 and @xmath83@xmath87 .",
    "it follows that any hamiltonian path in @xmath10 will be from @xmath88 to @xmath89 .",
    "[ rgcond ] if there exists a hamiltonian path from @xmath36 to @xmath37 in @xmath27 then there exists a hamiltonian path in @xmath10 .",
    "lets suppose that @xmath10 has no hamiltonian path from @xmath88 to @xmath89 .",
    "then for any path @xmath90 in @xmath10 starting at @xmath88 and ending at @xmath89 , there exist at least one node @xmath91 , which is not visited by @xmath90 .",
    "thus , for any path @xmath92 in @xmath27 starting at @xmath36 and ending at @xmath37 , there exist at least one scc @xmath91 which is not traversed by @xmath92 , so @xmath93 @xmath94 , then @xmath95 .",
    "thus any path in @xmath27 starting at @xmath36 and ending at @xmath37 is not hamiltonian .",
    "it follows that any transitive arc of @xmath10 must be pruned and that remaining arcs of @xmath10 are mandatory ( otherwise the graph becomes disconnected ) : any scc , but @xmath89 , must have exactly one outgoing arc .",
    "an example is given in figure  [ rp_fig ] : the graph @xmath27 contains four scc .",
    "its reduced graph , @xmath10 , has a unique hamiltonian path @xmath96 .",
    "arcs of @xmath97 are infeasible so @xmath98 and @xmath99 must be pruned from @xmath27 .    we introduce a new data structure in @xmath10 that we call @xmath100  : for each node @xmath101 , @xmath102 is the list of arcs @xmath103 @xmath104@xmath105 and @xmath106@xmath107 .",
    "we can now easily draw a complete filtering algorithm for the @xmath74  propagator which ensures the gac over the property that @xmath10 must be a path in @xmath52 time :    1 .",
    "data structures : compute the scc of @xmath27 ( with tarjan s algorithm @xcite ) and build the reduced graph @xmath9.[data ] 2 .   taking mandatory arcs into account : @xmath108 such that @xmath109@xmath104 and @xmath110@xmath106 , @xmath111 @xmath102 @xmath112 remove arc @xmath113 .",
    "[ mand ] 3 .",
    "consistency checking : make @xmath10 a path if possible , fail otherwise .",
    "[ const ] 4 .   for each arc",
    "@xmath114 such that @xmath109@xmath104 and @xmath115@xmath106 , @xmath79 , 1 .   pruning : if @xmath116 , remove arc @xmath44 .",
    "[ pruning ] 2 .   enforcing :",
    "if @xmath117 and @xmath44 is the only arc of @xmath32 that links @xmath73 and @xmath80 , enforce arc @xmath44 . [ enforcing ]    a procedure performing step [ const ]",
    "starts on node @xmath88 , finds its right successor @xmath118 ( the one which has only one predecessor ) and removes other outgoing arcs .",
    "then , the same procedure is applied on @xmath118 and so on , until @xmath89 is reached .",
    "such an algorithm must be performed once during the initial propagation .",
    "then , the propagator reacts to fine events . to have an incremental behavior",
    ", the propagator must maintain the set of scc and the reduced graph .",
    "haeupler et al .",
    "@xcite worked on maintaining scc and a topological ordering of nodes in the reduced graph , but under the addition of arcs .",
    "we deal with arc deletions .",
    "moreover , we may have lots of arc deletions per propagation ( at least for the first ones ) , thus we should not use a completely on - line algorithm .    _",
    "scc maintenance : _ let us consider an arc @xmath119 such that @xmath104@xmath105 and @xmath106@xmath120 . if @xmath121 and if @xmath44 is removed from @xmath32 then it must be removed from @xmath102 also .",
    "if @xmath122 then the removal of @xmath44 may split the scc @xmath73 , so computation is required .",
    "as many arcs can be removed from one propagation to another , we suggest a partially incremental algorithm which computes exclusively scc that contains at least one removed arc , each one exactly once . we introduce a bit set to mark nodes of @xmath10 .",
    "initially , each node is unmarked , then when a removed arc , inside an unmarked scc @xmath73 , is considered , we apply tarjan s algorithm on @xmath123 @xmath94 and mark @xmath73 .",
    "tarjan s algorithm will return either @xmath73 if @xmath73 is still strongly connected , or the new set of scc induced by all arc removals from @xmath73 . in both cases",
    ", we can ignore other arcs that have been removed from @xmath94 .",
    "since the scc of a graph are node - disjoint , the overall processing time of a propagation dealing with @xmath124 arc deletions involving some scc @xmath125 is @xmath126 .    _",
    "@xmath10 maintenance and filtering : _ algorithm  [ algorghpfinderincr ] shows how to get an incremental propagator that reacts to scc splits .",
    "when a scc @xmath73 is split into @xmath124 new scc , the reduced graph gets @xmath127 new nodes and must be turned into a path while some filtering may be performed on @xmath23 .",
    "the good thing is that there is no need to consider the entire graph .",
    "we note @xmath128 the set of nodes induced by the breaking of scc @xmath73 . since @xmath10 was a path at the end of the last propagation , we call @xmath129 the predecessor of @xmath73 in @xmath10 and @xmath36 its successor .",
    "then , we only need to consider nodes of @xmath130 in @xmath10 .",
    "to compute new arcs in @xmath10 it is necessary to examine arcs of @xmath27 , but only @xmath131 and arcs that have the tail in a scc of @xmath70 need to be considered . note that we filter during the maintenance process .",
    "let @xmath132 be the old scc split into a set @xmath133 of new scc    @xmath134 @xmath135 @xmath136    @xmath137 + @xmath138    @xmath139 @xmath140 @xmath141 @xmath142 @xmath143 @xmath144 @xmath145 @xmath146 @xmath147    once we get those data structures , then it is worth exploiting them the most we can , to make such a computation profitable .",
    "especially , a few trivial ad hoc rules come when considering scc .",
    "we call an _ indoor _ a node with a predecessor outside its own scc , an _ outdoor _ , a node with a successor outside its scc and a _ door _ a node which is an indoor or / and an outdoor .",
    "[ indoor ] if a scc @xmath70 has only one indoor @xmath148 , then any arc @xmath149 is infeasible .",
    "first we remark that @xmath21 can not be @xmath36 since @xmath36 has no predecessors .",
    "let us then suppose that such arc @xmath150 is enforced",
    ". as the tsp requires nodes of @xmath151 to have exactly one predecessors , all other predecessors of @xmath21 will be pruned . as @xmath21 was the only indoor of @xmath70 , then @xmath70 is not reachable anymore from @xmath88 , which is by proposition [ rgcond ] a contradiction .    by symmetry ,",
    "if a scc @xmath70 has only one outdoor @xmath148 , then any arc @xmath152 is infeasible .",
    "moreover , if a scc @xmath70 of more than two nodes has only two doors @xmath153 , then arcs @xmath154 and @xmath155 are infeasible .",
    "in general , the reduced graph provides three kinds of information : precedences between nodes of distinct scc ; reachability between nodes of the graph ; cardinality sets @xmath156@xmath102@xmath157 .",
    "such information can be directly used to generate lazy clauses @xcite .",
    "it can also improve the quality of the channeling between the graph variable and position variables by considering precedences : when adjusting bounds of position variables ( or time windows ) , the bfs must be tuned accordingly , processing scc one after the other .",
    "some propagators such as @xmath48  @xcite , require the transitive closure of the graph .",
    "its computation requires @xmath49 worst case time in general , but since the reduced graph is now a path , we can sketch a trivial and optimal algorithm : for any node @xmath158 , we call @xmath159 the set of nodes reachable from @xmath42 in @xmath27 and @xmath160 the set of nodes reachable from @xmath106@xmath161 in @xmath10 , including @xmath106 . more formally , @xmath162 and @xmath163 , where @xmath109@xmath106 . then , for any node @xmath164 , @xmath165@xmath166 @xmath167 . as @xmath10 is",
    "a path , iterating on @xmath168 requires @xmath169 operations .",
    "also , since scc are node - disjoints , computing @xmath170 takes @xmath171@xmath166@xmath172 because @xmath173 and @xmath174@xmath166 @xmath175 . as @xmath176",
    ", the computation of the transitive closure takes @xmath177 which is bounded by @xmath60 .",
    "it can be performed incrementally by considering scc splits only .",
    "finally we show how the mst relaxation of the tsp can be improved by considering the reduced graph .",
    "we call a bounding spanning tree ( bst ) of @xmath27 a spanning tree of @xmath27 obtained by finding a minimum spanning tree in every scc of @xmath27 independently and then linking them together using the cheapest arcs :    ll @xmath178 & @xmath179 @xmath94@xmath180 + & @xmath181 @xmath182 @xmath183@xmath184 . +     +    the resulting spanning tree provides a tighter bound than a mst .",
    "indeed , since bst and mst both are spanning trees , @xmath185 , otherwise mst is not minimal .",
    "we will now see how to improve the @xmath66  ( wst ) constraint , leading to the @xmath186  ( bst ) propagator .",
    "we assume that the reader is already familiar with this constraint , otherwise papers @xcite should be considered as references .",
    "the bst can replace the mst of the wst constraint : the pruning rules of wst constraint will provide more inference since the bound it tighter . actually , we can do even better by slightly modifying the pruning rule of the wst constraint for arcs that are between two scc : an arc linking two scc can only replace ( or be replaced by ) another arc linking those two same scc . consider a bst of cost @xmath187 , the upper bound of the objective variable @xmath188 , an arc @xmath117 and a tree arc @xmath189 @xmath102 , we can rephrase the pruning rule by : any arc @xmath190 @xmath102 is infeasible if @xmath191 . the reader should notice that no lowest common ancestor ( lca ) query is performed here .",
    "this do not only accelerate the algorithm , it also enables more pruning , because a lca query could have returned an arc that does not link scc @xmath73 and @xmath80 .",
    "such an arc can not replace @xmath44 since exactly one arc of @xmath102 is mandatory .",
    "we now briefly describe a simple and efficient way to compute the bst .",
    "we assume that the @xmath74  propagator has been applied and that @xmath10 is thus a path .",
    "initially the bst is empty .",
    "first , we add to the bst mandatory arcs of @xmath27 , then for each @xmath101 we add @xmath192 @xmath102@xmath180 .",
    "finally , we run kruskal s algorithm as described in @xcite until the bst has @xmath193 arcs",
    ". a faster way to compute a bst is to perform prim s algorithm on successive scc , but this method does not enable to use the efficient filtering algorithm of rgin @xcite .",
    "figure [ bst_fig ] illustrates this relaxation : the input directed graph , on figure [ ig ] , is composed of four scc @xmath194 and @xmath195 . for simplicity purpose , costs are symmetric .",
    "its minimum hamiltonian path , figure [ opt ] , costs 28 and we will suppose that such a value is the current upper bound of the objective variable .",
    "the mst of the graph , figure [ mst ] , only costs 19 , which is unfortunately too low to filter any arc . instead , the bst , figure [ bst ] , is much more accurate",
    ". it actually consists of the mst of each scc , @xmath196 with respective costs @xmath197 , and the cheapest arcs that connect scc each others : @xmath198 with respective costs @xmath199 .",
    "thus , the entire bst costs 27 .",
    "it is worth noticing that it enables to filter arcs @xmath200 and @xmath201 .",
    "indeed , @xmath200 can only replace @xmath202 in the relaxation , so its marginal cost is @xmath203 which is strictly greater than the upper bound of the objective .",
    "the same reasoning enables to prune @xmath201 .",
    "the lagrangian relaxation of held and karp has initially been defined for solving symmetric tsp . instead of converting asymmetric instances into symmetric ones , through the transformation of jonker and volgenant  @xcite , we can directly adapt it to the asymmetric case : at each iteration @xmath124 , we define two penalties per node @xmath164 , @xmath204 and @xmath205 , respectively equal to @xmath206 and @xmath207 .",
    "we note @xmath208 the in - degree of @xmath42 in the mst of iteration @xmath124 whereas @xmath209 is its out - degree and @xmath210 is a constant whose calculation is discussed in @xcite . as a path is expected , we post @xmath211 .",
    "arc costs are then changed according to : @xmath212 .",
    "it has to be noticed that , since it relies on the computation of successive mst , such a model is equivalent to what would give the usual held and karp scheme used on a transformed instance .",
    "however , this framework is more general and can also handle the computation of minimum spanning arborescence .",
    "such a method should be implemented within a specific propagator to be easily plugged , or unplugged , into a constraint . we noticed that keeping track of lagrangian multipliers from one propagation to another , even upon backtracking , saves lots of computations and provides better results on average .",
    "our approach is based on a few runs .",
    "a run is composed of @xmath213 iterations in which we compute a mst according to prim s algorithm and update @xmath210 and the cost matrix .",
    "then , we run a kruskal s based mst to apply the complete filtering of @xcite .",
    "we first chose @xmath214 but this led to disappointing results when scaling up to a hundred nodes .",
    "we thus decided to fix @xmath213 to a constant .",
    "the value @xmath215 appeared as a good compromise between speed and accuracy .",
    "remark that , as we perform a fix point , the method may be called several times per search node , and since it is relatively slow , we always schedule this propagator at the end of the propagation queue .",
    "this procedure has the inconvenient of not being monotonic(it is not even idempotent ) : filtering , related to other propagators , can slow down the convergence of the method .",
    "the intuition is that to go from a mst to an optimal tour , it may be easier to use some infeasible arcs during the convergence process .",
    "one can see an analogy with local search techniques that explore infeasible solutions in order to reach the best ( feasible ) ones more quickly @xcite .",
    "this fact , which occured during some of our experiments involving static branching heuristics , breaks the usual saying _ the more filtering , the better_. moreover , it follows that we can not measure precisely the improvement stemming from additional structural filtering .",
    "we mention that the bst relaxation can be used within the held and karp scheme , however , this may also affect the convergence of the method and thus sometimes yield to poorer results .",
    "for that reason , we recommend to use a lagrangian bst relaxation in addition to , rather than in replacement of , the usual held and karp procedure .",
    "this section presents some experiments we made in order to measure the impact of the graph structure .",
    "we will show that branching according to graph structure only outperforms current state of the art results while using implied filtering based on graph structure avoids pathological behaviors on hard instances at a negligible time consumption .",
    "our implementations have been done within the @xmath216  solver which is an open source java library .",
    "tests have been performed on a macbook pro under os x 10.7.2 and with a 2.7 ghz intel core i7 and 8go of ddr3 .",
    "we set a limit of 3 go to be allocated to the jvm .",
    "we tested tsp and atsp instance of the tsplib .",
    "for each one , we refer to the number of search nodes by @xmath217nodes@xmath217 and report time measurements in seconds . as in @xcite",
    ", we study optimality proof and thus provide the optimal value as an upper bound of the problem .",
    "we computed equivalent state of the art results ( sota ) ( referred as _",
    "1-tree with filtering _ in @xcite ) , to position our model in general .",
    "their implementation is in c++ and has no memory restriction .",
    "our implementation ( referred as basic ) involves one graph variable , one integer variable ( the objective ) and one single constraint that is composed of several propagators .",
    "subtour elimination is performed by a special purpose incremental propagator , inspired from the @xmath47  constraint @xcite .",
    "the degree constraint is ensured by special purpose incremental propagators described in section [ details ] .",
    "the objective is adjusted by the natural relaxation and an implied propagator , based on the held and karp method .",
    "we mention that we solved ` rbg ` instances ( that are highly asymmetric ) by replacing the tree based relaxation by a minimum assignment problem relaxation ( also in sota ) . for that",
    ", we have implemented a simple hungarian algorithm .",
    "indeed , it always provided the optimal value as a lower bound at the root node .",
    "when a relaxation finds an optimal solution , this one can be directly enforced  @xcite .",
    "however , it could be in contradiction with side constraints .",
    "thus , we unplugged such a greedy mode .",
    "the solver works under a trailing environment .",
    "we experimentally compare the branching heuristics _",
    "removemaxrc _ and _ sparse _ of section [ sota_heur ] .",
    "we also introduce three variants of these methods : + - _ enforcemaxrc _ , consists in enforcing the tree arc of maximum replacement cost .",
    "it is the opposite of _",
    "removemaxrc_. + - _ removemaxmc _ , consists in removing the non tree arc of maximum marginal cost , i.e. the arc which would involve the highest cost augmentation if it was enforced . this heuristic may require an important number of decisions to solve the problem .",
    "there are low probabilities to make wrong decisions , but if a mistake has been performed early in the search tree , it might be disastrous for the resolution .",
    "+ - _ enforcesparse _ , which first selects the set of nodes @xmath70 with no successor in @xmath28 and the smallest set of successors in @xmath27 .",
    "second , it finds the node @xmath71 which maximize @xmath72 .",
    "then it fixes the successor of @xmath73 by enforcing the arc @xmath218 such that @xmath219 is maximal .",
    "all branching heuristics are performed in a binary tree search .",
    "_ removemaxrc _ , _ removemaxmc _ and _ sparse _ can be said to be reduction heuristics .",
    "they respectively involve a worst case depth for the search tree of @xmath60 , @xmath60 and @xmath220 .",
    "in contrast , _ enforcemaxrc _ and _ enforcesparse _ perform assignments , leading to a @xmath55 depth in the worst case .",
    "assignment heuristics perform strong decisions that bring more structure in left branches of the search tree while it is the opposite for reduction branchings that restrict more right branches .",
    "an exception is _ sparse _ which has a balanced impact on both branches .",
    "we then study the benefit we could get from adding some implied filtering algorithms to the basic model with _ removemaxmc _ and _ sparse _ heuristics : + - arb : @xmath50  and @xmath53  propagators used together .",
    "+ - pos : the model based on nodes position , with an @xmath46  constraint performing bound consistency .",
    "+ - ad : @xmath46  propagator , adapted to graph variables , with gac .",
    "+ - bst : @xmath74  propagator with a lagrangian relaxation based on a bst , in addition to the usual held - karp scheme .",
    "+ - all : combine all above propagators .",
    ".implied filtering comparison with enforcesparse heuristic .",
    "hard instances ftv170 and p43 are significantly improved by all filtering algorithms .",
    "[ atsp_filter ] [ cols= \" < , > , > , > , > , > , > , > , > , > , > , > , > \" , ]",
    "we have provided a short survey over solving the atsp in cp and shown how general graph properties , standing from the consideration of the reduced graph , could improve existing models , such as the minimum spanning tree relaxation . as future work ,",
    "this could be extended to scheduling oriented tsp ( tsptw for instance ) since @xmath74  finds some sets of precedences in linear time .",
    "we also provided some implementation guidelines to have efficient algorithms , including the held and karp procedure .",
    "we have shown that our model outperforms the current state of the art cp model for solving both tsp and atsp , pushing further the limit of cp .",
    "our experiments enable us to state that graph structure has a serious impact on resolution : not only cost matters .",
    "more precisely , the _ enforcesparse _ heuristic provides impressive results while implied structural filtering improves robustness for a negligible time consumption .",
    "we also pointed out the fact that non monotonicity of the lagrangian relaxation could make implied filtering decrease performances",
    ". an interesting future work would be to introduce some afterglow into the held and karp method : when the tree based relaxation is applied , it first performs a few iterations allowing , but penalizing , the use of arcs that have been removed since the last call of the constraint .",
    "this smoothing could make the convergence easier and thus lead to better results .",
    "the authors thank pascal benchimol and louis - martin rousseau for interesting talks and having provided their c++ implementation as well as charles prudhomme for useful implementation advise .",
    "they are also grateful to the regional council of pays de la loire for its financial support .",
    "nicolas beldiceanu and xavier lorca .",
    "necessary condition for path partitioning constraints . in _ integration of ai and or techniques in constraint programming for combinatorial optimization problems , cpaior",
    "_ , volume 4510 , pages 141154 , 2007 .",
    "grgoire dooms , yves deville , and pierre dupont .",
    "( graph ) : introducing a graph computation domain in constraint programming . in _ principles and practice of constraint programming , cp _ , volume 3709 , pages 211225 , 2005 .",
    "grgoire dooms and irit katriel . the `` not - too - heavy spanning tree '' constraint . in _ integration of ai and or techniques in constraint programming for combinatorial optimization problems , cpaior",
    "_ , volume 4510 , pages 5970 , 2007 .",
    "claude  le pape , laurent perron , jean - charles rgin , and paul shaw .",
    "robust and parallel solving of a network design problem . in _ principles and practice of constraint programming , cp _ , volume 2470 , pages 633648 , 2002 .",
    "jean - charles rgin .",
    "simpler and incremental consistency checking and arc consistency filtering algorithms for the weighted spanning tree constraint . in _ integration of ai and or techniques in constraint programming for combinatorial optimization problems , cpaior",
    "_ , volume 5015 , pages 233247 , 2008 .",
    "jean - charles rgin , louis - martin rousseau , michel rueher , and willem  jan van hoeve .",
    "the weighted spanning tree constraint revisited . in _ integration of ai and or techniques in constraint programming for combinatorial optimization problems , cpaior",
    "_ , volume 6140 , pages 287291 , 2010 .",
    "petr vilm .",
    "n ) filtering algorithms for unary resource constraint . in _ integration of ai and or techniques in constraint programming for combinatorial optimization problems , cpaior",
    "_ , volume 3011 , pages 335347 , 2004 ."
  ],
  "abstract_text": [
    "<S> recent works on cost based relaxations have improved constraint programming ( cp ) models for the traveling salesman problem ( tsp ) . we provide a short survey over solving asymmetric tsp with cp . then </S>",
    "<S> , we suggest new implied propagators based on general graph properties . </S>",
    "<S> we experimentally show that such implied propagators bring robustness to pathological instances and highlight the fact that graph structure can significantly improve search heuristics behavior . </S>",
    "<S> finally , we show that our approach outperforms current state of the art results . </S>"
  ]
}