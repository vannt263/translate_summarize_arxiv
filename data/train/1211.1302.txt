{
  "article_text": [
    "the evaluation of the complexity of finite sequences is key in many areas of science .",
    "for example , the notions of structure , simplicity and randomness are common currency in biological systems epitomized by a sequence of fundamental nature and utmost importance : the dna .",
    "nevertheless , researchers have for a long time avoided any practical use of the current accepted mathematical theory of randomness , mainly because it has been considered to be useless in practice  @xcite . despite this belief ,",
    "related notions such as lossless uncompressibility tests have proven relative success , in areas such as sequence pattern detection  @xcite and have motivated distance measures and classification methods  @xcite in several areas ( see  @xcite for a survey ) , to mention but two examples among many others of even more practical use .",
    "the method presented in this paper aims to provide sound directions to explore the feasibility and stability of the evaluation of the complexity of strings by means different to that of lossless compressibility , particularly useful for short strings .",
    "the authors known of only two similar attempts to compute the uncomputable , one related to the estimation of a chaitin omega number  @xcite , and of another seminal related measure of complexity , bennett s logical depth  @xcite .",
    "this paper provides an approximation to the output frequency distribution of all turing machines with 5 states and 2 symbols which in turn allow us to apply a central theorem in the theory of algorithmic complexity based in the notion of algorithmic probability ( also known as solomonoff s theory of inductive inference ) that relates frequency of production of a string and its kolmogorov complexity hence providing , upon application of the theorem , numerical estimations of kolmogorov complexity by a method different to lossless compression algorithms .",
    "a previous result  @xcite using a simplified version of the method reported here soon found an application in the study of economic time series  @xcite , but wider application was preempted by length and number of strings .",
    "here we significantly extend  @xcite in various directions : ( 1 ) longer , and therefore a greater number  by a factor of three orders of magnitude  of strings are produced and thoroughly analyzed ; ( 2 ) in light of the previous result , the new calculation allowed us to compare frequency distributions of sets from considerable different sources and of varying sizes ( although the smaller is contained in the larger set , it is of negligible size in comparison)they could have been of different type , but they are not ( 3 ) we extend the method to sets of turing machines whose busy beaver has not yet been found by proposing an informed method for estimating a reasonably non - halting cutoff value based on theoretical and experimental considerations , thus ( 4 ) provide strong evidence that the estimation and scaling of the method is robust and much less dependent of turing machine sample size , fully quantified and reported in this paper .",
    "the results reported here , the data released with this paper and the online program in the form of a calculator , have now been used in a wider number of applications ranging from psychometrics  @xcite to the theory of cellular automata  @xcite , graph theory and complex networks  @xcite . in sum",
    "this paper provides a thorough description of the method , a complete statistical analysis of the _ coding theorem method _ and an online application for its use and exploitation .",
    "the calculation presented herein will remain the best possible estimation for a measure of a similar nature with the technology available to date , as an exponential increase of computing resources will improve the length and number of strings produced only linearly if the same standard formalism of turing machines used is followed .",
    "central to ait is the definition of algorithmic ( kolmogorov - chaitin or program - size ) complexity  @xcite :    @xmath5    where @xmath6 is a program that outputs @xmath7 running on a universal turing machine @xmath8 .",
    "a technical inconvenience of @xmath9 as a function taking @xmath7 to the length of the shortest program that produces @xmath7 is its uncomputability . in other words",
    ", there is no program which takes a string @xmath7 as input and produces the integer @xmath10 as output .",
    "this is usually considered a major problem , but one ought to expect a universal measure of complexity to have such a property .",
    "the measure was first conceived to define randomness and is today the accepted objective mathematical measure of complexity , among other reasons because it has been proven to be mathematically robust ( by virtue of the fact that several independent definitions converge to it ) . if the shortest program @xmath6 producing @xmath7 is larger than @xmath11 , the length of @xmath7 , then @xmath7 is considered random .",
    "one can approach @xmath9 using compression algorithms that detect regularities in order to compress data .",
    "the value of the compressibility method is that the compression of a string as an approximation to @xmath9 is a sufficient test of non - randomness .",
    "it was once believed that ait would prove useless for any real world applications  @xcite , despite the beauty of its mathematical results ( e.g. a derivation of gdel s incompleteness theorem  @xcite ) .",
    "this was thought to be due to uncomputability and to the fact that the theory s founding theorem ( the invariance theorem ) , left finite ( short ) strings unprotected against an additive constant determined by the arbitrary choice of programming language or universal turing machine ( upon which one evaluates the complexity of a string ) , and hence unstable and extremely sensitive to this choice .",
    "traditionally , the way to approach the algorithmic complexity of a string has been by using lossless compression algorithms .",
    "the result of a lossless compression algorithm is an upper bound of algorithmic complexity .",
    "however , short strings are not only difficult to compress in practice , the theory does not provide a satisfactory answer to all questions concerning them , such as the kolmogorov complexity of a single bit ( which the theory would say has maximal complexity because it can not be further compressed ) . to make sense of such things and close this theoretical gap we devised an alternative methodology  @xcite to compressibility for approximating the complexity of short strings , hence a methodology applicable in many areas where short strings are often investigated ( e.g. in bioinformatics ) .",
    "this method has yet to be extended and fully deployed in real applications , and here we take a major step towards full implementation , providing details of the method as well as a thorough theoretical analysis .",
    "a fair compression algorithm is one that transforms a string into two components .",
    "the first of these is the compressed version while the other is the set of instructions for decompressing the string .",
    "both together account for the final length of the compressed version .",
    "thus the compressed string comes with its own decompression instructions .",
    "paradoxically , lossless compression algorithms are more stable the longer the string .",
    "in fact the invariance theorem guarantees that complexity values will only diverge by a constant @xmath12 ( e.g. the length of a compiler , a translation program between @xmath13 and @xmath14 ) and will converge at the limit . + * invariance theorem *  @xcite : if @xmath13 and @xmath14 are two universal turing machines and @xmath15 and @xmath16 the algorithmic complexity of @xmath7 for @xmath13 and @xmath14 , there exists a constant @xmath12 such that :    latexmath:[\\[\\label{invariance }     hence the longer the string , the less important the constant @xmath12 or choice of programming language or universal turing machine .",
    "however , in practice @xmath12 can be arbitrarily large , thus having a very great impact on finite short strings . indeed , the use of data lossless compression algorithms as a method for approximating the kolmogorov complexity of a string is accurate in direct proportion to the length of the string .",
    "the algorithmic probability ( also known as levin s semi - measure ) of a string @xmath7 is a measure that describes the expected probability of a random program @xmath6 running on a universal ( prefix - free .",
    "for details see  @xcite . ] ) turing machine @xmath8 producing @xmath7 .",
    "formally  @xcite ,    @xmath18    levin s semi - measure @xmath19 defines the so - called universal distribution  @xcite .",
    "here we propose to use @xmath19 as an alternative to the traditional use of compression algorithms to calculate @xmath10 by means of the following theorem . + * coding theorem *  @xcite : there exists a constant @xmath12 such that : @xmath20    that is , if a string has many long descriptions it also has a short one  @xcite .",
    "it beautifully connects frequency to complexity  the frequency ( or probability ) of occurrence of a string with its algorithmic ( kolmogorov ) complexity .",
    "the coding theorem implies that  @xcite one can calculate the kolmogorov complexity of a string from its frequency  @xcite , simply rewriting the formula as :    @xmath21    an important property of @xmath22 as a semi - measure is that it dominates any other effective semi - measure @xmath23 because there is a constant @xmath24 such that for all @xmath7 , @xmath25 hence called _ universal _  @xcite .",
    "* notation : * we denote by @xmath26 the class ( or space ) of all @xmath27-state 2-symbol turing machines ( with the halting state not included among the @xmath27 states ) .",
    "+ in addressing the problem of approaching @xmath28 by running computer programs ( in this case deterministic turing machines ) one can use the known values of the so - called busy beaver functions as suggested by and used in  @xcite .",
    "the busy beaver functions @xmath29 and @xmath30 can be defined as follows : + * busy beaver functions * ( rado  @xcite ) : if @xmath31 is the number of ` 1s ' on the tape of a turing machine @xmath8 with @xmath27 states and @xmath32 symbols upon halting starting from a blank tape ( no input ) , then the busy beaver function @xmath33 .",
    "alternatively , if @xmath34 is the number of steps that a machine @xmath8 takes before halting from a blank tape , then @xmath35 .",
    "+ in other words , the busy beaver functions are the functions that return the longest written tape and longest runtime in a set of turing machines with @xmath27 states and @xmath32 symbols . @xmath36 and @xmath37 are noncomputable functions by reduction to the halting problem . in fact @xmath36",
    "grows faster than any computable function can .",
    "nevertheless , exact values can be calculated for small @xmath27 and @xmath32 , and they are known for , among others , @xmath38 symbols and @xmath39 states .",
    "a program showing the evolution of all known busy beaver machines developed by one of this paper s authors is available online  @xcite .",
    "this allows one to circumvent the problem of noncomputability for small turing machines of the size that produce short strings whose complexity is approximated by applying the algorithmic coding theorem ( see fig .",
    "[ flowchart ] ) .",
    "as is widely known , the halting problem for turing machines is the problem of deciding whether an arbitrary turing machine @xmath8 eventually halts on an arbitrary input @xmath7 .",
    "halting computations can be recognized by running them for the time they take to halt .",
    "the problem is to detect non - halting programs , programs about which one can not know in advance whether they will run forever or eventually halt .",
    "it is important to describe the turing machine formalism because numerical values of algorithmic probability for short strings will be provided under this chosen standard model of a turing machine .",
    "+ consider a turing machine with the binary alphabet @xmath40 and @xmath27 states @xmath41 and an additional halt state denoted by 0 ( as defined by rado in his original busy beaver paper  @xcite ) .",
    "+ the machine runs on a @xmath42-way unbounded tape . at each step :    the machine s current `` state '' ; and    the tape symbol the machine s head is scanning    define each of the following :    a unique symbol to write ( the machine can overwrite a @xmath43 on a @xmath44 , a @xmath44 on a @xmath43 , a @xmath43 on a @xmath43 , and a @xmath44 on a @xmath44 ) ;    a direction to move in : @xmath45 ( left ) , @xmath43 ( right ) or @xmath44 ( none , when halting ) ; and    a state to transition into ( which may be the same as the one it was in ) .    the machine halts if and when it reaches the special halt state 0",
    ". there are @xmath46 turing machines with @xmath27 states and 2 symbols according to the formalism described above .",
    "the output string is taken from the number of contiguous cells on the tape the head of the halting @xmath27-state machine has gone through .",
    "a machine produces a string upon halting .",
    "one can attempt to approximate @xmath19 ( see eq .",
    "3 ) by running every turing machine an particular enumeration , for example , a quasi - lexicographical ordering , from shorter to longer ( with number of states @xmath27 and 2 fixed symbols ) .",
    "it is clear that in this fashion once a machine produces @xmath7 for the first time , one can directly calculate an approximation of @xmath9 , because this is the length of the first turing machine in the enumeration of programs of increasing size that produces @xmath7 . but more important",
    ", one can apply the coding theorem to extract @xmath10 from @xmath19 directly from the output distribution of halting turing machines .",
    "let s formalize this by using the function @xmath47 as the function that assigns to every string @xmath7 produced in @xmath48 the quotient : ( number of times that a machine in @xmath48 produces @xmath7 ) / ( number of machines that halt in @xmath48 ) as defined in  @xcite .",
    "more formally , + @xmath49    where @xmath50 is the turing machine with number @xmath6 ( and empty input ) that produces @xmath7 upon halting and @xmath51 is , in this case , the cardinality of the set @xmath52 .",
    "a variation of this formula closer to the definition of @xmath22 is given by :    @xmath53    @xmath54 is strictly smaller than 1 for @xmath55 , because of the turing machines that never halt , just as it occurs for @xmath22 .",
    "however , for fixed @xmath27 and @xmath32 the sum of @xmath56 will always be 1 .",
    "we will use eq .",
    "[ d ] for practical reasons , because it makes the frequency values more readable ( most machines do nt halt , so those halting would have a tiny fraction with too many leading zeros after the decimal ) .",
    "moreover , the function @xmath57 is non - computable  @xcite but it can be approximated from below , for example , by running small turing machines for which known values of the busy beaver problem  @xcite are known .",
    "for example  @xcite , for @xmath58 , the busy beaver function for maximum runtime @xmath59 , tells us that @xmath60 , so we know that a machine running on a blank tape will never halt if it hasnt halted after 107 steps , and so we can stop it manually . in what follows",
    "we describe the exact methodology . from now on , @xmath61 with a single parameter",
    "will mean @xmath62 .",
    "we call this method the _ coding theorem method _ to approximate @xmath9 ( which we will denote by @xmath63 ) .",
    "approximations from the output distribution of turing machines with 2 symbols and @xmath64 states for which the busy beaver values are known were estimated before  @xcite but for the same reason the method was not scalable beyond @xmath58 .",
    "the formula for the number of machines given a number of states @xmath27 is given by @xmath65 derived from the formalism described .",
    "there are 26559922791424 turing machines with 5 states . here",
    "we describe how an optimal runtime based on theoretical and experimental grounds can be calculated to scale the method to larger sets of small turing machines .    because there are a large enough number of machines to run even for a small number of machine states ( @xmath27 ) , applying the coding theorem provides a finer and increasingly stable evaluation of @xmath10 based on the frequency of production of a large number of turing machines , but the number of turing machines grows exponentially , and producing @xmath66 requires considerable computational resources .",
    "the busy beaver for turing machines with 4 states is known to be 107 steps  @xcite , that is , any turing machine with 2 symbols and 4 states running longer than 107 steps will never halt .",
    "however , the exact number is not known for turing machines with 2 symbols and 5 states , although it is believed to be 47176870 , as there is a candidate machine that runs for this long and halts and no machine greater runtime has yet been found .",
    "so we decided to let the machines with 5 states run for 4.6 times the busy beaver value for 4-state turing machines ( for 107 steps ) , knowing that this would constitute a sample significant enough to capture the behavior of turing machines with 5 states .",
    "the chosen runtime was rounded to 500 steps , which was used to build the output frequency distribution for @xmath66 .",
    "the theoretical justification for the pertinence and significance of the chosen runtime is provided in the following sections .",
    "we did nt run all the turing machines with 5 states to produce @xmath66 because one can take advantage of symmetries and anticipate some of the behavior of the turing machines directly from their transition tables without actually running them ( this is impossible in general due to the halting problem ) .",
    "we avoided some trivial machines whose results we know without having to run them ( reduced enumeration ) .",
    "also , some non - halting machines were detected before consuming all the runtime ( filters ) .",
    "the following are the reductions utilized in order to reduce the number of total machines and therefore the computing time for the approximation of @xmath66 .",
    "the blank symbol is one of the 2 symbols ( 0 or 1 ) in the first run , while the other is used in the second run ( in order to avoid any asymmetries due to the choice of a single blank symbol ) . in other words",
    ", we considered two runs for each turing machine , one with 0 as the blank symbol ( the symbol with which the tape starts out and fills up ) , and an additional run with 1 as the blank symbol .",
    "this means that every machine was run twice .",
    "due to the symmetry of the computation , there is no real need to run each machine twice ; one can _ complete _ the string frequencies by assuming that each string produced produced by a turing machine has its complement produced by another symmetric machine with the same frequency , we then group and divide by symmetric groups .",
    "we used this technique from @xmath67 to @xmath68 .",
    "a more detailed explanation of how this is done is provided in  @xcite using polya s counting theorem .",
    "we can exploit the right - left symmetry .",
    "we may , for example , run only those machines with an initial transition ( initial state and blank symbol ) moving to the right and to a state different from the initial one ( because an initial transition to the initial state produces a non - halting machine ) and the halting one ( these machines stop in just one step and produce ` 0 ' or ` 1 ' ) .    for every string produced , we also count the reverse in the tables .",
    "we count the corresponding number of one - symbol strings and non - halting machines as well .",
    "if we consider only machines with a starting transition that moves to the right and goes to a state other than the starting and halting states , the number of machines is given by @xmath69 note that for the starting transition there are @xmath70 possibilities ( @xmath42 possible symbols to write and @xmath71 possible new states , as we exclude the starting and halting states ) .",
    "for the other @xmath72 transitions there are @xmath73 possibilities .",
    "we can make an enumeration from @xmath44 to @xmath74 .",
    "of course , this enumeration is not the same as the one we use to explore the whole space .",
    "the same number will not correspond to the same machine .    in the whole @xmath66 space",
    "there are @xmath65 machines , so it is a considerable reduction .",
    "this reduction in @xmath66 means that in the reduced enumeration we have @xmath75 of the machines we had in the original enumeration .",
    "suppose that using the previous enumeration we run @xmath76 machines for @xmath61 with blank symbol @xmath44 .",
    "@xmath76 can be the total number of machines in the reduced space or a random number of machines in it ( such as we use to study the runtime distribution , as it is better described below ) .    for the starting transition we considered only @xmath70 possibilities out of @xmath73 possible transitions in the whole space .",
    "then , we proceeded as follows to complete the strings produced by the @xmath76 runs .",
    "we avoided @xmath70 transitions moving left to a different state than the halting and starting ones .",
    "we completed such transitions by reversing all the strings found .",
    "non - halting machines were multiplied by @xmath42 .",
    "we also avoided @xmath42 transitions ( writing ` 0 ' or ` 1 ' ) from the initial to the halting state .",
    "we completed such transitions by    including @xmath77 times ` 0 ' .    including @xmath77 times ` 1 ' .",
    "finally , we avoided @xmath78 transitions from the initial state to itself ( @xmath42 movements @xmath79 @xmath42 symbols ) .",
    "we completed by including @xmath80 non - halting machines .    with these completions",
    ", we obtained the output strings for the blank symbol @xmath44 . to complete for the blank symbol @xmath43 we took the complement to @xmath43 of each string produced and counted the non - halting machines twice .",
    "then , by running @xmath76 machines , we obtained a result representing @xmath81 , that for @xmath82 is @xmath83 .",
    "it is useful to avoid running machines that we can easily check that will not stop .",
    "these machines will consume the runtime without yielding an output .",
    "the reduction in the enumeration that we have shown reduces the number of machines to be generated .",
    "now we present some reductions that work after the machines are generated , in order to detect non - halting computations and skip running them .",
    "some of these were detected when filling the transition table , others at runtime .",
    "while we are filling the transition table , if a certain transition goes to the halting state , we can activate a flag .",
    "if after completing the transition table the flag is not activated , we know that the machine wo nt stop .    in our reduced enumeration there are @xmath84 machines of this kind . in @xmath66",
    "this is @xmath85 machines .",
    "it represents 42.41% of the total number of machines .",
    "the number of machines in the reduced enumeration that are not filtered as non - halting when filling the transition table is 5562153742336 .",
    "that is 504.73 times the total number of machines that fully produce @xmath68 .",
    "there should be a great number of escapees , that is , machines that run infinitely in the same direction over the tape .",
    "some kinds are simple to check in the simulator .",
    "we can use a counter that indicates the number of consecutive not - previously - visited tape positions that the machines visits .",
    "if the counter exceeds the number of states , then we have found a loop that will repeat infinitely . to justify this ,",
    "let us ask you to suppose that at some stage the machine is visiting a certain tape - position for the first time , moving in a specific direction ( the direction that points toward new cells ) .",
    "if the machine continues moving in the same direction for @xmath86 steps , and thus reading blank symbols , then it has repeated some state @xmath7 in two transitions .",
    "as it is always reading ( not previously visited ) blank symbols , the machine has repeated the transition for @xmath87 twice , @xmath88 being the blank symbol .",
    "but the behavior is deterministic , so if the machine has used the transition for @xmath87 and after some steps in the same direction visiting blank cells , it has repeated the same transition , it will continue doing so forever , because it will always find the same symbols .",
    "there is another possible direction in which this filter may apply : if the symbol read is a blank one not previously visited , the shift is in the direction of new cells and there is no modification of state . in fact",
    "this would be deemed an escapee , because the machine runs for @xmath86 new positions over the tape .",
    "but it is an escapee that is especially simple to detect , in just one step and not @xmath86 .",
    "we call the machines detected by this simple filter `` short escapees '' , to distinguish them from other , more general escapees",
    ".      we can detect cycles of period two .",
    "they are produced when in steps @xmath7 and @xmath89 the tape is identical and the machine is in the same state and the same position .",
    "when this is the case , the cycle will be repeated infinitely . to detect it",
    ", we have to anticipate the following transition that will apply in some cases . in a cycle of period two",
    ", the machine can not change any symbol on the tape , because if it did , the tape would be different after two steps .",
    "then the filter would be activated when there is a transition that does not change the tape , for instance @xmath90 where @xmath91 is some direction ( left , right ) and the head is at position @xmath92 on tape @xmath93 , which is to say , reading the symbol @xmath94 $ ] .",
    "then , there is a cycle of period two if and only if the transition that corresponds to @xmath95\\}$ ] is @xmath96\\}\\to\\{s , t[i+d],-d\\}\\ ] ]      we calculated @xmath68 with and without all the filters as suggested in  @xcite . running @xmath68 without reducing the number or detecting non - halting machines took 952 minutes .",
    "running the reduced enumeration with non - halting detectors took 226 minutes .",
    "we filtered the following non - halting machines :    = 0.13 cm    [ cols=\"<,>\",options=\"header \" , ]      an important question is how robust is @xmath97 , that is how sensitive it is to @xmath27 . we know that the invariance theorem guarantees that the values converge in the long term , but the invariance theorem tells nothing about the rate of convergence .",
    "we have shown that @xmath98 respects the order of @xmath61 except for very few and minor value discrepancies concerning the least frequent strings ( and therefore the most unstable given the few machines generating them ) .",
    "this is not obvious despite the fact that all turing machines with @xmath27 states in @xmath48 are included in the space of @xmath99 machines",
    "( that is , the machines that never reach one of the @xmath86 states ) , because the number of machines in @xmath99 overcomes by far the number of machines in @xmath48 , and a completely different result could have been then produced . however , the agreement between @xmath61 and @xmath98 seems to be similarly high among , and despite , the few cases @xmath100 in hand to compare with .",
    "the only way for this behaviour to radically change for @xmath101 is if for some @xmath102 , @xmath103 starts diverging in ranks from @xmath104 on before starting to converge again ( by the invariance theorem ) . if one does not have any reason to believe in such a change of behavior , the rate of rank convergence of @xmath61 is close to optimal very soon , even for the relatively  small \" sets of turing machines for small @xmath27 .",
    "one may ask how robust the complexity values and classifications may be in the face of changes in computational formalism ( e.g. turing machines with several tapes , and all possible variations ) .",
    "we have shown  @xcite that radical changes to the computing model produce reasonable ( and correlated with different degrees of confidence ) ranking distributions of complexity values ( using even completely different computing models , such as unidimensional deterministic cellular automata and post tag systems ) .",
    "we have also calculated the maximum differences between the kolmogorov complexity evaluations of the strings occurring in every 2 distributions @xmath61 and @xmath98 for @xmath105 .",
    "this provides estimations for the constant @xmath12 in the invariance theorem ( eq .  [ invariance ] ) determining the maximum difference in bits among all the strings evaluated with one or another distribution , hence shedding light on the robustness of the evaluations under this procedure . the smaller the values of @xmath12 the more stable our method",
    ". the values of these bounding constants ( in bits ) among the different numerical evaluations of @xmath9 using @xmath61 for @xmath106 after application of the coding theorem ( eq .  [ codingeq ] ) are :    @xmath107 + @xmath108 + @xmath109 +    where @xmath110 means @xmath10 evaluated using the output frequency distribution @xmath61 after application of the coding theorem ( eq .  [ codingeq ] ) for @xmath111 ( @xmath112 is a trivial non interesting case ) and where every value of @xmath12 is calculated by quartiles ( separated by semicolons ) , that is , the calculation of @xmath12 among all the strings in the 2 compared distributions , then among the top 3/4 , then the top half and finally the top quarter by rank .",
    "notice that the estimation of @xmath12 between @xmath113 and @xmath114 , and @xmath114 and @xmath68 remained almost the same among all strings occurring in both , at about 4 bits .",
    "this means one could write a  compiler \" ( or translator ) among the two distributions for all their occurring strings of size only 4 bits providing one or the other complexity value for @xmath9 based on one or the other distribution .",
    "the differences are considerably smaller for more stable strings ( towards the top of the distributions ) .",
    "one may think that given that the strings with their occurrences in @xmath98 necessarily contain those in @xmath61 for all @xmath27 ( because the space of all turing machines with an additional state always contain the computations of the turing machines will less states ) , the agreement should be expected .",
    "however , the contribution of @xmath61 to @xmath98 contributes with @xmath115 the number of strings in @xmath98 .",
    "for example , @xmath68 contributes only 1832 strings to the 99608 produced in @xmath66 ( that is less than 2% ) .",
    "all in all , the largest difference found between @xmath68 and @xmath66 is only of 5 bits of among all the strings occurring both in @xmath68 and @xmath66 ( 1832 strings ) , where the values of @xmath9 in @xmath68 are between 2.285 and 29.9 .",
    "we have put forward a method based on algorithmic probability that produces frequency distributions based on the production of strings using a standard ( rado s ) model of turing machines generally used for the busy beaver problem .",
    "the distributions show very small variations , being the result of an operation that makes incremental changes based on a very large number of calculations having as consequence the production of stable numerical approximations of kolmogorov complexity for short strings for which error estimations of @xmath12 from the invariance theorem were also estimated .",
    "any substantial improvement on @xmath66 , for example , by approximation of a @xmath61 for @xmath101 , is unlikely to happen with the current technology as the number of turing machines grows exponentially in the number of states @xmath27 .",
    "however , we have shown here based both on theoretical and experimental grounds that one can choose informed runtimes significantly smaller than that of the busy beaver bound and capture most of the output determining the output frequency distribution .",
    "an increase of computational power by , say , one order of magnitude will only deliver a linear improvement on @xmath66 .",
    "the experimental method presented is computationally expensive , but it does not need to be executed more but once for a set of ( short ) strings . as a result",
    "this can now be considered an alternative to lossless compression as a complementary technique for approximating kolmogorov complexity .",
    "an _ online algorithmic complexity calculator _ ( oacc ) implementing this technique and releasing the data for public use has been made available at http://www.complexitycalculator.com .",
    "the data produced for this paper has already been used in connection to graph theory and complex networks  @xcite , showing , for example , that it produces better approximations of kolmogorov complexity of small graphs ( by comparing it to their duals ) than lossless compressibility . in  @xcite it",
    "is also shown how the method can be used to classify images and space - time diagrams of dynamical systems , where its results are also compared to the approximations obtained using compression algorithms , with which they show spectacular agreement . in  @xcite , it is used to investigate the ratios of complexity in rule spaces of cellular automata of increasing size , supported by results from block entropy and lossless compressibility . in  @xcite , it is also used as a tool to assess subjective randomness in the context of psychometrics . finally in  @xcite , the method is used in numerical approximations to another seminal measure of complexity ( bennett s logical depth ) , where it is also shown to be compatible with a calculation of strict ( integer - value ) program - size complexity as measured by an alternative means ( i.e. other than compression ) .",
    "the procedure promises to be a sound alternative , bringing theory and practice into alignment and constituting evidence that confirms the possible real - world applicability of levin s distribution and solomonoff s universal induction ( hence validating the theory itself , which has been subject to criticism largely on grounds of simplicity bias and inapplicability ) . as gregory chaitin has pointed out  @xcite when commenting on this very method of ours :    _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ the theory of algorithmic complexity is of course now widely accepted , but was initially rejected by many because of the fact that algorithmic complexity depends on the choice of universal turing machine and short binary sequences can not be usefully discussed from the perspective of algorithmic complexity . ",
    "discovered employing [ t]his empirical , experimental approach , the fact that most reasonable choices of formalisms for describing short sequences of bits give consistent measures of algorithmic complexity !",
    "so the dreaded theoretical hole in the foundations of algorithmic complexity turns out , in practice , not to be as serious as was previously assumed . ",
    "[ hence , of this approach ] constituting a marked turn in the field of algorithmic complexity from deep theory to practical applications .",
    "_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _    this also refers to the fact that we have found an important agreement in distribution  and therefore of estimations of kolmogorov complexity upon application of the algorithmic coding theorem  with other abstract computing formalisms such as one - dimensional cellular automata and post s tag systems  @xcite . in this paper",
    "we have provided strong evidence that the estimation and scaling ( albeit limited by computational power ) of the method is robust and much less dependent on formalism and size sample than what originally could have been anticipated by the invariance theorem .",
    "brady , the determination of the value of rado s noncomputable function @xmath116 for four - state turing machines , _ mathematics of computation 40 _ ( 162 ) : 647665 , 1983 .",
    "calude , _ information and randomness _ , springer , 2002 .",
    "calude and m.a .",
    "stay , most programs stop quickly or never halt , _ advances in applied mathematics _",
    ", 40 , 295 - 308 , 2008 .",
    "calude , m.j .",
    "dinneen , and c .- k . ,",
    "shu , computing a glimpse of randomness , _ exper .",
    "_ , 11 , 361370 , 2002 .",
    "chaitin , on the length of programs for computing finite binary sequences : statistical considerations , _ journal of the acm _ , 16(1):145159 , 1969 .",
    "chaitin , algorithmic information theory , _ ibm journal of r&d _ , 21 , no .",
    "4 , pp . 350359 , 1977 .",
    "chaitin et al .",
    "report of h.zenils phd ( computer science ) thesis , universit de lille 1 , france , 2011 .",
    "http://www.mathrix.org/zenil/report.pdf g.j .",
    "_ from philosophy to program size , _ 8th .",
    "estonian winter school in computer science , institute of cybernetics , tallinn , 2003 .",
    "r. cilibrasi , p. vitanyi , clustering by compression , _ ieee transactions on information theory , _ 51 , 4 , 15231545 , 2005 .",
    "t.m . cover and j.a .",
    "thomas , _ information theory , _ j. wiley and sons , 2006 .",
    "delahaye , h. zenil , towards a stable definition of kolmogorov - chaitin complexity , arxiv:0804.3459 , 2007 .",
    "delahaye and h. zenil , on the kolmogorov - chaitin complexity for short sequences . in c. calude ( ed . ) ,",
    "_ randomness and complexity : from leibniz to chaitin _",
    ", world scientific , 2007 .",
    "delahaye and h. zenil , numerical evaluation of the complexity of short strings : a glance into the innermost structure of algorithmic randomness , _ applied math . and comp .",
    "r. downey & d.r .",
    "hirschfeldt , _ algorithmic randomness and complexity _ , springer , 2010",
    ". n. gauvrit , h. zenil , j .-",
    "delahaye and f. soler - toscano , algorithmic complexity for short binary strings applied to psychology : a primer , _ behavior research methods _",
    "( in press ) doi : 10.3758/s13428 - 013 - 0416 - 0 w. kircher , m. li , and p. vitanyi , the miraculous universal distribution , _ the mathematical intelligencer , _ 19:4 , 715 , 1997 .",
    "kolmogorov , three approaches to the quantitative definition of information , _ problems of information and transmission _ ,",
    "1(1):17 , 1965 . l. levin , laws of information conservation ( non - growth ) and aspects of the foundation of probability theory , _ problems in form . transmission _ 10 . 206210 , 1974 . m. li , p. vitnyi , _ an introduction to kolmogorov complexity and its applications , _ springer , 2008 .",
    "l. ma , o. brandouy , j .-",
    "delahaye and h. zenil , algorithmic complexity of financial motions , _ research in international business and finance , _ pp . 336347 , 2014 .",
    "( published online in 2012 ) .",
    " . rivals , m. dauchet , j .-",
    "delahaye , o. delgrange , compression and genetic sequence analysis . , _ biochimie _ , 78 , pp 315322 , 1996 . t. rad , on non - computable functions , _ bell system technical journal , _ vol .",
    "3 , pp . 877884 , 1962 . f. soler - toscano , h. zenil , j .-",
    "delahaye and n. gauvrit , correspondence and independence of numerical evaluations of algorithmic information measures , computability , vol .",
    "2 , pp . 125140 , 2013 .",
    "solomonoff , a formal theory of inductive inference : parts 1 and 2 . _ information and control _ , 7:122 and 224254 , 1964 .",
    "h. zenil , f. soler - toscano , j .-",
    "delahaye and n. gauvrit , two - dimensional kolmogorov complexity and validation of the coding theorem method by compressibility , preprint at arxiv:1212.6745 [ cs.cc ] .",
    "( _ awaiting journal decision _ ) h. zenil , compression - based investigation of the dynamical properties of cellular automata and other systems , _ complex systems . _ 19(1 ) , pages 128 , 2010 .",
    "h. zenil , j .-",
    "delahaye and c. gaucherel , image information content characterization and classification by physical complexity , _ complexity _ , vol .",
    "173 , pages 2642 , 2012 . h. zenil and j - p .",
    "delahaye , on the algorithmic nature of the world , in g. dodig - crnkovic and m. burgin ( eds ) , _ information and computation _ , world scientific publishing company , 2010 .",
    "h. zenil , une approche exprimentale  la thorie algorithmique de la complexit , dissertation in fulfillment of the degree of doctor in computer science , university of lille 1 , 2011 .",
    "h. zenil , f. soler - toscano , k. dingle and a. louis , correlation of automorphism group size and topological properties with program - size complexity evaluations of graphs and complex networks , _ physica a : statistical mechanics and its applications _",
    "( in press ) doi : 10.1016/j.physa.2014.02.060 . h. zenil ,  busy beaver \" from the wolfram demonstrations project http://demonstrations.wolfram.com/busybeaver/ h. zenil and e. villarreal - zapata , asymptotic behaviour and ratios of complexity in cellular automata rule spaces , _ international journal of bifurcation and chaos _ vol .",
    "13 , no . 9 , 2013 . h. zenil and j .- p .",
    "delahaye , an algorithmic information - theoretic approach to the behaviour of financial markets , _ journal of economic surveys _ , vol .",
    "25 - 3 , pp . 463 , 2011"
  ],
  "abstract_text": [
    "<S> drawing on various notions from theoretical computer science , we present a novel numerical approach , motivated by the notion of algorithmic probability , to the problem of approximating the kolmogorov - chaitin complexity of short strings . </S>",
    "<S> the method is an alternative to the traditional lossless compression algorithms , which it may complement , the two being serviceable for different string lengths . </S>",
    "<S> we provide a thorough analysis for all @xmath0 binary strings of length @xmath1 and for most strings of length @xmath2 by running all @xmath3 turing machines with 5 states and 2 symbols ( @xmath4 with reduction techniques ) using the most standard formalism of turing machines , used in for example the busy beaver problem . </S>",
    "<S> we address the question of stability and error estimation , the sensitivity of the continued application of the method for wider coverage and better accuracy , and provide statistical evidence suggesting robustness . as with compression algorithms </S>",
    "<S> , this work promises to deliver a range of applications , and to provide insight into the question of complexity calculation of finite ( and short ) strings . </S>",
    "<S> + additional material can be found at the _ algorithmic nature group _ website at + http://www.algorithmicnature.org . </S>",
    "<S> an online algorithmic complexity calculator implementing this technique and making the data available to the research community is accessible at http://www.complexitycalculator.com . </S>",
    "<S> + keywords : algorithmic randomness ; algorithmic probability ; levin s universal distribution ; solomonoff induction ; algorithmic coding theorem ; invariance theorem ; busy beaver functions ; small turing machines . </S>"
  ]
}