{
  "article_text": [
    "ever since the celebrated paper of gallager , humblet , and spira @xcite , the task of constructing a minimum - weight spanning tree ( mst ) continues to be a rich source of difficulties and ideas that drive network algorithmics ( see , e.g. , @xcite ) . the _",
    "steiner forest _",
    "( sf ) problem is a strict generalization of mst : we are given a network with edge weights and some disjoint node subsets called _ input components _ ; the task is to find a minimum - weight edge set which makes each component connected .",
    "mst is a special case of sf , and so are the steiner tree and shortest @xmath3-@xmath4 path problems",
    ". the general sf problem is well motivated by many practical situations involving the design of networks , be it physical ( it was famously posed as a problem of railroad design ) , or virtual ( e.g. , vpns or streaming multicast ) . the problem has attracted much attention in the classical algorithms community , as detailed on the dedicated website @xcite .    the first network algorithm for sf in the congestmodel ( where a link can deliver @xmath6 bits in a time unit  details in ) was presented by khan _",
    "et al . _",
    "it provides @xmath6-approximate solutions in time @xmath10 , where @xmath13 is the number of nodes , @xmath5 is the number of components , and @xmath3 the _ shortest path diameter _ of the network , which is ( roughly  see ) the maximal number of edges in a weighted shortest path .",
    "subsequently , in @xcite , it was shown that for any given @xmath14 , an @xmath15-approximate solution to sf can be found in time @xmath16 , where @xmath8 is the diameter of the unweighted version of the network , and @xmath4 is the number of _ terminals _ , i.e. , the total number of nodes in all input components . the algorithms in @xcite are both randomized .",
    "[ [ our - results . ] ] our results .",
    "+ + + + + + + + + + + +    in this paper we improve the results for sf in the congestmodel in two ways .",
    "first , we show that for any given constant @xmath0 , a @xmath1-approximate solution to sf can be computed by a deterministic network algorithm in time @xmath2 .",
    "second , we show that an @xmath6-approximation can be attained by a randomized algorithm in time @xmath17 . on the other hand , we show that any algorithm in the congestmodel that computes a solution to sf with non - trivial approximation ratio has running time in @xmath18 . if the input is not given by indicating to each terminal its input component , but rather by _ connection requests _ between terminals , i.e. , informing each terminal which terminals it must be connected to , an @xmath19 lower bound holds .",
    "( it is easy to transform connection requests into equivalent input components in @xmath20 rounds . )",
    "[ [ related - work . ] ] related work .",
    "+ + + + + + + + + + + + +    the steiner tree problem ( the special case of sf where there is one input component ) has a remarkable history , starting with fermat , who posed the geometric 3-point on a plane problem circa 1643 , including gauss ( 1836 ) , and culminating with a popularization in 1941 by courant and robbins in their book `` what is mathematics '' @xcite . an interesting account of these early developments is given in @xcite .",
    "the contribution of computer science to the history of the problem apparently started with the inclusion of steiner tree as one of the original 21 problems proved np - complete by karp @xcite .",
    "there are quite a few variants of the sf problem which are algorithmically interesting , such as directed steiner tree , prize - collecting steiner tree , group steiner tree , and more .",
    "the site @xcite gives a continuously updated state of the art results for many variants .",
    "let us mention results for just the most common variants : for the steiner tree problem , the best ( polynomial - time ) approximation ratio known is @xmath21 for any constant @xmath0 @xcite . for steiner forest ,",
    "the best approximation ratio known is @xmath22 @xcite .",
    "it is also known that the approximation ratio of the steiner tree ( or forest ) problem is at least @xmath23 , unless p = np  @xcite .",
    "regarding distributed algorithms , there are a few relevant results .",
    "first , the special case of minimum - weight spanning tree ( mst ) is known to have time complexity of @xmath24 in the congestmodel @xcite . in @xcite , a 2-approximation for the special case of steiner tree",
    "is presented , with time complexity @xmath25 .",
    "the first distributed solution to the steiner forest problem was presented by khan _",
    "et al . _",
    "@xcite , where a randomized algorithm is used to embed the instance in a virtual tree with @xmath6 distortion , then finding the optimal solution on the tree ( which is just the minimal subforest connecting each input component ) , and finally mapping the selected tree edges back to corresponding paths in the original graph . the result is an @xmath6-approximation in time @xmath10 .",
    "intuitively , @xmath3 is the time required by the bellman - ford algorithm to compute distributed single - source shortest paths , and the virtual tree of @xcite is computed in @xmath26 rounds . a second distributed algorithm for steiner forest is presented in @xcite . here ,",
    "a sparse spanner for the metric induced on the set of terminals and a random sample of @xmath27 nodes is computed , on which the instance then is solved centrally . to get an @xmath15-approximation , the algorithm runs for @xmath28 rounds . for approximation ratio @xmath6 , the running time is @xmath29 .",
    "[ [ main - techniques . ] ] main techniques .",
    "+ + + + + + + + + + + + + + + +    our lower bounds are derived by the standard technique of reduction from results on @xmath30-party communication complexity .",
    "our deterministic algorithm is an adaptation of the `` moat growing '' algorithm of agrawal , klein , and ravi @xcite to the congestmodel .",
    "it involves determining the times in which `` significant events '' occur ( e.g. , all terminals in an input component becoming connected by the currently selected edges ) and extensive usage of pipelining . the algorithm generalizes the mst algorithm from  @xcite : for the special case of a steiner tree ( i.e. , @xmath31 ) , one can interpret the output as the edge set induced by an mst of the complete graph on the terminals with edge weights given by the terminal - terminal distances , yielding a factor-@xmath30 approximation ; specializing further to the mst problem , the result is an exact mst and the running time becomes @xmath32 .",
    "our randomized algorithm is based on the embedding of the graph into a tree metric from @xcite , but we improve the complexity of finding a steiner forest .",
    "a key insight is that while the least - weight paths in the original graph corresponding to virtual tree edges might intersect , no node participates in more than @xmath6 distinct paths . since the union of all least - weight paths ending at a specific node induces a tree , letting each node serve routing requests corresponding to different destinations in a round - robin fashion achieves a pipelining effect reducing the complexity to @xmath33 .",
    "if @xmath34 , the virtual tree and the corresponding solution are constructed only partially , in time @xmath35 , and the partial result is used to create another instance with @xmath36 terminals that captures the remaining connectivity demands ; we solve it using the algorithm from  @xcite , obtaining an @xmath6-approximation .    [",
    "[ organization . ] ] organization .",
    "+ + + + + + + + + + + + +    in we define the model , problem and basic concepts .",
    "contains our lower bounds . in and we present our deterministic and randomized algorithms , respectively .",
    "we only give a high - level overview in this extended abstract .",
    "proofs are deferred to the appendix .",
    "[ [ system - model . ] ] system model .",
    "+ + + + + + + + + + + + +    we consider the @xmath37 or simply the congestmodel as specified in  @xcite , briefly described as follows .",
    "the distributed system is represented by a weighted graph @xmath38 of @xmath39 nodes .",
    "the weights @xmath40 are polynomially bounded in @xmath13 ( and therefore polynomial sums of weights can be encoded with @xmath6 bits ) .",
    "each node initially knows its unique identifier of @xmath6 bits , the identifiers of its neighbors , the weight of its incident edges , and the local problem - specific input specified below .",
    "algorithms proceed in synchronous rounds , where in each round , ( i ) nodes perform arbitrary , finite local computations , ( ii ) may send , to each neighbor , a possibly distinct message of @xmath6 bits , and ( iii ) receive the messages sent by their neighbors . for randomized algorithms , each node has access to an unlimited supply of unbiased , independent random bits .",
    "time complexity is measured by the number of rounds until all nodes ( explicitly ) terminate .",
    "[ [ notation . ] ] notation .",
    "+ + + + + + + + +    we use the following conventions and graph - theoretic notions .",
    "the _ length _ or number of _ hops _ of a path @xmath41 in @xmath42 is @xmath43 .",
    "the weight of such a path is @xmath44 . for notational convenience ,",
    "we assume w.l.o.g .  that different paths have different weight ( ties broken lexicographically ) .",
    "by @xmath45 we denote the set of all paths between @xmath46 in @xmath42 , i.e. , @xmath47 and @xmath48 .",
    "the ( unweighted ) _ diameter _ of @xmath42 is + @xmath49 .",
    "the ( weighted ) _ distance _ of @xmath50 and @xmath51 in @xmath42 is @xmath52 .",
    "the _ weighted diameter _ of @xmath42 is @xmath53 .",
    "its _ shortest - path - diameter _ is @xmath54 .    for @xmath55 and @xmath56",
    ", we use @xmath57 to denote the ball of radius @xmath58 around @xmath50 in @xmath42 , which includes all nodes and edges at weighted distance at most @xmath58 from @xmath50 . the ball may contain edge fractions : for an edge @xmath59 for which @xmath51 is in @xmath57 , the @xmath60 fraction of the edge closer to @xmath51",
    "is considered to be within @xmath57 , and the remainder is considered outside @xmath57 .",
    "we use `` soft '' asymptotic notation . formally , given functions @xmath61 and @xmath62 , define ( i ) @xmath63 iff there is some @xmath64 so that @xmath65 , ( ii ) @xmath66 iff @xmath67 , and ( iii ) @xmath68 iff @xmath69 . by `` w.h.p .",
    ", '' we abbreviate `` with probability @xmath70 '' for a sufficiently large constant in the @xmath71 term .    [",
    "[ the - distributed - steiner - forest - problem . ] ] the distributed steiner forest problem . + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + +    in the steiner forest problem , the output is a set of edges .",
    "we require that the output edge set @xmath72 is represented distributively , i.e. , each node can locally answer which of its adjacent edges are in the output .",
    "the input may be represented by two alternative methods , both are justified and are common in the literature .",
    "we give the two definitions .",
    "[ distributed steiner forest with connection requests ( dsf - cr ) ]     at each node @xmath50 , a set of _ connection requests _ @xmath73 .    an edge set @xmath74 such that for each connection request @xmath75 , @xmath50 and @xmath51 are connected by @xmath72 .",
    "minimize @xmath76 .",
    "the set of _ terminal _ nodes is defined to be @xmath77 , i.e. , the set of nodes @xmath50 for which there is some connection request @xmath78 .       at each node @xmath50 , @xmath79 , where @xmath80 is the set of _ component identifiers_. the set of _ terminals _ is @xmath81 .",
    "an _ input component _",
    "@xmath82 for @xmath83 is the set of terminals with label @xmath84 .",
    "an edge set @xmath74 such that all terminals in each input component are connected by @xmath72 .",
    "minimize @xmath76 .",
    "an instance of dsf - icis _ minimal _ , if @xmath85 for all @xmath86 .",
    "we assume that the labels @xmath86 are encoded using @xmath6 bits .",
    "we define @xmath87 and @xmath88 , i.e. , the number of terminals and input components , respectively .",
    "we say that any two instances of the above problems on the same weighted graph , regardless of the way the input is given , are _ equivalent _ if the set of feasible outputs for the two instances is identical .",
    "[ lemma : transform_to_input ] any instance of dsf - crcan be transformed into an equivalent instance of dsf - icin @xmath89 rounds .    [ lemma : transform_to_minimal ] any instance of dsf - iccan be transformed into an equivalent minimal instance of dsf - icin @xmath90 rounds .",
    "in this section we state our lower bounds ( for proofs and more discussion , see . ) as our first result , we show that applying to instances of dsf - crcomes at no penalty in asymptotic running time ( a lower bound of @xmath91 is trivial ) .",
    "[ lem - lb1 ] any distributed algorithm for dsf - crwith finite approximation ratio has time complexity @xmath92 .",
    "this is true even in graphs with diameter at most @xmath93 and no more than two input components .    the main result of this section is the following theorem .    [ thm - lb ]",
    "any algorithm for the distributed steiner forest problem with non - trivial approximation ratio has worst - case time complexity in @xmath94 in expectation .",
    "the proof of in fact consists of proving the following two separate lower bounds .",
    "[ lem : lower_k ] any distributed algorithm for dsf - icwith finite approximation ratio has time complexity @xmath95 .",
    "this is true even for unweighted graphs of diameter 3 .",
    "[ lem : lower_s ] any distributed algorithm for dsf - icor dsf - crwith finite approximation ratio has running time @xmath96 for @xmath97 .",
    "this holds even for instances with @xmath98 , @xmath31 , and @xmath99 .",
    "we remark that the proofs of lemmas  [ lem - lb1 ] and [ lem : lower_k ] , are by reductions from set disjointness @xcite . in lemmas  [ lem - lb1 ] and  [ lem : lower_k ]",
    ", it is trivial to increase the other parameters , i.e. , @xmath8 , @xmath3 , @xmath4 , or @xmath13 , so we may apply lemmas  [ lemma : transform_to_input ] and  [ lemma : transform_to_minimal ] to obtain a minimal instance of dsf - icwithout affecting the asymptotic time complexity .",
    "let @xmath300 be a distributed algorithm for dsf - crwith approximation ratio @xmath301 .",
    "we reduce set disjointness ( sd ) to @xmath302-approximate dsf - cras follows .",
    "let @xmath303 $ ] be an instance of sd .",
    "alice , who knows @xmath304 , constructs the following graph : the nodes are the set @xmath305 and two additional nodes denoted @xmath306 and @xmath307 .",
    "all nodes corresponding to elements in @xmath304 are connected to @xmath306 and all nodes corresponding to @xmath308\\setminus a$ ] are connected to @xmath307 .",
    "formally , define @xmath309 .",
    "similarly , bob constructs nodes @xmath310 and edges @xmath311 .",
    "in addition to the edges @xmath312 and @xmath313 , the graph contains the edges @xmath314 .",
    "all edges , except @xmath315 have unit cost , and the edges @xmath315 have cost @xmath316 .",
    "this concludes the description of the graph ( see left ) .",
    "finally , we define the connection requests as follows : for each @xmath317 we introduce the connection request @xmath318 , and similarly for each @xmath319 we introduce the request @xmath320 .",
    "note that we have @xmath321 and @xmath322 .",
    "this completes the description of the dsf - crinstance .",
    "we now claim that if @xmath300 computes a @xmath302-approximation to dsf - cr , then we can output the answer `` yes '' to the original sd instance iff @xmath300 produces an output that does not include neither of the heavy edges @xmath323 . to see this , consider the optimal solutions . if @xmath324 , then all connection requests can be satisfied using edges from @xmath325 .",
    "hence the optimal cost is at most @xmath326 , which means that any @xmath302-approximate solution can not include a heavy edge ; and if @xmath327 , then any solution must include at least one of the heavy edges , and hence its weight is larger than @xmath328 .",
    "it follows that if @xmath300 is a @xmath302-approximate solution to dsf - cr , then the following algorithm solves sd : alice and bob construct the graph based on their local input without any communication",
    ". then alice simulates @xmath300 on the @xmath329 nodes and bob simulates @xmath300 on the @xmath330 nodes . the only communication required between alice and bob to run",
    "the simulation is the messages that cross the edges in @xmath331 .",
    "now , solving sd requires exchanging @xmath332 bits in the worst case ( see , e.g. , @xcite ) . in the @xmath333 model , at most @xmath334 bits can cross @xmath331 in a round , and hence it must be the case that the running time of @xmath300 is in @xmath335 .",
    "* remarks . *",
    "+ @xmath336 in the lower bound , @xmath13 is a parameter describing the universe size of the input to sd .",
    "let @xmath337 denote the number of nodes in the corresponding instance of dsf - cr .",
    "note that we can set @xmath337 to any number larger than @xmath326 just by adding isolated nodes .",
    "similarly we can extend the diameter to any number larger than @xmath100 so long as it s smaller than @xmath338 by attaching a chain of @xmath339 nodes to @xmath340 .",
    "finally , we can also extend @xmath5 to any number larger than @xmath30 by adding pairs of nodes @xmath341 , each pair connected by an edge , and have @xmath342 .",
    "+ @xmath336 since @xmath8 is a trivial lower bound , we may apply to convert any dsf - crinstance with @xmath343 into an dsf - icinstance without losing worst - case performance w.r.t .",
    "the set of the considered parameters .",
    "( if we are guaranteed that @xmath31 , the transformation is trivial , as all terminals are to be connected . ) + @xmath336 we note that in the hard instances of sd , @xmath344 and @xmath345 .",
    "+ @xmath336 the hardness result applies to dsf - cralgorithms that do not require symmetric requests . more specifically ,",
    "if the dsf - cralgorithm works only for inputs satisfying @xmath346 , then the reduction from sd fails .",
    "+ @xmath336 the special case of mst ( @xmath347 and @xmath31 ) can be solved in time @xmath348 @xcite .    as in , we reduce set disjointness ( sd ) to dsf - ic .",
    "specifically , the reduction is as follows .",
    "let @xmath349 be the input sets to alice and bob , respectively , where @xmath350 $ ] .",
    "alice constructs a star whose leaves are the nodes @xmath305 , all connected to a center node @xmath306 ( see right ) . for each node",
    "@xmath351 alice sets @xmath352",
    "if @xmath317 and @xmath353 otherwise . similarly bob constructs another star whose leaves are @xmath354 , all connected to the center node @xmath355 , and sets @xmath356 if @xmath319 and @xmath357 otherwise .",
    "in addition the instance to dsf - iccontains the edge @xmath358 .",
    "all edges have unit weight .",
    "note that using dsf - icterminology , we have that the number of input components satisfies @xmath359 .",
    "we now claim that given any @xmath302-approximation algorithm @xmath300 for dsf - ic , the following algorithm solves sd : alice and bob construct the graph ( without any communication ) , and then they simulate @xmath300 , where alice simulates all the @xmath329 nodes and bob simulates all the @xmath330 nodes .",
    "the answer to sd is yes iff the edge @xmath358 is not in the output of @xmath300 . to show the algorithm correct , consider two cases .",
    "if the sd instance is a no instance , then there exists some @xmath360 , which implies , by construction , that @xmath351 and @xmath361 must be connected by the output edges , and , in particular , the edge @xmath358 must be in the output of @xmath362 ( otherwise @xmath362 did not produce a valid output ) ; and if the sd instance was a no instance , then the optimal solution to the constructed dsf - icinstance contains no edges , i.e. , its weight is @xmath102 , and therefore no finite - approximation algorithm may include any edge , and in particular the edge @xmath358 , in its output .",
    "this establishes the correctness of the reduction .",
    "finally , we note that the simulation of @xmath300 requires communicating only the messages that are sent over the edge @xmath363 .",
    "since , as mentioned above , any algorithm for sd requires communicating @xmath332 bits between alice and bob , we conclude that if @xmath300 guarantees finite approximation ratio , the number of bits it must communicate over @xmath364 is in @xmath365 , and since in the @xmath333 model only @xmath334 bits can be communicated over a single edge in each round , it must be the case that the running time of @xmath300 is in @xmath366 .",
    "follows from the observation that the shortest @xmath3-@xmath4 path is a special case of the steiner forest problem where @xmath3 and @xmath4 are the only two terminals , belonging to the same component .",
    "therefore the lower bound of @xcite on distributed algorithms solving the shortest @xmath3-@xmath4 path problem applies .",
    "in this section we describe our deterministic algorithm .",
    "we start by reviewing the moat growing algorithm of @xcite , and then adapt it to the congestmodel .    [",
    "[ basic - moat - growing - algorithm ] ] basic moat growing algorithm + + + + + + + + + + + + + + + + + + + + + + + + + + + +    ( pseudocode in )",
    ". the algorithm proceeds by `` moat growing '' and `` moat merging . ''",
    "a _ moat _ of radius @xmath58 around a terminal @xmath50 is a set that contains all nodes and edges within distance @xmath58 from @xmath50 , where edges may be included fractionally : for example , if the only edge incident with @xmath50 has weight @xmath100 , then the moat of radius @xmath30 around @xmath50 contains @xmath50 and the @xmath101 of the edge closest to @xmath50 . _",
    "moat growing _ is a process in which multiple moats increase their radii at the same rate .",
    "the algorithm proceeds as follows .",
    "all terminals , in parallel , grow moats around them until two moats intersect . when this happens ,    moat growth is temporarily suspended ,    the edges of a shortest path connecting two terminals in the meeting moats are output ( discarding edges that close cycles ) , and    the meeting moats are contracted into a single node .    this is called a _ merge step _ or simply _",
    "merge_. then moat growing resumes , where the newly formed node is considered an active terminal if some input component is contained partially ( not wholly ) in the contracted region , and otherwise the new node is treated like a regular ( non - terminal ) node .",
    "if the new node is an active terminal , it resumes the moat - growing with initial radius @xmath102 .",
    "the algorithm terminates when no active terminals remain .",
    "formal details and analysis are provided in .",
    "the bottom line is as follows .",
    "[ theorem:2approx ] outputs a @xmath30-approximate steiner forest .",
    "[ [ rounded - moat - radii . ] ] rounded moat radii .",
    "+ + + + + + + + + + + + + + + + + + +    to reduce the number of times the moat growing is suspended due to moats meeting , we defer moat merging to the next integer power of @xmath103 , where @xmath104 is a given parameter .",
    "pseudo - code is given in in the appendix . obviously , the number of distinct radii in which merges may occur in this algorithm is now bounded by @xmath105 by our assumption that all edge weights , and hence the weighted diameter , are bounded by a polynomial in @xmath13 .",
    "furthermore , approximation deteriorates only a little , as the following result states ( proof in ) .",
    "[ theorem:2+eps_approx ] outputs a @xmath1-approximate steiner forest .",
    "our goal in this section is to derive a distributed implementation of the centralized . to do this",
    ", it is sufficient to follow the order in which moats merge in the sequential algorithm .",
    "the first main challenge we tackle is to achieve pipelining for the merges that do not change the activity status of terminals ; since all active moats grow at the same rate , we can compute the merge order simply by finding the distances between moats and ordering them in increasing order . when the active status of some terminal changes , we recompute the distances",
    ". we start by defining _",
    "merge phases_. intuitively , a merge phase is a maximal subsequence of merges in which no active terminal turns inactive and no inactive terminal is merged with an active one .",
    "[ def : merge ] consider a run of , and let @xmath106 be the values of @xmath107 in which @xmath108 for some @xmath109 , where @xmath110 .",
    "steps @xmath111 are called _ merge phase @xmath112 _ , and we denote @xmath113 , i.e. , node @xmath50 s activity status throughout merge phase @xmath112 .",
    "we use @xmath114 to denote the _ phase of merge @xmath107_.    [ lem - numphases ] the number of merge phases is at most @xmath115 .",
    "next , we define _ reduced weights _ , formalizing moat contraction .",
    "we use the following notation",
    ".    * notation .",
    "* for a terminal @xmath50 and merge step @xmath107 , @xmath116 .",
    "given merge phase @xmath112 of , define the _ reduced weight _ of an edge @xmath117 by @xmath118 , where fractionally contained edges lose weight accordingly .",
    "note that @xmath119 is determined by the state of the moats just before phase @xmath112 starts .",
    "we now define the voronoi decomposition for phase @xmath112 .",
    "let @xmath38 be a graph with non - negative edge weights , and let @xmath120 be a set of nodes called _ centers _ , with positive distances between any two centers . the _ voronoi decomposition _ of @xmath42 w.r.t .",
    "@xmath121 is a partition of the nodes and edges into @xmath5 subsets called _ voronoi regions _ , where region @xmath107 contains all nodes and all edge parts whose closest center is @xmath122 ( ties broken lexicographically ) .    in each phase @xmath112 , we consider the voronoi decomposition using reduced weights @xmath119 and active terminals as centers .",
    "let @xmath123 denote the voronoi region of a node @xmath50 under this decomposition .",
    "since we need to consider inactive moats too , the concept we actually use is the following .",
    "the _ region _ of a terminal @xmath50 in phase @xmath112 , denoted @xmath124 , is defined as follows .",
    "@xmath125 , and for @xmath126 , @xmath127 the @xmath128 terminal decomposition is given by a collection of shortest - path - trees spanning , for each @xmath109 , @xmath124 .",
    "we require that the tree of @xmath129 extends the tree of @xmath130 .",
    "in other words , @xmath124 is obtained from @xmath130 by growing all active moats at the same rate , but only into uncovered parts of the graph ; this growth stops at the end of a merge phase .",
    "given the @xmath131 terminal decomposition , it is straightforward to compute @xmath132 and the required spanning trees using the bellman - ford algorithm , as the following lemma states .",
    "[ lemma : partition ] suppose that each node @xmath133 knows the following about the @xmath134 terminal decomposition :    the node @xmath109 for which @xmath135 ;    @xmath136 ;    the parent in the shortest - path - tree spanning @xmath130 ( unless @xmath137 is the root ) ;    @xmath138 .",
    "then , in @xmath139 rounds we can compute shortest - path - trees rooted at nodes @xmath109 , that extend the given trees and span @xmath140 for active @xmath50 ( trees of inactive terminals remain unchanged ) . by the end of the computation , each node knows :    the node @xmath109 in whose tree @xmath141 participates ;    the parent in the shortest - path - tree rooted at @xmath50 ( unless @xmath137 is the root ) ;    for each edge incident to @xmath141 , the fraction of it contained in the tree rooted at @xmath50 ;    @xmath138 .",
    "note that says that we can `` almost '' compute the @xmath128 terminal decomposition ( the @xmath142 remain unknown ) .",
    "what justifies the trouble of computing decompositions is the following key observation .",
    "[ lemma : path_in_region ] for @xmath143 , let @xmath144 and @xmath145 be the terminals whose moats are joined in the @xmath146 merge of .",
    "let @xmath147 be a shortest path connecting them .",
    "then @xmath148 .    implies that each merging path is `` witnessed '' by the nodes of the respective edge crossing the boundary between the regions . by the construction from",
    ", these nodes will be able to correctly determine the reduced weight of the path .",
    "this motivates the following definition .",
    "[ def - induced ] for each @xmath109 , fix a shortest - paths tree on @xmath149 .",
    "suppose that @xmath150 is an edge so that @xmath151 and @xmath152 for some terminals @xmath153",
    ". then @xmath117 _ induces _ the unique path @xmath154 that is the concatenation of the shortest path from @xmath50 to @xmath155 given by the terminal decomposition with @xmath156 and the path from @xmath157 to @xmath51 given by the terminal decomposition .",
    "since the witnessing nodes can not determine locally whether `` their '' path is the next merging path , they need to encapsulate and communicate the salient information about the witnessed path .",
    "[ def - cands ] suppose that @xmath150 is an edge satisfying @xmath158 and @xmath159 with @xmath153 , @xmath160 , @xmath161 , and @xmath162 .",
    "then @xmath117 is said to induce a _",
    "candidate merge _ @xmath163 in phase @xmath112 with _ associated path _",
    "@xmath154 .",
    "@xmath164 specifies the increment of the moat radius of the ( active ) terminal @xmath50 before the respective balls intersect . to order candidate merges",
    "we need the following additional concept .",
    "[ def - cand - graph ] the _ candidate multigraph _ is defined as @xmath165 , where for each candidate merge @xmath166 there is an edge @xmath167 .",
    "we can now relate the paths selected by to the candidate merges .",
    "[ lemma : equivalent ] consider the sequence of candidate merges ordered in ascending lexicographical order : first by phase index , then by reduced weight , and finally break ties by identifiers . discard each merge that closes a cycle ( including parallel edges ) in @xmath168 .",
    "let @xmath169 be the resulting forest in @xmath168 .",
    "then union of the paths corresponding to @xmath170 is exactly the set @xmath171 computed by ( with the same tie - breaking rules ) .",
    "implies that , similarly to kruskal s algorithm , it suffices to scan the candidate merges in ascending order and filter out cycle - closing edges .",
    "using the technique introduced for mst @xcite , the filtering procedure can be done concurrently with collecting the merges , achieving full pipelining effect .",
    "for later development , we show a general statement that allows for multiple merge phases to be handled concurrently and out - of - order execution of a subset of the merges .",
    "[ lemma : filtering ] denote by @xmath172 the subset of candidate merges in phase @xmath112 and set @xmath173 . for a set @xmath174 ,",
    "assume that each node @xmath133 is given a set @xmath175 of candidate merges such that @xmath176 .",
    "finally , assume that for each @xmath133 , each candidate merge in @xmath175 is tagged by the connectivity components of its terminals in the subgraph @xmath177 of @xmath168 .",
    "then @xmath178 can be made known to all nodes in @xmath179 rounds .",
    "when emulating distributively , we may overrun the end of the phase if the causing event occurs remotely .",
    "this may lead to spurious merges , which should be invalidated later .",
    "a _ false candidate _ is a tuple @xmath180 with @xmath181 , @xmath182 , @xmath183 , and @xmath184 that is not a candidate merge .",
    "order is extended to false candidates in the natural way .    fortunately , false candidates originating from the @xmath128 voronoi decomposition given by will always have larger weights than candidate merges in phase @xmath112 , since they are induced by edges outside @xmath185 ( see ) .",
    "this motivates the following corollary .",
    "[ coro : filtering ] let @xmath172 denote the set of candidate merges in phase @xmath112 and set @xmath173 .",
    "suppose @xmath186 is globally known , as well @xmath187 , for all @xmath109 .",
    "if each node @xmath133 is given a set @xmath175 of candidate merges and false candidates so that @xmath188 and each false candidate has larger weight than all candidate merges in @xmath172 , then @xmath189 can be made globally known in @xmath190 rounds .",
    "we can now describe the algorithm ( see pseudocode in ) .",
    "the algorithm proceeds in merge phases . in each phase",
    ", it constructs the @xmath128 terminal decomposition except for knowing the @xmath142 values ( ) . using this decomposition ,",
    "nodes propose candidate merges , of which some are false candidates .",
    "the filtering procedure from is applied to determine @xmath191 .",
    "the weight of the last merge is the increase in moat radii during phase @xmath112 , setting @xmath142 and thus @xmath124 for each @xmath109 , which allows us to proceed to the next phase .",
    "finally , the algorithm computes the minimal subforest of the computed forest , as in .",
    "we summarize the analysis with the following statement .",
    "[ theorem:2_distributed ] dsf - iccan be solved deterministically with approximation factor @xmath30 in @xmath192 rounds .",
    "the additive @xmath4 term in can be avoided .",
    "we do this by generalizing a technique first used for mst construction  @xcite . roughly , the idea is to allow moats to grow locally until they are `` large , '' and then use centralized filtering .",
    "a new threshold that distinguishes `` large '' from `` small '' in this case is @xmath193 .",
    "define @xmath194 .",
    "a moat is called _ small _ if when formed , its connected component using edges that were selected to the output up to that point contains fewer than @xmath195 nodes . a moat which is not small",
    "is called _ large_.    to reduce the time complexity , we implement , where moats change their `` active '' status only between",
    "_ growth phases_. in each growth phase , the maximal moat radius grows by a factor of @xmath196 .",
    "the key insight here is that all we need is to determine at which moat size the first inactive moat gets merged , because all active terminals keep growing their moats throughout the entire growth phase .",
    "we first slightly adapt the definition of merge phases .    for",
    "an execution of , denote by @xmath197 , @xmath198 , the merges for which either the if - statement in is executed or one of the moats participating in the merge is inactive .",
    "then the merges @xmath199 constitute the _ @xmath128 merge phase_. for @xmath200 , denote by @xmath201 the index so that @xmath202 is the @xmath203 merge for which the if - statement in is executed .",
    "then the merges @xmath204 constitute the _",
    "@xmath203 growth phase _ and we define that @xmath205 . for convenience , @xmath206 and @xmath207 .    for constant @xmath104 ,",
    "the number of growth phases is in @xmath6 ( see ) .",
    "[ [ algorithm - overview . ] ] algorithm overview .",
    "+ + + + + + + + + + + + + + + + + + +    the algorithm is specified in , except for the final pruning step , which is discussed below .",
    "the main loop runs over growth phases : first , regions and terminal decompositions are computed .",
    "then , each small moat proposes its least - weight candidate merge . to avoid long chains of merges ,",
    "we run a matching algorithm with small moats as nodes and proposed merges as edges , and then add the candidate merges proposed by the unmatched small moats . after a logarithmic number of iterations of this procedure , at most @xmath195 moats remain that may participate in further merges in the growth phase ; the filtering procedure from then selects the remaining merges in @xmath208 rounds . finally , the activity status for the next growth phase is computed ; small moats are handled by communicating over the edges connecting them , and large moats rely on pipelining communication over a bfs tree .",
    "[ [ analysis - overview . ] ] analysis overview .",
    "+ + + + + + + + + + + + + + + + + +    the analysis is given in .",
    "we only review the main points here .",
    "first , shows that small moats have strong diameter at most @xmath195 , and that the number of large moats is bounded by @xmath195 .",
    "we show , in , that the set @xmath209 the algorithm selected by the end of growth phase @xmath62 is identical to that selected by an execution of on the same instance of dsf - ic . to this end , first shows that the terminal decompositions are computed correctly in @xmath210 rounds .",
    "finally , we prove in that the growth phase is completed in @xmath211 rounds and , if it was not the last phase , it provides the necessary information to perform the next one .",
    "we summarize the results of this subsection as follows .",
    "[ coro : growth ] for any instance of dsf - ic , a distributed algorithm can compute a solving forest @xmath72 in @xmath212 rounds that satisfies that its minimal subforest solving the instance is optimal up to factor @xmath213 .    [ [ sec : prune ] ] fast pruning algorithm .",
    "+ + + + + + + + + + + + + + + + + + + + + + +    after computing @xmath72 , it remains to select the minimal subforest solving the given instance of problem dsf - ic : we may have included merges with non - active moats that need to be pruned .",
    "simply collecting @xmath170 and @xmath84 at a single node takes @xmath214 rounds , and the depth of ( the largest tree in ) @xmath72 can be @xmath215 in the worst case .",
    "thus , we employ some of the strategies for computing @xmath72 again .",
    "first , we grow clusters to size @xmath195 locally , just like we did for moats , and then solve a derived instance on the clusters to decide which of the inter - cluster edges to select . subsequently , the subtrees inside clusters have sufficiently small depth to resolve the remaining demands by a simple pipelining approach .",
    "details are provided in .",
    "we summarize as follows .",
    "[ coro:2+eps_distributed ] for any constant @xmath0 , a deterministic distributed algorithm can compute a solution for problem dsf - icthat is optimal up to factor @xmath1 in @xmath216 rounds , where @xmath217 is the number of input components with at least two terminals .",
    "in @xcite , khan _ et al . _  propose a randomized algorithm for dsf - icthat constructs an expected @xmath6-approximate solution in @xmath218 time w.h.p . in this section",
    "we show how to modify it so as to reduce the running time to @xmath219 while keeping the approximation ratio in @xmath6 .    [ [ overview - of - the - algorithm - in- . ] ] overview of the algorithm in @xcite .",
    "+ + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + +    the algorithm consists of two main steps .",
    "first , a virtual tree is constructed and embedded in the network , where each physical node is a virtual leaf .",
    "then the algorithm selects , for each input component @xmath84 , the minimal subtree containing all terminals labeled @xmath220 , and adds , for each virtual edge in these subtrees , the physical edges of the corresponding path in @xmath42 . since the selected set of virtual edges corresponds to an optimal solution in the tree topology , and since it can be shown that the expected stretch factor of the embedding is in @xmath6 , the result follows .    in more detail ,",
    "the virtual tree is constructed as follows .",
    "nodes pick ids independently at random .",
    "each node of the graph is a leaf in the tree , with ancestors @xmath221 , where @xmath222 the base-2 logarithm of the weighted diameter ( rounded up ) .",
    "the @xmath146 ancestor @xmath144 is the node with the largest i d within distance @xmath223 from @xmath50 , for a global parameter @xmath224 picked uniformly at random from @xmath225 $ ] .",
    "the weight of the virtual edge @xmath226 is defined to be @xmath223 .",
    "we note that the embedding in @xmath42 is via a shortest path from each node @xmath50 to each of its @xmath227 ancestors ( and not from @xmath228 to @xmath144 ) , implemented by `` next hop '' pointers along the paths .",
    "it is shown that w.h.p .",
    ", at most @xmath6 such distinct paths pass through any physical node .",
    "now , consider the second phase .",
    "let @xmath229 , for an input component @xmath84 , denote the minimal subtree that contains all terminals of @xmath84 as leaves . clearly , @xmath230 is the optimal solution to dsf - icon the virtual tree .",
    "thus , all that needs to be done is to select for each virtual edge in this solution a path in @xmath42 ( of weight smaller or equal to the virtual tree edge ) so that the nodes in @xmath42 corresponding to the edge s endpoints get connected .",
    "however , since the embedding of the tree may have paths of @xmath139 hops , and since there are @xmath5 labels to worry about , the straightforward implementation from  @xcite requires @xmath10 rounds to select the output edges due to possible congestion .",
    "[ [ overview - of - our - algorithm . ] ] overview of our algorithm .",
    "+ + + + + + + + + + + + + + + + + + + + + + + + + +    our first idea is to improve the second phase from  @xcite as follows .",
    "each internal node @xmath144 is the root of a shortest paths tree of weighted diameter @xmath223 . for any virtual tree edge @xmath231 , we make sure that exactly one node @xmath50 in the virtual subtree rooted at @xmath228 includes the edges of a shortest physical path ( in @xmath42 ) connecting @xmath50 and @xmath144 in the edge set @xmath72 output of the algorithm .",
    "this is done by @xmath50 by sending a message @xmath232 to @xmath144 up the shortest paths tree rooted at @xmath144 , and these messages are filtered along the way so that only the first @xmath232 message is forwarded for each @xmath86 .",
    "this ensures that the only @xmath233 steps are needed per destination .",
    "since there are @xmath6 such destinations for each node , by time - multiplexing we get running time of @xmath33 ( w.h.p . ) .",
    "when @xmath34 , was known , because it can be determined in @xmath234 rounds as follows : compute @xmath13 by convergecast , then run bellman - ford until stabilization or until @xmath235 iterations have elapsed , whichever happens first . since stabilization can be detected @xmath236 time after it occurs , we are done . ] the running time can be improved further to @xmath35 .",
    "the idea is as follows .",
    "let @xmath237 be the set of the @xmath238 nodes of highest rank .",
    "we truncate each leaf - root path in the virtual tree at the first occurrence of a node from @xmath239 : instead of connecting to that ancestor , the node @xmath50 connects to the _ closest _ node from @xmath237 .",
    "this construction can be performed in time @xmath35 w.h.p .",
    "consider now the edge set @xmath72 returned by the procedure above : for each input component @xmath86 , the terminals labeled @xmath84 will be partitioned into connected components , each containing a node from @xmath239 ( if there is a single connected component it is possible that it does not include any node from @xmath239 ) .",
    "we view each such connected component as a `` super - terminal '' and solve the problem by applying an algorithm from @xcite .",
    "the output is obtained by the set @xmath72 from the first virtual tree and the additional edges selected by this algorithm .",
    "we show that the overall approximation ratio remains @xmath6 and that the total running time is @xmath240 .",
    "[ [ detailed - description . ] ] detailed description .",
    "+ + + + + + + + + + + + + + + + + + + + +    we present the construction for @xmath241 and @xmath34 in a unified way .",
    "detailed proofs for the claimed properties are given in .",
    "the first stage consists of the following steps .",
    "if @xmath241 , set @xmath242 .",
    "otherwise , let @xmath243 be the set of @xmath238 nodes of highest rank .",
    "delete from the virtual tree internal nodes mapped to nodes of @xmath239 .",
    "compute the remaining part of the virtual tree and , if @xmath244 , let each node learn about its closest node from @xmath237 .",
    "in other words , each node @xmath245 learns the identity of and the shortest paths to @xmath246 , where @xmath247 is the node closets to @xmath50 from @xmath239 .",
    "if @xmath248 , @xmath249 and @xmath250 .    for each terminal @xmath109 ,",
    "set @xmath251 .",
    "for all other terminals , @xmath252 .    for @xmath253 phases :    make for each @xmath86 known to all nodes whether it satisfies that there is only one terminal @xmath109 with @xmath254 .",
    "if this is the case , delete @xmath84 from @xmath255 .",
    "each node @xmath55 sets @xmath256 if @xmath257 and @xmath258 otherwise . then all nodes set @xmath259 , @xmath252 , and @xmath260 .",
    "repeat until no more messages are sent :    for each node @xmath51 , do the following .",
    "each node @xmath55 for which @xmath261 picks some @xmath262 and sets @xmath263 .",
    "if @xmath153 , it sends @xmath264 to the next node on the least - weight path to @xmath51 known from the tree construction , otherwise it sets @xmath265 . each traversed edge",
    "is added to @xmath72 .",
    "each node @xmath50 that receives a message @xmath264 sets @xmath266 .",
    "each node @xmath51 with @xmath267 selects a node @xmath50 that added , for some @xmath84 , @xmath264 to its @xmath268 variable in step  3b .",
    "it sends all entries in its @xmath269 variable to @xmath50 .",
    "the node @xmath50 and the routing path to @xmath50 are determined by backtracing a sequence of messages @xmath264 from step 3c .",
    "the receiving node @xmath50 sets @xmath270 .",
    "return @xmath72 .    _ the second stage .",
    "_ if @xmath241 , @xmath72 is the solution .",
    "otherwise , we construct a new instance and solve it . to define the new instance , define , for each @xmath271 , the node set @xmath272 ties broken lexicographically .",
    "let @xmath273 .",
    "the new instance is defined over the following graph .",
    "the _ @xmath72-reduced graph _",
    "@xmath274 is defined as follows .",
    "@xmath275    @xmath276    @xmath277    to complete the description of the new instance , we specify the new terminals and labels . given an instance of dsf - icand the edge set @xmath72 computed in the first stage , the _ @xmath72-reduced instance _ is defined over the @xmath72-reduced graph @xmath278 as follows .",
    "the set of terminals is @xmath279 . to construct the labels ,",
    "define the helper graph @xmath280 , where @xmath281 now , let @xmath282 be the set of connected components of @xmath280 , identified by @xmath6 bits each . finally , the label @xmath283 of a node @xmath284 in @xmath285 is the identifier of the connected component in @xmath280 of any label @xmath86 which belongs to any node in @xmath284 ( @xmath286 is well defined , because all these labels belong to the same connected component of @xmath280 ) .",
    "since the reduced instance imposes fewer constraints , its optimum is at most that of the original instance . we show that the reduced instance can be constructed efficiently , within @xmath35 rounds , and then apply the algorithm from  @xcite to solve it with approximation factor @xmath287 . for this approximation guarantee ,",
    "the algorithm has time complexity @xmath288 ; since we made sure that the reduced instance has @xmath289 terminals only , this becomes @xmath32 .",
    "the union of the returned edge set with @xmath72 then yields a solution of the original instance that is optimal up to factor @xmath6 .",
    "detailed proofs of these properties and the following main theorem can be found in .",
    "[ theorem : fast ] there is an algorithm that solves dsf - icin @xmath290 rounds within factor @xmath6 of the optimum w.h.p .",
    "10    a.  agrawal , p.  klein , and r.  ravi . . ,",
    "24:440456 , 1995 .",
    "m.  brazil , r.  graham , d.  thomas , and m.  zachariasen . .",
    ", pages 128 , 2013 .",
    "j.  byrka , f.  grandoni , t.  rothvo , and l.  sanit . . in _ proc",
    "42nd acm symp .  on theory of computing _ ,",
    "pages 583592 , 2010 .",
    "p.  chalermsook and j.  fakcharoenphol . .",
    "in _ proc .",
    "11th conf .  on computing and combinatorics _ ,",
    "pages 380389 , 2005 .",
    "m.  chlebk and j.  chlebkov . .",
    ", 406(3):207214 , 2008 .",
    "r.  cole and u.  vishkin . .",
    "in _ proc .",
    "18th acm symp . on theory of computing _ , pages 206219 , 1986 .",
    "r.  courant and h.  robbins . .",
    "oxford university press , 1941 .",
    "a.  das sarma , s.  holzer , l.  kor , a.  korman , d.  nanongkai , g.  pandurangan , d.  peleg , and r.  wattenhofer . .",
    "in _ proc .  43th acm symp .  on theory of computing _ ,",
    "pages 363372 , 2011 .",
    "m.  elkin . .",
    ", 36(2):463501 , 2006 .",
    "r.  g. gallager , p.  a. humblet , and p.  m. spira . .",
    ", 5(1):6677 , 1983 .",
    "j.  garay , s.  kutten , and d.  peleg . .",
    ", 27:302316 , 1998 .",
    "m.  hauptmann and m.  karpinski . .",
    "retreived january 2014 .",
    "r.  m. karp .",
    "reducibility among combinatorial problems . in _",
    "complexity of computer computations _ , pages 85103 .",
    "plenum , new york , 1972 .",
    "m.  khan , f.  kuhn , d.  malkhi , g.  pandurangan , and k.  talwar . .",
    ", 25:189205 , 2012 .",
    "e.  kushilevitz and n.  nisan . .",
    "cambridge university press , 1997 .",
    "s.  kutten and d.  peleg . .",
    ", 28(1):4066 , 1998 .    c.  lenzen and b.  patt - shamir . .",
    "in _ proc .  45th ann .",
    "acm symp .  on theory of computing _ ,",
    "pages 381390 , 2013 .",
    "z.  lotker , b.  patt - shamir , and d.  peleg .",
    "distributed mst for constant diameter graphs .",
    ", 18(6):453460 , 2006 .",
    "d.  peleg . .",
    "siam , philadelphia , pa , 2000 .",
    "d.  peleg and v.  rubinovich . .",
    ", 30:14271442 , 2000 .",
    "we construct an ( unweighted ) breadth - first - search ( bfs ) tree rooted at an arbitrary node , say the one with the largest identifier .",
    "clearly , this results in a tree of depth @xmath236 this can be done in @xmath236 rounds .",
    "for the first transformation , each node sends all connection requests it initially knows or receives from its children and that do not close cycles in @xmath291 to the root .",
    "since any forest on @xmath291 has at most @xmath292 edges , this takes at most @xmath20 rounds using messages of size @xmath6 .",
    "subsequently , the remaining set of requests at the root is broadcasted over the bfs tree to all nodes , also in time @xmath20 . by transitivity of connectivity ,",
    "a set @xmath72 is feasible in the original instance iff it is feasible w.r.t .",
    "the remaining set of connectivity requests .",
    "since these are now global knowledge , the nodes can locally compute the induced connectivity components ( on the set of terminals ) and and unique labels for them : say , the smallest i d in the component .",
    "setting the label of terminal @xmath50 to the label of its connectivity component , the resulting instance with input components is equivalent as well .    as for the previous lemma",
    ", we construct a bfs tree rooted at some node .",
    "each terminal sends the message @xmath293 to its parent in the bfs tree . for each label",
    "@xmath84 , if a node ever learns about two different messages @xmath294 , @xmath295 , it sends @xmath296 to its parent and ignores all future messages with label @xmath84 .",
    "all other messages are forwarded to the parent . since for each label @xmath84 , no node sends more than @xmath30 messages , this step completes in @xmath90 rounds .",
    "afterwards , for each @xmath84 with @xmath297 , the root has either received a message @xmath296 , or it has received two messages @xmath294 , @xmath295 , or it has received one message @xmath294 and is in input component @xmath82 itself . on the other hand , if @xmath298 , clearly none of these cases applies .",
    "therfore , the root can determine the subset of labels @xmath299 and broadcast it over the bfs tree , taking another @xmath90 rounds .",
    "the minimal instance is then obtained by all terminals in singleton input components deleting their label .",
    "@xmath367 // moats partition @xmath291 ; for @xmath109 , let @xmath368 s.t .",
    "@xmath369 + @xmath370 // set of selected edges + @xmath371 + // may have selected useless paths    each iteration of the while - loop of is called a _ merge step _ , or simply a _ merge_. the total number of merges is denoted @xmath372 .",
    "the number of active moats during the @xmath146 merge is denoted @xmath373 , i.e. , @xmath374 .",
    "[ lemma : components ] for @xmath375 , the set @xmath376 computed by is an inclusion - minimal forest such that each @xmath377 is the cut of @xmath291 with a component of @xmath378 .",
    "we show the claim by induction on @xmath107 .",
    "we have that @xmath379 and @xmath380 , i.e. , the claim holds for @xmath381 . now assume that it holds for @xmath375 and consider index @xmath382 . the choice of @xmath383 guarantees that the joint moat @xmath384 is subset of the same connectivity component of @xmath385 . to see that no terminal from @xmath386 is connected to this component by @xmath387 , observe that a least - weight path from @xmath388 to @xmath389 contains no terminal from @xmath390 ( otherwise it is not of least weight or @xmath391 would not have been minimal ) . by the induction hypothesis",
    ", this implies that @xmath384 is a maximal subset of @xmath291 that is in the same component @xmath385 .",
    "it remains to show that @xmath387 is an inclusion - minimal forest with this property .",
    "since @xmath383 closes no cycles , it follows from the induction hypothesis that @xmath387 is a forest . from this and the inclusion - minimality of @xmath376",
    "it follows that deleting any edge from @xmath376 will disconnect a pair of terminals in the same moat .",
    "similarly , removing an edge from @xmath383 will disconnect the new moat @xmath392 .",
    "[ lemma : feasible ] the output @xmath72 of is a feasible forest .    by and the fact that the algorithm terminates once all moats are inactive , it is sufficient to show that an inactive moat contains only complete input components .    note that if the algorithm changes component identifiers , it does so by changing them for all moats @xmath393 with @xmath394 into some @xmath395 . hence all terminals @xmath109 which initially shared the same value @xmath396 are always in moats with identical component identifiers . since initially for each @xmath86 there are at least two distinct terminals @xmath181 with @xmath397 , for each @xmath84 initially there are at least two moats @xmath398 with @xmath399 .",
    "a merge between moats @xmath400 assigns component identifier @xmath401 to all moats with identifier @xmath401 or @xmath402 .",
    "the merged moat ( which is a connectivity component of @xmath403 ) becomes inactive if and only if it is the only remaining moat with label @xmath401 .",
    "the statement of the lemma follows .",
    "[ lemma : cost ] for any feasible output @xmath72 , satisfies that @xmath404    we show the statement by induction on @xmath372 .",
    "the statement is trivial for @xmath405 ( i.e. , no input components ) , so suppose it holds for @xmath406 and consider @xmath407 .",
    "we split up the weight function @xmath408 into @xmath409 so that @xmath410 and define a modified instance to which we can apply the induction hypothesis , proving that @xmath411 .    for each @xmath184 , define @xmath412 to be @xmath408 within @xmath413 and @xmath102 outside ( boundary edges have the appropriate fraction of their weight ) and @xmath414 .",
    "consider the edge set @xmath415 of a connectivity component @xmath416 induced by @xmath72 .",
    "we claim that if it contains @xmath417 nodes , it must hold that @xmath418 . to see this , note that the choice of @xmath419 guarantees that the @xmath420 are disjoint for all @xmath109 .",
    "moreover , by definition , any path connecting @xmath109 to a node outside @xmath420 must contain edges of weight at least @xmath419 within @xmath420 . the claim follows .",
    "summing over all connectivity components @xmath416 induced by @xmath72 ( which satisfy @xmath421 since by the problem definition each terminal must be connected to at least one other terminal ) , we infer that @xmath422 .    recall that @xmath379 .",
    "we take the following steps :    the algorithm replaces the moats @xmath423 and @xmath424 by the joint moat @xmath425 . for the purpose of our induction",
    ", we simply interpret this as setting @xmath426 if the resulting moat is active .",
    "if the merge connected the only two terminals @xmath427 and @xmath428 sharing the same component identifier , the respective moat becomes inactive . in this case",
    ", we also remove @xmath427 from @xmath291 , i.e. , @xmath429 .",
    "the algorithm assigns to all moats @xmath398 with @xmath430 the component identifier @xmath431 , i.e. , @xmath432 .",
    "analogously , we set @xmath433 for all @xmath434 and @xmath435 for @xmath436 .",
    "note that the previous steps guarantee that for each terminal @xmath437 , there is a terminal @xmath438 so that @xmath439 .",
    "the new instance of the problem is now given by the graph @xmath440 , the terminal set @xmath441 , and the terminal component function @xmath442 .",
    "consider an execution of on the new instance .",
    "we make the following observations :    for each @xmath109 and any radius @xmath56 , it holds that @xmath443 .    since @xmath444 ( as their distance in @xmath445 is @xmath102 ) , deleting @xmath428 from the set of terminals has the same effect as joining them into one moat .",
    "hence , if the merged moat @xmath425 remains active and thus @xmath427 is part of the set of terminals of the new instance , we get a one - to - one correspondence between merges of the two instances , i.e. , it holds that @xmath446 and @xmath447 for all @xmath448 ( where @xmath449 indicates values for the new instance ) .    by the induction hypothesis",
    ", this implies that @xmath450    if @xmath425 became inactive , but never participates in a merge , the same arguments apply .    hence , suppose that @xmath451 participates in a merge in step @xmath452 . for all indices",
    "@xmath453 , the above correspondence holds .",
    "moreover , since @xmath425 is inactive , ( i ) the moat @xmath454 with which it is merged must satisfy that @xmath455 and ( ii ) we have that @xmath456 , i.e. , the resulting moat is active ( as @xmath457 for any @xmath458 would contradict the fact that @xmath425 is inactive ) .",
    "thus , the merge does not affect the number of active moats , i.e. , @xmath459 .",
    "furthermore , it holds that @xmath460 , since @xmath425 has been active only during merge @xmath461 .",
    "we conclude that , for any @xmath56 , @xmath462 as the moats of size @xmath419 around @xmath427 and @xmath428 at the end of the @xmath146 merge exactly compensate for the fact that the edges inside the respective weighted balls in @xmath42 have no weight in @xmath445 . by induction on @xmath463 , it follows that , for any @xmath56 , @xmath464 and we can map the following merges of the two runs onto each other , i.e. , @xmath465 and , for @xmath466 , @xmath467 as well as @xmath468 . in particular , @xmath469 and the induction hypothesis yields that @xmath470 hence , in both cases @xmath471 , and the proof is complete .    by , the output @xmath72 of the algorithm is a feasible forest . with each merge",
    ", the algorithm adds the edges of a path of cost @xmath472 to @xmath72 .",
    "hence @xmath473    we construct @xmath445 and @xmath474 from @xmath475 by contracting edges in @xmath476 for all @xmath109 .",
    "if edges are `` partially contracted '' since they are only fractionally part of @xmath476 for some @xmath109 , their weight simply is reduced accordingly ; note that since @xmath72 is a forest , no edges are `` merged '' , i.e. , the resulting weights are well - defined . by",
    ", this process identifies for each moat @xmath477 its terminals .",
    "note that the edges from @xmath478 are completely contained in these balls .",
    "we interpret the set of active moats @xmath479 ( which after contraction are singletons ) as the set of terminals in @xmath445 .",
    "since @xmath72 is minimal w.r.t .  satisfying all constraints , so is @xmath474 ( where in @xmath445 two terminals need to be connected if the corresponding moats contain terminals that need to be connected ) . as",
    "only active moats contain terminals with unsatisfied constraints ( cf .  )",
    ", @xmath474 is the union of at most @xmath480 shortest paths between terminal pairs from @xmath441 that contain no other terminals .",
    "now consider the balls @xmath481 around nodes @xmath437 . by the choice of @xmath482",
    ", they are disjoint . for each such ball @xmath481 , by definition",
    "any least - weight path has edges of weight at most @xmath482 within the ball .",
    "we claim that any path in @xmath474 that connects nodes @xmath483 , but contains no third node @xmath484 , does not pass through @xmath485 for any @xmath486 .",
    "otherwise , consider the subpath from @xmath50 to a node in @xmath485 for some @xmath484 and concatenate a shortest path from its endpoint to @xmath141 .",
    "the result is a path from @xmath50 to @xmath141 that smaller weight than the original path from @xmath50 to @xmath51 .",
    "symmetrically , there is a path shorter than the one from @xmath50 to @xmath51 connecting @xmath51 and @xmath141 .",
    "however , together with the fact that the algorithm connects moats incrementally using least - weight paths of ascending weight implies that the pairs @xmath487 and @xmath59 must end up in the same moat _ before _ the path connecting @xmath50 and @xmath51 is added . by transitivity of connectivity",
    "this necessitates that @xmath50 and @xmath51 are in the same moat when a path connecting them is added , a contradiction .",
    "we conclude that indeed each of the considered paths passes through the balls around its endpoints only .",
    "overall , we obtain that in the above double summation , for each index @xmath107 , there are at most @xmath488 summands of @xmath482 : @xmath30 for each of the at most @xmath489 paths connecting nodes in @xmath441 considered in the previous paragraph ( note that the contraction did not change weights of edges covered by these summands ) .",
    "we conclude that @xmath490 by , this is at most twice the cost of any feasible solution .",
    "in particular , the cost of @xmath72 is smaller than twice that of an optimal solution .",
    "@xmath367 // moats partition @xmath291 ; for @xmath109 , let @xmath368 s.t .",
    "@xmath369 + @xmath370 // set of selected edges + @xmath371 + @xmath491 + // may have selected useless paths    [ coro : cost_approx ] for any solution @xmath72 , satisfies that @xmath492 where @xmath372 is the final iteration of the while - loop of the algorithm .",
    "denote by @xmath493 the number of unsatisfied moats in the @xmath146 iteration of the while - loop of , i.e. , the moats which can terminals that need to be connected to terminals in different moats .",
    "analogously to , we have that @xmath494 now consider a satisfied moat @xmath495 that is formed in iteration @xmath496 out of two unsatisfied moats ; we call such a moat bad . denote by @xmath497 the first iteration in which a moat @xmath498 is unsatisfied or inactive , whichever happens earlier . since the minimal edge weight is @xmath461 and @xmath499",
    "is increased by factor @xmath103 whenever the algorithm checks whether to inactivate moats , it holds that @xmath500 . as an unsatisfied moat",
    "can only be created by merging an unsatisfied moat ( with a satisfied or unsatisfied moat ) , there is a sequence of unsatisfied moats @xmath501 such that @xmath502 .",
    "we observe that if we pick a different moat @xmath503 and merge @xmath504 as above and apply the same construction , the resulting sequence @xmath505 must be disjoint from the sequence @xmath506 , since for each @xmath507 , the set of moats @xmath508 forms a partition of @xmath291 and the sequences contain no unsatisfied moats .",
    "we conclude that @xmath509    analogous to , except that the final bound on the approximation ratio follows from .",
    "clearly , the total number of times moats become inactive is at most @xmath5 , because every input component becomes completely contained in a moat exactly once throughout the execution .",
    "when an inactive moat merges , either all its terminals become active again or a new inactive moat is formed .",
    "hence , the total number of merges for which the activity status of some terminals change is at most @xmath115 .    to compute the voronoi decomposition in phase @xmath112",
    ", we use the single - source bellman - ford algorithm , where active moats are sources . all nodes in active moats",
    "are initialized with distance @xmath102 , and the edge weights are given by the reduced weight function @xmath510 ( which is known locally , because the moat size is locally known ) .",
    "messages are tagged by the identifier of the closest source w.r.t .",
    "@xmath510 ( the `` old '' trees are not touched , but simply extended ) . in @xmath139 rounds ,",
    "the bellman - ford algorithm terminates , and the result is that the shortest paths trees are extended to include all nodes in the respective voronoi regions @xmath132 that are not in @xmath130 for a terminal @xmath109 with @xmath511 , and each node knows its distance from the closest moat according to @xmath119 , i.e. , @xmath138 .",
    "finally , observe that nodes in @xmath130 for some @xmath109 with @xmath512 simply can use the information from the previous phase @xmath513 .",
    "[ lemma : decomp ] for each @xmath514 , it holds that @xmath515 .",
    "we prove the statement by induction on @xmath112 ; it trivially holds for @xmath516 , so consider the induction step from @xmath513 to @xmath112 .",
    "for any node ( or part of an edge ) in @xmath517 , the statement trivially holds by the induction hypothesis . hence , suppose a node ( or part of an edge ) is outside @xmath518 and consider the least - weight path @xmath147 that leads to @xmath519 ( for simplicity , suppose it contains no fractional edges ; the general case follows by subdividing edges into lines ) .",
    "suppose @xmath109 is the terminal in whose region @xmath130 the path ends .",
    "then , by the definition of reduced weights and @xmath123 , the path is contained in @xmath520 .",
    "hence , if @xmath521 , i.e. , the node ( or part of an edge ) is contained in @xmath142 , it must be in @xmath522 .",
    "the choice of @xmath50 implies that @xmath523 is equivalent to @xmath524 .",
    "because the node ( or part of an edge ) is outside @xmath525 , this is equivalent to the node ( or part of an edge ) being in @xmath526 .",
    "we conclude that @xmath527 , i.e. , the induction step succeeds .    since @xmath147 is a least - weight path , @xmath528 . by the definition of @xmath482 , hence @xmath529 . by , @xmath530 .",
    "thus , any path @xmath531 between to terminals that enters the uncovered region in phase @xmath532 must have weight @xmath533 ; in particular , @xmath147 can not enter the uncovered region .",
    "hence , assume for contradiction that @xmath147 enters @xmath534 for some @xmath535 .",
    "denote by @xmath536 a minimal prefix of @xmath147 ending at node @xmath537 for some @xmath538 .",
    "we make a case distinction , where the first case is that @xmath539 .",
    "consider the concatenation @xmath540 of the suffix of @xmath147 starting at @xmath155 to a least - weight path from @xmath141 to @xmath155 . by the definition of regions ,",
    "we have that @xmath541 by assumption @xmath141 and @xmath144 are in the same moat after merge @xmath496 , which must have been active . by the definition of merge phases ,",
    "@xmath141 and @xmath144 thus were both in active moats during all merges @xmath542 .",
    "this entails that their @xmath543 variables have been increased by the same value in each of these merges , yielding that @xmath544 as @xmath147 is a least - weight path from @xmath144 to @xmath145 , we conclude that @xmath545 this contradicts the minimality of @xmath482 , since @xmath141 is in an active moat in merge @xmath107 .",
    "hence it must hold @xmath546 , which is the second case .",
    "consider the path @xmath547 which is the concatenation of a least - weight path between @xmath155 and @xmath141 to @xmath536 .",
    "similarly to the first case , we have that @xmath548 if @xmath549 is active , @xmath141 is in active moats during merges @xmath550 , and similarly to the first case we can infer that @xmath551 the same applies if @xmath552 . again",
    "this contradicts the minimality of @xmath482 , as @xmath553 is active .",
    "it remains to consider the possibility that @xmath554 and @xmath555 .",
    "symmetrically to the first case , we can exclude that @xmath556 . since @xmath141 is in inactive moats during phase @xmath532",
    ", it holds that @xmath557 . by definition of @xmath540 and @xmath547",
    ", we thus have that @xmath558 as @xmath559 , this yields @xmath560 by the pidgeon hole principle , we obtain that @xmath561 or that @xmath562 as both @xmath563 and @xmath564 , this contradicts the minimality of @xmath482 .",
    "we conclude that all cases lead to contradiction and therefore the claim of the lemma is true .",
    "to specify the execution of , the following symmetry breaking rule is introduced : among all feasible combinations of choices for @xmath144 and @xmath145 in , and paths @xmath147 in , the algorithm selects the path @xmath565 such that @xmath566 is minimal w.r.t .  the order used in point ( iii ) of .    for the respective execution",
    ", we show the claim by induction on the merges @xmath107 .",
    "we anchor the induction at @xmath381 , for which @xmath380 , which equals the union of edges in the paths associated with @xmath567 . hence , consider merge @xmath568 , assuming that the claim holds for the first @xmath496 merges / candidate merges in @xmath170 .",
    "shows that the least - weight path @xmath565 from @xmath144 to @xmath145 selected by in merge @xmath107 satisfies that @xmath569 .",
    "since @xmath570 and @xmath571 , @xmath117 induces candidate merge @xmath572 .",
    "we claim that this candidate merge is the next element of @xmath170 ( according to the order ) .",
    "assuming otherwise for contradiction , the symmetry breaking rules specified above imply that there is a candidate merge @xmath573 which ( i ) satisfies that @xmath574 ( lexicographically ) , ( ii ) closes no cycle with the first @xmath496 selected merges , and ( iii ) satisfies that @xmath575 . by property ( ii ) and the induction hypothesis , @xmath576 . if @xmath577 , the candidate merge must have been selected as element @xmath578 into @xmath170 , contradicting the fact that no w.r.t .",
    "@xmath168 duplicate edges are selected into @xmath170 .",
    "therefore , by ( i ) , @xmath579 and @xmath580 . by the definition of regions",
    ", this implies that @xmath581 .",
    "it follows that @xmath50 and @xmath51 must satisfy that @xmath582 , since otherwise would merge these moats instead in merge @xmath107 .",
    "however , the induction hypothesis and the facts that @xmath170 closes no cycles and contains no duplicate edges entail that @xmath583 , a contradiction ; the claim follows .",
    "because the path associated with candidate merge @xmath572 is @xmath565 , the induction hypothesis yields that the edge set of the union of paths associated with the first @xmath107 elements of @xmath170 is a superset of @xmath376 . since @xmath584 is contained in the shortest - path - trees at @xmath144 and @xmath145 , the respective edges close no cycles with the cut of @xmath478 with the trees rooted at @xmath144 and @xmath145 , respectively . since @xmath585",
    ", @xmath117 does not close a cycle in @xmath376 either .",
    "we conclude that adds all edges in @xmath565 to @xmath478 when @xmath565 does not close a cycle with @xmath478 , implying that constructing @xmath376 .",
    "hence , the the edge set of the union of paths associated with the first @xmath107 elements of @xmath170 equals @xmath376 , the induction step succeeds , and the proof is complete .",
    "we use the edge elimination procedure introduced for mst @xcite , which works as follows .",
    "we use an ( unweighted ) bfs tree rooted at some node @xmath586 , which can be constructed in @xmath236 rounds . for round @xmath587 ,",
    "let @xmath588 denote the set of candidate merges node @xmath589 holds at the end of round @xmath58 , where @xmath590 .",
    "in each round each node executes the following convergecast procedure .",
    "@xmath591 is scanned in ascending weight order , and a merge that closes a cycle in @xmath168 with the union of @xmath592 and previous merges is deleted .",
    "( this is possible because the merges are tagged by the connectivity components of the terminals they join in @xmath177 . )",
    "the least - weight unannounced merge in @xmath593 is announced by @xmath141 to its parent ( @xmath594 skips this step ) .",
    "@xmath595 is assigned the union of @xmath593 with all merges received from children .",
    "once all sets stabilize ( which can be detected at an overhead of @xmath236 rounds ) , the set @xmath596 equals @xmath597 .",
    "perfect pipelining is achieved , leading to the stated running time bound .",
    "set @xmath598 .",
    "each node @xmath133 locally computes the connectivity components of @xmath177 and tags the elements of @xmath175 accordingly .",
    "we apply the same procedure as for , except that we need to detect termination differently , as we would like to stop the routine once the root knows @xmath189 .",
    "the pipelining guarantees that after @xmath599 rounds of the routine , the first @xmath107 elements of the ascending list of merges ( whose sublist up to element @xmath191 equals @xmath189 ) are known to the root .",
    "since the root knows @xmath592 and , for each @xmath109 ,",
    "@xmath187 , it can locally compute the variables @xmath136 , @xmath55 , and will detect in round @xmath600 that some terminal changes its activity status .",
    "this enables to determine when to terminate the collection routine and which elements of @xmath601 constitute @xmath189 .",
    "we put the pieces of our analysis together to bound the time complexity of our algorithm .",
    "[ lemma:2_time ] the above algorithm can be implemented such that it runs in @xmath602 rounds .",
    "clearly , step 1 can be executed in @xmath236 rounds .",
    "step 2 consists of local computations only . by",
    ", we have that @xmath603 , since at the end of merge phase @xmath604 , no active terminals remain .",
    "we conclude that the loop in step 3 of the above algorithm is executed for @xmath604 iterations . by ,",
    "@xmath605 .",
    "we claim that iteration @xmath606 of the loop can be executed in @xmath607 rounds , which we show by induction on @xmath112 .",
    "the induction hypothesis is that , after @xmath513 iterations of the loop , the prerequisites of are satisfied for index @xmath513 , @xmath608 for all @xmath109 , and the value of the variable @xmath136 is correct for each @xmath109 .",
    "this is trivially satisfied for @xmath609 by initialization , hence suppose the hypothesis holds for @xmath610 . under this assumption , shows that step 3a can be executed in @xmath139 rounds , in the sense that the trees become locally known as stated in the lemma .",
    "clearly , this implies that step 3b can be executed in one round , by each node @xmath141 sending @xmath611 to each neighbor .",
    "consider @xmath612 .",
    "we have that @xmath613 . for each entry , we have that @xmath614 and @xmath615 .",
    "thus , if @xmath616 , the hypothesis that @xmath617 implies that @xmath618 and @xmath619 .",
    "hence , @xmath188 and an entry @xmath612 is a candidate merge if and only if @xmath616 .",
    "as @xmath613 , it holds that that @xmath620 is identical for all @xmath621 .",
    "we have that @xmath622 similarly , if @xmath623 , @xmath624 because @xmath625 .",
    "it follows that @xmath626 on the other hand , if @xmath627 , the statement @xmath628 is trivially satisfied , because @xmath629 spans @xmath630 .",
    "we conclude that @xmath631 is a candidate merge if and only if @xmath632 .",
    "therefore , each false candidate in @xmath633 is of larger weight than all candidate merges in @xmath172 .",
    "we conclude that the prerequisites of are satisfied for merge phase @xmath112 , yielding that step 3c can be executed in @xmath190 rounds .",
    "step 3d requires local computation only .",
    "we observe that :    for each @xmath109 , @xmath634 , since we established that @xmath635 for each @xmath636 with @xmath575 .    by , the local information available to the nodes from step 3a and the @xmath637 variables permit to determine , for each @xmath133 , whether @xmath638 and the fraction of its incident edges inside @xmath639 .    by , @xmath640 , i.e. , the moats at the beginning of merge phase @xmath641",
    "the computed variables @xmath642 , @xmath109 , are thus correct .",
    "this establishes the induction hypothesis for index @xmath641 .",
    "the total time complexity of the @xmath128 iteration of the loop in step 3 is @xmath643 , yielding a total of @xmath644 rounds to complete step 3 .",
    "step 4 requires local computations only . for step 5 , for an edge @xmath645 inducing a candidate merge from @xmath646 , @xmath155 and @xmath157 send a token to their respective parents .",
    "each node receiving a token for the first time forwards it , other tokens will be ignored .",
    "edge @xmath645 and all edges traversed by a token are selected into @xmath72 . since the goal is to select for each edge @xmath645 the edge and the paths from @xmath155 and @xmath157 to the roots in their respective trees , this rule ensures that @xmath72 is computed correctly . because the shortest - path - trees have depth at most @xmath3 and there is no congestion , this implementation of step 4 completes in @xmath139 rounds ( where termination is detected in @xmath647 rounds over the bfs tree ) . since step 6 requires no communication , summing up the time complexities for steps 1 to 6 yields a total running time bound of @xmath648 .    by , the above algorithm can be executed within the stated running time bound . by , the edge set @xmath474 of the union of paths associated with @xmath170 equals the set @xmath171 computed by some execution of .",
    "hence , if we can show that the set @xmath72 returned in step 6 of the above algorithm is the minimal subset of @xmath474 that solves the instance , the theorem readily follows from .",
    "recall that because never closes a cycle , @xmath649 is a forest , and so is @xmath72 . by the minimality of @xmath646 ,",
    "any two terminals connected by @xmath646 ( viewed as forest in @xmath168 ) must be connected by any subforest of @xmath474 that is a solution . for any edge @xmath650",
    ", there is an element of @xmath651 such that @xmath645 is on the associated path connecting @xmath50 and @xmath51 .",
    "deleting @xmath645 from @xmath72 will disconnect @xmath50 and @xmath51 ( because @xmath72 is a forest ) , implying that the resulting edge set does not solve the instance of dsf - ic .",
    "we conclude that @xmath72 is indeed the edge set returned by , and therefore optimal up to factor @xmath30 .",
    "construct a directed bfs tree , rooted at @xmath594 . for each @xmath109 , broadcast @xmath293 to all nodes ( via the bfs tree ) .",
    "set @xmath652 ( index of the merge phase ) and @xmath653 . for each @xmath109 , set @xmath654 , @xmath655 , and @xmath656 .    while @xmath657 with @xmath575 :    compute the collection of shortest - path - trees spanning for each @xmath109 with @xmath658 @xmath124 and for each @xmath109 with @xmath511 @xmath659 .    for each @xmath133 , denote by @xmath611 the root of the tree @xmath660 it participates in .",
    "for each @xmath133 with @xmath613 , locally construct @xmath175 as follows . for each neighbor @xmath661 of @xmath141 so that @xmath662 and @xmath663 , @xmath141 adds @xmath664 to @xmath175 . for all other nodes @xmath141 , @xmath665 .",
    "determine @xmath189 and make it known to all nodes .",
    "suppose the maximal merge in @xmath189 is @xmath666 .",
    "each @xmath133 locally computes :    for @xmath109 with @xmath575 , @xmath667 ;    for @xmath109 with @xmath512 , @xmath668 ;    whether @xmath638 or not , and the fraction of its incident edges inside @xmath639 ;    the set @xmath669 of connectivity components of the forest on @xmath291 induced by @xmath670 ( for @xmath109 , denote by @xmath671 the moat so that @xmath672 ) ;    for @xmath109 with @xmath673 , @xmath674 ;    for @xmath109 with @xmath675 , @xmath676 .",
    "@xmath677 .    set @xmath678 .",
    "each node locally computes the minimal subset @xmath679 such that the induced forest on @xmath291 connects for each @xmath86 all terminals @xmath109 with @xmath680 .",
    "@xmath681 . for",
    "each element of @xmath646 , suppose @xmath150 is the inducing edge and @xmath154 the associated path .",
    "add @xmath117 to @xmath72 and also all edges on the paths from @xmath155 to @xmath51 and @xmath157 to @xmath51 that are given by the shortest - path - trees spanning @xmath130 and @xmath682 , respectively .",
    "return @xmath72 .",
    "[ [ specification - of - the - algorithm . ] ] specification of the algorithm .",
    "+ + + + + + + + + + + + + + + + + + + + + + + + + + + + + + +    construct a directed bfs tree , rooted at @xmath594 .",
    "set @xmath683 ( index of the merge phase ) , @xmath681 , and @xmath491 . at each @xmath109 , set @xmath654 , @xmath655 , @xmath656 , @xmath684 , and @xmath685 ( the leader of moat @xmath686 ) .    while @xmath687 :    while @xmath688 :    @xmath677 .",
    "compute the shortest - path - trees spanning for each @xmath109 with @xmath658 @xmath124 and for other terminals @xmath659 .    for each @xmath133 ,",
    "denote by @xmath611 the root of the tree @xmath660 it participates in .",
    "for each @xmath133 with @xmath613 , check whether there is a neighbor @xmath689 with @xmath627 . if so , set @xmath690 i.e. , @xmath691 is the least - weight candidate merge with an inactive terminal induced by an edge incident to @xmath141 . for all other nodes @xmath141 , @xmath692 .    over the bfs tree ,",
    "determine @xmath693 and make it known to all nodes . if there is no such candidate merge or @xmath694 , set @xmath695 .",
    "otherwise , @xmath696 .",
    "all terminals @xmath109 with @xmath575 set @xmath667 .",
    "other terminals set @xmath668 .",
    "each terminal @xmath109 broadcasts @xmath697 over its current shortest - path - tree .",
    "each node @xmath133 determines whether it is in @xmath698 and the fraction of its incident edges in @xmath698 .",
    "if @xmath699 ( i.e. , merge phase @xmath112 does not end the growth phase ) , terminal @xmath700 ( i.e. , the one with @xmath701 ) broadcasts @xmath702 over the bfs tree .",
    "all terminals @xmath50 with @xmath703 set @xmath674 .",
    "each terminal @xmath109 broadcasts @xmath642 over its current shortest - path - tree .    for @xmath704 iterations :    denote by @xmath705 the set of current moats .",
    "each small moat @xmath706 finds the smallest candidate merge @xmath707 satisfying that @xmath708 , @xmath709 , and @xmath710 ( if there is any ) .",
    "denote the set of such candidate merges by @xmath415 .",
    "interpret @xmath415 as the edge set of a simple graph on the node set @xmath711 , by reading each candidate merge @xmath712 as an edge @xmath713 .",
    "ensures that there can be only one edge between any pair of moats . ]",
    "define @xmath714 .",
    "determine an inclusion - maximal matching @xmath715 .",
    "each ( small ) moat that is not incident to an edge in @xmath716 , but added an edge to @xmath415 , adds the respective edge to @xmath716 again , resulting in a set of candidate merges @xmath717 .    for each @xmath718 ,",
    "add the edges of @xmath154 to @xmath72 .",
    "denote by @xmath719 the set of connectivity components of @xmath720 . for each @xmath109 ,",
    "set @xmath721 , where @xmath722 is the component such that @xmath723 .",
    "each terminal @xmath109 learns the identifier of @xmath724 , the terminal with largest identifier among all terminals @xmath51 with @xmath725 .",
    "each terminal @xmath109 learns whether @xmath686 is small .    for each small @xmath686 ,",
    "make the complete set @xmath686 known to all its terminals .    for each @xmath109 , broadcast @xmath724 to all nodes in @xmath124 ( over its shortest - path - tree ) .    for each @xmath133 , locally construct @xmath175 as follows .",
    "starting from @xmath665 , for each @xmath726 with @xmath727 and each neighbor @xmath661 of @xmath141 so that @xmath662 and @xmath728 , @xmath141 adds @xmath729 to @xmath175 .",
    "each candidate merge is tagged by the identifiers of the moat leaders @xmath730 and @xmath731 .",
    "denote by @xmath592 the set of candidate merges whose associated paths edges have been added to @xmath72 so far .",
    "determine @xmath732 .    for each @xmath718 , add the edges of @xmath154 to @xmath72 .",
    "denote by @xmath719 the set of connectivity components of @xmath720 . for each @xmath109 ,",
    "set @xmath721 , where @xmath722 is the component such that @xmath723 .",
    "each terminal @xmath109 learns the identifier of @xmath724 , the terminal with largest identifier among all terminals @xmath51 with @xmath725 .",
    "each terminal @xmath109 learns whether @xmath686 is small .    for each small @xmath686 ,",
    "make the complete set @xmath686 known to all its terminals .    for each @xmath109 ,",
    "determine whether there are @xmath733 and @xmath734 so that @xmath735 .",
    "if this is the case , set @xmath674 , otherwise set @xmath676 .",
    "return @xmath72 .",
    "[ lemma : number_merge_growth_phase ] for @xmath736 and any execution of , there are at most @xmath737 growth phases and @xmath738 .",
    "we claim that @xmath739 . assuming the contrary",
    ", there must be some active moat @xmath740 . since the moat is active",
    ", there are terminals @xmath741 and @xmath742 so that @xmath397 .",
    "clearly , these terminals were not in the same moats after any merge @xmath743 and therefore remain active throughout the entire execution of the algorithm .",
    "it follows that @xmath744 . however , by definition @xmath745 , implying that @xmath746 because @xmath747 , this yields the contradiction @xmath748 we conclude that indeed @xmath739 . since @xmath499 is initialized to @xmath461 and grows by factor @xmath103 with each growth phase , we obtain that the number of growth phases is bounded by @xmath749 where the last step exploits that for @xmath736 , @xmath750 .",
    "the bound on the number of merge phases follows from this bound and the definition of the @xmath751 , since there are at most @xmath5 merges which may result in inactive moats ( i.e. , input components become satisfied ) , each of which can be merged only once .",
    "[ lemma : large_moats ] at any stage of the above algorithm , the number of large moats is bounded by @xmath195 and the connectivity component of @xmath720 of a small moat has a hop diameter of at most @xmath195 .",
    "the bound on the hop diameter of small moats components trivially follows from the fact that they contain at most @xmath195 nodes .",
    "suppose @xmath752 .",
    "we claim that the connectivity component of a moat with @xmath753 terminals contains at most @xmath754 nodes .",
    "this holds trivially for the initial moats .",
    "now suppose moats @xmath716 and @xmath503 are merged .",
    "the merging path has at most @xmath3 hops , implying that at most @xmath755 nodes are added .",
    "hence the new moat has at most @xmath756 nodes .",
    "the claim follows .",
    "this entails that the total number of nodes in moats components is bounded by @xmath757 .",
    "we conclude that there are at most @xmath758 nodes in moats connectivity components w.r.t .",
    "@xmath72 , and therefore at most @xmath195 large moats .",
    "[ lemma : decomp_correct ] suppose that after @xmath759 growth phases , the variables @xmath760 , @xmath761 , the local representations of @xmath124 , @xmath762 , and the trees spanning them , membership of edges in @xmath763 , and @xmath764 are identical to the corresponding values for an execution of .",
    "then in growth phase @xmath62 , step 3a of the algorithm correctly computes the terminal decompositions @xmath765 , as well as the variables @xmath634 and @xmath642 .",
    "it can be completed in @xmath210 rounds .",
    "we prove the claim by induction on the iterations @xmath765 of the loop in step 3a , anchored at @xmath766 .",
    "the hypothesis is that all respective values for index @xmath112 are correct , which holds for @xmath766 by assumption .",
    "for the induction step from @xmath513 to @xmath112 , observe that the hypothesis and yield that step 3aii can be performed in @xmath139 rounds .",
    "clearly , step 3aiii requires one round of communication only .",
    "if @xmath767 , suppose @xmath768 .",
    "if @xmath769 , we claim that @xmath770 is the candidate merge completing merge phase @xmath112",
    ". otherwise ( also if @xmath771 ) , @xmath772 and active moats grow by exactly @xmath773 during the merge phase . to see this ,",
    "recall that merge phase @xmath112 ends if ( i ) an active and an inactive moat merge or ( ii ) active moats have grown by @xmath773 .",
    "note that , by and the induction hypothesis , @xmath774 for any @xmath775 so that @xmath613 and @xmath627 .",
    "moreover , @xmath776 , as otherwise @xmath611 and @xmath777 would have been connected in an earlier merge phase and can not satisfy that @xmath778 .",
    "suppose ( i ) applies , i.e. , merges the moats of terminals @xmath779 and @xmath780 in step @xmath197 , and suppose it does so by the path @xmath781 induced by @xmath782 with @xmath783 and @xmath784 ( by , we know that such an edge exists ) . since the merge phase ends due to this merge and terminals can become inactive only at the end of a growth phase , it must hold that @xmath785 .",
    "it follows that @xmath786 , as any @xmath787 would imply that another pair of terminals from active and inactive moats would be merged earlier , ending the merge phase at an earlier point .",
    "the same argument yields that in case of ( ii ) , no @xmath788 can exist with @xmath789 , as otherwise an active and inactive terminal would get merged before the growth phase ends .",
    "we conclude that the above claim holds .",
    "it follows that in step 3aiv , which can be completed in @xmath790 rounds , the correct variables @xmath791 , @xmath109 , and therefore also regions @xmath124 are determined .",
    "if @xmath772 , the induction halts . otherwise , we know that the merge @xmath197 connects an active and inactive moat . because the input labels of terminals in the inactive moat must be disjoint from those of other terminals ( as by the hypothesis the variables @xmath792 have correct values ) , the resulting moat must consist of active terminals ; no terminals outside the new moat change their activity status . by the prerequisites of the lemma",
    ", the terminals in the inactive moat @xmath716 recognize their membership by the identifier of their leader @xmath793 .",
    "since any merge with an inactive moat makes its terminals active and no terminals can become inactive except for the end of a growth phase , we conclude that step 3av results in the correct values of the variables @xmath642 , @xmath109 .",
    "step 3av requires @xmath790 rounds , resulting in a total complexity of @xmath139 of the iteration of the while - loop in step 3a .",
    "the above establishes that , unless @xmath772 , the induction hypothesis is established for index @xmath641 .",
    "hence , the induction succeeds . we conclude that there are @xmath794 iterations of the loop in step 3a , for",
    "each of which we observed that it can be implemented with running time @xmath139 .",
    "[ lemma : growth_3b ] suppose that the prerequisites of are satisfied for growth phase @xmath62 .",
    "then , each candidate merge selected by the above algorithm in step 3b of growth phase @xmath62 is in @xmath170 for a ( specific , for all applications of the lemma to an instance fixed ) execution of .",
    "the step can be completed in @xmath795 rounds .    as in",
    ", we consider the execution of employing the same tie breaking mechanism as we use to order candidate merges .",
    "we prove the claim by induction on the iterations of the loop in step 3b .",
    "the hypothesis is that all merges performed by the algorithm up to the beginning of the current loop iteration correspond indeed to candidate merges from @xmath170 and the moats @xmath711 defined in step 3bi implicitly given by the variable @xmath724 known to each @xmath109 are the moats induced by the union of edges of associated paths .",
    "the induction is anchored by the assumptions of the lemma ; hence consider some iteration of the loop .",
    "suppose for a moat @xmath706 , the smallest candidate merge is @xmath180 . by , the nodes in @xmath117 can detect the existence of the candidate merge by communicating over @xmath117 ; performing this concurrently for all nodes , this takes one round , since each edge induces one candidate merge only .",
    "since the moat is small , by , the moat s component in @xmath720 has diameter at most @xmath195 .",
    "hence , a spanning tree rooted at the leader can be constructed and used to determine the least - weight candidate merge as specified in step 2bi within @xmath796 rounds ( the additive @xmath3 accounts for the depth of the trees of the terminal decomposition ) .    in step 2bii ,",
    "only small moats @xmath706 need to participate in the computation .",
    "we interpret the subgraph of the graph specified in step 2bii induced by @xmath415 as a directed graph , where each small moat has one outgoing edge .",
    "we @xmath100-color the graph by simulating the cole - vishkin algorithm  @xcite on this graph , where moat leaders take the role of the nodes and communication is routed through the spanning trees of the moats .",
    "observe that since nodes need to receive messages only from their `` parent '' and send identical messages to their children , the congestion is constant .",
    "hence , each round of the cole - vishkin algorithm can be simulated in @xmath796 rounds in @xmath42 , the depth bound for the trees constructed in step 2bi .",
    "after @xmath797 rounds , a @xmath100-coloring is computed , which in @xmath100 additional simulated rounds can be used to determine a maximal matching .",
    "after another simulated round , each moat leader in a small moat knows its incident edges from @xmath415 .",
    "consequently , step 2biii requires another @xmath796 rounds .    concerning step 3biv ,",
    "observe that the construction of @xmath798 ensures for each connectivity component of @xmath799 , either all moats in the component are small and it consists of two stars connected by a matching edge , or it is a star centered at a large moat , whose leaves are all small moats .",
    "if the former applies , shows that step 3biv can be completed for small moats within @xmath796 rounds using the edges from @xmath72 in the respective component of @xmath720 only .",
    "moreover , in this time a spanning tree can be constructed and used to count the number of terminals or nodes , respectively , determining whether the new moat is small . for the case where a large moat is involved , the new leader will be the leader of the unique large moat in the respective connectivity component of @xmath720 . since this leader is already known to all terminals in the large moat , shows that its identifier can be distributed to all nodes in the `` attached '' small moats in @xmath796 rounds .",
    "trivially , the resulting moat is large .    with respect to step 3bv , we again apply , showing that for each small moat , in @xmath800 rounds , a spanning tree with edges from @xmath72 can be constructed that spans its component in @xmath720 .",
    "this tree is used to broadcast the terminal identifiers of its at most @xmath801 terminals to all constituent nodes within @xmath800 rounds .    to complete the induction step , it thus remains to show that @xmath802 and therefore indeed all edges selected into @xmath72 in step 3biii are also selected by the execution of that selects the same merges and the associated paths , and also that the computed moats are indeed the cuts of @xmath291 with the connectivity components of @xmath720 .",
    "observe that for a candidate merge added to @xmath415 by moat @xmath716 , any cycle it might close in @xmath168 must contain another candidate merge between terminals in @xmath716 and @xmath803 . since any candidate merge selected into @xmath415",
    "is minimal among _ all _ candidate merges for @xmath716 , it follows that it will never be filtered out .",
    "therefore , it must hold that @xmath804 . as we already observed earlier , @xmath799 is a forest at the end of step 3bii . since for each @xmath805 the associated path is contained in @xmath806 for some @xmath112 , it connects exactly the moats @xmath807 .",
    "we conclude that the new moats are exactly those computed in the iteration of the loop in step 3b .",
    "we conclude that the induction hypothesis for the next loop iteration is established , i.e. , the induction succeeds . since there are @xmath6 iterations , the total time complexity is @xmath795 .",
    "[ lemma : growth_phase ] suppose the prerequisites of are satisfied for a growth phase @xmath808",
    ". then the growth phase can be completed in @xmath211 rounds and the prerequisites of hold for index @xmath809 .    by",
    ", the regions @xmath810 , @xmath55 , have been determined in step 3a , within @xmath811 rounds .",
    "by , the step completes in @xmath812 rounds and determines for @xmath109 the variable @xmath724 in accordance with @xmath72 , where @xmath72 is the edge set of paths associated with a set @xmath813 .",
    "step 3c can thus be correctly executed in @xmath139 rounds , and step 3d , which requires local computations only , will determine sets @xmath175 , @xmath133 , so that @xmath814 . hence , the preconditions of are satisfied , permitting to perform step 3e in @xmath815 rounds .",
    "we claim that @xmath816 . to see this , observe that in each iteration of the loop in step 2b , each small moat that has an incident candidate merge will be merge with some other moat .",
    "hence , the minimal number of terminals ( if @xmath817 ) or nodes ( if @xmath818 ) in a moat that can still participate in a merge in the growth phase doubles in each iteration of the loop .",
    "it follows that after step 2b , any moat that can still participate in a merge in merge phase @xmath62 is large . by , there are at most @xmath195 large moats .",
    "since @xmath170 ( as edge set in @xmath168 ) contains neither cycles nor duplicate edges , the claim follows .",
    "in particular , step 3d completes within @xmath819 rounds .",
    "since @xmath798 becomes known to all nodes , step 3f can be performed in @xmath139 rounds . for step 3 g ,",
    "we collect for each candidate merge in @xmath798 the identifiers of the merged moats leaders over the bfs tree , in @xmath820 rounds .",
    "the new leaders then can be computed locally by all nodes , since @xmath798 is known by all nodes . for each new moat ,",
    "the number of terminals ( or nodes ) is then determined by pipelining the respective additions on the bfs tree and broadcasting the result to all nodes , again requiring @xmath821 rounds .",
    "this enables each node to determine whether its moat is small or large .",
    "step 3h is performed , for each small moat , within its connectivity component of @xmath720 .",
    "because states that the diameter of these components is at most @xmath800 and small moats contain at most @xmath195 terminals , this completes in @xmath800 rounds .    to perform step 3i",
    ", we identify all terminals in each moat with the moat leader and then apply the technique from . since an input component @xmath86 is subset of a moat if and only if there will be only one tuple @xmath822 with @xmath680 present ( possibly at several nodes ) , this will determine correctly which input components are satisfied , after @xmath823 rounds .",
    "a moat is active in growth phase @xmath809 if and only if there is a terminal whose input component is not subset of some moat . by , small moats have diameter at most @xmath195 w.r.t .",
    "@xmath720 , enabling to complete the step within another @xmath800 rounds for small moats . for large moats , we perform the respective convergecasts and broadcasts on the bfs tree , tagging the messages with the moat leader s identifier . because , by , there are at most @xmath800 large moats , the congestion at each node is bounded by @xmath800 and the step can be completed in @xmath820 rounds for large moats .",
    "summing up the time complexities of all steps , a total of @xmath824 rounds suffices to complete the growth phase .",
    "the variables @xmath825 , @xmath55 , have been determined in step 3i .",
    "the variables @xmath826 are , by , known by the end of step 3a of growth phase @xmath62 , alongside @xmath810 and the corresponding spanning trees , for @xmath827 .",
    "by , the moat leader variables reflected the moats corresponding to the respective set of selected edges @xmath72 after step 3b , which in turn matched a set @xmath828 ( since there were never any candidate merges for phases @xmath829 ) . by and",
    "steps 3e to 3 g , we conclude that @xmath72 is the edge set of the paths associated with @xmath830 , i.e. , @xmath831 for the considered execution of , and leader variables @xmath724 , @xmath109 , have the correct values for these moats . in summary ,",
    "all claims of the lemma hold and the proof concludes .    constructing a bfs tree requires @xmath236 rounds . and inductive application of shows that steps 2 , 3 , and 4 of the algorithm can be executed in @xmath832 rounds .",
    "moreover , the returned set @xmath72 equals the set @xmath833 computed by .",
    "therefore , it is a forest , and its minimal subforest solving the instance is , by , optimal up to factor @xmath213 .",
    "the following routine assumes that for an instance of dsf - ic , a forest @xmath72 on at most @xmath834 nodes solving the instance is given , where each node knows which of its incident edges are in @xmath72 . at the heart of the routine are steps 4 to 6 , which heavily exploit that @xmath72 is a tree to ensure optimal pipe - lining for the edge selection process",
    ".    set @xmath370 ( this will be the pruned edge set ) . construct an ( unweighted ) bfs tree on @xmath42 , rooted at @xmath594 and make the set of labels @xmath80 known to all nodes .    for each connectivity component of @xmath720 of diameter at most @xmath195 ,",
    "optimally solve the respective ( sub)instance of dsf - ic .",
    "add the respective edges to @xmath835 and delete these components from @xmath720 .",
    ", assume that all components of @xmath720 have diameter larger than @xmath195 in the following .    construct a partition of @xmath720 into clusters @xmath719 , so that ( i ) @xmath836 , ( ii ) for each @xmath837 , the depth of the minimal subtree of @xmath72 spanning @xmath121 is @xmath838 , and ( iii ) for each @xmath839 , the spanning subtree induced by @xmath72 is directed to a root @xmath840 ( in the sense that each node knows its parent and the identifier of @xmath841 ) .",
    "denote by @xmath842 the forest on @xmath719 resulting from contracting each @xmath837 in @xmath720 .",
    "make @xmath842 known to all nodes .",
    "each node @xmath133 initializes for each @xmath843 @xmath844 and for each @xmath837 @xmath845 .",
    "terminals @xmath109 set @xmath846 ( where @xmath121 is uniquely identified by the identifier of @xmath841 ) .",
    "perform the following on the bfs tree until no more messages are sent    each node @xmath133 sends a _ non - redundant _ node label @xmath847 for @xmath848 to its parent ( if there is one ) .",
    "a label is _ redundant _ if the following holds .",
    "start from variables @xmath849 and @xmath850 and simulate the operations below for all messages sent to the parent in previous rounds . if the label in question would not alter the state of the variables further , it is redundant .",
    "if @xmath851 receives `` @xmath847 '' , it sets @xmath852 .",
    "if there is some other @xmath853 with @xmath854 , it sets @xmath855 and @xmath856 for all edges @xmath117 and nodes @xmath857 on the path connecting @xmath121 and @xmath858",
    ". must have disjoint sets of labels , since @xmath72 solves the instance . since @xmath72 is a forest",
    ", there is thus always a unique such path . ]    whenever there is for any node @xmath133 an edge @xmath117 with @xmath859 , for each @xmath843 with @xmath860 set @xmath861 and for each @xmath837 with @xmath862 set @xmath863 .",
    "once this is done , the root @xmath594 of the bfs tree broadcasts the result ( using the same encoding ) .    for each edge in @xmath843 with @xmath864 , add @xmath117 to @xmath835 .    for each terminal @xmath109 ,",
    "set @xmath251 .",
    "nodes @xmath865 set @xmath252 . if node @xmath133 is the endpoint of an edge @xmath843 , @xmath141 sets @xmath866 .    for each tree spanning a cluster @xmath837 ,",
    "select for each @xmath86 the edges of the minimal subtree spanning all terminals @xmath867 with @xmath868 into @xmath835 .",
    "return @xmath835 .",
    "we start by analyzing the time complexity of the routine .",
    "the first lemma covers the selection procedure for trees of depth at most @xmath195 used in steps 2 and 10 .",
    "[ lemma : prune_2_10 ] steps 2 and 10 of the above routine can be completed in @xmath869 rounds .",
    "consider a tree of depth at most @xmath195 , where each node @xmath141 in the tree is given a set @xmath870 and the requirement is to mark all edges that are on a path connecting some nodes @xmath141 and @xmath661 in the tree with @xmath871 , communicating over tree edges only .",
    "this is the requirement of step 10 , and by setting @xmath872 for terminals @xmath141 and @xmath873 otherwise , we see that step 2 can be seen as a special case .",
    "we root the tree in @xmath800 rounds .",
    "consider a fixed label @xmath874 .",
    "each node @xmath141 with @xmath875 a message @xmath84 to its parent , which is forwarded to the root ; each node sends only one such message @xmath84 .",
    "all edges traversed by a message are tentatively marked . once this is complete , the root @xmath594 checks whether it received at least two messages @xmath84 or satisfies that @xmath876 .",
    "if this is not the case , it sends an `` unmark '' message to the child sending a @xmath84 message ( if there is one ) .",
    "the receiving child performs the same check w.r.t .",
    "its subtree , possible sending another `` unmark '' message , and so on .",
    "clearly , removing the edges traversed by an `` unmark '' message from the set of tentatively marked edges is the minimal set of edges connecting the nodes with @xmath875 .",
    "we perform this process concurrently for all @xmath86 ( tagging the unmark messages by the respective component label ) , using pipelining to avoid congestion .",
    "each of the two phases can be completed in @xmath869 rounds , since there are at most @xmath5 distinct labels and each node sends at most two messages per label .",
    "the next lemma discusses the growing of clusters .",
    "the employed technique is the same as for step 3b of the subroutine from , analyzed in detail in .",
    "[ lemma : prune_3 ] step 3 of the above routine can be completed in @xmath838 rounds .",
    "initialize the clusters to singletons .",
    "we consider a cluster _ small _ , if it contains fewer than @xmath195 nodes . otherwise it is _",
    "large_. for @xmath877 iterations , perform the following .",
    "each small cluster selects an arbitrary outgoing edge from @xmath72 ( this is feasible , since after step 2 each connectivity component contains at least @xmath195 nodes ) .",
    "denote the set of selected edges by @xmath415 .",
    "suppose @xmath878 is the subset of edges between small clusters .",
    "find a maximal matching @xmath879 .",
    "each small cluster without an incident edge from @xmath716 adds the previously selected edge to @xmath716 , resulting in set @xmath798 .",
    "merge clusters according to @xmath798 ( constructing rooted spanning trees ) .",
    "the new clusters select a leader and determine whether they are small or not .",
    "since for each small cluster in each iteration at least one edge is selected , the minimal number of nodes in a cluster grows by at least factor @xmath30 in each iteration , implying that no small clusters remain in the end .",
    "since there can be at most @xmath880 large clusters , the bound on @xmath881 holds . due to the construction of @xmath798 , in each iteration",
    "the longest path in the graph on the current clusters that is selected into @xmath798 has @xmath100 hops .",
    "moreover , at most one large cluster is present in each connectivity component of the subgraph induced by @xmath798 , implying that the maximal diameter of clusters remains in @xmath838 .    concerning the running time ,",
    "observe that the matching can be selected by simulating the cole - vishkin algorithm  @xcite on the cluster graph . due to the bound on the diameter of clusters",
    ", the routine can be completed in @xmath838 rounds .",
    "step 6 of our subroutine pipelines several related pieces of information , namely ( i ) the inter - cluster edges to select , ( ii ) input components `` responsible '' for this edge to be selected , and ( iii ) input components which can be identified , because the minimal subtrees of @xmath72 spanning them are not disjoint ( and any subforest of @xmath72 solving the instance connects the terminals in the respective different input components , too ) .    [ lemma : prune_6_7 ] steps 6 and 7 of the above routine can be completed in @xmath882 rounds .    for each @xmath86 , any non - redundant ( received ) message @xmath847 after the first implies that some edge receives a new label .",
    "initially , the number of different possible labels for edges is at most @xmath5 . whenever an already labeled edge receives an additional label ,",
    "the number of possible different edge labels is decreased by one .",
    "the number of times an unlabeled edge can become labeled is at most @xmath836 .",
    "we conclude that no node sends more than @xmath883 messages .",
    "denote by @xmath884 the number of non - redundant messages non - root node @xmath141 will send and by @xmath885 the depth of the subtree rooted at @xmath141 . we claim that after @xmath58 rounds , @xmath141 has sent @xmath886 non - redundant messages , which we show by induction on @xmath885 .",
    "the statement is trivial for @xmath887 , i.e. , leaves . for @xmath888 , by the induction hypothesis at the end of round @xmath889 , either @xmath141 has received all non - redundant messages from its children or at least one child sent at least @xmath890 non - redundant messages .",
    "hence , if @xmath141 has not yet sent @xmath886 non - redundant messages , it will send another message in round @xmath58 . by the induction hypothesis ,",
    "it thus has sent @xmath886 messages by the end of round @xmath58 , and the induction step succeeds .    we conclude that step 6 completes within @xmath891 rounds . by broadcasting @xmath869 non - redundant messages over the bfs tree , it can make the result known to all nodes , also in @xmath891 rounds .",
    "it remains to show that the algorithm chooses the correct set of inter - cluster edges and the demands derived from the respective selection process in step 9 ensures that the intra - cluster edges selected into @xmath835 in step 10 complete the minimal solution .",
    "[ lemma : prune_correct ] the set @xmath892 returned is minimal with the property that it solves the instance of dsf - icsolved by @xmath72 .",
    "clearly , step 2 does not affect the correctness of the solution .",
    "hence , w.l.o.g .",
    "assume that @xmath720 contains only components of diameter larger than @xmath195 , i.e. , no deletions happen in step 2 .",
    "observe that the minimal subforest solving the instance is the union over all @xmath86 of the minimal trees @xmath893 spanning all terminals @xmath109 with @xmath680 .",
    "note that by the initialization and due to the rules of step 6 , @xmath894 will be labeled by @xmath84 , i.e. , @xmath895 . on the other hand , if @xmath896 , the set of input labels on each side of the edge must be disjoint .",
    "since step 6 will maintain this invariant , the edge will satisfy that @xmath897 .",
    "we conclude that the edges selected into @xmath835 in step 8 are exactly the edges from @xmath898 in a minimal solution .",
    "denote for each node @xmath899 in the minimal solution by @xmath900 its component in the minimal solution ; for @xmath901 for some such @xmath117 , denote @xmath902 ( @xmath903 otherwise ) .",
    "we claim that @xmath904 at the end of step 6 . to see this",
    ", we claim that the algorithm maintains for all @xmath133 the invariants that @xmath905 and @xmath906 .",
    "this holds trivially after the initialization in step 5 . according to the first rule of step 6 and the invariants , an sent message @xmath847 satisfies that @xmath907 .",
    "hence , a node @xmath51 receiving `` @xmath847 '' will not violate the invariant due to its change of @xmath908 .",
    "if there is some @xmath853 with @xmath854 , the invariant implies that @xmath121 and @xmath858 both contain nodes that are connected by the minimal solution to terminals @xmath909 with @xmath910 .",
    "since these terminals must be connected , too , the path connecting @xmath121 and @xmath858 is part of a single connectivity component of the minimal solution , which contains terminals labeled @xmath84 .",
    "we conclude that the invariants can not be violated ( first ) due to the second rule of step 6 .",
    "because if @xmath911 , they must be part of the same connectivity component of the minimal solution , the invariants can not be violated ( first ) due to the third rule of step 6 . in summary ,",
    "the invariants are upheld , yielding in particular that @xmath912 for each @xmath117 with @xmath864 .    from this result",
    ", it follows that replacing the labels @xmath187 , @xmath109 , by the sets @xmath913 , @xmath133 , defined in step 9 , does not change the minimal subset of @xmath72 that satisfies all constraints : if endpoint @xmath133 of edge @xmath914 sets @xmath915 for @xmath916 , it follows that @xmath917 and therefore @xmath141 is connected to all terminals @xmath109 with @xmath680 by the minimal solution .",
    "trivially , step 10 can not violate the minimality of the computed solution ; it thus remains to show that after step 10 , @xmath835 solves the instance .",
    "suppose @xmath181 with @xmath397 .",
    "if @xmath918 for some @xmath121 , step 10 ensures that @xmath50 and @xmath51 are connected by @xmath835 , since @xmath919 . hence , suppose that @xmath920 .",
    "denote by @xmath921 the unique path connecting @xmath50 and @xmath51 in @xmath72 .",
    "we already observed that @xmath922 and each edge @xmath923 satisfies that @xmath916 . due to steps 9 and 10",
    ", it follows that @xmath835 connects @xmath50 and @xmath51 .",
    "we summarize the results of our analysis of the pruning routine as follows .",
    "[ coro : prune ] given an instance of dsf - icand a forest @xmath72 on @xmath758 nodes that solves it , the above routine computes the minimal @xmath892 solving the instance .",
    "it can be implemented with running time @xmath882 .",
    "correctness is shown in .",
    "step 1 requires @xmath924 rounds .",
    "step 4 can be completed in @xmath925 rounds , since due to step 3 @xmath836 and the nodes incident to the edges in @xmath898 know that these edges are in @xmath898 .",
    "steps 5 , 8 , 9 , and 11 require local computations only .",
    "the remaining steps can be completed within @xmath882 rounds by lemmas  [ lemma : prune_2_10 ] , [ lemma : prune_3 ] , and [ lemma : prune_6_7 ] .",
    "we conclude that executing the pruning routine on the input @xmath72 determined by the algorithm from yields a fast factor @xmath1-approximation .",
    "[ theorem:2+eps_distributed ] for any constant @xmath0 , a deterministic distributed algorithm can compute a solution for problem dsf - icthat is optimal up to factor @xmath1 in @xmath926 rounds .    by",
    ", a forest solving the problem whose minimal subforest is optimal up to factor @xmath213 can be computed in @xmath926 .",
    "note that the forest is the union of at most @xmath292 paths of hop length at most @xmath3 , and trivially contains at most @xmath13 nodes .",
    "hence , we can apply with @xmath194 to show the claim of the theorem .",
    "since any instance can be transformed to one with minimal inputs efficiently and the number of different terminal decompositions that needs to be computed is trivially bounded by @xmath927 , we obtain the following stronger bound as a corollary .    by , we can transform the instance to a minimal instance in @xmath924 rounds ; the minimal instance has @xmath217 input components .",
    "the number of different possible moat sizes at which merges may happen is bounded by @xmath927 ( since edge weights are assumed to be integer and moats grow to size at most @xmath928 ) .",
    "if multiple merge phases end for the same such value , we can complete all of them without having to recompute the terminal decomposition .",
    "the result thus follows from .",
    "the first statement follows from the fact that for each @xmath935 , the index of @xmath388 w.r.t .",
    "the random order must be larger than that of @xmath144 , since @xmath388 attains the maximum index over @xmath936 .",
    "for the second statement , consider for any pair of nodes @xmath50 and @xmath51 a least - hop shortest path from @xmath50 to @xmath51 .",
    "if this path contains at least @xmath937 hops ( for a given constant @xmath938 ) , it contains also at least @xmath937 nodes ( since least - weight paths can not revisit nodes ) .",
    "observe that @xmath237 is a uniformly random subset of the nodes .",
    "hence , the probability that no node from @xmath237 is on the path is bounded from above by @xmath939 by the union bound applied to all pairs of nodes @xmath46 , we conclude that the probability that _ any _ of these paths contains no node from @xmath237 is at most @xmath940 . in other words , w.h.p .",
    ", for each pair of nodes @xmath941 , either a least - weight path from @xmath50 to @xmath51 with @xmath932 hops exists , or there is a node from @xmath237 on a least - weight path from @xmath50 to @xmath51 , which therefore is closer to @xmath50 w.r.t.weighted distance than @xmath51 . the second claim of the lemma follows . regarding the third claim ,",
    "observe that the same reasoning applies if we condition on @xmath942 , showing that w.h.p .",
    "the least - weight path from @xmath50 the nodes @xmath942 minimizing @xmath943 must have @xmath932 hops .",
    "[ lemma : stage1_partial ] delete the internal nodes corresponding to the set @xmath237 of the @xmath238 nodes of highest rank from the virtual tree . w.h.p .",
    ", the resulting forest can be computed within @xmath944 rounds . moreover , within this number of rounds , each node @xmath945 can learn about @xmath247 and all nodes on the corresponding least - weight path can learn the next hop on this path w.h.p .",
    "all detected least - weight paths have @xmath932 hops w.h.p .",
    "we compute a voronoi decomposition of @xmath42 w.r.t .  to @xmath237 .",
    "this can be done by , essentially , the single - source bellmann - ford algorithm to a virtual node by edges of weight @xmath102 and piggy - back the identifier of the node from @xmath237 through which the constructed path to the virtual node would pass on each message . ] in time @xmath932 w.h.p .",
    ", since by statement ( iii ) of , for each @xmath245 , there is a least - weight path from @xmath50 to @xmath946 of @xmath932 hops w.h.p .",
    "termination can be detected over a bfs tree , requiring additional @xmath236 rounds .",
    "this shows the second claim of the lemma . as a byproduct",
    ", each node @xmath245 learns @xmath947 , and the nodes on the corresponding least - weight path from @xmath50 to @xmath247 learn the next routing hop on the path .",
    "now we execute the algorithm from  @xcite , however , constructing only the forest resulting from deleting the internal nodes corresponding to nodes from @xmath237 . by statement  ( i ) of , this can be done by determining , for each @xmath945 , the nodes @xmath144 , @xmath931 , and the corresponding least - weight paths in @xmath42 connecting @xmath50 to the @xmath144 .",
    "the algorithm from  @xcite requires time @xmath948 to do so , where @xmath949 is the maximal length of any of the detected paths ; rounds , where in each round , information spreads by one hop along least - weight paths .",
    "] by statement  ( ii ) of , @xmath950 w.h.p .",
    "this operation completes within @xmath90 rounds , since no node sends more than two messages for each label .",
    "the root broadcasts the result over the bfs tree to all nodes , which also takes time @xmath90 .",
    "observe that if @xmath241 , for each @xmath109 and each @xmath956 , the least - weight path from @xmath50 to @xmath144 determined by the tree construction has at most @xmath3 hops .",
    "if @xmath34 and the partial construction was executed , by no detected path has more than @xmath957 hops w.h.p .",
    "therefore , all least - weight paths in @xmath42 used in step 3c have at most @xmath949 hops w.h.p .    in step 3c , in each iteration of the sending rule , each node sends at most one message for each node @xmath51 such that it is on a least - weight path from some leaf of the virtual tree to @xmath51 determined by the tree construction . by the properties of the tree , each node @xmath55 participates in at most @xmath6 different such paths w.h.p .",
    "hence each iteration requires @xmath6 rounds w.h.p .",
    ", which can be determined and communicated to all nodes in @xmath236 rounds .",
    "therefore , the iterations can be performed sequentially without the need to explicitly synchronize their execution . ]",
    "consider all messages @xmath958 that are sent in phase @xmath107 .",
    "these messages are sent along least - weight paths , i.e. , they induce a tree rooted at @xmath51 in @xmath42 . for each @xmath86",
    ", each node in the tree sends at most one message . in each iteration of the sending rule ,",
    "a node will send some message @xmath264 if it currently stores any message @xmath959 .",
    "hence , the total number of iterations until all messages @xmath264 are delivered is bounded by the sum of the depth of the tree , which is bounded by @xmath960 w.h.p . , and @xmath961 .",
    "termination of step 3c can be detected at an additive overhead of @xmath236 rounds over a bfs tree .",
    "we conclude that step 3c can be performed in @xmath962 rounds w.h.p .    concerning step 3d ,",
    "the same arguments apply : on each tree rooted at some @xmath51 , at most @xmath963 messages need to be sent to some node @xmath50 in the tree . using the same approach as for step 3c ,",
    "this requires @xmath962 rounds .      in  @xcite ,",
    "the authors show that the virtual tree can be constructed in @xmath964 rounds w.h.p . in ,",
    "we show that the partial tree can be constructed in @xmath944 rounds w.h.p .",
    "therefore , step 1 of the algorithm completes in @xmath965 rounds w.h.p . as steps 2 and 4",
    "are local and @xmath966 , it is sufficient to show that each phase can be implemented in time @xmath955 w.h.p . by , step 3a of each phase can be completed in @xmath90 rounds .",
    "step 3b requires local computations only .",
    "shows that steps 3c and 3d can be executed in @xmath955 rounds w.h.p .",
    "we now prove that the weight of the edge set @xmath72 selected in the first stage is bounded by the cost of the optimal solution on the virtual tree , which is optimal up to factor @xmath6 in expectation .",
    "this is facilitated by the following definition .",
    "we now show that the edges selected into @xmath72 correspond to edges in the optimal solution on the virtual tree , which is the edge set of the union @xmath967 .",
    "we first prove that the entries made into the @xmath268 variables in step 3b can be mapped to virtual tree edges in @xmath967 .",
    "assume for contradiction that the statement is wrong and @xmath968 is the minimal phase in which some node @xmath50 violates it .",
    "hence , @xmath973 for any @xmath974 . for the subtree @xmath975 of the virtual tree rooted at @xmath228 , this implies that @xmath80 is partitioned into the sets of labels @xmath976 and @xmath977 . by induction on phases",
    "@xmath978 , we see that at the beginning of each such phase @xmath112 , @xmath80 is partitioned into the subsets @xmath979 and @xmath980 : for @xmath981 , by the induction hypothesis and steps 3b to 3d of phase @xmath513 this would imply that there is a node @xmath51 on level @xmath513 of the virtual tree that has at least one descendant from @xmath975 and one descendant outside @xmath975 ; this is impossible for @xmath982 , as the root of @xmath975 is on level @xmath496 .    due to steps 3b and 3d in phase @xmath496 ,",
    "there is at most one node @xmath983 that has @xmath984 at the end of phase @xmath496 ; by step 3b for phase @xmath107 , it must hold that @xmath985 .",
    "however , we just showed that each node @xmath986 satisfies that @xmath987 .",
    "thus , @xmath50 sets @xmath252 in step 3a of phase @xmath107 , contradicting the assumption that it adds an entry to its @xmath268 variable in step 3b of the phase .",
    "therefore , our assumption that the statement of the lemma is wrong must be false , concluding the proof .    with this lemma in place",
    ", we are ready to prove that the total weight of the selected edge set does not exceed the weight of the optimal solution on the virtual tree .",
    "this is done by charging the weight of a selected least - weight path ( or prefix of such a path ) to the corresponding virtual tree edge given by .",
    "suppose edge @xmath117 is added to @xmath72 in phase @xmath253 .",
    "this must have happened because in step 3c of the phase , it was traversed by some message @xmath988 or @xmath989 , where some node @xmath50 made the respective entry to its @xmath268 variable in step 3b of the phase . in the latter case",
    ", we claim that @xmath990 . assuming the contrary , clearly @xmath991 and steps 3b to 3d of phase @xmath496 would entail that @xmath50 was selected in step 3d of phase @xmath496 by some node @xmath51 for which it added an entry @xmath958 to its @xmath268 variable in step 3b of the phase .",
    "it follows that @xmath992 , and each edge on the respective least - weight path from @xmath50 to @xmath247 has been traversed by a message in step 3c of phase @xmath496 .",
    "in particular , @xmath117 was added to @xmath72 already in an earlier phase .",
    "thus , indeed it must hold that @xmath993 .",
    "hence , @xmath117 is traversed by a message @xmath988 or @xmath994 in phase @xmath107 . from , we have that @xmath231 for some @xmath86 .",
    "moreover , by steps 3b and 3d of phase @xmath496 , the node @xmath50 that made the respective entry in step 3b of phase @xmath107 is unique ; there can be only one node @xmath50 in the subtree rooted at @xmath228 that satisfies @xmath995 at the beginning of phase @xmath107 .",
    "we `` charge '' the weight of @xmath117 to the edge @xmath996 .",
    "because node @xmath50 is unique with the property that the cost of edges traversed by messages @xmath988 or @xmath994 that are charged to @xmath997 can be backtraced to an entry it made in step 3b of phase @xmath107 , virtual tree edge @xmath997 is in total charged at most weight @xmath998 ( if @xmath257 ) or @xmath999 ( if @xmath993 ) , the weight of the respective least - weight paths in @xmath42 from @xmath50 to @xmath144 or @xmath247 , respectively . because @xmath1000 and @xmath1001 , @xmath997 is in total charged at most its own weight of @xmath1002 .",
    "we conclude that @xmath1003 is indeed at most the weight of the optimal solution on the virtual tree , i.e. , of the edge set of @xmath967 .",
    "[ lemma : stage1_connect ] for each terminal @xmath1004 , at least one of the following holds for the graph @xmath720 , where @xmath72 is the output of the first stage : ( i ) all terminals @xmath1005 with @xmath397 are in the same connectivity component or ( ii ) @xmath50 is at most @xmath1006 hops from a node in @xmath237 w.h.p .",
    "we claim that , for each phase @xmath253 and @xmath86 , the following holds w.h.p . : if at the beginning of the phase there are two or more terminals @xmath50 with @xmath868 , at the end of the phase each such @xmath50 will be connected to a terminal @xmath51 with @xmath1007 by a path of @xmath932 hops in @xmath720 .    to see this , observe first that if there are two or more terminals @xmath50 with @xmath868 at the beginning of phase @xmath107 , @xmath84 will not be deleted from the @xmath255 variables of these nodes in step 3a of the phase .",
    "hence , each such @xmath50 will add an entry @xmath1008 , where either @xmath1009 or @xmath1010 , to its @xmath268 variable in step 3b of the phase . in step 3c",
    ", all edges on the least - weight path from @xmath50 to @xmath141 will be added to @xmath72 .",
    "each of the respective paths has by step 1 of the algorithm and @xmath932 hops w.h.p .    due to step 3c",
    ", @xmath141 will add @xmath84 to @xmath1011 . in step 3d",
    ", it will select some node @xmath51 that added @xmath1012 to its @xmath268 variable in step 3b and sent @xmath1013 to it ; @xmath51 will hence set @xmath1014 .",
    "again , @xmath51 is connected to @xmath141 by a path of at most @xmath932 hops whose edges have been added to @xmath72 , since in step 3d a sequence of messages from step 3c is backtraced .",
    "this shows the claim .    by induction on the phases , for each @xmath86 , ( i ) each terminal @xmath636 with @xmath680 is connected in @xmath720 to some node @xmath51 with @xmath1007 via @xmath1006 hops w.h.p .  at the end of the first stage , or ( ii )",
    "there is a unique node so that all terminals @xmath109 with @xmath680 are connected by @xmath72 to this node .",
    "if ( i ) applies and @xmath244 , note that in phase @xmath222 all entries made to @xmath268 variables in step 3b were of the form @xmath1015 , where @xmath1016 is the root of the virtual tree .",
    "hence , all terminals @xmath109 with @xmath680 are connected to the root of the virtual tree by edges in @xmath72 . if @xmath1017 , the root of the virtual tree , i.e. , the node of highest rank , must be in @xmath237 .",
    "hence , all entries made to @xmath268 variables in step 3b of phase @xmath222 were of the form @xmath989 , and all terminals @xmath109 with @xmath680 are connected to a node in  @xmath237 .",
    "[ coro : stage2_group ] within @xmath1006 rounds , each @xmath1020 can learn the identifier of the node @xmath248 such that @xmath1021 .",
    ", terminals @xmath1022 satisfy that all terminals @xmath141 with @xmath1023 are connected in @xmath720 .",
    "membership in @xmath284 , @xmath248 , can be concurrently determined for all terminals @xmath1005 by running ( essentially ) the single - source bellmann - ford algorithm for @xmath932 rounds on the ( unweighted ) graph @xmath720 , with a virtual source connected by @xmath102-weight edges to nodes in @xmath237 and piggy - backing the identifiers of nodes in @xmath237 on messages referring to paths to them",
    ". this can be simulated on @xmath42 at no overhead , since for each @xmath1024 , @xmath50 and @xmath51 know that @xmath1024 .",
    "the second statement of the lemma directly follows from .        by , for each @xmath248 and each terminal @xmath1021",
    ", @xmath51 can learn @xmath50 in @xmath932 rounds .",
    "we also make the set @xmath237 global knowledge , by broadcasting it over the bfs tree ; this takes @xmath1028 rounds .",
    "next , each node @xmath50 locally initializes @xmath1029 and @xmath1030 for each @xmath1031 if @xmath1032 and @xmath1033 otherwise .",
    "subsequently , the following is executed on a bfs tree until no node sends any further messages .",
    "since there are @xmath1044 variables @xmath1036 at each node @xmath50 and @xmath1045 remains a forest , each node sends at most @xmath1046 messages .",
    "since forests are matroids , we have optimal pipelining and no messages are sent any more after @xmath1047 rounds ; this can be detected in additional @xmath236 rounds .",
    "we claim that once the above subroutine terminated , at the root @xmath1048 of the bfs tree the connectivity components of @xmath1049 are the same as the connectivity components of @xmath1050 . to see this , observe first that @xmath1051 , since a node @xmath50 adds an edge @xmath1043 to its set @xmath1052 only if it either receives a message `` @xmath1043 '' or it receives a message `` @xmath84 '' and stores @xmath1053 ( or vice versa ) ; this implies that some nodes @xmath1054 and @xmath1055 must have had @xmath1056 and @xmath1057 initially , which by the initialization values of the variables implies that indeed @xmath1058 .",
    "hence , for any node @xmath50 , any connectivity component of @xmath1059 is a subset of a connectivity component of @xmath280 .",
    "now suppose that @xmath1058 .",
    "thus , there are @xmath1060 and @xmath1061 so that @xmath680 and @xmath1062 .",
    "consider the sequence of ancestors @xmath1063 of @xmath50 in the bfs tree , and consider their variables @xmath1064 and @xmath1065 , @xmath1066 , at the end of the computation .",
    "we will prove by induction on @xmath107 that for each such @xmath144 , @xmath1065 connects @xmath84 to @xmath1067 .",
    "trivially , this holds for @xmath1068 , so assume that it holds for some @xmath1069 and consider @xmath388 .",
    "since @xmath144 sends @xmath1064 at some point , @xmath1070 . at the latest upon reception of this message , @xmath1071 and @xmath1064 become connected by @xmath1072 ; since @xmath1071 is modified only once and @xmath1073 can only add edges to @xmath1072 , but not remove them , @xmath1071 and @xmath1064 are connected by @xmath1072 when the subroutine terminates . by the induction hypothesis , @xmath1064 and @xmath84 are connected by @xmath1065 . due to the rules of the algorithm",
    ", @xmath144 will announce all edges in @xmath1065 at some point to @xmath388 .",
    "whenever such a message is received , @xmath388 either adds the edge to @xmath1072 or its endpoints are already connected by @xmath1072 .",
    "this shows that @xmath1071 eventually gets connected to @xmath84 , i.e. , the induction hypothesis holds for index @xmath382 .",
    "in particular , @xmath1052 connects @xmath84 and @xmath1074 .",
    "reasoning analogously for @xmath442 , @xmath1052 connects @xmath442 and @xmath1074 , and therefore also @xmath84 and @xmath442 .",
    "hence , any connectivity component of @xmath1075 is a superset of a connectivity component of @xmath280 .",
    "we conclude that the connectivity components of @xmath1075 are the same as those of @xmath280 , as claimed .",
    "since @xmath1052 is a forest , the root can broadcast @xmath1075 over the bfs tree in @xmath1076 rounds . from this",
    ", each node can determine the connectivity components of @xmath280 locally .",
    "now , each node can compute @xmath1026 ( for @xmath1031 , @xmath1077 iff it is not isolated in @xmath280 ) and @xmath1025 locally , as @xmath237 is already known to all nodes .",
    "[ lemma : stage2_feasible ] suppose @xmath1078 is a solution of an @xmath72-reduced instance , where @xmath72 is the set returned by the first stage .",
    "define @xmath1079 by selecting for each @xmath1080 an edge @xmath184 inducing it into @xmath474 .",
    "then @xmath1081 is a solution of the original instance w.h.p .",
    "suppose for @xmath909 we have that @xmath1082 .",
    "if @xmath141 or @xmath661 are not in @xmath1083 , shows that @xmath72 connects @xmath141 and @xmath661 w.h.p . hence , suppose that @xmath1084 and @xmath1085 for some @xmath1086 .",
    "this implies that @xmath1087 . because @xmath1078 solves the @xmath72-reduced instance",
    ", there is a path in @xmath1088 connecting @xmath284 and @xmath1089 . by definition of @xmath1090 and",
    "induced edges together with the fact @xmath72 connects each of the sets @xmath1091 , @xmath1092 , @xmath1093 connects @xmath141 and @xmath661 . since @xmath909 where arbitrary with the property that @xmath1082",
    ", applying the union bound over all pairs of terminals shows that @xmath1081 is a solution of the original instance w.h.p .",
    "denote by @xmath1094 an optimal solution of the original instance . for each @xmath1095 , drop all edges between nodes @xmath1096 .",
    "the remaining edge set induces an edge set @xmath1097 of at most weight @xmath1098 in @xmath278 , which we claim to be a solution to the reduced instance ; from this the statement of the lemma follows immediately .",
    "consider terminals @xmath1099 of the new instance with @xmath1100 . by definition of @xmath1025 , this entails that there are nodes @xmath1101 and @xmath1102 and a path @xmath1103 in @xmath280 .",
    "for each edge @xmath1104 on the path , @xmath1105 , there is a node @xmath1106 and terminals @xmath1107 so that @xmath1108 and @xmath1109 . because @xmath1094 is a solution of the original instance and @xmath1110 for each @xmath1111 ,",
    "there is a path in @xmath1094 connecting @xmath1112 and @xmath1113 .",
    "hence , @xmath1078 connects @xmath1114 and @xmath1115 .",
    "it follows that it also connects @xmath1116 and @xmath1117 . as @xmath1118 and @xmath1119 , there are paths in @xmath1094 that connect @xmath50 to @xmath427 and @xmath51 to @xmath1120 , respectively .",
    "therefore , @xmath1078 connects @xmath1121 to @xmath1116 and @xmath629 to @xmath1117 , respectively .",
    "overall , @xmath1078 connets @xmath1121 and @xmath629 . since @xmath1099 were arbitrary with the property that @xmath1100 , we conclude that @xmath1078 is indeed a solution of the @xmath72-reduced instance .",
    "[ lemma : stage2_solve ] a solution @xmath1078 of the @xmath72-reduced instance determined by the output of the first stage of weight @xmath6 times the optimum can be found in @xmath32 rounds w.h.p .",
    ", in the sense that an inducing edge set @xmath1079 is marked in @xmath42 that satisfies @xmath1122 .",
    "adding the set @xmath237 ensures that any least - weight path between pairs of nodes in @xmath1124 that has no inner nodes from @xmath1124 has @xmath1006 hops .",
    "this property is already guaranteed in @xmath42 and thus also @xmath278 due to the uniformly random set @xmath237 of the @xmath238 nodes of highest rank ; therefore , it can be skipped .    to simulate the algorithm on @xmath278",
    ", it suffices to slightly modify the second step of the algorithm",
    ". the spanner construction iteratively grows clusters of nodes that are connected by spanner edges , where usually the clusters are initialized to the singletons given by the node set of the spanner . in our setting , for each @xmath248 , the nodes in @xmath284 are already connected after the first stage and identified to a single node in @xmath278 . to reflect this in the spanner construction , we simply initialize the clusters to be the sets @xmath284 , @xmath248 ; the algorithm then constructs a spanner on the complete graph on @xmath1126 with edge weights given by distances in @xmath278 .",
    "the paths the algorithm detects and whose edges will be returned in the last step of the algorithm have weight equal to the edge weights in @xmath278 .",
    "because the third step operates on the spanner only , it does not have to be modified . using the ( deterministic ) moat - growing algorithm , which guarantees @xmath1127 , and parameter @xmath1128 in the spanner construction , theorem 5.2 from @xcite shows that the returned edge set @xmath474 has weight at most @xmath6 times the optimum of the @xmath72-reduced instance .",
    "the above modifications to the algorithm do not affect the running time apart from ensuring that the number of nodes in the spanner ( and the instance of dsf - icon the spanner solved in the third step ) becomes @xmath1129 , so the analysis from @xcite yields a running time of @xmath1130 .",
    "the time complexity follows from the observation that checking the weight of an edge set returned by the first stage can be done in @xmath236 rounds using a bfs tree , lemmas  [ lemma : stage2_compute ] and  [ lemma : stage2_solve ] , and corollaries  [ coro : stage1_time ] and  [ coro : stage2_group ] .    in  @xcite",
    ", it is shown that the weight of the optimal solution on the virtual tree is within factor @xmath6 of the optimum in expectation . by markov s inequality , with probability at least @xmath1132 , this expectation",
    "is exceeded by factor at most @xmath30 .",
    "hence , with probability at least @xmath1133 , i.e. , w.h.p .",
    ", at least one of the computed virtual trees exhibits an optimal solution that is within factor @xmath6 of the optimum for the instance on @xmath42 . by",
    ", the weight of the set @xmath72 is at most that of the optimal solution on the corresponding virtual tree , implying that the set @xmath72 determined in the second step of the algorithm has weight within factor @xmath6 of the optimum w.h.p .    for @xmath241 , by @xmath72",
    "is a solution , i.e. , the claim of the theorem holds . for @xmath34 ,",
    "the algorithm proceeds to compute @xmath474 . by",
    ", @xmath474 induces a solution of the @xmath72-reduced instance , yielding by that @xmath1081 solves the original instance w.h.p .",
    "also guarantees that @xmath474 has weight within factor @xmath6 of the optimum of the @xmath72-reduced instance , which by implies that @xmath1134 weighs also at most @xmath287 times optimum of the original instance .",
    "we conclude that @xmath1135 is optimal up to factor @xmath6 w.h.p .",
    "applying the union bound over the various statements that hold w.h.p . , the statement of the theorem follows for @xmath34 ."
  ],
  "abstract_text": [
    "<S> we present new distributed algorithms for constructing a steiner forest in the congestmodel . </S>",
    "<S> our deterministic algorithm finds , for any given constant @xmath0 , a @xmath1-approximation in @xmath2 rounds , where @xmath3 is the `` shortest path diameter , '' @xmath4 is the number of terminals , and @xmath5 is the number of terminal components in the input . </S>",
    "<S> our randomized algorithm finds , with high probability , an @xmath6-approximation in time @xmath7 , where @xmath8 is the unweighted diameter of the network . </S>",
    "<S> we prove a matching lower bound of @xmath9on the running time of any distributed approximation algorithm for the steiner forest problem . </S>",
    "<S> the best previous algorithms were randomized and obtained either an @xmath6-approximation in @xmath10 time , or an @xmath11-approximation in @xmath12 time .    </S>",
    "<S> = 8.5 in    = 1 </S>"
  ]
}