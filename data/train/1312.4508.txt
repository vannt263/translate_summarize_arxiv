{
  "article_text": [
    "this article takes up the generation of prime numbers smaller than a given bound @xmath7 , by using the wheel sieve distributively .",
    "wheel sieve algorithms can be very efficient to determine the primality of integers which belong to a given finite interval @xmath0 $ ] , for sufficiently large values of @xmath7 and when the test of primality is carried out on all numbers of the interval .",
    "the paper designs a fully distributed wheel sieve algorithm using scheduling by multiple edge reversal ( smer ) .",
    "the main purpose of a parallelization of such kind of algorithm is to increase the bounds of the generation of prime numbers , and to reach these bounds in a shorter execution time .",
    "the first parallelization of a sieve algorithm was realized in 1987 @xcite , who parallelized the sieve of eratosthenes .",
    "this work was motivated by testing a new parallel machine ( the _ flex/32 _ ) , because this kind of algorithm is ideal to test the performances of a new architecture ( of a sequential or parallel machine ) as a benchmark .",
    "the sieve of eratosthenes was the first prime sieving algorithm , and it consists in eliminating all non prime numbers in the interval @xmath0 $ ] .",
    "first , the algorithm takes the first number of the interval and generates all its multiples ( by adding its own value to himself ) , which are thus eliminated .",
    "the next ( non eliminated ) number is the one ( the next prime number ) which sieves the interval , and this process is pursued until all intervals has been sieved .",
    "various parallelizations of this algorithm can be found , e.g. in @xcite .    however , the main drawback of the practical sieve of eratosthenes is clearly the fact that it imposes to go through all the entries of the multiples of each number during the sieving process .",
    "for instance , if the current entry corresponds to @xmath8 , then any entry at locations @xmath9 , @xmath10 , @xmath11 is changed to zero , and so on , until the stop criteria is reached , i.e. , @xmath12 . the basic sieve of eratosthenes proceeds in the same way on any other entry .",
    "it is easy to see that some numbers will be generated more than once , for example @xmath13 is generated twice ( from @xmath14 and @xmath15 ) , and @xmath16 is generated three times ( from @xmath17 and @xmath18 ) .",
    "the entries that are already zeros are left unchanged , but each entry must nevertheless be checked throughout the sieving process .",
    "the main idea consists then in trying to prevent all numbers from being sieved `` too many times '' . sieving the multiples of any given number more than once",
    "must be avoided , as much as possible .",
    "all efficient sieving algorithms are based on similar techniques .",
    "so , the complexity @xmath19 of the sieve of eratosthenes may be somewhat improved by several clever arguments that are carried out by the above methods .",
    "such sieve algorithms achieve a linear @xcite or even a sublinear ( step ) complexity @xcite .",
    "so far , the best algorithm known is the `` wheel sieve '' , designed in 1981 @xcite .",
    "it requires only @xmath20 steps to find the set of primes in the interval @xmath21 $ ] ( with @xmath22 ) , where each step is either for bookkeeping or an addition with integers at most @xmath7 .",
    "basically , the algorithm relies on the central result on the number of primes in arithmetic progressions .",
    "more precisely , dirichlet s theorem states that if @xmath23 , @xmath24 are coprime integers ( @xmath25 ) and @xmath26 , then the arithmetic progression @xmath27 contains infinitely many primes  ( * ? ? ?",
    "( see  @xcite for more details on the analysis of the wheel sieve algorithm . )",
    "the paper presents a new kind of fully distributed algorithm that finds all primes by sieving in a given interval @xmath28 $ ] , using the properties of the wheel sieve using the smer @xcite .",
    "some other distributed algorithms generating all prime numbers can be found in @xcite , which use the properties of dirichlet s theorem . in @xcite",
    "another kind of distributed prime number generation is presented , based only on scheduling by multiple edge reverse framework  @xcite .    in sect .  2 ,",
    "the wheel sieve algorithm is introduced . in sect .",
    "3 and 4 , the framework of the _ scheduling by edge reversal _ ( ser ) and the _ scheduling by multiple edge reversal _ ( smer ) mechanisms are both introduced .",
    "5 is devoted to the design of our distributed algorithm for sieving primes by using the smer - based method applied to the wheel sieve .",
    "the worst - case complexity analysis of the algorithm is achieved in sect .",
    "6 . the final sect",
    ".  7 draws a short conclusion and offers some perspectives .",
    "the wheel sieve derived from pritchard s algorithm @xcite operates basically by generating a set of numbers that are not multiples of the first @xmath29 prime numbers .",
    "the sieve , applied on the resulting set from the wheel , eliminates the non prime numbers that remain in the set .",
    "this is the basic idea of the _ wheel _ which were employed as a reduced residue class @xmath30 , where @xmath31 denotes the product of the first @xmath29 prime numbers @xcite .",
    "@xmath32 denotes the @xmath29-th wheel , which is defined as @xmath33 where @xmath34 and @xmath35 are coprime numbers .",
    "the sieve introduced by the wheel sieve consists basically , after having generated the next wheel @xmath36 , in using the prime number @xmath37 to sieve the new wheel , generating all its multiples and removing them from @xmath36 . for more clarity",
    "this new set will denoted @xmath38 .",
    "it is clear that after @xmath38 is obtained the algorithm proceeds to another sieving process , and eliminate the remaining composite numbers .",
    "the wheels are thus patterns that are repeated every @xmath31 times .",
    "starting from the preceding wheel @xmath32 . _ _ ]    in fig .",
    "[ fig : wheel1 ] we use @xmath39 in the first step of the wheel sieve as the product of the first two prime numbers @xmath40 and @xmath41 figured by the small circle ; this generates all `` pseudo - primes '' numbers prime numbers .",
    "] between @xmath42 and the new bound contained in the new wheel @xmath43 , that is the actual bound @xmath39 multiplied by the next prime @xmath44 .",
    "the next prime is the first number after @xmath42 that belongs to the interval being sieved @xcite in the second wheel , which contains now the next value @xmath45 .        the above fig .",
    "[ fig : wheel2 ] shows that all the pseudo - prime numbers of the big wheel , that is @xmath46 , are generated within the small wheel .    ) . _ _ ]    in fig .",
    "[ fig : wheel3 ] the process of generating the big wheel is going on .",
    "number @xmath47 is generated from the number @xmath42 of the small wheel , which can be interpreted as if we were `` rolling '' the small circle inside the big one .",
    "this means that starting from a wheel @xmath32 , we can generate the next wheel @xmath36 in a graphical way .",
    "the points where the elements of the wheel @xmath32 touch the circle featuring @xmath36 are the new pseudo - primes .",
    "more precisely , @xmath36 is defined as @xmath48     to generate @xmath38 . _ _ ]    fig .",
    "[ fig : wheel4 ] shows the final phase of the wheel sieve , where the multiples of the previous @xmath49 ( in that case , the number @xmath45 ) are eliminated from the set @xmath50 . according to the definition of @xmath36 in eq .",
    "( [ wheel ] ) , we also define @xmath51 the previous wheel @xmath32 is put in the center of the new wheel @xmath38 ( see fig .",
    "[ fig : wheel4 ] ) . then drawing a radius from the center of the small circle containing each pseudo - prime number of this circle , each one of the prolongations of such radii touches the big circle at every pseudo - prime that will be eliminated in the new wheel @xmath36 .",
    "thus , the prime @xmath49 will be put in the set @xmath52 of all prime numbers .    in @xcite a distributed version of the wheel sieve is proposed .",
    "it is implemented by using a message passing interface specification ( _ lam - mpi 7.0.6 library _ )  @xcite .",
    "the time measurements of a sequential and a distributed implementation of the wheel sieve are compared , together with a sequential and distributed implementation of the sieve of eratosthenes . in @xcite a fully distributed version of the wheel sieve",
    "is also presented .",
    "consider a neighbourhood - constrained system composed by a set of _ processing elements _ ( pes ) and a set of _ atomic shared resources _ represented by a connected directed graph @xmath53 , where @xmath54 is the set of pes and @xmath55 the set of its directed edges ( or arcs ) , stating the access topology ( directed edges are henceforth refered to as arcs ) .",
    "the latter is defined in the following way : an arc exists between any two nodes _ if , and only if , _ the two corresponding pes share at least one atomic resource .",
    "ser works as follows : starting from any acyclic orientation @xmath56 on @xmath57 , there is at least one _ sink _ node , i.e. , a node such that all its arcs are directed to itself ; all sink nodes are allowed to operate while other nodes remain idle .",
    "this obviously ensures mutual exclusion at any access made to shared resources by sink nodes .",
    "after operation , a sink node will reverse the orientation of its arcs , becoming a _ source _ and thus releasing the access to resources to its neighbours .",
    "a new acyclic orientation is defined and the whole process is then repeated for the new set of sinks .",
    "let @xmath58 denote this greedy operation .",
    "ser can be regarded as the endless repetition of the application of @xmath59 upon @xmath57 .",
    "assuming that @xmath57 is finite , it is easy to see that eventually a set of acyclic orientations will be repeated defining a period of length @xmath60 .",
    "this simple dynamics ensures that no deadlocks or starvation will ever occur since in every acyclic orientation there exists at least one sink , i.e. one node allowed to operate .",
    "also , it is proved that inside any period , every node operates exactly the same constant number of times ( denoted @xmath61 )  @xcite .",
    "ser is a fully distributed graph dynamics in which the sense of time is defined by its own operation , i.e. , the synchronous behavior is equivalent to the case where every node in @xmath57 takes an identical amount of time to operate and also an identical amount of time to reverse arcs .",
    "another interesting observation to be made here is that any topology @xmath57 will have its own set of possible ser dynamics  @xcite .        as an example of ser s applicability ,",
    "consider dijkstra s paradigmatic _ dining philosophers problem _",
    "@xcite under heavy load , i.e. , in the case philosophers are either `` hungry '' or `` eating '' ( no `` thinking '' state )",
    ". such system can be represented by a set @xmath62 of @xmath2 pes , in which each pe shares a resource both with its previous pe and its subsequent pe .",
    "thus , taking the original configuration where @xmath63 and setting an acyclic orientation over the @xmath45 nodes ring , the resulting ser dynamics where @xmath64 and @xmath65 is illustrated in fig .",
    "[ fig : dining ] .",
    "smer is a generalization of ser in which pre - specified access rates to atomic resources are imposed to processes in a distributed resource - sharing system represented by a multigraph @xmath66 .",
    "in contrast with ser , multiple edges can exist between any two nodes @xmath67 and @xmath68 ( @xmath69 ) in the smer dynamics : there can exist @xmath70 undirected edges connecting nodes @xmath67 and @xmath68 ; such connected nodes are called `` neighbours '' .",
    "let @xmath71 denote the `` reversibility '' of node @xmath67 , as defined in @xcite .",
    "more precisely , reversibility @xmath71 is the number of arcs that shall be reversed by @xmath67 towards each of its neighbouring nodes at the end of each operation step ( access to shared resources ) .",
    "node @xmath67 is called a @xmath72-sink if at least @xmath73 arcs are directed to itself from each of its neighbours . in the smer dynamics , each @xmath72-sink node @xmath67 operates by reversing @xmath73 arcs towards all of its neighbours , next a new set of @xmath72-sinks",
    "operates in turn , and so on .",
    "similarly to sinks under ser , only @xmath72-sink nodes are allowed to operate under smer . unlike ser",
    ", nodes may operate more than once consecutively in smer dynamics .",
    "let @xmath74 be the sequence of orientations produced by smer over @xmath1 from the initial orientation @xmath75 .",
    "as infinite sequences are of our interest ( originally motivated by the dining philosophers with rates ( dppr ) problem @xcite ) , let @xmath76 denote the greatest multiple of @xmath77 of @xmath71 and @xmath78 , which does not exceed the number of edges oriented from @xmath67 to @xmath68 in @xmath79 .",
    "orientations @xmath80 , such that @xmath81 , @xmath82 , remaining constant as a consequence of the two terms changing by a certain multiple of gcd@xmath83 ( arcs reversed between neighbouring nodes @xmath67 and @xmath68 ) .",
    "let @xmath84 be the submultigraph of @xmath1 induced by a pair of neighbouring nodes @xmath67 and @xmath68 , and let @xmath85 , @xmath86 be the sequence of orientations of @xmath84 produced by smer from @xmath85 .",
    "the following lemma  [ lem : relations ] states a basic topology constraint towards the definition of the multigraph @xmath1 .",
    "( @xcite ) [ lem : relations ] if @xmath87 , aplication of smer from @xmath85 on @xmath84 solves the instance of dppr given by neighbouring nodes @xmath67 and @xmath68 , @xmath73 and @xmath88 , if and only if @xmath89 .",
    "in this case , the sequence @xmath90 ( @xmath91 ) includes all orientations of @xmath92 that are legal for @xmath67 and @xmath68 given @xmath93 in a given arbitrary multigraph @xmath1 .",
    "if no deadlock arises for any initial orientation of the arcs between i and j , then @xmath94    it is important to remark that there is always at least one smer solution for any target system s topology having arbitrary pre - specified reversibilities at any of its nodes  @xcite .",
    "according to lemma  [ lem : relations ] , since @xmath95 , either @xmath67 or @xmath68 is in a @xmath72-sink condition , independently of @xmath96 .",
    "it may also be seen that , between all pairs of neighbouring nodes @xmath67 and @xmath68 in @xmath1 , any smer dynamics produces _ one unique _ period , given by the relation @xmath97  @xcite .",
    "this periodic property of smer can be observed in fig .",
    "[ fig : smer ] , where @xmath98 and the nodes in @xmath1 share values that are pairwise coprime integers : such pairs @xmath83 have no common divisors ( except @xmath42 ) .    .",
    "oriented arcs are represented by tokens . _ _ ]",
    "let @xmath66 be an arbitrary multigraph having @xmath2 nodes . for the sake of simplicity",
    ", the distributed algorithm is actually assumed to sieve the restricted interval @xmath99odd integers in @xmath100 $ ] } , according to the parity of @xmath7 .",
    "such a smer - based sieving algorithm is called _ semi - smer _ ; this in contrast with the smer dynamics described in section  3 , which considers the whole neighbourhood of any given node .    the procedure _ semi - smer _ is designed for any current node process @xmath101 , and it uses local variables , defined as follows :    * the interval @xmath102 is set to an exclusive value within @xmath103 .",
    "for example , when we make use of the third wheel @xmath104 in the algorithm , the interval @xmath105 is set to a value of @xmath106 extended to @xmath107 , @xmath108 and @xmath109 . * _ _ neigh__@xmath110 denotes the set of neighbours of process @xmath67 , and the number of incoming arcs oriented from every @xmath111 _ _ neigh__@xmath110 to the current process @xmath67 is denoted by the variable _",
    "_ incoming__@xmath112 $ ] ; * @xmath113 $ ] denotes the required number of arcs that shall be reversed by @xmath67 towards every @xmath111 _",
    "_ neigh__@xmath110 , independently .",
    "the variable @xmath113 $ ] takes its values in the interval @xmath102 , and the variable @xmath114 $ ] takes its values in the interval @xmath105 ; * @xmath115 $ ] denotes the number of undirected edges ( both outgoing and incoming arcs ) connecting every pair of neighbours @xmath116 in @xmath1 ( see fig .  [",
    "fig : smer ] ) ; * @xmath117 $ ] denotes the number of incoming arcs oriented from each @xmath111 _ _ neigh__@xmath110 to @xmath67 in the initial orientation ; * process @xmath67 also maintains the boolean variables @xmath118 $ ] and @xmath119 $ ] .",
    "if , at the end of the _ semi - smer _ period , @xmath118 $ ] is true for @xmath111 _ _",
    "neigh__@xmath110 , then @xmath113 $ ] and @xmath114 $ ] are coprime numbers ( @xmath120 ) .",
    "the value of @xmath119 $ ] checks whether the _ semi - smer _ between two nodes ended its execution or not ; * @xmath121 contains the numbers generated by the extended wheel that consists in the remaining prime numbers .    ' '' ''     +   +   + @xmath122 + @xmath52 ; + @xmath123 ; + @xmath49 ; + @xmath124 : boolean  * init * true ; + @xmath125 $ ] : integer ; + @xmath118 $ ] : boolean  * init * false ; + @xmath126 $ ] : boolean  * init * false ; +   +  @xmath113 \\le r_{j}[i]$ ]  * then * + @xmath117 = r_{i}[j]$ ] ; + @xmath125 = r_{i}[j]$ ] ; + @xmath115 = r_{i}[j ] + r_{j}[i]-1 $ ] ; +   + @xmath117 = r_{i}[j ] - 1 $ ] ; + @xmath125 = a_{i}[j]$ ] ; + @xmath115 = r_{i}[j]+r_{j}[i]-1 $ ] ; +   +  @xmath126 $ ] +  @xmath125 \\ge r_{i}[j]$ ]  * then *  send message @xmath127\\rangle$ ] to @xmath128 ; + @xmath125 = incoming_{i}[j ] - r_{i}[j ] $ ] ; + @xmath129 ; +   + receive @xmath130\\rangle$ ] from @xmath128 ; + @xmath113= incoming_{i}[j ] +   r_{j}[i ] $ ] ; + @xmath129 ; +   +  @xmath125 = 0 $ ] * then *  @xmath118 = true$ ] ;  * endif * +  @xmath125 = a_{i}[j]$ ] * then *  @xmath126 = true$ ] ;   * endif * + @xmath131 ; + @xmath126 $ ] : boolean * init * false ; +   +  @xmath113 \\le r_{j}[i]$ ]  * then * + @xmath117 = r_{i}[j]$ ] ; + @xmath125 = r_{i}[j]$ ] ; + @xmath115 = r_{i}[j ] + r_{j}[i]-1 $ ] ; +   + @xmath117 = r_{i}[j ] - 1 $ ] ; + @xmath125 = a_{i}[j]$ ] ; + @xmath115= r_{i}[j]+r_{j}[i]-1 $ ] ; +   +  @xmath126 $ ] +  @xmath125 \\ge r_{i}[j]$ ]  * then *  send message @xmath127\\rangle$ ] to @xmath128 ; + @xmath125 = incoming_{i}[j ] - r_{i}[j]$ ] ;    receive @xmath130\\rangle$ ] from @xmath128 ; + @xmath113= incoming_{i}[j ] +   r_{j}[i ] $ ] ; +   +  @xmath125 = 0 $ ] * then *  @xmath118 = true$ ] ;  * endif * +  @xmath125 = a_{i}[j]$ ] * then *  @xmath126 = true$ ] ;   * endif * +   +  @xmath118 = true$ ]  * then *  @xmath132  * endif * +  @xmath52 +   +    ' '' ''    as pointed out , if we start initially the sieve with the third wheel there are eight processes , whose values are the numbers @xmath133 , that represent the values of @xmath102 . the set @xmath105 is started in accordance with @xmath2 ; for example , if @xmath134 , eight processes are needed , one for each value @xmath135 .",
    "these values represent the multiples of @xmath136 . beginning with these values ( we consider that at the beginning , each process knows its identity ) , and after executing the _ wheelsieve - smer _",
    ", we obtain a set ( @xmath121 ) composed with the values of all periods spread in between the values of @xmath102 and @xmath105 .",
    "there remains the operation of sieving the @xmath121 set with @xmath49 in order to obtain @xmath52 .",
    "in order to sieve all primes from the interval @xmath0 $ ] , the only fundamental operations explicitly used in the algorithm _ semi - smer _ are comparisons , additions and the sending and receiving of messages ( arc reversals ) . besides , a send - receive event and one comparison operation are assumed to take @xmath137 number of time slots .",
    "the number of steps required by _ semi - smer _ is proportional to the period involved between any two nodes of @xmath1 during the algorithm .",
    "now , the largest period @xmath138 follows from lemma  [ lem : relations ] and  @xcite : @xmath139 , when @xmath140 .",
    "since @xmath141 and @xmath142 , for any pair of nodes @xmath116 , the procedure _ semi - smer(@xmath7 ) _ requires at most @xmath3 steps .",
    "similarly , for any current pair of nodes @xmath116 of @xmath1 smaller than @xmath143 , the number of messages exchanged in the * while * loop is proportional to @xmath144 , with @xmath145__neigh__@xmath110 .",
    "hence , if we let @xmath146 denote the largest period between all pairs @xmath147 , the maximum message complexity of the algorithm is proportional to @xmath148 , where @xmath149 is the maximum multidegree of @xmath1",
    ". finally , the message complexity achieves at most @xmath4 .",
    "the maximum amount of memory space required per process is @xmath6 bits .",
    "this paper introduced a totally new kind of smer - based distributed sieve algorithm that generates all primes in a given interval @xmath0 $ ] . apart from observing that the fundamental operation of the _ semi - smer _ algorithm is a local comparison , it is also worth noticing that no @xmath150 computation is needed .",
    "moreover , no precomputation is assumed in the _ semi - smer _ complexity analysis ( precomputation would take @xmath151 , where @xmath31 denotes the product of the first @xmath29 prime numbers , in the wheel sieve ) .",
    "this approach seems also general enough to compute some of the elementary arithmetic functions in number theory .",
    "for instance , using the gcd and inverse , the least common multiple of integers , and various basic multiplicative arithmetic functions , e.g. euler s totient function @xmath152 , mbius function @xmath153 and divisor functions : @xmath154 , @xmath155 , @xmath156 , @xmath157 , etc .",
    "finally , it stems also from both computer - driven and theoretical results that the number of steps @xmath158 executed by the algorithm stays always `` very close '' to the maximal number of steps .",
    "more precisely , @xmath159 , where @xmath160 is a positive non periodic arithmetic function with rather small fluctuations when @xmath161 : we conjecture that @xmath162 for `` almost every '' @xmath161 .",
    "hence , for every @xmath161 , @xmath160 should yield an expected @xmath163 for all @xmath164 , and the _ average _ number of steps required by the algorithm should then be expected to achieve @xmath165 ."
  ],
  "abstract_text": [
    "<S> this paper presents a new distributed approach for generating all prime numbers in a given interval of integers . from eratosthenes , who elaborated the first prime sieve ( more than 2000 years ago ) , to the current generation of parallel computers , which have permitted to reach larger bounds on the interval or to obtain previous results in a shorter time , prime numbers generation still represents an attractive domain of research and plays a central role in cryptography . </S>",
    "<S> we propose a fully distributed algorithm for finding all primes in the interval @xmath0 $ ] , based on the _ wheel sieve _ and the smer ( _ scheduling by multiple edge reversal _ ) multigraph dynamics . given a multigraph @xmath1 of arbitrary topology , having @xmath2 nodes , a smer - driven system is defined by the number of directed edges ( arcs ) between any two nodes of @xmath1 , and by the global period length of all `` arc reversals '' in @xmath1 . </S>",
    "<S> the new prime number generation method inherits the distributed and parallel nature of smer and requires at most @xmath3 time steps . </S>",
    "<S> the message complexity achieves at most @xmath4 , where @xmath5 is the maximal multidegree of @xmath1 , and the maximal amount of memory space required per process is @xmath6 bits .    </S>",
    "<S> distributed algorithms ; prime numbers generation ; wheel sieve ; scheduling by edge reversal ; scheduling by multiple edge reversal . </S>"
  ]
}