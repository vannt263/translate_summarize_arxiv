{
  "article_text": [
    "_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ `` interpreters are the second - class citizens of the compiler construction world : everybody employs them , but hardly any author pays serious attention to them.''grune _ et al .",
    "_ , _ modern compiler design _ , p. 49",
    "_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _    the undergraduate compiler construction course at our school is a one - semester , upper - division elective , offered every other year .",
    "the class is a mix of software engineering concerns and conceptual material from a traditional core ( lexing , parsing , semantic analysis , and code generation ) , and at its heart is the construction by each student of a working compiler , completed over the 15-week semester . for its balance of simplicity and realistic features , we focus on the tiger programming language , originally developed by andrew appel for his project - based `` modern compiler implementation '' suite of c , ml , and java textbooks @xcite .",
    "our projects differ from his work in that we do not tackle some of the more advanced back - end problems such as register allocation and liveness analysis , concentrating instead on the simpler task of code generation for a virtual machine . in order to facilitate modularity between the assignments ( and prevent early difficulties from having a cumulative effect on later work ) , the students build their work from a skeleton java source code distribution , consisting of some utility code , a set of ast classes , and interfaces for traversal of the ast . following the lead of more recent texts ( @xcite , for example ) , this traversal is done according to the well - known _ visitor pattern _ @xcite , in both the semantic analysis and code generation phases .    through several versions of this course , an unfortunate trend in student performance has emerged .",
    "students do well with the material on lexing and parsing , but too many of them begin to struggle during implementation of the semantic analysis phase .",
    "they find overwhelming both the conceptual material underlying type checking , the details of the visitor pattern in traversing an ast , and the interplay of this traversal technique with the complexities of a realistic semantic analysis implementation .",
    "it is not uncommon for students to fall behind badly at this point , with the result that their final effort ",
    "ast- based code generation  is less successful than it should be , even with the relative modularity of the accompanying assignments .",
    "the reappearance of ast traversal in the code generation phase does serve to deepen the understanding of the semantic analysis phase , but often this benefit comes only at or near the end of the semester .    in meetings with individual students , i have often used the basic structure of a language s _ interpreter _ as a touchstone for explanation of these two phases . though it was",
    "not a scheduled topic in the class , this approach was one that proved almost uniformly effective among the students with whom i discussed it , so much so that i began to reorganize the classroom lectures introducing both compiler phases to include this structure as a reference point .",
    "this paper proposes to teach this connection explicitly , through a version of the undergraduate compilers course that treats the interpreter as a first class citizen . in this approach ,",
    "the semester - long compiler construction project includes an interpreter for the source language , which is organized in a way that makes plain the congruence between this interpreter s basic structure and that of the semantic analyzer and the code generator . with some changes to the semester s topic schedule , a module on interpreters and their implementation",
    "is presented early in the semester , after construction of the parser , as the first substantial example of the ast traversal technique .",
    "after a few days study of the structure of this interpreter , the more traditional type - checking material is introduced , followed by intermediate - form translation . despite the apparent impracticality and distraction from `` core '' material , student learning of this topic can offer several practical and conceptual benefits .",
    "the key point here is not the observation that all three tasks involve a similar recursive descent of the ast .",
    "rather , it is an explicit emphasis on teaching both compiler stages as forms of interpretation .",
    "this approach has the immediate practical advantage of providing a tool  the interpreter  which gives a lightweight implementation of the language s reference semantics for later testing of the completed compiler .",
    "moreover , it establishes an early code base that supports both reuse and the comprehension of new design and algorithmic patterns in the subsequent semantic analysis and code generation implementations .",
    "most importantly , it provides a lucid , unified framework in which key ideas in both type checking and code generation can be explained as forms of explicit - control evaluation over different forms of abstract value domain .    in the remainder of this paper",
    ", we develop a model curriculum for this approach .",
    "section [ section : related ] positions this work within the relevant literature .",
    "the development proper begins in section [ section : distribution ] with an overview of the standard distribution for the course s semester - long project .",
    "section [ section : interpreter ] introduces the primary innovation of this paper , in its presentation of an _",
    "interpreter _ for the semester project s target language , along with a discussion of the interpreter s place in the semester schedule .",
    "sections [ section : semant ] and [ section : codegen ] discuss the semantic analysis and code generation phases , the teaching of which is the principal motivation for the development _ a priori _ of an interpreter .",
    "there are frequent references throughout to the source code of a model semester - long project .",
    "this code is freely available by request from the author .",
    "from a theoretical perspective , it is well known that both semantic analysis and code generation are closely related to a language s _ interpreter _ , the former a simulation of program execution on abstract value domains @xcite and the latter a specialization of the interpreter with respect to a program s source code @xcite .",
    "it is therefore unsurprising that the implementation of an interpreter shares many structural characteristics with the implementation of both the semantic analysis and code generation phases .",
    "however , the details of these correspondences are likely inaccessible to the typical undergraduate student , and moreover , they are a distraction .",
    "an undergraduate course in compiler construction generally focuses on a narrow range of language features , emphasizing instead many real - world concerns such as efficient symbol table construction , separation of front and back ends through an intermediate representation , call stack frames , and ( time permitting ) various code - improving transformation techniques . as a consequence , interpreters ,",
    "if they are included at all , generally serve as a foil for the superior performance of compiled code @xcite , or else as material for a more breadth - based course on general language implementation @xcite .    on the other hand ,",
    "the construction of interpreters plays a prominent role in many courses on programming language design .",
    "the simplicity of an interpreter s core structure and the close correspondence to a language s semantics makes this a natural teaching tool , both for conceptual organization and for prototypical implementation of various language features @xcite .",
    "abelson and sussman s classic cs1 text @xcite even uses this structure to introduce the structure of a simple compiler , though the correspondence between the two is quickly buried in the details of code generation , and their compiler lacks many real - world features such as a semantic analysis phase .",
    "several undergraduate - level texts on programming language theory make the formal connection between a language s type system and its concrete semantics explicit ( for example , harper @xcite ) .",
    "the correspondence between an interpreter and a type - checker is an easy consequence of this .",
    "pagan proposes the inclusion of material on partial evaluation to derive a code generator from a language s interpreter @xcite .",
    "however , his work in that paper is more focused on the specialization of an interpreter for a program with respect to a file of known input values , and the way in which this can be used to generate a more efficient intermediate representation ( pascal source code ) . he does not address the correspondence between interpretation and semantic analysis",
    "tiger was introduced by andrew appel as a simple yet realistic teaching language for compiler construction @xcite .",
    "it is an imperative language , with a feature set drawn from a simplification of pascal .",
    "it offers a standard assortment of imperative control flow constructs , procedure definition and call , nested variable declaration scopes , and nested procedure definitions , and there is a rudimentary standard library to support string - related operations and user interaction .",
    "data types are limited to integers , strings , arrays , and programmer - defined records .",
    "there is no support for either object - oriented or functional programming features .",
    "@xmath0    following appel s lead , students in our course implement a compiler for tiger from a skeleton distribution , consisting of some utility classes , a collection of classes representing the possible types , and interfaces for important components of code generation , such as stack frames , abstractions of frame access , labels , and so on .",
    "there is a complete set of ast classes , corresponding to the concrete grammar illustrated in figure [ fig : tiger - syn ] .",
    "finally , the distribution includes a pair of interfaces to support traversal of according to the _ visitor pattern_. behaviors that are defined by traversal of an ast implement the appropriate _ visit ( ) _ methods :    .... public interface iabsynvisitor {      void visit(expint e ) ;      void visit(expifelse e ) ;      void visit(explet e ) ;      void visit(expwhile e ) ;              ... ( etc . ) } ....    in turn , each of the ast node classes includes an _ accept ( ) _ method    .... public interface ivisitable {      void accept(iabsynvisitor v ) ; } ....    with each _ accept ( ) _ implementation dispatching the appropriate behavior ( _ i.e. _ , _ visit ( ) _ call ) for an object s type .",
    "for example ,    .... public class explet implements ivisitable {            ...       public void accept(iabsynvisitor v ) {          v.visit(this ) ;      }            ... } ....    a common motivation behind the use of this pattern is the need to defer the definition of one or more operations on a collection of data without having to later modify the definitions of those classes themselves , and at the same time providing some compile - time assurance that the behavior definition is exhaustive on the collection of class definitions .",
    "this need to separate future behavioral commitments from a fixed set of data types is particularly acute in the case of a student compiler project , as students must learn the ast hierarchy weeks before they encounter the last stages of the compiler .",
    "the disadvantage is any implementation of a visitor pattern is , at best , complicated , and the first encounter with this pattern and its multiple redirection of control often proves confusing . to ameliorate this confusion , students first encounter ast traversal through the visitor pattern as they finish learning basic parsing and syntax - directed translation . at this point , they have each built a working grammar specification file with production rules whose associated actions result in the construction of an ast from the concrete source code . among the tools in the standard distribution is a fully implemented pretty - print visitor , which is used to test the generated parsers .",
    "the final day in which we study syntax - directed translation is actually dedicated to the study of this pretty - printer , and through this , students are given an introduction to the visitor pattern .",
    "once parsing is finished , it seems to be customary to move immediately into the next stage of the compiler pipeline , semantic analysis .",
    "this is the approach given in project - based texts such as fischer / leblanc / cytron @xcite and appel @xcite , for example , and it is the one we have until recently used in our course .    at this point in the class , however , it is possible to add a few days of material on interpretation and the structure of an interpreter s implementation . while challenging in its own way ,",
    "a basic interpreter is considerably simpler to understand than a compiler for the same language , particularly if real - world concerns of performance are ignored .",
    "aside from the ast itself , the critical components of interpretation are a domain of runtime values produced by programs , an understanding of the traversal algorithm underlying interpretation , and an _ environment _ _ i.e. _ , a record of the bindings of current names to their values .",
    "the environment is necessary to support the declaration and subsequent use of identifiers , whether they refer to variables , procedures , or type aliases . in a compiler , this is the _ symbol table _ , and efficient construction of these can involve some complicated data structures . in its essence , however , it has a very simple interface , needing only the ability to retrieve the value associated with an identifier , add new identifier / value bindings , and record the entry to and exit from a scope :    .... public class table < t > {      public t get(symbol key ) { ... }      public void put(symbol key , t value ) { ... }        public void beginscope ( ) { ... }      public void endscope ( ) { ... } } ....    our distribution includes a `` semant '' package that provides students with a complete implementation of this class , along with a `` wrapper '' class , env , which adds on a few utility methods .",
    ".... public abstract class env < t > {      public final table < t > env ;        protected static symbol sym(string s ) {          return symbol.symbol(s ) ;      }         ... ( etc . ) } ....    typically , a compilers text will cover the problem of symbol table data structures in some detail , though many courses ( including ours ) elide this . the project distribution used in our class realizes a fairly efficient implementation using hashtables and `` binding '' objects that support fast addition and disposal of scopes .",
    "however , if one wanted students to gain experience implementing such tables on their own , a more straightforward , stack - based prototype could be provided at this point instead .",
    "the declaration of the env class as both generic and reflects the broader theme of this project : each of the `` interpreter - like '' stages of the compiler , semantic analysis , and code generation , will have its own version of an environment . yet where the interpreter uses the environment to store symbol / value bindings , the abstract forms of interpretation will store bindings of symbols to _",
    "value abstractions_. in our work , this is reflected in the fact that the interpreter , semantic analyzer , and code generator all define a comparable hierarchy of entry classes , reflecting the differences across the three uses of the environment .",
    "following appel @xcite , we use an abstract entry superclass and two child entries , varentry and funentry :        the difference is that we have a separate version of this hierarchy for each of the interpretation , semantic analysis , and code generation components .",
    "although each of these stages needs to distinguish bindings of procedure names from ordinary value bindings , the difference in their respective levels of abstraction means that , for example , a varentry ( _ i.e. _ , name / value binding ) for an interpreter means something different from the corresponding varentry during code generation .",
    "it is these entry families that parameterize env declarations , in the concrete environment designed for a stage .",
    "for example , our interpreter uses a representation of `` value '' ( for tiger , this means integers , strings , records , or arrays ) to define the notion of a varentry and funentry , which leads in turn to    .... public class envint extends        tigerc.semant.env<tigerc.semant.interp.entry > {        ...   } ....    finally , there is the interpreter itself .",
    "the version developed for this paper is a single class , which includes a value environment ( envint ) , a utility error message handler , and which implements the ast visitor ( _ iabsynvisitor _ ) , with the result field storing the ` return' value of each visit ( ) call :    .... public class interpv implements iabsynvisitor {      private ivalue result = null ;      private envint env ;            ...      public void visit(expint e ) {          result = new valint(e.value ) ;      }      public void visit(expop e ) {          e.left.accept(this ) ;          ivalue v1 = this.result ;          e.right.accept(this ) ;          ivalue v2 = this.result ;            switch ( e.oper ) {          case plus : {             this.result =                 new valint(((valint ) v1).val                             + ( ( valint ) v2).val ) ;            break ;          }            ...          }      }      public void visit(explet e ) {          env.env.beginscope ( ) ;          for ( decl dec : e.decls ) {              dec.accept(this ) ;          }          e.body.accept(this ) ;          env.env.endscope ( ) ;      }        ... ( etc . ) } ....    it is worth noting the problem of type safety here .",
    "although tiger is a statically typed language , students have not yet learned anything about semantic analysis .",
    "two options are possible here . on the one hand",
    ", we can simply `` cheat '' on the language specification and add easy dynamic checks of safety to the visit ( ) bodies ( or , worse , we can ignore the problem altogether ) .",
    "alternately , we can use the problem of unsafe methods in the interpreter to motivate type checking , with students diving in immediately to the implementation of semantic analysis , though applied here to the interpreter . at present , it is unclear , which of these leads to a smoother outcome in learning semantic analysis implementation .",
    "the interpv class can be given to students as a complete product , with a couple of days devoted to studying its details .",
    "alternately , one might choose a partial distribution , with the expectation that they complete it on their own .",
    "however , the purpose of this digression in the course is to provide a richer basis of study and comprehension for the actual later compiler stages , so it is important that students finish this component of the course with a fully functional interpreter to study , whether that is provided _ a priori _ or _ a posteriori_.",
    "semantic analysis is the last `` filter '' of bad programs before the back end phase(s ) , and languages of a realistic scale ( even one as small as tiger ) include a complicated array of requirements : compatibility of value types with operators , declaration of variables before use ( and use only within a given scope ) , non - assignability of bounded loop counters , enclosing loops for nonstandard jumps such as break , non - circularity of type alias definitions , and so on . at root , however , all of these verification tasks can be understood as the simulation of program execution on a suitable set of abstractions of the possible concrete values .",
    "this is not only true as a theoretical statement @xcite , it is a useful lens for comprehension of the type checking process .",
    "our implementation of semantic analysis is structured to reflect this view in a simple manner .",
    " la appel , the semantic analysis package ( tigerc.semant.analysis ) makes use of a collection of `` type '' objects , ( tigerc.semant.types ) , instead of the ivalue hierarchy of the interpreter .",
    "similarly , it includes the following entry hierarchy :    .... public interface entry { }    public class varentry implements entry {      public final type ty ;      public final boolean assignable ;         ... }    public class funentry implements entry {      public final list < pair < symbol , type > > formals ;      public final type result ;         ... } ....    these value abstractions are used to implement an environment of symbol / type bindings :    .... public class envtc extends     tigerc.semant.env<tigerc.semant.analysis.entry > {        protected final table < type > tenv ;        public envtc ( ) {          tenv = new table < type > ( ) ;            //",
    "bindings for the primitive types .            tenv.put(sym(\"int \" ) , primty.int_t ) ;          tenv.put(sym(\"string \" ) , primty.string_t ) ;            makestdlib ( ) ;      }           ... ( etc . ) } ....    this version of the environment specializes its generic parent with its own , abstract notion of entry . hidden inside is a second symbol table , to support tiger s requirement that an identifier can exist as both a variable and a type name definition .    with these abstractions of value ( the semant.types classes ) and environment , we are ready to implement semantic analysis in a form highly congruent to that of the interpreter :    .... public class semantv implements iabsynvisitor {        private type ty = null ;   // the \" return value \"      private envtc env ;      private errormsg err ;           ...      public void visit(expint e ) {          this.ty = new int ( ) ;      }           public void visit(varsimple v ) {          entry en = env.env.get(v.name ) ;          if ( en = = null ) {              err.error ( ... ) ;              this.ty = error.instance ( ) ;          } else if ( en instanceof funentry ) {              err.error ( ... ) ;              this.ty = error.instance ( ) ;          } else {              varentry var = ( varentry ) en ;              this.ty = var.ty ;           }      }        ... ( etc . ) } ....",
    "in its industrial - strength form , code generation is the most formidable of the stages in a compiler .",
    "when a physical architecture is targeted , it is common to translate the ast into an intermediate representation that , although still tree - structured , more closely resembles the assembly language of real machines . even in the case where the target language is a virtual machine like the jvm",
    ", a realistic compiler must perform extensive data flow analysis and code - improving transformations .    at the core ,",
    "though , is a partial evaluation of the interpreter : literally , a traversal of the ast , for which the result is the machine code that corresponds to the execution steps the interpreter would take .",
    "this is true whether our target is virtual machine code or an intermediate tree language .    in this stage ,",
    "the abstraction of value is not a type but rather a description of the resources that must be laid out for a value , either a register or a stack frame .",
    "for our project , that means an abstraction of _ frames _ and _ access _ within a frame :    .... public interface iframe {      iaccess alloclocal(type t ) ;        iaccess poplocal ( ) ;      // removes and returns the resource allocated at       // the end of this frame .",
    "int frameend ( ) ;      //offset of the first available word in this frame }    public interface iaccess {      int offset ( ) ;      type gettype ( ) ; } ....    to aid in calculating access properties on some machines , we will need to make use of types here , though we only need record them , rather than checking , since they are all presumed correct at this point .",
    "this gives rise to an environment definition abstracted as    .... public class envtrans extends                  tigerc.semant.env<entry > {      public final table < type > tenv ;            ... ( etc . ) }    public class varentry implements entry {      public final type ty ;      public final iaccess access ;        ... }    public class funentry implements entry {        public final list < pair < symbol , type > > formals ;      public final type result ;        private label label ;      private class < ? > extern ;      private iframe frame ;      ... } ....    unfortunately , there are a some practical issues that arise with a straightforward analogy to interpreters here , primarily in the need to distinguish more carefully the use of a variable as an l - value or r - ralue .",
    "the code generated for these is often quite different .",
    "for example , suppose we are targeting jvm code ( as our project does ) . for simple identifiers , we do nt need to put the lefthand - side ( lhs ) value on the stack .",
    "it suffices to compute the righthand side ( rhs ) , then store the value . for array subscripts and record fields ,",
    "however , we need to do a little more work in computing the lhs . too , the address on the record / array must be put on the stack , just below the top ( which will contain the value of the rhs ) .",
    "nonetheless , the interpreter / code generation correspondence is very close :    .... public class jvmgeneratorv implements             tigerc.semant.translate.icodegen ,              tigerc.syntax.absyn.iabsynvisitor {         private iframe frame = new jvmframe ( ) ;      private envtrans env ;       private java.io.printwriter tgtout ;       // target destination for generated code      private type exptype ;       // type of the most recently - visited expression        public void visit(expint e ) {          emitln(this.code , \" ldc \" + e.value ) ;          this.exptype = primty.int_t ;      }           public void visit(expassign e ) {          if ( e.lhs instanceof varsimple ) {              e.rhs.accept(this ) ;                           this.rvaluemode = false ;              e.lhs.accept(this ) ;              this.rvaluemode = true ;          } else {              ...           }          this.exptype = primty.void_t ;      }        public void visit(varsimple x ) {          varentry v = ( varentry ) env.env.get(x.name ) ;          string loadstore =               ( this.rvaluemode ?",
    "\" load \" : \" store \" ) ;            if ( v.ty.coerceto(primty.int_t ) ) {              emitln(this.code , \" i \" + loadstore                         + \" \" + v.access.offset ( ) ) ;          } else {               emitln(this.code , \" a \" + loadstore                         + \" \" + v.access.offset ( ) ) ;          }          this.exptype = v.ty.actual ( ) ;      }          ... } ....",
    "this paper has shown how to use a known set of theoretical connections between a language s interpreter and key stages in the back end of a compiler for that language to structure the last few weeks of a compilers course .",
    "it provides both an elegant , reusable body of code and a set of patterns through which students can organize their understanding of these topics .",
    "future opportunities include the assessment of this approach among a larger population of students , as our own institution is small enough to make substantial data gathering of this kind impractical .",
    "too , there remains the question of other opportunities within the pipeline in which to leverage this analogy . in more advanced courses , for example ,",
    "is it helpful to bring in some of the original insights from abstract interpretation , in order to explain the task of data flow analysis ?",
    "is there a corresponding notion of interpretation of machine code versus abstractions of interpretation on tree - valued intermediate form ?",
    "the prospect of future investigation in these directions is exciting ."
  ],
  "abstract_text": [
    "<S> an undergraduate compilers course poses significant challenges to students , in both the conceptual richness of the major components and in the programming effort necessary to implement them . in this paper , </S>",
    "<S> i argue that a related architecture , the _ interpreter _ </S>",
    "<S> , serves as an effective conceptual framework in which to teach some of the later stages of the compiler pipeline . </S>",
    "<S> this framework can serve both to unify some of the major concepts that are taught in a typical undergraduate course and to structure the implementation of a semester - long compiler project . </S>"
  ]
}