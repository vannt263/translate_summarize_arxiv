{
  "article_text": [
    "we study the admission control problem in general graphs with edge capacities .",
    "an online algorithm can receive a sequence of communications requests on a virtual path , that may be accepted or rejected , while staying within the capacity limitations .",
    "this problem has typically been studied as a benefit problem .",
    "this means that the online algorithm has to be competitive with respect to the number of accepted requests .",
    "a problem with this objective function is that in some cases an online algorithm with a good competitive ratio may reject the vast majority of the requests , whereas the optimal solution rejects only a small fraction of them .    in this paper",
    "we consider the goal of minimizing the number of rejected requests , which was first studied in @xcite .",
    "this approach is suitable for applications in which rejections are intended to be rare events .",
    "a situation in which a significant fraction of the requests is rejected even by the optimal solution means that the network needs to be upgraded .",
    "we consider preemptive online algorithms for the admission control problem .",
    "allowing preemption is necessary for achieving reasonable bounds for the competitive ratio .",
    "each request arrives together with the path it should be routed on .",
    "the admission control algorithm decides whether to accept or reject it .",
    "an online algorithm for both admission control and routing easily admits a trivial lower bound @xcite .    * the admission control to minimize rejections problem .",
    "* we now formally define the admission control problem .",
    "the input consist of the following :    * a directed graph @xmath12 , where @xmath13 .",
    "each edge @xmath14 has an integer capacity @xmath15 .",
    "we denote @xmath16 . *",
    "a sequence of requests @xmath17 each of which is a simple path in the graph .",
    "every request @xmath18 has a cost @xmath19 associated with it .    a feasible solution for the problem must assure that for every edge @xmath14",
    ", the number of accepted requests whose paths contain @xmath14 is at most its capacity @xmath20 .",
    "the goal is to find a feasible solution of minimum cost of the rejected requests .",
    "the online algorithm is given requests one at a time , and must decide whether to accept or reject each request .",
    "it is also allowed to preempt a request , i.e. to reject it after already accepting it , but it can not accept a request after rejecting it .",
    "let @xmath21 be a feasible solution having minimum cost @xmath22 .",
    "an algorithm is @xmath23-competitive if the total cost of the requests rejected by this algorithm is at most @xmath24 .    * previous results for admission control .",
    "* tight bounds were achieved for the admission control problem , where the goal is to maximize the number of accepted requests .",
    "awerbuch , azar and plotkin @xcite provide an @xmath25-competitive algorithm for general graphs .",
    "for the admission control problem on a tree , @xmath26-competitive randomized algorithms appear in @xcite , where @xmath27 is the diameter of the tree .",
    "adler and azar presented a constant - competitive preemptive algorithm for admission control on the line @xcite .    the admission control to minimize rejections problem",
    "was studied by blum , kalai and kleinberg in @xcite , where two deterministic algorithms with competitive ratios of @xmath28 and @xmath29 are given ( @xmath1 is the number of edges in the graph and @xmath2 is the maximum capacity ) .",
    "they raised the question of whether an online algorithm with polylogarithmic competitive ratio can be obtained .",
    "we note that one can combine an algorithm for maximizing throughput of accepted requests and an algorithm for minimizing rejections and get one algorithm which achieves both simultaneously with slightly degrading the competitive ratio @xcite .    in this paper",
    "we show that the admission control to minimize rejections problem is a generalization of the online set cover with repetitions problem described below :    * the online set cover with repetitions problem .",
    "* the online set cover problem is defined as follows : let @xmath30 be a ground set of @xmath4 elements , and let @xmath31 be a family of subsets of @xmath30 , @xmath32 .",
    "each @xmath33 has a non - negative cost associated with it .",
    "an adversary gives elements to the algorithm from @xmath30 one by one .",
    "each element of @xmath30 can be given an arbitrary number of times , not necessarily consecutively .",
    "an element should be covered by a number of sets which is equal to the number of times it arrived .",
    "we assume that the elements of @xmath30 and the members of @xmath31 are known in advance to the algorithm , however , the elements given by the adversary are not known in advance .",
    "the objective is to minimize the cost of the sets chosen by the algorithm .    * previous results for online set cover .",
    "* the offline version of the set cover problem is a classic np - hard problem that was studied extensively , and the best approximation factor achievable for it in polynomial time ( assuming @xmath34 ) is @xmath35 @xcite .",
    "the basic online set cover problem , where repetitions are not allowed , was studied in @xcite .",
    "a different variant of the problem , dealing with maximum benefit , is presented in @xcite .",
    "an @xmath36-competitive deterministic algorithm for the online set cover problem was given by @xcite where @xmath4 is the number of elements and @xmath1 is the number of sets .",
    "a lower bound of @xmath37 was also shown for any deterministic online algorithm .",
    "a recent result of feige and korman @xcite establishes a lower bound of @xmath6 for the competitive ratio of any randomized _ polynomial _ time algorithm for the online set cover problem , under the @xmath7 assumption .",
    "they also prove the same lower bound for any deterministic _ polynomial _ time algorithm , under the @xmath34 assumption .    * our results . *",
    "the main result we give in this paper is an @xmath0-competitive randomized algorithm for the admission control to minimize rejections problem .",
    "this settles the open question raised by blum et al .",
    "for the unweighted case , where all costs are equal to 1 , we slightly improve this bound and give an @xmath38-competitive randomized algorithm ,    we present a simple reduction between online set cover with repetitions and the admission control to minimize rejections problem .",
    "this implies an @xmath39-competitive randomized algorithm for the online set cover with repetitions problem .",
    "for the unweighted case ( all costs are equal to @xmath40 ) , we get an @xmath5-competitive randomized algorithm .",
    "this matches the lower bound of @xmath6 given by feige and korman .",
    "their results also imply a lower bound of @xmath41 for the competitive ratio of any randomized _ polynomial _ time algorithm for the admission control to minimize rejections problem ( assuming @xmath7 ) .",
    "the derandomization techniques used in @xcite for the online set cover problem do not seem to apply here .",
    "this is why we also consider the bicriteria version of the online set cover with repetition problem . for a given constant @xmath8 ,",
    "the online algorithm is required to cover each element by a fraction of @xmath42 times the number of its appearances .",
    "specifically , at any point of time , if an element has been requested @xmath11 times so far , then the optimal solution covers it by @xmath11 different sets , whereas the online algorithm covers it by @xmath10 different sets .",
    "we give an @xmath5-competitive deterministic bicriteria algorithm for this problem .",
    "* techniques . * the techniques we use",
    "follow those of @xcite together with some new ideas .",
    "we start with an online fractional solution which is monotone increasing during the algorithm .",
    "then , the fractional solution is converted into a randomized algorithm .",
    "interestingly , to get a deterministic bicriteria algorithm we use a different fractional algorithm than the one used for the randomized algorithm .",
    "in this section we describe a fractional algorithm for the problem .",
    "a fractional algorithm is allowed to reject a fraction of a request @xmath18 .",
    "we use a weight @xmath43 for this fraction .",
    "specifically , if @xmath44 , we reject with percentage of precisely @xmath43 .",
    "if @xmath45 , then the request is completely rejected . at any stage of the fractional algorithm we will use the following notation :    * @xmath46 will denote the set of requests that arrived so far whose paths contain the edge @xmath14 .",
    "* @xmath47 will denote @xmath48 .",
    "* @xmath49 will denote the requests from @xmath46 that have not been fully rejected ( requests @xmath18 for which @xmath50 ) .",
    "* @xmath51 will denote the excess of edge @xmath14 caused by the requests in @xmath49 .",
    "the requirement from a fractional algorithm is that for every edge @xmath14 , @xmath53 the cost associated with a fractional algorithm is defined to be @xmath54 .",
    "we will now describe an @xmath55-competitive algorithm for the problem , even versus a fractional optimum .",
    "the cost of the optimal fractional solution , @xmath22 is denoted by @xmath56 .",
    "we may assume , by doubling , that the value of @xmath56 is known up to a factor of @xmath57 . to determine the initial value of @xmath56 we look for the first time in which we must reject a request from an edge @xmath14 .",
    "we can start guessing @xmath58 , and then run the algorithm with this bound on the optimal solution .",
    "if it turns out that the value of the optimal solution is larger than our current guess for it , ( that is , the cost exceeds @xmath59 ) , then we `` forget '' about all the request fractions rejected so far , update the value of @xmath56 by doubling it , and continue .",
    "we note that the cost of the request fractions that we have `` forgotten '' about can increase the cost of our solution by at most a factor of @xmath57 , since the value of @xmath56 was doubled in each step .",
    "we thus assume that @xmath56 is known .",
    "denote by @xmath60 the requests with cost exceeding @xmath61 .",
    "the optimal fractional solution can reject a total fraction of at most @xmath62 out of the requests of @xmath60 .",
    "hence , when an edge is requested more than its capacity , the fractional optimum must reject a total fraction of at least @xmath62 out of the requests not in @xmath60 whose paths contain the edge . by doubling the fraction of rejection for all the requests not in @xmath60 ( keeping fractions to be at most @xmath40 ) and completely accepting all the requests in @xmath60",
    ", we get a feasible fractional solution whose cost is at most twice the optimum .",
    "hence , the online algorithm can always completely accept requests of cost exceeding @xmath61 ( and adjust the edge capacities @xmath20 accordingly ) .",
    "denote by @xmath63 the requests with cost at most @xmath64 .",
    "we claim that we can completely reject all the requests from @xmath63 . for each edge @xmath14 , the optimal solution can accept a total fraction of at most @xmath2 out of the requests whose paths contain the edge @xmath14 , and therefore it can accept a total fraction of at most @xmath65 requests .",
    "the fractions of requests accepted out of @xmath63 have total cost at most @xmath66 .",
    "it follows that the optimal solution pays at least @xmath67 for the fractions of requests out of @xmath63 that it rejected .",
    "therefore , the online algorithm can reject all the requests in @xmath63 and pay @xmath68 .",
    "if @xmath69 , then this adds only @xmath70 to the cost of the online algorithm . if @xmath71 , then @xmath72 , so the online algorithm is @xmath57-competitive with respect to the requests in @xmath63 .    by the above arguments ,",
    "all the requests of cost smaller than @xmath64 or greater than @xmath61 are rejected immediately or accepted permanently ( edge capacities are decreased in this case ) , respectively .",
    "an algorithm needs to handle only requests of cost between @xmath64 and @xmath61 .",
    "we normalize the costs so that the minimum cost is @xmath40 and the maximum cost is @xmath73 , and fix @xmath56 appropriately .",
    "the algorithm maintains a weight @xmath43 for each request @xmath18 .",
    "the weights can only increase during the run of the algorithm .",
    "initially @xmath74 for all the requests .",
    "assume now that the algorithm receives a request @xmath18 for a path of cost @xmath75 .",
    "for each edge @xmath14 , we update @xmath46 , @xmath49 and @xmath51 according to the definitions given above . the following is performed for all the edges @xmath14 of the path of @xmath18 , in an arbitrary order .    1 .",
    "if @xmath76 , then do nothing .",
    "2 .   else , while @xmath77 , perform a _ weight augmentation _ : 1 .   for each @xmath78 , if @xmath74 , then set @xmath79.[alg1 ] 2 .   for each @xmath78 , @xmath80.[alg2 ] 3 .",
    "update @xmath49 and @xmath51 .",
    "note that the fractional algorithm starts with all weights equal to zero .",
    "this is necessary , since the online algorithm must reject @xmath81 requests in case the optimal solution rejects @xmath81 requests .",
    "hence , the algorithm is competitive for @xmath82 , and from now on we assume without loss of generality that @xmath83 . in the following",
    "we analyze the performance of the algorithm .",
    "[ frac_steps ] the total number of weight augmentations performed during the algorithm is at most @xmath84 .",
    "consider the following potential function : @xmath85 where @xmath86 is the weight of the request @xmath18 in the optimal fractional solution .",
    "we now show three properties of @xmath87 :    * the initial value of the potential function is : @xmath88 . * the potential function never exceeds @xmath89 . * in each weight augmentation step , the potential function is multiplied by at least @xmath57 .",
    "the first two properties follow directly from the initial value and from the fact that no request gets a weight of more than @xmath90 . consider an iteration in which the adversary gives a request @xmath18 with cost @xmath75 .",
    "now suppose that a weight augmentation is performed for an edge @xmath14 .",
    "we must have @xmath91 since the optimal solution must satisfy the capacity constraint .",
    "thus , the potential function is multiplied by at least : @xmath92 the first inequality follows since for all @xmath93 and @xmath94 , @xmath95 and the last inequality follows since @xmath96 .",
    "it follows that the total number of weight augmentation steps is at most : @xmath97    [ frac_comp ] for the weighted case , the fractional algorithm is @xmath98-competitive . in case",
    "all the costs are equal to @xmath40 , the algorithm is @xmath99-competitive .",
    "the cost associated with the online algorithm is @xmath100 , which we will denote by @xmath101 .",
    "consider a weight augmentation step performed for an edge @xmath14 . in step [ alg1 ] of the algorithm ,",
    "the weights of at most @xmath29 requests change from @xmath81 to @xmath102 .",
    "this is because before the current request arrived , there could have been at most @xmath2 requests containing the edge @xmath14 and having @xmath74 ( the maximum capacity is @xmath2 ) .",
    "since the maximum cost is @xmath103 , the total increase of @xmath101 in step [ alg1 ] of the algorithm is at most @xmath104 . if follows that in step [ alg1 ] , the quantity @xmath105 can increase by at most @xmath106 .",
    "a weight augmentation is performed as long as @xmath107 . before step [ alg2 ]",
    "we have that @xmath108 .",
    "thus , the total increase of @xmath101 in step [ alg2 ] of the algorithm does not exceed @xmath109 it follows that the total increase of @xmath101 in a weight augmentation step is at most @xmath110 . using lemma [ frac_steps ] which bounds the number of augmentation steps ,",
    "we conclude that the algorithm is @xmath111-competitive .    for the weighted case",
    ", we saw that the input can be transformed so that @xmath112 , which implies that the algorithm is @xmath98-competitive . in case",
    "all the costs are equal to @xmath40 , @xmath103 is also equal to @xmath40 and the algorithm is @xmath99-competitive .",
    "we describe in this section an @xmath0-competitive randomized algorithm for the weighted case and a slightly better @xmath38-competitive randomized algorithm for the unweighted case .",
    "the algorithm maintains a weight @xmath43 for each request @xmath18 , exactly like the fractional algorithm .",
    "assume now that the algorithm receives a request @xmath18 with cost @xmath75 .",
    "the following is performed in this case .    1 .",
    "perform all the weight augmentations according to the fractional algorithm .",
    "2 .   reject all requests whose weight is at least @xmath113.[rand2 ] 3 .",
    "for every request @xmath114 , if its weight @xmath115 increased by @xmath116 , then reject the request @xmath114 with probability @xmath117.[rand1 ] 4 .",
    "if the current request @xmath18 can not be accepted ( some edge would be over capacity ) , then reject the request .",
    "else , accept the request @xmath18.[rand3 ]    we can assume that @xmath118 , the total number of requests whose paths contain a specific edge @xmath14 , is less than @xmath119 . to see this , note that the fractional algorithm normalizes the costs so that the minimum cost is @xmath40 and the maximum cost is at most @xmath120 . if @xmath121 , then since the optimal solution can accept at most @xmath2 requests from @xmath46 , it must pay a cost of at least @xmath122 for requests rejected out of @xmath46 , where @xmath123 is the total cost of these requests .",
    "the online algorithm can reject all the requests in @xmath46 , pay @xmath123 and it will still be @xmath57-competitive with respect to the requests in @xmath46 , since @xmath124 .",
    "[ rand_comp ] for the weighted case , the randomized algorithm is @xmath125-competitive .",
    "denote by @xmath126 the cost of the fractional algorithm .",
    "the expected cost of requests rejected in step [ rand1 ] of the algorithm is at most @xmath127 .",
    "the cost of requests rejected in step [ rand2 ] has the same upper bound .",
    "we now calculate the probability for a request @xmath114 to be rejected in step [ rand3 ] .",
    "this can happen only if the path of request @xmath114 contains an edge @xmath14 for which @xmath128 but the randomized algorithm rejected less than @xmath51 requests whose paths contain the edge @xmath14 .",
    "all the requests with weight at least @xmath113 are rejected for sure , so we can assume that @xmath129 for all @xmath130 .",
    "suppose that @xmath78 and that during all runs of step [ rand1 ] of the algorithm the request @xmath18 has been rejected with probabilities @xmath131 , where @xmath132 .",
    "the probability that @xmath18 will be rejected is at least @xmath133 the last inequality follows since for all @xmath134 , @xmath135 .",
    "the number of requests in @xmath49 which were rejected by the algorithm is a random variable whose value is the sum of mutually independent @xmath136-valued random variables and its expectation is at least @xmath137 . by chernoff bound ( c.f .",
    ", e.g. , @xcite ) , the probability for this random variable to get a value less than @xmath138 is at most @xmath139 for every @xmath140 .",
    "therefore , the probability to be less than @xmath51 is at most @xmath141 the request costs were normalized , so that the maximum cost is at most @xmath120 .",
    "each edge is contained in the paths of at most @xmath119 requests .",
    "therefore , the expected cost of requests which are rejected in step [ rand3 ] because of this edge is at most @xmath142 .",
    "thus , the total expected cost of requests rejected in step [ rand3 ] is @xmath143 .",
    "the result now follows from theorem [ frac_comp ] .",
    "for the unweighted case we slightly change the algorithm as follows . in step [ rand1 ] of the algorithm we reject a request with probability @xmath144 , and in step [ rand2 ] we reject all the requests whose weight is at least @xmath145 .",
    "[ unweighted_rand_comp ] for the unweighted case , the randomized algorithm is @xmath146-competitive .",
    "following the proof of theorem [ rand_comp ] , we get that the probability for an edge to cause a specific request to be rejected in step [ rand3 ] of the randomized algorithm is at most @xmath147    denote by @xmath148 the quantity @xmath149 .",
    "hence , @xmath148 is the maximum excess capacity in the network .",
    "the total expected cost of requests rejected in step [ rand3 ] is at most @xmath150 .",
    "it is obvious that the optimal solution must reject at least @xmath148 requests .",
    "the result now follows from theorem [ frac_comp ] .",
    "we now describe the reduction between online set cover and admission control .",
    "suppose we are given the following input to the online set cover with repetitions problem : @xmath30 is a ground set of @xmath4 elements and @xmath31 is a family of @xmath1 subsets of @xmath30 , with a positive cost @xmath151 associated with each @xmath33 .",
    "the instance of the admission control to minimize rejections problem is constructed as follows : the graph @xmath12 has an edge @xmath152 for each element @xmath153 .",
    "the capacity of the edge @xmath152 is defined to be the number of sets that contain the element @xmath154 .",
    "the maximum capacity is therefore at most @xmath1 .",
    "the requests are given to the admission control algorithm in two phases .",
    "in the first phase , before any element is given to the online set cover algorithm , we generate @xmath1 requests to the admission control online algorithm . for every @xmath33 ,",
    "the request consists of all the edges @xmath152 such that @xmath155 .",
    "the online algorithm can accept all the requests and this will cause the edges to reach their full capacity .    in the second phase , each time the adversary gives an element @xmath154 to the online set cover algorithm , we generate a request which consists of the one edge @xmath152 and give it to the admission control algorithm . in case",
    "the request caused the edge @xmath152 to be over capacity , the algorithm will have to reject one request in order to keep the capacity constraint .    in case there is a feasible cover for the input given to the online set cover problem , there is no reason for the admission control algorithm to reject requests that were given in the second phase .",
    "this is because requests in the second phase consist of only one edge .",
    "thus , we can assume that the admission control algorithm rejects only requests given in the first phase , which correspond to subsets of @xmath30 .",
    "it is easy to see that the requests rejected by the admission control algorithm correspond to a legal set cover .",
    "we reduced an online set cover problem with @xmath4 elements and @xmath1 sets to an admission control problem with @xmath4 edges and maximum capacity at most @xmath1 .",
    "the fact that the requests we generated are not simple paths in the graph can be easily fixed by adding extra edges .",
    "in this section we describe , given any constant @xmath8 , an @xmath5-competitive deterministic bicriteria algorithm that covers each element by at least @xmath10 sets , where @xmath11 is the number of times the element has been requested , whereas the optimum covers it @xmath11 times .",
    "we assume for simplicity that all the sets have cost equal to 1",
    ". the result can be easily generalized for the weighted case using techniques from @xcite .",
    "the algorithm maintains a weight @xmath156 for each @xmath33 .",
    "initially @xmath157 for each @xmath33 .",
    "the weight of each element @xmath153 is defined as @xmath158 , where @xmath159 denotes the collection of sets containing element @xmath154 .",
    "initially , the algorithm starts with the empty cover @xmath160 . for each @xmath153",
    ", we define @xmath161 , which is the number of times element @xmath154 is covered so far .",
    "the following potential function is used throughout the algorithm :    @xmath162    we give a high level description of a single iteration of the algorithm in which the adversary gives an element @xmath154 and the algorithm chooses sets that cover it .",
    "we denote by @xmath11 the number of times that the element @xmath154 has been requested so far .    1 .",
    "if @xmath163 , then do nothing .",
    "2 .   else , while @xmath164 , perform a _ weight augmentation _ : 1 .   for each @xmath165 , @xmath166.[detalg1 ] 2 .   add to @xmath167 all the subsets for which @xmath168.[detalg2 ] 3 .",
    "choose from @xmath159 at most @xmath169 sets to @xmath167[detalg3 ] so that the value of the potential function @xmath87 does not exceed its value before the weight augmentation .    in the following",
    "we analyze the performance of the algorithm and explain which sets to add to the cover @xmath167 in step [ detalg3 ] of the algorithm .",
    "the cost of the optimal solution @xmath170 is denoted by @xmath56 .",
    "[ det_steps ] the total number of weight augmentations performed during the algorithm is at most @xmath171 .",
    "consider the following potential function : @xmath172 we now show three properties of @xmath173 :    * the initial value of the potential function is : @xmath174 .",
    "* the potential function never exceeds @xmath175 . * in each weight augmentation step , the potential function is multiplied by at least @xmath176 .",
    "the first two properties follow directly from the initial value and from the fact that no request gets a weight of more than @xmath177 .",
    "consider an iteration in which the adversary gives an element @xmath154 for the @xmath11th time .",
    "now suppose that a weight augmentation is performed for element @xmath154 .",
    "we must have that @xmath164 , which means that the online algorithm has covered element @xmath154 less than @xmath10 times .",
    "the optimal solution @xmath21 covers element @xmath154 at least @xmath11 times , which means that there are at least @xmath178 subsets of @xmath21 containing @xmath154 which were not chosen yet .",
    "thus , in step [ detalg1 ] of the algorithm the potential function is multiplied by at least : @xmath179 it follows that for fixed @xmath180 the total number of weight augmentation steps is at most :    @xmath181    [ det_poten ] consider an iteration in which a weight augmentation is performed .",
    "let @xmath182 and @xmath183 be the values of the potential function @xmath87 before and after the iteration , respectively .",
    "then , there exist at most @xmath169 sets that can be added to @xmath167 during the iteration such that @xmath184 .",
    "furthermore , the value of the potential function never exceeds @xmath185 .",
    "the proof is by induction on the iterations of the algorithm .",
    "initially , the value of the potential function @xmath87 is less than @xmath186 .",
    "suppose that in the iteration the adversary gives element @xmath154 for the @xmath11th time . for each set @xmath187 ,",
    "let @xmath188 and @xmath189 denote the weight of @xmath190 before and after the iteration , respectively .",
    "define @xmath191 . by the induction hypothesis , we know that @xmath192 , because otherwise @xmath182 would have been greater than @xmath185 .",
    "thus , @xmath193 .",
    "this means that @xmath194 .",
    "we now explain which sets from @xmath159 are added to @xmath167 .",
    "repeat @xmath169 times : choose at most one set from @xmath159 such that each set @xmath187 is chosen with probability @xmath195 .",
    "( this can be implemented by choosing a number uniformly at random in [ 0,1 ] , since @xmath196 . )",
    "consider an element @xmath197 .",
    "let the weight of @xmath198 before the iteration be @xmath199 and let the weight after the iteration be @xmath200 .",
    "element @xmath198 contributes before the iteration to the potential function the value @xmath201 . in each random choice , the probability that we do not choose a set containing element @xmath198 is @xmath202 .",
    "the probability that this happens in all the @xmath169 random choices is therefore @xmath203 .",
    "note that @xmath204 . in case",
    "we choose a set containing element @xmath198 , then @xmath205 will increase by at least @xmath40 and the contribution of element @xmath198 to the potential function will be at most @xmath206 .",
    "therefore , the expected contribution of element @xmath198 to the potential function after the iteration is at most    @xmath207    where to justify the last inequality , we prove that @xmath208 for every @xmath209 . to show this we note that @xmath210 and @xmath211 .",
    "this implies that @xmath212 for every @xmath209 .",
    "we can conclude that @xmath213 for every @xmath209 , as needed .    by linearity of expectation",
    "it follows that @xmath214 \\leq \\phi_s$ ] .",
    "hence , there exists a choice of at most @xmath169 sets such that @xmath184 .",
    "the choices of the various sets @xmath190 to be added to @xmath167 can be done deterministically and efficiently , by the method of conditional probabilities , c.f .",
    ", e.g. , @xcite , chapter 15 .",
    "after each weight augmentation , we can greedily add sets to @xmath167 one by one , making sure that the potential function will decrease as much as possible after each such choice .",
    "[ det_comp ] the deterministic algorithm for online set cover is @xmath9-competitive .",
    "it follows from lemma [ det_steps ] that the number of iterations is at most @xmath171 . by lemma [ det_poten ] , in each iteration we choose at most @xmath169 sets to @xmath167 in step [ detalg3 ] of the algorithm .",
    "the sets chosen is step [ detalg2 ] of the algorithm are those which have weight at least @xmath40 .",
    "the sum of weights of all the sets is initially @xmath62 and it increases by at most @xmath62 in each weight augmentation .",
    "this means that at the end of the algorithm , there can be only @xmath171 sets whose weight is at least @xmath40 .",
    "therefore , the total number of sets chosen by the algorithm is as claimed .",
    "* an interesting open problem is to decide if the algorithm presented here for the admission control problem can be derandomized . * recently , feige and korman established a lower bound of @xmath6 for the competitive ratio of any randomized polynomial time algorithm for the online set cover problem , under the @xmath7 assumption .",
    "it is interesting to decide whether this lower bound applies for superpolynomial time algorithms as well . *",
    "the algorithms we gave for the admission control problem did not use the fact that the requests are simple paths in the graph .",
    "all the algorithms treated a request as an arbitrary subset of edges .",
    "b.  awerbuch , y.  azar , a.  fiat , and t.  leighton .",
    "making commitments in the face of uncertainty : how to pick a winner almost every time . in _ proc .",
    "28th acm symp . on theory of computing _ , pages 519530 , 1996 .",
    "b.  awerbuch , r.  gawlick , t.  leighton , and y.  rabani . on - line",
    "admission control and circuit routing for high performance computation and communication . in _ proc .",
    "35th ieee symp . on found . of comp . science _ , pages 412423 , 1994 .",
    "y.  azar , a.  blum , and y.  mansour .",
    "combining online algorithms for rejection and acceptance . in _ proceedings of the 15th annual acm symposium on parallelism in algorithms and architectures _",
    ", pages 159163 , 2003 .",
    "d.  bunde and y.  mansour .",
    "improved combination of online algorithms for acceptance and rejection . in _ proceedings of the 16th annual acm symposium on parallelism in algorithms and architectures _ ,",
    "pages 265266 , 2004 ."
  ],
  "abstract_text": [
    "<S> we study the admission control problem in general networks . </S>",
    "<S> communication requests arrive over time , and the online algorithm accepts or rejects each request while maintaining the capacity limitations of the network . the admission control problem has been usually analyzed as a benefit problem , where the goal is to devise an online algorithm that accepts the maximum number of requests possible . </S>",
    "<S> the problem with this objective function is that even algorithms with optimal competitive ratios may reject almost all of the requests , when it would have been possible to reject only a few . </S>",
    "<S> this could be inappropriate for settings in which rejections are intended to be rare events .    in this paper </S>",
    "<S> , we consider preemptive online algorithms whose goal is to minimize the number of rejected requests . </S>",
    "<S> each request arrives together with the path it should be routed on . </S>",
    "<S> we show an @xmath0-competitive randomized algorithm for the weighted case , where @xmath1 is the number of edges in the graph and @xmath2 is the maximum edge capacity . for the unweighted case </S>",
    "<S> , we give an @xmath3-competitive randomized algorithm . </S>",
    "<S> this settles an open question of blum , kalai and kleinberg raised in @xcite . </S>",
    "<S> we note that allowing preemption and handling requests with given paths are essential for avoiding trivial lower bounds .    </S>",
    "<S> the admission control problem is a generalization of the online set cover with repetitions problem , whose input is a family of @xmath1 subsets of a ground set of @xmath4 elements . </S>",
    "<S> elements of the ground set are given to the online algorithm one by one , possibly requesting each element a multiple number of times . </S>",
    "<S> ( if each element arrives at most once , this corresponds to the online set cover problem . ) </S>",
    "<S> the algorithm must cover each element by different subsets , according to the number of times it has been requested .    </S>",
    "<S> we give an @xmath5-competitive randomized algorithm for the online set cover with repetitions problem . </S>",
    "<S> this matches a recent lower bound of @xmath6 given by feige and korman for the competitive ratio of any randomized _ polynomial _ time algorithm , under the @xmath7 assumption . </S>",
    "<S> given any constant @xmath8 , an @xmath9-competitive deterministic bicriteria algorithm is shown that covers each element by at least @xmath10 sets , where @xmath11 is the number of times the element is covered by the optimal solution .    </S>",
    "<S> [ routing protocols ] </S>"
  ]
}