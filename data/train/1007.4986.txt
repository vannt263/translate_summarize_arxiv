{
  "article_text": [
    "during the last decade , answer - set programming ( asp ) has become a well - acknowledged paradigm for declarative problem solving .",
    "although there exist efficient solvers ( see , e.g. ,  @xcite for an overview ) and a considerable body of literature concerning the theoretical foundations of asp , comparably little effort has been spent on methods to support the development of asp programs .",
    "especially novice programmers , tempted by the intuitive semantics and expressive power of asp , may get disappointed and discouraged soon when some observed program behaviour diverges from his or her expectations . unlike for other programming languages like java or c++",
    ", there is currently little support for _ debugging _ a program in asp , i.e. ,  methods to _ explain _ and _ localise _ unexpected observations .",
    "this is a clear shortcoming of asp and work in this direction has already started  @xcite .",
    "most of the current debugging approaches for asp rely on declarative strategies , focusing on _ conceptual errors _ of programs , i.e. ,  mismatches between the intended meaning and the actual meaning of a program .",
    "in fact , an elegant realisation of declarative debugging is to use asp itself to debug programs in asp .",
    "this has been put forth , e.g. ,  in the approaches of  @xcite and  @xcite .",
    "while the former uses a `` tagging '' method to decompose a program and applying various debugging queries , the latter is based on a meta - programming technique , i.e. ,  using a program over a meta - language to manipulate a program over an object language ( in this case , both the meta - language and the object language are instances of asp ) .",
    "such techniques have the obvious benefits of allowing ( i )  to use reliable state - of - the - art asp solvers as back - end reasoning engines and ( ii )  to stay within the same paradigm for both the programming and debugging process .",
    "indeed , both approaches are realised by the system ` spock `  @xcite .",
    "however , like most other asp debugging proposals , ` spock ` can deal only with propositional programs which is clearly a limiting factor as far as practical applications are concerned .    in this paper",
    ", we present a debugging method for non - ground programs following the methodology of the meta - programming approach of  @xcite for propositional programs .",
    "that is to say , we deal with the problem of finding reasons why some interpretation is _ not _ an answer set of a given program .",
    "this is addressed by referring to a model - theoretic characterisation of answer sets due to @xcite : an interpretation @xmath0 is not an answer set of a program @xmath1 iff ( i )  some rule in @xmath1 is not classically satisfied by @xmath0 or ( ii )  @xmath0 contains some loop of @xmath1 that is unfounded by @xmath1 with respect to  @xmath0 .",
    "intuitively , item  ( ii ) states that some atoms in @xmath0 are not justified by @xmath1 in the sense that no rules in @xmath1 can derive them or that some atoms are in @xmath0 only because they are derived by a set of rules in a circular way  like the _ ouroboros _ , the ancient symbol of a dragon biting its own tail that represents cyclicality and eternity .",
    "this characterisation seems to be quite natural and intuitive for _ explaining _ why some interpretation is not an answer set .",
    "furthermore , a particular benefit is that it can ease the subsequent _ localisation _ of errors since the witnesses why an interpretation is not an answer set , like rules which are not satisfied , unfounded atoms , or cyclic rules responsible for unfounded loops , can be located in the program or the interpretation .",
    "although , at first glance , one may be inclined to directly apply the original approach of  @xcite to programs with variables by simply grounding them in a preprocessing step , one problem in such an endeavour is that then it is not immediate clear how to relate explanations for the propositional program to the non - ground program .",
    "the more severe problem , however , is that the grounding step requires exponential space and time with respect to  the size of the problem instance which yields a mismatch of the overall complexity as checking whether an interpretation is an answer set of some ( non - ground ) program is complete for @xmath2  @xcite , and thus the complementary problem why some interpretation is not an answer set is complete for @xmath3our method to decide this problem accounts for this complexity bound and avoids exponential space requirements .",
    "indeed , we devise a _ uniform _ encoding of our basic debugging problem in terms of a _",
    "fixed _ disjunctive logic program @xmath4 and an efficient reification of a problem instance as a set @xmath5 of facts , where @xmath1 is the program to be debugged and @xmath0 is the interpretation under consideration .",
    "explanations why @xmath0 is not an answer set of @xmath1 are then obtained by the answer sets of @xmath6 .",
    "we stress that the definition of @xmath4 is non - trivial : while the meta - program in the approach of  @xcite for debugging propositional disjunctive programs could be achieved in terms of a normal non - ground program , _ by uniformly encoding a @xmath3 property , we reach the very limits of disjunctive asp _ and have to rely on advanced saturation techniques that inherently require disjunctions in rule heads  @xcite .    currently , our approach handles disjunctive logic programs with constraints , integer arithmetic , comparison predicates , and strong negation , thus covering a practically relevant program class .",
    "further language constructs , in particular aggregates and weak constraints , are left for future work .",
    "we deal with _ disjunctive logic programs _ which are finite sets of rules of form @xmath7 where @xmath8 , `` @xmath9 '' denotes _",
    "default negation _ , and all @xmath10 are literals over a function - free first - order language @xmath11 . a literal is an atom possibly preceded by the _ strong negation _",
    "symbol @xmath12 . in the sequel",
    ", we assume that @xmath11 will be implicitly defined by the considered programs . for a rule @xmath13 as above",
    ", we define the _ head _ of @xmath13 as @xmath14 , the _ positive body _ as @xmath15 , and the _ negative body _ as @xmath16 .",
    "if @xmath17 , @xmath13 is a _",
    "fact _ ; if @xmath13 contains no disjunction , @xmath13 is _ normal _ ; and if @xmath18 and @xmath19 , @xmath13 is a _",
    "constraint_. for facts , we will omit the symbol @xmath20 . a literal , rule , or program is _ ground _ if it contains no variables .",
    "furthermore , a program is normal if all rules in it are normal . finally , we allow arithmetic and comparison predicate symbols @xmath21 , @xmath22 , @xmath23 , @xmath24 , @xmath25 , @xmath26 , @xmath27 , and  @xmath28 in programs , but these may appear only positively in rule bodies .",
    "let @xmath29 be a set of constants .",
    "substitution over _ @xmath29 is a function @xmath30 assigning each variable an element of @xmath29 .",
    "we denote by @xmath31 the result of applying @xmath30 to an expression @xmath32 .",
    "the _ grounding _ of a program @xmath1 relative to its herbrand universe , denoted by @xmath33 , is defined as usual .    an _ interpretation _",
    "@xmath0 ( over some language @xmath11 ) is a finite and consistent set of ground literals ( over @xmath11 ) that does not contain any arithmetic or comparison predicates .",
    "recall that consistency means that @xmath34 , for any atom @xmath35 .",
    "the satisfaction relation , @xmath36 , between @xmath0 and a ground atom , a literal , a rule , a set of literals , or a program @xmath37 is defined in the usual manner .",
    "note that the presence of arithmetic and comparison operators implies that the domain of our language will normally include natural numbers as well as a linear ordering , @xmath38 , for evaluating the comparison relations ( which coincides with the usual ordering in case of constants which are natural numbers ) .    for any ground program @xmath1 and any interpretation @xmath0 , the _ reduct _ , @xmath39 , of @xmath1 with respect to  @xmath0 @xcite is defined as @xmath40 .",
    "an interpretation @xmath0 is an _ answer set _ of a program @xmath1 iff @xmath0 is a minimal model of @xmath33 .",
    "we will base our subsequent elaboration on an alternative characterisation of answer sets following , described next . given a program @xmath1 ,",
    "the _ positive dependency graph _ is a directed graph @xmath41 , where ( i )  @xmath42 equals the herbrand base of the considered language @xmath11 and ( ii )  @xmath43 iff @xmath44 and @xmath45 , for some rule @xmath46 .",
    "a non - empty set @xmath47 of ground literals is a _ _ loop _ _ of a program @xmath1 iff , for each pair @xmath48 , there is a path @xmath49 of length greater than or equal to 0 from @xmath35 to @xmath50 in the positive dependency graph of @xmath1 such that each literal in @xmath49 is in @xmath47 .",
    "let @xmath1 be a program and @xmath0 and @xmath51 interpretations .",
    "then , @xmath51 is _ externally supported by @xmath1 with respect to  @xmath0 _ iff there is a rule @xmath52 such that ( i )  @xmath53 and @xmath54 , ( ii )  @xmath55 , ( iii )  @xmath56 , and ( iv )  @xmath57 .",
    "intuitively , items ( i)(iii ) express that @xmath51 is supported by @xmath1 with respect to  @xmath0 , in the sense that the grounding of @xmath1 contains some rule @xmath13 whose body is satisfied by @xmath0 ( item  ( i ) ) and which is able to derive some literal in @xmath51 ( item  ( ii ) ) , while all head atoms of @xmath13 not contained in @xmath51 are false under @xmath0",
    ". moreover , item  ( iv ) ensures that this support is external as it is without reference to the set @xmath51 itself .",
    "answer sets are now characterised thus :    [ prop : lee05 ] let @xmath1 be a program and @xmath0 an interpretation .",
    "then , @xmath0 is an answer set of @xmath1 iff ( i )  @xmath58 and ( ii )  every loop of @xmath1 that is contained in @xmath0 is externally supported by @xmath1 with respect to  @xmath0 .",
    "we actually make mainly use of the complementary relation of external support : following , we call @xmath51 _ unfounded by @xmath1 with respect to  @xmath0 _ iff @xmath51 is not externally supported by @xmath1 with respect to  @xmath0 .",
    "as discussed in the introduction , we view an error as a mismatch between the intended answer sets and the observed actual answer sets of some program .",
    "more specifically , our basic debugging question is why a given interpretation @xmath0 is not answer set of some program @xmath1 , and thus we deal with finding explanations for @xmath0 not being an answer set of @xmath1 .",
    "proposition  [ prop : lee05 ] allows us to distinguish between two kinds of such explanations : ( i )  instantiations of rules in @xmath1 that are not satisfied by @xmath0 and ( ii )  loops of @xmath1 in @xmath0 that are unfounded by @xmath1 with respect to  @xmath0 .",
    "although our basic debugging question allows for different , multi - faceted , answers , we see two major benefits of referring to this kind of categorisation : first , in view of proposition  [ prop : lee05 ] , these kinds of explanations are always sufficient to explain why @xmath0 is not an answer set of @xmath1 , and second , this method provides _ concrete witnesses _ , e.g. ,  unsatisfied rules or unfounded atoms , that can help to localise the reason for an error in a program or an interpretation in a rather intuitive way .",
    "before we introduce the details of our approach , we discuss its virtues compared to a method for debugging non - ground programs which can be obtained using the previous meta - programming technique for propositional programs due to .      explaining why some interpretation is not an answer set of some program based on the characterisation of has been dealt with in previous work for debugging propositional disjunctive logic programs  @xcite . in principle",
    ", we could use this method for debugging non - ground programs as well by employing a preparatory grounding step .",
    "however , such an undertaking comes at a higher computational cost compared to our approach which respects the inherent complexity of the underlying tasks .",
    "we lay down our arguments in what follows .    to begin with ,",
    "let us recall that defined a fixed normal non - ground program @xmath59 and a mapping @xmath60 from disjunctive propositional programs and interpretations to sets of facts .",
    "given a disjunctive program @xmath1 without variables and some interpretation @xmath0 , explanations why @xmath0 is not an answer set of @xmath1 can then be extracted from the answer sets of @xmath61 .",
    "such a problem encoding is _ uniform _ in the sense that @xmath59 does not depend on the problem instance determined by @xmath1 and @xmath0 .    to find reasons why some interpretation @xmath0 is not an answer set of a non - ground program @xmath1",
    ", the above approach can be used by computing the answer sets of @xmath62 . however , in general , the size of @xmath33 is exponential in the size of @xmath1 , and the computation of the answer sets of a ground program requires exponential time with respect to the size of the program , unless the polynomial hierarchy collapses .",
    "hence , this outlined approach to compute explanations using a grounding step requires , all in all , _ exponential space _ and _ double - exponential time _",
    "with respect to the size of @xmath1 .",
    "but this is a mismatch to the inherent complexity of the overall task , as the following result shows :    [ prop : complexity ] given a program @xmath1 and an interpretation @xmath0 , deciding whether @xmath0 is not an answer set of @xmath1 is @xmath63-complete .",
    "this property is a consequence of the well - known fact that the complementary problem , i.e. ,  checking whether some given interpretation is an answer set of some program , is @xmath3-complete  @xcite .",
    "hence , checking whether an interpretation is not an answer set of some program can be computed in _",
    "polynomial space_.    our approach takes this complexity property into account .",
    "we exploit the expressive power of disjunctive non - ground asp by providing a uniform encoding that avoids both exponential space and double - exponential time requirements : given a program @xmath1 and an interpretation @xmath0 , we define an encoding @xmath6 , where @xmath4 is a fixed disjunctive non - ground program , and @xmath5 is an efficient encoding of @xmath1 and @xmath0 by means of facts . explanations why @xmath0 is not an answer set of @xmath1 are determined by the answer sets of @xmath6 . since @xmath4 is fixed , the grounding of @xmath6 is bounded by a polynomial in the size of @xmath1 and @xmath0 .",
    "thus , our approach requires only polynomial space and single - exponential time with respect to @xmath1 and @xmath0 .",
    "note that disjunctions can presumably not be avoided in @xmath4 due to the @xmath2-hardness of deciding whether an interpretation is not an answer set of some program .",
    "one may ask , however , whether @xmath4 could be normal in case @xmath1 is normal .",
    "we have to answer in the negative : answer - set checking for normal programs is complete for @xmath64 , even if no negation is used or negation is only used in a stratified way  @xcite .",
    "( we recall that @xmath64 is the class of problems that can be decided by a conjunction of an @xmath65 and an independent @xmath66 property . )",
    "hence , @xmath4 can not be normal unless @xmath67 .",
    "however , one could use two independent normal meta - programs to encode our desired task .",
    "a further benefit of debugging a program directly at the non - ground level is that we can immediately relate explanations for errors to first - order expressions in the considered program , e.g. ,  to rules or literals with variables instead of their ground instantiations .    in what follows ,",
    "we give details of @xmath4 and @xmath68 and describe their main properties .        for realising the encoding @xmath69 for program @xmath1 and interpretation @xmath0 , we rely on a reification @xmath70 of @xmath1 and a reification @xmath71 of @xmath0 .",
    "the former is , in turn , constructed from reifications @xmath72 of each individual rule @xmath73 .",
    "we introduce the mappings @xmath74 , @xmath75 , and @xmath76 in the following .",
    "to begin with , we need unique names for certain language elements . by an",
    "_ extended predicate symbol _",
    "( eps ) we understand a predicate symbol , possibly preceded by the symbol for strong negation .",
    "let @xmath77 be an injective _ labelling function _ from the set of program rules , literals , epss , and variables to a set of labels from the symbols in our language @xmath11 .",
    "note that we do not need labels for constant symbols since they will serve as unique names for themselves .",
    "a single program rule is reified by means of facts according to the following definition .",
    "let @xmath13 be a rule .",
    "then ,    @xmath78    the first fact states that label @xmath79 denotes a rule .",
    "the next three sets of facts associate labels of the literals in the head , the positive body , and the negative body to the respective parts of  @xmath13 .",
    "then , each label of some literal in @xmath13 is associated with a label for its eps .",
    "the following two sets of facts encode the positions of variables and constants in the literals of the rule .",
    "finally , the last set of facts states which variables occur in the rule @xmath13 .",
    "a program is encoded as follows :    let @xmath1 be a program .",
    "then ,    @xmath80    the first union of facts stem from the reification of the single rules in the program .",
    "the remaining facts represent the herbrand universe of the program and associate the epss occurring in the program with their arities .",
    "the translation from an interpretation to a set of facts is formalised by the next definition .",
    "let @xmath0 be an interpretation .",
    "then ,    @xmath81    the first two sets of facts associate the literals in @xmath0 with their respective labels and epss .",
    "the last set of facts reifies the internal structure of the literals occurring in @xmath0 .",
    "let @xmath1 be a program and @xmath0 an interpretation .",
    "furthermore , let @xmath82 be the the maximum of @xmath83 and the arities of all predicate symbols in @xmath1 .",
    "then , @xmath84 .",
    "the literals @xmath85 are necessary to add sufficiently many natural numbers to the herbrand universe of @xmath69 to carry out correctly all computations in the subsequent program encodings .",
    "note that the size of @xmath69 is always linear in the size of @xmath1 and  @xmath0 .    ' '' ''",
    "@xmath86 { { \\gamma_{{\\text{\\it{unsat}}}}}^{{\\text{\\it{check}}}}}=   \\ { &    { { \\text{\\it{unsatisfied } } } } \\leftarrow   { { \\text{\\it{satbody } } } } , { \\mathrm{not}}\\ { { \\text{\\it{sathead } } } } , \\\\ & { { \\text{\\it{satbody } } } } \\leftarrow   { \\mathrm{not}}\\ { { \\text{\\it{unsatposbody } } } } , { \\mathrm{not}}\\ { { \\text{\\it{unsatnegbody}}}},\\\\ & { { \\text{\\it{sathead } } } }       \\leftarrow { { \\text{\\it{guessrule}}}}(r ) , { { \\text{\\it{head}}}}(r , a ) , { { \\text{\\it{true}}}}(a),\\\\ & { { \\text{\\it{unsatposbody } } } } \\leftarrow { { \\text{\\it{guessrule}}}}(r),{{\\text{\\it{posbody}}}}(r , a ) ,                { { \\text{\\it{false}}}}(a),\\\\ & \\begin{array}{@{}r } { { \\text{\\it{unsatnegbody } } } } \\leftarrow { { \\text{\\it{guessrule}}}}(r),{{\\text{\\it{negbody}}}}(r , a ) ,                             { { \\text{\\it{true}}}}(a ) \\}\\mbox{. } \\end{array } \\end{array}\\ ] ] +    ' '' ''      we proceed with the definition of the central meta - program @xmath87 . the complete program consists of more than 160 rules . for space reasons , we only present the relevant parts and omit modules containing simple auxiliary definitions .",
    "the full encodings can be found at    _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ www.kr.tuwien.ac.at/research/projects/mmdasp/encoding.tar.gz . _",
    "_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _    the meta - program @xmath4 consists of the following modules : ( i )  @xmath88 , related to unsatisfied rules , ( ii )  @xmath89 , related to loops , ( iii )  @xmath90 , for testing unfoundedness of loops , and ( iv )  @xmath91 , integrating parts  ( i)(iii ) for performing the overall test of whether a given interpretation @xmath0 is not an answer set of a given program @xmath1 .",
    "we first introduce the program module @xmath88 to identify unsatisfied rules .",
    "[ def : unsat ] by @xmath88 we understand the program @xmath92 , where @xmath93 and @xmath94 are given in figure  [ fig : unsat ] , and @xmath95 defines the auxiliary predicates @xmath96 and @xmath97 .    intuitively , for a program @xmath1 and an interpretation @xmath0 , @xmath93 guesses a rule @xmath98 , represented by predicate @xmath99 , and a substitution @xmath30 , represented by @xmath100 , and @xmath94 defines that @xmath101 holds if @xmath102 .",
    "module @xmath95 ( omitted for space reasons ) defines the auxiliary predicates @xmath96 and @xmath97 such that @xmath103 holds if @xmath104 , for some literal @xmath105 , and @xmath106 holds if @xmath107 .",
    "module @xmath88 has the following central property :    [ thm : unsat ] let @xmath1 be a program and @xmath0 an interpretation .",
    "then , @xmath108 iff some answer set of @xmath109 contains @xmath101 .",
    "more specifically , for each rule @xmath98 with @xmath102 , for some substitution @xmath30 over the herbrand universe of @xmath1 , @xmath109 has an answer set @xmath110 such that ( i )  @xmath111 and ( ii )  @xmath112 iff @xmath113 .",
    "we next define module @xmath89 for identifying loops of a program .",
    "[ def : loop ] by @xmath89 we understand the program @xmath114 , where @xmath115 and @xmath116 are given in figure  [ fig : loop ] , and @xmath117 defines the auxiliary predicates @xmath118 and @xmath119 .    ' '' ''",
    "@xmath120 { { \\gamma_{{\\text{\\it{loop}}}}}^{{\\text{\\it{check}}}}}=   \\ { &     \\begin{array}[t]{@{}l@{}l }   { { \\text{\\it{inruleset}}}}(n , r ) \\vee { { \\text{\\it{outruleset}}}}(n , r ) \\leftarrow\\ & 1 \\leq n , n \\leq s ,            { { \\text{\\it{loopsz}}}}(s ) , { { \\text{\\it{rule}}}}(r ) , \\\\ &            { { \\text{\\it{natnumber}}}}(n ) , \\end{array}\\\\ & { { \\text{\\it{somerule}}}}(n ) \\leftarrow { { \\text{\\it{inruleset}}}}(n , r ) , \\\\ & \\leftarrow { \\mathrm{not}}\\ { { \\text{\\it{somerule}}}}(n ) , 1 \\leq n , n \\leq s , { { \\text{\\it{loopsz}}}}(s ) ,   { { \\text{\\it{rule}}}}(r ) , { { \\text{\\it{natnumber}}}}(n ) , \\\\ & \\leftarrow { { \\text{\\it{inruleset}}}}(n , r_{1 } ) , { { \\text{\\it{inruleset}}}}(n , r_{2 } ) , r_{1 } \\neq r_{2 } ,   \\\\   & \\leftarrow   { { \\text{\\it{inruleset}}}}(n_{1},r_{1 } ) , { { \\text{\\it{inruleset}}}}(n_{2},r_{2 } ) , n_{1 } \\leq n_{2 } , r_{1 } > r_{2 } , \\\\ & \\begin{array}[t]{@{}l@{}l } { { \\text{\\it{loopsubst}}}}(n , x , c ) \\vee { { \\text{\\it{nloopsubst}}}}(n , x , c ) \\leftarrow\\ & { { \\text{\\it{var}}}}(r , x),{{\\text{\\it{dom}}}}(c),\\\\ & { { \\text{\\it{inruleset}}}}(n , r),\\end{array}\\\\ & { { \\text{\\it{loopassigned}}}}(n , x ) \\leftarrow { { \\text{\\it{loopsubst}}}}(n , x , c ) , \\\\   & \\leftarrow { \\mathrm{not}}\\ { { \\text{\\it{loopassigned}}}}(n , x ) , { { \\text{\\it{inruleset}}}}(n , r ) , { { \\text{\\it{var}}}}(r , x ) , \\\\   & \\leftarrow { { \\text{\\it{loopsubst}}}}(n , x , c_{1 } ) , { { \\text{\\it{loopsubst}}}}(n , x , c_{2 } ) , c_{1 } \\neq c_{2 } ,   \\\\&{{\\text{\\it{isloop } } } }   \\leftarrow { \\mathrm{not}}\\ { { \\text{\\it{unreachablepair } } } } , inloop(x ) , \\\\   & { { \\text{\\it{unreachablepair } } } } \\leftarrow { { \\text{\\it{inloop}}}}(x ) , { { \\text{\\it{inloop}}}}(y ) ,   { \\mathrm{not}}\\ { { \\text{\\it{path}}}}(x , y ) , \\\\   & { { \\text{\\it{path}}}}(x , x ) \\leftarrow { { \\text{\\it{inloop}}}}(x ) ,    \\\\   & \\begin{array}[t]{@{}l@{}l } { { \\text{\\it{path}}}}(x , y ) \\leftarrow\\ & { { \\text{\\it{inloop}}}}(x ) , { { \\text{\\it{inloop}}}}(y ) , { { \\text{\\it{pred}}}}(x , t_{1 } ) , { { \\text{\\it{pred}}}}(y , t_{2 } ) ,                 { { \\text{\\it{loopsz}}}}(s ) , \\\\ & 1 \\leq n , n \\leq s ,              { { \\text{\\it{head}}}}(r , h),{{\\text{\\it{inruleset}}}}(n , r ) ,                { { \\text{\\it{posbody}}}}(r , b ) , \\\\&{{\\text{\\it{pred}}}}(h , t_{1 } ) , { { \\text{\\it{pred}}}}(b , t_{2 } ) ,                  { \\mathrm{not}}\\ { { \\text{\\it{differseq}}}}(n , x , h ) , \\\\ & { \\mathrm{not}}\\ { { \\text{\\it{differseq}}}}(n , y , b ) , \\end{array}\\\\ & { { \\text{\\it{path}}}}(x , z ) \\leftarrow { { \\text{\\it{inloop}}}}(x ) , { { \\text{\\it{inloop}}}}(z ) , { { \\text{\\it{path}}}}(x , y ) , { { \\text{\\it{path}}}}(y , z ) \\}\\mbox{. } \\end{array}\\ ] ]    ' '' ''    intuitively , for a program @xmath1 and an interpretation @xmath0 , @xmath115 guesses a non - empty subset @xmath47 of @xmath0 , represented by @xmath121 , as a candidate for a loop , and @xmath116 defines that @xmath122 holds if @xmath47 is a loop of @xmath1 . more specifically , this check is realised as follows .",
    "assume @xmath47 contains @xmath123 literals .    1 .",
    "guess a set @xmath124 of @xmath123 pairs @xmath125 , where @xmath13 is a rule from @xmath1 and @xmath30 is a substitution over the herbrand universe of @xmath1 .",
    "2 .   check , for each @xmath48 , whether there is a path @xmath49 in the positive dependency graph of the ground program consisting of rules @xmath126 such that @xmath49 starts with @xmath35 and ends with @xmath50 , and all literals in @xmath49 are in @xmath47 .",
    "a path @xmath49 is represented by the binary predicate @xmath127 .",
    "module @xmath117 ( again omitted for space reasons ) defines that ( i )  @xmath128 holds if @xmath129 and ( ii )  @xmath130 holds if @xmath131 , where @xmath35 , @xmath50 are literals and @xmath30 is the substitution stemming from a pair in @xmath124 that is associated with an index @xmath132 by @xmath89 .",
    "[ thm : loop ] for any program @xmath1 and any interpretation @xmath0 , @xmath133 is a loop of @xmath1 iff , for some answer set @xmath110 of @xmath134 , @xmath135 and @xmath136 .",
    "we proceed with module @xmath90 for checking whether some set @xmath51 of ground literals is unfounded by @xmath1 with respect to  an interpretation @xmath0 .",
    "we later combine this @xmath66 check with @xmath89 to identify unfounded loops , i.e. ,  we will integrate a loop guess with a @xmath66 check , thus reaching the very limits of disjunctive asp by uniformly encoding a @xmath3 property .    ' '' ''",
    "@xmath137 { { \\gamma_{{\\text{\\it{unfd}}}}}^{{\\text{\\it{check}}}}}=   \\ { & { { \\text{\\it{unfounded } } } } \\leftarrow { { \\text{\\it{unsupp}}}}(r ) , { { \\text{\\it{lastr}}}}(r),\\\\ & { { \\text{\\it{unsupp}}}}(r )    \\leftarrow { { \\text{\\it{firstr}}}}(r ) , { { \\text{\\it{unsupprule}}}}(r),\\\\ & { { \\text{\\it{unsupp}}}}(r_{2 } )   \\leftarrow { { \\text{\\it{succr}}}}(r_{1},r_{2 } ) , { { \\text{\\it{unsupp}}}}(r_{1 } ) , { { \\text{\\it{unsupprule}}}}(r_{2}),\\\\ & { { \\text{\\it{saturate } } } } \\leftarrow { { \\text{\\it{unfounded}}}},\\\\   & { { \\text{\\it{suppsubst}}}}(x , c )   \\leftarrow { { \\text{\\it{variable}}}}(x),{{\\text{\\it{dom}}}}(c ) , { { \\text{\\it{saturate}}}},\\\\ & { { \\text{\\it{nsuppsubst}}}}(x , c ) \\leftarrow { { \\text{\\it{variable}}}}(x),{{\\text{\\it{dom}}}}(c ) , { { \\text{\\it{saturate}}}}\\ \\}\\cup\\\\ \\{&{{\\text{\\it{unsupprule}}}}(r ) \\leftarrow c_{i}(r ) \\mid i \\in \\{1,\\ldots , 5\\}\\}\\mbox{. } \\end{array}\\ ] ]    ' '' ''    [ def : unfounded ] by @xmath90 we understand the program @xmath138 , where @xmath139 and @xmath140 are given in figure  [ fig : support ] , and @xmath141 defines the auxiliary predicates @xmath142",
    ", @xmath143 , @xmath144 , @xmath145 , @xmath146 , @xmath147 , and @xmath148 .",
    "the intuition behind this definition is as follows .",
    "consider a program @xmath1 , some set @xmath51 of ground literals , encoded via @xmath121 , and an interpretation @xmath0 .",
    "module @xmath139 non - deterministically guesses a binary relation @xmath149 between the variables and the constant symbols in @xmath1 . in case this relation is not a function , @xmath139 establishes @xmath150 .",
    "module @xmath140 , in turn , encodes whether , for each substitution @xmath30 and each rule @xmath98 , some of the conditions from the definition of @xmath51 being externally supported by @xmath1 is violated .",
    "in fact , @xmath151 is derived if some of these conditions is violated .",
    "moreover , @xmath150 holds if @xmath151 holds , and @xmath140 saturates the relation defined by predicate @xmath149 if @xmath150 holds .",
    "module @xmath141 ( omitted for space reasons ) defines @xmath142 and @xmath143 , which express the immediate successor relation , based on @xmath38 , for the constant symbols and rules in @xmath1 , respectively , as well as the predicates @xmath144 , @xmath146 , @xmath145 , and @xmath147 , which mark the first and the last elements in the order defined by @xmath142 and @xmath143 , respectively .",
    "moreover , the module @xmath141 defines predicates @xmath148 , expressing failure of one of the conditions for @xmath51 being externally supported by @xmath1 with respect to  @xmath0 .    the rough idea behind the encoded saturation technique is to search , via @xmath139 , for counterexample substitutions that witness that the set @xmath51 of ground literals is _ not _ unfounded .",
    "for such a substitution , neither @xmath150 nor @xmath151 can become true which implies that no answer set can contain @xmath151 due to the saturation of @xmath149 and the minimality of answer sets .",
    "[ thm : support ] consider a program @xmath1 , an interpretation @xmath0 , and a set @xmath51 of ground literals . then",
    ", @xmath51 is unfounded by @xmath1 with respect to  @xmath0 iff the unique answer set of @xmath152 contains the literal @xmath151 .    given the above defined program modules , we arrive at the uniform encoding of the overall program @xmath87 .",
    "let @xmath88 , @xmath89 , and @xmath90 be the programs from definitions  [ def : unsat ] , [ def : loop ] , and [ def : unfounded ] , respectively .",
    "then , @xmath153 , where    @xmath154    module @xmath91 encodes that each answer set of @xmath87 witnesses either @xmath108 or that some loop @xmath133 of @xmath1 is unfounded by @xmath1 with respect to  @xmath0 .",
    "we finally obtain our main result , which follows essentially from the semantics of module @xmath91 and theorems  [ thm : unsat ] , [ thm : loop ] , and [ thm : support ] .",
    "[ th : main ] given a program @xmath1 and an interpretation @xmath0 , @xmath155 satisfies the following properties :    1 .",
    "@xmath156 has no answer set iff @xmath0 is an answer set of @xmath1 .",
    "@xmath0 is not an answer set of @xmath1 iff , for each answer set @xmath110 of @xmath156 , @xmath157 .",
    "3 .   @xmath108 iff @xmath158 , for some answer set @xmath110 of @xmath156 .",
    "moreover , for each rule @xmath98 with @xmath102 , for some substitution @xmath30 over the herbrand universe of @xmath1 , there is some answer set @xmath110 of @xmath156 such that ( a )  @xmath111 and ( b )  @xmath112 iff @xmath113 .",
    "a loop @xmath133 is unfounded by @xmath1 with respect to  @xmath0 iff some answer set @xmath110 of @xmath156 contains both @xmath122 and @xmath151 , and @xmath136 .",
    "in this section , we first describe a simple scenario with different debugging tasks and show how the meta - program defined in the previous section can be used to solve them .",
    "afterwards , we discuss some pragmatic aspects relevant for realising a prospective user - friendly debugging system based on our approach .",
    "we assume that students have to encode the assignments of papers to members of a program committee ( pc ) based on some bidding information in terms of asp .",
    "we consider three cases , each of them illustrates a different kind of debugging problem . in the first case ,",
    "an answer set is expected but the program is inconsistent . in the second case ,",
    "multiple answer sets are expected but the program yields only one answer set . in the third case",
    ", it is expected that a program is inconsistent , but it actually yields some answer set .",
    "we illustrate that , in all cases , our approach gives valuable hints how to debug the program in an iterative way .",
    "assume that @xmath159 means that @xmath160 is a member of the pc , @xmath161 means that @xmath160 is a paper , and @xmath162 means that pc member @xmath160 bids on paper @xmath163 with value @xmath164 , where @xmath164 is a natural number ranging from @xmath165 to @xmath166 expressing a degree of preference for that paper .    to start with , lucy wants to express that the default bid for a paper is @xmath167 .",
    "that is , if a pc member does not bid on a paper , then it is assumed that the pc member bids @xmath167 on that paper per default .",
    "first attempt looks as follows :    @xmath168    lucy s intention is that @xmath169 is true if pc member @xmath170 bids on paper @xmath1 , and @xmath171 is true if there is no evidence that pc member @xmath170 has bid on that paper . indeed , the unique answer set of @xmath172 is @xmath173 the answer set @xmath174 is indeed as expected : we have that each pc member bids on some paper in @xmath172 and the last rule is inactive .",
    "lucy s next step is to delete the fact @xmath175 from @xmath172let us denote the resulting program by @xmath176 .",
    "lucy expects that the answer set of @xmath176 contains @xmath177 .",
    "however , it turns out that @xmath176 yields no answer set at all !    to find out what went wrong , lucy defines her expected answer set as @xmath178 and inspects the answer sets of @xmath179 .",
    "it turns out that one answer set contains the facts @xmath101 and @xmath180 , where @xmath181 is the label for the rule @xmath182 hence , @xmath183 is not satisfied by @xmath184 : @xmath177 is in @xmath184 and thus satisfies the body of @xmath183 , but the head of @xmath183 is not satisfied since @xmath184 does not contain @xmath185 .    now that lucy sees that @xmath176 s answer set has to contain @xmath185 , she defines @xmath186 as @xmath184 plus the fact @xmath185",
    "the answer sets of @xmath187 reveal that @xmath186 is not an answer set of @xmath176 because the singleton loop @xmath177 is contained in @xmath186 but it is unfounded by @xmath176 with respect to  @xmath186 .",
    "the reason is clear : the only rule that could support @xmath177 is @xmath188 however , @xmath189 is blocked since @xmath186 contains @xmath185 .",
    "lucy concludes that , to make @xmath189 work as expected , @xmath185 must not be contained in the answer set . to achieve this , lucy changes @xmath183 , the only rule with predicate @xmath190 in the head , into @xmath191 the resulting program works as expected and contains @xmath177 in its answer set .    the next student who is faced with a mystery is linus .",
    "he tried to formalise that each paper is non - deterministically assigned to at least one member of the pc .",
    "his program looks as follows :    @xmath192    linus expects that the disjunctive rule realises the non - deterministic guess , and then the constraint prunes away all answer set candidates where a paper is not assigned to some pc member .",
    "now , poor linus is desperate since the non - deterministic guess seems not to work correctly ; the only answer set of @xmath193 is    @xmath194    although linus expected one answer set for each possible assignment . in particular , linus expected @xmath195 to be an answer set as well .",
    "hence , linus inspects the answer sets of @xmath196 and learns that the constraint in @xmath193 is not satisfied by @xmath197 .",
    "in particular , it is the substitution that maps the variable @xmath1 to @xmath198 and @xmath170 to @xmath199 that is responsible for the unsatisfied constraint , which can be seen from the @xmath200 atoms in each answer set that contains @xmath101 .    having this information",
    ", linus observes that the constraint in its current form is unsatisfied if some paper is not assigned to _ each _ pc member .",
    "however , he intended it to be unsatisfied only when a paper is assigned to _ no _ pc member .",
    "hence , he replaces the constraint by the two rules @xmath201 the resulting program yields the nine expected answer sets .",
    "meanwhile , peppermint patty encounters a strange problem .",
    "her task was to write a program that expresses the following issue : if a pc member @xmath170 bids 0 on some paper @xmath1 , then this means that there is a conflict of interest with respect to  @xmath170 and @xmath1 .",
    "in any case , there is a conflict of interest if @xmath170 ( co-)authored @xmath1 .",
    "a pc member can only be assigned to some paper if there is no conflict of interest with respect to  that pc member and that paper .",
    "this is peppermint patty s solution :    @xmath202    the facts in @xmath203 should model a scenario where a pc member authored a paper and is assigned to that paper . according to the specification from above , this should not be allowed .",
    "since patty is convinced that her encoding is correct , she expects that @xmath203 has no answer sets .",
    "but @xmath203 has the unique answer set @xmath204",
    "what peppermint patty finds puzzling is that @xmath205 does not contain any atoms signalling a conflict of interest .",
    "hence , she decides to analyse why @xmath206 is not an answer set of @xmath207 . if @xmath203 was correct , then the only reason why @xmath208 is not an answer set of @xmath203 would be that the ( only ) constraint in @xmath203 is unsatisfied .",
    "as expected , some answer sets of @xmath209 contain @xmath101 and @xmath210 , where @xmath79 is the label of the constraint in @xmath203 .",
    "however , some answer sets contain the atom @xmath151 as well  a surprising observation .",
    "patty learns , by inspecting the @xmath121 atoms in the respective answer set , that @xmath208 contains the loop @xmath211 which is unfounded by @xmath203 with respect to  @xmath208 : @xmath212 seems to be justified only by the literal @xmath213 and vice versa .",
    "this should not be the case since @xmath203 contains the rule @xmath214 that should support @xmath213 because all the facts @xmath215 , @xmath216 , and @xmath217 should be contained in @xmath203 .",
    "now , the error is obvious : @xmath218 does not contain the fact @xmath217 but @xmath219the order of the arguments was wrong .",
    "after peppermint patty fixed that bug , her program is correct .      for a debugging system of practical value",
    ", certain pragmatic aspects have to be taken into account which we briefly sketch in what follows .",
    "to start with , our encodings can be seen as a `` golden design''tailored towards clarity and readability  which leaves room for optimisations .",
    "related to this issue , solver features like limiting the number of computed answer sets or query answering are needed to avoid unnecessary computation and to limit the amount of information presented to the user .",
    "our debugging approach requires information about the intended semantics in form of the interpretation representing a desired answer set .",
    "typically , answer sets of programs encoding real - world problems tend to be large which makes it quite cumbersome to manually create interpretations from scratch .",
    "it is therefore vital to have convenient means for obtaining an intended answer set in the first place .",
    "for this purpose , we envisage a tool - box for managing interpretations that allows for their manipulation and storage . in such",
    "a setting , answer sets of previous versions of the debugged program could be a valuable source of interpretations which are then tailored towards an intended answer set of the current version .",
    "in addition to manual adaptations , partial evaluation of the program could significantly accelerate the creation of interpretations .",
    "we plan to further investigate these issues and aim at incorporating our debugging technique , along with an interpretation management system as outlined , in an integrated development environment ( ide ) . here ,",
    "an important issue is to achieve a suitable user interface for highlighting the identified unsatisfied rules and unfounded loops in the source code and for visualising the involved variable substitutions .",
    "besides the debugging approach by , as already discussed earlier , other related approaches on debugging include the work of @xcite on _ justifications _ for non - ground answer - set programs that can be seen as a complementary approach to ours .",
    "their goal is to explain the truth values of literals with respect to a given actual answer set of a program .",
    "explanations are provided in terms of _ justifications _ which are labelled graphs whose nodes are truth assignments of possibly default - negated ground atoms .",
    "the edges represent positive and negative support relations between these truth assignments such that every path ends in an assignment which is either assumed or known to hold .",
    "the authors have also introduced justifications for partial answer sets that emerge during the solving process ( online justifications ) , being represented by three - valued interpretations .    the question why atoms are contained or are not contained in an answer",
    "set has also been raised by @xcite who provide algorithms for recursively computing explanations in terms of satisfied supporting rules .",
    "note that these problems can in principle also be handled by our approach , as illustrated in section  [ sec : peanuts ] . indeed , consider some program @xmath1 with answer set @xmath0 and suppose we want to know why a certain set @xmath47 of literals is contained in @xmath0 .",
    "using our approach , explanations why @xmath220 is not an answer set of @xmath1 will reveal rules which are unsatisfied under @xmath220 but which support literals in @xmath47 under @xmath0 .",
    "likewise , we can answer the question why expected atoms are missing in an answer set",
    ".    aims at finding explanations why some propositional program has no answer sets .",
    "his approach is based on finding minimal sets of constraints such that their removal yields consistency .",
    "hereby , it is assumed that a program does not involve circular dependencies between literals through an odd number of negations which might also cause inconsistency .",
    "finding reasons for program inconsistency can be handled by our approach when an intended answer set is known , as illustrated by program @xmath221 in section  [ sec : peanuts ] .",
    "otherwise , an interpretation can be chosen from the answer sets resulting from temporarily removing all constraints from the considered program ( providing this yields consistency ) .",
    "rewrite a program using some additional control atoms , called _ tags _ , that allow , e.g. , for switching individual rules on or off and for analysing the resulting answer sets .",
    "debugging requests in this approach can be posed by adding further rules that can employ tags as well .",
    "one such extension allows also for detecting atoms in unfounded loops .",
    "however , as opposed to our current approach , the individual loops themselves are not identified .",
    "developed a declarative debugging approach for datalog using a classification of error explanations similar to the one by and our current work .",
    "their approach is tailored towards query answering and , in contrast to our approach , the language is restricted to stratified datalog .",
    "however , provide an implementation that is based on computing a graph that reflects the execution of a query .",
    "show how a calculus can be used for debugging first - order theories with inductive definitions in the context of model expansion problems , i.e. ,  problems of finding models of a given theory that expand some given interpretation .",
    "the idea is to trace the proof of inconsistency of such an unsatisfiable model expansion problem .",
    "the authors provide a system that allows for interactively exploring the proof tree .    besides the mentioned approaches which rely on the semantical behaviour of programs , @xcite use a translation from logic - program rules to natural language in order to detect program errors more easily .",
    "this seems to be a potentially useful feature for an ide as well , especially for novice and non - expert asp programmers .",
    "our approach for declaratively debugging non - ground answer - set programs aims at providing intuitive explanations why a given interpretation fails to be an answer set of the program in development . to answer this question , we localise , on the one hand , unsatisfied rules and , on the other hand , loops of the program that are unfounded with respect to the given interpretation . as underlying technique",
    ", we use a sophisticated meta - programming method that reflects the complexity of the considered debugging question which resides on the second level of the polynomial hierarchy .",
    "typical errors in asp may have quite different reasons and many of them could be avoided rather easily in the first place , e.g. ,   by a compulsory declaration of predicates @xcite , forbidding uneven loops through negation  @xcite , introducing type checks , or defining program interfaces .",
    "we plan to realise these kinds of simple prophylactic techniques for our future ide for asp that will incorporate our current debugging approach . in this context ,",
    "courses on logic programming at our institute shall provide a permanent testbed for our techniques .",
    "moreover , as part of an ongoing research project on methods and methodologies for developing answer - set programs  @xcite , we want to put research efforts into methodologies that avoid or minimise debugging needs right from the start . as a next direct step regarding our efforts towards debugging ,",
    "we plan to extend our approach to language features like aggregates , function symbols , and optimisation techniques such as minimise - statements or weak constraints .",
    "\\2005 . debugging logic programs under the answer - set semantics . in _ proceedings of the 3rd workshop on answer set programming : advances in theory and implementation ( asp05 ) , bath , uk , july 27 - 29 , 2005_. ceur workshop proceedings , vol . 142 .",
    "ceur-ws.org , aachen , germany .    ,",
    "gebser , m. , phrer , j. , schaub , t. , tompits , h. , and woltran , s. 2007 .",
    "debugging asp programs by means of asp . in _ proceedings of the 9th international conference on logic programming and nonmonotonic reasoning ( lpnmr07 ) , tempe , az ,",
    "usa , may 15 - 17 , 2007 _ , c.  baral , g.  brewka , and j.  s. schlipf , eds .",
    "lecture notes in computer science , vol . 4483 .",
    "springer , berlin - heidelberg , germany , 3143 .    , garca - ruiz , y. , and senz - prez , f. 2008 . a theoretical framework for the declarative debugging of datalog programs . in _ revised selected papers of the 3rd international workshop on semantics in data and knowledge bases ( sdkb08 ) , nantes , france , march  29 , 2008 _ , k .-",
    "schewe and b.  thalheim , eds .",
    "lecture notes in computer science , vol . 4925 .",
    "springer , berlin - heidelberg , germany , 143159 .    ,",
    "lin , f. , wang , y. , and zhang , m. 2006 .",
    "first - order loop formulas for normal logic programs . in _ proceedings of the 10th international conference on principles of knowledge representation and reasoning ( kr06 ) , lake district , uk , june 2 - 5 , 2006 _ , p.",
    "doherty , j.  mylopoulos , and c.  a. welty , eds .",
    "aaai press , menlo park , ca , usa , 298307 .    , vennekens , j. , bond , s. , gebser , m. , and truszczynski , m. 2009 . the second answer set programming competition . in _ proceedings of the 10th international conference on logic programming and nonmonotonic reasoning ( lpnmr09 ) , potsdam , germany ,",
    "september 14 - 18 , 2009 _ , e.  erdem , f.  lin , and t.  schaub , eds .",
    "lecture notes in computer science , vol . 5753 .",
    "springer , berlin - heidelberg , germany , 637654 .    ,",
    "faber , w. , fink , m. , pfeifer , g. , and woltran , s. 2004 .",
    "complexity of model checking and bounded predicate arities for non - ground answer set programming . in",
    "_ proceedings of the 9th international conference on principles of knowledge representation and reasoning ( kr04 ) , whistler , canada , june 2 - 5 , 2004 _ , d.  dubois , c.  a. welty , and m .- a .",
    "williams , eds .",
    "aaai press , menlo park , ca , usa , 377387 .      , phrer , j. , schaub , t. , and tompits , h. 2008 . a meta - programming technique for debugging answer - set programs . in _ proceedings of the 23rd aaai conference on artificial intelligence ( aaai08 ) , chicago , il , usa ,",
    "july 13 - 17 , 2008 _",
    ", d.  fox and c.  p. gomes , eds .",
    "aaai press , menlo park , ca , usa , 448453 .    , phrer , j. , schaub , t. , tompits , h. , and woltran , s. 2009 .",
    "spock : a debugging support tool for logic programs under the answer - set semantics . in",
    "_ revised selected papers of the 17th international conference on applications of declarative programming and knowledge management and the 21st workshop on logic programming ( inap07/wlp07 ) , wrzburg , germany , october 4 - 6 , 2007 _",
    ", d.  seipel , m.  hanus , and a.  wolf , eds .",
    "lecture notes in computer science , vol . 5437 .",
    "springer , berlin - heidelberg , germany , 247252 .",
    "a model - theoretic counterpart of loop formulas . in _ proceedings of the 19th international joint conference on artificial intelligence ( ijcai05 ) , edinburgh , scotland , uk , july  30-august  5 , 2005 _ , l.  p. kaelbling and a.  saffiotti , eds . professional book center ,",
    "denver , co , usa , 503508 .    \\2008 . on loop formulas with variables . in _ proceedings of the 11th international conference on principles of knowledge representation and reasoning ( kr08 ) , sydney , australia ,",
    "september 16 - 19 , 2008 _ , g.  brewka and j.  lang , eds .",
    "aaai press , menlo park , ca , usa , 444453 .        , moseley , e. , and truszczynski , m. 2007 . towards debugging of answer - set programs in the language pspb . in _ proceedings of the 2007 international conference on artificial intelligence ( icai07 ) , volume ii , las vegas , nv , usa , june 25 - 28 , 2007 _ , h.  r. arabnia , m.  q. yang , and j.  y. yang , eds .",
    "csrea press , bogart , ga , usa , 635640 .    , phrer , j. , and tompits , h. 2010 .",
    "methods and methodologies for developing answer - set programs  project description . in _",
    "technical communications of the 26th international conference on logic programming ( iclp10 ) _ , m.  hermenegildo and t.  schaub , eds .",
    "leibniz international proceedings in informatics ( lipics ) , vol",
    "schloss dagstuhl  leibniz - zentrum fr informatik , dagstuhl ,",
    "germany .",
    "debugging inconsistent answer set programs . in _ proceedings of the 11th international workshop on non - monotonic reasoning ( nmr06 ) ,",
    "lake district , uk , may 30-june 1 , 2006 _ , j.  dix and a.  hunter , eds .",
    "institut fr informatik , technische universitt clausthal , technical report , clausthal , germany , 7783 .    ,",
    "vlaeminck , h. , and denecker , m. 2009 .",
    "debugging for model expansion . in _ proceedings of the 25th international conference on logic programming ( iclp09 ) , pasadena ,",
    "ca , usa , july 14 - 17 , 2009 _ , p.  m. hill and d.  s. warren , eds .",
    "lecture notes in computer science , vol .",
    "springer , berlin - heidelberg , germany , 296311 ."
  ],
  "abstract_text": [
    "<S> an important issue towards a broader acceptance of answer - set programming ( asp ) is the deployment of tools which support the programmer during the coding phase . in particular , methods for _ debugging _ an answer - set program </S>",
    "<S> are recognised as a crucial step in this regard </S>",
    "<S> . initial work on debugging in asp mainly focused on propositional programs , yet practical debuggers need to handle programs with variables as well . in this paper </S>",
    "<S> , we discuss a debugging technique that is directly geared towards non - ground programs . following previous work </S>",
    "<S> , we address the central debugging question why some interpretation is not an answer set . </S>",
    "<S> the explanations provided by our method are computed by means of a meta - programming technique , using a uniform encoding of a debugging request in terms of asp itself . </S>",
    "<S> our method also permits programs containing comparison predicates and integer arithmetics , thus covering a relevant language class commonly supported by all state - of - the - art asp solvers .    </S>",
    "<S> [ firstpage ]    answer - set programming , program analysis , debugging </S>"
  ]
}