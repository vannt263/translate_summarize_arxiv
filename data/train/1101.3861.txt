{
  "article_text": [
    "tim was originally conceived as a tool to allow experimentation ( although only in the computer ) with novel optical components called metatoys @xcite prior to building them ( tim is an acronym for _ the interactive metatoy _ ) . since then",
    ", it has developed into a much more general ray - tracing program , suitable for use in optics research ( including , but not limited to , metatoys research ) , but also for simply playing with .",
    "metatoys are surfaces that appear to change the direction of light in ways that often result in wave - optically forbidden light - ray fields @xcite . of course",
    ", metatoys can not _ actually _ create wave - optically forbidden light - ray fields ; what they do is create light - ray fields that are visually almost indistinguishable from the forbidden fields . of particular interest to us",
    "are surfaces that perform a generalisation of refraction : they change the direction of transmitted light rays according to laws that can be much more general than snell s law . in tim",
    ", such generalised refraction can be described in terms of a complex representation , which is explained in section [ surface - property - section ] . the ability to handle very general surface properties , which enables the visualisation of scenes that include objects with metatoy surfaces ( fig .",
    "[ vertical - flip - window - figure ] ) , is tim s key speciality .    simulated view of a cylinder lattice , seen on its own ( top ) and through a window that changes the sign of the vertical light - ray - direction components  ( bottom ) . ]    simulated view of a cylinder lattice , seen on its own ( top ) and through a window that changes the sign of the vertical light - ray - direction components  ( bottom ) . ]",
    "tim , running as an interactive java application on an intel macbook .",
    "the central image is the rendered view of the default scene .",
    "the java applet version looks identical , apart from the `` save image '' button being absent in the java applet version because of security restrictions . ]",
    "but tim has other specialities , which support different aspects of our research .",
    "tim can    * simulate photos taken with cameras that can focus on almost arbitrary surfaces ( section  [ arbitrary - focus - surface - camera ] ) ; * simulate surfaces that `` teleport '' light rays to corresponding positions on other surfaces , from where the light rays then continue ( section  [ teleporting - section ] ) ; * visualise the trajectories of individual light rays ( section  [ light - ray - visualisation - section ] ) ; * render scenes as anaglyphs for viewing with red / cyan anaglyph glasses ( section  [ anaglyph - section ] ) ; * render scenes as random - dot autostereograms ( section  [ autostereogram - section ] ) .",
    "there is one more speciality : tim can be run as an interactive java applet ( fig .",
    "[ tim - window - figure ] ) , which can easily be embedded in internet pages .",
    "we use this capability to disseminate our research over the internet , in a manner that invites playful exploration .",
    "the use of this interactive version of tim is described in a user guide  @xcite .",
    "sometimes our research requires capabilities which are not yet built into the interactive version of tim .",
    "this then requires modification of the source code , and sometimes the modifications become part of the interactive version of tim . as",
    "tim is open - source software , in principle everybody can do this .",
    "the aim of this paper is to encourage this : to invite others to play with the interactive version of tim , and to entice them to download and modify tim s source code .",
    "the paper contains several appendices aimed at facilitating the source - code modification by outlining the implementation of ray tracing , which forms the core of tim s source code ( [ ray - tracing - appendix ] ) ; the overall structure of tim s source code ( [ structure - appendix ] ) ; and how to perform a number of code - modification tasks , including rendering a specific scene by modifying the source code for the default non - interactive tim java application ( [ non - interactive - tim - appendix ] ) , adding a new class of scene object ( [ new - scene - object - appendix ] ) , and adding a new class of surface property ( [ add - surface - property - appendix ] ) .",
    "tim exists because we wanted to see scenes that include metatoys .",
    "surface properties describing metatoys therefore play a key role in tim .",
    "tim describes almost all metatoy surface properties in terms of a complex representation introduced in ref .",
    "@xcite .",
    "the complex representation is itself an extension of the way ray direction is represented in snell s law , @xmath0 where @xmath1 is the angle between the incident light - ray direction and the surface normal at the point @xmath2 where the ray intersects the surface , @xmath3 is the angle between the outgoing light - ray direction and the surface normal at @xmath2 , and @xmath4 and @xmath5 are the refractive indices that meet at @xmath2 .",
    "each sine of an angle with the local surface normal can be interpreted as the number at the orthographic projection of the tip of the unit vector @xmath6 representing the corresponding light - ray direction onto a real axis that is tangential to the surface at @xmath7 , has its origin located at @xmath7 , and is lying in the plane of incidence ( the plane spanned by the incident light - ray direction and the surface normal ) ; this is shown in fig .",
    "[ complex - projection - figure](a ) .",
    "snell s law can then be interpreted as a simple multiplication of the projection of the light - ray direction by a factor @xmath8 .",
    "representations of the normalised light - ray direction @xmath6 at a point @xmath2 on a surface .",
    "( a )  orthographic projection onto a real axis tangential to the surface at @xmath2 and with its origin at @xmath2 .",
    "the real axis lies in the plane of incidence , which is the plane through @xmath2 that is spanned by the local surface normal , @xmath9 , and the normalised light - ray direction , @xmath6 .",
    "( b )   orthographic projection into a complex plane tangential to the surface at @xmath2 and with its origin at @xmath2 . ]",
    "we now replace the real axis with a complex plane ( argand plane ) , again tangential to the surface at @xmath2 and with its origin at @xmath2 .",
    "light - ray direction can then be described in terms of the complex number @xmath10 at the orthographic projection of the tip of the unit light - ray - direction vector @xmath6 into this complex plane ( fig .",
    "[ complex - projection - figure](b ) ) . in this representation ,",
    "snell s law is still described by a simple multiplication of @xmath10 by a factor @xmath8 . that the outgoing light ray also lies in the plane of incidence",
    "is explicitly contained in this formulation , but not in snell s law @xcite .",
    "rotation of the light - ray direction by an angle @xmath11 around the local surface normal @xcite is described by multiplication of @xmath10 by a factor @xmath12 @xcite .",
    "other light - ray - direction mappings can be described by other complex mappings @xmath13 ; the visual effects due to such mappings are investigated in more detail elsewhere  @xcite .",
    "tim has the ability to simulate photos taken with a camera that can focus on almost arbitrary surfaces . in this section",
    "we explain how tim simulates such a camera .",
    "focussing matters only in cameras with a non - zero aperture size .",
    "( in photos taken by cameras with a point - like aperture  pinhole cameras  everything is imaged as sharply as diffractions permits . )",
    "tim simulates a camera with a finite - size aperture by backward - tracing , starting from each pixel , a number of light rays which have passed through different points on the aperture , and averaging the resulting colours .",
    "the points on the aperture through which the backwards - traced light rays emerge are randomly chosen .",
    "which direction these light rays have as they leave the aperture is determined by the imaging properties of the lens : the light rays originate at the position of a particular pixel , and so they have to leave the lens in the direction of the pixel s _ image _ formed by the lens .    in a real lens ,",
    "the images of all detector pixels lie , to a good approximation , in a plane . by allowing the images of the detector pixels to lie on a much more general surface , the _ focus surface _ , tim simulates a camera which focusses on this focus surface .",
    "the focus surface is defined as follows .",
    "the camera has associated with it a number of scene objects that define the so - called _ focus scene _ , a scene in addition to the scene tim renders .",
    "the focus surface is then defined as those points in the focus scene visible to an observer placed at the centre of the aperture .",
    "construction of the focus surface and the position of the image of any detector pixel .",
    "the focus surface ( thick red line ) consists of those parts of the focus scene visible from the centre @xmath14 of the aperture of the imaging element .",
    "the position of the image of any particular detector pixel @xmath2 lies on the intersection between the focus surface and the continuation of the straight line between the pixel position and the point @xmath14 .",
    "the figure shows the positions of the images of two pixels , @xmath15 and @xmath16 . in the example shown here",
    ", the focus scene consists of three objects : a circle , a rectangle , and a line . ]    in the case of a thin lens , the image of any point , and specifically any detector pixel , lies somewhere along the continuation of the straight line from the point to the centre of the lens .",
    "we generalise this here such that , in tim s camera that focusses on non - planar surfaces , the image of any detector pixel lies somewhere along the continuation of the straight line from the pixel position to the centre of the aperture .",
    "[ focus - surface - figure ] illustrates this .",
    "conveniently , the position of the image of a particular pixel at position @xmath2 can be found using functionality already built into tim , namely its capability to find the closest intersection between an arbitrary light ray and a group of scene objects , one of the key capabilities for ray tracing : all that is required is finding the closest intersection between the focus scene and a ray that starts from the centre of the aperture , @xmath14 , with a direction given by @xmath17 , the direction from the detector pixel to the centre of the aperture .",
    "example of a scene rendered with a non - planar focus surface .",
    "the focus scene consists of two of the four spheres , the chequered cylinder , and a plane in the far distance . ]",
    "[ blur - example - figure ] shows an example of a scene rendered for a non - planar focus surface .",
    "the focus scene consists of a few  but not all  of the scene objects in the scene , and a distant plane .",
    "the objects that are part of the focus scene can clearly be seen to be rendered sharply ; those that are not are blurred .",
    "an ideal lens takes the field in one plane and creates an image of this field in another plane .",
    "the image is stretched in the transverse directions , but not otherwise distorted .",
    "sometimes it is desirable to create an image that is distorted according to a specific mapping between the coordinates in the object and image planes .",
    "this is called a geometrical optical transformation , and it can be approximated holographically @xcite .",
    "our own interest in geometrical optical transformations stems from the application of a polar - to - cartesian transformation between two planes to the detection of optical angular momentum  @xcite .",
    "parametrisation of a scene object .",
    "each point on the surface is described by a pair of surface coordinates , in the picture the spherical coordinates @xmath1 and @xmath18 , defined with respect to an arbitrary zenith direction ( here @xmath19 ) and direction of the azimuth axis ( here @xmath20 ) .",
    "this parametrisation of the surface has been indicated by covering it in a chequerboard pattern with tiles of side length 1 in both @xmath1 and @xmath18 .",
    "the local surface - coordinate axes , @xmath21 and @xmath22 , together with the local surface normals , @xmath23 , are shown for two points , @xmath24 ( @xmath25 ) .",
    "the sphere has radius 1 and is centred at @xmath26 . ]    for geometrical optical transformations , coordinates are clearly important .",
    "many of tim s scene objects have associated with them a two - dimensional coordinate system that parametrises their surface , i.e.  each point @xmath2 on the scene object s surface is described by a pair of associated surface coordinates , @xmath27 and @xmath28 .",
    "for example , positions on a plane are described by cartesian surface coordinates ; positions on a circular disc are described by their polar coordinates @xmath29 ( the distance from the centre ) and @xmath18 ( the azimuthal angle ) ; positions on a sphere are described by their spherical polar coordinates @xmath1 ( the polar angle ) and @xmath18 ( the azimuthal angle ) .",
    "scene objects parametrised in this way can also calculate the local surface - coordinate axes for any point on the surface .",
    "these are the vectors @xmath30 they respectively point in the direction in which the corresponding surface coordinate changes at the point @xmath2 , and their respective length indicates the distance on the surface over which the corresponding surface coordinate changes by 1 .",
    "[ parametrisation - figure ] shows the local surface - coordinate axes for two positions on a sphere .",
    "the surface coordinates and surface - coordinate axes , respectively , play a key role in the calculation of the starting point and direction of the continuation of the incident light ray .",
    "tim can simulate geometrical optical transformations using an unusual surface property . in tim s implementation of ray tracing ( see [ ray - tracing - appendix ] ) , surface properties are responsible for returning the colour of light leaving a specific point on the surface in a specific direction . finding this colour often requires further tracing of the incident ray , for example in the case of a specularly reflective surface , where the continuation of the ray leaves the same point on the surface with a new direction given by the law of reflection .",
    "geometrical optical transformations can therefore be implemented in the form of a surface property that continues tracing the incident light ray , starting from a transformed position and with a suitably transformed direction .",
    "simulated view through a cartesian - to - polar converter . in the example shown here",
    ", the converter has been placed immediately in front of the cylinder lattice shown in fig .",
    "[ vertical - flip - window - figure ] .",
    "the converter distorts vertical cylinders ( green ) into circles centred on the origin , and horizontal cylinders ( blue ) into radial lines .",
    "a brightening of the central region due to area elements being transformed to a different size ( see eqn  ( [ intensity - change - equation ] ) ) is clearly visible .",
    "the converter consists of a circular disc ( the origin object ) , parametrised in terms of distance from the centre and azimuthal angle @xmath18 , with a teleporting surface whose target object is a black square immediately behind the disc , parametrised in terms of cartesian coordinates .",
    "all coordinates are scaled to range from 0 to 1 . ]",
    "tim s teleporting surface property does precisely this .",
    "a teleporting surface has associated with it a destination object ; note that the link is one - way .",
    "we call the object with the teleporting surface the origin object .",
    "the mapping from the position @xmath2 where the incident light ray intersects the origin object to the position where its continuation leaves the destination object s surface , @xmath31 , is defined in terms of the surface - coordinate systems ( fig .",
    "[ parametrisation - figure ] ) associated with the two objects surfaces .",
    "specifically , if the position @xmath2 where the incident light ray intersects the origin object s surface is described by some values of its surface coordinates , then the point @xmath31 where the ray s continuation leaves the destination object s surface is the point at which the destination object s surface coordinates take those same values .",
    "for example , if a planar origin object is parametrised in terms of polar surface coordinates @xmath29 and @xmath18 , and the destination object associated with its teleporting surface property is also planar and parametrised in terms of cartesian surface coordinates , then this setup is a polar - to - cartesian converter for backwards - propagating light rays , which means it is a cartesian - to - polar converter for forwards - propagating light rays .",
    "[ cartesian-2-polar - converter - figure ] shows a three - dimensional ( 3d ) lattice of cylinders seen through such a setup .",
    "it can clearly be seen that lines of constant @xmath10 and @xmath32 value ( i.e.  vertical lines ) in the cylinder lattice become lines of constant radius ( i.e.  circles ) when seen through the converter , and that lines of constant @xmath10 and @xmath33 value ( horizontal lines ) become lines of constant azimuthal angle ( spokes ) .",
    "the corresponding mapping of the light - ray direction is based on wave - optical considerations .",
    "specifically , we assume that phase and intensity of the ( scalar ) optical field on the teleporting surface gets mapped onto the destination object s surface . in the ray - optics limit of wave optics @xcite , which is arguably appropriate here ,",
    "the light - ray direction is proportional to the direction of the gradient of the phase .",
    "the wave s local phase gradient then defines the new light - ray direction . in tim",
    ", light - ray direction is normalised and therefore naturally interpreted as normalised phase gradient .",
    "the components of the phase gradient are , of course , the rate of change of phase in the corresponding directions .",
    "consider the two coordinate systems that describe the surfaces of the origin object and of the destination object . now consider the component of the incident light - ray direction in the direction of the origin object s first surface coordinate , @xmath27 .",
    "a value @xmath34 means that the phase changes locally at a rate of @xmath34 full @xmath35 phase cycles over the distance on the surface in which @xmath27 changes by 1 . on the destination object",
    ", the phase then changes locally ( at the point @xmath31 where the light ray continues ) at a rate of @xmath34 full @xmath35 phase cycles over the distance in which the destination object s first surface coordinate , @xmath36 , changes by 1 .",
    "the ratio of the phase gradients in the direction of the first surface coordinate , which is the ratio of the light - ray components in the direction of the first surface coordinates , is therefore given by the ratio of the distances over which the first surface coordinate changes by 1 in the origin object and in the destination object .",
    "these distances are given by length of surface - coordinate axes , @xmath37 and @xmath38 .",
    "a similar argument can be made for the second surface coordinate , @xmath28 .",
    "the components of the direction of the continuation of the light ray in the directions of the destination object s first and second surface coordinates , @xmath39 and @xmath40 , are then @xmath41 where @xmath42 and @xmath43 are the components of the direction of the incident light ray in the directions of the first and second surface coordinates of the origin object .",
    "the component of the light - ray - direction vector in the direction of the surface normal is chosen such that the length of the light - ray - direction vector remains unchanged .",
    "this correctly represents the case of the continuation of the ray travelling in a medium with the same refractive index as the medium in which the incident ray was travelling .",
    "one further consideration is a concomitant change in brightness .",
    "tim assumes that no power is lost during teleportation , so the power entering an area element @xmath44 on the surface of the origin object at position @xmath45 is the same as that exiting the corresponding area element @xmath46 on the surface of the destination object at @xmath47 .",
    "the light intensities ( power per area ) at @xmath45 and @xmath47 , @xmath48 and @xmath49 , are then given by the equation @xmath50 .",
    "the ratio of the area elements is given by @xmath51 and so @xmath52    it is worth noting that the teleporting surface property can be used for purposes other than implementing geometrical optical transformations .",
    "for example , consider a planar origin object placed immediately in front of the camera and a planar target object placed elsewhere , both parametrised in terms of cartesian coordinate systems . if the scale of the two coordinate systems is the same , i.e.  if the surface - coordinate axes on the origin and target objects are of the same length , then the effect is a simple change of camera position and viewing direction",
    "one of tim s capabilities , namely the visualisation of light - ray trajectories , can be very helpful in understanding the effect of optical components .",
    "[ light - ray - cone - figure ] shows a cone of light rays being traced through a window that rotates the local light - ray direction through @xmath53 , showing , for example , that such a window would not create an image of a point light source at the apex of the cone .",
    "visualisation of light - ray trajectories .",
    "a cone of light - ray trajectories originating from a point in front of a window that rotates the light - ray direction by @xmath54 around the local window normal is converted into a twisted bundle of rays . ]",
    "tim visualises the trajectories of specific light rays in three steps :    1 .   trace the light rays , keeping a list of the points where each light ray intersects a scene object ; 2 .   for",
    "each segment of the above light - ray trajectory , i.e.  between each pair of neighbouring intersection points , add a cylinder to the scene ; 3 .   visualise the scene .",
    "the first point uses the ray - tracing methods already built into tim , but those methods needed to be extended slightly to keep track of ray trajectories .",
    "this requires the ability to deal with rays branching , which occurs whenever a ray encounters an object with multiple surface properties that require further ray tracing , such as a partially transmissive mirror . in tim , whenever a ray hits a surface that requires further ray tracing , a new ray is created , added to the list of the ray s branches , and traced . a light ray s full trajectory is then stored in the form of a list of positions where the main branch intersects scene objects , and the list of the branches .",
    "parallax causes a scene to look different when viewed from two different positions .",
    "this is called binocular disparity ; the process of deriving depth perception from the two different views the two eyes receive is called stereopsis @xcite . in anaglyph images @xcite , the two views are superposed , but in different colours .",
    "when viewed through suitable anaglyph glasses , i.e.  a different colour filter in front of each eye which in the simplest case completely filters out the view intended for the other eye , different images can be presented to the eyes , and stereopsis can lead to depth perception .",
    "anaglyph versions of the images in fig .",
    "[ vertical - flip - window - figure ] , which show a cylinder lattice au naturel  ( top ) and when seen through a window that inverts the vertical ray - direction component  ( bottom ) . ]    anaglyph versions of the images in fig .",
    "[ vertical - flip - window - figure ] , which show a cylinder lattice au naturel  ( top ) and when seen through a window that inverts the vertical ray - direction component  ( bottom ) . ]",
    "tim can create anaglyph images intended for viewing with red / cyan anaglyph glasses .",
    "two images are calculated for camera positions that differ by a sideways displacement .",
    "these two images can then be turned into anaglyph images in two different ways :    1 .   the red component of the image is the luminosity of the left - eye image , the blue component is the luminosity of the right - eye image .",
    "the resulting anaglyph has lost colour information .",
    "2 .   following `` recent simple practice '' @xcite ,",
    "the blue and green components are removed from the image that corresponds to the left eye , the red component is removed from the right - eye image , and the two images are superposed .",
    "the resulting anaglyph includes colour information , but does not work very well for objects of certain colours .",
    "figures [ anaglyph - images - figure ] and [ anaglyph - colour - figure ] show examples of anaglyph images .",
    "example of a colour anaglyph image .",
    "in addition to the chequerboard floor , the scene contains three reflective spheres . ]",
    "tim can render scenes as random - dot autostereograms @xcite . fig .",
    "[ autostereogram - example - figure ] shows an example of such a random - dot autostereogram created by tim .",
    "random - dot autostereogram of tim s default scene ( fig .",
    "[ tim - window - figure ] ) .",
    "note that the scene includes a plane behind tim s head which can be seen in the background , making it easier to see the autostereogram . ]",
    "principle of random - dot autostereograms .",
    "the eyes are located at the positions @xmath55 and @xmath56 ; the autostereogram is in the plane @xmath57 ; @xmath58 is the 3d surface represented by the autostereogram . ]",
    "autostereograms rely on the fact that two different patterned surfaces can look identical from different viewing positions . in the case of standard autostereograms ,",
    "the two different viewing positions are the positions of the observer s eyes , one of the surfaces is planar , and the pattern in that plane is the autostereogram of the other , three - dimensional , surface . for the observer to perceive the visual illusion of seeing the three - dimensional surface",
    "when viewing the autostereogram requires the patterns to be sufficiently detailed .",
    "placing dots on the two surfaces such that the patterns are consistent with each other is perhaps the simplest way to construct autostereograms .",
    "tim uses the following algorithm .",
    "we call the plane of the autostereogram @xmath57 , and the three - dimensional surface @xmath58 ( see fig .  [ random - dot - autostereogram - figure ] ) .    1 .   randomly pick a dot colour .",
    "[ pick - d ] randomly pick a position @xmath59 in the plane @xmath57 and place a small dot of the picked dot colour there .",
    "[ find - p ] find the point @xmath2 on @xmath58 that lies on the same line of sight as @xmath59 , as seen from the position of the left eye , @xmath55 .",
    "for the surfaces @xmath57 and @xmath58 to look identical from the position of the left eye , @xmath2 therefore has to have the same colour as @xmath59 , namely the dot colour picked above .",
    "4 .   find the point @xmath60 on @xmath57 that lies on the same line of sight as @xmath2 , as seen from the position of the _ right _ eye , @xmath56 . by the same argument as above",
    ", the colour of this point must also be the dot colour picked above .",
    "therefore , place another small dot of the picked dot colour at @xmath60 .",
    "[ find - ds ] the previous two steps constructed , from the position @xmath59 of one dot in the autostereogram , the position @xmath60 of another dot that has to have the same colour .",
    "repeat the previous two steps to construct , from the position @xmath60 of this other dot , the position of yet another dot that has to have the same colour .",
    "keep repeating until the position of the new dot lies outside the area of the autostereogram . 6 .",
    "steps [ find - p ] to [ find - ds ] constructed , from the position @xmath59 picked in step [ pick - d ] , the positions of further dots that have to be of the same colour .",
    "this was done by using the left eye s line of sight to construct a corresponding point on @xmath58 , and then the right eye s line of sight to construct a point on @xmath57 corresponding to this new point .",
    "start again from the position picked in step [ pick - d ] , @xmath59 , and repeat steps [ find - p ] to [ find - ds ] , but swapping the role of the left eye and the right eye . in other words , now use the _ right _ eye s line of sight to construct a point on @xmath58 that corresponds to a dot position in @xmath57 , and then use the _ left _",
    "eye s line of sight to construct a point on @xmath57 corresponding to this point on @xmath58 , which is then the position of a new dot .",
    "two details in tim s algorithm are perhaps worth noting .    1 .",
    "the dots placed by tim in the autostereogram are not single pixels but gaussians .",
    "this means that their positions are not restricted to the pixel positions , so they can be placed `` between pixels '' .",
    "this is advantageous as restricting dot positions to pixel positions restricts the possible separations between dots , and therefore the depths the dot patterns can represent , which results in `` layered '' random - dot stereograms .",
    "each dot tim places in the autostereogram has a particular hue . to calculate the colour of a particular pixel in the autostereogram",
    ", tim calculates the weighted average of the hues of all the dots that intersect at the pixel .",
    "hue is the azimuthal angle @xmath18 of a colour s position in a suitable colour wheel ( e.g.  red @xmath61 , yellow @xmath62 , green @xmath63 , cyan @xmath64 , blue @xmath65 , purple @xmath66 ) . to form the weighted average of the hues due to all dots",
    ", tim converts the hue of each dot into corresponding cartesian coordinates ( the coordinates corresponding to the hue @xmath67 of the @xmath68th dot , weighted by a factor @xmath69 , are @xmath70 and @xmath71 ) , adding up the @xmath32 and @xmath33 coordinates due to all hues , and calculating the azimuthal angle @xmath18 of the resulting @xmath72 position .",
    "the weight of the hue of a particular dot is given by @xmath73 $ ] , where @xmath74 is the distance between the pixel and the centre of the @xmath68th dot , and @xmath75 is the dot radius .",
    "this can be expressed in terms of complex numbers as @xmath76 \\exp({\\mathrm{i}}\\phi_j ) \\right\\}.\\ ] ] finally , the pixel colour is found using the standard java method for converting a colour represented in terms of its hue , saturation and brightness ( hsb ) into its red , green and blue ( rgb ) components .",
    "both saturation and brightness are set to their maximum value , 1 .",
    "tim is a powerful raytracer with extensive capabilities , a number of them unique .",
    "we use tim in our research on metatoys : for disseminating our research over the internet by inviting playful experimentation with metatoys through tim s interactive version ; and for conducting computer experiments with metatoys ourselves .",
    "sometimes it is necessary to modify tim s source code , which can be a daunting prospect .",
    "this paper is intended to help others and ourselves doing this .",
    "we hope it will entice other researchers to use tim in their own work .",
    "thanks to the mathworks and to nist for making the source code of jama publicly available .",
    "tim is written in java @xcite , an object - orientated programming language @xcite . as in all object - orientated languages , objects are instances of classes .",
    "a class has associated methods and data ( variables ) , which take on specific values in specific instances of the class , i.e.  the objects .",
    "a class can have subclasses , which inherit its methods and properties ; the former is called the latter s superclass . in java",
    "there are also interfaces , which are collections of methods .",
    "if an object implements a specific interface , it has to implement all the interface s methods .    to trace a ray in tim ,",
    "a number of objects are interacting .",
    "the following are the most important ones .    rays . : :    each ray is an object of class ` ray ` , which has a starting position    and a normalised direction , both represented as 3d cartesian vectors . scene objects . : :    each scene object implements the interface ` sceneobject ` ; most    ( but , for complicated reasons , not all ) are instances of a subclass of    ` sceneobjectclass ` , which implements the ` sceneobject ` interface .    specifically , a scene object implements methods that calculate the    intersection point between the scene object and any ray , and methods    that calculate the colour of an intersection point when seen along the    direction of a given ray and under specified illumination",
    ". there are    particularly fundamental scene objects , each typically representing a    simple geometrical object ( such as a sphere ) with specific surface    properties ( such as reflective ) , which are instances of the    ` sceneobjectprimitive ` subclass of ` sceneobjectclass ` .",
    "another    subclass of ` sceneobjectclass ` is ` sceneobjectcontainer ` , which    represents a collection of scene objects .",
    "there are also more    complicated scene objects that are neither ` sceneobjectprimitive`s nor    ` sceneobjectcontainer`s , but ultimately every intersection with a    ` sceneobject ` must be traceable to an intersection with a    ` sceneobjectprimitive ` . surface properties . : :    perhaps the simplest surface property is a colour that is independent    of any light sources ( effectively a coloured glow ) , which is    represented by the class ` surfacecolourlightsourceindependent ` .",
    "the    colour of non - glowing surfaces depends on illumination , and this is    represented by the class ` surfacecolour ` , in which the surface has    separate diffuse and specular colours .",
    "the diffuse component colours    light due to lambertian reflectance  @xcite ; the specular components    colours light that is specularly ( or near - specularly )    reflected  @xcite .",
    "+    there are also classes representing surfaces on which the ray does not    end , but which change its direction .",
    "examples include mirror surfaces    ( ` reflective ` ) and refractive - index interfaces ( ` refractive ` ) .    +    finally , there is currently one class ( ` teleporting ` ) which continues    tracing a light ray with a changed direction and from a new starting    position .",
    "+    all surface properties implement the interface ` surfaceproperty ` .",
    "light sources .",
    ": :    light sources are represented by instances of the class ` lightsource ` .    in tim ,",
    "two types of light source are implemented : ambient light ,    represented by the class ` ambientlight ` , and light sources with a    specific 3d position which throw shadows and which can create    highlights due to specular ( or near - specular ) reflection off surfaces    of type ` surfacecolour ` .    ray - tracing software usually considers only those light rays that eventually enter the virtual camera .",
    "they do this by tracing light rays _ backwards _ , starting from each pixel in the camera s virtual detector chip .",
    "what they try to do is establish the colour such a light ray would have if it was travelling in the opposite direction , i.e.  the colour of the reverse ray , which is the colour an observer would see in the direction of the light ray .",
    "more details can be found in ref .",
    "@xcite .    backwards tracing a specific light ray in tim proceeds as follows :    1 .",
    "the ` sceneobject ` representing the entire scene is asked to return the colour of the reverse ray .",
    "the ` sceneobject ` finds the ` sceneobjectprimitive ` the light ray intersects ( if any ) , and asks its ` surfaceproperty ` to return the colour of the reverse ray .",
    "the ` surfaceproperty ` either changes the light - ray direction and starts tracing again , or it determines the colour of the surface under illumination by the ` lightsource ` . if the ` surfaceproperty ` is a ` surfacepropertycontainer ` , then the colours due to all the surface properties are summed ( by adding up the individual rgb components ) .",
    "the ` lightsource ` returns a colour according to its shading model .",
    "if the ` lightsource ` is a ` lightsourcecontainer ` , then it asks each of the ` lightsource`s it contains to return a colour and then sums these colours .",
    "we discuss the steps in some more detail below .    in tim , tracing an individual ray backwards",
    "is initiated by asking the ` sceneobjectcontainer ` containing all scene objects to return the colour an observer at the ray s starting point would see in the ray s direction .",
    "this is done by calling the ` sceneobjectcontainer ` s ` getcolour ` method ( which is defined in the ` sceneobjectcontainer ` s superclass ` sceneobjectclass ` ) .",
    "the ` sceneobjectcontainer ` then establishes which one ( if any ) of the scene objects it contains the ray would intersect with first . if the ray intersects none of the scene objects , then the ` getcolour ` method returns the colour black . if the ray intersects one of the scene objects , then the method establishes which ` sceneobjectprimitive ` was hit and calls this ` sceneobjectprimitive ` s ` surfaceproperty ` to establish the colour .",
    "each ` surfaceproperty ` implements a ` getcolour ` method , which returns the colour an observer at the ray s starting point would see in the ray s direction . in the simplest case , implemented in the class `",
    "surfacecolourlightsourceindependent ` ( surface type `` coloured ( glowing ) '' ) , the colour stored within the specific instance of the class is returned , irrespective of the illumination and the rest of the scene .",
    "illumination - dependent colour is handled by the ` surfacecolour ` class , which calls the light source s ` getcolour ` method to establish the appearance of the surface under illumination by the light source .",
    "there are also surface properties , for example ` reflective ` , whose ` getcolour ` method returns the colour resulting from tracing through the scene a new ray that starts from the intersection point and travels in a new direction ( given , in the case of the ` reflective ` class , by the law of reflection ) .",
    "finally , it is also possible to have surface properties whose ` getcolour ` method returns the colour resulting from tracing a new ray that starts at a point different from the intersection point ; the ` teleporting ` class is an example of such a class . in the latter two cases of surface properties that continue tracing rays through the optical system",
    ", the colour may be slightly darkened to represent a reflection or transmission coefficient of less than one .    a light source s ` getcolour `",
    "method calculates the colour in which an observer would see a specific surface colour at a particular point on a surface if it was illuminated only by this light source .",
    "tim models two different types of light source : ambient light ( class ` ambientlight ` ) , which illuminates all objects in all directions with a given rgb colour ; and ` phonglightsource ` , which implements the phong shading model @xcite .",
    "the latter corresponds roughly to a small , coloured light bulb : it has a specific position , which is used to determine whether the surface is in another scene object s shadow and whether near - specular reflection occurs , which leads to highlights ; and it has a specific colour .",
    "there is also a class ( ` lightsourcecontainer ` ) that models the effect of combinations of different light sources",
    ".    it should be clear from the above discussion that backward tracing of a ray ends when a light ray has intersected a surface with a surface of class ` surfacecolourlightsourceindependent ` , or when it hits a surface of class ` surfacecolour ` ( in which case the light source performs the final calculation of colour ) . sometimes it can happen that rays get `` trapped '' , for example between mirror surfaces such as those in canonical optical resonators @xcite . in such cases , a reflection ( or transmission )",
    "coefficient @xmath77 ensures exponential fall - off of the intensity with the number of bounces , so such light rays become dark .",
    "tim limits the number of bounces it models , and when the limit is reached returns the colour black .",
    "this is controlled by a variable called ` tracelevel ` , which gets passed between the objects .",
    "the backwards tracing process starts with ` tracelevel ` taking a value of typically 100 ; whenever a surface property initiates tracing of a new ray , it does so with a value of ` tracelevel ` that is reduced by 1 .",
    "when the value 0 is reached , the colour black is returned .",
    "tim is divided into a hierarchical package structure .",
    "we describe here the main branch of this structure , namely the ` optics ` package and the packages it contains .",
    "there are three additional packages :    1 .   `",
    "jama ` is a matrix package in the public domain @xcite .",
    "tim uses it ; for convenience , the unmodified third - party source code is distributed with tim s source code .",
    "math ` is a package that defines additional mathematical functionality as required , including classes dealing with complex numbers , 2d vectors , and 3d vectors .",
    "test ` contains only the class ` test ` , which can be executed as a java application for the purposes of testing any parts of the code .",
    "the ` optics ` package collects together optics - related code . at the top level",
    ", it contains the ` constants ` class , a collection of optics - related constants such as a few common refractive indices ; and ` doublecolour ` , which is used internally to represent colours .",
    "the only sub - package within the ` optics ` package that is distributed with tim s source code is ` optics.raytrace ` .",
    "it contains both the ray tracer code as well as associated mathematical , graphical and user interface code , organised in the form of a number of sub - packages . at the top level",
    ", it contains ` noninteractivetim ` , a template for a class that can be run as a java application that uses tim ( see section [ non - interactive - tim - appendix ] ) ; ` timapplet ` , the applet class that is called when the interactive version of tim is run as an applet ; ` timjavaapplication ` , which allows the interactive version of tim to be run as a java application ( with slightly increased functionality , specifically the ability to save images as ` .bmp ` files ) ; and ` timinteractivebits ` , a class that defines the interactive parts of tim , which are called by both the ` timapplet ` and ` timjavaapplication ` classes .",
    "the package ` optics.raytrace.core ` contains a number of the core ray - tracing classes and interfaces . a number of these , and their interactions ,",
    "are discussed in [ ray - tracing - appendix ] .",
    "the ray - tracing core classes and interfaces include those defining the structure of cameras ( ` camera ` ) , light sources ( ` lightsource ` ; see ` optics.raytrace.lights ` for implementations ) , scene objects ( ` sceneobject ` ; implementations are in package ` optics.raytrace.sceneobjects ` ) , surface properties ( ` surfaceproperty ` ; implementations in ` optics.raytrace.surfaces ` ) , rays ( ` ray ` and ` raywithtrajectory ` ) , and intersections between rays and objects ( ` raysceneobjectintersection ` ) .",
    "the ` studio ` class defines a collection of everything required to calculate a photo , namely information about the scene ( in a ` sceneobject ` object ) , lighting ( a ` lightsource ` object ) , and camera ( in the form of a ` camera ` object ; implementations of cameras are in the package ` optics.raytrace.cameras ` ) .",
    "a number of interfaces outline mechanisms for the parametrisation of object surfaces :    * ` parametrisedobject ` defines coordinates assigned to each point on a surface ; * ` one2oneparametrisedobject ` extends ` parametrisedobject ` by asking for the reverse of the coordinate assignment , i.e.  for a method that returns the point on a surface associated with a set of coordinate values .",
    "other classes included in the package are ` cameraclass ` , which implements a number of methods common to currently all cameras , and which is a superclass to currently all cameras ; ` sceneobjectclass ` , which similarly implements a number of methods common to most scene objects , and is a superclass of many scene - object classes ; ` sceneobjectprimitive ` , which describes simple geometric objects , such as spheres and planes ; ` ccd ` and ` centredccd ` , which represent the light - detecting element in cameras ; ` transformation ` , which defines the structure of geometrical transformations ( such as translation or rotation ) which can be applied to scene objects ( for implementations see package ` optics.raytrace.sceneobjects.transformations ` ) ; and ` doublecolourcamera ` and ` doublecolourccd ` , which define the structure of higher - quality cameras and their light - detecting elements .",
    "the useful ` optics.raytrace.demo ` package contains a number of classes which can be run as java applications and which demonstrate the use and effect of different features , for example ` lightsdemo ` , which was used to create fig .",
    "[ lights - demo - figure ] .",
    "it is worth studying the examples contained in this package to understand how to access tim s functionality .",
    "the package ` optics.raytrace.exceptions ` defines classes that signal exceptional circumstances that occured during rendering , for example a ray becoming evanescent ( ` evanescentexception ` ) .",
    "the ` optics.raytrace.cameras ` package contains implementations of the ` camera ` interface .",
    "these handle the mechanisms of generating the rays that are then traced through the scene , and of turning creating corresponding images . implemented camera classes include ` pinholecamera ` , which is the simplest type of camera that takes pictures in which everything is in focus ; ` aperturecamera ` , a camera with a circular aperture that can focus on any transverse plane ; ` anyfocussurfacecamera ` , a camera with a circular aperture that can focus very general surfaces ( section [ arbitrary - focus - surface - camera ] ) ; ` orthographiccamera ` , which produces orthographic projections into a plane ; ` anaglyphcamera ` , which can produce either red / blue or colour anaglyph images that can be viewed with standard red / cyan anaglyph glasses ( section [ anaglyph - section ] ) ; and ` autostereogramcamera ` , which can create random - dot autostereograms of the scene ( section [ autostereogram - section ] ) .",
    "effect of combination of different light sources . here ,",
    "a shiny blue sphere is illuminated by a combination of three phong light sources , one red , one green , one blue , placed in different directions high above the sphere .",
    "the phong light sources produce differently - coloured highlights at the top of the sphere and differently - coloured shadows ( the colours are due to subtractive colour mixing ) on the floor . where the shadows from all phong light sources overlap , the scene is completely black in the absence of an ambient light source .",
    "the image was rendered using the ` lightsdemo ` class in the ` optics.raytrace.demo ` package ( [ structure - appendix ] ) . ]",
    "the ` optics.raytrace.lights ` package includes implementations of light sources .",
    "these include ` ambientlight ` , which represents a coloured ambient light ; ` phonglightsource ` , which realizes the phong shading model @xcite , which is roughly equivalent to a slightly fuzzy point light source ; and ` lightsourcecontainer ` , which allows light sources to be combined .",
    "[ lights - demo - figure ] demonstrates effects due to different light sources .",
    "the package ` optics.raytrace.sceneobjects ` contains implementations of scene objects .",
    "it contains classes describing different types of scene objects :    simple geometrical shapes .",
    ": :    classes that describe simple geometrical shapes are implementations of    the ` sceneobjectprimitive ` class ( [ primitive - appendix ] ) .",
    "examples    include spheres ( ` sphere ` ) , planes ( ` plane ` ) , parallelograms    ( ` centredparallelogram ` ) , discs ( ` disc ` ) , and cylinders ( ` cylinder ` ) .",
    "combinations of other scene objects .",
    ": :    a number of classes describe compound objects    ( [ scene - object - combinations - appendix ] ) .",
    "examples include ` arrow ` ,    ` cylinder ` , and ` eye ` .",
    "shapes with parametrised surfaces .",
    ": :    parametrisation , described by implementations of the interfaces    ` parametrisedobject ` and ` one2oneparametrisedobject ` , assigns    coordinates to points on the surface of a geometrical shape    ( [ parametrisation - appendix ] )",
    ". examples of classes that define    parametrised geometrical shapes include ` parametrisedsphere ` ,    ` parametrisedplane ` , and ` parametrisedcentredparallelogram ` .",
    "there are    also classes that allow the range of the coordinates that describes    the surface of the geometrical shape to be varied .",
    "for example , in the    ` scaledparametrisedsphere ` class , the range of the polar angle    @xmath1 can be set to range from an arbitrary value    @xmath78 to another arbitrary value    @xmath79 .",
    "other examples include    ` scaledparametriseddisc ` and ` scaledparametrisedcentredparallelogram ` .",
    "the ` optics.raytrace.sceneobjects.solidgeometry ` package is a collection of classes useful for combining scene objects . in the simplest case",
    ", scene objects are grouped in a hierarchical way ( ` sceneobjectcontainer ` ) .",
    "more elaborate combinations of scene objects include intersections ( ` sceneobjectintersection ` ) , unions ( ` sceneobjectunion ` ) , and inverse ( ` sceneobjectinverse ` ) .",
    "one of the capabilities required of any scene object is the ability to create a transformed copy of itself .",
    "the structure of the transformation is defined by the ` transformation ` class ( in ` optics.raytrace.core ` ) .",
    "the package ` optics.raytrace.sceneobjects.transformations ` contains classes that describe specific types of transformation , i.e.  subclasses of ` transformation ` .",
    "examples include ` translation ` , ` rotationaroundxaxis ` , ` rotationaroundyaxis ` , ` rotationaroundzaxis ` , and the more general ` lineartransformation ` .",
    "the ` optics.raytrace.surfaces ` package contains implementations of the ` surfaceproperty ` interface ( in ` optics.raytrace.core ` ) .",
    "these include    * the classes representing coloured surfaces , ` surfacecolourlightsourceindependent ` and ` surfacecolour ` ; * a class representing a transparent surface ( ` transparent ` ) ; * the ` reflective ` class which represents specularly reflective surfaces ; * the ` refractive ` class which represents refraction at the interface between media with different refractive indices according to snell s law ; * a class that facilitates the implementation of classes that represent surfaces that change direction according to generalised laws of refraction ( ` metarefractive ` ) ; * a number of subclasses of ` metarefractive ` representing surfaces that invert of one of the ray - direction components tangential to the surface @xcite ( ` rayflipping ` ) , rotate the ray direction around the local surface normal @xcite ( ` rayrotating ` ) , and refract like  formally @xcite  the interface between media with a _",
    "complex _ refractive - index ratio would ( ` refractivecomplex ` ) ;",
    "* classes representing surfaces that have combinations of other surface properties ( ` surfacepropertycontainer ` and ` surfacepropertycontainerweighted ` ) ; * a ` semitransparent ` class , which combines an arbitrary surface property with the ` transparent ` surface property ; * a class representing a surface whose inside has different properties from its outside ( ` twosidedsurface ` ) ; * classes representing surfaces with completely different surface properties at different points on the surface ( ` surfacetiling ` , ` eitherorsurface ` , ` picturesurface ` , ` picturesurfacediffuse ` , ` picturesurfacespecular ` ; * a class representing the hologram of a thin lens ( ` thinlenshologram ` ) , which changes light - ray direction dependent on the point where it is being intersected ; * and a class representing a surface a light ray enters and then continues , from a corresponding position and with a corresponding direction , from the surface of a different scene object ( ` teleporting `  see section [ teleporting - section ] ; we use this to model geometric optical transformations @xcite ) .",
    "[ new - surface - property - appendix ] discusses how to add new surface properties to tim .",
    "the ` optics.raytrace.surfaces.metarefraction ` package contains description of the direction change performed by surfaces of class ` metarefractive ` ( see ` optics.raytrace.surfaces ` ) .",
    "the format of these descriptions is defined by the abstract ` metarefraction ` class .",
    "the ` complexmetarefraction ` class is a subclass of ` metarefraction ` , again abstract , which formulates the direction change in terms of the projections of the incoming and outgoing light rays into an argand plane tangential to the surface at the intersection point and with its origin there ( section [ surface - property - section ] ) @xcite .",
    "this is a generalisation of the formal description in terms of multiplication with a complex number of rotation of the light - ray direction around the local surface normal @xcite .",
    "all other classes in this package are non - abstract subclasses of ` complexmetarefraction ` .",
    "they include classes that describe surfaces that change light - ray direction described by complex multiplication ( ` complexmetarefractionmultiplication ` ) , complex addition ( ` complexmetarefractionaddition ` ) , complex conjugation ( ` complexmetarefractioncc ` ) , and complex exponentiation ( ` complexmetarefractionexp ` ) .",
    "the ` optics.raytrace.gui ` package is a collection of packages that together constitute tim s graphical user interface ( gui ) .",
    "all but one of the sub - packages of ` optics.raytrace.gui ` contain classes that handle user interaction in tim s interactive version .",
    "the exception that contains the classes that handle user interaction in the non - interactive version of tim is the package ` optics.raytrace.gui.noninteractive ` .",
    "it contains two classes : ` photocanvas ` , which creates a panel ( screen element ) in which ` noninteractivetim ` and classes derived from it display the rendered image ; and ` photoframe ` , which opens a window containing a ` photocanvas ` .",
    "editing one object in a hierarchical structure using the ` ipanel ` class .",
    "the top line displays a breadcrumb trail , giving an idea of the place in the hierarchy . ]",
    "the package ` optics.raytrace.gui.core ` contains gui core classes .",
    "the ` raytraceworker ` class handles rendering in a background thread , so that the gui can continue to react to user interaction .",
    "the class ` ipanel ` defines a screen element intended to allow browsing and editing hierarchical networks of objects on a relatively small screen area , so that it can be integrated into an internet page without necessarily dominating the page . at any one time",
    ", the panel corresponding to one object in this network is displayed . `",
    "ipanel ` handles a stack of these panels , displaying only the top one , and a breadcrumb trail of the other panels in the stack ( fig .",
    "[ ipanel - figure ] ) .",
    "the mechanism by which this panel is supplied by the object , and how control is handed over when another object s panel gets displayed in the ` ipanel ` , is defined in the ` ipanelcomponent ` interface , which all objects in tim which are editable interactively implement . `",
    "editablecamera ` is an interface that defines the functionality of an editable camera .",
    "the package ` optics.raytrace.gui.lowlevel ` is a collection of low - level classes related to the gui .",
    "the class ` guiframe ` represents the window tim s interactive version opens when run as a java application .",
    "` guipanel ` is the top - level screen element that contains the entire gui , i.e.  the tabs showing views of the rendered scene from different view points , any component being edited , and all buttons ( see fig .  [ tim - window - figure ] ) . `",
    "bufferedimagecanvas ` is the panel displaying the rendered image . `",
    "raytracingimagecanvas ` extends ` bufferedimagecanvas ` by adding some interactive functionality , including the ability to identify the scene object and coordinates of the point on the object the mouse pointer hovers over and clicks on , and the ability to edit that scene object by double - clicking on it .",
    "most classes provide panels for editing small chunks of data , including integers ( ` intpanel ` and ` labelledintpanel ` , an ` intpanel ` displayed next to a brief verbal description ) , individual double - precision real numbers ( ` doublepanel ` and ` labelleddoublepanel ` ) , pairs of double - precision real numbers ( ` twonumberspanel ` ) , complex numbers ( ` complexpanel ` and ` labelledcomplexpanel ` ) , 2d vectors ( ` vector2dpanel ` and ` labelledvector2dpanel ` ) , 3d vectors ( ` vector3dpanel ` and ` labelledvector3dpanel ` ) , and the limiting values of a range of real numbers ( ` labelledminmaxpanel ` ) .",
    "the class ` sceneobjectprimitivescombobox ` describes a panel that allows any ` sceneobjectprimitive ` in the scene to be selected , which is used in the panel editing surface properties for selecting a target object for a surface of type ` teleporting ` .",
    "there are a number of classes for editing camera - specific parameters such as aperture size ( ` aperturesizecombobox ` and ` labelledaperturesizecombobox ` ) ; quality ( ` qualitycombobox ` and ` labelledqualitycombobox ` ) , which can be applied to blurring and to anti - aliasing ; and all parameters related to camera blur collected in one panel ( ` blurpanel ` ) .",
    "the class ` buttonspanel ` describes a panel containing one or more buttons .",
    "the interface ` statusindicator ` outlines the structure of an object that can display brief status messages . finally , `",
    "guibitsandbobs ` is a small collection of miscellaneous methods commonly used by the gui .",
    "the package ` optics.raytrace.gui.cameras ` contains classes that describe various editable camera classes .",
    "the classes ` editableanyforucsurfacecamera ` , ` editableaperturecamera ` , ` editableanaglyphcamera ` , ` editableautostereogramcamera ` and ` editableorthographiccamera ` respectively extend the ` anyfocussurfacecamera ` , ` aperturecamera ` , ` anaglyphcamera ` , ` autostereogramcamera ` and ` orthographiccamera ` classes in this way .",
    "the classes ` editableorthographiccameraside ` and ` editableorthographiccameratop ` make special cases of the ` orthographiccamera ` class editable ; these respectively correspond to tim s `` side view '' and `` top view '' tabs .",
    "the package ` optics.raytrace.gui.sceneobjects ` contains the classes describing all editable scene objects .",
    "most of these are simply editable versions of classes in ` optics.raytrace.sceneobjects ` , including ` editablearrow ` , ` editableparametrisedcone ` , ` editableparametrisedcylinder ` , ` editableparametrisedplane ` , ` editableraytrajectory ` , ` editableraytrajectorycone ` , ` editablescaledparametriseddisc ` , ` editablescaledparametrisedcentredparallelogram ` , and ` editablescaledparametrisedsphere ` .",
    "the class ` editablesceneobjectcollection ` allows editing of groups of scene objects , which can be combined a number of ways respectively handled by the ` sceneobjectcontainer ` , ` sceneobjectintersection ` , and ` sceneobjectunion ` classes in the ` optics.raytrace.sceneobjects.solidgeometry ` package .",
    "a few of the classes defined in ` optics.raytrace.gui.sceneobjects ` exist only in editable form .",
    "examples include ` editablecylinderframe ` , ` editablecylinderlattice ` , ` editablelens ` , ` editableobjectcoordinatesystem ` , ` editablepolartocartesianconverter ` , and ` editabletelescope ` .",
    "the ` optics.raytrace.gui.surfaces ` package contains classes that enable selecting a class of surface property and editing class - specific parameters .",
    "the class that provides a panel for doing all of this is ` surfacepropertypanel ` ( see fig .",
    "[ surfacepropertypanel - figure ] , appendix [ interactive - surface - property - appendix ] ) .",
    "the remaining classes in this package allow editing of class - specific parameters . `",
    "editablesurfacetiling ` and ` editabletwosidedsurface ` are editable subclasses of ` surfacetiling ` and ` twosidedsurface ` , respectively . `",
    "teleportingtargetscombobox ` is a subclass of ` sceneobjectprimitivescombobox ` ( in the ` optics.raytrace.gui.lowlevel ` package ) that allows a suitable scene object contained in the scene to be selected . in its labelled form ( ` labelledteleportingtargetscombobox ` ) this is used in the ` surfacepropertypanel ` class to select a target object for the ` teleporting ` surface property .",
    "last , and least , the package ` optics.raytrace.gui.sceneobjects.transformations ` contains only the class ` editablelineartransformation ` , which will eventually be able to edit linear scene - object transformations ( see package ` optics.raytrace.sceneobjects.transformations ` ) and become part of tim s interactive version .",
    "tim s source code comes with a class called ` noninteractivetim ` , which can be compiled and run as a java application that defines a studio ( scene , camera and lights ) ; renders the scene under the conditions defined in the studio ; and displays the rendered image on the screen and saves it as a ` .bmp ` file .",
    "this class can serve as an example and template for using tim s source code .",
    "the class ` noninteractivetim ` provides three methods :    1 .   `",
    "getfilename ` returns the filename under which the rendered image is saved ; 2 .   `",
    "createstudio ` defines and returns the studio , i.e.  a scene , a camera , and lights ; 3 .   `",
    "main ` calls the ` createstudio ` method , renders the image , displays it on the screen , and saves it as a ` .bmp ` file ; automatically gets called when the ` noninteractivetim ` class is run as a java application .",
    "modifying these methods allows tim to perform tasks that can not currently be achieved in the interactive version ; below are a few examples .",
    "first we discuss modifying the ` createstudio ` method , which changes one or more of scene , camera and lights .",
    "this allows the programmer to do a number of things that are not currently possible in the interactive version , including    * setting parameter values by typing in formulas ; * using java s built - in flow control ( such as ` for ` or ` while ` loops ) and formulas to create a number of objects systematically ; * accessing classes of scene object not currently supported in the interactive version ( e.g.  ` maskedobject ` ) ; * transforming objects , e.g.  rotate , move , or scale them ( these transformations are defined in the ` optics.raytrace.sceneobjects.transformations ` package ) ; * accessing additional classes of surface properties ( an example is ` picturesurface ` , which maps a picture loaded from a file onto a surface ; other examples include several types of ` metarefractivesurface ` ) ; * giving surfaces _ combinations _ of surface properties ( which can be achieved by using the ` surfacepropertycontainer ` or ` surfacepropertycontainerweighted ` classes ) ; * changing the lights .    changing the behaviour of the resulting java application altogether can be achieved by altering the ` main ` class .",
    "simple examples include stopping the java application from saving the image ( by removing the relevant line in the code , or simply by commenting it out ) . by running a loop in which parameters change values , for example the position of a scene object or the camera , and by saving the rendered images with a suitable filename ( in the simplest case ending in a number ) ,",
    "the saved images can later be combined into a movie by other software .",
    "sometimes it is necessary to add a new class of scene object to tim . we can distinguish the following cases , which we treat in more detail in the following sections :    1 .",
    "it is desirable to add a class representing a geometrical shape not yet represented in tim , for example an ellipsoid or a torus .",
    "2 .   it is desirable to define a class representing combinations of geometrical shapes already represented in tim .",
    "one reason for doing so could be to automate the placing and adding to the scene of the constituent scene objects , for example the cone and the cylinder that form an arrow represented by the ` arrow ` class .",
    "the individual scene objects can also automatically be combined using the solid - geometry classes defined in the ` optics.raytrace.sceneobjects.solidgeometry ` package ; this is how a lens is created by the ` editablelens ` class .",
    "it is desirable to ( re)parametrise the surface of an existing geometrical shape .",
    "4 .   it is desirable to add a scene - object class that is represented in tim for non - interactive use to the interactive version .",
    "a geometrical shape is represented by a ( non - abstract ) subclass of the ( abstract ) ` sceneobjectprimitive ` class .",
    "this is itself a subclass of ` sceneobjectclass ` , an abstract class that implements some common methods required by the ` sceneobject ` interface such as keeping a copy of the studio , the parent object , and the description , and providing implementations of methods such as ` getcolour ` that reduce the task to other methods that remain to be implemented , such as finding the intersection between a ray and the object .",
    "it is instructive to study the implementation of such a class , for example ` sphere ` .",
    "any new subclass of the ` sceneobjectprimitive ` class needs to implement methods for dealing with the geometry of ray tracing , namely finding the intersection between a ray and the shape ( ` getclosestrayintersection ` ) ; calculating the normalised surface normal at any possible intersection point ( ` getnormalisedsurfacenormal ` ) ; and determining whether a position is inside the object or not ( ` insideobject ` ) .",
    "it also needs to implement methods for an instance of the class to make an identical copy of itself ( ` clone ` ) , or a copy that is geometrically transformed , for example shifted , rotated , or scaled ( ` transform ` ) .",
    "note that the surface normal points in the direction of the shape s outside . in many cases ,",
    "it is obvious which side of the surface is on the inside and which one is on the outside , for example in the case of a sphere .",
    "however , in other cases , for example in the case of a plane , it is not at all obvious . in such cases , the direction of the surface normal",
    "_ defines _ an inside and an outside .",
    "it is important to be able to distinguish inside from outside as many types of surface property , for example refraction , distinguish between rays that arrive from the inside from those arriving from the outside .",
    "sometimes it is desirable to define a new class of scene objects that consists of a number of scene objects of existing classes .",
    "examples include the ` arrow ` class , which represents a combination of a cone ( the arrow s tip ) and a cylinder ( the shaft ) , and the ` editablelens ` class , which represents a convex - convex lens .",
    "the easiest way to implement such a class is to extend the class that represents the appropriate combination of scene objects .",
    "for example , an arrow , which is simply a collection of a cone and a cylinder , can be realised by extending the class representing simple scene - object collections , ` sceneobjectcontainer ` ; a convex - convex lens , which is the intersection of two spheres , can be realised by extending the ` sceneobjectintersection ` class .",
    "all the class then needs to do ( usually in the constructor ) is to add the appropriate scene objects to the array of objects in the class , using the ` addsceneobject ` method .",
    "a number of surface properties require a surface that has a two - dimensional coordinate system associated with it ( section [ teleporting - section ] , especially fig .",
    "[ parametrisation - figure ] ) .",
    "an example of such a surface property is ` surfacetiling ` , which covers the surface in a chequerboard pattern in the surface s coordinate system .",
    "a surface that can calculate a pair of coordinates for any point on the surface is represented by the ` parametrisedobject ` interface ; it needs to implement methods for returning coordinates of an arbitrary point on the surface ( ` getsurfacecoordinates ` ) and for returning the corresponding coordinate names , for example ` theta ` and ` phi ` in the case of a sphere s polar coordinate system ( ` getsurfacecoordinatenames ` ) . a surface that can also identify a point on the surface for arbitrary coordinates",
    "is represented by ` one2oneparametrisedobject ` interface .",
    "such a surface needs to implement the methods required by the ` parametrisedobject ` interface , and additionally the ` getpointforsurfacecoordinates ` method .",
    "if the mapping between surface points and coordinates is not one - to - one then the behaviour of this method is undefined .",
    "note that there are scene objects , most notably compound scene objects , which can implement the ` parametrisedobject ` interface so that patterned surfaces can be applied to each constituent scene object , provided it implements ` parametrisedobject ` , but which should not implement the ` one2oneparametrisedobject ` interface even if all constituent scene objects do as there might be points on different constituent objects that correspond to the same combination of coordinate values , and so the mapping between surface points and coordinates is not one - to - one .",
    "a scene object that implements the ` parametrisedobject ` interface also defines directions on the surface , through the ` getsurfacecoordinateaxes ` call - back method .",
    "this allows the implementation of anisotropic surface properties , which require a preferred direction to be defined .",
    "[ parametrisation - figure ] shows these vectors for two points on the surface of an object of class ` parametrisedsphere ` . their primary purpose is to define directions on the surface , which is why they many methods that use these vectors normalise them .",
    "an example is the surface - property class ` metarefractive ` , which allows surfaces to deflect light rays in very general ways .",
    "( this can be seen as a generalisation of refraction at the interface between media with different refractive indices , or `` metarefraction '' @xcite . ) as many light - ray - direction changes are internally handled through the ` metarefractive ` class ( see [ new - metarefractive - surface - property - appendix ] ) , it is often important that surfaces implement the ` parametrisedobject ` interface .",
    "those light - ray - direction changes include snells - law refraction ( surface property ` refractive ` ) ; ray flipping , which changes the sign of one light - ray - direction component @xcite ( surface property ` rayflipping ` ) ; and ray rotation ( fig .",
    "[ tim - window - figure ] ) , which rotates the light - ray direction by an arbitrary ( but fixed ) angle around the local surface normal @xcite ( surface property ` rayrotating ` ) .    creating a class that parametrises the geometrical shape described in an existing class can be achieved by creating a subclass of the existing class .",
    "this new subclass needs to implement the methods of the relevant interfaces , ` parametrisedobject ` or ` one2oneparametrisedobject ` . if the existing class is already parametrised and the new subclass overrides its methods related to parametrisation , then the new class re - parametrises the geometrical shape described in the existing class .",
    "all scene - object classes available in the interactive version of tim need to be fully parametrised ( see previous section ) , i.e.  they need to implement the ` one2oneparametrisedobject ` interface .    for a class to be editable through the mechanism built into the interactive version of tim",
    ", it needs to implement the ` ipanelcomponent ` interface . to add an existing scene - object class to the interactive version of tim , it is easiest to create a subclass that implements the following methods required by ` ipanelcomponent ` :    1",
    ".   ` createeditpanel ` prompts the creation of the edit panel ( of class ` jpanel ` ) , an area of screen that allows interactive editing of any of the scene object s parameters ; 2 .   `",
    "discardeditpanel ` signals to the ` ipanelcomponent ` that the edit panel is no longer required , and any resources associated with it can be freed up ; 3 .",
    "` geteditpanel ` returns the edit panel ; 4 .",
    "` setvaluesineditpanel ` sets all the sub - panels in the edit panel to reflect the current values of the scene object s parameters ; 5 .",
    "` acceptvaluesineditpanel ` sets the scene object s parameters to the edited values in the edit panel ; 6 .",
    "` backtofront ` gets invoked after editing of a different ` ipanelcomponent ` s edit panel has been completed ( for example , the surface property of the current scene object could have been edited ) , and this one s edit panel is being edited again .",
    "the new class can now be part of the scene , and it can be edited , but it is so far not possible to create a new instance ( unless another one is being duplicated ) . creating a new instance of a scene object in interactive",
    "tim happens by adding a new scene object to a collection of scene objects .",
    "this collection can be `` the scene '' , which is the top - level collection of scene objects , but it can also be a collection that is part of `` the scene '' ( or of other collections in the hierarchy ) .",
    "editing a collection is handled by the ` editablesceneobjectcollection ` class .",
    "we will discuss the required steps using the example of the ` editabletelescope ` class .    1 .",
    "add a string that describes an object of this class ( e.g.  ` string object_telescope = telescope ; ` ) .",
    "2 .   add this string to the array of strings that are to be the menu items in the combo box responsible for initiating the creation of a new instance of a scene object ( e.g.  ` string [ ] componentstrings = \\ { [ ... ] , object_telescope , [ ... ] \\ } ; ` ) 3 .",
    "in the ` actionperformed ` method of the internal class ` sceneobjectcontrolpanel ` , which gets called whenever the user interacts with the combo box that initiates the creation of a new scene object , add a case that gets invoked when the user has selected the new object type in the new - object combo box . in the case of our example , it has the following form : + .... else if(newelementname.equals (      object_telescope )    )    ipanelcomponent = new editabletelescope (        \" telescope \" ,   // description        // default centre        new vector3d(0 , 0 , 10 ) ,        //",
    "default ocular normal        new vector3d(0 , 0 , -1 ) ,        1 ,   //",
    "default magnification        1 ,   // default radius of aperture        // parent in hierarchy",
    "editablesceneobjectcollection.this ,          // scene , lights and camera        getstudio ( )      ) ; ....",
    "one of the main reasons why we wrote tim was to be able to fully control the effect of surfaces on light rays , which has proved tremendously useful not only for our research on metatoys but also for our work on optical orbital angular momentum .",
    "this section outlines how new surface properties can be added to tim .",
    "tim establishes the effect of a surface on any specific light ray by asking the ` getcolour ` method of the ` surfaceproperty ` object representing the surface to return the colour of the reverse ray , i.e.  the light ray travelling in the opposite direction .",
    "the role of surfaces in establishing this colour is outlined in more detail in [ ray - tracing - appendix ] .",
    "a new surface property can be created by implementing the ` surfaceproperty ` interface directly .",
    "the class representing the new surface property must implement the ` getcolour ` method . precisely how it calculates the reverse ray s",
    "colour varies greatly between different surface - property classes .",
    "the ` getcolour ` method has access to all the information being passed to it as arguments :    * the ` ray ` object describing the incident light ray contains its direction and starting position ; * the ` raysceneobjectintersection ` object describing the intersection between the surface and the light ray contains the position of the intersection point and the primitive scene object being intersected ; * the entire scene information is passed in the form of a ` sceneobject ` object ; * information about lights is passed in the form of a ` lightsource ` object .        * the class ` surfacetiling ` is an example of a spatially varying surface property that calculates the local coordinates in the intersected primitive scene object s coordinate system .",
    "this is done by the code fragment + .... (    ( parametrisedobject)(i.o ) ) .getsurfacecoordinates(i.p ) , .... + where ` i ` is the ` raysceneobjectintersection ` object describing the intersection point ; ` i.o ` is the primitive scene object being intersected ( which has to implement the ` parametrisedobject ` interface here ; if it does not , an exception is thrown ) ; and ` i.p ` is a 3d vector describing the position of the intersection point . *",
    "the class ` reflective ` is an example of a surface property that requires further ray tracing . its ` getcolour ` method illustrates , amongst other things , checking that the trace level is greater than zero and continuing backwards ray tracing with a new direction .",
    "the latter is achieved by the following code segment : + .... return scene.getcolouravoidingorigin (    ray.getbranchray(i.p , newraydirection ) ,    // the primitive scene object being    //",
    "intersected    i.o ,    l ,     // the light source(s )    scene ,     // the entire scene    tracelevel-1 ) .multiply(reflectioncoefficient ) ; .... + note that creating the continuation of the ray using the original ray s ` getbranchray ` method ensures the ray trajectory is recorded correctly ( see section [ light - ray - visualisation - section ] ) ; that the branch ray is being launched with a trace level reduced by 1 ; and that the intensity of the branch ray is multiplied by a reflection coefficient stored in the ` reflective ` object .",
    "[ [ new - metarefractive - surface - property - appendixadding - a - surface - property - that - affects - only - light - ray - direction ] ] [ new - metarefractive - surface - property - appendix]adding a surface property that affects only light - ray direction ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~    as surface properties that change light - ray direction in different ways are of particular interest to us for the purposes of our metatoys research , we have put in place a surface - property class that aims to facilitate the creation of new light - ray - direction - changing surface properties .",
    "the direction change itself is described by a subclass of the abstract ` metarefraction ` class , which must provide methods that calculate the new light - ray direction from the old light - ray direction for the two cases of light travelling inwards , i.e.  arriving from the surface s outside , or outwards , i.e.  arriving from the inside .",
    "( inside and outside are defined by the direction of the normalised surface normal , which can be obtained with the ` sceneobjectprimitive ` class s ` getnormalisedsurfacenormal ` method , and which is defined to point outwards . )",
    "these methods are the call - back methods ` refractinwards ` and ` refractoutwards ` .",
    "the surface - property class that represents this light - ray - direction change is of class ` metarefractive ` .",
    "the description of the direction change ( i.e.  the implementation of the ` metarefraction ` class ) is passed as an argument to the constructor of the ` metarefractive ` surface property ; in other words , an object of class ` metarefractive ` is always created around a specific light - ray - direction change .    in tim , most light - ray - direction changes at surfaces are described in terms of their projection into an argand plane tangential to the surface at the intersection point and with its origin placed there ( section [ surface - property - section ] ) @xcite . a complex number that corresponds to the projection of the incoming light ray",
    "is mapped to another complex number , which corresponds to the projection of the outgoing light ray .",
    "the component in the direction of the surface normal is calculated so that the length of the direction vector remains unchanged .",
    "the mapping of the light - ray projection then defines the direction change ; for example , refraction according to snell s law is described by multiplication with a real number , and rotation through an angle @xmath11 around the surface normal is described by multiplication with a complex number of the form @xmath12 @xcite .",
    "direction changes can be described in this way by the ` complexmetarefraction ` class , which is a subclass of ` metarefraction ` .",
    "examples of surface properties which have been implemented by extending the ` metarefractive ` surface - property class , and which use extensions of the ` complexmetarefraction ` class to describe the light - ray - direction change they represent , include ` rayflipping ` , which represents surfaces that change the sign of one of the ray - direction components tangential to the surface at the intersection point @xcite ; ` rayrotating ` , which represents surfaces that rotate the light - ray direction by an arbitrary , but fixed , angle around the local surface normal @xcite ; ` refractive ` , which represents standard snells - law refraction at the interface between optical media with different refractive indices ; and ` refractivecomplex ` , which represents a combination of snells - law refraction and rotation around the local surface normal , which can be described formally as refraction at the interface between optical media with different _ complex _ refractive indices  @xcite .    [",
    "[ interactive - surface - property - appendixadding - an - existing - surface - property - class - to - interactive - tim ] ] [ interactive - surface - property - appendix]adding an existing surface - property class to interactive tim ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~    the panel for editing the surface property an orange object .",
    "the top half allows selecting a surface - property class ; the lower half allows editing of parameters specific to the selected class , in this case the red ( r ) , green ( g ) , and blue ( b ) values of the surface colour .",
    "the panel is created by the class ` surfacepropertypanel ` . ]",
    "surface properties are being selected in a panel described by the ` surfacepropertypanel ` class ( fig .",
    "[ surfacepropertypanel - figure ] ) .",
    "this panel consists of a combo box that allows selection of the class of surface property , and space for editing any parameters specific to the selected surface - property class .",
    "the following modifications of the ` surfacepropertypanel ` class add an existing surface - property class to tim s interactive incarnation ; we discuss these using the example of the surface property describing a coloured surface ( ` surfacecolour ` in ` optics.raytrace.surfaces ` ) .    1 .",
    "define a string constant , with a suitable name , that describes the surface property .",
    "after completion of the steps below , the contents of this string will come up as an option in the combo box for selecting a surface - property class . in our example , add the lines + .... private static final string    surface_property_description_coloured =      \" coloured \" ; .... 2 .",
    "if the surface - property class requires additional parameters , define a variable that can hold the panel for editing these parameters .",
    "in our example , this panel allows separate editing of the red , green and blue ( rgb ) components of the surface colour , and it has a label which helpfully points out what it is the user is editing ( `` colour '' ) .",
    "all of this can be achieved with the ` labelleddoublecolourpanel ` class , using the following lines of code : + .... private labelleddoublecolourpanel    colourpanel ; .... + in the constructor of the ` surfacepropertypanel ` class , create an instance of the panel for the additional parameters and initialise it with a default value : + .... colourpanel =    new labelleddoublecolourpanel(\"colour \" ) ; colourpanel.setdoublecolour (      doublecolour.white    ) ; .... 3 .",
    "the ` setsurfaceproperty ` method contains a chain of ` if ` statements that distinguishes between different surface - property classes of the variable ` surfaceproperty ` . into this chain ,",
    "link a case for the surface - property class to be added . in the code block for this ` if ` statement , add statements that make the surface - property class that currently selected in the surface - property - class combo box ; set the panel for editing the surface - property - class - specific parameters to reflect the properties of the variable ` surfaceproperty ` ; and ensure that the panel for editing the class - specific parameters is shown .",
    "the following block of code does this for our example : + .... if(surfaceproperty instanceof surfacecolour ) {    surfacepropertycombobox .",
    "setsurfacepropertystring (        surface_property_description_coloured      ) ;    colourpanel.setdoublecolour (      (        ( surfacecolour)surfaceproperty      ) .getdiffusecolour ( )    ) ;    setoptionalparameterpanelcomponent (        colourpanel      ) ; } .... 4 .",
    "there is a similar chain of ` if ` statements in the ` getsurfaceproperty ` method . into that chain , add a case that returns an instance of the new surface - property class with the parameters from the class - specific - parameters panel . in our case , the following lines do this : + .... if(surfacepropertystring.equals (      surface_property_description_coloured    ) ) {    // return a shiny version of the colour    return new surfacecolour (        colourpanel.getdoublecolour ( ) ,        // specular component ; white = shiny        doublecolour.white    ) ; } .... 5 .",
    "the remaining changes are to the internal class ` surfacepropertycombobox ` , which describes the combo box for selecting a surface - property class .",
    "first , the code for adding the string describing the new surface - property class to the various options available for selection by the combo box needs to be added to the constructor .",
    "this is done by adding the string constant describing the surface property defined above to the array of strings called ` surfacepropertystrings ` .",
    "for our example , + .... surfacepropertystrings.add (      surface_property_description_coloured    ) ; .... 6 .",
    "finally , in the ` actionperformed ` method , a case needs to be added to the chain of ` if ` statements which displays the class - specific - parameters panel in case the user selects the new surface - property class in the surface - property - class - selection combo box . in our example , the following code is suitable : + .... if(surfacepropertystring.equals (      surface_property_description_coloured )    ) {    setoptionalparameterpanelcomponent (        colourpanel      ) ; } ....    for a few classes of surface property it is necessary to edit more parameters than fit into the space reserved for the surface - property panel .",
    "the way this has been achieved in tim is by making the surface - property - class - specific panel consist of a button which , when clicked , initiates editing of the class - specific parameters .",
    "the details of how this has been implemented can be seen by studying how the classes describing tiled and two - sided surfaces , ` surfacetiling ` and ` twosidedsurface ` , respectively , have been incorporated into the ` surfacepropertypanel ` class .",
    "tyler , c.  w. and clarke , m.  b. , the autostereogram , in _ stereoscopic displays and applications _ ,",
    "volume 1258 of _ spie proceedings series _ , pages 182196 , bellingham , washington , 1990 , spie - the international society for optical engineering ."
  ],
  "abstract_text": [
    "<S> tim ( the interactive metatoy ) is a ray - tracing program specifically tailored towards our research in metatoys , which are optical components that appear to be able to create wave - optically forbidden light - ray fields . </S>",
    "<S> for this reason , tim possesses features not found in other ray - tracing programs . </S>",
    "<S> tim can either be used interactively or by modifying the openly available source code ; in both cases , it can easily be run as an applet embedded in a web page . here </S>",
    "<S> we describe the basic structure of tim s source code and how to extend it , and we give examples of how we have used tim in our own research .    </S>",
    "<S> = 1    ray tracing ; geometrical optics ; metatoys    * program summary *    _ manuscript title : _ </S>",
    "<S> tim , a ray - tracing program for forbidden ray optics + _ authors : _ dean lambert , alasdair c.  hamilton , george constable , harsh snehanshu , sharvil talati , johannes courtial + _ program title : _ </S>",
    "<S> tim + _ journal reference : _ </S>",
    "<S> + _ catalogue identifier : _ </S>",
    "<S> + _ licensing provisions : _ gnu gpl + _ programming language : _ </S>",
    "<S> java + _ computer : _ any computer capable of running the java virtual machine ( jvm ) 1.6 + _ operating system : _ any ; developed under mac os x version 10.6 + _ ram : _ typically 145 mb ( interactive version running under mac os x version 10.6 ) + _ keywords : _ ray tracing , geometrical optics , metatoys + _ classification : _ 14 graphics , 18 optics + _ external routines / libraries : _ jama @xcite ( source code included ) + _ nature of problem : _ + visualisation of scenes that include scene objects that create wave - optically forbidden light - ray fields + _ solution method : _ ray tracing + _ unusual features : _ </S>",
    "<S> + specifically designed to visualise wave - optically forbidden light - ray fields ; can visualise ray trajectories ; can visualise geometric optic transformations ; can create anaglyphs ( for viewing with coloured `` 3d glasses '' ) and random - dot autostereograms of the scene ; integrable into web pages + _ running time : _ </S>",
    "<S> + problem - dependent ; typically seconds for a simple scene +    0 jama : a java matrix package , http://math.nist.gov/javanumerics/jama/ </S>"
  ]
}