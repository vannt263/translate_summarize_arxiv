{
  "article_text": [
    "systems are becoming ubiquitous and an integral part of our everyday life . addressing functional safety",
    "is a major challenge with increasing complexity .",
    "typical examples of safety - critical embedded systems include vehicle safety or driver assistance systems with accident prevention .",
    "however , functional safety is becoming more prevalent not just in the automotive sector , but also in industrial markets such as aviation , solar energy , and the medical sector @xmath4 .",
    "memory devices increasingly provide built - in error correction in order to restore corrupted data  @xcite and also to maximize the number of writes in flash memory  @xcite . with information and communication technology components becoming ever smaller and more complex",
    ", the probability for hardware immanent error arises .",
    "decoders taking advantage of the cyclic structure of shortened reed ",
    "muller codes accommodate the increasing demand for less space consumption  at the cost of the decoding duration  @xcite . on the other hand ,",
    "several recursive algorithms were developed allowing decoding with only @xmath5 operations  @xcite .",
    "though the number of operations could be reduced , all these operations need to be executed one after another .",
    "therefore , these algorithms require much parallel time .",
    "parallel time is defined as the time the algorithm takes if all its modules are parallelized to the maximum possible amount .",
    "thus , cyclic as well as recursive decoders are not designed for correcting errors in parallel . however , for all safety - critical applications , where real - time control is ranked first , decoding multiple positions in parallel saves precious time .",
    "decoders based on majority - logic can accomplish this task .",
    "furthermore , in embedded systems , very simple hard - decision algorithms are mostly preferable to soft - decision algorithms  @xcite .",
    "therefore , hard - decision decoders for reed  muller codes using decision by majority are an attractive option for forward error correction in real - time on hardware level .",
    "a majority - logic decoding algorithm was first proposed by reed  @xcite .",
    "reed s algorithm consists of @xmath6 decoding steps in which majority voting is performed .",
    "chen  @xcite significantly improved reed s decoding algorithm by reducing the number of decoding steps . in particular ,",
    "if reed  muller codes @xmath0 with @xmath1 @xmath7 are employed , chen s algorithm consists of only two decoding steps . in this case , up to @xmath8 functions are called concurrently and chen s algorithm can be executed in constant parallel time provided majority voting also takes constant parallel time .",
    "the authors in  @xcite investigated how far the number of majority votes in chen s algorithm can be reduced while focusing on information bits .",
    "they established upper and lower bounds for the complexity .",
    "but an explicit instruction how to construct a decoder is only provided for a few codes .",
    "furthermore , their decoding process depends on the encoding procedure .    in the present paper",
    ", we propose a new hard - decision decoding algorithm for all reed ",
    "muller codes @xmath0 with @xmath1 @xmath2 our decoder is easy to design for software and hardware applications .",
    "the algorithm decodes all bits , i.e. , information and redundancy , without considering the encoding process .",
    "compared to state - of - the - art majority - logic decoders , our algorithm is less complex .",
    "in contrast to recursive decoders  @xcite , our decoder enables massively parallel decoding in constant parallel time .",
    "the paper is organized as follows .",
    "section  [ sect01 ] introduces the notation and preliminaries on reed  muller codes . in section  [ sect02 ] ,",
    "we revisit chen s decoding algorithm and analyze its complexity . in section  [ sect03 ] ,",
    "we present in detail our new decoding algorithm including proof of correctness , pseudocode , estimation of complexity and an example for @xmath9 .",
    "our algorithm is compared to chen s algorithm in terms of complexity in section  [ sect04 ] .",
    "the paper concludes in section  [ sect05 ] with further advantages of our algorithm in comparison to other classes of decoders .",
    "the binary reed  muller code @xmath0 is a @xmath10 $ ] code with @xmath11 which guarantees correcting up to @xmath12 errors .",
    "we number the vectors in @xmath13 in arbitrary order starting from zero .",
    "every position @xmath14 in a binary word of length @xmath15 is identified by @xmath16 then , we characterize a set of vectors @xmath17 by its incidence vector @xmath18 the @xmath19-th position in @xmath20 is set to one if and only if @xmath21    a _ @xmath22-flat _ is a @xmath22-dimensional affine subspace in @xmath23 given @xmath24 , @xmath25 and the specific ordering , the reed ",
    "muller code @xmath0 is generated by all incidence vectors that characterize @xmath22-flats with @xmath26  @xcite .",
    "therefore , we denote by @xmath0 not one code but a family of equivalent codes depending on the chosen ordering in @xmath13 .    for the rest of the paper , let @xmath7 , @xmath27 .",
    "furthermore , we generally assume a codeword @xmath28 was sent through a noisy channel and @xmath29 was received where at most @xmath12 errors occurred .    for any vectors",
    "@xmath30 , let @xmath31 denote the scalar product @xmath32 of the two vectors @xmath33 and @xmath34 .",
    "let @xmath17 be arbitrary .",
    "the scalar product @xmath35 is called the _ check - sum of @xmath36_. since @xmath37 it is not necessary to consider all @xmath15 entries of @xmath38 . to reduce the complexity of computing the check - sum of @xmath36 , we only take into account the @xmath39 entries",
    "@xmath40 , @xmath41 .    in the following",
    ", we will say that @xmath36 _ possesses @xmath42 errors _ if and only if @xmath43 in particular , we call @xmath36 _ odd _ or _ even _ if @xmath36 possesses an odd or even number of errors , respectively . note that @xmath36 is odd if and only if @xmath44 .",
    "the majority function @xmath45 is defined as follows : @xmath46 where @xmath47 represents the largest integer not greater than @xmath48 .",
    "chen s decoding algorithm  @xcite corrects in two majority - logic steps all @xmath15 positions .",
    "it operates on flats of dimension @xmath6 or less and performs majority voting .",
    "chen s algorithm takes advantage of the following proposition .",
    "[ 27 ] let @xmath49 be arbitrary .",
    "suppose there exist @xmath50 with @xmath51 which intersect pairwise in @xmath36 , i.e. , @xmath52 for all @xmath53 , @xmath54 .",
    "then @xmath36 is odd if and only if more than @xmath55 sets @xmath56 are odd .",
    "suppose @xmath36 possesses @xmath42 errors . beyond these @xmath42 errors , up to @xmath57 further errors occurred while transmitting the codeword .",
    "therefore , at least @xmath58 sets @xmath56 must possess the same number of errors as @xmath36 , namely @xmath42 errors . note that @xmath59 hence , if @xmath42 is odd , more than @xmath55 sets @xmath56 are odd . on the other hand ,",
    "if @xmath42 is even , at least @xmath55 sets @xmath56 are even and therefore at most @xmath55 sets @xmath56 are odd .    according to proposition  [ 27 ]",
    ", it can be deduced whether a set @xmath36 in @xmath13 is odd or even , once we have this information about @xmath60 arbitrary supersets of @xmath36 , intersecting pairwise in @xmath36 .",
    "for some sets , namely @xmath22-flats with @xmath61 this information can be easily gained .",
    "let us consider a @xmath22-flat @xmath62 with @xmath63 then , its incidence vector , @xmath64 is a codeword of @xmath65 , the dual code of @xmath0  @xcite .",
    "thus , @xmath66 hence , @xmath62 is odd if and only if the check - sum of @xmath62 equals one .",
    "reed  @xcite proposed an algorithm comprising @xmath6 steps in which proposition  [ 27 ] is applied .",
    "taking into account the check - sums of certain @xmath67-flats , the algorithm computes in the first step whether certain @xmath24-flats are even or odd using majority - logic . in each step",
    "@xmath68 it is iteratively decided whether the @xmath69-flats are odd or even . in the final step , the algorithm yields the number of errors in @xmath70-flats where every @xmath70-flat corresponds to a single position .    analyzing reed s algorithm",
    ", chen noticed that several steps can be omitted . in the case of",
    "@xmath71 @xmath72 chen showed that for every position @xmath73 there exist @xmath60 @xmath24-flats intersecting pairwise in @xmath74 .",
    "in addition , each @xmath24-flat is the pairwise intersection of @xmath60 @xmath67-flats  @xcite .",
    "this observation is the basis for a two - step majority - logic algorithm to decode all @xmath15 positions .",
    "the first step is identical to the one in reed s algorithm where the second step deduces the number of errors in @xmath70-flats directly from the results for @xmath24-flats .",
    "chen s algorithm operates on a set of flats of dimension 0 , @xmath24 and @xmath75 say @xmath76 which meets the following conditions .    1 .",
    "@xmath77 for all @xmath78 2 .",
    "for every @xmath70-flat @xmath79 there exist @xmath24-flats @xmath80 with @xmath81 for @xmath82 3 .",
    "for every @xmath24-flat @xmath83 there exist @xmath67-flats @xmath84 with @xmath85 for @xmath82    we call a set of flats _ admissible _ if it satisfies these three conditions .",
    "furthermore , we say _",
    "@xmath86 is used for decoding of @xmath62 _ and _ @xmath87 is used for decoding of @xmath88 _",
    ", @xmath89    by proving the existence of an admissible set in  @xcite , chen indicates a strategy how to decode all positions in two steps using majority - logic .",
    "[ 05 ] let @xmath90 be arbitrary and let @xmath91 be an admissible set .    1 .",
    "[ 31 ] an error occurred at position @xmath19 , i.e. , @xmath92 , if and only if more than half of the @xmath24-flats used for decoding of @xmath74 are odd .",
    "2 .   [ 32 ] an @xmath24-flat @xmath83 is odd if and only if more than half of the @xmath67-flats used for decoding of @xmath62 are odd .",
    "we recall that an @xmath67-flat @xmath93 is odd if and only if @xmath94    the flats used for decoding are labeled as follows .",
    "for all @xmath73 let @xmath95 be a set of @xmath24-flats used for decoding of @xmath74 and for all @xmath96 let @xmath97 be a set of @xmath67-flats used for decoding of @xmath98 the corresponding algorithm consists of four _ function levels_.    the received word @xmath99 at most @xmath12 errors occurred the actual transmitted codeword from @xmath0 @xmath100 @xmath101[33 ] @xmath102 @xmath103[29 ] @xmath104 @xmath105[30 ] @xmath106    the symbol `` @xmath107 '' represents an addition in @xmath108 if not more than @xmath12 errors occurred , @xmath109 equals the error pattern @xmath110 such that the actual transmitted codeword @xmath111 is returned .",
    "the term two - step decoding refers to the two steps in line  [ 29 ] and  [ 30 ] testing for majority .      at each of the four function levels , a specific function",
    "is called multiple times .",
    "all function calls at the same function level can be carried out simultaneously . in table",
    "[ table05 ] , we specify for each function level how often the corresponding function is called ( simultaneously ) and how many inputs the function gets . in total , @xmath112 functions are called in chen s algorithm .",
    "level & & & function calls + 1&check - sum & @xmath113 & @xmath114 + 2&majority vote & @xmath115 & @xmath116 + 3&majority vote & @xmath115 & @xmath15 + 4&xor & 2 & @xmath15 +",
    "our new decoding algorithm consists of two majority - logic steps .",
    "in contrast to chen , we test less times for majority and compute less check - sums .",
    "more precisely , we substitute step [ 32 ] in chen s decoding procedure @xmath117 by a more efficient method , while we maintain step [ 31 ] .",
    "there are two main reasons why our new algorithm is less complex than chen s decoding procedure .",
    "first , instead of considering arbitrary flats for decoding , we use every @xmath24-flat for all its @xmath118 positions .",
    "second , we never consider @xmath67-flats .",
    "instead , we developed a new approach where we focus solely on @xmath24-flats .",
    "we start constructing a set of @xmath24-flats , @xmath76 having the characteristics specified in the following proposition .    [",
    "03 ] there exist @xmath119 @xmath24-flats in @xmath13 such that the intersection of any two of them has at most size 1 and every @xmath120 is contained in exactly @xmath60 of these @xmath24-flats .    in the proof of this proposition",
    ", the authors of  @xcite verify the existence by demonstrating how to construct such a set of @xmath24-flats . at the very beginning ,",
    "@xmath60 @xmath24-dimensional subspaces in @xmath13 , say @xmath121 , pairwise intersecting in @xmath122 need to be computed .",
    "in fact , for @xmath123 , @xmath124 , @xmath125 , at least @xmath126 such subspaces exist  ( * ? ? ? * ch .",
    "1.1 , corollary  2.4 ) and can be constructed as shown in  ( * ? ? ?",
    "1.1 , lemma 2.2 ,  corollary  2.3 , corollary  2.4 ) .",
    "note that @xmath127 . then , for all @xmath128 , let @xmath129 be a complementary subspace of @xmath130 such that @xmath131 .",
    "we can state two facts .",
    "first , for every vector @xmath120 and for every subspace @xmath130 , @xmath132 there exists an @xmath133 such that @xmath134 second , every two @xmath24-flats have at most one vector in common because the intersection of the underlying subspaces is trivial .",
    "thus , the set of @xmath24-flats @xmath135 comprising @xmath119 @xmath24-flats , meets the conditions stated in proposition  [ 03 ] .",
    "the algorithm we will propose operates on this set of @xmath24-flats . before we present our algorithm , we will explain its mathematical background in theorem  [ 07 ] using the following notations .",
    "we define @xmath67-flats @xmath136 and integers @xmath137 @xmath138 for all @xmath139 with @xmath132 @xmath140 @xmath82    [ 07 ]    1 .",
    "[ 22 ] an error occurred at position @xmath141 , i.e. , @xmath142 , if and only if at least @xmath143 flats from @xmath91 containing @xmath144 are odd .",
    "2 .   [ 23 ] a flat @xmath145 is odd if and only if @xmath146 .",
    "before we prove theorem  [ 07 ] , we state some general properties of flats .",
    "[ 02]let @xmath147 be arbitrary",
    ". then    1 .",
    "[ 04 ] @xmath148[14 ] 2 .",
    "[ 06 ] @xmath149[15 ] 3 .",
    "@xmath150[16 ]    for all pairwise distinct indices @xmath151    1 .",
    "2 .   clearly , @xmath152 and with  [ 04 ] @xmath153 3 .   follows from  [ 04 ] and  [ 06 ] .",
    "assertion  [ 22 ] directly follows from proposition  [ 27 ] . proceeding to part  [ 23 ]",
    ", let @xmath133 and @xmath147 be arbitrary .",
    "we will prove that the following statements are equivalent .    1 .",
    "[ 37 ] the flat @xmath145 is odd .",
    "2 .   [ 35 ] @xmath154 .",
    "3 .   [ 36 ] @xmath155 .",
    "@xmath156 the @xmath157 distinct @xmath67-flats @xmath158 @xmath159 @xmath160 intersect pairwise in @xmath161 by lemma  [ 02 ] .",
    "thus , by proposition  [ 27 ] , the flat @xmath161 is odd if and only if at least @xmath143 of these @xmath67-flats @xmath162 are odd resulting in the formula stated in  [ 35 ] .",
    "+ @xmath163 similarly to equation  , we have @xmath164 for every @xmath159 @xmath160 where the second equality follows from lemma  [ 02 ] .",
    "we show now that @xmath165 .",
    "suppose @xmath166 .",
    "it follows from   that for every @xmath167 with @xmath168 @xmath169 applying the already proved equivalence @xmath156 , we conclude @xmath170 is odd for every @xmath167 with @xmath168 .",
    "thus , @xmath143 @xmath24-flats are odd . since these @xmath24-flats are pairwise disjoint by lemma  [ 02 ]  [ 14 ] , we have at least @xmath143 errors , a contradiction . hence , @xmath171    let us assume @xmath172 then , by the definition of @xmath173 and what we have shown before , there exist at least @xmath174 scalars , say @xmath175 being unequal to @xmath176 according to equation  , we have @xmath177 for all @xmath178    on the other hand , assuming @xmath179 , there are at most @xmath12 scalars @xmath180 differing from @xmath176 by equation  , less than @xmath143 of the @xmath181 , @xmath182 , @xmath183 , are 1 .      our new algorithm is strongly based on theorem  [ 07 ] . tracing back",
    "in which @xmath24-flats every position is contained enables us to design the decoding procedure .",
    "therefore , we define mappings @xmath184 , @xmath128 , from @xmath185 to @xmath186 ensuring that @xmath187 and therefore @xmath188 for all @xmath189 , @xmath128 . once the decoder has been constructed , this mapping between positions and @xmath24-flats is no longer needed .",
    "the received word @xmath99 at most @xmath12 errors occurred the actual transmitted codeword @xmath190    @xmath191 @xmath192[39 ] @xmath193@xmath194[19 ] @xmath195    @xmath196 @xmath197[40 ] @xmath198[42 ]    @xmath199[21 ] @xmath200    @xmath106[43 ]    first , the scalar @xmath201 is computed for every @xmath24-flat @xmath202 .",
    "second , after evaluating the majority function at @xmath203 for each @xmath128 , the value @xmath173 is added to the scalars @xmath204 where the symbol `` @xmath107 '' represents an addition in @xmath205 .",
    "this guarantees with reference to theorem  [ 07 ] that each @xmath206 equals one if and only if @xmath161 is odd .",
    "finally , the value one is assigned to @xmath207 if and only if the majority of the scalars @xmath208 assumes one . provided not more than @xmath12 errors occurred ,",
    "@xmath109 equals the error pattern @xmath110 and @xmath209      our algorithm consists of five function levels .",
    "analogous to chen s algorithm , a specific function is called multiple times at each function level and all function calls at the same function level can be carried out simultaneously ( see table  [ table06 ] ) . because @xmath210 and therefore , @xmath211 , overall , @xmath212 functions are called in our algorithm .",
    "level & & & function calls + 1&check - sum&@xmath213 & @xmath214 + 2&majority vote&@xmath215 & @xmath60 + 3&xor&2 & @xmath119 + 4&majority vote & @xmath115 & @xmath15 + 5&xor & 2 & @xmath15 +      for every @xmath19 , @xmath216 , let the vector @xmath217 be the binary representation of @xmath19 such that @xmath218 for reasons of clarity , we primarily write @xmath19 instead of @xmath219 .    the reed ",
    "muller code @xmath9 is an @xmath220$]-code correcting three errors .",
    "a generator matrix @xmath221 is given by    @xmath222 1&1&1&1&1&1&1&1&1&1&1&1&1&1&1&1&1&1&1&1&1&1&1&1&1&1&1&1&1&1&1&1\\\\ 0&0&0&0&0&0&0&0&0&0&0&0&0&0&0&0&1&1&1&1&1&1&1&1&1&1&1&1&1&1&1&1\\\\ 0&0&0&0&0&0&0&0&1&1&1&1&1&1&1&1&0&0&0&0&0&0&0&0&1&1&1&1&1&1&1&1\\\\ 0&0&0&0&1&1&1&1&0&0&0&0&1&1&1&1&0&0&0&0&1&1&1&1&0&0&0&0&1&1&1&1\\\\ 0&0&1&1&0&0&1&1&0&0&1&1&0&0&1&1&0&0&1&1&0&0&1&1&0&0&1&1&0&0&1&1\\\\ 0&1&0&1&0&1&0&1&0&1&0&1&0&1&0&1&0&1&0&1&0&1&0&1&0&1&0&1&0&1&0&1\\\\ 0&0&0&0&0&0&0&0&0&0&0&0&0&0&0&0&0&0&0&0&0&0&0&0&1&1&1&1&1&1&1&1\\\\ 0&0&0&0&0&0&0&0&0&0&0&0&0&0&0&0&0&0&0&0&1&1&1&1&0&0&0&0&1&1&1&1\\\\ 0&0&0&0&0&0&0&0&0&0&0&0&0&0&0&0&0&0&1&1&0&0&1&1&0&0&1&1&0&0&1&1\\\\ 0&0&0&0&0&0&0&0&0&0&0&0&0&0&0&0&0&1&0&1&0&1&0&1&0&1&0&1&0&1&0&1\\\\ 0&0&0&0&0&0&0&0&0&0&0&0&1&1&1&1&0&0&0&0&0&0&0&0&0&0&0&0&1&1&1&1\\\\ 0&0&0&0&0&0&0&0&0&0&1&1&0&0&1&1&0&0&0&0&0&0&0&0&0&0&1&1&0&0&1&1\\\\ 0&0&0&0&0&0&0&0&0&1&0&1&0&1&0&1&0&0&0&0&0&0&0&0&0&1&0&1&0&1&0&1\\\\ 0&0&0&0&0&0&1&1&0&0&0&0&0&0&1&1&0&0&0&0&0&0&1&1&0&0&0&0&0&0&1&1\\\\ 0&0&0&0&0&1&0&1&0&0&0&0&0&1&0&1&0&0&0&0&0&1&0&1&0&0&0&0&0&1&0&1\\\\ 0&0&0&1&0&0&0&1&0&0&0&1&0&0&0&1&0&0&0&1&0&0&0&1&0&0&0&1&0&0&0&1\\\\ \\end{array}\\right)\\end{aligned}\\ ] ]    first , the decoder itself needs to be created .",
    "as presented in section  [ sect06 ] , we construct six two - dimensional subspaces @xmath223 and corresponding complementary subspaces @xmath224 ,    u_0&:=\\{0 , 1 , 30 , 31 } , & w_0&:=\\{0 , 2 , 8 , 10 , 16 , 18 , 24 , 26 } + u_1&:=\\{0 , 2 , 24 , 26 } , & w_1&:=\\{0 , 3 , 4 , 7 , 16 , 19 , 20 , 23 } + u_2&:=\\{0 , 3 , 20 , 23 } , & w_2&:=\\{0 , 4 , 8 , 12 , 18 , 22 , 26 , 30 } + u_3&:=\\{0 , 4 , 18 , 22 } , & w_3&:=\\{0 , 2 , 5 , 7 , 25 , 27 , 28 , 30 } + u_4&:=\\{0 , 5 , 25 , 28 } , & w_4&:=\\{0 , 6 , 8 , 14 , 19 , 21 , 27 , 29 } + u_5&:=\\{0 , 6 , 27 , 29 } , & w_5&:=\\{0 , 1 , 8 , 9 , 22 , 30 , 23 , 31 }    based on each subspace @xmath225 , @xmath226 , there exist eight 2-flats @xmath227 , @xmath228    v_0+u_0&:=\\{0,1,30,31 } , & v_0+u_1&:=\\{0 , 2 , 24 , 26 } , + v_2+u_0&:=\\{2,3,28,29 } , & v_3+u_1&:=\\{1,3 , 25,27 } , + v_8+u_0 & : = \\{8,9,22,23 } , & v_4+u_1&:=\\{4,6,28,30 } , + v_10+u_0&:=\\{10,11,20,21 } , & v_7+u_1&:=\\{5,7,29,31 } , + v_16+u_0&:=\\{14 , 15 , 16,17 } , & v_16+u_1&:=\\{8,10,16,18 } , + v_18+u_0&:=\\{12 , 13 , 18 , 19 } , & v_19+u_1&:=\\{9 , 11 , 17 , 19 } , + v_24+u_0&:=\\{6,7,24,25 } , & v_20+u_1&:=\\{12,14,20,22 } , + v_26+u_0&:=\\{4,5,26,27 } , & v_23+u_1&:=\\{13,15 , 21,23}.    v_0+u_2&:=\\{0 , 3 , 20 , 23 } , & v_0+u_3&:=\\{0 , 4 , 18 , 22 } , + v_4+u_2&:=\\{4 , 7 , 16 , 19 } , & v_2+u_3&:=\\{2 , 6 , 16 , 20 } , + v_8+u_2 & : = \\{8 , 11 , 28 , 31 } , & v_5+u_3&:=\\{1,5 , 19,23 } , + v_12+u_2&:=\\{12 , 15 , 24 , 27 } , & v_7+u_3&:=\\{3 , 7 , 17 , 21 } , + v_18+u_2&:=\\{5 , 6 , 17 , 18 } , & v_25+u_3&:=\\{11 , 15 , 25 , 29 } , + v_22+u_2&:=\\{1 , 2 , 21 , 22 } , & v_27+u_3&:=\\{9 , 13 , 27 , 31 } , + v_26+u_2&:=\\{13 , 14 , 25 , 26 } , & v_28+u_3&:=\\{10 , 14 , 24 , 28 } , + v_30+u_2&:=\\{9 , 10 , 29 , 30 } , & v_30+u_3&:=\\{8 , 12 , 26 , 30}.    v_0+u_4&:=\\{0 , 5 , 25 , 28 } , & v_0+u_5&:=\\{0 , 6 , 27 , 29 } , + v_6+u_4&:=\\{3 , 6 , 26 , 31 } , & v_1+u_5&:=\\{1 , 7 , 26 , 28 } , + v_8+u_4 & : = \\{8 , 13 , 17 , 20 } , & v_8+u_5&:=\\{8 , 14 , 19 , 21 } , + v_14+u_4&:=\\{11 , 14 , 18 , 23 } , & v_9+u_5&:=\\{9 , 15 , 18 , 20 } , + v_19+u_4&:=\\{10 , 15 , 19 , 22 } , & v_22+u_5&:=\\{11 , 13 , 16 , 22 } , + v_21+u_4&:=\\{9 , 16 , 12 , 21 } , & v_30+u_5&:=\\{3 , 5 , 24,30 } , + v_27+u_4&:=\\{2 , 7 , 27 , 30 } , & v_23+u_5&:=\\{10 , 12 , 17 , 23 } , + v_29+u_4&:=\\{1 , 4 , 24 , 29 } , & v_31+u_5&:=\\{2 , 4 , 25 , 31}.    the mappings @xmath184 , @xmath229 , are specified in table  [ table09 ] ensuring @xmath188 for all @xmath216 .    cl @xmath230 & @xmath231 + & @xmath232 + & @xmath233 + & @xmath234 + & @xmath235 + & @xmath236 + & @xmath237 + & @xmath238 + & @xmath239 + & @xmath240 + & @xmath241 + & @xmath242 + & @xmath243 +    after constructing the underlying geometrical structure of our decoder , we consider the following example .",
    "let @xmath244 be the message word .",
    "then , @xmath245 is the corresponding codeword from @xmath246 .",
    "suppose @xmath111 was sent through a noisy channel and @xmath247 was received with errors at positions 0,1 and 31 .",
    "the decoding can be performed as stated in section  [ 26 ] .",
    "@xmath38 @xmath248 @xmath249 @xmath250 @xmath251 @xmath252 @xmath253 @xmath254 , @xmath255 @xmath256 @xmath257 @xmath258 @xmath259 @xmath260 @xmath261 @xmath262 @xmath263 @xmath264 @xmath265 @xmath266 @xmath267 @xmath268 @xmath269 @xmath270 @xmath271 ... @xmath272",
    "@xmath273 @xmath274     with input @xmath38 and output @xmath111 provided not more than three errors occurred . ]",
    "corresponding to any @xmath275 with input @xmath276 and output @xmath277 in the first layer , even parity generators compute the check - sums and return @xmath278 from top to bottom . the majority gate in the second layer returns @xmath173 . using xor gates , @xmath173 and @xmath279",
    "are combined in the third layer . ]    0 [ table10 ]    cl @xmath230 & @xmath280 + & @xmath281 + & @xmath282 + & @xmath283 + & @xmath284 + & @xmath285 + & @xmath286 + & @xmath287 + & @xmath288 + & @xmath289 + & @xmath290 + & @xmath291 + & @xmath292 +    fig .",
    "[ 25 ] and fig .",
    "[ 44 ] show how the decoding architecture can be built in hardware for a reed ",
    "muller code @xmath293 for reasons of clarity and comprehensibility , we structure the decoder ( see fig .",
    "[ 25 ] ) such that six identical modules , one for every @xmath229 , execute line 1 , line 2 and line 3 of the proposed algorithm ( cf .",
    "section  [ 26 ] ) .",
    "a schematic of such a _ parity - majority module _",
    ", denoted by @xmath294 , is presented in fig .",
    "the blocks labeled with @xmath295 and @xmath296 do not contain any logic gate .",
    "they just represent fixed wirings permuting the 32 inputs .",
    "the corresponding permutations @xmath297 are specified in table  [ table10 ] .",
    "more precisely , within the block @xmath298 , the input signals , indexed from 0 to 31 , are rearranged in the order @xmath299 such that the @xmath19-th signal comes on position @xmath300 where @xmath301 .",
    "thus , the 32-bit input of the @xmath230-th module @xmath294 is just @xmath302 .",
    "the module @xmath294 processes these signals and returns the eight output signals @xmath303 . recalling that @xmath206 , @xmath304 , @xmath305 , states whether @xmath161 is odd or",
    "even , every signal @xmath206 needs to be conveyed to those four different majority gates corresponding to the four vectors contained in @xmath161 .",
    "therefore , within block @xmath306 , the 32 signals are reordered such that the signal on position @xmath19 , @xmath216 , is transferred to position @xmath307 . applying this second permutation , it is ensured that the @xmath19-th signal yields information for determining the @xmath19-th entry of the codeword ,  @xmath308 .",
    "in this section , we compare our algorithm with chen s algorithm in terms of number of function calls as well as in terms of depth and size of circuits realizing the algorithms .",
    "clearly , the number of function calls is correlated with time complexity where depth and size of a circuit provide information about parallel time and space consumption , respectively .",
    "an overview of the executed functions with respect to the number of inputs and how often each is called in chen s and the proposed algorithm is provided in table  [ table07 ] .",
    "& & chen s algorithm & the new algorithm + & @xmath113 & @xmath114 & 0 + & @xmath213 & 0 & @xmath119 + & @xmath215 & 0 & @xmath60 + & @xmath115 & @xmath309 & @xmath15 + xor & 2&@xmath15 & @xmath310 + in total & & @xmath112 & @xmath212 +     & & & & & & & & + & & chen s & the new & & chen s & the new & & chen s & the new & & chen s & the new + & & & & & & & & + & 8 & 64 & 0 & 8 & 1,152 & 0 & 16 & 2,304 & 0 & 16 & 25,088 & 0 + & 4 & 0 & 8 & 4 & 0 & 48 & 8 & 0 & 48 & 8 & 0 & 224 + & 4 & 0 & @xmath311 & 8 & 0 & @xmath312 & 8 & 0 & 6 & 16 & 0 & 14 + & 2 & 48 & 16 & 6 & 224 & 32 & 6 & 448 & 64 & 14 & 1,920 & 128 + xor & 2 & 16 & 24 & 2 & 32 & 80 & 2 & 64 & 112 & 2 & 128 & 352 + & & & & +    apparently , decoding with our method instead of chen s algorithm reduces the number of check - sums to be computed by an order of @xmath15 and the number of majority votes to be decided by an order of @xmath215 .",
    "the parameterized data of table  [ table07 ] is illustrated by way of example in table  [ table08 ] .",
    "we want to investigate the size and depth of combinational circuits realizing chen s and the proposed decoding algorithm .",
    "therefore , we need to consider concrete implementations of the functions , majority vote and check - sum .    in the following , we assume majority voting is performed in constant time by a single _ majority gate _ , a specific _ linear threshold gate_. linear threshold gates compute for a given threshold @xmath313 and for given weights @xmath314 the boolean function @xmath315 where @xmath316 @xmath317{hassoun95}$ ] . thus , a majority gate with @xmath318 inputs is a linear threshold gate where each weight equals one and the threshold equals @xmath319 .    an _ even parity generator _ is a combinational circuit which computes the _ even parity bit _ from the input bits .",
    "the even parity bit is set to one if and only if the number of input bits which take on the value one is odd .",
    "every check - sum @xmath35 , @xmath320 , can be calculated by an even parity generator taking @xmath321 as input .",
    "even parity generators of depth @xmath322 can be simply built out of @xmath323 xor gates .",
    "it is not surprising that even parity generators with @xmath324 inputs and of constant depth require more than a polynomial @xmath325 number of unbounded fan - in and , or and not gates  @xcite . but by using linear threshold gates , constant depth and polynomial size can be achieved .",
    "+ minnick showed in 1961 that an @xmath326-bit even parity generator of depth 2 can be constructed with @xmath327 linear threshold gates  @xcite .",
    "furthermore , at most @xmath328 linear threshold gates are required for an @xmath326-bit even parity generator of depth 3  @xcite .",
    "in fact , the parity function with @xmath324 inputs can be realized by a threshold circuit of any given depth @xmath329 and size @xmath330  @xcite .",
    "recalling the particular function levels of our new algorithm , it can be implemented in a circuit of any given depth @xmath331 and size @xmath332 . in this case , the circuit consists of two layers of xor gates , two layers of majority gates and @xmath333 layers of linear threshold gates . on the other hand ,",
    "chen s algorithm can be realized by a circuit of depth @xmath334 and size @xmath335 with one layer of xor gates , two layers of majority gates and @xmath336 layers of linear threshold gates .",
    "note that for all @xmath331 , @xmath337 where @xmath338    hence , using our new instead of chen s algorithm , the size of the decoder with a fixed depth can be reduced by at least an order of @xmath339 .",
    "furthermore , compared to our depth - efficient decoder , the number of gates in a size - efficient circuit realizing chen s algorithm is still higher by an order of at least @xmath215 : @xmath340",
    "in the present paper , we proposed a new hard - decision majority - logic decoding algorithm for reed  muller codes @xmath0 with @xmath1 @xmath2 we showed how to design the decoder by explaining how to construct its underlying geometrical structure . therefore , our algorithm is easy to implement in both software and hardware . in embedded systems , the proposed decoder can be realized by a simple non - clocked combinational circuit without any registers or flip - flops .",
    "regarding the number of operations , recursive decoders  @xcite usually outperform those based on majority - logic  @xcite and the proposed one .",
    "however , if decoding is to be performed as fast as possible , parallel processing of the functions is appropriate .",
    "clearly , this can not be sufficiently achieved by recursive algorithms .",
    "their decoding hierarchy is too deeply nested in order to allow fast parallel decoding .",
    "therefore , if algorithms are evaluated on the basis of the required parallel time , majority - logic decoding is preferable to recursive decoding .",
    "we aimed to construct an algorithm which decodes in constant parallel time but is less complex than the best known majority - logic decoders .",
    "in fact , chen s  @xcite as well as the presented algorithm offers decoding with a constant level of nesting . nevertheless , using the new method instead of chen s algorithm , the number of function calls and space consumption can be reduced by at least an order of @xmath15 and @xmath215 , respectively .",
    "thus , the proposed decoder is a good candidate when massively parallel decoding of all bits in real - time or near real - time is desired .",
    "the authors thank the anonymous reviewers for their constructive comments and useful suggestions which greatly contributed to improving the manuscript .",
    "j. eisfeld and l. storme , ",
    "( partial ) t - spreads and minimal t - covers in finite projective spaces , lecture notes from the socrates intensive course on finite geometry and its applications , ghent , apr .",
    "available : http://www.maths.qmul.ac.uk/  leonard / partialspreads / eisfeldstorme.ps .",
    "freescale semiconductor inc .",
    ", `` addressing the challenges of functional safety in the automotive and industrial markets , '' white paper , 2011 .",
    "available : http://www.freescale.com/files/microcontrollers/doc/white_paper/ + fctnlsftywp.pdf .",
    "p. hauck , m. huber , j. bertram , d. brauchle , and s. ziesche , `` efficient majority - logic decoding of short - length reed ",
    "muller codes at information positions , '' _ ieee trans .",
    "_ , vol .",
    "61 , pp .  930938 , mar ."
  ],
  "abstract_text": [
    "<S> we propose an easy - to - implement hard - decision majority - logic decoding algorithm for reed  muller codes @xmath0 with @xmath1 @xmath2 the presented algorithm outperforms the best known majority - logic decoding algorithms and offers highly parallel decoding . </S>",
    "<S> the result is of special importance for safety- and time - critical applications in embedded systems . </S>",
    "<S> a simple combinational circuit can perform the proposed decoding . in particular , we show how our decoder for the three - error - correcting code @xmath3 of dimension 16 and length 32 can be realized on hardware level .    </S>",
    "<S> majority - logic decoding , reed  </S>",
    "<S> muller codes , combinational circuits , parallel decoding , real - time and embedded systems . </S>"
  ]
}