{
  "article_text": [
    "multicore processors have become the norm in many execution platforms in various fields .",
    "such architectures come with a cache memory hierarchy made of several levels , shared or not between cores .",
    "figure  [ cache - archi ] represents the typical cache hierarchy that can be found in a multicore architecture with two levels of cache , noted @xmath1 and @xmath2 where @xmath3 is the number of the core ( in the figure @xmath3 ranges from 1 to 4 ) . in such architectures ,",
    "the @xmath2 cache is larger but provides slower access time than the @xmath0 cache .",
    "generally , the @xmath4 cache is unified and shared among all cores , while at the @xmath5 level data and instruction caches are separated and private to each core .",
    "however , in this work we focus only on the data caches .",
    "using such multicore architectures for developing hard real - time systems is an important research area .",
    "multicore are generally tuned for optimizing performance for the average case , while hard real - time systems must consider worst - case scenarios due to certification constraints .",
    "a major problem lies in the management of cache for mastering the impact of conflicts on the worst - case execution time ( wcet ) of each task .",
    "designing cache - aware scheduling policies is becoming a popular research area . in this work ,",
    "we show _ how a static scheduling that minimizes @xmath0 data cache misses between hard real - time tasks on a multicore architecture can be computed_.",
    "@xcite focuses on the memory - to-@xmath2 traffic in the cache hierarchy of soft real - time systems .",
    "they propose a two steps method to discourage the co - scheduling of the tasks generating such traffic .",
    "first , the tasks that may induce significant memory - to-@xmath2 traffic are gathered into groups . then at runtime , they use a scheduling policy that reduces concurrency within groups .",
    "@xcite also proposes several global multi - core scheduling strategies for soft real - time systems to minimize the @xmath2 cache trashing .",
    "co - scheduling of the tasks of a same group is used to optimize the efficient use of the @xmath2 shared cache .",
    "task promotion is another example of a studied scheduling policy .",
    "when considering hard real - time systems , to the best of our knowledge we are only aware of  @xcite .",
    "cache - partitioning techniques are used to avoid interferences , at the @xmath2 cache level , between the tasks that are running simultaneously .",
    "in addition to regular temporal constraints used within a schedulability test , cache constraints due to cache - partitionning are added and steer the computation of the scheduling .",
    "they propose a linear programming formulation to solve this problem and an approximation of this formulation for larger task sets .",
    "the closest work to ours is  @xcite .",
    "while proposed cache - aware scheduling strategies are evaluated using a soft - real time kernel , the results can also be used for hard real - time systems .",
    "they propose a bin packing approach to evenly distribute the working set size ( wss ) of the tasks on all cores in order to reduce conflicts .",
    "the resolution algorithm is based on the next fit decreasing heuristic applied on the tasks ordered by their decreasing wss .",
    "besides , they rely on a notion of distance between caches of non - uniform memory architectures to further optimize the solution . this is only used for the tasks that share some common memory area and are gathered into groups .",
    "however , it is unclear how the common memory area defines a group as well as how groups are reduced when the heuristic fails to allocate a group .    to summarize ,",
    "most of the existing cache - aware scheduling proposal have focused on the efficient use of the @xmath2 cache .",
    "let @xmath6 be a set of @xmath7 independent , synchronous , preemptible and periodic tasks .",
    "@xmath8 is handled using the implicit deadline periodic task model .",
    "each task @xmath9 has the following temporal parameters @xmath10 .",
    "@xmath11 is the period of the task and @xmath12 is the wcet .",
    "a job @xmath13 represents an instance of a task with @xmath12 its wcet .",
    "let @xmath14 be the hyper - period of task set .",
    "it equals to the least common multiple of all periods of tasks in @xmath8 .    as in  @xcite",
    ", the hyper - period @xmath14 is divided in intervals , an interval being delimited by two task releases .",
    "a job can be present on several intervals , and we note @xmath15 the weight of job @xmath16 on interval @xmath17 .",
    "we denote by @xmath18 the set of intervals and @xmath19 the duration of the @xmath20 interval , @xmath21 .",
    "the weight of each job is the amount of processor necessary to execute job @xmath13 on interval @xmath19 only ( it is not an execution time but a fraction of it ) .",
    "@xmath22 is the job set of all jobs of @xmath23 scheduled during the hyper - period @xmath14 .",
    "then , temporal schedulability constraints are expressed using a linear program described in  @xcite to compute the optimal job weights on each interval for all tasks @xmath24 .",
    "first , the sum of all job weights on an interval does not exceed the processor maximum capacity : @xmath25 then each job weight does not exceed each processor maximum capacity : @xmath26 finally , jobs must be completely executed : @xmath27",
    "the problem we address in this work is to reduce @xmath5 data cache misses when scheduling hard real - time tasks on a multicore architecture . to this end , we maximize the co - scheduling on a same core of tasks that exchange data while still ensuring temporal schedulability constraints . we assume a static knowledge of data exchange between the tasks of an application .",
    "therefore , we extend the classical periodic task model with the wss parameter for each task and model this problem using a variant of the knapsack problem .",
    "we also assume that the system is schedulable and hence we only seek to optimize the allocation of the tasks on the @xmath5 caches .",
    "in addition , we suppose that the size of a @xmath5 cache enables to host several tasks simultaneously , a valid hypothesis in the case studies we consider .",
    "we leave as future work the management of cache conflicts , using techniques such as in  @xcite .",
    "the multicore platform is made of @xmath28 cores and we note @xmath29 the capacity of each data cache @xmath0 ( we assume the @xmath0 caches to have an equal size ) .",
    "finally , from the data of the application we can calculate @xmath30 which is the wss of job @xmath31 .",
    "this is computed by adding the size of each data section from the binary of an application .",
    "we note @xmath32 the affinity between the job @xmath13 and the job @xmath33 .",
    "the affinity between two tasks is defined as the number of communication flows between them .",
    "higher is the number of communication flow , higher is the affinity between two tasks .",
    "communication flows between tasks are extracted using the software architecture of the considered hard real - time application .",
    "then , integrating into the previously described schedulability constraints require to introduce a decision variable representing the allocation of the tasks on cores for each intervals .",
    "let @xmath34 be this decision variable that is equal to @xmath35 if the job @xmath13 is assigned to cache @xmath16 during time interval @xmath36 and @xmath37 otherwise .",
    "the sum of the wss of the jobs allocated to a cache should not exceed its capacity : @xmath38 in addition , each job must be assigned to a single cache : @xmath39 besides , to link the temporal schedulability constraints with the aforementioned cache constraints , the following relationship can be define : if @xmath40 then @xmath41 and if @xmath42 then @xmath43",
    ". finally , since our aim is to maximise affinity @xmath0 , we obtain the following objective function : @xmath44",
    "in this work , we show how we can extend classical ( temporal ) schedulability constraints to minimize @xmath0 data cache miss between communicating hard real - time tasks on a multicore architecture . in future work , we plan to generalise the formulation to address other level of a cache memory hierarchy . as our formulation of the problem uses a _",
    "quadratic knapsack _ , known to be _ np - hard _",
    "@xcite , another next step is therefore the linearization of the objective function .",
    "then , we plan to implement it using the cplex solver to generate the static scheduling of hard real - time tasks .",
    "finally , we plan to test our method on several hard real - time industrial applications .",
    "m.  lemerre , v.  david , c.  aussagus , and g.  vidal - naquet , _ equivalence between schedule representations : theory and applications _ , proc . of the ieee real - time and embedded technology and applications symp . , 2008 ."
  ],
  "abstract_text": [
    "<S> the growing need for continuous processing capabilities has led to the development of multicore systems with a complex cache hierarchy . </S>",
    "<S> such multicore systems are generally designed for improving the performance in average case , while hard real - time systems must consider worst - case scenarios . </S>",
    "<S> an open challenge is therefore to efficiently schedule hard real - time tasks on a multicore architecture . in this work , </S>",
    "<S> we propose a mathematical formulation for computing a static scheduling that minimize @xmath0 data cache misses between hard real - time tasks on a multicore architecture using communication affinities . </S>"
  ]
}