{
  "article_text": [
    "_ answer set programming _ ( asp ) @xcite is an approach to declarative rule - based constraint programming that has been successively used in many knowledge representation and reasoning tasks @xcite . in asp",
    ", the problem at hand is solved declaratively    1 .   by writing down a logic program the answer sets of which correspond to the solutions of the problem and 2 .   by computing the answer sets of the program using a special purpose search engine that has been designed for this task .",
    "a modelling philosophy of this kind suggests to treat programs as integral entities .",
    "the answer set semantics  originally defined for entire programs only  @xcite  reflects also this fact .",
    "such indivisibility of programs is creating an increasing problem as program instances tend to grow along the demands of new application areas of asp .",
    "it is to be expected that prospective application areas such as semantic web , bioinformatics , and logical cryptanalysis will provide us with huge program instances to create , to solve , and to maintain .",
    "modern programming languages provide means to exploit _ modularity _ in a number of ways to govern the complexity of programs and their development process .",
    "indeed , the use of _ program modules _ or _ objects _ of some kind can be viewed as an embodiment of the classical _ divide - and - conquer _ principle in the art of programming .",
    "the benefits of modular program development are numerous .",
    "a software system is much easier to design as a set of interacting components rather than a monolithic system with unclear internal structure .",
    "a modular design lends itself better for implementation as programming tasks are then easier to delegate amongst the team of programmers .",
    "it also enables the re - use of code organized as module libraries , for instance . to achieve similar advantages in asp ,",
    "one of the central goals of our research is to foster modularity in the context of asp .",
    "although modularity has been studied extensively in the context of conventional logic programs , see bugliesi et al .   for a survey ,",
    "relatively little attention has been paid to modularity in asp .",
    "many of the approaches proposed so far are based on very strict syntactic conditions on the module hierarchy , for instance , by enforcing stratification of some kind , or by prohibiting recursion altogether @xcite . on the other hand , approaches based on _ splitting - sets _",
    "@xcite are satisfactory from the point of view of _ compositional semantics _ :",
    "the answer sets of an entire program are obtained as specific combinations of the answer sets of its components .",
    "a limitation of splitting - sets is that they divide logic programs in two parts , the _ top _ and the _ bottom _ , which is rather restrictive and conceptually very close to stratification . on the other hand , the compositionality of answer set semantics is neglected altogether in syntactic approaches @xcite and this aspect of models remains completely at the programmer s responsibility .    to address the deficiencies described above , we accommodate a module architecture proposed by gaifman - shapiro   to answer set programming , and in particular , in the context of the smodels system @xcite .",
    "there are two main criteria for the design .",
    "first of all , it is essential to establish the full compositionality of answer set semantics with respect to the module system . this is to ensure that various reasoning tasks  such as the verification of program equivalence @xcite  can be modularized .",
    "second , for the sake of flexibility of knowledge representation , any restrictions on the module hierarchy should be avoided as far as possible .",
    "we pursue these goals according to the following plan .    in section  [ section : related ] , we take a closer look at modularity in the context of logic programming . in order to enable comparisons later on , we also describe related approaches in the area of asp in more detail .",
    "the technical preliminaries of the paper begin with a recapitulation of _ stable model semantics _",
    "@xcite in section  [ section : background ] .",
    "however , stable models , or answer sets , are reformulated for a class of programs that corresponds to the input language of the smodels solver  @xcite .",
    "the definition of _ splitting - sets _ is included to enable a detailed comparison with our results .",
    "moreover , we introduce the concepts of _ program completion _ and _ loop formulas _ to be exploited in proofs later on , and review some notions of equivalence that have been proposed in the literature .    in section [ section : modules ]",
    ", we present a _ module architecture _ for smodels programs , in which the interaction between modules takes place through a clearly defined _ input / output interface_. the design superficially resembles that of gaifman and shapiro   but in order to achieve the full compositionality of stable models , further conditions on program composition are incorporated .",
    "this is formalized as the main result of the paper , namely the _ module theorem _ , which goes beyond the splitting - set theorem  @xcite as _ negative recursion _ is tolerated by our definitions .",
    "the proof is first presented for normal programs and then extended for smodels programs using a translation - based scheme . the scheme is based on three distinguished properties of translations , _ strong faithfulness _ , _ preservation of compositions _ , and _ modularity _",
    ", that are sufficient to lift the module theorem . in this way",
    ", we get prepared for even further syntactic extensions of the module theorem in the future . the respective notion of module - level equivalence ,",
    "that is , _ modular equivalence _ , is proved to be a proper _ congruence _ for program composition . in other words ,",
    "substitutions of modularly equivalent modules preserve modular equivalence . this way modular equivalence can be viewed as a reasonable compromise between _ uniform equivalence _",
    "@xcite which is not a congruence for program union , and _ strong equivalence _",
    "@xcite which is a congruence for program union but allows only rather straightforward semantics - preserving transformations of ( sets of ) rules .    in section [ section : decomposition - and - semantical - join ] ,",
    "we address principles for the decomposition of smodels programs .",
    "it turns out that strongly connected components of dependency graphs can be exploited in order to extract a module structure when there is no explicit a priori knowledge about the modules of a program .",
    "in addition , we consider the possibility of relaxing our restrictions on program composition using the content of the module theorem as a criterion .",
    "the result is that the notion of modular equivalence remains unchanged but the computational cost of checking legal compositions of modules becomes essentially higher . in section [ section : experiments ] , we demonstrate how the module system can be exploited in practise in the context of the smodels system .",
    "we present tools that have been developed for ( de)composition of logic programs and conduct a practical experiment which illustrates the performance of the tools when processing very large benchmark instances , that is , smodels programs having up to millions of rules .",
    "the concluding remarks of this paper are presented in section [ section : conclusions ] .",
    "bugliesi et al .   address several properties that are expected from a modular logic programming language .",
    "for instance , a modular language should    * allow _ abstraction , parameterization _ , and _",
    "information hiding _ , * _ ease program development _ and _ maintenance _ of large programs , * allow _ re - usability _ , * have a _",
    "non - trivial notion of program equivalence _ to justify replacement of program components , and * maintain the _ declarativity _ of logic programming .",
    "two mainstream programming disciplines are identified . in _",
    "programming - in - the - large _ approaches programs are composed with algebraic operators , see for instance @xcite . in _",
    "programming - in - the - small _ approaches abstraction mechanisms are used , see for instance @xcite .",
    "the _ programming - in - the - large _ approaches have their roots in the framework proposed by okeefe   where logic programs are seen as _ elements of an algebra _ and the operators for _ composing programs _ are seen as _ operators in that algebra_.",
    "the fundamental idea is that a logic program should be understood as a part of a system of programs .",
    "program composition is a powerful tool for structuring programs without any need to extend the underlying language of horn clauses .",
    "several algebraic operations such as _ union _ , _ deletion _ , _ overriding union _ and _ closure _ have been considered .",
    "this approach _ supports _ naturally the _ re - use _ of the pieces of programs in different composite programs , and when combined with an adequate equivalence relation also the replacement of equivalent components .",
    "this approach is highly flexible , as new composition mechanisms can be obtained by introducing a corresponding operator in the algebra or combining existing ones .",
    "encapsulation and information hiding can be obtained by introducing suitable _ interfaces _ for components .",
    "the _ programming - in - the - small _ approaches originate from @xcite . in this approach",
    "the composition of modules is modelled in terms of logical connectives of a language that is defined as an _ extension of horn clause logic_. the approach in  @xcite employs the same structural properties , but suggests a more refined way of modelling visibility rules than the one in  @xcite .",
    "it is essential that a semantical characterization of a modular language is such that the meaning of composite programs can be defined in terms of the meaning of its components  @xcite . to be able to identify when it is safe to substitute a module with another without affecting the global behavior it is crucial to have a notion of _ semantical equivalence_. more formally these desired properties",
    "can be described under the terms of _ compositionality _ and _ full abstraction _  @xcite .",
    "two programs are _ observationally congruent _ , if and only if they exhibit the same observational behavior in every _ context _ they can be placed in .",
    "a semantics is compositional if semantical equality implies observational congruence , and fully abstract if semantical equivalence coincides with observational congruence .",
    "the compositionality and full abstraction properties for different notions of semantical equivalence ( _ subsumption equivalence _ , _ logical equivalence _ , and _ minimal herbrand model equivalence _ ) and different operators in an algebra ( union , closure , overriding union ) are considered in  @xcite .",
    "it is worth noting that minimal herbrand model equivalence coincides with the _ weak equivalence _",
    "relation for positive logic programs . as to be defined in section [",
    "sect : equivalences ] , two logic programs are weakly equivalent if and only if they have exactly the same answer sets .",
    "as the equivalence based on minimal herbrand model semantics is not compositional with respect to program union  @xcite , we note that it is not a suitable composition operator for our purposes unless further constraints are introduced .",
    "there are a number of approaches within answer set programming involving modularity in some sense , but only a few of them really describe a flexible module architecture with a clearly defined interface for module interaction .",
    "eiter , gottlob , and veith   address modularity in asp in the programming - in - the - small sense .",
    "they view program modules as _",
    "generalized quantifiers _ as introduced in  @xcite .",
    "the definitions of quantifiers are allowed to nest , that is , program @xmath0 can refer to another module @xmath1 by using it as a generalized quantifier . the main program is clearly distinguished from subprograms , and it is possible to nest calls to submodules if the so - called _ call graph _ is _ hierarchical _ , that is , _",
    "acyclic_. nesting , however , increases the computational complexity depending on the depth of nesting .",
    "ianni et al .",
    "propose another programming - in - the - small approach to asp based on _",
    "templates_. the semantics of programs containing template atoms is determined by an _ explosion algorithm _ , which basically replaces the template with a standard logic program .",
    "however , the explosion algorithm is not guaranteed to terminate if template definitions are used recursively .",
    "tari et al .",
    "extend the language of normal logic programs by introducing the concept of _ import rules _ for their asp program modules .",
    "there are three types of import rules which are used to import a set of tuples @xmath2 for a predicate @xmath3 from another module .",
    "an _ asp module _ is defined as a quadruple of a module name , a set of parameters , a collection of normal rules and a collection of import rules .",
    "semantics is only defined for modular programs with acyclic dependency graph , and answer sets of a module are defined with respect to the modular asp program containing it .",
    "also , it is required that import rules referring to the same module always have the same form .",
    "programming - in - the - large approaches in asp are mostly based on lifschitz and turner s splitting - set theorem @xcite or are variants of it .",
    "the class of logic programs considered in @xcite is that of _ extended disjunctive logic programs _ , that is , disjunctive logic programs with two kinds of negation .",
    "a _ component structure _ induced by a _ splitting sequence _ , that is , iterated splittings of a program , allows a bottom - up computation of answer sets .",
    "the restriction implied by this construction is that the dependency graph of the component chain needs to be acyclic .",
    "eiter , gottlob , and mannila consider _ disjunctive logic programs as a query language for relational databases_. a query program @xmath4 is instantiated with respect to an input database @xmath5 confined by an input schema @xmath6 .",
    "the semantics of @xmath4 determines , for example , the answer sets of @xmath7 $ ] which are projected with respect to an output schema @xmath8 .",
    "their module architecture is based on both _ positive and negative dependencies _ and no recursion between modules is tolerated .",
    "these constraints enable a straightforward generalization of the splitting - set theorem for the architecture .",
    "faber et al .",
    "apply the _ magic set method _ in the evaluation of _ datalog programs with negation _ , that is , effectively normal logic programs .",
    "this involves the concept of an _ independent set _",
    "@xmath9 of a program @xmath0 which is a specialization of a splitting set .",
    "due to a close relationship with splitting sets , the flexibility of independent sets for parceling programs is limited in the same way .    the approach based on _ lp - functions _",
    "@xcite is another programming - in - the - large approach .",
    "an lp - function has an interface based on input and output signatures .",
    "several operations , for instance _ incremental extension _ ,",
    "_ interpolation _ , _ input opening _ , and _ input extension _ , are introduced for composing and refining lp - functions .",
    "the composition of lp - functions , however , only allows incremental extension , and thus similarly to the splitting - set theorem there can be no recursion between lp - functions .",
    "to keep the presentation of our module architecture compatible with an actual implementation , we cover the input language of the smodels system  excluding _ optimization statements_. in this section we introduce the syntax and semantics for smodels programs , and , in addition , point out a number of useful properties of logic programs under stable model semantics .",
    "we end this section with a review of equivalence relations that have been proposed for logic programs .      _ basic constraint rules _",
    "@xcite are either _ weight rules _ of the form @xmath10 or _ choice rules _ of the form @xmath11 where @xmath12 , @xmath13 s , @xmath14 s , and @xmath15 s are atoms , @xmath16 , @xmath17 , @xmath18 , and @xmath19 denotes _ negation as failure _ or _",
    "default negation_. in addition , a weight rule ( [ eq : weight - rule ] ) involves a weight limit @xmath20 and the respective weights @xmath21 and @xmath22 associated with each _ positive literal _ @xmath14 and _ negative literal _ @xmath23 .",
    "we use a shorthand @xmath24 for any set of atoms @xmath25 .",
    "each basic constraint rule @xmath26 consists of two parts : @xmath12 or @xmath27 is the _",
    "head _ of the rule , denoted by @xmath28 , whereas the rest is called its _ body_. the set of atoms appearing in a body of a rule can be further divided into the set of _ positive body atoms _ , defined as @xmath29 , and the set of _ negative body atoms _ , defined as @xmath30 .",
    "we denote by @xmath31 the set of atoms appearing in the body of a rule @xmath26 .",
    "roughly speaking , the body gives the conditions on which the head of the rule must be satisfied .",
    "for example , in case of a choice rule ( [ eq : choice - rule ] ) , this means that any head atom @xmath13 can be inferred to be true if @xmath32 hold true by some other rules but none of the atoms @xmath33 .",
    "weight rules of the form ( [ eq : weight - rule ] ) cover many other kinds of rules of interest as their special cases : @xmath34 _ cardinality rules _ of the form ( [ eq : cardinality - rule ] ) are essentially weight rules ( [ eq : weight - rule ] ) where @xmath35 and all weights associated with literals equal to @xmath36 .",
    "a _ normal rule _ , or alternatively a _",
    "basic rule _",
    "( [ eq : basic - rule ] ) is a special case of a cardinality rule ( [ eq : cardinality - rule ] ) with @xmath37 .",
    "the intuitive meaning of an integrity constraint ( [ eq : integrity - constraint ] ) is that the conditions given in the body are never simultaneously satisfied .",
    "the same can be stated in terms of a basic rule @xmath38 where @xmath39 is a new atom dedicated to integrity constraints .",
    "finally , _ compute statements _ ( [ eq : compute - statement ] ) of the smodels system effectively correspond to sets of integrity constraints @xmath40 and @xmath41 .",
    "because the order of literals in ( [ eq : weight - rule ] ) and ( [ eq : choice - rule ] ) is considered irrelevant , we introduce shorthands @xmath42 , @xmath43 , and @xmath44 for the sets of atoms involved in rules , and @xmath45 and @xmath46 for the respective sets of weights in ( [ eq : weight - rule ] ) . using these notations ( [ eq : weight - rule ] ) and ( [ eq : choice - rule ] ) are abbreviated by @xmath47 and @xmath48 are to be understood as sets of pairs of the form @xmath49 and @xmath50 , respectively . for convenience the exact matching between literals and weights",
    "is left implicit in the shorthand . ] and @xmath51 .    in the smodels system ,",
    "the internal representation of programs is based on rules of the forms ( [ eq : weight - rule])([eq : basic - rule ] ) and ( [ eq : compute - statement ] ) and one may conclude that basic constraint rules , as introduced above , provide a reasonable coverage of smodels programs .",
    "thus we concentrate on rules of the forms ( [ eq : weight - rule ] ) and ( [ eq : choice - rule ] ) and view others as syntactic sugar in the sequel .",
    "[ smodels - program ] an smodels program @xmath0 is a finite set of basic constraint rules .",
    "an smodels program consisting only of basic rules is called a _ normal logic program _  ( nlp ) , and a basic rule with an empty body is called a _",
    "fact_. given an smodels program @xmath0 , we write @xmath52 for its _ signature _ , that is , the set of atoms occurring in @xmath0 , and @xmath53 and @xmath54 for the respective subsets of @xmath52 having _ body occurrences _ and _ head occurrences _ in the rules of @xmath0 .",
    "furthermore , @xmath55 denotes the set of atoms having a head occurrence in a choice rule of @xmath0 .",
    "given a program @xmath0 , an _ interpretation _",
    "@xmath56 of @xmath0 is a subset of @xmath52 defining which atoms @xmath57 are _ true _ ( @xmath58 ) and which are _ false _ ( @xmath59 ) .",
    "a weight rule ( [ eq : weight - rule ] ) is satisfied in @xmath56 if and only if @xmath58 whenever the sum of weights @xmath60 is at least @xmath61 .",
    "a choice rule @xmath62 is always satisfied in @xmath56 .",
    "an interpretation @xmath63 is a ( classical ) model of @xmath0 , denoted by @xmath64 , if and only if @xmath56 satisfies all the rules in @xmath0 .",
    "the generalization of the _ gelfond - lifschitz reduct _  @xcite for smodels programs is defined as follows .",
    "[ reduct ] for an smodels program @xmath0 and an interpretation @xmath63 , the reduct @xmath65 contains    1 .",
    "a rule @xmath66 if and only if there is a choice rule @xmath62 in @xmath0 such that @xmath67 , and @xmath68 ; 2 .",
    "a rule @xmath69 if and only if there is a weight rule @xmath70 in @xmath0 such that @xmath71 .",
    "we say that an smodels program @xmath0 is _ positive _ if each rule in @xmath0 is a weight rule restricted to the case @xmath72 .",
    "recalling that the basic rules are just a special case of weight rules , we note that the reduct @xmath73 is always positive .",
    "an interpretation @xmath63 is the _ least model _ of a positive smodels program @xmath0 , denoted by @xmath74 , if and only if @xmath64 and there is no @xmath75 such that @xmath76 .",
    "given the _",
    "least model semantics _ for positive programs  @xcite , the stable model semantics  @xcite straightforwardly generalizes for smodels programs  @xcite .    [ smodels - stable ]",
    "an interpretation @xmath63 is a stable model of an smodels program @xmath0 if and only if @xmath77 .",
    "given an smodels program @xmath0 and @xmath78 , we say that @xmath12 _ depends directly _ on @xmath79 , denoted by @xmath80 , if and only if @xmath0 contains a rule @xmath26 such that @xmath81 and @xmath82 .",
    "the _ positive dependency graph _ of @xmath0 , denoted by @xmath83 , is the graph @xmath84 .",
    "the reflexive and transitive closure of @xmath85 gives rise to the dependency relation @xmath86 over @xmath52 .",
    "a _ strongly connected component _ ( scc ) @xmath9 of @xmath83 is a maximal set @xmath87 such that @xmath88 holds for every @xmath89 .      in this section",
    "we consider only the class of _ normal logic programs_. we formulate the _ splitting - set theorem _",
    "@xcite in the case of normal logic programs , and give an alternative definition of stable models based on the _ classical models _ of the _ completion _ of a program  @xcite and its _ loop formulas _  @xcite .",
    "the splitting - set theorem can be used to simplify the computation of stable models by splitting a program into parts , and it is also a useful tool for structuring mathematical proofs for properties of logic programs .",
    "[ def : splitting - set ] a splitting set for a normal logic program @xmath0 is any set @xmath90 such that for every rule @xmath26 in @xmath0 it holds that @xmath91 if @xmath92 .",
    "the set of rules @xmath93 such that @xmath91 is the _ bottom _ of @xmath0 relative to @xmath94 , denoted by @xmath95 .",
    "the set @xmath96 is the _ top _ of @xmath0 relative to @xmath94 which can be partially evaluated with respect to an interpretation @xmath97 .",
    "the result is a program @xmath98 defined as @xmath99 a _ solution _ to a program with respect to a splitting set is a pair consisting of a stable model  @xmath100 for the bottom and a stable model @xmath101 for the top partially evaluated with respect to @xmath100 .",
    "[ solution ] given a splitting set @xmath94 for a normal logic program @xmath0 , a solution to @xmath0 with respect to @xmath94 is a pair @xmath102 such that    1 .",
    "@xmath97 is a stable model of @xmath95 , and 2 .",
    "@xmath103 is a stable model of @xmath98 .",
    "solutions and stable models relate as follows .",
    "[ thr : splitting - set ]   + let @xmath94 be a splitting set for a normal logic program @xmath0 and @xmath63 an interpretation",
    ". then @xmath104 if and only if the pair @xmath105 is a solution to @xmath0 with respect to @xmath94 .",
    "the splitting - set theorem can also be used in an iterative manner , if there is a _ monotone sequence _ of splitting sets @xmath106 , that is , @xmath107 if @xmath108 , for program @xmath0 .",
    "this is called a _ splitting sequence _ and it induces a _ component structure _ for @xmath0 .",
    "the splitting - set theorem generalizes to a _ splitting sequence theorem _",
    "@xcite , and given a splitting sequence , the stable models of a program @xmath0 can be computed iteratively bottom - up .",
    "lin and zhao present an alternative definition of stable models for normal logic programs based on the _ classical models _ of the _ completion _ of a program  @xcite and its _ loop formulas _",
    ". we will apply this definition later on in the proof of the module theorem ( theorem [ moduletheorem ] ) .",
    "[ clarks - completion ] the completion of a normal logic program @xmath0 is @xmath109    note that an empty body reduces to true and in that case the respective equivalence for an atom @xmath12 is logically equivalent to @xmath110 .",
    "[ def : loop ] given a normal logic program @xmath0 , a set of atoms @xmath111 is a loop of @xmath0 if for every @xmath112 there is a path of non - zero length from @xmath12 to @xmath79 in @xmath83 such that all vertices in the path are in @xmath113 .",
    "[ def : loop - formula ] given a normal logic program @xmath0 and a loop @xmath111 of @xmath0 , the loop formula associated with @xmath113 is @xmath114 where @xmath115 is the set of rules in @xmath0 which have external bodies of @xmath113 .",
    "now , stable models of a program and classical models of its completion that satisfy the loop formulas relate as follows .",
    "[ stable - models - using - loop - formulas ] given a normal logic program @xmath0 and an interpretation @xmath63 , @xmath104",
    "if and only if @xmath116 , where @xmath117 is the set of all loop formulas associated with the loops of @xmath0 .      there are several notions of equivalence that have been proposed for logic programs .",
    "we review a number of them in the context of smodels programs .",
    "lifschitz et al .",
    "address the notions of _ weak / ordinary equivalence _ and _ strong equivalence_.    [ weak - strong - eq ] smodels programs @xmath0 and @xmath1 are weakly equivalent , denoted by @xmath118 , if and only if @xmath119 ; and strongly equivalent , denoted by @xmath120 , if and only if @xmath121 for any smodels program @xmath122 .",
    "the program @xmath122 in the above definition can be understood as an arbitrary context in which the two programs being compared could be placed .",
    "therefore strongly equivalent logic programs are semantics preserving substitutes of each other and relation @xmath123 is a _ congruence relation _ for @xmath124 among smodels programs , that is , if @xmath120 , then also @xmath125 for all smodels programs @xmath122 . using @xmath126 as context",
    ", one sees that @xmath120 implies @xmath118 .",
    "the converse does not hold in general .",
    "a way to weaken strong equivalence is to restrict possible contexts to sets of facts .",
    "the notion of _ uniform equivalence _ has its roots in the database community @xcite , see @xcite for the case of the stable model semantics .",
    "[ uniform - eq ] smodels programs @xmath0 and @xmath1 are uniformly equivalent , denoted by @xmath127 , if and only if @xmath128 for any set of facts @xmath129 .",
    "example [ uni - not - strong ] shows that uniform equivalence is not a congruence for union .    *",
    "( ( * ? ? ?",
    "* example 1 ) ) * [ uni - not - strong ] consider programs @xmath130 and @xmath131 .",
    "it holds that @xmath127 , but @xmath132 for the context @xmath133 .",
    "this implies @xmath134 and @xmath135 .",
    "@xmath136    there are also _ relativized variants of strong and uniform equivalence _",
    "@xcite which allow the context to be constrained using a set of atoms @xmath25 .    for weak equivalence of programs @xmath0 and @xmath1 to hold ,",
    "@xmath137 and @xmath138 have to be identical subsets of @xmath139 and @xmath140 , respectively .",
    "the same effect can be seen with @xmath120 and @xmath127 .",
    "this makes these relations less useful if @xmath52 and @xmath141 differ by some ( local ) atoms not trivially false in all stable models .",
    "the _ visible equivalence relation _",
    "@xcite takes the interfaces of programs into account .",
    "the atoms in @xmath52 are partitioned into two parts , @xmath142 and @xmath143 , which determine the _ visible _ and the _ hidden _ parts of @xmath52 , respectively .",
    "visible atoms form an interface for interaction between programs , and hidden atoms are local to each program and thus negligible when visible equivalence of programs is concerned .",
    "[ equivalences ] smodels programs @xmath0 and @xmath1 are visibly equivalent , denoted by @xmath144 , if and only if @xmath145 and there is a bijection @xmath146 such that for all @xmath104 , @xmath147 .",
    "note that the number of stable models is also preserved under @xmath148 .",
    "such a strict correspondence of models is much dictated by the answer set programming methodology : the stable models of a program usually correspond to the solutions of the problem being solved and thus the exact preservation of models is highly significant . in the fully visible case , that is , for @xmath149 , the relation @xmath148 becomes very close to @xmath150 .",
    "the only difference is the requirement that @xmath151 insisted on @xmath148 .",
    "this is of little importance as @xmath52 can always be extended by adding ( tautological ) rules of the form @xmath152 to @xmath0 without affecting the stable models of the program . since",
    "weak equivalence is not a congruence for @xmath124 , visible equivalence can not be a congruence for program union either .",
    "the verification of weak , strong , or uniform equivalence is a @xmath153-complete decision problem for smodels programs @xcite .",
    "the computational complexity of deciding @xmath148 is analyzed in  @xcite .",
    "if the use of hidden atoms is not limited in any way , the problem of verifying visible equivalence becomes at least as hard as the counting problem @xmath154 which is @xmath155-complete @xcite .",
    "it is possible , however , to govern the computational complexity by limiting the use of hidden atoms by the property of having _ enough visible atoms _",
    "intuitively , if @xmath0 has enough visible atoms , the eva property for short , then each interpretation of @xmath142 _ uniquely _ determines an interpretation of @xmath143 .",
    "consequently , the stable models of @xmath0 can be distinguished on the basis of their visible parts .",
    "although verifying the eva property can be hard in general ( * ? ? ?",
    "* proposition 4.14 ) , there are syntactic subclasses of smodels programs with the eva property .",
    "the use of visible atoms remains unlimited and thus the full expressiveness of smodels programs remains at programmer s disposal .",
    "also note that the eva property can always be achieved by declaring sufficiently many atoms visible . for smodels programs with the eva property",
    ", the verification of visible equivalence is a * conp*-complete decision problem  @xcite .",
    "eiter et al .",
    "introduce a very general framework based on _ equivalence frames _ to capture various kinds of equivalence relations .",
    "all the equivalence relations defined in this section can be defined using the framework .",
    "visible equivalence , however , is exceptional in the sense that it does not fit into equivalence frames based on _ projected answer sets_. as a consequence , the number of answer sets may not be preserved which is somewhat unsatisfactory because of the general nature of answer set programming as discussed in the previous section . under the eva assumption , however , the _ projective variant of visible equivalence _ defined by @xmath156 coincides with visible equivalence .    recently woltran presented another general framework characterizing _ @xmath157-equivalence _",
    "@xmath157-equivalence is defined similarly to strong equivalence , but the set of possible contexts is restricted by limiting the head and body occurrences of atoms in a context program @xmath122 by @xmath158 and @xmath159 , respectively .",
    "thus , programs @xmath0 and @xmath1 are @xmath157-equivalent if and only if @xmath121 for all @xmath122 such that @xmath160 and @xmath161 . several notions of equivalence such as weak equivalence together with ( relativized ) strong and ( relativized )",
    "uniform equivalence can be seen as special cases of @xmath157-equivalence by varying the sets @xmath158 and @xmath159 .",
    "we start this section by introducing the syntax and the stable model semantics for an individual smodels program module , and then formalize the conditions for module composition .",
    "one of the main results is the _ module theorem _ showing that module composition is suitably restricted so that compositionality of stable model semantics for smodels programs is achieved .",
    "we also introduce an equivalence relation for modules , and propose a general translation - based scheme for introducing syntactical extensions for the module theorem .",
    "the scheme is then utilized in the proof of the module theorem .",
    "we end this section with a brief comparison between our module architecture and other similar proposals .",
    "we define a _ logic program module _ similarly to gaifman and shapiro  , but consider the case of smodels programs instead of positive normal logic programs covered in  @xcite .",
    "an analogous module system in the context of _ disjunctive logic programs _ is presented in @xcite .",
    "[ smodels - module ] an smodels program module @xmath162 is a quadruple @xmath163 where    1 .",
    "@xmath122 is a finite set of basic constraint rules ; 2 .",
    "@xmath164 , @xmath165 , and @xmath166 are pairwise disjoint sets of input , output , and hidden atoms ; 3 .",
    "@xmath167 which is defined by @xmath168 ; and 4",
    ".   @xmath169 .    the atoms in @xmath170 are considered to be _ visible _ and hence accessible to other modules conjoined with @xmath162 ; either to produce input for @xmath162 or to utilize the output of @xmath162 .",
    "we use notations @xmath171 and @xmath172 for referring to the _ input signature _ @xmath164 and the _ output signature _ @xmath165 , respectively .",
    "the _ hidden _ atoms in @xmath173 are used to formalize some auxiliary concepts of @xmath162 which may not be sensible for other modules but may save space substantially . the use of hidden atoms may yield exponential savings in space , see  ( * ? ? ?",
    "* example 4.5 ) , for instance .",
    "the condition @xmath169 ensures that a module may not interfere with its own input by defining input atoms of @xmath164 in terms of its rules .",
    "thus input atoms are only allowed to appear as conditions in rule bodies .",
    "[ ex : hc1 ] consider the hamiltonian cycle problem for directed graphs , that is , whether there is a cycle in the graph such that each node is visited exactly once returning to the starting node .",
    "let @xmath174 denote the number of nodes in the graph and let @xmath175 denote that there is a directed edge from node @xmath176 to node @xmath177 in the graph .",
    "module @xmath178 selects the edges to be taken into a cycle by insisting that each node must have exactly one incoming and exactly one outgoing edge .",
    "the input signature of @xmath179 is a graph represented as a set of edges : @xmath180 .",
    "the output signature of @xmath179 represents which edges get selected into a candidate for a hamiltonian cycle : @xmath181 .",
    "the set @xmath122 contains rules @xmath182 for each @xmath183 ; and a rule @xmath184 which enforces @xmath185 to be false in every stable model . the rules in ( [ eq : selection ] )",
    "encode the selection of edges taken in the cycle .",
    "the rules in ( [ eq : ingoing1 ] ) and ( [ eq : ingoing2 ] ) are used to guarantee that each node has exactly one outgoing edge , and the rules in ( [ eq : outgoing1 ] ) and ( [ eq : outgoing2 ] ) give the respective condition concerning incoming edges .",
    "we also need to check that each node is reachable from the first node along the edges in the cycle . for this",
    ", we introduce module @xmath186 .",
    "the input signature of @xmath187 is @xmath188 , and the output signature is @xmath189 , where @xmath190 tells that node @xmath176 is reachable from the first node .",
    "the set @xmath191 contains rules @xmath192 for each @xmath193 and @xmath194 .",
    "@xmath136    to generalize the stable model semantics to cover modules as well , we must explicate the semantical role of input atoms . to this end",
    ", we will follow an approach from @xcite and take input atoms into account in the definition of the reduct adopted from @xcite .",
    "it should be stressed that _ all negative literals _ and _ literals involving input atoms _ get evaluated in the reduction .",
    "moreover , our definitions become equivalent with those proposed for normal programs @xcite and smodels programs @xcite if an empty input signature @xmath195 is additionally assumed . using the same idea , a conventional smodels program ,",
    "that is , a set of basic constraint rules @xmath122 , can be viewed as a module @xmath196 without any input atoms and all atoms visible .",
    "[ def : reduct ] given a module @xmath197 , the _ reduct _ of @xmath122 with respect to an interpretation @xmath198 and input signature @xmath164 , denoted by @xmath199 , contains    1 .",
    "a rule @xmath200 if and only if there is a choice rule @xmath62 in @xmath122 such that @xmath67 , @xmath201 , and @xmath68 ; and 2 .",
    "a rule @xmath202 if and only if there is a weight rule @xmath70 in @xmath122 , and @xmath203    as all occurrences of atoms in the input signature and all negative occurrences of atoms are evaluated , the generalized reduct @xmath199 is a positive program in the sense of @xcite and thus it has a unique least model @xmath204 .",
    "[ def : stable - model ] an interpretation @xmath198 is a stable model of an smodels program module @xmath197 , denoted by @xmath205 , if and only if @xmath206 .",
    "if one is interested in computing stable models of a module with respect to a certain input interpretation , it is easier to use an alternative definition of stable semantics for modules  @xcite , where an actual input is seen as a set of facts ( or a database ) to be combined with the module .",
    "[ def : instantiate - module ] given an smodels program module @xmath197 and a set of atoms @xmath207 , the instantiation of @xmath162 with an actual input @xmath25 is @xmath208    the module @xmath209 is essentially an smodels program with @xmath210 as the set of visible atoms .",
    "thus the stable model semantics of smodels programs in definition [ smodels - stable ] directly generalizes for an instantiated module .",
    "[ def : alter - stable - model ] an interpretation @xmath198 is a stable model of an smodels program module @xmath197 if and only if @xmath211    it is worth emphasizing that definitions [ def : stable - model ] and [ def : alter - stable - model ] result in exactly the same semantics for smodels program modules .",
    "[ ex : hc2 ] recall module @xmath179 from example [ ex : hc1 ] .",
    "we consider the stable models of @xmath179 for @xmath212 to see that the rules in @xmath179 do not alone guarantee that each node is reachable along the edges taken in the cycle candidate .",
    "consider @xmath213 .",
    "the reduct @xmath199 contains facts @xmath214 and @xmath215 ; and rules @xmath216 , @xmath217 , @xmath218 , and @xmath219 ; and finally the rule @xmath220 .",
    "now @xmath221 since @xmath222 .",
    "however , @xmath56 does not correspond to a graph with a hamiltonian cycle , as node @xmath223 is not reachable from node @xmath36 . @xmath136",
    "the stable model semantics  @xcite does not lend itself directly for program composition .",
    "the problem is that in general , stable models associated with modules do not determine stable models assigned to their _",
    "composition_.    gaifman and shapiro   cover positive normal programs under logical consequences . for their purposes , it is sufficient to assume that whenever two modules @xmath224 and @xmath225 are put together , their output signatures have to be disjoint and they have to _ respect each other s hidden atoms _ , that is , @xmath226 and @xmath227 .",
    "[ def : program - composition ] given smodels program modules @xmath228 and @xmath229 , their composition is @xmath230 if @xmath231 and @xmath224 and @xmath225 respect each other s hidden atoms .",
    "the following example shows that the conditions given for @xmath232 are not enough to guarantee compositionality in the case of stable models and further restrictions on program composition become necessary .",
    "[ ex : gs - composition ] consider normal logic program modules @xmath233 and @xmath234 both of which have stable models @xmath235 and @xmath236 by symmetry .",
    "the _ composition _ of @xmath224 and @xmath225 is @xmath237 and @xmath238 , that is , @xmath236 is not a stable model of @xmath239 .",
    "@xmath136    we define the positive dependency graph of an smodels program module @xmath197 as @xmath240 .",
    "given that @xmath239 is defined , we say that @xmath224 and @xmath225 are _ mutually dependent _ if and only if @xmath241 has an scc @xmath9 such that @xmath242 and @xmath243 , that is , @xmath9 is _ shared by _",
    "@xmath224 and @xmath225 .",
    "[ def : join ] the _ join _ @xmath244 of two smodels program modules @xmath224 and @xmath225 is @xmath239 , provided @xmath239 is defined and @xmath224 and @xmath225 are not mutually dependent .    [",
    "ex : join - modules ] consider modules @xmath179 and @xmath187 from example [ ex : hc1 ] . since @xmath179 and @xmath187 respect each other s hidden atoms and are not mutually dependent , their join @xmath245 is defined .",
    "@xmath136    the conditions in definition [ def : join ] impose no restrictions on positive dependencies _ inside _ modules or on _ negative _ dependencies in general .",
    "it is straightforward to show that @xmath246 has the following properties :    1 .",
    "identity : @xmath247 for all modules @xmath162 .",
    "commutativity : @xmath248 for all modules @xmath224 and @xmath225 such that @xmath249 is defined .",
    "associativity : @xmath250 for all modules @xmath251 and @xmath252 such that all pairwise joins are defined .",
    "the equality `` @xmath253 '' used above denotes syntactical equality .",
    "also note that @xmath254 is usually undefined , which is a difference with respect to @xmath124 for which it holds that @xmath255 for all programs @xmath0 .",
    "furthermore , considering the join @xmath244 , since each atom is defined in exactly one module , the sets of rules in @xmath224 and @xmath225 are distinct , that is , @xmath256 , and also , @xmath257 , @xmath258 , and @xmath259 .    having the semantics of an individual smodels program module",
    "now defined , we may characterize the properties of the semantics under program composition using the notion of _",
    "[ def : compatibility ] given smodels program modules @xmath224 and @xmath225 such that @xmath239 is defined , we say that interpretations @xmath260 and @xmath261 are compatible if and only if @xmath262 .",
    "we use _ natural join _",
    "@xmath263 to combine compatible interpretations .",
    "[ def : natural - join ] given smodels program modules @xmath224 and @xmath225 and sets of interpretations @xmath264 and @xmath265 , the natural join of @xmath266 and @xmath267 , denoted by @xmath268 , is @xmath269    the stable model semantics is compositional for @xmath246 , that is , if a program ( module ) consists of several submodules , its stable models are locally stable for the respective submodules ; and on the other hand , local stability implies global stability for compatible stable models of the submodules .",
    "[ moduletheorem ] if @xmath224 and @xmath225 are smodels program modules such that @xmath244 is defined , then @xmath270    instead of proving theorem [ moduletheorem ] directly from scratch we will propose _ a general translation - based scheme _ for introducing syntactical extensions for the module theorem . for this",
    "we need to define a concept of _ modular equivalence _",
    "first , and thus the proof of theorem [ moduletheorem ] is deferred until section [ proof - mod - theorem ] .",
    "it is worth noting that classical propositional theories have an analogous property obtained by substituting @xmath124 for @xmath246 and replacing stable models by classical models in theorem [ moduletheorem ] , that is , for any smodels programs @xmath271 and @xmath272 , @xmath273 , where @xmath274 .",
    "recall modules @xmath179 and @xmath187 in example [ ex : hc1 ] . in example",
    "[ ex : hc2 ] we showed that @xmath275 is a stable model of @xmath276 .",
    "now module @xmath277 has six stable models , but none of them is compatible with @xmath56 . thus by theorem [ moduletheorem ] there is no stable model @xmath278 for @xmath279 such that @xmath280 .",
    "the join @xmath281 can be used to find any graph of @xmath174 nodes which has a hamiltonian cycle .",
    "for instance @xmath279 has four stable models : @xmath282 these models represent the four possible graphs of two nodes having a hamiltonian cycle . @xmath136",
    "theorem [ moduletheorem ] straightforwardly generalizes for modules consisting of several submodules .",
    "consider a collection of smodels program modules @xmath283 such that the join @xmath284 is defined ( recall that @xmath246 is associative ) .",
    "we say that a collection of interpretations @xmath285 for modules @xmath283 , respectively , is _ compatible _ , if and only if @xmath286 and @xmath287 are pairwise compatible for all @xmath288 .",
    "the natural join generalizes for a collection of modules as @xmath289 where @xmath290 .",
    "[ general - moduletheorem ] for a collection of smodels program modules @xmath283 such that the join @xmath284 is defined , it holds that @xmath291    although corollary [ general - moduletheorem ] enables the computation of stable models on a module - by - module basis , it leaves us the task of excluding mutually incompatible combinations of stable models . it should be noted that applying the module theorem in a naive way by first computing stable models for each submodule and finding then the compatible pairs afterwards , might not be preferable .",
    "[ ex - cor - mod - thr ] consider smodels program modules @xmath292 and their join @xmath293 we have @xmath294 , @xmath295 , and @xmath296 . to apply corollary [ general - moduletheorem ] for finding @xmath297 ,",
    "a naive approach is to compute all stable models of all the modules and try to find a compatible triple of stable models @xmath298 , @xmath299 , and @xmath300 for @xmath224 , @xmath225 , and @xmath252 , respectively .",
    "* now @xmath301 and @xmath302 are compatible , since @xmath303",
    ". however , @xmath304 is not compatible with @xmath302 , since @xmath305 . on the other hand , @xmath306 is not compatible with @xmath301 , since @xmath307 .",
    "* also @xmath308 and @xmath309 are compatible , but @xmath308 is incompatible with @xmath304 . nor is @xmath309 compatible with @xmath306 .",
    "thus there are no @xmath310 , @xmath311 , and @xmath312 such that @xmath313 is compatible , which is natural as @xmath314 .",
    "@xmath136    it is not necessary to test all combinations of stable models to see whether we have a compatible triple .",
    "instead , we use the alternative definition of stable models ( definition [ def : alter - stable - model ] ) based on instantiating the module with respect to an input interpretation , and apply the module theorem similarly to the splitting - set theorem .",
    "one should notice that the set of rules in @xmath162 presented in example [ ex - cor - mod - thr ] has no non - trivial splitting sets , and thus the splitting - set theorem is not applicable ( in a non - trivial way ) in this case .",
    "[ ex - cor - mod - thr-2 ] consider smodels program modules @xmath224 , @xmath225 , and @xmath252 from example [ ex - cor - mod - thr ] .",
    "now , @xmath224 has two stable models @xmath315 and @xmath316 .    *",
    "the set @xmath317 can be seen as an input interpretation for @xmath252 .",
    "module @xmath252 instantiated with @xmath266 has one stable model : @xmath318 .",
    "furthermore , we can use @xmath319 to instantiate @xmath225 : @xmath320 .",
    "however , @xmath321 is not compatible with @xmath298 , and thus there is no way to find a compatible collection of stable models for the modules starting from @xmath298 .",
    "* we instantiate @xmath252 with @xmath322 and get @xmath323 . continuing with @xmath324 , we get @xmath325 . again , we notice that @xmath326 is not compatible with @xmath299 , and thus it is not possible to find a compatible triple of stable models starting from @xmath299 either .",
    "thus we can conclude @xmath314 .",
    "@xmath136      the notion of _ visible equivalence _",
    "@xcite was introduced in order to neglect hidden atoms when logic programs or other theories of interest are compared on the basis of their models .",
    "the compositionality property from theorem [ moduletheorem ] enables us to bring the same idea to the level of program modules  giving rise to _ modular equivalence _ of logic programs .",
    "visible and modular equivalence are formulated for smodels program modules as follows .",
    "[ smodels - mod - eq ] for two smodels program modules @xmath162 and @xmath327 ,    * @xmath328 if and only if @xmath329 and there is a bijection @xmath330 such that for all @xmath205 , @xmath331 * @xmath332 if and only if @xmath333 and @xmath328 .",
    "we note that the condition @xmath329 insisted on the definition of @xmath148 , implies @xmath334 in the presence of @xmath333 as required by the relation  @xmath335 .",
    "moreover , these relations coincide for completely specified smodels programs , that is modules  @xmath162 with @xmath336 .",
    "modular equivalence lends itself for program substitutions in analogy to _ strong equivalence _",
    "@xcite , that is , the relation @xmath335 is a proper _ congruence _ for the join operator @xmath246 .",
    "[ smodels - congruence ] let @xmath337 and @xmath338 be smodels program modules such that @xmath339 and @xmath340 are defined . if @xmath332 , then @xmath341 .",
    "the proof of theorem [ smodels - congruence ] is given in [ proofs ] .",
    "the following examples illustrate the use of modular equivalence in practice .",
    "recall programs @xmath130 and @xmath131 from example [ uni - not - strong ] .",
    "we can define modules based on them : @xmath342 and @xmath343 .",
    "now it is impossible to define a module @xmath338 based on @xmath133 in a way that @xmath340 would be defined .",
    "moreover , it holds that @xmath332 .",
    "@xmath136    module @xmath344 is based on an alternative encoding for hamiltonian cycle problem given in  @xcite .",
    "in contrast to the encoding described in example [ ex : hc1 ] , this encoding does not allow us to separate the selection of the edges to the cycle and the checking of reached vertices into separate modules as their definitions are mutually dependent .",
    "the input signature of @xmath345 is the same as for @xmath179 , that is , @xmath346 .",
    "the output signature of @xmath345 is the output signature of @xmath281 , that is , @xmath347 the set @xmath348 contains rules @xmath349 for each @xmath350 such that @xmath351 in ( [ y - ne - z ] ) and @xmath352 in ( [ x - ne - z ] ) .",
    "now , one may notice that @xmath345 and @xmath281 have the same input / output interface , and @xmath353 which implies @xmath354 .",
    "@xmath136    as regards the relationship between modular equivalence and previously proposed notions of equivalence , we note the following . first , if one considers the _ fully visible case _ , that is , the restriction @xmath355 , modular equivalence can be seen as a special case of @xmath25-uniform equivalence for @xmath356 .",
    "recall , however , the restriction that input atoms may not appear in the heads of the rules as imposed by module structure . with a further restriction @xmath357 ,",
    "modular equivalence basically coincides with weak equivalence because @xmath358 can always be satisfied by extending the interface of the module .",
    "setting @xmath359 would in principle give us uniform equivalence , but the additional condition @xmath169 leaves room for the empty module only .",
    "in the general case with hidden atoms , the problem of verifying @xmath335 for smodels program modules can be reduced to verifying @xmath148 for smodels programs .",
    "this is achieved by introducing a special module @xmath360 containing a single choice rule , which acts as a context generator in analogy to @xcite .",
    "we say that two modules @xmath162 and @xmath327 are _ compatible _ if they have the same input / output interface , that is , @xmath333 and @xmath334 .",
    "[ reduce - modular - to - visible ] consider compatible smodels program modules @xmath162 and @xmath327 .",
    "now @xmath332 if and only if @xmath361 where @xmath362 and @xmath363 generates all possible input interpretations for @xmath162 and @xmath327 .    notice that @xmath364 and @xmath365 are smodels program modules with empty input signatures , and thus they can also be viewed as smodels programs .",
    "( @xmath366 ) assume @xmath332 .",
    "since @xmath364 and @xmath365 are defined , @xmath367 by theorem [ smodels - congruence ] .",
    "this implies @xmath361 .",
    "( @xmath368 ) assume @xmath361 , that is , @xmath329 and there is a bijection @xmath369 such that for each @xmath370 , @xmath371 . by theorem  [ moduletheorem ] , @xmath372 and @xmath373 .",
    "now , @xmath374 , and thus @xmath375 and @xmath376 .",
    "this implies @xmath328 , and furthermore @xmath332 since @xmath162 and @xmath327 are compatible smodels program modules .",
    "due to the close relationship of @xmath148 and @xmath335 , the respective verification problems have the same computational complexity .",
    "as already observed in @xcite , the verification of @xmath328 involves a _ counting problem _ in general and , in particular , if @xmath377 . in this special setting @xmath328 holds if and only if @xmath378 , that is , the numbers of stable models for @xmath162 and @xmath327 coincide . a reduction of computational time complexity can be achieved for modules that have _ enough visible atoms _ , that is , the eva property .",
    "basically , we say that module @xmath197 has enough visible atoms , if and only if @xmath122 has enough visible atoms with respect to @xmath379 .",
    "however , the property of having enough visible atoms can be elegantly stated using modules .",
    "we define the _ hidden part _ of a module @xmath197 as @xmath380 where @xmath381 contains all rules of @xmath122 involving atoms of @xmath166 in their heads . for a choice rule @xmath382",
    ", we take the projection @xmath383 in @xmath381 .",
    "[ eva - modules ]   + an smodels program module @xmath197 has enough visible atoms if and only if the hidden part @xmath380 has a unique stable model @xmath56 for each interpretation @xmath384 such that @xmath385 .",
    "verifying the eva property is @xmath153-hard and in @xmath386 for smodels programs  ( * ? ? ?",
    "* proposition 4.14 ) , and thus for smodels program modules , too .",
    "it is always possible to enforce the eva property by uncovering sufficiently many hidden atoms : a module @xmath162 for which @xmath387 has clearly enough visible atoms because @xmath388 has no rules .",
    "it is also important to realize that choice rules involving hidden atoms in their heads most likely break up the eva property  unless additional constraints are introduced to exclude multiple models created by choices .",
    "based on the observations we can conclude that verifying the modular equivalence of modules with the eva property is a @xmath153-complete decision problem .",
    "motivated by the complexity result and by previous proposals for translating various equivalence verification problems into the problem of computing stable models ( see @xcite for instance ) , we recently introduced a translation - based method for verifying modular equivalence  @xcite .",
    "in the following theorem , @xmath389 is the linear translation function mapping two smodels program modules into one smodels program module presented in  ( * ? ? ?",
    "* definition  10 ) .    *",
    "( ( * ? ? ?",
    "* theorem 4 ) ) * [ eq - test - with - context ] let @xmath162 and @xmath327 be compatible smodels program modules with the eva property , and @xmath390 any smodels program module such that @xmath391 and @xmath392 are defined .",
    "then @xmath393 if and only if @xmath394 .",
    "let us now proceed to the proof of the module theorem .",
    "we describe the overall strategy in this section whereas detailed proofs for the theorems are provided in [ proofs ] . instead of proving theorem [ moduletheorem ] from scratch ,",
    "we first show that the theorem holds for normal logic program modules , and then present a general scheme that enables us to derive extensions of the module theorem syntactically in terms of translations .",
    "we start by stating the module theorem for normal logic program modules .",
    "[ theorem : nlp - moduletheorem ] if @xmath224 and @xmath225 are normal logic program modules such that @xmath244 is defined , then @xmath395    proof for theorem [ theorem : nlp - moduletheorem ] is given in [ proofs ] .",
    "next definition states the conditions which we require a translation function to have in order to achieve syntactical extensions to the module theorem .",
    "intuitively , the conditions serve the following purposes : first , the translation has to be _ strongly faithful _ , that is , it preserves the roles of all atoms in the original module ; second , it is _ @xmath246-preserving _ , that is , possible compositions of modules are not limited by the translation ; and third , the translation is _",
    "modular_.    for convenience , we define an operator @xmath396 for any program module @xmath397 and for any set of atoms @xmath398 . the revealing operator is used to make a set of hidden atoms of a module visible to other modules .",
    "[ def : conditions - for - translation ] let @xmath399 and @xmath400 be two classes of logic program modules such that @xmath401 .",
    "a translation function @xmath402 is _ strongly faithful , modular and @xmath246-preserving _ , if the following hold for any program modules",
    "@xmath403 :    1 .   @xmath404 ; 2 .",
    "if @xmath405 is defined , then @xmath406 is defined ; and 3 .",
    "@xmath407 .",
    "notice that the condition for strong faithfulness requires @xmath408 , @xmath409 , and @xmath410 to hold .",
    "moreover , strong faithfulness implies _ faithfulness _ , that is , @xmath411 .",
    "[ theorem : modulethr - translation ] let @xmath399 and @xmath400 be two classes of logic program modules such that @xmath401 and there is a translation function @xmath412 that is strongly faithful , @xmath246-preserving , and modular as given in definition [ def : conditions - for - translation ] .",
    "if the module theorem holds for modules in @xmath400 , then it holds for modules in @xmath399 .",
    "the proof of theorem  [ theorem : modulethr - translation ] is provided in [ proofs ] .",
    "as regards the translation from smodels program modules to nlp modules , it suffices , for example , to take a natural translation similarly to  @xcite .",
    "note that the translation presented in definition [ smodels2basic ] is in the worst case exponential with respect to the number of rules in the original module . for a more compact translation , see @xcite , for example .",
    "[ smodels2basic ] given an smodels program module @xmath197 , its translation into a normal logic program module is @xmath413 , where @xmath191 contains the following rules :    * for each choice rule @xmath414 the set of rules @xmath415 * for each weight rule @xmath416 the set of rules @xmath417    where each @xmath418 is a new atom not appearing in @xmath419 and @xmath420 .",
    "[ theorem : translation - smodels2nlp ] the translation @xmath421 from smodels program modules to normal logic program modules given in definition [ smodels2basic ] is strongly faithful , @xmath246-preserving , and modular .    the proof of theorem [ theorem : translation - smodels2nlp ] is given in [ proofs ] .",
    "the module theorem now directly follows from theorems [ theorem : nlp - moduletheorem ] , [ theorem : modulethr - translation ] , and [ theorem : translation - smodels2nlp ] .    by theorem [ theorem : nlp - moduletheorem ]",
    "we know that the module theorem holds for normal logic program modules .",
    "theorem [ theorem : modulethr - translation ] shows that definition [ def : conditions - for - translation ] gives the conditions under which theorem [ theorem : nlp - moduletheorem ] can be directly generalized for a larger class of logic program modules . by theorem [ theorem : translation - smodels2nlp ]",
    "we know that the translation @xmath421 from smodels program modules to nlp modules introduced in definition [ smodels2basic ] satisfies the conditions given in definition [ def : conditions - for - translation ] , and therefore smodels program modules are covered by the module theorem .",
    "our module system resembles the module system proposed in  @xcite . however , to make our system compatible with the stable model semantics we need to introduce a further restriction of mutual dependence , that is , we need to deny positive recursion between modules .",
    "also other propositions involve similar conditions for module composition .",
    "for example , brogi et al .",
    "employ visibility conditions that correspond to respecting hidden atoms .",
    "however , their approach covers only positive programs under the least model semantics .",
    "maher   forbids all recursion between modules and considers przymusinski s _ perfect models _ @xcite rather than stable models .",
    "etalle and gabbrielli restrict the composition of _ constraint logic program _",
    "@xcite modules with a condition that is close to ours : @xmath422 but no distinction between input and output is made , for example , @xmath423 is allowed according to their definitions .",
    "approaches to modularity within asp typically do not allow any recursion ( negative or positive ) between modules @xcite .",
    "theorem [ moduletheorem ] , the module theorem , is strictly stronger than the splitting - set theorem  @xcite for normal logic programs , and the general case allows us to generalize the splitting - set theorem for smodels programs .",
    "consider first the case of normal logic programs .",
    "a _ splitting _ of a program can be used as a basis for a module structure .",
    "if @xmath94 is a splitting set for a normal logic program @xmath0 , then we can define @xmath424 it follows directly from theorems [ thr : splitting - set ] and [ moduletheorem ] that @xmath425 and @xmath426 are compatible if and only if @xmath427 is a solution for @xmath0 with respect to @xmath94 .    [ modulethr - vs - splitting ] consider a normal logic program @xmath428 the set @xmath429 is a splitting set for @xmath0 , and therefore the splitting set - theorem ( theorem [ thr : splitting - set ] ) can be applied : @xmath430 and @xmath431 .",
    "now @xmath315 and @xmath316 are the stable models of @xmath95 , and we can evaluate the top with respect to @xmath298 and @xmath299 , resulting in solutions @xmath432 and @xmath433 , respectively . on the other hand ,",
    "@xmath0 can be seen as join of modules @xmath434 and @xmath435 .",
    "now , we have @xmath436 and @xmath437 . out of eight possible pairs",
    "only @xmath438 and @xmath439 are compatible .",
    "however , it is possible to apply theorem [ moduletheorem ] similarly to the splitting - set theorem , that is , we only need to compute the stable models of @xmath225 compatible with the stable models of @xmath224 .",
    "notice that when the splitting - set theorem is applicable , the stable models of @xmath224 fully define the possible input interpretations for @xmath225 .",
    "this leaves us with stable models @xmath440 and @xmath441 for the composition .",
    "@xmath136    on the other hand , consider the module @xmath434 in the above example .",
    "there are no non - trivial splitting sets for the bottom program @xmath442 .",
    "however , @xmath224 can be viewed as the join of two nlp modules @xmath443 , and @xmath444 to which the module theorem is applicable .    in the general case of smodels program modules",
    "we can use the module theorem to generalize the splitting - set theorem for smodels programs .",
    "then the bottom module acts as an input generator for the top module , and one can simply find the stable models for the top module instantiated with the stable models of the bottom module .",
    "the latter strategy used in example [ modulethr - vs - splitting ] works even if there is negative recursion between the modules , as already shown in example [ ex - cor - mod - thr-2 ] .",
    "the module theorem strengthens an earlier version given in @xcite to cover programs that involve positive body literals , too .",
    "the independent sets proposed by faber et al .",
    "push negative recursion inside modules which is unnecessary in view of our results .",
    "their version of the module theorem is also weaker than theorem [ moduletheorem ] .",
    "the approach to modularity based on lp - functions  @xcite has features similar to our approach .",
    "the components presented by lp - functions have an input / output interface and a _ domain _ reflecting the possible input interpretations .",
    "the functional specification requires an lp - function to have a _",
    "consistent answer set _ for any interpretation in its domain .",
    "this is something that is not required in our module system .",
    "lp - functions are flexible in the sense that there are several operators for refining them .",
    "however , the composition operator for lp - functions allows only incremental compositions , which again basically reflects the splitting - set theorem .",
    "so far we have established a module architecture for the class smodels programs , in which modules interact through an input / output interface and the stable model semantics is fully compatible with the architecture . in this section",
    "we investigate further the ways to understand the internal structure of logic programs by seeing them as compositions of logic program modules .",
    "first , we use the conditions for module composition to introduce a method for decomposing an smodels program into modules . a more detailed knowledge of the internal structure of a program ( or a module ) might reveal ways to improve search for stable models .",
    "another application can be found in modularization of the translation - based equivalence verification method in  @xcite .",
    "second , we consider possibilities of relaxing the conditions for module composition , that is , whether it is possible to allow positive recursion between modules in certain cases .",
    "recall that any smodels program @xmath0 can be viewed as a module @xmath445 , and thus we consider here a more general case of finding a module decomposition for an arbitrary smodels program module @xmath197 .",
    "the first step is to exploit the strongly connected components @xmath446 of @xmath447 and define submodules  @xmath448 by grouping the rules so that for each @xmath449 all the rules @xmath450 such that @xmath451 are put into one submodule .",
    "now , the question is whether @xmath448 s defined this way would form a valid decomposition of @xmath162 into submodules .",
    "first notice that input atoms form a special case because @xmath169 .",
    "each @xmath452 ends up in its own strongly connected component and there are no rules to include into a submodule corresponding to strongly connected component @xmath453 . thus it is actually unnecessary to include a submodule based on such a component .",
    "obviously , each weight rule in @xmath122 goes into exactly one of the submodules .",
    "one should notice that for a choice rule @xmath450 it can happen that @xmath454 and @xmath455 for @xmath456 .",
    "this is not a problem , since it is always possible to _ split a choice rule _ by projecting the head , that is , by replacing a choice rule of the form @xmath51 with choice rules @xmath457 for each scc @xmath449 such that @xmath458 .",
    "based on the discussion above , we define the _ set of rules defining a set of atoms _ for an smodels program module .",
    "[ rule - set - defining ] given an smodels program module @xmath197 and a set of atoms @xmath459 , the set of rules defining @xmath5 , denoted by @xmath460 $ ] , contains the following rules :    * a choice rule @xmath461 if and only if there is a choice rule  @xmath51 in @xmath122 such that @xmath462 ; and * a weight rule @xmath463 if and only if there is a weight rule  @xmath463 in @xmath122 such that @xmath464",
    ".    we continue by defining a submodule of @xmath197 induced by a set of atoms @xmath459 .",
    "we use definition [ rule - set - defining ] for the set of rules , and choose @xmath465 to be the output signature and the rest of the visible atoms appearing in @xmath460 $ ] to be the input signature .",
    "[ induced - module ] given an smodels program module @xmath197 and a set of atoms @xmath459 , a submodule induced by @xmath5 is @xmath466=(r[d ] ,   ( { \\mathrm{at}(r[d])}\\setminus d){\\cap}(i{\\cup}o ) ,   d{\\cap}o , d{\\cap}h).\\ ] ]    let @xmath467 be the strongly connected components of @xmath447 such that @xmath468",
    ". now we can define @xmath469 $ ] for each @xmath470 .",
    "since the strongly connected components of @xmath447 are used as a basis , it is guaranteed that there is no positive recursion between any of the submodules @xmath448 .",
    "also , it is clear that the output signatures of the submodules are pairwise disjoint .",
    "unfortunately this construction does not yet guarantee that hidden atoms stay local , and therefore the composition @xmath471 might not be defined because certain @xmath448 s might not respect each others hidden atoms .",
    "a solution is to combine @xmath472 s in a way that modules will be closed with respect to dependencies caused by the hidden atoms , that is , if a hidden atom @xmath473 belongs to a component @xmath472 , then also all the atoms in the heads of rules in which @xmath473 or @xmath474 appears , have to belong to @xmath472 , too .",
    "this can be achieved by finding the strongly connected components , denoted by @xmath475 , for @xmath476 , where @xmath476 has @xmath477 as the set of vertices , and @xmath478 as the set of edges .",
    "now , we take the sets @xmath479 for @xmath480 and use them to induce a module structure for @xmath162 by defining @xmath481 $ ] for @xmath480 .",
    "as there may be atoms in @xmath419 not appearing in the rules of @xmath162 , that is , @xmath482 does not necessarily hold for @xmath197 , it is possible that @xmath483 to keep track of such atoms in @xmath484 we need an additional module defined as @xmath485 there is no need for a similar treatment for atoms in @xmath486 as each atom in @xmath487 belongs to some @xmath488 by definition .",
    "theorem [ decomposition ] shows that we have a valid decomposition of @xmath162 into submodules .",
    "[ decomposition ] consider an smodels program module @xmath162 , and let @xmath467 be the sccs of @xmath447 such that @xmath468 , and @xmath475 the strongly connected components of @xmath476 .",
    "define @xmath489 , and @xmath481 $ ] for @xmath490 and @xmath480 .",
    "then the join of the submodules @xmath448 for @xmath491 is defined and @xmath492 .",
    "based on the construction of @xmath493 s and the discussion in this section it is clear that @xmath494 is defined .",
    "it is easy to verify that the sets of input , output , and hidden atoms of modules @xmath495 and @xmath162 are exactly the same .",
    "the only difference between the sets of rules in @xmath162 and @xmath495 is that some choice rules in @xmath162 may have been split into several rules in @xmath495 .",
    "this is a syntactical change not affecting the stable models of the modules , that is , @xmath496 .",
    "notice also that @xmath497 .",
    "thus it holds that @xmath498 .",
    "even though example [ ex : gs - composition ] shows that conditions for @xmath232 are not enough to guarantee that the module theorem holds , there are cases where @xmath405 is not defined and still it holds that @xmath499 .",
    "[ ex3 ] consider modules @xmath500 and @xmath501 . now",
    ", the composition @xmath502 is defined as the output sets are disjoint and there are no hidden atoms .",
    "since @xmath503 and @xmath504 , we get @xmath505 .",
    "@xmath136    example [ ex3 ] suggests that the denial of positive recursion between modules can be relaxed in certain cases .",
    "we define a semantical characterization for module composition that maintains the compositionality of the stable model semantics .",
    "[ semantical - join ] the _ semantical join",
    "_ @xmath506 of two smodels program modules @xmath224 and @xmath225 is @xmath239 , provided @xmath239 is defined and @xmath507 .",
    "the module theorem holds by definition for smodels program modules composed with @xmath508 .",
    "we can now present an alternative formulation for modular equivalence taking features from strong equivalence  @xcite .",
    "[ new - mod - eq ] smodels program modules @xmath162 and @xmath327 are _ semantically modularly equivalent _ , denoted by @xmath509 , if and only if @xmath333 and @xmath510 for all @xmath338 such that @xmath511 and @xmath512 are defined .",
    "it is straightforward to see that @xmath513 is a congruence for @xmath508 and reduces to @xmath148 for modules with completely specified input , that is , modules @xmath162 such that @xmath336 .",
    "[ same - eqs ] @xmath332 if and only if @xmath509 for any smodels program modules @xmath162 and @xmath327 .",
    "assume @xmath509 .",
    "now , @xmath332 is implied by definition [ new - mod - eq ] with empty context module @xmath514 .",
    "assume then @xmath332 , that is , there is a bijection @xmath515 such that for each @xmath205 , @xmath371 .",
    "consider arbitrary @xmath338 such that @xmath511 and @xmath512 are defined . then @xmath516 and @xmath517 .",
    "we now define @xmath518 such that for any @xmath519 , @xmath520 where @xmath521 such that @xmath522 and @xmath523 are compatible .",
    "now , @xmath524 is a bijection and @xmath525 for each @xmath519 .",
    "since @xmath338 was arbitrary , @xmath509 follows .",
    "theorem [ same - eqs ] implies that @xmath335 is a congruence for @xmath508 , too .",
    "thus it is possible to replace @xmath162 with modularly equivalent @xmath327 in the contexts allowed by @xmath508 .",
    "the syntactical restriction denying positive recursion between modules is easy to check , since sccs can be found in a linear time with respect to the size of the dependency graph  @xcite . to the contrary , checking whether @xmath526 is a computationally harder problem .",
    "[ tradeoff ] given smodels program modules @xmath224 and @xmath225 such that @xmath239 is defined , deciding whether it holds that @xmath526 is a @xmath153-complete decision problem .",
    "let @xmath224 and @xmath225 be smodels program modules such that @xmath239 is defined .",
    "we can show @xmath527 by choosing @xmath528 and checking that    * @xmath529 and @xmath530 ; or * @xmath529 and @xmath531 ; or * @xmath532 , @xmath533 , and @xmath534 .",
    "once we have chosen @xmath56 , these tests can be performed in polynomial time , which shows that the problem is in @xmath153 . to establish @xmath153-hardness",
    "we present a reduction from @xmath535 .",
    "consider a finite set @xmath536 of three - literal clauses @xmath537 of the form @xmath538 where each @xmath539 is either an atom @xmath12 or its classical negation @xmath540 .",
    "each clause @xmath537 is translated into rules @xmath541 of the form @xmath542 , where @xmath543 , and @xmath544 if @xmath545 and @xmath546 if @xmath547 .",
    "the intuitive reading of @xmath548 is that clause @xmath537 is satisfied .",
    "we define modules @xmath549 and @xmath550 now @xmath239 is defined , and @xmath551 .",
    "there is @xmath552 that is compatible with @xmath553 if and only if @xmath554 . since @xmath555 and @xmath556 for all @xmath557 , it follows that @xmath558 if and only if @xmath559 .",
    "theorem [ tradeoff ] shows that there is a tradeoff for allowing positive recursion between modules , as more effort is needed to check that composition of such modules does not compromise the compositionality of the stable model semantics .",
    "the goal of this section is to demonstrate how the module system introduced in section [ section : modules ] can be exploited in practise in the context of the smodels system and other compatible systems . in this respect ,",
    "we present tools that have been developed for the ( de)composition of logic programs that are represented in the _ _ internal file format _ _ of the smodels engine .",
    "the binaries for both tools are available under the asptools collection . moreover , we conduct and report a practical experiment which illustrates the performance of the tools when processing substantially large benchmark instances , that is , smodels programs having up to millions of rules ( see the asptools web page for examples ) .    the first tool , namely modlist , is targeted at program decomposition based on the strongly connected components of an smodels program given as input . in view of the objectives of section [ section : decomposition ] , there are three optional outcomes of the decomposition , that is , strongly connected components that take into account    1 .",
    "positive dependencies only , 2 .   positive dependencies and hidden atoms , and 3 .",
    "both positive and negative dependencies as well as hidden atoms .    the number of modules created by modlist decreases in this order .",
    "however , our benchmarks cover program instances that get split in tens of thousands of modules . to tackle the problem of storing such numbers of modules in separate files we decided to use file compression and packaging tools and , in particular , the zip utility available in standard linux installations .",
    "we found zip superior to tar as it allows random access to files in an archive , or a _",
    "zipfile_. this feature becomes valuable when the modules are accessed from the archive for further processing .",
    "the tool for program composition has been named as lpcat which refers to the concatenation of files containing logic programs .",
    "a new version of the tool was implemented for experiments reported below for better performance as well as usability .",
    "the old version ( version 1.8 ) is only able to combine two modules at a time which gives a quadratic nature for a process of combining @xmath174 modules together : modules are added one - by - one to the composition .",
    "the new version , however , is able to read in modules from several files and , even more conveniently , a _ stream of modules _ from an individual file .",
    "the zip facility provides an option for creating such a stream that can then be forwarded for lpcat for composition .",
    "this is the strategy for composing programs in experiments that are described next .",
    "@c@    .summary of benchmark results for module ( de)composition [ table : results ] [ cols=\"<,>,>,<,>,>,>\",options=\"header \" , ]     a few concluding remarks follow .",
    "increasing the number of modules in a program tends to decrease the number of modules that can be decomposed per time unit .",
    "this observation suggests that the creation of the zipfile has a quadratic flavor although modules themselves can be figured out in linear time ( using a variant of tarjan s algorithm ) .",
    "perhaps this can be improved in the future by better integrating the creation of the zipfile into modlist . for",
    "now , it creates a shell script for this purpose . handling the biggest program instances is also subject to the effects of memory allocation which may further slow down computations . on the other hand",
    ", the cost of increasing the number of rules in modules seems to be relatively small .",
    "moreover , it is clear on the basis of data given in table [ table : results ] that the composition of programs is faster than decomposition",
    ". this would not be the case if the old version of lpcat were used for composition .",
    "last , we want to emphasize that modlist and lpcat have been implemented as supplementary tools that are not directly related to the computation of stable models . nevertheless , we intend to exploit these tools in order to modularize different tasks in asp such as verifying ordinary / modular equivalence and program optimization .",
    "the existence of such tools enables modular program development and the creation of _ module libraries _ for smodels programs , and thus puts forward the use of module architectures in the realm of asp .",
    "in this paper , we introduce a simple and intuitive notion of a logic program module that interacts with other modules through a well - defined input / output interface .",
    "the design has its roots in a module architecture proposed for conventional logic programs @xcite , but as regards our contribution , we tailor the architecture in order to better meet the criteria of asp .",
    "perhaps the most important objective in this respect is to achieve the compositionality of stable model semantics , that is , the semantics of an entire program depends directly on the semantics assigned to its modules . to this end",
    ", the main result of this paper is formalized as the _ module theorem _ ( theorem [ moduletheorem ] ) which links program - level stability with module - level stability .",
    "the theorem holds under the assumption that positively interdependent atoms are always placed in the same module .",
    "the _ join _",
    "operation @xmath246 defined for program modules effectively formalizes this constraint  which we find acceptable when it comes to good programming style in asp .",
    "the module theorem is also a proper generalization of the splitting - set theorem  @xcite recast for smodels programs .",
    "the main difference is that splitting - sets do not enable any kind of recursion between modules . even though the module theorem is proved to demonstrate the feasibility of the respective module architecture , it is also applied as a tool to simplify mathematical proofs in this paper and recently also in  @xcite .",
    "it also lends itself to extensions for further classes of logic programs which can be brought into effect in terms of _ strongly faithful _ , @xmath246-_preserving _ , and _",
    "translations for the removal of new syntax ( theorem [ theorem : modulethr - translation ] ) .",
    "moreover , the module theorem paves the way for the modularization of various reasoning tasks , such as search for answer sets , query evaluation , and verification , in asp .",
    "the second main theme of the paper is the notion of modular equivalence which is proved to be a proper congruence relation for program composition using @xmath246 ( theorem [ smodels - congruence ] ) .",
    "thus modular equivalence is preserved under substitutions of modularly equivalent program modules . since",
    "uniform equivalence is not a congruence for ordinary @xmath124 but strong equivalence is by definition , modular equivalence can be viewed as a reasonable compromise between these two extremes .",
    "in addition to the congruence property , we present a number of results about modular equivalence .    1 .",
    "we show that deciding modular equivalence forms a @xmath153-complete decision problem for smodels program modules with the eva property , that is , those having enough visible atoms so that their stable models can be distinguished from each other on the basis of visible atoms only . in this way , it is possible to use the smodels solver for the actual verification task .",
    "we consider the possibility of redefining the join operation @xmath246 using a semantical condition that corresponds to the content of the module theorem .",
    "the notion of modular equivalence is not affected , but the cost of verifying whether a particular join of modules is defined becomes a @xmath153-complete decision problem .",
    "this is in contrast with the linear time check for positive recursion ( tarjan s algorithm for strongly connected components ) but it may favorably extend the coverage of modular equivalence in certain applications .",
    "finally , we also analyze the problem of decomposing an smodels program into modules when there is no a priori knowledge about the structure of the program .",
    "the strongly connected components of the program provide the starting point in this respect , but the usage of hidden atoms may enforce a higher degree of amalgamation when the modules of a program are extracted .",
    "the theoretical results presented in the paper have emerged in close connection with the development of tools for asp .",
    "the practical demonstration in section [ section : experiments ] illustrates the basic facilities that are required to deal with _ object level _",
    "modules within the smodels system .",
    "the linker , namely lpcat , enables the composition of ground programs in the smodels format . using this tool , for instance",
    ", it is possible to add a query to a program afterwards without grounding the program again . on the other hand , individual modules of a program",
    "can be accessed from the zipfile created by the module extractor modlist .",
    "this is highly practical since we intend to pursue techniques for module - level optimization in the future .",
    "this work has been partially supported by the academy of finland through projects # 211025 and # 122399 .",
    "the first author gratefully acknowledges the financial support from helsinki graduate school in computer science and engineering , emil aaltonen foundation , the finnish foundation for technology promotion tes , the nokia foundation , and the finnish cultural foundation .",
    "let @xmath162 and @xmath327 be modules such that @xmath332 .",
    "let @xmath338 be an arbitrary module such that @xmath339 and @xmath340 are defined . from @xmath329 and @xmath333",
    "it follows that @xmath560 and @xmath561 .",
    "consider any model @xmath562 . by theorem [ moduletheorem ] , @xmath563 , that is , @xmath564 and @xmath565 .",
    "since @xmath332 , there is a bijection @xmath566 such that @xmath567 , and @xmath568 denote @xmath569 .",
    "clearly , @xmath570 and @xmath571 are compatible .",
    "since ( [ eq4 ] ) holds , also @xmath572 and @xmath571 are compatible . applying theorem [ moduletheorem ]",
    "we get @xmath573 .",
    "* @xmath524 is an injection : @xmath577 implies @xmath578 for all @xmath579 , since @xmath580 or @xmath581 .",
    "* @xmath524 is a surjection : for any @xmath582 , @xmath583 and @xmath584 , since @xmath39 is a surjection .",
    "we present an alternative proof to the one given in @xcite .",
    "we use the characterization of stable models based on the programs completion and loop formulas presented in theorem  [ stable - models - using - loop - formulas ] .",
    "first , we need to generalize the concepts of completion and loop formulas for nlp modules . given a normal logic program module @xmath197",
    ", we define @xmath588 that is , we take the completion in the normal way for the set of rules @xmath122 with the exception that we take into account that input atoms do not have any defining rules . as regards loop formulas , we define @xmath589 , since no atom in the input signature can appear in any of the loops .",
    "consider an arbitrary nlp module @xmath197 .",
    "define a set of rules , that is , a conventional normal logic program , @xmath590 , where @xmath591 and all atoms @xmath592 are new atoms not appearing in @xmath419 .",
    "now , @xmath205 if and only if @xmath593 . on the other hand , by theorem [ stable - models - using - loop - formulas ] , @xmath594 if and only if @xmath595 .",
    "considering the completion , since @xmath169 , and atoms @xmath592 are new , it holds that @xmath596 . as regards loop formulas",
    ", we notice that @xmath597 is @xmath598 together with vertices for atoms @xmath599 , which have no edges in @xmath597",
    ". therefore , @xmath600 .",
    "thus @xmath595 if and only if @xmath601 . furthermore ,",
    "based on the relationship between @xmath56 and @xmath278 , it holds that @xmath601 if and only if @xmath602 . thus theorem [ stable - models - using - loop - formulas ] generalizes directly for nlp modules : given a normal logic program module @xmath162 and an interpretation @xmath198 , it holds that @xmath205 if and only if @xmath602 .",
    "furthermore , the satisfaction relation is compositional for @xmath124 , that is , @xmath605 if and only if @xmath606 and @xmath607 for any propositional theories @xmath0 and @xmath1 .",
    "thus @xmath608 it follows that @xmath609 .",
    "let @xmath399 and @xmath400 be two classes of logic program modules such that @xmath401 , and the module theorem holds for modules in @xmath400 . consider a translation function @xmath412 such that conditions 13 from definition [ def : conditions - for - translation ] are satisfied .",
    "let @xmath610 be modules such that @xmath244 is defined .",
    "then condition 2 implies that @xmath611 are modules such that @xmath612 is defined . since the module theorem holds for modules in @xmath400 , @xmath613 .",
    "moreover , condition 3 implies that @xmath614 .",
    "condition 1 implies there is a bijection @xmath615 such that for any @xmath616 we have @xmath617 .",
    "notice that strong faithfulness requires that the projections of @xmath56 and @xmath618 have to be identical over whole @xmath619 not just over @xmath620 .",
    "similarly there are bijections @xmath621 such that for any @xmath622 ( @xmath623 ) it holds that @xmath624 .",
    "consider arbitrary @xmath625 , and its projections @xmath626 and @xmath627 .",
    "now , @xmath298 and @xmath299 are compatible , and @xmath628 .",
    "assume that @xmath616 .",
    "since the module theorem holds for @xmath400 , we have @xmath629 that is , @xmath630 @xmath631 and @xmath632 are compatible projections of @xmath618 .",
    "moreover , @xmath617 and @xmath633 for @xmath623 . using the inverse functions of @xmath634 and @xmath635 we get @xmath636 and @xmath637 .    for",
    "the other direction , assume that @xmath310 and @xmath311 .",
    "then @xmath638 and @xmath639 .",
    "since @xmath640 @xmath298 and @xmath299 are compatible , also @xmath631 and @xmath632 are compatible . by applying the module theorem for @xmath400",
    ", we get @xmath641 .",
    "furthermore , @xmath642 , and using the inverse of @xmath524 we get @xmath643 .",
    "consider smodels program modules @xmath224 and @xmath225 .",
    "it is straightforward to see that @xmath421 is @xmath246-preserving , that is , if @xmath244 is defined , then also @xmath644 is defined .",
    "the key observation is that for every edge in the dependency graph @xmath645 there is also an edge in @xmath646 .",
    "contains some edges that are not in @xmath645 .",
    "this happens when there is a weight rule the body of which can never be satisfied .",
    "] since @xmath224 and @xmath225 are mutually independent , also @xmath647 and @xmath648 are mutually independent .",
    "furthermore , if @xmath244 is defined , then @xmath647 and @xmath648 respect each other s hidden atoms .",
    "this is because new atoms are introduced only for @xmath649 and @xmath650 , and @xmath651 . since @xmath652 holds , @xmath421 is also modular .",
    "thus @xmath421 satisfies conditions 2 and 3 in definition  [ def : conditions - for - translation ] .",
    "we are left to show that @xmath653 for any smodels program module @xmath654 and its translation @xmath655 note that @xmath656 and @xmath657 , and the additional restriction imposed by revealing is that the bijection between these sets of stable models needs to be such that their projections over @xmath419 , not just over @xmath658 , coincide .",
    "* _ we show that @xmath667 for any @xmath668 : _ + assume first @xmath669 , that is , there is a rule @xmath26 in @xmath670 that is not satisfied by @xmath278 .",
    "if @xmath671 , then @xmath26 is of the form @xmath672 and there are two possibilities : 1 .",
    "there is a rule @xmath673 corresponding to a choice rule @xmath674 such that @xmath675 , @xmath676 , @xmath677 , and @xmath678 .",
    "since @xmath679 implies @xmath680 , @xmath26 is satisfied in @xmath278 , a contradiction .",
    "2 .   there is a rule @xmath681 corresponding to a weight rule @xmath682 such that @xmath683 , @xmath684 , @xmath685 , @xmath677 , and @xmath686 . since @xmath687",
    "we must have @xmath688 ( which implies @xmath59 ) and @xmath689 .",
    "thus @xmath690 which implies @xmath691 .",
    "moreover , @xmath686 implies @xmath692 .",
    "but then @xmath693 . since @xmath683 and @xmath684 , we have @xmath694 and @xmath695 , a contradiction .",
    "+ otherwise each @xmath696 is of the form @xmath418 , in which case there is a rule @xmath697 and @xmath688 . since @xmath688 implies @xmath698 , then @xmath699 , a contradiction .",
    "thus @xmath700 , and furthermore @xmath701 . + assume now @xmath702 , that is , there is @xmath703 such that @xmath704 .",
    "we define @xmath705 and show @xmath706 , which contradicts the assumption @xmath707 , since @xmath708 .",
    "assume that there is a rule @xmath709 such that @xmath710 .",
    "there are two possibilities : 1 .",
    "@xmath26 is of the form @xmath711 .",
    "then there is a choice rule @xmath712 , such that @xmath201 , @xmath713 , and @xmath714 .",
    "now , @xmath201 implies @xmath715 , @xmath713 implies @xmath678 , and @xmath58 implies @xmath716 and @xmath679 .",
    "together with @xmath717 these imply @xmath696 . since @xmath710 , we have @xmath718 and @xmath719 .",
    "but , since @xmath720 , this implies @xmath721 , a contradiction to @xmath722 .",
    "@xmath26 is of the form @xmath723 .",
    "then there is a weight rule @xmath724 such that @xmath725 since @xmath710 , we have @xmath718 and @xmath726 . define @xmath727 and @xmath728 , and recall that @xmath720 .",
    "now @xmath729 , @xmath686 , @xmath677 , @xmath730 and @xmath731 , which implies that there is a rule @xmath732 such that @xmath733 which is in contradiction with @xmath704 .",
    "+ thus assuming that there is @xmath703 such that @xmath722 leads to a contradiction , and it holds that @xmath734 , that is , @xmath735 .",
    "* _ we show that @xmath736 is a bijection : _",
    "+ clearly @xmath39 is an injection : @xmath737 implies @xmath738 . to show that @xmath39 is a surjection",
    ", we consider an arbitrary @xmath735 and show @xmath739 and @xmath740 . *",
    "* assume first @xmath741 , that is , there is a rule @xmath742 that is not satisfied .",
    "notice that all the rules in @xmath743 corresponding to a choice rule in @xmath0 are always satisfied in @xmath56 .",
    "thus we need to consider only rules that correspond to a weight rule in @xmath0 .",
    "now , @xmath744 , if there is a weight rule @xmath724 such that @xmath745 .",
    "since @xmath746 , then @xmath59 and @xmath747 .",
    "define @xmath748 and @xmath728 .",
    "since @xmath749 and @xmath750 , there is a normal rule @xmath681 .",
    "furthermore , @xmath686 and @xmath677 imply @xmath732 . since @xmath59 , also @xmath688 .",
    "furthermore , @xmath751 . these imply @xmath752 which leads to a contradiction .",
    "thus @xmath753 , and moreover @xmath754 .",
    "* * next , assume that there is @xmath708 such that @xmath755 and define @xmath756 . since @xmath757 by definition , each rule of the form @xmath758 is satisfied in @xmath759 .",
    "other rules in @xmath670 are of the form @xmath760 where @xmath761 .",
    "there are now two possibilities",
    "there is a choice rule @xmath762 , such that @xmath763 , @xmath677 , @xmath678 , and @xmath679 .",
    "now , @xmath764 implies @xmath709 , and furthermore , @xmath765 implies @xmath766 .",
    "recalling @xmath767 , we get @xmath768 .",
    "2 .   there is a rule @xmath769 corresponding to a weight rule @xmath724 such that @xmath683 , @xmath684 , @xmath750 , @xmath677 and @xmath686 . if @xmath770 , then @xmath768 .",
    "assume that @xmath771 .",
    "it follows from @xmath683 and @xmath684 that @xmath772 since @xmath764 , there is @xmath773 such that @xmath774",
    ". furthermore , @xmath775 . since @xmath776 , we have @xmath777 , and also @xmath778 . thus @xmath768 . +",
    "thus using the assumption @xmath779 we can show that there is @xmath703 such that @xmath704 , which leads to a contradiction with @xmath734 .",
    "therefore , @xmath707 . * * finally , we show that @xmath740 .",
    "let @xmath780 , that is , @xmath781 notice that @xmath782 .",
    "assume @xmath783 , that is , there is @xmath698 such that @xmath784 . since @xmath784 , we have @xmath778 and furthermore @xmath680 . the only rule @xmath26 in @xmath122",
    "such that @xmath785 is @xmath786 .",
    "however , if @xmath680 , there is no rule in @xmath670 in which @xmath418 appears in the head . because @xmath787 is the least model of @xmath670",
    ", we have @xmath679 , a contradiction .",
    "assume then @xmath788 , that is , there is @xmath789 such that @xmath679 .",
    "since @xmath789 , we have @xmath731 and furthermore @xmath688 . if @xmath688 , then @xmath758 .",
    "since @xmath790 , we must have @xmath791 , a contradiction .",
    "therefore it holds that @xmath792 .        , crick , t. , vos , m.  d. , and fitch , j. 2006 . :",
    "applying answer set programming to superoptimisation . in _ logic programming : 22nd international conference , iclp 2006 , seattle , wa , usa , august 2006 , proceedings _ , s.  etalle and m.  truszczynski , eds .",
    "lecture notes in computer science , vol . 4079 .",
    "springer , 270284 .            \\2003",
    ". uniform equivalence of logic programs under the stable model semantics .",
    "in _ logic programming : 19th international conference , iclp 2003 , mumbai , india , december 2003 , proceedings _ , c.  palamidessi , ed .",
    "lecture notes in computer science , vol . 2916 .",
    "springer , 224238 .    ,",
    "fink , m. , tompits , h. , and woltran , s. 2004 . simplifying logic programs under uniform and strong equivalence . in _ logic programming and nonmonotonic reasoning : 7th international conference , lpnmr 2004 , fort lauderdale , fl , usa , january 2004 , proceedings _ , v.  lifschitz and i.  niemel , eds .",
    "lecture notes in artificial intelligence , vol .",
    "springer , 8799 .      ,",
    "gottlob , g. , and veith , h. 1997 . modular logic programming and generalized quantifiers . in _ logic programming and nonmonotonic reasoning : 4th international conference , lpnmr97 , dagstuhl castle , germany , july 1997 , proceedings _ ,",
    "j.  dix , u.  furbach , and a.  nerode , eds .",
    "lecture notes in artificial intelligence , vol .",
    "springer , 290309 .    , tompits , h. , and woltran , s. 2005 . on solution correspondences in answer - set programming . in _",
    "ijcai-05 , proceedings of the nineteenth international joint conference on artificial intelligence , edinburgh , scotland , uk , july - august 2005 _ , l.  p. kaelbling and a.  saffiotti , eds .",
    "professional book center , 97102 .        ,",
    "greco , g. , and leone , n. 2005 .",
    "magic sets and their application to data integration . in _ database theory - icdt 2005 : 10th international conference , edinburgh , uk , january 2005 , proceedings _ , t.  eiter and l.  libkin , eds .",
    "lecture notes in computer science , vol .",
    "springer , 306320 .",
    "fully abstract compositional semantics for logic programs . in _ conference record of the sixteenth annual acm sigact - sigplan symposium on principles of programming languages_. acm press , austin , texas , usa , 134142 .    , kaufmann , b. , neumann , a. , and schaub , t. 2007 . : a conflict - driven answer set solver . in _ logic programming and nonmonotonic reasoning : 9th international conference , lpnmr 2007 , tempe , az , usa , may 2007 , proceedings _ , c.  baral , g.  brewka , and j.  s. schlipf , eds .",
    "lecture notes in artificial intelligence , vol .",
    "springer , 260265 .",
    "the stable model semantics for logic programming . in _ logic programming : proceedings of the fifth international conference and symposium , seattle , washington , august 1988 _ , r.  a. kowalski and k.  a. bowen , eds . mit press , 10701080 .",
    "logic programs with classical negation . in _ logic programming : proceedings of the 7th international conference , jerusalem , israel , june 1990 _ , d.  h.  d. warren and p.  szeredi , eds . mit press , 579597 .",
    "complexity results for checking distributed implementability . in _",
    "fifth international conference on application of concurrency to system design , acsd 2005 , st .",
    "malo , france , june 2005 , proceedings _ , j.  desel and y.  watanabe , eds .",
    "ieee computer society , 7887 .    ,",
    "ielpa , g. , pietramala , a. , santoro , m.  c. , and calimeri , f. 2004 .",
    "enhancing answer set programming with templates . in _",
    "10th international workshop on non - monotonic reasoning ( nmr 2004 ) , whistler , canada , june 2004 , proceedings _ , j.  p. delgrande and t.  schaub , eds .",
    "233239 .        \\2007 .",
    "intermediate languages of asp systems and tools . in _ proceedings of the 1st international workshop on software engineering for answer set programming _ , m.  de  vos and t.  schaub , eds .",
    "number csbu-2007 - 05 in deparment of computer science , university of bath , technical report series .",
    "tempe , arizona , usa , 1225 .",
    "\\2002 . testing the equivalence of logic programs under stable model semantics . in _ logics in artificial intelligence ,",
    "8th european conference , jelia 2002 , cosenza , italy ,",
    "september 2002 , proceedings _ , s.  flesca , s.  greco , n.  leone , and g.  ianni , eds .",
    "lecture notes in artificial intelligence , vol . 2424 .",
    "springer , 493504 .      ,",
    "oikarinen , e. , tompits , h. , and woltran , s. 2007 .",
    "modularity aspects of disjunctive stable models .",
    "in _ logic programming and nonmonotonic reasoning : 9th international conference , lpnmr 2007 , tempe , az , usa , may 2007 , proceedings _ , c.  baral , g.  brewka , and j.  schlipf , eds .",
    "lecture notes in artificial intelligence , vol . 4483 .",
    "springer , 175187 .",
    "extended asp tableaux and rule redundancy in normal logic programs . in _ logic programming : 23rd international conference , iclp 2007 , porto , portugal , september 2007 , proceedings _ , v.  dahl and i.  niemel , eds .",
    "lecture notes in computer science , vol .",
    "springer , 134148 .",
    " sat - based disjunctive answer set solver . in _ logic programming and nonmonotonic reasoning , 8th international conference , lpnmr 2005 , diamante ,",
    "italy , september 2005 , proceedings _ , c.  baral , g.  greco , n.  leone , and g.  terracina , eds .",
    "lecture notes in artificial intelligence , vol . 3662 .",
    "springer , 447451 .",
    "computing circumscription . in _ proceedings of the ninth international joint conference on artificial intelligence , 1823 august 1985 , los angeles ,",
    "california _ , a.  k. joshi , ed .",
    "morgan kaufmann , 121127 .",
    "splitting a logic program .",
    "in _ logic programming : proceedings of the eleventh international conference on logic programming , june 1994 , santa margherita ligure , italy _ , p.  v. hentenryck , ed . mit press , 2337 .",
    "an algebra of logic programs . in _ logic programming : proceedings of the fifth international conference and symposium , seattle , washington , august 1988 _ , r.  a. kowalski and k.  a. bowen , eds . mit press , 10061023 .",
    "stable models and an alternative logic programming paradigm . in _ the logic programming paradigm : a 25-year perspective _",
    ", k.  r. apt , v.  w. marek , m.  truszczyski , and d.  s. warren , eds .",
    "springer , 375398 .",
    "semantical paradigms : notes for an invited lecture , with two appendices by stavros s. cosmadakis . in _",
    "proceedings , 3rd annual symposium on logic in computer science , 5 - 8 july 1988 , edinburgh , scotland , uk _ , y.  gurevich , ed .",
    "ieee computer society , 236253 .          ,",
    "balduccini , m. , gelfond , m. , watson , r. , and barry , m. 2001 .",
    "an a - prolog decision support system for the space shuttle . in _ practical aspects of declarative languages ,",
    "third international symposium , padl 2001 , las vegas , nevada , march 2001 , proceedings _ , i.  v. ramakrishnan , ed .",
    "lecture notes in computer science , vol . 1990 .",
    "springer , 169183 .",
    "modularity in smodels programs . in _ logic programming and nonmonotonic reasoning : 9th international conference , lpnmr 2007 , tempe , az , usa , may 2007 , proceedings _ , c.  baral , g.  brewka , and j.  schlipf , eds .",
    "lecture notes in artificial intelligence , vol . 4483 .",
    "springer , 321326 .",
    "modular equivalence for normal logic programs . in _",
    "ecai 2006 , 17th european conference on artificial intelligence , august 29 ",
    "september 1 , 2006 , riva del garda , italy , proceedings _ , g.  brewka , s.  coradeschi , a.  perini , and p.  traverso , eds .",
    "ios press , 412416 .",
    "2008a . implementing prioritized circumscription by computing disjunctive stable models . in",
    "artificial intelligence : methodology , systems , and applications , 13th international conference , aimsa 2008 , varna , bulgaria , september 2008 proceedings _",
    ", d.  dochev , m.  pistore , and p.  traverso , eds .",
    "lecture notes in artificial intelligence , vol .",
    "springer , 167180 .        , tompits , h. , and woltran , s. 2001 .",
    "encodings for equilibrium logic and logic programs with nested expressions . in _",
    "progress in artificial intelligence , knowledge extraction , multi - agent systems , logic programming and constraint solving , 10th portuguese conference on artificial intelligence , epia 2001 , porto , portugal , december 2001 , proceedings _ ,",
    "p.  brazdil and a.  jorge , eds .",
    "lecture notes in artificial intelligence , vol .",
    "springer , 306320 .",
    "perfect model semantics . in _ logic programming : proceedings of the fifth international conference and symposium , seattle , washington , august 1988 _ , r.  a. kowalski and k.  a. bowen , eds .",
    "mit press , 10811096 .        ,",
    "niemel , i. , tiihonen , j. , and sulonen , r. 2001 .",
    "representing configuration knowledge with weight constraint rules . in _ proceedings of the 1st international workshop on answer set programming : towards efficient and scalable knowledge ( asp 2001 ) _ , a.  provetti and t.  c. son , eds .",
    "aaai press , stanford , usa .    ,",
    "baral , c. , and anwar , s. 2005 . a language for modular answer set programming : application to acc tournament scheduling . in _",
    "answer set programming , advances in theory and implementation , proceedings of the 3rd international asp05 workshop , bath , uk , september 2005 _ , m.  d. vos and a.  provetti , eds .",
    "ceur workshop proceedings , vol .",
    "ceur-ws.org .",
    "characterizations for relativized notions of equivalence in answer set programming . in",
    "_ logics in artificial intelligence : 9th european conference , jelia 2004 , lisbon , portugal ,",
    "september 2004 , proceedings _ , j.  j. alferes and j.  a. leite , eds .",
    "lecture notes in artificial intelligence , vol . 3229 .",
    "springer , 161173 .",
    "\\2007 . a common view on strong , uniform , and other notions of equivalence in answer - set programming . in _ proceedings of the lpnmr07 workshop on correspondence and equivalence for nonmonotonic theories ( cent2007 ) , tempe , az , usa , may 2007 _",
    ", d.  pearce , a.  polleres , a.  valverde , and s.  woltran , eds .",
    "ceur workshop proceedings , vol . 265 .",
    "ceur-ws.org , 1324 ."
  ],
  "abstract_text": [
    "<S> in this paper , a gaifman - shapiro - style module architecture is tailored to the case of smodels programs under the stable model semantics . </S>",
    "<S> the composition of smodels program modules is suitably limited by module conditions which ensure the compatibility of the module system with stable models . </S>",
    "<S> hence the semantics of an entire smodels program depends directly on stable models assigned to its modules . </S>",
    "<S> this result is formalized as a _ module theorem _ which truly strengthens lifschitz and turner s splitting - set theorem @xcite for the class of smodels programs . to streamline generalizations in the future , </S>",
    "<S> the module theorem is first proved for normal programs and then extended to cover smodels programs using a translation from the latter class of programs to the former class . moreover , the respective notion of module - level equivalence , namely _ modular equivalence _ , </S>",
    "<S> is shown to be a proper congruence relation : it is preserved under substitutions of modules that are modularly equivalent . </S>",
    "<S> principles for program decomposition are also addressed . </S>",
    "<S> the strongly connected components of the respective dependency graph can be exploited in order to extract a module structure when there is no explicit a priori knowledge about the modules of a program . </S>",
    "<S> the paper includes a practical demonstration of tools that have been developed for automated ( de)composition of smodels programs .    </S>",
    "<S> answer set programming , module system , compositional semantics , stable model semantics , modular equivalence </S>"
  ]
}