{
  "article_text": [
    "there are situations where the users of a database system can not trust the database .",
    "for example , the database might be outside the users security perimeter , or might not follow the same security policies as the users .",
    "the users must therefore assume that the database could be taken over by an attacker .",
    "the entities writing the database entries want to be sure that the database delivers their entries on requests unchanged .",
    "the database maintainer wants to be able to defend itself against accusations of misbehavior .",
    "how can an attacker or malicious database maintainer deceptively influence the database s replies ? the following list explains the attacks :    1 .   *",
    "changing existing entries : * the attacker can change the value of an existing entry.[cha1 ] 2 .   * creating false entries : * the attacker can create @xmath0 pairs himself .",
    "* re  labeling existing entries : * the attacker can insert existing values under different keys .",
    "[ cha3 ] 4 .   * returning old entries : * [ cha4 ] if the value of a @xmath1 pair is overwritten by a new @xmath2 , the attacker can return the old @xmath3 on request for @xmath4 .",
    "* denying existing entries : * on a @xmath5 request , the attacker can make the database deny that a @xmath6 exists for the given @xmath4 in the table .",
    "[ cha5 ]    this is not only of theoretical interest .",
    "life examples are web  hosting solutions , where the changing parts of all web pages are kept in a central relational database and the pages are constructed from templates .",
    "another example is the internet s domain name system ( dns ) , which is basically a partially distributed lookup  table .",
    "attacks on dns as listed above are described in @xcite , remedies are suggested in the dns security extensions@xcite and a draft by bellovin @xcite .",
    "the readers should be able to detect if the database is lying about entries .",
    "the database should be able to prove the correctness of its answers as long as the writers are honest . for most of the listed attacks ,",
    "this can easily be achieved if public key cryptography is employed .",
    "it is not necessary to assume the existence of a global public key infrastructure for this purpose .",
    "it is sufficient if the readers of the database have access to all the public keys of the writers ( presumably a smaller set than the readers ) .",
    "the keys must be stored outside the database . with this information at hand , and routines for signature creation ( @xmath7 ) and verification ( @xmath8 )",
    ", readers and writers can make attacks detectable under standard cryptographic assumptions . here",
    "is how :    1 .   *",
    "changing existing entries : * writers sign the values of their entries and include the signature in the @xmath6 of the table .",
    "readers check the signatures and detect changes by the database .",
    "@xmath9 2 .",
    "* creating false entries : * the same applies here .",
    "since the database has no access to the writer s secret keys , it can not produce deceptive entries .",
    "3 .   * re ",
    "labeling existing entries : * this calls for an extension : the writers now include the @xmath4 in the data they sign : @xmath10 the readers can now check if the entry belonged to the @xmath4 they gave in their _ search _ request .",
    "points [ cha4 ] and [ cha5 ] , however , pose a harder problem .",
    "if there is no information about existing entries anywhere outside the database , then these attacks can not be detected .",
    "as for point [ cha4 ] , from the algebraic properties of standard digital signatures it follows that a signature on an old entry will still be valid after the entry has been replaced .",
    "there are signature schemes where the signer s cooperation is necessary for verification , called",
    "_ undeniable signatures_. the concept was presented first by chaum @xcite in 1989 .",
    "such a scheme in our scenario would introduce much more communication than in the standard writer  database  reader setup .",
    "a writer who substitutes an existing entry would have to reliably notify the writer of the previous version , so that the previous author retracts the signature ( e.g. by sending a new `` signature outdated '' message in the verification protocol ) .",
    "readers would need to communicate with writers who might not be available every time someone wants to validate a reply .",
    "we would like to avoid such a complicated and error ",
    "prone setup .",
    "the problem with point [ cha5 ] is that from the perspective of the database , it would mean proving that it does _ not know _ the table entry , an impossible feat in this scenario .",
    "since there is no @xmath6 returned , there can be no signature , unless the writers supply a special `` no entry '' value tied to _ every possible and unused _ key .",
    "there are ways around this , however , if we allow the writers and readers access to another service besides the database .",
    "the service is required to supply a single value on request ; authenticated writers must be able to overwrite that value .",
    "we will call this service the _ announcement service _ ;    the writers store a signed , condensed description of the database s state .",
    "this value must be updated after every write to the database .",
    "the readers can use this description to validate the database s replies . we will call this summary of database state a _",
    "state credential_. the validation protocol consists of two parts :    * a writer builds and publishes a new state credential from the previous one .",
    "* readers check the validity of a database reply .",
    "this requires interaction with the announcement service and the database .",
    "our requirements for the state credential ( to be short and uniquely bound to the database state ) suggest the application of a cryptographic hash function .",
    "we will now describe several possibilities to build state credentials with hash functions .",
    "this is the simplest form of a state credential .",
    "the writer queries the database for all entries and inserts the _",
    "key _ of his / her new entry .",
    "the writer then sorts all keys in a pre  defined order and computes the hash value over all of them .",
    "this value is signed and supplied through the announcement service .",
    "formally : @xmath11 where @xmath12 is the number of entries in the database , @xmath13 is the @xmath14th _ key _ in the particular order and addition denotes string concatenation after adding a special `` end of key '' marker to the parameters .",
    "the simple hash is not a solution , because to check a database reply against this , a reader would have to download the whole database as well .",
    "application of hash chains make the computation of the credential cheaper .",
    "the writer pulls the latest credential from the announcement service and `` adds '' the new entry s _ key_. formally : @xmath15 @xmath16 where @xmath17 is the credential after adding the @xmath14th entry to the database and @xmath18 is the hash of the empty string .",
    "addition is defined as above .    to validate a database reply",
    ", a reader would have to pull all keys up to the requested key in their order of addition . in the interesting case of a non  existing key",
    ", the reader has to pull the whole database .",
    "so this is still not satisfactory .",
    "merkle s @xcite hash trees allow fast ( log - time ) verification of digests over many entries .",
    "hashes over pairs of entries ( the keys in our scenario ) are computed and the resulting hashes are again paired and new hashes computed and so on .",
    "the number of entries has to be a power of @xmath19 .",
    "formally : @xmath20 @xmath21 where @xmath22 , by `` @xmath23 '' we denote the concatenation of strings and @xmath24 is the @xmath25th key in an arbitrary order ( @xmath26 is the root of the tree ) .    the state credential at the announcement service must be updated for each new entry and a hash tree root can only be computed if the number of entries is a power of two .",
    "so we must find a form of state credential that allows instant updating but still can use hash trees .",
    "the solution is to split the number of entries into powers of @xmath19 and to generate hash trees of appropriate height for all of those powers .",
    "for this reason , the state credential will consist of a number of hash tree roots , at most @xmath27 where @xmath12 is the number of entries , together with the height of the trees .",
    "when an entry is added to the non  empty database , and if the number of entries is odd after the addition , then a new hash tree of height zero ( simply the hash of the key ) is appended to the state credential .",
    "if the number is even , then the two most recent tree roots are combined ( hashed together ) to form the root of a higher tree .",
    "this is done recursively from the end .",
    "note that we must start at the zeroth entry , since even an empty database needs a state credential .",
    "so if the bit representation is @xmath28 and @xmath29 ( the hamming  weight of @xmath30 ) , then the credential consists of the roots of @xmath31 hash trees of height @xmath14 for every @xmath32 .",
    "the database in turn keeps a counter of entries .",
    "it can thus deduce in which of the trees in the current state credential an entry resides .",
    "this is achieved by comparing the entry s number against the current set of trees and their heights .",
    "if a reader wishes to validate the databases reply for a certain key @xmath33 , the database has to supply a path in the tree leading to the leaf with @xmath33 , as well as all pairs of hashes along that path .",
    "the reader can now verify that each pair s concatenation hashes to the corresponding hash in the next pair , up to the root of the tree in the state credential .",
    "communication with the database for validation is bounded at worst by @xmath34  bytes , where @xmath35 is the byte  length of the hash s output .",
    "the drawback of this scheme is that validation of a negative reply ( `` no such entry '' ) still requires downloading the whole database .",
    "our contribution is the introduction of _ keyed hash trees_. in these , the position of a leaf in the tree is dependent on the key corresponding to the leaf .",
    "our construction uses a tree of height @xmath35 , where @xmath36 is a cryptographic hash function . for every @xmath0 in the database ,",
    "a leaf is inserted in the tree , where the path to the leaf from the root is defined by @xmath37 and the data in the leaf is @xmath38 .",
    "leaves without a corresponding entry are implicitly set to the hash of the empty string @xmath18 .",
    "we call a sub  tree _ empty _ if there is no path leading through the sub  tree s root that leads to a leaf with a non  empty value .",
    "all leaves of an empty sub  tree have the value @xmath18 .",
    "the nodes in the layer above the leaves all have value @xmath39 , and so on .",
    "note that all nodes in a layer have the same value , which in turn is derived from the hash of the empty word .",
    "it is easy to pre  compute these values .",
    "it allows identification of a sub  tree as being empty by a single table lookup , since all empty sub  trees of equal height have the same pre  computed root hash .    from the collision resistance for cryptographic hash functions",
    ", it follows that @xmath40 the value of the tree s root thus depends on all the leaves values and all the paths .",
    "in contrast to the schemes above , non  existing entries _ do _ have leaves and paths and can thus be validated .",
    "storing and working on a binary tree of height  @xmath41 ( for @xmath42 for example ) seems daunting at first , since there would be @xmath43 entries , only a few orders of magnitude less then the number of hydrogen atoms in the whole universe . but",
    "all except @xmath12 of the leaves are empty , where @xmath12 is the number of entries in the database .",
    "we will show in section [ sparse ] that it is sufficient to store only the non  empty leaves and the branches leading to them from the root .    before inserting a new entry @xmath0 in the database , a writer requests all pairs of hashes on the path to the new entry .",
    "the writer then validates the hashes against the current state credential , which is the root of the keyed hash tree .",
    "the writer substitutes the hash in the respective leaf by the hash of the _ value _ , and computes a new root hash .",
    "he then signs this root hash and puts it on the announcement service after inserting the new entry in the database .    to validate a database reply , the reader requests all pairs of hashes on the path derived from the key .",
    "for positive replies , the reader hashes over the returned value , compares that with the hash in the corresponding leaf and proceeds as with a standard hash tree .",
    "if the reply was negative ( `` no such entry '' ) , then the path must lead to an empty leaf and  as in the hash tree scheme above  the hash values can be checked recursively up to the root .",
    "the root must be the same as the signed value received from the announcement service .",
    "our database should be able to respond quickly to requests for pairs of hashes along a given path . to do this , we need an internal representation of the keyed hash tree corresponding to the current database table .",
    "we are helped by the keyed hash tree s property that all empty sub  trees of equal height are identical ( an algorithm for creating a list of all empty sub  trees roots is given in figure [ emptys ] ) .",
    "instead of storing @xmath44 nodes , we need to store only those nodes that are part of a path to an existing entry in the database , i.e. the hash of at least one key in the database describes a path leading through the node . to reduce the space further , we store only one node for every sub  tree that contains exactly one entry , i.e. the first node from the root down which lies on one single path is used to describe the whole sub ",
    "tree containing the corresponding leaf .",
    "we call the resulting data structure a _ sparse hash tree_.    the main problem is that searching in the tree is done from the root down to the leaf , while the hash values in the nodes are computed from the leaves up .    .... list empty_init(void ) {      i = 0 ;      empty[i ] = h ( ) ;      for ( ; i<159;i++ ) {          empty[i ] = h(empty[i-1 ] . empty[i-1 ] ) ;      }      return empty ; } ....    each stored node in our hash tree representation is a struct defined in listing [ structs ]    .... struct node {      struct node * b[2 ] ; # define leaf    1 # define branch 2      int flag ;      struct entry * e ;      unsigned char * hash ; } ;    struct entry {      unsigned char * path ;      unsigned char * value ; } ; ....    the b[2 ] array contains pointers to the left and right children , or null if there is no respective child .",
    "flag indicates whether this node represents a branch or a leaf .",
    "hash is the hash of the tree rooted in this node . only in leaf nodes",
    "is e not null and contains a pointer to a struct entry defined in listing [ structs ] .",
    "note that leaf nodes do represent the leaves of the tree , but only non  empty leaves have leaf nodes .",
    "the nodes contain data structures that allow dynamic computation of all node  values of the hash tree below their path .",
    "entry holds the information necessary to compute all nodes below the node pointing to it ( see algorithm leafnode for details ) .",
    "path is a bit  string of 0s and 1s and describes the path to the actual leaf from the leaf node , i.e. the part of the path for which we do nt store nodes , but generate them as needed .",
    "value contains the hash of the entry at the actual leaf .",
    "the function rootpath defined in listing  [ rootpath ] on page returns a list of pairs of hashes along a given path .",
    "the first two if statements handle the special cases that there is at most one entry in the sparse tree .",
    ".... list rootpath(node root , bitstring path ) {      if(root = = null ) {           / * empty sub - tree * /          return nullnode(path ) ;       }      if(root->flag = = leaf ) {          / * exactly one leaf in subtree * /          return leafnode(root , path ) ;      }      if(root->flag = = branch ) {          / * non - unique path * /          init ( list ) ;          return branchnode(path , root , list ) ;      } } ....    rootpath calls the auxiliary functions nullnode , leafnode and branchnode .",
    "nullnode simply builds pairs of empty sub  tree roots in ascending order .",
    "leafnode calls singlepath to generate a temporary list of all non  empty sub  trees below the leaf node .",
    "it then compares the supplied path against the path to the leaf and selects the pairs from the temporary list for the maximum left ",
    "match of the paths . for the rest of the path , empty sub  tree roots",
    "are appended to the selected pairs .",
    "this list is returned .",
    "branchnode walks recursively down the tree as long as the path runs through branch nodes . at each step",
    "it appends the hashes in the children of the current node to the list .",
    "at the point where the path changes to an undefined or leaf node , branchnode calls nullnode or leafnode respectively , to complete the list .    ....",
    "list nullnode(bitstring path ) {      init ( list ) ;      for(i=0 ; i <",
    "length(path ) ; i++ ) {          push list , ( empty[i ] , empty[i ] ) ;      }      return(list ) ; } ....    .... list singlepath(bitstring path , char value[160 ] ) {      revpath = reverse ( path ) ;      init ( list ) ;      init ( pair ) ;      i=1 ;      bit = shift revpath ;      pair[bit ] = value ;      pair[not bit ] = empty[0 ] ;      push ( list , pair ) ;      while(bit = shift revpath ) {          pair[bit ] = h(list[0][0 ] .",
    "list[0][1 ] ) ;          pair[not bit ] = empty[i++ ] ;          push ( list , pair ) ;      }      return list ; } ....    .... list leafnode ( struct node * node , bitstring path ) {      init ( tmplist ) ;      init ( list ) ;      init ( pair ) ;      i=0 ;      / * create list of non - empty nodes ' hashes * /      tmplist = singlepath(node->e->path , node->e->value ) ;        / * compare given path against path of leaf * /      while(path[i ] = = node->e->path[i ] ) {          append ( list , templist[i ] ) ;          i++ ;      }      height = length(path ) - i ;        / * if the two diverge , return empty nodes ' hashes * /      while(height > 0 ) {              pair = ( empty[height ] , empty[height ] ) ;              append ( list , pair ) ;              height-- ;      }      return list ; ....    .... list branchnode ( struct node * n , bitstring path ) {      init ( pair ) ;      / * get hashes of children * /      for(b = 0 , 1 ) {          if ( n->b[b ] ! = null ) {              pair[b ] = n->b[b]->hash ;          } else {              pair[b ] = empty[length(path ) ] ;          }      }      append ( list , pair ) ;      bit = shift path ;           if ( n->b[bit ] !",
    "= null & & n->b[bit]->flag = = branch ) {          / * walk down * /          append ( list , branchnode(path , n->b[bit ] , list ) ) ;      } else {          if(n->n[bit ] !",
    "= null & & n->b[bit]->flag = = leaf ) {              / * we hit a leaf * /              append ( list , leafnode(path , n->b[bit ] ) ) ;          } else {              / * walked into an empty sub - tree * /              append ( list , nullnode(path ) ) ;          }      }      return list ; }     ....      insert ( algorithm [ insert ] on page ) recursively walks down the tree along the given path , putting the traversed nodes on the stack .",
    "if the path runs into an empty subtree , a leaf node with the given ( path , value ) is created .",
    "if the path runs through a leaf node , the entry in the node is moved one step along its path down the tree , the node is converted to a branch , and insert is called again on it . on the way up to the root , all the hashes on the path are adjusted .    .... struct node * insert(bitstring path , char value[160 ] , struct node * node ) {",
    "if ( node = = null ) {          / * virgin sub - tree : create new leaf * /          init ( list ) ;          init ( newnode ) ;          init ( entry ) ;          newnode->flag = leaf ;          list = leafnode(path , value ) ;          entry->path = path ;          entry->value = value ;          newnode->e = entry ;          newnode->hash = h(list[0][0 ] .",
    "list[0][1 ] ) ;          free(list ) ;          return(newnode ) ;      }      if(node->flag = = branch ) {          init ( newnode ) ;          bit = shift path ;          / * walk down * /          newnode = insert(path , value , node->b[bit ] ) ;          / * update the hash value on the way back * /          init ( pair ) ;          pair[bit ] = newnode->hash ;          if ( node->b[not bit ] = = null ) {                  pair[not bit ] = empty[length(path ) ] ;          } else {              pair[not bit ] = node->b[not bit]->hash ;          }          node->hash = h(pair[0 ] .",
    "pair[1 ] ) ;          return(node ) ;      }      if(node->flag = = leaf ) {          / * change leaf to branch * /          init ( tmppath ) ;          init ( tmpval ) ;          tmppath = node->e->path ;          tmpval = node->e->value ;          node->flag = branch ;          / * move leaf 's content down along its own path * /          free node->entry ;          node->entry = null ;          node = insert(tmppath , tmpval , node ) ;          / * insert new ( path , value ) in the now branch * /          bit = shift path ;          init ( newnode ) ;          newnode = insert(path , value , node->b[bit ] ) ;          / * update hash on the way back * /          node->b[bit ] = newnode ;          init ( pair ) ;          pair[bit ] = newnode->hash ;          if ( node->b[not bit ] = = null ) {              pair[not bit ] = empty[length(path ) ] ;          } else {              pair[not bit ] = node->b[not bit]->hash ;          }          node->hash = h(pair[0 ] . pair[1 ] ) ;          return(node ) ;      } }     ....      delete ( algorithm [ delete ] on page ) recursively walks down the tree until it reaches the leaf node with the entry to delete . on the way up , it checks if the current node has only one child , which is a leaf .",
    "if so , the entry in the leaf is attached to the parent , and the child deleted .",
    "this is to handle situations where two leaves hang at the end of a stalk .",
    "if one of the leaves is removed , the stalk would be a series of roots of subtrees with exactly one entry . to keep storage minimal",
    ", this should be avoided .",
    "delete attaches the lonely leaf at the uppermost branch of the stalk .",
    ".... struct node * delete(bitstring path , struct node * node ) {      if(node->flag = = leaf ) {          / * remove leaf , stop recursion * /          free ( node->entry ) ;          free ( node ) ;          return null ;      }      / * we 're on the way to the leaf still * /      init ( pair ) ;      / * remember the bit * /      bit = shift path ;        / * walk down * /      node->b[bit ] = delete(path , node->b[bit ] ) ;        / * reconstruct the path * /      path = prepend bit , path ;        / * how many non - children ? *",
    "/      for ( i = 0 , 1 ) {          if(node->b[i ] = = null ) {              emp = i ;              numemp++ ;          }      }      if(numemp = = 2 ) {          / * node was a stalk with a single leaf , delete * /          free ( node ) ;          return null ;      }      if(numemp = = 1 ) {          if(node->b[not emp]->flag = = leaf ) {              / * one child , a leaf , move it up * /              node->e = node->b[not emp]->e ;              node->e->path = node->e->path ;              / * correct the path * /              pop node->e->path ;               node->flag = leaf ;              pair[emp ] = empty[length(path ) ] ;              pair[not emp ] = node->b[not emp]->hash ;              node->hash = h(pair[0 ] .",
    "pair[1 ] ) ;              free ( node->b[not emp]->e ) ;              free ( node->b[not emp ] ) ;              return node ;          } else {              / * branch node leading to at least two leafs * /              / * update the hash * /              pair[emp ] = empty[length(path ) ] ;              pair[not emp ] = node->b[not emp]->hash ;              node->hash = h(pair[0 ] .",
    "pair[1 ] ) ;              return node ;          }      }      if(numemp = = 0 ) {          / * branch node with at least two leafs below * /          / * update the hash * /          pair[0 ] = node->b[0]->hash ;          pair[1 ] = node->b[1]->hash ;          node->hash = h(pair[0 ] . pair[1 ] ) ;          return node ;      } } ....      we assume that the hash function @xmath36 behaves as an ideal hash function would , an assumption often used in cryptography called the random oracle model .",
    "it implies that the output of @xmath36 is indistinguishable from the output of a random function . under this assumption ,",
    "our algorithms have the following properties :    the sparse tree in memory is nearly balanced .",
    "if @xmath36 s output behaves as randomness , the paths in the tree will be random walks starting at the root . for a large number @xmath12 of entries , @xmath45 paths will lead through each node at the @xmath14th layer in the tree , and the average path length is @xmath46 .",
    "space for the sparse tree is bounded by twice the number of entries in the database .",
    "we store @xmath12 entries at @xmath12 leaves , and each pair of nodes has one parent  node .",
    "this means that @xmath47    pairs along paths to a non  existing key can be computed quickly .",
    "if the key is not in the table , then the path will enter an empty subtree after @xmath46 steps , in the mean .",
    "for one million entries , for example , this means that after traversal of 20 nodes on average , nullnode will be called , and all that remains to be done is table lookups .",
    "readers recognize non  existing keys after @xmath46 steps from the root , in the mean .",
    "the pre  computation shown in [ emptys ] consists of 160 calls to the hash function .",
    "after this , a reader simply checks the returned pairs from the database against the pre ",
    "computed table empty .",
    "maximum message size per validation is @xmath48  bits .",
    "two pairs of @xmath35 bit hashes per step lie on a path with @xmath35 steps .",
    "for sha-1 as @xmath36 , this would mean @xmath49  bytes per validation . if stronger collision resistance is required , a cryptographic hash function with longer output may be chosen .",
    "while the resistance grows exponentially with the hash size , the messages grow only linearly .",
    "the database can be distributed over several machines .",
    "the insert , delete and rootpath functions are independent of the actual height of the stored tree . as long as writers and readers know how to compute the @xmath50 hashes at the root of the tree , they can use @xmath51 independent databases .",
    "this would also allow @xmath51 concurrent writes , by locking at the branches .",
    "there are other schemes with different objectives related to the one just presented .",
    "we will discuss the differences to our proposal .",
    "ahto buldas et al . presented schemes for accountable certificate management in 2000 ( @xcite and @xcite ) . in their scenario ,",
    "the database is a part of a certificate authority ( ca ) , i.e.  the list of valid certificates .",
    "their goal is to make sure that there is never an ambiguity about the state of a certificate . on request for a key @xmath33",
    ", the database sends an _ attester _",
    "@xmath52 , which is a cryptographic statement about the presence or absence of the key @xmath33 in the table @xmath53 .",
    "the database also returns a _ digest _",
    "@xmath54 which is a summary of the database s table @xmath53 .",
    "any party can then call a verification algorithm @xmath55 which returns `` accept '' if the statement @xmath56 about @xmath33 was correct for table summary @xmath51 or else `` reject '' .",
    "buldas et al .",
    "call an attester _ undeniable _ if a ca can produce two contradicting attesters for the same key with only negligible probability .",
    "formally , this is defined as follows :    let @xmath57 be the class of probabilistic algorithms of polynomial runtime .",
    "let @xmath33 be the security parameter ( in our context the bitlength of the hash function s output ) .",
    "the attester @xmath58 is given by the tuple of algorithms @xmath59 serves only to select a hash function for a given security parameter @xmath33 . ] .",
    "its resilience against an attacker @xmath60 of class @xmath57 is defined as @xmath61\\,.\\ ] ] if @xmath33 can be chosen as to minimize @xmath62 below any given @xmath63 , then @xmath58 is called undeniable .",
    "the paper examines different schemes for attesters and concludes with an efficient , undeniable attester based on search trees .",
    "a search tree ( see for example knuth @xcite ) is a binary tree with the additional property that there is a comparison relation @xmath64 and each node contains a value @xmath65 for which the following holds : @xmath66 where @xmath67 and @xmath68 are the values in the left and right child of the node , respectively . if one or both children do not exist , the empty string is used instead .",
    "buldas et al .",
    "add another field to each node , which holds the hash @xmath69 .",
    "the digest @xmath51  the root of the search tree  is signed by the ca and published through an untrusted publication authority ( pa ) .",
    "the digest corresponds to our state credential and the pa to our announcement service .",
    "a proof @xmath56 output by @xmath70 for a key @xmath33 is a list @xmath71 of values @xmath72 , where @xmath13 is the value of a node and @xmath73 are the hashes stored in the left andx .",
    "right child of the node , repectively , or the empty string if there is no such node .",
    "the values are selected such that @xmath74 if @xmath33 is in the database .",
    "if @xmath33 is not in the database , then the tree contains two keys @xmath25 and @xmath75 such that @xmath75 is the smallest value larger than @xmath33 and @xmath25 the largest value smaller than @xmath33 . by construction of the tree",
    ", there is a path from the node of @xmath25 to the root leading through @xmath75 or vice versa .",
    "the key of @xmath25 and @xmath75 which is lower in the tree is used as @xmath76 in that case .",
    "if @xmath33 is larger or smaller than all keys in the search tree , then @xmath75 or @xmath25 is set to the largest or smallest key in the tree , respectively .",
    "together with the published digest @xmath51 allows to prove the absence of a key .",
    "the verifier can check the hashes from @xmath76 to the root and verify the strict order of child nodes .",
    "if a key @xmath33 is not in the tree , then @xmath56 will contain @xmath77 such that @xmath78 . by the strict order and lack of right children of @xmath25 and left children of @xmath75",
    ", @xmath33 can not be a node s value in the tree .",
    "the verifier @xmath79 returns `` error '' if any of the following fails :    * checking the order of keys in @xmath56 . *",
    "computing and comparing the hashes along the path given in @xmath56 up to the root . * comparing @xmath51 against the root hash in @xmath56 .",
    "if @xmath80 is the first key in @xmath56 , @xmath81 returns `` accept '' , else `` reject '' .",
    "the attester states absence or presence in a list , exclusively .",
    "a state credential includes the _ value _ of the entry under the _ key _ , so that changes of an entry can be expressed .",
    "buldas et al .",
    "assume that the database is reigned by a single entity which is trustworthy at the moment when an attester is issued , but may turn untrusted or unavailable later . that the database signs the digest itself establishes a different scenario than in our setting .    to show that the database cheated , a user has to find another attester contradicting the attester he / she received . in our setting",
    ", a reader can prove that the database cheated immediately and without contacting other readers .",
    "we can build undeniable attesters for keys from signed state credentials .",
    "since values of entries are irrelevant for attesters , we will substitute the @xmath0 pairs in our algorithms by @xmath82 pairs .",
    "since the empty word might be an entry s key in the generality of the proof , we will use the reserved key @xmath83 instead in that case . the digest @xmath51 is the state credential , but is supplied by the database instead of the announcement service .",
    "our @xmath84 are defined as follows :    @xmath85 is the list of pairs of hashes along the path given by @xmath86 in the keyed hash tree generated from all entries in @xmath53 .",
    "@xmath87 is the root of said keyed hash tree .",
    "@xmath88 outputs `` error '' if any of the following fails :    * comparing the hash at the leaf corresponding to @xmath80 against @xmath86 or @xmath18 .",
    "* hashing the pairs of hashes up along the path @xmath86 . * comparing the resulting root hash against @xmath51",
    ".    if the leaf value at the end of path @xmath86 is the empty hash , then @xmath81 returns `` reject '' .",
    "if the leaf value is @xmath86 , then `` accept '' .",
    "assume that some @xmath89 outputs @xmath90 with probability @xmath63 , such that @xmath91 and @xmath92 .",
    "since @xmath81 did not return `` error '' , all the pairs of hashes in @xmath56 _ and _ in @xmath93 resolved up to @xmath51 .",
    "this means that @xmath60 produced a collision in the hash @xmath36 with probability @xmath63 , and the values @xmath94 are members of @xmath56 and @xmath93 .",
    "thus we have reduced the security of our attester to the collision resistance of the hash @xmath36 .",
    "bulda s et al .",
    "use the search keys as they are , because the proofs of non  membership in the table rely on the greater  than relation between the keys .",
    "this has the disadvantage that the tree becomes unbalanced if the inserted entries are not uniformly distributed or if the first entry ( the subsequent root ) is not near the median of the set of entries .",
    "unbalanced search trees cause longer searches , as more than @xmath46 nodes need to be traversed for some keys .",
    "the paper does not explain whether there is any re  balancing ( see for example @xcite ) done on the search tree .",
    "re  balancing this particular tree type would change all the hash  entries on the path from the previous root to the new one .",
    "our sparse hash tree in memory is always balanced for large @xmath12 .",
    "using the keys as they are makes the attester s size unpredictable . with state credentials ,",
    "the size is fixed ( and quite small ) .",
    "unknown to this author , s. micali , m. rabin and j. kilian presented a more general scheme , called zero  knowledge sets @xcite in 2003 .",
    "their goal was to prove set ",
    "membership non  interactively and that without leaking any other information about the set .",
    "the data structure underlying their scheme is almost identical to the keyed hash trees defined above .",
    "micali et al .",
    "use a commitment scheme to bind the database to its previous statements about its contents .      in commitment schemes ,",
    "a prover @xmath70 _ commits _ to a message @xmath95 by making public a commitment string @xmath96 and computing a proof @xmath97 .",
    "before @xmath70 publishes @xmath95 or @xmath97 , nothing should be inducable about the message @xmath95 from @xmath96 .",
    "after @xmath70 sends message @xmath95 , a verifier @xmath81 can check whether this was the message committed to by @xmath96 . for this , @xmath70 supplies @xmath81 with @xmath97 .",
    "a commitment scheme is secure if @xmath70 can produce contradicting proofs @xmath98 only with neglegible probability .",
    "pedersen s scheme requires four public parameters , i.e. , two primes @xmath99 such that @xmath100 , and two generators @xmath101 , where @xmath102 and @xmath36 generate @xmath103 , the subgroup of order @xmath104 in @xmath105 .",
    "@xmath70 commits to @xmath95 by publishing @xmath106 .",
    "@xmath97 is the corresponding proof , a randomly chosen value @xmath107 . to verify the commitment",
    ", @xmath81 re  computes @xmath96 for herself and compares .",
    "to produce two proofs @xmath98 for differing messages @xmath108 , @xmath70 would have to find @xmath98 such that @xmath109 .",
    "assume she succeeded .",
    "she then could compute @xmath110 and from this @xmath111 and thus get @xmath112 , breaking the discrete logarithm mod  @xmath56 .",
    "it follows that the security of the pedersen commitment is reducible to the discrete log problem .",
    "it also follows that if @xmath113 is known to the prover , she can fake arbitary commitments .",
    "micali et al .",
    "use this scheme to construct a hash function @xmath114 where @xmath33 is the bitlength of prime @xmath56 .",
    "they use this hash function to process a data  structure very much like our keyed hash tree from section [ keyedhash ] .",
    "their prover builds the tree by first inserting all leaves derived from the database s entries , such that the value in the leaf is @xmath115 , where @xmath116 is the value stored in the database under key @xmath80 , and the leaf s position in the tree is determined by the path described by @xmath117 .",
    "the prover adds all nodes on those paths to the root , their values remain undefined until later .",
    "she adds those nodes whose parents are now in the tree , but does not repeat this recursively .",
    "these nodes correspond to the empty subtree s roots in our construction .    in the next step , the prover generates a random exponent @xmath118 for every node @xmath65 in the structure , and stores @xmath119 in it if @xmath65 is a non  empty leaf or the ancestor of one , and @xmath120 for the empty leaves .",
    "thus the prover knows @xmath121 for these nodes , a property exploited later .",
    "the prover now computes commitments for the leaves by computing @xmath122 , where @xmath123 or @xmath124 , @xmath125 the value stored in the last step , and @xmath126 a random value chosen per leaf .    in the last step ,",
    "the internal nodes of the tree get their commitment values generated .",
    "the process runs from the leaves upwards as in merkle s scheme .",
    "each internal node @xmath127 is associated a value @xmath128 , where @xmath129 are the left and right children of node @xmath127 . from this and",
    "the value @xmath130 stored alread in @xmath127 , @xmath131 is computed as @xmath132 for a randomly chosen @xmath133 .",
    "the commitment value for the whole database is the commitment of the tree s",
    "root @xmath134 .",
    "this value is published before any queries are answered .    to prove that the value stored under key  @xmath80 is @xmath135 in the database , the prover provides the tuples @xmath136 for every node on the path through the tree given by @xmath117 , together with the values @xmath137 for @xmath65 s siblings .    to check this proof , verifier @xmath81    1 .",
    "compares the leaf s @xmath138 against @xmath139 .",
    "checks recursively that @xmath140 3 .",
    "checks for every @xmath65 on the path that @xmath119 and @xmath122 .    for a proof of the non  existance of key @xmath80 in the database",
    ", the prover provides all the nodes values along the path given by @xmath117 as long as these nodes are in the generated tree .",
    "the last of these nodes , @xmath127 , will have @xmath141 .",
    "if @xmath70 would supply this to @xmath81 , then the verifier would learn that there are no non  empty nodes in this sub  tree .",
    "to disguise this fact , @xmath70 generates a branch of non  empty nodes down to a virtual , empty leaf ( the computation goes bottom  up however ) .",
    "node @xmath127 becomes the branch s root for this proof , the value @xmath141 is substituted by the value in the uppermost node of the freshly generated branch .",
    "the prover can do this convincingly because she can re  commit to any @xmath142 in node @xmath127 .",
    "this is caused by the special construction of @xmath130 for empty leaves , where @xmath70 knows the value of @xmath143 by design .",
    "this allows to `` glue '' the generated branch of nodes , complete with their commitments , to node @xmath127 .",
    "the verification runs as above , except that @xmath81 checks for @xmath144 .      in our proposal ,",
    "the writers are different entities from the database , but they compute the committment string .",
    "they are continuously updating and changing entries . in micali",
    "et al.s terminology , our writers _",
    "commit _ to the history of their changes to the database , while the database later _",
    "proves _ that it did reply in accordance to it state after the latest update .",
    "knowledge was no requirement in our design .",
    "since the motivations and requirements are different , the mechanisms behind micali et al.s scheme and ours differ in several points :    * multiple , mutually trusting authors * in our design , multiple database authors ( writers ) were a prerequisit .",
    "it is not obvious , how zero knowledge sets could be adapted for multiple writers .",
    "two writers would have to communicate at least the secret @xmath145 for each node to be able to insert entries .",
    "this would require a secure authenticated channel between all writers .",
    "* zero knowledge * the zero  knowledge requirement is violated in our scheme , because a proof about any key will leak information about the existence or non  existence of other keys .",
    "* database modification * one of our requirements was that the database can be modified by the writers who can re  compute the credential / attester / commitment for the database .",
    "the zero - knowledge property of micali et al.s scheme is lost if the database is allowed to change / add / remove entries .",
    "this is because the commitment values change along the path to a modified node and thus give away information about the minimum number of modified entries .",
    "this makes their construction extremely static and not suitable for our application .",
    "micali et al .",
    "mention this in their open problems section .",
    "* speed * because micali et al.s scheme must satisfy additional constraints , it is much slower ( five modular exponentations per node versus one application of an optimized hash function ) .",
    "we have presented an efficient mechanism that allows readers to verify the replies of a database with the help of the writers . to achieve this",
    ", we introduced a new cryptographic primitive , an extension of merkle s hash trees . a verification protocol between reader and database",
    "validates a reply with a low amount of data traffic .",
    "this extends even to those replies where the database denies the existence of the requested entry .",
    "the mechanism thus allows a database to prove that it does not know about such an entry .",
    "we examined the relationship to work in the area of certificate management , and showed how our proposal can be applied there as well . in comparison to the more general zero  knowledge sets by micali et al .",
    ", our scheme has the advantage that it is faster and allows subsequent modifications by multiple writers .",
    "steven  m. bellovin . using bloom filters for authenticated yes / no answers in the dns .",
    "http://www.research.att.com/~smb / papers / draft - bellovin - dnsext - bloomfilt% -00.txt[http://www.research.att.com/~smb / papers / draft - bellovin - dnsext - bloomfilt% -00.txt ] , december 2001 .",
    "ahto buldas , peeter laud , and helger lipmaa .",
    "accountable certificate management using undeniable attestations . in _",
    "7th acm conference on computer and communications security _ , pages 918 .",
    "acm press , november 2000 ."
  ],
  "abstract_text": [
    "<S> we present a protocol for verification of `` no such entry '' replies from databases . </S>",
    "<S> we introduce a new cryptographic primitive as the underlying structure , the keyed hash tree , which is an extension of merkle s hash tree . </S>",
    "<S> we compare our scheme to buldas et al.s undeniable attesters and micali et al.s zero knowledge sets .    in the following , the term _ database _ refers to a system supplying the simplest form of databases , a table of @xmath0 pairs with functions for keyed insertion and retrieval . </S>"
  ]
}