{
  "article_text": [
    "parameter variation is expected to play a significant role in the design of integrated circuits in the nanoscale era @xcite .",
    "therefore it will become more and more difficult to guarantee the correct behavior of integrated circuits at the gate level , meaning that the hardware may become _ faulty _ in the sense that data is not always processed or stored correctly .",
    "traditional methods to ensure accurate hardware behavior , such as using larger transistors or circuit - level error correcting codes , are costly in terms of both area and power . fortunately , many applications are inherently fault tolerant in the sense that they do not fail catastrophically under faulty hardware . a good example of such an application are wireless communication systems , since the data is already probabilistic in nature due to transmission over a noisy channel .    more specifically , faulty iterative decoding of ldpc codes was first studied in  @xcite , where the gallager a and sum - product algorithms are considered .",
    "later studies also targeted the gallager b algorithm  @xcite and the min - sum algorithm  @xcite .",
    "all of the aforementioned studies provide valuable insight into the limitations of ldpc codes under various decoding algorithms and fault models .",
    "unfortunately , in most cases , the conclusion is that fully reliable communication is not possible when faults are present inside the decoder itself .",
    "polar codes  @xcite , constitute a different class of channel codes which has recently attracted significant attention , albeit not in the context of faulty decoding .",
    "polar codes are provably capacity achieving over various channels and they have an efficient and structured successive cancellation decoding algorithm whose complexity scales like @xmath0 , where @xmath1 is the length of the code .",
    "moreover , encoding can also be performed with complexity that scales like @xmath0 .      in this paper",
    "we provide an initial study of successive cancellation decoding of polar codes for transmission over the binary erasure channel ( bec ) under a simple fault model .",
    "we show that , under the fault model assumed in this paper , fully reliable communication is no longer possible .",
    "moreover , we provide numerical frame erasure rate ( fer ) results and we employ a fault - tolerance method which shows significant improvements with very low overhead .",
    "the remainder of this paper is organized as follows .",
    "section  [ sec : background ] provides some background on the construction and decoding of polar codes . in section  [ sec : faulty ] , we introduce the fault model that is used throughout this paper and we prove that fully reliable communication using polar codes is not possible under faulty decoding over the bec .",
    "section  [ sec : numerical ] provides some numerical results on the frame erasure rate and the bit erasure rate and in section  [ sec : protection ] we study an unequal error protection scheme .",
    "finally , section  [ sec : conclusion ] concludes this paper .",
    "following the notation of @xcite , we use @xmath2 to denote a row vector @xmath3 and @xmath4 to denote the subvector @xmath5 . if @xmath6 , then the subvector @xmath4 is empty .",
    "we use @xmath7 to denote the binary logarithm .",
    "if @xmath8 is a set of indices , then @xmath9 denotes the subvector formed by taking the elements of @xmath2 whose indices belong to @xmath8 .",
    "we denote the binary erasure channel with erasure probability @xmath10 as bec@xmath11 .",
    "let @xmath12 denote a binary input discrete and memoryless channel with input @xmath13 , output @xmath14 , and transition probabilities @xmath15 .",
    "a polar code is constructed by applying a @xmath16 _ channel combining _ transformation recursively on @xmath12 for @xmath17 times , followed by a _ channel splitting _",
    "step  @xcite .",
    "this results in a set of @xmath18 channels , denoted by @xmath19 .    in principle , it is possible to compute the bhattacharyya parameters @xmath20 . in practice ,",
    "finding an analytical expression turns out to be a very hard problem , except for the case of the bec , where an exact recursive calculation is possible @xcite .",
    "the construction of a polar code of rate @xmath21 is completed by choosing the @xmath22 channels with the lowest @xmath23 as _ non - frozen _ channels which carry information bits , while _ freezing _ the remaining channels to some values @xmath24 that are known both to the transmitter and to the receiver .",
    "the set of frozen channel indices is denoted by @xmath25 and the set of non - frozen channel indices is denoted by @xmath26 .",
    "the encoder generates a vector @xmath27 by setting @xmath28 equal to the known frozen values , while choosing @xmath29 freely .",
    "a codeword is obtained as @xmath30 where @xmath31 is the generator matrix .      the successive cancellation ( sc )",
    "decoding algorithm  @xcite starts by computing an estimate of @xmath32 , denoted by @xmath33 , based only on @xmath34 .",
    "subsequently , @xmath35 is estimated using @xmath36 etc .",
    "let the log - likelihood ratio ( llr ) for @xmath37 be defined as @xmath38 decisions are taken according to @xmath39 if @xmath40 , the decoder declares a failure . in order to calculate each @xmath41 ,",
    "the channel llrs @xmath42 are combined through the stages of a decoding graph containing nodes of two types .",
    "each node has two input llrs and one output llr , which we denote by @xmath43 and @xmath44 , respectively .",
    "for the first type of node , we have @xmath45 where @xmath46 is called a _ partial sum _ and it is always a sum of some of the codeword bits that have already been decoded . for the second type of node",
    ", we have @xmath47 due to the similarity of these update rules with the update rules of the sum - product algorithm that is commonly used to decode ldpc codes , we call the two types of nodes _ variable nodes _ and _ check nodes _ , respectively",
    ".    sc decoding can be greatly simplified for the bec as follows .",
    "all messages belong to an alphabet of cardinality three , which we define to be @xmath48 .",
    "the symbol @xmath49 denotes an erasure . for a check node ,",
    "the update rule consists of taking the product of the signs of the incoming messages . for a variable node ,",
    "if we define @xmath50 , the update rule becomes a simple addition .",
    "in order to analyze the erasure probability for each @xmath51 , we use the notion of a _ tree channel _  @xcite . in order to calculate the llr @xmath41 required to decode each bit @xmath24 ,",
    "the @xmath1 channel llrs , are combined through a tree - like structure of height @xmath17 with @xmath52 levels of nodes .",
    "@xmath41 is found at level @xmath17 ( which is the root of the tree ) , while the channel llrs are found at level @xmath49 .",
    "let @xmath53 denote the right - msb @xmath54-bit binary expansion of @xmath55 .",
    "all nodes at level @xmath56 are variable nodes if @xmath57 , and check nodes if @xmath58 .    due to channel and decoder symmetry",
    ", we can assume that the all - zero codeword was transmitted  @xcite , meaning that , since @xmath46 is always equal to @xmath49 , the variable node update rule becomes @xmath59 .",
    "moreover , since the output of a bec is never erroneous , messages with value @xmath60 can not appear during the decoding process .",
    "thus , under the all - zero codeword assumption for the bec , at a variable node the outgoing message is an erasure when both of the incoming messages are erasures , while at a check node the outgoing message is an erasure when any of the two incoming messages is an erasure .",
    "when the variable node update rule is applied to two independent messages with erasure probability @xmath61 , the erasure probability of the outgoing message is given by @xmath62 similarly , for the application of the check node we have @xmath63 following  @xcite , we define the random process @xmath64 as @xmath65 where @xmath66 is the erasure probability of the channel messages , which are found at level @xmath49 of each tree .",
    "it was shown in @xcite that @xmath67 converges almost surely to a random variable @xmath68 , with @xmath69 .",
    "we model faulty decoding as additional erasures in the decoder , which may be caused either by faulty message processing or by faulty message storage .",
    "these additional erasures can only happen on messages that are not already erased , and they happen independently of whether the message value is @xmath70 or @xmath60 and with probability @xmath71 .",
    "we get a non - faulty decoder , while for @xmath72 all messages are always erasures leading to a completely faulty decoder .",
    "thus , it is mainly interesting to study the decoder for @xmath71 . ]",
    "thus , at a variable node the total erasure probability is @xmath73 while at a check node we have @xmath74 we can re - define the random process @xmath64 using and as @xmath75 where again @xmath66 .",
    "we first show some properties of @xmath76 and @xmath77 , which will be useful to prove the main result of this section and to interpret some of the numerical results of section  [ sec : numerical ] .",
    "[ prop : properties ] for @xmath76 and @xmath77 , we have    1 .",
    "@xmath78 , 2 .",
    "@xmath79 3 .",
    "@xmath80 .    for @xmath76",
    ", we have @xmath81 the roots of @xmath82 are @xmath83 and @xmath84 . since @xmath85 , which is the coefficient of @xmath86 , the sign of the function between the two roots will be negative and ( i ) follows . moreover , using the same argument",
    ", we have @xmath87 , so ( ii ) follows . for ( iii )",
    "we have @xmath88 which indeed holds for any @xmath89 .",
    "[ prop : fixed ] the fixed points of @xmath76 are @xmath83 and @xmath84 .",
    "the unique fixed point of @xmath77 for @xmath90 $ ] is @xmath83 .",
    "the above proposition can easily be shown by solving @xmath91 and @xmath92 for @xmath61 , respectively , and noting that one solution of @xmath92 is negative .",
    "moreover , the following result about the process @xmath64 gives us some first insight into the effect that the faulty decoder has on the decoding process .",
    "the process @xmath93 defined in is a submartingale .",
    "since @xmath64 is bounded , it holds that @xmath94 .",
    "moreover we have @xmath95    specifically , this tells us that , contrary to @xcite , the overall erasure probability is not preserved by @xmath76 and @xmath77 .",
    "so , even if fully reliable transmission were possible in the limit of infinite blocklength , this would come at the cost of a rate loss , so the polar code would not be capacity achieving . unfortunately , as the following theorem asserts , fully reliable transmission under faulty decoding is not possible .",
    "[ thm : nopol ] let @xmath96 denote the sample space of the process @xmath97 and let @xmath98 denote a specific realization of @xmath97 .",
    "polarization does not happen under faulty sc decoding for the bec in the sense that @xmath99 such that @xmath100 .    to see this , it is sufficient to observe that @xmath101 and @xmath102 for any @xmath90 $ ] . a more detailed proof is provided in the appendix .",
    "so far , we have shown that fully reliable communication under faulty sc decoding for the bec is unfortunately impossible . however , in practice fully reliable communication is typically not required .",
    "thus , it is interesting to study the behavior of the sc decoder under faulty decoding and explore what _ is _ in fact possible . to this end , in this section we provide some numerical results to explore the process @xmath64 , as well as the fer performance of polar codes constructed based on this process .",
    "values for polar codes of length @xmath103 designed for the bec@xmath104 under faulty sc decoding with @xmath105 . ]",
    "the bhattacharyya parameters @xmath106 of a polar code of length @xmath1 for transmission over a bec@xmath11 correspond to all possible realizations of @xmath67 for @xmath66 and for a given @xmath107 , where @xmath108 . in fig .",
    "[ fig : z ] , we present the ( sorted ) values of @xmath109 for polar codes of length @xmath110 designed for the bec@xmath104 under faulty sc decoding with @xmath105 .",
    "we observe that we always have @xmath111 , which is not surprising since from proposition  [ prop : fixed ] we know that that @xmath112 is a fixed point of @xmath76 .",
    "however , @xmath112 is not a fixed point of @xmath77 ( whereas @xmath113 is a fixed point for both ) , resulting in the staircase - like structure of fig .",
    "[ fig : z ] .",
    "the process @xmath64 is a bounded submartingale , so it converges almost surely to some limiting random variable @xmath114 .",
    "indeed , in our numerical studies we observe that , as @xmath1 is increased , the staircase structure becomes more pronounced and seems to converge to a limit .",
    "unfortunately , we have not been able to identify that limit .",
    "let @xmath115 denote the frame erasure rate ( fer ) of a rate-@xmath116 polar code of length @xmath1 .",
    "it was shown in @xcite that for the bec ( under reliable decoding ) we have @xmath117 it is not clear whether the proof of @xcite can be immediately extended to the faulty decoding case , but we nevertheless use as a proxy for the fer . in fig .",
    "[ fig : fervsr ] , we present the evaluation of @xmath115 as a function of @xmath116 and for @xmath118 for a faulty sc decoder with @xmath105 and transmission over the bec@xmath104",
    ". we also present the fer under non - faulty decoding for comparison .",
    "strikingly , over a wide range of rates , the fer under sc decoding actually increases when the blocklength is increased .",
    "this can be explained if we recall that @xmath119 .",
    "thus , by increasing the blocklength while keeping the rate fixed , we are increasing the number of terms in , and since some of these terms do not decrease beyond some point , the value of the sum can increase .",
    "designed for the bec@xmath104 with @xmath105 . ]",
    "the sc decoder can be implemented as a tree of processing elements ( pes ) , which apply the update rules and also store the resulting messages  @xcite .",
    "in essence , this tree of pes is the implementation of a tree channel of depth @xmath17 in hardware , containing @xmath52 levels of pes . at level @xmath56 ,",
    "we need @xmath120 pes , so the total number of pes required by a decoder is @xmath121    as mentioned in section  [ sec : introduction ] , standard methods employed to enhance the fault tolerance of circuits , such as using larger transistors or circuit - level error correcting codes , are costly in terms of both area and power if the whole circuit needs to be protected .",
    "however , not all levels in the tree of pes are of equal importance , meaning that it may suffice to employ _ partial protection _ of the decoder against hardware - induced errors .",
    "in fact , as theorem  [ thm : uneqprot ] asserts , a careful application of such a protection method allows polarization to happen even in a faulty decoder while protecting only a constant fraction of the total decoder pes .",
    "( as a percentage of the capacity @xmath122 ) for @xmath123 and @xmath124 .",
    "the channel is a bec@xmath104 . ]",
    "let @xmath125 denote the number of levels that are protected , starting from level @xmath17 of the tree ( i.e. , the root ) and going towards the leaves .",
    "we assume that for these @xmath125 levels we have @xmath126 .",
    "let @xmath127 denote the total number of protected pes , where @xmath128 if we set @xmath129 , where @xmath130 is a _ fixed _ number of unprotected levels , then the fraction of the decoder that is protected converges to a constant as @xmath17 grows .",
    "indeed , we have @xmath131 in this case , the process @xmath97 can be rewritten as @xmath132 the following theorem asserts that the protection of a constant fraction of the decoder is sufficient to ensure that polarization happens as @xmath17 grows .",
    "[ thm : uneqprot ] setting @xmath129 for any fixed @xmath133 suffices to ensure that @xmath64 converges almost surely to a random variable @xmath68 .",
    "however , the unprotected levels result in a rate loss @xmath134 , in the sense that @xmath135 .",
    "the process @xmath136 as defined in is a submartingale for @xmath137 , but it becomes a martingale for @xmath138 .",
    "thus , for @xmath138 we have @xmath139 . using the arguments from @xcite",
    ", we can show that @xmath64 converges almost surely to a random variable @xmath68 with @xmath140 .",
    "equivalently , @xmath135 for @xmath141 , where @xmath142 can be evaluated numerically via density evolution .",
    "theorem [ thm : uneqprot ] implies that , when partial protection of the decoder is employed , polar codes are still not capacity achieving , but they can nevertheless be used for reliable transmission at any rate @xmath116 such that @xmath143 . the rate loss @xmath134 is presented in fig .",
    "[ fig : rateloss ] as a function of @xmath133 for some values of @xmath107 for a code designed for the bec@xmath104 .",
    "moreover , the effect of the partial protection for a finite length code is illustrated in fig .",
    "[ fig : fervsstageprotection ] , where we present @xmath115 for @xmath144 and @xmath105 when @xmath145 levels of the tree are protected .",
    "we observe that protecting only the root node already improves the performance significantly , especially for the lower rates .",
    "when @xmath146 , the performance of the faulty sc decoder is almost identical to the non - faulty decoder and it is remarkable that this performance improvement is achieved by protecting only @xmath147 of the decoder .",
    "moreover , in fig .",
    "[ fig : fervsstageprotectionn ] , we present @xmath115 for @xmath148 and @xmath105 with @xmath149 , so that the protected part for each @xmath1 is fixed to approximately @xmath150 of the decoder .",
    "we observe that , contrary to the results of section  [ sec : numerical ] , increasing the blocklength actually decreases @xmath115 , as in the case of the non - faulty decoder .     designed for the bec@xmath104 under faulty sc decoding with @xmath105 and @xmath151 protected decoding levels . ]",
    "designed for the bec@xmath104 under faulty sc decoding with @xmath105 and @xmath152 protected decoding levels . ]",
    "in this paper , we studied faulty sc decoding of polar codes for the bec , where the hardware - induced errors are modeled as additional erasures within the decoder .",
    "we showed that , under this model , fully reliable communication is not possible .",
    "moreover , we presented numerical frame erasure rate results to explore what _ is _ possible under faulty sc decoding",
    ". finally , we proposed an error protection scheme which can significantly improve the performance of a faulty sc decoder by protecting as little as @xmath150 of the decoder .",
    "the authors would like to thank the anonymous reviewers for their helpful comments .",
    "this work was kindly supported by the swiss nsf under project i d 200021_149447 .",
    "any @xmath153 results from repeated applications of @xmath76 and @xmath77 to @xmath154 . from this point on , we denote @xmath155 by @xmath97 for simplicity . from proposition",
    "[ prop : properties ] , we know that @xmath156 is strictly increasing for @xmath157 , and that @xmath158 is strictly decreasing for @xmath159 and strictly increasing for @xmath160 .",
    "so , in order to show that @xmath64 can not become arbitrarily small , it suffices to show that @xmath158 can not decrease the value of @xmath64 beyond some strictly positive value when @xmath159 .",
    "indeed , @xmath161 for any @xmath162 $ ] , so the claim holds .",
    "e.  arikan , `` channel polarization : a method for constructing capacity - achieving codes for symmetric binary - input memoryless channels , '' _ ieee trans .",
    "inf . theory _ ,",
    "55 , no .  7 , pp .",
    "30513073 , july 2009 .        c.  leroux , i.  tal , a.  vardy , w.  j.  gross , `` hardware architectures for successive cancellation decoding of polar codes , '' in _ proc .",
    "acoustics , speech , sig .",
    "16651668 , may 2011 ."
  ],
  "abstract_text": [
    "<S> we study faulty successive cancellation decoding of polar codes for the binary erasure channel . to this end </S>",
    "<S> , we introduce a simple erasure - based fault model and we show that , under this model , polarization does not happen , meaning that fully reliable communication is not possible at any rate . </S>",
    "<S> moreover , we provide numerical results for the frame erasure rate and bit erasure rate and we study an unequal error protection scheme that can significantly improve the performance of the faulty successive cancellation decoder with negligible overhead . </S>"
  ]
}