{
  "article_text": [
    "this report continues a series of documents @xcite around our spatio - temporal modelling and reasoning framework bespaced@xcite . in this report",
    "we use the bespaced language in a domain specific modelling task , namely a factory demonstrator for food processing .",
    "the models cover a variety of spatial and temporal aspects of the factory including physical location and sizing , meta - data about each component , temporal correlations between actuators and sensors as well as temporal safety margins between actuating .",
    "bespaced is our framework for spatio - temporal modelling and reasoning@xcite .",
    "bespaced is implemented using scala and provides ( i ) spatio - temporal constructs for defining components and their relationship especially with respect to time and space , and ( ii ) other basic logic constructs to specify properties and models .",
    "bespaced is open source and the work described in this report is part of the main development repository .",
    "the formalization presented here primarily serves academic purposes and is a candidate for a reference formalization and example for future efforts .",
    "in addition to industrial automation @xcite , bespaced has been applied to mobile systems @xcite using the reactive blocks tool set @xcite , the verification of wireless network setups @xcite and in the area of smart energy systems @xcite .",
    "the work described in this paper makes use of qualitative spatial representations @xcite following ideas similar to principles of the region connection calculus @xcite .",
    "initial ideas for the formalization of the demonstrator that is subject to this report have been discussed in @xcite .",
    "the factory demonstrator is also part of our vxlab activities @xcite .",
    "we provide a short overview on bespaced in section  [ sec : bespaced ] .",
    "domain specific constructs for industrial automation are provided in section  [ sec : ia ] and section  [ sec : demo ] introduces our demonstrator .",
    "section  [ sec : form ] provides the formalization of the example system using bespaced . a conclusion is featured in section  [ sec : concl ] .",
    "the modelling constructs we use for the industrial automation domain are built on some generic data structures in the bespaced core language .",
    "bespaced provides some primitives for representing symbolic scalars and integers , component meta - data , events , time and space .",
    "bespaced builds most of its constructs on two foundational types :    ....      trait invariant extends ordered[invariant ]      trait atom extends invariant ....    an invariant is a formula that is supposed to hold for a system .",
    "an atom is a special case of invariant that is not composed of multiple invariants .",
    "time and space are of primary concern in bespaced .",
    "bespaced represents time with the following constructs :    ....      case class timepoint [ + t ] ( timepoint : t ) extends atom      case class timeinterval[+t](timepoint1 : t , timepoint2 : t ) extends atom ....    bespaced represents geometric space with many occupational constructs . here",
    ", we primarily use :    ....      case class occupy3dbox ( x1 : int , y1 : int , z1 : int ,                              x2 : int , y2 : int , z2 : int )           extends atom ....    bespaced represents events with a single construct called event :    ....      case class event [ + e ] ( override val event   : e ) extends atom ....    for our modelling effort in industrial automation we extend the the bespaced language in a number of areas .",
    "the rest of this section presents these extensions .",
    "bespaced represents events with a single construct called event , and a generalization called eventlike :    ....      trait eventlike   [ + e ] extends atom { val event : e }      case class event [ + e ] ( override val event   : e ) extends eventlike[e ] ....    in the industrial automation domain an event is something that changes state at an instant in time .",
    "there is a construct in bespaced to reflect these semantics :    ....      class instate[+o , + t , + s ] ( val owner : o , val timepoint : timepoint[t ] ,                                 val state : s )            extends event[(o , timepoint[t],s ) ] ( ( owner , timepoint , state ) ) ....    the value passed to the superclass event s constructor is a tuple of cardinality three which maintains compatibility with the more general event .",
    "we define meta - data for each of the components that make up a machine .",
    "this data lends itself to a key - value style encoding . in order to support this style we added the following bespaced structural constructs to tag data with semantics in the context of this key - value encoding style :    ....      case class component[+i ] ( i d : i )",
    "extends atom      case class componentvalue[+v ] ( value : v ) extends atom ....",
    "component defines the keys and componentvalue defines the values . by convention , the keys identify a single component .",
    "the type could be a string or a reference to any domain specific component . in our case the component i d s are stings used to define a unique name for each .",
    "meta data is defined in bespaced as a conjunction ( bigand ) of key value pairs , where each pair is an implication ( implies ) .",
    "this is very similar to a `` map '' in mathematics and many programming languages .",
    "bespaced provides the bemap construct ( a specialization of bigand ) which extends the relatively simple bigand with map like behaviour :    ....      class bemap[+p < : invariant , + c < : invariant](terms : list[implies[p , c ] ] )          extends bigand[implies[p , c]](terms )          {            lazy val premises     = ( this.terms map { _ .premise } ) .toset[any ]            lazy val conclusions = ( this.terms map { _ .conclusion } ) .toset[any ]            lazy val elements     = premises union conclusions                 def apply(key : invariant ) : option[c ]          } ....    bemaps are used to construct the descriptions using component as the key and componentvalue as the value :    ....      case class componentdescription[+c < : component[any ] ,                                      + v < : componentvalue[any ] ]                 ( override val terms : list[implies[c , v ] ] )           extends bemap[c , v](terms ) ....    an example construction of meta data is shown below :    ....      val elon = bemap (          component(\"name \" )     = = > componentvalue(\"elon musk \" ) ,          component(\"address \" ) = = > componentvalue(\"mars \" )          ) ....    an example query of a bemap can be done as follows :    ....      elon(\"address \" ) ....      to support the use of graphs for defining topologies we added a graph construct to bespaced . in our model",
    "the edges are annotated so the existing bespaced edge primitive is extended to support annotations of any type :    ....      class edgeannotated[+n , + a ] ( val source : n , val target : n ,                                   val annotation : option[a ] )            extends atom      case class edge[+n ] ( override val source : n , override val target : n )           extends edgeannotated[n,{\\tt nothing}](source , target , none ) ....    it is interesting to note , in type inheritance terms , edge is a specialisation of edgeannotated . on the surface , this may feel counter - intuitive , however , it makes sense when you consider that edge proper is a special kind of edge annotated with nothing .",
    "scala provides a special type called nothing that is a specialisation of all other types and we make use of this feature .",
    "the edge and edgeannotated constructs define edges with two nodes .",
    "we define graphs as a bigand of annotated edge objects called begraphannotated .",
    "the non - annotated version is called a `` begraph '' for behavioural graph .    ....      class begraphannotated[+n , + a](terms : list[edgeannotated[n , a ] ] )            extends bigand[edgeannotated[n , a]](terms )          class begraph[+n](terms : list[edge[n ] ] )            extends begraphannotated[n , nothing](terms ) ....    an example construction of a simple graph would be :    ....      begraph (             component(\"smoke detector \" ) -- > component(\"alarm \" ) ,             component(\"motion sensor \" ) -- > component(\"alarm \" )             ) ....    the ",
    "> symbol is a binary infix operator that constructs an edge object .",
    "we model a number of different topologies for the industrial automation domain most of which require temporal semantics .",
    "we extended bespaced with two temporal constructs to represent timing relationships : correlations and constraints .",
    "a temporal correlation declares that two events coincide with a specified time delay relative to the first event .",
    "the first event is called the `` cause '' and the second , `` effect '' .",
    "case class temporalcorrelation[+e , + t < : number ]           ( cause : eventlike[e ] , duration : timeduration[e ] , effect : eventlike[e ] )           extends invariant ....    a temporal constraint declares that two events ( or one event and the lack of a second event in the inverse case ) occur within a specified time duration relative to the first event .",
    ".... case class temporalconstraint [ + e , + t < : number ]             ( cause : eventlike[e ] , range : timedurationrange[e ] ,              effect : eventlike[e ] , inverse : boolean = false )       extends invariant ....",
    "we identified many data structures that are reusable within the industrial automation domain which are kept separated from applications . for the modelling exercise we considered programmable logic controllers ( plc ) outside the scope .",
    "the industrial automation domain meta - model is defined in the bespacedia project and defines types which , in effect , present design patterns for developers of more specific domains such as food processing . in this section",
    "we categorize and summarize all the domain specific types in the physicalmodel module of bespacedia .",
    "we provide a trait for each kind of physical object and then break this down into a generalised type hierarchy representing components of automation equipment .    ....",
    "trait physicalobject[+i ]        extends component[i ] ....    a device represents any built in component of the machine itself .",
    "this is further broken down into parts , actuators and sensors .",
    "a part represents a device that forms part of a useful process .",
    "an actuator is a device that connects plcs with parts to make them do something .",
    "a sensor is a device that communicates some portion of the state of the machine back to the plc .    ....",
    "trait device[+i ]                extends physicalobject[i ]      trait part[+i ]                  extends device[i ]      trait actuator[+i ]              extends device[i ]      trait sensor[+i ]                extends device[i ] ....    material represents physical things that pass through the machine but are not considered part of the machine itself .",
    "a discrete material represents atomic objects that should not be divided ; for example bottle caps .",
    "there is no point it measuring fractions of a cap , so these can be measured using natural numbers .",
    "an analog material represents a divisible material where we can measure it using a real number ; for example , water .    ....",
    "trait material[+i ]              extends physicalobject[i ]      trait discretematerial[+i ]      extends material[i ]      trait analogmaterial[+i ]        extends material[i ]            { val unit : string ; val quantity : double } ....",
    "all physical objects have an identity . with regards to discrete materials",
    "there is the ability to uniquely identify each one , for example each bottle cap can have a unique identity .",
    "this would allow one to trace discrete materials through the system .",
    "the following type is defined for creating an application specific spatial variation :    ....      trait spatialvariation extends invariant ....    this allows the applications to model a set of discrete values representing positions in space ( like an enumerated type ) .",
    "this is done in scala using singleton objects which extend the spatialvariation trait , for example :    ....      abstract class stackejectorposition extends atom with spatialvariation      object stackejectorretractedposition extends stackejectorposition      object stackejectorextendedposition extends stackejectorposition ....      the following types are defined for creating application specific states :    ....      trait physicalstate[+s ]            extends componentstate[s ]      trait devicestate[+ds ]             extends physicalstate[ds ]      trait partstate[+ps ]               extends devicestate[ps ]      trait actuatorstate[+as ]           extends devicestate[as ]      trait sensorstate[+ss ]             extends devicestate[ss ] ....",
    "this allows the applications to model a set of discrete values representing all the useful abstract states for each category of device , for example :    ....      abstract class lightsensorstate(sig : signal ) extends sensorstate(sig )      class obstructedstate(sig : signal ) extends lightsensorstate(sig )      val obstructedhigh    = obstructedstate(high )      val obstructedlow     = obstructedstate(low )      val obstructed        = obstructedstate(dc ) ....    obstructed is an abstract state and obstructedhigh additionally records the actual domain specific electrical signal that indicates this state .",
    "the following types are defined for creating application specific events :    ....      abstract class physicalevent[+i , s](component : physicalobject[i ] ,                                          timepoint : timepoint[long ] ,                                          state : physicalstate[s ] )               extends instate[physicalobject[i ] , long , physicalstate[s ] ]                       ( component , timepoint , state )               with bespacedgestalt.core.event[s ]                    abstract class deviceevent[+i , s](device : device[i ] ,                                         timepoint : timepoint[long ] ,                                        state : devicestate[s ] )               extends physicalevent[i , s](device , timepoint , state )         abstract class actuatorevent[+i , s](actuator : actuator[i ] ,                                          timepoint : timepoint[long ] ,                                          state : actuatorstate[s ] )               extends deviceevent[i , s](actuator , timepoint , state )                     abstract class sensorevent[+i , s](sensor : sensor[i ] ,                                          timepoint : timepoint[long ] ,                                          state : sensorstate[s ] )               extends deviceevent[i , s](sensor , timepoint , state )   ....    the following allows the application to model live events describing changes in the state of the factory , for example :    ....      sensorevent(stackempty , timepoint(new date ( ) ) , obstructed ) ....",
    "this means the relevant light sensor has detected the stack is empty .",
    "the following types are defined for creating application specific topologies :    ....      abstract trait relationship      abstract trait spatialrelationship extends relationship      abstract trait temporalrelationship extends relationship      abstract trait spatiotemporalrelationship               extends spatialrelationship with temporalrelationship        type topology[+com < : component[any ] , + rel < : relationship ] =           begraphannotated[com , rel ]      type spatialtopology[+com < : component[any ] ,                           + srel < : spatialrelationship ] =           begraphannotated[com , srel ]      type temporaltopology[+com < : component[any ] ,                            + trel < : temporalrelationship ] =           begraphannotated[com , trel ]      type spatiotemporaltopology[+com < : component[any ] ,                                  + strel < : spatiotemporalrelationship ] =           begraphannotated[com , strel ] ....    the following allows the applications to model functional , spatial and/or temporal relationships between devices , for example :    ....          case class seconds(s : int )               extends timeduration(s ) with spatialrelationship            begraphannotated (              edgeannotated(component(\"smoke detected \" ) ,                            component(\"alarm activated \" ) ,                            some(seconds(1 ) ) ) ,              edgeannotated(component(\"smoke clear \" ) ,                            component(\"alarm deactivated \" ) ,                            some(seconds(3 ) ) )              ) ....",
    "the food processing factory used in our demonstrator is scaled down version of a fully functioning factory system capable of filling bottles with liquid or corn kernels , capping the bottles , moving bottles on conveyer belts and supplying both bottles and caps from storage .          for this modelling application",
    "we limit the scope to a single station ( as seen in figure  [ fig : festo - station-1 ] ) which is controlled by a single plc .",
    "the originally provided plc is replaced with a customized raspberry pi based plc solution which allows us to run bespaced and communicate to both the station and the cloud over a wifi network .",
    "we numbered this station one and named it `` capdispenser '' .",
    "other stations that are out of scope but we have partially modelled include : capconveyer , capping , rotarytablepart1 , rotarytablepart2 , cappedbottlesconveyerbelt , packagingstation , bottleconveyer and bottleconveyersorting .",
    "the capdispenser station involves two subsystems ( as seen in figure  [ fig : festo - stack - loader ] ) .        * a tube to hold caps with a cap ejector underneath that pushes caps out of the tube ( see figure  [ fig : festo - stack ] ) .",
    "+    * a lever arm ( that swings in an arc ) with a vacuum gripper built into the tip of the arm used to pick up and drop off caps ( see figure  [ fig : festo - loader ] ) .",
    "+      in this section we describe the two subsystems of the cap dispenser station in more detail including the parts , actuators and sensors .",
    "there is only one actuator integrated into the cap ejector part :    * stack ejector extend : activation causes the ejector to be extended which pushes out the bottom cap in the stack if there is one . * stack ejector extend : inactivation causes the ejector to be retracted which returns the ejector to the original position and causes the rest of the caps to move down one cap height in the stack due to gravity .",
    "there are three sensors integrated into the cap tube and ejector parts :    * stack empty : a light sensor positioned at the base of the tube that when unobstructed indicates the tube is empty .",
    "* stack ejector extended : a light sensor positioned at the extreme extended position of the ejector .",
    "when obstructed this indicates the stack ejector has been fully extended .",
    "* stack ejector retracted : a light sensor positioned at the extreme retracted position of the ejector .",
    "when obstructed this indicates the stack ejector has been fully retracted .",
    "there are four actuators integrated into the cap loader and vacuum gripper parts :    * loader pickup : activation causes the arm to rotate to the left towards the pickup area . *",
    "loader dropoff : activation causes the arm to rotate to the right towards the drop - off area . * vacuum grip : activation causes the vacuum motor to pump air out of the suction cup mounted in the tip of the lever arm .",
    "* eject air pulse : activation causes the pulse motor to pump air into the suction cup causing the cup to loose suction .",
    "there are three sensors integrated into the cap loader and vacuum gripper parts :    * loader picked up : a contact sensor that indicates the arm has fully rotated into the pickup area . *",
    "loader dropped off : a contact sensor that indicates the arm has fully rotated into the drop - off area .",
    "* workpiece gripped : a sensor that indicates the vacuum has reached a level where suction force is greater than the gravitational force of a bottle cap ( i.e. it is gripped and should not fall off ) .",
    "we divide our model of the food processing factory domain into four distinct areas :    * components - for modelling the identity of each physical component in the factory . for this domain",
    "we call the components `` devices '' . * meta data - for modelling static data about the components . for this domain",
    "we call this data `` device descriptions '' .",
    "spatial data is included in the descriptions .",
    "* topologies - for modelling information in a graph structure . for this domain we experimented with a few topologies representing different information .",
    "* events - for modelling dynamic data ( i.e. data that is defined in time ) .",
    "each area is described in more detail below including definitions of the data structures used and some example code snippets .",
    "the model of devices provides a uniform way to identify every component in the factory . as per the industrial automation domain model",
    "we define three categories of devices : parts , actuators and sensors .",
    "we ensure the bespaced component construct is used to define every device by reusing the device class defined for the industrial automation domain .    ....",
    "trait festodevice extends device[id ] ....",
    "we define the identity type for all devices as a string and use a type alias called i d .",
    "....      type i d = string ....    this type is used consistently throughout the model where identity is required .",
    "finally , we define the three sub devices for this domain :    ....      class festopart(override val i d : i d )            extends component(id ) with part[id ] with festodevice      class festoactuator(override val i d : string )            extends component(id ) with actuator[id ] with festodevice      class festosensor(override val i d : i d )            extends component(id ) with sensor[id ] with festodevice ....      to construct device descriptions realizing meta data in the domain model we re - use the bespaced componentdescription class and refine the constructor parameter to be a behavioral map :    ....      class festocomponentdescription(entries : bemap[component[any ] ,                                                     componentvalue[any ] ] )            extends componentdescription[component[any],componentvalue[any ] ]                    ( entries.terms ) ....    each device category requires different meta - data .",
    "first we introduce a few concepts in section  [ sssec : app - desc - anat ] .",
    "then we define the data common to all devices in section  [ sssec : app - desc - all ] followed by the meta data specific to each device category in its own section .      to illustrate the structure of the device descriptions we will briefly delve deep into one simple example ; the stackejector part .",
    "( the `` = = > ''",
    "symbol is a binary infix operator for the bespaced implies construct ) . here",
    "is how we define it at the top level :    ....      val exampleentry =   component(stackejector )   = = >                          festocomponentdescription(ispart , ishorizontalpusher ,                          stackejectorvariations , stackejectoroccupy ) ....    and this is what the parameters mean and how we construct them : the device category and type is meta data about the type of the device and are simply key - value pairs constructed using an implies construct .    ....",
    "val ispart                = devicecategory = = > part      val ishorizontalpusher    = devicetype      = = > horizontalpusherpart ....",
    "spatial variations represent a discrete set of spatial positions that a part can be `` in '' .",
    "first , we define the set of demonstrator specific positions , and then map this to a mutual exclusion structure of component values .",
    "we use the bespaced exclusive or xor logical construct to represent mutual exclusion .    ....",
    "val stackejectorpositions = xor(stackejectorretractedposition ,                                      stackejectorextendedposition                                      )      val stackejectorvariations = spatialvariations = = >                                       componentvalue(xor (                                           stackejectorpositions.terms map                                                { pos = > componentvalue.apply(pos ) }                                           )                                       ) ....    figure  [ fig : variations ] represents the above spatial variations as a graph of bespaced objects .",
    "the last parameter , stackejectoroccupy , defines the three dimensional space which the part occupies :    ....      val stackejectoroccupy = spatiallocation = = >            componentvalue(occupy3dbox (               x.stackejectorleft , y.stackejectorfront , z.stackejectorbottom ,               width.stackejector , depth.stackejector , height.stackejector            ) ) ....    the parameters in the occupy3dbox above are constant measurements .",
    "how we define these measurements is discussed further in subsection  [ ssec : space ] .",
    "the meta data for multiple devices includes the keys : devicecategory , devicetype , gpio , partassociation , signalmapping and spatiallocation .",
    "well known values are defined for the first three keys ; for example :    ....      //",
    "device categories      val part            = componentvalue(\"part \" )      val actuator        = componentvalue(\"actuator \" )      val sensor          = componentvalue(\"sensor \" )         // device types      val solenoidactuator = componentvalue(\"solenoid \" )      val lightsensor = componentvalue(\"light sensor \" )         // gpio pins - actuators      val gpio_1   = componentvalue(1 )      val gpio_26 = componentvalue(26 )           // gpio pins - sensors      val gpio_7   = componentvalue(7 )      val gpio_25 = componentvalue(25 ) ....    the gpio pins are either used for a sensor or an actuator , not both .",
    "our factory demonstrator comes with a variety of actuators and sensors .",
    "in station one , they all have binary signalling which means there are only two voltage levels generated or accepted .",
    "these signals are named high ( for a high voltage level ) and low ( for a low voltage level )",
    ". it would be perfect if every actuator interpreted high as activation and every light sensor generated a high signal for an obstructed state .",
    "unfortunately , this semantic mapping is inconsistent between devices , even in station one of our demonstrator factory .",
    "some solenoid based actuators activate on high and some on low .",
    "some light sensors when obstructed generate high and others low .",
    "so we need a functional mapping between signal level and its meaning .",
    "we encode the meaning of the signal to / from each actuator / sensor in a signal mapping data structure . to model the meaning",
    ", we use the state types defined in the industrial automation domain model ( see section  [ ssec : ia - var ] ) .",
    "the embedded object is of any type and allows us to create domain specific types for the demonstrator domain . in our case",
    "we created the following signal types :    ....      class festosignal(val state : string )      case object high extends festosignal(\"high \" )      case object low   extends festosignal(\"low \" )      case object dc    extends festosignal(\"don't care \" ) ....    and them embed in the device states :    ....      class festoactuatorstate(signal : festosignal )            extends festodevicestate(signal ) with actuatorstate[festosignal ]      class festosensorstate(signal : festosignal )            extends festodevicestate(signal ) with sensorstate[festosignal ] ....    the dc signal is used to specify an abstracted device state where we do nt care what the voltage signal actually is or will be . in the application domain specific model ,",
    "constants are defined for all the device states , for example actuators that use a solenoid are defined as follows :    ....      abstract class festosolenoidactuatorstate(signal : festosignal )               extends festoactuatorstate(signal )      class activestate(sig : festosignal )            extends festosolenoidactuatorstate(sig )      class passivestate(sig : festosignal )            extends festosolenoidactuatorstate(sig )        val activehigh   = activestate(high )      val activelow    = activestate(low )      val active       = activestate(dc )      val passivehigh = passivestate(high )      val passivelow   = passivestate(low )      val passive      = passivestate(dc ) ....    objects of these types are used in the mapping to describe the meaning of the signal .",
    "the signal mapping function is defined as : :    ....      type signalto[r ]            = map[festosignal , r ]      type signalsensormapping    = signalto[festosensorstate ]      type signalactuatormapping = signalto[festoactuatorstate ] ....    and used for example in the following way :    ....      val highsolenoidactuatormapping : signalactuatormapping =              map(high - > activehigh ,   low - > passivelow )          val signalmapping = component(\"signal mapping \" )      val ishighsolenoidactuator =              signalmapping = = > componentvalue(highsolenoidactuatormapping ) ....      the meta data for parts includes the key spatialvariations and an example of a well known value is :    ....      val conveyerpart          = componentvalue(\"conveyer \" )      val isconveyer            = devicetype = = > conveyerpart ....    a spatial variation defines a discrete set of positions for a moving part semantically as discussed in section  [ sssec : app - desc - anat ] .",
    "actuators are defined in terms of the common keys , however , they do have some specific well known values such as :    ....      val solonoidactuator = componentvalue(\"solonoid \" )        val issolonoid = devicetype = = > solonoidactuator ....    an example description for the vacuum gripper actuator is :    ....      val forloader = partassociation    = = > componentvalue(loader )      component(vacuumgrip ) = = > festocomponentdescription (                                isactuator , issolonoid , isgpio5 ,                                 ishighsolonoidactuator , forloader )   ....    note , the spatial occupation data has been left out .",
    "a topic for future work would be how to model spatial occupation when it is not fixed relative to the machine but will be moving relative to how the part it is embedded in moves .",
    "the ishighsolonoidactuator is a signal mapping function ( see section  [ sssec : sigmap ] ) that declares that a high voltage activates the solenoid and a low voltage inactivates it .",
    "sensors have some specific well known values such as :    ....      val lightsensor = componentvalue(\"light sensor \" )      val islightsensor = devicetype = = > lightsensor ....",
    "an example of a sensor description follows .",
    "it uses the same meta data keys as the actuators :    ....      component(stackejectorextended )   = = > festocomponentdescription (                                        issensor , islightsensor , isgpio0 ,                                        ishighlightsensor , forstackejector ,                                        stackejectorextendedoccupy ) ....    the stackejectorextendedoccupy parameter is spatial data and is explained in the following section  [ ssec : space ] .",
    "we use the occupy3dbox core construct to define the volume of space occupied by a device .",
    "the desired result of an occupy3dbox is quite simple , however , the steps to construct one is not so simple .",
    "we did this in an elegant way that minimises the number of measurements that need to be taken by reusing the measurements of key reference points and sizes .",
    "below is a partial extract of the measurement code and serves as an example for the two light sensors in the proximity of the cap ejector part :    ....      object x {        val station1edgeleft          = 0        val stackejectorright         = station1edgeleft + 85        val extendretractsensorright = stackejectorright        val extendretractsensorleft   = extendretractsensorright - width.extendretractsensor      }      object y {        val station1edgefront         = 0        val stackejectorfront         = station1edgefront + 76               val extendsensorfront         = stackejectorfront + 122        val extendsensorback          = extendsensorfront + depth.extendretractsensor               val retractsensorfront        = stackejectorfront + 236        val retractsensorback         = retractsensorfront + depth.extendretractsensor      }      object z {        val base                         = 0        val stackejectorbottom           = base        val extendretractsensorbottom    = base + 4        val extendretractsensortop       = base + 20      }      object width {        val extendretractsensor = 32      }      object depth {        val extendretractsensor = 10      }      object height {        val extendretractsensor = z.extendretractsensortop -                                  z.extendretractsensorbottom      } ....    note , that the width , depth and height metrics are reused for both sensors as are the x and z coordinates .",
    "the y coordinate is different for each sensor and so is separated .",
    "in addition , reference metrics are used that are reused to build up the actual metric symbolically .",
    "there are several layers of referencing including the base of the station one , the edge of a part and the edge of sensor or actuator .",
    "these layers are referenced by downstream layers to formulate the metrics .",
    "finally some meta data can be created for defining the spatial occupation for the sensor s descriptions :    ....      val stackejectorextendedoccupy   = occupy (                                           x.extendretractsensorleft ,                                           y.extendsensorfront ,                                            z.extendretractsensorbottom ,                                           width.extendretractsensor ,                                           depth.extendretractsensor ,                                           height.extendretractsensor )                                                component(stackejectorextended )   = = > festocomponentdescription (                                              issensor , islightsensor , isgpio0 ,                                               ishighlightsensor , forstackejector ,                                              stackejectorextendedoccupy )           val stackejectorretractedoccupy = occupy (                                           x.extendretractsensorleft ,                                           y.retractsensorfront ,                                           z.extendretractsensorbottom ,                                           width.extendretractsensor ,                                           depth.extendretractsensor ,                                           height.extendretractsensor )                                                component(stackejectorretracted ) = = > festocomponentdescription (                                              issensor , islightsensor , isgpio3 ,                                              ishighlightsensor , forstackejector ,                                              stackejectorretractedoccupy ) ....    notice that the occupybox objects are consistently built from the left , front and bottom coordinates as well as the width , depth and height sizes for each sensor .    in this section",
    "we have seen step by step how spatial data for the volume occupied by a device is built from a few measurements with layered symbolic referencing .",
    "so far we have only addressed static meta data oriented around components . in this section",
    "we show how we modelled information in a topological structure .",
    "we have developed several different but complimentary topologies that illustrate the possibilities that bespaced offers in modelling topological information and these are presented in the following .",
    "the first topology involves only sensors and captures the expected order of state change in a set of sensors as material flows through the machine during normal processing scenarios .",
    "the process flow topology is illustrated in figure  [ fig : top - procseq ] .",
    "each edge in the topology represents a temporal proximity relationship : a state change in one sensor ( source node ) is expected to be soon followed by a state change in another sensor ( destination node ) . the way we model this is by representing sensors as nodes and the expectation as edges .",
    "each edge is annotated with three pieces of information :    * cause : the state change of the first sensor .",
    "this is done by annotating the leading edge with the value the sensor state changes to . *",
    "duration : the exact time between the two state changes .",
    "* effect : the state change of the second sensor .",
    "this is done by annotating the trailing edge with the value the sensor state changes to .",
    "the bespaced encoding of the annotations use a temporalcorrelation as follows :    ....      class   festostatecorrelation (                cause : festodevicestate ,                duration : timeduration[festodevicestate ] ,                effect : festodevicestate )      extends temporalcorrelation[festodevicestate , integer ]              ( cause , duration , effect ) ....    below is an example of one such process sequence edge in bespaced serialised to json ( this edge is the same one commented on in figure  [ fig : top - procseq ] ) :    .... {      \" type \" : \" edgeannotated \" ,      \" source \" : { \" type\":\"component\",\"id\":\"loader picked up \" } ,      \" target \" : { \" type\":\"component\",\"id\":\"loader dropped off \" } ,      \" annotation \" : {          \" type \" : \" festostatecorrelation \" ,          \" cause \" : { \" type \" : \" obstructed \" } ,          \" duration \" : {              \" type\":\"timeduration \" ,              \" start\":{\"type \" : \" ss variable \" , \" expression \" : { \" type \" : \" obstructed \" } } ,              \" scalar\":{\"type \" : \" ss addition \" , \" expression \" : [                       { \" type \" : \" ss variable \" , \" expression \" : { \" type \" : \" obstructed \" } } ,                       { \" type \" : \" ss constant \" , \" expression \" : 3 }                       ] }               } ,           \" effect \" : { \" type \" : \" obstructed \" } }      } ....    notice that this topology does not allow for any variability in the timing so it would be best suited for modelling real world data inferred from live events .      the causality topology is illustrated in figure  [ fig : top - cause ] .        each edge in the causality topology represents a temporal proximity relationship between an actuator to a sensor : a state change in an actuator ( source node ) leads to a state change in a sensor ( destination node ) .",
    "we assert that this must happen within some time range .",
    "the way we model this is by representing devices as nodes and the assertion as edges .",
    "each edge is annotated with three pieces of information :    * cause : the state change of the actuator .",
    "this is done by annotating the leading edge with the value the actuator state changes to . *",
    "duration range : one minimum and one maximum time duration .",
    "* effect : the state change of the sensor .",
    "this is done by annotating the trailing edge with the value the sensor state changes to .",
    "the bespaced encoding of these annotations use a temporalconstraint as follows :    ....      class   festostateconstraint (                cause : festodevicestate ,                durationrange : timedurationrange[festodevicestate ] ,                effect : festodevicestate , inverse : boolean = false                )            extends temporalconstraint[festodevicestate , integer ]                ( cause , durationrange , effect , inverse ) ....    below is an example of one such causality edge in bespaced serialized to json ( this edge is the same one commented on in figure  [ fig : top - cause ] ) :    .... {      \" type \" : \" edgeannotated \" ,      \" source \" : { \" type\":\"component\",\"id\":\"stack ejector extend \" } ,      \" target \" : { \" type\":\"component\",\"id\":\"stack ejector retracted \" } ,      \" annotation \" : {          \" type \" : \" festostateconstraint \" ,          \" cause \" : { \" type \" : \" active \" } ,          \" durationrange \" : {              \" type\":\"timedurationrange \" ,              \" minimum \" : {                  \" type\":\"timeduration \" ,                  \" start \" : {                      \" type \" : \" ss variable \" ,                      \" expression \" : { \" type \" : \" active \" } } ,                  \" scalar \" : {                      \" type \" : \" ss addition \" ,                      \" expression \" : [                          { \" type \" : \" ss variable \" , \" expression \" : { \" type \" : \" active \" } } ,                          { \" type \" : \" ss constant \" , \" expression \" : 200 }                          ] }                  } ,              \" maximum \" : {                  \" type\":\"timeduration \" ,                  \" start\":{\"type \" : \" ss variable \" , \" expression \" : { \" type \" : \" active \" } } ,                  \" scalar \" : {                      \" type \" : \" ss addition \" ,                      \" expression \" : [                          { \" type \" : \" ss variable \" , \" expression \" : { \" type \" : \" active \" } } ,                          { \" type \" : \" ss constant \" , \" expression \" : 300 }                          ] }                  }              } ,      \" effect \" : { \" type \" : \" unobstructed \" } } } ....      the avoidance topology is illustrated in figure  [ fig : top - avoid ] .        each edge in the avoidance topology represents a temporal proximity relationship between two actuators : a state change in a first actuator ( source node ) leads to a state change in a second actuator ( destination node ) .",
    "we assert that this must happen within some time range .",
    "the way we model this is by representing devices as nodes and the assertion as edges .    *",
    "cause : the state change of the first actuator .",
    "this is done by annotating with the leading edge with the value the actuator state changes to . *",
    "duration range : one minimum and one maximum time duration . *",
    "effect : the state change of the second actuator .",
    "this is done by annotating with the leading edge with the value the actuator state changes to .",
    "the bespaced encoding of these annotations use a temporalconstraint as in section  [ sssec : cause ] .",
    "below is an example of one such avoidance edge in bespaced serialized to json ( this edge is the top edge commented on in figure  [ fig : top - avoid ] ) :    .... {      \" type \" : \" edgeannotated \" ,      \" source \" : { \" type\":\"component\",\"id\":\"stack ejector extend \" } ,      \" target \" : { \" type\":\"component\",\"id\":\"loader pickup \" } ,      \" annotation \" : {          \" type \" : \" festostateconstraint \" ,          \" cause \" : { \" type \" : \" active \" } ,          \" durationrange \" : {              \" type\":\"timedurationrange \" ,              \" minimum \" : {                  \" type\":\"timeduration \" ,                  \" start\":{\"type \" : \" ss variable \" , \" expression \" : { \" type \" : \" active \" } } ,                  \" scalar\":{\"type \" : \" ss addition \" , \" expression \" : [                      { \" type \" : \" ss variable \" , \" expression \" : { \" type \" : \" active \" } } ,                      { \" type \" : \" ss constant \" , \" expression \" : -500 }                      ] }                  } ,              \" maximum \" : {                  \" type\":\"timeduration \" ,                  \" start \" : {                      \" type \" : \" ss variable \" ,                      \" expression \" : { \" type \" : \" active \" } } ,                  \" scalar \" : {                      \" type \" : \" ss addition \" ,                      \" expression \" : [                          { \" type \" : \" ss variable \" , \" expression \" : { \" type \" : \" active \" } } ,                          { \" type \" : \" ss constant \" , \" expression \" : 1000 }                          ]                      }                  }              } ,      \" effect \" : { \" type \" : \" passive \" } } } ....      the model for live events from the food processing factory is built in layers of domain specific types that ultimately derive from bespaced constructs .",
    "figure  [ fig : event ] illustrates the bespaced data structure for live events .",
    "the figure also shows the traits from the industrial automation domain to further illustrate the layers .",
    "the entity low on the diagram is an immutable singleton object ( in scala ) meaning the name refers to an object instance of a class with the same name as the object .    ....",
    "case object low   extends festosignal(\"low \" ) ....    types for sensors , actuators and parts are built from component objects .",
    "types for the state of these devices are built from componentstate objects . and",
    "finally types for events are built from the core type in the industrial automation domain called physicalevent ( see section  [ ssec : ia - event ] ) .",
    "physical events are a composition of the previous two types plus a time point .",
    "the three key pieces of information are the object this event is scoped to , the time this event occurred and the state this object changed to . below is an example of how to create a live event for the demonstrator plant . apart from the time this constrction code matched the the illustration in figure  [ fig : event ] :    ....        val now = new gregoriancalendar ( )        val timepoint = timepoint(now.gettime.gettime )        val event = festosensorevent (                           capdispenser.stackejectorextended ,                           timepoint ,                           obstructedlow                           ) ....    the state obstructedlow is predefined in our application domain along with general light sensor states as follows :    ....        abstract class festolightsensorstate(sig : festosignal )                 extends festosensorstate(sig )        class obstructedstate(sig : festosignal )              extends festolightsensorstate(sig )        val obstructedhigh = obstructedstate(high )        val obstructedlow = obstructedstate(low ) ....",
    "we created a visualisation of live events from our food processing demonstrator in the context of a topology .",
    "a snapshot of an example visualisation can be seen in figure  [ fig : vis - basic ] .        in this visualisation",
    ", a red node means the sensor is obstructed and a green node means it is not .",
    "this corresponds to the the state changes inferred from the incoming live events .",
    "the tool estoreed was used to create this visualisation .",
    "we have presented domain specific constructs for industrial automation in our bespaced modelling and reasoning framework .",
    "furthermore , we presented some specific insights into the formalization of our food processing facility .",
    "this report continues a series of work , where we exemplify and highlight characteristics of our bespaced framework .",
    "we would like to thank ian d. peake , lasith fernando , james harland , huai liu , zoran savic , and yvette wouters as well as our students for supporting us with the formalization work of the factory demonstrator .",
    "jan olaf blech , lasith fernando , keith foster , abhilash g and sudarsan sd .",
    "spatio - temporal reasoning and decision support for smart energy systems .",
    "emerging technologies and factory automation ( etfa ) , ieee , 2016 .",
    "jan olaf blech , ian peake , heinz schmidt , mallikarjun kande , srini ramaswamy , sudarsan sd , venkateswaran narayanan .",
    "collaborative engineering through integration of architectural , social and spatial models .",
    "emerging technologies and factory automation ( etfa ) , ieee , 2014 .",
    "jan olaf blech , ian peake , heinz schmidt , mallikarjun kande , akilur rahman , srini ramaswamy , sudarsan sd , venkateswaran narayanan .",
    "efficient incident handling in indus- trial automation through collaborative engineering .",
    "emerging technologies and factory au- tomation ( etfa ) , ieee , 2015 .",
    "jan olaf blech and heinz schmidt .",
    "towards modeling and checking the spatial and interaction behavior of widely distributed systems . improving systems and software engineering conference , melbourne , 2013 .",
    "jan olaf blech , heinz schmidt .",
    "bespaced : towards a tool framework and methodology for the specification and verification of spatial behavior of distributed software component systems , http://arxiv.org/abs/1404.3537 .",
    "arxiv.org ] , 2014 .",
    "jan olaf blech , maria spichkova , ian peake , heinz schmidt .",
    "cyber - virtual systems : simulation , validation & visualization .",
    "evaluation of novel approaches to software engineering .",
    "lisbon , isbn 978 - 989 - 758 - 030 - 7 , pages 218 - 225 , 2014 .",
    "james harland , jan olaf blech , ian peake , luke trodd .",
    "formal behavioural models to facilitate distributed development and commissioning in industrial automation .",
    "evaluation of novel approaches to software engineering ( enase ) , colaform track , isbn 978 - 989 - 758 - 189 - 2 , pages 363 - 369 , scitepress , 2016 .",
    "peter herrmann , alexander svae , henrik heggelund svendsen , jan olaf blech .",
    "collaborative model - based development of a remote train monitoring system .",
    "evaluation of novel approaches to software engineering , colaform track , 2016 .",
    "simon hordvik , kristoffer seth , jan olaf blech , peter herrmann .",
    "a methodology for model - based development and safety analysis of transport systems .",
    "evaluation of novel approaches to software engineering , 2016 .",
    "frank alexander kraemer , vidar slatten , and peter herrmann .",
    "tool support for the rapid composition , analysis and implementation of reactive services .",
    "journal of systems and software , vol .",
    "82 , issue 12 , pp . 2068 - 2080 , elsevier , 2009 .",
    "ian d. peake , jan olaf blech , edward watkins , stefan greuter , heinz w. schmidt .",
    "the virtual experiences portals  a reconfigurable platform for immersive visualization .",
    "3rd international conference on augmented reality , virtual reality and computer graphics ( salento avr 2016 ) , springer , 2016 .",
    "d. a. randell , z. cui , and a. g. cohn . a spatial logic based on regions and connection . in proceedings of the 3rd international conference on knowledge representation and reasoning ,",
    "pages 165176 , 1992 ."
  ],
  "abstract_text": [
    "<S> this report gives an overview of our efforts towards a formalization for a food processing demonstrator plant . </S>",
    "<S> our bespaced framework is used for the formalization . </S>",
    "<S> the formalization comprises properties of components and relations between components . </S>",
    "<S> we present domain - specific constructs for the formalization of industrial automation facilities and provide some insights into the concrete food processing formalization . </S>",
    "<S> we are particularly interested in spatio - temporal and other physical characteristics . </S>",
    "<S> relationships are formalized as graphs with annotated edges and components are represented as nodes . </S>"
  ]
}