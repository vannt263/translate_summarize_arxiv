{
  "article_text": [
    "the concept of _ computational universality _ is the most important concept in computer science , yet because proofs of universality are very difficult to produce , little is known about the incidence of computational universality among random computer programs , and possible answers to this kind of question depend on the choice of enumeration .",
    "here we undertake a systematic and exhaustive investigation of the reprogramming capabilities of computer programs of fixed and growing sizes under sets of initial conditions that allow the computer programs to behave like other computer programs ( hence as effective compilers ) .    while it is known that questions about general properties of computer programs are not only uncomputable but also not invariant to the choice of enumeration  @xcite , interesting questions and answers arise for natural enumerations .",
    "for example , it is known that if one considers all possible programs of increasing size , most of them will either halt quickly or never halt  @xcite and this has been confirmed numerically  @xcite . here",
    "we explore a related but different question concerning the _ reprogrammability _ of programs that may halt or never halt for specific ( empty ) inputs but that may operate under a restricted domain of possible initial conditions . by constraining the domain of possible initial conditions for a program to operate , such that every initial condition allows the computer program to behave like another program under a transformation ( an effective compiler ) , we then ask how many other computer programs the said computer program can emulate . the question is evidently at the heart of the seminal concept of turing universality .",
    "we study the behavioral and programmability capabilities of the cartesian product @xmath1 , where @xmath2 is the set of all possible computer programs of fixed size and @xmath3 the space of all possible compilers of growing size such that @xmath4 emulates @xmath5 with @xmath6 under a coarse - graining transformation .",
    "we think it is natural ( and more relevant in practice ) to consider the asymptotic density of a set by considering the limit of the proportion of programs of fixed size @xmath7 with the property in question ( reprogrammability / intrinsic universality ) as @xmath7 tends to infinity , in order to avoid the trivializing effects of arbitrarily rearranged ( computable ) enumerations .",
    "we find that if @xmath3 is the ( semi - computable ) set of initial conditions and @xmath8 a compiler of size @xmath9 , the sets of emulating @xmath10 and emulable @xmath11 computer programs ( via cellular automata ) have asymptotic density 1 for growing and fixed program size @xmath7 and increasing compiler size ( initial condition ) @xmath9 .",
    "thus the number of computer programs that can be reprogrammed is of density 1 , suggesting a phenomenon of pervasive intrinsic universality .",
    "time complexity results related to the type of emulation reported here may apply only to the chosen model of computation , given the parallel computing capabilities of cellular automata .",
    "however , without loss of generality regarding intrinsic universality , turing - universality and the reprogramming capabilities of computer programs , we explore the rule space of cellular automata ( ca ) , which is known to be a turing - complete  @xcite model of computation . as any cellular automaton",
    "can be simulated by a 1-dimensional cellular automaton , we only consider 1-dimensional ca  @xcite .",
    "however , for every cellular automaton of size @xmath7 , there is a turing machine proportional to @xmath7 that computes the same function  @xcite , so the phenomenon of pervasive reprogrammability and universality holds , independently of formal model , for fixed or increasing @xmath7 .",
    "the chief advantage of using cellular automata ( ca ) as models of computer programs is that they reveal their behavior in a very visual fashion , in ways that equivalent programs such as turing machines do not due to their sequential nature , making cellular automata transparent to immediate visual inspection and understanding .    while it has been shown that small variations of the model description of cas can effectively and qualitatively modify their behavior ( e.g.  @xcite , by enriching cells with _ memory _ ) , for example , here we found a wide reprogrammability range of computing capabilities without changing the model description , but simply modifying the set of allowed possible inputs . in other words , we effectively reprogrammed a computer program by finding a _ compiler / translator _ that mapped the unrestricted initial condition domain of a ca to a restricted one .",
    "hence , by manipulating initial conditions , we show that even the simplest programs are able to emulate the most complex ones , mediated only by specific choices of initial conditions . by a single initial interaction we effectively reprogram a computer program to behave like any other program .",
    "a _ cellular automaton _ ( ca ) is a tuple @xmath12 with a set @xmath13 of states , a lattice @xmath14 with a binary operation @xmath15 , a neighborhood template @xmath16 , and a local rule @xmath17 .",
    "the _ set of states _",
    "@xmath13 is a finite set with elements @xmath18 taken from a finite alphabet @xmath19 with at least two elements .",
    "it is common to take an alphabet composed of all integers modulo @xmath18 : @xmath20 .",
    "an element of the lattice @xmath21 is called a cell .",
    "the lattice @xmath14 can have @xmath22 dimensions and can be either infinite or finite with cyclic boundary conditions .",
    "the _ neighborhood template _",
    "@xmath23 is a sequence of @xmath14 . in particular ,",
    "the neighborhood of cell @xmath24 is given by adding the cell @xmath24 to each element of the template @xmath16 : @xmath25 .",
    "each cell @xmath24 of the ca is in a particular state @xmath26 \\in s$ ] .",
    "a _ configuration _ of the ca is a function @xmath27 .",
    "the _ set of all possible configurations _ of the ca is defined as @xmath28 .",
    "@xcite    the _ evolution of the ca _ occurs in discrete time steps @xmath29 .",
    "the transition from a configuration @xmath30 at time @xmath31 to the configuration @xmath32 at time @xmath33 is induced by applying the local rule @xmath17 .",
    "the local rule is to be taken as a function @xmath34 which maps the states of the neighborhood cells of time step @xmath31 in the neighborhood template @xmath16 to cell states of the configuration at time step @xmath33 :    @xmath35=f\\left(c_t[i+\\eta_1], ...",
    ",c_t[i+\\eta_m]\\right ) \\ ] ]    the general transition from configuration to configuration is called the _ global map _ and is defined as : @xmath36 .    in the following",
    "we will consider only 1-dimensional ( 1-d ) cas .",
    "the lattice can be either finite , i.e. , @xmath37 , having the length @xmath38 , or infinite , @xmath39 . in the 1-d case it is common to introduce the _ radius _ of the neighborhood template which can be written as @xmath40 and has length @xmath41 cells . with a given radius @xmath42",
    "the local rule is a function @xmath43 with @xmath44 rules .",
    "three cases of 1-d cas will be studied further in this paper .",
    "we study cas which have states taken from the set @xmath45 and have different ranges .",
    "we have cas with range @xmath46 , which have the neighborhood template @xmath47 , meaning that the neighborhood comprises the center cell and one cell to the right .",
    "we will call these _ primitive cellular automata _",
    "( pca , also called _ oneway _ ca ) .",
    "we have the so called _ elementary cellular automata ( eca ) _ with radius @xmath48 ( closest neighbors ) , having the neighborhood template @xmath49 , meaning that the neighborhood is comprised of a central cell , one cell to the left and one to the right .",
    "we also have what we will call _ general cellular automata _ ( gca ) , with radius @xmath0 , i.e. , they have the neighborhood template @xmath50 , meaning that the neighborhood is comprised of the central cell , one cell to the left and two to the right .",
    "the rule space for pcas contains @xmath51 rules , the rule space for ecas contains @xmath52 rules , and the gca rule space contains @xmath53 rules . here",
    "we only consider non - equivalent rules subject to the operations complementation , reflection , conjugation and joint transformation ( reflection and conjugation together ) ( see sup . mat . ) .",
    "for example , the number of reduced rules for eca is 88 . by increasing the range @xmath42 or",
    "the number of states @xmath54 the cardinality of the rule space is increased dramatically .    a cellular automaton at time step @xmath31 @xmath55 is composed of a lattice @xmath56 of cells that can each assume a value from a finite alphabet @xmath57 .",
    "a single cell is referenced as @xmath58 .",
    "the update rule @xmath59 for each time step is defined as @xmath60 with @xmath61 $ ] .",
    "the entire lattice gets updated through the operation @xmath62 .",
    "@xcite      the notion of computational universality used for cellular automata was an adaptation of classical turing - universality  @xcite . a stronger notion called _",
    "intrinsic universality _ was later proposed ( see  @xcite ) .",
    "a ca is intrinsically universal if it is able to simulate any other ca  @xcite .",
    "the exploration of the computing capabilities of ca by _ block emulation _ is a related mechanism by which the scale of space - time diagrams are decomposed into causally disconnected ` light cones ' and then coarse - grained according to an encoding / compiler establishing the emulation of a rule by some other rule under such a translation .",
    "( emulation / simulation ) : let @xmath10 and @xmath11 be two cellular automata",
    ". then @xmath10 emulates / simulates @xmath11 if there exists a rescaling projection ( what we also call a compiler or sometimes a back transformation ) @xmath2 of @xmath10 such that @xmath63 .",
    "notice that the transformation under the compiler is independent of initial conditions , and the emulation is therefore an emulation for every possible initial condition , i.e. a true full system ( ca ) emulation .",
    "this is because cas are decomposed into independent causally disconnected ` light cones ' ( see subfig .",
    "d in fig .",
    "[ fig_emul_diagram ] ) the size of which is determined by the ca neighborhood ( which determines the width ) and the length of the compiler ( which determines the depth ) .",
    "not all decompositions are mutually exclusive . if they were it would mean that the emulated ca is not in the same rule space but in a larger one ( which makes for an interesting question in its own right  the nature and number of emulations that are not in the same rule space and whether they indicate anything about the emulators ) .",
    "in other words , emulation is not closed under coarse - graining transformation .    a cellular automaton @xmath10 is intrinsically universal if , for each cellular automaton @xmath11 , there exists a rescaling / projection @xmath2 of @xmath10 ( given by the reverse transformation of the block emulation ) such that @xmath64 .",
    "intrinsic universality is strictly stronger than turing - universality ; the former implies the latter .",
    "for example , intrinsic universality requires @xmath2-completeness , i.e. a system is intrinsically universal if it simulates all others in polynomial time .",
    "while eca rule 110 is turing - universal  @xcite , no eca is known to be intrinsically universal , including rule 110  @xcite . to prove that a particular 1-dimensional cellular automaton is intrinsically universal ( and therefore turing - universal ) , it is sufficient to prove that it can simulate any other 1-dimensional cellular automaton  @xcite .",
    "our emulations are related to an even stronger form of intrinsic universality , namely _ linear - time intrinsic universality _ , meaning that all emulations only carry a linear overhead as the result of our brute force approximation in the exploration of the compiler and rule spaces .",
    "one can try out different possible compilers / encodings and see what type of cas these encodings are able to emulate ( see sup . mat . for more details )",
    ". it would be highly interesting to find encodings / compilers which would allow one ca to emulate another which has been proven to be universal , but it would also be interesting to find cas with large reprogrammability capabilities that are not known to be universal but that can simulate other cas that are qualitatively very different , thereby making them too natural candidates for intrinsic universality and turing - universality . even though this is impossible to do exhaustively , given that there is an infinite number of possible encodings / compilers for any ca , one can make an assumption of uniformity and derive conclusions from statistical behavior .",
    "here we define a _ linear _ block transformation   @xcite , i.e. , a scheme where the original ca @xmath65 is emulated by a ca @xmath66 through the lattice transformation @xmath67 .",
    "the projection function @xmath68 projects a single cell of the initial condition of ca a to a block of @xmath38 cells , which we call a block. @xmath69 denotes the block - wise application of @xmath2 on the entire lattice @xmath70 .",
    "more generally , one can consider a block transformation @xmath2 of block size @xmath16 acting on an initial condition and then running rule @xmath71 for @xmath72 time steps .",
    "this emulates rule @xmath73 .",
    "in fact , taking only every @xmath16 time step of the result of running @xmath71 for @xmath72 time steps , one gets exactly the output one would if one were to run @xmath73 for @xmath31 time steps on the same initial condition .    in order for ca @xmath71 and projection @xmath2 to provide a successful emulation ( we use simulation interchangeably with emulation ) of ca @xmath74",
    ", they must satisfy the commutativity condition :    @xmath75    the constant @xmath16 is the time scale of the emulation .",
    "in other words , running rule @xmath59 for @xmath16 time steps with the block projected initial condition @xmath76 and projecting the output back with @xmath77 is identical to running the emulated rule @xmath73 for @xmath31 time steps .",
    "flow diagram of the exploration of the program ( rule ) space and compiler spaces . , width=495 ]    flow diagram of a ca emulation :",
    "compiler ( d ) for rule 94 ( a ) to emulate rule 90 ( c ) for any initial condition ( in the example only one is depicted , the simplest black cell ) . at the top",
    "are the rule icons ( source code ) of the 2 ecas .",
    "( f ) block transformation ( h ) coarse - graining ( g ) final emulation computes rule 94 . , width=491 ]    fig .",
    "[ fig_emul_diagram ] demonstrates the emulation process for any initial condition .",
    "here we start , without loss of generality , with the most simple initial condition , e.g. one black cell . by applying rule 94",
    "we let the ca evolve for 10 steps ( a ) .",
    "if , on the other hand , we apply the block transformation @xmath78 and @xmath79 ( b ) to the above initial condition , we get two black cells .",
    "if we then let the transformed initial condition evolve , also with rule 94 but now for 20 steps , we get the space - time diagram of a different ca ( c ) . in this particular case",
    "it amounts to the same thing as eca rule 90 taking one black cell as the initial condition and then evolving for 10 steps ( g ) . to see this better ,",
    "we take the boxed area of ( c ) and highlight every second step ( e ) . extracting these steps",
    "leads to the spacetime diagram given in ( h ) . by applying the back transformation @xmath80 and @xmath81 ( f )",
    "to ( h ) we get eca rule 90 , i.e. the boxed area in ( g ) .",
    "the back transformation is the actual coarse - graining process after the compilers create their output for each emulation step .    in fig .",
    "[ fig_emul_diagram ] ( d ) ( top ) we give an example of a shortest compiler ( all compilers we found include the shortest possible compiler for emulating a specific ca ) , which allows eca rule 94 to emulate eca rule 90 by defining the projection @xmath82",
    ". each represents the encoding of all eight possible inputs of the compiler .",
    "the output comprises the bits for eca rule 90 .",
    "each compilation displays a distinct pattern . in ( e )",
    "we highlight two of the compiler components , effectively showing how the compiler translates cells from eca rule 94 to eca rule 90 .     visualizing ca coarse - graining : space - time diagram of eca rule 94 ( c ) for any initial condition ( in the example",
    "only one is depicted , the simplest black cell ) with compiler components ( a ) identified as supercells ( b ) which are coarse - grained ( d ) to yield the space - time diagram of eca rule 90 ( f ) .",
    ", width=377 ]    in fig .",
    "[ fig_emul_diagram_coarse ] we demonstrate the coarse - graining in more detail for the same initial condition as in fig .  [ fig_emul_diagram ] .",
    "we start with the space - time diagram of rule 94 ( c ) for the initial condition of one black cell as used in fig .",
    "[ fig_emul_diagram ] and then block transform it with @xmath78 and @xmath79 . taking the compiler components ( a ) and identifying the encoding of all eight possible inputs of the compiler as supercells  @xcite",
    "one may understand the compiler to be a mapping of each supercell to one cell , either black or white ( b ) .",
    "combining this with ( c ) one can depict the necessarily overlapping supercells as scales on the space - time of the block transformed ca ( d ) . simply by taking the coarse - grained cells we get the coarse - grained version of eca rule 90 .",
    "emulation is a common technique in proofs for turing - universality .",
    "for example , eca rule 110  @xcite was proven to be universal by finding a `` compiler '' to translate it into a cyclic tag system , another model of computation proven to be universal , which in turn was proven to be universal by finding a `` compiler '' to translate a post - classical ( in this case a 2-)tag system  @xcite .",
    "emulation by coarse - graining in cellular automata ( see e.g.  @xcite ) has led to a stronger definition of universality  @xcite . using these techniques , we proceed by brute force in order to explore the compiler space and the reprogramming capabilities of computer programs in general .",
    "an heuristic method to classify the behavior of computer programs into four qualitatively different classes was introduced by wolfram  @xcite . for eca",
    ", we will use the original wolfram classification .    for gca and the general case other than eca ( unless otherwise specified ) , a candidate complexity class @xmath83 of a cellular automaton @xmath84",
    "can recursively be given by  @xcite :    @xmath85    where @xmath86 is the maximum wolfram class of @xmath84 reached across all inputs @xmath24 ( for an arbitrary enumeration ) up to runtime @xmath31 .",
    "it is therefore clear that @xmath87 is approachable from below .",
    "that is , if @xmath88 and @xmath89 , then @xmath84 belongs to class @xmath90 , where @xmath91 .",
    "@xmath83 introduces a partition , given that a system @xmath18 can not belong to 2 different wolfram classes at the limit .",
    "that is , @xmath92 and @xmath93 . which does not mean one can not misclassify a system for initial values @xmath24 and @xmath31 .",
    "@xmath86 can then be formalized by using a suitable complexity measure , for example , the kolmogorov complexity @xmath94 for initial conditions @xmath24 up to time @xmath31 .",
    "then one takes the maximum or tries to calculate a limit . in practice",
    "this is impossible because @xmath95 is semi - computable , but a lossless compression algorithm implementing an efficient entropy rate can be used as a sufficient test for non - randomness , and therefore a loose upper bound on @xmath95 .",
    "thresholds are then trained to divide @xmath83 into candidate classes @xmath96 with @xmath97 motivated by wolfram s original classes .",
    "the measure , based on the change of the asymptotic size of the compressed evolutions for increasing @xmath24 and @xmath31 , is calculated by following an enumeration of @xmath24 based on a gray - code enumeration , as suggested in  @xcite , to establish a distance metric between initial configurations .",
    "the measure then gauges the resiliency or sensitivity of a system based on its initial conditions .",
    "the phase transition coefficient thus defined led to an interesting characterization and classification of systems , which when applied to elementary ca , yielded precisely wolfram s four classes of system behavior ( with the exception of one borderline case ) .",
    "the coefficient works by compressing the changes of the different evolutions through time , normalized by evolution space .",
    "it has been shown to be an interesting approach to ca behavioral classification questions  @xcite .",
    "@xmath98    the criteria for classifying the asymptotic behavior of the space - time evolution of a computer program , particularly a cellular automaton , are as follows :    classes 1 and 2 : the evolution of the system is highly compressible for any number of steps ;    classes 3 and 4 : the lengths of the compressed evolutions asymptotically converge to the lengths of the uncompressed evolutions .",
    "the question of the asymptotic behavior of a cellular automaton is therefore the question of whether @xmath99 , for complex behavior , or @xmath100 , for simple behavior  @xcite . here",
    "we will use @xmath101 together with block entropy ( see sup . mat . ) to determine the class @xmath83 of a cellular automaton .",
    "if @xmath102 , then @xmath103 ; otherwise @xmath104 , then @xmath105 . however , a numerical approximation of @xmath106 is needed , which means evaluating @xmath107 for a number of initial conditions @xmath24 , following the gray - code numbering scheme as suggested in  @xcite , and for a number of time steps .",
    "we believe that the approach introduced in  @xcite provides a scalable formalization comparable to the original heuristic approach .    here",
    "we use a combination of two ( related ) measures , on the one hand block entropy ( see sup . mat . ) , also identified as the shannon entropy rate , and on the other , a formalization of wolfram s classes based on average compression .",
    "block entropy or the entropy rate of the space - time evolution of a ca is given by :    @xmath108    where @xmath109 is the traditional shannon entropy over @xmath110 blocks after decomposition of the cellular automaton @xmath3 after @xmath31 steps for initial condition @xmath24 .",
    "then we look at the maximum value of @xmath111 for all @xmath38 blocks up to a certain length and set of initial conditions and time steps , which in combination with the average compression , determines the complexity of a ca for the given @xmath31 and @xmath24 , providing an indication of its candidate ( wolfram ) class .      in a dynamical system",
    ", coarse - graining is used to describe large scale structures in the evolution of a system .",
    "this process has been applied to ca before  @xcite . in theory",
    "there are many ways one can define the coarse - graining of a dynamical system such as a ca . here",
    "we follow a definition in  @xcite .",
    "a renormalization scheme is defined where the original ca @xmath71 is coarse - grained by a lattice transformation @xmath67 . in this case the projection function @xmath112 projects the value of a block of @xmath38 cells ( also called a `` supercell ''  @xcite ) in ca @xmath71 to a single cell in ca @xmath74 .",
    "the coarse - graining emulation of ca @xmath71 by ca @xmath74 with the projection @xmath2 only works if the following commutative condition is imposed :    @xmath113    one can now apply this description of coarse - graining to the block emulation procedure described above . applying the projection @xmath2 to ( [ block_emulation_condition ] ) on both sides ,",
    "one obtains    @xmath114    note , ca @xmath59 , ca @xmath73 , and @xmath2 are in principle different from the ones defined for ( [ coarse_grain_condition ] )",
    ". we can now compare ( [ refcoarse_grain_equivalence ] ) with ( [ coarse_grain_condition ] ) and ascertain that it describes the coarse - graining emulation of ca @xmath74 by ca @xmath71 with the projection @xmath2 . in other words , the block emulated ca @xmath74 is a coarse - grained description of the ca @xmath71 transformed with @xmath2 , i.e. , in fig [ fig_emul_diagram ] e. ) is the coarse - grained description of the block transformed ca b. ) .",
    "we start with the pca rule 13 . by defining the projection @xmath115 to random initial conditions @xmath76 , i e. @xmath116 , rule 13",
    "can be made to emulate rule 12 . in this particular case",
    "the block size is 2 and it takes 2 time steps for rule 13 to emulate one lattice entry of rule 12 .",
    "the lattice entry @xmath117 is identical to the lattice entry of rule 12 at @xmath118 if one applies the back projection @xmath119 .",
    "using projection @xmath121 to random initial condition @xmath76 , eca rule 45 can be made to emulate eca rule 15 .",
    "rule 45 emulates rule 15 , which is a high heat ca being programmed to emulate a simple rule .",
    "this was not shown in  @xcite . in  @xcite ,",
    "rule 45 is shown to emulate rule 90 with a time shifted block emulation , which is different from the block emulation used in this paper .",
    "the actual block emulation process of rule 15 by rule 45 shows that rule 45 takes @xmath122 steps in order to reproduce one line of rule 15 .",
    "another example of emulation is the emulation of eca 90 by eca 164 . in this case",
    "the projection is @xmath123 . on applying the projection @xmath2 to random initial condition @xmath76 using rule 164 to evolve the lattice , one obtains as a result an emulation of rule 90",
    "this is especially interesting since rule 164 is a class 2 eca and rule 90 a class 3 eca .",
    "an example is the emulation of gca rule 782 by gca rule 4086 . in this case",
    "the projection is @xmath124 .",
    "on applying the projection @xmath2 to random initial condition @xmath76 using rule 4086 to evolve the lattice , one obtains as a result an emulation of rule 782 .",
    "rule 4086 is more complex than rule 782 , and the emulation is another example of a class emulating another , less complex one , which is very common .",
    "another example of a gca rule emulating an apparently more complex rule is the emulation of gca 4382 by gca 17910 . in this case",
    "the projection is @xmath125 . on applying the projection @xmath2 to random initial condition @xmath76 using rule 17910 to evolve the lattice , one obtains as a result an emulation of rule 4382 .",
    "rule 4382 is more complex than rule 17910 .",
    "this is another example of a `` jumper '' rule , just like eca rule 164 .",
    "an example of a wolfram class 1 gca emulating a class 3 gca is the emulation of gca rule 27030 by gca rule 13960 . in this case",
    "the projection is @xmath126 .",
    "on applying the projection @xmath2 to random initial condition @xmath76 using rule 13960 to evolve the lattice , one obtains an emulation of rule 27030 .",
    "rule 27030 is more complex than rule 13960 , and the emulation is another example of one class emulating another , less complex one , which is very common .    despite the disorganized nature of class 3 rules",
    ", they also display a wide range of reprogramming capabilities , being able to compute and behave in an orderly fashion , as , for example , class 2 or 4 rules . fig .",
    "[ fig_cross_class ] , shows how class 3 rules can be reprogrammed to emulate not only other class 3 rules but also class 4 rules .",
    "hence they can not be overlooked as candidates for turing - universality on the grounds that they seem difficult to control , as this uncontrollability is only apparent .",
    "an example of a wolfram class 1 emulating a wolfram class 3 gca is the emulation of gca rule 6696 by gca rule 27030 . in this case",
    "the projection is again @xmath127 .",
    "applying the projection @xmath2 to random initial condition @xmath76 using rule 6696 to evolve the lattice , one obtains an emulation of rule 27030 .",
    "rule 6696 is much less complex than rule 13960 , and the emulation is an example of one class emulating another , more complex rule .",
    "an example of an intra - class 4 emulation is the emulation of gca 2966 by eca 25542 . in this case",
    "the projection is @xmath124 .",
    "applying the projection @xmath2 to random initial condition @xmath76 using rule 2966 to evolve the lattice , one obtains an emulation of rule 25542 .",
    "this is interesting , since both rules 2966 and 25542 are class 4 eca rules .",
    "the depth of the  compiler \" ( or length of block encoding ) provides the time complexity overhead of the simulation .",
    "for example , in fig .",
    "[ fig_mass2 ] , rule 54 requires 7 time steps to emulate every time step of rule 51 , and the time complexity overhead of the simulation with respect to the simulated is @xmath128 .",
    "this also means that the block transformation to obtain the actual computation of the simulated from the simulating rule has to take the coarse - grained version of the latter and every other 7 steps . in this way",
    "one can obtain the exact output of the simulated rule .",
    "cross - boundary _ circos _ plots showing emulating and emulated rules in different qualitative classes .",
    "each square represents a complexity class .",
    "ecas were classified according to their consensus wolfram classes , while gcas where classified by compressibility , taking 3 clusters based on the euclidian distance of the compressibility index .",
    "eca rules ( left ) can emulate almost any other rule except class 4 , which is isolated , but in gca space ( right ) , all rule classes can be emulated by all other rules , though low ( l ) rules can not emulate high ( h ) rules .",
    "a table with specific examples is provided in the sup . mat .",
    "and the full list is available in csv format at https://github.com/algorithmicnature/reprogrammingcapabilitiesofcas.,title=\"fig:\",width=170 ]   cross - boundary _ circos _ plots showing emulating and emulated rules in different qualitative classes .",
    "each square represents a complexity class .",
    "ecas were classified according to their consensus wolfram classes , while gcas where classified by compressibility , taking 3 clusters based on the euclidian distance of the compressibility index .",
    "eca rules ( left ) can emulate almost any other rule except class 4 , which is isolated , but in gca space ( right ) , all rule classes can be emulated by all other rules , though low ( l ) rules can not emulate high ( h ) rules .",
    "a table with specific examples is provided in the sup . mat .",
    "and the full list is available in csv format at https://github.com/algorithmicnature/reprogrammingcapabilitiesofcas.,title=\"fig:\",width=170 ]      while we consider how many times a rule is emulated a measure of its complexitywhich is deeply related to its kolmogorov complexity by way of algorithmic probability  we also consider how many other programs a given computer program can emulate up to a certain compiler size , treating this number as a measure indicating its likelihood of turing - universality .",
    "the results reported here provide strong evidence on all counts , even if for item 2 only a relatively small set ( despite being huge in absolute numbers ) of computer program and compiler pairs can be explored .",
    "distributions of emulating and emulated gca rules of varying complexity , showing that ( 1 ) emulating rules emulate non - trivial rules covering the full range of possible behaviors ( emulating rules emulate all classes of complexity into which gca were divided by compressibility and entropy ) and ( 2 ) the more complex the rule the greater the programmability ( there is a short compiler to carry the emulations).,width=472 ]    on the one hand , among eca almost all rules emulate at least one other rule , almost all of them emulate at least 2 wolfram classes , and 3 rules ( 26 , 94 , 164 ) emulate 3 different wolfram classes ( see table  [ morecas ] ) .",
    "it is worth noting that the number of native low complexity rules exponentially decays  @xcite and is therefore one of the reasons for the lack of emulation in the first panel . in other words ,",
    "the fact that native high complexity rules dominate higher rule spaces strengthens the pervasive programmability and hence the pervasive universality hypothesis .",
    "on the other hand , fig .",
    "[ mainb ] , shows that in gca , almost all rules emulate at least one other complexity class , and that among high complexity rules there are around 500 multi - emulating rules ( more than 3% ) that emulate 2 different complexity classes .",
    "[ maina ] show that among the emulators in eca and gca , each emulates on average ( for all classes ) a larger fraction of other rules as a function of compiler size .",
    "plots for eca and gca for collapsed ( only differently emulated ) and non - collapsed cases ( counting repetitions of emulations ) show that all frequencies do increase in linear fashion",
    ".    collapsed + * ecagca *   frequency counts for collapsed and non - collapsed cases .",
    "( @xmath129-axis block size and y - axis @xmath130 average of emulation frequency per ca class ( eca for wolfram classes and gca divided into low and high complexity ) .",
    "for the collapsed case ( i.e. distinct frequencies not considering different encodings per block size ) the data is not enough .",
    "however , for non - collapsed eca and both collapsed and non - collapsed gca , the average increase of non - trivial reprogrammability per rule is confirmed.,title=\"fig:\",width=207 ]   frequency counts for collapsed and non - collapsed cases .",
    "( @xmath129-axis block size and y - axis @xmath130 average of emulation frequency per ca class ( eca for wolfram classes and gca divided into low and high complexity ) .",
    "for the collapsed case ( i.e. distinct frequencies not considering different encodings per block size ) the data is not enough .",
    "however , for non - collapsed eca and both collapsed and non - collapsed gca , the average increase of non - trivial reprogrammability per rule is confirmed.,title=\"fig:\",width=207 ] + non - collapsed + * ecagca *   frequency counts for collapsed and non - collapsed cases .",
    "( @xmath129-axis block size and y - axis @xmath130 average of emulation frequency per ca class ( eca for wolfram classes and gca divided into low and high complexity ) .",
    "for the collapsed case ( i.e. distinct frequencies not considering different encodings per block size ) the data is not enough .",
    "however , for non - collapsed eca and both collapsed and non - collapsed gca , the average increase of non - trivial reprogrammability per rule is confirmed.,title=\"fig:\",width=215 ]   frequency counts for collapsed and non - collapsed cases .",
    "( @xmath129-axis block size and y - axis @xmath130 average of emulation frequency per ca class ( eca for wolfram classes and gca divided into low and high complexity ) . for the collapsed case ( i.e. distinct frequencies not considering different encodings per block size )",
    "the data is not enough .",
    "however , for non - collapsed eca and both collapsed and non - collapsed gca , the average increase of non - trivial reprogrammability per rule is confirmed.,title=\"fig:\",width=200 ]    finally , fig .",
    "[ main ] shows that the rule space together with the compiler space saturates the number of ( non - trivial ) emulations in the rule space , and that the larger the rule space the greater the number of emulating and emulated rules , thereby suggesting a path toward ubiquitous intrinsic universality and hence turing - universal computation for even the smallest rule spaces and for the simplest rules , with the exception of the set of most trivial rules ( e.g. rule 0 and rule 255 in eca ) that is shown to remain constant as a function of growing rule spaces and is therefore asymptotically negligible and effectively of size 0 .",
    "other rules , such as the linear ones , can be proven not to be intrinsically universal  @xcite , yet they seem to remain low in number as compared to both the growing number of emulators and the growing number of emulating rules per emulator in larger spaces .    as seen in fig .",
    "[ main ] , almost all eca rules are capable of being reprogrammed to behave like some other rule , showing the wide range of computing capabilities of the rule space up to the explored compiler size 15 , with this range asymptotically showing 100% of the rules being able to emulate some other rule .",
    "most rules emulate more than one other rule and with more than one compiler .",
    "gca rules continue generating emulating rules beyond compiler size 12 . while the fraction of possible emulations is small when considering the huge rule @xmath15 compiler pair combinatorial space ( on @xmath131 axis , right plot ) , the plot on the right provides statistical evidence that the number of emulations ( including all compilers that emulate rules emulated previously ) grows and that the larger the rule space ( gca ) the faster the potential convergence . a more fine grained version of these results is shown in  [ fig_emulfreq ] .",
    "asymptotic intrinsic universality and turing universality .",
    "accumulated rules that can be reprogrammed to behave like at least one other ( non - trivial ) rule in the same rule space with a compiler up to size 15 ( eca ) and 12 ( gca ) . all class 3 and 4 emulating rules in eca , that is , 9 rules representing almost 10% of the number of essential rules in eca , are emulators of a rule not in class 1 or 2 in the same rule space and with even smaller compilers ( hence the constant behavior ) .",
    "non - trivial emulating gcas of medium complexity grow asymptotically , just as in all other cases , strongly indicating reprogramming capabilities rapidly saturating every rule space , even for the smallest and simplest rule and compiler combinations ( evidently trivial rules like eca rule 0 and 255 will never be reprogrammed but they are effectively of size 0).,width=370 ]    while almost all eca rules emulate some other non - trivial eca ( including class 2 emulating class 3 rules ) , no class 4 eca was emulated .",
    "however , among gca , both medium high ( equivalent to class 4 ) and lowest high complexity rules emulated all other rule complexity cases , including a class 1 emulating a class 3 , a class 2 emulating class 3 and 4 , a class 3 emulating 3 and 4 , and class 4 emulating all others , including class 3 and other class 4 rules .",
    "i.e. , all gcas emulated all other complexity classes , except for class 1 , which did not emulate class 4 .",
    ".[morecas ] there are 3 ecas of medium compressibility ( at least wolfram class 2 ) that emulate more than 2 different complexity classes ( all cases , low , medium and high uncompressibility ) .",
    "likewise , in the ca space there are 781 emulators of at least one other ca in each of the 3 complexity classes ( low , medium and high ) , 237 of them are of medium compressibility themselves , and 544 of high uncompressibility .",
    "thus , the more complex the more likely they are to be able to emulate rules in different complexity classes .",
    "[ cols=\">,^,^\",options=\"header \" , ]"
  ],
  "abstract_text": [
    "<S> we consider the problem of finding a reasonable framework to ask the question of estimating the density of turing universality and the reprogramming capabilities of random computer programs . by means of a natural enumeration and based upon the concept of _ intrinsic universality _ , we provide strong evidence of ubiquitous turing - universality under a compiler space based on rescaling computation and coarse - graining emulation . </S>",
    "<S> we show a series of boundary crossing results , including instances of emulation ( in all cases for all initial conditions ) of wolfram class 2 elementary cellular automata ( eca ) by class 1 eca , classes 2 and 3 eca emulating classes 1 , 2 and 3 , and class 3 eca emulating classes 1 , 2 and 3 , along with results of a similar type for general ca ( neighborhood @xmath0 ) , including class 1 ca emulating classes 2 and 3 , classes 3 and 4 emulating all other classes ( 1 , 2 , 3 and 4 ) . </S>",
    "<S> we also found that there is no possible hacking strategy with which to compress the search space based on compiler complexity or compiler similarity . </S>",
    "<S> + * keywords : * coarse graining computing ; rescaling ; cellular automata ; intrinsic universality ; sensitivity ; computer simulation ; reprogrammability ; causality ; turing - universality ; controllability .    </S>",
    "<S> pacs numbers : 05.45.-a </S>"
  ]
}