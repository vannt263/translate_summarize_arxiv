{
  "article_text": [
    "this paper is a companion technical report to the article `` continuation - passing c : from threads to events through continuations '' @xcite .",
    "it contains the complete version of the proofs presented in the article .",
    "it does not , however , give any background or motivation for our work : please refer to the original article .",
    "to prove the correctness of lambda - lifting in an imperative , call - by - value language when functions are called in tail position , we do not reason directly on cpc programs , because the semantics of c is too broad and complex for our purposes .",
    "the cpc translator leaves most parts of converted programs intact , transforming only control structures and function calls .",
    "therefore , we define a simple language with restricted values , expressions and terms , that captures the features we are most interested in ( section  [ sec : definitions ] ) .    the reduction rules for this language ( section  [ sec : naive - def ] ) use a simplified memory model without pointers and enforce that local variables are not accessed outside of their scope , as ensured by our boxing pass .",
    "this is necessary since lambda - lifting is not correct in general in the presence of extruded variables .",
    "it turns out that the `` naive '' reduction rules defined in section  [ sec : naive - def ] do not provide strong enough invariants to prove this correctness theorem by induction , mostly because we represent memory with a store that is not invariant with respect to lambda - lifting .",
    "therefore , in section  [ sec : semopt ] , we define an equivalent , `` optimised '' set of reduction rules which enforces more regular stores and closures .    the proof of correctness is then carried out in section  [ sec : correction - ll ] using these optimised rules .",
    "we first define the invariants needed for the proof and formulate a strengthened version of the correctness theorem ( theorem  [ thm : correction - ll ] , section  [ sec : strong - invariants ] ) . a comprehensive overview of the proof is then given in section  [ sec : overview ] .",
    "the proof is fully detailed in section  [ sec : proof - correctness ] , with the help of a number of lemmas to keep the main proof shorter ( sections  [ sec : rewriting - lemmas ] and  [ sec : aliasing - lemmas ] ) .",
    "the main limitation of this proof is that theorems  [ thm : lambda - lifting - correctness ] and  [ thm : correction - ll ] are implications , not equivalences : we do not prove that if a term does not reduce , it will not reduce once lifted .",
    "for instance , this proof does not ensure that lambda - lifting does not break infinite loops .      in this section",
    ", we define the terms ( definition  [ def : full - language ] ) , the reduction rules ( section  [ sec : naive - def ] ) and the lambda - lifting transformation itself ( section  [ sec : lifting - def ] ) for our small imperative language . with these preliminary definitions , we are then able to characterise _ liftable parameters _ ( definition  [ dfn : var - liftable - simple ] ) and state the main correctness theorem ( theorem  [ thm : lambda - lifting - correctness ] , section  [ sec : correctness ] ) .",
    "[ def : full - language ]    values are either boolean and integer constants or @xmath0 , a special value for functions returning ` void ` .",
    "@xmath1    expressions are either values or variables .",
    "we deliberately omit arithmetic and boolean operators , with the sole concern of avoiding boring cases in the proofs .",
    "@xmath2    terms are consist of assignments , conditionals , sequences , recursive functions definitions and calls .",
    "our language focuses on the essential details affected by the transformations : recursive functions , conditionals and memory accesses .",
    "loops , for instance , are ignored because they can be expressed in terms of recursive calls and conditional jumps  and that is , in fact , how the splitting pass translates them .",
    "since lambda - lifting happens after the splitting pass , our language need to include inner functions ( although they are not part of the c language ) , but it can safely exclude ` goto ` statements .      [ [ environments - and - stores ] ] environments and stores + + + + + + + + + + + + + + + + + + + + + + +    handling inner functions requires explicit closures in the reduction rules .",
    "we need environments , written @xmath4 , to bind variables to locations , and a store , written @xmath5 , to bind locations to values .",
    "_ environments _ and _ stores _ are partial functions , equipped with a single operator which extends and modifies a partial function : @xmath6 .",
    "the modification ( or extension ) @xmath7 of a partial function @xmath8 , written @xmath9 , is defined as follows : @xmath10    environments of variables are defined inductively by @xmath11 i.e.  the empty domain function and @xmath12 ( respectively ) .",
    "environments of functions associate function names to closures : @xmath13}}\\}.\\ ] ]    note that although we have a notion of locations , which correspond roughly to memory addresses in c , there is no way to copy , change or otherwise manipulate a location directly in the syntax of our language .",
    "this is on purpose , since adding this possibility would make lambda - lifting incorrect : it translates the fact , ensured by the boxing pass in the cpc translator , that there are no extruded variables in the lifted terms .",
    "[ [ reduction - rules ] ] reduction rules + + + + + + + + + + + + + + +    we use classical big - step reduction rules for our language ( figure  [ sem - proof : naive ] , p.  ) .    @xmath14 { } { { \\ensuremath{v^{\\,s }    \\naivearrow[{\\ensuremath{\\mathcal{f}}}]{\\rho } v^{\\,s } } } } \\qquad\\qquad    \\inferrule*[left=(var)]{\\rho\\ x = l \\in { \\mathop{\\mathrm{dom}}\\nolimits}\\ s}{{\\ensuremath{x^{\\,s }    \\naivearrow[{\\ensuremath{\\mathcal{f}}}]{\\rho }",
    "s\\ l^{\\,s}}}}\\\\    \\inferrule*[left=(assign)]{{\\ensuremath{a^{\\,s }    \\naivearrow[{\\ensuremath{\\mathcal{f}}}]{\\rho } v^{\\,s ' } } } \\\\      \\rho\\ x = l \\in { \\mathop{\\mathrm{dom}}\\nolimits}\\ s'}{\\      { \\ensuremath{x { \\vcentcolon\\mkern-1.2mu=}a^{\\,s }    \\naivearrow[{\\ensuremath{\\mathcal{f}}}]{\\rho } { \\ensuremath{\\mathbf{1}}}^{\\,{{\\ensuremath{s ' + \\{l\\mapstov\\ } } } } } } } } \\qquad\\qquad    \\inferrule*[left=(seq)]{{\\ensuremath{a^{\\,s }    \\naivearrow[{\\ensuremath{\\mathcal{f}}}]{\\rho } v^{\\,s ' } } } \\\\ { \\ensuremath{b^{\\,s ' }    \\naivearrow[{\\ensuremath{\\mathcal{f}}}]{\\rho } v'^{\\,s''}}}}{{\\ensuremath{a\\ ; \\",
    "b^{\\,s }    \\naivearrow[{\\ensuremath{\\mathcal{f}}}]{\\rho } v'^{\\,s''}}}}\\\\    \\inferrule*[left=(if - t.)]{{\\ensuremath{a^{\\,s }    \\naivearrow[{\\ensuremath{\\mathcal{f}}}]{\\rho } { \\ensuremath{\\mathop{\\mathbf{true}}\\nolimits}}^{\\,s ' } } } \\\\ { \\ensuremath{b^{\\,s ' }    \\naivearrow[{\\ensuremath{\\mathcal{f}}}]{\\rho } v^{\\,s''}}}}{\\      { \\ensuremath{{\\ensuremath{\\mathop{\\mathbf{if}}\\ a\\   \\mathop{\\mathbf{then}}\\ b\\ \\mathop{\\mathbf{else}}\\ c}}^{\\,s }    \\naivearrow[{\\ensuremath{\\mathcal{f}}}]{\\rho } v^{\\,s''}}}}\\qquad\\qquad    \\inferrule*[left=(if - f.)]{{\\ensuremath{a^{\\,s }    \\naivearrow[{\\ensuremath{\\mathcal{f}}}]{\\rho } { \\ensuremath{\\mathop{\\mathbf{false}}\\nolimits}}^{\\,s ' } } } \\\\ { \\ensuremath{c^{\\,s ' }    \\naivearrow[{\\ensuremath{\\mathcal{f}}}]{\\rho } v^{\\,s''}}}}{\\      { \\ensuremath{{\\ensuremath{\\mathop{\\mathbf{if}}\\ a\\   \\mathop{\\mathbf{then}}\\ b\\ \\mathop{\\mathbf{else}}\\ c}}^{\\,s }    \\naivearrow[{\\ensuremath{\\mathcal{f}}}]{\\rho } v^{\\,s''}}}}\\\\    \\inferrule*[left=(letrec)]{\\      { \\ensuremath{b^{\\,s }    \\naivearrow[\\mathcal{f'}]{\\rho } v^{\\,s ' } } } \\\\\\\\      \\mathcal{f'}={\\ensuremath{{\\ensuremath{\\mathcal{f}}}+ \\{f\\mapsto{\\ensuremath{\\left[\\lambda{\\ensuremath{x_{1}\\dotscx_{n}}}.a,\\rho,{\\ensuremath{\\mathcal{f}}}\\right]}}\\ } } }     } { \\      { \\ensuremath{{\\ensuremath{\\mathop{\\mathbf{letrec}}\\ f({\\ensuremath{x_{1}\\dotscx_{n}}})=a\\    \\mathop{\\mathbf{in}}\\ b}}^{\\,s }    \\naivearrow[{\\ensuremath{\\mathcal{f}}}]{\\rho } v^{\\,s'}}}}\\\\    \\inferrule*[left=(call)]{\\ { \\ensuremath{\\mathcal{f}}}\\,f = { \\ensuremath{\\left[\\lambda{\\ensuremath{x_{1}\\dotscx_{n}}}.b,\\rho',\\mathcal{f'}\\right]}}\\\\ \\rho''= { \\ensuremath{(x_{1},l_{1}){\\cdot}\\dotsc{\\cdot}(x_{n},l_{n})}}\\\\ \\text{$l_{i}$ fresh and distinct}\\\\\\\\ \\forall i,{\\ensuremath{a_i^{\\,s_i }    \\naivearrow[{\\ensuremath{\\mathcal{f}}}]{\\rho } v_i^{\\,s_{i+1 } } } } \\\\ { \\ensuremath{b^{\\,{\\ensuremath{s_{n+1 } + \\{l_i\\mapstov_i\\ } } } }    \\naivearrow[{\\ensuremath{\\mathcal{f ' } + \\{f\\mapsto{\\ensuremath{\\mathcal{f}}}\\,f\\ } } } ] { \\rho''{\\cdot}\\rho ' } v^{\\,s ' } } } } { \\ { \\ensuremath{f({\\ensuremath{a_{1}\\dotsca_{n}}})^{\\,s_{1 } }    \\naivearrow[{\\ensuremath{\\mathcal{f}}}]{\\rho } v^{\\,s'}}}}\\end{gathered}\\ ] ]    in the ( call )",
    "rule , we need to introduce _ fresh _ locations for the parameters of the called function .",
    "this means that we must choose locations that are not already in use , in particular in the environments @xmath15 and @xmath16 . to express this choice , we define two ancillary functions , @xmath17 and @xmath18 , to extract the environments and locations contained in the closures of a given environment of functions @xmath16 .",
    "@xmath19 } } \\in    { \\mathop{\\mathrm{im}}\\nolimits}({\\ensuremath{\\mathcal{f } } } ) , \\rho ' \\in { \\mathop{\\mathrm{env}}\\nolimits}(\\mathcal{f'})\\right\\}\\ ] ] @xmath20 @xmath21    these functions allow us to define fresh locations .    in the ( call ) rule ,",
    "a location is _ fresh _ when :    * @xmath22 , i.e.  @xmath23 is not already used in the store before the body of @xmath8 is evaluated , and * @xmath23 does nt appear in @xmath24 , i.e. @xmath23 will not interfere with locations captured in the environment of functions .",
    "note that the second condition implies in particular that @xmath23 does not appear in either @xmath16 or @xmath15 .",
    "lambda - lifting can be split into two parts : parameter lifting and block floating@xcite .",
    "we will focus only on the first part here , since the second one is trivial .",
    "parameter lifting consists in adding a free variable as a parameter of every inner function where it appears free .",
    "this step is repeated until every variable is bound in every function , and closed functions can safely be floated to top - level .",
    "note that although the transformation is called lambda - lifting , we do not focus on a single function and try to lift all of its free variables ; on the contrary , we define the lifting of a single free parameter @xmath25 in every possible function .",
    "smart lambda - lifting algorithms strive to minimize the number of lifted variables .",
    "such is not our concern in this proof : parameters are lifted in every function where they might potentially be free .",
    "[ dfn : lifted - term ] assume that @xmath25 is defined as a parameter of a given function @xmath26 , and that every inner function in @xmath26 is called @xmath27 ( for some @xmath28 ) .",
    "also assume that function parameters are unique before lambda - lifting .",
    "then the _ lifted form _",
    "@xmath29 of the term @xmath30 with respect to @xmath25 is defined inductively as follows : @xmath31      we show that parameter lifting is correct for variables defined in functions whose inner functions are called exclusively in _ tail position_.",
    "we call these variables _ liftable parameters_.",
    "we first define tail positions as usual @xcite :    _ tail positions _ are defined inductively as follows :    1 .",
    "@xmath30 and @xmath32 are in tail position in @xmath33 .",
    "@xmath32 is in tail position in @xmath32 and @xmath34 and @xmath35 .",
    "a parameter @xmath25 defined in a function @xmath26 is liftable if every inner function in @xmath26 is called exclusively in tail position .",
    "[ dfn : var - liftable - simple ] a parameter @xmath25 is _ liftable _ in @xmath30 when :    * @xmath25 is defined as the parameter of a function @xmath26 , * inner functions in @xmath26 , named @xmath27 , are called exclusively in tail position in @xmath26 or in one of the @xmath27 .    our main theorem states that performing parameter - lifting on a liftable parameter preserves the reduction :    [ thm : lambda - lifting - correctness ] if @xmath25 is a liftable parameter in @xmath30 , then @xmath36{\\varepsilon } v^{\\,t } } } \\text { implies } \\exists t ' , { \\ensuremath{{\\ensuremath{\\mathop{(m)}\\nolimits_{\\ast}}}^{\\,\\varepsilon }    \\naivearrow[\\varepsilon]{\\varepsilon } v^{\\,t'}}}.\\ ] ]    note that the resulting store @xmath37 changes because lambda - lifting introduces new variables , hence new locations in the store , and changes the values associated with lifted variables ; section  [ sec : correction - ll ] is devoted to the proof of this theorem . to maintain invariants during the proof , we need to use an equivalent ,",
    "`` optimised '' set of reduction rules ; it is introduced in the next section .",
    "the naive reduction rules ( section  [ sec : naive - def ] ) are not well - suited to prove the correctness of lambda - lifting .",
    "indeed , the proof is by induction and requires a number of invariants on the structure of stores and environments . rather than having a dozen of lemmas to ensure these invariants during the proof of correctness , we translate them as constraints in the reduction rules .    to this end , we introduce two optimisations  minimal stores ( section  [ sec : mini - store ] ) and compact closures ( section  [ sec : compact - closures ] )  which lead to the definition of an optimised set of reduction rules ( figure  [ sem - proof : opt ] , section  [ sec : opt - rules ] ) .",
    "the equivalence between optimised and naive reduction rules is shown in section  [ sec : sem - equiv ] .      in the naive reduction rules",
    ", the store grows faster when reducing lifted terms , because each function call adds to the store as many locations as it has function parameters .",
    "this yields stores of different sizes when reducing the original and the lifted term , and that difference can not be accounted for locally , at the rule level .",
    "consider for instance the simplest possible case of lambda - lifting : @xmath38 at the end of the reduction , the store for the original term is @xmath39 whereas the store for the lifted term is @xmath40 .",
    "more complex terms would yield even larger stores , with many out - of - date copies of lifted variables .    to keep the store under control , we need to get rid of useless variables as soon as possible during the reduction .",
    "it is safe to remove a variable @xmath25 from the store once we are certain that it will never be used again , i.e.  as soon as the term in tail position in the function which defines @xmath25 has been evaluated .",
    "this mechanism is analogous to the deallocation of a stack frame when a function returns .    to track the variables whose location can be safely reclaimed after the reduction of some term @xmath30",
    ", we introduce _",
    "split environments_. split environments are written @xmath41 , where @xmath42 is called the _ tail environment _ and @xmath4 the non - tail one ; only the variables belonging to the tail environment may be safely reclaimed .",
    "the reduction rules build environments so that a variable @xmath25 belongs to @xmath42 if and only if the term @xmath30 is in tail position in the current function @xmath8 and @xmath25 is a parameter of @xmath8 . in that case",
    ", it is safe to discard the locations associated to all of the parameters of @xmath8 , including @xmath25 , after @xmath30 has been reduced because we are sure that the evaluation of @xmath8 is completed ( and there are no first - class functions in the language to keep references on variables beyond their scope of definition ) .",
    "we also define a _ cleaning _ operator , @xmath43 , to remove a set of variables from the store .",
    "the store @xmath5 cleaned with respect to the variables in @xmath4 , written @xmath44 , is defined as @xmath45 .",
    "another source of complexity with the naive reduction rules is the inclusion of useless variables in closures .",
    "it is safe to remove from the environments of variables contained in closures the variables that are also parameters of the function : when the function is called , and the environment restored , these variables will be hidden by the freshly instantiated parameters .",
    "this is typically what happens to lifted parameters : they are free variables , captured in the closure when the function is defined , but these captured values will never be used since calling the function adds fresh parameters with the same names .",
    "we introduce _ compact closures _ in the optimised reduction rules to avoid dealing with this hiding mechanism in the proof of lambda - lifting .",
    "a compact closure is a closure that does not capture any variable which would be hidden when the closure is called because of function parameters having the same name .",
    "a closure @xmath46}}$ ] is _ compact _ if @xmath47 and @xmath48 is compact .",
    "an environment is _ compact _ if it contains only compact closures .",
    "we define a canonical mapping from any environment @xmath16 to a compact environment @xmath49 , restricting the domains of every closure in @xmath16 .    the _ canonical compact environment _ @xmath49 is the unique environment with the same domain as @xmath16 such that @xmath50}}\\\\      \\text{implies } { { \\ensuremath{\\mathcal{f}}}_{*}}\\ f & =      { \\ensuremath{\\left[\\lambda{\\ensuremath{x_{1}\\dotscx_{n}}}.m,\\rho|_{{\\mathop{\\mathrm{dom}}\\nolimits}(\\rho)\\setminus\\{{\\ensuremath{x_{1}\\dotscx_{n}}}\\}},{\\mathcal{f'}_{*}}\\right]}}.    \\end{aligned}\\ ] ]      combining both optimisations yields the _ optimised _ reduction rules ( figure  [ sem - proof : opt ] , p.  ) , used section  [ sec : correction - ll ] for the proof of lambda - lifting .",
    "we ensure minimal stores by cleaning them in the ( val ) , ( var ) and ( assign ) rules , which correspond to tail positions ; split environments are introduced in the ( call ) rule to distinguish fresh parameters , to be cleaned , from captured variables , which are preserved .",
    "tail positions are tracked in every rule through split environments , to avoid cleaning variables too early , in a non - tail branch .",
    "we also build compact closures in the ( letrec ) rule by removing the parameters of @xmath8 from the captured environment @xmath15 .",
    "@xmath14 { } { { \\ensuremath{v^{\\,s }    \\optarrow[{\\ensuremath{\\mathcal{f}}}]{{\\ensuremath{{\\ensuremath{{\\rho_{t}}}}|\\rho } } } v^{\\,{s \\setminus { \\ensuremath{{\\rho_{t}}}}}}}}}\\qquad\\qquad    \\inferrule*[left=(var)]{{\\ensuremath{{\\rho_{t}}}}{\\cdot}\\rho\\ x = l \\in { \\mathop{\\mathrm{dom}}\\nolimits}\\ s}{{\\ensuremath{x^{\\,s }    \\optarrow[{\\ensuremath{\\mathcal{f}}}]{{\\ensuremath{{\\ensuremath{{\\rho_{t}}}}|\\rho } } } s\\ l^{\\,{s \\setminus { \\ensuremath{{\\rho_{t}}}}}}}}}\\\\    \\inferrule*[left=(assign)]{{\\ensuremath{a^{\\,s }    \\optarrow[{\\ensuremath{\\mathcal{f}}}]{{\\ensuremath{|{\\ensuremath{{\\rho_{t}}}}{\\cdot}\\rho } } } v^{\\,s ' } } } \\\\      { \\ensuremath{{\\rho_{t}}}}{\\cdot}\\rho\\ x = l \\in { \\mathop{\\mathrm{dom}}\\nolimits}\\ s'}{\\      { \\ensuremath{x { \\vcentcolon\\mkern-1.2mu=}a^{\\,s }    \\optarrow[{\\ensuremath{\\mathcal{f}}}]{{\\ensuremath{{\\ensuremath{{\\rho_{t}}}}|\\rho } } } { \\ensuremath{\\mathbf{1}}}^{\\,{{{\\ensuremath{s ' + \\{l\\mapstov\\ } } } } \\setminus { \\ensuremath{{\\rho_{t}}}}}}}}}\\qquad\\qquad    \\inferrule*[left=(seq)]{{\\ensuremath{a^{\\,s }    \\optarrow[{\\ensuremath{\\mathcal{f}}}]{{\\ensuremath{|{\\ensuremath{{\\rho_{t}}}}{\\cdot}\\rho } } } v^{\\,s ' } } } \\\\ { \\ensuremath{b^{\\,s ' }    \\optarrow[{\\ensuremath{\\mathcal{f}}}]{{\\ensuremath{{\\ensuremath{{\\rho_{t}}}}|\\rho } } } v'^{\\,s''}}}}{{\\ensuremath{a\\ ; \\ b^{\\,s }    \\optarrow[{\\ensuremath{\\mathcal{f}}}]{{\\ensuremath{{\\ensuremath{{\\rho_{t}}}}|\\rho } } } v'^{\\,s''}}}}\\\\    \\inferrule*[left=(if - t.)]{{\\ensuremath{a^{\\,s }    \\optarrow[{\\ensuremath{\\mathcal{f}}}]{{\\ensuremath{|{\\ensuremath{{\\rho_{t}}}}{\\cdot}\\rho } } } { \\ensuremath{\\mathop{\\mathbf{true}}\\nolimits}}^{\\,s ' } } } \\\\ { \\ensuremath{b^{\\,s ' }    \\optarrow[{\\ensuremath{\\mathcal{f}}}]{{\\ensuremath{{\\ensuremath{{\\rho_{t}}}}|\\rho } } } v^{\\,s''}}}}{\\      { \\ensuremath{{\\ensuremath{\\mathop{\\mathbf{if}}\\ a\\   \\mathop{\\mathbf{then}}\\ b\\ \\mathop{\\mathbf{else}}\\ c}}^{\\,s }    \\optarrow[{\\ensuremath{\\mathcal{f}}}]{{\\ensuremath{{\\ensuremath{{\\rho_{t}}}}|\\rho } } } v^{\\,s''}}}}\\qquad\\qquad    \\inferrule*[left=(if - f.)]{{\\ensuremath{a^{\\,s }    \\optarrow[{\\ensuremath{\\mathcal{f}}}]{{\\ensuremath{|{\\ensuremath{{\\rho_{t}}}}{\\cdot}\\rho } } } { \\ensuremath{\\mathop{\\mathbf{false}}\\nolimits}}^{\\,s ' } } } \\\\ { \\ensuremath{c^{\\,s ' }    \\optarrow[{\\ensuremath{\\mathcal{f}}}]{{\\ensuremath{{\\ensuremath{{\\rho_{t}}}}|\\rho } } } v^{\\,s''}}}}{\\      { \\ensuremath{{\\ensuremath{\\mathop{\\mathbf{if}}\\ a\\   \\mathop{\\mathbf{then}}\\ b\\ \\mathop{\\mathbf{else}}\\ c}}^{\\,s }    \\optarrow[{\\ensuremath{\\mathcal{f}}}]{{\\ensuremath{{\\ensuremath{{\\rho_{t}}}}|\\rho } } } v^{\\,s''}}}}\\\\    \\inferrule*[left=(letrec)]{\\      { \\ensuremath{b^{\\,s }    \\optarrow[{\\mathcal{f'}}]{{\\ensuremath{{\\ensuremath{{\\rho_{t}}}}|\\rho } } } v^{\\,s ' } } } \\\\\\\\      \\rho ' = { \\ensuremath{{\\rho_{t}}}}{\\cdot}\\rho|_{{\\mathop{\\mathrm{dom}}\\nolimits}({\\ensuremath{{\\rho_{t}}}}{\\cdot}\\rho)\\setminus\\{{\\ensuremath{x_{1}\\dotscx_{n}}}\\ } } \\\\      \\mathcal{f'}={\\ensuremath{{\\ensuremath{\\mathcal{f}}}+ \\{f\\mapsto{\\ensuremath{\\left[\\lambda{\\ensuremath{x_{1}\\dotscx_{n}}}.a,\\rho',{\\ensuremath{\\mathcal{f}}}\\right]}}\\ } } }     } { \\      { \\ensuremath{{\\ensuremath{\\mathop{\\mathbf{letrec}}\\ f({\\ensuremath{x_{1}\\dotscx_{n}}})=a\\    \\mathop{\\mathbf{in}}\\ b}}^{\\,s }    \\optarrow[{\\ensuremath{\\mathcal{f}}}]{{\\ensuremath{{\\ensuremath{{\\rho_{t}}}}|\\rho } } } v^{\\,s'}}}}\\\\    \\inferrule*[left=(call)]{\\ { \\ensuremath{\\mathcal{f}}}\\,f = { \\ensuremath{\\left[\\lambda{\\ensuremath{x_{1}\\dotscx_{n}}}.b,\\rho',\\mathcal{f'}\\right]}}\\\\ \\rho''= { \\ensuremath{(x_{1},l_{1}){\\cdot}\\dotsc{\\cdot}(x_{n},l_{n})}}\\\\ \\text{$l_{i}$ fresh and distinct}\\\\\\\\ \\forall i,{\\ensuremath{a_i^{\\,s_i }    \\optarrow[{\\ensuremath{\\mathcal{f}}}]{{\\ensuremath{|{\\ensuremath{{\\rho_{t}}}}{\\cdot}\\rho } } } v_i^{\\,s_{i+1 } } } } \\\\ { \\ensuremath{b^{\\,{\\ensuremath{s_{n+1 } + \\{l_i\\mapstov_i\\ } } } }    \\optarrow[{{\\ensuremath{\\mathcal{f ' } + \\{f\\mapsto{\\ensuremath{\\mathcal{f}}}\\,f\\ } } } } ] { { \\ensuremath{\\rho''|\\rho ' } } } v^{\\,s ' } } } } { \\ { \\ensuremath{f({\\ensuremath{a_{1}\\dotsca_{n}}})^{\\,s_{1 } }    \\optarrow[{\\ensuremath{\\mathcal{f}}}]{{\\ensuremath{{\\ensuremath{{\\rho_{t}}}}|\\rho } } } v^{\\,{s ' \\setminus { \\ensuremath{{\\rho_{t}}}}}}}}}\\end{gathered}\\ ] ]    [ thm : sem - equiv ] optimised and naive reduction rules are equivalent : every reduction in one set of rules yields the same result in the other .",
    "it is necessary , however , to take care of locations left in the store by the naive reduction : @xmath51{{\\ensuremath{\\varepsilon|\\varepsilon } } } v^{\\,\\varepsilon } } }    { \\ensuremath{\\quad\\text{iff}\\quad}}\\exists s,{\\ensuremath{m^{\\,\\varepsilon }    \\naivearrow[\\varepsilon]{\\varepsilon } v^{\\,s}}}\\ ] ]    we prove this theorem in section  [ sec : sem - equiv ] .",
    "this section is devoted to the proof of equivalence between the optimised naive reduction rules ( theorem  [ thm : sem - equiv ] ) .    to clarify the proof , we introduce intermediate reduction rules ( figure  [ sem - proof : inter ] , p.  ) , with only one of the two optimisations : minimal stores , but not compact closures .",
    "the proof then consists in proving that optimised and intermediate rules are equivalent ( lemma  [ lem : iimplieso ] and lemma  [ lem : oimpliesi ] , section  [ subsec : first - step ] ) , then that naive and intermediate rules are equivalent ( lemma  [ lem : iimpliesn ] and lemma  [ lem : nimpliesi ] , section  [ subsec : second - step ] ) .",
    "@xmath52{\\text{lemma~\\ref{lem : nimpliesi } } } \\text{intermediate rules } \\xtofrom[\\text{lemma~\\ref{lem : oimpliesi}}]{\\text{lemma~\\ref{lem : iimplieso } } } \\text{optimised rules}\\ ] ]    @xmath14 { } { { \\ensuremath{v^{\\,s }    \\intarrow[{\\ensuremath{\\mathcal{f}}}]{{\\ensuremath{{\\ensuremath{{\\rho_{t}}}}|\\rho } } } v^{\\,{s \\setminus { \\ensuremath{{\\rho_{t}}}}}}}}}\\qquad\\qquad    \\inferrule*[left=(var)]{{\\ensuremath{{\\rho_{t}}}}{\\cdot}\\rho\\ x = l \\in { \\mathop{\\mathrm{dom}}\\nolimits}\\ s}{{\\ensuremath{x^{\\,s }    \\intarrow[{\\ensuremath{\\mathcal{f}}}]{{\\ensuremath{{\\ensuremath{{\\rho_{t}}}}|\\rho } } } s\\ l^{\\,{s \\setminus { \\ensuremath{{\\rho_{t}}}}}}}}}\\\\    \\inferrule*[left=(assign)]{{\\ensuremath{a^{\\,s }    \\intarrow[{\\ensuremath{\\mathcal{f}}}]{{\\ensuremath{|{\\ensuremath{{\\rho_{t}}}}{\\cdot}\\rho } } } v^{\\,s ' } } } \\\\      { \\ensuremath{{\\rho_{t}}}}{\\cdot}\\rho\\ x = l \\in { \\mathop{\\mathrm{dom}}\\nolimits}\\ s'}{\\      { \\ensuremath{x { \\vcentcolon\\mkern-1.2mu=}a^{\\,s }    \\intarrow[{\\ensuremath{\\mathcal{f}}}]{{\\ensuremath{{\\ensuremath{{\\rho_{t}}}}|\\rho } } } { \\ensuremath{\\mathbf{1}}}^{\\,{{{\\ensuremath{s ' + \\{l\\mapstov\\ } } } } \\setminus { \\ensuremath{{\\rho_{t}}}}}}}}}\\qquad\\qquad    \\inferrule*[left=(seq)]{{\\ensuremath{a^{\\,s }    \\intarrow[{\\ensuremath{\\mathcal{f}}}]{{\\ensuremath{|{\\ensuremath{{\\rho_{t}}}}{\\cdot}\\rho } } } v^{\\,s ' } } } \\\\ { \\ensuremath{b^{\\,s ' }    \\intarrow[{\\ensuremath{\\mathcal{f}}}]{{\\ensuremath{{\\ensuremath{{\\rho_{t}}}}|\\rho } } } v'^{\\,s''}}}}{{\\ensuremath{a\\ ; \\",
    "b^{\\,s }    \\intarrow[{\\ensuremath{\\mathcal{f}}}]{{\\ensuremath{{\\ensuremath{{\\rho_{t}}}}|\\rho } } } v'^{\\,s''}}}}\\\\    \\inferrule*[left=(if - t.)]{{\\ensuremath{a^{\\,s }    \\intarrow[{\\ensuremath{\\mathcal{f}}}]{{\\ensuremath{|{\\ensuremath{{\\rho_{t}}}}{\\cdot}\\rho } } } { \\ensuremath{\\mathop{\\mathbf{true}}\\nolimits}}^{\\,s ' } } } \\\\",
    "{ \\ensuremath{b^{\\,s ' }    \\intarrow[{\\ensuremath{\\mathcal{f}}}]{{\\ensuremath{{\\ensuremath{{\\rho_{t}}}}|\\rho } } } v^{\\,s''}}}}{\\      { \\ensuremath{{\\ensuremath{\\mathop{\\mathbf{if}}\\ a\\   \\mathop{\\mathbf{then}}\\ b\\ \\mathop{\\mathbf{else}}\\ c}}^{\\,s }    \\intarrow[{\\ensuremath{\\mathcal{f}}}]{{\\ensuremath{{\\ensuremath{{\\rho_{t}}}}|\\rho } } } v^{\\,s''}}}}\\qquad\\qquad    \\inferrule*[left=(if - f.)]{{\\ensuremath{a^{\\,s }    \\intarrow[{\\ensuremath{\\mathcal{f}}}]{{\\ensuremath{|{\\ensuremath{{\\rho_{t}}}}{\\cdot}\\rho } } } { \\ensuremath{\\mathop{\\mathbf{false}}\\nolimits}}^{\\,s ' } } } \\\\ { \\ensuremath{c^{\\,s ' }    \\intarrow[{\\ensuremath{\\mathcal{f}}}]{{\\ensuremath{{\\ensuremath{{\\rho_{t}}}}|\\rho } } } v^{\\,s''}}}}{\\      { \\ensuremath{{\\ensuremath{\\mathop{\\mathbf{if}}\\ a\\   \\mathop{\\mathbf{then}}\\ b\\ \\mathop{\\mathbf{else}}\\ c}}^{\\,s }    \\intarrow[{\\ensuremath{\\mathcal{f}}}]{{\\ensuremath{{\\ensuremath{{\\rho_{t}}}}|\\rho } } } v^{\\,s''}}}}\\\\    \\inferrule*[left=(letrec)]{\\      { \\ensuremath{b^{\\,s }    \\intarrow[{\\mathcal{f'}}]{{\\ensuremath{{\\ensuremath{{\\rho_{t}}}}|\\rho } } } v^{\\,s ' } } } \\\\\\\\      \\rho ' = { \\ensuremath{{\\rho_{t}}}}{\\cdot}\\rho \\\\      \\mathcal{f'}={\\ensuremath{{\\ensuremath{\\mathcal{f}}}+ \\{f\\mapsto{\\ensuremath{\\left[\\lambda{\\ensuremath{x_{1}\\dotscx_{n}}}.a,\\rho,{\\ensuremath{\\mathcal{f}}}\\right]}}\\ } } }     } { \\      { \\ensuremath{{\\ensuremath{\\mathop{\\mathbf{letrec}}\\ f({\\ensuremath{x_{1}\\dotscx_{n}}})=a\\    \\mathop{\\mathbf{in}}\\ b}}^{\\,s }    \\intarrow[{\\ensuremath{\\mathcal{f}}}]{{\\ensuremath{{\\ensuremath{{\\rho_{t}}}}|\\rho } } } v^{\\,s'}}}}\\\\    \\inferrule*[left=(call)]{\\ { \\ensuremath{\\mathcal{f}}}\\,f = { \\ensuremath{\\left[\\lambda{\\ensuremath{x_{1}\\dotscx_{n}}}.b,\\rho',\\mathcal{f'}\\right]}}\\\\ \\rho''= { \\ensuremath{(x_{1},l_{1}){\\cdot}\\dotsc{\\cdot}(x_{n},l_{n})}}\\\\ \\text{$l_{i}$ fresh and distinct}\\\\\\\\ \\forall i,{\\ensuremath{a_i^{\\,s_i }    \\intarrow[{\\ensuremath{\\mathcal{f}}}]{{\\ensuremath{|{\\ensuremath{{\\rho_{t}}}}{\\cdot}\\rho } } } v_i^{\\,s_{i+1 } } } } \\\\ { \\ensuremath{b^{\\,{\\ensuremath{s_{n+1 } + \\{l_i\\mapstov_i\\ } } } }    \\intarrow[{{\\ensuremath{\\mathcal{f ' } + \\{f\\mapsto{\\ensuremath{\\mathcal{f}}}\\,f\\ } } } } ] { { \\ensuremath{\\rho''|\\rho ' } } } v^{\\,s ' } } } } { \\ { \\ensuremath{f({\\ensuremath{a_{1}\\dotsca_{n}}})^{\\,s_{1 } }    \\intarrow[{\\ensuremath{\\mathcal{f}}}]{{\\ensuremath{{\\ensuremath{{\\rho_{t}}}}|\\rho } } } v^{\\,{s ' \\setminus { \\ensuremath{{\\rho_{t}}}}}}}}}\\end{gathered}\\ ] ]      in this section , we show that optimised and intermediate reduction rules are equivalent : @xmath53{\\text{lemma~\\ref{lem : iimplieso } } } \\text{optimised rules}\\ ] ] we must therefore show that it is correct to use compact closures in the optimised reduction rules .",
    "compact closures carry the implicit idea that some variables can be safely discarded from the environments when we know for sure that they will be hidden .",
    "the following lemma formalises this intuition .",
    "[ lem : intro - in - env2 ] @xmath54{{\\ensuremath{{\\ensuremath{{\\rho_{t}}}}{\\cdot}(x , l)|\\rho } } } v^{\\,s ' } } } { \\ensuremath{\\quad\\text{iff}\\quad } } &    { \\ensuremath{m^{\\,s }    \\intarrow[{\\ensuremath{\\mathcal{f}}}]{{\\ensuremath{{\\ensuremath{{\\rho_{t}}}}{\\cdot}(x , l)|(x , l'){\\cdot}\\rho } } } v^{\\,s ' } } } \\\\",
    "\\forall l , l ' , { \\ensuremath{m^{\\,s }    \\optarrow[{\\ensuremath{\\mathcal{f}}}]{{\\ensuremath{{\\ensuremath{{\\rho_{t}}}}{\\cdot}(x , l)|\\rho } } } v^{\\,s ' } } } { \\ensuremath{\\quad\\text{iff}\\quad } } &    { \\ensuremath{m^{\\,s }    \\optarrow[{\\ensuremath{\\mathcal{f}}}]{{\\ensuremath{{\\ensuremath{{\\rho_{t}}}}{\\cdot}(x , l)|(x , l'){\\cdot}\\rho } } } v^{\\,s ' } } }    \\end{aligned}\\ ] ] moreover , both derivations have the same height .",
    "the exact same proof holds for both intermediate and optimised reduction rules .    by induction on the structure of the derivation .",
    "the proof relies solely on the fact that @xmath55 .",
    "[ [ seq ] ] ( seq ) + + + + +    @xmath56 .",
    "so , @xmath57{{\\ensuremath{|{\\ensuremath{{\\rho_{t}}}}{\\cdot}(x , l){\\cdot}(x , l'){\\cdot}\\rho } } } v^{\\,s ' } } } { \\ensuremath{\\quad\\text{iff}\\quad}}{\\ensuremath{a^{\\,s }    \\intarrow[{\\ensuremath{\\mathcal{f}}}]{{\\ensuremath{|{\\ensuremath{{\\rho_{t}}}}{\\cdot}(x , l){\\cdot}\\rho } } } v^{\\,s'}}}\\ ] ] moreover , by the induction hypotheses , @xmath58{{\\ensuremath{{\\ensuremath{{\\rho_{t}}}}{\\cdot}(x , l)|(x , l'){\\cdot}\\rho } } } v'^{\\,s '' } } } { \\ensuremath{\\quad\\text{iff}\\quad}}{\\ensuremath{b^{\\,s ' }    \\intarrow[{\\ensuremath{\\mathcal{f}}}]{{\\ensuremath{{\\ensuremath{{\\rho_{t}}}}{\\cdot}(x , l)|\\rho } } } v'^{\\,s''}}}\\ ] ] hence , @xmath59{{\\ensuremath{{\\ensuremath{{\\rho_{t}}}}{\\cdot}(x , l)|(x , l'){\\cdot}\\rho } } } v'^{\\,s '' } } } { \\ensuremath{\\quad\\text{iff}\\quad}}{\\ensuremath{a\\ ; \\ b^{\\,s }    \\intarrow[{\\ensuremath{\\mathcal{f}}}]{{\\ensuremath{{\\ensuremath{{\\rho_{t}}}}{\\cdot}(x , l)|\\rho } } } v'^{\\,s''}}}\\ ] ]    the other cases are similar .    [",
    "[ val ] ] ( val ) + + + + +    @xmath60{{\\ensuremath{{\\ensuremath{{\\rho_{t}}}}{\\cdot}(x , l)|\\rho } } } v^{\\,{s \\setminus { \\ensuremath{{\\rho_{t}}}}{\\cdot}(x , l ) } } } } { \\ensuremath{\\quad\\text{iff}\\quad}}{\\ensuremath{v^{\\,s }    \\intarrow[{\\ensuremath{\\mathcal{f}}}]{{\\ensuremath{{\\ensuremath{{\\rho_{t}}}}{\\cdot}(x , l)|(x , l'){\\cdot}\\rho } } } v^{\\,{s \\setminus { \\ensuremath{{\\rho_{t}}}}{\\cdot}(x , l)}}}}$ ]    [ [ var ] ] ( var ) + + + + +    @xmath56 so , with @xmath61 , @xmath62{{\\ensuremath{{\\ensuremath{{\\rho_{t}}}}{\\cdot}(x , l)|\\rho } } } s\\ l''^{\\,{s \\setminus { \\ensuremath{{\\rho_{t}}}}{\\cdot}(x , l ) } } } }        { \\ensuremath{\\quad\\text{iff}\\quad}}{\\ensuremath{y^{\\,s }    \\intarrow[{\\ensuremath{\\mathcal{f}}}]{{\\ensuremath{{\\ensuremath{{\\rho_{t}}}}{\\cdot}(x , l)|(x , l'){\\cdot}\\rho } } } s\\ l''^{\\,{s \\setminus { \\ensuremath{{\\rho_{t}}}}{\\cdot}(x , l)}}}}\\ ] ]    [ [ assign ] ] ( assign ) + + + + + + + +    @xmath56 .",
    "so , @xmath57{{\\ensuremath{|{\\ensuremath{{\\rho_{t}}}}{\\cdot}(x , l){\\cdot}(x , l'){\\cdot}\\rho } } } v^{\\,s ' } } } { \\ensuremath{\\quad\\text{iff}\\quad}}{\\ensuremath{a^{\\,s }    \\intarrow[{\\ensuremath{\\mathcal{f}}}]{{\\ensuremath{|{\\ensuremath{{\\rho_{t}}}}{\\cdot}(x , l){\\cdot}\\rho } } } v^{\\,s'}}}\\ ] ] hence , with @xmath61 , @xmath63{{\\ensuremath{{\\ensuremath{{\\rho_{t}}}}{\\cdot}(x , l)|\\rho } } } { \\ensuremath{\\mathbf{1}}}^{\\,{{{\\ensuremath{s ' + \\{l''\\mapstov\\ } } } } \\setminus { \\ensuremath{{\\rho_{t}}}}{\\cdot}(x , l ) } } } } { \\ensuremath{\\quad\\text{iff}\\quad}}{\\ensuremath{y { \\vcentcolon\\mkern-1.2mu=}a^{\\,s }    \\intarrow[{\\ensuremath{\\mathcal{f}}}]{{\\ensuremath{{\\ensuremath{{\\rho_{t}}}}{\\cdot}(x , l)|(x , l'){\\cdot}\\rho } } } { \\ensuremath{\\mathbf{1}}}^{\\,{{{\\ensuremath{s ' + \\{l''\\mapstov\\ } } } } \\setminus { \\ensuremath{{\\rho_{t}}}}{\\cdot}(x , l)}}}}\\ ] ]    [ [ if - true - and - if - false ] ] ( if - true ) and ( if - false ) + + + + + + + + + + + + + + + + + + + + + + + +    are proved similarly to ( seq ) .",
    "[ [ letrec ] ] ( letrec ) + + + + + + + +    @xmath64 .",
    "moreover , by the induction hypotheses , @xmath65{{\\ensuremath{{\\ensuremath{{\\rho_{t}}}}{\\cdot}(x , l)|(x , l'){\\cdot}\\rho } } } v^{\\,s ' } } } { \\ensuremath{\\quad\\text{iff}\\quad}}{\\ensuremath{b^{\\,s }    \\intarrow[{\\mathcal{f'}}]{{\\ensuremath{{\\ensuremath{{\\rho_{t}}}}{\\cdot}(x , l)|\\rho } } } v^{\\,s'}}}\\ ] ] hence , @xmath66{{\\ensuremath{{\\ensuremath{{\\rho_{t}}}}{\\cdot}(x , l)|(x , l'){\\cdot}\\rho } } } v^{\\,s ' } } }        { \\ensuremath{\\quad\\text{iff}\\quad}}\\\\        { \\ensuremath{{\\ensuremath{\\mathop{\\mathbf{letrec}}\\ f({\\ensuremath{x_{1}\\dotscx_{n}}})=a\\    \\mathop{\\mathbf{in}}\\ b}}^{\\,s }    \\intarrow[{\\ensuremath{\\mathcal{f}}}]{{\\ensuremath{{\\ensuremath{{\\rho_{t}}}}{\\cdot}(x , l)|\\rho } } } v^{\\,s ' } } }        \\end{gathered}\\ ] ]    [ [ call ] ] ( call ) + + + + + +    @xmath56 .",
    "so , @xmath67{{\\ensuremath{|{\\ensuremath{{\\rho_{t}}}}{\\cdot}(x , l){\\cdot}(x , l'){\\cdot}\\rho } } } v_i^{\\,s_{i+1 } } } } { \\ensuremath{\\quad\\text{iff}\\quad}}{\\ensuremath{a_i^{\\,s_i }    \\intarrow[{\\ensuremath{\\mathcal{f}}}]{{\\ensuremath{|{\\ensuremath{{\\rho_{t}}}}{\\cdot}(x , l){\\cdot}\\rho } } } v_i^{\\,s_{i+1}}}}\\ ] ] hence , @xmath68{{\\ensuremath{{\\ensuremath{{\\rho_{t}}}}{\\cdot}(x , l)|(x , l'){\\cdot}\\rho } } } v^{\\,{s ' \\setminus { \\ensuremath{{\\rho_{t}}}}{\\cdot}(x , l ) } } } } { \\ensuremath{\\quad\\text{iff}\\quad}}{\\ensuremath{f({\\ensuremath{a_{1}\\dotsca_{n}}})^{\\,s_{1 } }    \\intarrow[{\\ensuremath{\\mathcal{f}}}]{{\\ensuremath{{\\ensuremath{{\\rho_{t}}}}{\\cdot}(x , l)|\\rho } } } v^{\\,{s ' \\setminus { \\ensuremath{{\\rho_{t}}}}{\\cdot}(x , l)}}}}.        \\qedhere\\ ] ]    now we can show the required lemmas and prove the equivalence between the intermediate and optimised reduction rules .    [",
    "lem : iimplieso ] @xmath69{{\\ensuremath{{\\ensuremath{{\\rho_{t}}}}|\\rho } } } v^{\\,s ' } } }    \\text { then } { \\ensuremath{m^{\\,s }    \\optarrow[{{\\ensuremath{\\mathcal{f}}}_{*}}]{{\\ensuremath{{\\ensuremath{{\\rho_{t}}}}|\\rho } } } v^{\\,s'}}}.\\ ] ]    by induction on the structure of the derivation .",
    "the interesting cases are ( letrec ) and ( call ) , where compact environments are respectively built and used .    [ [ letrec-1 ] ] ( letrec ) + + + + + + + +    by the induction hypotheses , @xmath70{{\\ensuremath{{\\ensuremath{{\\rho_{t}}}}|\\rho } } } v^{\\,s'}}}\\ ] ] since we defined canonical compact environments so as to match exactly the way compact environments are built in the optimised reduction rules , the constraints of the ( letrec ) rule are fulfilled : @xmath71}}\\ } } } , \\ ] ] hence : @xmath72{{\\ensuremath{{\\ensuremath{{\\rho_{t}}}}|\\rho } } } v^{\\,s'}}}\\ ] ]    [ [ call-1 ] ] ( call ) + + + + + +    by the induction hypotheses , @xmath73{{\\ensuremath{|{\\ensuremath{{\\rho_{t}}}}{\\cdot}\\rho } } } v_i^{\\,s_{i+1}}}}\\ ] ] and @xmath74{{\\ensuremath{\\rho''|\\rho ' } } } v^{\\,s'}}}\\ ] ] lemma  [ lem : intro - in - env2 ] allows to remove hidden variables , which leads to @xmath74{{\\ensuremath{\\rho''|\\rho'_{|{\\mathop{\\mathrm{dom}}\\nolimits}(\\rho')\\setminus\\{{\\ensuremath{x_{1}\\dotscx_{n}}}\\ } } } } } v^{\\,s'}}}\\ ] ] besides , @xmath75}}\\ ] ] and @xmath76 hence @xmath77{{\\ensuremath{{\\ensuremath{{\\rho_{t}}}}|\\rho } } } v^{\\,{s ' \\setminus { \\ensuremath{{\\rho_{t}}}}}}}}.\\ ] ]    [ [ val-1 ] ] ( val ) + + + + +    @xmath78{{\\ensuremath{{\\ensuremath{{\\rho_{t}}}}|\\rho } } } v^{\\,{s \\setminus { \\ensuremath{{\\rho_{t}}}}}}$ ]    [ [ var-1 ] ] ( var ) + + + + +    @xmath79{{\\ensuremath{{\\ensuremath{{\\rho_{t}}}}|\\rho } } } s\\ l^{\\,{s \\setminus { \\ensuremath{{\\rho_{t}}}}}}$ ]    [ [ assign-1 ] ] ( assign ) + + + + + + + +    by the induction hypotheses , @xmath80{{\\ensuremath{|{\\ensuremath{{\\rho_{t}}}}{\\cdot}\\rho } } } v^{\\,s'}$ ] .",
    "hence , @xmath81{{\\ensuremath{{\\ensuremath{{\\rho_{t}}}}|\\rho } } } { \\ensuremath{\\mathbf{1}}}^{\\,{{{\\ensuremath{s ' + \\{l\\mapstov\\ } } } } \\setminus { \\ensuremath{{\\rho_{t}}}}}}}}\\ ] ]    [ [ seq-1 ] ] ( seq ) + + + + +    by the induction hypotheses , @xmath82{{\\ensuremath{|{\\ensuremath{{\\rho_{t}}}}{\\cdot}\\rho } } } v^{\\,s ' } } } \\qquad\\qquad        { \\ensuremath{b^{\\,s ' }    \\optarrow[{{\\ensuremath{\\mathcal{f}}}_{*}}]{{\\ensuremath{{\\ensuremath{{\\rho_{t}}}}|\\rho } } } v'^{\\,s''}}}\\ ] ] hence , @xmath83{{\\ensuremath{{\\ensuremath{{\\rho_{t}}}}|\\rho } } } v'^{\\,s''}}}\\ ] ]    [ [ if - true - and - if - false-1 ] ] ( if - true ) and ( if - false ) + + + + + + + + + + + + + + + + + + + + + + + +    are proved similarly to ( seq ) .",
    "[ lem : oimpliesi ] @xmath84{{\\ensuremath{{\\ensuremath{{\\rho_{t}}}}|\\rho } } } v^{\\,s ' } } }    \\text { then } \\forall \\mathcal{g } \\text { such that } { \\mathcal{g}_{*}}={\\ensuremath{\\mathcal{f } } } ,    { \\ensuremath{m^{\\,s }    \\intarrow[{\\mathcal{g}}]{{\\ensuremath{{\\ensuremath{{\\rho_{t}}}}|\\rho } } } v^{\\,s'}}}.\\ ] ]    first note that , since @xmath85 , @xmath16 is necessarily compact .    by induction on the structure of the derivation .",
    "the interesting cases are ( letrec ) and ( call ) , where non - compact environments are respectively built and used .",
    "[ [ letrec-2 ] ] ( letrec ) + + + + + + + +    let @xmath86 .",
    "remember that @xmath87 .",
    "let @xmath88}}\\ } } } \\ ] ] which leads , since @xmath16 is compact ( @xmath89 ) , to @xmath90}}\\ } } } \\\\          & = \\mathcal{f ' }        \\end{aligned}\\ ] ] by the induction hypotheses , @xmath91{{\\ensuremath{{\\ensuremath{{\\rho_{t}}}}|\\rho } } } v^{\\,s'}}}\\ ] ] hence , @xmath92{{\\ensuremath{{\\ensuremath{{\\rho_{t}}}}|\\rho } } } v^{\\,s'}}}\\ ] ]    [ [ call-2 ] ] ( call ) + + + + + +    let @xmath86 . by the induction hypotheses , @xmath93{{\\ensuremath{|{\\ensuremath{{\\rho_{t}}}}{\\cdot}\\rho } } } v_i^{\\,s_{i+1}}}}\\ ] ] moreover , since @xmath94 , @xmath95}}\\ ] ] where @xmath96 , and the @xmath97 are some locations stripped out when compacting @xmath98 to get @xmath16",
    ". by the induction hypotheses , @xmath99{{\\ensuremath{\\rho''|\\rho ' } } } v^{\\,s'}}}\\ ] ] lemma  [ lem : intro - in - env2 ] leads to @xmath99{{\\ensuremath{\\rho''|{\\ensuremath{(x_{i},l_{i}){\\cdot}\\dotsc{\\cdot}(x_{j},l_{j})}}\\rho ' } } } v^{\\,s'}}}\\ ] ] hence , @xmath100{{\\ensuremath{{\\ensuremath{{\\rho_{t}}}}|\\rho } } } v^{\\,{s ' \\setminus { \\ensuremath{{\\rho_{t}}}}}}}}.\\ ] ]    [ [ val-2 ] ] ( val ) + + + + +    @xmath101{{\\ensuremath{{\\ensuremath{{\\rho_{t}}}}|\\rho } } } v^{\\,s'}}}$ ]    [ [ var-2 ] ] ( var ) + + + + +    @xmath102{{\\ensuremath{{\\ensuremath{{\\rho_{t}}}}|\\rho } } } s\\ l^{\\,{s \\setminus { \\ensuremath{{\\rho_{t}}}}}}}}$ ]    [ [ assign-2 ] ] ( assign ) + + + + + + + +    let @xmath86 . by the induction hypotheses , @xmath103{{\\ensuremath{|{\\ensuremath{{\\rho_{t}}}}{\\cdot}\\rho } } } v^{\\,s'}}}$ ] .",
    "hence , @xmath104{{\\ensuremath{{\\ensuremath{{\\rho_{t}}}}|\\rho } } } { \\ensuremath{\\mathbf{1}}}^{\\,{{{\\ensuremath{s ' + \\{l\\mapstov\\ } } } } \\setminus { \\ensuremath{{\\rho_{t}}}}}}}}\\ ] ]    [ [ seq-2 ] ] ( seq ) + + + + +    let @xmath86 . by the induction hypotheses , @xmath105{{\\ensuremath{|{\\ensuremath{{\\rho_{t}}}}{\\cdot}\\rho } } } v^{\\,s ' } } }        \\qquad\\qquad        { \\ensuremath{b^{\\,s ' }    \\intarrow[{\\mathcal{g}}]{{\\ensuremath{{\\ensuremath{{\\rho_{t}}}}|\\rho } } } v'^{\\,s''}}}\\ ] ] hence @xmath106{{\\ensuremath{{\\ensuremath{{\\rho_{t}}}}|\\rho } } } v'^{\\,s''}}}\\ ] ]    [ [ if - true - and - if - false-2 ] ] ( if - true ) and ( if - false ) + + + + + + + + + + + + + + + + + + + + + + + +    are proved similarly to ( seq ) .      in this section ,",
    "we show that the naive and intermediate reduction rules are equivalent : @xmath52{\\text{lemma~\\ref{lem : nimpliesi } } } \\text{intermediate rules}\\ ] ] we must therefore show that it is correct to use minimal stores in the intermediate reduction rules .",
    "we first define a partial order on stores :    @xmath107    [ prop : ext - order ] store extension ( @xmath108 ) is a partial order over stores .",
    "the following operations preserve this order : @xmath109 and @xmath110 , for some given @xmath4 , @xmath23 and @xmath111 .",
    "immediate when considering the stores as function graphs : @xmath108 is the inclusion , @xmath109 a relative complement , and @xmath110 a disjoint union ( preceded by @xmath112 when @xmath23 is already bound to some @xmath113 ) .    before we prove that using minimal stores is equivalent to using full stores , we need an alpha - conversion lemma , which allows us to rename locations in the store , provided the new location does not already appear in the store or the environments .",
    "it is used when choosing a fresh location for the ( call ) rule in proofs by induction .",
    "[ lem : rename - loc ] if @xmath114{{\\ensuremath{{\\ensuremath{{\\rho_{t}}}}|\\rho } } } v^{\\,s'}$ ] then , for all @xmath23 , for all @xmath115 appearing neither in @xmath5 nor in @xmath16 nor in @xmath116 , @xmath117 }    \\intarrow[{s[l'/l]}]{{\\ensuremath{{\\ensuremath{{\\rho_{t}}}}[l'/l|]}}^{\\,m}}}{v}{s'[l'/l]}{{\\ensuremath{\\mathcal{f}}}[l'/l]}.\\ ] ] moreover , both derivations have the same height .    by induction on the height of the derivation .",
    "for the ( call ) case , we must ensure that the fresh locations @xmath97 do not clash with @xmath115 . in case",
    "they do , we conclude by applying the induction hypotheses twice : first to rename the clashing @xmath97 into a fresh @xmath118 , then to rename @xmath23 into @xmath115 .    two preliminary elementary remarks .",
    "first , provided @xmath115 appears neither in @xmath4 or @xmath42 , nor in @xmath5 , @xmath119 = { ( s[l'/l ] ) \\setminus ( \\rho[l'/l])}\\ ] ] and @xmath120 = { \\ensuremath{{\\rho_{t}}}}[l'/l]{\\cdot}\\rho[l'/l].\\ ] ]    moreover , if @xmath121{{\\ensuremath{{\\ensuremath{{\\rho_{t}}}}|\\rho } } } v^{\\,s'}}}$ ] , then @xmath122 ( straightforward by induction ) .",
    "this leads to : @xmath123 .    by induction on the height of the derivation , because the induction hypothesis must be applied twice in the case of the ( call ) rule .",
    "[ [ call-3 ] ] ( call ) + + + + + +    @xmath124 .",
    "thus , @xmath125 .",
    "this leads , by the induction hypotheses , to @xmath126 }    \\intarrow[{\\ensuremath{\\mathcal{f}}}]{{\\ensuremath{|({\\ensuremath{{\\rho_{t}}}}{\\cdot}\\rho)[l'/l } } a_i^{\\,s_i[l'/l]}}}{v_i}{s_{i+1}[l'/l]}{{\\ensuremath{\\mathcal{f}}}[l'/l]}\\ ] ] moreover , @xmath127 is part of @xmath16 . as a result ,",
    "since @xmath115 does not appear in @xmath16 , it does not appear in @xmath127 , nor in @xmath24 .",
    "it does not appear in @xmath15 either ( since @xmath15 is part of @xmath127 ) .",
    "on the other hand , there might be some @xmath128 such that @xmath129 , so @xmath115 might appear in @xmath130 .",
    "in that case , we apply the induction hypotheses a first time to rename @xmath131 in some @xmath132 .",
    "one can chose @xmath133 such that it does not appear in @xmath134 , @xmath24 nor in @xmath135 . as a result",
    ", @xmath133 is fresh .",
    "since @xmath131 is fresh too , and does not appear in @xmath136 ( because of our preliminary remarks ) , this leads to a mere substitution in @xmath130 : @xmath137\\mapstov_i\\ } } } } ] { { \\ensuremath{\\rho''[l'_j / l_j|]}}^{\\,b}}}{v}{s'}{{\\ensuremath{\\mathcal{f ' } + \\{f\\mapsto{\\ensuremath{\\mathcal{f}}}\\,f\\ } } } } \\ ] ] once this ( potentially ) disturbing @xmath131 has been renamed ( we ignore it in the rest of the proof ) , we apply the induction hypotheses a second time to rename @xmath23 to @xmath115 : @xmath138 }    \\intarrow[{({\\ensuremath{s_{n+1 } + \\{l_i\\mapstov_i\\ } } } ) [ l'/l]}]{{\\ensuremath{\\rho''[l'/l|]}}^{\\,b}}}{v}{s'[l'/l]}{{\\ensuremath{\\mathcal{f ' } + \\{f\\mapsto{\\ensuremath{\\mathcal{f}}}\\,f\\ } } } } \\ ] ] now , @xmath139",
    "= { \\ensuremath{s_{n+1}[l'/l ] + \\{l_i\\mapstov_i\\ } } } $ ] .",
    "moreover , @xmath140\\ f = { \\ensuremath{\\left[\\lambda{\\ensuremath{x_{1}\\dotscx_{n}}}.b,\\rho'[l'/l],\\mathcal{f'}[l'/l]\\right]}}\\ ] ] and @xmath141 =       { \\ensuremath{\\mathcal{f'}[l'/l ] + \\{f\\mapsto{\\ensuremath{\\mathcal{f}}}[l'/l]\\ f\\ } } } \\ ] ] finally , @xmath142 = \\rho''$ ] .",
    "hence : @xmath117 }    \\intarrow[{s_{1}[l'/l]}]{{\\ensuremath{{\\ensuremath{{\\rho_{t}}}}[l'/l|]}}^{\\,f({\\ensuremath{a_{1}\\dotsca_{n}}})}}}{v}{{s'[l'/l ] \\setminus { \\ensuremath{{\\rho_{t}}}}[l'/l]}}{{\\ensuremath{\\mathcal{f}}}[l'/l]}.\\ ] ]    [ [ val-3 ] ] ( val ) + + + + +    @xmath143 }    \\intarrow[{s[l'/l]}]{{\\ensuremath{{\\ensuremath{{\\rho_{t}}}}[l'/l|]}}^{\\,v}}}{v}{{s[l'/l ] \\setminus { \\ensuremath{{\\rho_{t}}}}[l'/l]}}{{\\ensuremath{\\mathcal{f}}}[l'/]}$ ]    [ [ var-3 ] ] ( var ) + + + + +    @xmath144({\\ensuremath{{\\rho_{t}}}}[l'/l]{\\cdot}\\rho[l'/l]\\ x ) =     s({\\ensuremath{{\\rho_{t}}}}{\\cdot}\\rho\\ x ) = v$ ] implies @xmath117 }    \\intarrow[{s[l'/l]}]{{\\ensuremath{{\\ensuremath{{\\rho_{t}}}}[l'/l|]}}^{\\,x}}}{v}{{s[l'/l ] \\setminus { \\ensuremath{{\\rho_{t}}}}[l'/l]}}{{\\ensuremath{\\mathcal{f}}}[l'/]}\\ ] ]    [ [ assign-3 ] ] ( assign ) + + + + + + + +    by the induction hypotheses , @xmath145 }    \\intarrow[{v}]{{\\ensuremath{|({\\ensuremath{{\\rho_{t}}}}{\\cdot}\\rho)[l'/l } } a^{\\,s[l'/l]}}}{s'[l'/]}{{\\ensuremath{\\mathcal{f}}}[l'/]}\\ ] ] let @xmath146 .",
    "then , @xmath147 + \\{({\\ensuremath{{\\rho_{t}}}}{\\cdot}\\rho)[l'/l]\\ x\\mapstov\\ } } } } = s''[l'/l]\\ ] ] hence @xmath117 }    \\intarrow[{s[l'/l]}]{{\\ensuremath{{\\ensuremath{{\\rho_{t}}}}[l'/l|]}}^{\\,x { \\vcentcolon\\mkern-1.2mu=}a}}}{{\\ensuremath{\\mathbf{1}}}}{{s''[l'/l ] \\setminus { \\ensuremath{{\\rho_{t}}}}[l'/l]}}{{\\ensuremath{\\mathcal{f}}}[l'/]}\\ ] ]    [ [ seq-3 ] ] ( seq ) + + + + +    by the induction hypotheses , @xmath145 }    \\intarrow[{v}]{{\\ensuremath{|({\\ensuremath{{\\rho_{t}}}}{\\cdot}\\rho)[l'/l } } a^{\\,s[l'/l]}}}{s'[l'/l]}{{\\ensuremath{\\mathcal{f}}}[l'/]}\\ ] ] besides , @xmath148 , therefore @xmath149 . then , by the induction hypotheses , @xmath117 }    \\intarrow[{s'[l'/l]}]{{\\ensuremath{{\\ensuremath{{\\rho_{t}}}}[l'/l|]}}^{\\,b}}}{v'}{s''[l'/l]}{{\\ensuremath{\\mathcal{f}}}[l'/]}\\ ] ] hence @xmath117 }    \\intarrow[{s[l'/l]}]{{\\ensuremath{{\\ensuremath{{\\rho_{t}}}}[l'/l|]}}^{\\,a\\ ; \\ b}}}{v'}{s''[l'/l]}{{\\ensuremath{\\mathcal{f}}}[l'/]}\\ ] ]    [ [ if - true - and - if - false-3 ] ] ( if - true ) and ( if - false ) + + + + + + + + + + + + + + + + + + + + + + + +    are proved similarly to ( seq ) .",
    "[ [ letrec-3 ] ] ( letrec ) + + + + + + + +    since @xmath115 appears neither in @xmath15 nor in @xmath16 , it does not appear in @xmath127 either . by the induction hypotheses , @xmath117 }    \\intarrow[{s[l'/l]}]{{\\ensuremath{{\\ensuremath{{\\rho_{t}}}}[l'/l|]}}^{\\,b}}}{v}{s'[l'/l]}{\\mathcal{f'}[l'/l]}\\ ] ] moreover , @xmath150={\\ensuremath{{\\ensuremath{\\mathcal{f}}}[l'/l ] + \\{f\\mapsto{\\ensuremath{\\left[\\lambda{\\ensuremath{x_{1}\\dotscx_{n}}}.a,\\rho'[l'/l],{\\ensuremath{\\mathcal{f}}}\\right]}}\\ } } } \\ ] ] hence @xmath117 }    \\intarrow[{s}]{{\\ensuremath{{\\ensuremath{{\\rho_{t}}}}[l'/l|]}}^{\\,{\\ensuremath{\\mathop{\\mathbf{letrec}}\\ f({\\ensuremath{x_{1}\\dotscx_{n}}})=a\\    \\mathop{\\mathbf{in}}\\ b}}}}}{v}{s'}{{\\ensuremath{\\mathcal{f}}}[l'/ ] }     \\qedhere\\ ] ]    to prove that using minimal stores is correct , we need to extend them so as to recover the full stores of naive reduction .",
    "the following lemma shows that extending a store before an ( intermediate ) reduction extends the resulting store too :    [ lem : extend - store ] @xmath151{{\\ensuremath{{\\ensuremath{{\\rho_{t}}}}|\\rho } } } v^{\\,s ' } } } ,      \\text { then }     \\forall t { \\sqsupseteq}s , \\exists t'{\\sqsupseteq}s ' ,     { \\ensuremath{m^{\\,t }    \\intarrow[{\\ensuremath{\\mathcal{f}}}]{{\\ensuremath{{\\ensuremath{{\\rho_{t}}}}|\\rho } } } v^{\\,t'}}}.\\ ] ] moreover , both derivations have the same height .    by induction on the height of the derivation .",
    "the most interesting case is ( call ) , which requires alpha - converting a location ( hence the induction on the height rather than the structure of the derivation ) .",
    "( var ) , ( val ) and ( assign ) are straightforward by the induction hypotheses and property  [ prop : ext - order ] ; ( seq ) , ( if - true ) , ( if - false ) and ( letrec ) are straightforward by the induction hypotheses .",
    "[ [ call-4 ] ] ( call ) + + + + + +    let @xmath152 . by the induction hypotheses , @xmath153{{\\ensuremath{|{\\ensuremath{{\\rho_{t}}}}{\\cdot}\\rho } } } v_1^{\\,t_2}}}\\\\          \\exists t_{i+1 } { \\sqsupseteq}s_{i+1 } & ,",
    "{ \\ensuremath{a_i^{\\,t_i }    \\intarrow[{\\ensuremath{\\mathcal{f}}}]{{\\ensuremath{|{\\ensuremath{{\\rho_{t}}}}{\\cdot}\\rho } } } v_i^{\\,t_{i+1}}}}\\\\          \\exists t_{n+1 } { \\sqsupseteq}s_{n+1 } & ,          { \\ensuremath{a_n^{\\,t_n }    \\intarrow[{\\ensuremath{\\mathcal{f}}}]{{\\ensuremath{|{\\ensuremath{{\\rho_{t}}}}{\\cdot}\\rho } } } v_n^{\\,t_{n+1 } } } }        \\end{aligned}\\ ] ] the locations @xmath97 might belong to @xmath154 and thus not be fresh . by alpha - conversion",
    "( lemma  [ lem : rename - loc ] ) , we chose fresh @xmath118 ( not in @xmath155 and @xmath136 ) such that @xmath156{{\\ensuremath{(l'_i , v_i)|\\rho ' } } } v^{\\,s'}}}\\ ] ] by property  [ prop : ext - order ] , @xmath157 . by the induction hypotheses , @xmath158{{\\ensuremath{(l'_i , v_i)|\\rho ' } } } v^{\\,t'}}}\\ ] ] moreover , @xmath159 .",
    "hence , @xmath160{{\\ensuremath{{\\ensuremath{{\\rho_{t}}}}|\\rho } } } v^{\\,{t ' \\setminus { \\ensuremath{{\\rho_{t}}}}}}}}.\\ ] ]    [ [ var-4 ] ] ( var ) + + + + +    let @xmath161 . @xmath162{{\\ensuremath{{\\ensuremath{{\\rho_{t}}}}|\\rho } } } v^{\\,{t \\setminus { \\ensuremath{{\\rho_{t}}}}}}}}$ ] and @xmath163 ( property  [ prop : ext - order ] ) .",
    "[ [ val-4 ] ] ( val ) + + + + +    let @xmath161 . @xmath164{{\\ensuremath{{\\ensuremath{{\\rho_{t}}}}|\\rho } } } t\\ l^{\\,{t \\setminus { \\ensuremath{{\\rho_{t}}}}}}}}$ ] and @xmath163 ( property  [ prop : ext - order ] ) .",
    "moreover , @xmath165 because @xmath166 and @xmath167 .",
    "[ [ assign-4 ] ] ( assign ) + + + + + + + +    let @xmath161 . by the induction hypotheses , @xmath168{{\\ensuremath{|{\\ensuremath{{\\rho_{t}}}}{\\cdot}\\rho } } } v^{\\,t'}}}\\ ] ] hence , @xmath169{{\\ensuremath{{\\ensuremath{{\\rho_{t}}}}|\\rho } } } { \\ensuremath{\\mathbf{1}}}^{\\,{{{\\ensuremath{t ' + \\{l\\mapstov\\ } } }",
    "} \\setminus { \\ensuremath{{\\rho_{t}}}}}}}}\\ ] ] concludes , since @xmath170 ( property  [ prop : ext - order ] ) .",
    "[ [ seq-4 ] ] ( seq ) + + + + +    let @xmath161 . by the induction hypotheses , @xmath171{{\\ensuremath{|{\\ensuremath{{\\rho_{t}}}}{\\cdot}\\rho } } } v^{\\,t'}}}\\\\          \\exists t''{\\sqsupseteq}s '' & , { \\ensuremath{b^{\\,t ' }    \\intarrow[{\\ensuremath{\\mathcal{f}}}]{{\\ensuremath{{\\ensuremath{{\\rho_{t}}}}|\\rho } } } v'^{\\,t '' } } }        \\end{aligned}\\ ] ] hence , @xmath172{{\\ensuremath{{\\ensuremath{{\\rho_{t}}}}|\\rho } } } v'^{\\,t''}}}\\ ] ]    [ [ if - true - and - if - false-4 ] ] ( if - true ) and ( if - false ) + + + + + + + + + + + + + + + + + + + + + + + +    are proved similarly to ( seq ) .    [ [ letrec-4 ] ] ( letrec ) + + + + + + + +    let @xmath161 . by the induction hypotheses , @xmath173{{\\ensuremath{{\\ensuremath{{\\rho_{t}}}}|\\rho } } } v^{\\,s'}}}\\ ] ] hence , @xmath174{{\\ensuremath{{\\ensuremath{{\\rho_{t}}}}|\\rho } } } v^{\\,t ' } } }        \\qedhere\\ ] ]    now we can show the required lemmas and prove the equivalence between the intermediate and naive reduction rules .",
    "[ lem : iimpliesn ] @xmath69{{\\ensuremath{{\\ensuremath{{\\rho_{t}}}}|\\rho } } } v^{\\,s ' } } }      \\text { then }      \\exists t'{\\sqsupseteq}s ' , { \\ensuremath{m^{\\,s }    \\naivearrow[{\\ensuremath{\\mathcal{f}}}]{{\\ensuremath{{\\rho_{t}}}}{\\cdot}\\rho } v^{\\,t'}}}.\\ ] ]    by induction on the height of the derivation , because some stores are modified during the proof .",
    "the interesting cases are ( seq ) and ( call ) , where lemma  [ lem : extend - store ] is used to extend intermediary stores . other cases are straightforward by property  [ prop : ext - order ] and the induction hypotheses .",
    "[ [ seq-5 ] ] ( seq ) + + + + +    by the induction hypotheses , @xmath175{\\rho } v^{\\,t'}}}.\\ ] ] moreover , @xmath58{{\\ensuremath{{\\ensuremath{{\\rho_{t}}}}|\\rho } } } v'^{\\,s''}}}.\\ ] ] since @xmath176 , lemma  [ lem : extend - store ] leads to : @xmath177{{\\ensuremath{{\\ensuremath{{\\rho_{t}}}}|\\rho } } } v'^{\\,t}}}\\ ] ] and the height of the derivation is preserved . by the induction hypotheses , @xmath178{\\rho } v'^{\\,t''}}}\\ ] ] hence , since @xmath108 is transitive ( property  [ prop : ext - order ] ) , @xmath179{\\rho } v'^{\\,t''}}}.\\ ] ]    [ [ call-5 ] ] ( call ) + + + + + +    similarly to the ( seq ) case , we apply the induction hypotheses and lemma  [ lem : extend - store ] : @xmath180{\\rho } v_1^{\\,t_2}}}&\\text{(induction)}\\\\          \\exists t'_{i+1 } { \\sqsupseteq}s_{i+1 } & ,          { \\ensuremath{a_i^{\\,t_i }    \\intarrow[{\\ensuremath{\\mathcal{f}}}]{{\\ensuremath{|{\\ensuremath{{\\rho_{t}}}}{\\cdot}\\rho } } } v_i^{\\,t'_{i+1}}}}&\\text{(lemma~\\ref{lem : extend - store})}\\\\          \\exists t_{i+1 } { \\sqsupseteq}t'_{i+1 } { \\sqsupseteq}s_{i+1 } & ,          { \\ensuremath{a_i^{\\,t_i }    \\naivearrow[{\\ensuremath{\\mathcal{f}}}]{\\rho } v_i^{\\,t_{i+1}}}}&\\text{(induction)}\\\\          \\exists t'_{n+1 } { \\sqsupseteq}s_{n+1 } & ,          { \\ensuremath{a_n^{\\,t_n }    \\intarrow[{\\ensuremath{\\mathcal{f}}}]{{\\ensuremath{|{\\ensuremath{{\\rho_{t}}}}{\\cdot}\\rho } } } v_n^{\\,t'_{n+1}}}}&\\text{(lemma~\\ref{lem : extend - store})}\\\\          \\exists t_{n+1 } { \\sqsupseteq}t'_{n+1 } { \\sqsupseteq}s_{n+1 } & ,          { \\ensuremath{a_n^{\\,t_n }    \\naivearrow[{\\ensuremath{\\mathcal{f}}}]{\\rho } v_n^{\\,t_{n+1}}}}&\\text{(induction ) }        \\end{aligned}\\ ] ] the locations @xmath97 might belong to @xmath154 and thus not be fresh . by alpha - conversion ( lemma  [ lem : rename - loc ] )",
    ", we choose a set of fresh @xmath118 ( not in @xmath155 and @xmath136 ) such that @xmath156{{\\ensuremath{(l'_i , v_i)|\\rho ' } } } v^{\\,s'}}}.\\ ] ] by property  [ prop : ext - order ] , @xmath157 .",
    "lemma  [ lem : extend - store ] leads to , @xmath181{{\\ensuremath{(l'_i , v_i)|\\rho ' } } } v^{\\,t}}}.\\ ] ] by the induction hypotheses , @xmath182{(l'_i , v_i){\\cdot}\\rho ' } v^{\\,t'}}}.\\ ] ] moreover , @xmath159 .",
    "hence , @xmath183{\\rho } v^{\\,{t ' \\setminus { \\ensuremath{{\\rho_{t}}}}}}}}.\\ ] ]    [ [ val-5 ] ] ( val ) + + + + +    @xmath184{\\rho } v^{\\,t'}}}$ ] with @xmath185 .",
    "[ [ var-5 ] ] ( var ) + + + + +    @xmath186{\\rho } s\\ l^{\\,s''}}}$ ] with @xmath185 .    [",
    "[ assign-5 ] ] ( assign ) + + + + + + + +    by the induction hypotheses , @xmath187{\\rho } v^{\\,t'}}}\\ ] ] hence , @xmath188{\\rho } { \\ensuremath{\\mathbf{1}}}^{\\,{{\\ensuremath{t ' + \\{l\\mapstov\\ } } } } } } } \\ ] ] concludes since @xmath189 ( property  [ prop : ext - order ] ) .",
    "[ [ if - true - and - if - false-5 ] ] ( if - true ) and ( if - false ) + + + + + + + + + + + + + + + + + + + + + + + +    are proved similarly to ( seq ) .    [ [ letrec-5 ] ] ( letrec ) + + + + + + + +    by the induction hypotheses , @xmath190{\\rho } v^{\\,s'}}}.\\ ] ] hence , @xmath191{\\rho } v^{\\,t'}}}.        \\qedhere\\ ] ]    the proof of the converse property  i.e.   if a term reduces in the naive reduction rules , it reduces in the intermediate reduction rules too  is more complex because the naive reduction rules provide very weak invariants about stores and environments .",
    "for that reason , we add an hypothesis to ensure that every location appearing in the environments @xmath4 , @xmath42 and @xmath16 also appears in the store @xmath5 : @xmath192 moreover , since stores are often larger in the naive reduction rules than in the intermediate ones , we need to generalise the induction hypothesis .",
    "[ lem : nimpliesi ]    assume @xmath193 .",
    "then , @xmath194{{\\ensuremath{{\\rho_{t}}}}{\\cdot}\\rho } v^{\\,s'}}}$ ] implies @xmath195{{\\ensuremath{{\\ensuremath{{\\rho_{t}}}}|\\rho } } } v^{\\,s'|_{{\\mathop{\\mathrm{dom}}\\nolimits}(t)\\setminus{\\mathop{\\mathrm{im}}\\nolimits}({\\ensuremath{{\\rho_{t}}}})}}}}.\\ ] ]    by induction on the structure of the derivation .",
    "[ [ val-6 ] ] ( val ) + + + + +    let @xmath196 .",
    "then @xmath197 hence , @xmath198{{\\ensuremath{{\\ensuremath{{\\rho_{t}}}}|\\rho } } } v^{\\,{t \\setminus { \\ensuremath{{\\rho_{t}}}}}}}}.\\ ] ]    [ [ var-6 ] ] ( var ) + + + + +    let @xmath196 such that @xmath199 . note that @xmath200 implies @xmath165 . then , @xmath197 hence , @xmath201{{\\ensuremath{{\\ensuremath{{\\rho_{t}}}}|\\rho } } } t\\ l^{\\,{t \\setminus { \\ensuremath{{\\rho_{t}}}}}}}}.\\ ] ]    [ [ assign-6 ] ] ( assign ) + + + + + + + +    let @xmath196 such that @xmath199 . by the induction hypotheses ,",
    "since @xmath202 , @xmath203{{\\ensuremath{|{\\ensuremath{{\\rho_{t}}}}{\\cdot}\\rho } } } v^{\\,s'|_{{\\mathop{\\mathrm{dom}}\\nolimits}(t)}}}}\\ ] ] note that @xmath200 implies @xmath204 .",
    "then @xmath205 hence , @xmath206{{\\ensuremath{{\\ensuremath{{\\rho_{t}}}}|\\rho } } } { \\ensuremath{\\mathbf{1}}}^{\\,{({{\\ensuremath{s'|_{{\\mathop{\\mathrm{dom}}\\nolimits}(t ) } + \\{l\\mapstov\\ } } } } ) \\setminus { \\ensuremath{{\\rho_{t}}}}}}}}.\\ ] ]    [ [ seq-6 ] ] ( seq ) + + + + +    let @xmath196 such that @xmath199 . by the induction hypotheses ,",
    "since @xmath202 , @xmath203{{\\ensuremath{|{\\ensuremath{{\\rho_{t}}}}{\\cdot}\\rho } } } v^{\\,s'|_{{\\mathop{\\mathrm{dom}}\\nolimits}(t)}}}}\\ ] ] moreover , @xmath207 and @xmath208 . by the induction hypotheses ,",
    "this leads to : @xmath209{{\\ensuremath{{\\ensuremath{{\\rho_{t}}}}|\\rho } } } v'^{\\,s''|_{{\\mathop{\\mathrm{dom}}\\nolimits}(s'|_{{\\mathop{\\mathrm{dom}}\\nolimits}(t)})\\setminus{\\mathop{\\mathrm{im}}\\nolimits}({\\ensuremath{{\\rho_{t}}}})}}}}.\\ ] ] hence , with @xmath210 , @xmath211{{\\ensuremath{{\\ensuremath{{\\rho_{t}}}}|\\rho } } } v'^{\\,s''|_{{\\mathop{\\mathrm{dom}}\\nolimits}(t)\\setminus{\\mathop{\\mathrm{im}}\\nolimits}({\\ensuremath{{\\rho_{t}}}})}}}}.\\ ] ]    [ [ if - true - and - if - false-6 ] ] ( if - true ) and ( if - false ) + + + + + + + + + + + + + + + + + + + + + + + +    are proved similarly to ( seq ) .",
    "[ [ letrec-6 ] ] ( letrec ) + + + + + + + +    let @xmath196 such that @xmath199 .",
    "@xmath212 then , by the induction hypotheses , @xmath213{{\\ensuremath{{\\ensuremath{{\\rho_{t}}}}|\\rho } } } v^{\\,s'|_{{\\mathop{\\mathrm{dom}}\\nolimits}(t)\\setminus{\\mathop{\\mathrm{im}}\\nolimits}({\\ensuremath{{\\rho_{t}}}})}}}}.\\ ] ] hence , @xmath214{{\\ensuremath{{\\ensuremath{{\\rho_{t}}}}|\\rho } } } v^{\\,s'|_{{\\mathop{\\mathrm{dom}}\\nolimits}(t)\\setminus{\\mathop{\\mathrm{im}}\\nolimits}({\\ensuremath{{\\rho_{t}}}})}}}}.\\ ] ]    [ [ call-6 ] ] ( call ) +",
    "+ + + + +    let @xmath215 such that @xmath199 .",
    "note the following equalities : @xmath216 by the induction hypotheses , they yield : @xmath217{{\\ensuremath{|{\\ensuremath{{\\rho_{t}}}}{\\cdot}\\rho } } } v_1^{\\,s_2|_{{\\mathop{\\mathrm{dom}}\\nolimits}(t)}}}}\\\\         { \\ensuremath{a_2^{\\,s_2|_{{\\mathop{\\mathrm{dom}}\\nolimits}(t ) } }    \\intarrow[{\\ensuremath{\\mathcal{f}}}]{{\\ensuremath{|{\\ensuremath{{\\rho_{t}}}}{\\cdot}\\rho } } } v_1^{\\,s_3|_{{\\mathop{\\mathrm{dom}}\\nolimits}(t)}}}}\\\\         \\forall i,{\\ensuremath{a_i^{\\,s_i|_{{\\mathop{\\mathrm{dom}}\\nolimits}(t ) } }    \\intarrow[{\\ensuremath{\\mathcal{f}}}]{{\\ensuremath{|{\\ensuremath{{\\rho_{t}}}}{\\cdot}\\rho } } } v_i^{\\,s_{i+1}|_{{\\mathop{\\mathrm{dom}}\\nolimits}(t ) } } } }       \\end{aligned}\\ ] ] moreover , @xmath218 implies @xmath219 ( property  [ prop : ext - order ] ) and : @xmath220 then , by the induction hypotheses , @xmath221{{\\ensuremath{\\rho''|\\rho ' } } } v^{\\,s'|_{{\\mathop{\\mathrm{dom}}\\nolimits}({\\ensuremath{s_{n+1}|_{{\\mathop{\\mathrm{dom}}\\nolimits}(t ) } + \\{l_i\\mapstov_i\\ } } } ) \\setminus{\\mathop{\\mathrm{im}}\\nolimits}(\\rho'')}}}}\\ ] ] finally , @xmath222 hence , @xmath223{{\\ensuremath{{\\ensuremath{{\\rho_{t}}}}|\\rho } } } v^{\\,({s ' \\setminus { \\ensuremath{{\\rho_{t}}}}})|_{{\\mathop{\\mathrm{dom}}\\nolimits}(t)\\setminus{\\mathop{\\mathrm{im}}\\nolimits}({\\ensuremath{{\\rho_{t}}}})}}}}.       \\qedhere\\ ] ]      in this section , we prove the correctness of lambda - lifting ( theorem  [ thm : lambda - lifting - correctness ] , p.  ) by induction on the height of the optimised reduction .",
    "section  [ sec : strong - invariants ] defines stronger invariants and rewords the correctness theorem with them .",
    "section  [ sec : overview ] gives an overview of the proof .",
    "sections  [ sec : rewriting - lemmas ] and  [ sec : aliasing - lemmas ] prove a few lemmas needed for the proof .",
    "section  [ sec : proof - correctness ] contains the actual proof of correctness .",
    "we need strong induction hypotheses to ensure that key invariants about stores and environments hold at every step . for that purpose ,",
    "we define _ aliasing - free environments _ , in which locations may not be referenced by more than one variable , and _ local positions_. they yield a strengthened version of liftable parameters ( definition  [ dfn : var - liftable ] ) .",
    "we then define lifted environments ( definition  [ dfn : lifted - env ] ) to mirror the effect of lambda - lifting in lifted terms captured in closures , and finally reformulate the correctness of lambda - lifting in theorem  [ thm : correction - ll ] with hypotheses strong enough to be provable directly by induction .",
    "[ dfn : aliasing ] a set of environments @xmath224 is _ aliasing - free _ when : @xmath225 by extension , an environment of functions @xmath16 is aliasing - free when @xmath226 is aliasing - free .",
    "the notion of aliasing - free environments is not an artifact of our small language , but translates a fundamental property of the c semantics : distinct function parameters or local variables are always bound to distinct memory locations ( section  6.2.2 , paragraph  6 in iso / iec 9899 @xcite ) .",
    "a local position is any position in a term except inner functions .",
    "local positions are used to distinguish functions defined directly in a term from deeper nested functions , because we need to enforce invariant  [ case : loc ] ( definition  [ dfn : var - liftable ] ) on the former only .",
    "_ local positions _ are defined inductively as follows :    1 .",
    "@xmath30 is in local position in @xmath30 , @xmath227 , @xmath228 , @xmath229 and @xmath230 .",
    "@xmath32 is in local position in @xmath35 .",
    "we extend the notion of liftable parameter ( definition  [ dfn : var - liftable - simple ] , p.  ) to enforce invariants on stores and environments .",
    "[ dfn : var - liftable ] the parameter @xmath25 is _ liftable _ in @xmath231 when :    1 .",
    "@xmath25 is defined as the parameter of a function @xmath26 , either in @xmath30 or in @xmath16 , [ case : def ] 2 .   in both @xmath30 and @xmath16 , inner functions in @xmath26 , named @xmath27 ,",
    "are defined and called exclusively : 1 .   in tail position in @xmath26 , or 2 .   in tail position in some @xmath232 ( with possibly @xmath233 ) , or 3 .   in tail position in @xmath30 , + [",
    "case : pos ] 3 .   for all @xmath8 defined in local position in @xmath30 , @xmath234 , [",
    "case : loc ] 4 .   moreover , if @xmath27 is called in tail position in @xmath30 , then @xmath235 , [ case : term ] 5 .   in @xmath48 , @xmath25 appears necessarily and exclusively in the environments of the @xmath27 s closures , [ case : exclu ] 6 .",
    "@xmath16 contains only compact closures and @xmath236 is aliasing - free .",
    "[ case : share ]    we also extend the definition of lambda - lifting ( definition  [ dfn : lifted - term ] , p.  ) to environments , in order to reflect changes in lambda - lifted parameters captured in closures .",
    "[ dfn : lifted - env ] @xmath237}}\\qquad\\text{then}\\\\    { \\ensuremath{\\mathop{({\\ensuremath{\\mathcal{f}}})}\\nolimits_{\\ast}}}\\ f= &    \\begin{cases }    { \\ensuremath{\\left[\\lambda{\\ensuremath{x_{1}\\dotscx_{n}}}x.{\\ensuremath{\\mathop{(b)}\\nolimits_{\\ast}}},\\rho'|_{{\\mathop{\\mathrm{dom}}\\nolimits}(\\rho')\\setminus\\{x\\}},{\\ensuremath{\\mathop{(\\mathcal{f'})}\\nolimits_{\\ast}}}\\right]}}&\\text{when    $ f = h_i$ for some $ i$}\\\\    { \\ensuremath{\\left[\\lambda{\\ensuremath{x_{1}\\dotscx_{n}}}.{\\ensuremath{\\mathop{(b)}\\nolimits_{\\ast}}},\\rho',{\\ensuremath{\\mathop{(\\mathcal{f'})}\\nolimits_{\\ast}}}\\right]}}&\\text{otherwise }    \\qedhere    \\end{cases }    \\end{aligned}\\ ] ]    lifted environments are defined such that a liftable parameter never appears in them .",
    "this property will be useful during the proof of correctness .",
    "[ lem : fstarclean ] if @xmath25 is a liftable parameter in @xmath231 , then @xmath25 does not appear in @xmath238 .",
    "since @xmath25 is liftable in @xmath239 , it appears exclusively in the environments of @xmath27 . by definition",
    ", it is removed when building @xmath238 .",
    "these invariants and definitions lead to a correctness theorem with stronger hypotheses .",
    "[ thm : correction - ll ] if @xmath25 is a liftable parameter in @xmath231 , then @xmath240{{\\ensuremath{{\\ensuremath{{\\rho_{t}}}}|\\rho } } } v^{\\,s ' } } } \\text { implies } { \\ensuremath{{\\ensuremath{\\mathop{(m)}\\nolimits_{\\ast}}}^{\\,s }    \\optarrow[{{\\ensuremath{\\mathop{({\\ensuremath{\\mathcal{f}}})}\\nolimits_{\\ast}}}}]{{\\ensuremath{{\\ensuremath{{\\rho_{t}}}}|\\rho } } } v^{\\,s'}}}\\ ] ]    since naive and optimised reductions rules are equivalent ( theorem  [ thm : sem - equiv ] , p.  ) , the proof of theorem  [ thm : lambda - lifting - correctness ] ( p.  ) is a direct corollary of this theorem .",
    "if @xmath25 is a liftable parameter in @xmath30 , then @xmath36{\\varepsilon } v^{\\,t } } } \\text { implies } \\exists t ' , { \\ensuremath{{\\ensuremath{\\mathop{(m)}\\nolimits_{\\ast}}}^{\\,\\varepsilon }    \\naivearrow[\\varepsilon]{\\varepsilon } v^{\\,t'}}}.\\ ] ]      with the enhanced liftability definition , we have invariants strong enough to perform a proof by induction of the correctness theorem .",
    "this proof is detailed in section  [ sec : proof - correctness ] .",
    "the proof is not by structural induction but by induction on the height of the derivation .",
    "this is necessary because , even with the stronger invariants , we can not apply the induction hypotheses directly to the premises in the case of the ( call ) rule : we have to change the stores and environments , which means rewriting the whole derivation tree , before using the induction hypotheses .    to deal with this most difficult case ,",
    "we distinguish between calling one of the lifted functions ( @xmath241 ) and calling another function ( either @xmath26 , where @xmath25 is defined , or any other function outside of @xmath26 ) . only the former requires rewriting ; the latter follows directly from the induction hypotheses .",
    "in the ( call ) rule with @xmath241 , issues arise when reducing the body @xmath242 of the lifted function . during this reduction , indeed",
    ", the store contains a new location @xmath115 bound by the environment to the lifted variable @xmath25 , but also contains the location @xmath23 which contains the original value of @xmath25 .",
    "our goal is to show that the reduction of @xmath242 implies the reduction of @xmath243 , with store and environments fulfilling the constraints of the ( call ) rule .    to obtain the reduction of the lifted body @xmath243",
    ", we modify the reduction of @xmath242 in a series of steps , using several lemmas :    * the location @xmath23 of the free variable @xmath25 is moved to the tail environment ( lemma  [ lem : switch - x ] ) ; * the resulting reduction meets the induction hypotheses , which we apply to obtain the reduction of the lifted body @xmath243 ; * however , this reduction does not meet the constraints of the optimised reduction rules because the location @xmath23 is not fresh : we rename it to a fresh location @xmath115 to hold the lifted variable ( lemma  [ lem : rename - loc - opt ] ) ; * finally , since we renamed @xmath23 to @xmath115 , we need to reintroduce a location @xmath23 to hold the original value of @xmath25 ( lemmas  [ lem : intro - in - store ] and  [ lem : intro - in - env ] ) .",
    "the rewriting lemmas used in the ( call ) case are shown in section  [ sec : rewriting - lemmas ] .",
    "for every other case , the proof consists in checking thoroughly that the induction hypotheses apply , in particular that @xmath25 is liftable in the premises .",
    "these verifications consist in checking invariants  [ case : loc ] to  [ case : share ] of the extended liftability definition ( definition  [ dfn : var - liftable ] )  invariants  [ case : def ] and  [ case : pos ] are obvious enough not to be detailed . to keep the main proof as compact as possible ,",
    "the most difficult cases of liftability , related to aliasing , are proven in some preliminary lemmas ( section  [ sec : aliasing - lemmas ] ) .",
    "one last issue arises during the induction when one of the premises does not contain the lifted variable @xmath25 . in that case",
    ", the invariants do not hold , since they assume the presence of @xmath25 .",
    "but it turns out that in this very case , the lifting function is the identity ( since there is no variable to lift ) and lambda - lifting is trivially correct .",
    "calling a lifted function has an impact on the resulting store : new locations are introduced for the lifted parameters and the earlier locations , which are not modified anymore , are hidden . because of these changes , the induction hypotheses do not apply directly in the case of the ( call ) rule for a lifted function @xmath27 .",
    "we use the following four lemmas to obtain , through several rewriting steps , a reduction of lifted terms meeting the induction hypotheses .",
    "* lemma  [ lem : switch - x ] shows that moving a variable from the non - tail environment @xmath4 to the tail environment @xmath42 does not change the result , but restricts the domain of the store .",
    "it is used transform the original free variable @xmath25 ( in the non - tail environment ) to its lifted copy ( which is a parameter of @xmath27 , hence in the tail environment ) .",
    "* lemma  [ lem : rename - loc - opt ] handles alpha - conversion in stores and is used when choosing a fresh location .",
    "* lemmas  [ lem : intro - in - store ] and  [ lem : intro - in - env ] finally add into the store and the environment a fresh location , bound to an arbitrary value .",
    "it is used to reintroduce the location containing the original value of @xmath25 , after it has been alpha - converted to @xmath115 .",
    "[ lem : switch - x ] if @xmath244{{\\ensuremath{{\\ensuremath{{\\rho_{t}}}}|(x , l){\\cdot}\\rho } } } v^{\\,s'}}}$ ] and @xmath245 then @xmath244{{\\ensuremath{{\\ensuremath{{\\rho_{t}}}}{\\cdot}(x , l)|\\rho } } } v^{\\,s'|_{{\\mathop{\\mathrm{dom}}\\nolimits}(s')\\setminus\\{l\\}}}}}$ ] .",
    "moreover , both derivations have the same height .    by induction on the structure of the derivation .",
    "for the ( val ) , ( var ) , ( assign ) and ( call ) cases , we use the fact that @xmath246 when @xmath247 .",
    "[ [ val-7 ] ] ( val ) + + + + +    @xmath248{{\\ensuremath{{\\ensuremath{{\\rho_{t}}}}{\\cdot}(x , l)|\\rho } } } v^{\\,{s \\setminus { \\ensuremath{{\\rho_{t}}}}{\\cdot}(x , l)}}}}$ ] and @xmath246 with @xmath247 .    [",
    "[ var-7 ] ] ( var ) + + + + +    @xmath249{{\\ensuremath{{\\ensuremath{{\\rho_{t}}}}{\\cdot}(x , l)|\\rho } } } s\\ l'^{\\,{s \\setminus { \\ensuremath{{\\rho_{t}}}}{\\cdot}(x , l)}}}}$ ] and @xmath246 , with @xmath250 and @xmath247 .    [",
    "[ assign-7 ] ] ( assign ) + + + + + + + +    by hypothesis , @xmath251{{\\ensuremath{|{\\ensuremath{{\\rho_{t}}}}{\\cdot}(x , l){\\cdot}\\rho } } } v^{\\,s'}}}$ ] hence @xmath252{{\\ensuremath{{\\ensuremath{{\\rho_{t}}}}{\\cdot}(x , l)|\\rho } } } { \\ensuremath{\\mathbf{1}}}^{\\,{{{\\ensuremath{s ' + \\{l'\\mapstov\\ } } } } \\setminus { \\ensuremath{{\\rho_{t}}}}{\\cdot}(x , l)}}}}$ ] and @xmath253 with @xmath250 and @xmath254 .    [",
    "[ seq-7 ] ] ( seq ) + + + + +    by hypothesis , @xmath251{{\\ensuremath{|{\\ensuremath{{\\rho_{t}}}}{\\cdot}(x , l){\\cdot}\\rho } } } v^{\\,s'}}}$ ] and , by the induction hypotheses , @xmath255{{\\ensuremath{{\\ensuremath{{\\rho_{t}}}}{\\cdot}(x , l)|\\rho } } } v^{\\,s''|_{{\\mathop{\\mathrm{dom}}\\nolimits}(s'')\\setminus\\{l\\}}}}}$ ] hence @xmath256{{\\ensuremath{{\\ensuremath{{\\rho_{t}}}}{\\cdot}(x , l)|\\rho } } } v^{\\,s''|_{{\\mathop{\\mathrm{dom}}\\nolimits}(s'')\\setminus\\{l\\}}}}}.\\ ] ]    [ [ if - true - and - if - false-7 ] ] ( if - true ) and ( if - false ) + + + + + + + + + + + + + + + + + + + + + + + +    are proved similarly to ( seq ) .",
    "[ [ letrec-7 ] ] ( letrec ) + + + + + + + +    by the induction hypotheses , @xmath257{{\\ensuremath{{\\ensuremath{{\\rho_{t}}}}{\\cdot}(x , l)|\\rho } } } v^{\\,s'|_{{\\mathop{\\mathrm{dom}}\\nolimits}(s')\\setminus\\{l\\}}}}}\\ ] ] hence @xmath258{{\\ensuremath{{\\ensuremath{{\\rho_{t}}}}{\\cdot}(x , l)|\\rho } } } v^{\\,s'|_{{\\mathop{\\mathrm{dom}}\\nolimits}(s')\\setminus\\{l\\}}}}}\\ ] ]    [ [ call-7 ] ] ( call ) + + + + + +    the hypotheses do not change , and the conclusion becomes : @xmath259{{\\ensuremath{{\\ensuremath{{\\rho_{t}}}}{\\cdot}(x , l)|\\rho } } } v^{\\,{s ' \\setminus { \\ensuremath{{\\rho_{t}}}}{\\cdot}(x , l)}}}}\\ ] ] as expected , since @xmath260 with @xmath261    [ lem : rename - loc - opt ] if @xmath262{{\\ensuremath{{\\ensuremath{{\\rho_{t}}}}|\\rho } } } v^{\\,s'}$ ] then , for all @xmath23 , for all @xmath115 appearing neither in @xmath5 nor in @xmath16 nor in @xmath116 , @xmath117 }    \\optarrow[{s[l'/l]}]{{\\ensuremath{{\\ensuremath{{\\rho_{t}}}}[l'/l|]}}^{\\,m}}}{v}{s'[l'/l]}{{\\ensuremath{\\mathcal{f}}}[l'/l]}\\ ] ] moreover , both derivations have the same height .",
    "see lemma  [ lem : rename - loc ] , p.  [ lem : rename - loc ] .",
    "[ lem : intro - in - store ] if @xmath244{{\\ensuremath{{\\ensuremath{{\\rho_{t}}}}|\\rho } } } v^{\\,s'}}}$ ] and @xmath263 does not appear in either @xmath5 , @xmath16 or @xmath264 , then , for all value @xmath265 , @xmath266{{\\ensuremath{{\\ensuremath{{\\rho_{t}}}}|\\rho } } } v^{\\,{\\ensuremath{s ' + \\{k\\mapstou\\ } } } } } } $ ] .",
    "moreover , both derivations have the same height .    by induction on the height of the derivation .",
    "the key idea is to add @xmath267 to every store in the derivation tree .",
    "a collision might occur in the ( call ) rule , if there is some @xmath128 such that @xmath268 . in that case , we need to rename @xmath131 to some fresh variable @xmath269 ( by alpha - conversion ) before applying the induction hypotheses .",
    "[ [ call-8 ] ] ( call ) + + + + + +    by the induction hypotheses , @xmath270{{\\ensuremath{|{\\ensuremath{{\\rho_{t}}}}{\\cdot}\\rho } } } v_i^{\\,{\\ensuremath{s_{i+1 } + \\{k\\mapstou\\ } } } } } } \\ ] ] because @xmath263 does not appear in @xmath16 , @xmath271 for the same reason , it does not appear in @xmath15 .",
    "on the other hand , there might be a @xmath128 such that @xmath268 , so @xmath263 might appear in @xmath130 . in that case",
    ", we rename @xmath131 in some fresh @xmath269 , appearing in neither @xmath134 , nor @xmath127 or @xmath272 ( lemma  [ lem : rename - loc - opt ] ) . after this alpha - conversion",
    ", @xmath263 does not appear in either @xmath272 , @xmath24 , or @xmath273 . by the induction hypotheses , @xmath274{{\\ensuremath{\\rho''|\\rho ' } } } v^{\\,{\\ensuremath{s ' + \\{k\\mapstou\\ } } } } } } \\ ] ] moreover , @xmath275 ( since @xmath263 does not appear in @xmath42 ) .",
    "hence @xmath276{{\\ensuremath{{\\ensuremath{{\\rho_{t}}}}|\\rho } } } v^{\\,{{\\ensuremath{s ' + \\{k\\mapstou\\ } } } \\setminus { \\ensuremath{{\\rho_{t}}}}}}}}.\\ ] ]    [ [ val-8 ] ] ( val ) + + + + +    @xmath277{{\\ensuremath{{\\ensuremath{{\\rho_{t}}}}|\\rho } } } v^{\\,{{\\ensuremath{s + \\{k\\mapstou\\ } } } \\setminus { \\ensuremath{{\\rho_{t}}}}}}}}$ ] and @xmath278 since @xmath263 does not appear in @xmath42 .",
    "[ [ var-8 ] ] ( var ) + + + + +    @xmath279{{\\ensuremath{{\\ensuremath{{\\rho_{t}}}}|\\rho } } } ( { \\ensuremath{s + \\{k\\mapstou\\ } } } ) \\        l^{\\,{{\\ensuremath{s + \\{k\\mapstou\\ } } } \\setminus { \\ensuremath{{\\rho_{t}}}}}}}}$ ] , with @xmath278 since @xmath263 does not appear in @xmath42 , and @xmath280 since @xmath281 ( @xmath263 does not appear in @xmath5 ) .    [",
    "[ assign-8 ] ] ( assign ) + + + + + + + +    by the induction hypotheses , @xmath282{{\\ensuremath{|{\\ensuremath{{\\rho_{t}}}}{\\cdot}\\rho } } } v^{\\,{\\ensuremath{s ' + \\{k\\mapstou\\ } } } } } } $ ] . and @xmath281 ( since @xmath263 does not appear in @xmath5 ) then @xmath283 .",
    "moreover , @xmath263 does not appear in @xmath42 then @xmath284 . hence @xmath285{{\\ensuremath{{\\ensuremath{{\\rho_{t}}}}|\\rho } } } { \\ensuremath{\\mathbf{1}}}^{\\,{\\ensuremath{{{{\\ensuremath{s ' + \\{l\\mapstov\\ } } } } \\setminus { \\ensuremath{{\\rho_{t } } } } } + \\{k\\mapstou\\ } } } } } } \\ ] ]    [ [ seq-8 ] ] ( seq ) + + + + +    by the induction hypotheses , @xmath286{{\\ensuremath{|{\\ensuremath{{\\rho_{t}}}}{\\cdot}\\rho } } } { \\ensuremath{\\mathop{\\mathbf{true}}\\nolimits}}^{\\,{\\ensuremath{s ' + \\{k\\mapstou\\ } } } } } } \\ ] ] @xmath287{{\\ensuremath{{\\ensuremath{{\\rho_{t}}}}|\\rho } } } v'^{\\,{\\ensuremath{s '' + \\{k\\mapstou\\ } } } } } } \\ ] ] hence @xmath288{{\\ensuremath{{\\ensuremath{{\\rho_{t}}}}|\\rho } } } v'^{\\,{\\ensuremath{s '' + \\{k\\mapstou\\ } } } } } } \\ ] ]    [ [ if - true - and - if - false-8 ] ] ( if - true ) and ( if - false ) + + + + + + + + + + + + + + + + + + + + + + + +    are proved similarly to ( seq ) .",
    "[ [ letrec-8 ] ] ( letrec ) + + + + + + + +    the location @xmath263 does not appear in @xmath127 , because it does not appear in either @xmath16 or @xmath289 ( @xmath290}}\\ } } } $ ] ) . then , by the induction hypotheses , @xmath291{{\\ensuremath{{\\ensuremath{{\\rho_{t}}}}|\\rho } } } v^{\\,{\\ensuremath{s ' + \\{k\\mapstou\\ } } } } } } \\ ] ] hence @xmath292{{\\ensuremath{{\\ensuremath{{\\rho_{t}}}}|\\rho } } } v^{\\,{\\ensuremath{s ' + \\{k\\mapstou\\ } } } } } } .",
    "\\qedhere\\ ] ]    [ lem : intro - in - env ] @xmath293{{\\ensuremath{{\\ensuremath{{\\rho_{t}}}}{\\cdot}(x , l)|\\rho } } } v^{\\,s ' } } } { \\ensuremath{\\quad\\text{iff}\\quad } } &    { \\ensuremath{m^{\\,s }    \\optarrow[{\\ensuremath{\\mathcal{f}}}]{{\\ensuremath{{\\ensuremath{{\\rho_{t}}}}{\\cdot}(x , l)|(x , l'){\\cdot}\\rho } } } v^{\\,s ' } } }    \\end{aligned}\\ ] ] moreover , both derivations have the same height .",
    "see lemma  [ lem : intro - in - env2 ] , p.  [ lem : intro - in - env2 ] .",
    "we need three lemmas to show that environments remain aliasing - free during the proof by induction in section  [ sec : proof - correctness ] .",
    "the first lemma states that concatenating two environments in an aliasing - free set yields an aliasing - free set .",
    "the other two prove that the aliasing invariant ( invariant  [ case : share ] , definition  [ dfn : var - liftable ] ) holds in the context of the ( call ) and ( letrec ) rules , respectively .",
    "[ lem : alias - concat ] if @xmath294 is aliasing - free then @xmath295 is aliasing - free .    by exhaustive check of cases .",
    "we want to prove @xmath296 if @xmath297 and @xmath298 , immediate . if @xmath299 , @xmath300 .",
    "this is the same for @xmath301 .",
    "then @xmath302 is equivalent to @xmath303 ( or some other combination , depending on @xmath25 , @xmath304 , @xmath305 and @xmath301 ) which leads to the expected result .",
    "[ lem : aliasing - call ] assume that , in a ( call ) rule ,    * @xmath306}}$ ] , * @xmath226 is aliasing - free , and * @xmath307 , with fresh and distinct locations @xmath308 .    then @xmath309 is also aliasing - free .",
    "let @xmath310 .",
    "we know that @xmath311 so @xmath224 is aliasing - free we want to show that adding fresh and distinct locations from @xmath130 preserves this lack of freedom .",
    "more precisely , we want to show that @xmath312 we reason by checking of all cases . if @xmath297 and @xmath298 , immediate . if @xmath313 then @xmath314 holds because the locations of @xmath130 are distinct . if @xmath315 and @xmath316 then @xmath317 holds because @xmath318 ( by freshness hypothesis ) .",
    "[ lem : aliasing - letrec ] if @xmath236 is aliasing free , then , for all @xmath319 , @xmath320 is aliasing free .",
    "let @xmath321 and @xmath322 .",
    "adding @xmath130 , a restricted concatenation of @xmath42 and @xmath4 , to @xmath224 preserves aliasing freedom , as in the proof of lemma  [ lem : alias - concat ] . if @xmath297 and @xmath298 , immediate .",
    "if @xmath323 , @xmath300 .",
    "this is the same for @xmath301 .",
    "then @xmath302 is equivalent to @xmath303 ( or some other combination , depending on @xmath25 , @xmath304 , @xmath305 and @xmath301 ) which leads to the expected result .",
    "we finally show theorem  [ thm : correction - ll ] .",
    "thm : correction - ll if @xmath25 is a liftable parameter in @xmath231 , then @xmath240{{\\ensuremath{{\\ensuremath{{\\rho_{t}}}}|\\rho } } } v^{\\,s ' } } } \\text { implies } { \\ensuremath{{\\ensuremath{\\mathop{(m)}\\nolimits_{\\ast}}}^{\\,s }    \\optarrow[{{\\ensuremath{\\mathop{({\\ensuremath{\\mathcal{f}}})}\\nolimits_{\\ast}}}}]{{\\ensuremath{{\\ensuremath{{\\rho_{t}}}}|\\rho } } } v^{\\,s'}}}\\ ] ]    assume that @xmath25 is a liftable parameter in @xmath231 .",
    "the proof is by induction on the height of the reduction of @xmath244{{\\ensuremath{{\\ensuremath{{\\rho_{t}}}}|\\rho } } } v^{\\,s'}}}$ ] . to keep the proof readable ,",
    "we detail only the non - trivial cases when checking the invariants of definition  [ dfn : var - liftable ] to ensure that the induction hypotheses hold .",
    "[ [ call - first - case ] ] ( call )  first case + + + + + + + + + + + + + + + + + + +    first , we consider the most interesting case where there exists @xmath324 such that @xmath241 .",
    "the variable @xmath25 is a liftable parameter in @xmath325 hence in @xmath326 too .",
    "indeed , the invariants of definition  [ dfn : var - liftable ] hold :    * invariant  [ case : loc ] : by definition of a local position , every @xmath8 defined in local position in @xmath327 is in local position in @xmath328 , hence the expected property by the induction hypotheses .",
    "* invariant  [ case : term ] : immediate since the premise does not hold : since the @xmath327 are not in tail position in @xmath328 , they can not feature calls to @xmath27 ( by invariant  [ case : pos ] ) . *",
    "invariant  [ case : share ] : lemma  [ lem : alias - concat ] , p.  .",
    "the other invariants hold trivially .    by the induction hypotheses , we get @xmath329{{\\ensuremath{|{\\ensuremath{{\\rho_{t}}}}{\\cdot}\\rho } } } v_{i}^{\\,s_{i+1}}}}.\\ ] ] by definition of lifting , @xmath330 . but @xmath25 is not a liftable parameter in @xmath331 since the invariant  [ case : term ] might be broken : @xmath332 ( @xmath25 is not a parameter of @xmath27 ) but @xmath232 might appear in tail position in @xmath242 .    on the other hand , we have @xmath333 : since , by hypothesis , @xmath25 is a liftable parameter in @xmath325 , it appears necessarily in the environments of the closures of the @xmath27 , such as @xmath15 .",
    "this allows us to split @xmath15 into two parts : @xmath334 .",
    "it is then possible to move @xmath335 to the tail environment , according to lemma  [ lem : switch - x ] : @xmath336{{\\ensuremath{\\rho''(x , l)|\\rho ' '' } } } v^{\\,s'|_{{\\mathop{\\mathrm{dom}}\\nolimits}(s')\\setminus\\{l\\}}}}}\\ ] ] this rewriting ensures that @xmath25 is a liftable parameter in @xmath337 .",
    "indeed , the invariants of definition  [ dfn : var - liftable ] hold :    * invariant  [ case : loc ] : every function defined in local position in @xmath242 is an inner function in @xmath27 so , by invariant  [ case : pos ] , it is one of the @xmath27 and @xmath338 .",
    "* invariant  [ case : term ] : immediate since @xmath338 . * invariant  [ case : exclu ] : immediate since @xmath127 is included in @xmath16 . *",
    "invariant  [ case : share ] : immediate for the compact closures . aliasing freedom",
    "is guaranteed by lemma  [ lem : aliasing - call ] ( p.  ) .",
    "the other invariants hold trivially .    by the induction hypotheses , @xmath339{{\\ensuremath{\\rho''(x , l)|\\rho ' '' } } } v^{\\,s'|_{{\\mathop{\\mathrm{dom}}\\nolimits}(s')\\setminus\\{l\\}}}}}\\ ] ] the @xmath23 location is not fresh : it must be rewritten into a fresh location , since @xmath25 is now a parameter of @xmath27 .",
    "let @xmath115 be a location appearing in neither @xmath340 , nor @xmath273 or @xmath341 .",
    "then @xmath115 is a fresh location , which is to act as @xmath23 in the reduction of @xmath243 .",
    "we will show that , after the reduction , @xmath115 is not in the store ( just like @xmath23 before the lambda - lifting ) . in the meantime ,",
    "the value associated to @xmath23 does not change ( since @xmath115 is modified instead of @xmath23 ) .",
    "lemma  [ lem : fstarclean ] implies that @xmath25 does not appear in the environments of @xmath238 , so it does not appear in the environments of @xmath342 either . as a consequence , lack of aliasing implies by definition  [ dfn : aliasing ] that the label @xmath23 , associated to @xmath25 , does not appear in @xmath340 either , so @xmath343 = { \\ensuremath{\\mathop{({\\ensuremath{\\mathcal{f ' } + \\{f\\mapsto{\\ensuremath{\\mathcal{f}}}\\,f\\ } } } ) } \\nolimits_{\\ast}}}.\\ ] ] moreover , @xmath23 does not appear in @xmath344 . by alpha - conversion ( lemma  [ lem : rename - loc - opt ] ,",
    "since @xmath115 does not appear in the store or the environments of the reduction , we rename @xmath23 to @xmath115 : @xmath345 + \\{l_i\\mapstov_i\\ } } } }    \\optarrow[{\\      { \\ensuremath{\\mathop{({\\ensuremath{\\mathcal{f ' } + \\{f\\mapsto{\\ensuremath{\\mathcal{f}}}\\,f\\ } } } ) } \\nolimits_{\\ast}}}}]{{\\ensuremath{\\rho''(x , l')|\\rho ' '' } } } v^{\\,s'|_{{\\mathop{\\mathrm{dom}}\\nolimits}(s')\\setminus\\{l\\}}}}}.\\ ] ] we want now to reintroduce @xmath23 .",
    "let @xmath346 .",
    "the location @xmath23 does not appear in @xmath347 + \\{l_i\\mapstov_i\\ } } } $ ] , @xmath340 , or @xmath348 .",
    "thus , by lemma  [ lem : intro - in - store ] , @xmath349 + \\{l_i\\mapstov_i\\ } } } + \\{l\\mapstov_x\\ } } } }    \\optarrow[{\\      { \\ensuremath{\\mathop{({\\ensuremath{\\mathcal{f ' } + \\{f\\mapsto{\\ensuremath{\\mathcal{f}}}\\,f\\ } } } ) } \\nolimits_{\\ast}}}}]{{\\ensuremath{\\rho''(x , l')|\\rho ' '' } } } v^{\\,{\\ensuremath{s'|_{{\\mathop{\\mathrm{dom}}\\nolimits}(s')\\setminus\\{l\\ } } + \\{l\\mapstov_x\\ } } } } } } .\\ ] ] since @xmath350 + \\{l_i\\mapstov_i\\ } } } + \\{l\\mapstov_x\\ } } }        & = { \\ensuremath{{\\ensuremath{s_{n+1}[l'/l ] + \\{l\\mapstov_x\\ } } } + \\{l_i\\mapstov_i\\ } } }        & & \\text{because $ \\forall",
    "i , l \\neq l_i$}\\\\        & = { \\ensuremath{{\\ensuremath{s_{n+1 } + \\{l'\\mapstov_x\\ } } } + \\{l_i\\mapstov_i\\ } } }        & & \\text{because $ v_x = s_{n+1 } l$}\\\\        & = { \\ensuremath{{\\ensuremath{s_{n+1 } + \\{l_i\\mapstov_i\\ } } } + \\{l'\\mapstov_x\\ } } }        & & \\text{because $ \\forall i , l ' \\neq l_i$ }      \\end{aligned}\\ ] ] and @xmath351 , we finish the rewriting by lemma  [ lem : intro - in - env ] , @xmath352{{\\ensuremath{\\rho''(x , l')|(x , l){\\cdot}\\rho ' '' } } } v^{\\,\\      { \\ensuremath{s ' + \\{l\\mapstov_x\\ } } } } } } .\\ ] ] hence the result : @xmath353{\\      { \\ensuremath{\\mathop{({\\ensuremath{\\mathcal{f}}})}\\nolimits_{\\ast}}}\\ h_i = { \\ensuremath{\\left[\\lambda{\\ensuremath{x_{1}\\dotscx_{n}}}x.{\\ensuremath{\\mathop{(b)}\\nolimits_{\\ast}}},\\rho',{\\ensuremath{\\mathop{(\\mathcal{f'})}\\nolimits_{\\ast}}}\\right]}}\\\\      \\rho''= { \\ensuremath{(x_{1},l_{1}){\\cdot}\\dotsc{\\cdot}(x_{n},l_{n})}}(x,{\\ensuremath{{\\rho_{t}}}}\\ x)\\\\      \\text{$l'$ and $ l_{i}$ fresh and distinct}\\\\\\\\      \\forall i,{\\ensuremath{{{\\ensuremath{\\mathop{(a_{i})}\\nolimits_{\\ast}}}}^{\\,s_{i } }    \\optarrow[{\\ensuremath{\\mathop{({\\ensuremath{\\mathcal{f}}})}\\nolimits_{\\ast}}}]{{\\ensuremath{|{\\ensuremath{{\\rho_{t}}}}{\\cdot}\\rho } } } v_{i}^{\\,s_{i+1 } } } } \\\\      { \\ensuremath{{{\\ensuremath{\\mathop{(x)}\\nolimits_{\\ast}}}}^{\\,s_{n+1 } }    \\optarrow[{\\ensuremath{\\mathop{({\\ensuremath{\\mathcal{f}}})}\\nolimits_{\\ast}}}]{{\\ensuremath{|{\\ensuremath{{\\rho_{t}}}}{\\cdot}\\rho } } } v_x^{\\,s_{n+1 } } } } \\\\      { \\ensuremath{{\\ensuremath{\\mathop{(b)}\\nolimits_{\\ast}}}^{\\,{\\ensuremath{{\\ensuremath{s_{n+1 } + \\{l_i\\mapstov_i\\ } } } + \\{l'\\mapstov_x\\ } } } }    \\optarrow[{{\\ensuremath{\\mathop{({\\ensuremath{\\mathcal{f ' } + \\{f\\mapsto{\\ensuremath{\\mathcal{f}}}\\,f\\ } } } ) } \\nolimits_{\\ast}}}}]{{\\ensuremath{\\rho''(x , l')|\\rho ' } } } v^{\\,\\      { \\ensuremath{s ' + \\{l\\mapstov_x\\ } } } } } }      } { \\      { \\ensuremath{{{\\ensuremath{\\mathop{(h_i({\\ensuremath{a_{1}\\dotsca_{n}}}))}\\nolimits_{\\ast}}}}^{\\,s_{1 } }    \\optarrow[{\\ensuremath{\\mathop{({\\ensuremath{\\mathcal{f}}})}\\nolimits_{\\ast}}}]{{\\ensuremath{{\\ensuremath{{\\rho_{t}}}}|\\rho } } } v^{\\,{{\\ensuremath{s ' + \\{l\\mapstov_x\\ } } } \\setminus { \\ensuremath{{\\rho_{t}}}}}}}}}\\ ] ] since @xmath354 ( because @xmath25 is a liftable parameter in @xmath325 ) , the extraneous location is reclaimed as expected : @xmath355 .",
    "[ [ call - second - case ] ] ( call )  second case + + + + + + + + + + + + + + + + + + + +    we now consider the case where @xmath8 is not one of the @xmath27 .",
    "the variable @xmath25 is a liftable parameter in @xmath356 hence in @xmath326 too .",
    "indeed , the invariants of definition  [ dfn : var - liftable ] hold :    * invariant  [ case : loc ] : by definition of a local position , every @xmath8 defined in local position in @xmath327 is in local position in @xmath357 , hence the expected property by the induction hypotheses .",
    "* invariant  [ case : term ] : immediate since the premise does not hold : the @xmath327 are not in tail position in @xmath357 so they can not feature calls to @xmath27 ( by invariant  [ case : pos ] : ) . *",
    "invariant  [ case : share ] : lemma  [ lem : alias - concat ] , p.  .",
    "the other invariants hold trivially .    by the induction hypotheses , we get @xmath329{{\\ensuremath{|{\\ensuremath{{\\rho_{t}}}}{\\cdot}\\rho } } } v_{i}^{\\,s_{i+1}}}},\\ ] ] and , by definition  [ dfn : lifted - term ] , @xmath358 if @xmath25 is not defined in @xmath242 or @xmath16 , then @xmath359 is the identity function and can trivially be applied to the reduction of @xmath242 .",
    "otherwise , @xmath25 is a liftable parameter in @xmath360 .    indeed ,",
    "the invariants of definition  [ dfn : var - liftable ] hold .",
    "assume that @xmath25 is defined as a parameter of some function @xmath26 , in either @xmath242 or @xmath16 :    * invariant  [ case : loc ] : we have to distinguish the cases where @xmath361 ( with @xmath362 ) and @xmath363 ( with @xmath332 and @xmath364 ) .",
    "in both cases , the result is immediate by the induction hypotheses . *",
    "invariant  [ case : term ] : if @xmath363 , the premise can not hold ( by the induction hypotheses , invariant  [ case : pos ] ) .",
    "if @xmath361 , @xmath362 ( by the induction hypotheses , invariant  [ case : pos ] ) .",
    "* invariant  [ case : exclu ] : immediate since @xmath127 is included in @xmath16 . *",
    "invariant  [ case : share ] : immediate for the compact closures . aliasing freedom",
    "is guaranteed by lemma  [ lem : aliasing - call ] ( p.  ) .",
    "the other invariants hold trivially .    by the induction hypotheses , @xmath365{{\\ensuremath{\\rho''|\\rho ' } } } v^{\\,s'}}}\\ ] ] hence : @xmath353{\\      { \\ensuremath{\\mathop{({\\ensuremath{\\mathcal{f}}})}\\nolimits_{\\ast}}}\\ f = { \\ensuremath{\\left[\\lambda{\\ensuremath{x_{1}\\dotscx_{n}}}.{\\ensuremath{\\mathop{(b)}\\nolimits_{\\ast}}},\\rho',{\\ensuremath{\\mathop{(\\mathcal{f'})}\\nolimits_{\\ast}}}\\right]}}\\\\      \\rho''= { \\ensuremath{(x_{1},l_{1}){\\cdot}\\dotsc{\\cdot}(x_{n},l_{n})}}\\\\      \\text{$l_{i}$ fresh and distinct}\\\\\\\\      \\forall i,{\\ensuremath{{{\\ensuremath{\\mathop{(a_{i})}\\nolimits_{\\ast}}}}^{\\,s_{i } }    \\optarrow[{\\ensuremath{\\mathop{({\\ensuremath{\\mathcal{f}}})}\\nolimits_{\\ast}}}]{{\\ensuremath{|{\\ensuremath{{\\rho_{t}}}}{\\cdot}\\rho } } } v_{i}^{\\,s_{i+1 } } } } \\\\      { \\ensuremath{{\\ensuremath{\\mathop{(b)}\\nolimits_{\\ast}}}^{\\,{\\ensuremath{s_{n+1 } + \\{l_{i}\\mapstov_{i}\\ } } } }    \\optarrow[{{\\ensuremath{\\mathop{({\\ensuremath{\\mathcal{f ' } + \\{f\\mapsto{\\ensuremath{\\mathcal{f}}}\\,f\\ } } } ) } \\nolimits_{\\ast}}}}]{{\\ensuremath{\\rho''|\\rho ' } } } v^{\\,s ' } } }      } { \\      { \\ensuremath{{{\\ensuremath{\\mathop{(f({\\ensuremath{a_{1}\\dotsca_{n}}}))}\\nolimits_{\\ast}}}}^{\\,s_{1 } }    \\optarrow[{\\ensuremath{\\mathop{({\\ensuremath{\\mathcal{f}}})}\\nolimits_{\\ast}}}]{{\\ensuremath{{\\ensuremath{{\\rho_{t}}}}|\\rho } } } v^{\\,{s ' \\setminus { \\ensuremath{{\\rho_{t}}}}}}}}}\\ ] ]    [ [ letrec-9 ] ] ( letrec ) + + + + + + + +    the parameter @xmath25 is a liftable in @xmath366 so @xmath25 is a liftable parameter in @xmath367 too .    indeed , the invariants of definition  [ dfn : var - liftable ] hold :    * invariants  [ case : loc ] and  [ case : term ] : immediate by the induction hypotheses and definition of tail and local positions .",
    "* invariant  [ case : exclu ] : by the induction hypotheses , invariant  [ case : loc ] ( @xmath25 is to appear in the new closure if and only if @xmath241 ) . *",
    "invariant  [ case : share ] : lemma  [ lem : aliasing - letrec ] ( p.  ) .",
    "the other invariants hold trivially .    by the induction hypotheses , we get @xmath368{{\\ensuremath{{\\ensuremath{{\\rho_{t}}}}|\\rho } } } v^{\\,s'}}}.\\ ] ] if @xmath369 , @xmath370 hence , by definition of @xmath371 , @xmath372{\\      { \\ensuremath{{\\ensuremath{\\mathop{(b)}\\nolimits_{\\ast}}}^{\\,s }    \\optarrow[{{\\ensuremath{\\mathop{(\\mathcal{f'})}\\nolimits_{\\ast}}}}]{{\\ensuremath{{\\ensuremath{{\\rho_{t}}}}|\\rho } } } v^{\\,s ' } } } \\\\\\\\",
    "\\rho ' = { \\ensuremath{{\\rho_{t}}}}{\\cdot}\\rho|_{{\\mathop{\\mathrm{dom}}\\nolimits}({\\ensuremath{{\\rho_{t}}}}{\\cdot}\\rho)\\setminus\\{{\\ensuremath{x_{1}\\dotscx_{n}}}\\ } } \\\\",
    "{ \\ensuremath{\\mathop{(\\mathcal{f'})}\\nolimits_{\\ast}}}=      { \\ensuremath{{\\ensuremath{\\mathop{({\\ensuremath{\\mathcal{f}}})}\\nolimits_{\\ast } } } + \\{f\\mapsto{\\ensuremath{\\left[\\lambda{\\ensuremath{x_{1}\\dotscx_{n}}}.{\\ensuremath{\\mathop{(a)}\\nolimits_{\\ast}}},\\rho',f\\right]}}\\ } } }     } { \\      { \\ensuremath{{{\\ensuremath{\\mathop{({\\ensuremath{\\mathop{\\mathbf{letrec}}\\ f({\\ensuremath{x_{1}\\dotscx_{n}}})=a\\    \\mathop{\\mathbf{in}}\\ b}})}\\nolimits_{\\ast}}}}^{\\,s }    \\optarrow[{\\ensuremath{\\mathop{({\\ensuremath{\\mathcal{f}}})}\\nolimits_{\\ast}}}]{{\\ensuremath{{\\ensuremath{{\\rho_{t}}}}|\\rho } } } v^{\\,s'}}}}\\ ] ] on the other hand , if @xmath241 , @xmath373 hence , by definition of @xmath371 , @xmath372{\\      { \\ensuremath{{\\ensuremath{\\mathop{(b)}\\nolimits_{\\ast}}}^{\\,s }    \\optarrow[{{\\ensuremath{\\mathop{(\\mathcal{f'})}\\nolimits_{\\ast}}}}]{{\\ensuremath{{\\ensuremath{{\\rho_{t}}}}|\\rho } } } v^{\\,s ' } } } \\\\\\\\      \\rho ' = { \\ensuremath{{\\rho_{t}}}}{\\cdot}\\rho|_{{\\mathop{\\mathrm{dom}}\\nolimits}({\\ensuremath{{\\rho_{t}}}}{\\cdot}\\rho)\\setminus\\{{\\ensuremath{x_{1}\\dotscx_{n}}}x\\ } } \\\\      { \\ensuremath{\\mathop{(\\mathcal{f'})}\\nolimits_{\\ast}}}=      { \\ensuremath{{\\ensuremath{\\mathop{({\\ensuremath{\\mathcal{f}}})}\\nolimits_{\\ast } } } + \\{h_i\\mapsto{\\ensuremath{\\left[\\lambda{\\ensuremath{x_{1}\\dotscx_{n}}}x.{\\ensuremath{\\mathop{(a)}\\nolimits_{\\ast}}},\\rho',f\\right]}}\\ } } }     } { \\      { \\ensuremath{{{\\ensuremath{\\mathop{({\\ensuremath{\\mathop{\\mathbf{letrec}}\\ h_i({\\ensuremath{x_{1}\\dotscx_{n}}})=a\\    \\mathop{\\mathbf{in}}\\ b}})}\\nolimits_{\\ast}}}}^{\\,s }    \\optarrow[{\\ensuremath{\\mathop{({\\ensuremath{\\mathcal{f}}})}\\nolimits_{\\ast}}}]{{\\ensuremath{{\\ensuremath{{\\rho_{t}}}}|\\rho } } } v^{\\,s'}}}}\\ ] ]    [ [ val-9 ] ] ( val ) + + + + +    @xmath374 so @xmath375 { } { { \\ensuremath{{{\\ensuremath{\\mathop{(v)}\\nolimits_{\\ast}}}}^{\\,s }    \\optarrow[{\\ensuremath{\\mathop{({\\ensuremath{\\mathcal{f}}})}\\nolimits_{\\ast}}}]{{\\ensuremath{{\\ensuremath{{\\rho_{t}}}}|\\rho } } } v^{\\,{s \\setminus { \\ensuremath{{\\rho_{t}}}}}}}}}\\ ] ]    [ [ var-9 ] ] ( var ) + + + + +    @xmath376 so @xmath377{{\\ensuremath{{\\rho_{t}}}}{\\cdot}\\rho\\ y = l \\in { \\mathop{\\mathrm{dom}}\\nolimits}\\ s}{{\\ensuremath{{{\\ensuremath{\\mathop{(y)}\\nolimits_{\\ast}}}}^{\\,s }    \\optarrow[{\\ensuremath{\\mathop{({\\ensuremath{\\mathcal{f}}})}\\nolimits_{\\ast}}}]{{\\ensuremath{{\\ensuremath{{\\rho_{t}}}}|\\rho } } } s\\ l^{\\,{s \\setminus { \\ensuremath{{\\rho_{t}}}}}}}}}\\ ] ]    [ [ assign-9 ] ] ( assign ) + + + + + + + +    the parameter @xmath25 is liftable in @xmath378 so in @xmath379 too .    indeed , the invariants of definition  [ dfn : var - liftable ] hold :    * invariant  [ case : share ] : lemma  [ lem : alias - concat ] , p.  .",
    "the other invariants hold trivially .    by the induction hypotheses , we get @xmath380{{\\ensuremath{|{\\ensuremath{{\\rho_{t}}}}{\\cdot}\\rho } } } v^{\\,s'}}}.\\ ] ]",
    "moreover @xmath381 so : @xmath382{{\\ensuremath{{{\\ensuremath{\\mathop{(a)}\\nolimits_{\\ast}}}}^{\\,s }    \\optarrow[{\\ensuremath{\\mathop{({\\ensuremath{\\mathcal{f}}})}\\nolimits_{\\ast}}}]{{\\ensuremath{|{\\ensuremath{{\\rho_{t}}}}{\\cdot}\\rho } } } v^{\\,s ' } } }   \\\\      { \\ensuremath{{\\rho_{t}}}}{\\cdot}\\rho\\ y = l \\in { \\mathop{\\mathrm{dom}}\\nolimits}\\ s'}{\\      { \\ensuremath{{{\\ensuremath{\\mathop{(y { \\vcentcolon\\mkern-1.2mu=}a)}\\nolimits_{\\ast}}}}^{\\,s }    \\optarrow[{\\ensuremath{\\mathop{({\\ensuremath{\\mathcal{f}}})}\\nolimits_{\\ast}}}]{{\\ensuremath{{\\ensuremath{{\\rho_{t}}}}|\\rho } } } { \\ensuremath{\\mathbf{1}}}^{\\,{{{\\ensuremath{s ' + \\{l\\mapstov\\ } } } } \\setminus { \\ensuremath{{\\rho_{t}}}}}}}}}\\ ] ]    [ [ seq-9 ] ] ( seq ) + + + + +    the parameter @xmath25 is liftable in @xmath383 . if @xmath25 is not defined in @xmath384 or @xmath16 , then @xmath359 is the identity function and can trivially be applied to the reduction of @xmath384 .",
    "otherwise , @xmath25 is a liftable parameter in @xmath379 .",
    "indeed , the invariants of definition  [ dfn : var - liftable ] hold :    * invariant  [ case : share ] : lemma  [ lem : alias - concat ] , p.  .",
    "the other invariants hold trivially .",
    "if @xmath25 is not defined in @xmath242 or @xmath16 , then @xmath359 is the identity function and can trivially be applied to the reduction of @xmath242 . otherwise , @xmath25 is a liftable parameter in @xmath385 .",
    "indeed , the invariants of definition  [ dfn : var - liftable ] hold trivially .    by the induction hypotheses , we get @xmath386{{\\ensuremath{|{\\ensuremath{{\\rho_{t}}}}{\\cdot}\\rho } } } v^{\\,s'}$ ] and @xmath387{{\\ensuremath{{\\ensuremath{{\\rho_{t}}}}|\\rho } } } v'^{\\,s''}$ ] .",
    "+ moreover , @xmath388 hence : @xmath389{{\\ensuremath{{{\\ensuremath{\\mathop{(a)}\\nolimits_{\\ast}}}}^{\\,s }    \\optarrow[{\\ensuremath{\\mathop{({\\ensuremath{\\mathcal{f}}})}\\nolimits_{\\ast}}}]{{\\ensuremath{|{\\ensuremath{{\\rho_{t}}}}{\\cdot}\\rho } } } v^{\\,s ' } } } \\\\      { \\ensuremath{{{\\ensuremath{\\mathop{(b)}\\nolimits_{\\ast}}}}^{\\,s ' }    \\optarrow[{\\ensuremath{\\mathop{({\\ensuremath{\\mathcal{f}}})}\\nolimits_{\\ast}}}]{{\\ensuremath{{\\ensuremath{{\\rho_{t}}}}|\\rho } } } v'^{\\,s''}}}}{\\      { \\ensuremath{{{\\ensuremath{\\mathop{(a\\ ; \\ b)}\\nolimits_{\\ast}}}}^{\\,s }    \\optarrow[{\\ensuremath{\\mathop{({\\ensuremath{\\mathcal{f}}})}\\nolimits_{\\ast}}}]{{\\ensuremath{{\\ensuremath{{\\rho_{t}}}}|\\rho } } } v'^{\\,s''}}}}\\ ] ]    [ [ if - true - and - if - false-9 ] ] ( if - true ) and ( if - false ) + + + + + + + + + + + + + + + + + + + + + + + +    are proved similarly to ( seq ) .",
    "in this section , we prove the correctness of the cps - conversion performed by the cpc translator .",
    "this conversion is defined only on a subset of c programs that we call _ cps - convertible terms _ ( section  [ sec : cps - convertible ] ) .",
    "we first show that the _ early evaluation _ of function parameters in cps - convertible terms is correct ( section  [ sec : early - eval ] ) . to simplify the proof of correctness of cps - conversion ,",
    "we then introduce small - step reduction rules featuring contexts and early evaluation ( section  [ sec : ss - reduction ] ) .    in section  [ sec : cps - terms ] , we define _ cps terms _ , with the ` push ` and ` invoke ` operators to build and execute continuations , and the associated reduction rules .",
    "since the syntax of cps - terms does not ensure a correct reduction , we also define _ well - formed _ cps - terms , which are the image of cps - convertible terms by cps - conversion .    the proof of correctness of cps - conversion is finally carried out in section  [ sec : translation ] .",
    "it consists merely in checking that the reduction rules for cps - convertible terms and well - formed cps - terms execute in lock - step .",
    "cps conversion is not defined for every c function ; instead , we restrict ourselves to a subset of functions , which we call the _ cps - convertible _ subset . the cps - convertible form restricts the calls to cps functions to make it straightforward to capture their continuation . in cps - convertible form , a call to a cps function ` f ` is either in tail position , or followed by a tail call to another cps function whose parameters are _ non - shared _ variables that can not be modified by ` f ` .      [ def : cps - c ] a function h is in _ cps - convertible form _ if every call to a cps function that it contains matches one of the following patterns , where both ` f ` and ` g ` are cps functions , ` e_\\text{\\tt 1 } , ... , e_\\text{\\tt n } ` are any c expressions and ` x , y_\\text{\\tt 1 } , ... , y_\\text{\\tt n } ` are distinct , non - shared variables : @xmath390    note the use of ` return ` to explicitly mark calls in tail position .",
    "the forms ( [ useless1 ] ) to ( [ useless2 ] ) are only necessary to handle the cases where ` f ` and ` g ` return ` void ` ; in the rest of the proof , we ignore these cases that are a syntactical detail of the c language , and focus on the essential cases ( 1 ) and ( 2 ) .    to prove the correctness of cps - conversion , we need to express this definition in our small imperative language .",
    "this is done by defining cps - convertible terms , which are a subset of the terms introduced in definition  [ def : full - language ] ( section  [ sec : definitions ] ) .",
    "a program in cps - convertible form consists of a set of mutually - recursive functions with no free variables , the body of each of which is a cps - convertible term .",
    "a cpsconvertible term has two parts : the head and the tail .",
    "the head is a ( possibly empty ) sequence of assignments , possibly embedded within conditional statements .",
    "the tail is a ( possibly empty ) sequence of function calls in a highly restricted form : their parameters are ( side - effect free ) expressions , except possibly for the last one , which can be another function call of the same form . values and expressions are left unchanged .      the essential property of cpsconvertible terms , which makes their cps conversion immediate to perform , is the guarantee that there is no cps call outside of the tails .",
    "it makes continuations easy to represent as a series of function calls ( tails ) and separates them clearly from imperative blocks ( heads ) , which are not modified by the cpc translator .",
    "the tails are a generalisation of definition  [ def : cps - c ] , which will be useful for the proof of correctness of cps - conversion .",
    "note that x = f(e@xmath392 , ... , e@xmath393 ) ; return g(x , y@xmath392 , ... , y@xmath393 )",
    "is represented by @xmath394 : this translation is correct because , contrary to c , our language guarantees a left - to - right evaluation of function parameters .",
    "* there is no letrec construct anymore since every function is defined at top - level , * assignments , conditions and function parameters of @xmath8 are restricted to expressions , to ensure that function calls only appear in tail position , * there is no need to forbid shared variables in the parameters of @xmath26 because they are ruled out of our language by design .      in this section",
    ", we prove that correctness of _ early evaluation _",
    ", ie.evaluating the expressions @xmath395 before @xmath396 when reducing @xmath397 in a tail .",
    "this result is necessary to show the correctness of the cps - conversion , because function parameters are evaluated before any function call when building continuations .",
    "the reduction rules may be simplified somewhat for cps - convertible terms .",
    "we do not need to keep an explicit environment of functions since there are no inner functions any more ; for the same reason , the ( letrec ) rule disappears .",
    "instead , we use a constant environment @xmath16 holding every function used in the reduced term @xmath30 . to account for the absence of free variables , the closures in @xmath16 need not carry an environment . as a result , in the ( call ) rule , @xmath398 and @xmath399 .                                by the induction hypotheses , @xmath409 since @xmath410 , @xmath411 and @xmath412 ( by freshness ) , @xmath413 so @xmath414 .",
    "+ since @xmath415 , @xmath416 finally , we can prove similarly to the ( seq ) case that @xmath417 hence , @xmath418        we prove the corollary by induction on the structure of a tail",
    ". first remember that _ store extension _ ( written @xmath108 ) is a partial order over stores ( property  [ prop : ext - order ] ) , defined in section  [ subsec : second - step ] as follows : @xmath421 .",
    "the case @xmath422 is trivial .",
    "the case @xmath423 is immediate by induction ( ( seq ) rule ) , since @xmath108 is transitive .",
    "similarly , it is pretty clear that @xmath424 follows by induction and transitivity from @xmath425 ( ( call ) rule ) .",
    "we focus on this last case .",
    "immediate induction on the structure of tails and expressions : corollary  [ cor : lift - store - invariant ] implies that @xmath434 and @xmath433 ensures that @xmath435 in the relevant cases ( namely the ( seq ) rule for @xmath423 and the ( call ) rule for @xmath424 ) .",
    "we define the semantics of cpsconvertible terms through a set of small - step reduction rules .",
    "we distinguish three kinds of reductions : @xmath436 to reduce the head of terms , @xmath437 to reduce the tail , and @xmath438 to evaluate expressions .",
    "these rules describe a stack machine with a store @xmath439 to keep the value of variables .",
    "since free and shared variables have been eliminated in earlier passes , there is a direct correspondence at any point in the program between variable names and locations , with no need to dynamically maintain an extra environment .",
    "we use contexts as a compact representation for stacks .",
    "the head rules @xmath436 reduce triples made of a term , a context and a store : @xmath440 , \\sigma \\rangle$ ] . the tail rules @xmath437 , which merely unfold tails with no need of a store , reduce couples of a tail and a context : @xmath441 , \\rangle$ ] .",
    "the expression rules do not need context to reduce , thus operating on couples made of an expression and a store : @xmath442 .",
    "contexts are sequences of function calls . in those sequences ,",
    "function parameters shall be already evaluated : constant expressions are allowed , but not variables . as a special case , the last parameter might be a `` hole '' instead , written @xmath443 , to be filled with the return value of the next , nested function .",
    "@xmath445 , \\sigma \\rangle & \\rightarrow_t \\langle t , c[\\ ] , \\sigma[x\\mapsto v ]   \\rangle \\\\&\\quad\\text{when $ \\langle { \\ensuremath{\\mathop{expr}\\nolimits\\/}},\\sigma \\rangle \\rightarrow_e^\\star      v$}\\notag\\\\ \\langle { \\ensuremath{\\mathop{\\mathbf{if}}\\ { \\ensuremath{\\mathop{expr}\\nolimits\\/}}\\   \\mathop{\\mathbf{then}}\\ t_1\\ \\mathop{\\mathbf{else}}\\ t_2 } } , c[\\ ] , \\sigma \\rangle & \\rightarrow_t \\langle t_1 , c[\\ ] , \\sigma \\rangle \\\\&\\quad\\text{when } \\langle { \\ensuremath{\\mathop{expr}\\nolimits\\/}},\\sigma \\rangle \\rightarrow_e^\\star      { \\ensuremath{\\mathop{\\mathbf{true}}\\nolimits}}\\notag\\\\ \\langle { \\ensuremath{\\mathop{\\mathbf{if}}\\ { \\ensuremath{\\mathop{expr}\\nolimits\\/}}\\   \\mathop{\\mathbf{then}}\\ t_1\\ \\mathop{\\mathbf{else}}\\ t_2 } } , c[\\ ] , \\sigma \\rangle & \\rightarrow_t \\langle t_2 , c[\\ ] , \\sigma \\rangle \\\\&\\quad\\text{when } \\langle { \\ensuremath{\\mathop{expr}\\nolimits\\/}},\\sigma \\rangle \\rightarrow_e^\\star      { \\ensuremath{\\mathop{\\mathbf{false}}\\nolimits}}\\notag\\\\ \\langle { \\ensuremath{\\mathop{expr}\\nolimits\\/ } } , c[[\\ ] \\ ; \\ f(v_1 , \\ldots , v_n ) ] , \\sigma \\rangle & \\rightarrow_t \\langle \\epsilon , c[[\\ ] \\ ; \\ f(v_1 , \\ldots , v_n ) ] \\rangle\\\\ \\langle { \\ensuremath{\\mathop{expr}\\nolimits\\/ } } , c[[\\ ] \\ ; \\ f(v_1 , \\ldots , v_n , \\circleddash ) ] , \\sigma \\rangle & \\rightarrow_t \\langle \\epsilon , c[[\\ ] \\ ; \\ f(v_1 , \\ldots , v_n , v ) ] \\rangle \\\\&\\quad\\text{when $ \\langle { \\ensuremath{\\mathop{expr}\\nolimits\\/}},\\sigma \\rangle \\rightarrow_e^\\star      v$}\\notag\\\\ \\langle { \\ensuremath{\\mathop{expr}\\nolimits\\/ } } , [ \\ ] , \\sigma \\rangle & \\rightarrow_t v \\quad\\text{when $ \\langle { \\ensuremath{\\mathop{expr}\\nolimits\\/}},\\sigma \\rangle \\rightarrow_e^\\star",
    "v$}\\notag\\\\ \\langle q , c[\\ ] , \\sigma \\rangle & \\rightarrow_t \\langle q[x_i\\setminus \\sigma\\ x_i ] , c[\\ ] \\rangle \\label{rule : preevaluation } \\\\&\\quad\\text{for every $ x_i$ in $ { \\mathop{\\mathrm{dom}}\\nolimits}(\\sigma)$}\\notag\\\\ \\notag\\\\ \\langle q\\ ; \\",
    "f(v_1 , \\ldots , v_n ) , c[\\ ] \\rangle & \\rightarrow_q \\langle q , c[[\\ ] \\ ; \\ f(v_1 , \\ldots , v_n ) ] \\rangle \\label{rule : context } \\\\",
    "\\langle q\\ ; \\ f(v_1 , \\ldots , v_n , f ) , c[\\ ] \\rangle & \\rightarrow_q \\langle q\\ ; \\ f , c[[\\ ] \\ ; \\ f(v_1 , \\ldots , v_n , \\circleddash ) ] \\rangle \\label{rule : context - hole } \\\\",
    "\\langle \\epsilon , c[[\\ ] \\ ; \\ f(v_1 , \\ldots , v_n ) ] \\rangle & \\rightarrow_q \\langle t , c[\\ ] , \\sigma \\rangle \\label{rule : exec } \\\\&\\quad\\text{when } f(x_1,\\ldots , x_n ) = t      \\text { and } \\sigma = \\{x_i\\mapsto v_i\\}\\notag\\end{aligned}\\ ] ]        note that rule  [ rule : preevaluation ] evaluates every function parameter in a tail before the evaluation of the tail itself .",
    "this is precisely the early evaluation process described above , which is correct by theorem  [ thm : preevaluation ] .",
    "we introduce early evaluation directly in the reduction rules rather than using it as a lemma to simplify the proof of correctess of the cps - conversion .      unlike classical cps conversion techniques @xcite , our cps terms are not continuations , but a procedure which builds and executes the continuation of a term .",
    "construction is performed by @xmath446 , which adds a function to the current continuation , and execution by @xmath447 , which calls the first function of the continuation , optionally passing it the return value of the current function .",
    "a continuation is a sequence of function calls to be performed , with already evaluated parameters .",
    "we write @xmath449 for appending a function to a continuation , and @xmath450 for a `` hole '' , i.e.  an unknown parameter .",
    "@xmath452 \\rangle \\\\&\\quad\\text{when $ \\langle { \\ensuremath{\\mathop{expr}\\nolimits\\/}},\\sigma \\rangle \\rightarrow_e^\\star      v$}\\notag\\\\ \\langle { \\ensuremath{\\mathop{\\mathbf{if}}\\ { \\ensuremath{\\mathop{expr}\\nolimits\\/}}\\   \\mathop{\\mathbf{then}}\\ t_1\\ \\mathop{\\mathbf{else}}\\ t_2 } } , \\mathcal{c } , \\sigma \\rangle & \\rightarrow_t \\langle t_1 , \\mathcal{c } , \\sigma \\rangle \\\\&\\quad\\text{if } \\langle { \\ensuremath{\\mathop{expr}\\nolimits\\/}},\\sigma \\rangle \\rightarrow_e^\\star      { \\ensuremath{\\mathop{\\mathbf{true}}\\nolimits}}\\notag\\\\ \\langle { \\ensuremath{\\mathop{\\mathbf{if}}\\ { \\ensuremath{\\mathop{expr}\\nolimits\\/}}\\   \\mathop{\\mathbf{then}}\\ t_1\\ \\mathop{\\mathbf{else}}\\ t_2 } } , \\mathcal{c } , \\sigma \\rangle & \\rightarrow_t \\langle t_2 , \\mathcal{c } , \\sigma \\rangle \\\\&\\quad\\text{if } \\langle { \\ensuremath{\\mathop{expr}\\nolimits\\/}},\\sigma \\rangle \\rightarrow_e^\\star      { \\ensuremath{\\mathop{\\mathbf{false}}\\nolimits}}\\notag\\\\ \\langle { { \\ensuremath{\\mathop{\\mathbf{invoke}}\\nolimits}}}\\ { \\ensuremath{\\mathop{expr}\\nolimits\\/ } } , f(v_1 , \\ldots , v_n ) { \\cdot}\\mathcal{c } , \\sigma \\rangle & \\rightarrow_t \\langle { \\ensuremath{\\mathop{\\mathbf{invoke}}\\nolimits } } , f(v_1 , \\ldots , v_n ) { \\cdot}\\mathcal{c } \\rangle\\\\ \\langle { { \\ensuremath{\\mathop{\\mathbf{invoke}}\\nolimits}}}\\ { \\ensuremath{\\mathop{expr}\\nolimits\\/ } } , f(v_1 , \\ldots , v_n , \\boxdot ) { \\cdot}\\mathcal{c } , \\sigma \\rangle & \\rightarrow_t \\langle { \\ensuremath{\\mathop{\\mathbf{invoke}}\\nolimits } } , f(v_1 , \\ldots , v_n , v ) { \\cdot}\\mathcal{c } \\rangle \\\\&\\quad\\text{when $ \\langle { \\ensuremath{\\mathop{expr}\\nolimits\\/}},\\sigma \\rangle \\rightarrow_e^\\star      v$}\\notag\\\\ \\langle { { \\ensuremath{\\mathop{\\mathbf{invoke}}\\nolimits}}}\\ { \\ensuremath{\\mathop{expr}\\nolimits\\/ } } , \\varepsilon , \\sigma \\rangle & \\rightarrow_t v \\quad\\text{when $ \\langle { \\ensuremath{\\mathop{expr}\\nolimits\\/}},\\sigma \\rangle \\rightarrow_e^\\star      v$}\\notag\\\\ \\langle q , \\mathcal{c } , \\sigma \\rangle & \\rightarrow_t \\langle q[x_i\\setminus \\sigma\\ x_i ] , \\mathcal{c } \\rangle \\\\&\\quad\\text{for every $ x_i$ in $ { \\mathop{\\mathrm{dom}}\\nolimits}(\\sigma)$}\\notag\\\\ \\notag\\\\ \\langle { \\ensuremath{\\mathop{\\mathbf{push}}\\nolimits}}\\ f(v_1 , \\ldots , v_n)\\ ; \\ q , \\mathcal{c } \\rangle & \\rightarrow_q \\langle q , f(v_1 , \\ldots , v_n ) { \\cdot}\\mathcal{c } \\rangle\\\\ \\langle { \\ensuremath{\\mathop{\\mathbf{push}}\\nolimits}}\\ f(v_1 , \\ldots , v_n , \\boxdot)\\ ; \\ q , \\mathcal{c } \\rangle & \\rightarrow_q \\langle q , f(v_1 , \\ldots , v_n , \\boxdot ) { \\cdot}\\mathcal{c } \\rangle\\\\ \\langle { \\ensuremath{\\mathop{\\mathbf{invoke}}\\nolimits } } , f(v_1 , \\ldots , v_n ) { \\cdot}\\mathcal{c } \\rangle & \\rightarrow_q \\langle t , \\mathcal{c } , \\sigma \\rangle \\\\&\\quad\\text{when } f(x_1,\\ldots , x_n ) = t      \\text { and } \\sigma = \\{x_i\\mapsto v_i\\}\\notag\\end{aligned}\\ ] ]                    in the rest of this section , we prove that this mapping yields an isomorphism between the reduction rules of cpsconvertible terms and well - formed cps terms , whence the correctness of our cps conversion ( theorem  [ thm : cps - correct ] ) .",
    "we first prove two lemmas to show that @xmath456 yields only well - formed cps terms .",
    "this leads to a third lemma to show that @xmath456 is a bijection between cpsconvertible terms and well - formed cps terms .",
    "@xmath473)^\\vartriangle & = \\varepsilon\\\\ ( c[[\\ ] \\ ; \\ f(v_1 , \\ldots , v_n)])^\\vartriangle & =      f(v_1 , \\ldots , v_n ) { \\cdot}\\mathcal{c } \\\\&\\quad\\text{with $ ( c[\\ ] ) ^\\vartriangle = \\mathcal{c}$}\\\\ ( c[[\\ ] \\ ; \\ f(v_1 , \\ldots , v_n , \\circleddash)])^\\vartriangle & =      f(v_1,\\ldots , v_n , \\boxdot ) { \\cdot}\\mathcal{c } \\\\&\\quad\\text{with $ ( c[\\ ] ) ^\\vartriangle = \\mathcal{c}$}\\end{aligned}\\ ] ]      [ thm : cps - correct ] the @xmath456 and @xmath474 mappings are two bijections , the inverses of which are written @xmath467 and @xmath475 .",
    "they yield an isomorphism between reduction rules of cpsconvertible terms and cps terms .      to complete the proof , we only need to apply @xmath456 , @xmath474 , @xmath467 and @xmath475 to cpsconvertible terms , contexts , well - formed cps terms and continuations ( respectively ) in every reduction rule and check that we get a valid rule in the dual reduction system .",
    "the result is summarized in figure  [ fig : iso ] .",
    "@xmath445 , \\sigma \\rangle & \\rightarrow_t \\langle t , c[\\ ] , \\sigma[x\\mapsto v ] \\rangle & \\leftrightarrow & & \\langle x { \\vcentcolon\\mkern-1.2mu=}{\\ensuremath{\\mathop{expr}\\nolimits\\/}}\\ ; \\ t , \\mathcal{c } , \\sigma \\rangle & \\rightarrow_t \\langle t , \\mathcal{c } , \\sigma[x\\mapsto v ] \\rangle \\\\&&&&&\\quad\\text{when $ \\langle { \\ensuremath{\\mathop{expr}\\nolimits\\/}},\\sigma \\rangle \\rightarrow_e^\\star      v$}\\notag\\\\ \\langle { \\ensuremath{\\mathop{\\mathbf{if}}\\ { \\ensuremath{\\mathop{expr}\\nolimits\\/}}\\   \\mathop{\\mathbf{then}}\\ t_1\\ \\mathop{\\mathbf{else}}\\ t_2 } } , c[\\ ] , \\sigma \\rangle & \\rightarrow_t \\langle t_1 , c[\\ ] , \\sigma \\rangle & \\leftrightarrow & & \\langle { \\ensuremath{\\mathop{\\mathbf{if}}\\ { \\ensuremath{\\mathop{expr}\\nolimits\\/}}\\   \\mathop{\\mathbf{then}}\\ t_1\\ \\mathop{\\mathbf{else}}\\ t_2 } } , \\mathcal{c } , \\sigma \\rangle & \\rightarrow_t \\langle t_1 , \\mathcal{c } , \\sigma \\rangle \\\\&&&&&\\quad\\text{if } \\langle { \\ensuremath{\\mathop{expr}\\nolimits\\/}},\\sigma \\rangle \\rightarrow_e^\\star      { \\ensuremath{\\mathop{\\mathbf{true}}\\nolimits}}\\notag\\\\ \\langle { \\ensuremath{\\mathop{\\mathbf{if}}\\ { \\ensuremath{\\mathop{expr}\\nolimits\\/}}\\   \\mathop{\\mathbf{then}}\\ t_1\\ \\mathop{\\mathbf{else}}\\ t_2 } } , c[\\ ] , \\sigma \\rangle & \\rightarrow_t \\langle t_2 , c[\\ ] , \\sigma \\rangle & \\leftrightarrow & & \\langle { \\ensuremath{\\mathop{\\mathbf{if}}\\ { \\ensuremath{\\mathop{expr}\\nolimits\\/}}\\   \\mathop{\\mathbf{then}}\\ t_1\\ \\mathop{\\mathbf{else}}\\ t_2 } } , \\mathcal{c } , \\sigma \\rangle & \\rightarrow_t \\langle t_2 , \\mathcal{c } , \\sigma \\rangle \\\\&&&&&\\quad\\text{if } \\langle { \\ensuremath{\\mathop{expr}\\nolimits\\/}},\\sigma \\rangle \\rightarrow_e^\\star      { \\ensuremath{\\mathop{\\mathbf{false}}\\nolimits}}\\notag\\\\ \\langle { \\ensuremath{\\mathop{expr}\\nolimits\\/ } } , c[[\\ ] \\ ; \\ f(v_1 , \\ldots , v_n ) ] , \\sigma \\rangle & \\rightarrow_t \\langle \\epsilon , c[[\\ ] \\ ; \\ f(v_1 , \\ldots , v_n ) ] \\rangle & \\leftrightarrow & & \\langle { { \\ensuremath{\\mathop{\\mathbf{invoke}}\\nolimits}}}\\ { \\ensuremath{\\mathop{expr}\\nolimits\\/ } } , f(v_1 , \\ldots , v_n ) { \\cdot}\\mathcal{c } , \\sigma \\rangle & \\rightarrow_t \\langle { \\ensuremath{\\mathop{\\mathbf{invoke}}\\nolimits } } , f(v_1 , \\ldots , v_n ) { \\cdot}\\mathcal{c } \\rangle\\\\ \\langle { \\ensuremath{\\mathop{expr}\\nolimits\\/ } } , c[[\\ ] \\ ; \\ f(v_1 , \\ldots , v_n , \\circleddash ) ] , \\sigma \\rangle & \\rightarrow_t \\langle \\epsilon , c[[\\ ] \\ ; \\ f(v_1 , \\ldots , v_n , v ) ] \\rangle & \\leftrightarrow & & \\langle { { \\ensuremath{\\mathop{\\mathbf{invoke}}\\nolimits}}}\\ { \\ensuremath{\\mathop{expr}\\nolimits\\/ } } , f(v_1 , \\ldots , v_n , \\boxdot ) { \\cdot}\\mathcal{c } , \\sigma \\rangle & \\rightarrow_t \\langle { \\ensuremath{\\mathop{\\mathbf{invoke}}\\nolimits } } , f(v_1 , \\ldots , v_n , v ) { \\cdot}\\mathcal{c } \\rangle \\\\&&&&&\\quad\\text{when $ \\langle { \\ensuremath{\\mathop{expr}\\nolimits\\/}},\\sigma \\rangle \\rightarrow_e^\\star      v$}\\notag\\\\ \\langle { \\ensuremath{\\mathop{expr}\\nolimits\\/ } } , [ \\ ] , \\sigma \\rangle & \\rightarrow_t v & \\leftrightarrow & & \\langle { { \\ensuremath{\\mathop{\\mathbf{invoke}}\\nolimits}}}\\ { \\ensuremath{\\mathop{expr}\\nolimits\\/ } } , \\varepsilon , \\sigma \\rangle & \\rightarrow_t v \\\\&&&&&\\quad\\text{when $ \\langle { \\ensuremath{\\mathop{expr}\\nolimits\\/}},\\sigma \\rangle \\rightarrow_e^\\star",
    "v$}\\notag\\\\ \\langle q , c[\\ ] , \\sigma \\rangle & \\rightarrow_t \\langle q[x_i\\setminus \\sigma\\ x_i ] , c[\\ ] \\rangle & \\leftrightarrow & & \\langle q , \\mathcal{c } , \\sigma \\rangle & \\rightarrow_t \\langle q[x_i\\setminus \\sigma\\ x_i ] , \\mathcal{c } \\rangle \\\\&&&&&\\quad\\text{for every $ x_i$ in $ { \\mathop{\\mathrm{dom}}\\nolimits}(\\sigma)$}\\notag\\\\ \\notag\\\\ \\langle q\\ ; \\",
    "f(v_1 , \\ldots , v_n ) , c[\\ ] \\rangle & \\rightarrow_q \\langle q , c[[\\ ] \\ ; \\ f(v_1 , \\ldots , v_n ) ] \\rangle & \\leftrightarrow & & \\langle { \\ensuremath{\\mathop{\\mathbf{push}}\\nolimits}}\\ f(v_1 , \\ldots , v_n)\\ ; \\ q , \\mathcal{c } \\rangle & \\rightarrow_q \\langle q , f(v_1 , \\ldots , v_n ) { \\cdot}\\mathcal{c } \\rangle\\\\ \\langle q\\ ; \\",
    "f(v_1 , \\ldots , v_n , f ) , c[\\ ] \\rangle & \\rightarrow_q \\langle q\\ ; \\ f , c[[\\ ] \\ ; \\ f(v_1 , \\ldots , v_n , \\circleddash ) ] \\rangle & \\leftrightarrow & & \\langle { \\ensuremath{\\mathop{\\mathbf{push}}\\nolimits}}\\ f(v_1 , \\ldots , v_n , \\boxdot)\\ ; \\ q ' , \\mathcal{c } \\rangle & \\rightarrow_q \\langle q ' , f(v_1 , \\ldots , v_n , \\boxdot ) { \\cdot}\\mathcal{c } \\rangle \\\\&&&&&\\quad\\text{when $ q ' = ( q\\ ; \\ f)^\\blacktriangle$}\\\\ \\langle \\epsilon , c[[\\ ] \\ ; \\ f(v_1 , \\ldots , v_n ) ] \\rangle & \\rightarrow_q \\langle t , c[\\ ] , \\sigma \\rangle & \\leftrightarrow & & \\langle { \\ensuremath{\\mathop{\\mathbf{invoke}}\\nolimits } } , f(v_1 , \\ldots , v_n ) { \\cdot}\\mathcal{c } \\rangle & \\rightarrow_q \\langle t , \\mathcal{c } , \\sigma \\rangle \\\\&&&&&\\quad\\text{when } f(x_1,\\ldots , x_n ) = t      \\text { and } \\sigma = \\{x_i\\mapsto v_i\\}\\notag\\end{aligned}\\ ] ]      william  d. clinger .",
    "proper tail recursion and space efficiency . in _ proceedings of the acm sigplan 1998 conference on programming language design and implementation",
    "_ , pldi 98 , pages 174185 , new york , ny , usa , 1998 .",
    "olivier danvy and ulrik schultz .",
    "lambda - lifting in quadratic time . in _ functional and logic programming _ , volume 2441 of _ lecture notes in computer science _ , pages 134151 .",
    "springer - verlag , berlin , germany , 2002 ."
  ],
  "abstract_text": [
    "<S> this paper is a companion technical report to the article `` continuation - passing c : from threads to events through continuations '' . </S>",
    "<S> it contains the complete version of the proofs of correctness of lambda - lifting and cps - conversion presented in the article . </S>"
  ]
}