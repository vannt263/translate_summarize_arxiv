{
  "article_text": [
    "a ubiquitous robot perception task is that of identifying and localizing objects whose 3d models are known ahead of time : examples include robots operating in flexible automation factory settings , and domestic robots manipulating common household objects .",
    "traditional methods for identifying and localizing objects rely on a two - step procedure : i ) precompute a set of feature descriptors on the 3d models and match them to observed features , and ii ) estimate the rigid transform between the set of found correspondences . in more recent methods ,",
    "global descriptors jointly encoding object pose and viewpoint information are computed over different training instances , and a lookup is performed at test time . while such discriminative methods have been used successfully , they are limited by the ability of the feature descriptors to capture variations in observed data . for illustration , consider a scene with two objects , one almost completely occluding the other .",
    "methods that employ feature correspondence matching fare poorly as key feature descriptors could be lost due to occlusion ( fig .",
    "[ fig : chess ] ) , whereas learning - based methods could suffer as they might have not seen a similar training instance where the object is only partially visible .",
    "we introduce an orthogonal approach to tackle this problem : perception via search ( perch ) , which exploits the fact that the full 6 dof sensor pose is available for most robotic systems .",
    "perch is a generative approach that attempts to simulate or render the scene which best explains the observed data .",
    "our hypothesis is that if 3d models and sensor pose are available , we could perform deliberative reasoning :  under this configuration of objects in the scene for the given sensor pose , we would expect to see only this specific portion of that object \" .",
    "the ability to reason deliberatively paves the way for an exhaustive search over possible configurations of objects .    while exhaustive search provides optimal solutions , it is often impractical owing to the size of the state space that grows exponentially with the number of objects in the scene .",
    "a key insight in this work is that the exhaustive search over possible scene configurations can be formulated as a tree search problem for a specific choice of an ` explanation cost ' .",
    "the formulation involves breaking down the scene explanation cost into additive components over individual objects in the scene , which in turn manifest as edge costs in a tree called the monotone scene generation tree .",
    "this allows us to use state - of - the - art heuristic search techniques for determining the configuration of objects that best explains the observed scene .",
    "we summarize our contributions below :     [ chess_real ]         [ chess_depth ]    * perception via search ( perch ) , an algorithm for simultaneously localizing multiple objects in 2.5d or 3d sensor data when 3d models of those objects are available along with the camera pose . * formulating the multi - object localization problem as the minimization of an ` explanation cost ' that captures the difference between the observed scene and the hypothesized scene . * exploiting structure in the explanation cost to cast it as a combinatorial search problem on a tree which we call the monotone scene generation tree .",
    "this alleviates the need to exhaustively generate / synthesize every possible scene while still returning solutions are that are provably optimal or bounded suboptimal .",
    "* incorporating parallelism in the search procedure , thereby allowing the algorithm to scale with the availability of computation .    in our experiments ,",
    "we show how perch can localize objects even under heavy occlusion  a result which would be hard to obtain without explicit deliberative reasoning .",
    "while model - based recognition and pose estimation of objects has been an active area of research for decades in the computer vision community  @xcite , the proliferation of low - cost depth sensors such as the microsoft kinect has introduced a plethora of opportunities and challenges .",
    "we describe approaches in vogue for object recognition and localization from 3d sensor data , their limitations , inspirations from early research in vision that motivate our work , and the potential role of contemporary learning - based systems .",
    "model - based object recognition and localization in the present 3d era falls broadly under two approaches : _ local _ and _ global _ recognition systems .",
    "the former class of algorithms operate in a two step procedure : i ) compute and find correspondences between a set of local shape - preserving 3d feature descriptors on the model and the observed scene and ii ) estimate the rigid transform between a set of geometrically consistent correspondences . a final",
    ", optional and often used step is to perform a fine - grained local optimization to align the model to the scene and obtain the pose .",
    "examples of local 3d feature descriptors range from spin images  @xcite to fast point feature histograms ( fpfh )  @xcite , whereas final alignment procedures include iterative closest point ( icp )  @xcite and bingham procrustrean alignment ( bpa )  @xcite . the survey paper by aldoma et al .",
    "@xcite provides a comprehensive overview of other local approaches .",
    "the second , _ global _ recognition systems employ a single - shot process for identifying object type and pose jointly .",
    "global feature descriptors encode the notion of an object and capture shape and viewpoint information jointly in the descriptor .",
    "these approaches employ a training phase to build a library of global descriptors corresponding to different observed instances ( e.g. , each object viewed from different viewpoints ) and attempt to match the descriptor computed at observation time to the closest one in the library . additionally , global methods unlike the local ones , require points in the observed scene to be segmented into different clusters , so that descriptors can be computed on each object cluster separately . some of the global recognition systems include viewpoint feature histogram ( vfh )  @xcite , clustered viewpoint feature histogram ( cvfh )  @xcite , our - cvfh  @xcite , ensemble of shape functions ( esf )  @xcite , and global radius - based surface descriptors ( grsd )  @xcite . other approaches to estimating object pose include local voting schemes  @xcite or template matching  @xcite to first detect objects , and then using global descriptor matching or icp for pose refinement .",
    "although both local and global feature - based approaches have enjoyed popularity owing to their speed and intuitive appeal , they suffer when used for identifying and localizing multiple objects in the scene .",
    "the limitation is perhaps best described by the following lines from the book by stevens and beveridge  @xcite : `` _ _ searching for individual objects in isolation precludes explicit reasoning about occlusion .",
    "although the absence of a model feature can be detected ( i.e. , no corresponding data feature ) , the absence can not be explained ( why is there no corresponding data feature ? ) . as the number of missing features",
    "increase , recognition performance degrades _ _ '' . global verification  @xcite and filtering  @xcite approaches somewhat attempt to address the occlusion problems faced by feature - based methods through a joint optimization procedure over candidate object poses , but are restricted by the fact that initial predictions for object poses are provided by a system that does not model occlusion . in this work , we aim to explicity reason about the interactions between multiple objects in the observed data by hypothesizing or rendering scenes , and using combinatorial search to control the number of scenes generated .",
    "the idea of using search to ` explain ' scenes was popular in the early years of 2d computer vision : goad  @xcite promoted the idea of treating feature matching between the observed scene and 3d model as a constrained search while lowe  @xcite developed and implemented a viewpoint - constrained feature matching system .",
    "grimson  @xcite introduced the interpretation tree to systematically search for geometrically - consistent matches between scene and model features , while using various heuristics to speed up search .",
    "our work is also based on a search system , but it differs from the aforementioned works in that the search is over the space of full hypothesized / rendered scenes and not feature correspondences .",
    "in fact , our proposed algorithm does not employ feature descriptors at all .",
    "the philosophy of the render , match and refine ( rmr ) approach proposed by stevens and beveridge  @xcite motivates our work .",
    "rmr explicitly models interaction between objects by rendering the scene and uses occlusion data to inform measurement of similarity between the rendered and observed scenes .",
    "it then uses a global optimization procedure to iteratively improve the rendered scene to match the observed one .",
    "perch , our proposed algorithm , operates on a similar philosophy but differs in several details .",
    "the ` explanation cost ' we use to compare the rendered and observed scene is based purely on 3d sensor data , as opposed to the 2d edge - feature and per - pixel depth differences used in rmr that make it vulnerable to offset errors between the rendered and observed 2d scenes .",
    "moreover , the explanation cost we propose can be decomposed over the objects in the scene , thereby obviating the need for exhaustive search over the joint object poses .",
    "finally , an emerging trend for object recognition and pose estimation in rgb - d data is the use of deep neural networks trained on synthetic data generated using 3d models  @xcite . as promising as deep learning methods are",
    ", they would require sufficient training data to capture invariances to multi - object interaction and occlusion , the generation of which is a combinatorial problem by itself .",
    "on the other hand , these methods could be incorporated in perch as heuristics for guiding deliberative search as discussed in sec .",
    "[ subsec : heuristics ] .",
    "the problem we consider is that of localizing tabletop objects in a point cloud or 2.5d data such as from a kinect sensor .",
    "the problem statement is as follows : given 3d models of @xmath0 unique objects , a point cloud ( @xmath1 ) of a scene containing @xmath2 objects ( possibly containing replicates of the @xmath0 unique objects ) , and the 6 dof pose of the sensor , we are required to find the 3 dof pose ( @xmath3 ) of each of the @xmath4 objects in the scene .",
    "we make the following assumptions :    * the number ( @xmath4 ) and type of objects in the scene are known ahead of time ( but not the correspondences themselves ) . * the objects in the scene vary only in position @xmath5 and yaw @xmath63 dof , with respect to their 3d models . *",
    "the input point cloud can be preprocessed ( table plane , background filtered etc . )",
    "such that the points in it only belong to objects of interest .",
    "* we have access to the intrinsic parameters of the sensor , so that we can render scenes using the available 3d models .",
    "we specifically note that we _ do not _ make any assumptions about the ability to ` cluster ' points into different object groups as is done by most global 3d object recognition methods such as the viewpoint feature histogram ( vfh )  @xcite .      throughout the paper",
    ", we will use the following notation :    * @xmath7 : an object state characterized by @xmath8 , the unique object i d , position and yaw . *",
    "@xmath1 : the input / observed point cloud from the depth sensor . * @xmath9 : a point cloud generated by rendering a scene containing objects @xmath10 . *",
    "@xmath11 : a point @xmath12 in any point cloud . *",
    "@xmath13 , the point cloud containing points in @xmath9 but not in @xmath14 . in other words , the set of points belonging to object @xmath15 that would be visible given the presence of objects @xmath16 .",
    "* @xmath17 : the set of all points in the volume occupied by object @xmath15 .",
    "when it is not possible to compute this in closed form , this can be replaced by an admissible / conservative approximation , for example , the volume of an inscribed cylinder .",
    "* @xmath18 , the union of volumes occupied by objects @xmath10 .      ) and the number of unexplained points in the rendered point cloud ( @xmath19).,title=\"fig:\",height=113 ] ) and the number of unexplained points in the rendered point cloud ( @xmath19).,title=\"fig:\",height=113 ]    we formulate the problem of identifying and obtaining the 3 dof poses of objects @xmath20 as that of finding the minimizer of the following ` explanation cost ' : @xmath21 } \\\\    j_{rendered}(o_{1:k } ) & = \\sum_{p \\in r_k}\\mathds{1}_{[p \\text { is unexplained by }    i]}\\end{aligned}\\ ] ]    in which the indicator function @xmath22}$ ] for a point cloud @xmath23 and point @xmath11 is defined as follows :    @xmath24 } & = \\begin{cases } 1 & \\text{if }      \\min_{p '      \\in c}\\|p'-p\\| > \\delta \\\\      0   & \\text{otherwise } { \\addtocounter{equation}{1}\\tag{\\theequation}}\\label{eq : explanation_indicator }    \\end{cases}\\end{aligned}\\ ] ]    for some sensor noise threshold @xmath25 .",
    "we will use the notation @xmath26 and @xmath19 to refer to the observed and rendered explanation costs respectively .",
    "the explanation cost essentially counts the number of points in the observed scene that are not explained by the rendered scene and the number of points in the rendered scene that can not be explained by the observed scene . while it looks simplistic , the cost function forces the rendering of a scene that as closely explains the observed scene as possible , from both a ` filled ' ( occupied ) and ` empty ' ( negative space ) perspective .",
    "figure  [ fig : cost ] illustrates the computation of the ` explanation cost ' .",
    "another interpretation for the explanation cost is to treat it as an approximation of the difference between the union volume and intersection volume of the objects in the observed and rendered scenes .    in the ideal scenario where there is no noise in the observed scene and where we have access to a perfect renderer",
    ", we could do an exhaustive search over the joint object poses to obtain a solution with zero cost .",
    "however , this naive approach is a recipe for computational disaster : even when we have only 3 objects in the scene and discretize our positions to 100 grid locations and 10 different orientations , we would have to synthesize / render @xmath27 scenes to find the global optimum .",
    "this immediately calls for a better optimization scheme , which we derive next .",
    "the crux of our algorithm exploits the insight that the explanation cost function can be decomposed over the set of objects in the scene . to see this",
    ", we first note that the rendered scene containing @xmath4 objects , @xmath28 can be incrementally constructed : @xmath29 where @xmath30 and @xmath31 is assumed to be an empty point cloud .",
    "the constraint @xmath32 translates to saying that the addition of a new object to the scene does not ` occlude ' the existing scene , thereby guaranteeing that every point in @xmath33 exists in @xmath34 as well . in other words ,",
    "the number of points in the rendered point cloud can only increase with the addition of a new object .",
    "the above constraint implicity assumes that the scene does not contain objects which can simultaneously occlude an object and also be occluded by another object , such as horseshoe - shaped objects .",
    "using the above , we can write the rendered explanation cost as follows : @xmath35 } & \\\\                        & = \\sum_{i=1}^k\\sum_{p \\in \\delta                        r_i}\\mathds{1}_{[p \\text { is unexplained by }                        i ] } & \\text { s.t . }",
    "r_{i-1 } \\subseteq r_{i}\\end{aligned}\\ ] ] we then similarly decompose the observed explanation cost : @xmath36 } & \\\\              & = \\sum_{p \\in i } \\prod_{i=1}^k\\mathds{1}_{[p \\text { is unexplained by }    \\delta r_i ] } & \\text { s.t . }",
    "r_{i-1 } \\subseteq r_{i}\\\\                 & = \\sum_{i=1}^k\\sum_{p \\in \\{i \\cap v(o_i)\\ } } \\mathds{1}_{[p    \\text { is unexplained by }    \\delta r_i]}\\\\                  & \\;\\qquad+ \\sum_{p \\in \\{i - v_k\\ } }    \\mathds{1}_{[p \\text { is unexplained by }    r_k ] } & \\text { s.t . }",
    "r_{i-1 } \\subseteq r_{i}\\end{aligned}\\ ] ]    with the above decompositions , we can re - write the overall optimization objective as : @xmath37 where @xmath38 } \\\\",
    "\\delta j_{o}^i & =   \\sum_{p \\in \\{i \\cap v(o_i)\\ } } \\mathds{1}_{[p \\text { is unexplained by } \\delta r_i ] } + \\text{residual}(i)\\\\    \\text{residual}(i ) & = \\begin{cases }                \\sum_{p \\in \\{i - v_k\\ } }                \\mathds{1}_{[p \\text { is unexplained by }                r_k ] } & \\text { if } i = k\\\\      0 & \\text { otherwise }    \\end{cases}\\end{aligned}\\ ] ]     level of the tree is a goal state , and the task is to find the one that has the lowest cost path from the root  marked by a green bounding box in this example . ]",
    "equation  [ eq : total_cost ] defines a pairwise - constrained optimization problem , the constraint being that the assignment of the @xmath39 object does not occlude the scene generated by the assignment of the previous objects @xmath40 through @xmath41 .",
    "a natural way to solve this problem is to construct a tree that satisifies the required constraint , and assigns the object poses in a sequential order .",
    "this is precisely our approach and the resulting tree we construct is called the monotone scene generation tree ( msgt ) , with ` monotone ' emphasizing that as we go down the tree , newly added objects can not occlude the scene generated thus far ( fig .",
    "[ fig : msgt ] ) .",
    "we note that while a particular configuration of objects can be generated by choosing different assignment orders , only one is sufficient to retain as all those configurations have identical explanation costs .",
    "thus , we obtain a tree structure instead of a directed acyclic graph ( dag ) . formally ,",
    "any vertex / state in the msgt is a partial assignment of object states : @xmath42 , with @xmath43 . for a msgt state @xmath44 with an assignment of @xmath45 objects , the implicit successor generation function and the associated cost",
    "are defined as follows : @xmath46 the root node of the tree @xmath47 is an empty state containing no object assignments , while a goal state is any state @xmath44 that has an assignment for all objects .",
    "given the msgt construction , the multi - object localization problem reduces to that of finding the cheapest cost path in the tree from the root state to any goal state .",
    "although we have replaced exhaustive search with tree search , the problem still remains daunting owing to its branching factor .",
    "assume that we have @xmath48 possible configurations @xmath49 for each object .",
    "then , the worst case branching factor for the msgt is @xmath50 for all levels if we allow repetition of objects in the scene , or @xmath51 for level @xmath52 if there is no repetition . figure  [ fig : mosaic ] illustrates this by showing a subset of the states generated during the tree search corresponding to the scene in fig .",
    "[ fig : msgt ] . while heuristic search techniques such as a * are often a good choice for such problems , they require an _ admissible _ heuristic that provides a conservative estimate of the remaining cost - to - go .",
    "usual heuristic search methods are limited by the following : i ) admissible heuristics are non - trivial to obtain for this problem , and ii ) they can not support multiple heuristics , each of which could be useful on their own  for e.g , different feature - based and learning - based methods could serve as a heuristic each .",
    "fortunately , recent work in heuristic search  @xcite allows us to use multiple , inadmissible heuristics to find solutions with bounded suboptimality guarantees .",
    "the particular multi - heuristic search we use is the focal - mha *  @xcite algorithm , and its choice is motivated by the fact that it permits the use of inadmissible heuristics that have no connection with the cost structure of the problem .",
    "this necessity will become clear in sec .",
    "[ subsec : heuristics ] . at a high level",
    ", focal - mha * operates much like a * search . like a * , it maintains a priority list of states ordered by an estimate of the path cost through that state and repeatedly ` expands ' the most promising states until a goal is found .",
    "the difference from a * is in that focal - mha * interleaves this process with expansion of states chosen greedily by other heuristics  @xcite .",
    "finally , focal - mha * guarantees that the solution found will have a cost which is bounded by @xmath53 , where opt is the optimal solution cost and @xmath54 is a user - chosen suboptimality bound .",
    "algorithm  [ alg : perch ] shows an instantiation of focal - mha * in the context of perch .    the implicit msgt construction ( eq .  [ eq : succ ] and eq .",
    "[ eq : cost ] ) .",
    "suboptimality bound factor @xmath55 ( @xmath56 ) .",
    "@xmath40 admissible heuristic @xmath57 and @xmath58 arbitrary , possibly inadmissible , heuristics @xmath59 .",
    "+    an assignment of object poses @xmath60 with @xmath61 whose cost is within @xmath62 .",
    "+    @xmath63 planner @xmath64 focal - mha*-planner ( ) planner.@xmath65 planner.@xmath66 planner.@xmath67 planner.@xmath68 planner.@xmath69 @xmath70 planner.@xmath71 @xmath60      focal - mha * requires one admissible and multiple inadmissible heuristics .",
    "constructing an informative admissible heuristic is non - trivial for this setting , and thus we set our admissible heuristic to the trivial heuristic that returns @xmath72 for all states .",
    "we next describe our inadmissible heuristics .",
    "the large branching factor of the msgt might result in the search ` expanding ' or opening every node in a level before moving on to the next . to guide the search towards the goal ,",
    "a natural heuristic would be a depth - first heuristic that encourages expansion of states further down in the tree .",
    "consquently , our first inadmissible heuristic for focal - mha * is the depth heuristic that returns the number of assignments left to make : @xmath73    as a reminder , states with _ smaller _ heuristic values are expanded ahead of those with larger values .",
    "next , it would be useful to encourage the search to expand states that have maximum overlap with the observed point cloud @xmath1 so far , rather than states with little overlap with the observed scene .",
    "our second heuristic is therefore the overlap heuristic that counts the number of points in @xmath1 that _ do not _ fall within the volume of assigned objects : @xmath74}\\end{aligned}\\ ] ] where @xmath75 and @xmath76 is the union of the volumes occupied by the @xmath45 assigned objects .",
    "another interpretation for this heuristic is the number of points in the observed scene that are outside the space carved by objects assigned thus far .",
    "while we use only the above two heuristics in this work , we note that there is a possibility of using a wide class of heuristics derived from feature and learning - based methods .",
    "for instance , if an algorithm like vfh  @xcite produced a pose estimate @xmath77 for each of the @xmath4 objects in the scene , then a heuristic for @xmath44 with @xmath78 could resemble @xmath79 for some appropriate choice of the norm .",
    "more generally , the multi - heuristic approach we use provides a framework to plug in various discriminative algorithms each with their own strengths and weaknesses .",
    "perch inherits all the theoretical properties of focal - mha *  @xcite .",
    "we state those here without proof :    perch is complete with respect to the construction of the graph , i.e , if a solution ( feasible assignment of all object poses ) exists in the msgt , it will be found .",
    "the returned solution has an explanation cost which is no more than @xmath55 times the cost of the best possible solution under the chosen graph construction .    as a disclaimer",
    ", we note that bounded suboptimal solutions with regard to the explanation cost do not translate to any bounded suboptimal properties with respect to the true object poses in the observed scene .",
    "the most computationally complex part of perch is that of generating successor states for a given state in the msgt .",
    "this involves generating and rendering every state that contains one more object than the number in the present state , in every possible configuration .",
    "several elements influence this branching factor : the number of objects in the scene , the chosen discretization for object poses , whether objects are rotationally symmetric ( in which case only @xmath5 is of interest ) etc . in our implementation , we limit the complexity by favoring coarse discretization and compensating with a local alignment technique such as icp  @xcite . specifically , every time we render a state with a new object , we take the non - occluded portion and perform an icp alignment in the local vicinity of the observed point cloud .",
    "this allows us to obtain accurate pose estimates while retaining a coarse discretization .",
    "we do note that the underlying msgt now becomes a function of the observed point cloud due to the icp adjustment .",
    "the generation of successor states is an embarassingly parallel process .",
    "we exploit this in our implementation by using multiple processes to generate successors in parallel .",
    "theoretically , with sufficient number of cores , the time to expand a state would simply be the time to render a single scene .",
    "0.4     0.4      +    0.4     0.4     0.325     0.325     0.325     to evaluate the performance of perch for multi - object recognition and pose estimation in challenging scenarios where objects could be occluding each other , we pick the occlusion dataset described by aldoma et al .",
    "@xcite that contains objects partially touching and occluding each other .",
    "the dataset contains 3d cad models of 36 common household objects , and 23 rgb - d tabletop scenes with 82 object instances in total .",
    "all scenes except one contain objects only varying in translation and yaw , with some objects flipped up - side down . since perch is designed only for 3d pose estimation , we drop the one non - compatible scene from the dataset , and preprocess the 3d cad models such that they vary only in translation and yaw with respect to the ground truth poses .",
    "figure  [ fig : dataset ] shows some examples from the dataset .",
    "since perch requires that points in the scene only belong to objects of interest , we first preprocess the scene to remove the tabletop and background .",
    "then , based on the ransac - estimated table plane , we compute a transform that aligns the point cloud from the camera frame to a gravity aligned frame , to simplify construction of the msgt .",
    "perch has two parameters to set : the sensor noise threshold @xmath25 for determining whether a point is ` explained ' ( eq .",
    "[ eq : explanation_indicator ] ) , and the suboptimality factor @xmath55 for the focal - mha * algorithm . in our experiments",
    ", we set @xmath25 to @xmath80 mm to account for uncertainty in the depth measurement from the kinect sensor , as well as inaccuracies in estimating the table height using ransac . for the suboptimality factor @xmath55",
    ", we use a value of @xmath80 .",
    "while this results in solutions that can be suboptimal by a factor of upto @xmath80 , it greatly speeds up the search since computing the optimal solution typically takes much more time  @xcite . for focal - mha * , we use the two heuristics described in sec .",
    "[ subsec : heuristics ] . finally , for defining the msgt we pick a discretization resolution of @xmath81 cm for both @xmath82 and @xmath83 and @xmath84 degrees for yaw . the adaptive icp alignment ( sec .",
    "[ subsubsec : discretization ] ) is constrained to find correspondences within @xmath85 cm , which is half the discretization resolution .",
    "our first baseline is the our - cvfh global descriptor  @xcite , a state - of - the - art global descriptor designed to be robust to occlusions . by clustering object surfaces into separate smooth regions and computing descriptors for each portion",
    ", our - cvfh can handle occlusions better than descriptors such vfh and fpfh .",
    "furthermore , it has the added advantage of directly encoding the full pose of the object , with no ambiguity in camera roll .",
    "we build the training database by rendering 642 views of every 3d cad model from viewpoints sampled around the object .",
    "then , for computing the training descriptors we use moving least squares to upsample every training view to a common resolution followed by downsampling to the kinect resolution of @xmath80 mm as suggested in the our - cvfh paper  @xcite .",
    "since the number and type of models in the test scene is assumed to be known for perch , we use the following pipeline for fair comparison : for the @xmath4 largest clusters in the test scene we obtain the histogram distance to each of the models we know that are in the scene .",
    "then , we solve a min - cost matching problem to assign a particular model ( and associated pose ) to each cluster and obtain a feasible solution . finally , we constrain the full 6 dof poses returned by our - cvfh to vary only in translation and yaw and perform a local icp alignment for each object pose .",
    "the second baseline is an icp - based optimization one , which we will refer to as brute force without rendering ( bfw / or ) . here",
    ", we slide the 3d model of every object in the scene over the observed point cloud ( at the same discretization used for perch ) , and perform a local icp - alignment at every step .",
    "the location ( @xmath86 that has the best icp fitness score is chosen as the final pose for that model and made unavailable for other objects that have not yet been considered . since the order in which the models are chosen for sliding can influence the solution , we try all permutations of the ordering ( @xmath87 ) and take the overall best solution based on the total icp fitness score .",
    "0.155     0.155     0.155     0.155     0.155     0.155     0.155     0.155     0.155     to evaluate the accuracy of object localization , we use the following criterion : a predicted pose @xmath88 for an object is considered correct if @xmath89 and @xmath90 .",
    "we then compute the number of correct poses produced by each method for different combinations of @xmath91 and @xmath92 .",
    "figure  [ fig : experiments ] compares the performance of perch with bfw / or and our - cvfh .",
    "immediately obvious is the significant performance of perch over the baseline methods for @xmath93 .",
    "perch is able to correctly estimate the pose of over 20 objects with translation error under @xmath40 cm and rotation error under @xmath94 degrees . while the baseline methods have comparable recall for higher thresholds , they are unable to provide as many precise poses as perch does .",
    "further , perch consistently dominates the baseline methods for all definition of ` correct pose ' . among all methods , bfw / or performs the worst .",
    "this is mainly due to the fact that it uses the point cloud corresponding to the complete object model for icp refinement , rather than the point cloud corresponding to the unoccluded portion of the object .",
    "again , this showcases the necessity to explicity reason about self - occlusions as well as inter - object occlusions .",
    "the last column of the histogram in fig .",
    "[ fig : last_hist ] ( corresponding to @xmath95 , @xmath96 ) is essentially a measure of recognition alone  perch can correctly identify 69 of the 80 object instances , where ` identified ' is defined as obtaining a translation error under @xmath97 cm .",
    "figure  [ fig : experiment_examples ] shows some qualitative examples of perch s peformance on the occlusion dataset .",
    "further examples and illustrations are provided in the supplementary video .      unlike global descriptor approaches such as our - cvfh which require an elaborate training phase to build a histogram library",
    ", perch does not require any precomputation .",
    "consequently , the run time cost is high owing to the numerous scenes that need to be rendered .",
    "however , as mentioned earlier , the parallel nature of the problem and the easy availability of cluster computing makes this less daunting . for our experiments",
    ", we used the mpi framework to parallelize the implementation and ran the tests on a cluster of 2 amazon aws m4.10x machines , each having a 40-core virtual cpu .",
    "for each scene , we used a maximum time limit of 15 minutes and took the best solution obtained within that time .",
    "overall , the mean planning time was 6.5 minutes , and the mean number of hypotheses rendered ( i.e , states generated ) was 15564 .",
    "finally , to demonstrate that perch can be used for scenes containing several objects , we conducted a test on a chessboard scene ( fig .",
    "[ chess_real ] ) .",
    "we captured a kinect depth image of the scene containing 12 pieces , of which 6 are unique and 4 are rotationally symmetric .",
    "we ran perch with suboptimality bound factor @xmath98 and sensor resolution @xmath99 mm , and took the best solution found within a time limit of 20 minutes .",
    "the solution found ( i.e. , the depth image corresponding to the goal state ) is shown in fig .",
    "[ chess_depth ] .",
    "in his lecture on computer heuristics in 1985  @xcite , richard feynman notes that if one had access to all the generative parameters of a scene ( lighting , model etc . )",
    ", one could possibly generate every single scene and take the best match to the observed data .",
    "we presented perch as a first step towards this deliberative reasoning .",
    "the key contributions were the formulation of multi - object recognition and localization as an optimization problem and designing an efficient combinatorial search algorithm for the same .",
    "we demonstrated how perch can robustly localize objects under occlusion , and handle scenes containing several objects .",
    "while our results look promising on the accuracy front , much work remains to be done in making the algorithm suitable for real - time use .",
    "our future work involves exploring optimizations and heuristics for the search to obtain faster yet high quality solutions . specifically , we are interested in leveraging state - of - the - art discriminative learning to provide guidance for the search .",
    "other directions include generalizing perch to a variety of perception tasks that require deliberative reasoning .",
    "this research was sponsored by arl , under the robotics cta program grant w911nf-10 - 2 - 0016 .",
    "we thank maurice fallon and hordur johannson for making their kinect simulator publicly available as part of the point cloud library ."
  ],
  "abstract_text": [
    "<S> in many robotic domains such as flexible automated manufacturing or personal assistance , a fundamental perception task is that of identifying and localizing objects whose 3d models are known . </S>",
    "<S> canonical approaches to this problem include discriminative methods that find correspondences between feature descriptors computed over the model and observed data . while these methods have been employed successfully , they can be unreliable when the feature descriptors fail to capture variations in observed data ; a classic cause being occlusion . as a step towards deliberative reasoning , </S>",
    "<S> we present perch : perception via search , an algorithm that seeks to find the best explanation of the observed sensor data by hypothesizing possible scenes in a generative fashion . </S>",
    "<S> our contributions are : i ) formulating the multi - object recognition and localization task as an optimization problem over the space of hypothesized scenes , ii ) exploiting structure in the optimization to cast it as a combinatorial search problem on what we call the monotone scene generation tree , and iii ) leveraging parallelization and recent advances in multi - heuristic search in making combinatorial search tractable . </S>",
    "<S> we prove that our system can guaranteedly produce the best explanation of the scene under the chosen cost function , and validate our claims on real world rgb - d test data . </S>",
    "<S> our experimental results show that we can identify and localize objects under heavy occlusion  </S>",
    "<S> cases where state - of - the - art methods struggle . </S>"
  ]
}