{
  "article_text": [
    "erasure - correcting codes are the basis of the ubiquitous raid schemes for storage systems , where disks correspond to symbols in the code .",
    "specifically , raid schemes are based on mds ( maximum distance separable ) array codes that enable optimal storage and efficient encoding and decoding algorithms . with @xmath4 redundancy symbols ,",
    "an mds code is able to reconstruct the original information if no more than @xmath4 symbols are erased .",
    "an array code is a two dimensional array , where each column corresponds to a symbol in the code and is stored in a disk in the raid scheme .",
    "we are going to refer to a disk / symbol as a node or a column interchangeably , and an entry in the array as an element .",
    "examples of mds array codes are evenodd @xcite , b - code @xcite , x - code @xcite , rdp @xcite , and star - code @xcite .",
    "suppose that some nodes are erased in a systematic mds array code , we will rebuild them by accessing ( reading ) some information in the surviving nodes , all of which are assumed to be accessible .",
    "the fraction of the accessed information in the surviving nodes is called the _ rebuilding ratio_. if @xmath4 nodes are erased , then the rebuilding ratio is @xmath0 since we need to read all the remaining information .",
    "is it possible to lower this ratio for less than @xmath4 erasures ?",
    "apparently , it is possible : figure [ fig : firstfigure ] shows an example of our new mds code with @xmath3 information nodes and @xmath3 redundancy nodes , every node has @xmath3 elements , and operations are over a finite field of size @xmath9 . consider the rebuilding of the first information node , it requires access to @xmath9 elements out of @xmath10 ( a rebuilding ratio of @xmath1 ) , because @xmath11 and @xmath12 . in practice",
    ", there is a difference between erasures of the information ( also called systematic ) and the parity nodes .",
    "an erasure of the former will affect the information access time since part of the raw information is missing , however erasure of the latter does not have such effect , since the entire information is accessible .",
    "moreover , in most storage systems the number of parity nodes is negligible compared to the number of systematic nodes .",
    "therefore our constructions focus on the optimally of the rebuilding ratio related to the systematic nodes .",
    "mds array code over @xmath13 .",
    "assume the first node ( column ) is erased . ]    in @xcite , a related problem is discussed : the nodes are assumed to be distributed and fully connected in a network , and the concept of a _ repair bandwidth _ is defined as the minimum amount of data that needs to be transmitted in the network in order to rebuild the erased nodes .",
    "in contrast to our concept of the _ rebuilding ratio _ a transmitted element of data can be a function of a number of elements that are accessible on the same node .",
    "in addition , in their general framework , an acceptable rebuilding is one that retains the mds property and not necessarily rebuilds the original erased node , whereas , we restrict our solutions to _ exact _ rebuilding .",
    "it is clear that our framework is a special case of the general framework , hence , the repair bandwidth is a lower bound on the rebuilding ratio .",
    "what is known about lower bounds on the repair bandwidth ?",
    "in @xcite it was proved that a lower bound on the repair bandwidth for an @xmath14 mds code is : @xmath15 here the code has a total of @xmath16 nodes with @xmath17 nodes of information and @xmath18 nodes of redundancy / parity , where @xmath19 is the total amount of information .",
    "also all the surviving nodes are assumed to be accessible .",
    "it can be verified that figure [ fig : firstfigure ] matches this lower bound .",
    "note that equation ( [ eq : tradeoff ] ) represents the amount of information , it should be normalized to reach the ratio .",
    "a number of researchers addressed the repair bandwidth problem @xcite , however the constructed code achieving the lower bound all have low code rate , i.e. , @xmath20 . and it was shown by interference alignment in @xcite that this bound is asymptotically achievable for exact repair .    instead of trying to construct mds codes that can be easily rebuilt ,",
    "a different approach @xcite was used by trying to find ways to rebuild existing families of mds array codes .",
    "the ratio of rebuilding a single systematic node was shown to be @xmath21 for evenodd or rdp codes@xcite , both of which have 2 parities .",
    "however , based on the lower bound of the ratio can be as small as @xmath22 .",
    "moreover , related work on constructing codes with optimal rebuilding appeared independently in @xcite .",
    "their constructions are similar to this work , but only single erasure is considered .",
    "our main goal in this paper is to design @xmath14 mds array codes with _",
    "optimal rebuilding ratio , for arbitrary number of parities .",
    "_ we first consider the case of @xmath3 parities .",
    "we assume that the code is systematic .",
    "in addition , we consider codes with _ optimal update _ , namely , when an information element is written , only the element itself and one element from each parity node needs update , namely , there is optimal reading / writing during writing of information .",
    "hence , in the case of a code with @xmath3 parities only @xmath9 elements are updated . under such assumptions , we will prove that every parity element is a linear combination of exactly one information element from each systematic column .",
    "we call this set of information elements a _ parity set_. moreover , the parity sets of a parity node form a partition of the information array .    [ cols=\"^,^,^,^,^,^\",options=\"header \" , ]     for example , figure [ fig : shapes ] shows a code with @xmath9 systematic nodes and @xmath3 parity nodes .",
    "the parity sets corresponding to parity node @xmath23 are the sets of information elements in the same row .",
    "the parity sets that correspond to the parity node @xmath24 are the sets of information elements with the same symbol . for instance",
    "the first element in column @xmath23 is a linear combination of the elements in the first row and in columns @xmath25 , and @xmath3 . and",
    "the @xmath26 in column z is a linear combination of all the @xmath26 elements in columns @xmath27 , and @xmath3 .",
    "we can see that each systematic column corresponds to a permutation of the four symbols . in general",
    ", we will show that each parity relates to a set of a permutations of the systematic columns . without loss of generality , we assume that the first parity node corresponds to identity permutations ,",
    "namely , it is linear combination of rows . in the case of codes with @xmath3 parities ,",
    "we call the first parity the _ row parity _ and the second parity the _ zigzag parity_. the corresponding sets of information elements for a parity element are called _ row _ and _ zigzag sets _ , respectively .    it should be noted that in contrast to existing mds array codes such as evenodd and x - code , the parity sets in our codes are not limited to elements that correspond to straight lines in the array , but can also include elements that correspond to zigzag lines",
    ". we will demonstrate that this property is essential for achieving an optimal rebuilding ratio .",
    "if a single systematic node is erased , we will rebuild each element in the erased node either by its corresponding row parity or zigzag parity , referred to as _",
    "rebuild by row ( or by zigzag)_. in particular , we access the row ( zigzag ) parity element , and all the elements in this row ( zigzag ) set , except the erased element . for example , consider figure [ fig : shapes ] , suppose that the column labeled @xmath0 is erased , one can access the @xmath28 shaded elements and rebuild its first two elements by rows , and the rest by zigzags .",
    "namely , only half of the remaining elements are accessed .",
    "it can be verified that for the code in figure [ fig : shapes ] , all the three systematic columns can be rebuilt by accessing half of the remaining elements .",
    "thus the rebuilding ratio is @xmath22 , which is the lower bound expressed in .",
    "the key idea in our construction is that for each erased node , the row sets and the zigzag sets have a large intersection - resulting in a small number of accesses .",
    "so the question is : how do we find permutations such that the row sets and zigzag sets intersect as much as possible ? in this paper , we will present an optimal solution to this question by constructing permutations that are derived from binary vectors .",
    "this construction provides an optimal rebuilding ratio of @xmath22 for any erasure of a systematic node .",
    "how do we define permutations on integers from a binary vector ? we simply add to each integer the binary vector and use the sum as the image of this integer . here",
    "each integer is expressed as its binary expansion .",
    "for example , in order to define the permutation on integers @xmath29 from the binary vector @xmath30 , we express each integer in binary : @xmath31",
    ". then add ( mod @xmath3 ) the vector @xmath30 to each integer , and get @xmath32 . at last change each binary expansion back to integer and define it as the image of the permutation : @xmath33 .",
    "hence , @xmath34 are mapped to @xmath35 in this permutation , respectively .",
    "this simple technique for generating permutations is the key in our construction .",
    "we can generalize our construction for arbitrary @xmath4 ( number of parity nodes ) by generating permutations using @xmath4-ary vectors .",
    "our constructions are optimal in the sense that we can construct codes with @xmath4 parities and a rebuilding ratio of @xmath36 .",
    "so far we focused on the optimal rebuilding ratio , however , a code with two parity nodes should be able to correct two erasures , namely , it needs to be an mds code .",
    "we will present that for large enough field size the code can be made mds . in particular ,",
    "another key result in this paper is that for the case of a code with two parity nodes , the field size is @xmath9 , and this field size is optimal .",
    "in addition , our codes have an optimal array size in the sense that for a given number of rows , we have the maximum number of columns among all systematic codes with optimal ratio and update . however , the length of the array is exponential in the width .",
    "we introduce techniques for making the array wider while having a rebuilding ratio that is very close to @xmath36 .",
    "we also considered the following generalization : suppose that we have an mds code with three parity nodes , if we have a single erasure , using our codes , we can rebuild the erasure with rebuilding ratio of @xmath37 .",
    "what happens if we have two erasures ?",
    "what is the rebuilding ratio in this case ?",
    "our codes can achieve the optimal rebuilding ratio of @xmath38 .",
    "in general , if we have @xmath39 parity nodes and @xmath6 erasures happen , @xmath7 , we will prove that the lower bound of repair bandwidth is @xmath40 ( normalized by the size of the remaining array ) , and so is the rebuilding ratio .",
    "and the code we constructed achieves this lower bound for any @xmath6 .    in summary , the main contribution of this paper is the first explicit construction of systematic @xmath14 mds array codes for any constant @xmath18 , which achieves optimal rebuilding ratio of @xmath41 .",
    "moreover , our codes achieve optimal rebuilding ratio of @xmath5 when @xmath6 systematic erasures occur , @xmath7 .",
    "the parity symbols are constructed by linear combinations of a set of information symbols , such that each information symbol is contained exactly once in each parity node .",
    "these codes have a variety of advantages : 1 ) they are systematic codes , hence it is easy to retrieve information ; 2 ) they have high code rate @xmath42 , which is commonly required in storage systems ; 3 ) the encoding and decoding of the codes can be easily implemented ( for @xmath8 , the code uses finite field of size 3 ) ; 4 ) they match the lower bound of the ratio when rebuilding @xmath6 systematic nodes ; 5 ) the rebuilding of a failed node requires simple computation and access to only @xmath36 of the data in each node ( no linear combination of data ) ; 6 ) they have _ optimal update _ , namely , when an information element is updated , only @xmath43 elements in the array need update ; and 7 ) they have optimal array size .    the remainder of the paper is organized as follows .",
    "section [ sec3 ] constructs @xmath44 mds array codes with optimal rebuilding ratio .",
    "section [ sec2 ] gives formal definitions and some general observations on mds array codes .",
    "section [ code - duplication ] introduces code duplication and thus generates @xmath44 mds array codes for arbitrary number of columns .",
    "we discuss the size of the finite field needed for these constructions in section [ section 5 ] .",
    "decoding algorithms for erasures and errors are discussed in section [ sec : dec ] .",
    "section [ generalization ] generalizes the mds code construction to arbitrary number of parity columns .",
    "these generalized codes have properties that are similar to the @xmath44 mds array codes , likewise some of them has optimal rebuilding ratio .",
    "rebuilding of multiple erasures and generalization of the rebuilding algorithms are presented in section [ sec : multi ] .",
    "finally we provide concluding remarks in section [ summary ] .",
    "in the rest of the paper , we are going to use @xmath45 $ ] to denote @xmath46 and @xmath47 $ ] to denote @xmath48 , for integers @xmath49 . and denote the complement of a subset @xmath50 as @xmath51 . for a matrix @xmath52",
    ", @xmath53 denotes the transpose of @xmath52 . for a binary vector @xmath54",
    "we denote by @xmath55 its complement vector .",
    "the standard vector basis of dimension @xmath56 will be denoted as @xmath57 and the zero vector will be denoted as @xmath58 for an integer @xmath16 denote by @xmath59 the set of permutations over the integers @xmath60 $ ] , namely the symmetric group . for two functions @xmath61 ,",
    "denote their composition by @xmath62 or @xmath63 .",
    "recall that _",
    "rebuilding ratio _ is the average fraction of accesses in the surviving systematic and parity nodes while rebuilding one systematic node .",
    "more specific definition will be given in the next section . in this section",
    "we give the construction of mds array code with two parities and optimal rebuilding ratio @xmath22 for one erasure , which uses an optimal finite field of only size @xmath9 .",
    "we mentioned in the introduction that each @xmath44 mds array code with optimal update can be constructed by defining the row and zigzag parities ( proofs are given in section [ sec2 ] ) .",
    "more specifically , the row parity corresponds to identity permutation in each systematic column , and the zigzag parity corresponds to a set of permutations @xmath64 for the systematic columns @xmath65 . from the example in figure [ fig : shapes ] , we know that in order to get low rebuilding ratio , we need to find @xmath66 such that the row and zigzag sets used in rebuilding intersect as much as possible .",
    "in addition , since each parity element is a linear combination of elements in its parity set , we need to define the coefficients of the linear combination such that the code is mds . noticing that all elements and all coefficients are from some finite field , we would like to choose the coefficients such that the finite field size is as small as possible .",
    "so our construction of the code includes two steps :    1 .",
    "find zigzag permutations to minimize the ratio .",
    "2 .   assign the coefficients such that the code is mds .    the following construction constructs a family of mds array codes with @xmath3 parities using binary vectors . from any set @xmath67 , @xmath68",
    ", we construct a @xmath44 mds array code of size @xmath69 we will show that some of these codes have the optimal ratio of @xmath1 .    in this section",
    "all the calculations are done over @xmath70 . by abuse of notation",
    "we use @xmath71 $ ] both to represent the integer and its binary representation .",
    "it will be clear from the context which meaning is in use .",
    "let @xmath72 be an array of size @xmath73 for some integers @xmath74 and @xmath75 .",
    "let @xmath76 be a set of vectors of size @xmath17 which does not contain the zero vector .",
    "for @xmath77 we define the permutation @xmath78\\to [ 0,2^m-1 ] $ ] by @xmath79 , where @xmath80 is represented in its binary representation .",
    "one can check that this is actually a permutation .",
    "for example when @xmath81 , @xmath82 one can check that the permutation @xmath83 in vector notation is @xmath84 $ ] .",
    "in addition , we define @xmath85:x\\cdot v=0\\}$ ] as the set of integers orthogonal to @xmath86 . for example , @xmath87 .",
    "the construction of the two parity columns is as follows : the first parity is simply the row sums .",
    "the second parity is the linear combination of elements in the zigzag set .",
    "the zigzag sets @xmath88 are defined by the permutations @xmath89 as @xmath90 if @xmath91 we will denote the permutation @xmath92 as @xmath93 and the set @xmath94 as @xmath95 .",
    "assume column @xmath96 is erased , and define @xmath97 and @xmath98 .",
    "rebuild the elements in @xmath99 by rows and the elements in @xmath100 by zigzags .",
    "[ cnstr1 ]    [ orthogonal - permutations ] construct permutations @xmath101 and sets @xmath102 by the vectors @xmath103 as in construction [ cnstr1 ] , where @xmath104 is modified to be @xmath105",
    ". then the corresponding @xmath106 code has _",
    "optimal _ ratio of @xmath107    before proving the theorem , we first give an example . actually , this example is the code in figure [ fig : shapes ] with more details .",
    "let @xmath52 be an array of size @xmath108 .",
    "we construct a @xmath109 mds array code for @xmath52 as in theorem [ orthogonal - permutations ] that accesses @xmath1 of the remaining information in the array to rebuild any systematic node ( see figure [ fig2 ] ) .",
    "for example , @xmath110 , and for rebuilding of node @xmath0 ( column @xmath111 ) we access the elements @xmath112 , and the following four parity elements @xmath113 it is trivial to rebuild node @xmath0 from the accessed information . note that each of the surviving node accesses exactly @xmath1 of its elements .",
    "it can be easily verified that the other systematic nodes can be rebuilt the same way . rebuilding a parity node",
    "is easily done by accessing all the information elements .    in order to prove theorem [ orthogonal - permutations ] , we first prove the following lemma .",
    "we use a binary vector to represent its corresponding systematic node . and define @xmath114 as the number of coordinates at which @xmath86 has a @xmath0 but @xmath115 has a @xmath116 .",
    "[ lemma 3 ] ( i ) for any @xmath117 , to rebuild node @xmath86 , the number of accessed elements in node @xmath115 is @xmath118 ( ii ) for any @xmath119 , @xmath120    \\(i ) in rebuilding of node @xmath86 we rebuild the elements in rows @xmath121 by rows , thus the row parity column accesses the values of the sum of rows @xmath121 .",
    "moreover , the surviving node @xmath115 also accesses its elements in rows @xmath121 . hence ,",
    "by now @xmath122 elements are accessed .",
    "the elements of node @xmath86 in rows @xmath123 are rebuilt by zigzags , thus the zigzag parity column accesses the values of the zigzags sums @xmath124 , and each surviving systematic node accesses the elements of these zigzags from its column , unless these elements are already included in the rebuilding by rows .",
    "the zigzag elements in @xmath125 of node @xmath115 are in rows @xmath126 , where @xmath127 is the inverse function of @xmath128 .",
    "thus the extra elements node @xmath115 needs to access are in rows @xmath129 but , @xmath130 where we used the fact that @xmath131 are bijections , and @xmath132    \\(ii ) consider the group @xmath133 .",
    "recall that @xmath134 .",
    "the sets @xmath135 and @xmath136 are cosets of the subgroup @xmath137 , and they are either identical or disjoint",
    ". moreover , they are identical iff @xmath138 , namely @xmath139 however , by definition @xmath140 , and the result follows .",
    "let @xmath141 be a set of permutations over the set @xmath142 $ ] with associated subsets @xmath143 $ ] , where each @xmath144 .",
    "we say that this set is a set of _ orthogonal permutations _ if for any @xmath145 $ ] , @xmath146 where @xmath147 is the kronecker delta . for a set of orthogonal permutations , in order to rebuild any systematic node , only @xmath148 elements are accessed from each surviving systematic node by lemma [ lemma 3 ] . and",
    "only @xmath148 elements are accessed from each parity node , too .",
    "hence codes generated by orthogonal permutations has optimal rebuilding ratio @xmath22 .",
    "now we are ready to prove theorem [ orthogonal - permutations ] .    since @xmath149 for any @xmath150 , we get by lemma [ lemma 3 ] @xmath151 now consider @xmath152 and @xmath153 , for @xmath154 .",
    "note that @xmath155 so @xmath156 similarly , @xmath157 and @xmath158 hence the permutations @xmath159 are orthogonal permutations , and the ratio is @xmath22 .",
    "note that the optimal code can be shortened by removing some systematic columns and still retain an optimal ratio , i.e. , for any @xmath160 we have a code with optimal rebuilding .",
    "having found the set of orthogonal permutations , we need to specify the coefficients in the parities such that the code is mds .",
    "consider the @xmath106 code @xmath161 constructed by theorem [ orthogonal - permutations ] and the vectors @xmath162 .",
    "let @xmath163 be the finite field we use .",
    "let the information in row @xmath164 , column @xmath96 be @xmath165 .",
    "let its row and zigzag coefficients be @xmath166 . for a row set @xmath167 ,",
    "the row parity is @xmath168 . for a zigzag set @xmath169 ,",
    "the zigzag parity is @xmath170 .",
    "recall that the @xmath106 code is mds iff we can recover the information from up to @xmath3 columns erasures .",
    "it is clear that none of the coefficients @xmath171 can be zero .",
    "moreover , if we assign all the coefficients as @xmath172 we get that in an erasure of two systematic columns the set of equations derived from the parity columns are linearly dependent and thus not solvable ( the sum of the equations from the row parity and the sum of those from the zigzag parity will both be the sum of the entire information array ) .",
    "therefore the coefficients need to be from a field with more than @xmath0 nonzero element , thus a field of size at least @xmath9 is necessary .",
    "the construction below surprisingly shows that in fact @xmath173 is sufficient .",
    "[ cons3 ] for the code @xmath161 in theorem [ orthogonal - permutations ] over @xmath173 , define @xmath174 for @xmath175 .",
    "assign row coefficients as @xmath176 for all @xmath177 , and zigzag coefficients as @xmath178 where @xmath179 is represented in binary and the calculation in the exponent is done over @xmath70 .",
    "the coefficients in figure [ fig2 ] are assigned by construction [ cons3 ] .",
    "the following theorem shows that the code is mds .",
    "[ thm0506 ] construction [ cons3 ] is an @xmath106 mds code with optimal finite field size of @xmath9 .",
    "it is easy to see that if at least one of the two erased columns is a parity column then we can recover the information .",
    "hence we only need to show that we can recover from any erasure of two systematic columns . in an erasure of two systematic columns @xmath180,i",
    "< j$ ] , we access the entire remaining information in the array . for @xmath181 $ ]",
    "set @xmath182 , and recall that @xmath183 iff @xmath184 , thus @xmath185 and @xmath186 from the two parity columns we need to solve the following equations ( for some @xmath187 ) @xmath188 \\left [ \\begin{array}{c } a_{r , i } \\\\ a_{r , j } \\\\ a_{r',i } \\\\",
    "a_{r',j } \\\\",
    "\\end{array } \\right ] = \\left [ \\begin{array}{c } y_1 \\\\",
    "\\\\ y_4 \\end{array } \\right].\\ ] ] this set of equations is solvable iff @xmath189 note that the multiplicative group of @xmath190 is isomorphic to the additive group of @xmath70 , hence multiplying two elements in @xmath190 is equivalent to summing up their exponent in @xmath70 when they are represented as a power of the primitive element of the field @xmath173 . for columns @xmath191 and",
    "rows @xmath192 defined above , we have @xmath193 however in the same manner we derive that @xmath194 hence is satisfied and the code is mds .    *",
    "remark : * the above proof shows that @xmath195 , and @xmath196 for @xmath197 . and is a necessary and sufficient condition for a mds code for vectors @xmath198 .",
    "in addition to optimal ratio and optimal field size , we will show in the next section that the code in theorem [ orthogonal - permutations ] is also of optimal array size , namely , it has the maximum number of columns , given the number of rows .",
    "in this section , we first give some observations of an arbitrary mds array code with optimal update . then we prove some properties and give some examples of our code in construction [ cnstr1 ] .",
    "let us define an mds array code with 2 parities .",
    "let @xmath72 be an array of size @xmath199 over a finite field @xmath163 , where @xmath200,j\\in [ 0,k-1]$ ] , and each of its entry is an information element .",
    "we add to the array two parity columns and obtain an @xmath201 mds code of array size @xmath202 .",
    "each element in these parity columns is a linear combination of elements from @xmath52 .",
    "more specifically , let the two parity columns be @xmath203 and @xmath204 .",
    "let @xmath205 and @xmath206 be two sets such that @xmath207 are subsets of elements in @xmath52 for all @xmath208 $ ] . then for all @xmath208",
    "$ ] , define @xmath209 , for some sets of coefficients @xmath210 .",
    "we call @xmath23 and @xmath24 as the sets that generate the parity columns .",
    "we assume the code has optimal update , meaning that only @xmath9 elements in the code are updated when an information element is updated . under this assumption",
    ", the following theorem characterizes the sets @xmath23 and @xmath24 .    for an @xmath44 mds code with optimal update , the sets @xmath23 and @xmath24 are partitions of @xmath52 into @xmath211 equally sized sets of size @xmath17 , where each set in @xmath23 or @xmath24 contains exactly one element from each column .",
    "since the code is a @xmath44 mds code , each information element should appear at least once in each parity column @xmath212 however , since the code has optimal update , each element appears exactly once in each parity column .",
    "let @xmath213 , note that if @xmath214 contains two entries of @xmath52 from the systematic column @xmath215 , @xmath216 $ ] , then rebuilding is impossible if columns @xmath215 and @xmath217 are erased .",
    "thus @xmath214 contains at most one entry from each column , therefore @xmath218 however each element of @xmath52 appears exactly once in each parity column , thus if @xmath219 , @xmath214 @xmath220 @xmath23 , there is @xmath221 , with @xmath222 , which leads to a contradiction .",
    "therefore , @xmath223 for all @xmath224 . as",
    "each information element appears exactly once in the first parity column , @xmath225 is a partition of @xmath52 into @xmath211 equally sized sets of size @xmath17 .",
    "similar proof holds for the sets @xmath226 .    by the above theorem , for the @xmath96-th systematic column @xmath227 , its @xmath211 elements",
    "are contained in @xmath211 distinct sets @xmath228 , @xmath208 $ ] .",
    "in other words , the membership of the @xmath96-th column s elements in the sets @xmath229 defines a permutation @xmath230 \\to [ 0,p-1]$ ] , such that @xmath231 iff @xmath232 .",
    "similarly , we can define a permutation @xmath93 corresponding to the second parity column , where @xmath233 iff @xmath234 .",
    "for example , in figure [ fig : shapes ] each systematic column corresponds to a permutation of the four symbols .    observing that there is no importance of the elements ordering in each column , w.l.o.g .",
    "we can assume that the first parity column contains the sum of each row of @xmath52 and @xmath235 s correspond to identity permutations , i.e. @xmath236 for some coefficients",
    "we refer to the first and the second parity columns as the row parity and the zigzag parity respectively , likewise @xmath228 and @xmath238 , @xmath208 $ ] , are referred to as row sets and zigzag sets respectively .",
    "we will call @xmath93 , @xmath239 $ ] , zigzag permutations . by assuming that the first parity column contains the row sums , we want to ( 1 ) find zigzag permutations to minimize the rebuilding ratio ; and ( 2 ) assign the coefficients such that the code is mds .",
    "first we show that any set of zigzag sets @xmath240 defines a @xmath44 mds array code over a field @xmath163 large enough .",
    "[ zigzag - sets ] let @xmath72 be an array of size @xmath199 and the zigzag sets be @xmath240 , then there exists a @xmath44 mds array code for @xmath52 with @xmath24 as its zigzag sets over the field @xmath163 of size greater than @xmath241 .",
    "the proof is shown in appendix [ app1 ] .",
    "the above theorem states that there exist coefficients such that the code is mds , and thus we will focus first on finding proper zigzag permutations @xmath242 .",
    "the idea behind choosing the zigzag sets is as follows : assume a systematic column @xmath243 is erased .",
    "each element @xmath244 is contained in exactly one row set and one zigzag set . for rebuilding of element @xmath244 , access the parity of its row set or zigzag set .",
    "moreover access the values of the remaining elements in that set , except @xmath244 .",
    "we say that an element @xmath244 is rebuilt by a row ( zigzag ) if the parity of its row set ( zigzag set ) is accessed .",
    "for example , in figure [ fig : shapes ] supposing column @xmath0 is erased , one can access the shaded elements and rebuild its first two elements by rows , and the rest by zigzags .",
    "the set @xmath245 is called a rebuilding set for column @xmath243 if for each @xmath164 , @xmath246 . in order to minimize the number of accesses to rebuild the erased column",
    ", we need to minimize the size of @xmath247 .",
    "more specifically , the intersections between the row sets in @xmath248 and the zigzag sets in @xmath248 .    for a @xmath44 mds code @xmath249 with @xmath211 rows define the _ rebuilding ratio _ @xmath250 as the average fraction of accesses in the surviving systematic and parity nodes while rebuilding one systematic node , i.e. , @xmath251 notice that in the two parity nodes , we access @xmath211 elements because each erased element must be rebuilt either by row or by zigzag .",
    "and @xmath252 contains @xmath211 elements in the erased column .",
    "thus the above expression is exactly the rebuilding ratio .",
    "define the _ ratio function _ for all @xmath44 mds codes with @xmath211 rows as @xmath253 which is the minimal average portion of the array needed to be accessed in order to rebuild one erased column .",
    "[ monotone function ] @xmath254 is no less than @xmath1 and is a monotone nondecreasing function .    the proof is given in appendix [ app2 ] .",
    "for example , the code in figure [ fig2 ] achieves the lower bound of ratio @xmath22 , and therefore @xmath255 .",
    "moreover , we will see in corollary [ thm2 ] that @xmath254 is almost @xmath22 for all @xmath17 and @xmath256 , where @xmath56 is large enough .",
    "so far we have discussed the characteristics of an arbitrary mds array code with optimal update .",
    "next , let us look at our code in construction [ cnstr1 ] .",
    "recall that by theorem [ zigzag - sets ] this code can be an mds code over a field large enough .",
    "the ratio of the constructed code will be proportional to the size of the union of the elements in the rebuilding set in .",
    "the following theorem gives the ratio for construction [ cnstr1 ] and can be easily derived from lemma [ lemma 3 ] part ( i ) .",
    "[ th:123 ] the code described in construction [ cnstr1 ] and generated by the vectors @xmath257 is a @xmath44 mds array code with ratio @xmath258    next we show the optimal code in theorem [ orthogonal - permutations ] is optimal in size , namely , it has the maximum number of columns given the number of rows .",
    "[ thm : size ] let @xmath259 be an orthogonal set of permutations over the integers @xmath260 $ ] , then the size of @xmath259 is at most @xmath261    we will prove it by induction on @xmath56 .",
    "for @xmath262 there is nothing to prove .",
    "let @xmath263 be a set of orthogonal permutations over the set @xmath260.$ ] we only need to show that @xmath264 it is trivial to see that for any permutations @xmath265 on @xmath260 $ ] , the set @xmath266 is also a set of orthogonal permutations with sets @xmath267 thus w.l.o.g .",
    "we can assume that @xmath268 is the identity permutation and @xmath269 $ ] .",
    "from the orthogonality we get that @xmath270.\\ ] ] we claim that for any @xmath271 assume the contrary , thus w.l.o.g we can assume that @xmath272 , otherwise @xmath273 for any @xmath274 we get that @xmath275 @xmath276 ) and ( [ eq:445 ] ) we conclude that @xmath277 , which contradicts the orthogonality property .",
    "define the set of permutations @xmath278 over the set of integers @xmath279 $ ] by @xmath280 , which is a set of orthogonal permutations with sets @xmath281 . by induction @xmath282 and",
    "the result follows .",
    "the above theorem implies that the number of rows has to be exponential in the number of columns in any systematic code with optimal ratio and optimal update .",
    "notice that the code in theorem [ orthogonal - permutations ] achieves the _ maximum _ possible number of columns , @xmath283 .",
    "besides , an exponential number of rows is still practical in storage systems , since they are composed of dozens of nodes ( disks ) each of which has size in an order of gigabytes .",
    "in addition , increasing the number of columns can be done using duplication ( theorem [ lem13 ] ) or a larger set of vectors ( the following example ) with a cost of a small increase in the ratio .",
    "let @xmath284 be the set of vectors with weight 3 and length @xmath56 .",
    "notice that @xmath285 .",
    "construct the code @xmath249 by @xmath286 according to construction [ cnstr1 ] .",
    "given @xmath287 , @xmath288 , which is the number of vectors with 1 s in different positions as @xmath86 .",
    "similarly , @xmath289 and @xmath290 . by theorem [ th:123 ] and lemma [ lemma 3 ] , for large @xmath56 the ratio is @xmath291    note that this code reaches the lower bound of the ratio as @xmath56 tends to infinity , and has @xmath292 columns .",
    "in this section , we are going to duplicate the code to increase the number of columns in the constructed @xmath44 mds codes , such that @xmath17 does not depend on the number of rows , and ratio is approximately @xmath1",
    ". then we will show the optimality of the duplication code based on the standard basis .",
    "let @xmath161 be a @xmath44 array code with @xmath211 rows , where the zigzag sets @xmath293 are defined by the set of permutations @xmath294 on @xmath295 $ ] . for an integer @xmath296 , an @xmath296-_duplication code _",
    "@xmath297 is an @xmath298 mds code with zigzag permutations defined by duplicating the @xmath17 permutations @xmath296 times each , and the first parity column is the row sums . in order to make the code mds ,",
    "the coefficients in the parities may be different from the code @xmath249 .",
    "for an @xmath296-duplication code , denote the column corresponding to the @xmath299-th @xmath93 as column @xmath300 , @xmath301 .",
    "call the columns @xmath302\\}$ ] the @xmath299-th copy of the original code .",
    "an example of a @xmath3-duplication of the code in figure [ fig2 ] is illustrated in figure [ fig : duplication ] .",
    "[ lem13 ] if a @xmath44 code @xmath161 has ratio @xmath250 , then its @xmath296-duplication code @xmath297 has ratio @xmath303 .",
    "we propose a rebuilding algorithm for @xmath297 with ratio of @xmath303 , which will be shown to be optimal .",
    "suppose in the optimal rebuilding algorithm of @xmath161 , for column @xmath164 , elements of rows @xmath304 are rebuilt by zigzags , and the rest by rows . in @xmath297 ,",
    "all the @xmath296 columns corresponding to @xmath305 are rebuilt in the same way : the elements in rows @xmath306 are rebuilt by zigzags .",
    "assume column @xmath307 is erased .",
    "since column @xmath308 , @xmath309 $ ] corresponds to the same zigzag permutation as the erased column , for the erased element in the @xmath310-th row , no matter if it is rebuilt by row or by zigzag , we have to access the element in the @xmath310-th row and column @xmath308 ( e.g. permutations @xmath311 and the corresponding columns @xmath312 in figure [ fig : duplication ] ) .",
    "hence all the elements in column @xmath308 must be accessed . moreover , the optimal way to access the other surviving columns can not be better than the optimal way to rebuild in the code @xmath249 .",
    "thus the proposed algorithm has optimal rebuilding ratio .",
    "when column @xmath307 is erased , the average ( over all @xmath216 $ ] ) of the number of elements needed to be accessed in columns @xmath313 , for all @xmath314 , l \\neq i$ ] and @xmath315 $ ] is @xmath316 here the term @xmath317 corresponds to the access of the parity nodes in @xmath249 .",
    "moreover , we need to access all the elements in columns @xmath318 , and access @xmath211 elements in the two parity columns .",
    "therefore , the rebuilding ratio is @xmath319 and the proof is completed .",
    "theorem [ lem13 ] gives us the ratio of the @xmath296- duplication of a code @xmath249 as a function of its ratio @xmath320 . as a result , for the optimal - ratio code in theorem [ orthogonal - permutations ] , the ratio of its duplication code is slightly more than @xmath22 , as the following corollary suggests .",
    "[ thm2 ] the @xmath296-duplication of the code in theorem [ orthogonal - permutations ] has ratio @xmath321 , which is @xmath322 for large @xmath296 .    for example , we can rebuild the column @xmath323 in figure [ fig : duplication ] by accessing the elements in rows @xmath324 and in columns @xmath325 , and all the elements in column @xmath326 .",
    "the rebuilding ratio for this code is @xmath327 .    using duplication we can have _ arbitrarily large number of columns _ , independent of the number of rows .",
    "moreover the above corollary shows that it also has an almost optimal ratio .",
    "next we will show that if we restrict ourselves to codes constructed using construction [ cnstr1 ] and duplication , the code using the standard basis and duplication has optimal asymptotic rate .    in order to show that",
    ", we define a related graph . define the directed graph @xmath328 as @xmath329 , and @xmath330 .",
    "hence the vertices are the nonzero binary vectors of length @xmath56 , and there is a directed edge from @xmath331 to @xmath332 if @xmath333 is odd size . from any induced subgraph @xmath334 of @xmath335 , we construct the code @xmath336 from the vertices of @xmath334 using construction [ cnstr1 ] . by lemma",
    "[ lemma 3 ] we know that a directed edge from @xmath331 to @xmath332 in @xmath334 means @xmath337 , so only half of the information from the column corresponding to @xmath331 is accessed while rebuilding the column corresponding to @xmath332 . for a directed graph @xmath338 ,",
    "let @xmath339 and @xmath286 be two disjoint subsets of its vertices .",
    "we define the density of the set @xmath339 to be @xmath340 and the density between @xmath339 and @xmath286 to be @xmath341 , where @xmath342 is the number of edges with both of its endpoints in @xmath339 , and @xmath343 is the number of edges incident with a vertex in @xmath339 and a vertex in @xmath286 .",
    "the following theorem shows that the asymptotic ratio of any code constructed using construction [ cnstr1 ] and duplication is a function of the density of the corresponding graph @xmath334 .",
    "[ th:34 ] let @xmath334 be an induced subgraph of @xmath335 .",
    "let @xmath344 be the @xmath296-duplication of the code constructed using the vertices of @xmath334 and construction [ cnstr1 ] .",
    "then the asymptotic ratio of @xmath344 is @xmath345    let the set of vertices and edges of @xmath334 be @xmath346 and @xmath347 respectively .",
    "denote by @xmath348 , @xmath349 $ ] , the @xmath310-th copy of the column corresponding to the vector @xmath350 . in the rebuilding of column",
    "@xmath351 $ ] each remaining systematic column @xmath352 $ ] , needs to access all of its @xmath353 elements unless @xmath354 is odd , and in that case it only has to access @xmath148 elements .",
    "hence the total amount of accessed information for rebuilding this column is @xmath355 where @xmath356 is the indegree of @xmath350 in the induced subgraph @xmath334 .",
    "averaging over all the columns in @xmath344 we get the ratio : @xmath357 hence @xmath358    we conclude from theorem [ th:34 ] that the asymptotic ratio of any code using duplication and a set of binary vectors @xmath359 is a function of the density of the corresponding induced subgraph of @xmath335 with @xmath359 as its vertices .",
    "hence the induced subgraph of @xmath335 with maximal density corresponds to the code with optimal asymptotic ratio .",
    "it is easy to check that the induced subgraph with its vertices as the standard basis @xmath57 has density @xmath360 .",
    "in fact this is the maximal possible density among all the induced subgraph as theorem [ thm : opt rate ] suggests , but in order to show it we will need the following technical lemma .",
    "[ density lemma ] let @xmath338 be a directed graph and @xmath361 be a partition of @xmath362 , i.e. , @xmath363 , then @xmath364    note that @xmath365 w.l.o.g assume that @xmath366 therefore if @xmath367 , @xmath368 if @xmath369 then , @xmath370 and the result follows .",
    "now we are ready to prove the optimality of the duplication of the code using standard basis , if we assume that the number of copies @xmath296 tends to infinity .",
    "[ thm : opt rate ] for any induced subgraph @xmath334 of @xmath371 .",
    "so the optimal asymptotic ratio among all codes constructed using duplication and construction [ cnstr1 ] is @xmath372 and is achieved using the standard basis .",
    "we say that a binary vector is an even ( odd ) vector if it has an even ( odd ) weight .",
    "for two binary vectors @xmath373 , @xmath374 being odd is equivalent to @xmath375 hence , one can check that when @xmath373 have the same parity , there are either no edges or @xmath3 edges between them .",
    "moreover , when their parities are different , there is exactly one edge between the two vertices .    when @xmath376 the graph @xmath377 has only one vertex and the only nonempty induced subgraph is itself .",
    "@xmath378 . when @xmath379 , the graph @xmath380 has three vertices and one can check that the induced subgraph with maximum density contains @xmath381 , and the density is @xmath382 .    for @xmath383 ,",
    "assume to the contrary that there exists a subgraph of @xmath335 with density higher than @xmath360 .",
    "let @xmath334 be the smallest subgraph of @xmath335 ( with respect to the number of vertices ) among the subgraphs of @xmath335 with maximal density .",
    "hence for any subset of vertices @xmath384 , we have @xmath385 .",
    "therefore from lemma [ density lemma ] we conclude that for any partition @xmath386 of @xmath387 , @xmath388 if @xmath334 contains both even and odd vectors , denote by @xmath339 and @xmath286 the set of even and odd vectors of @xmath334 respectively . since between any even and any odd vertex there is exactly one directed edge we get that @xmath389 .",
    "however @xmath390 and we get a contradiction .",
    "thus @xmath334 contains only odd vectors or even vectors .",
    "let @xmath391 .",
    "if this set of vectors is independent then @xmath392 and the outgoing degree for each vertex @xmath350 is at most @xmath393 hence @xmath394 and we get a contradiction .",
    "hence assume that the dimension of the subspace spanned by these vectors in @xmath395 is @xmath396 where @xmath397 are basis for it .",
    "define @xmath398 .",
    "the following two cases show that the density can not be higher than @xmath360 .",
    "* @xmath334 contains only odd vectors : * let @xmath399 .",
    "since @xmath400 there is at least one @xmath401 such that @xmath402 and thus @xmath403 , therefore the number of directed edges between @xmath115 and @xmath339 is at most @xmath404 for all @xmath405 , which means @xmath406 and we get a contradiction .    * @xmath334 contains only even vectors : * since the @xmath350 s are even the dimension of @xmath407 is at most @xmath408 ( since for example @xmath409 ) thus @xmath410 let @xmath411 be the induced subgraph of @xmath412 with vertices @xmath413 .",
    "it is easy to see that all the vectors of @xmath411 are odd , @xmath414 , and the dimension of @xmath415 is at most @xmath416 having already proven the case for odd vectors , we conclude that @xmath417 and we get a contradiction .",
    "in this section , we address the problem of finding proper coefficients in the parities in order to make the code mds . we have already shown that if a code is over some large enough finite field @xmath163 , it can be made mds ( theorem [ zigzag - sets ] ) .",
    "and we have shown that the optimal code in theorem [ orthogonal - permutations ] needs only field of size @xmath9 . in the following",
    ", we will discuss in more details on the field size required to make two kinds of codes mds : ( 1 ) duplication of the optimal code in corollary [ thm2 ] , and ( 2 ) a modification of the code in example [ xmpl1 ] .",
    "note that both the codes have asymptotic optimal ratio .",
    "consider the duplication of the optimal code ( the code in corollary [ thm2 ] ) .",
    "for the @xmath296-duplication code @xmath297 in theorem [ thm2 ] , denote the coefficients for the element in row @xmath164 and column @xmath300 by @xmath418 and @xmath419 , @xmath301 .",
    "let @xmath420 be a field of size @xmath421 , and suppose its elements are @xmath422 for some primitive element @xmath423 .",
    "[ cons4 ] for the @xmath296-duplication code @xmath297 in theorem [ thm2 ] over @xmath420 , assign @xmath424 for all @xmath425 . for odd @xmath421 ,",
    "let @xmath426 and assign for all @xmath315 $ ] @xmath427 where @xmath428 .",
    "for even @xmath421 ( power of 2 ) , let @xmath429 and assign for all @xmath315 $ ] @xmath430    notice that the coefficients in each duplication has the same pattern as construction [ cons3 ] except that values 1 and 2 are replaced by @xmath431 and @xmath432 if @xmath421 is odd ( or @xmath432 and @xmath433 if @xmath421 is even ) .    [",
    "thm3 ] construction [ cons4 ] is an @xmath434 mds code .",
    "for the two elements in columns @xmath435 and row @xmath4 , @xmath436 , we can see that they are in the same row set and the same zigzag set .",
    "the corresponding two equations from the two parities are linearly independent iff @xmath437 which is satisfied by the construction .",
    "for the four elements in columns @xmath438 and rows @xmath439 , @xmath440 , @xmath441 , the code is mds if @xmath442 by . by the remark after theorem [ thm0506 ] , we know that @xmath443 , and @xmath444 for some @xmath80 . when @xmath421 is odd , @xmath445 for any @xmath80 and @xmath446 .",
    "when @xmath421 is even , @xmath447 for any @xmath446 and @xmath448 ( mod @xmath449 ) .",
    "and by construction , @xmath450 or @xmath451 for @xmath452 , so @xmath448 ( mod @xmath449 ) . hence , the construction is mds .",
    "* remark : * for two identical permutations @xmath453 , is necessary and sufficient condition for an mds code .    for an mds @xmath296-duplication code , we need a finite field @xmath420 of size @xmath454 . therefore , theorem [ thm3 ] is optimal for odd @xmath421 .",
    "consider the two information elements in row @xmath164 and columns @xmath455 , which are in the same row and zigzag sets , for @xmath456 $ ] .",
    "the code is mds only if @xmath457\\ ] ] has full rank .",
    "all the coefficients are nonzero ( consider erasing a parity column and a systematic column ) .",
    "thus , @xmath458 , and @xmath459 are distinct nonzero elements in @xmath420 , for @xmath315 $ ] .",
    "so @xmath454 .    for instance",
    ", the coefficients in figure [ fig : duplication ] are assigned as construction [ cons4 ] and @xmath173 is used .",
    "one can check that any two column erasures can be rebuilt in this code .",
    "consider for example an @xmath296-duplication of the code in theorem [ orthogonal - permutations ] with @xmath460 , the array is of size @xmath461 .",
    "for @xmath462 and @xmath463 , the ratio is @xmath464 and @xmath465 by corollary [ thm2 ] , the code length is @xmath466 and @xmath467 , and the field size needed can be @xmath468 and @xmath28 by theorem [ thm3 ] , respectively .",
    "both of these two sets of parameters are suitable for practical applications .    as noted before the optimal construction yields a ratio of @xmath469 by using duplication of the code in theorem [ orthogonal - permutations ] .",
    "however the field size is a linear function of the number of duplications of the code .",
    "is it possible to extend the number of columns in the code while using a constant field size ? we know how to get @xmath292 columns by using @xmath470 duplications of the optimal code , however , the field size is @xmath470 .",
    "the following code construction has roughly the same parameters : @xmath292 columns and an ratio of @xmath471 , however it requires only a constant field size of @xmath472 .",
    "actually this construction is a modification of example [ xmpl1 ] .",
    "let @xmath473 , and consider the following set of vectors @xmath474 : for each vector @xmath475 , @xmath476 and @xmath477 for some @xmath478,i_2 \\in [ m/3 + 1,2m/3 ] , i_3 \\in [ 2m/3 + 1,m]$ ] . for simplicity",
    ", we write @xmath479 . construct the @xmath44 code as in construction [ cnstr1 ] using the set of vectors @xmath339 , hence the number of systematic columns is @xmath480 . for any @xmath481",
    "$ ] and some @xmath482 , define a row vector @xmath483 . then define a @xmath484 matrix @xmath485\\ ] ] for @xmath479 .",
    "let @xmath423 be a primitive element of @xmath486 .",
    "assign the row coefficients as @xmath0 and the zigzag coefficient for row @xmath4 , column @xmath86 as @xmath431 , where @xmath487 ( in its binary expansion ) .",
    "for example , let @xmath488 , and @xmath489 .",
    "the corresponding matrix is @xmath490^t.\\ ] ] for row @xmath491 , we have @xmath492 and the zigzag coefficient is @xmath493 .",
    "[ thm : k/3 ] construction [ k/3 ] is a @xmath44 mds code with array size @xmath494 and @xmath495 .",
    "moreover , the rebuilding ratio is @xmath496 for large @xmath56 .    for each vector @xmath497 , there are @xmath498 vectors @xmath499 such that they have one @xmath0 in the same location as @xmath86 , i.e. @xmath500 . hence by theorem [ th:123 ] and lemma [ lemma 3 ] , for large @xmath56 the ratio is @xmath501    next",
    "we show that the mds property of the code holds .",
    "consider columns @xmath502 for some @xmath503 and @xmath504,i_2 , j_2 \\in [ m/3 + 1,2m/3 ] , i_3,j_3 \\in [ 2m/3 + 1,m]$ ] .",
    "consider rows @xmath4 and @xmath505 .",
    "the condition for the mds property from becomes @xmath506 where each vector of length @xmath9 is viewed as an integer in @xmath507 $ ] and the addition is usual addition mod 8 .",
    "since @xmath508 , let @xmath509 $ ] be the largest index such that @xmath510 .",
    "assume that @xmath511 , hence by the remark after theorem [ thm0506 ] @xmath512 and @xmath513 note that for all @xmath299 , @xmath514 , @xmath515 , then since @xmath516 , we have @xmath517 it is easy to infer from , , that the @xmath310-th bit in the binary expansions of @xmath518 and @xmath519 do nt equal .",
    "hence is satisfied , and the result follows .",
    "notice that if we do mod @xmath520 in instead of mod @xmath28 , the proof still follows because @xmath520 is greater than the largest possible sum in the equation .",
    "therefore , a field of size @xmath521 is also sufficient to construct an mds code , and it is easier to implement in a storage system .",
    "construction [ k/3 ] can be easily generalized to any constant @xmath522 such that it contains @xmath523 columns and it uses the field of size at least @xmath524 . for simplicity",
    "assume that @xmath525 , and simply construct the code using the set of vectors @xmath526 such that @xmath527 , and for any @xmath528 $ ] , there is unique @xmath529 $ ] and @xmath530 .",
    "moreover , the finite field of size @xmath531 is also sufficient to make it an mds code .",
    "when @xmath522 is odd the code has ratio of @xmath532 for large @xmath56 .",
    "in this section , we will discuss decoding algorithms of the proposed codes in case of column erasures as well as a column error . the algorithms work for both construction [ cnstr1 ] and its duplication code .",
    "let @xmath249 be a @xmath44 mds array code defined by construction [ cnstr1 ] ( and possibly duplication ) .",
    "the code has array size @xmath494 .",
    "let the zigzag permutations be @xmath93 , @xmath239 $ ] , which are not necessarily distinct .",
    "let the information elements be @xmath533 , and the row and zigzag parity elements be @xmath534 and @xmath535 , respectively , for @xmath536,j \\in [ 0,k-1]$ ] .",
    "assume the row coefficients are @xmath176 for all @xmath177 . and",
    "let the zigzag coefficients be @xmath537 in some finite field @xmath163 .",
    "the following is a summary of the erasure decoding algorithms mentioned in the previous sections .",
    "[ alg0506](erasure decoding ) + * one erasure . * + 1 ) one parity node is erased .",
    "rebuild the row parity by @xmath538 and the zigzag parity by @xmath539 2 ) one information node @xmath96 is erased .",
    "rebuild the elements in rows @xmath95 ( see construction [ cnstr1 ] ) by rows , and those in rows @xmath540 by zigzags .",
    "+ * two erasures . * + 1 ) two parity nodes are erased .",
    "rebuild by and .",
    "+ 2 ) one parity node and one information node is erased .",
    "if the row parity node is erased , rebuild by zigzags ; otherwise rebuild by rows .",
    "+ 3 ) two information nodes @xmath541 and @xmath542 are erased .",
    "+ - if @xmath543 , for any @xmath544 $ ] , compute @xmath545 solve @xmath546 from the equations @xmath547 \\left [ \\begin{array}{l } a_{i , j_1 } \\\\ a_{i , j_2 } \\end{array } \\right ] = \\left [ \\begin{array}{l } x_i \\\\ y_i \\end{array } \\right].\\ ] ] - else , for any @xmath544 $ ] , set @xmath548 , and compute @xmath549 according to . then solve @xmath550 from equations @xmath551 \\left [ \\begin{array}{c } a_{i , j_1 } \\\\",
    "a_{i , j_2 } \\\\",
    "a_{i',j_1 } \\\\",
    "a_{i',j_2 } \\\\",
    "\\end{array } \\right ] = \\left [ \\begin{array}{c } x_i \\\\ x_{i ' } \\\\ y_i \\\\",
    "y_{i ' } \\end{array } \\right].\\ ] ]    in case of a column error , we first compute the syndrome , then locate the error position , and at last correct the error .",
    "let @xmath552 .",
    "denote @xmath553 for a permutation @xmath554 on @xmath295 $ ] .",
    "the detailed algorithm is as follows .",
    "[ alg2 ] ( error decoding ) + compute for all @xmath544 $ ] : @xmath555 let the syndrome be @xmath556 and @xmath557 .",
    "+ - if @xmath558 and @xmath559 , there is no error .",
    "+ - else if one of @xmath560 is @xmath116 , there is an error in the parity .",
    "correct it by or .",
    "+ - else , find the error location .",
    "for @xmath561 to @xmath393 : + compute for all @xmath544 $ ] , @xmath562 + let @xmath563 and @xmath564 .",
    "+ if @xmath565 , subtract @xmath566 from column @xmath96 . stop .",
    "+ if no such @xmath96 is found , there are more than one error .",
    "if there is only one error , the above algorithm is guaranteed to find the error location and correct it , since the code is mds , as the following theorem states .",
    "algorithm [ alg2 ] can correct one column error .",
    "notice that each zigzag permutation @xmath93 is the inverse of itself by construction [ cnstr1 ] , or @xmath567 .",
    "suppose there is error in column @xmath96 , and the error is @xmath568 .",
    "so the received column @xmath96 is the sum of the original information and @xmath569 .",
    "thus the syndromes are @xmath570 and @xmath571 for column @xmath299 , @xmath572 $ ] , we have @xmath573 .",
    "write @xmath574 and then @xmath575 we will show the algorithm finds @xmath576 iff @xmath577 , and therefore subtracting @xmath578 from column @xmath96 will correct the error . when @xmath577 , @xmath579 for all @xmath544 $ ] , so @xmath565 .",
    "now suppose there is @xmath580 such that @xmath576 .",
    "since the error @xmath569 is nonzero , there exists @xmath164 such that @xmath581 .",
    "consider the indices @xmath164 and @xmath582 .",
    "@xmath583 yields @xmath584 * case 1 * : when @xmath585 , set @xmath586 , then becomes @xmath587 with @xmath588 .",
    "hence @xmath589 which contradicts .",
    "+ * case 2 * : when @xmath590 , since @xmath591 are commutative and are inverse of themselves , @xmath592 and @xmath593 . therefore @xmath594 yields @xmath595 the two equations have nonzero solution @xmath596 iff @xmath597 which contradicts with @xmath598 .",
    "hence the algorithm finds the unique erroneous column .",
    "if the computations are done in parallel for all @xmath544 $ ] , then algorithm [ alg2 ] can be done in time @xmath599 .",
    "moreover , since the permutations @xmath305 s only change one bit of a number in @xmath260 $ ] in the optimal code in theorem [ orthogonal - permutations ] , the algorithm can be easily implemented .",
    "in this section we generalize construction [ cnstr1 ] to arbitrary number of parity nodes .",
    "let @xmath600 be the number of parity nodes .",
    "we will construct an @xmath14 mds array code , i.e. , it can recover from up to @xmath4 node erasures for arbitrary integers @xmath601",
    ". we will show this code has optimal rebuilding ratio of @xmath36 when a systematic node is erased .",
    "we assume that each systematic nodes stores @xmath602 of the information and corresponds to columns @xmath603 $ ] .",
    "the @xmath164-th parity node is stored in column @xmath604 , @xmath605 , and is associated with zigzag sets @xmath606\\}$ ] , where @xmath211 is the number of rows in the array .",
    "[ cnstr5 ] let the information array be @xmath72 with size @xmath607 for some integers",
    "let @xmath608 be a subset of vectors of size @xmath17 , where for each @xmath609 @xmath610 where @xmath611 is the greatest common divisor .",
    "for any @xmath310 , @xmath612 , and @xmath77 we define the permutation @xmath613\\rightarrow [ 0,r^m-1]$ ] by @xmath614 , where by abuse of notation we use @xmath615 $ ] both to represent the integer and its @xmath4-ary representation , and all the calculations are done over @xmath616.for example , for @xmath617 , @xmath618 one can check that the permutation @xmath619 in a vector notation is @xmath620 $ ] . for simplicity",
    "denote the permutation @xmath621 as @xmath622 for @xmath623 . for @xmath624 $ ]",
    ", we define the zigzag set @xmath625 in parity node @xmath310 as the elements @xmath533 such that their coordinates satisfy @xmath626 in a rebuilding of systematic node @xmath164 the elements in rows @xmath627:x\\cdot v_i = r - l\\}$ ] are rebuilt by parity node @xmath310 , @xmath628 $ ] . from",
    "we get that for any @xmath164 and @xmath310 , @xmath629    note that similar to theorem [ zigzag - sets ] , using a large enough field , the parity nodes described above form an @xmath14 mds array code under appropriate selection of coefficients in the linear combinations of the zigzags .",
    "consider the rebuilding of systematic node @xmath630 $ ] . in a systematic column @xmath631",
    "we need to access all the elements that are contained in the sets that belong to the rebuilding set of column @xmath164 .",
    "namely , in column @xmath96 we need to access the elements in rows @xmath632 follows since the zigzags @xmath625 for any @xmath633 are used to rebuild the elements of column @xmath164 in rows @xmath634 .",
    "moreover the element in column @xmath96 and zigzag @xmath625 is @xmath635 .",
    "the following lemma will help us to calculate the size of , and in particular calculating the ratio of codes constructed by construction [ cnstr5 ] .",
    "[ lem : orth ] for any @xmath636 and @xmath637 $ ] such that @xmath638 , define @xmath639 .",
    "then @xmath640 in particular for @xmath641 we get @xmath642    consider the group @xmath643 . note that @xmath644 is a subgroup of @xmath645 and @xmath646 is its coset .",
    "therefore , @xmath647 , for some @xmath648 .",
    "hence @xmath649 and @xmath650 are cosets of @xmath651 .",
    "so they are either identical or disjoint .",
    "moreover they are identical if and only if @xmath652 i.e. , @xmath653 .",
    "but by definition of @xmath654 and @xmath655 , @xmath656 , @xmath657 , so @xmath658 and the result follows .",
    "the following theorem gives the ratio for any code of construction [ cnstr5 ] .",
    "[ thm : gen rate ] the ratio for the code constructed by construction [ cnstr5 ] and set of vectors @xmath286 is @xmath659 which also equal to @xmath660 here we define the function @xmath661 for @xmath662    by and noticing that we access @xmath663 elements in each parity node , the ratio is @xmath664 from lemma [ lem : orth ] , and noticing that @xmath665 , we get @xmath666 and the first part follows . for the second part ,",
    "@xmath667 the proof is completed .",
    "notice that @xmath668 represents elements not accessed for parity 0 ( row parity ) , and @xmath669 are elements accessed for parity @xmath670 .",
    "therefore @xmath671 are the elements accessed excluding those for the row parity . in order to get a low rebuilding ratio ,",
    "we need to minimize the second term in .",
    "we say that a family of permutation set @xmath672 together with sets @xmath673 is a family of _ orthogonal permutations _",
    "if for any @xmath145 $ ] the set @xmath674 is a equally sized partition of @xmath675 $ ] and @xmath676 one can check that for @xmath8 the definition coincides with the previous definition of orthogonal permutations for two parities . it can be shown that the above definition is equivalent to that for any @xmath677 , @xmath678 for a set of orthogonal permutations , rebuilding ratio is @xmath36 by , which is optimal according to ( [ eq : tradeoff ] ) ,    now we are ready to construct a code with optimal rebuilding ratio and @xmath4 parities .",
    "[ mashumashu ] the set @xmath679together with set @xmath680 constructed by the vectors @xmath103 and construction [ cnstr5 ] , where @xmath681 is modified to be @xmath682 for any @xmath637 $ ] is a family of _ orthogonal permutations_. moreover the corresponding @xmath683 code has _ optimal _ ratio of @xmath684    for @xmath685 , @xmath686 , hence by lemma [ lem : orth ] for any @xmath687 $ ] @xmath688 and is satisfied . for @xmath689 , and all @xmath690 , @xmath691 therefore , @xmath692 , and is satisfied .",
    "similarly , @xmath693 hence again is satisfied and this is a family of orthogonal permutations , and the result follows .        surprisingly , one can infer from the above theorem that changing the number of parities from @xmath3 to @xmath9 adds only one node to the system , but reduces the ratio from @xmath22 to @xmath37 in the rebuilding of any systematic column .",
    "the example in figure [ fig5 ] shows a code with @xmath9 systematic nodes and @xmath9 parity nodes constructed by theorem [ mashumashu ] with @xmath379 .",
    "the code has an optimal ratio of @xmath37 .",
    "for instance , if column @xmath111 is erased , accessing rows @xmath694 in the remaining nodes will be sufficient for rebuilding .",
    "similar to the @xmath3 parity case , the following theorem shows that theorem [ mashumashu ] achieves the optimal number of columns . in other words ,",
    "the number of rows has to be exponential in the number of columns in any systematic mds code with optimal ratio , optimal update , and @xmath4 parities .",
    "this follows since any such optimal code is constructed from a family of orthogonal permutations .",
    "[ thm0519 ] let @xmath695 be a family of orthogonal permutations over the integers @xmath675 $ ] together with the sets @xmath696 , then @xmath160 .",
    "we prove it by induction on @xmath56 .",
    "when @xmath262 , it is trivial that @xmath697 .",
    "now suppose we have a family of orthogonal permutations @xmath695 over @xmath675 $ ] , and we will show @xmath698 . recall that orthogonality is equivalent .",
    "notice that for any permutations @xmath699 are still a family of orthogonal permutations with sets @xmath700 .",
    "this is because @xmath701 therefore , w.l.o.g .",
    "we can assume @xmath702 $ ] , and @xmath703 is the identity permutation , for @xmath690 .    let @xmath704 $ ] and define @xmath705 therefore @xmath706 are subsets of @xmath52 , and their compliments in @xmath52 are @xmath707 from for any @xmath708 , @xmath709hence , @xmath710 similarly , for any @xmath708 , @xmath711 , hence @xmath712 from , we conclude that @xmath713 , i.e. , @xmath714 for each @xmath687,j\\in [ 1,k-1]$ ] define @xmath715 and @xmath716 then , @xmath717)&=f_j^l(x_0 ^ 0)-lr^{m-1}\\nonumber\\\\ & = x_0^l - lr^{m-1}\\label{wewe}\\\\ & = [ 0,r^{m-1}-1]\\nonumber,\\end{aligned}\\ ] ] where follows from .",
    "moreover , since @xmath718 is bijective we conclude that @xmath719 is a permutation on @xmath720.$ ] @xmath721 where follows from . since @xmath722 is a partition of @xmath675 $ ] , then @xmath723 is also a partition of @xmath724 $ ] .",
    "moreover , since @xmath725 for any @xmath637 $ ] , and @xmath726 are bijections , we conclude @xmath727 for all @xmath628 $ ] , i.e. , @xmath728 , @xmath628 $ ] , is a equally sized partition of @xmath720 $ ] .",
    "therefore @xmath729 together with @xmath730 is a family of orthogonal permutations over integers @xmath720 $ ] , hence by induction @xmath731 and the result follows .    after presenting the construction of a code with optimal ratio of @xmath36 , we move on to deal with the problem of assigning the proper coefficient in order to satisfy the mds property .",
    "this task turns out to be not easy when the number of parities @xmath732 the next theorem gives a proper assignment for the code with @xmath733 parities , constructed by the optimal construction given before .",
    "this assignment gives an upper bound on the required field size .",
    "a field of size at most @xmath734 is sufficient to make the code constructed by theorem [ mashumashu ] with @xmath733 parities , a @xmath735 mds code .",
    "let @xmath420 be a field of size @xmath736 .",
    "for any @xmath737 $ ] let @xmath738 be the representation of the permutation @xmath739 by a permutation matrix with a slight modification and is defined as follows , @xmath740 where @xmath741 is a primitive element of @xmath420 .",
    "let @xmath742 be the matrix that create the parities nodes , defined as @xmath743.\\ ] ] where @xmath744 for @xmath737\\text { and } j\\in[0,2]$ ] .",
    "it easy to see that indeed block row @xmath745 $ ] in the block matrix @xmath56 corresponds to parity @xmath164 .",
    "we will show that this coefficient assignment satisfy the mds property of the code .",
    "first we will show that under this assignment of coefficients the matrices @xmath746 , i.e. for any @xmath747,a_{l_1}a_{l_2}=a_{l_2}a_{l_1}$ ] . for simplicity ,",
    "write @xmath748 . for a vector @xmath749 and @xmath750",
    ", its @xmath96-th entry satisfies @xmath751 for all @xmath752 $ ] . and by similar calculation",
    ", @xmath753 will satisfy @xmath754 similarly , if @xmath755 , then @xmath756 notice that @xmath757 so @xmath758 .",
    "similarly , @xmath759 .",
    "moreover , @xmath760 hence , @xmath761 for all @xmath96 and @xmath762 for all @xmath763 .",
    "thus @xmath764 .",
    "next we show for any @xmath164 , @xmath765 . for any vector @xmath80 ,",
    "let @xmath766 then @xmath767 however , @xmath768 ( since the addition is done over @xmath769 ) , and exactly one of @xmath770 equals to @xmath116 .",
    "thus @xmath771 or @xmath772 for any @xmath80 .",
    "hence @xmath773 .",
    "the code is mds if it can recover from loss of any @xmath9 nodes . with this assignment of coefficients",
    "the code is mds iff any block sub matrices of sizes @xmath774 of the matrix @xmath775 are invertible .",
    "the case of @xmath776 sub matrix is trivial .",
    "let @xmath777 we will see that the @xmath778 matrix @xmath779\\ ] ] is invertible . by theorem @xmath0 in @xcite and",
    "the fact that all the blocks in the matrix commute we get that the determinant of this matrix equals to @xmath780 .",
    "hence we need to show that for any @xmath781 , @xmath782 , which is equivalent to @xmath783 note that for any @xmath164 , @xmath784 .",
    "denote by @xmath785 , hence @xmath786 .",
    "therefore @xmath787 therefore @xmath788 .    for a submatrix of size @xmath789",
    ", we need to check that for @xmath781 @xmath790)=\\det(a_j^{2})\\det(a_i^2a_j^{-2}-i)\\neq 0.\\ ] ] note that @xmath791 since @xmath792 hence @xmath793 and @xmath794 which concludes the proof .",
    "for example , the coefficients of the parities in figure [ fig5 ] are assigned as the above proof . since @xmath379 , the field of size",
    "@xmath795 is sufficient .",
    "the primitive element is chosen to be @xmath9 .",
    "one can check that when losing any three columns we can still rebuild them .",
    "in this section , we discuss the rebuilding of @xmath6 erasures , @xmath7 . we will first prove the lower bound for rebuilding ratio and repair bandwidth .",
    "then we show a construction achieving the lower bound for systematic nodes .",
    "at last we generalize this construction and construction [ cnstr5 ] , and propose a rebuilding algorithm using an arbitrary subgroup and its cosets .    in this section , in order to simplify some of the results we will assume that @xmath4 is a prime and the calculations are done over @xmath796 .",
    "note that all the result can be generalized with minor changes for an arbitrary integer @xmath4 and the ring @xmath616 .",
    "the next theorem shows that the rebuilding ratio for construction [ cnstr5 ] is at least @xmath40 .",
    "[ thm0419 ] let @xmath52 be an array with @xmath4 parity nodes constructed by construction [ cnstr5 ] .",
    "in an erasure of @xmath797 systematic nodes , the rebuilding ratio is at least @xmath5 .    in order to recover the information in the systematic nodes we need to use at least @xmath798",
    "zigzag sets from the @xmath799 sets ( there are @xmath4 parity nodes , @xmath800 zigzag sets in each parity ) . by the pigeonhole principle there is at least one parity node , such that at least @xmath801 of its zigzag sets are used .",
    "hence each remaining systematic node has to access its elements that are contained in these zigzag sets .",
    "therefore each systematic node accesses at least @xmath801 of its information out of @xmath800 , which is a portion of @xmath802    since we use at least @xmath798 zigzag sets , we use at least @xmath798 elements in the @xmath4 parity nodes , which is again a portion of @xmath5 .",
    "hence the overall rebuilding ratio is at least @xmath5 .    in a general code",
    "( not necessary mds , systematic , or optimal update ) , what is the amount of information needed to transmit in order to rebuild @xmath6 nodes ?",
    "assume that in the system multiple nodes are erased , and we rebuild these nodes _ simultaneously _ from information in the remaining nodes .",
    "it should be noted that this model is a bit different from the distributed repair problem , where the recovery of each node is done separately .",
    "we follow the definitions and notations of @xcite .",
    "an _ exact - repair reconstructing code _ satisfies the following two properties : ( i)reconstruction : any @xmath17 nodes can rebuild the total information .",
    "( ii)exact repair : if @xmath6 nodes are erased , they can be recovered exactly by transmitting information from the remaining nodes .",
    "suppose the total amount of information is @xmath19 , and the @xmath16 nodes are @xmath803 $ ] .",
    "for @xmath6 erasures , @xmath797 , denote by @xmath804 the amount of information stored in each node , the number of nodes connected to the erased nodes , and the amount of information transmitted by each of the nodes , respectively . for subsets @xmath805 $ ] , @xmath806 is the amount of information stored in nodes @xmath52 , and @xmath807 is the amount of information transmitted from nodes @xmath52 to nodes @xmath808 in the rebuilding .",
    "the following results give lower bound of repair bandwidth for @xmath6 erasures , and the proofs are based on @xcite .",
    "let @xmath809 $ ] be a subset of nodes of size @xmath810 , then for an arbitrary set of nodes @xmath52 , @xmath811 such that @xmath812 , @xmath813    if nodes @xmath808 are erased , consider the case of connecting to them nodes @xmath52 and nodes @xmath814 , @xmath815 then the exact repair condition requires @xmath816 moreover , it is clear that @xmath817 and the result follows .",
    "[ th0503 ] any reconstructing code with file size @xmath19 must satisfy for any @xmath797 @xmath818 where @xmath819 .",
    "moreover for an mds code , @xmath820    the file can be reconstructed from any set of @xmath17 nodes , hence @xmath821})\\\\ & = h(w_{[s]})+\\sum_{i=0}^{\\lfloor\\frac{k}{e}\\rfloor-1}h({{\\cal w}}_{[ie+s+1,(i+1)e+s]}|{{\\cal w}}_{[ie+s]})\\\\ & \\leq s \\alpha+ \\sum_{i=0}^{\\lfloor \\frac{k}{e}\\rfloor-1 } \\min\\{e \\alpha,(d_e - ie - s)\\beta_e\\}.\\end{aligned}\\ ] ] in an mds code @xmath822 , hence in order to satisfy the inequality any summand of the form @xmath823 must be at least @xmath824 , which occurs if and only if @xmath825 . hence we get @xmath826 and the proof is completed .    therefore , the lower bound of the repair bandwidth for an mds code is @xmath827 , which is the same as the lower bound of the rebuilding ratio in theorem [ thm0419 ] .",
    "next we discuss how to rebuild in case of @xmath6 erasures , @xmath7 , for an mds array code with optimal update .",
    "theorem [ th0503 ] gives the lower bound @xmath40 on the rebuilding ratio for @xmath6 erasures .",
    "is this achievable ?",
    "let us first look at an example .",
    "[ xmpl0503 ] consider the code in figure [ fig5 ] with @xmath733 .",
    "when @xmath828 and columns @xmath829 are erased , we can access rows @xmath830 in column @xmath831 , rows @xmath832 in column @xmath833 , and rows @xmath834 in column @xmath835 .",
    "one can check that the accessed elements are sufficient to rebuild the two erased columns , and the ratio is @xmath836 .",
    "it can be shown that similar rebuilding can be done for any two systematic node erasures .",
    "therefore , in this example the lower bound is achievable .",
    "consider an information array of size @xmath199 and an @xmath14 mds code with @xmath18 parity nodes .",
    "each parity node @xmath637 $ ] is constructed from the set of permutations @xmath837 for @xmath216 $ ] .",
    "notice that in the general case the number of rows @xmath211 in the array is not necessarily a power of @xmath4 .",
    "we will assume columns @xmath838 $ ] are erased .",
    "in an erasure of @xmath6 columns , @xmath839 elements need rebuilt , hence we need @xmath839 equations ( zigzags ) that contain these elements . in an optimal rebuilding",
    ", each parity node contributes @xmath840 equations by accessing the values of @xmath840 of its zigzag elements .",
    "moreover , the union of the zigzag sets that create these zigzag elements , constitute an @xmath40 portion of the elements in the surviving systematic nodes . in other words",
    ", assume that we access rows @xmath214 from the surviving columns @xmath841 $ ] , @xmath842 $ ] , then @xmath843 and @xmath844 for any parity node @xmath628 $ ] and @xmath845 $ ] .",
    "note that it is equivalent that for any parity node @xmath628 $ ] and surviving systematic node @xmath846 $ ] @xmath847 let @xmath848 be the subgroup of the symmetric group @xmath849 that is generated by the set of permutations @xmath850 .",
    "it is easy to see that the previous condition is also equivalent to that for any parity @xmath637 $ ] the group @xmath848 _ stabilizes _",
    "@xmath214 , i.e. , for any @xmath851    assuming there is a set @xmath214 that satisfies this condition , we want to rebuild the @xmath839 elements from the chosen @xmath839 equations , i.e. , the @xmath839 equations with the @xmath839 variables being solvable .",
    "a necessary condition is that each element in the erased column will appear at least once in the chosen zigzag sets ( equations ) .",
    "parity @xmath637 $ ] accesses its zigzag elements @xmath852 , and these zigzag sets contain the elements in rows @xmath853 of the erased column @xmath854 $ ] .",
    "hence the condition is equivalent to that for any erased column @xmath854 $ ] @xmath855.\\ ] ] these two conditions are necessary for optimal rebuilding ratio . in addition , we need to make sure that the @xmath839 equations are linearly independent , which depends on the coefficients in the linear combinations that created the zigzag elements .",
    "we summarize : + * sufficient and necessary conditions for optimal rebuilding ratio in @xmath6 erasures : * there exists a set @xmath842 $ ] of size @xmath843 , such that    1 .   for any parity node @xmath856 $ ]",
    "the group @xmath848 stabilizes the set @xmath214 , i.e. , for any @xmath857 @xmath858 where @xmath848 is generated by the set of permutations + @xmath859 2 .   for any erased column",
    "@xmath854 $ ] , @xmath855 .",
    "\\label{eq03172}\\ ] ] 3 .",
    "the @xmath839 equations ( zigzag sets ) defined by the set @xmath214 are linearly independent .",
    "the previous discussion gave the condition for optimal rebuilding ratio in an mds optimal update code with @xmath6 erasures in general .",
    "next will interpret these conditions in the special case where the number of rows @xmath860 , and the permutations are generated by @xmath861 @xmath862 @xmath863 and construction [ cnstr5 ] , i.e. , @xmath864 for any @xmath865 $ ] .",
    "note that in the case of @xmath4 a prime @xmath866 and in that case we simply denote the group as @xmath867 .",
    "the following theorem gives a simple characterization for sets that satisfy condition @xmath0 .",
    "let @xmath868 and @xmath867 defined above then @xmath867 stabilizes @xmath214 , if and only if @xmath214 is a union of cosets of the subspace @xmath869    it is easy to check that any coset of @xmath24 is stabilized by @xmath867 , hence if @xmath214 is a union of cosets it is also a stabilized set . for the other direction let @xmath870 be two vectors in the same coset of @xmath24 ,",
    "it is enough to show that if @xmath871 then also @xmath872 .",
    "since @xmath873 there exist @xmath874 $ ] such that @xmath875 since @xmath876 for any @xmath877 we get that @xmath878 for any @xmath871 and @xmath877 , hence @xmath879 for @xmath880 .",
    "so @xmath881 and the result follows .",
    "* remark : * for any set of vectors @xmath339 and @xmath882 , @xmath883 here @xmath884 hence , the subspace @xmath24 defined in the previous theorem does not depend on the choice of the vector @xmath885 . by the previous theorem we interpret the * necessary and sufficient conditions of an optimal code * as follows",
    ": + there exists a set @xmath886 of size @xmath887 , such that    1 .",
    "@xmath214 is a union of cosets of @xmath888 2 .   for any erased column",
    "@xmath854 $ ] , @xmath889 3 .",
    "the @xmath798 equations ( zigzag sets ) defined by the set @xmath214 are linearly independent .",
    "the following theorem gives a simple equivalent condition for conditions @xmath890 .",
    "[ thm03311 ] there exists a set @xmath886 of size @xmath887 such that conditions @xmath890 are satisfied if and only if @xmath891 for any erased column @xmath854.$ ]    assume conditions @xmath890 are satisfied . if @xmath892 for some erased column @xmath854 $ ] then @xmath893 which is a contradiction to @xmath894 on the other hand , if is true , then @xmath895 can be viewed as a permutation that acts on the cosets of @xmath24 .",
    "the number of cosets of @xmath24 is @xmath896 and this permutation ( when it is written in cycle notation ) contains @xmath897 cycles , each with length @xmath4 . for each @xmath854",
    "$ ] choose @xmath897 cosets of @xmath24 , one from each cycle of the permutation @xmath898 in total @xmath899 cosets are chosen for the @xmath6 erased nodes .",
    "let @xmath214 be the union of the cosets that were chosen .",
    "it is easy to see that @xmath214 satisfies condition @xmath3 . if @xmath900 ( since there might be cosets that were chosen more than once ) add arbitrary @xmath901 other cosets of @xmath24 , and also condition @xmath0 is satisfied .",
    "in general , if is not satisfied , the code does not have an optimal rebuilding ratio .",
    "however we can define @xmath902 where we assume w.l.o.g . @xmath903 and @xmath904 $ ] is a maximal subset of surviving nodes that satisfies for any erased node @xmath905 , v_j - v_e\\notin z.$ ] hence from now on we assume that @xmath24 is defined by a subset of surviving nodes @xmath906 .",
    "this set of surviving nodes will have an optimal rebuilding ratio ( see corollary [ cor0401 ] ) , i.e. , in the rebuilding of columns @xmath838 $ ] , columns @xmath906 will access a portion of @xmath40 of their elements .",
    "the following theorem gives a sufficient condition for the @xmath798 equations defined by the set @xmath214 to be solvable linear equations .",
    "[ thm0413 ] suppose that there exists a subspace @xmath104 that contains @xmath24 such that for any erased node @xmath854 $ ] @xmath907 then the set @xmath214 defined as an union of some @xmath6 cosets of @xmath104 satisfies conditions @xmath890 and @xmath9 over a field large enough .",
    "condition @xmath0 is trivial .",
    "note that by , @xmath908 for any @xmath909 $ ] and @xmath854 $ ] , hence @xmath910}$ ] is the set of cosets of @xmath104 .",
    "let @xmath911 be a coset of @xmath104 for some @xmath912 $ ] and suppose @xmath913 .",
    "now let us check condition 2 : @xmath914 holds since @xmath915 is computed mod @xmath4 .",
    "so condition @xmath3 is satisfied .",
    "next we prove condition @xmath9 .",
    "there are @xmath798 unknowns and @xmath798 equations .",
    "writing the equations in a matrix form we get @xmath916 , where @xmath52 is an @xmath917 matrix .",
    "@xmath918 are vectors of length @xmath798 , and @xmath919 is the unknown vector . the matrix @xmath72 is defined as @xmath920 if the unknown @xmath921 appears in the @xmath164-th equation , otherwise @xmath922 .",
    "hence we can solve the equations if and only if there is assignment for the indetermediates @xmath923 in the matrix @xmath52 such that @xmath924 . by , accessing rows corresponding to any coset @xmath95 will give us equations where each unknown appears exactly once . since @xmath214 is a union of @xmath6 cosets , each unknown appears @xmath6 times in the equations .",
    "thus each column in @xmath52 contains @xmath6 indeterminates .",
    "moreover , each equation contains one unknown from each erased node , thus any row in @xmath52 contains @xmath6 indeterminates . then by hall",
    "s marriage theorem @xcite we conclude that there exists a permutation @xmath554 on the integers @xmath925 $ ] such that @xmath926 hence the polynomial @xmath927 when viewed as a symbolic polynomial , is not the zero polynomial , i.e. , @xmath928 by theorem [ polynomial - method ] we conclude that there is an assignment from a field large enough for the indeterminates such that @xmath924 , and the equations are solvable .",
    "note that this proof is for a specific set of erased nodes .",
    "however if is satisfied for any set of @xmath6 erasures , multiplication of all the nonzero polynomials @xmath927 derived for any set of erased nodes is again a nonzero polynomial and by the same argument there is an assignment over a field large enough such that any of the matrices @xmath52 is invertible , and the result follows .    in order to use theorem [ thm0413 ] , we need to find a subspace @xmath104 as in .",
    "the following theorem shows that such a subspace always exists , moreover it gives an explicit construction of it .",
    "[ thm0414 ] suppose @xmath929 erasures occur .",
    "let @xmath24 be defined by and @xmath930 for any erased node @xmath912 $ ] .",
    "then there exists @xmath931 such that for any @xmath912 $ ] , @xmath932 moreover the orthogonal subspace @xmath933 satisfies .",
    "first we will show that such vector @xmath115 exists .",
    "let @xmath934 be a basis for @xmath935 the orthogonal subspace of @xmath936 any vector @xmath115 in @xmath935 can be written as @xmath937 for some @xmath938 s .",
    "we claim that for any @xmath912 $ ] there exists @xmath96 such that @xmath939 . because otherwise , @xmath940 , which means @xmath941 and reaches a contradiction .",
    "thus the number of solutions for the linear equation @xmath942 is @xmath943 , which equals the number of @xmath115 such that @xmath944 .",
    "hence by the union bound there are at most @xmath945 vectors @xmath115 in @xmath935 such that @xmath944 for some erased node @xmath854 $ ] . since @xmath946 there exists @xmath115 in @xmath935 such that for any erased node @xmath854 $ ] , @xmath947 define @xmath933 , and note that for any erased node @xmath854,v_i - v_e\\notin x_0 $ ] , since @xmath948 and @xmath104 is the orthogonal subspace of @xmath115 .",
    "moreover , since @xmath104 is a hyperplane we conclude that @xmath949 and the result follows .",
    "theorems [ thm0413 ] and [ thm0414 ] give us * an algorithm to rebuild multiple erasures : *    1 .",
    "find @xmath24 by satisfying .",
    "find @xmath950 satisfying .",
    "define @xmath951 and @xmath214 as a union of @xmath6 cosets of @xmath104 .",
    "access rows @xmath952 in parity @xmath628 $ ] and all the corresponding information elements .",
    "we know that under a proper selection of coefficients the rebuilding is possible .    in the following we give two examples of rebuilding using this algorithm .",
    "the first example shows an optimal rebuilding for any set of @xmath6 node erasures .",
    "as mentioned above , the optimal rebuilding is achieved since is satisfied , i.e. , @xmath953 $ ] .",
    "[ xmpl0331 ] let @xmath954 be a set of vectors that contains an orthonormal basis of @xmath863 together with the zero vector .",
    "suppose columns @xmath838 $ ] are erased .",
    "note that in that case @xmath955 $ ] and @xmath24 is defined as in .",
    "define @xmath956 and @xmath933 .",
    "when @xmath957 and @xmath958 , modify @xmath115 to be @xmath959 it is easy to check that @xmath931 and for any erased column @xmath854,u\\cdot ( v_i - v_e)=-1 $ ] . therefore by theorems [ thm0413 ] and [ thm0414 ] a set @xmath214 defined as a union of an arbitrary @xmath6 cosets of @xmath104 satisfies conditions @xmath890 and @xmath9 , and optimal rebuilding is achieved .    in the example of figure [ fig5 ] , we know that the vectors generating the permutations are the standard basis ( and thus are orthonormal basis ) and the zero vector . when columns @xmath829 are erased , @xmath960 and @xmath961 .",
    "take @xmath214 as the union of @xmath104 and its coset @xmath962 , which is the same as example [ xmpl0503 ] .",
    "one can check that each erased element appears exactly 3 times in the equations and the equations are solvable in @xmath963 .",
    "similarly , the equations are solvable for other @xmath3 systematic erasures .    before we proceed to the next example",
    ", we give an upper bound for the rebuilding ratio using theorem [ thm0413 ] and a set of nodes @xmath964    [ cor0401 ] theorem [ thm0413 ] requires rebuilding ratio at most @xmath965    by theorem [ thm0413 ] , the fraction of accessed elements in columns @xmath906 and the parity columns is @xmath40 of each column .",
    "moreover , the accessed elements in the rest columns are at most an entire column",
    ". therefore , the ratio is at most @xmath966 and the result follows .",
    "note that as expected when @xmath967 the rebuilding ratio is optimal , i.e. @xmath40 . in the following example the code has @xmath470 columns .",
    "the set @xmath906 does not contain all the surviving systematic nodes , hence the rebuilding is not optimal but is at most @xmath471 .",
    "[ xmpl0401 ] suppose @xmath968 .",
    "let @xmath969 , j \\in [ m/2 + 1,m]\\}\\subset \\mathbb{f}_2^m$ ] be the set of vectors generating the code with @xmath8 parities , hence the number of systematic nodes is @xmath970 .",
    "suppose column @xmath971 , @xmath972 is erased .",
    "define the set @xmath973 and @xmath974 for some @xmath975 .",
    "thus @xmath976 .",
    "it can be seen that @xmath24 defined by the set @xmath906 satisfies , i.e. , @xmath977 since the first coordinate of a vector in @xmath24 is always @xmath116 , as oppose to @xmath0 for the vector @xmath978 .",
    "define @xmath979 and @xmath980 it is easy to check that @xmath931 and @xmath981 hence , the conditions in theorem [ thm0414 ] are satisfied and rebuilding can be done using @xmath104 .",
    "moreover by corollary [ cor0401 ] the rebuilding ratio is at most @xmath982 which is a little better than theorem [ thm : k/3 ] in the constants .",
    "note that by similar coefficients assignment of construction [ k/3 ] , we can use a field of size @xmath983 or @xmath28 to assure the code will be an mds code .",
    "next we want to point out a surprising phenomena .",
    "we say that a set of vectors @xmath339 satisfies _ property _",
    "@xmath6 for @xmath984 if for any subset @xmath985 of size @xmath6 and any @xmath986 , @xmath987 where @xmath988 . recall that by theorem [ thm03311 ] any set of vectors that generates a code @xmath249 and can rebuild optimally any @xmath6 erasures , satisfies property @xmath6 .",
    "the following theorem shows that this property is monotonic , i.e. , if @xmath339 satisfies property @xmath6 then it also satisfies property @xmath423 for any @xmath989    let @xmath339 be a set of vectors that satisfies property @xmath6 , then it also satisfies property @xmath423 , for any @xmath990 .",
    "let @xmath991 and assume to the contrary that @xmath992 for some @xmath986 and @xmath988 .",
    "@xmath993 hence there exists @xmath994 .",
    "it is easy to verify that @xmath995 , where @xmath996 and @xmath997 which contradicts the property @xmath6 for the set @xmath339 .",
    "hence , from the previous theorem we conclude that a code @xmath249 that can rebuild optimally @xmath6 erasures , is able to rebuild optimally any number of erasures greater than @xmath6 as well",
    ". however , as pointed out already there are codes with @xmath4 parities that can not rebuild optimally from some @xmath998 erasures .",
    "therefore , one might expect to find a code @xmath249 with parameter @xmath999 such that it can rebuild optimally @xmath6 erasures _ only _ when @xmath1000 .",
    "for example , for @xmath1001 let @xmath249 be the code constructed by the vectors @xmath1002 . we know that any code with more than @xmath9 systematic nodes can not rebuild one erasure optimally , since the size of a family of orthogonal permutations over the integers @xmath1003 $ ] is at most @xmath9 .",
    "however , one can check that for any two erased columns , the conditions in theorem [ thm0413 ] are satisfied hence the code can rebuild optimally for any @xmath828 erasures and we conclude that @xmath1004 for this code .    the phenomena that some codes has a threshold parameter @xmath1005 , such that _ only _ when the number of erasures @xmath6 is at least as the threshold @xmath1005 then the code can rebuild optimally , is a bit counter intuitive and surprising .",
    "this phenomena gives rise to another question .",
    "we know that for a code constructed with vectors from @xmath863 , the maximum number of systematic columns for optimal rebuilding of @xmath1006 erasures is @xmath283 ( theorem [ thm0519 ] ) .",
    "can the number of systematic columns in a code with an optimal rebuilding of @xmath1007 erasures be increased ?",
    "the previous example shows a code with @xmath468 systematic columns can rebuild optimally any @xmath828 erasures .",
    "but theorem [ thm0519 ] shows that when @xmath1001 , optimal rebuilding for @xmath0 erasure implies no more than @xmath9 systematic columns . hence the number of systematic columns",
    "is increased by at least @xmath0 compared to codes with @xmath472 rows and optimal rebuilding of @xmath0 erasure .",
    "the following theorem gives an upper bound for the maximum systematic columns in a code that rebuilds optimally any @xmath6 erasures .",
    "let @xmath249 be a code constructed by construction [ cnstr5 ] and vectors from @xmath863 .",
    "if @xmath249 can rebuild optimally any @xmath6 erasures , for some @xmath1008 , then the number of systematic columns @xmath17 in the code satisfies @xmath1009    consider a code with length @xmath17 and generated by vectors @xmath1010 if these vectors are linearly independent then @xmath392 and we are done .",
    "otherwise they are dependent .",
    "suppose @xmath6 columns are erased , @xmath929 .",
    "let @xmath1011 be a surviving column .",
    "consider a new set a of vectors : @xmath1012,i\\neq e\\}.$ ] we know that the code can rebuild optimally only if is satisfied for all possible @xmath6 erasures .",
    "thus for any @xmath1013 , @xmath216,$ ] if column @xmath164 is erased and column @xmath6 is not , we have @xmath930 and thus @xmath1014 .",
    "so every vector in @xmath286 is nonzero .",
    "let @xmath296 be the minimum number of dependent vectors in @xmath286 , that is , the minimum number of vectors in @xmath286 such that they are dependent . for nonzero vectors",
    ", we have @xmath1015 .",
    "say @xmath1016 is a minimum dependent set of vector .",
    "since any @xmath283 vectors are dependent in @xmath863 , @xmath1017 we are going to show @xmath1018 .",
    "suppose to the contrary that the number of remaining columns satisfies @xmath1019 and @xmath6 erasures occur .",
    "when column @xmath1020 is erased and the @xmath296 columns @xmath1021 are not , we should be able to rebuild optimally .",
    "however since we chose a dependent set of vectors , @xmath1022 is a linear combination of @xmath1023 , whose span is contained in @xmath24 in .",
    "hence is violated and we reach a contradiction .",
    "therefore , @xmath1024    notice that this upper bound is tight .",
    "for @xmath1006 we already gave codes with optimal rebuilding of @xmath0 erasure and @xmath1025 systematic columns .",
    "moreover , for @xmath828 the code already presented in this section and constructed by the vectors @xmath1026 , reaches the upper bound with @xmath1027 systematic columns .",
    "the rebuilding algorithms presented in constructions [ cnstr1],[cnstr5 ] and theorem [ thm0413 ] all use a specific subspace and its cosets in the rebuilding process .",
    "this method of rebuilding can be generalized by using an arbitrary subspace as explained below .",
    "let @xmath1028 be a set of vectors generating the code in construction [ cnstr5 ] with @xmath800 rows and @xmath4 parities .",
    "suppose @xmath6 columns @xmath838 $ ] are erased .",
    "let @xmath24 be a proper subspace of @xmath863 .",
    "in order to rebuild the erased nodes , in each parity column @xmath628 $ ] , access the zigzag elements @xmath1029 for @xmath1030 , and @xmath1031 is a union of cosets of @xmath24 . in each surviving node , access all the elements that are in the zigzag sets @xmath1031 of parity @xmath310 .",
    "more specifically , access element @xmath533 in the surviving column @xmath1032 $ ] if @xmath1033 . hence , in the surviving column",
    "@xmath96 and parity @xmath310 , we access elements in rows @xmath1034 . in order to make the rebuilding successful we impose the following conditions on the sets @xmath1035 . since the number of equations needed is at least as the number of erased elements , we require @xmath1036 moreover , we want the equations to be solvable , hence for any erased column @xmath854 $ ] , @xmath1037 \\text { multiplicity } e,\\ ] ] which means if the union is viewed as a multi - set , then each element in @xmath675 $ ] appears exactly @xmath6 times .",
    "this condition makes sure that the equations are solvable by hall s theorem ( see theorem [ thm0413 ] ) . under these conditions",
    "we would like to minimize the ratio , i.e. , the number of accesses which is , @xmath1038 in summary , for the * generalized rebuilding algorithm * one first chooses a subspace @xmath24 , and then solves the minimization problem in subject to and .",
    "the following example interprets the minimization problem for a specific case .",
    "let @xmath1039 , i.e. , two parities and one erasure , then equations , becomes @xmath1040.\\ ] ] therefore @xmath1041 the objective function in becomes , @xmath1042 each @xmath1043 defines a permutation @xmath1044 on the cosets of @xmath24 by @xmath1045 for a coset @xmath52 of @xmath24 . if @xmath1046 then @xmath1044 is the identity permutation and @xmath1047 , regardless of the choice of @xmath104 .",
    "however , if @xmath1048 , then @xmath1044 is of order @xmath3 , i.e. , it s composed of disjoint cycles of length @xmath3 . note that if @xmath1044 maps @xmath52 to @xmath808 and only one of the cosets @xmath1049 is contained in @xmath104 , say @xmath52 , then only @xmath52 is contained in @xmath1050 . on the other hand , if both @xmath1051 then , @xmath1052 in other words , @xmath1053 is a cycle in @xmath1044 which is totally contained in @xmath1054 .",
    "define @xmath1055 as the number of cycles @xmath1053 in the permutation @xmath1044 that are totally contained in @xmath214 or in @xmath1056 , where @xmath214 is a union of some cosets of @xmath24 .",
    "it is easy to see that the minimization problem is equivalent to minimizing @xmath1057 in other words , we want to find a set @xmath214 which is a union of cosets of @xmath24 , such that the number of totally contained or totally not contained cycles in the permutations defined by @xmath1058 , @xmath1059 $ ] is minimized .    from the above example",
    ", we can see that given a non - optimal code with two parities and one erasure , finding the solution in requires minimizing for the sum of these @xmath393 permutations , which is an interesting combinatorial problem . moreover , by choosing a different subspace @xmath24 we might be able to get a better rebuilding algorithm than that in construction [ cnstr1 ] or theorem [ thm0413 ] .",
    "in this paper , we described explicit constructions of the first known systematic @xmath14 mds array codes with @xmath1060 equal to some constant , such that the amount of information needed to rebuild an erased column equals to @xmath1061 , matching the information - theoretic lower bound . while the codes are new and interesting from a theoretical perspective , they also provide an exciting practical solution , specifically , when @xmath1062 , our zigzag codes are the best known alternative to raid-6 schemes .",
    "raid-6 is the most prominent scheme in storage systems for combating disk failures@xcite-@xcite .",
    "our new zigzag codes provide a raid-6 scheme that has optimal update ( important for write efficiency ) , small finite field size ( important for computational efficiency ) and optimal access of information for rebuilding - cutting the current rebuilding time by a factor of two .",
    "we note that one can add redundancy for the sake of lowering the rebuilding ratio .",
    "for instance , one can use three parity nodes instead of two .",
    "the idea is that the third parity is not used for protecting data from erasures , since in practice , three concurrent failures are unlikely .",
    "however , with three parity nodes , we are able to rebuild a single failed node by accessing only @xmath37 of the remaining information ( instead of @xmath22 ) .",
    "an open problem is to construct codes that can be extended in a simple way , namely , codes with three parity nodes such that the first two nodes ensure a rebuilding ratio of @xmath22 and the third node further lowers the ratio to @xmath37 .",
    "hence , we can first construct an array with two parity nodes and when needed , extend the array by adding an additional parity node to obtain additional improvement in the rebuilding ratio .",
    "another future research direction is to consider the ratio of read accesses in the case of a write ( update ) operation .",
    "for example , in an array code with two parity nodes , in order to update a single information element , one needs to read at least three elements and write three elements , because we need to know the values of the old information and old parities and compute the new parity elements ( by subtracting the old information from the parity and adding the new information ) .",
    "however , an interesting observation , in our optimal code construction with two parity nodes , is if we update all the information in the first column and the rows in the first half of the array ( see figure [ fig2 ] ) , we do not need to read for computing the new parities , because we know the values of all the information elements needed for computing the parities .",
    "these information elements take about half the size of the entire array .",
    "so in a storage system we can cache the information to be written until most of these elements needs update ( we could arrange the information in a way that these elements are often updated at the same time ) , hence , the ratio between the number of read operations and the number of new information elements is relatively very small .",
    "clearly , we can use a similar approach for any other systematic column . in general , given @xmath4 parity nodes , we can avoid redundant read operations if we update about @xmath36 of the array .",
    "in order to prove theorem [ zigzag - sets ] , we use the well known combinatorial nullstellensatz by alon @xcite :    ( combinatorial nullstellensatz ) ( * ? ? ? * th 1.2 ) [ polynomial - method ] let @xmath163 be an arbitrary field , and let @xmath1063 be a polynomial in @xmath1064 $ ] .",
    "suppose the degree of @xmath554 is @xmath1065 , where each @xmath1066 is a nonnegative integer , and suppose the coefficient of @xmath1067 in @xmath554 is nonzero .",
    "then , if @xmath1068 are subsets of @xmath163 with @xmath1069 , there are @xmath1070 so that @xmath1071    assume the information of @xmath52 is given in a column vector @xmath742 of length @xmath1072 , where column @xmath1073 $ ] of @xmath52 is in the row set @xmath1074 $ ] of @xmath742",
    ". each systematic node @xmath164 , @xmath216 $ ] , can be represented as @xmath1075 where @xmath1076 $ ] .",
    "moreover define @xmath1077,q_{k+1}=[x_0p_0,x_1p_1, ...",
    ",x_{k-1}p_{k-1}]$ ] where the @xmath1078 s are permutation matrices ( not necessarily distinct ) of size @xmath1079 , and the @xmath1080 s are variables , such that @xmath1081 . the permutation matrix @xmath1082 is defined as @xmath1083 if and only if @xmath1084 . in order to show that there exists such mds code , it is sufficient to show that there is an assignment for the intermediates @xmath1085 in the field @xmath163 , such that for any set of integers @xmath1086 $ ] the matrix @xmath1087 $ ] is of full rank .",
    "it is easy to see that if the parity column @xmath217 is erased i.e. , @xmath1088 then @xmath1089 is of full rank . if @xmath1090 then @xmath1089 is of full rank if none of the @xmath1080 s equals to zero .",
    "the last case is when both @xmath1091 , i.e. , there are @xmath1092 such that @xmath1093 it is easy to see that in that case @xmath1089 is of full rank if and only if the submatrix @xmath1094 is of full rank .",
    "this is equivalent to @xmath1095 .",
    "note that @xmath1096 and the coefficient of @xmath1097 is @xmath1098 .",
    "define the polynomial @xmath1099 and the result follows if there are elements @xmath1100 such that @xmath1101 @xmath286 is of degree @xmath1102 and the coefficient of @xmath1103 is @xmath1104 .",
    "set for any @xmath1105 in theorem [ polynomial - method ] , and the result follows .        for the rebuilding of node @xmath164 by row and zigzag sets @xmath1106 , define the number of intersections by @xmath1107 moreover define the number of total intersections in an mds array code @xmath161 as @xmath1108 now define @xmath1109 to be the maximal possible intersections over all @xmath44 mds array codes , i.e.",
    ", @xmath1110 for example , in figure [ fig : shapes ] the rebuilding set for column @xmath0 is @xmath1111 , the size in equation ( [ eq:77 ] ) is @xmath28 , and @xmath1112 .",
    "let @xmath52 be an information array of size @xmath1115 .",
    "construct a mds array code @xmath249 by the row sets and the zigzag sets that reaches the maximum possible number of intersections , and suppose @xmath1116 achieves the maximal number of intersections for rebuilding column @xmath164 , @xmath216 $ ] .",
    "namely the zigzag sets @xmath24 of the code @xmath249 and the rebuilding sets @xmath1116 satisfy that , @xmath1117 for a subset of columns @xmath1118 $ ] and a rebuilding set @xmath1119 we denote the restriction of @xmath1116 to @xmath286 by @xmath1120 , where @xmath1121 .",
    "denote by @xmath1122 the number of intersections in column @xmath96 while rebuilding column @xmath164 by @xmath1116 .",
    "it is easy to see that @xmath1123 and thus @xmath1124 note also that if @xmath1125 and @xmath1126 , then @xmath1127 hence @xmath1128:\\\\i , j\\in t,|t|=q}}i(j,\\mathbf{s}^i)\\nonumber\\\\ & = \\sum_{\\substack{i , j:\\\\j\\neq i}}\\quad\\sum_{\\substack{t\\subseteq [ 0,k-1]:\\\\i , j\\in t,|t|=q}}i(j,\\mathbf{s}^i_t)\\nonumber\\\\ & = \\sum_{\\substack{t\\subseteq [ 0,k-1]:\\\\|t|=q}}\\quad\\sum_{\\substack{i , j\\in t:\\\\i\\neq j}}i(j,\\mathbf{s}^i_t)\\nonumber\\\\ & \\leq\\sum_{\\substack{t\\subseteq [ 0,k-1]:\\\\|t|=q}}h(q ) \\label{eq0429}\\\\ & = \\binom{k}{q}h(q).\\nonumber \\label{eq:34}\\end{aligned}\\ ] ] inequality holds because the code restricted in columns @xmath286 is a @xmath1129 mds and optimal - update code , and @xmath1130 is the maximal intersections among such codes . hence , @xmath1131 and the result follows .    for a @xmath44 mds code @xmath249 with @xmath211 rows the _ rebuilding ratio _",
    "@xmath250 can be written as @xmath1132 notice that in the two parity nodes , we access @xmath211 elements because each erased element must be rebuilt either by row or by zigzag .",
    "thus we have the term @xmath211 in the above equation .",
    "and the _ ratio function _ for all @xmath44 mds codes with @xmath211 rows is @xmath1133    consider a @xmath44 code with @xmath211 rows and assume a systematic node is erased . in order to rebuild it ,",
    "@xmath211 row and zigzag sets are accessed .",
    "let @xmath1134 be the number of elements that are accessed from the first and the second parity respectively .",
    "w.l.o.g we can assume that @xmath1135 , otherwise @xmath1136 would satisfy it .",
    "each element of these @xmath80 sets is a sum of a set of size @xmath17 .",
    "thus in order to rebuild the node , we need to access at least @xmath1137 elements in the @xmath393 surviving systematic nodes , which is at least half of the size of these nodes .",
    "so the number of intersections is no more than @xmath1138 .",
    "thus @xmath1139 and the ratio function satisfies @xmath1140 so the rebuilding ratio is no less than @xmath22 .",
    "10 [ 1]#1 url@samestyle [ 2]#2 [ 2]l@#1=l@#1#2 m.  blaum , j.  brady , j.  bruck , and j.  menon , `` evenodd : an efficient scheme for tolerating double disk failures in raid architectures , '' _ ieee trans . on computers _ ,",
    "44 , no .  2 ,",
    "192202 , feb . 1995 .",
    "p.  corbett , b.  english , a.  goel , t.  grcanac , s.  kleiman , j.  leong , and s.  sankar , `` row - diagonal parity for double disk failure correction , '' in _ proc . of the 3rd usenix symposium on file and storage technologies ( fast 04 ) _ , 2004 .",
    "k. v.  rashmi , n. b.  shah , p. v.  kumar , and k.  ramchandran , `` explicit construction of optimal exact regenerating codes for distributed storage , '' in _ allertonallerton conference on control , computing , and communication , urbana - champaign , il _ , 2009 .",
    "c.  suh and k.  ramchandran , `` exact - repair mds codes for distributed storage using interference alignment , '' in _ isit _ , 2010 .",
    "n.  b. shah , k. v.  rashmi , p.  v. kumar , and k.  ramchandran , `` explicit codes minimizing repair bandwidth for distributed storage , '' in _ ieee information theory workshop ( itw ) _ , jan .",
    "2010 .    c.  suh and k.  ramchandran ,",
    "`` on the existence of optimal exact - repair mds codes for distributed storage , '' tech . rep .",
    "arxiv:1004.4663 , 2010 .",
    "v.  r. cadambe , s.  a. jafar , and h.  maleki , `` minimum repair bandwidth for exact regeneration in distributed storage , '' in _ wireless network coding conference ( winc ) , 2010 ieee _ , june 2010 .",
    "n. b.  shah , k. v.  rashmi , p. v.  kumar , k.  ramchandran , `` distributed storage codes with repair - by - transfer and non - achievability of interior points on the storage - bandwidth tradeoff , '' tech .",
    "arxiv:1011.2361v2 , 2010 ."
  ],
  "abstract_text": [
    "<S> mds array codes are widely used in storage systems to protect data against erasures . </S>",
    "<S> we address the _ rebuilding ratio _ problem , namely , in the case of erasures , what is the fraction of the remaining information that needs to be accessed in order to rebuild _ exactly _ the lost information ? </S>",
    "<S> it is clear that when the number of erasures equals the maximum number of erasures that an mds code can correct then the rebuilding ratio is @xmath0 ( access all the remaining information ) . </S>",
    "<S> however , the interesting and more practical case is when the number of erasures is smaller than the erasure correcting capability of the code . </S>",
    "<S> for example , consider an mds code that can correct two erasures : what is the smallest amount of information that one needs to access in order to correct a single erasure ? </S>",
    "<S> previous work showed that the rebuilding ratio is bounded between @xmath1 and @xmath2 , however , the exact value was left as an open problem . in this paper , we solve this open problem and prove that for the case of a single erasure with a @xmath3-erasure correcting code , the rebuilding ratio is @xmath1 . in general , we construct a new family of @xmath4-erasure correcting mds array codes that has optimal rebuilding ratio of @xmath5 in the case of @xmath6 erasures , @xmath7 . </S>",
    "<S> our array codes have efficient encoding and decoding algorithms ( for the case @xmath8 they use a finite field of size @xmath9 ) and an optimal update property . </S>"
  ]
}