{
  "article_text": [
    "in this paper we are interested in evaluating the performance of two recently suggested algorithms for drawing so - called _ tanglegrams _",
    "@xcite , that is , pairs of trees whose leaf sets are in one - to - one correspondence .",
    "the need to visually compare pairs of trees arises in applications such as the analysis of software projects , phylogenetics , or clustering . in the first application",
    ", trees may represent package - class - method hierarchies or the decomposition of a project into layers , units , and modules .",
    "the aim is to analyze changes in hierarchy over time or to compare human - made decompositions with automatically generated ones .",
    "whereas trees in software analysis can have nodes of arbitrary degree , trees from our second application , that is , ( rooted ) phylogenetic trees , are binary trees .",
    "this makes binary tanglegrams an interesting special case , see  [ fig : example ] .",
    "hierarchical clusterings , our third application , are usually visualized by a binary tree - like structure called _ dendrogram _ , where elements are represented by the leaves and each internal node of the tree represents the cluster containing the leaves in its subtree .",
    "pairs of dendrograms stemming from different clustering processes of the same data can be compared visually using tanglegrams .        from the application point of view",
    "it makes sense to insist that ( a )  the trees under consideration are drawn plane , that is , without edge crossings , ( b )  each leaf of one tree is connected by an _",
    "inter - tree _ edge to the corresponding leaf in the other tree , and ( c )  the number of crossings among the inter - tree edges is minimized . following the bioinformatics literature ( e.g. , @xcite )",
    ", we call this the _ tanglegram layout _ problem ; fernau et al .",
    "@xcite refer to it as _ two - tree crossing minimization_.    _ problem : ( tanglegram layout ( tl ) ) .",
    "_ given a tanglegram @xmath0 consisting of two rooted trees @xmath1 and @xmath2 on @xmath3 leaves and a bijection between their leaf sets , find a tanglegram layout , that is , two plane drawings of @xmath1 and @xmath2 , such that    1 .",
    "the drawing of @xmath1 is to the left of the line @xmath4 with all leaves on @xmath4 ; 2 .",
    "the drawing of @xmath2 is to the right of the line @xmath5 with all leaves on @xmath5 ; 3 .",
    "the inter - tree edges are drawn as straight - line segments ; 4 .",
    "the number of inter - tree edge crossings is minimum .    given a tree  @xmath2 , we say that a linear order of its leaves is _ compatible _ with  @xmath2 if for each node  @xmath6 of  @xmath2 the nodes in the subtree of  @xmath6 form an interval in the order . note that tl is a purely combinatorial problem .",
    "in short , given two trees  @xmath1 and  @xmath2 , tl consists of finding an order  @xmath7 of the leaves of  @xmath1 compatible with  @xmath1 and an order  @xmath8 of the leaves of  @xmath2 compatible with  @xmath2 such that the number of inversions between  @xmath8 and  @xmath7 is minimum @xcite .",
    "let the _ crossing number _ of a tanglegram @xmath0 be the minimum number of inter - tree edge crossings of any tanglegram layout of @xmath0 .    in the following",
    "we restrict our attention to _ binary _ tanglegrams such as , for example , pairs of phylogenetic trees or clustering dendrograms .",
    "the restriction of tl to binary trees is denoted as _ binary _ tl . after presenting related work ( section  [ sec : related ] )",
    ", we introduce the algorithms that we want to compare experimentally ( section  [ sec : algorithms ] ) .",
    "we first sketch a recursive algorithm of buchin et al .",
    "then , in an algorithm engineering process we adapt their algorithm to the needs of unbalanced trees in order to achieve better results .",
    "we apply branch - and - bound to speed up the improved variant .",
    "next , we introduce hierarchy sort , a crossing - reduction heuristic used in the visualization tool of holten and van wijk  @xcite , and a quadratic integer program that solves binary tl optimally . finally , we provide a detailed description of the results of our experimental comparison of these algorithms , see section  [ sec : experimental - results ] .",
    "in graph drawing the so - called _ two - sided crossing minimization problem _ ( 2scm ) is an important np - hard problem that occurs when computing layered graph layouts .",
    "such layouts have been introduced by sugiyama et al .",
    "@xcite and are widely used for drawing hierarchical graphs . in 2scm ,",
    "vertices of a bipartite graph are to be placed on two parallel lines ( called _ layers _ ) such that for each vertex on one line all its adjacent vertices lie on the other line . as in tl the objective",
    "is to minimize the number of edge crossings provided that edges are drawn as straight - line segments . in one - sided crossing minimization ( 1scm )",
    "the order of the vertices on one of the layers is fixed .",
    "even 1scm is np - hard  @xcite .",
    "jnger and mutzel  @xcite performed an experimental comparison of exact and heuristic algorithms for both 1scm and 2scm .",
    "the main findings were that for 1scm the exact solution can be computed quickly for up to 60 vertices in the free layer , and for 2scm an iterated barycenter heuristic is the method of choice for instances with more than 15 vertices in each layer .",
    "the main difference between tl and 2scm is that in tl , the possible orders of the leaves are limited to those that are compatible with the two input trees .",
    "furthermore the inter - tree edges are usually restricted to be a matching of the leaves .",
    "dwyer and schreiber  @xcite studied drawing a series of tanglegrams in 2.5 dimensions , that is , the trees are drawn on a set of stacked two - dimensional planes .",
    "they considered a one - sided version of binary tl by fixing the layout of the first tree in the stack , and then , layer - by - layer , computing an optimal compatible leaf order of the next tree in @xmath9 time each .",
    "fernau et al .",
    "@xcite showed that binary tl is np - hard and gave a fixed - parameter algorithm that runs in @xmath10 time , where the @xmath11-notation ignores polynomial factors , @xmath12 is a constant that fernau et al .",
    "estimate to be @xmath13 , and @xmath14 is the minimum number of crossings in any drawing of the given tanglegram .",
    "they further showed that the problem can be solved in @xmath15 time if the leaf order of one tree is fixed .",
    "this improves the result of dwyer and schreiber  @xcite .",
    "they also made the simple observation that the edges of the tanglegram can be directed from one root to the other .",
    "thus the existence of a planar drawing can be verified using a linear - time upward - planarity test for single - source directed acyclic graphs  @xcite .",
    "later , apparently not knowing these previous results , lozano et al .",
    "@xcite gave a quadratic - time algorithm for the same special case , to which they refer as _ planar tanglegram layout_. recently , buchin et al .",
    "@xcite showed that binary tl remains np - hard even if both trees are complete binary trees .",
    "for this case they gave an @xmath16-time factor-2 approximation algorithm and a simple @xmath17-time fixed - parameter algorithm , where @xmath14 is the minimum number of crossings as before .",
    "their approximation algorithm is based on recursive splitting of the instance and can also be used as a heuristic for general binary trees .",
    "holten and van wijk  @xcite present a tanglegram visualization tool for the comparison of two ( not necessarily binary ) trees that uses local optimization to reduce inter - tree crossings an edge - bundling technique to reduce visual clutter .",
    "in this section we describe the recursive splitting algorithm of buchin et al .",
    "@xcite and our improved variant of it , then the algorithm hierarchy sort of holten and van wijk  @xcite , and finally a simple integer quadratic program ( iqp ) that provides us with exact solutions for the experimental comparison that follows in section  [ sec : experimental - results ] .",
    "the main idea behind the recursive splitting algorithm is to recursively consider for an instance @xmath0 the four possible orders of the two subtrees @xmath18 of @xmath1 and @xmath19 of @xmath2 below the roots @xmath20 and @xmath21 of @xmath1 and @xmath2 as in  [ fig : subinstance ] .",
    "each order gives rise to a certain number of crossings at that level of the recursion ( called _ current - level _ crossings ) , which is added to the number of crossings of both recursively solved subproblems induced by that order ( called _ lower - level _ crossings ) .",
    "each current - level    r5 cm     crossing has the property that it can be removed by swapping the subtrees of @xmath20 or @xmath21 .",
    "for example the crossing depicted in  [ fig : subinstance ] can be removed by swapping the subtrees of @xmath20 and placing @xmath22 above @xmath23 .",
    "of course such a swap generally introduces other current - level crossings .",
    "the minimum of the four possibilities will be returned to the previous level of the recursion .",
    "the two subproblems that arise from each recursive split are not independent . nevertheless , they are treated independently by the algorithm .",
    "this obviously introduces an error with respect to the actual number of crossings , which , for the case of _ complete _ binary trees , can be bounded by the number of crossings in an optimal solution  @xcite . for complete binary trees the recursive algorithm",
    "thus yields a 2-approximation .",
    "obviously , the depth of the recursion equals the minimum height  @xmath24 of the two trees .",
    "the recursion tree is of size @xmath25 since each instance starts eight recursive calls ( two for each of the four subtree arrangements ) .",
    "the computation of all current - level crossings is done in @xmath26 time , resulting in a total running time of @xmath27 . for complete trees with @xmath28",
    "this resolves to @xmath16 time . in applications most binary tl instances do not consist of _ complete _ binary trees .",
    "the above recursive algorithm can be applied to any pair of binary trees as a heuristic but an approximation guarantee can not be given any more .",
    "under the unique games conjecture a constant - factor approximation does not even exist for general binary trees  @xcite .",
    "the original algorithm always divides an instance into an upper and a lower subinstance , that is , the two problems @xmath29 and @xmath30 in the example of  [ fig : subinstance ] . for unbalanced trees",
    "this can lead to an unnecessarily high number of ignored crossings as  [ fig : alg - bad ] shows .",
    "the original algorithm aligns the leaves ( nodes  7 and  8) attached directly to the roots since this causes no current - level crossings .",
    "all 14 crossings in  [ fig : alg - bad-14 ] are crossings that the algorithm does not take into account .",
    "a small modification of our algorithm weakens this effect ( and yields the optimum solution in the given example ) . instead of always dividing into an upper and a lower subinstance",
    ", we can also consider dividing into the two _ diagonal _ subinstances @xmath31 and @xmath32 in the example of  [ fig : subinstance ] .",
    "the improved algorithm always selects among the two possible splits the one that has the higher total number of edges between its two subinstances .",
    "this modification not only improves the algorithm performance , but it also allows us to precompute in @xmath33 time all required numbers of current - level crossings for a constant - time lookup .",
    "thus the total running time reduces to @xmath34 , which still equals @xmath16 for complete trees .",
    "interestingly , it can be proved ( omitted here ) that the approximation factor of  2 still holds for this modified algorithm in the case of complete trees .        in our most refined implementation of the improved algorithm we additionally make use of a branch - and - bound technique in order to prune large parts of the search tree as early as possible .",
    "this considerably sped up the naive implementation , see section  [ sec : runn - time - perf ] .",
    "let s consider an instance of the problem with roots  @xmath35 and  @xmath36 . instead of computing the number of crossings for all four possible arrangements of the respective subtrees of  @xmath35 and  @xmath36",
    "we first consider the one that yields the lowest number of current - level crossings and recurse .",
    "this gives us an initial upper bound on the number of crossings once the leaf level is reached .",
    "now at each level we can immediately prune the respective parts of the search tree for those arrangements that exceed this upper bound .",
    "the rest of the search tree is examined further , and each time a better solution is found the upper bound is updated accordingly .",
    "the algorithm hierarchy sort of holten and van wijk  @xcite performs a number of collapse - and - expand cycles on both trees of the binary tanglegram . during each step of these cycles ,",
    "the well - known barycentric method of sugiyama et al .",
    "@xcite for 1scm is used by successively fixing one tree , optimizing the leaf order of the other , and then changing the trees roles until no further crossing reduction is possible .",
    "we illustrate the algorithm using the example in fig .",
    "[ fig : hierarchysorting ] .        figure  [ fig : hierarchysorting]a shows a binary tanglegram with 13 inter - tree edge crossings",
    ". figures  [ fig : hierarchysorting]b to  [ fig : hierarchysorting]p illustrate the hierarchy sorting algorithm using one full collapse - and - expand cycle .",
    "since crossings are to be reduced on _ corresponding _ levels in the two trees , the numbers of levels of the two trees need to equalized .",
    "this is done by introducing dummy nodes that bring all leaves to the lowest level . in our example , this results in a tanglegram consisting of two four - level binary trees , see  [ fig : hierarchysorting]b .    crossing reduction ( cr )",
    "is now performed per level by employing the barycentric method on corresponding levels . due to the hierarchical structure of the data that we consider",
    ", only nodes having the same parent may be swapped .",
    "nodes that are swapped during cr are encircled in  [ fig : hierarchysorting ] .    after having completed cr at the lowest level , we move up one level in both trees .",
    "we do this by _ collapsing _ both levels , that is , by contracting all edges ending in leaves ( see the step from  [ fig : hierarchysorting]c to  [ fig : hierarchysorting]d , for example ) .",
    "cr can now proceed . collapsing and cr",
    "are repeated until the levels below the roots are reached (  [ fig : hierarchysorting]i ) . at this point ,",
    "the process is reversed and levels are expanded again ( with in - between cr ) until the leaf levels are reached .",
    "this is illustrated in figs .",
    "[ fig : hierarchysorting]j to  [ fig : hierarchysorting]o .",
    "such collapse - and - expand cycles are repeated until the number of crossings does not decrease any further .",
    "a last step remains : the original number of levels in both hierarchies needs to be restored , that is , all dummy nodes are contracted ( see  [ fig : hierarchysorting]p ) . in our example the hierarchy sorting algorithm has reduced the number of crossings from  13 to  2 .",
    "the asymptotic running time of this algorithm depends of course on the number  @xmath37 of collapse - and - expand cycles and the maximum number  @xmath38 of executions of the linear - time barycentric heuristic on each level . in our experiments ( see section  [ sec : experimental - results ] ) it turned out that in all instances we had @xmath39 and @xmath40 . under the condition that both @xmath37 and @xmath38 are constants",
    ", hierarchy sort runs in @xmath41 time , where @xmath42 is the maximum height of the two trees . in the case of complete trees",
    "@xmath43 , and the running time is @xmath44 .      for the iqp",
    "we introduce a binary variable  @xmath45 for each inner node of @xmath46 .",
    "if  @xmath47 , the two subtrees of  @xmath48 change their order with respect to the input drawing , otherwise the order of the input drawing is kept .",
    "let  @xmath49 and  @xmath50 be two inter - tree edges with  @xmath51 and @xmath52 .",
    "let @xmath53 and @xmath54 be the lowest common ancestors of the leaves  @xmath55 and  @xmath12 , and of  @xmath56 and  @xmath57 , respectively .",
    "assume that  @xmath49 and  @xmath50 cross each other in the original drawing .",
    "then  @xmath49 and  @xmath50 cross each other in the solution encoded by the iqp if and only if @xmath58 or @xmath59 .",
    "otherwise , if  @xmath49 and  @xmath50 do not cross each other originally , they will cross in the solution encoded by the iqp if and only if @xmath60 or @xmath61 .",
    "thus the total number of edge crossings can be expressed as the sum of these products for all pairs of edges .",
    "the iqp minimizes this sum as its objective function .",
    "no further constraints , apart from the variables being binary , are necessary .",
    "the recursive splitting algorithms were written in java  1.5 and executed in suse linux  9.3 running on an amd opteron  248 2.2 ghz system with 4 gb ram .",
    "the hierarchy sorting algorithm was implemented in delphi  7.0 and executed in windows xp on an intel pentium  4 2.8 ghz system with 1 gb ram .",
    "the quadratic program was solved with the mathematical programming software cplex  9.1 running on the above linux system .",
    "we generated four sets ( a  d ) of random tanglegrams .",
    "set  a contains ten pairs of complete binary trees with random leaf orders for each @xmath62 . in set  b we simulated tree mutations by starting with two identical complete binary trees and then randomly swapping the positions of up to 20% of the leaves of one tree .",
    "this is done as follows : we first pick a leaf uniformly at random and then iteratively climb up the tree with probability 0.75 in each step . from the node",
    "thus reached we climb back down and flip a coin at each node to choose its left or right child until we reach another leaf .",
    "this leaf and the leaf picked in the beginning are swapped .",
    "thus the probability of two leaves being swapped decreases with their distance in the tree . set  c contains ten pairs of general binary trees for each @xmath63 .",
    "the trees are constructed from a set of nodes , initially containing the @xmath3 leaves , by iteratively joining two random nodes in a new parent node that replaces its children in the set .",
    "this process generates trees that resemble phylogenetic trees or clustering dendrograms .",
    "set  d is similar to set  c but again in each tanglegram the second tree is a mutation of the first tree , where up to 10% of the leaves can swap positions as done in set  b and up to 25% of the subtrees can reattach to another edge .",
    "this edge is selected in a random walk starting at the subtree s old position .",
    "the walk continues with probability 0.75 and chooses the left or right edge by tossing a coin .",
    "trees in this set are of interest since real - world tanglegrams often consist of two related and rather similar trees .",
    "the average crossing numbers of the trees in sets  a  d are given in  [ fig : crnumbers - random ] in the appendix .",
    "our real - world examples comprise three sets ( e  g ) of tanglegrams .",
    "set  e contains six pairs of dendrograms of a hierarchically clustered social network based on email communication of 21 subjects  @xcite .",
    "sets  f and  g contain six and ten pairs of phylogenetic trees for 15 species of pocket gophers and 17 species of lice , respectively  @xcite .",
    "(  [ fig : example ] shows a tanglegram in set  g. ) while the email tanglegrams have between 23 and 45 crossings in an optimal solution , the phylogenetic trees can be drawn with at most two crossings , most of them even without any crossings .      in the following",
    "we denote the original recursive algorithm of buchin et al .",
    "@xcite by _ rec - split _  and our modification for unbalanced trees by _",
    "rec - split - improved_. the algorithm of holten and van wijk is _",
    "hierarchy sort_. let @xmath3 be the size of an instance , that is , the number of leaves per tree .",
    "to each tanglegram we applied the three algorithms and the iqp , and recorded the crossing numbers @xmath64 in their respective solutions for @xmath65 _ rec - split _ , _ rec - split - improved _ , _",
    "hierarchy sort_. we then computed for each tanglegram the performance ratios @xmath66 , where @xmath67 denotes the optimal number of crossings obtained from solving the iqp .",
    "note that we add one to both crossing numbers in order to have a well - defined ratio also for crossing - free instances .",
    "+     +   +     the results for sets  a  d are shown in  [ fig : ratio ] . for complete binary trees ( sets  a and  b ) _ rec - split _  and _ rec - split - improved_achieved similar performance ratios that tend to  1 as the size of the trees grows .",
    "recall that on these complete instances both algorithms are 2-approximations . on average",
    "both methods performed slightly better on mutated trees ( b ) than on random trees ( a ) .",
    "in several cases the instances in set  b could be solved optimally .",
    "the average performance ratio of _ hierarchy sort _",
    "was slightly worse for the random trees of set  a and drastically worse for the mutated trees of set  b with average values between 2.23 and 4.4 in comparison to values between 1 and 1.05 for the recursive algorithms .",
    "furthermore , _",
    "hierarchy sort_performed better on random trees rather than on mutated trees .",
    "note that the absolute number of crossings is lower for mutated trees ; thus a difference of only 1 or 2 to the optimum can already lead to relatively large ratios for small @xmath3 .    for general binary trees the performance ratios of _ rec - split _  and",
    "_ rec - split - improved _  are no longer upper - bounded by 2 but at least for random trees ( c ) the ratios were on average well below  2 . as expected , _ rec - split - improved _",
    "outperformed _ rec - split _  due to the modification for unbalanced trees .",
    "algorithm _ rec - split _  attained performance ratios close to 1 for most random instances but it had some outliers as well .",
    "the solutions of _ rec - split - improved _  were not only closer to the optimum , they also spread much less .",
    "note that due to excessive computation times of several hours we did not record the results of _ rec - split _  for @xmath68 .",
    "the hierarchy sorting algorithm yielded results that were clearly inferior to those of the recursive algorithms .",
    "but it still achieved performance ratios below  1.2 as  @xmath3 grows .",
    "in general , the behavior of both _ rec - split - improved _  and _ hierarchy sort_did not differ much between sets  a and  c and thus the completeness of the trees seems of low impact on the solution quality . in contrast _ rec - split _  performed worse on general trees than on complete trees .",
    "for the mutated trees of set  d with relatively fewer crossings in the optimal solution we use a logarithmic scale for the performance ratio .",
    "the results were generally worse and spread a lot more for all three algorithms , but still _ rec - split - improved _  had the best performance with the upper quartile of the ratios mostly below  3 . on the other hand the upper quartile of _ hierarchy",
    "sort _  reached values mostly above  20 and up to  85 for @xmath69 .",
    "algorithm _ rec - split _  reached performance ratios between those of the other two algorithms .",
    "for @xmath70 we stopped considering _ rec - split _  since its computation times became again too high .",
    "r5 cm     the relative performance of the algorithms for random non - complete trees was confirmed by the results for the sets  e  g of real - world examples , see fig .",
    "[ fig : real_world ] . for the clustering data of set  e with an average of 33.5 crossings _",
    "rec - split - improved",
    "_  reached an average performance ratio of 1.06 , _ rec - split _",
    "was slightly worse with 1.15 , and _ hierarchy sort _  had an average ratio of 1.86 .",
    "the phylogenetic data of sets  f and  g can often be drawn without crossings and thus have average crossing numbers of only 0.17 and 0.7 , respectively .",
    "this explains the relatively high performance ratios .",
    "still , _ rec - split - improved _  found an optimum layout for four of the six examples in set  f and solved all ten instances in set  g optimally .",
    "although the number of crossings is the main aspect to assess the quality of tl algorithms , their running time is also important  especially if the layouts are to be produced interactively .",
    "figure  [ fig : times ] shows plots of the running times of _ rec - split _ , _ rec - split - improved _ ,",
    "_ rec - split - bb _  ( the branch - and - bound implementation of _ rec - split - improved _ ) , _ hierarchy sort _ , and the iqp for all four classes of random tanglegrams .",
    "note the use of log scales . recall that _ hierarchy sort _  was written in delphi instead of java and executed on a different system .",
    "hence the absolute running times of _ hierarchy sort _  are to be taken with a grain of salt .",
    "by far the fastest algorithm in all our examples was _ hierarchy sort _ , which took at most 12 ms for complete trees and less than 90 ms for arbitrary trees .",
    "no difference in terms of the running time could be seen between random pairs and mutated pairs of trees .",
    "in contrast , the measured running times of the branch - and - bound algorithm _",
    "rec - split - bb_were about ten times higher for complete trees and between four and six times higher for general trees .",
    "still , the median running time of _ rec - split - bb _  was less than 360 ms for all instances . in the direct comparison of random  ( c ) and mutated",
    "( d ) pairs of non - complete trees with the same number of leaves , the random pairs , which have a much larger crossing number , required between 50 and 100% more computation time .",
    "the naive recursive implementations of _ rec - split _  and _ rec - split - improved_were far slower than _ hierarchy sort _  and _ rec - split - bb_. for complete binary trees they both grow at a cubic rate in @xmath3 , but _ rec - split - improved _",
    "is about three times faster than _ rec - split_.",
    "this is due to the additional @xmath33-time preprocessing step mentioned in section  [ sec : recurs - splitt - algo ] .",
    "both algorithms are not influenced by the class of the complete trees ( a or b ) as to be expected from their definitions .",
    "for general binary trees their running times quickly grew up to several hours , at least for some of the instances , which is due to the fact that the running time is exponential in the tree height .",
    "thus complete trees with 256 leaves could be solved as fast as some random trees with only 50 leaves . the better performance in terms of crossings of _",
    "rec - split - improved _  for unbalanced trees",
    "is paid for by higher running times in comparison to _ rec - split_.      +        interestingly , layouts for pairs of mutated and thus rather similar trees took much more time to compute than layouts for two random trees .",
    "one explanation is that for a subinstance @xmath71 the smaller of the heights of @xmath72 and @xmath73 determines the recursion depth .",
    "thus for two similar trees with similar heights the recursion depth will be larger on average than for two random trees with fairly different heights .",
    "it is also noteworthy that the running time of _ rec - split - bb _  in our experiments was dominated by the above mentioned @xmath74-time preprocessing step , which unlike the recursive algorithms does not depend exponentially on the height .    finally , we look at the running times of the iqp .",
    "in contrast to the recursive algorithms the running time of the iqp is independent of the height ( and thus the completeness ) of the trees .",
    "rather it is the value of the objective function , that is , the crossing number , that influences the solution time .",
    "therefore all mutated trees , which have relatively small crossing numbers , could be solved optimally within the time limits of ten minutes . on the other hand for random tanglegrams optimality",
    "could only be proven for @xmath75 . for larger instances a slowly increasing gap between the best found integer solution and the fractional solution remained ,",
    "see fig .",
    "[ fig : crnumbers - random ]  ( top ) .",
    "the experimental evaluation shows that in terms of crossing reduction our improvement of the recursive splitting algorithm of buchin et al .",
    "@xcite clearly has the best performance for all instances that were included in the tests .",
    "moreover , our branch - and - bound implementation is fast enough ( less than 0.4 seconds for trees with 200 leaves each ) to be used interactively .",
    "thus it is the method of choice for drawing binary tanglegrams with up to a few hundred leaves .",
    "still , in terms of running time the hierarchy sorting heuristic of holten and van wijk  @xcite outperforms the recursive splitting algorithm ; it can thus also be used for very large trees if the number of crossings is not the main optimization criterion .",
    "also , it is currently the only method that can draw non - binary tanglegrams . for medium - sized tanglegrams that consist of two similar trees and thus have a rather small crossing number it is worth to give it a try and solve the very simple integer quadratic program to obtain the optimal solution  often this takes but a few seconds .",
    "10    p.  bertolazzi , g.  di battista , c.  mannino , and r.  tamassia .",
    "optimal upward planarity testing of single - source digraphs .",
    ", 27(1):132169 , 1998 .",
    "k.  buchin , m.  buchin , j.  byrka , m.  nllenburg , y.  okamoto , r.  i.  silveira , and a.  wolff .",
    "drawing binary tanglegrams : hardness , approximation , fixed - parameter tractability .",
    "available at http://arxiv.org/abs/0806.0920    t.  dwyer and f.  schreiber .",
    "optimal leaf ordering for two and a half dimensional phylogenetic tree visualization . , volume  35 of _ crpit _ , pages 109115 .",
    "australian computer society , 2004 .",
    "p.  eades and n.  wormald .",
    "edge crossings in drawings of bipartite graphs . , 10:379403 , 1994 .",
    "h.  fernau , m.  kaufmann , and m.  poths . comparing trees via crossing minimization . in _ proc .",
    "25th intern .",
    "conf . found .",
    "( fsttcs05 ) _ , volume 3821 of _ lecture notes comput .",
    "_ , pages 457469 , 2005 .",
    "r.  grke , m.  gaertler , and d.  wagner . .",
    "in _ proc .",
    "15th internat .",
    "graph drawing ( gd07 ) _ , volume 4875 of _ lecture notes comput .",
    "_ , pages 352364 .",
    "springer - verlag , 2008 .",
    "m.  s. hafner , p.  d. sudman , f.  x. villablanca , t.  a. spradling , j.  w. demastes , and s.  a. nadler .",
    "disparate rates of molecular evolution in cospeciating hosts and parasites . , 265:10871090 , 1994 .",
    "d.  holten and j.  j.  van wijk",
    ". visual comparison of hierarchically organized data . in _ proc .",
    "10th eurographics / ieee - vgtc sympos .",
    "visualization ( eurovis08 ) _ , pages 759766 , 2008 .",
    "m.  jnger and p.  mutzel .",
    "2-layer straightline crossing minimization : performance of exact and heuristic algorithms .",
    ", 1(1):125 , 1997 .",
    "a.  lozano , r.  y. pinter , o.  rokhlenko , g.  valiente , and m.  ziv - ukelson .",
    "seeded tree alignment and planar tanglegram layout . in _ proc .",
    "7th internat .",
    "workshop algorithms bioinformatics ( wabi07 ) _ , volume 4645 of _ lecture notes comput .",
    "_ , pages 98110 .",
    "springer - verlag , 2007 .",
    "r.  d.  m. page , editor . .",
    "university of chicago press , 2002 .",
    "k.  sugiyama , s.  tagawa , and m.  toda .",
    "methods for visual understanding of hierarchical system structures .",
    ", 11(2):109125 , 1981 .",
    "there is a remaining gap between the best found integer solution and the best fractional solution .",
    "both values are plotted ; however , the gap is relatively small ( less than 70 for @xmath76 ) and hardly visible.,title=\"fig : \" ] +   there is a remaining gap between the best found integer solution and the best fractional solution .",
    "both values are plotted ; however , the gap is relatively small ( less than 70 for @xmath76 ) and hardly visible.,title=\"fig : \" ]"
  ],
  "abstract_text": [
    "<S> a _ binary tanglegram _ is a pair @xmath0 of binary trees whose leaf sets are in one - to - one correspondence ; matching leaves are connected by inter - tree edges . for applications , for example in phylogenetics or software engineering , it is required that the individual trees are drawn crossing - free . a natural optimization problem , denoted _ tanglegram layout problem _ </S>",
    "<S> , is thus to minimize the number of crossings between inter - tree edges .    </S>",
    "<S> the tanglegram layout problem is np - hard and is currently considered both in application domains and theory . in this paper </S>",
    "<S> we present an experimental comparison of a recursive algorithm of buchin et al .  </S>",
    "<S> @xcite , our variant of their algorithm , the algorithm hierarchy sort of holten and van wijk  @xcite , and an integer quadratic program that yields optimal solutions . </S>"
  ]
}