{
  "article_text": [
    "projective techniques are often used for determining the ground - state properties of strongly correlated models defined on a lattice .",
    "they were initially developed for non - lattice models  @xcite and then used for the study of fermionic lattice models  @xcite .",
    "they were subsequently applied to quantum spin models  @xcite as well as other models .",
    "the underlying idea is easy to describe . for a lattice hamiltonian @xmath3 , it is possible to choose a constant @xmath4 such that the dominant eigenvalue @xmath5 of @xmath6 corresponds to the ground - state wavefunction of @xmath3 , @xmath7 .",
    "we can then use @xmath8 as a projective operator in the sense that the repeated application of @xmath9 to a trial wave function , @xmath10 , will approach @xmath11 for large @xmath12 .",
    "hence , if @xmath12 can be taken large enough , @xmath7 can be projected out in this manner provided that @xmath13 . some variants of this approach are often referred to as green s functions monte carlo ( gfmc )  @xcite .",
    "other projective operators such as @xmath14 can be used depending on the model and its spectrum . for",
    "a review see ref .  .",
    "the convergence of such projective techniques may be non - trivial as can be shown by analyzing simple models  @xcite .",
    "if @xmath15 can be evaluated exactly , this projective scheme is equivalent to the power method as used in exact diagonalization studies .",
    "as the number of sites in the lattice model is increased , exact evaluation quickly becomes impossible and monte carlo methods ( projector monte carlo ) have to be used .",
    "the efficiency of the monte carlo sampling is crucial for the performance of implementations of the projective method and detailed knowledge of such monte carlo methods is of considerable importance . here",
    ", we have investigated a new class of monte carlo algorithms for projective methods for lattice models .",
    "we discuss these algorithms within the context of quantum monte carlo where the projection is performed in the valence bond basis  @xcite , so called valence bond quantum monte carlo ( vbqmc ) .",
    "the algorithms are , however , applicable to projective techniques in any basis .",
    "vbqmc was first developed by liang  @xcite and then , starting fifteen years later , significantly further developed by sandvik and collaborators  @xcite and it is now widely used . since its inception , vbqmc has been improved and generalized in several ways : it can be used on systems with spins with @xmath16  @xcite and states with total @xmath17  @xcite .",
    "an efficient sampling algorithm with loop updates is known for systems with @xmath18  @xcite .",
    "( here 5 ) terms .",
    "the operator that acts on the state first , is chosen at the first node on the left .",
    "this node is called the root and the direction towards the root we define to be up .",
    "the operator that acts on the state last is at the end of the string .",
    "the two colored paths differ in the choice of the last three operators .",
    "the last three branches , thus , contribute different operators and weights ( @xmath19 , @xmath20 ) .",
    "the resulting strings _ _ and _ _ are different . ]    as outlined above , vbqmc works by projecting onto the ground - state by repeatedly acting on a trial - state @xmath21 with @xmath22 , where the constant @xmath4 is chosen such that the ground - state has the biggest eigenvalue . for hamiltonians with bounded spectrum such a @xmath4",
    "can always be found .",
    "for a simple quantum spin model defined on a lattice we have @xmath23 and we can write @xmath24 as a sum over @xmath25 bond - operators @xmath26 . taking @xmath9 to the @xmath12th power then results in a sum over products of these bond - operators @xmath26 : @xmath27 each instance of this product then forms a string @xmath28 of bond - operators of length @xmath12 .",
    "when selecting such a string of length @xmath12 , one has to make a choice between the @xmath25 bond - operators at each position in the string .",
    "it is possible to view the construction of such a string as a specific path in a decision - tree ( see fig .",
    "[ fig_tree ] ) .",
    "although the algorithms we present can be extended to higher spin models , we shall restrict the discussion to quantum spin models with @xmath18 where one usually takes @xmath29 .",
    "the action of the bond - operators then takes an attractively simple form .    in a valence",
    "bond basis state spins are paired into singlets .",
    "a specific pairing of all spins is usually referred to as a covering . all such coverings form an over complete basis for the singlet sub - space of the model .",
    "we shall only be concerned with models defined on a bi - partite lattice in which case a given valence bond covering , @xmath30 , for a lattice with @xmath31 spins can be denoted by listing all @xmath32 pairs of @xmath33 $ ] with @xmath34 on sub - lattice @xmath35 and @xmath36 on sub - lattice @xmath37 . here ,",
    "@xmath33=(|\\uparrow_{i_a}\\downarrow_{j_b}\\rangle-|\\downarrow_{i_a}\\uparrow_{j_b}\\rangle)/\\sqrt{2}$ ] .",
    "we label the initial covering ( trial - state ) as @xmath38 .",
    "the action of an operator @xmath26 can take two forms  @xcite :    * the sites @xmath34 and @xmath36 are in a singlet before the action of the operator .",
    "then , the action of the operator does not change the state and we can associate a weight of @xmath39 : @xmath40=1[i , j ] \\,.\\ ] ] * the sites @xmath34 and @xmath36 are not in a singlet before the action of the operator .",
    "then , after the action of the operator , the sites @xmath34 and @xmath36 form a singlet .",
    "the sites they were originally connected to are also returned in a singlet - state .",
    "furthermore , the state is multiplied by a weight equal to @xmath41 : @xmath42[l , j]=\\frac{1}{2}[i , j][l , k ] \\,.\\ ] ]    a particularly nice feature is that the application of any of the @xmath26 to any given covering yields a unique other covering and _ not _ a linear combination of coverings . although convenient , this feature of projections in the valence bond basis is not strictly necessary for the algorithms we discuss here as they can be adapted to the case where a linear combination of states are generated  @xcite . for a given operator string @xmath43 , we can associate a weight given by @xmath44 .",
    "the state @xmath45 will contribute to the final projected estimate of the ground - state with this weight .",
    "one can then sample the ground - state by performing a random walk in the space of all possible strings @xmath28  @xcite according to the weight @xmath46 .",
    "this way of sampling is quite different from gfmc even though vbqmc and gfmc are closely related projective techniques .",
    "gfmc , as it is used in for instance ref .",
    ", is usually performed in the @xmath47 basis but can also be done in terms of the valence bond basis  @xcite . in gfmc",
    "the projection is done by stochastically evaluating the action of the whole projection - operator on a trial - state .",
    "this is done by introducing probabilistic `` walkers '' .",
    "in contrast , as mentioned , in vbqmc a single state results and the strings @xmath28 are sampled according to their weight .",
    "clearly , the efficient sampling of states resulting from the stochastic projection of the trial - state is a difficult problem . here",
    ", we propose to use worm ( cluster ) algorithms for this purpose .    in monte carlo calculations one averages over many configurations of the system which are generated with appropriate probabilities .",
    "usually , this is done in a markov - chain , where one configuration is chosen as a variation of the last .",
    "one important feature of an efficient algorithm is that these consecutive configurations are as uncorrelated as possible .",
    "this led to the introduction of algorithms where whole clusters and not just single elements are changed going from one configuration to the next  @xcite or where all elements in the path of a _ worm _ are changed  @xcite .    here",
    ", we show how it is possible to adapt such worm algorithms for projections in the context of vbqmc .",
    "the algorithms we have studied are based on the notion of a worm moving around in the decision tree described above . as in earlier worm algorithms , the change of many elements",
    "is achieved by moving the worm based on local conditions  @xcite and one might refer to the algorithms as tree - worm algorithms",
    ". in general , the algorithms can be viewed as _ directed _  @xcite algorithms .",
    "when we update the string , we start with a worm at the end of the tree and move it up the tree .",
    "see fig .",
    "[ fig_tree ] .",
    "the worm then moves around in the tree and where it goes the operator - string is changed .",
    "when the worm finds its way back to the bottom of the tree the update is complete .",
    "we derive a set of simple equations governing the movement of the worm .",
    "the solution of these equations lead to parameters defining a new class of algorithms .",
    "quite generally , many solutions are possible leaving significant room for choosing parameters that will lead to the most optimal algorithm .",
    "we focus on two specific choices of parameters corresponding to two different algorithms .",
    "the _ bouncing worm _ algorithm , for which every update is accepted and the _ driven worm _ algorithm , for which the update is accepted with some probability . with the driven worm algorithm one can choose at will",
    "how much of the operator - string is on average changed in a successful update .    in order to test the algorithms",
    ", we calculate the ground - state energy of the isotropic heisenberg - chain .",
    "this quantity is easy to calculate with vbqmc and can be exactly computed using the bethe - ansatz .",
    "it is thus a very convenient quantity to test the algorithms with .",
    "the algorithms presented in this paper can , however , be used for the same calculations as other vbqmc implementations  ( see e.g. @xcite ) . in section  [ sec_tree_algorithm ]",
    "we derive the general equations governing the movement of the worm .",
    "section  [ sec_impl ] contains a description of the specific implementation corresponding to the two choices of parameter solutions we have studied .",
    "the _ bouncing worm _ is detailed in section  [ subsec_bouncing_worm ] while the _ driven worm _ algorithm is described in section  [ subsec_driven_worm ] .",
    "the algorithms are then compared in section  [ sec_comp ] .",
    "we present our conclusions in section  [ sec_conclusion ] .",
    "we now turn to a discussion of the general framework for the algorithms we have investigated .",
    "we begin by deriving the equations governing their behavior in a general way .",
    "let us take the hamiltonian to have @xmath25 terms .",
    "we now imagine a tree where each node indicates the decision to chose one of the @xmath25 bond operators composing the string ( see fig .",
    "[ fig_tree ] ) .",
    "each branch of the tree corresponds to one of the @xmath25 bond operators .",
    "a given operator string then corresponds to selecting a path in the tree . consider 2 such paths and that are identical for the part of the operator string first applied to the trial - state .",
    "the last 3 operators , however , differ .",
    "this leads to different weights , which we denote with @xmath19 and @xmath20 .",
    "as it is done in most monte carlo methods , we set out to construct a markov - chain .",
    "here it is a chain of different strings .",
    "if the probabilities to go from one string to the next have detailed balance , the markov - chain contains the strings with the desired probability . for detailed balance , the probabilities for starting from operator string and going to operator string _ _ and reverse have to satisfy @xmath48 we can achieve this ratio of probabilities by imagining a worm ( tree - worm ) working its way up the tree to the point @xmath49 where it turns around and then working its way down again .    let us call the valence - bond covering of the trial - state @xmath38 .",
    "up to numerical factors , the application of an operator string _ _ of length @xmath12 will yield a new valence - bond covering @xmath50 .",
    "the worm is started by removing the last applied bond operator and considering the resulting covering @xmath51 .",
    "a decision now has to be made if the worm is to continue `` up '' the tree by removing more bond operators from the string or if it should instead go `` down '' the tree by adding a new bond operator to the string . at each node in the tree",
    "the decision to continue up or turn around is made according to a set of _ conditional probabilities _ @xmath52 and @xmath53 .",
    "here , @xmath52 denotes the probability for going up after coming from a bond operator that carried weight @xmath54 and @xmath53 is the probability for turning around by applying a bond operator of weight @xmath55 coming from an operator with weight @xmath54 .",
    "likewise , @xmath56 denotes the probability of choosing an operator with weight @xmath54 given that the worm is coming from further up the tree . with these conditional probabilities the left - hand side of eq .",
    "( [ eq_mc ] ) can be written as    @xmath57    clearly , eq .",
    "( [ eq_detailed_balance ] ) is satisfied if we choose @xmath58 where @xmath4 is an additional free parameter included for later optimization of the probabilities .",
    "if we can choose conditional probabilities with these properties , we can go between different operator strings always accepting the new string .",
    "the rejection probability is then zero .",
    "this is a very desirable property of any monte carlo algorithm since it indicates that the algorithm is sampling .",
    "we mostly focus on so called _ zero bounce _",
    "algorithms for which if the worm turns around the probability for replacing a bond operator with the same operator is zero .",
    "then the two operator strings @xmath59 and @xmath0 are always different .",
    "this means that @xmath60 quite generally , it is easy to find _ many _ solutions to the equations ( [ eq_ratio ] ) leading to many monte carlo algorithms which can be tuned for efficiency .",
    "we now focus on @xmath59@xmath1@xmath61-heisenberg models defined on bi - partite lattices . as has been described above , for these models only 2 weights can occur : @xmath62 .",
    "the two weights correspond to the two different actions the bond - operators can have on the state .",
    "it is @xmath63 if the operator acts on two sites that are in a valence - bond .",
    "the state is not altered under the action of such an operator .",
    "we call such operators diagonal",
    ". the weight is @xmath61 if the operator acts on two sites that are _ not _ in a valence - bond .",
    "after the action of the operator the two sites are connected by a bond as well as the sites they were connected to .",
    "we call such operators non - diagonal .    if a decision has to be made at the node at position @xmath64 , the conditional probabilities depend on how many of the @xmath25 bond - operators will yield a weight of 1 ( are diagonal ) or @xmath65 ( are non - diagonal ) when applied to the present covering @xmath66 .",
    "we shall denote these numbers by @xmath67 and @xmath68 respectively . when the worm is started @xmath67 and @xmath68 therefore have to be calculated for @xmath51 , if they are not already known from an earlier update .",
    "it is thus sensible to store @xmath67 or @xmath68 at all nodes .",
    "@xmath67 can only be zero at the node furthest up the tree ( the root ) and only if the trial - state is chosen to not contain any diagonal bonds . in fig .",
    "[ fig_tree ] it is the gray node on the very left .",
    "@xmath69 can not be smaller than @xmath70 .",
    "we can now write down an @xmath71 matrix @xmath72 of conditional probabilities for each node of the tree .",
    "the @xmath36th column of the matrix describes the probability for going in any of the @xmath73 directions when coming from the direction @xmath36 . for clarity",
    "we order the rows and columns such that the first @xmath69 correspond to the non - diagonal operators and the next @xmath67 to the diagonal operators .",
    "the last column contains the probabilities for going down the tree when coming from above ; the last row the probabilities for going up the tree when coming from below .",
    "the remaining part of the matrix describe the probabilities for replacing one operator with another when the worm turns from going up to going down .",
    "the matrix @xmath72 has the form    @xmath74    where @xmath75 refers to the conditional probability of coming from an operator with weight @xmath54 and going to a _",
    "different _ operator with the same weight . as mentioned above",
    ", @xmath52 denotes the probability for going up coming from an operator with weight @xmath54 and @xmath53 is the probability for turning around by choosing a bond operator of weight @xmath55 coming from an operator with weight @xmath54 .",
    "likewise , @xmath56 denotes the probability of choosing an operator with weight @xmath54 coming from further up the tree .    to shorten the notation we introduce the short - hand @xmath76",
    "furthermore we define the ` bounce ' probabilities @xmath77 here it is implied that the probabilities are for going from one operator to the _ same _ operator .",
    "finally we also need to define the branching probabilities @xmath78 from which it follows ( using eq .",
    "( [ eq_ratio ] ) ) that : @xmath79    the matrix @xmath72 is then given by @xmath80 the requirement that this matrix be stochastic ( i.e.  some branch is chosen with probability one ) means that the entries in each column have to sum to 1 .",
    "this leads to the set of equations @xmath81 these simple equations are the central equations governing the behavior of the algorithms . to find an algorithm , we need to solve these 3 equations with the constraints that @xmath82 ; a straight forward problem",
    ".    at the root ,",
    "the equations are modified slightly : since it is not possible to go further up the tree , @xmath83 , @xmath84 , @xmath85 are not meaningful and can be set to zero . for convenience we set @xmath86 and @xmath87 at the root .",
    "this allows one to just choose diagonal operators twice as often as non - diagonal operators . since the number of diagonal operators does not change at the root , a table generated at the beginning of the calculation suffices to perform this task .",
    "it can be very useful to choose different @xmath4 s at different nodes .",
    "then , calculating the probabilities to choose operators according to the rules introduced in this section will not lead to an algorithm with detailed balance , because @xmath88 from different strings will not cancel in eq .",
    "( [ eq_detailed_balance ] ) .",
    "it is necessary to work with an acceptance probability .",
    "we find @xmath89 here @xmath90 and @xmath91 denote @xmath4 at the different nodes in the strings @xmath92 and @xmath93 , respectively . to validate the algorithm",
    ", we must therefore introduce an acceptance probability that must cancel the factor @xmath94 .",
    "this can be achieved by choosing @xmath95 meaning that when a new string is generated through a worm move it is accepted with this probability .",
    "since we always start from the bottom of the tree ( the last operator applied ) , the worm algorithms presented in this paper always change a block of consecutive branches at the end of the string .",
    "this is favorable to changes across the whole string because changes far up the string might be undone by changes closer to the end of the string  @xcite . in this way",
    "the most important part of the string is updated most substantially .",
    "it is also important to note that the algorithm will conserve certain topological numbers .",
    "for instance , for a two - dimensional system @xmath18 heisenberg model the number of valence bond crossing a cut in the @xmath96- or @xmath97-direction is either odd or even .",
    "hence , the initial covering , @xmath38 is characterized by these 2 parities .",
    "it is easy to see that the application of @xmath9 to any covering can not change these parities and they are therefore preserved under the projection .",
    "as is explained in the last section , many different algorithms can be found because many different solutions to the equations  ( [ eq_cond ] ) exist .    in this section",
    "we present two different algorithms .",
    "one pure worm algorithm where every update is accepted ( the _ bouncing worm _ algorithm ) and an algorithm that allows for control over how far in the tree updates are attempted ( the _ driven worm _",
    "algorithm ) . to test and compare the different algorithms",
    ", we calculate the ground - state energy of the antiferromagnetic heisenberg chain .",
    "the nel - state @xmath98 has equal overlap with all valence - bond states .",
    "this can be used to very directly estimate the ground - state energy , @xmath99  @xcite : @xmath100 if we take @xmath101 and assume that the monte carlo sampling will visit strings according to their weight @xmath46 , then for a monte carlo sequence of length @xmath31 of independent strings we find : @xmath102 where again we have used the fact that @xmath103 is independent of the covering @xmath30 .    to analyze the correlation - properties of the worm algorithms we use the energy - autocorrelation - time , which we take to be the number of updates it takes the energy - autocorrelation - function @xmath104 to decay to 0.1 .",
    "the results of all update - attempts enter the calculation of the expectation - values .",
    "the shorter the autocorrelation - time is , the fewer steps have to be done between consecutive measurements .",
    "if not stated otherwise an operator - string of 20,000 operators was used for calculations with worm algorithms .       where it turns to go down to node 3 .",
    "the worm bounces back and goes all the way to node 1 .",
    "then the worm turns around and does not bounce again . ]",
    "the first algorithm we discuss is the bouncing worm algorithm .",
    "only a few of the variables that appear in the equations  ( [ eq_cond ] ) are chosen to be non - zero .",
    "we choose to set : @xmath105 while @xmath106 as is @xmath107 .",
    "we leave @xmath108 as a parameter that can be zero or non - zero allowing for tuning of the algorithm . with this choice ,",
    "when the worm is moving up the tree the only possibility for it to turn around is by opting to replace one diagonal operator with another diagonal operator .",
    "the @xmath88 are chosen to be the same at all nodes : @xmath109 .",
    "the equations for the non - zero parameters are then @xmath110 the requirements that @xmath111 imply that @xmath112 to satisfy eq .",
    "( [ eq_algod_ccond ] ) with node - independent @xmath4 , we set @xmath113    with this choice of parameters , we find the probability to go up the tree if the worm is at a node with a non - diagonal operator to be @xmath114 for _ any _ @xmath108 .",
    "likewise , if the worm is at a node with a diagonal operator the probability to go up is given by @xmath115 independent of @xmath108 .",
    "the probability for going up the tree is therefore independent of @xmath108 .",
    "we define the penetration depth ( p .- depth ) , which we denote by @xmath116 , as the maximal height that the worm reaches .",
    "the actual length of the worm is denoted by @xmath117 and with @xmath118 we find @xmath119 .",
    "the penetration depth @xmath116 will determine how much the operator - string is changed . obviously , it is desirable to have the worm reach as far up the tree as possible .",
    "it is possible to force the worm farther up the tree by having it bounce back to going up after it has turned to go down ( see fig .",
    "[ fig_treebouncing ] ) . in that case , the actual _ length _ of the worm , @xmath117 , will then be substantially different from twice the penetration depth since the worm can turn many times , a point we shall return to later .",
    "such bounces occurs with a likelihood of @xmath108 which was left as a free parameter and can now be used as a tuning parameter .",
    "the algorithm is straight forward to implement and the acceptance probability for a worm update is 1 .",
    "the move is _ always _ accepted .",
    "specific details of an implementation of the bouncing worm update can be found in appendix  [ subsec_bouncing_worm_pse ] .",
    "we begin by discussing the case of @xmath118 . in this case",
    "the worm first moves up the operator string , turns around once and then proceeds down to the bottom of the tree .",
    "it does not go back up the operator string since @xmath118 . in order to measure the performance of the algorithm we did calculations on an antiferromagnetic heisenberg chain with 50 sites using an operator string of length @xmath120 . as can be seen in table  [ tab_bounce_slowdown ]",
    ", this leads to a rather small mean penetration - depth ( p .- depth ) of about 5 .",
    "the maximal penetration - depth of 50 is substantially larger .",
    "both these numbers are , however , substantially smaller than the length of the operator string ( @xmath120 ) and it appears that the algorithm with @xmath108 is not very effective .",
    ".data for several runs at different @xmath108 . at @xmath121 increasing the bounce - probability starts to significantly slow down the algorithm .",
    "the last column contains the run - times divided by the runtime for @xmath108  @xmath1  @xmath2 .",
    "the data were generated with an operator - string of 100,000 operators .",
    "the maximal penetration and the expected slowdown could thus not be resolved for @xmath108 @xmath1 @xmath122 .",
    "we used @xmath123 measurements and a chain with 50 sites . [ cols=\"^,^,^,^\",options=\"header \" , ]",
    "in the following we compare worm - updates to simple conventional vbqmc - updates as described for example in reference  @xcite . this means that for vbqmc we attempt to change 4 randomly selected operators during one update .",
    "we do not compare to loop - updates as introduced in reference  @xcite , since we anticipate the worm algorithms to be of most with algorithms for which loop - updates are not known although our current implementations of them are similar to conventional vbqmc .",
    "we first consider the convergence of the energy with the projection power ( the length of the operator strings ) .",
    "our results for a 50 site heisenberg chain are shown in fig .",
    "[ fig_comp_sivabo_driven_bounce ] .",
    "it turns out that if the worm algorithms penetrate the tree sufficiently deeply , the results do not depend on the type of algorithm in use .",
    "in particular , the dependence of the results on the length of the string is the same for _ all three _ algorithms ( see fig .  [ fig_comp_sivabo_driven_bounce ] ) , just as one might have expected since the power method underlies all three algorithms .    , which corresponds to a mean penetration - depth of about @xmath124 and full penetration of the string .",
    "the bouncing worm algorithm was run with a bounce probability @xmath125 , which corresponds to a mean penetration - depth of roughly @xmath126 and full penetration of the string .",
    "the calculation was done for a chain with 50 sites . ]",
    "when using the worm algorithms , the operator string is usually chosen so long that the worm never or very rarely reaches the root of the tree .",
    "this means that there are almost always nodes close to the root with operators that are never updated and thus act on the trial - state after every update . in this way",
    ", we are effectively using an optimized trial - state .",
    "the effect is similar to generating the trial - state by performing several updates on a randomly chosen trial - state and taking the resulting state for the actual calculation .",
    "we used such a trial - state for the conventional vbqmc - calculations shown in this section .    .",
    "hence , data for conventional vbqmc updates , the driven worm algorithm and the bouncing worm algorithm were multiplied by @xmath127 , @xmath128 and @xmath129 , respectively . for the worm",
    "algorithms the same parameters as in fig .",
    "[ fig_comp_sivabo_driven_bounce ] were used .",
    "this means that @xmath130 and @xmath125 .",
    "an operator - string of length 1000 was used for all three algorithms .",
    "the horizontal line at @xmath131 was added to allow for easy visual estimation of the scaled autocorrelation - time . ]    a useful measure of the effectiveness of an algorithm can be obtained from the autocorrelation function . if simply measured as a function of the number of updates it decreases dramatically faster for the worm algorithms when compared to conventional vbqmc .",
    "however , just using one update as the temporal unit puts conventional vbqmc at an unfair disadvantage .",
    "the reason is , that in calculations with conventional vbqmc one attempts to change 4 operators per update while for the worm algorithms it could be many more .",
    "the number of updated operators in a given worm update varies greatly with the length of the worm , @xmath132 , which can easily be hundreds of operators long .",
    "since a single worm update is , therefore , computationally more expensive to perform than a single 4 operator update with conventional vbqmc , it seems fairer to compare autocorrelation functions with this difference taken into account .",
    "that is , a fair comparison would ask which algorithm has the smallest correlations when on average the same number of changes has been attempted .",
    "we can take this into account by simply scaling the temporal axis with the average size of the attempted update .    in fig .",
    "[ fig_comp_sivabo_driven_bounce_autocorfu ] we therefore show results for the energy autocorrelation function for the two worm algorithms as well as for conventional vbqmc with the temporal axis rescaled by the number of operators one attempts to change in a single update . during one update with worm - algorithms one tries to update @xmath133 operators .",
    "the scaled number of updates is simply @xmath134 with @xmath135 for conventional vbqmc and @xmath136 for the driven worm algorithm . for the bouncing worm algorithm , @xmath137 has to be measured during the simulation , since the bouncing worm can go up and down the tree many times .",
    "thus , @xmath138 can be orders of magnitudes bigger than the mean penetration - depth .",
    "for instance , for the calculations shown in fig .",
    "[ fig_comp_sivabo_driven_bounce_autocorfu ] the mean penetration - depth was approximately 7.8 whereas @xmath139 . even including such a rescaling of the temporal axis , it is clear that the autocorrelation - times are much shorter for the worm algorithms , as shown in fig .",
    "[ fig_comp_sivabo_driven_bounce_autocorfu ] .    , from the exact bethe - ansatz results for a chain with 100 sites .",
    "the results are shown for the driven and bouncing worm algorithms versus the mean penetration - depth and for conventional vbqmc updates versus the projective power ( length of operator string ) .",
    "the worm algorithms reach the same small value of @xmath140 with a mean penetration - depth an order of magnitude smaller than the projective power used for the calculation with conventional vbqmc updates .",
    "the bars on the markers indicated the statistical uncertainty .",
    "the colored ( dark ) surfaces are due to overlapping error - bars .",
    "operator - strings of 20,000 operators were used for the calculations with the worm algorithms . ]",
    "the two worm algorithms change operators of the string starting from one end while the conventional vbqmc selects 4 operators at random to be changed .",
    "as mentioned in subsection  [ subsec_bouncing_worm ] , the mean and the maximum penetration - depth are usually much smaller than the length of the operator - string ( the projection power ) .",
    "it is therefore natural to ask if one can reach a similar quality of results using worm algorithms and conventional vbqmc .",
    "that this is so can be seen by plotting the absolute deviation from the ground - state energy , @xmath141 , versus the mean penetration - depth .",
    "as shown in fig .",
    "[ fig_sivabo_driven_bounce_a_u ] , the mean penetration - depth can , in fact , be much smaller than the projection power of a conventional vbqmc - calculation and still yield results of the same accuracy .    finally , we look at how the scaled autocorrelation - time depends on the size of the system studied . for convenience ,",
    "we define the scaled autocorrelation - time to be the point where the autocorrelation function has decreased to the value @xmath131 ( see fig .",
    "[ fig_comp_sivabo_driven_bounce_autocorfu ] ) . since in realistic calculations",
    "one would use a fixed ( large ) length of operator string with the worm algorithms , while one would scale it with the size of the system in conventional vbqmc , we here only compare the two worm algorithms .",
    "our results are shown in fig .",
    "[ fig_algod_algoc_sivabo ] for a fixed length operator string of @xmath142 .     was used in the calculations . in the calculations shown",
    ", the bouncing worm algorithm was run with @xmath143 and the driven worm algorithm was run with @xmath130 . for the scaling we use @xmath144 for the driven worm algorithm and an @xmath138 between @xmath145 for @xmath146 and @xmath147 for @xmath148 for the bouncing worm algorithm . ]    for the simulations shown in fig .",
    "[ fig_algod_algoc_sivabo ] the mean penetration - depths for the driven worm algorithm were about @xmath149 .",
    "the autocorrelation - time for the driven worm algorithm starts to increase appreciably at this system size , while it is initially are almost flat .",
    "we conclude that a significant increase in the autocorrelation - time appears once the system size significantly exceeds the mean penetration - depth .",
    "a similar effect can be observed for the bouncing worm algorithm .",
    "the mean penetration - depths for the bouncing worm algorithm are , however , much smaller ( around @xmath150 ; see fig .  [ fig_sivabo_driven_bounce_a_u ] ) .",
    "results for @xmath31 smaller than the mean penetration - depth are therefore not shown in fig .",
    "[ fig_algod_algoc_sivabo ] .",
    "the autocorrelation - times remain manageable for the system sizes studied , even though it is consistently increasing .",
    "compared to simple implementations of vbqmc , the worm algorithms have significant overhead .",
    "this is largely compensated by the large number of operators that can be changed in an update and resulting shorter autocorrelation - times , as we found in all computations .",
    "given the somewhat different properties of the two worm algorithms , a realistic implementation could combine the two by performing updates with the driven worm algorithm mixed with updates using the bouncing worm algorithm ( and perhaps conventional vbqmc updates ) .",
    "we have shown that valence - bond quantum monte carlo can be implemented with an update build around the notion of a worm propagating through a tree .",
    "many different such algorithms are possible .",
    "we studied the validity and efficiency of two of them .",
    "one for which no update is rejected ( the bouncing worm algorithm ) and one for which big parts of the operator - string are updated ( the driven worm algorithm ) .",
    "both algorithms are attractively simple and straight forward to implement and produce high quality results",
    ".    while they may not be computationally competitive with state of the art loop update algorithms  @xcite for vbqmc , the algorithms presented here are intrinsically interesting since they represent a new class of algorithms that should be generally applicable to projective methods .",
    "these algorithms are not restricted to the valence bond basis and preliminary results show that they can be quite efficient in the @xmath47-basis  @xcite method and might spark further development of it .",
    "we also note that many other algorithms can easily be found with the results contained in this paper and that it is possible that the parameter space allows for much more efficient algorithms than the two we have studied here .    in terms of further optimizing the algorithms",
    "several directions may be interesting to pursue .",
    "not updating some of the operators the worm visits , might boost the acceptance ratio of the driven worm algorithms and thereby reduce the autocorrelation - times .",
    "this could be combined with attempting to reduce the overhead of the driven worm calculations by always forcing the worm all the way down to the root .",
    "this would eliminate the need to keep track of the state at each node . with the current practice of updating all operators after turning around , going all the way to the node during every update leads to very small acceptance ratios .",
    "we acknowledge computing time at the shared hierarchical academic research computing network ( sharcnet : www.sharcnet.ca ) and research support from nserc .",
    "this appendix contains pseudocode that shall serve to clarify the algorithms proposed in this paper . to simplify notation we refer to diagonal operator as dop and non - diagonal operators as ndop .      in this section",
    "we give detailed information on a straightforward ( albeit not optimized ) implementation of the bounce - algorithm ( see subsec .  [ subsec_bouncing_worm ] ) .",
    "shown is an outline of the central part of the algorithm : the update of the operator - string and the state .",
    "the algorithm works its way up the tree .",
    "it starts at the last branch which is assigned the @xmath12th position . at each position",
    "it is decided if the worm goes up the tree or down , in which case a new operator is chosen for the branch at this position .",
    "the necessary probabilities are calculated according to the expressions given in eq .",
    "[ eq_algod_weights ] and eq .",
    "[ eq_bounce_c ] .",
    "if a new operator is chosen for the @xmath12th branch , the update is complete .",
    "it is assumed that the tree is so high ( the operator - string so long ) that the root is never reached . if the root is reached , one has to choose an operator for the first branch according to the probabilities outlined in sec .",
    "[ sec_tree_algorithm ] after eq .",
    "[ eq_cond ] .",
    "we now turn to a description of a ( not optimized ) implementation of the driven worm algorithm ( see subsec .  [ subsec_driven_worm ] ) . as above",
    ", we show an outline of the central part of the algorithm : the update of the operator - string and the state .",
    "the worm works its way up the tree .",
    "it starts at the last branch which is assigned the position @xmath12 .",
    "while going up the tree , the worm , at each node , goes further up the tree with probability @xmath160 or turns around with probability @xmath63@xmath161@xmath160 . after turning around",
    ", the worm keeps going down until it reaches the end . at the nodes the worm visits new operators are chosen .",
    "when the worm reaches the end , it has to be decided whether or not the update should be accepted .",
    "the associated probabilities are calculated according to the expressions given in the main text ( see eq .",
    "[ eq_alphadefinition ] , eq .",
    "[ eq_algoc_weights ] and eq .",
    "[ eq_accprob ] ) .    as above",
    ", we assume that the tree is so high ( the operator - strings so long ) that the root is never reached . if that the root is reached , one has to choose an operator for the first branch according to the probabilities outlined in sec .",
    "[ sec_tree_algorithm ] after eq .",
    "[ eq_cond ] .",
    "@xmath151 @xmath152 true @xmath153 @xmath154 @xmath152 false choose new ndop at @xmath155 choose dop at @xmath155 choose new dop at @xmath155 choose ndop at @xmath155 update state , weights , @xmath4 , and @xmath67 at @xmath155 @xmath157 choose dop at @xmath155 choose ndop at @xmath155 update state , weights , @xmath4 , and @xmath67 at @xmath155 @xmath157 accept or reject using old and new @xmath4 s ."
  ],
  "abstract_text": [
    "<S> we present a new class of algorithms for performing valence - bond quantum monte carlo of quantum spin models . </S>",
    "<S> valence - bond quantum monte carlo is a projective @xmath0@xmath1@xmath2 monte carlo method based on sampling of a set of operator - strings that can be viewed as forming a tree - like structure . </S>",
    "<S> the algorithms presented here utilize the notion of a worm that moves up and down this tree and changes the associated operator - string . in quite general terms </S>",
    "<S> we derive a set of equations whose solutions correspond to a new class of algorithms . as specific examples of this class of algorithms we focus on two cases . </S>",
    "<S> the _ bouncing worm _ algorithm , for which updates are _ always accepted _ by allowing the worm to bounce up and down the tree and the _ driven worm _ </S>",
    "<S> algorithm , where a single parameter controls how far up the tree the worm reaches before turning around . </S>",
    "<S> the latter algorithm involves only a _ single bounce _ where the worm turns from going up the tree to going down . </S>",
    "<S> the presence of the control parameter necessitates the introduction of an acceptance probability for the update . </S>"
  ]
}