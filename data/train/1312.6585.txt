{
  "article_text": [
    "* motivation .",
    "* parameterized complexity deals with problems whose instances @xmath2 come equipped with an additional integer parameter @xmath3 , and the objective is to obtain algorithms whose running time is of the form @xmath4 , where @xmath5 is some computable function ( see  @xcite for an introduction to the field )",
    ". we will be only concerned with problems defined on graphs .",
    "a fundamental notion in parameterized complexity is that of _ kernelization _ , which asks for the existence of polynomial - time preprocessing algorithms that produce equivalent instances whose size depends exclusively ( preferably polynomially or event linearly ) on @xmath3 . finding kernels of size polynomial or linear in @xmath3 ( called _ linear kernels _ ) is one of the major goals of this area .",
    "an influential work in this direction was the linear kernel of alber _",
    "et al_.  @xcite for dominating set on planar graphs , which was generalized by guo and niedermeier  @xcite to a family of problems on planar graphs .",
    "several algorithmic meta - theorems on kernelization have appeared in the last years , starting with the result of bodlaender _",
    "et al_.  @xcite on graphs of bounded genus .",
    "after that , similar results have been obtained on larger sparse graph classes , such as graphs excluding a minor  @xcite or a topological minor  @xcite .    typically , the above results guarantee the _ existence _ of linear or polynomial kernels on sparse graph classes for a number of problems satisfying some generic conditions but , mainly due to their generality , it is hard to derive from them _ constructive _ kernels with _",
    "explicit _ constants .",
    "the main reason behind this non - constructibility is that the proofs rely on a property of problems called _ finite integer index _ (",
    "fii ) that , roughly speaking , allows to replace large `` protrusions '' ( i.e. , large subgraphs with small boundary to the rest of the graph ) with `` equivalent '' subgraphs of constant size .",
    "this substitution procedure is known as _",
    "protrusion replacer _ , and while its _ existence _ has been proved , so far , there is no generic way to _ construct _ it . using the technology developed in  @xcite , there are cases where protrusion replacements can become constructive given the expressibility of the problem in counting monadic second order ( cmso ) logic .",
    "this approach is essentially based on extensions of courcelle s theorem  @xcite that , even when they offer constructibility , it is hard to extract from them any _ explicit constant _ that upper - bounds the size of the derived kernel .    * results and techniques .",
    "* in this article we tackle the above issues and make a step toward a fully constructive meta - kernelization theory on sparse graphs with explicit constants . for this",
    ", we essentially substitute the algorithmic power of cmso logic with that of dynamic programming on graphs of bounded decomposability ( i.e. , bounded treewidth ) .",
    "our approach provides a dynamic programming framework able to construct a protrusion replacer for a wide variety of problems .    loosely speaking , the framework that we present",
    "can be summarized as follows .",
    "first of all , we propose a general definition of a problem encoding for the tables of dynamic programming when solving parameterized problems on graphs of bounded treewidth . under this setting",
    ", we provide general conditions on whether such an encoding can yield a protrusion replacer .",
    "while our framework can also be seen as a possible formalization of dynamic programming , our purpose is to use it for constructing protrusion replacement algorithms and linear kernels whose size is explicitly determined .    in order to obtain an explicit linear kernel for a problem @xmath6 ,",
    "the main ingredient is to prove that when solving @xmath6 on graphs of bounded treewidth via dynamic programming , we can use tables such that the maximum difference between all the values that need to be stored is bounded by a function of the treewidth . for this",
    ", we prove in theorem  [ thm : protrusionreplacement ] that when the input graph excludes a fixed graph @xmath7 as a ( topological ) minor , this condition is sufficient for constructing an explicit protrusion replacer algorithm , i.e. , a polynomial - time algorithm that replaces a large protrusion with an equivalent one whose size can be bounded by an _ explicit _ constant .",
    "such a protrusion replacer can then be used , for instance , whenever it is possible to compute a linear protrusion decomposition of the input graph ( that is , an algorithm that partitions the graph into a part of size linear in @xmath8 and a set of @xmath8 protrusions ) . as there is a wealth of results for constructing such decompositions  @xcite , we can use them as a starting point and , by applying dynamic programming , obtain an explicit linear kernel for @xmath6 .",
    "we demonstrate the usefulness of this general strategy by providing the first explicit linear kernels for three distinct families of problems on sparse graph classes . on the one hand , for each integer @xmath9 , we provide a linear kernel for @xmath0-dominating set and @xmath0-scattered set on graphs excluding a fixed apex graph @xmath7 as a minor .",
    "moreover , for each finite family @xmath1 of connected graphs containing at least one planar graph , we provide a linear kernel for planar-@xmath1-deletion on graphs excluding a fixed graph @xmath7 as a ( topological ) minor - packing on graphs excluding a fixed graph @xmath7 as a minor .",
    "nevertheless , as this problem is not directly vertex - certifiable ( see definition  [ def : vertexcertifiable ] ) , for presenting it we should restate and extend many of the definitions and results given in section  [ sec : framework ] in order to deal with more general families of problems .",
    "therefore , we decided not to include this family of problems in this article . ] .",
    "we chose these families of problems as they are all tuned by a secondary parameter that is either the constant @xmath0 or the size of the graphs in the family @xmath10 .",
    "that way , we not only capture a wealth of parameterized problems , but we also make explicit the contribution of the secondary parameter in the size of the derived kernels .",
    "( we would like to note that the constants involved in the kernels for @xmath0-dominating set and @xmath0-scattered set ( resp .",
    "planar-@xmath1-deletion ) depend on the function @xmath11 ( resp .",
    "@xmath12 ) defined in proposition  [ prop : tw - contraction ] ( resp .",
    "proposition  [ prop : tw - minor ] ) in section  [ sec : prelim ] . )    * organization of the paper .",
    "* for the reader not familiar with the background used in previous work on this topic  @xcite , some preliminaries can be found in section  [ sec : prelim ] , including graph minors , parameterized problems , ( rooted ) tree decompositions , boundaried graphs , the canonical equivalence relation @xmath13 for a problem @xmath6 and an integer @xmath14 , fii , protrusions , and protrusion decompositions . in section",
    "[ sec : framework ] we introduce the basic definitions of our framework and present an explicit protrusion replacer .",
    "the next three sections are devoted to showing how to apply our methodology to various families of problems , namely , we focus on @xmath0-dominating set in section  [ sec : rdomset ] , on @xmath0-scattered set in section  [ sec : rscatset ] , and on planar-@xmath1-deletion in section  [ sec : planarfdeletion ] .",
    "finally , we conclude with some directions for further research in section  [ sec : further ] .",
    "* graphs and minors .",
    "* we use standard graph - theoretic notation ( see  @xcite for any undefined terminology ) . given a graph @xmath15 , we let @xmath16 denote its vertex set and @xmath17 its edge set . for  @xmath18 ,",
    "we let  @xmath19 $ ] denote the graph @xmath20 , where @xmath21 , and we define @xmath22 $ ] .",
    "the open ( resp . closed ) _",
    "neighborhood _ of a vertex @xmath23 is denoted by @xmath24 ( resp .",
    "@xmath25 $ ] ) , and more generally , for an integer @xmath26 , we denote by @xmath27 the set of vertices that are at distance at most @xmath0 from @xmath23 .",
    "the neighborhoods of a set of vertices @xmath28 are defined analogously .",
    "the _ distance _ between a vertex @xmath23 and a set of vertices @xmath28 is defined as @xmath29 , where @xmath30 denotes the usual distance .",
    "a graph @xmath31 is an _ apex graph _ if there exists @xmath32 such that @xmath33 is planar . given an edge  @xmath34 of a graph  @xmath15 , we let  @xmath35 denote the graph obtained from  @xmath15 by _ contracting _ the edge  @xmath36 , which amounts to deleting the endpoints of  @xmath36 , introducing a new vertex  @xmath37 , and making it adjacent to all vertices in @xmath38 .",
    "a _ minor _",
    "_ contraction _ ) of  @xmath15 is a graph obtained from a subgraph of  @xmath15 ( resp . from @xmath15 ) by contracting zero or more edges .",
    "a _ topological minor _ of  @xmath15 is a graph obtained from a subgraph of  @xmath15 by contracting zero or more edges , such that each edge that is contracted has at least one endpoint with degree at most two .",
    "a graph @xmath15 is _ @xmath7-(topological-)minor - free _ if @xmath15 does not contain @xmath7 as a ( topological ) minor .    * parameterized problems , kernels , and treewidth . *",
    "a _ parameterized graph problem _",
    "@xmath6 is a set of pairs @xmath39 , where @xmath15 is a graph and @xmath40 , such that for any two instances @xmath41 and @xmath42 with @xmath43 it holds that @xmath44 if and only if @xmath45 . if @xmath46 is a graph class , we define @xmath6 _ restricted to _ @xmath46 as @xmath47 a _ kernelization algorithm _ , or just _ kernel _ , for a parameterized graph problem @xmath6 is an algorithm that given an instance @xmath39 outputs , in time polynomial in @xmath48 , an instance @xmath49 of @xmath6 such that @xmath50 if and only if @xmath51 and @xmath52 , where  @xmath53 is some computable function .",
    "the function @xmath53 is called the _ size _ of the kernel .",
    "if @xmath54 or @xmath55 , we say that @xmath6 admits a _ polynomial kernel _ and a _ linear kernel _ , respectively .    given a graph  @xmath56 , a _ tree decomposition of @xmath15 _",
    "is an ordered pair @xmath57 , where  @xmath58 is a tree and such that the following hold :    1 .   @xmath59 ; 2 .   for every edge  @xmath60 in  @xmath15",
    ", there exists  @xmath61 such that  @xmath62 ; and 3 .   for each vertex  @xmath63 , the set of nodes  @xmath64 induces a subtree .",
    "the vertices of the tree  @xmath58 are usually referred to as _ nodes _ and the sets  @xmath65 are called _",
    "bags_. the _ width _ of a tree decomposition is the size of a largest bag minus one .",
    "the _ treewidth _ of  @xmath15 , denoted  @xmath66 , is the smallest width of a tree decomposition of  @xmath15 . a _ rooted tree decomposition _",
    "is a tree decomposition @xmath57 in which a distinguished node @xmath67 has been selected as the _",
    "root_. the bag @xmath68 is called the _ root - bag_. note that the root defines a child / parent relation between every pair of adjacent nodes in @xmath58 , and ancestors / descendants in the usual way .",
    "a node without children is called a _",
    "leaf_.    for the definition of _ nice tree decompositions _ , we refer to  @xcite .",
    "a set of vertices @xmath69 of a graph @xmath15 is called a _ treewidth - modulator _ if @xmath70 , where @xmath14 is some fixed constant .",
    "given a bag @xmath71 of a rooted tree decomposition with tree @xmath58 , we denote by @xmath72 the subtree rooted at the node corresponding to bag @xmath71 , and by @xmath73 $ ] the subgraph of @xmath15 induced by the vertices appearing in the bags corresponding to the nodes of @xmath72 .",
    "if a bag @xmath71 is associated with a node @xmath74 of @xmath58 , we may interchangeably use @xmath75 or @xmath76 .    * boundaried graphs and canonical equivalence relation . *",
    "the following two definitions are taken from  @xcite .",
    "[ def : boundaried ] a _ boundaried graph _ is a graph @xmath15 with a set @xmath77 of distinguished vertices and an injective labeling @xmath78 . the set @xmath71 is called the _ boundary _ of @xmath15 and the vertices in @xmath71 are called _",
    "boundary vertices_. given a boundaried graph @xmath15 , we denote its boundary by @xmath79 , we denote its labeling by @xmath80 , and we define its label set by @xmath81 .",
    "we say that a boundaried graph is a _",
    "@xmath14-boundaried graph _ if @xmath82 .",
    "note that a @xmath83-boundaried graph is just a graph with no boundary .",
    "[ def : gluing ] let @xmath84 and @xmath85 be two boundaried graphs .",
    "we denote by @xmath86 the graph obtained by taking the disjoint union of @xmath84 and @xmath85 and identifying vertices with the same label of the boundaries of @xmath84 and @xmath85 . in @xmath86",
    "there is an edge between two labeled vertices if there is an edge between them in @xmath84 or in @xmath85 .    in the above definition , after identifying vertices with the same label , we may consider the resulting graph as a boundaried graph or not , depending on whether we need the labels for further gluing operations . following  @xcite",
    ", we introduce a canonical equivalence relation on boundaried graphs .",
    "[ def : canonicalequivrelation ] let @xmath6 be a parameterized graph problem and let @xmath87 .",
    "given two @xmath14-boundaried graphs @xmath84 and",
    "@xmath85 , we say that @xmath88 if @xmath89 and there exists a transposition constant @xmath90 such that for every @xmath14-boundaried graph @xmath91 and every @xmath92 , it holds that @xmath93 if and only if @xmath94 .",
    "we define in section  [ sec : framework ] another equivalence relation on boundaried graphs that refines this canonical one ( cf .",
    "definitions  [ def : equivalencerelation ] and  [ def : equivalencerelation2 ] ) , and that will allow us to perform a constructive protrusion replacement with explicit bounds .    the notion of _ finite integer index _ was originally defined by bodlaender and van antwerpen - de fluiter  bvf01,vanf97 .",
    "we would like to note that fii does not play any role in the framework that we present for constructing explicit kernels , but we present its definition for completeness , as we will sometimes refer to it throughout the article .",
    "[ def : fii ] a parameterized graph problem @xmath6 has _ finite integer index _ ( _ fii _ for short ) if for every positive integer @xmath14 , the equivalence relation @xmath13 has finite index .    * protrusions and protrusion decompositions . * given a graph  @xmath56 and a set  @xmath95 , we define  @xmath96 as the vertices in  @xmath97 that have a neighbor in  @xmath98 . a set  @xmath99 is a _ @xmath14-protrusion _ if @xmath100 and @xmath101 ) { \\leqslant}t-1 $ ] .",
    "we would like to note that a @xmath14-protrusion @xmath97 can be naturally seen as a @xmath14-boundaried graph by arbitrarily assigning labels to the vertices in @xmath96 . in this case",
    ", it clearly holds that @xmath102 .",
    "note also that if @xmath15 is a @xmath14-boundaried graph of treewidth at most @xmath103 , we may assume that the boundary vertices are contained in any specified bag of a tree decomposition , by increasing the width of the given tree decomposition to at most @xmath104 .",
    "an @xmath105_-protrusion decomposition _ of a graph @xmath15 is a partition @xmath106 of @xmath16 such that :    1 .   for every @xmath107 , @xmath108",
    "; 2 .   @xmath109 ; and 3 .   for every @xmath107",
    ", @xmath110 is a @xmath14-protrusion of @xmath15 .",
    "when @xmath15 is the input of a parameterized graph problem with parameter @xmath3 , we say that an @xmath105-protrusion decomposition of @xmath15 is _ linear _ whenever @xmath111 .",
    "* large treewidth and grid minors . * in our applications in sections",
    "[ sec : rdomset ] , [ sec : rscatset ] , and [ sec : planarfdeletion ] we will need the following results , which state a _ linear _ relation between the treewidth and certain grid - like graphs that can be found as minors or contractions in a graph that excludes some fixed ( apex ) graph as a minor .    [ prop : tw - minor ] there is a function @xmath112 such that for every @xmath113-vertex graph @xmath7 and every positive integer @xmath0 , every @xmath7-minor - free graph with treewidth at least @xmath114 , contains an @xmath115-grid as a minor .",
    "before we state the next proposition , we need to define a grid - like graph that is suitable for a contraction counterpart of proposition  [ prop : tw - minor ] .",
    "let @xmath116 ( @xmath117 ) be the graph obtained from the @xmath115-grid by triangulating internal faces of the @xmath115-grid such that all internal vertices become of degree @xmath118 , all non - corner external vertices are of degree 4 , and one corner of degree 2 is joined by edges with all vertices of the external face ( the _ corners _ are the vertices that in the underlying grid have degree 2 ) .",
    "the graph @xmath119 is shown in fig .  [ fig - gamma - k ] .",
    "[ prop : tw - contraction ] there is a function @xmath120 such that for every @xmath113-vertex apex graph @xmath7 and every positive integer @xmath0 , every @xmath7-minor - free graph with treewidth at least @xmath121 , contains the graph @xmath116 as a contraction .",
    "propositions  [ prop : tw - minor ] and  [ prop : tw - contraction ] have been the main tools for developing bidimensionality theory for kernelization  @xcite .",
    "the best known estimation for  function @xmath12 has been given by kawarabayashi and kobayashi in  @xcite and is @xmath122 . to our knowledge ,",
    "no reasonable estimation for the function @xmath123 is known up to now .",
    "the two functions @xmath124 and @xmath123 will appear in the upper bounds on the size of the kernels presented in sections  [ sec : rdomset ] , [ sec : rscatset ] , and [ sec : planarfdeletion ] . any improvement on these functions will directly translate to the sizes of our kernels .",
    "in this section we present our strategy to construct an explicit protrusion replacer via dynamic programming . for a positive integer @xmath14 , we define @xmath125 as the class of all @xmath14-boundaried graphs , and we define @xmath126 as the class of all @xmath14-boundaried graphs of treewidth at most @xmath103 that have a rooted tree decomposition with all boundary vertices contained in the root - bag could be avoided by allowing the width of the tree decompositions of the graphs in @xmath126 to be at most @xmath104 , such that all boundary vertices could be added to all bags of any tree decomposition . ] .",
    "note that it holds clearly that @xmath127 .",
    "we will restrict ourselves to parameterized graph problems such that a solution can be certified by a subset of vertices .",
    "[ def : vertexcertifiable ] a parameterized graph problem @xmath6 is called _ vertex - certifiable _ if there exists a language @xmath128 ( called _ certifying language for @xmath6 _ ) defined on pairs @xmath129 , where @xmath15 is a graph and @xmath130 , such that @xmath39 is a yes - instance of @xmath6 if and only if there exists a subset @xmath130 with @xmath131 ( or @xmath132 , depending on the problem ) such that @xmath133 .",
    "many graph problems are vertex - certifiable , like @xmath0-dominating set , feedback vertex set , or treewidth-@xmath14 vertex deletion .",
    "this section is structured as follows . in subsection",
    "[ sec : encoders ] we define the notion of encoder , the main object that will allow us to formalize in an abstract way the tables of dynamic programming . in subsection",
    "[ sec : equivalencerelations ] we use encoders to define an equivalence relation on graphs in @xmath134 that , under some natural technical conditions , will be a _ refinement _ of the canonical equivalence relation defined by a problem @xmath6 ( see definition  [ def : canonicalequivrelation ] in section  [ sec : prelim ] ) .",
    "this refined equivalence relation allows us to provide an explicit upper bound on the size of its representatives ( lemma  [ lem : finitesize ] ) , as well as a linear - time algorithm to find them ( lemma  [ lem : compute ] ) . in subsection",
    "[ sec : explicitprotrusionreplacer ] we use the previous ingredients to present an explicit protrusion replacement rule ( theorem  [ thm : protrusionreplacement ] ) , which replaces a large enough protrusion with a bounded - size representative from its equivalence class , in such a way that the parameter does not increase .      the dominating set problem , as a vertex - certifiable problem ,",
    "will be used hereafter as a running example to particularize our general framework and definitions .",
    "let us start with a description of dynamic programming tables for dominating set on graphs of bounded treewidth , which will illustrate the final purpose of the definitions stated below .",
    "[ example : dominatingset ] let @xmath71 be a bag of a rooted tree decomposition @xmath135 of width @xmath103 of a graph @xmath136 .",
    "the dynamic programming ( dp ) tables for dominating set can be defined as follows .",
    "the entries of the dp - table for @xmath71 are indexed by the set of tuples @xmath137 , so - called _ encodings_. as detailed below , the symbol 0 stands for vertices in the ( partial ) dominating set , the symbol @xmath138 for vertices that are already dominated , and @xmath138 for vertices with no constraints .",
    "more precisely , the coordinates of each @xmath139-tuple are in one - to - one correspondence with the vertices of @xmath71 . for a vertex @xmath140 ,",
    "we denote by @xmath141 its corresponding coordinate in the encoding @xmath142 .",
    "a subset @xmath143 is a _ partial dominating set satisfying _",
    "@xmath142 if the following conditions are satisfied :    * @xmath144 , @xmath145 ; and * @xmath146 : @xmath147 @xmath148 @xmath149 , and @xmath150 @xmath148 @xmath145 .",
    "observe that if @xmath28 is a partial dominating set satisfying @xmath142 , then @xmath151 , but @xmath28 may also contain vertices with @xmath152 .",
    "likewise , the vertices that are not ( yet ) dominated by @xmath28 are contained in the set @xmath153 .",
    "the following definition considers the tables of dynamic programming in an abstract way .",
    "[ def : encoder ] an _ encoder _ @xmath154 is a pair @xmath155 where    * @xmath156 is a function that , for each ( possibly empty ) finite subset @xmath157 , outputs a ( possibly empty ) finite set @xmath158 of strings over some alphabet .",
    "each @xmath159 is called a _ @xmath156-encoding _ of @xmath2 ; and *",
    "@xmath160 is a computable language whose strings encode triples @xmath161 , where @xmath15 is a boundaried graph , @xmath130 , and @xmath162 . if @xmath163 , we say that @xmath28 _ satisfies _ the @xmath156-encoding @xmath142 .",
    "as it will become clear with the running example , the set @xmath2 represents the labels from a bag , @xmath158 represents the possible configurations of the vertices in the bag , and @xmath164 contains triples that correspond to solutions to these configurations .",
    "each rooted graph @xmath75 can be naturally viewed as a @xmath139-boundaried graph such that @xmath165 with @xmath166 .",
    "let @xmath167 be the encoder described above for dominating set .",
    "the tables of the dynamic programming algorithm to solve dominating set are obtained by assigning to every @xmath168-encoding ( that is , dp - table entry ) @xmath169 , the size of a minimum partial dominating set satisfying @xmath142 , or @xmath170 if such a set of vertices does not exist .",
    "this defines a function @xmath171 .",
    "observe that if @xmath172 , then the value assigned to the encodings in @xmath173 is indeed the size of a minimum dominating set of @xmath75 .    in the remainder of this subsection we will state several definitions for minimization problems , and we will restate them for maximization problems whenever some change is needed .",
    "for a general minimization problem @xmath6 , we will only be interested in encoders that permit to solve @xmath6 via dynamic programming .",
    "more formally , we define a @xmath6-encoder and the values assigned to the encodings as follows .",
    "[ def : piencoder ] let @xmath6 be a vertex - certifiable minimization problem .    * an encoder @xmath174 is a _",
    "@xmath6-encoder _ if @xmath175 consists of a single @xmath156-encoding , namely @xmath176 , such that for every @xmath83-boundaried graph @xmath15 and every @xmath130 , @xmath177 if and only if @xmath133 .",
    "* let @xmath15 be a @xmath14-boundaried graph with @xmath178 .",
    "we define the function @xmath179 as @xmath180 + in equation  ( [ eq : femin ] ) , if such a set @xmath28 does not exist , we set @xmath181 .",
    "we define @xmath182 .",
    "condition  ( i ) in definition  [ def : piencoder ] guarantees that , when the considered graph @xmath15 has no boundary , the language of the encoder is able to _ certify _ a solution of problem @xmath6 . in other words",
    ", we ask that the set @xmath183 is a _ certifying language _ for @xmath6 .",
    "observe that for a @xmath83-boundaried graph @xmath15 , the function @xmath184 outputs the minimum size of a set @xmath28 such that @xmath185 .    for encoders @xmath186 that will be associated with problems where the objective is to find a set of vertices of size _ at least _",
    "some value , the corresponding function @xmath187 is defined as @xmath188 similarly , in equation  ( [ eq : femax ] ) , if such a set @xmath28 does not exist , we set @xmath189 .",
    "we define @xmath190 .",
    "the following definition provides a way to control the number of possible distinct values assigned to encodings .",
    "this property will play a similar role to fii or _",
    "monotonicity _ in previous work  @xcite .",
    "[ def : thin ] an encoder @xmath191 is _ @xmath53-confined _ if there exists a function @xmath192 such that for any @xmath14-boundaried graph @xmath15 with @xmath193 it holds that either @xmath194 or @xmath195    see fig .",
    "[ fig : illustrationencoding ] for a schematic illustration of a confined encoder . in this figure",
    ", each column of the table corresponds to a @xmath156-encoder @xmath142 , which is filled with the value @xmath196 .    -confined encoding.[fig : illustrationencoding],scaledwidth=80.0% ]    it is easy to observe that the encoder @xmath197 described above is @xmath53-confined for @xmath198 .",
    "indeed , let @xmath15 be a @xmath14-boundaried graph ( corresponding to the graph @xmath75 considered before ) with @xmath178 .",
    "consider an arbitrary encoding @xmath199 and the encoding @xmath200 satisfying @xmath201 for every @xmath202 .",
    "let @xmath203 be a minimum - sized partial dominating set satisfying @xmath204 , i.e. , such that @xmath205 .",
    "observe that @xmath206 also satisfies @xmath142 , i.e. , @xmath207 .",
    "it then follows that @xmath208 .",
    "moreover , let @xmath209 be a minimum - sized partial dominating set satisfying @xmath142 , i.e. , such that @xmath210 . then note that @xmath204 is satisfied by the set @xmath211 , so we have that for every encoding @xmath142 , @xmath212 .",
    "it follows that @xmath213 , proving that the encoder is indeed @xmath53-confined .",
    "for some problems and encoders , we may need to `` force '' the confinement of an encoder @xmath154 that may not be confined according to definition  [ def : thin ] , while still preserving its usefulness for dynamic programming , in the sense that no relevant information is removed from the tables ( for example , see the encoder for @xmath0-scattered set in subsection  [ sec : description - encoder - rscatset ] ) . to this end ,",
    "given a function @xmath214 , we define the function @xmath215 as    @xmath216    intuitively , one shall think as the function @xmath217 as a `` compressed '' version of the function @xmath218 , which stores only the values that are useful for performing dynamic programming .    for encoders @xmath186",
    "associated with maximization problems , given a function @xmath214 , we define the function @xmath219 as    @xmath220      an encoder @xmath191 together with a function @xmath214 define an equivalence relation @xmath221 on @xmath14-boundaried graphs as follows .",
    "( in fact , in our applications we will use only this equivalence relation on graphs in @xmath126 , but for technical reasons we need to define it on general @xmath14-boundaried graphs . )",
    "[ def : equivalencerelation ] let @xmath191 be an encoder , let @xmath222 , and let @xmath223 .",
    "we say that @xmath224 if and only if @xmath225 and there exists an integer @xmath226 , depending only on @xmath84 and @xmath85 , such that for every @xmath156-encoding @xmath227 it holds that @xmath228 if we restrict the graphs @xmath229 to belong to @xmath126 , then the corresponding equivalence relation , which is a restriction of @xmath221 , is denoted by @xmath230 .",
    "note that if there exists @xmath227 such that @xmath231 , then the integer @xmath226 satisfying equation  ( [ eq : equivtruncation ] ) is unique , otherwise every integer @xmath226 satisfies equation  ( [ eq : equivtruncation ] ) .",
    "we define the following function @xmath232 , which is called , following the terminology from bodlaender _",
    "et al_.  bfl+09 , the _ transposition function _ for the equivalence relation @xmath221 .",
    "@xmath233    note that we can consider the restriction of the function @xmath234 to couples of graphs in @xmath134 , defined by using the restricted equivalence relation @xmath230 .",
    "if we are dealing with a problem defined on a graph class @xmath235 , the protrusion replacement rule has to preserve the class @xmath236 , as otherwise we would obtain a _",
    "bikernel _ instead of a kernel .",
    "that is , we need to make sure that , when replacing a graph in @xmath237 or in @xmath238 with one of its representatives , we do not produce a graph that does not belong to @xmath235 anymore . to this end",
    ", we define an equivalence relation @xmath239 ( resp .",
    "@xmath240 ) on graphs in @xmath237 ( resp .",
    "@xmath238 ) , which refines the equivalence relation @xmath221 ( resp .",
    "@xmath230 ) of definition  [ def : equivalencerelation ] .",
    "[ def : equivalencerelation2 ] let @xmath236 be a class of graphs and let @xmath241 .",
    "* @xmath242 if and only if for any graph @xmath243 , @xmath244 if and only if @xmath245 .",
    "* @xmath246 if and only if @xmath224 and @xmath242 .",
    "if we restrict the graphs @xmath229 to belong to @xmath126 ( but still @xmath243 ) , then the corresponding equivalence relation , which is a restriction of @xmath239 , is denoted by @xmath240 .",
    "it is well - known by bchi s theorem that regular languages are precisely those definable in monadic second order logic ( mso logic ) . by myhill - nerode s theorem",
    ", it follows that if the membership in a graph class @xmath236 can be expressed in mso logic , then the equivalence relation @xmath247 has a finite number of equivalence classes ( see for instance  @xcite ) .",
    "however , we do not have in general an explicit upper bound on the number of equivalence classes of @xmath247 , henceforth denoted by @xmath248 . fortunately , in the context of our applications in sections  [ sec : rdomset ] ,  [ sec : rscatset ] , and  [ sec : planarfdeletion ] , where @xmath236 will be a class of graphs that exclude some fixed graph on @xmath113 vertices as a ( topological ) minor in mso logic , whereas in previous work  @xcite what is used in the expressibility in cmso logic of the _ problems _ defined on a graph class . ] , this will always be possible , and in this case it holds that @xmath249 .    for an encoder @xmath174 , we let @xmath250 , where @xmath251 denotes the number of @xmath156-encodings in @xmath252 .",
    "the following lemma gives an upper bound on the number of equivalence classes of @xmath239 , which depends also on @xmath248 .",
    "[ lem : finite ] let @xmath235 be a graph class whose membership can be expressed in mso logic . for any encoder @xmath191 , any function @xmath222 , and any positive integer @xmath14 , the equivalence relation @xmath239 has finite index .",
    "more precisely , the number of equivalence classes of @xmath239 is at most @xmath253 . in particular ,",
    "the number of equivalence classes of @xmath240 is at most @xmath254 as well .",
    "let us first show that the equivalence relation @xmath221 has finite index .",
    "indeed , let @xmath255 . by definition , we have that for any graph @xmath256 with @xmath178 , the function @xmath217 can take at most @xmath257 distinct values ( @xmath258 finite values and possibly the value @xmath170 ) .",
    "therefore , it follows that the number of equivalence classes of @xmath221 containing all graphs @xmath15 in @xmath259 with @xmath178 is at most @xmath260 .",
    "as the number of subsets of @xmath261 is @xmath262 , we deduce that the overall number of equivalence classes of @xmath221 is at most @xmath263 .",
    "finally , since the equivalence relation @xmath239 is the cartesian product of the equivalence relations @xmath221 and @xmath247 , the result follows from the fact that @xmath235 can be expressed in mso logic .    in order for an encoding @xmath191 and a function @xmath53 to be useful for performing dynamic programming on graphs in @xmath126 that belong to a graph class @xmath236 ( recall that this is our final objective ) , we introduce the following definition , which captures the natural fact that the tables of a dynamic programming algorithm should depend exclusively on the tables of the descendants in a rooted tree decomposition . before moving to the definition",
    ", we note that given a graph @xmath264 and a rooted tree decomposition @xmath135 of @xmath15 of width at most @xmath103 such that @xmath79 is contained in the root - bag of @xmath135 , the labels of @xmath79 can be propagated in a natural way to all bags of @xmath135 by introducing , removing , and shifting labels appropriately .",
    "therefore , for any node @xmath74 of @xmath58 , the graph @xmath76 can be naturally seen as a graph in @xmath134 .",
    "( a brief discussion can be found in the proof of lemma  [ lem : compute ] , and we refer to  @xcite for more details . )    again , for technical reasons ( namely , for the proof of lemma  [ lem : characterize ] ) , we need to state the definition below for graphs in @xmath259 , even if we will only use it for graphs in @xmath134 .",
    "[ def : dpfriendly ] an equivalence relation @xmath239 is _ dp - friendly _ if for any graph @xmath256 with @xmath265 and any separator @xmath266 with @xmath267 , the following holds : let @xmath75 be any collection of connected components of @xmath268 such that @xmath269 . considering @xmath75 as a @xmath14-boundaried graph with boundary @xmath71 , let @xmath270 be the @xmath14-boundaried graph with @xmath271 obtained from @xmath15 by replacing the subgraph @xmath75 with a @xmath14-boundaried graph @xmath272 such that @xmath273",
    ". then @xmath270 satisfies the following conditions :    * @xmath274 ; and * @xmath275 .",
    "note that if an equivalence relation @xmath239 is dp - friendly , then by definition its restriction @xmath240 to graphs in @xmath134 is dp - friendly as well .",
    "we would like to note that in the above definition we have used the notation @xmath75 because in all applications the subgraph to be replaced will correspond to a rooted subtree in a tree decomposition of a graph @xmath15 . with this in mind ,",
    "the condition @xmath269 in definition  [ def : dpfriendly ] corresponds to the fact that the boundary @xmath276 will correspond in the applications to the vertices in the root - bag of a rooted tree decomposition of @xmath15 .    in definition  [ def : dpfriendly ] , as well as in the remainder of the article , when we _",
    "replace _ the graph @xmath75 with the graph @xmath272 , we do _ not _ remove from @xmath15 any of the edges with both endvertices in the boundary of @xmath75 .",
    "that is , @xmath277 .",
    "recall that for the protrusion replacement to be valid for a problem @xmath6 , the equivalence relation @xmath240 needs to be a refinement of the canonical equivalence relation @xmath13 ( note that this implies , in particular , that if @xmath240 has finite index , then @xmath6 has fii ) .",
    "the next lemma states a sufficient condition for this property , and furthermore it gives the value of the transposition constant @xmath278 , which will be needed in order to update the parameter after the replacement .",
    "[ lem : characterize ] let @xmath6 be a vertex - certifiable problem . if @xmath191 is a @xmath6-encoder and @xmath239 is a dp - friendly equivalence relation , then for any two graphs @xmath279 such that @xmath280 , it holds that @xmath88 and @xmath281 . in particular ,",
    "if @xmath191 is a @xmath6-encoder and @xmath239 is dp - friendly , then for any two graphs @xmath282 such that @xmath283 , it holds that @xmath88 and @xmath281 .",
    "assume without loss of generality that @xmath6 is a minimization problem , and let @xmath284 .",
    "we need to prove that for any @xmath14-boundaried graph @xmath7 and any integer @xmath3 , @xmath285 if and only if @xmath286 .",
    "suppose that @xmath285 ( by symmetry the same arguments apply starting with @xmath85 ) .",
    "this means that there exists @xmath287 with @xmath288 such that @xmath289 . and",
    "since @xmath290 is a @xmath83-boundaried graph and @xmath191 is a @xmath6-encoder , we have that @xmath291 , where @xmath292 .",
    "this implies that @xmath293 as @xmath239 is dp - friendly and @xmath280 , it follows that @xmath294 and that @xmath295 .",
    "since @xmath296 is also a @xmath83-boundaried graph , the latter property and equation  ( [ eq : lemmacharacterize ] ) imply that @xmath297 from equation  ( [ eq : lemmacharacterize2 ] ) it follows that there exists @xmath298 with @xmath299 such that @xmath300 .",
    "since @xmath296 is a @xmath83-boundaried graph and @xmath191 is a @xmath6-encoder , this implies that @xmath301 , which in turn implies that @xmath286 , as we wanted to prove .",
    "note that , in particular , lemma  [ lem : characterize ] implies that under the same hypothesis , for graphs in @xmath134 the equivalence relation @xmath240 refines the canonical equivalence relation @xmath13 .    in the following ,",
    "we will only deal with equivalence relations @xmath240 defined on graphs in @xmath134 , and therefore we will only use this particular case of lemma  [ lem : characterize ] .",
    "the reason why we restrict ourselves to graphs in @xmath134 is that , while a dp - friendly equivalence relation refines the canonical one for all graphs in @xmath259 ( lemma  [ lem : characterize ] ) , we need _ bounded treewidth _ in order to bound the _ size _ of the progressive representatives ( lemma  [ lem : finitesize ] ) and to explicitly _ compute _ these representatives for performing the replacement ( lemma  [ lem : compute ] )",
    ".    the following definition will be important to guarantee that , when applying our protrusion replacement rule , the parameter of the problem under consideration does not increase .",
    "[ def : progressive ] let @xmath302 be some equivalence class of @xmath240 and let @xmath303 .",
    "we say that @xmath15 is a _ progressive representative _ of @xmath302 if for any graph @xmath304 it holds that @xmath305 .    in the next lemma we provide an upper bound on the size of a smallest _ progressive _ representative of any equivalence class of @xmath240 .",
    "[ lem : finitesize ] let @xmath235 be a graph class whose membership can be expressed in mso logic .",
    "for any encoder @xmath191 , any function @xmath222 , and any @xmath306 such that @xmath239 is dp - friendly , every equivalence class of @xmath240 has a progressive representative of size at most @xmath307 , where @xmath254 is the function defined in lemma  [ lem : finite ] .",
    "let @xmath302 be an arbitrary equivalence class of @xmath240 , and we want to prove that there exists in @xmath302 a progressive representative of the desired size .",
    "let us first argue that @xmath302 contains some progressive representative .",
    "we construct an ( infinite ) directed graph @xmath308 as follows .",
    "there is a vertex in @xmath308 for every graph in @xmath302 , and for any two vertices @xmath309 , corresponding to two graphs @xmath310 respectively , there is an arc from @xmath311 to @xmath312 if and only if @xmath313 .",
    "we want to prove that @xmath308 has a sink , that is , a vertex with no outgoing arc , which by construction is equivalent to the existence of a progressive representative in @xmath302 .",
    "indeed , let @xmath23 be an arbitrary vertex of @xmath308 , and grow greedily a directed path @xmath314 starting from @xmath23 .",
    "because of the transitivity of the equivalence relation @xmath240 and by construction of @xmath308 , it follows that @xmath308 does not contain any finite cycle , so @xmath314 can not visit vertex @xmath23 again . on the other hand ,",
    "since the function @xmath218 takes only positive values ( except possibly for the value @xmath315 ) , it follows that there are no arbitrarily long directed paths in @xmath308 starting from any fixed vertex , so in particular the path @xmath314 must be finite , and therefore the last vertex in @xmath314 is necessarily a sink .",
    "( note that for any two graphs @xmath310 such that their corresponding vertices @xmath309 are sinks , it holds by construction of @xmath308 that @xmath316 . )",
    "now let @xmath317 be a progressive representative of @xmath302 with minimum number of vertices .",
    "we claim that @xmath15 has size at most @xmath318 .",
    "( we would like to stress that at this stage we only need to care about the _ existence _ of such representative @xmath15 , and not about how to _ compute _ it . ) indeed , let @xmath319 be a nice rooted tree decomposition of @xmath15 of width at most @xmath103 such that @xmath79 is contained in the root - bag ( such a nice tree decomposition exists by  @xcite ) , and let @xmath0 be the root of @xmath58 .",
    "we first claim that for any node @xmath74 of @xmath58 , the graph @xmath76 is a progressive representative of its equivalence class with respect to @xmath240 , namely @xmath320 .",
    "indeed , assume that it is not the case , and let @xmath7 be a progressive representative of @xmath320 , which exists by the discussion in the first paragraph of the proof . since @xmath7 is progressive and @xmath76 is not , @xmath321 .",
    "let @xmath322 be the graph obtained from @xmath15 by replacing @xmath76 with @xmath7 .",
    "since @xmath239 is dp - friendly , it follows that @xmath323 and that @xmath324 , contradicting the fact that @xmath15 is a progressive representative of the equivalence class @xmath302 .",
    "we now claim that for any two nodes @xmath325 lying on a path from @xmath0 to a leaf of @xmath58 , it holds that @xmath326 . indeed ,",
    "assume for contradiction that there are two nodes @xmath325 lying on a path from @xmath0 to a leaf of @xmath58 such that @xmath327 .",
    "let @xmath320 be the equivalence class of @xmath76 and @xmath328 with respect to @xmath240 .",
    "by the previous claim , it follows that both @xmath76 and @xmath328 are progressive representatives of @xmath320 , and therefore it holds that @xmath329 .",
    "suppose without loss of generality that @xmath330 ( that is , @xmath328 is a strict subgraph of @xmath76 ) , and let @xmath270 be the graph obtained from @xmath15 by replacing @xmath76 with @xmath328 .",
    "again , since @xmath239 is dp - friendly , it follows that @xmath331 and that @xmath332 .",
    "therefore , @xmath270 is a progressive representative of @xmath302 with @xmath333 , contradicting the minimality of @xmath334 .",
    "finally , since for any two nodes @xmath325 lying on a path from @xmath0 to a leaf of @xmath58 we have that @xmath326 , it follows that the height of @xmath58 is at most the number of equivalence classes of @xmath240 , which is at most @xmath254 by lemma  [ lem : finite ] .",
    "since @xmath58 is a binary tree , we have that @xmath335 .",
    "finally , since @xmath336 , it follows that @xmath337 , as we wanted to prove .",
    "the next lemma states that if one is given an upper bound on the size of the progressive representatives of an equivalence relation defined on @xmath14-protrusions ( that is , on graphs in @xmath134)-protrusions and graphs in @xmath134 , as protrusions are defined as subsets of vertices of a graph . nevertheless , this will not cause any confusion .",
    "] , then a _ small _ progressive representative of a @xmath14-protrusion can be explicitly calculated in linear time . in other words",
    ", it provides a generic and constructive way to perform a dynamic programming procedure to replace protrusions , without needing to deal with the particularities of each encoder in order to compute the tables .",
    "its proof uses some ideas taken from  @xcite .",
    "[ lem : compute ] let @xmath235 be a graph class , let @xmath191 be an encoder , let @xmath222 , and let @xmath306 such that @xmath239 is dp - friendly .",
    "assume that we are given an upper bound @xmath338 on the size of a smallest progressive representative of any equivalence class of @xmath240 , with @xmath339 .",
    "then , given an @xmath340-vertex @xmath14-protrusion @xmath15 inside some graph , we can output in time @xmath341 a @xmath14-protrusion @xmath7 inside the same graph of size at most @xmath338 such that @xmath342 and the corresponding transposition constant @xmath343 with @xmath344 , where the hidden constant in the `` @xmath345 '' notation depends only on @xmath346 , and @xmath14 .",
    "let @xmath347 be the given encoder .",
    "we start by generating a repository @xmath348 containing all the graphs in @xmath134 with at most @xmath349 vertices .",
    "such a set of graphs , as well as a rooted nice tree decomposition of width at most @xmath103 of each of them , can be clearly generated in time depending only on @xmath338 and @xmath14 . by assumption ,",
    "the size of a smallest progressive representative of any equivalence class of @xmath240 is at most @xmath338 , so @xmath348 contains a progressive representative of any equivalence class of @xmath240 with at most @xmath338 vertices .",
    "we now partition the graphs in @xmath348 into equivalence classes of @xmath240 as follows . for each graph @xmath350 and each @xmath351-encoding @xmath162 ,",
    "as @xmath160 is a computable language , we can compute the value @xmath352 in time depending only on @xmath353 and @xmath338 .",
    "therefore , for any two graphs @xmath354 , we can decide in time depending only on @xmath355 , and @xmath236 whether @xmath356 , and if this is the case , we can compute the transposition constant @xmath357 within the same running time .    given a @xmath14-protrusion @xmath15 on @xmath340 vertices with boundary @xmath79 , we first compute a rooted nice tree decomposition @xmath319 of @xmath15 such that @xmath79 is contained in the root bag in time @xmath358 , by using the linear - time algorithm of bodlaender  @xcite . such a @xmath14-protrusion @xmath15 equipped with a tree decomposition can be naturally seen as a graph in @xmath134 by assigning distinct labels from @xmath261 to the vertices in the root - bag .",
    "these labels from @xmath261 can be transferred to the vertices in all the bags of @xmath319 by performing a standard shifting procedure when a vertex is introduced or removed from the nice tree decomposition ( see  @xcite for more details ) . therefore , each node @xmath61 defines in a natural way a graph @xmath359 in @xmath134 with its associated rooted nice tree decomposition .",
    "let us now proceed to the description of the replacement algorithm .",
    "we process the bags of @xmath319 in a bottom - up way until we encounter the first node @xmath74 in @xmath360 such that @xmath361 .",
    "( note that as @xmath319 is a nice tree decomposition , when processing the bags in a bottom - up way , at most one new vertex is introduced at every step , and recall that by hypothesis @xmath362 . )",
    "let @xmath302 be the equivalence class of @xmath76 according to @xmath240 .",
    "as @xmath361 , the graph @xmath76 is contained in the repository @xmath348 , so in constant time we can find in @xmath348 a progressive representative @xmath363 of @xmath302 with at most @xmath338 vertices and the corresponding transposition constant @xmath364 , where the inequality holds because @xmath363 is a progressive representative .",
    "let @xmath270 be the graph obtained from @xmath15 by replacing @xmath76 with @xmath363 , so we have that @xmath333 .",
    "( note that this replacement operation directly yields a rooted nice tree decomposition of width at most @xmath103 of @xmath270 . )",
    "since @xmath239 is dp - friendly , it follows that @xmath331 and that @xmath365 .",
    "we recursively apply this replacement procedure on the resulting graph until we eventually obtain a @xmath14-protrusion @xmath7 with at most @xmath338 vertices such that @xmath342 .",
    "the corresponding transposition constant @xmath343 can be easily computed by summing up all the transposition constants given by each of the performed replacements .",
    "since each of these replacements introduces a progressive representative , we have that @xmath344 . as we can assume that the total number of nodes in a nice tree decomposition of @xmath15 is @xmath341  ( * ? ? ?",
    "* lemma 13.1.2 ) , the overall running time of the algorithm is @xmath341 , where the constant hidden in the `` @xmath345 '' notation depends indeed exclusively on @xmath346 , and @xmath14 .",
    "we are now ready to piece everything together and state our main technical result , which can be interpreted as a generic _ constructive _ way of performing protrusion replacement with _ explicit _ size bounds . for our algorithms to be fully constructive , we restrict @xmath235 to be the class of graphs that exclude some fixed graph @xmath7 as a ( topological ) minor .",
    "[ thm : protrusionreplacement ] let @xmath7 be a fixed graph and let @xmath235 be the class of graphs that exclude @xmath7 as a ( topological ) minor .",
    "let @xmath6 be a vertex - certifiable parameterized graph problem defined on @xmath235 , and suppose that we are given a @xmath6-encoder @xmath191 , a function @xmath214 , and an integer @xmath306 such that @xmath239 is dp - friendly .",
    "then , given an input graph @xmath39 and a @xmath14-protrusion @xmath366 in @xmath15 , we can compute in time @xmath367 an equivalent instance @xmath368 , where @xmath369 and @xmath370 is a @xmath14-protrusion with @xmath371 , where @xmath372 is the function defined in lemma  [ lem : finitesize ] .    by lemma  [ lem : finite ] , the number of equivalence classes of the equivalence relation @xmath240 is finite , and by lemma  [ lem : finitesize ] the size of a smallest progressive representative of any equivalence class of @xmath240 is at most @xmath372 .",
    "therefore , we can apply lemma  [ lem : compute ] and deduce that , in time @xmath367 , we can find a @xmath14-protrusion @xmath370 of size at most @xmath372 such that @xmath373 , and the corresponding transposition constant @xmath374 with @xmath375 . since @xmath191 is a @xmath6-encoder and",
    "@xmath239 is dp - friendly , it follows from lemma  [ lem : characterize ] that @xmath376 and that @xmath377 .",
    "therefore , if we set @xmath378 , it follows that @xmath39 and @xmath368 are indeed equivalent instances of @xmath6 with @xmath369 and @xmath371 .",
    "the general recipe to use our framework on a parameterized problem @xmath6 defined on a class of graphs @xmath236 is as follows : one has just to define the tables to solve @xmath6 via dynamic programming on graphs of bounded treewidth ( that is , the encoder @xmath191 and the function @xmath53 ) , check that @xmath191 is a @xmath6-encoder and that @xmath239 is dp - friendly , and then theorem  [ thm : protrusionreplacement ] provides a linear - time algorithm that replaces large protrusions with graphs whose size is bounded by an explicit constant , and that updates the parameter of @xmath6 accordingly .",
    "this protrusion replacer can then be used , for instance , whenever one is able to find a linear protrusion decomposition of the input graphs of @xmath6 on some sparse graph class @xmath236 .",
    "in particular , theorem  [ thm : protrusionreplacement ] yields the following corollary .",
    "[ corollary : withprotrusiondecomposition ] let @xmath7 be a fixed graph , and let @xmath235 be the class of graphs that exclude @xmath7 as a ( topological ) minor .",
    "let @xmath6 be a vertex - certifiable parameterized graph problem on @xmath235 , and suppose that we are given a @xmath6-encoder @xmath191 , a function @xmath214 , and an integer @xmath306 such that @xmath239 is dp - friendly .",
    "then , given an instance @xmath39 of @xmath6 together with an @xmath379-protrusion decomposition of @xmath15 , we can construct a linear kernel for @xmath6 of size at most @xmath380 , where @xmath372 is the function defined in lemma  [ lem : finitesize ] .    for @xmath381",
    ", we apply the polynomial - time algorithm given by theorem  [ thm : protrusionreplacement ] to replace each @xmath14-protrusion @xmath382 with a graph @xmath383 of size at most @xmath372 , and to update the parameter accordingly . in this way we obtain an equivalent instance @xmath49 such that @xmath384 , @xmath369 , and @xmath385 .",
    "notice that once we fix the problem @xmath6 and the class of graphs @xmath235 where corollary  [ corollary : withprotrusiondecomposition ] is applied , a kernel of size @xmath386 can be derived with a concrete upper bound for the value of @xmath226 .",
    "notice that such a bound depends on the problem @xmath6 and the excluded ( topological ) minor @xmath7 .",
    "in general , the bound can be quite big as it depends on the bound of lemma  [ lem : finitesize ] , and this , in turn , depends on the bound of lemma  [ lem : finite ] .",
    "however , as we see in the next section , more moderate estimations can be extracted for particular families of parameterized problems .    before demonstrating the applicability of our framework by providing linear kernels for several families of problems on graphs excluding a fixed graph as a ( topological ) minor",
    ", we need another ingredient .",
    "namely , the following result will be fundamental in order to find linear protrusion decompositions when a treewidth - modulator @xmath69 of the input graph @xmath15 is given , with @xmath387 .",
    "it is a consequence of  ( * ? ? ?",
    "* lemma  3 , proposition  1 , and theorem  1 ) and , loosely speaking , the algorithm consists in marking the bags of a tree decomposition of @xmath388 according to the number of neighbors in the set @xmath69 .",
    "when the graph @xmath15 is restricted to exclude a fixed graph @xmath7 as a topological minor , it can be proved that the obtained protrusion decomposition is linear .",
    "all the details can be found in the full version of  @xcite .",
    "[ thm : protdec ] let @xmath389 be two positive integers , let @xmath7 be an @xmath113-vertex graph , let @xmath15 be an @xmath340-vertex @xmath7-topological - minor - free graph , and let @xmath3 be a positive integer ( typically corresponding to the parameter of a parameterized problem ) .",
    "if we are given a set @xmath18 with @xmath390 such that @xmath391 , then we can compute in time @xmath341 an @xmath392-protrusion decomposition of @xmath15 , where @xmath393 is a constant depending only on @xmath7 , which is upper - bounded by @xmath394 .    as mentioned in subsection",
    "[ sec : equivalencerelations ] , if @xmath236 is a graph class whose membership can be expressed in mso logic , then @xmath247 has a finite number of equivalence classes , namely @xmath248 . in our applications , we will be only concerned with families of graphs @xmath236 that exclude some fixed @xmath113-vertex graph @xmath7 as a ( topological ) minor . in this case , using standard dynamic programming techniques , it can be shown that @xmath249 .",
    "the details can be found in the encoder described in subsection  [ sec : description - encoder - planarfdeletion ] for the @xmath1-deletion problem .",
    "let @xmath26 be a fixed integer .",
    "we define the @xmath0-dominating set problem as follows .    .95 @xmath0-dominating set    [ cols= \" > , < \" , ]     when all the graphs in @xmath1 are connected , the corresponding problem is called connected-@xmath1-deletion , and when @xmath1 contains at least one planar graph , we call it planar-@xmath1-deletion . when both conditions are satisfied , the problem is called connected - planar-@xmath1-deletion . note that connected - planar-@xmath1-deletion encompasses , in particular , vertex cover and feedback vertex set .",
    "our encoder for the @xmath1-deletion problem uses the dynamic programming machinery developed by adler _ et al_.  @xcite , and it is described in subsection  [ sec : description - encoder - planarfdeletion ] .",
    "the properties of this encoder also guarantee that the equivalence relation @xmath247 has finite index ( see the last paragraph of subsection  [ sec : explicitprotrusionreplacer ] ) .",
    "we prove that this encoder is indeed an @xmath1-deletion - encoder and that the corresponding equivalence relation is dp - friendly , under the constraint that all the graphs in @xmath1 are _",
    "connected_. interestingly , this phenomenon concerning the connectivity seems to be in strong connection with the fact that the @xmath1-deletion problem has fii if all the graphs in @xmath1 are connected  @xcite , but for some families @xmath1 containing disconnected graphs , @xmath1-deletion has not fii ( see  @xcite for an example of such family ) .",
    "we then obtain a linear kernel for the problem using two different approaches .",
    "the first one , described in subsection  [ sec : description - encoder - planarfdeletion ] , follows the same scheme as the one used in the previous sections ( sections  [ sec : rdomset ] and  [ sec : rscatset ] ) , that is , we first find a treewidth - modulator @xmath69 in polynomial time , and then we use this set @xmath69 as input to the algorithm of theorem  [ thm : protdec ] to find a linear protrusion decomposition of the input graph . in order to find the treewidth - modulator @xmath69 , we need that the input graph @xmath15 excludes a fixed graph @xmath7 as a minor .    with our second approach , which can be found in subsection  [ sec : construction - kernel - planarfdeletion - h - topological - minor - free ] ,",
    "we obtain a linear kernel on the larger class of graphs that exclude a fixed graph @xmath7 as a _",
    "topological _ minor .",
    "we provide two variants of this second approach .",
    "one possibility is to use the randomized constant - factor approximation for planar-@xmath1-deletion by fomin _",
    "et al_.  @xcite as treewidth - modulator , which yields a randomized linear kernel that can be found in uniform polynomial time .",
    "the second possibility consists in arguing just about the _ existence _ of a linear protrusion decomposition in yes - instances , and then greedily finding large protrusions to be reduced by the protrusion replacer given by theorem  [ thm : protrusionreplacement ] .",
    "this yields a deterministic linear kernel that can be found in time @xmath395 , where @xmath5 is a function depending on @xmath7 and @xmath1 .",
    "in this subsection we define an encoder @xmath396 for @xmath1-deletion , and along the way we will also prove that when @xmath236 is the class of graphs excluding a fixed graph on @xmath113 vertices as a minor , then the index of the equivalence relation @xmath247 is bounded by @xmath397 .    recall first that a _ model _ of a graph @xmath363 in a graph @xmath15 is a mapping @xmath398 , that assigns to every edge @xmath399 an edge @xmath400 , and to every vertex @xmath401 a non - empty connected subgraph @xmath402 , such that    * the graphs @xmath403 are mutually vertex - disjoint and the edges @xmath404 are pairwise distinct ; * for @xmath405 , @xmath406 has one end - vertex in @xmath407 and the other in @xmath408 .",
    "assume first for simplicity that @xmath409 consists of a single connected graph @xmath363 .",
    "following  @xcite , we introduce a combinatorial object called _ rooted packing_. these objects are originally defined for branch decompositions , but we can directly translate them to tree decompositions . loosely speaking ,",
    "rooted packings capture how `` potential models '' of @xmath363 intersect the separators that the algorithm is processing .",
    "it is worth mentioning that the notion of rooted packing is related to the notion of _ folio _ introduced by robertson and seymour in  @xcite , but more suited to dynamic programming .",
    "see  @xcite for more details .",
    "formally , let @xmath410 be a subset of the vertices of the graph @xmath363 , and let @xmath411 . given a bag @xmath71 of a tree decomposition @xmath319 of the input graph @xmath15",
    ", we define a _ rooted packing _ of @xmath71 as a quintuple @xmath412 , where @xmath413 is a ( possible empty ) collection of mutually disjoint non - empty subsets of @xmath71 ( that is , a _ packing _ of @xmath71 ) , @xmath414 is a surjective mapping ( called the _ rooting _ ) assigning vertices of @xmath415 to the sets in @xmath413 , and @xmath416 is a binary symmetric function between pairs of vertices in @xmath415 .",
    "the intended meaning of a rooted packing @xmath417 is as follows . in a given separator @xmath71 ,",
    "a packing @xmath413 represents the intersection of the connected components of the potential model with @xmath71 .",
    "the subsets @xmath418 and the function @xmath419 indicate that we are looking in the graph @xmath75 for a potential model of @xmath420 $ ] containing the edges between vertices in @xmath415 given by the function @xmath419 .",
    "namely , the function @xmath419 captures which edges of @xmath420 $ ] have been realized so far in the processed graph .",
    "since we allow the vertex - models intersecting @xmath71 to be disconnected , we need to keep track of their connected components .",
    "the subset @xmath411 tells us which vertex - models intersect @xmath71 , and the function @xmath421 associates the sets in @xmath413 with the vertices in @xmath415 .",
    "we can think of @xmath421 as a coloring that colors the subsets in @xmath413 with colors given by the vertices in @xmath415 .",
    "note that several subsets in @xmath413 can have the same color @xmath422 , which means that the vertex - model of @xmath423 in @xmath75 is not connected yet , but it may get connected in further steps of the dynamic programming .",
    "again , see  @xcite for the details .",
    "it is proved in  @xcite that rooted packings allow to carry out dynamic programming in order to determine whether an input graph @xmath15 contains a graph @xmath363 as a minor .",
    "it is easy to see that the number of distinct rooted packings at a bag @xmath71 is upper - bounded by @xmath424 , where @xmath425 and @xmath426 . in particular",
    ", this proves that when @xmath236 is the class of graphs excluding a fixed graph @xmath7 on @xmath113 vertices as a minor , then the index of the equivalence relation @xmath247 is bounded by @xmath397 .    nevertheless , in order to solve the @xmath1-deletion problem , we need a more complicated data structure .",
    "the intuitive reason is that it is inherently more difficult to cover _ all _ models of a graph @xmath363 with at most @xmath3 vertices , rather than just finding one .",
    "we define @xmath427 as the function which maps @xmath428 to a subspace of @xmath429 .",
    "that is , each @xmath427-encoding @xmath430 is a vector of @xmath431 bits , which when interpreted as the tables of a dynamic programming algorithm at a given bag @xmath71 such that @xmath432 , prescribes which rooted packings exist in the graph @xmath75 once the corresponding vertices of the desired solution to @xmath1-deletion have been removed .",
    "more precisely , the language @xmath433 contains the triples @xmath161 ( recall from definition  [ def : encoder ] that here @xmath15 is a boundaried graph with @xmath434 , @xmath130 , and @xmath435 ) such that the graph @xmath436 contains precisely the rooted packings prescribed by @xmath142 ( namely , those whose corresponding bit equals 1 in @xmath142 ) , and such that the graph @xmath437 does _ not _ contain @xmath363 as a minor .    when the family @xmath438 may contain more than one graph ,",
    "let @xmath439 , and we define @xmath427 as the function which maps @xmath440 to a subspace of @xmath441 .",
    "the language is defined @xmath433 is defined accordingly , that is , such that the graph @xmath436 contains precisely the rooted packings of @xmath442 prescribed by @xmath142 , for each @xmath381 , and such that the graph @xmath437 does _ not _ contain any of the graphs in @xmath1 as a minor . by definition of @xmath443 , it clearly holds that @xmath444    assume henceforth that all graphs in the family @xmath1 are _",
    "connected_. this assumption is crucial because for a connected graph @xmath445 and a potential solution @xmath28 , as the graph @xmath437 does not contain @xmath363 as a minor , we can assume that the packing @xmath446 corresponding to a potential model of @xmath363 rooted at @xmath447 is _",
    "nonempty_. indeed , as @xmath363 is connected , a rooted packing which does _ not _ intersect @xmath447 can never be extended to a ( complete ) model of @xmath363 in @xmath448 for any @xmath14-boundaried graph @xmath449 .",
    "therefore , we can directly discard these empty rooted packings .",
    "we will use this property in the proof of lemma  [ lem : encoderfdeletion ] below . note that this assumption is not safe if @xmath363 contains more than one connected component . as mentioned before",
    ", this phenomenon seems to be in strong connection with the fact that the @xmath1-deletion problem has fii if all the graphs in @xmath1 are connected  @xcite , but for some families @xmath1 containing disconnected graphs , @xmath1-deletion has not fii .",
    "[ lem : encoderfdeletion ] the encoder @xmath443 is a connected-@xmath1-deletion - encoder .",
    "furthermore , if @xmath236 is an arbitrary class of graphs and @xmath198 , then the equivalence relation @xmath450 is dp - friendly .",
    "the fact that @xmath396 is a connected-@xmath1-deletion - encoder follows easily from the above discussion , as if @xmath15 is a @xmath83-boundaried graph , then @xmath451 consists of a single @xmath427-encoding @xmath176 , and @xmath452 if and only if the graph @xmath453 contains none of the graphs in @xmath1 as a minor .",
    "it remains to prove that the equivalence relation @xmath450 is dp - friendly for @xmath198 .",
    "the proof is similar to the proofs for @xmath0-dominating set and @xmath0-scattered set , so we will omit some details . as in the proof of lemma  [ lem : rdomcharacterizes ] , we start by proving that the encoder @xmath443 for connected-@xmath1-deletion is @xmath53-confined for the identity function @xmath198 .",
    "similarly to the encoder we presented for @xmath0-dominating set , @xmath396 has the following monotonicity property .",
    "for @xmath454 such that @xmath455 and @xmath456 , @xmath457 where for @xmath458 , @xmath459 denotes the set of rooted packings whose corresponding bit equals @xmath83 in @xmath460 . indeed , equation  ( [ fdeletion : monotone ] ) holds",
    "because any solution @xmath28 in @xmath15 that covers all the rooted packings forbidden by @xmath461 also covers those forbidden by @xmath462 ( as by hypothesis @xmath463 ) , so it holds that @xmath464 .",
    "let @xmath465 be the @xmath466-encoding will all the bits set to @xmath83 .",
    "the key observation is that , since each graph in @xmath1 is _ connected _ , by the discussion above the lemma we can assume that each packing @xmath446 in a rooted packing is nonempty .",
    "this implies that if @xmath467 such that @xmath468 for some set @xmath130 , then @xmath469 .",
    "in other words , any solution @xmath28 for an arbitrary @xmath427-encoder @xmath142 can be transformed into a solution for @xmath204 by adding a set of vertices of size at most @xmath470 .",
    "as by equation  ( [ fdeletion : monotone ] ) , for any @xmath427-encoding @xmath142 with @xmath471 , it holds that @xmath472 , it follows that for any graph @xmath15 with @xmath178 , @xmath473    once we have that @xmath396 is @xmath53-confined , the proof goes along the same lines of that of lemma  [ lem : rdomcharacterizes ] .",
    "that is , the objective is to show that , in the setting depicted in fig .  [",
    "fig : unglueglue ] , @xmath474 ( due to fact  [ fact : dpfriendly ] ) and @xmath475 . due to the @xmath53-confinement",
    ", it suffices to prove that @xmath476 for all @xmath477 . since @xmath478 , the definition of @xmath443 it implies that the graphs @xmath75 and @xmath272 contain exactly the same set of rooted packings , so their behavior with respect to @xmath7 ( see fig .  [ fig : unglueglue ] ) in terms of the existence of models of graphs in @xmath1 is exactly the same . for more details ,",
    "it is proved in  @xcite that using the encoder @xmath396 , the tables of a given bag in a tree- or branch - decomposition can indeed be computed from the tables of their children .",
    "therefore , we have that @xmath474 . finally , the fact that @xmath479 can be easily proved by noting that any set @xmath480 satisfying @xmath481 can be transformed into a set @xmath482 satisfying @xmath481 such that @xmath483 ( by just replacing @xmath484 with the corresponding set of vertices in @xmath485 , using that @xmath478 ) , and vice versa .      the objective of this subsection is to prove the following theorem .",
    "[ thm : kernelfdeletion ] let @xmath1 be a finite set of connected graphs containing at least one @xmath0-vertex planar graph @xmath363 , let @xmath7 be an @xmath113-vertex graph , and let @xmath486 be the restriction of the connected - planar-@xmath1-deletion problem to input graphs which exclude @xmath7 as a minor .",
    "then @xmath486 admits a constructive linear kernel of size at most @xmath487 , where @xmath5 is an explicit function depending only on @xmath0 and @xmath113 , defined in equation  ( [ eq : kernelfdeletion ] ) below .",
    "similarly to the strategy that we presented in subsection  [ sec : construction - kernel - rdomset ] for @xmath0-dominating set , in order to construct a linear kernel for connected - planar-@xmath1-deletion when the input graph excludes a fixed graph @xmath7 as a minor , we use the fact that this problem satisfies the minor - bidimensionality and separability conditions required in order to apply the results of fomin _",
    "et al_.  @xcite .",
    "namely , in the following proposition we specify the result in  ( * ? ? ?",
    "* lemma  3.3 ) for the case of planar-@xmath1-deletion while making visible the dependance on @xmath0 and the size @xmath113 of the excluded graph .",
    "again , the polynomial - time algorithm follows from fomin _",
    "et al_.  ( * ? ? ?",
    "* lemma 3.2 ) .",
    "[ thm : protdecfdeletion ] let @xmath1 be a finite set of graphs containing at least one @xmath0-vertex planar graph @xmath363 , let @xmath7 be an @xmath113-vertex graph , and let @xmath488 be the restriction of the planar-@xmath1-deletion problem to input graphs which exclude @xmath7 as a minor . if @xmath489 , then there exists a set @xmath490 such that @xmath491 and @xmath492 , where @xmath124 is the function in proposition  [ prop : tw - minor ] .",
    "moreover , given an instance @xmath39 of @xmath488 , there is a polynomial - time algorithm that either finds such a set @xmath69 or correctly reports that @xmath39 is a no - instance .",
    "we are ready to present a linear kernel for connected - planar-@xmath1-deletion when the input graph excludes a fixed graph @xmath7 as a minor .",
    "the proof is very similar to the one of theorem  [ thm : kernelrdomset ] .",
    "given an instance @xmath39 , we run the polynomial - time algorithm given by proposition  [ thm : protdecfdeletion ] to either conclude that @xmath39 is a no - instance or to find a set @xmath490 such that @xmath491 and @xmath492 . in the latter case , we use the set @xmath69 as input to the algorithm given by theorem  [ thm : protdec ] , which outputs in linear time a @xmath493-protrusion decomposition of @xmath15 .",
    "we now consider the encoder @xmath396 defined in subsection  [ sec : description - encoder - planarfdeletion ] . by lemma  [ lem : encoderfdeletion ] , @xmath443 is a @xmath486-encoder and @xmath450 is dp - friendly , where @xmath198 and @xmath235 is the class of @xmath7-minor - free graphs .",
    "an upper bound on @xmath494 is given in equation  ( [ eq : sizeencoderfdeletion ] ) .",
    "therefore , we are in position to apply corollary  [ corollary : withprotrusiondecomposition ] and obtain a linear kernel for @xmath486 of size at most @xmath495 where @xmath496 is the function defined in lemma  [ lem : finitesize ] .      in this subsection",
    "we explain how to obtain linear kernels for planar-@xmath1-deletion on graphs excluding a topological minor .",
    "we first describe a uniform randomized kernel and then a nonuniform deterministic one .",
    "we would like to note that in the case that @xmath236 is the class of graphs excluding a fixed @xmath113-vertex graph @xmath7 as a topological minor , by using a slight variation of the rooted packings described in subsection  [ sec : description - encoder - planarfdeletion ] it can be proved , using standard dynamic techniques , that the index of the equivalence relation @xmath247 is also upper - bounded by @xmath397 .    before presenting the uniform randomized kernel ,",
    "we need the following two results .",
    "[ thm : approx ] the optimization version of the planar-@xmath1-deletion problem admits a randomized constant - factor approximation .    [ thm : boundtw ] for every simple planar graph @xmath363 on @xmath0 vertices , every @xmath363-minor - free graph @xmath15 satisfies @xmath497 .",
    "[ thm : kernelfdeletionrandomized ] let @xmath1 be a finite set of connected graphs containing at least one @xmath0-vertex planar graph @xmath363 , let @xmath7 be an @xmath113-vertex graph , and let @xmath498 be the restriction of the connected - planar-@xmath1-deletion problem to input graphs which exclude @xmath7 as a topological minor . then @xmath498 admits a linear randomized kernel of size at most @xmath487 , where @xmath5 is an explicit function depending only on @xmath0 and @xmath113 , defined in equation  ( [ eq : kernelfdeletionrandom ] ) below",
    ".    given an instance @xmath39 of @xmath498 , we first run the randomized polynomial - time approximation algorithm given by theorem  [ thm : approx ] , which achieves an expected constant ratio @xmath499 . if we obtain a solution @xmath18 such that @xmath500 , we declare that @xmath39 is a no - instance . otherwise , if @xmath501 , we use the set @xmath69 as input to the algorithm given by theorem  [ thm : protdec ] .",
    "as by theorem  [ thm : boundtw ] we have that @xmath502 , we obtain in this way a @xmath503-protrusion decomposition of @xmath15 .",
    "we now consider again the encoder @xmath396 defined in subsection  [ sec : description - encoder - planarfdeletion ] , and by corollary  [ corollary : withprotrusiondecomposition ] we obtain a kernel of size at most @xmath504 where @xmath505 is the function defined in lemma  [ lem : finitesize ] and @xmath235 is the class of @xmath7-topological - minor - free graphs .",
    "we finally present a deterministic kernel , whose drawback is that the running time is nonuniform on @xmath1 and @xmath7 .",
    "[ thm : kernelfdeletionnonuniform ] let @xmath1 be a finite set of connected graphs containing at least one @xmath0-vertex planar graph @xmath363 , let @xmath7 be an @xmath113-vertex graph , and let @xmath498 be the restriction of the connected - planar-@xmath1-deletion problem to input graphs which exclude @xmath7 as a topological minor .",
    "then @xmath498 admits a linear kernel of size at most @xmath487 , where @xmath5 is an explicit function depending only on @xmath0 and @xmath113 , defined in equation  ( [ eq : kernelfdeletionnonuniform ] ) below .",
    "the main observation is that if @xmath506 , then there exists a set @xmath18 with @xmath507 such that @xmath388 is @xmath508-minor - free . in particular , by theorem  [ thm : boundtw ] it holds that @xmath502 .",
    "therefore , we know by theorem  [ thm : protdec ] that if @xmath506 , then @xmath15 admits a @xmath509-protrusion decomposition . nevertheless , we do not have tools to efficiently find such linear decomposition .",
    "however , we use that , as observed in  @xcite , a @xmath14-protrusion of size more than a prescribed number @xmath74 in an @xmath340-vertex graph can be found in @xmath510 steps , it if exists .",
    "our kernelization algorithm proceeds as follows .",
    "we try to find a @xmath511-protrusion @xmath366 of size strictly larger than @xmath512 , where @xmath443 is the encoder for @xmath1-deletion described in subsection  [ sec : description - encoder - planarfdeletion ] , @xmath513 is the function defined in lemma  [ lem : finitesize ] , and @xmath235 is the class of @xmath7-topological - minor - free graphs .",
    "if we succeed , we apply the protrusion replacement algorithm given by theorem  [ thm : protrusionreplacement ] and replace @xmath366 with another @xmath14-boundaried graph @xmath370 such that @xmath514 .",
    "the algorithm continues as far as we are able to find such large protrusion . at the end of this procedure",
    ", we either obtain an equivalent instance of size at most @xmath515 or otherwise we can correctly declare that @xmath39 is a no - instance .",
    "this kernelization algorithm runs in time @xmath516 .    to conclude this section , we would like to note that the recent results of chekuri and chuzhoy  chch13",
    "show that in theorem  [ thm : boundtw ] , the inequality @xmath497 can be replaced with @xmath517 .",
    "this directly implies that in equations  ( [ eq : kernelfdeletionrandom ] ) and  ( [ eq : kernelfdeletionnonuniform ] ) , as well as in the running time of the algorithm of theorem  [ thm : kernelfdeletionnonuniform ] , the term @xmath518 can be replaced with @xmath519 . nevertheless , we decided to keep the current bounds in order to be able to give explicit constants",
    "the methodology for performing explicit protrusion replacement via dynamic programming that we have presented is quite general , and it could also be used to obtain polynomial kernels ( not necessarily linear ) .",
    "we have restricted ourselves to vertex - certifiable problems , but is seems plausible that our approach could be also extended to edge - certifiable problems or to problems on directed graphs .",
    "we have presented in section  [ sec : planarfdeletion ] a linear kernel for connected - planar-@xmath1-deletion when the input graph excludes a fixed graph @xmath7 as a ( topological ) minor .",
    "the planar-@xmath1-deletion problem is known to admit a polynomial kernel on general graphs  @xcite . nevertheless , this kernel has size @xmath520 , where @xmath226 is a constant depending on @xmath1 that is upper - bounded by @xmath521 , where @xmath0 is the size of a largest graph in @xmath1 .",
    "the existence of a _ uniform _ polynomial kernel ( that is , a polynomial kernel whose degree does not depend on the family @xmath1 ) for planar-@xmath1-deletion on general graphs remains open .",
    "as mentioned above , our linear kernel for planar-@xmath1-deletion requires that all graphs in the family @xmath1 are _ connected_. it would be interesting to get rid of this assumption . on the other hand , in the linear kernel for connected - planar-@xmath1-deletion on @xmath7-topological - minor - free graphs given in theorem  [ thm : kernelfdeletionrandomized ] , the randomization appears because we use the randomized constant - factor approximation for planar-@xmath1-deletion on general graphs  @xcite , but for our kernel to be deterministic , it would be enough with a constant - factor approximation on @xmath7-topological - minor - free graphs , which is not known .",
    "all the applications examined in this paper concerned parameterized problems tuned by a secondary parameter , i.e. , @xmath0 for the case of @xmath0-dominating set and @xmath0-scattered set and the size of the graphs in @xmath10 for the case of @xmath10-deletion . in all kernels derived for these problems , the dependance on this secondary parameter is triple - exponential , while the dependance on the excluded graph @xmath7 involves the functions @xmath12 and @xmath11 defined in section  [ sec : prelim ] .",
    "two questions arise :    * extend our results to larger graph classes and more general problems .",
    "also , improve the dependance of the size of the kernels on the `` meta - parameters '' associated with the problems ( that is , @xmath0 , @xmath1 , and @xmath7 ) .",
    "probably the recent results of chekuri and chuzhoy  chch13 can be used in this direction .",
    "moreover , provide refinements of this framework that can lead to reasonable explicit bounds for the kernels for particular problems .",
    "* examine to what extent this exponential dependance is unavoidable under some assumptions based on automata theory or ( parameterized ) complexity theory .",
    "we suspect that the unification between dynamic programming and kernelization that we propose in this paper might offer a common understanding of the lower bounds in the running time of dynamic programming algorithms for certain problems ( see  @xcite ) and the sizes of their corresponding kernels ( see for instance  @xcite )",
    ". finally , we refer the reader to  @xcite for constructibility issues of algebraic graph reduction .    * acknowledgement . *",
    "we wish to thank fedor v. fomin and saket saurabh for their advises and comments on this work . also , we are particularly indebted to daniel lokshtanov for his insightful remarks and suggestions .",
    "finally , we would like to thank the anonymous referees of the conference version of this paper for helpful remarks that improved the presentation of the manuscript .",
    "h.  l. bodlaender , f.  v. fomin , d.  lokshtanov , e.  penninkx , s.  saurabh , and d.  m. thilikos . .",
    "in _ proc . of the 50th ieee symposium on foundations of computer science ( focs ) _ , pages 629638 .",
    "ieee computer society , 2009 .",
    "h.  l. bodlaender , b.  m.  p. jansen , and s.  kratsch .",
    "cross - composition : a new technique for kernelization lower bounds . in _ proc . of the 28th international symposium on theoretical aspects of computer science ( stacs )",
    "_ , volume  9 of _ lipics _ , pages 165176 , 2011 .",
    "h.  dell and d.  van melkebeek .",
    "satisfiability allows no nontrivial sparsification unless the polynomial - time hierarchy collapses . in _ proc . of the 42nd acm symposium on theory of computing ( stoc ) _ , pages 251260 .",
    "acm , 2010 .",
    "j.  guo and r.  niedermeier .",
    "linear problem kernels for np - hard problems on planar graphs . in _ proc . of the 34th international colloquium on automata , languages and programming ( icalp ) _ , volume 4596 of _ lncs _ , pages 375386 , 2007 .",
    "e.  j. kim , a.  langer , c.  paul , f.  reidl , p.  rossmanith , i.  sau , and s.  sikdar .",
    "linear kernels and single - exponential algorithms via protrusion decompositions . in _ proc . of the 40th international colloquium on automata , languages and programming ( icalp ) _ , volume 7965 of _ lncs _ , pages 613624 , 2013 .",
    "full version available at _ corr _ , abs/1207.0835 .",
    "d.  lokshtanov , d.  marx , and s.  saurabh .",
    "known algorithms on graphs of bounded treewidth are probably optimal . in _ proc . of the 22nd acm - siam symposium on discrete algorithms ( soda ) _",
    ", pages 777789 .",
    "siam , 2011 ."
  ],
  "abstract_text": [
    "<S> several algorithmic meta - theorems on kernelization have appeared in the last years , starting with the result of bodlaender _ </S>",
    "<S> et al_. [ focs 2009 ] on graphs of bounded genus , then generalized by fomin _ </S>",
    "<S> et al_. [ soda 2010 ] to graphs excluding a fixed minor , and by kim _ </S>",
    "<S> et al_. [ icalp 2013 ] to graphs excluding a fixed topological minor . </S>",
    "<S> typically , these results guarantee the existence of linear or polynomial kernels on sparse graph classes for problems satisfying some generic conditions but , mainly due to their generality , it is not clear how to derive from them constructive kernels with explicit constants .    in this paper </S>",
    "<S> we make a step toward a fully constructive meta - kernelization theory on sparse graphs . </S>",
    "<S> our approach is based on a more explicit protrusion replacement machinery that , instead of expressibility in cmso logic , uses dynamic programming , which allows us to find an explicit upper bound on the size of the derived kernels . </S>",
    "<S> we demonstrate the usefulness of our techniques by providing the first explicit linear kernels for @xmath0-dominating set and @xmath0-scattered set on apex - minor - free graphs , and for planar-@xmath1-deletion on graphs excluding a fixed ( topological ) minor in the case where all the graphs in @xmath1 are connected .    </S>",
    "<S> * keywords : * parameterized complexity , linear kernels , dynamic programming , protrusion replacement , graph minors . </S>"
  ]
}