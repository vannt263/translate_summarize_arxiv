{
  "article_text": [
    "live sequence charts ( lscs )  @xcite have been introduced as an inter - object scenario - based specification and visual programming language for reactive systems .",
    "the language extends traditional sequence charts , typically sequence charts in uml  @xcite and message sequence charts ( mscs )  @xcite , by enabling mandatory behaviors and forbidden behaviors specification . with mandatory behaviors , lscs are able to specify necessary system behaviors in a more semantically precise manner instead of only posing weak partial order restriction on possible behaviors as in sequence charts .",
    "such a semantical precision is critical to upgrading the lscs from a formal specification tool to an achievable dream of becoming a scenario - based programming language  @xcite , since mandatory behaviors exactly tell what to expect at system runtime .",
    "in addition , a forbidden behavior specification further enriches the lscs with self - contained consistency checking capability ; it allows the lscs to specify the failure scenarios at runtime by checking reachability instead of testing failure conditions explicitly and blindly at every running step .",
    "lscs have been successfully used in many real - life applications such as hardware and software verification  @xcite , an air traffic control system  @xcite , and a radio - based train system  @xcite .",
    "the features of specifying mandatory and forbidden behaviors have recently been incorporated into the uml 2.0  @xcite to increase its expressive power .",
    "consistency checking  @xcite is one of the major and formidable problems on lscs . in a complicated system consisting of many lscs",
    ", inconsistency may be raised by inherent contradiction among multiple charts or due to inappropriate environmental / external event sequences .",
    "previous work on consistency checking are mainly focused on automata - based strategies . in  @xcite , the consistency of lscs is shown as a necessary and sufficient condition for the existence of an object system satisfying it ; the consistency checking is then reduced to a problem whether a satisfying object system , in a form of automaton , can be synthesized from lscs .",
    "other automata - based transformation includes  @xcite , which turn the lsc specification into variants of bchi automata for verification . in  @xcite , a semantic transformation from lscs to communicating sequential process ( csp )",
    "is presented , so that the consistency checking of lscs can be done by reusing an existing tool for csp .",
    "there has been some other work done in translating lscs to temporal logic for model checking  @xcite .",
    "all these automata - based consistency checking strategies lack the capabilities for lscs users , at the language level , to specify any user - preferred testing and simulate running lscs in any way .",
    "therefore , they can only be served as a formal verification tool to support static analysis on lscs , and at the same time , may suffer the complexities caused by transformation itself , automata synthesis , or the blowing size of transformed results  @xcite .    in this paper , we introduce a logic - based framework to implement an automated lsc simulator with practical user controls , and to check the consistency of an lsc specification with sufficient justification .",
    "an lsc simulator has been implemented in logic programming to show how a reactive system in lscs would response to a set of external event sequences .",
    "a formal language is defined for users to specify external event sequences by extending a regular expression notation with a parallel operator and a testing control .",
    "the parallel operator allows the lsc simulator to test the scenarios where multiple external events may happen simultaneously ; and the testing control provides users with a new approach to specify certain temporal properties ( e.g. , ctl formula  @xcite ) in a form of lsc .",
    "we present a new high - level computational ( operational ) semantics of lscs to show how a running lsc affects the system behaviors in response to a continuous input of external events .",
    "the semantics is defined in the form of a derivation tree , called _ play - tree _ , where each branch from the root to a leaf corresponds to a possible lsc run on a finite sequence of external event inputs .",
    "the consistency of an lsc specification @xmath0 is defined as , given a nonempty language @xmath1 of external events , whether there exists a corresponding _ play - tree _ with all successful branches .",
    "if such a play - tree exists , then the lsc @xmath0 is consistent on the input language @xmath1 ; otherwise , a failure trace can be obtained along the failure branch in the play - tree . as a result , the consistency checking of an lsc is basically an ordered traversal of the play - tree .",
    "our lsc simulator utilizes a traversal algorithm using a memoized depth - first search strategy for efficient consistency checking of lscs .    besides running lscs and checking their consistency",
    ", our lsc simulator further generates evidences to justify the truth value of checking results .",
    "if the consistency is true , the simulator can generate a state transition diagram to illustrate system behaviors as well as ctl formula satisfaction . otherwise , if the checking result is false , the lsc simulator returns a least prefix failure trace as a counter - example evidence , so that the lsc users can easily re - construct the simulation anti - scenarios .    in this paper ,",
    "we adopt assumptions similar to  @xcite .",
    "we assume all messages in lscs are synchronous and that no sending messages are lost over communication channels ; the running lscs use an input - enabled concurrency model , where no two external events occur at the same time and that internal events are processed at real - time , much faster than receiving a next external event .",
    "it needs to be mentioned that even though we assume no simultaneous external events in our lsc simulation , interleaved parallel external events can still be simulated with extra language features as described in later sections .",
    "the paper is structured as follows . section  [ sec : lsc ] gives a brief introduction of the syntax and semantics of lscs through a web order example .",
    "section  [ sec : l2c2 ] presents an architecture of a logic - based lsc consistency checker .",
    "section  [ sec : l2s ] illustrates how a running lsc reacts to the environment events using a computational tree , and shows how the consistency of lscs can be achieved through a memoized depth - first search strategy .",
    "section  [ sec : eesl ] defines a formal language for specifying the external events with parallel and testing controls .",
    "section  [ sec : justification ] shows the supporting evidence for lsc consistency checking and simulation .",
    "finally , conclusions are given in section  [ sec : conclusion ] .",
    "lscs have two types of charts : _ universal _ and _ existential _ charts .",
    "a universal chart is used to specify a scenario - based _ if - then _ rule , which applies to all possible system runs .",
    "a universal chart typically contains a _ prechart _ , denoted by a top dashed hexagon , and a _ main chart _ , denoted by a solid rectangle right below a prechart",
    "; if the prechart is satisfied , then the system is forced to satisfy the defined scenario in the main chart . an existential chart is usually used to specify a testing scenario that can be satisfied by at least one possible system run . in this paper",
    ", we will focus on universal charts only , since achieving the consistency among universal charts on all system runs is more interesting and difficult ; in addition , a testing scenario can easily be specified in a universal chart in our framework .",
    "cc   &   + ( a ) rbc creates an order & ( b ) stc receives an order + &   + ( c ) rbc aborts the order & ( d ) stc receives an `` abort '' + [ 0pt ]    [ cols=\"^ \" , ]     if the consistency is false , it returns a least prefix failure trace as an evidence ; while if the result is true , then it actually returns a state transition graph , showing labeled transitions among states after processing each external event and the testing temporal properties .",
    "figure  [ fig : ws4 ] shows two positive justification graphs , where the green ( or gray ) color represents the satisfiability of a testing scenario .",
    "each node in the graph represents a super state , either an initial state or a stable state after processing an external event or parallel external events ; the text in each node shows the current i d ; the labels on a transition mean the external events , separated by a semi - colon ; a label of two external events ( e.g. , `` a , b '' ) , separated by a comma , represents interleaved parallel events in this order .",
    "figure  [ fig : ws4](a ) verifies the saftyness property in ctl : ag@xmath2 , where the state predicate is globally true on every path .",
    "figure  [ fig : ws4](b ) verifies the reachability property in ctl : ef@xmath3 , which means that it is possible that in some scenario , the stc receives an abort event but sends an orderconfirm event to rbc .",
    "users can also re - construct the simulation scenarios using the justification evidence in an interactive way with play - engine .",
    "we introduce a logic - based lsc consistency checking system , named _",
    "l2c2_. an lsc simulator , named _ l2s _ , has been presented , utilizing a memoized depth - first search strategy over a computational play - tree , to show how a reactive system in lscs would response to a set of external event sequences . a formal language , named _ eesl _ ,",
    "has been defined to specify external event sequences .",
    "the language extends a regular expression notation with a parallel operator @xmath4 and a testing operator @xmath5 .",
    "the parallel operator , combined with a virtual parallel control in lscs , allows interleaved parallel external events to be processed in lscs .",
    "the testing operator , combined with a virtual testing control in lscs , provides users to a new approach to specify and test ctl temporal properties .",
    "the l2c2 system further provides either a state transition graph or a failure trace to justify the consistency checking results .",
    "we believe that an automatic lsc simulator as well as debugging , temporal property testing , and consistency checking capabilities will play important roles on designing trustworthy reactive distributed software and hardware processes ."
  ],
  "abstract_text": [
    "<S> live sequence charts ( lscs ) have been proposed as an inter - object scenario - based specification and visual programming language for reactive systems . in this paper </S>",
    "<S> , we introduce a logic - based framework to check the consistency of an lsc specification . </S>",
    "<S> an lsc simulator has been implemented in logic programming , utilizing a memoized depth - first search strategy , to show how a reactive system in lscs would response to a set of external event sequences . </S>",
    "<S> a formal notation is defined to specify external event sequences , extending the regular expression with a parallel operator and a testing control . </S>",
    "<S> the parallel operator allows interleaved parallel external events to be tested in lscs simultaneously ; while the testing control provides users to a new approach to specify and test certain temporal properties ( e.g. , ctl formula ) in a form of lsc . </S>",
    "<S> our framework further provides either a state transition graph or a failure trace to justify the consistency checking results . </S>"
  ]
}