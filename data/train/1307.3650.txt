{
  "article_text": [
    "we consider the problem of scheduling maintenance jobs on the arcs of a flow network with the objective of maximizing the throughput over a given time horizon .",
    "this problem combines the diverse fields of scheduling ( see for instance  @xcite ) and network flow optimization , in particular dynamic network flows , which have been the subject of intense study in recent years ; see , for example ,  @xcite .    the combination of scheduling and network optimization represents a natural extension to existing network models , and admits many interesting variants .",
    "for example , tawamalarmi and li  @xcite , motivated by a problem in highway maintenance , consider a multicommodity flow variant , providing complexity results , combinatorial algorithms , and integer programming models .",
    "network optimization problems and scheduling have also been combined in the context of restoring infrastructure networks after major disruptions  @xcite ) and in network design over time  @xcite .",
    "the optimization problem studied in the present paper was originally motivated by annual maintenance planning for a coal export supply chain  @xcite , in which maximizing the annual throughput is a key concern ( see  @xcite for a comprehensive survey of mathematical models in railway maintenance scheduling ) .",
    "boland  _ et al . _",
    "@xcite introduced a general network optimization problem in which arc maintenance jobs need to be scheduled so as to maximize the total flow in the network over time .",
    "a simplified version of the problem in which all jobs have unit processing time was studied in  @xcite , and the complexity was determined taking into account certain instance characteristics , such as special network structures and restrictions on the set of jobs .    in the present paper",
    "we extend this model by adding the constraint that the number of jobs scheduled in any time period is bounded by a number @xmath0 which is given as part of the input .",
    "the problem is defined over a network @xmath1 with node set @xmath2 , arc set @xmath3 ( we admit parallel arcs having the same start and end nodes ) , source @xmath4 , sink @xmath5 and nonnegative integral capacity vector @xmath6 . by @xmath7 and @xmath8",
    "we denote the set of incoming and outgoing arcs of node @xmath9 , respectively .",
    "we consider this network over a set of @xmath10 time periods indexed by the set @xmath11:=\\{1,2,\\ldots , t\\}$ ] , and our objective is to maximize the total flow from @xmath12 to @xmath13 .",
    "we are also given a subset @xmath14 of arcs that have to be shut down for exactly one time period in the time horizon .",
    "in other words , there is a set of maintenance jobs , one for each arc in @xmath15 , each with unit processing time .",
    "in addition , there is a parameter @xmath0 such that the number of maintenance jobs scheduled in any time period must not exceed @xmath0 .    from a practical point of view , this is a natural variation of the model . in many real world network maintenance scheduling problems ,",
    "there are resource and budget constraints that do not allow too many jobs to be performed at the same time . for example",
    ", the number of crews available to work at night may be limited , or the maintenance operation may require the use of specialized machines , of which very few are available . in the coal supply chain situation that motivated this research ,",
    "some types of rail maintenance require the use of such machines : the machines were shared across the whole state , with at most two available in the region at any one time .",
    "of course , in practice there can be complicated rules about the combinations of jobs that are allowed . disregarding these complications , we propose to study a very simple version of the model as an abstract combinatorial optimization problem .",
    "we also make the simplifying assumptions that flow is instantaneous , i.e. , there are no transit times associated with the arcs , and that there is always enough flow available to exhaust the network capacity",
    ". these are both valid assumptions in the case of the coal supply chain application that motivated this work  @xcite .",
    "for example , it can be shown that all transit times can be set to zero if all job start times are expressed in a standardized time , in which each job s start time is delayed by the travel time from its location to the port terminal .",
    "the optimization problem is to choose the outage time periods in such a way that the total flow from @xmath12 to @xmath13 is maximized .",
    "we call this problem maximum flow arc shutdown scheduling ( mfass ) , and more formally , it can be written as a mixed binary program as follows : @xmath16 , \\label{eq : cap_job_arcs } \\\\",
    "x_{ai } & \\leqslant u_a & & a\\in a\\setminus j,\\ i\\in[t ] , \\label{eq : cap_nonjob_arcs } \\\\",
    "\\sum_{i=1}^ty_{ai } & = t-1 & & a\\in j , \\label{eq : scheduling } \\\\",
    "\\sum_{a\\in\\delta^-(v)}x_{ai } & = \\sum_{a\\in\\delta^+(v)}x_{ai } & &   v \\in v\\setminus \\{s , t\\},\\ i\\in[t ] , \\label{eq : flow_conservation}\\\\ \\sum_{a\\in j } y_{ai } & \\geqslant \\lvert j\\rvert - k & & \\ i\\in[t ] ,   \\label{eq : job_bound}\\\\ x_{ai } & \\geqslant 0 & & a\\in a,\\ i\\in[t ] ,   \\label{eq : nonnegative_flows}\\\\ y_{ai } & \\in\\{0,1\\ } & & a\\in a,\\ i\\in[t ] , \\label{eq : binary_indicators}\\end{aligned}\\ ] ] where @xmath17 for @xmath18 and @xmath19 $ ] denotes the flow on arc @xmath20 in time period @xmath21 , and @xmath22 for @xmath18 and @xmath19 $ ] indicates when the arc @xmath20 is available in time period @xmath21 , i.e. , @xmath23 in the period @xmath21 in which the outage for arc @xmath20 is scheduled .",
    "the problem is to schedule the maintenance jobs so that the total flow of the network over the time horizon @xmath10 is maximized .    in the present work ,",
    "our focus is not primarily on the real - world application in the background , but on the abstract optimization problem mfass and on the properties that make a class of instances hard or easy .",
    "these instance classes may or may not correspond to properties that occur in the coal supply chain application .",
    "for instance , the reduction from 3-partition in  @xcite shows that the general problem is strongly np - complete for the class of instances with @xmath24 , and this raises the question about the hardness of the case @xmath25 .",
    "nevertheless , the original supply chain application did motivate some features studied .",
    "for example , the real - life network is series - parallel , ( @xcite ) , some types of maintenance , ( especially on the rail network ) , require the use of scarce equipment , motivating the study of small values of @xmath0 , and the sum of arc capacities entering any node is equal , or nearly equal , to the sum of arc capacities leaving any node , for almost all network nodes ( @xcite ) . in  @xcite several instance classes for the problem without the job limit per time period were analyzed .    in order to classify instances",
    "we introduce the following notation .",
    "let @xmath26 be the class of all mfass instances . with an upper index @xmath0",
    "we denote the class of all instances with an upper bound of @xmath0 on the number of jobs scheduled per time period , and a lower index indicates additional restrictions as introduced in  @xcite .",
    "* let @xmath27 be the class of instances where the underlying network is series - parallel .",
    "* let @xmath28 be the class of instances where the underlying network is _ balanced _ , i.e. , for each transshipment node @xmath29 the capacity into this node equals the capacity out of this node . *",
    "let @xmath30 be the class of _ _ u__nit _ _ c__apacity instances , i.e. , the capacities are @xmath31 for all arcs @xmath32 . *",
    "let @xmath33 be the class of instances where _",
    "_ a__ll _ _ a__rcs have a job associated , i.e. , @xmath34 .    for instance @xmath35 is the set of all instances with a series - parallel network which is not balanced , a job associated with every arc , and the constraint that at most @xmath36 jobs can be scheduled per time period . in general , @xmath0 is not constant , and we also consider instance classes with varying @xmath0 , but imposing some restrictions on how @xmath0 can vary relative to other instance parameters .",
    "for instance , @xmath37 is the class of instances with a series - parallel network and no limit on the number of jobs per time period , and @xmath38 contains the instances in which at most one third of all jobs can be scheduled per time period . as proved in  @xcite , the classes @xmath39 and @xmath40 are trivial : it is always optimal to schedule all jobs at the same time .",
    "in contrast , the restriction of the problem to @xmath41 is still strongly np - hard , and the restriction to @xmath37 is np - hard , but for fixed @xmath10 it can be solved in pseudopolynomial time using dynamic programming .",
    "our new complexity results are summarized in table  [ tab : results ] .",
    ".complexity results . [",
    "cols=\"<,<\",options=\"header \" , ]     note that the classes @xmath27 , @xmath28 and @xmath42 are interesting from the coal chain point of view : the actual network underlying the work in  @xcite is series - parallel , almost balanced , and has the property that a large proportion of the arcs has the same capacity .",
    "note that the problem is solvable in polynomial time if both @xmath10 and @xmath0 are bounded , say @xmath43 and @xmath44 for some absolute constants @xmath45 and @xmath46 .",
    "then @xmath47 for any feasible instance , and we can enumerate all partitions of @xmath15 into at most @xmath10 sets of size at most @xmath0 of which there are at most @xmath48 for each of these partitions we have to solve @xmath10 maximum flow problems , hence the run - time is bounded by @xmath49 , since the maximum flow problem can be solved in @xmath50 time  @xcite .",
    "consequently , for the asymptotic analysis we are interested in instance classes where at least one of the parameters @xmath10 and @xmath0 is unbounded .",
    "the paper is organized as follows . in section  [ sec : k_2 ] we show that the case @xmath25 can be solved in polynomial time .",
    "in addition we provide an explicit description of an optimal solution for @xmath25 and a network with a single transshipment node which leads to a significantly better run - time bound for this case .",
    "the hardness results are proved in section  [ sec : hardness ] . in section  [ sec : fptas ] we present a fully polynomial time approximation scheme for series - parallel networks with fixed time horizon .",
    "we also provide a polynomial time approximation scheme for series parallel networks in general when @xmath51 .",
    "in this section we consider the case @xmath25 . in section  [ subsec : general ]",
    "we show that this case can be reduced to a maximum weighted matching problem and thus is solvable in polynomial time , and in section  [ subsec : single_node ] we give an explicit description of an optimal solution for the case that the network has only a single transshipment node .",
    "we reduce the problem to a maximum weight perfect matching problem .",
    "let @xmath52 denote the maximum flow value in the whole network , for @xmath53 let @xmath54 denote the maximum flow when arc @xmath20 is shut , and for distinct @xmath55 let @xmath56 be the maximum flow when arcs @xmath20 and @xmath57 are shut .",
    "we set @xmath58 and define an auxiliary graph whose vertex set contains two vertices for every arc @xmath53 and two sets @xmath59 and @xmath60 of dummy vertices with @xmath61 and @xmath62 .",
    "the two vertices for @xmath53 are denoted by @xmath20 and @xmath63 , and the weighted edge set of the auxiliary graph is defined as follows :    * for distinct arcs @xmath55 there is an edge @xmath64 with weight @xmath65 . * for @xmath53",
    "there is an edge @xmath66 of weight @xmath54 .",
    "* there are all edges of the form @xmath67 for @xmath53 and @xmath68 .",
    "all these edges have zero weight . *",
    "the vertex set @xmath60 induces a matching consisting of zero weight edges .",
    "there is a correspondence between perfect matchings in the auxiliary graph and outage schedules .",
    "let @xmath69 be a perfect matching in the auxiliary digraph .",
    "the corresponding schedule has    * for every edge @xmath70 with @xmath55 one time period with arcs @xmath20 and @xmath57 shut , * for every edge @xmath71 with @xmath53 one time period with only arc @xmath20 shut , * all other time periods without shut arcs .",
    "this construction is illustrated in figure  [ fig : matching ] for @xmath72 and @xmath73 .",
    "the bold edges form a perfect matching corresponding to scheduling the following outage of schedule : period 1 : @xmath74 , period 2 : @xmath75 , period 3 : @xmath76 , period 4 : @xmath77 , period 5 : @xmath78 , period 6 : @xmath79 .    for a perfect matching @xmath69",
    "we define subsets @xmath80 and @xmath81 by @xmath82 note that the @xmath83 nodes in @xmath59 must be matched to nodes @xmath63 , hence @xmath84 and with @xmath85 this implies @xmath86 the total throughput for the schedule corresponding to the matching @xmath69 is @xmath87 where @xmath88 is the weight of @xmath69 .",
    "thus the original problem is equivalent to finding a maximum weighted perfect matching in the auxiliary graph , and with an efficient implementation  @xcite of the blossom algorithm  @xcite we have proved the following proposition .",
    "[ prop : poly_k_2 ] for @xmath25 the problem mfass can be solved in @xmath89 time .",
    "consider a network with a single transshipment node @xmath9 , a job set @xmath15 , a time horizon @xmath10 and @xmath25 .",
    "we use the notation @xmath90 and @xmath91 and assume without loss of generality that @xmath92 .",
    "we order the arcs in @xmath93 and @xmath94 such that the capacities are non - increasing , i.e. @xmath95 and @xmath96 ( @xmath97 ) with @xmath98 note that it is necessary for feasibility that @xmath99 , and in particular @xmath100 .",
    "we will show that an optimal solution can be obtained as follows .",
    "[ prop : k_2_single_node ] an optimal solution for the single node problem with @xmath25 is given by the following schedule .",
    "* for @xmath101 take arcs @xmath102 and @xmath103 out in time period @xmath21 . * for @xmath104",
    "take arc @xmath103 out in time period @xmath21 . *",
    "if @xmath105 then for @xmath106 take arcs @xmath103 and @xmath107 out in time period @xmath21 .    for the proof of proposition  [ prop : k_2_single_node ] we will need the following notation for the inbound and outbound capacities under various outage scenarios .",
    "@xmath108 we need the following inequality .",
    "[ lem : inequality ] for any real numbers @xmath109 satisfying @xmath110 $ ] , @xmath111 and @xmath112 , we have @xmath113    the lhs is @xmath114 , and we have @xmath115    let @xmath116 be the schedule described in the proposition , and let @xmath117 be the set of arcs that are scheduled to be shut in period @xmath21 ( @xmath118 )",
    ". for the sake of contradiction , suppose that @xmath116 is not optimal . among all optimal schedules we can choose one ,",
    "say @xmath119 , that differs from @xmath116 as late as possible , i.e. , such that the smallest index @xmath21 with @xmath120 is maximal , where @xmath121 is the set of arcs that are shut down in period @xmath21 according to schedule @xmath119 .",
    ": :    @xmath122",
    ". there are indices    @xmath123 with @xmath124 , and    @xmath125 . without loss of generality",
    ", we may assume @xmath126 ,    since otherwise @xmath121 could be swapped with    @xmath127 to yield a schedule with the same objective value .",
    "furthermore , @xmath128 since otherwise @xmath129 .    replacing @xmath121 with @xmath130 and    @xmath131 with @xmath132",
    "we obtain another schedule    @xmath133 which agrees with @xmath116 for one time    period more than @xmath119 . in order to arrive at the required    contradiction we have to check that schedule",
    "@xmath133 is not    worse than schedule @xmath119 .",
    "note that the schedules    @xmath119 and @xmath133 differ only in periods    @xmath21 and @xmath134 .",
    "we distinguish several cases for    the sets @xmath121 and @xmath131 . for each case we    write down the total flows in periods @xmath21 and    @xmath134 for the schedules @xmath119 and    @xmath133 , and then we apply lemma  [ lem : inequality ] to verify    that @xmath133 is at least as good as @xmath119 .",
    "+    case 1.1 .",
    "; ;      @xmath135 and      @xmath136 for some      @xmath137 and      @xmath138 .",
    "@xmath139 the claim follows from lemma  [ lem : inequality ]      with      @xmath140 .",
    "case 1.2 . ; ;      @xmath135 for some      @xmath138 , and @xmath141 .",
    "@xmath142 the claim follows from lemma  [ lem : inequality ]      with @xmath143 .",
    "; ;      @xmath144 and @xmath136 for      some @xmath137 .",
    "@xmath145 the claim follows from lemma  [ lem : inequality ]      with      @xmath146 .",
    "case 1.4 . ; ;      @xmath144 and @xmath141 .",
    "@xmath147 the claim follows from lemma  [ lem : inequality ]      with @xmath148 .",
    "case 1.5 . ; ;      @xmath149 and      @xmath150 .",
    "@xmath151 the claim follows from lemma  [ lem : inequality ]      applied twice , first with      @xmath152      and then with      @xmath153 :      @xmath154    case 1.6 . ; ;      @xmath149 for some      @xmath137 , and @xmath141 .",
    "@xmath155 the claim follows from lemma  [ lem : inequality ]      with      @xmath156 .",
    "case 1.7 . ; ;      @xmath144 and , @xmath150 for      some @xmath138 .",
    "@xmath157 the claim follows from lemma  [ lem : inequality ]      with      @xmath158 .",
    "case 1.8 . ; ;      @xmath149 and @xmath159      for some @xmath160 .",
    "@xmath161 the claim follows from lemma  [ lem : inequality ]      with      @xmath162 .",
    "case 1.9 . ; ;      @xmath163 and      @xmath164 for some      @xmath165 .",
    "@xmath166 the claim follows from lemma  [ lem : inequality ]      with      @xmath167 .",
    ": :    @xmath168 and @xmath169 . without loss of    generality , we assume that @xmath170 , and then    @xmath120 implies @xmath171    for some @xmath172 .",
    "furthermore ,    @xmath173 ,    and from @xmath174 and    @xmath175 it follows that    @xmath176 for some    @xmath177 . consequently ,",
    "@xmath178 or @xmath179 for some    @xmath138 . replacing @xmath121 with    @xmath180 and @xmath131 with",
    "@xmath181 we obtain another schedule    @xmath133 which agrees with @xmath116 for one time    period more than @xmath119 , and we claim that @xmath133    is not worse than @xmath119 .",
    "if @xmath179 then    the total flows in periods @xmath21 and @xmath134 are    @xmath182 and the claim follows from lemma  [ lem : inequality ]    with    @xmath183 .",
    "if @xmath178 then the total flows in periods    @xmath21 and @xmath134 are @xmath184 and the claim follows from lemma  [ lem : inequality ]    with @xmath185 .",
    ": :    @xmath168 and @xmath186 .",
    "we have    @xmath187 .",
    "this implies @xmath188 for all    @xmath189 . without loss of generality ,",
    "we    assume @xmath171 for some    @xmath190 , and there exists    @xmath177 with    @xmath191 for @xmath192 and    some @xmath193 .",
    "replacing    @xmath121 with @xmath194 and    @xmath131 with @xmath195 we obtain another    schedule @xmath133 which agrees with @xmath116 for one    time period more than @xmath119 .",
    "the total flows in periods    @xmath21 and @xmath134 are @xmath196 from lemma  [ lem : inequality ] with    @xmath197    it follows that @xmath133 is at least as good as    @xmath119 and this is the required contradiction .",
    "since sorting the arcs dominates the run - time of the algorithm to find the solution described in proposition  [ prop : k_2_single_node ] we obtain the following stronger run - time bound for the single - node case .",
    "[ cor : k=2_single_node ] for @xmath25 and a single transshipment node mfass can be solved in time @xmath198 .",
    "before proving the hardness results we make precise the definition of _ series - parallel network_. in the present paper this term refers to a _ two - terminal series - parallel network _ : a network that has a single source and single sink and is constructed by a sequence of series and parallel compositions starting from single arcs . for two networks @xmath199 and @xmath200 the _ parallel composition _ of @xmath199 and @xmath200 is obtained by identifying the source node @xmath201 and sink node @xmath202 of @xmath199 with the source node @xmath203 and sink node @xmath204 of @xmath200 , respectively .",
    "the _ series composition _ of @xmath199 and @xmath200 is obtained by identifying the sink node @xmath202 of @xmath199 with the source node @xmath203 of @xmath200 .",
    "the construction of a series parallel network can be encoded into a tree , the so - called sp - tree , whose leaves are the arcs of the network .",
    "this is illustrated in figure  [ fig : sp_tree ] .",
    "[ prop : strong_hardness ] the restriction of mfass to the instance class @xmath205 is strongly np - complete .",
    "we use reduction from 3-partition .",
    "let a 3-partition instance be given by an integer @xmath206 and a set @xmath207 of integers with @xmath208 for all @xmath209 and @xmath210 .",
    "the problem is to decide if there is a partition of the set @xmath207 into @xmath211 triples such that the sum of each triple equals @xmath206 .",
    "we define new numbers @xmath212 for @xmath213 by @xmath214 .",
    "note that @xmath215 and for every triple @xmath216 we have @xmath217 without loss of generality we assume that for some integer @xmath218 , we have @xmath219 for @xmath122 and @xmath220 for @xmath168 .",
    "we define an instance of our problem with @xmath24 , @xmath221 , a single transshipment node @xmath9 and the following arcs :    * for @xmath101 there is an arc @xmath102 into @xmath9 having capacity @xmath212 , and * for @xmath222 there is an arc @xmath102 that goes out of @xmath9 and has capacity @xmath223 .",
    "this is illustrated in figure  [ fig : strong_111 ] , where the arc labels represent capacities and all arcs have an associated job , i.e. , @xmath34 .",
    "obviously the network is series - parallel . from @xmath24 , @xmath221 and @xmath224",
    "it follows that we need to shut down exactly 3 arcs in every period .",
    "it follows from   that the network is balanced .",
    "let @xmath225 be the capacity of the network .",
    "clearly , @xmath226 is an upper bound for the total throughput , and we claim that this bound can be achieved if and only if the set @xmath227 can be partitioned into triples that sum up to zero , or equivalently , the set @xmath228 can be partitioned into triples that sum up to @xmath206 .",
    "first assume that @xmath229 is a partition with @xmath230 for all @xmath231 .",
    "consider the schedule that shuts down the arcs @xmath232 , @xmath233 and @xmath234 in period @xmath218 .",
    "it follows from @xmath230 that the network with arc set @xmath235 is balanced , and therefore we get a feasible flow in which every arc in @xmath236 is at capacity .",
    "therefore , every arc is at capacity in @xmath237 periods and the total throughput equals @xmath238 conversely , if there is a schedule with a total throughput of @xmath226 then every arc must be at capacity in every period in which it is not shut down .",
    "this implies that in every period @xmath231 the network with arc set @xmath235 , is balanced , where @xmath239 , @xmath240 and @xmath241 are the indices of the arcs that are shut down in period @xmath242 .",
    "consequently @xmath230 for every @xmath231 , and this yields a solution for the 3-partition instance .    .",
    "]    . ]",
    "[ prop : weak_hardness ] the restriction of mfass to the instance class @xmath243 is np - complete .",
    "we use reduction from partition .",
    "let a partition instance be given by an integer @xmath206 and a set @xmath244 of integers with @xmath245 .",
    "the problem is to decide if there is a partition of the set @xmath244 into two parts such that the sum of each part equals @xmath206 .",
    "the network used for the reduction is shown in figure  [ fig : weak_111 ] , where the arc labels represent capacities and all arcs have an associated job , i.e. , @xmath34 . consider this network for the time horizon @xmath246 and with @xmath247 .",
    "each of the two arcs of capacity @xmath206 can carry at most @xmath206 units of flow over the whole time horizon , because it needs to be shut down for one period .",
    "therefor @xmath248 is an upper bound for the total throughput .",
    "it is not possible to have a flow of @xmath248 in a single period , since otherwise all @xmath249 arcs would need to be shut in the other period .",
    "therefore , in order to achieve the bound of @xmath248 we must have a flow of value @xmath206 in each time period .",
    "this is possible if and only if the total capacity of the arcs between @xmath12 and @xmath9 that are shut down in period 1 is @xmath206 , i.e. , the partition instance is a yes instance .",
    "note that the algorithm from  @xcite for series - parallel networks and @xmath250 which is pseudopolynomial for fixed @xmath10 can be adapted to the case @xmath251 .",
    "this algorithm computes a list of @xmath10-dimensional vectors for each node of the sp - tree .",
    "the vectors at a node @xmath9 of the sp - tree represent the possible throughputs for the corresponding subnetwork : @xmath252 is in the list at node @xmath9 if and only if the jobs for arcs in the subnetwork can be scheduled such that the maximum flow value for the subnetwork in time period @xmath21 is @xmath253 ( @xmath118 ) . in each node of the tree",
    "we flag a vector that can only be achieved by scheduling all jobs at the same time ( which is at most one per node in the tree ) .",
    "finally , when we scan the list at the root node in order to determine the optimal solution , we exclude the flagged vector .    in  @xcite , the class @xmath30 of instances where every arc has unit capacity was shown to be tractable when there is no limit for the number of jobs per time period .",
    "we finish this section with a proof that this class becomes np - complete when such a limit is introduced .    [",
    "prop : unit_cap ] the restriction of mfass to the instance class @xmath30 is np - complete .",
    "we use reduction from 3-partition .",
    "let a 3-partition instance be given by an integer @xmath206 and a set @xmath207 of integers with @xmath208 for all @xmath209 and @xmath210 .",
    "this can be reduced to the instance presented in figure  [ fig : unit_cap ] , where every arc has unit capacity and the set @xmath15 is represented by dashed arcs .    .",
    "the dashed arcs indicate the set @xmath15 of arcs with an associated job . ]",
    "since 3-partition is strongly np - hard we may assume that the numbers @xmath254 are bounded by a polynomial in the input size , and this ensures that the network size is polynomial in the size of the 3-partition instance .",
    "we consider this network with a time horizon @xmath221 and a bound of @xmath255 jobs per time period .",
    "the total throughput is bounded by @xmath256 since the total capacity of the arcs entering node @xmath13 is @xmath257 and there are @xmath211 time periods . from @xmath258",
    "it follows that exactly @xmath206 jobs have to be scheduled in each time period .",
    "we claim that the bound of @xmath256 on the total throughput can be achieved if and only if the 3-partition instance is a yes instance .",
    "first suppose the 3-partition instance is a yes instance , and let @xmath259 be a partition with @xmath260 for all @xmath231 .",
    "we obtain a schedule that achieves the upper bound as follows . in time",
    "period @xmath242 we shut down the arcs on the paths number @xmath239 , @xmath240 and @xmath241 , where the paths between @xmath12 and @xmath9 are numbered from top to bottom in figure  [ fig : unit_cap ] , i.e. , the @xmath21-th path contains exactly @xmath254 dashed arcs .",
    "conversely , suppose that there is a schedule that achieves a total throughput of @xmath256 .",
    "for @xmath231 let @xmath261 be the set of paths on which at least one arc is shut down in period @xmath242 . in order to achieve a total throughput of @xmath256",
    "we must have a flow of value @xmath257 in each time period .",
    "therefore , in each period we can shut down arcs on at most 3 paths from @xmath12 to @xmath9 , i.e. , @xmath262 for all @xmath231 .",
    "since all dashed arcs have to be shut down in some time period we have @xmath263 , and consequently , @xmath264 for all @xmath242 and @xmath265 for all @xmath266 .",
    "this implies that in every time period all arcs on exactly 3 paths are shut down , hence @xmath267 for every @xmath231 and the 3-sets @xmath268 form a solution of the 3-partition instance .",
    "in this section we restrict our attention to series - parallel networks .",
    "we modify the algorithm from  @xcite such that the bound @xmath0 can be taken into account . for fixed time",
    "horizon @xmath10 , this algorithm runs in pseudopolynomial time , and we use it together with scaling and rounding  @xcite to design an fptas .",
    "the algorithm presented in  @xcite starts at the leaves of the sp - tree and computes a list of vectors @xmath269 for each node of the sp - tree , where the list at a node @xmath9 in the sp - tree contains exactly the vectors @xmath270 such that there exists some schedule for which the subnetwork corresponding to @xmath9 can carry flow @xmath253 in time period @xmath21 for @xmath118 . in the problem variant",
    "studied in  @xcite there is no restriction on the number of arcs that can be shut in a period , so it is sufficient to keep track of the possible flow vectors at the nodes of the sp - tree .",
    "but the same capacity vector can be realised through different schedules . for instance , for the network shown in in figure",
    "[ fig : example ] , there are three possibilities to get the flow vector @xmath271 , i.e. 7 units in the first time period and zero flow in the second period :    * shut 2 arcs in period 1 ( arcs with capacities 1 and 2 ) , and 2 arcs in period 2 ( arcs with capacities 8 and 7 ) ; or * shut 1 arc in period 1 ( arc with capacity 1 or 2 ) , and 3 arcs in period 2 ( arcs with capacities 8 , 7 and ( 2 or 1 ) ) ; or * shut no arc in period 1 , and all four arcs in period 2 .    thus with a limit @xmath0 for the number of shut arcs per time period it becomes important to keep track of the number of arcs shut in each period along with maximum flow that can be sent in that period",
    "let @xmath272 represent the number of arcs shut in the @xmath273 period .",
    "we determine lists of _ job - capacity _ vectors of the form @xmath274 at each node of the sp - tree .",
    "the interpretation of such a vector @xmath270 in the list of node @xmath275 is that there is a solution in which , for @xmath118 , in time period @xmath21 exactly @xmath272 arcs from the subnetwork corresponding to @xmath275 are shut , and this subnetwork has capacity @xmath253 . due to the symmetry with respect to the time periods",
    "it is no loss of generality to require the job - capacity vectors to be ordered .",
    "hence we consider only vectors that satisfy , for @xmath276 , either @xmath277 or @xmath278 and @xmath279 .",
    "we say that a vector with this property is in _ standard form _ , and we note that for every job - capacity vector there is a unique vector in standard form which can be obtained by a permutation of the entries . the list at a leaf node of the tree , corresponding to an arc @xmath20 of the network , consists of the unique vector @xmath280 if @xmath281 or @xmath282 if @xmath283 . as in  @xcite , let @xmath284 and @xmath285 denote the sets of leaves and internal nodes of the sp - tree , and let @xmath286 ( @xmath287 ) be the set of internal nodes at distance @xmath21 from the root .",
    "the lists of job - capacity vectors are computed as described in algorithm  [ alg : sp_networks_k ] .    ............................................",
    "+ * for * @xmath288 * do * + let @xmath32 be the arc corresponding to @xmath9 + * if * @xmath53 * then * @xmath289 $ ] + * else * @xmath290 $ ] + * for * @xmath291 * do * + * for * @xmath292 * do * + @xmath293$]\\{initialize empty list } + let @xmath294 and @xmath295 be the child nodes of @xmath9 + * for * @xmath296 and @xmath297 permutation of @xmath298 * do * + * for * @xmath299 $ ] * do * @xmath300 + * if * @xmath301 for all @xmath299 $ ] * then * + * if * @xmath9 is a parallel composition node * then * + * for * @xmath299 $ ] * do * @xmath302 + * else * + * for * @xmath299 $ ] * do * @xmath303 + sort @xmath304 to get the corresponding canonical vector + * if * @xmath305 * then * add @xmath304 to @xmath306 + let @xmath9 be the root node + return @xmath307    consider the series - parallel graph in figure  [ fig : example ] where arc labels indicate capacities , all arcs need maintenance for a period over a time horizon of 2 periods .",
    "suppose that @xmath24 .",
    "in figure  [ fig : algorithm_run_k ] , we show how job - capacity vectors are computed in the sp - tree .",
    "[ prop : runtime ] let @xmath308 be the number of arcs , b be an upper bound for the capacities and k be the limit on the number of arcs that can be shut in a period . for series - parallel networks mfass can be solved in time @xmath309 .",
    "the first and second component of an entry of a vector in the list at an internal node are bounded by @xmath0 and @xmath310 respectively , hence each entry can take @xmath311 possible values .",
    "therefore every list can contain at most @xmath312 elements .",
    "thus , the loop over @xmath313 and permutations @xmath297 is over at most @xmath314 elements .",
    "if hash tables are used for the check of @xmath315 then the bound of @xmath316 for sorting @xmath304 dominates the run - time of the loop . in total",
    "there are @xmath317 internal nodes , thus the run - time of the complete algorithm is @xmath309 .    from proposition  [ prop : runtime ]",
    ", it follows that for fixed @xmath10 mfass on series - parallel networks can be solved in @xmath318 time where @xmath206 is the maximum capacity of an arc in the network .",
    "now we use a scaling approach to derive a fully polynomial approximation scheme ( fptas ) , that is a family @xmath319 of algorithms , parameterized by a positive real number @xmath320 , such that algorithm @xmath321 produces a solution with objective value at least @xmath322 , where @xmath323 is the optimal value , and the run - time of algorithm @xmath321 is polynomially bounded in the input size and @xmath324 .",
    "our approximation scheme is based on scaling the problem such that the maximum capacity becomes bounded . in order to ensure that the solution of the scaled problem is sufficiently close to the optimum we need a lower bound for the optimal objective value .",
    "if @xmath325 there is a feasible solution having one time period without any outage , and the flow value for such a time period will be sufficient as lower bound for our purpose .",
    "for @xmath326 the situation is more complicated , and we need a preprocessing step to transform a given instance into an equivalent one with some control on the maximum capacity .",
    "let @xmath327 , and let @xmath69 be the maximum flow value with @xmath328 arcs closed . for @xmath329",
    ", @xmath69 is the capacity of a minimum cut and can be computed by solving a max flow problem .",
    "for @xmath330 , the computation of @xmath69 is described in algorithm  [ alg : get_m ] .    ............................................",
    "+ * for * @xmath288 * do * + let @xmath32 be the arc corresponding to @xmath9 + @xmath331 + * if * @xmath53 * then * @xmath332 * else * @xmath333 + * for * @xmath334 * do * @xmath335 + * for * @xmath291 * do * + * for * @xmath292 * do * + * for * @xmath336 * do * @xmath335 + let @xmath294 and @xmath295 be the child nodes of @xmath9 + * for * @xmath336 * do * + * for * @xmath337 * do * + * if * @xmath9 is a parallel composition node * then * + @xmath338 + * else*\\{@xmath9 is a series composition node } + @xmath339 + let @xmath9 be the root node + return @xmath340    here , for a node @xmath9 in the sp - tree and a number @xmath341 , @xmath342 is the capacity of the subnetwork corresponding to node @xmath9 when @xmath209 arcs in the intersection of @xmath15 and this subnetwork are closed .",
    "if @xmath209 is larger than the size of this intersection , we put @xmath343 .",
    "algorithm  [ alg : get_m ] shows that @xmath69 can be computed efficiently .",
    "no arc can carry more than @xmath69 units of flow in any time period , hence we may assume w.l.o.g . that @xmath345 .",
    "we also know that the optimal objective value is at least @xmath69 because , we can schedule @xmath328 jobs allowing a flow of value @xmath69 in time period 1 , and then continue arbitrarily .",
    "let @xmath346 and consider the scaled problem with the capacities @xmath347 replaced by @xmath348 .",
    "the scaled instance can be solved in time @xmath349 for any feasible vector @xmath350}\\in\\{0,1\\}^{\\lvert j\\rvert\\ , t}$ ] , let @xmath351 and @xmath352 denote the objective values for the problem on the original network and for the scaled version , respectively .",
    "let @xmath353}$ ] and @xmath354}$ ] denote optimal solutions of the problem on the original network and of the scaled version , respectively .",
    "in the following lemma , we study the the behaviour of the objective values for these solutions under the scaling .",
    "both inequalities are obvious for @xmath356 , because in this case the original and the scaled problem coincide .",
    "so we assume @xmath357 .",
    "for @xmath118 let @xmath358 be a minimum cut in the network @xmath359 where @xmath360 . then , using @xmath361 , we obtain @xmath362 similarly , let @xmath363 be a minimum cut in the network @xmath364 where @xmath365 .",
    "then @xmath366        the problem can be generalized by allowing the bound on the number of jobs to vary over time .",
    "in other words , the parameter @xmath0 is replaced by a vector @xmath369 and constraints  ( [ eq : job_bound ] ) are replaced by @xmath370.\\ ] ] algorithm  [ alg : sp_networks_k ] can be modified to solve this more general problem , and with @xmath371}k_i\\right\\}\\ ] ] we obtain an fptas of runtime @xmath372 for this problem .    for @xmath250 , it was shown in  @xcite that the method corresponding to algorithm  [ alg : sp_networks_k ] runs in time @xmath373 , and using the same argument as above , we obtain the following approximation result .",
    "if @xmath10 is not fixed we still get a ptas using the fact that for @xmath375 shutting all arcs in the job set @xmath15 at the same time gives an approximation ratio of @xmath376 .",
    "the basic idea is that in order to get a @xmath377-approximation for an instance with arbitrary @xmath10 we can distinguish two cases : if @xmath378 we schedule all jobs at time 1 and otherwise we run the @xmath377-approximation algorithm from proposition  [ prop : fptas2 ] .",
    "let @xmath381 be fixed . if @xmath378 we schedule all jobs at time 1 .",
    "otherwise @xmath382 and we run the @xmath377-approximation algorithm for @xmath10 . by proposition  7 in  @xcite , the run - time",
    "is bounded by @xmath383 we have @xmath384 with @xmath385 and @xmath386 we obtain @xmath387^{2(t-1)\\alpha/\\beta}\\leqslant e^{2(t-1)\\alpha/\\beta}.\\ ] ] now @xmath388 and this implies @xmath389 substituting into  ( [ eq : runtime_bound ] ) yields a run - time bound of @xmath390 and since all terms are increasing in @xmath10 , we get with @xmath391 and using stirling s formula to bound the factorial , that the run - time is bounded by @xmath392              n.  boland , t.  kalinowski , h.  waterer , and l.  zheng .",
    "an optimisation approach to maintenance scheduling for capacity alignment in the hunter valley coal chain . in e.y .",
    "baafi , r.j .",
    "kininmonth , and i.  porter , editors , _ proceedings of the 35th apcom symposium : applications of computers and operations research in the minerals industry _",
    ", pages 887897 .",
    "the australasian institute of mining and metallurgy publication series , 2011 .",
    "n.  boland , b.  mcgowan , a.  mendes , and f.  rigterink .",
    "modelling the capacity of the hunter valley coal chain to support capacity alignment of maintenance activities . in j.",
    "piantadosi , r.s .",
    "anderssen , and j.  boland , editors , _",
    "modsim2013 , 20th international congress on modelling and simulation _ , pages 33023308 .",
    "modelling and simulation society of australia and new zealand , 2013 .",
    "n.  boland and m.  w.  p. savelsbergh . optimizing the hunter valley coal chain . in h.",
    "gurnani , a.  mehrotra , and s.  ray , editors , _ supply chain disruptions : theory and practice of managing risk_. springer - verlag london ltd . , 2011 .",
    "t.  lidn .",
    "survey of railway maintenance activities from a planning perspective and literature review concerning the use of mathematical algorithms for solving such planning and scheduling problems .",
    "technical report , linkpings universitet , 2014 ."
  ],
  "abstract_text": [
    "<S> we study the problem of scheduling maintenance on arcs of a capacitated network so as to maximize the total flow from a source node to a sink node over a set of time periods . </S>",
    "<S> maintenance on an arc shuts down the arc for the duration of the period in which its maintenance is scheduled , making its capacity zero for that period . </S>",
    "<S> a set of arcs is designated to have maintenance during the planning period , which will require each to be shut down for exactly one time period . in general </S>",
    "<S> this problem is known to be np - hard , and several special instance classes have been studied . here </S>",
    "<S> we propose an additional constraint which limits the number of maintenance jobs per time period , and we study the impact of this on the complexity .    </S>",
    "<S> : network models , complexity theory , maintenance scheduling , mixed integer programming    : 90c10 , 90b10 , 68q25 </S>"
  ]
}