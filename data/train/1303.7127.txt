{
  "article_text": [
    "polarization gives rise to an elegant and provably good class of channel codes , called _ polar codes _  @xcite .",
    "decoding of polar codes is usually performed using a successive cancellation ( sc ) decoder  @xcite .",
    "some hardware architectures for sc decoding of polar codes were discussed in  @xcite , and @xcite , while the first asic of such a decoder was presented in  @xcite . moreover ,",
    "an fpga implementation of a belief propagation decoder for polar codes was presented in @xcite .",
    "recently , more sophisticated decoding algorithms , such as the list sc decoder @xcite , and the stack sc decoder @xcite , were introduced .",
    "these algorithms provide improved error correcting performance at the cost of increased complexity .",
    "stack sc decoding suffers from high memory requirements , costly metric normalization , and non - deterministic decoding latency , making list sc decoding more attractive from a practical perspective .",
    "unfortunately , the list sc decoder is burdened by a likelihood copying step and no architecture of such a decoder exists yet in the literature .",
    "this brief presents an architecture for list sc decoding of polar codes . to this end",
    ", we also describe how the copying of the intermediate likelihoods in the list sc decoding algorithm can be avoided . in section [",
    "sec : polardec ] , we briefly review the construction and decoding of polar codes .",
    "section  [ sec : alg ] discusses algorithmic improvements to list sc decoding , while in section  [ sec : arch ] the proposed list sc decoder architecture is described .",
    "section  [ sec : results ] summarizes vlsi implementation results and concludes this letter .",
    "we use @xmath4 to denote a row vector @xmath5 and @xmath6 to denote the subvector @xmath7 .",
    "we use the operators @xmath8 and @xmath9 for the binary and natural logarithm , respectively .",
    "a polar code is constructed by recursively applying a polarizing transform @xmath10 times to the binary input symmetric and memoryless channel @xmath11 .",
    "this transform is linear and it can be expressed as a @xmath12 matrix , denoted by @xmath13 . the @xmath10-fold application of this transform can be expressed as an @xmath14 matrix @xmath15 , with @xmath16 , where @xmath17 denotes the @xmath10-fold application of the kronecker product .",
    "encoding is performed by choosing a sequence @xmath18 and calculating the codeword @xmath19 .",
    "this codeword is transmitted over @xmath20 uses of @xmath11 and a noisy codeword @xmath21 is received .      the decoding method proposed by arikan",
    "is based on successive cancellation . first , an estimate for @xmath22 , denoted by @xmath23 , is calculated based on @xmath21 . then , @xmath24 is decoded , based on @xmath21 _ and _ the knowledge of @xmath23 , etc . in principle",
    ", it is possible to calculate the mutual information between @xmath25 and @xmath26 for every @xmath27 .",
    "a polar code of rate @xmath28 is constructed by letting only the @xmath29 @xmath26 s with the highest mutual information convey information , while freezing the remaining @xmath26 s to @xmath30 .",
    "the sets of non - frozen and frozen bit indices are denoted by @xmath31 and @xmath32 , respectively .     with @xmath33.,scaledwidth=30.0% ]    the exact decoding procedure is dictated by the recursive structure of the code . in fig .",
    "[ fig : sc ] , the decoding process is visualized for @xmath33 . on the right - hand side of the graph , the likelihoods @xmath34 are available .",
    "these likelihoods are combined pair - wise by going through a data dependency graph ( ddg ) with @xmath35 nodes , which are grouped into @xmath36 _ stages_. the output on the left side of the graph is @xmath37 .",
    "hard decisions are taken according to @xmath38 the two pairs of incoming likelihoods at each node , denoted by @xmath39 and @xmath40 , are combined in order to produce the _ intermediate likelihoods _ , according to either @xmath41 ^ 4 \\rightarrow [ 0,1]^2 $ ] or @xmath42 ^ 4 \\times \\{0,1\\ } \\rightarrow [ 0,1]^2 $ ] with @xmath43 where @xmath44 is called a _ partial sum_. each partial sum is a linear combination of some of the previously decoded codeword bits @xcite . the circle and square nodes of the ddg in fig .",
    "[ fig : sc ] represent application of @xmath45 and @xmath46 , respectively . if intermediate likelihoods are stored , then the computational complexity of sc decoding is @xmath47  @xcite .",
    ".,scaledwidth=40.0% ]      successive decoding can be described as a search procedure on a full binary tree .",
    "the @xmath48 nodes at depth @xmath49 represent @xmath26 given all possible choices for @xmath50 .",
    "the two outgoing edges of each node in the tree are labeled with the two possible choices for @xmath51 .",
    "a decoder explores one or more paths in the tree by deciding which edge to follow at each step based on some metric .",
    "the sc decoder explores a single path from the root to the leaves of the tree .",
    "it uses the likelihood in ( [ eqn : ml ] ) as a metric for edges corresponding to non - frozen bits and it always follows the edge corresponding to @xmath30 for frozen bits .",
    "the sc decoder has the drawback that erroneous decisions at some point can never be recovered in the future .",
    "the list sc decoder , on the other hand , performs a breadth - first search on the tree under a complexity constraint .",
    "this constraint is enforced by discarding some of the paths at each step .",
    "specifically , the list sc decoder with list size @xmath52 keeps track of @xmath52 paths simultaneously and also uses the likelihood in ( [ eqn : ml ] ) as a path metric when encountering non - frozen bits .",
    "more formally , let @xmath53 denote the @xmath52 distinct decoding paths after the @xmath49-th bit has been decoded . for every path @xmath54 , there are two choices for @xmath55 . out of the resulting @xmath56 paths ,",
    "the @xmath52 paths with the highest metric are preserved .",
    "when bit @xmath20 is reached , the path with the highest metric is set as the decoded codeword .",
    "decoding paths for an sc and a list sc decoder with @xmath57 are shown by the red dashed and green dotted lines in fig .",
    "[ fig : listsctree ] , respectively .    all results in this paper",
    "are illustrated for @xmath0 and @xmath58 .",
    "the performance of list sc decoding over an awgn channel for some practical list sizes is compared with the performance of sc decoding in fig .",
    "[ fig : listsc ] .",
    "we performed @xmath59 monte - carlo simulations for each data point .",
    "we observe that the returns of increased list size are small for @xmath60 and that at high snr using @xmath61 provides almost no gain .",
    "however , at a fer of @xmath62 , which is a sensible target fer for many communications standards , e.g. , @xcite , the gain of list sc decoding is not negligible .",
    "polar code under sc and list sc decoding with various @xmath52.,scaledwidth=38.0% ]",
    "for each path , the intermediate likelihoods , the partial sums , and the path itself are stored in memories .",
    "we call these three memories collectively the _ state - memories_. the content of each memory forms the _ state _ of each path . after the path selection step , each of the initial @xmath52 paths is either discarded , kept , or duplicated , depending on whether it has zero , one , or two child nodes in the set of @xmath52 out of @xmath56 largest metrics , respectively . in order to duplicate a path , in a straightforward implementation its state",
    "is copied from one state - memory to another state - memory , with some differences between the two copies that correspond to the two different choices for @xmath51 .",
    "it was shown in @xcite that list sc decoding can be performed with complexity @xmath63 when using a _ lazy copy _ technique .",
    "our approach is to introduce an auxiliary _ pointer memory _ in order to avoid the high complexity of likelihood copying .",
    "the algorithm in fig .",
    "[ fig : alg1 ] describes list sc decoding .",
    "@xmath64 , @xmath65 , @xmath66 , and @xmath67 denote the likelihood , partial sum , path , and pointer memories , respectively . for simplicity",
    "we think of @xmath64 as a three - dimensional memory which is indexed by the path index , the current stage index , and the bit index . each element of @xmath64 stores a _",
    "likelihood pair_. the channel likelihood pairs are assumed to be stored in @xmath68 before listsc is called .",
    "@xmath65 , @xmath66 , and @xmath67 are two - dimensional memories .",
    "their first dimension is indexed by the path index and their second dimension is indexed by a combination of the partial sum , bit , and stage indices . the operation and structure of the pointer memory",
    "are described in the following section .",
    "the @xmath56 path metrics are stored in the @xmath69 memory @xmath70 .",
    "pathselection takes @xmath56 path metrics as input and outputs the indices of the parent paths corresponding to the paths with the @xmath52 best metrics , denoted by @xmath71 , and the corresponding values for @xmath72 .",
    "the straightforward copying approach is chosen for the partial sums and the paths because it can be carried out in a single clock cycle in hardware with small overhead due to the small size of the involved memories .",
    "lines 410 of can be performed in parallel , since there are no data dependencies between the loop iterations .",
    "updatestage , which performs the likelihood updates for the given decoding stage using the update rules described in @xcite , can also be executed in parallel for the @xmath73 nodes of the ddg that require updating at stage @xmath74  @xcite .",
    "* function * listsc@xmath75 @xmath76 @xmath77 index of first 1 in @xmath36-bit msb-0 binary representation of @xmath49 ( if @xmath78 , then @xmath76 @xmath79 ) @xmath80 @xmath81 @xmath82 @xmath83 @xmath84 @xmath85 @xmath86 @xmath87 @xmath88      in this section , we describe the function of the pointer memory @xmath67 .",
    "assume that , for the code in fig .",
    "[ fig : sc ] , we have @xmath57 , and @xmath89 are non - frozen while @xmath90 are frozen . decoding starts with one ( empty ) path .",
    "the path metrics for @xmath91 are calculated using the sc procedure based on the contents of the first state - memory .",
    "the intermediate likelihoods which are produced are written to the first state - memory .",
    "in general , the intermediate likelihoods which are produced for path @xmath54 , are written to the @xmath92-th state - memory .",
    "instead of taking a hard decision on @xmath23 as the sc decoder would , the list sc decoder duplicates the ( empty ) parent path and extends the first copy with @xmath93 and the second copy with @xmath94 .",
    "the sc procedure for the two new paths requires the intermediate likelihoods produced by their parent path in order to calculate the path metrics for @xmath95 .",
    "these likelihoods are located in the first state - memory , since they were produced by the first path in the previous decoding step .",
    "the intermediate likelihoods produced by the sc procedure for @xmath96 for the first and second paths are written to the first and second state - memory , respectively . from lines 58 of the list sc algorithm in fig .",
    "[ fig : alg1 ] , we see that the sc procedure does not process all stages of the decoding graph for each @xmath26 .",
    "so , if after @xmath97 has been processed the list sc decoder follows a new path whose parent is the second path , it has to read the intermediate likelihoods for the stages which were not processed when decoding @xmath97 from the first state - memory , and the intermediate likelihoods for the stages which were processed when decoding @xmath97 from the second state - memory .",
    "the auxiliary pointer memory @xmath67 of dimension @xmath98 keeps track of which memory stores each path s likelihood for each stage .",
    "when a decision for @xmath97 needs to be made , there are four candidate paths , out of which the two paths with the best metrics are kept , while the remaining two are discarded .",
    "now , instead of copying the intermediate likelihoods of the paths that we want to keep , it suffices to copy the references to the state - memories contained in the pointer memory .",
    "since @xmath99 and @xmath100 are frozen , both paths are extended with @xmath101 and @xmath102 and the best path is declared as the decoded codeword .",
    "sc decoding can be carried out in the log - likelihood ratio ( llr ) domain by modifying ( [ eqn : f])([eqn : g ] )  @xcite .",
    "llrs provide reduced storage requirements , increased numerical stability , as well as simplified computations with respect to a likelihood based implementation .",
    "the list sc decoding algorithm is described using likelihoods and log - likelihoods ( lls ) in @xcite and @xcite , respectively .",
    "llrs can be converted to lls by using @xmath103 . however",
    ", this conversion assumes that @xmath104 , which is not true in general .",
    "thus , each ll is normalized by a different factor , so the ordering of the path metrics will be affected and they can no longer be used to choose the @xmath52 best paths .",
    "for this reason , in our decoder the likelihoods are represented in ll form , which also simplifies the computations in ( [ eqn : f])([eqn : g ] ) and provides numerical stability , but requires more storage .",
    "we use negative lls , which are always positive numbers and do not require a sign bit , to make the binary representation more compact . assuming transmission over an awgn channel with noise variance @xmath105 , the negative lls are @xmath106 where @xmath107",
    ", @xmath108 is the modulated version of codeword bit @xmath109 . using negative lls , ( [ eqn : f ] ) and ( [ eqn : g ] )",
    "become @xmath110 where @xmath111 .",
    "the @xmath45 function is simplified by using an approximation that ignores the @xmath112 term . in fig .",
    "[ fig : listsc ] , the performance of sc and list sc decoding with this approximation are plotted using dashed lines .",
    "there is practically no difference in performance with respect to the exact implementation for the used blocklength and list sizes .",
    "our simulations show that the loss becomes slightly larger as the blocklength is increased .",
    "for example , for @xmath113 the loss is approximately @xmath114  db . moreover , let @xmath115 be constants .",
    "then , for any @xmath116 , we have @xmath117 at each stage of sc decoding only one type of function is used , so the constant terms are common for all involved calculations .",
    "thus , they can be recursively factored out and removed without affecting the ordering of the path metrics .",
    "so , we can use @xmath118 , which is easier to handle by the quantization step .",
    "the list sc decoder is a combination of three components .",
    "the first component is the metric computation unit ( mcu ) , which calculates the metrics for each path using the sequential sc procedure .",
    "the second component , called the _ state - memories _ component , consists of @xmath52 state - memories , which the mcu uses to compute the @xmath56 path metrics .",
    "moreover , a third component manages the tree search by performing _ path selection _ based on the metrics that are calculated by the mcu .",
    "an overview of the proposed list sc decoder architecture is presented in fig .",
    "[ fig : archhigher](a ) .",
    "the mcu contains @xmath52 _ sc decoder cores _ , which perform the metric calculation based on the state that they are supplied with .",
    "multiplexers are responsible for redirecting the correct lls to each decoder core , according to the entries of the pointer memory .",
    "the path selection unit contains a sorter which finds the @xmath52 best metrics out of @xmath56 options , along with the path index and the value of @xmath119 from which they resulted , and the pointer memory , which manages the memory read access of the sc decoder cores .",
    "polar code under floating - point and fixed - point list sc decoding for @xmath57.,scaledwidth=38.0% ]      since the lls are positive numbers , as sc decoding moves towards stage @xmath30 , their dynamic range increases . when an ll pair saturates , it is useless for making a decision . thus , when using lls , it is crucial to avoid saturation . in ( [ eq : fll ] ) and ( [ eq : gll ] ) , two numbers with the same dynamic range are added .",
    "the simplest way to avoid all saturations is to increase the number of bits used to store the lls by one bit per stage .",
    "this way , the only performance degradation with respect to the floating point implementation comes from the quantization of the channel lls .",
    "let @xmath120 denote the number of bits used for the quantization of the channel lls .",
    "the performance of the list sc decoder under various quantization bit - widths using a uniform quantizer with quantization step @xmath121 is presented in fig .  [",
    "fig : listscquant ] . for the remainder of this paper , we choose @xmath122 , since the degradation with respect to the floating point and to the @xmath123 implementations is very small .      the architecture of the sc decoder cores contained in the mcu is derived from the log - likelihood ratio ( llr ) based architecture of @xcite , which was modified to implement ll based sc decoding .",
    "each decoder core consists of @xmath124 processing elements ( pes ) that operate on up to @xmath124 nodes of each stage of the ddg in parallel . for fair comparison",
    ", we chose @xmath125 as in @xcite .",
    "three counters track the index @xmath27 of the bit that is currently being decoded , the current stage @xmath74 within the decoding graph , and the current part within the stage @xmath126 for the stages that require more than one cycle to be processed .",
    "all control signals and memory addresses are generated based on @xmath127 .",
    "the maximum ll bit - width , denoted by @xmath128 , determines the width of the pes . using the ll quantization scheme described previously",
    ", we have @xmath129 .",
    "the pes implement both ( [ eq : fll ] ) and ( [ eq : gll ] ) .",
    "an additional input is used to choose between the @xmath45 and @xmath46 outputs . due to the choice of quantization scheme ,",
    "no overflow checks are needed .",
    "the mcu contains @xmath52 @xmath52-to-@xmath130 multiplexers , which are controlled by the pointer memory in the path selection unit and redirect the correct lls to each sc decoder core .",
    "sc decoding can be implemented by storing 2n ll pairs @xcite , requiring a total of 4n data words .",
    "the @xmath20 first pairs that correspond to the channel lls are never overwritten during sc decoding .",
    "thus , only one copy of the channel ll memory is needed , from which all decoder cores can read . the remaining @xmath20 memory position pairs",
    "have to be distinct for each path .",
    "the number of required memory position pairs is @xmath131 and the total number of bits used for ll storage is @xmath132 there are @xmath52 partial sum and @xmath52 path memories , with @xmath20 memory positions of @xmath130 bit each , resulting in a total of @xmath133 bits .",
    "the architecture of the partial sum memories is identical to the one used in @xcite . in order to complete the state copying step in a single cycle",
    ", all the contents of each of the @xmath52 partial sum memories can be copied to and from one another by means of crossbars , as illustrated in fig .",
    "[ fig : archhigher ] .",
    "the same holds for the path memories .",
    "so , the number of bits per mcu state is @xmath134        for the path selection step , the @xmath56 metrics are sorted in a single cycle . to minimize the delay , a radix-@xmath56 sorter was implemented by extending the architecture presented in  @xcite to support finding of the @xmath52 smallest values , instead of only the @xmath135 smallest values .",
    "this sorter requires @xmath136 comparators of @xmath128-bit quantities .",
    "since a single sorter is needed , minimizing its size is not critical .",
    "in fact , the metric sorter occupies only 0.1% and 0.8% of the total decoder area for @xmath57 and @xmath137 , respectively .",
    "a register is added between the output of the mcu and the metric sorter in order to reduce the length of the critical path .",
    "unfortunately , decoding can not proceed before the choice of paths is made , so an idle cycle is introduced every time the output of the metric sorter is needed .",
    "this happens @xmath138 times per codeword .",
    "thus , by modifying the expression found in @xcite , the number of cycles required to decode one codeword is @xmath139 if we ignore the second term , which is small , then the overhead with respect to the case where we do not add a register is approximately @xmath138 cycles , or @xmath140 percent .",
    "nevertheless , adding the register leads to a higher throughput due to a higher clock frequency .",
    "the architecture of the metric sorter is presented in fig .",
    "[ fig : archhigher](b ) .",
    "the pointer memory contains @xmath98 elements .",
    "each element can take on @xmath52 distinct values , so we need @xmath141 bits for the representation . in total",
    ", the pointer memory contains @xmath142 bits .",
    "for example , for @xmath1 and @xmath143 , this translates to @xmath144 and @xmath145 bits , respectively , which is negligible .",
    "this memory also has the copying functionality that the partial sum and path memories provide .",
    "the architecture of the pointer memory is presented in fig .",
    "[ fig : archhigher](b ) .    .synthesis results and comparison . [ cols=\"^,^,^,^,^\",options=\"header \" , ]     we used the typical timing model at @xmath146c and @xmath130v supply voltage .",
    "synthesis results for @xmath143 and @xmath147 using a umc  90 nm cmos technology are shown in table  [ tab : synthesis ] .",
    "since there exist no other list sc decoder architectures in the literature , we try to quantify the additional hardware complexity that is required to reap the decoding gain benefits of list sc decoding by comparing our design with the existing sc decoder synthesis results of  @xcite and the chip results of  @xcite .    in this work ,",
    "the first list sc decoder architecture in the literature was presented .",
    "it was also described how to avoid copying of the intermediate likelihoods by copying between pointers instead of the actual values .",
    "the authors would like to thank pascal giard and gabi sarkis ( mcgill university ) , and mani bastani parizi ( epfl ) for helpful discussions .",
    "this project was kindly supported by the swiss nsf under project i d 200021_149447 .",
    "99 e.  arikan , `` channel polarization : a method for constructing capacity - achieving codes for symmetric binary - input memoryless channels , '' _ ieee trans .",
    "inf . theory _ ,",
    "55 , no .  7 , pp .",
    "30513073 , july 2009 .    c.  leroux , i.  tal , a.  vardy , and w.  j. gross , `` hardware architectures for successive cancellation decoding of polar codes , '' in _ ieee int .",
    "acoustics , speech and sig . process .",
    "_ , may 2011 , pp .",
    "16651668 .",
    "a.  mishra , a.  j. raymond , l.  amaru , g.  sarkis , c.  leroux , p.  meinerzhagen , a.  burg , and w.  j. gross , `` a successive cancellation decoder asic for a 1024-bit polar code in 180 nm cmos , '' in _ proc .",
    "asian solid - state circuits conf .",
    "2012 _ , nov .",
    "2012 .",
    "l.  amaru , m.  martina , and g.  masera , `` high speed architectures for finding the first two maximum / minimum values , '' _ ieee trans .",
    "very large scale integr .",
    "_ , vol .  20 , no .  12 , pp .",
    "23422346 , dec ."
  ],
  "abstract_text": [
    "<S> we present a hardware architecture and algorithmic improvements for list sc decoding of polar codes . more specifically , </S>",
    "<S> we show how to completely avoid copying of the likelihoods , which is algorithmically the most cumbersome part of list sc decoding . </S>",
    "<S> the hardware architecture was synthesized for a blocklength of @xmath0 bits and list sizes @xmath1 using a umc  90 nm vlsi technology . the resulting decoder can achieve a coded throughput of @xmath2  mbps at a frequency of @xmath3  mhz .    </S>",
    "<S> polar codes , list sc decoding , vlsi . </S>"
  ]
}