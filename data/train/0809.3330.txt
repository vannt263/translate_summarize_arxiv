{
  "article_text": [
    "we study the algorithmic properties of infinite graphs that result from a natural unfolding operation applied to finite graphs .",
    "the unfolding process always produces infinite graphs of finite degree .",
    "moreover , the class of resulting graphs is a subclass of the class of automatic graphs . as such",
    ", any element of this class possesses all the known algorithmic and algebraic properties of automatic structures .",
    "an equivalent way to describe these graphs employs automata over a unary alphabet ( see theorem [ thm : gsigma ] ) .",
    "therefore , we call this class of graphs _ unary automatic graphs of finite degree_.    in recent years there has been increasing interest in the study of structures that can be presented by automata . the underlying idea in this line of research",
    "consists of using automata ( such as word automata , bchi automata , tree automata , and rabin automata ) to represent structures and study logical and algorithmic consequences of such presentations .",
    "informally , a structure @xmath0 is _ automatic _ if the domain @xmath1 and all the relations @xmath2 , @xmath3 , @xmath4 of the structure are recognized by finite automata ( precise definitions are in the next section ) .",
    "for instance , an automatic graph is one whose set of vertices and set of edges can each be recognized by finite automata .",
    "the idea of automatic structures was initially introduced by hodgson @xcite and was later rediscovered by khoussainov and nerode @xcite .",
    "automatic structures possess a number of nice algorithmic and model - theoretic properties .",
    "for example , khoussainov and nerode proved that the first - order theory of any automatic structure is decidable @xcite .",
    "this result is extended by adding the @xmath5 ( there are infinitely many ) and @xmath6 ( there are @xmath7 many mod @xmath8 ) quantifiers to the first order logic @xcite . blumensath and grdel proved a logical characterization theorem stating that automatic structures are exactly those definable in the following fragment of the arithmetic @xmath9 , where @xmath10 and @xmath11 have their usual meanings and @xmath12 is a weak divisibility predicate for which @xmath13 if and only if @xmath14 is a power of @xmath15 and divides @xmath16 @xcite .",
    "automatic structures are closed under first - order interpretations .",
    "there are descriptions of automatic linear orders and trees in terms of model theoretic concepts such as cantor - bendixson ranks @xcite .",
    "also , khoussainov , nies , rubin and stephan have characterized the isomorphism types of automatic boolean algebras @xcite ; thomas and oliver have given a full description of finitely generated automatic groups @xcite .",
    "some of these results have direct algorithmic implications .",
    "for example , isomorphism problem for automatic well - ordered sets and boolean algebras is decidable @xcite .",
    "there is also a body of work devoted to the study of resource - bounded complexity of the first order theories of automatic structures .",
    "for example , on the one hand , grdel and blumensath constructed examples of automatic structures whose first - order theories are non - elementary @xcite .",
    "on the other hand , lohrey in @xcite proved that the first - order theory of any automatic graph of bounded degree is elementary .",
    "it is worth noting that when both a first - order formula and an automatic structure @xmath17 are fixed , determining if a tuple @xmath18 from @xmath17 satisfies @xmath19 can be done in linear time .",
    "most of the results about automatic structures , including the ones mentioned above , demonstrate that in various concrete senses automatic structures are not complex from a logical point of view",
    ". however , this intuition can be misleading .",
    "for example , in @xcite it is shown that the isomorphism problem for automatic structures is @xmath20-complete .",
    "this informally tells us that there is no hope for a description ( in a natural logical language ) of the isomorphism types of automatic structures .",
    "also , khoussainov and minnes @xcite provide examples of automatic structures whose scott ranks can be as high as possible , fully covering the interval @xmath21 $ ] of ordinals ( where @xmath22 is the first non - computable ordinal ) .",
    "they also show that the ordinal heights of well - founded automatic relations can be arbitrarily large ordinals below @xmath22 .    in this paper , we study the class of unary automatic graphs of finite degree .",
    "since these graphs are described by the unfolding operation ( definition [ dfn : unfolding ] ) on the pair of finite graphs @xmath23 , we use this pair to represent the graph .",
    "the size of this pair is the sum of the sizes of the automata that represent these graphs . in the study of algorithmic properties of these graphs one",
    "directly deals with the pair @xmath23 .",
    "we are interested in the following natural decision problems :    * * connectivity problem*. given an automatic graph @xmath24 , decide if @xmath24 is connected . * * reachability problem*. given an automatic graph @xmath24 and two vertices @xmath14 and @xmath16 of the graph , decide if there is a path from @xmath14 to @xmath16 .",
    "if we restrict to the class of finite graphs , these two problems are decidable and can be solved in linear time on the sizes of the graphs .",
    "however , we are interested in infinite graphs and therefore much more work is needed to investigate the problems above .",
    "in addition , we also pose the following two problems :    * * infinity testing problem*. given an automatic graph @xmath24 and a vertex @xmath14 , decide if the component of @xmath24 containing @xmath14 is infinite . * * infinite component problem*. given an automatic graph @xmath24 decide if @xmath24 has an infinite component .",
    "unfortunately , for the class of automatic graphs all of the above problems are undecidable .",
    "in fact , one can provide exact bounds on this undecidability .",
    "the connectivity problem is @xmath25-complete ; the reachability problem is @xmath26-complete ; the infinite component problem is @xmath27-complete ; and the infinity testing problem is @xmath25-complete @xcite .    since all unary automatic structures are first - order definable in @xmath28 ( the monadic second - order logic of the successor function ) , it is not hard to prove that all the problems above are decidable @xcite .",
    "direct constructions using this definability in @xmath28 yield algorithms with non - elementary time since one needs to transform @xmath28 formulas into automata @xcite .",
    "however , we provide polynomial - time algorithms for solving all the above problems for this class of graphs .",
    "we now outline the rest of this paper by explaining the main results .",
    "we comment that these polynomial - time algorithms are based on deterministic input automata .",
    "section 2 introduces the main definitions needed , including the concept of automatic structure .",
    "section 3 singles out unary automatic graphs and provides a characterization theorem ( theorem [ thm : characterization ] ) .",
    "section 4 introduces unary automatic graphs of finite degree .",
    "the main result is theorem [ thm : gsigma ] that explicitly provides an algorithm for building unary automatic graphs of finite degree .",
    "this theorem is used throughout the paper .",
    "section 5 is devoted to deciding the infinite component problem .",
    "the main result is the following :    * theorem [ thm : infinite component ] * _ the infinite component problem for unary automatic graph of finite degree @xmath24 is solved in @xmath29 , where @xmath8 is the number of states of the deterministic finite automaton recognizing @xmath24 .",
    "_    in this section , we make use of the concept of oriented walk for finite directed graphs .",
    "the subsequent section is devoted to deciding the infinity testing problem .",
    "the main result is the following :    * theorem [ thm : inftest ] *  _ the infinity testing problem for unary automatic graph of finite degree @xmath24 is solved in @xmath29 , where @xmath8 is the number of states of the deterministic finite automaton @xmath17 recognizing @xmath24 . in particular ,",
    "when @xmath17 is fixed , there is a constant time algorithm that decides the infinity testing problem on @xmath24 .",
    "_    the fact that there is a constant time algorithm when @xmath17 is fixed will be made clear in the proof .",
    "the value of the constant is polynomial in the number of states of @xmath17 .",
    "the reachability problem is addressed in section 7 .",
    "this problem has been studied in @xcite,@xcite , @xcite via the class of * pushdown graphs*. a pushdown graph is the configuration space of a pushdown automaton .",
    "unary automatic graphs are pushdown graphs @xcite . in @xcite it is proved that for a pushdown graph @xmath24 , given a node @xmath30 , there is an automaton that recognizes all nodes reachable from @xmath30 . the number of states in the automaton depends on the input node @xmath30 .",
    "this result implies that there is an algorithm that decides the reachability problem on unary automatic graphs of finite degree .",
    "however , there are several issues with this algorithm",
    ". the automata constructed by the algorithm are not uniform in @xmath30 in the sense that different automata are built for different input nodes @xmath30",
    ". moreover , the automata are nondeterministic . hence , the size of the deterministic equivalent automata is exponential in the size of the representation of @xmath30 .",
    "section 7 provides an alternative algorithm to solve the reachability problem on unary automatic graphs of finite degree uniformly .",
    "this new algorithm constructs a deterministic automaton @xmath31 that accepts the set of pairs @xmath32 there is a path from @xmath33 to @xmath34 .",
    "the size of @xmath31 only depends on the number of states of the automaton @xmath8 , and constructing the automaton requires polynomial - time in @xmath8 .",
    "the practical advantage of such a uniform solution is that , when @xmath31 is built , deciding whether node @xmath30 is reachable from @xmath33 by a path takes only linear time ( details are in section 7 ) .",
    "the main result of this section is the following :    * theorem [ thm : reachability ] *  _ suppose @xmath24 is a unary automatic graph of finite degree represented by deterministic finite automaton @xmath17 of size @xmath8 .",
    "there exists a polynomial - time algorithm that solves the reachability problem on @xmath24 . for inputs @xmath35 ,",
    "the running time of the algorithm is @xmath36 .",
    "_    finally , the last section solves the connectivity problem for @xmath24 .",
    "* theorem [ thm : connectivity ] * _ the connectivity problem for unary automatic graph of finite degree @xmath24 is solved in @xmath29 , where @xmath8 is the number of states of the deterministic finite automaton recognizing @xmath24 .",
    "_    the authors would like to thank referees for comments on improvement of this paper .",
    "a * finite automaton * @xmath17 over an alphabet @xmath37 is a tuple @xmath38 , where @xmath39 is a finite set of * states * , @xmath40 is the * initial state * , @xmath41 is the * transition table * and @xmath42 is the set of * final states*. a * computation * of @xmath17 on a word @xmath43 ( @xmath44 ) is a sequence of states , say @xmath45 , such that @xmath46 and @xmath47 for all @xmath48 .",
    "if @xmath49 , then the computation is * successful * and we say that automaton @xmath17 * accepts * the word .",
    "the * language * accepted by the automaton @xmath17 is the set of all words accepted by @xmath17 . in general",
    ", @xmath50 is * fa recognizable * , or * regular * , if @xmath51 is the language accepted by some finite automaton . in this paper",
    "we always assume the automata are deterministic . for two states @xmath52 ,",
    "the * distance * from @xmath53 to @xmath54 is the minimum number of transitions required for @xmath17 to go from @xmath53 to @xmath54 .    to formalize the notion of a relation being recognized by an automaton",
    ", we define synchronous @xmath8-tape automata .",
    "such an automaton can be thought of as a one - way turing machine with @xmath8 input tapes .",
    "each tape is semi - infinite having written on it a word in the alphabet @xmath37 followed by a succession of @xmath55 symbols .",
    "the automaton starts in the initial state , reads simultaneously the first symbol of each tape , changes state , reads simultaneously the second symbol of each tape , changes state , etc . , until it reads @xmath55 on each tape .",
    "the automaton then stops and accepts the @xmath8-tuple of words if and only if it is in a final state .",
    "more formally , we write @xmath56 for @xmath57 where @xmath55 is a symbol not in @xmath37 .",
    "the * convolution * of a tuple @xmath58 is the string @xmath59 of length @xmath60 symbol is @xmath61 where @xmath62 is the @xmath63 symbol of @xmath64 if @xmath65 is the relation @xmath66 formed as the set of convolutions of all the tuples in @xmath67 .",
    "an @xmath8-ary relation @xmath68 is * fa recognizable * , or * regular * , if its convolution @xmath69 is recognizable by a finite automaton .    a * structure * @xmath70 consists of a countable set @xmath51 called the * domain * and some relations and operations on @xmath51 .",
    "we may assume that @xmath70 only contains relational predicates since operations can be replaced with their graphs .",
    "we write @xmath71 where @xmath72 is an @xmath73-ary relation on @xmath51 .",
    "the relation @xmath74 are sometimes called basic or atomic relations .",
    "we assume that the function @xmath75 is always a computable one .",
    "a structure @xmath70 is * automatic over alphabet @xmath37 * if its domain @xmath50 is finite automaton recognizable , and there is an algorithm that for each @xmath76 produces an @xmath77-tape automaton recognizing the relation @xmath78 .",
    "a structure is called * automatic * if it is automatic over some alphabet . if @xmath79 is isomorphic to an automatic structure @xmath70 , then we call @xmath70 an * automatic presentation * of @xmath79 and say that @xmath79 is _ * automatically presentable*_.    an example of an automatic structure is the word structure @xmath80 , where for all @xmath81 , @xmath82 , @xmath83 , @xmath84 if and only if @xmath85 , and @xmath86 is the lexicographical order .",
    "the configuration graph of any turing machine is another example of an automatic structure .",
    "examples of automatically presentable structures are @xmath87 , @xmath88 , @xmath89 , the group @xmath90 , the order on the rational @xmath91 , and the boolean algebra of finite and co - finite subsets of @xmath92 .",
    "consider the first - order logic extended by @xmath93 ( there exist infinitely many ) and @xmath6 ( there exist @xmath8 many mod @xmath7 , where @xmath8 and @xmath7 are natural numbers ) quantifiers .",
    "we denote this logic by @xmath94 .",
    "we will use the following theorem without explicit reference to it .",
    "@xcite let @xmath17 be an automatic structure .",
    "there exists an algorithm that , given a formula @xmath19 in @xmath95 , produces an automaton that recognizes exactly those tuples @xmath18 from the structure that make @xmath96 true .",
    "in particular , the set of all sentences of @xmath95 which are true in @xmath17 is decidable .",
    "we now turn our attention to the subclass of the automatic structures which is the focus of the paper .",
    "a structure @xmath17 is * unary automatic * if it has an automatic presentation whose domain is @xmath97 and whose relations are automatic .    examples of unary automatic structures are @xmath98 and @xmath99 .",
    "some recent work on unary automatic structures includes a characterization of unary automatic linearly ordered sets , permutation structures , graphs , and equivalence structures @xcite . for example , unary automatic linearly ordered sets are exactly those that are isomorphic to a finite sum of orders of type @xmath100 , @xmath101 ( the order of negative integers ) , and finite @xmath8 .",
    "a * unary automatic graph * is a graph @xmath102 whose domain is @xmath97 , and whose edge relation @xmath103 is regular .",
    "we use the following example to illustrate that this class of graphs are the best possible . consider the class of graphs with all vertices being of the form @xmath104 for some alphabet @xmath105 . at first sight , graphs of this form may have an intermediate position between unary and general automatic graphs .",
    "however , the infinite grid @xmath106 can be coded automatically over @xmath104 by @xmath107 , and @xmath108 is not decidable @xcite . in particular , counter machines can be coded into the grid , so the reachability problem is not decidable .    to eliminate bulky exposition , we make the following assumptions in the rest of the paper .    *",
    "the automata under consideration are viewed as deterministic .",
    "hence , when we write automata , we mean deterministic finite automata . *",
    "all structures are infinite unless explicitly specified . *",
    "the graphs are undirected .",
    "the case of directed graphs can be treated in a similar manner .",
    "let @xmath109 be an automatic graph .",
    "let @xmath17 be an automaton recognizing @xmath103 .",
    "we establish some terminology for the automaton @xmath17 .",
    "the general shape of @xmath17 is given in figure [ fg : standard ] .",
    "all the states reachable from the initial state by reading inputs of type @xmath110 are called * @xmath110-states*. a * tail * in @xmath17 is a sequence of states linked by transitions without repetition . a * loop",
    "* is a sequence of states linked by transitions such that the last state coincides with the first one , and with no repetition in the middle .",
    "the set of @xmath110-states is a disjoint union of a tail and a loop .",
    "we call the tail the * @xmath110-tail * and the loop the * @xmath110-loop*. let @xmath111 be a @xmath110 state .",
    "all the states reachable from @xmath111 by reading inputs of type @xmath112 are called * @xmath112-states*. this collection of all @xmath112-states is also a disjoint union of a tail and a loop ( see the figure ) , called the * @xmath112-tail * and the * @xmath112-loop * , respectively . the * @xmath113-tails * and * @xmath113-loops * are defined in a similar matter .",
    "we say that an automaton is * standard * if the lengths of all its loops and tails equal some number @xmath114 , called the * loop constant*. if @xmath17 is a standard automaton recognizing a binary relation , it has exactly @xmath115 @xmath110-states . on each of these states , there is a @xmath116-tail and a @xmath117-tail of length exactly @xmath114 . at the end of each @xmath112-tail and @xmath113-tail",
    "there is a @xmath112-loop and @xmath118-loop , respectively , of size exactly @xmath114 . therefore if @xmath8 is the number of states in @xmath17 , then @xmath119 .",
    "[ lemma : standard ] let @xmath17 be an @xmath8 state automaton recognizing a binary relation @xmath103 on @xmath97 .",
    "there exists an equivalent standard automaton with at most @xmath120 states .",
    "let @xmath114 be the least common multiple of the lengths of all loops and tails of @xmath17 .",
    "an easy estimate shows that @xmath114 is no more than @xmath121 .",
    "one can transform @xmath17 into an equivalent standard automaton whose loop constant is @xmath114 .",
    "hence , there is a standard automaton equivalent to @xmath17 whose size is bounded above by @xmath122 .",
    "we can simplify the general shape of the automaton using the fact that we consider undirected graphs .",
    "indeed , we need only consider transitions labelled by @xmath123 . to see this , given an automaton with only @xmath118 transitions , to include all symmetric transitions ,",
    "add a copy of each @xmath118 transition which is labelled with @xmath116 .",
    "we recall a characterization theorem of unary automatic graphs from @xcite .",
    "let @xmath124 and @xmath125 be finite graphs .",
    "let @xmath126 be subsets of @xmath127 , and @xmath128 be subsets of @xmath129 .",
    "consider the graph @xmath130 followed by @xmath100 many copies of @xmath79 , ordered as @xmath131 .",
    "formally , the vertex set of @xmath132 is @xmath133 and we write @xmath134 for @xmath135 and @xmath136 .",
    "the edge set @xmath137 of @xmath132 consists of all pairs @xmath138 such that @xmath139 .",
    "we define the infinite graph , * @xmath140 * , as follows :  @xmath141   the vertex set is @xmath142 ;  @xmath143  the edge set contains @xmath144 as well as the following edges , for all @xmath145 , @xmath146 , and @xmath147 :    * @xmath148 when @xmath149 , and @xmath150 when @xmath151 , * @xmath152 when @xmath153 , and @xmath154 when @xmath155 .",
    "[ thm : characterization ] @xcite a graph is unary automatic if and only if it is isomorphic to @xmath140 for some parameters @xmath79 , @xmath130 , and @xmath156 . moreover , if @xmath17 is a standard automaton representing @xmath24 then the parameters @xmath157 can be extracted in @xmath158 ; otherwise , the parameters can be extracted in @xmath159 , where @xmath8 is the number of states in @xmath17 .",
    "a graph is of * finite degree * if there are at most finitely many edges from each vertex @xmath30 .",
    "we call an automaton @xmath17 recognizing a binary relation over @xmath160 a * one - loop automaton * if its transition diagram contains exactly one loop , the @xmath110-loop . the general structure of one - loop automata is given in figure [ fg : type1auto ]",
    ".    we will always assume that the lengths of all the tails of the one - loop automata are not bigger than the size of the @xmath110-loop .",
    "the following is an easy proposition and we omit its proof .",
    "let @xmath109 be a unary automatic graph , then @xmath24 is of finite degree if and only if there is a one - loop automaton @xmath17 recognizing @xmath103 .    by lemma [ lemma : standard ] , transforming a given automaton to an equivalent standard automaton may blow up the number of states exponentially",
    ". however , there is only polynomial blow up if @xmath17 is a one - loop automaton .",
    "if @xmath17 is a one - loop automaton with @xmath8 states , there exists an equivalent standard one - loop automaton with loop constant @xmath161 .",
    "let @xmath162 be the length of the loop in @xmath17 and @xmath163 be the length of the longest tail in @xmath17 .",
    "let @xmath114 be the least multiple of @xmath162 such that @xmath164 .",
    "it is easy to see that @xmath165 .",
    "one can transform @xmath17 into an equivalent standard one - loop automaton whose loop constant is @xmath114 .    note that the equivalent standard automaton has @xmath115 ( 1,1)-states . from each of them",
    "there is a @xmath112-tail of length @xmath114 and a @xmath118-tail of length @xmath114 .",
    "hence the automaton has @xmath166 states . by the above lemma",
    ", we always assume the input automaton @xmath17 is standard . in the rest of the paper",
    ", we will state all results in terms of the loop constant @xmath114 instead of @xmath8 , the number of states of the input automaton . since @xmath161 , for any constant @xmath167",
    ", an @xmath168 algorithm can also be viewed as an @xmath169 algorithm .    given two unary automatic graphs of finite degree @xmath170 and @xmath171 ( where we recall the convention that the domain of each graph is @xmath97 ) , we can form the * union graph * @xmath172 and the * intersection graph * @xmath173 .",
    "automatic graphs of finite degree are closed under these operations .",
    "indeed , let @xmath174 and @xmath175 be one - loop automata recognizing @xmath176 and @xmath177 with loop constants @xmath178 and @xmath179 , respectively .",
    "the standard construction that builds automata for the union and intersection operations produces a one - loop automaton whose loop constant is @xmath180 .",
    "we introduce another operation : consider the new graph @xmath181 , where the set @xmath182 of edges is defined as follows ; a pair @xmath183 is in @xmath184 if and only if @xmath185 and @xmath186 .",
    "the relation @xmath182 is recognized by the same automaton as @xmath176 , modified so that all @xmath113-states that are final declared non - final , and all the @xmath113-states that are non - final declared final .",
    "thus , we have the following proposition :    if @xmath187 and @xmath188 are automatic graphs of finite degree then so are @xmath189 , @xmath190 , and @xmath191 .",
    "now our goal is to recast theorem [ thm : characterization ] for graphs of finite degree .",
    "our analysis will show that , in contrast to the general case for automatic graphs , the parameters @xmath79 , @xmath130 , and @xmath156 for graphs of finite degree can be extracted in linear time .",
    "[ dfn : unfolding ] let @xmath192 and @xmath193 be finite graphs . consider the finite sets @xmath194 consisting of all mappings @xmath195 , and @xmath196 consisting of all mappings @xmath197 .",
    "any infinite sequence @xmath198 where @xmath199 and @xmath200 for each @xmath76 , defines the infinite graph @xmath201 as follows :    * @xmath202 . * @xmath203 .",
    "thus @xmath204 is obtained by taking @xmath130 together with an infinite disjoint union of @xmath205 such that edges between @xmath130 and the first copy of @xmath205 are put according to the mapping @xmath206 , and edges between successive copies of @xmath205 are put according to @xmath62 .",
    "figure [ fg : gsigma ] illustrates the general shape of a unary automatic graph of finite degree that is build from @xmath130 , @xmath205 , @xmath206 , and @xmath207 , where @xmath208 is the infinite word @xmath209 .    [ thm : gsigma ] a graph of finite degree @xmath109 possesses a unary automatic presentation if and only if there exist finite graphs @xmath210 and mappings @xmath211 and @xmath212 such that @xmath24 is isomorphic to @xmath213 .",
    "let @xmath109 be a unary automatic graph of finite degree .",
    "let @xmath17 be an automaton recognizing @xmath103 .",
    "in linear time on the number of states of @xmath17 we can easily transform @xmath17 into a one - loop automaton .",
    "so , we assume that @xmath17 is a one - loop automaton with loop constant @xmath114 .",
    "we construct the finite graph @xmath130 by setting @xmath214 , where @xmath53 is the starting state , @xmath215 are all states on the @xmath110-tail such that @xmath216 is reached from @xmath217 by reading @xmath110 for @xmath218 ; and for @xmath219 , @xmath220 iff there is a final state @xmath221 on the @xmath113-tail out of @xmath216 , and the distance from @xmath216 to @xmath221 is @xmath222 .",
    "we construct the graph @xmath205 similarly by setting @xmath223 where @xmath224 are all states on the @xmath110-loop .",
    "the edge relation @xmath225 is defined in a similar way as @xmath226 .",
    "the mapping @xmath227 is defined for any @xmath228 by putting @xmath229 in @xmath230 if and only if there exists a final state @xmath231 on the @xmath118-tail out of @xmath232 , and the distance from @xmath232 to @xmath231 equals @xmath233 .",
    "the mapping @xmath234 is constructed in a similar manner by reading the @xmath118-tails out of the @xmath110-loop .",
    "it is clear from this construction that the graphs @xmath24 and @xmath235 are isomorphic .",
    "conversely , consider the graph @xmath213 for some @xmath236 and @xmath237 .",
    "assume that @xmath238 , @xmath239 .",
    "a one - loop automaton @xmath17 recognizing the edge relation of @xmath240 is constructed as follows .",
    "the @xmath110-tail of the automaton is formed by @xmath241 and the @xmath110-loop is formed by @xmath242 , both in natural order",
    ". the initial state is @xmath53 .",
    "if for some @xmath243 , @xmath244 , then put a final state @xmath221 on the @xmath118-tail starting from @xmath216 such that the distance from @xmath216 to @xmath221 is @xmath222 .",
    "if @xmath245 , then repeat the process but make the corresponding distance @xmath246 .",
    "the set of edges @xmath225 and mapping @xmath234 are treated in a similar manner by putting final states on the @xmath118-tails from the @xmath110-loop .",
    "again , we see that @xmath17 represents a unary automatic graph that is isomorphic to @xmath213 .",
    "the proof of the above theorem also gives us the following corollary .",
    "if @xmath24 is a unary automatic graph of finite degree , the parameters @xmath130 , @xmath205 , @xmath234 and @xmath206 can be extracted in @xmath247 time , where @xmath114 is the loop constant of the one - loop automaton representing the graph .",
    "furthermore , @xmath248 .",
    "recall the graphs are undirected .",
    "a * component * of @xmath24 is the transitive closure of a vertex under the edge relation .",
    "the * infinite component problem * asks whether a given graph @xmath24 has an infinite component .",
    "[ thm : infinite component ] the infinite component problem for unary automatic graph of finite degree @xmath24 is solved in @xmath249 , where @xmath114 is the loop constant of the automaton recognizing @xmath24 .    by theorem [ thm : gsigma ] , let @xmath250 .",
    "we observe that it is sufficient to consider the case in which @xmath251 ( hence @xmath252 ) since @xmath213 has an infinite component if and only if @xmath253 has one .",
    "let @xmath254 be the @xmath255 copy of @xmath205 in @xmath24 .",
    "let @xmath256 be the copy of vertex @xmath14 in @xmath257 .",
    "we construct a finite directed graph @xmath258 as follows .",
    "each node in @xmath259 represents a distinct connected component in @xmath205 . for simplicity",
    ", we assume that @xmath260 and hence use @xmath14 to denote its own component in @xmath205 .",
    "the case in which @xmath261 can be treated in a similar way . for @xmath262 , put @xmath263 if and only if @xmath264 for some @xmath265 and @xmath266 that are in the same component as @xmath14 and @xmath16 , respectively .",
    "constructing @xmath267 requires finding connected components of @xmath205 hence takes time @xmath247 .",
    "to prove the above theorem , we make essential use of the following definition .",
    "see also @xcite .",
    "[ dfn : edge - path ] an * _ oriented walk _ * in a directed graph @xmath268 is a subgraph @xmath269 of @xmath268 that consists of a sequence of nodes @xmath270 such that for @xmath271 , either @xmath272 or @xmath273 is an arc in @xmath268 , and for each @xmath274 , exactly one of @xmath275 and @xmath276 belongs to @xmath269 .",
    "an oriented walk is an * _ oriented cycle _ * if @xmath277 and there are no repeated nodes in @xmath278 .    in an oriented walk @xmath269 , an arc @xmath279 is called a * forward arc * and @xmath280 is called a * backward arc*. the * net length * of @xmath269 , denoted @xmath281 , is the difference between the number of forward arcs and backward arcs . note the net length can be negative .",
    "the next lemma establishes a connection between oriented cycles in @xmath267 and infinite components in @xmath24 .",
    "[ lm : cycle ] there is an infinite component in @xmath24 if and only if there is an oriented cycle in @xmath282 such that the net length of the cycle is positive .",
    "suppose there is an oriented cycle @xmath269 from @xmath14 to @xmath14 in @xmath282 of net length @xmath283 .",
    "for all @xmath284 , @xmath269 defines the path @xmath285 in @xmath24 from @xmath286 to @xmath287 where @xmath285 lies in @xmath288 .",
    "therefore , for a fixed @xmath284 , all vertices in the set @xmath289 belong to the same component of @xmath24 . in particular , this implies that @xmath24 contains an infinite component .",
    "conversely , suppose there is an infinite component @xmath51 in @xmath24 . since @xmath205 is finite , there must be some @xmath14 in @xmath290 such that there are infinitely many copies of @xmath14 in @xmath51 .",
    "let @xmath286 and @xmath291 be two copies of @xmath14 in @xmath51 such that @xmath292 .",
    "consider a path between @xmath286 and @xmath291 .",
    "we can assume that on this path there is at most one copy of any vertex @xmath293 apart from @xmath14 ( otherwise , choose @xmath291 to be the copy of @xmath14 in the path that has this property ) .",
    "by definition of @xmath253 and @xmath267 , the node @xmath14 must be on an oriented cycle of @xmath267 with net length @xmath222 .    by the equivalence in lemma [ lm : cycle ]",
    ", it suffices to provide an algorithm that decides if @xmath282 contains an oriented cycle with positive net length .",
    "notice that the existence of an oriented cycle with positive net length is equivalent to the existence of an oriented cycle with negative net length .",
    "therefore , we give an algorithm which finds oriented cycles with non - zero net length .    for each node @xmath14 in @xmath267 , we search for an oriented cycle of positive net length from @xmath14 by creating a labeled queue of nodes @xmath294 which are connected to @xmath14 .    `",
    "alg : oriented - cycle `    1 .",
    "pick node @xmath295 for which a queue has not been built yet .",
    "initially the queue @xmath294 is empty .",
    "let @xmath296 , and put @xmath14 into the queue .",
    "mark @xmath14 as _ unprocessed_. if queues have been built for each @xmath295 , stop the process and return _",
    "let @xmath16 be the first _ unprocessed _ node in @xmath294 .",
    "if there are no _ unprocessed _ nodes in @xmath294 , return to ( 1 ) .",
    "3 .   for each of the nodes @xmath297 in the set @xmath298 , do the following . 1 .   if @xmath299 , set @xmath300 ; if @xmath301 , set @xmath302 .",
    "( if both hold , do steps ( a ) , ( b ) , ( c ) first for @xmath303 and then for @xmath304 . ) 2 .   if @xmath305 , then set @xmath306 , put @xmath297 into @xmath294 , and mark @xmath297 as _ unprocessed_. 3 .   if @xmath307 then 1 .",
    "if @xmath306 , move to next @xmath297 , 2 .   if @xmath308 , stop the process and return _",
    "yes_. 4 .",
    "mark @xmath16 as _ processed _ and go back to ( 2 ) .",
    "an important property of this algorithm is that when we are building a queue for node @xmath14 and are processing @xmath297 , both @xmath309 and @xmath310 represent net lengths of paths from @xmath14 to @xmath297 .",
    "we claim that the algorithm returns _ yes _ if and only if there is an oriented cycle in @xmath267 with non - zero net length .",
    "suppose the algorithm returns _",
    "yes_. then , there is a base node @xmath14 and a node @xmath297 such that @xmath308 .",
    "this means that there is an oriented walk @xmath269 from @xmath14 to @xmath297 with net length @xmath309 and there is an oriented walk @xmath311 from @xmath14 to @xmath297 with net length @xmath310 . consider the oriented walk @xmath312 , where @xmath313 is the oriented walk @xmath311 in reverse direction .",
    "clearly this is an oriented walk from @xmath14 to @xmath14 with net length @xmath314 . if there are no repeated nodes in @xmath312 , then it is the required oriented cycle",
    ". otherwise , let @xmath16 be a repeated node in @xmath312 such that no nodes between the two occurrences of @xmath16 are repeated .",
    "consider the oriented walk between these two occurrences of @xmath16 , if it has a non - zero net length , then it is our required oriented cycle ; otherwise , we disregard the part between the two occurrences of @xmath297 and make the oriented walk shorter without altering its net length .",
    "conversely , suppose there is an oriented cycle @xmath315 of non - zero net length where @xmath316 .",
    "however , we assume for a contradiction that the algorithm returns _ no_. consider how the algorithm acts when we pick @xmath317 at step ( 1 ) .",
    "for each @xmath318 , one can prove the following statements by induction on @xmath76 .    1 .",
    "@xmath319 always gets a label @xmath320 2 .",
    "@xmath320 equals the net length of the oriented walk from @xmath317 to @xmath319 in @xmath269 .    by the description of the algorithm",
    ", @xmath317 gets the label @xmath321 .",
    "suppose the statements holds for @xmath319 , @xmath322 , then at the next stage , the algorithm labels all nodes in @xmath323 .",
    "in particular , it calculates @xmath324 . by the inductive hypothesis ,",
    "@xmath324 is the net length of the oriented walk from @xmath317 to @xmath325 in @xmath269 .",
    "if @xmath325 has already had a label @xmath326 and @xmath327 , then the algorithm would return _ yes_. therefore @xmath328 . by assumption on @xmath269 , @xmath329 .",
    "however , since @xmath330 , the induction gives that @xmath331 .",
    "this is a contradiction , and thus the above algorithm is correct .    in summary",
    ", the following algorithm solves the infinite component problem .",
    "suppose we are given an automaton ( with loop constant @xmath114 ) which recognizes the unary automatic graph of finite degree @xmath24 . recall that @xmath114 is also the cardinality of @xmath290 .",
    "we first compute @xmath267 , in time @xmath247 .",
    "then we run ` oriented - cycle ` to decide whether @xmath267 contains an oriented cycle with positive net length . for each node @xmath14 in @xmath267 ,",
    "the process runs in time @xmath247 .",
    "since @xmath267 contains @xmath114 number of nodes , this takes time @xmath332 .    note that lemma [ lm : cycle ] holds for the case when @xmath333 deciding the infinity testing problem -------------------------------------    we next turn our attention to the * infinity testing problem * for unary automatic graphs of finite degree .",
    "recall that this problem asks for an algorithm that , given a vertex @xmath30 and a graph @xmath24 , decides if @xmath30 belongs to an infinite component .",
    "we prove the following theorem .",
    "[ thm : inftest ] the infinity testing problem for unary automatic graph of finite degree @xmath24 is solved in @xmath332 , where @xmath114 is the loop constant of the automaton @xmath17 recognizing @xmath24 . in particular ,",
    "when @xmath17 is fixed , there is a constant time algorithm that decides the infinity testing problem on @xmath24 .    for a fixed input @xmath286 , we have the following lemma .",
    "[ lm : infinite ] if @xmath286 is connected to some @xmath334 such that @xmath335 , then @xmath286 is in an infinite component .",
    "suppose such a @xmath334 exists .",
    "take a path @xmath336 in @xmath24 from @xmath286 to @xmath334 . since @xmath114 is the cardinality of @xmath290",
    ", there is @xmath337 such that @xmath338 and @xmath339 appear in @xmath336 with @xmath340 .",
    "therefore all nodes in the set @xmath341 are in the same component as @xmath286 .",
    "let @xmath342 . to decide if @xmath286 and @xmath334 are in the same component , we run a breadth first search in @xmath24 starting from @xmath286 and going through all vertices in @xmath343 .",
    "the algorithm is as follows :    ` alg : finitereach `    1 .",
    "let @xmath344 .",
    "2 .   initialize the queue @xmath345 to be empty . put the pair @xmath346 into @xmath345 and mark it as _",
    "unprocessed_. 3 .",
    "if there are no _ unprocessed _ pairs in @xmath345 , stop the process .",
    "otherwise , let @xmath347 be the first _ unprocessed _ pair .",
    "for arcs @xmath348 of the form @xmath304 or @xmath303 in @xmath349 , do the following . 1 .   if @xmath348 is of the form @xmath304 , let @xmath350 ; if @xmath348 is of the form @xmath303 , let @xmath351 .",
    "2 .   if @xmath352 and @xmath353 is not in @xmath345 , then put @xmath353 into @xmath345 and mark @xmath353 as _ unprocessed_. 4 .",
    "mark @xmath347 as _ processed _ , and go to ( 2 ) .",
    "note that any @xmath334 is reachable from @xmath286 on the graph @xmath24 restricted on @xmath354 if and only if after running ` finitereach ` on the input @xmath286 , the pair @xmath355 is in @xmath345 .",
    "when running the algorithm we only use the exact value of the input @xmath76 when @xmath356 ( we set @xmath357 whenever @xmath284 ) , so the running time of ` finitereach ` is bounded by the number of edges in @xmath24 restricted to @xmath358 .",
    "therefore the running time is @xmath332 .",
    "let @xmath359 .",
    "[ lm : inftest - b ] let @xmath360 .",
    "@xmath286 is in an infinite component if and only if @xmath361 .",
    "suppose a vertex @xmath362 , then there is a path from @xmath286 to @xmath363 .",
    "by lemma [ lm : infinite ] , @xmath286 is in an infinite component .",
    "conversely , if @xmath286 is in an infinite component , then there must be some vertices in @xmath364 reachable from @xmath286 .",
    "take a path from @xmath286 to a vertex @xmath363 such that @xmath363 is the first vertex in @xmath364 appearing on this path",
    ". then @xmath362 .",
    "we assume the input vertex @xmath286 is given by tuple @xmath365 .",
    "the above lemma suggests a simple algorithm to check if @xmath286 is in an infinite component .    `",
    "alg : infinitetest `    1 .",
    "run ` finitereach ` on vertex @xmath256 , computing the set @xmath366 while building the queue @xmath345 .",
    "2 .   for every @xmath362 ,",
    "check if there is edge @xmath299 .",
    "return @xmath367 if one such edge is found ; otherwise , return @xmath368 .",
    "running ` finitereach ` takes @xmath332 and checking for edge @xmath304 takes @xmath247 .",
    "the running time is therefore @xmath332 .",
    "since @xmath14 is bounded by @xmath114 , if @xmath17 is fixed , checking whether @xmath286 belongs to an infinite component takes constant time .",
    "suppose @xmath24 is a unary automatic graph of finite degree represented by an automaton with loop constant @xmath114 .",
    "the * reachability problem * on @xmath24 is formulated as : given two vertices @xmath369 in @xmath24 , decide if @xmath286 and @xmath334 are in the same component .",
    "we prove the following theorem .",
    "[ thm : reachability ] suppose @xmath24 is a unary automatic graph of finite degree represented by an automaton @xmath17 of loop constant @xmath114",
    ". there exists a polynomial - time algorithm that solves the reachability problem on @xmath24 . for inputs",
    "@xmath35 , the running time of the algorithm is @xmath370 .",
    "we restrict to the case when @xmath371 .",
    "the proof can be modified slightly to work in the more general case , @xmath372 .    since , by theorem [ thm : inftest ] , there is an @xmath332-time algorithm to check if @xmath256 is in a finite component , we can work on the two possible cases separately .",
    "we first deal with the case when the input @xmath286 is in a finite component . by lemma",
    "[ lm : infinite ] , @xmath286 and @xmath334 are in the same ( finite ) component if and only if after running ` finitereach ` on the input @xmath286 , the pair @xmath355 is in the queue @xmath345 .",
    "[ cr : finite reach ] if all components of @xmath24 are finite and we represent @xmath373 as @xmath374 , then there is an @xmath332-algorithm deciding if @xmath286 and @xmath334 are in the same component .    now , suppose that @xmath286 is in an infinite component .",
    "we start with the following question : given @xmath375 , are @xmath286 and @xmath376 in the same component in @xmath24 ? to answer this , we present an algorithm that computes all vertices @xmath375 whose @xmath255 copy lies in the same @xmath24-component as @xmath286 .",
    "the algorithm is similar to ` finitereach ` , except that it does not depend on the input @xmath76 .",
    "line(3b ) in the algorithm is changed to the following :    ( 3b ) if @xmath377 and @xmath353 is not in @xmath345 , then put @xmath353 into @xmath345 and mark @xmath353 as _",
    "unprocessed_.    we use this modified algorithm to define the set @xmath378 .",
    "intuitively , we can think of the algorithm as a breadth first search through @xmath379 which originates at @xmath380 .",
    "therefore , @xmath381 if and only if there exists a path from @xmath380 to @xmath382 in @xmath24 restricted to @xmath379 .",
    "[ lm : reach_reach ] suppose @xmath286 is in an infinite component .",
    "the vertex @xmath376 is in the same component as @xmath286 if and only if @xmath376 is also in an infinite component and @xmath383 .",
    "suppose @xmath376 is in an infinite component and @xmath383 .",
    "if @xmath284 , then the observation above implies that there is a path from @xmath286 to @xmath376 in @xmath384 .",
    "so , it remains to prove that @xmath286 and @xmath376 are in the same component even if @xmath385 .",
    "since @xmath381 , there is a path @xmath336 in @xmath24 from @xmath380 to @xmath382 .",
    "let @xmath386 be the least number such that @xmath387 .",
    "if @xmath388 , then it is clear that @xmath286 and @xmath376 are in the same component .",
    "thus , suppose that @xmath389 .",
    "let @xmath297 be such that @xmath390 .",
    "then @xmath336 is @xmath391 where @xmath392 is a path from @xmath380 to @xmath393 and @xmath394 is a path from @xmath393 to @xmath382 .",
    "since @xmath286 is in an infinite component , it is easy to see that @xmath380 is also in an infinite component .",
    "there exists an @xmath395 such that all vertices in the set @xmath396 are in the same component .",
    "likewise , there is an @xmath397 such that all vertices in @xmath398 are in the same component .",
    "consider @xmath399 and @xmath400 .",
    "analogous to the path @xmath392 , there is a path @xmath401 from @xmath399 to @xmath402 .",
    "similarly , there is a path @xmath403 from @xmath402 to @xmath400 .",
    "we describe another path @xmath404 from @xmath380 to @xmath382 as follows .",
    "@xmath404 first goes from @xmath380 to @xmath399 , then goes along @xmath405 from @xmath399 to @xmath400 and finally goes to @xmath382 .",
    "notice that the least @xmath406 such that @xmath407 must be larger than @xmath386 .",
    "we can iterate this procedure of lengthening the path between @xmath380 and @xmath382 until @xmath408 , as is required to reduce to the previous case .    to prove the implication in the other direction , we assume that @xmath286 and @xmath376 are in the same infinite component",
    ". then @xmath376 is , of course , in an infinite component .",
    "we want to prove that @xmath409 .",
    "let @xmath410 .",
    "suppose there exists a path @xmath336 in @xmath24 from @xmath286 to @xmath376 which stays in @xmath411 .",
    "then , indeed , @xmath381 . on the other hand ,",
    "suppose no such path exists .",
    "since @xmath286 and @xmath376 are in the same component , there is some path @xmath336 from @xmath286 to @xmath376 .",
    "let @xmath412 be the largest number such that @xmath413 .",
    "let @xmath414 be the least number such that @xmath415 .",
    "we are in one of two cases : @xmath416 or @xmath417",
    ". we will prove that if @xmath416 then there is a path @xmath404 from @xmath286 to @xmath376 such that @xmath418 and @xmath419 .",
    "the case in which @xmath417 can be handled in a similar manner .    without loss of generality , we assume @xmath420 since otherwise we can change the input @xmath14 and make @xmath421 .",
    "let @xmath297 be a vertex in @xmath205 such that @xmath422",
    ". then @xmath336 is @xmath391 where @xmath392 is a path from @xmath286 to @xmath423 and @xmath394 is a path from @xmath423 to @xmath376 . since @xmath424",
    ", there must be some @xmath425 and @xmath426 in @xmath392 such that @xmath427 .",
    "for the same reason , there must be some @xmath428 and @xmath429 in @xmath394 such that @xmath430 .",
    "therefore , @xmath336 contains paths between any consecutive pair of vertices in the sequence @xmath431 .",
    "consider the following sequence of vertices : @xmath432 it is easy to check that there exists a path between each pair of consecutive vertices in the sequence .",
    "therefore the above sequence describes a path @xmath404 from @xmath286 to @xmath376 .",
    "it is easy to see that @xmath433 .",
    "also since @xmath421 , @xmath434",
    ". therefore @xmath404 is our desired path .    in the following , we abuse notation by using @xmath435 and @xmath234 on subsets of @xmath436 .",
    "we inductively define a sequence @xmath437 such that each @xmath438 is a subset of @xmath436 .",
    "let @xmath439 and for @xmath427 , we define @xmath440 .",
    "the following lemma is immediate from this definition .",
    "[ lm : reach_closure ] suppose @xmath286 is in an infinite component , then @xmath286 and @xmath334 are in the same component if and only if @xmath334 is also in an infinite component and @xmath441",
    ".    we can use the above lemma to construct a simple - minded algorithm that solves the reachability problem on inputs @xmath442 .    `",
    "alg : navereach `    1 .",
    "check if each of @xmath286 , @xmath334 are in an infinite component of @xmath24 ( using the algorithm of theorem [ thm : inftest ] ) .",
    "2 .   if exactly one of @xmath286 and @xmath334 is in a finite component , then return _",
    "if both @xmath286 and @xmath334 are in finite components , then run ` finitereach ` on input @xmath286 and check if @xmath355 is in @xmath345 .",
    "if both @xmath286 and @xmath334 are in infinite components , then compute @xmath443 . if @xmath441 , return _ yes _ ; otherwise , return _",
    "no_.    we now consider the complexity of this algorithm .",
    "the set @xmath444 can be computed in time @xmath332 .",
    "given @xmath445 , we can compute @xmath438 in time @xmath332 by computing @xmath446 for any @xmath447 .",
    "therefore , the total running time of ` navereach ` on input @xmath286 , @xmath334 is @xmath448 .",
    "we want to replace the multiplication with addition and hence tweak the algorithm .    from lemma [ lm : inftest - b ] ,",
    "@xmath286 is in an infinite component in @xmath24 if and only if ` finitereach ` finds a vertex @xmath363 connecting to @xmath286 . now , suppose that @xmath286 is in an infinite component",
    ". we can use ` finitereach ` to find such a @xmath16 , and a path from @xmath286 to @xmath363 . on this path",
    ", there must be two vertices @xmath449 with @xmath450 .",
    "let @xmath451 .",
    "note that @xmath452 can be computed from the algorithm .",
    "it is easy to see that all vertices in the set @xmath453 belong to the same component .",
    "[ lm : reach_repeat ] @xmath454 .    by definition , @xmath455 if and only if @xmath380 and @xmath382 are in the same component of @xmath24 .",
    "suppose that there exists a path in @xmath24 from @xmath380 to @xmath382 .",
    "then there is a path from @xmath456 to @xmath457 . since @xmath380 and @xmath456 are in the same component of @xmath24 , @xmath380 and @xmath457 are in the same component .",
    "hence @xmath458 .    for the reverse inclusion ,",
    "suppose @xmath459 .",
    "then there exists a path from @xmath380 to @xmath457 .",
    "therefore , @xmath456 and @xmath457 are in the same component . since @xmath460 , @xmath380 and @xmath382 are in the same component .    using the above lemma , we define a new algorithm ` reach ` on inputs @xmath286 , @xmath334 by replacing line ( 4 ) in ` navereach ` with    \\(4 ) if @xmath286 and @xmath334 belong to infinite components , then compute @xmath461 .",
    "if @xmath462 for @xmath463 such that @xmath464 , return _ yes _ ; otherwise , return _",
    "no_.    say input vertices are given as @xmath286 and @xmath334 . by lemma [ lm : reach_closure ] and lemma [ lm :",
    "reach_repeat ] , the algorithm ` reach ` returns _ yes _ if and only if @xmath286 and @xmath334 are in the same component .",
    "since @xmath460 , calculating @xmath461 requires time @xmath465 .",
    "therefore the running time of ` reach ` on input @xmath286 , @xmath334 is @xmath466 .",
    "notice that , in fact , the algorithm produces a number @xmath467 such that in order to check if @xmath286 , @xmath334 ( @xmath468 ) are in the same component , we need to test if @xmath469 and if @xmath470 .",
    "therefore if @xmath24 is fixed and we compute @xmath471 for all @xmath14 beforehand , then deciding whether two vertices @xmath33 , @xmath30 belong to the same component takes linear time .",
    "the above proof can also be used to build an automaton that decides reachability uniformly :    [ cr : reach_aut ] given a unary automatic graph of finite degree @xmath24 represented by an automaton with loop constant @xmath114 , there is a deterministic automaton with at most @xmath472 states that solves the reachability problem on @xmath24 .",
    "the time required to construct this automaton is @xmath473 .    for all @xmath474 , @xmath475 ,",
    "let string @xmath476 represent vertex @xmath286 in @xmath24 .",
    "suppose @xmath477 , we construct an automaton @xmath31 that accepts @xmath478 if and only if @xmath286 and @xmath334 are in the same component in @xmath24 .    1 .",
    "@xmath31 has a @xmath110-tail of length @xmath479 .",
    "let the states on the tail be @xmath480 , where @xmath53 is the initial state .",
    "these states represent vertices in @xmath481 .",
    "2 .   from @xmath482",
    ", there is a @xmath110-loop of length @xmath114 .",
    "we call the states on the loop @xmath483 .",
    "these states represent vertices in @xmath484 .",
    "3 .   for @xmath485",
    ", there is a @xmath118-tail from @xmath486 of length @xmath487 .",
    "we denote the states on this tail by @xmath488 .",
    "these states represent vertices in @xmath489 .",
    "4 .   for @xmath490 ,",
    "if @xmath286 is in an infinite component , then there is a @xmath118-loop of length @xmath491 from @xmath492 .",
    "the states on this loop are called @xmath493 .",
    "these states represent vertices in @xmath494 .",
    "5 .   for @xmath495 , if @xmath380 is in a finite component , then there is a @xmath118-tail from @xmath496 of length @xmath479 .",
    "these states are denoted @xmath497 and represent vertices in @xmath498 .",
    "if @xmath380 is in an infinite component , from @xmath496 , there is a @xmath118-loop of length @xmath491 .",
    "we write these states as @xmath499 .",
    "the final ( accepting ) states of @xmath31 are defined as follows :    1 .",
    "states @xmath500 are final .",
    "2 .   for @xmath385 ,",
    "if @xmath286 is in a finite component , run the algorithm ` finitereach ` on input @xmath286 and declare state @xmath501 final if @xmath502 .",
    "3 .   for @xmath385 ,",
    "if @xmath286 is in an infinite component , compute @xmath503 .",
    "1 .   make state @xmath501 final if @xmath504 is in an infinite component and @xmath505 .",
    "2 .   make state @xmath506 final if @xmath505 4 .",
    "if @xmath380 is in a finite component , run the algorithm ` finitereach ` on input @xmath380 and make state @xmath507 final if @xmath502 .",
    "if @xmath380 is in an infinite component , compute @xmath503 .",
    "declare state @xmath508 final if @xmath505 .",
    "one can show that @xmath31 is the desired automaton . to compute the complexity of building @xmath31 , we summarize the computation involved .    1 .   for all @xmath286 in @xmath509 , decide whether @xmath286 is in a finite component .",
    "this takes time @xmath473 by theorem [ thm : inftest ] .",
    "2 .   for all @xmath286 in @xmath509",
    "such that @xmath286 is in a finite component , run ` finitereach ` on input @xmath286 .",
    "this takes time @xmath473 by corollary [ cr : finite reach ] .",
    "3 .   for all @xmath360 such that @xmath380 is in an infinite component , compute the sets @xmath510 @xmath511 . this requires time @xmath473 by theorem [ thm : reachability ] .",
    "therefore the running time required to construct @xmath31 is @xmath473 .",
    "finally , we present a solution to the * connectivity problem * on unary automatic graphs of finite degree . recall a graph is * connected * if there is a path between any pair of vertices .",
    "the construction of @xmath31 from the last section suggests an immediate solution to the connectivity problem .    `",
    "alg : naveconnect `    1 .",
    "construct the automaton @xmath31 .",
    "2 .   check if all states in @xmath31 are final states .",
    "if it is the case , return @xmath367 ; otherwise , return @xmath512 .",
    "the above algorithm takes time @xmath473 .",
    "note that @xmath31 provides a uniform solution to the reachability problem on @xmath24 .",
    "given the `` regularity '' of the class of infinite graphs we are studying , it is reasonable to believe there is a more intuitive algorithm that solves the connectivity problem .",
    "it turns out that this is the case .",
    "[ thm : connectivity ] the connectivity problem for unary automatic graph of finite degree @xmath24 is solved in @xmath332 , where @xmath114 is the loop constant of the automaton recognizing @xmath24 .",
    "observe that if @xmath24 does not contain an infinite component , then @xmath24 is not connected .",
    "therefore we suppose @xmath24 contains an infinite component @xmath513 .",
    "[ lm : infinite - connect ] for all @xmath514 , there is a vertex in @xmath257 belonging to @xmath513 .",
    "since @xmath513 is infinite , there is a vertex @xmath286 and @xmath515 such that all vertices in @xmath516 belong to @xmath513 and @xmath76 is the least such number . by minimality , @xmath517 .",
    "take a walk along the path from @xmath518 to @xmath256 .",
    "let @xmath519 be the first vertex in @xmath520 that appears on this path .",
    "it is easy to see that @xmath521 must also be in @xmath513 .",
    "therefore @xmath513 has a non - empty intersection with each copy of @xmath205 in @xmath24 .",
    "pick an arbitrary @xmath522 and run ` finitereach ` on @xmath523 to compute the queue @xmath345 .",
    "set @xmath524 .",
    "suppose @xmath24 contains an infinite component , then @xmath24 is connected if and only if @xmath525 .",
    "suppose there is a vertex @xmath526 .",
    "then there is no path in @xmath24 between @xmath523 to @xmath521 .",
    "otherwise , we can shorten the path from @xmath523 to @xmath521 using an argument similar to the proof of lemma [ lm : reach_reach ] , and show the existence of a path between @xmath523 to @xmath521 in the subgraph restricted on @xmath527 .",
    "therefore @xmath24 is not connected .",
    "conversely , if @xmath528 , then every set of the form @xmath529 for @xmath530 equals @xmath290 .",
    "by lemma [ lm : infinite - connect ] , all vertices are in the same component .    by the above lemma",
    "the following algorithm decides the connectivity problem on @xmath268 :    ` alg : connectivity `    1 .   use the algorithm proposed by theorem [ thm : infinite component ] to decide if there is an infinite component in @xmath268 .",
    "if there is no infinite component , then stop and return @xmath512 .",
    "2 .   pick an arbitrary @xmath522 , run ` finitereach ` on @xmath523 to compute the queue @xmath345 .",
    "3 .   let @xmath531 .",
    "if @xmath532 , return @xmath367 ; otherwise , return @xmath512 .    solving the infinite component problem takes @xmath332 by theorem [ thm : infinite component ] .",
    "running algorithm ` finitereach ` also takes @xmath332 .",
    "therefore ` connectivity ` takes @xmath332 .",
    "in this paper we addressed algorithmic problems for graphs of finite degree that have automata presentations over a unary alphabet .",
    "we provided polynomial - time algorithms that solve connectivity , reachability , infinity testing , and infinite component problems . in our future work",
    "we plan to improve these algorithms for other stronger classes of unary automatic graphs .",
    "we also point out that there are many other algorithmic problems for finite graphs that can be studied for the class of unary automatic graphs .",
    "these , for example , may concern finding spanning trees for automatic graphs , studying the isomorphism problems , and other related issues .",
    "j. r. bchi , _ on a decision method in restricted second - order arithmetic_. proc .",
    "international congress on logic , methodology and philosophy of science ( e. nagel , p. suppes , a. tarski , eds . ) , stanford university press , 1 - 11 , 1960 ."
  ],
  "abstract_text": [
    "<S> this paper studies infinite graphs produced from a natural unfolding operation applied to finite graphs . </S>",
    "<S> graphs produced via such operations are of finite degree and automatic over the unary alphabet ( that is , they can be described by finite automata over unary alphabet ) . </S>",
    "<S> we investigate algorithmic properties of such unfolded graphs given their finite presentations . </S>",
    "<S> in particular , we ask whether a given node belongs to an infinite component , whether two given nodes in the graph are reachable from one another , and whether the graph is connected . </S>",
    "<S> we give polynomial - time algorithms for each of these questions . for a fixed input graph , </S>",
    "<S> the algorithm for the first question is in constant time and the second question is decided using an automaton that recognizes reachability relation in a uniform way . </S>",
    "<S> hence , we improve on previous work , in which non - elementary or non - uniform algorithms were found . </S>"
  ]
}