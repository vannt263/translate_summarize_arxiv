{
  "article_text": [
    "with the wide and ever - growing availability of multi - core processors it is evermore compelling to design and develop more efficient concurrent data structures .",
    "the non - blocking concurrent data structures are more attractive than their blocking counterparts because of obvious reasons of being immune to deadlocks due to various fault - causing factors beyond the control of the data structure designer .",
    "lock - free data structures provide guarantee of deadlock / livelock freedom with fault tolerance and are usually faster than wait - free ones which provide additional guarantee of starvation freedom at the cost of increased programming complexity .    in literature , there are lock - free as well as wait - free singly linked - lists  @xcite , lock - free doubly linked - list  @xcite , lock - free hash - tables  @xcite and lock - free skip - lists  @xcite . however , not many performance - efficient non - blocking concurrent search trees are available . a multi - word compare - and - swap ( ` mcas ` ) based lock - free bst implementation",
    "was presented by fraser in  @xcite .",
    "however , ` mcas ` is not a native atomic primitive provided by available multi - core chips and is very costly to be implemented using single - word ` cas ` .",
    "bronson et al . proposed an optimistic lock - based partially - external bst with relaxed balance  @xcite .",
    "ellen et al . presented lock - free external binary search tree  @xcite based on co - operative helping technique presented by barnes  @xcite .",
    "though their work did not include an analysis of complexity or any empirical evaluation of the algorithm , the contention window of update operations in the data structure is large .",
    "also , because it is an external binary search tree , delete are simpler at the cost of extra memory to maintain internal nodes without actual values .",
    "howley et al .",
    "presented a non - blocking internal binary search tree  @xcite based on similar technique . a software transactional memory based approach was presented by crain et al .",
    "@xcite to design a concurrent red - black tree .",
    "while this approach seems to outperform some coarse - grained locking methods , they are easily vanquished by a carefully tailored locking scheme as in @xcite .",
    "recently , two lock - free external bsts  @xcite and a lock - based internal bst  @xcite have been proposed .",
    "all of these works lack comprehensive theoretical complexity analysis .    in an internal bst , add operations start from the root and finish at a leaf node , where the new element is inserted . to remove a node which has both the children present , its successor or predecessor is shifted to take its place .",
    "a common predicament for the existing lock - free bst algorithms is that if multiple modify operations contend at a leaf node , and , if a remove operation among them succeeds then all other operations have to restart from the root .",
    "it results in the complexity of a modify operation to be @xmath4 where @xmath1 is the height of the bst on @xmath2 nodes and @xmath3 is the measure of contention . it may grow dramatically with the growth in the size of the tree and the contention .",
    "in addition to that , contains operations have to be aware of ongoing remove of nodes with both children present , otherwise , it may return invalid results , and , hence in the existing implementations of lock - free internal bst  @xcite , they also may have to restart from the root on realizing that the return may be invalid if the other subtree is not scanned .",
    "the external or partially - external bsts remain immune to the latter problem at a cost of extra memory for the routing internal nodes .",
    "our algorithm solves both these problems elegantly .",
    "the contains operations in our bst enjoy oblivion of any kind of modify operation as long as we do not put them to help a concurrent remove , which may be needed only in write - heavy situations . also , the modify operations after helping a concurrent modify operation restart not from the root rather from a level in the vicinity of failure .",
    "it ensures that all the operations in our algorithm run in @xmath0 .",
    "this is our main contribution .",
    "we always strive to exploit maximum possible disjoint - access - parallelism  @xcite in a concurrent data structure .",
    "the lock - free methods for bst @xcite , in order to use single - word ` cas ` for modifying the outgoing links atomically , and yet maintain correctness , store a flag as an operation field or some version indicator in the node itself , and hence a modify operation `` holds '' a node .",
    "this way of holding a node , specifically for a remove , can reduce the progress of two operations which may remain non - conflicting if modifying two outgoing links concurrently . in  @xcite",
    ", a flag is stored in a link instead of a node in an external bst .",
    "we chase this problem of just holding a link for an internal bst .",
    "we find that it is indeed possible that a remove operation , instead of holding the node , just holds the links connected to and from a node in a determined order so that maximum possible progress of two concurrent operations , working at two disjoint memory words corresponding to two links can be ensured .",
    "we take the business of `` storing a flag '' to the link level from the node level which significantly improves the disjoint - access - parallelism .",
    "this is our next contribution .    helping mechanism which ensures non - blocking progress may prove counterproductive to the performance if not used judiciously .",
    "however , at times , if the proportion of remove operations increases , which may need help to finish their pending steps , it is better to help them , so that the traversal path does not contain large number of `` under removal '' nodes .",
    "keeping that in view , we take helping to a level of adaptability to the read - write load : we provide choice over whether an operation , during its traversal , helps an ongoing remove operation .",
    "we believe that this adaptive conservative helping in internal bsts may be very useful in some situations .",
    "this is a useful contribution of this work .",
    "our algorithm requires only single - word atomic ` cas ` primitives along with single - word atomic read and write which now exist in practically all the widely available multi - core processors in the market . based on our design ,",
    "we implement a set adt .",
    "we prove that our algorithm is linearizable  @xcite .",
    "we also present complexity analysis of our implementation which is lacking in existing lock - free bst algorithms .",
    "this is another contribution in this paper .",
    "the body of our paper will further consist of the following sections . in section [ secexiststruct ] ,",
    "we present the basic tree terminologies . in section [ secalgo ] ,",
    "the proposed algorithm is described .",
    "section [ secanalysis ] presents a discussion on the correctness and the progress of our concurrent implementation along with an amortized analysis of its step complexity .",
    "the paper is concluded in section [ secconclude ] .",
    "a _ binary tree _ is an ordered tree in which each _ node _ @xmath5 has a _ left child _ and a _ right child _ denoted as @xmath6 and @xmath7 respectively , either or both of which may be _",
    "external_. when both the children are external the node is called a _ leaf _ , with one external child a _",
    "unary _ node and with no external child a _ binary _ node , and , all these non - external nodes are called _ internal _ nodes .",
    "we denote the parent of a node @xmath5 by @xmath8 and there is a unique node called _ root _ s.t .",
    "each parent is connected with its children via pointers as links ( we shall be often using the term pointer and link interchangeably when the context will be understood ) .",
    "we are primarily interested in implementing an ordered _ set _ adt - _ binary search tree _ using a binary tree in which each node is associated with a unique key @xmath10 selected from a totally ordered universe .",
    "a node with a key @xmath10 is denoted as @xmath11 and @xmath5 if the context is otherwise understood .",
    "determined by the total order of the keys , each node @xmath5 has a _ predecessor _ and a _ successor _ , denoted as @xmath12 and @xmath13 , respectively .",
    "we denote height of @xmath5 by @xmath14 , which is defined as the distance of the deepest leaf in the subtree rooted at @xmath5 from @xmath5 .",
    "+ we focus on _ internal bsts _ ,",
    "in which , all the internal nodes are _ data - nodes _ and the external nodes are usually denoted by .",
    "there is a _",
    "symmetric order _ of arranging the data - all the nodes in the _ left subtree _ of @xmath11 have keys less than @xmath10 and all the nodes in its _ right subtree _ have keys greater than @xmath10 , and so no two nodes can have the same key . to query if the bst contains a data with key @xmath10 , at every _ search - step _",
    "we utilize this order to look for the desired node either in the left or in the right subtree of the _ current node _ if not matched at it , unless we reach an external node . on reaching an external node",
    "we return , else , if the key matches at a node then we return or address of the node if needed . to add data , we query by its key @xmath10 . on reaching an external node",
    "we replace this node with a new leaf node @xmath11 . to remove a data - node corresponding to key @xmath10 we check whether @xmath11 is in the bst .",
    "if the bst does not contain @xmath11 , is returned . on finding a node with key @xmath10 , we perform delete as following .",
    "if it is a leaf then we just replace it with an external node .",
    "in case of a unary node its only child is connected to its parent . for a binary node @xmath5 , it is first replaced with @xmath12 or @xmath13 , which may happen to be a leaf or a unary node , and then the replacer is removed .",
    "+ in an alternate form - an _ external bst _ , all the internal nodes are _ routing - nodes _ and the external nodes are data - nodes . in this paper",
    "we focus on internal bsts , and hence forward , by a bst we shall mean an internal bst .",
    "to implement a lock - free bst , we represent it in a threaded format @xcite . in this format",
    ", if the left or the right child pointers at @xmath5 is null and so corresponds to an external node , it is instead connected to @xmath12 or @xmath13 , respectively .",
    "some indicator is stored to indicate whether a child - link is used for such a connection .",
    "this is called _ threading _ of the child - links . in our design ,",
    "we use the null child pointers at the leaf and unary nodes as following - right child pointer , if null , is threaded and is used to point to the successor node , whereas , a similar left child pointer is threaded to point to the node itself , see fig . [ bst](a ) . in this representation a binary tree can be viewed as an ordered list with exactly two outgoing and two incoming pointers per node , as shown in fig .",
    "[ bst](b ) . also , among two incoming pointers , exactly one is threaded and the other is not .",
    "further , if @xmath15 and @xmath16 are two nodes in the bst and there is no node @xmath11 such that @xmath17 then the interval @xmath18 $ ] is called _ associated _ with the threaded link incoming at @xmath19 .",
    "we exploit this symmetry of the equal number of incoming and outgoing pointers . a usual traversal in the bst following its symmetric order for a predecessor query , is equivalent to a traversal over a _ subsequence _ of the ordered - list produced by an in - order traversal of the bst , which is exactly the one shown in fig .",
    "[ bst](b ) .",
    "this is made possible by the threaded right - links at leaf or unary nodes .",
    "though in this representation , there are two pointers in both incoming and outgoing directions at each node , a single pointer needs to be modified to add a node in the list . to remove a node we may have to modify up to four pointers .",
    "therefore , add can be as simple as that in a lock - free single linked - list  @xcite , and remove is no more complex than that in a lock - free double linked - list  @xcite .",
    "a traversal in a lock - free list may enjoy oblivion from a concurrent remove of a node .",
    "also in our design of internal bst , a traversal can remain undeterred by any ongoing modification , unlike that in existing lock - free implementations of internal bsts  @xcite .",
    "in all the existing designs of lock - free bsts , when an operation fails at a link connecting to an external node because of a concurrent modify operation , it retries from the scratch i.e. it restarts the operation from the root of the tree , after helping the obstructing concurrent operation .",
    "we aim to avoid the `` retry from scratch '' behavior and rather restart from a node at the vicinity of the link where the operation fails , after the required helping . to achieve that , we need to get hold of the appropriate node(s ) to restart the failed operations .",
    "we use a _ backlink _ per node which is guaranteed to point to a node _ present _ in the tree from where the failure spot is always a single link away .",
    "it should be noted that a backlink is not used for a tree traversal , see fig .",
    "[ bst_node_category](a ) .        in designing an internal bst in a concurrent setup ,",
    "the most difficult part is to perform an error - free remove of a binary node . to remove a binary node",
    "we replace it with its predecessor , and hence , the incoming and outgoing links of the predecessor also need to be modified in addition to the incoming and outgoing links of the node itself . according to the number of links needed to be modified in order to remove a node , unlike traditional categorization of nodes of a bst into leaf , unary and binary , we categorize them into three categories as shown in fig .",
    "[ bst_node_category](b ) .",
    "the categorization characteristic is the origin of the threaded incoming link into the node , hereafter we call this link the _ order - link_. nodes belonging to category 1 are those whose order - link emanates from themselves ; to category 2 , it emanates from the left - child of the node , and to category 3 are those whose incoming order - link emanates from a `` distant '' node in its left - subtree .",
    "we name the node where the order - link emanates from , an _ order - node_.    to remove a node of category 1 , only the incoming parent - link needs to be modified to connect to the node pointed by the right - link . for a category 2 ,",
    "the parent - link is updated to connect to the node pointed by the left - link and the order - link is modified to point to the node which the right - link was pointing to . in order to remove a category 3 node",
    ", its predecessor replaces it and the incoming and outgoing links of the predecessor are updated to take the values of that of the removed node .",
    "parent - link of the predecessor is connected to the node which its left - link was pointing to before it got shifted . also , when a link is updated the thread indicator value of the link , which it updates to , is copied to it .",
    "please note that in this categorization , a unary or a binary node whose left child is left - unary ( i.e. whose right child is ) or a leaf , gets classified in to category 2 .",
    "whereas , category 1 includes conventional leaf and right - unary nodes ( whose left child is ) .",
    "having categorized the nodes as above we describe the modification of links associated with a node undergoing remove . storing an indicator bit in a pointer has been used in many previous papers  @xcite .",
    "we use a similar technique as in  @xcite . before swapping the pointers associated with a node we flag the incoming pointers to the node and its possible predecessor and mark the outgoing pointers from the same . note that because a backlink is neither used for traversal nor for injecting a modify operation",
    ", we do not need to mark / flag it .",
    "flagging ensures that an operation does not have to travel a long _ chain _ of backlinks .",
    "once a link is flagged or marked it can not be a _ point of injection _ of a _ new _ add or remove .",
    "however , in the conflict between a remove of a category 3 node , and therefore shifting its predecessor , and a concurrent remove of the predecessor node itself , we give priority to the former . also to guarantee a single pointer travelling for recovery from failure due to a concurrent modify operation , we use a _ prelink _ at each node .",
    "it connects a node to its order - node before any of the outgoing pointers are marked .",
    "the flagging and marking are performed in a definite order to avoid a malformed structure of the bst and to ensure required priorities between conflicting operations .",
    "the flag - mark order of links for a category 3 node is as following - ( i ) flag the incoming order - link , ( ii ) set the prelink , ( iii ) mark the outgoing right - link , ( iv ) flag the parent - link of the predecessor incoming to that , ( v ) flag the incoming parent - link , ( vi ) mark the outgoing left - link and finally ( vii ) mark the outgoing left - link of the predecessor . for a node belonging to category 1 or 2 , because there is no node between its order - node and itself , steps ( iv ) , ( vi ) and ( vii ) do not happen .",
    "having performed the flagging and marking we update the flagged links according to the category of the node as described before .",
    "[ bst_del ] .",
    "because we follow orderly the modifications of the links , it never allows a node to be missed by a traversal in the bst unless both its incoming links are pointed away .",
    "however , because a node may shift `` upward '' to replace its successor , the interval associated with its successor , may shift `` rightward '' i.e. to the right subtree of the node after the successor is removed .",
    "therefore , in order to terminate a traversal at the correct location , we have the stopping criterion given in condition [ cond1 ] .",
    "it follows from the fact that the threaded left - link of a node is connected to the node itself and a traversal in the bst uses the order in the equivalent list .",
    "[ cond1 ] let @xmath10 be the search key and @xmath20 be the key of the current node in the search path .",
    "if @xmath21 then stop .",
    "else , if the next link is a threaded left - link then stop .",
    "else , if the next link is a threaded right - link and the next node has key @xmath22 then check if @xmath23 .",
    "if true then stop , else continue .",
    "this stopping criterion not only solves the problem of synchronization between a concurrent remove and a traversal for a predecessor query but also enables to achieve bound on the length of the traversal path .",
    "we shall explain that in section [ secanalysis ] .",
    "a similar stopping criterion is used in  @xcite for conventional doubly - threaded bsts .",
    "we can observe that in our bst design , two modify operations that need to change two disjoint memory - words have significantly improved conditions for progress . for example , to remove a category 2 node the left - link of its predecessor is never marked or flagged , therefore when such a node goes under remove , a concurrent injection of add or remove at the predecessor is possible .",
    "also , because of the orderly flagging and marking of the links in more than one atomic steps , even after remove of the node has commenced , a link at it that comes late in the order of flagging - marking , can be modified for injection of an add or a remove of another node .",
    "these progress conditions are not possible in the existing algorithms that use `` node holding ''  @xcite .",
    "it shows that our algorithm has improved disjoint - access - parallelism .",
    "we consider our concurrent setup as a shared memory machine in which processes are fully asynchronous and arbitrary failure halting is allowed .",
    "the read and write of a single memory - word is guaranteed to be atomic .",
    "the system provides atomic single - word ` cas ` primitives . ` cas`@xmath24 returns , if @xmath25 , after updating @xmath26 to @xmath27 , else it returns .",
    "we steal three bits from a pointer , for ( a ) thread indicator , ( b ) mark - bit and ( c ) flag - bit , see line [ nodepointer ] .",
    "this is easily possible in many high level languages , including c / c`++ ` .",
    "we assume our algorithm be implemented with a safe lock - free memory reclamation scheme like hazard - pointer  @xcite .",
    "a typical node @xmath5 in our bst implementation is represented by a structure consisting of five memory - words corresponding to - ( a ) a key @xmath10 , ( b ) array @xmath28 $ ] containing two child pointers : @xmath29~:=~left(x)$ ] and @xmath30~:=~right(x)$ ] , ( c ) a @xmath31 and ( d ) a @xmath32 .",
    "the bit sequence corresponding to boolean variables overlapping three stolen bits from a link is represented as @xmath33 .",
    "one or more bits together can be set or unset using a single atomic ` cas ` operation over the pointer containing it .",
    "the node structure is shown in lines [ decbegin ] to [ decend ] .",
    "we use two dummy nodes as global variables represented by a two member array of node - pointers @xmath34 .",
    "the keys @xmath35 and @xmath36 are stored in the two members of @xmath34 and they can never be deleted .",
    "node @xmath37 $ ] is left - child and predecessor of the node @xmath38 $ ] , see line [ gv ] and figure [ bst_node_category ] ( c ) .      the set operations - contains , add and remove , need to perform a predecessor query using a given key @xmath10 to locate an interval @xmath39 $ ] , s.t .",
    "either @xmath40 or @xmath41 , where @xmath42 and @xmath43 are two nodes in the bst .",
    "the function locate is used for that , which starts from a specified set of two consecutive nodes \\ { , } and follows the symmetric order of the internal bst to terminate at such a location @xmath44 .",
    "the return value of locate can be 0 , 1 or 2 depending on whether the key @xmath10 is less than , greater than or equal to the key @xmath20 at the termination point , line [ cmp ] .",
    "if @xmath45 then the desired interval is associated with the threaded outgoing link from @xmath46 in the direction indicated by return value of locate , 0 denotes left and 1 denotes right . the termination criterion for locate implements condition [ cond1 ] .    as we mentioned before",
    ", we can make a traversal eagerly help pending remove operations , even though it is not obstructed by them , in the situations in which proportion of remove increases .",
    "if that is done then a traversal cleans a node whose marked right - link it encounters during execution by calling the function cleanmark .",
    "this functionality can be enabled using a boolean variable as an input argument to every set operation which is further passed to the locate that it performs .",
    "this is not done if the implementation does not demand such eager helping .",
    "see line [ eagerhelp1 ] to [ eagerhelp2 ] . to perform a contains operation of key @xmath10 , we start from the location @xmath47 represented by the global variables .",
    "having performed locate , the return value itself indicates whether the key @xmath10 was present in the bst at the point of termination of locate .",
    "if locate returns 2 then contains returns otherwise , line [ searchbeg ] to [ searchend ] .      to remove a node corresponding to key @xmath10 ,",
    "starting from @xmath47 we locate the link corresponding to the interval containing the key @xmath48 line [ locdel ] .",
    "if the locate terminates at @xmath44 then @xmath49 is the desired node to remove if @xmath10 matches with its key .",
    "@xmath50 is the node pointed by the threaded right - link of @xmath46 and this link is indeed the order - link of @xmath11 .",
    "if @xmath11 is located then we try to flag its order - link using tryflag , line [ algtryflag ] , in order to perform the step ( i ) of remove .    ,",
    "line [ tryflagbegin ] to [ tryflagend ] , returns only if the operation performing it could successfully flag the desired link at line [ atomicflag ] .",
    "if the ` cas ` step to atomically flag the link fails then it checks the reason of failure . if it fails because some other thread already had successfully flagged the link , is returned , line [ tryflagretfal ] .",
    "if it fails because the link was marked then it first helps the operation that marked the link , line [ flaghepsclean ] .",
    "it could also fail to flag a threaded link because of an add of a new node . in both these cases",
    "it moves a step back and locates the node whose parent - link was desired to be flagged .",
    "the address for starting the recovery is saved in the variable .",
    "if the node is not located then it implies that some other thread already removed the target node and so tryflag just returns , line [ tryflagret ] .",
    "having performed the tryflag , remove checks whether the target node is still there . if the target node is found then remove goes to clean the flag at the order - link of the target node , using the function cleanflag , line [ algcleanflag_from_rem ] .",
    "the function cleanflag is also used to clean the flag of the parent - link of a node , and therefore a boolean variable is passed to it to inform about the thread - bit of the flagged link .",
    "if the link is an order - link then , for all categories of nodes , the next step is to set the prelink and then mark the right - link , see lines [ mark_cf_start ] to [ mark_cf_end ] .",
    "if the ` cas ` to mark the right - link fails because of its flagging , and if the right - link is threaded then it indicates that the node itself is being shifted to replace its successor by a concurrent remove operation .",
    "we give priority to the shifting operation and therefore before proceeding it helps .",
    "as before , we need to recover from failures and so a node stores the address to restart the recovery from . here",
    "one has to be careful that if was pointed at the successor node under remove then we need to change it before going to help , see line [ shift_back ] .",
    "having marked the right - link , remove proceeds to take further steps in the function cleanmark .",
    "also , before marking the right - link , the prelink gets pointed to the correct order - node , line [ setprelink ] .    if cleanflag is performed on a link that is not threaded then it is helping an operation that has flagged the parent of a node or of its predecessor . in that case",
    "it is determined whether the link is the parent - link of a node under remove or that of its predecessor by checking the flag , mark and thread bits of the right - link .",
    "the right - link of a node being removed is marked , whereas that for the predecessor of a node being removed is always flagged and threaded .",
    "accordingly , either step ( v ) ( lines [ step6_1 ] to [ step6_2 ] ) or step ( vi ) ( lines [ tm_left ] ) are performed . to perform the step ( vi ) the outgoing left - link of a category 3 node",
    "is marked , and for that the function trymark is used .",
    "trymark atomically inserts the mark - bit at a link specified by its direction outgoing from a node , see lines [ tmbeg ] to [ tmend ] .",
    "note that , if the ` cas ` to atomically mark a link fails due to a concurrent flagging of the link then trymark helps the concurrent operation that flagged the link , except in the case when the link is a threaded left - link .",
    "this is because a flagged and threaded left - link of a node indicates that the node is a category 1 node under remove and we give priority to the operation that must have already flagged its right link to shift it .    because the last step for category 1 and category 2 nodes is flagging their parent - link before the pointers are appropriately swapped",
    ", cleanflag also includes the final swapping of pointers for such nodes .",
    "having determined that a node belongs to category 1 or 2 by checking the equality of left - node and order - node at line [ cf_check_category ] , it performs the pointer swapping for category 1 nodes in lines [ ptr_swapping_cat1_1 ] and [ ptr_swapping_cat1_2 ] .",
    "pointer swapping steps to clean a category 2 node is shown between lines [ ptr_swapping_cat2_1 ] and [ ptr_swapping_cat2_2 ] .",
    "the cleanmark function is used to help an operation that puts a mark - bit at a link . depending on whether the link is a left- or a right - link",
    ", it takes different steps .",
    "if the link happens to be a right - link then , for category 1 and 2 nodes , the final step of flagging the parent is executed ; otherwise for a category 3 node the parent of its predecessor is flagged .",
    "to determine the category of a node , its order - node is checked if it coincides with its left - child .",
    "if it is a category 3 node then cleanmark attempts to flag the parent of the order - node .",
    "on failing because a concurrent operation had marked the link , it helps that operation .",
    "however , after helping it may be that the node under remove changes from a category 3 to a category 2 node , so its status is checked again , see lines [ conbackl ] to [ conback2 ] .",
    "a mark - bit at a left - link indicates that it is either coming out from a category 3 node or its predecessor . in the first case ,",
    "the final step i.e. step ( vii ) to mark the left - link of predecessor of a category 3 node is performed , line [ mark_leftplink ] . in the second case the pointer swapping steps of a category 3 nodes",
    "are performed , see lines [ ptr_swapping_cat3_1 ] to [ cmend ] .",
    "return value of remove is that of the absolutely first tryflag that it performs if the node was located .      to add a new data - node with key @xmath10 in the bst",
    ", we locate the target interval @xmath39 $ ] , associated with a threaded link , containing key @xmath10 . if locate returns 2 then key is present in the bst and therefore add returns .",
    "if it returns 0 or 1 then we create a new node containing the key @xmath10 .",
    "its left - link is threaded and connected to itself and right - link takes the value of the link to which it needs to be connected , line [ lem5_2 ] .",
    "note that when a new node is added , both its children links are threaded .",
    "also , its backlink is pointed to the node @xmath42 .",
    "the link which it needs to connect to is modified in one atomic step to point to the new node using a ` cas ` .",
    "if the ` cas ` succeeds then is returned . on failure",
    ", it is checked whether the target link was flagged , marked or another add operation succeeded to insert a new node after we read the link . in case a new node is inserted , we start locating for a new proper link starting with the location comprising nodes at the two ends of the changed link . on failure due to marking or flagging of the current link , the concurrent remove operation is helped .",
    "recovery from failure due to a flagging or marking by a concurrent remove operation makes it to go one link back following the backlink of . after locating the new proper link ,",
    "add is retried .",
    "in this section we first show that executions in our algorithm produce a correct bst with linearizable operations .",
    "then we prove the lock - free progress property and finally we discuss its amortized step complexity .      here",
    "we present a proof - sketch of correctness , due to space constraints .",
    "a detailed proof can be found in the technical report  @xcite .",
    "first we give classification of nodes in a bst @xmath51 implemented by our algorithm .",
    "[ def1 ] a node @xmath52 is called logically removed if its right - link is marked and @xmath53 s.t . either @xmath54 or @xmath55 .",
    "a node @xmath52 is called physically removed if @xmath56 s.t . either @xmath54 or @xmath55 or @xmath57 .",
    "a node @xmath52 is called regular if it is neither logically removed nor physically removed .",
    "a node ever inserted in @xmath51 has to fit in one of the above categories . at a point in the history of executions",
    ", the bst formed by our algorithm contains elements stored in regular nodes or logically removed nodes .",
    "before we show that the return values of the set operations are consistent with this definition according to their linearizability , we have to show that the operations work as intended and the structure formed by the nodes operated with these operations maintains a valid bst .",
    "we present some invariants maintained by the operations and the nodes in lemmas [ lem1 ] to [ lem12 ] .",
    "[ lem1 ] if a locate@xmath58 , , @xmath59 returns @xmath60 and terminates at @xmath61 $ ] then    a.   either @xmath62 or @xmath63 . b.   if @xmath64 then the link @xmath65 $ ] is threaded . c.   @xmath46 is not physically deleted .",
    "[ lem2 ] a contains operation returns true if and only if the key is located at a non - physically removed node .",
    "[ lem3 ] an add always happens at an unmarked and unflagged threaded link .",
    "[ lem4 ] a remove always starts by flagging the incoming order - link to a node .",
    "[ lem5 ] when a node is inserted , both its left- and right- links both threaded .",
    "[ lem6 ] before a node is logically removed its incoming order - link is flagged and its prelink points to its correct order - node .",
    "[ lem8 ] backlink of a node always points to a non physically removed node .",
    "[ lem9 ] an unthreaded left - link can not be both flagged and marked .",
    "[ lem10 ] a right - link can not be both flagged and marked .",
    "[ lem11 ] a link once marked never changes again .",
    "[ lem12 ] if a node gets logically removed then it will be eventually physically removed .",
    "lemma [ lem1 ] follows from the lines [ locsuc ] and [ term2 ] .",
    "contains returns only if locate returns 2 and that happens only if is non - physically removed at line [ cmp ] during its execution , this proves lemma [ lem2 ] . in the case of a key match ,",
    "add returns and otherwise it tries adding the key using an atomic ` cas ` . if the ` cas ` fails , it always uses locate to find the desired link before retrying the ` cas ` to add the new node . from this observation and using [ lem1](b ) ,",
    "lemma [ lem3 ] follows . by lemma [ lem1 ]",
    "if @xmath11 is present in the tree then locate@xmath58 , , @xmath66 will always terminate at a location such that is order - node of @xmath11 and that establishes lemma [ lem4 ] .",
    "lemma [ lem5 ] follows from lines [ lem5_1 ] and [ lem5_2 ] .",
    "line [ flag_copy ] ensures that even if the function cleanflag helps a pending remove , before it could successfully mark the right - link at line [ atomicmark ] the flag that was put on the order link at line [ algtryflag ] is copied to the changed order - link .",
    "also , the line [ setprelink ] inside the while loop ensures that prelink is always set to the order - node .",
    "that proves the correctness of lemma [ lem6 ] . when a node is added its backlink",
    "is pointed to at line [ lem8_1 ] .",
    "before a remove operation returns it ensures that the backlinks of the predecessor , left - child and right - child , if present for the node under remove , are appropriately updated at lines [ ptr_swapping_cat1_2 ] , [ bk_update1 ] , [ ptr_swapping_cat2_2 ] , [ bk_update2 ] , [ bk_update3 ] , [ bk_update4 ] and [ cmend ] .",
    "hence , by induction , lemma [ lem8 ] is proved . in our algorithm",
    "we always use an atomic ` cas ` to put a flag or mark - bit in a pointer .",
    "whenever a ` cas ` fails we check the possible reason .",
    "the function trymark helps cleaning the flag in all cases except when the link has direction 0 and it is threaded , line [ trymark_ret_left ] .",
    "these observations prove lemmas [ lem9 ] and [ lem10 ] .",
    "lemma [ lem11 ] follows from lemmas [ lem9 ] and [ lem10 ] .",
    "lemma [ lem11 ] proves that once the right - link of a node is marked , it can not be reversed and if the thread invoking remove to mark it becomes faulty then eventually another thread invoking a possible add or remove which gets obstructed , will help to complete the physical removal . having proved the lemmas listed above , it is trivial to observe that whenever a pointer is dereferenced it is not null . and , by the initialization of the global variable to @xmath36 and @xmath35 , at line [ gv ] , the two starting nodes are never deleted .",
    "+ hence , we state proposition [ treedef ] whose proof will follow by the above stated lemmas and the fact that a thread always takes a correct `` turn '' during traversal according to the symmetric order of the internal bst .",
    "[ treedef ] the union of the regular and logically removed nodes operated under the set operations in the algorithm efficient lock free bst maintain a valid internal binary search tree .",
    "an execution history in our implementation may consist of add , remove and contains operations .",
    "we present the linearization point of the execution of these operations .",
    "proving that a history consisting of concurrent executions of these operations is legal will be ordering these linearization points .",
    "the linearization points of the operations are as following :    * add * - for a successful add operation , execution of the ` cas ` at line [ addsuc ] will be the linearization point . for an unsuccessful one the linearization point will be at line [ cmp ] where",
    "a key in the tree is found matched .    *",
    "remove * - for a successful remove operation the linearization point will be the successful ` cas ` that swaps the flagged parent link .",
    "for an unsuccessful one there may be two cases - ( a ) if the node is not located then it is treated as an unsuccessful contains and its linearization point will be accordingly ( b ) if the node is located but its order - link got flagged by another concurrent remove then its linearization point is just after the linearization point of that remove .",
    "* contains * - our algorithm varies according to the read - write load situation . in case",
    "we go for eager helping by a thread performing locate , a successful contains shall always return a regular node .",
    "however , if we opt otherwise then a successful contains returns any non - physically removed node . in both situations",
    "a successful contains will be linearized at line [ cmp ] .",
    "an unsuccessful one , if the node never existed in the bst , is linearized at the start point . and , if the node existed in the bst when the contains was invoked but got removed during its traversal by a concurrent remove then the linearization point will be just after the successful ` cas ` operation that physically removed the node from the bst .    following the linearization points",
    "as described above we have proposition [ linearize ] :    [ linearize ] the set operations in the algorithm efficient lock free bst are linearizable .",
    "the lemmas [ lem6 ] , [ lem9 ] , [ lem10 ] and [ lem11 ] imply the following lemma .",
    "[ rem_obstruct ] if remove@xmath67 and remove@xmath68 work concurrently on nodes @xmath5 and @xmath69 then without loss of generality    a.   if @xmath5 is the left - child of @xmath69 and both @xmath5 and @xmath69 are logically deleted then remove@xmath67 finishes before remove@xmath68 . b.   if @xmath5 is the right - child of @xmath69 and both @xmath5 and @xmath69 are logically deleted then remove@xmath68 finishes before remove@xmath67 . c.   if @xmath5 is the predecessor of @xmath69 and the order - links of both @xmath5 and @xmath69 have been successfully flagged then remove@xmath68 finishes before remove@xmath67 .",
    "d.   if @xmath5 is the predecessor of @xmath69 and @xmath5 has been logically deleted then remove@xmath67 finishes before the order - link of @xmath69 could be successfully flagged .",
    "e.   if @xmath5 is the left - child of the predecessor of @xmath69 and the incoming parent - link of @xmath5 has been successfully flagged then remove@xmath67 finishes before remove@xmath68 .",
    "f.   if @xmath5 is the left - child of the predecessor of @xmath69 and the left - link of the predecessor of @xmath69 has been successfully marked then remove@xmath68 finishes before remove@xmath67 . g.   in all other cases remove@xmath67 and remove@xmath68 do not obstruct each other .    by the description of our algorithm",
    ", a non - faulty thread performing contains will always return unless its search path keeps on getting longer forever . if that happens , an infinite number of add operations would have successfully completed adding new nodes making the implementation lock - free .",
    "so , it will suffice to prove that the modify operations are lock - free . considering a thread @xmath70 performing a pending operation @xmath71 on a bst @xmath51 and takes infinite steps , and",
    ", no other modify operation completes after that .",
    "now , if no modify operation completes then the tree remains unchanged forcing @xmath70 to retract every time it wants to inject its own modification on @xmath51 .",
    "this is possible only if every time @xmath71 finds its injection point flagged or marked .",
    "this implies that a remove operation is pending .",
    "it is easy to observe in the function add that if it gets obstructed by a concurrent remove then before retrying after recovery from failure it helps the pending remove by taking all the remaining steps of that . also from lemma [ rem_obstruct ]",
    ", whenever two remove operations obstruct each other , one finishes before the other .",
    "it implies that whenever two modify operations obstruct each other one finishes before the other and so the tree changes .",
    "it is contrary to our assumption .",
    "hence , by contradiction we show that no non - faulty thread shall remain taking infinite steps if no other non - faulty thread is making progress .",
    "this proves the following proposition [ lockfree ] .",
    "[ lockfree ] lock - freedom is guaranteed in the algorithm efficient lock free bst .",
    "having proved that our algorithm guarantees lock - freedom , though we can not compute worst - case complexity of an operation , we can definitely derive their amortized complexity .",
    "we derive the amortized step complexity of our implementation by the accounting method along the similar lines as in  @xcite .    in our algorithm , an add operation does not have to hold any pointer and so does not obstruct an operation .",
    "we observe that after flagging the order - link of a node , a remove operation @xmath72 takes only a constant number of steps to flag , mark and swap pointers connected to the node and to its predecessor , if any , in addition to setting the prelink of the node under remove .",
    "so , if a modify operation @xmath71 gets obstructed by @xmath72 then it would have to perform only a constant number of extra steps in order to help @xmath72 provided that during the help it is not obstructed further by another remove operation @xmath73 .",
    "this observation implies following lemma    [ lemextrasteps ] an obstructing operation @xmath71 makes an obstructed operation @xmath74 take only a constant number of extra steps in order to finish the execution of @xmath74 .",
    "now for an execution @xmath75 , let @xmath2 be the number of nodes at the beginning of @xmath75 .",
    "let @xmath76 be the set of operations and let @xmath77 be the set of steps taken by all @xmath78 .",
    "considering the invocation point @xmath79 of @xmath71 to be the time it reads the root node , and response point @xmath80 to be the time it reads or writes at the last link before it leaves the tree , its _ interval contention _",
    "@xmath81 is defined as the total number of operations @xmath74 whose execution overlaps the interval @xmath82 $ ]  @xcite .",
    "we define a function @xmath83 such that :    a.   had there been no contention , all the essential steps @xmath84 , representing read , write and ` cas ` taken by an operation @xmath71 is mapped to @xmath71 by @xmath85 .",
    "b.   in case of contention , any failed ` cas ` by an operation @xmath71 is mapped to the operation @xmath74 whose successful ` cas ` causes the failure . c.",
    "if an extra read is performed by a traversal due to an added node to the set of existing nodes by a concurrent add operation @xmath71 then it is mapped to @xmath71 .",
    "d.   any read , write or ` cas ` step @xmath84 taken by an operation @xmath71 after the first failed ` cas ` and before retrying at the same link i.e. during helping is mapped to an operation @xmath74 that performed the successful ` cas ` in order to make @xmath71 help it .",
    "this includes resetting of prelink , if needed .",
    "now we bound the length of the traversal path for a predecessor query in our implementation .",
    "note that , all the set operations have to perform a predecessor query by key @xmath10 to locate an interval @xmath39 $ ] s.t .",
    "either @xmath86 @xmath87 and @xmath15 and @xmath16 are two nodes in the bst .",
    "let us define the _ access - node _ of an interval as the order - node of the node that the interval associates with .",
    "we define _ distance _ of an interval from a traversal @xmath71 as the number of links that @xmath71 traverses from its current location to read the access - node of the interval .",
    "suppose that at @xmath79 there are @xmath2 nodes in the bst @xmath51 .",
    "clearly , distance of the interval associated with any node for @xmath71 at @xmath79 is @xmath88 .",
    "it is also easy to observe that unless @xmath71 accesses a node @xmath5 , distance of any node in the subtree rooted at it is @xmath89 .",
    "when @xmath71 travels in the left subtree of a category 3 node @xmath5 and if it gets removed , the interval associated with it gets associated with the leftmost node in the right subtree of the node that replaces it and so the distance of that interval from @xmath71 changes .",
    "there is no such change for a category 1 or category 2 node .",
    "however , once an interval gets associated with the leftmost node in the right - subtree of @xmath5 , which is obviously a category 1 node , its distance can not become more than @xmath89 from a traversal that has accessed @xmath5 .",
    "these observations show that the path length of a traversal in our lock - free bst is bounded by @xmath90 , if no node is added in the traversal path . in case a node is added , the extra read cost is mapped to the concurrent add .",
    "having identified the operations to map for a step , it is easy to observe that an operation @xmath74 to which a step @xmath84 by an operation @xmath71 is mapped , always has its execution interval overlapping @xmath82 $ ] .",
    "so , because ( a ) the traversal path is bounded by @xmath88 , ( b ) a constant number of steps are needed for a modify operation after locating its target ( node or link ) and ( c ) by lemma [ lemextrasteps ] , to an operation @xmath71 only a constant number of extra steps can be mapped by any concurrent operation @xmath74 counted in @xmath81 , we can conclude that the amortized step complexity of a set operation in our lock - free bst algorithm is @xmath91 .    as we described in the section [ secalgo ] ,",
    "we give choice of eager helping to operations according to the read - write load .",
    "now if that happens , we do not need to count all the operations whose executions overlap the interval @xmath82 $ ] .",
    "we can then use a tighter notion of _ point contention _",
    "@xmath92  @xcite , which counts the maximum number of operations that execute concurrently at any point in @xmath82 $ ] . in that case ,",
    "given the above discussion , along the similar lines as presented in  @xcite , we can show that for any execution @xmath75 , the average amortized step complexity of a set operation @xmath71 in our algorithm will be @xmath93 where @xmath94 is the number of nodes in the bst at the point of invocation of @xmath71 and @xmath95 is its point contention during @xmath75 . that concludes the amortized analysis of our algorithm .",
    "it is straightforward to observe that the number of memory - words used by a bst with @xmath2 nodes in our design is @xmath96 .",
    "in this paper we proposed a novel algorithm for the implementation of a lock - free internal bst . using amortized analysis we proved that all the operations in our implementation run in time @xmath0 .",
    "we solved the existing problem of `` retry from scratch '' for modify operations after failure caused by a concurrent modify operation , which resulted into an amortized step complexity of @xmath4 .",
    "this improvement takes care of an algorithmic design issue for which the step complexity of modify operations increases dramatically with the increase in the contention and the size of the data structure .",
    "this is an important improvement over the existing algorithms .",
    "our algorithm also comes with improved disjoint - access - parallelism compared to similar lock - free bst algorithms .",
    "we also proposed a conservative helping technique which adapts to read - write load on the implementation .",
    "we proved the correctness showing linearizability and lock - freedom of the proposed algorithm .",
    "+ we plan to thoroughly evaluate our algorithm experimentally vis - a - vis existing concurrent set implementations .",
    "this work was supported by the swedish research council under grant number 37252706 as part of project scheme ( www.scheme-project.org ) .",
    "b.  chatterjee , n.  nguyen , and p.  tsigas .",
    "efficient lock - free binary search trees .",
    "technical report 2014:05 , isnn 1652 - 926x , department of computer science and engineering , chalmers university of technology , 2014 .",
    "s.  timnat , a.  braginsky , a.  kogan , and e.  petrank .",
    "wait - free linked - lists .",
    "in r.  baldoni , p.  flocchini , and r.  binoy , editors , _ principles of distributed systems _ , volume 7702 of _ lncs _ , pages 330344 .",
    "springer berlin heidelberg , 2012 ."
  ],
  "abstract_text": [
    "<S> in this paper we present a novel algorithm for concurrent lock - free internal binary search trees ( bst ) and implement a set abstract data type ( adt ) based on that . </S>",
    "<S> we show that in the presented lock - free bst algorithm the amortized step complexity of each set operation - add , remove and contains - is @xmath0 , where , @xmath1 is the height of bst with @xmath2 number of nodes and @xmath3 is the contention during the execution . </S>",
    "<S> our algorithm adapts to contention measures according to read - write load . </S>",
    "<S> if the situation is read - heavy , the operations avoid helping pending concurrent remove operations during traversal , and , adapt to interval contention . </S>",
    "<S> however , for write - heavy situations we let an operation help pending remove , even though it is not obstructed , and so adapt to tighter point contention . </S>",
    "<S> it uses single - word compare - and - swap ( ` cas ` ) operations . </S>",
    "<S> we show that our algorithm has improved disjoint - access - parallelism compared to similar existing algorithms . </S>",
    "<S> we prove that the presented algorithm is linearizable . to the best of our knowledge </S>",
    "<S> this is the first algorithm for any concurrent tree data structure in which the modify operations are performed with an additive term of contention measure .    : </S>",
    "<S> concurrent data structures , binary search tree , amortized analysis , shared memory , lock - free , cas + </S>"
  ]
}