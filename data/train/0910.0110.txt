{
  "article_text": [
    "the notion of _ algorithmic pricing _ encompasses a wide range of optimization problems aiming to assign revenue - maximizing prices to some fixed set of items given information about the valuation functions of potential customers @xcite . in a line of recent work the approximation complexity of this kind of problem",
    "has received considerable attention .    without supply constraints , the very simple _ single - price algorithm _ , which reduces the search to the one - dimensional subspace of pricings assigning identical prices to all the items , achieves an approximation guarantee of @xmath4 , where @xmath5 and @xmath6 denote the number of item types and customers , respectively @xcite",
    ". corresponding hardness of approximation results of @xmath7 for some @xmath8 are known to hold ( under different complexity theoretic assumptions ) even in the special cases that valuation functions are _ single - minded _ ( items are _ strict complements _ ) @xcite or _ unit - demand _ ( items are _ strict substitutes _ ) @xcite . in these cases , it is the potentially conflicting nature of different customers valuations that constitutes the combinatorial difficulty of multi - dimensional pricing .",
    "another line of research has been considering so - called _ stackelberg pricing _",
    "problems @xcite , in which valuation functions are expressed implicitly in terms of some optimization problem .",
    "more formally , we are given a set of items , each of which has some fixed cost associated with it .",
    "in addition to these fixed costs , we may assign prices to a subset of the items . given both fixed costs and prices",
    ", a single customer will purchase a min - cost subset of items subject to some feasibility constraints and we receive payment equal to the prices assigned to items purchased by the customer . as an example , we may think of items as being the edges of a graph and a customer aiming to buy a min - cost spanning tree , cheapest path , etc .",
    "clearly , as there is only a single customer in this type of problem , conflicting valuation functions can no longer pose a barrier for the design of efficient pricing algorithms . yet , many stackelberg pricing problems - and in particular the aforementioned spanning tree and shortest path versions - have so far resisted all attempts at improving over the single - price algorithm s logarithmic approximation guarantee .",
    "however , the best known hardness results to date only prove apx - hardness of both the spanning tree @xcite and shortest path @xcite cases without deriving explicit constants .    in this paper , we present the first explicit hardness of approximation result for the shortest path version of stackelberg pricing , which we show to be hard to approximate within a factor of @xmath3 .",
    "the result is based on a novel analysis of reduction that is quite similar to the ones previously described in @xcite and @xcite .      in the _ stackelberg shortest - path pricing problem _ ( stacksp ) , we are given a directed graph @xmath9 , a cost function @xmath10 , a distinguished set of _ pricable edges _",
    "@xmath11 , @xmath12 , and two distinguished nodes @xmath13 .",
    "we may assign prices @xmath14 to the pricable edges .",
    "given these prices , a consumer will purchase a shortest directed @xmath1-@xmath2-path @xmath15 in @xmath0 , i.e.,@xmath16 and we receive revenue @xmath17 .",
    "we want to find a price assignment @xmath18 maximizing @xmath19 .    throughout the rest of this paper",
    ", we will w.l.o.g . only consider stacksp instances for which @xmath20 for all @xmath21 , i.e. , every edge is either pricable or fixed - cost , but never both .",
    "we are going to show that stacksp is quasi - np - hard to approximate within a factor of @xmath3 .",
    "the result is obtained by a refined analysis of a construction very similar to the one used previously in @xcite and @xcite .",
    "[ t : pathpricing ] stacksp can not be approximated in polynomial time within a factor of @xmath22 for any @xmath8 , unless np @xmath23 dtime(@xmath24 ) .",
    "the proof of the theorem is based on a reduction from the _ label cover problem _ ( labelcover ) , which is defined as follows . given a bipartite graph @xmath25 , a set @xmath26 of _ labels _ and a set @xmath27 of satisfying label combinations for every edge @xmath28 , we want to find a label assignment @xmath29 to the vertices of @xmath0 satisfying the maximum possible number of edges , i.e. , edges @xmath30 with @xmath31 .",
    "the following hardness result for labelcover , which is an easy consequence of the pcp theorem @xcite combined with raz parallel repetition theorem @xcite , is found , e.g. , in the survey by arora and lund @xcite .",
    "[ t : labelcover ] for labelcover on graphs with @xmath5 vertices , @xmath6 edges and label set of size @xmath32 there exists no polynomial time algorithm to decide whether the maximum number of satisfiable edges is @xmath6 or at most @xmath33 for any @xmath8 , unless np @xmath23 dtime(@xmath24 ) .",
    "* reduction : * let an instance @xmath25 with label set @xmath26 as in theorem [ t : labelcover ] be given",
    ". denote @xmath34 , where the ordering of the edges is chosen arbitrarily .",
    "note that in our notation @xmath35 , @xmath36 for @xmath37 may well refer to the same vertex ( and the same is true for @xmath38 , @xmath39 ) .",
    "for ease of notation we denote by @xmath40 the satisfying label combinations for edge @xmath41 .",
    "r.3    we create a stacksp instance as follows . for every edge @xmath41",
    "we construct a gadget as depicted in fig .",
    "[ fig : gadget ] .",
    "essentially , the gadget consist of a set of parallel pricable edges , one for each satisfying label assignment @xmath42 and an additional parallel fixed - cost edge of price @xmath43 .",
    "these gadgets are joined together sequentially ( see fig . [",
    "fig : reduction ] ) .",
    "let @xmath44 and consider two pricable edges corresponding to label assignments @xmath42 and @xmath45 .",
    "we connect the endpoint of the first edge with the start point of the second edge with a _",
    "shortcut edge _ of cost @xmath46 , if the two label assignments are conflicting , i.e. , if either @xmath47 and @xmath48 or @xmath49 and @xmath50 .",
    "this construction is depicted in fig .",
    "[ fig : reduction ] .",
    "finally , we define the first node in the gadget corresponding to edge @xmath51 and the last node in the gadget corresponding to @xmath52 as nodes @xmath1 and @xmath2 the consumer seeks to connect via a directed shortest path .",
    "we will refer to the gadgets by their indices @xmath53 and denote the pricable edge corresponding to label assignment @xmath54 in gadget @xmath55 as @xmath56 .",
    "* completeness : * let @xmath57 be a label assignment satisfying all edges in @xmath0 . we define a corresponding pricing @xmath18 by setting for every pricable edge",
    "@xmath58 if @xmath59 , @xmath60 and @xmath61 else .",
    "the resulting shortest path from @xmath1 to @xmath2 can not use any of the shortcut edges , because , as @xmath57 is a feasible label assignment , out of any two pricable edges corresponding to conflicting assignments , one must be priced at @xmath62 .",
    "consequently , no path using a shortcut edge can have finite cost . on the other hand , since @xmath57 satisfies every edge , there is a pricable edge of cost @xmath43 in each of the gadgets .",
    "it is then w.l.o.g . to assume that the consumer purchases the shortest path using the maximum possible number of pricable edges and , hence , total revenue is @xmath63 .    *",
    "soundness : * let @xmath18 be a given pricing resulting in overall revenue @xmath64 and let @xmath65 denote the shortest path purchased by the consumer given these prices .",
    "we will argue that there exists a label assignment @xmath57 satisfying @xmath66 of the edges in @xmath0 .    first note that w.l.o.g .",
    "any pricable edge that is not part of path @xmath65 has price @xmath62 under price assignment @xmath18 .",
    "in particular , this means that in every gadget @xmath55 there is at most a single pricable edge with a finite price .",
    "we call this edge the _ @xmath65-edge _ of gadget @xmath55 .",
    "we proceed by grouping gadgets into so - called _ islands _ as detailed below .",
    "* islands : * let @xmath67 be the first gadget with a @xmath65-edge and call @xmath67 the _ start point _ of an",
    "_ island_. now for each @xmath68 find the maximum value of @xmath69 , such that gadget @xmath70 has a @xmath65-edge and there exists a shortcut edge between the @xmath65-edges of gadgets @xmath68 and @xmath70 . if such a @xmath70 exists , define @xmath71 , else call @xmath68 an _ end point _",
    ", let @xmath72 be the minimum value such that gadget @xmath73 has a @xmath65-edge , define @xmath74 and call @xmath75 a start point .",
    "if no such @xmath73 exists , call @xmath68 an end point and stop .",
    "let @xmath76 be the end point of the final island .",
    "we call @xmath77 the _ significant gadgets_.    note that by construction every gadget with a @xmath65-edge is covered by some _ island _ , i.e. , the interval defined by some consecutive start and end points .",
    "[ fact1 ] consider an island @xmath78 .",
    "path @xmath65 does not enter gadget @xmath79 or exit gadget @xmath80 via a shortcut edge .    if @xmath65 exits @xmath80 via a shortcut edge , then @xmath80 could not have been declared an end point .",
    "if @xmath79 is entered via a shortcut edge , this shortcut must originate from a gadget @xmath81 which lies within the preceding island . as @xmath65 can not bypass the endpoint of the preceding island via a shortcut",
    ", @xmath55 must in fact be the end point @xmath82 and so @xmath79 could not have become a start point .",
    "consider now a single island @xmath78 . by @xmath83",
    "we denote the length of the shortcut edge between gadgets @xmath68 and @xmath75 for @xmath84 .",
    "furthermore , by @xmath85 and @xmath86 we refer to the lengths of the shortcut edges used by path @xmath65 to enter and exit gadget @xmath68 , respectively , and set them to @xmath87 if no shortcuts are used .",
    "from fact [ fact1 ] above it follows that @xmath88 .",
    "[ fig : island ] for an illustration .    for @xmath89",
    "let the cost of path @xmath65 between shortcut edges @xmath86 and @xmath90 be @xmath91 , where @xmath92 denotes the cost due to pricable edges and @xmath93 the cost due to fixed - cost edges , respectively .",
    "we are going to bound the expression @xmath94 .",
    "we note that @xmath95 , since by the fact that gadget @xmath80 is an endpoint , no shortcut edge connects its @xmath65-edge to the @xmath65-edge of another gadget .",
    "similarly , we have @xmath96 , since path @xmath65 does not use pricable edges between islands , as we have argued before .",
    "path @xmath65 crosses the end node of the @xmath65-edge in gadget @xmath68 ( node @xmath97 in fig .",
    "[ fig : island ] ) and the start node of the @xmath65-edge of gadget @xmath75 ( node @xmath98 in fig .",
    "[ fig : island ] ) for @xmath84 .",
    "the total cost of path @xmath65 between these two vertices is @xmath99 .",
    "an alternative path @xmath100 is obtained by replacing this part of @xmath65 with the shortcut edge of length @xmath83 between @xmath68 and @xmath75 . by the fact that @xmath65 is the shortest path we have @xmath101 and , thus , @xmath102 where the bound on @xmath103 follows from the fact that for @xmath104 all summands in the above expression are @xmath87 .",
    "similarly , the cost of path @xmath65 between the start node of the shortcut edge into gadget @xmath68 ( node @xmath105 in fig .",
    "[ fig : island ] ) and the end node of the shortcut edge exiting @xmath68 ( node @xmath106 in fig .",
    "[ fig : island ] ) is @xmath107 for @xmath89 .",
    "we obtain an alternative path @xmath108 by taking only fixed cost edges of cost @xmath43 to bypass both shortcuts and gadget @xmath68 at total cost @xmath109 . again , since @xmath65 is the shortest path , we get @xmath110 , or @xmath111 combining ( [ eqn1 ] ) and ( [ eqn2 ] ) yields @xmath112 finally , we have @xmath113    recall that @xmath77 denote the significant gadgets across all islands",
    ". assume now that there is a total number @xmath114 of islands with start and end points @xmath115 .",
    "summing over all islands we get that overall revenue of price assignment @xmath18 is bounded by@xmath116 where the last inequality follows from the fact that @xmath117 for @xmath118 , @xmath119 and @xmath120 , since all shortcuts defining the @xmath83 are disjoint .",
    "thus , we have @xmath121 , or @xmath122 .",
    "now consider the @xmath65-edges of the @xmath123 gadgets @xmath124 and their corresponding label assignments @xmath125 . by definition",
    ", there are no shortcut edges between the @xmath65-edges of any of these gadgets and , thus , @xmath126 define a non - conflicting label assignment satisfying at least @xmath127 edges in @xmath0 .",
    "( labels not defined by @xmath126 can be chosen arbitrarily . )    finally , consider a label cover instance as in theorem [ t : labelcover ] and the path pricing instance resulting from our reduction above .",
    "if all edges can be satisfied , maximum path pricing revenue is @xmath63 .",
    "if no label assignment satisfies more than @xmath33 edges , maximum path pricing revenue is bounded by @xmath128 .",
    "this finishes the proof of theorem [ t : pathpricing ] .",
    "we briefly mention that our analysis is tight in the following sense .",
    "it is easy to check that by assigning price @xmath129 to all pricable edges we can make sure that w.l.o.g .",
    "the shortest @xmath1-@xmath2-path uses a pricable edge in each of the gadgets and , thus , we obtain revenue @xmath6 .",
    "since maximum possible revenue is bounded above by @xmath63 ( there is an @xmath1-@xmath2-path of that cost that does not use any pricable edges ) , it follows that it is trivial to achieve approximation guarantee @xmath43 on the instances resulting from our reduction .",
    "we have proven the first explicit approximation threshold for any stackelberg pricing problem . still , the approximation threshold for this kind of problem in general - and the shortest path version in particular - is far from settled .",
    "the following questions seem to constitute fertile ground for future research :    * can we prove super - constant hardness of approximation results for any kind of stackelberg pricing problem ? *",
    "is it possible to achieve a better than logarithmic approximation guarantee for the stackelberg shortest path pricing problem ?",
    "is there an interesting restricted set of graphs on which constant approximation factors are possible ?"
  ],
  "abstract_text": [
    "<S> we consider the _ stackelberg shortest - path pricing problem _ , which is defined as follows . </S>",
    "<S> given a graph @xmath0 with fixed - cost and pricable edges and two distinct vertices @xmath1 and @xmath2 , we may assign prices to the pricable edges . </S>",
    "<S> based on the predefined fixed costs and our prices , a customer purchases a cheapest @xmath1-@xmath2-path in @xmath0 and we receive payment equal to the sum of prices of pricable edges belonging to the path . our goal is to find prices maximizing the payment received from the customer . </S>",
    "<S> while stackelberg shortest - path pricing was known to be apx - hard before , we provide the first explicit approximation threshold and prove hardness of approximation within @xmath3 . </S>"
  ]
}