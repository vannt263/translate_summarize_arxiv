{
  "article_text": [
    "the poplmark challenge is a set of common programming language problems meant to test the utility of modern proof assistants and techniques for mechanized metatheory . in response to this challenge",
    ", significant strides have been made in making it easier to mechanize the metatheory of programming languages , especially regarding variable binding  @xcite .",
    "however , little progress has been made in the direction of modularity : it is still difficult to separately develop the definitions and meta - theory of language fragments and then link the fragments together to obtain the definitions and meta - theory for a language composed of such fragments .",
    "dependent types have formed the foundation of a broad and rich range of type systems that allow values and types to be freely mixed .",
    "programmers can express propositions as types viewed as sets , and proofs as objects viewed as inhabitants of those sets .",
    "this style of theorem proving suggests the use of familiar engineering abstractions as general solutions to questions about theorem proving . rather than relying on semi - automated proof search such as coq s ltac we propose a method of proof composition using simple abstractions whereby components are defined piecewise and `` tied '' together at the end using a wrapper datatype acting as a tagged union .",
    "the method of language definition used is iterative .",
    "components are defined separately from one another and are composable along with their proofs .",
    "thus we would like for separate language designers to be able to reuse one anothers work without the need for sophisticated proof search algorithms or with effort spent copying and pasting terms .",
    "the language we present is one of simple expressons using agda as the implementation language and proof assistant .",
    "we begin by defining a series of language syntaxes for sums , options , and arrays .",
    "we chose to include arrays because they not only can result in runtime errors requiring the inclusion of the @xmath0 type but like addition , they use the natural numbers , forcing consideration of how value types can be shared across otherwise isolated components .",
    "we continue by defining evaluation semantics and typing rules . the language is defined piecewise , each component is built in isolation alongside a proof of type preservation .",
    "we conclude with a presentation of how these components can be composed and a proof of type preservation for the combined language can be immediately derived from the componentwise proofs .",
    "the motivation for our technique is drawn from a solution to the expression problem where languages are defined as the disjoint sum of smaller languages by removing explicit recursion .",
    "we show that this idea can be recast from types and terms , to proofs .",
    "when modeling a problem with a functional flavor often the natural solution emerges as several recursive cases handled by some helper functions .",
    "the expression problem states that this type of solution presents us with a choice : we may ordain our data structure forever unchanging , making it easy to add new functions without changing the program ; or we may leave our data structure open , making it difficult to extend the original program with new functions .    while many solutions to the expression problem have been proposed over the years ,",
    "here we make use of the method described by malcom  @xcite which generalizes recursion operators such as fold , from lists to polynomial types .",
    "the problem we encounter arises as a result of algebraic data types being _ closed _ : once the type has been declared , no new constructors for the type may be added without amending the original declaration and the solution presented lies at the heart of our work .",
    "the idea is simply to remove immediate recursion and split a monolithic datatype into components to be later collected under the umbrella of a tagged union .    throughout this paper",
    "we will work with a simple evaluator over natural numbers and basic arithmetic operators ; in agda we might first consider     +   +    this definition has the advantage of being direct and simple , however a problem lies within the explicit recursion ; notice that when later extending expressions with arrays and option types we can make no reuse of expr+ due to the closed nature of algebraic data types . to extend expr+",
    "we must define a whole new data type , as in the following definition of monolithicexpr .",
    "+   +   +   +   +   +   + 0.06em   +   +   +   +   + ( ) + ( )    suppose instead we begin with polymorphic definitions such as the following .",
    "( ) +   + ( ) +   +   + 0.06em   + ( ) +   +   + ( ) +    we then introduce recursion as follows , combining components as a disjoint sum , written @xmath1 in agda .",
    "+   +   +   +   +    more generally , this type of data can be captured using a `` categorical approach '' where recursion is introduced as the fixed point of a functor :    ( ) + ( ) + ( ) +   +   +    it is easy to see that this new type is equivalent to monolithicexpr up to isomorphism @xmath2 \\ ; \\textpipe \\ ; -!!- \\ ; \\textpipe \\ ; -[-]:=- \\\\\\end{aligned}\\ ] ]      the functor @xmath3 , passed into @xmath4 above , serves as the key abstraction allowing us to represent expressions as least fixed points .",
    "functors are a special mapping defined over both types and functions satisfying the so called _ functor laws _ ; a functor f    1",
    ".   assigns to each type @xmath5 , a type @xmath6 2 .",
    "assigns to each function @xmath7 , a function @xmath8    such that    1 .",
    "identity is preserved : @xmath9 , and 2 .   when @xmath10 is defined : @xmath11 .",
    "one familiar example is the @xmath12 functor mapping each type @xmath5 to @xmath13 and each function @xmath7 to @xmath14 which applies @xmath15 to each element of a list .",
    "here we define the least fixed point over a restricted class of functors called the _",
    "polynomial functors_. polynomial functors are a subset roughly equivalent to the more familiar algebraic polynomials , @xmath16 where addition is disjoint sum and multiplication is cartesian product . in agda",
    ", ulf norell@xcite expresses this class as a datatype @xmath17 along with an interpretation as a set @xmath18 $ ]     +   +   +   +   +   +   + [ 1.5mu 0.06em 1.5mu ] + [ 1.5mu 1.5mu ] + [ 1.5mu 1.5mu ] + [ 1.5mu 1.5mu ] + [ 1.5mu 1.5mu ]    with least fixed point    ( ) + ( )    then to reexpress @xmath19 as a polynomial functor we use sum @xmath20 to define cases within a type , and product @xmath21 to represent arguments of a particular case     +   +   +   +   +   +   +   +   +    unfolding @xmath22 yields the same value calculated above  as we should hope !     +   + ( ) + ( ) + ( ) + ( ) +   + ( ) + ( ) ( ) + ( ) ( ) ( ) ( ) ( )    what do values in @xmath22 look like ?",
    "written directly they appear nonsensical , consider @xmath23     + ( ( ( + ( ( ( ( ) ) ) ) + , ( ( ( ( ) ) ) ) ) ) )    notice here the role that the injections and @xmath24 functions play .",
    "traditionally we would provide a unique name for each branch in an algebraic datatype , however here we only have two names @xmath25 and @xmath26 so we instead rely on nesting to create unique prefixes .",
    "once we have tagged a value we must give it a well known type so that parent expressions can expect a common child type , this is the role of @xmath24 .",
    "although cumbersome we can hide much of this complexity provided the right abstractions     +   +   +   +   + ( ( ( , ) ) )",
    "we are now ready to define a simple language and its operational semantics .",
    "the language is small including just sums , an option type , and an array with assignment and lookup . in agda",
    ", the unit type is written @xmath27 and has only one member : @xmath28 .",
    "@xmath27 is used to represent constructors that take no arguments such as @xmath29 , the empty list .",
    "+   +   +   +   +   +   +   +   +    what do each of these definitions mean ? the maybe type has two constructors : some , which wraps a single expression ; and none taking no arguments .",
    "we define more descriptive constructors for tagging these two types of values     + ( ( ( ( ) ) ) ) +   +    giving a convenient constructor for @xmath30 is similarly straightforward     +   +   + ( ( ( , ) ) )    and to define arrays we have assignment taking an array , an index , and a value to assign at that index ; nil , the empty array ; and lookup which accepts an array and an index    0.06em   + ( ( ( ( , , ) ) ) ) +   + ( ( ( ) ) ) +   + ( ( ( , ) ) )    so far the definition of our syntax has used fairly standard techniques but we have failed to give any sort of meaning to these expressions . we first define a monolithic static and dynamic semantics for this language , then show how to modularize their definition later in this section .",
    "figure  [ fig : value typing rules ] defines a simple set of typing rules using metavariables @xmath31 to range over experssions and @xmath32 to range over values ; figure  [ fig : evaluation semantics ] gives a small step operational semantics .",
    "c c c & +   + & +    [ fig : language definition ]    while agda is expressive enough to implement these rules , directly and indeed they are nearly a direct reflection of that implementation , recall that our goal is to create several independant languages each carrying their own semantics .",
    "we begin by defining monolithic semantics for @xmath19 and proceed to determine points of failure and to dissect the definition into independant constituents . to simplify things we define our notion of @xmath33 as a closed adt     +   +   +    and here is the definition of the monolithic type system and evaluation relation in agda .",
    "+ \\{1.5mu 1.5mu } ( ) + \\{1.5mu 1.5mu } +   + ( ) +   + \\{1.5mu 1.5mu } +   +   + ( ) + \\{1.5mu 1.5mu } +   +   +   + ( ) +   +   + \\{1.5mu 1.5mu } +   +   + \\{1.5mu 1.5mu}\\{1.5mu 1.5mu } +   +   + \\{1.5mu 1.5mu } + ( ) + \\{1.5mu 1.5mu } +   +   + \\{1.5mu 1.5mu } + ,    the function @xmath34 is the lookup function that evaluates to @xmath35 when @xmath36 has been defined and @xmath37 otherwise . notice that we currently do not restrict the values of @xmath32 enough in the @xmath38 rule ; our typing rules require that n be a value while in agda we have only required it be an expression .",
    "some notion of value is needed and a common solution is to add a tag @xmath39 to the @xmath40 type and pattern match ; here @xmath39 is called @xmath41 $ ] and in a dependantly typed context we might then define a predicate over @xmath39 .",
    "however because the sum type has only one type of value , a number , it is simpler to use @xmath42 directly .",
    "this method for defining semantics is common with the advantage of being direct and concise , but similar to our first implementation of @xmath43 and @xmath44 above : there is no simple mechanism for code reuse .",
    "the answer is again to delay recursion .      in order to modularize the evaluation rules we define a separate step relation for each functor making up our @xmath19 type .",
    "first note that @xmath45 does nt make use of _ how _ the step from @xmath46 to @xmath47 occurs so we can factor this top - level relation    \\{1.5mu 1.5mu } +   + \\{1.5mu 1.5mu } +   + \\{1.5mu 1.5mu}\\{1.5mu 1.5mu } +   +   + \\{1.5mu 1.5mu } + ( )    while this is better there is still an undesirable reference to the datatype @xmath19 .",
    "applying the same factorization here to the underlying functor requires parametrization by two extra coercion functions , these are the @xmath45 and @xmath42 functions defined previously . the new names @xmath48 and @xmath49 used here are meant to imply that a subtype is being `` lifted '' into its supertype    \\{1.5mu 1.5mu}\\{1.5mu 1.5mu } + \\{1.5mu ( ) 1.5mu}\\{1.5mu 1.5mu } +   + \\{1.5mu 1.5mu } + ( , ) ( , ) + \\{1.5mu 1.5mu}\\{1.5mu 1.5mu } +   + ( , ) ( , ) + \\{1.5mu 1.5mu } + ( , ) ( )    unfortunately this definition falls short too . when we lift terms into the expression type @xmath50 , agda `` forgets '' the constituents @xmath46 and @xmath47in turn we lose the ability to reason about these distinct components of the sums @xmath51 and @xmath52 .",
    "this later becomes a problem when , for example , attempting to abstract the welltyping relation .",
    "an intelligent human can peel away @xmath48 and see that the terms @xmath46 and @xmath47 in @xmath53 and @xmath54 are the same because @xmath48 is _",
    "injective_. however agda is unconvinced , and rightfully so , for it does not require a particularly great deal of ingenuity to find a counterexample , consider taking @xmath55 so that @xmath56     + ( , )    the problem is that our abstraction is too general .",
    "what we require is a proof that @xmath57(\\mu e)$ ] and @xmath58 are subtypes of the top - level expression datatype @xmath50 .",
    "the solution to the problem is drawn from the notion of a categorical subobject .",
    "we proceed by delaying application of injections and view the objects as injectable , existential terms .",
    "the importance of this approach is two - fold : firstly this allows us to take inverses of lift functions while we are secondly able to retain the perspective of operating on a single type @xmath50 .",
    "a subobject of a type @xmath59 is a left invertible function with codomain @xmath59 , @xmath60 .",
    "being restricted to polynomial functors , we know that all our subobjects @xmath61 will be some composition of @xmath24 , @xmath25 and @xmath26 so a proof that @xmath62 is a subtype of @xmath50 is merely a description of which direction to move at each point in a disjoin sum     +   + \\{1.5mu 1.5mu } +   + \\{1.5mu 1.5mu } +   + \\{1.5mu 1.5mu } +    now we can define containment on a functor s interpretation as a set     +   + \\{1.5mu 1.5mu } + ( ) ( )    with conversion functions defined as    \\{1.5mu 1.5mu } ( ) +   + ( ) + ( ) + \\{1.5mu 1.5mu } ( ) + ( )    recall the two goals we had in mind .",
    "we first wished to take the inverse of a lift function to gain access to its arguments , in the case of @xmath30 these were @xmath46 and @xmath47 . by representing an injection as a delayed application of a subobject  because the constructor s arguments are stored as a part of the coercion ",
    "finding left inverses will become a trivial case of pattern matching . to delay function application allowing agda to effectively peel away the @xmath63 functions we define a @xmath64 datatype from type @xmath5 to @xmath65 representing the _ intention _ of coercing an object @xmath66 while treating it at the type - level as @xmath65 .",
    "a lazy coercion is then an injection @xmath67 along with an object in @xmath5     + \\{1.5mu 1.5mu } ( ) + \\{1.5mu 1.5mu } + ( )    our second goal was to operate on objects of a single type .",
    "why is this the case ? recall that the type of our step relation is indexed by two expressions : @xmath68 .",
    "we should expect the same of the final abstraction over step relations because it can not easily name the underlying type of its indexing expressions .",
    "instead we have packaged the indices as _",
    "existentials _ which are viewed as the type @xmath65 .",
    "we seem to be close to a modular step relation @xmath54 , defining at each point another level of abstraction to delay immediate application . to modularize datatypes , recursion is delayed and types are viewed as polynomial functors , then to modularize step relations , evaluation is parametrized and expression upcasts are delayed by viewing them as an intention .",
    "attempting again to define a step relation for addition we find very little has changed    \\{1.5mu 1.5mu } + \\{1.5mu 1.5mu } + \\{1.5mu ( ) 1.5mu } + \\{1.5mu 1.5mu } + ( ) ( ) +   + \\{1.5mu 1.5mu } +   + ( , ) ( , ) + \\{1.5mu 1.5mu } +   + ( , ) ( , ) + \\{1.5mu 1.5mu } + ( , ) + ( )    it appears we ve littered an otherwise simple definition with @xmath69 but we ve replaced our arbitrary arrows with objects having constructors we can match on . using the above techniques we can modularize the welltyping relation over sums for free    \\{1.5mu 1.5mu } + \\{1.5mu 1.5mu } + \\{1.5mu ( ) 1.5mu } + ( ) + \\{1.5mu 1.5mu } +   + ( ( , ) )    the above definitions nearly wrote themselves .",
    "the simplicity comes from the fact we are just abstracting as many terms as possible , keeping in mind we can fill them in naturally later because the abstraction is so general there are few options available .",
    "we proceed by defining the step and welltypedness relations on arrays that can be combined with the relations on sums .",
    "the definitions for evaluation and welltypedness should look similar to those for sums @xmath54 .",
    "0.06em \\{1.5mu 1.5mu } + \\{1.5mu 1.5mu } + \\{1.5mu ( ) 1.5mu } + \\{1.5mu 1.5mu } + \\{1.5mu ( ) 1.5mu } + ( ) ( ) +   + \\{1.5mu 1.5mu } + ( ) ( ) + \\{1.5mu ( ) 1.5mu}\\{1.5mu 1.5mu } + ( ) + ,    to define the typing relation we again follow the format of @xmath70 above and we are done .",
    "\\{1.5mu 1.5mu } + \\{1.5mu 1.5mu } + \\{1.5mu ( ) ( ) 1.5mu } + \\{1.5mu 1.5mu } + ( ) + ( ) + \\{1.5mu 1.5mu } +   + ( ( ) ) + \\{1.5mu 1.5mu } +   + ( ( ) )",
    "the type preservation lemma states that if a term is welltyped and can step , then the type of the term is preserved after evaluation @xmath71 prior to considering how type preservation might look for each of the previously defined components we should review what type preservation looks like for the @xmath44 language .",
    "the proof is standard , proceeding by structural induction on the shape of the welltyping tree .",
    "\\{1.5mu 1.5mu}\\{1.5mu 1.5mu } +   +   +   + ( ) ( ) + ( ) + ( ) ( ) + ( ) +   + ( \\{1.5mu 1.5mu}\\{1.5mu 1.5mu } ) ( ) + ( ) + ( ) ( ) + ( ) +   + ( \\{1.5mu 1.5mu}\\{1.5mu 1.5mu } ) ( ) + ,    there are three items worth noting here : the first is the use of the function @xmath72 which we have assumed produces a pair with first component an expression and second component a proof that the expression is a welltyped option ; the second is that recursion acts as our induction hypothesis ; and finally that agda is smart enough to notice there is only a single possible welltyping constructor for each step constructor  in agda all functions are total .",
    "we should expect the modular type preservation lemmas to look similar because there is little global knowledge involved .",
    "the induction hypothesis and values aside , each case is `` contained within its own world '' in the sense that each evaluation rule relies only on the fact that subterms are welltyped but ignoring the _ reason _ they are welltyped . to show type preservation for sums we might start with    \\{1.5mu 1.5mu}\\{1.5mu 1.5mu } + \\{1.5mu ( ) 1.5mu }",
    "+   +   +   +   + ( \\{1.5mu 1.5mu}\\{1.5mu 1.5mu}\\{1.5mu 1.5mu } ) ( )    however recall that @xmath54 requires the top - level step relation and proof that @xmath73 contains both sums and naturals .",
    "there is a second mistake in writing preservation this way  we would like to show that @xmath74 is welltyped in the expression language , not just necessarily in the modular sum language , this reflects our desire to expose as little about each component as possible . a second formulation might then begin as follows but we again fail .",
    "\\{1.5mu 1.5mu } + \\{1.5mu 1.5mu } + \\{1.5mu 1.5mu } + \\{1.5mu ( ) 1.5mu } + \\{1.5mu 1.5mu } + \\{1.5mu 1.5mu } + \\{1.5mu ( ) 1.5mu } + \\{1.5mu 1.5mu}\\{1.5mu 1.5mu}\\{1.5mu 1.5mu}\\{1.5mu 1.5mu } + \\{1.5mu 1.5mu}\\{1.5mu 1.5mu}\\{1.5mu 1.5mu } + ( ) + ( ) ( ) + ( ) + ( ) ( ) + ( ) + ( ) + ( )    it seems we re only missing two pieces : we need to be able to lift welltyped sums and naturals into @xmath75 ; and we need some way of expressing the induction hypothesis which states that because @xmath46 is welltyped and stepped , @xmath76 is welltyped too .",
    "the induction hypothesis is slightly stranger than was the case in our @xmath44 s because we know @xmath46 and @xmath76 are welltyped despite the fact that they are any expressions , not necessarily just sums .",
    "this motivates our solution which takes the induction hypothesis as an explicit assumption .",
    "\\{1.5mu 1.5mu } + \\{1.5mu 1.5mu } + \\{1.5mu 1.5mu } + \\{1.5mu ( ) 1.5mu } + \\{1.5mu 1.5mu } + \\{1.5mu 1.5mu } + \\{1.5mu ( ) 1.5mu } + ( ( ) ( ) ) + ( \\{1.5mu 1.5mu}\\{1.5mu 1.5mu } + \\{1.5mu 1.5mu}\\{1.5mu 1.5mu}\\{1.5mu 1.5mu } ( ) + ( ) ) + ( \\{1.5mu 1.5mu}\\{1.5mu 1.5mu } ) + \\{1.5mu 1.5mu}\\{1.5mu 1.5mu}\\{1.5mu 1.5mu}\\{1.5mu 1.5mu } + \\{1.5mu 1.5mu}\\{1.5mu 1.5mu}\\{1.5mu 1.5mu } + ( ) +   + ( ) ( ) + ( ( ) ) +   + ( ) ( ) + ( ( ) ) +   + ( \\{1.5mu 1.5mu}\\{1.5mu 1.5mu } ) ( ) + ( )    we are pleased with how similar this is to the original , monolithic formulation .",
    "notice again that the solution was to factor out assumptions about the outside world similar to the previous abstractions .",
    "proving type preservation for arrays is similarly natural :    \\{1.5mu 1.5mu } + \\{1.5mu 1.5mu } + \\{1.5mu 1.5mu } + \\{1.5mu ( ) ( ) 1.5mu } + \\{1.5mu 1.5mu } + \\{1.5mu ( ) ( ) 1.5mu } + \\{1.5mu 1.5mu } + \\{1.5mu ( ) 1.5mu } + ( ( ( ) ) ( ) ) + ( \\{1.5mu 1.5mu}\\{1.5mu 1.5mu } + \\{1.5mu 1.5mu}\\{1.5mu 1.5mu}\\{1.5mu 1.5mu}\\{1.5mu 1.5mu } ( ) + ( ) ) + ( \\{1.5mu 1.5mu}\\{1.5mu 1.5mu } ) + 0.06em \\{1.5mu",
    "1.5mu}\\{1.5mu 1.5mu}\\{1.5mu 1.5mu}\\{1.5mu 1.5mu}\\{1.5mu 1.5mu } + \\{1.5mu 1.5mu}\\{1.5mu 1.5mu}\\{1.5mu 1.5mu}\\{1.5mu 1.5mu } + ( ) +   + ( ) ( ) + ( ( ) ) +   + ( \\{1.5mu 1.5mu}\\{1.5mu 1.5mu } ) ( ) + ,    it would seem we re nearly done and the final pieces should be entirely guided by the selected abstractions .",
    "the @xmath77 functions each have a unique solution :     + ( ( ( ) ) ) +   + ( ( ( ) ) ) +   + ( ( ( ) ) ) +   + ( )    but how should we define welltypedness for @xmath40 ? again",
    "the notion of what it means to be welltyped has already been defined and we simply need to `` tie the knot '' as @xmath78 did above     + ( ) ( ) + ( ) + ( ) + \\{1.5mu 1.5mu}\\{1.5mu 1.5mu } + \\{1.5mu 1.5mu}\\{1.5mu 1.5mu}\\{1.5mu 1.5mu } ( ) + ( ) + \\{1.5mu 1.5mu}\\{1.5mu 1.5mu } + \\{1.5mu 1.5mu}\\{1.5mu 1.5mu}\\{1.5mu 1.5mu}\\{1.5mu 1.5mu } + ( ) + ( )    to define a step relation on @xmath40 , @xmath53 we provide a similar wrapping for each language component     + \\{1.5mu 1.5mu}\\{1.5mu 1.5mu } + \\{1.5mu 1.5mu}\\{1.5mu 1.5mu}\\{1.5mu 1.5mu}\\{1.5mu 1.5mu } + ( ) +   + \\{1.5mu 1.5mu}\\{1.5mu 1.5mu } + 0.06em   + \\{1.5mu 1.5mu}\\{1.5mu 1.5mu}\\{1.5mu 1.5mu}\\{1.5mu 1.5mu}\\{1.5mu 1.5mu } + ( ) +    the only piece remaining is to prove type preservation .",
    "we begin in the same way we have for each of the previous proofs using the step relation s constructors as a guide .",
    "the type signature should not have changed    \\{1.5mu 1.5mu}\\{1.5mu 1.5mu } +    and there are two cases @xmath79 and @xmath80 $ ] ; moreover we should expect to merely apply preservation- * to each case , supplying the necessary lift functions and the induction hypothesis .",
    "this is indeed the case :    ( ) ( ) +   +   + ( ) ( ) +   +    having shown type preservation it is interesting to see the similarity between how terms are shown to be welltyped and to evaluate and how the terms are expressed in @xmath81 .",
    "recall that each term in @xmath40 is wrapped by a tag  given by @xmath25 and @xmath26and the constructor @xmath24 plays the role of recursion . to reiterate",
    "consider the convenience functions ,     + ( ( ( ) ) ) +   + ( ( ( ) ) ) + 0.06em   + ( ) +   + ( ) +   + ( , )    we may then ask : why is the term     + ( ) ( )    welltyped ? the answer given by @xmath82 is     + ( ) +   + ( ) +   + ( ( ) + ( ) ( ) ) + ( ) + ( + ( ) ( ) )    the @xmath83 functions play the same role in @xmath84 as @xmath24 does in @xmath40 ; however rather than using the generalized approach of a series of disjoint sums we bundle the tag and recursion into a single constructor for each language component .",
    "evaluation displays a similar symmetry    ( ) ( ) + ( ) + ( ( ) )    what does the proof that @xmath85= { \\textrm{nat}\\;}1)\\,!e\\,{\\textrm{nat}\\;}1 $ ] is welltyped look like ?",
    "we can compute it by invoking    which evaluates to     + ( + ( + ( ( ) ( ) ( ) ) ) + ( ) )",
    "independent and concurrently with our work , delaware , et al .",
    "@xcite developed a solution to moduler meta - theory in coq .",
    "both their approach and ours relies on the principle of representing data types as functors ; however they have chosen to express inductive types using church encodings and recursive evaluation using mendler algebras , which requires some extra sophistication . here",
    "we express types as data members of the family of polynomial functors and apply recursive evaluation directly .",
    "their approach presented is further along and has shown the important level of robustness required by most languages while there are more unanswered questions regarding the method presented here .",
    "we should ask if we have accomplished the goal that we set out with .",
    "the language @xmath40 was given componentwise and the boiler - plate necessary to wrap each welltyping and step relation is minimal .",
    "the proof of type preservation was almost immediate , requiring only an invocation of previously defined proofs for each component .",
    "moreover there is no copy and paste necessary and the repetitive components should be automatically producable given a sophisticated macro system where terms can be inspected by name ",
    "set equality is non - deterministic  rather than value .    using agda as a proof language ,",
    "although convenient , leaves the question of consistency open .",
    "we regard this as a minor problem and hope that our implementation would port to coq .",
    "a more pertinent problem is the definition of @xmath86 for @xmath40agda is unable to prove termination and we plan to address this soon .",
    "the language presented is quite simple , unable to express even euclid s algorithm , and the method of polynomial functor s used to express @xmath19 precludes the possibility of first class function types which are critical for functional programming .",
    "various solutions to this problem have been proposed  @xcite and the area of recursion schemes is rich  @xcite .",
    "a real world language calls for much heavier sophistication , but the ideas presented here are new and their reach is open to question and requires further exploration .            erik meijer and graham hutton . _ bananas in space : extending fold and unfold to exponential types . _ in proceedings of the seventh international conference on functional programming languages and computer architecture ( fpca 95 ) .",
    "acm , new york , ny , usa , 324 - 333 ."
  ],
  "abstract_text": [
    "<S> while methods of code abstraction and reuse are widespread and well researched , methods of proof abstraction and reuse are still emerging . </S>",
    "<S> we consider the use of dependent types for this purpose , introducing a completely mechanical approach to proof composition . </S>",
    "<S> we show that common techniques for abstracting algorithms over data structures naturally translate to abstractions over proofs . </S>",
    "<S> we first introduce a language composed of a series of smaller language components tied together by standard techniques from malcom  @xcite . </S>",
    "<S> we proceed by giving proofs of type preservation for each language component and show that the basic ideas used in composing the syntactic data structures can be applied to their semantics as well . </S>"
  ]
}