{
  "article_text": [
    "given a set @xmath0 of @xmath8 points in @xmath9 , a well - known problem in computational geometry is nearest neighbor searching : preprocess @xmath0 such that , for any query point @xmath1 , a point in @xmath0 that is closest to @xmath1 can be reported efficiently .",
    "this problem has been studied extensively ; in this paper , we consider the related problem of _ reverse nearest neighbor searching _ , which has attracted some attention recently .",
    "the reverse nearest neighbor searching problem is the following . given a query point @xmath1",
    ", we want to report all the points in @xmath0 that have @xmath1 as one of their nearest neighbors .",
    "more formally , we want to find the points @xmath10 such that for all points @xmath11 , the distance @xmath12 is larger or equal to the distance  @xmath13 .",
    "the earliest work on reverse nearest neighbor searching is by korn and muthukrishnan  @xcite .",
    "they motivate this problem by applications in databases . their approach is based on r - trees , so it is unlikely to give a good worst - case time bound .",
    "subsequently , the reverse nearest neighbor searching problem has attracted some attention in the database community  @xcite .    the only previous work on reverse nearest neighbor searching where worst - case time bounds are given is the work by maheshwari et al",
    ".  @xcite .",
    "they give a data structure for the two - dimensional case , using @xmath4 space , with @xmath14 preprocessing time , and @xmath6 query time .",
    "their approach is to show that the arrangement of the largest empty circles centered at data points has linear size , and then they answer queries by doing point location in this arrangement .    in this paper , we extend the result of maheshwari et al .",
    "@xcite to arbitrary fixed dimension .",
    "we give a data structure for reverse nearest neighbor searching in @xmath9 , where @xmath15 , using the euclidean distance .",
    "our data structure has size @xmath4 , with preprocessing time @xmath5 , and with query time @xmath6 .",
    "it is perhaps surprising that we can match the bounds for the two - dimensional case in arbitrary fixed dimension . for _ nearest neighbor queries _",
    ", this does not seem to be possible : the bounds for nearest neighbor searching in higher dimension depend on the complexity of the voronoi diagram , which is @xmath16 in @xmath17-dimensional space .",
    "our approach is similar to some previous work on approximate voronoi diagrams  @xcite : the space is partitioned using a compressed quadtree , each cell of this quadtree containing a small set of candidate points .",
    "queries are answered by finding the cell containing the query point , and checking all the candidate points in this cell .",
    "interestingly , this approach allows to answer reverse nearest neighbor queries efficiently and _ exactly _ , while it only seems to give approximations for nearest neighbor searching .",
    "our model of computation is the real - ram model , with some additional operations that are common in quadtree algorithms , such as the floor function , the logarithm @xmath18 , and the bitwise xor . in particular , we need to be able to find in constant time the first binary digit at which two numbers differ .",
    "this allows , for instance , to find in constant time the smallest quadtree box that contains two given points .",
    "for more details on this issue , we refer to the lecture notes of har - peled  @xcite , and to previous work related to quadtrees  @xcite .",
    "in this section , we describe compressed quadtrees , a well known data structure in computational geometry . a more detailed presentation can be found in har - peled s lecture notes  @xcite , in the article on skip quadtrees by eppstein , goodrich , and sun  @xcite , or in the article by bern , eppstein and teng  @xcite .",
    "we first describe quadtrees , and then we describe their compressed version .",
    "we consider quadtrees in @xmath9 , where @xmath15 .",
    "we denote by @xmath19 the hypercube @xmath20^d$ ] ; the leaves of a quadtree will form a partition of @xmath19 .    a _ quadtree box _",
    "is either @xmath19 , or is obtained by partitioning a quadtree box @xmath21 into @xmath22 equal sized hypercubes ",
    "these hypercubes are called the _ quadrants _ of @xmath21 .",
    "a quadtree is a data structure that stores quadtree boxes in a hierarchical manner .",
    "each node @xmath23 of a quadtree stores a quadtree box @xmath24 , and pointers to its parent and its children .",
    "we call @xmath24 the _ cell _ of node @xmath23 . in this paper ,",
    "the cell of the root of a quadtree is always the box @xmath19 .",
    "each node @xmath23 either is a leaf , or has @xmath22 children that store the @xmath22 quadrants of  @xmath24 . with this definition ,",
    "the cells of the leaves of a quadtree form a partition of @xmath19 .",
    "let @xmath25 denote a set of @xmath26 quadtree boxes .",
    "we can construct the smallest quadtree whose nodes store all boxes in @xmath25 as follows .",
    "we start by constructing the root .",
    "if @xmath27 , then we are done . otherwise , we construct the @xmath22 children of the root .",
    "we consider the subset @xmath28 ( resp .",
    "@xmath29 ) of the boxes in @xmath25 contained in the first quadrant ( resp .",
    "second , third ,  ) .",
    "we construct recursively the quadtree , by taking the first ( resp .",
    "second , third ,  ) child as the root and using the set of boxes @xmath30 ( resp .",
    "@xmath31 ) .    the above construction results in a quadtree that stores all the boxes in @xmath25 .",
    "even though it is the smallest such quadtree , its size can be arbitrarily large when @xmath25 contains very small boxes . to remedy this",
    ", we use a _ compressed quadtree _ , which allows to bypass long chains of internal nodes .    in order to reduce the size of the data structure , we allow two different kinds of nodes in a compressed quadtree . an _ ordinary node _ stores a quadtree box as before . a _ compressed node _",
    "@xmath23 , however , stores the difference @xmath32 of two quadtree boxes @xmath21 and @xmath33 .",
    "we still call this difference the cell  @xmath24 .",
    "compressed nodes are always leaves of the compressed quadtree .    as in a quadtree",
    ", the cells of the children of a node @xmath23 form a partition of @xmath24 .",
    "but two cases are now possible : either these cells are the quadrants of @xmath24 , or @xmath23 has two children , one of them storing a quadtree box @xmath34 , and the other storing @xmath35 .",
    "the construction of a compressed quadtree that stores all the boxes in @xmath25 is analogous to the construction of the ordinary quadtree , with the following difference .",
    "assume we are processing an internal node @xmath23 .",
    "let @xmath21 denote the smallest quadtree box containing the boxes in @xmath25 that are strictly contained in @xmath24 .",
    "if @xmath36 , then we proceed exactly as we did for the ordinary quadtree : we construct @xmath22 children corresponding to the quadrants of @xmath24 .",
    "otherwise , @xmath23 has two children , one stores @xmath21 , and the other is a compressed node that stores @xmath35 .",
    "intuitively , this construction of a compressed node allows us to `` zoom in '' when all the boxes in @xmath24 are within a small area , and avoids a long chain of internal nodes .",
    "( see figure  [ fig : quadtree ] . )    ]    a direct implementation of the quadtree construction that we just described would lead to @xmath37 construction time and @xmath38 query time , since a quadtree may have linear depth . however , it is possible to achieve @xmath39 construction time and @xmath40 query time using different algorithms for constructing and querying a compressed quadtree .",
    "one such construction is presented in har - peled s lecture notes  @xcite .",
    "the idea is first to find a quadtree box @xmath41 that contains a constant fraction of the input boxes  @xmath25 , which can be done in linear time by choosing the center among the vertices of an irregular , constant - size grid .",
    "then one computes recursively a compressed quadtree for the set @xmath42 of the boxes in  @xmath25 that are contained in  @xmath41 , and for @xmath43 . finally , these two quadtrees are merged in linear time , essentially by hanging the quadtree of @xmath42 at a leaf of  @xmath44 .",
    "the quadtree can be queried in @xmath40 time by constructing a _ finger tree _ over the quadtree , which is an auxiliary data structure to allow faster search .",
    "( this approach is also presented in har peled s notes  @xcite . )",
    "we first find a cell of the quadtree such that the subtree rooted at the corresponding node contains a constant fraction of the boxes in  @xmath25 .",
    "this node is called a _",
    "separator _ and can be found in linear time by traversing the quadtree . this construction is repeated recursively on the forest obtained by removing this node .",
    "the construction allows to answer a query in @xmath40 time , as this tree has @xmath40 depth .",
    "so we have the following bounds for constructing and querying a quadtree :    [ lem : quadtree ] let @xmath25 be a set of @xmath26 quadtree boxes contained in @xmath19 .",
    "we can construct in time @xmath39 a compressed quadtree  @xmath45 , such that each box in @xmath25 is the cell of a node of  @xmath45 . this compressed quadtree  @xmath45 has size  @xmath38 .",
    "after @xmath39 preprocessing time , we can find for any query point @xmath46 the leaf of  @xmath45 whose cell contains  @xmath1 in time @xmath40 .",
    "note that a query point might lie on the boundaries of several cells . in this case",
    ", we break the tie arbitrarily , and we return only one cell containing  @xmath1 .",
    "in this section , we describe the construction of our data structure and how we answer reverse nearest neighbor queries .",
    "this data structure is a compressed quadtree , with a set of candidate points stored at each node . to answer a query",
    ", we locate the leaf of the compressed quadtree whose cell contains the query point , and we check all the candidate points in this leaf ; the reverse nearest - neighbors are among these points .",
    "we start with some notation .",
    "our input point set is denoted by @xmath47 , with @xmath48 .",
    "we still work in @xmath9 , where @xmath15 , and so @xmath49 .",
    "the _ empty ball _",
    "@xmath50 is the largest ball centered at @xmath51 that does not contain any other point of @xmath0 in its interior . in other words",
    ", the boundary of the empty ball centered at @xmath2 goes through the nearest point to @xmath2 in @xmath52 . in this paper , we only consider closed balls , so @xmath53 is a reverse nearest neighbor of a query point @xmath1 if and only if @xmath54 .",
    "let @xmath55 be a smallest axis - aligned @xmath17-dimensional hypercube containing the input point set @xmath0 . without loss of generality ,",
    "we assume that @xmath56^d$ ] ; then any empty ball is contained in @xmath57^d$ ] .",
    "when @xmath23 is an ordinary node , we denote by @xmath58 the side length of the quadtree box @xmath24 .    ]",
    "we first compute the set of all the largest empty balls for @xmath0",
    ". this can be done in @xmath14 time using vaidya s all - nearest neighbors algorithm  @xcite .",
    "we denote by @xmath59 the radius of @xmath50 . for each @xmath50",
    ", we compute the quadtree boxes with side length in @xmath60 that overlap @xmath50 .",
    "( see figure  [ f : notation ] . )",
    "our model of computation allows us to do this in @xmath61 time .",
    "there are at most @xmath22 such boxes ; we denote them by @xmath62 .",
    "using lemma  [ lem : quadtree ] , we construct in @xmath5 time a compressed quadtree @xmath45 of size @xmath4 such that each box @xmath63 appears in @xmath45 . for each node @xmath23 of @xmath45 , if the corresponding cell @xmath24 is @xmath63 , we store @xmath53 as a candidate point for @xmath23 . storing these candidate points",
    "can be done during the construction of the quadtree within the same time bound .",
    "notice that we may store several candidate points for a given node @xmath23 .",
    "these sets of candidate points are not sufficient for our purpose , so we will add some other points . for each ordinary ( non - compressed ) node @xmath23 , we store the points @xmath53 such that @xmath64 and @xmath50 overlaps @xmath24 ; this list of candidate points is denoted by @xmath65 . in order to analyze our algorithm , we need the following lemma , which is proved in section  [ sec : packing ] .    [",
    "lem : size ] for any ordinary node @xmath23 , the cardinality of the set of candidate points @xmath65 stored at  @xmath23 is  @xmath61 .",
    "we construct the lists @xmath66 by traversing @xmath45 recursively , starting from the root .",
    "assume that @xmath23 is the current ordinary node .",
    "the points @xmath53 such that @xmath67 for some @xmath68 have already been stored at @xmath23 . by our construction , they are the points @xmath53 in @xmath65 such that @xmath69 .",
    "so we need the other candidate points @xmath70 , such that @xmath71 .",
    "these points can be found in @xmath72 , where @xmath73 is the parent of @xmath23 .",
    "so we insert in @xmath65 all the points @xmath74 such that @xmath75 overlaps @xmath24 , which completes the construction of @xmath65 . by lemma  [",
    "lem : size ] , this can be done in @xmath61 time per node , and thus overall , computing the lists of candidate points for ordinary nodes takes @xmath4 time .",
    "if @xmath23 is a compressed node , and @xmath73 is its parent , we just set @xmath76 .",
    "we complete the construction of our data structure by handling all the compressed nodes .    given a query point @xmath1",
    ", we answer reverse nearest - neighbor queries as follows .",
    "if @xmath77 , then we return @xmath78 , because we saw earlier that all empty balls are in @xmath19 . otherwise , we find the leaf @xmath23 such that @xmath79 , which can be done in @xmath6 time by lemma  [ lem : quadtree ] . for each point @xmath80 , we check whether @xmath53 is a reverse nearest neighbor , that is , we check whether @xmath54 . if this is the case , we report  @xmath53 .",
    "we still need to argue that we answered the query correctly .",
    "assume that @xmath70 is a reverse nearest neighbor of @xmath1 , and the leaf @xmath23 containing @xmath1 is an ordinary node .",
    "as @xmath81 , we have @xmath82 for some @xmath68 , and since the side length of @xmath83 is less than @xmath84 , we have @xmath85 .",
    "since @xmath75 contains @xmath1 , it overlaps @xmath24 , so by definition of @xmath65 , we have @xmath86 , and thus @xmath70 was reported .",
    "if @xmath23 is a compressed node , then the same proof works if we replace @xmath23 by its parent @xmath73 , since @xmath76 .",
    "the discussion above proves the main result of this paper :    [ th : main ] let @xmath0 be a set of @xmath8 points in @xmath9 .",
    "we assume that @xmath15",
    ". then we can construct in time @xmath5 a data structure of size @xmath4 that answers reverse nearest - neighbor queries in @xmath6 time .",
    "the number of reverse nearest neighbors is  @xmath61 .",
    "the fact that the number of reverse nearest neighbors is @xmath61 was known before : in fixed dimension , the in - degree of the vertices of the nearest neighbor graph is bounded by a constant .",
    "in this section , we prove lemma  [ lem : size ] , which was needed to establish the time bounds in theorem  [ th : main ] . we start with a packing lemma .",
    "[ lem : packing ] let @xmath87 be a ball with radius @xmath88",
    ". then @xmath87 intersects at most @xmath89 empty balls with radius larger or equal to @xmath88 .",
    "when @xmath90 , we denote by @xmath91 the euclidean distance between @xmath92 and @xmath93 , and we denote by @xmath94 the line segment connecting them .",
    "we denote by @xmath95 the center of @xmath87 , and we denote by @xmath96 the ball with center @xmath95 and radius @xmath97 .",
    "we first bound the number of empty balls with radius @xmath98 whose center is contained in @xmath96 .",
    "let @xmath99 denote this set of balls , and let @xmath100 denote the set of their centers .",
    "any two points in @xmath100 are at distance at least @xmath88 from each other .",
    "hence , the balls with radius @xmath101 and with centers in @xmath100 are disjoint . as they are all contained in the ball @xmath102 with center @xmath95 and radius @xmath103 , the sum of their volumes is at most the volume of @xmath102 .",
    "hence , we have @xmath104 , and thus @xmath105 .",
    "we now consider the empty balls with radius @xmath98 that intersect @xmath87 , and whose centers are not in @xmath96 .",
    "we denote by @xmath106 the set of these balls , and we denote by @xmath107 the set of their centers .",
    "let @xmath108 ( resp .",
    "@xmath109 ) be a ball in @xmath106 with radius @xmath110 ( resp .",
    "@xmath111 ) and center @xmath112 ( resp .",
    "@xmath113 ) .",
    "( see figure  [ fig : packing ] . )",
    ".[fig : packing ] ]    without loss of generality , we assume that @xmath114 .    let @xmath115 be the point of @xmath116 such that @xmath117 .",
    "let @xmath118 , and let @xmath119 denote the ball with center @xmath115 and radius @xmath120 . as @xmath121 , we know that @xmath119 does not contain @xmath112 in its interior , and thus @xmath122 .",
    "as @xmath119 intersects @xmath87 , we have @xmath123 .",
    "it implies that @xmath124 . since @xmath125",
    ", it follows that @xmath126 .",
    "let @xmath127 ( resp .",
    "@xmath128 ) denote the projection of @xmath112 ( resp .",
    "@xmath113 ) onto the unit sphere @xmath129 centered at @xmath95 .",
    "in other words , @xmath130 .",
    "then it follows from the previous paragraph that @xmath131 .",
    "hence , the spheres with radius @xmath132 and centered at the projections onto @xmath129 of the points in @xmath107 are disjoint .",
    "as these spheres are contained in the sphere with radius @xmath133 centered at @xmath95 , we have @xmath134 , and thus @xmath135 .",
    "now we prove lemma  [ lem : size ] : for any ordinary node @xmath23 , the number of candidate points stored in @xmath65 is @xmath61 .",
    "we assume that @xmath80 . by definition",
    ", we must have @xmath64 , and @xmath50 overlaps @xmath24 . as @xmath24 can be covered by @xmath61 balls with radius @xmath136 , lemma  [ lem : packing ] implies that there can be only @xmath61 such candidate points .",
    "our approach does not only give a data structure to answer reverse nearest neighbor queries , it also yields a _",
    "reverse voronoi diagram _ : a spatial subdivision with linear complexity such that , within each cell , the set of reverse nearest neighbors is fixed . to achieve this ,",
    "we construct , within the cell of each leaf of our quadtree , the arrangement of the empty balls of the candidate points .",
    "as there is only a constant number of candidates per cell , each such arrangement has constant complexity , so overall we get a subdivision of linear size .",
    "the time bounds of our data structure can be improved in the word ram model of computation , when the coordinates of the input points are @xmath6-bits integers . in this case",
    ", chan showed that the all - nearest neighbors computation and the compressed quadtree construction can be done in linear time , so our data structure can be built in linear time as well .",
    "then using the shuffle - and - sort approach of chan  @xcite , combined with van emde boas trees , the compressed quadtree in our data structure can be queried in @xmath137 time .",
    "so overall , we can construct in linear time a data structure for reverse nearest neighbors with query time @xmath137 .",
    "the most natural extension to this problem would be to handle different metrics .",
    "our approach applies directly to any norm of @xmath9 , with @xmath15 , as its unit ball can be made _ fat _ after changing the coordinate system : we just need to apply an affine map such that the john ellipsoid of the unit ball of this norm becomes a euclidean ball .",
    "the time bounds and space usage remain the same",
    ".    another possible extension would be to make our algorithm dynamic .",
    "the main difficulty is that it seems that we would need to maintain the empty balls , which means maintaining all nearest neighbors .",
    "the result of maheshwari et al .",
    "@xcite , combined with the data structure of chan for dynamic nearest neighbors  @xcite , gives polylogarithmic update time and query time in @xmath138 . in higher dimension",
    ", these bounds would be considerably worse , if one uses the best known data structures for dynamic nearest neighbors  @xcite .    finally , it would be interesting to find the dependency of our time bounds on the dimension  @xmath17 . we did not deal with this issue , because one would first have to find this dependency for constructing compressed quadtrees , which is not the focus of this paper .",
    "y.  kumar , r.  janardan , and p.  gupta .",
    "efficient algorithms for reverse proximity query problems . in _",
    "16th acm sigspatial international symposium on advances in geographic information systems _",
    ", page  39 , 2008 .",
    "i.  stanoi , d.  agrawal , and a.  el abbadi .",
    "reverse nearest neighbor queries for dynamic databases . in _ proc .",
    "acm sigmod workshop on research issues in data mining and knowledge discovery _ ,",
    "pages 4453 , 2000 ."
  ],
  "abstract_text": [
    "<S> reverse nearest neighbor queries are defined as follows : given an input point set @xmath0 , and a query point @xmath1 , find all the points @xmath2 in @xmath0 whose nearest point in @xmath3 is @xmath1 . </S>",
    "<S> we give a data structure to answer reverse nearest neighbor queries in fixed - dimensional euclidean space . </S>",
    "<S> our data structure uses @xmath4 space , its preprocessing time is @xmath5 , and its query time is @xmath6 .    </S>",
    "<S> [ theorem]lemma [ theorem]proposition [ theorem]corollary    @ plus 1pt minus 4pt </S>"
  ]
}