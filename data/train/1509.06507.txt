{
  "article_text": [
    "a classical method for model - checking timed behavioral properties  such as those expressed using timed extensions of temporal logic  is to rely on the use of observers . in this approach",
    ", we check that a given property , , is valid for a system by checking the behavior of the system composed with an observer for the property .",
    "that is , for every property of interest , we need a pair @xmath0 of a system ( the observer ) and a formula .",
    "then property is valid if and only if the composition of with @xmath1 , denoted ( @xmath1 ) , satisfies @xmath2 .",
    "this approach is useful when the properties are complex , for instance when they include realtime constraints or involve arithmetic expressions on variables .",
    "another advantage is that we can often reduce the initial verification problem to a much simpler model - checking problem , for example when @xmath2 is a simple reachability property .    in this context ,",
    "a major problem is to prove the correctness of observers .",
    "essentially , this boils down to proving that every trace that contradicts a property can be detected .",
    "but this also involve proving that an observer will never block the execution of a valid trace ; we say that it is _ innocuous _ or non - intrusive .",
    "in other words , we need to assure that the `` measurements '' performed by the observer can be made without affecting the system .    in the present work ,",
    "we propose to use a model - checking tool chain in order to check the correctness of observers .",
    "we consider observers related to linear time properties obtained by extending the pattern specification language of dwyer et al .",
    "@xcite with hard , realtime constraints . in this paper , we take the example of the pattern `` @xmath3 '' , meaning that event must occur within @xmath4 units of time ( u.t . ) of the first occurrence of , if any , but not later than @xmath5 . our approach can be used to prove both the soundness and correctness of an observer when we fix the values of the timing constraints ( the values of @xmath4 and @xmath5 in this particular case ) .",
    "our method is not enough , by itself , to prove the correctness of a verification tool .",
    "indeed , to be totally trustworthy , this will require the use of more heavy - duty software verification methods , such as interactive theorem proving .",
    "nonetheless our method is complementary to these approaches . in particular",
    "it can be used to debug new or optimized definitions of an observer for a given property before engaging in a more complex formal proof of its correctness .",
    "our method is obtained by automating an approach often referred to as _ visual verification _ , in which the correctness of a system is performed by inspecting a graphical representation of its state space . instead of visual inspection",
    ", we check a set of branching time ( modal @xmath6-calculus ) properties on the discrete time state space of a system .",
    "these formulas are derived automatically from a definition of the pattern expressed as a first - order formula over timed traces .",
    "the gist of this method is that , in a discrete time setting , first - order formulas over timed traces can be expressed , interchangeably , as regular expressions , ltl formulas or modal @xmath6-calculus formulas .",
    "this approach has been implemented on the tool tina  @xcite , a model - checking toolbox for time petri net  @xcite ( tpn ) .",
    "this implementation takes advantage of several components of tina : state space exploration algorithms with a discrete time semantics ( using the option ` -f1 ` of tina ) ; model - checkers for ltl and for modal @xmath6-calculus , called _ selt _ and _ muse _ respectively ; a new notion of _ verification probes _",
    "recently added to fiacre  @xcite , one of the input specification language of tina .",
    "while model checkers are used to replace visual verification , probes are used to ensure innocuousness of the observers .",
    "the rest of the paper is organized as follows . in sect .",
    "[ sec2:fiacre ] , we give a brief definition of fiacre and the use of probes and observers in this language . in sect .",
    "[ sec3:timedtrace ] , we introduce the technical notations necessary to define the semantics of patterns and time traces and focus on an example of timed patterns . before concluding , we describe the graphical verification method and show how to use a model - checker to automatize the verification process .",
    "the theory and technologies underlying our verification method are not new : model - checking algorithms , semantics of realtime patterns , connection between path properties and modal logics ,  nonetheless , we propose a novel way to combine these techniques in order to check the implementation of observers and in order to replace traditional `` visual '' verification methods that are prone to human errors .",
    "our paper also makes some contributions at the technical level .",
    "in particular , this is the first paper that documents the notion of probe , that was only recently added to fiacre .",
    "we believe that our ( language - level ) notion of probes is interesting in its own right and could be adopted in other specification languages .",
    "we consider systems modeled using the specification language fiacre  @xcite .",
    "( both the system and the observers are expressed in the same language . )",
    "fiacre is a high - level , formal specification language designed to represent both the behavioral and timing aspects of reactive systems .",
    "fiacre programs are stratified in two main notions : _ processes _ , which are well - suited for modeling structured activities , and _ components _ , which describes a system as a composition of processes .",
    "components can be hierarchically composed .",
    "we give in fig .",
    "[ fig / fiacre - process ] a simple example of fiacre specification for a computer mouse button capable of emitting a double - click event . the behavior , in this case , is to emit the event if there are more than two events in strictly less than one unit of time ( u.t . ) .    [",
    "cols=\"^,^ \" , ]     we can already debug the pattern @xmath7 by visually inspecting the state graph .    for _ soundness _ , we need to check that , when the pattern is not satisfied  for traces @xmath8 that do not satisfy formula @xmath9then the observer will detect a problem ( observer eventually reaches a state in the set _ errors _ ) .    for _ innocuousness _",
    "we need to check that , from any state , it is always possible to reach a state where event ( respectively and ) can fire .",
    "indeed , this means that the observer can not selectively remove the observation of a particular sequence of external transitions or the passing of time .",
    "this graphical verification method has some drawbacks .",
    "as such , it relies on a discrete time model and only works for fixed values of the timing parameters ( we have to fix the value of @xmath4 and @xmath5 ) . nonetheless , it is usually enough to catch many errors in the observer before we try to prove the observer correct more formally .",
    "a problem with the previous approach is that it essentially relies on an informal inspection ( and on human interaction ) .",
    "we show how to solve this problem by replacing the visual inspection of the state graph by the verification of modal @xmath6-calculus formulas .",
    "( the tina toolset includes a model - checker for the @xmath6-calculus called _",
    "muse_. ) the general idea rests on the fact that we can interpret the state graph as a finite state automaton and ( some ) sets of traces as regular languages .",
    "this analogy is generally quite useful when dealing with model - checking problems .",
    "we start by defining some useful notations .",
    "label expressions are boolean expressions denoting a set of ( transition ) labels .",
    "for instance , @xmath10 denotes the external transitions , while the expression ` - ( ) ` is only matched by the silent transition label .",
    "we will also use the expression @xmath11 to denote the conjunction of all possible labels , e.g. @xmath12 . the model checker _",
    "muse _ allows the definition of label expressions using the same syntax .      in the following ,",
    "we consider regular expressions build from label expressions .",
    "for example , the regular expression @xmath13 denotes traces of duration 1 with no events occurring at time @xmath14 .",
    "@xmath15 we remark that it is possible to define the set of ( discrete ) traces where the fott formula pres holds using the union of two regular languages : ( 1 ) the traces where never occurs , @xmath16 ; and ( 2 ) the traces where there is an four units of time after the first . in this particular case",
    ", @xmath17 is a regular expression corresponding to the property @xmath18 ) @xmath19 by construction , the regular language associated to @xmath20 is exactly the set of finite traces matching ( the discrete semantics ) of pres . in the most general case ,",
    "a regular expressions can always be automatically generated from an existential fott formula when the time constraints of delay expressions are fixed ( the intervals @xmath21 in the occurrences of ( @xmath22 ) ) .",
    "the next step is to check that the observer agrees with every trace conforming to @xmath17 . for this",
    "we simply need to check that , starting from the initial state of ( ) , it is not possible to reach a state in the set _ errors _ by following a sequence of transitions labeled by a word in @xmath17 .    this is a simple instance of a language inclusion problem between finite state automata .",
    "more precisely , if @xmath23 is the set of states visited when accepting the traces in @xmath20 , we need to check that @xmath24 is included in the complement of the set _ present _ ( denoted @xmath25 ) . in our example of fig .",
    "[ fig : example ] , we have that @xmath26 , and therefore @xmath27 .",
    "this automata - based approach has still some drawbacks .",
    "this is what will motivate our use of a branching time logic in the next section . in particular , this method is not enough to check the soundness or the innocuousness of the observer . for innocuousness",
    ", we need to check that every event may always eventually happen . concerning soundness , we need to prove that @xmath28 ; which is false in our case .",
    "the problem lies in the treatment of time divergence ( and of fairness ) , as can be seen from one of the counter - example produced when we use our ltl model - checker to check the soundness property , namely : ` b.start.z.t.t.t.t.watch.t.t.\\cdots ` ( ending with a cycle of ` t ` transitions ) .",
    "this is an example where the error transition is continuously enabled but never fired .",
    "we show how to interpret regular expressions over traces using a modal logic . in this case",
    ", the target logic is a modal @xmath6-calculus with operators for forward and backward traversal of a state graph .",
    "( many temporal logics can be encoded in the @xmath6-calculus , including ctl@xmath29 ) . in this context , the semantics of a formula @xmath30 over a kripke structure ( a state graph ) is the set of states where @xmath30 holds .",
    "@xmath31    the basic modalities in the logic are ` < a>\\psi ` and ` \\psi < a > ` , where @xmath32 is a label expression .",
    "a state @xmath33 is in @xmath34 if and only if there is a ( successor ) state @xmath35 in @xmath30 and a transition from @xmath33 to @xmath35 with a label in a. symmetrically , @xmath33 is in @xmath36 if and only if there is a ( predecessor ) state @xmath35 in @xmath30 and a transition from @xmath35 to @xmath33 with a label in a. in the following , we will also use two constants , ` t ` , the true formula ( matching all the states ) , and `  0 ` , that denotes the initial state of the model ; and the least fixpoint operator ` min x | \\psi(x ) ` .",
    "for example , the formula ` < > t ` matches all the states that are the source of an -transition , likewise ` reach _ `",
    "@xmath37  ` min x|(<>t \\vee < z > x ) ` matches all the states that can lead to an -transition using only internal transitions . as a consequence , we can test innocuousness by checking that the formula ` ( reach_reach_reach _ ) ` is true for all states .",
    "the soundness proof rely on an encoding from regular path expressions into modal formulas .",
    "we define two encodings : @xmath38 that matches the states encountered while firing a trace matching a regular expression @xmath39 ; and @xmath40 that matches the state reached ( at the end ) of a finite trace in @xmath39 .",
    "these encodings rely on two derived operators .",
    "( again , we assume here that @xmath32 is a label expression . )",
    "@xmath41{l }    \\hfill { \\psi \\,{\\,\\ensuremath{\\text{\\texttt{o}}}\\,}\\ , a   \\ { \\ensuremath{\\overset{\\text{\\tiny def}}{=}}}\\   \\psi{\\texttt{<a > } } }    \\hspace*{4em }    { \\psi \\,{\\texttt{*}}\\ , a \\ { \\ensuremath{\\overset{\\text{\\tiny def}}{=}}}\\ { \\texttt{min x | $ \\psi$\\,{\\,\\ensuremath{\\vee}\\,}\\,x<$a$ > } } }    \\hspace*{2em}\\\\[1em ]       \\begin{array}[c]{lcl@{\\quad}|@{\\quad}lcl }         { ( \\kern-.5mm({r \\cdot a})\\kern-.5mm)_{e } } & { \\ensuremath{\\overset{\\text{\\tiny def}}{= } } } & { ( \\kern-.5mm({r})\\kern-.5mm)_{e } } \\,{\\texttt{o}}\\ , a &      { ( \\kern-.5mm({r \\cdot a})\\kern-.5 mm ) _ { { } } } & { \\ensuremath{\\overset{\\text{\\tiny def}}{= } } } & { ( \\kern-.5mm({r})\\kern-.5 mm ) _ { { } } } \\vee { ( \\kern-.5mm({r        \\cdot a})\\kern-.5mm)_{e}}\\\\        { ( \\kern-.5mm({r \\cdot a{\\ensuremath{\\mathclose{\\overset{*}{\\ } } } } } ) \\kern-.5mm)_{e } } & \\ { \\ensuremath{\\overset{\\text{\\tiny def}}{=}}}\\ & { ( \\kern-.5mm({r})\\kern-.5mm)_{e } } \\,{\\texttt{*}}\\ , a &      { ( \\kern-.5mm({r \\cdot a{\\ensuremath{\\mathclose{\\overset{*}{\\ } } } } } ) \\kern-.5 mm ) _ { { } } } & \\ { \\ensuremath{\\overset{\\text{\\tiny def}}{=}}}\\ & { ( \\kern-.5mm({r})\\kern-.5 mm ) _ { { } } } \\vee { ( \\kern-.5mm({r \\cdot a{\\ensuremath{\\mathclose{\\overset{*}{\\ } } } } } ) \\kern-.5mm)_{e}}\\\\                                { ( \\kern-.5mm({r \\cdot { \\ensuremath{\\mathit{tick}}}})\\kern-.5mm)_{e } } & \\ { \\ensuremath{\\overset{\\text{\\tiny def}}{=}}}\\ &      { \\texttt { ( } } { ( \\kern-.5mm({r})\\kern-.5mm)_{e } } { \\texttt{\\,o\\,t)\\,*\\,(-t ) } } &       { ( \\kern-.5mm({r \\cdot { \\ensuremath{\\mathit{tick}}}})\\kern-.5 mm ) _ { { } } } & \\ { \\ensuremath{\\overset{\\text{\\tiny def}}{=}}}\\ &      { ( \\kern-.5mm({r})\\kern-.5 mm ) _ { { } } } \\vee { ( \\kern-.5mm({r \\cdot { \\ensuremath{\\mathit{tick}}}})\\kern-.5mm)_{e}}\\\\        { ( \\kern-.5mm({r_1 \\vee r_2})\\kern-.5mm)_{e } } & \\ { \\ensuremath{\\overset{\\text{\\tiny def}}{=}}}\\ &      { ( \\kern-.5mm({r_1})\\kern-.5mm)_{e } } \\vee { ( \\kern-.5mm({r_2})\\kern-.5mm)_{e } }   &       { ( \\kern-.5mm({r_1 \\vee r_2})\\kern-.5 mm ) _ { { } } } & \\ { \\ensuremath{\\overset{\\text{\\tiny def}}{=}}}\\ &      { ( \\kern-.5mm({r_1})\\kern-.5 mm ) _ { { } } } \\vee { ( \\kern-.5mm({r_2})\\kern-.5mm)_{{}}}\\\\        { ( \\kern-.5mm({\\epsilon})\\kern-.5mm)_{e } } & \\ { \\ensuremath{\\overset{\\text{\\tiny def}}{=}}}\\ &      { \\texttt{`0 } }      &       { ( \\kern-.5mm({\\epsilon})\\kern-.5 mm ) _ { { } } } & \\ { \\ensuremath{\\overset{\\text{\\tiny def}}{=}}}\\ &      { \\texttt{`0 } }    \\end{array}\\\\ \\end{array}\\ ] ]    given a kripke structure @xmath42 , the states matching the formula @xmath40 ( respectively @xmath38 ) in @xmath42 are the states reachable from the initial state after firing ( resp . all the states reachable while firing ) a sequence of transitions matching @xmath39 .    by induction on the definition of @xmath39 .",
    "for example , if we assume that @xmath30 correspond to the regular expression @xmath39 , then @xmath43 matches all the states reachable from states where @xmath30 is true using ( finite ) sequences of transition with label in a ; i.e. formula @xmath30 ` * ` @xmath32 corresponds to @xmath44 .",
    "likewise , we use the interpretation of the empty expression , @xmath45 , to prefix every formula with the constant `  0 ` ( that will only match the initial state ) .",
    "this is necessary since @xmath6-calculus formulas are evaluated on all states whereas regular path expressions are evaluated from the initial state .",
    "for example , we give the formula for @xmath46 below , where @xmath47 stands for the expression @xmath48 : @xmath49 if @xmath50 is a modal @xmath6-calculus formula that matches the error condition of the observer , then we can check the correctness and soundness of the observer by proving that the equivalence ( eq ) , below , is a tautology ( that it is true on every states of ( ) ) .",
    "@xmath51 again , we can interpret the `` error condition '' using the @xmath6-calculus .",
    "the definition of errors is a little bit more involved than in the previous case .",
    "we say that a state is in error if the transition is enabled ( the formula ` < error > t ` is true ) or if the state can only be reached by firing the transition ( which corresponds to the formula ` ( t < error > t)\\wedge(0(- error ) ) ` .",
    "hence @xmath50 is the disjunction of these two properties : @xmath52 the formula ( eq ) can be checked almost immediately ( less than on a standard computer ) for models of a few thousands states using _ muse_.",
    "listing  [ muse ] gives a _ muse _ script file that can be used to test this equivalence relation .",
    "few works consider the verification of model - checking tools . indeed , most of the existing approaches concentrate on the verification of the model - checking algorithms , rather than on the verification of the tools themselves .",
    "for example , smaus et al .",
    "@xcite provide a formal proof of an algorithm for generating bchi automata from a ltl formula using the isabelle interactive theorem prover .",
    "this algorithm is at the heart of many ltl model - checker based on an automata - theoretic approach .",
    "the problem of verifying verification tools also appears in conjunction with certification issues . in particular , many certification norms , such as the do-178b",
    ", requires that any tool used for the development of a critical equipment be qualified at the same level of criticality than the equipment .",
    "( of course , certification does not necessarily mean formal proof ! ) in this context , we can cite the work done on the certification of the scade compiler  @xcite , a tool - suite based on the synchronous language lustre that integrates a model - checking engine . nonetheless , only the code - generation part of the compiler is certified and not the verification part .    concerning observer - based model - checking , most of the works rely on an automatic way to synthesize observers from a formal definition of the properties .",
    "for instance , aceto et al .  @xcite propose a method to verify properties based on the use of test automata . in this framework ,",
    "verification is limited to safety and bounded liveness properties since the authors focus on properties that can be reduced to reachability checking . in the context of time",
    "petri net , toussaint et al .",
    "@xcite also propose a verification technique based on `` timed observers '' , but they only consider four specific kinds of time constraints .",
    "none of these works consider the complexity or the correctness of the verification problem .",
    "another related work is  @xcite , where the authors define observers based on timed automata for each pattern .",
    "our approach is quite orthogonal to the `` synthesis approach '' .",
    "indeed we seek , for each property , to come up with the best possible observer in practice . to this end , using our toolchain , we compare the complexity of different implementations on a fixed set of representative examples and for a specific set of properties and kept the best candidates .",
    "the need to check multiple implementations for the same patterns has motivated the need to develop a lightweight verification method for checking their correctness .    compared to these works ,",
    "we make several contributions . we define a complete verification framework for checking observers with hard realtime constraints .",
    "this framework has been tested on a set of observers derived from high - level timed specification patterns .",
    "this work is also our first public application of the probe technology , that was added to fiacre only recently . to the best of our knowledge , the notion of _ probes _ is totally new in the context of formal specification language .",
    "paun and chechik propose a somewhat similar mechanism in  @xcite  in an untimed setting  where they define new categories of events .",
    "however our approach is more general , as we define probes for a richer set of events , such as variables changing state .",
    "we believe that this ( language - level ) notion of probes is interesting in its own right and could be adopted by other formal specification languages .",
    "finally , we propose a formal approach that can be used to gain confidence on the implementation of our model - checking tools and that replaces traditional `` visual verification methods '' that are prone to human errors .",
    "this result also prove the usefulness of having access to a complete toolbox that provides different kind of tools : editors , model - checkers for different kind of logics , ",
    "b.  berthomieu , j .-",
    "bodeveix , and m.  fillali and g.  hubert and f.  lang and f.  peres and r.  saad and s.  jan and f.  vernadat .",
    "the syntax and semantics of fiacre  version 3.0 .",
    "http://www.laas.fr/fiacre/ , 2012 .                a janowska , w penczek , a. prola , a zbrzezny . towards discrete - time verification of time petri nets with dense - time semantics",
    ". in _ proc . of the int",
    ". workshop on concurrency , specification and programming _ , 2011 ."
  ],
  "abstract_text": [
    "<S> a classical method for model - checking timed properties  such as those expressed using timed extensions of temporal logic  is to rely on the use of observers . in this context , </S>",
    "<S> a major problem is to prove the correctness of observers . </S>",
    "<S> essentially , this boils down to proving that : ( 1 ) every trace that contradicts a property can be detected by the observer ; but also that ( 2 ) the observer is innocuous , meaning that it can not interfere with the system under observation . in this paper , we describe a method for automatically testing the correctness of realtime observers . </S>",
    "<S> this method is obtained by automating an approach often referred to as _ visual verification _ , in which the correctness of a system is performed by inspecting a graphical representation of its state space . </S>",
    "<S> our approach has been implemented on the tool tina , a model - checking toolbox for time petri net . </S>"
  ]
}