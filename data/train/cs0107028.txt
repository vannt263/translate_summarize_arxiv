{
  "article_text": [
    "logic is most commonly used in declarative programming and knowledge representation as follows . to solve a problem",
    "we represent its constraints and the relevant background knowledge as a theory in the language of some logic .",
    "we formulate the goal ( the statement of the problem ) as a formula of the logic .",
    "we then use proof techniques to decide whether this formula follows from the theory .",
    "a proof of the formula , variable substitutions or both determine a solution .",
    "recently , an alternative way in which logic can be used in computational knowledge representation has emerged from studies of nonstandard variants of logic programming such as logic programming with negation and disjunctive logic programming @xcite .",
    "this alternative approach is rooted in semantic notions and is based on methods to compute models .",
    "to represent a problem , we design a finite theory so that its _ models _ ( and not proofs or variable substitutions ) determine problem solutions ( answers ) . to solve the problem , we compute models of the corresponding theory .",
    "this model - based approach is now often referred to as _ answer - set programming _ ( or asp ) .",
    "logic programming with stable model semantics @xcite ( _ stable logic programming _ or _",
    "slp _ , in short ) is an example of an asp formalism @xcite . in slp , we represent problem constraints by a fixed program ( independent of problem instances ) .",
    "we represent a specific instance of the problem ( input data ) by a collection of ground atoms . to solve the problem , we find stable models of the program formed jointly by the two components . to this end , we first _ ground _ it ( compute its equivalent propositional representation ) and , then , compute stable models of this grounded propositional program .",
    "thanks to the emergence of fast systems to compute stable models of propositional logic programs , such as _ smodels _",
    "@xcite , slp is quickly becoming a viable declarative programming environment for computational knowledge representation .",
    "disjunctive logic programming with the semantics of answer sets @xcite is another logic programming formalism that fits well into the answer - set programming paradigm .",
    "an effective solver for computing answer sets of disjunctive programs , _ dlv _ , is available @xcite and its performance is comparable with that of _",
    "smodels_.    our goal in this paper is to propose answer - set programming formalisms based on propositional logic and its extensions .",
    "our approach is motivated by recent improvements in the performance of satisfiability checkers .",
    "researchers developed several new and fast implementations of the basic davis - putnam method such as _ satz _ @xcite and _ relsat _ @xcite .",
    "a renewed interest in local - search techniques resulted in highly effective ( albeit incomplete ) satisfiability checkers such as _ walksat _",
    "@xcite , capable of handling large cnf theories , consisting of millions of clauses .",
    "improvements in the performance resulted in an expanding range of applications of satisfiability checkers , with planning being one of the most spectacular examples @xcite .",
    "the way in which propositional satisfiability solvers are used in planning @xcite clearly fits the asp paradigm .",
    "planning problems are encoded as propositional theories so that models correspond to plans . in our paper , we extend ideas proposed in @xcite in the domain of planning and show that propositional satisfiability can be used as the foundation of a general purpose asp system . to this end , we propose a logic to serve as a modeling language . this logic is a modification of the logic of propositional schemata @xcite ; we explicitly separate theories into data and program , and use a version of closed world assumption ( cwa ) to define the semantics .",
    "this logic is nonmonotonic .",
    "we call it the _ logic of propositional schemata with cwa _ ( or , @xmath1 ) .",
    "the logic @xmath1 offers only basic logical connectives to help model problem constraints .",
    "we extend logic @xmath1 to support direct representation of constraints involving cardinalities .",
    "examples of such constraints are : `` at least @xmath2 elements from the list must be in the model '' or `` exactly @xmath2 elements from the list must be in the model '' .",
    "they appear commonly in statements of constraint satisfaction problems .",
    "we refer to this new logic as _ extended logic of propositional schemata with closed world assumption _ and denote it by @xmath0 .",
    "in the paper we characterize the class of problems that can be solved by _",
    "finite _ @xmath0 theories . in other words , we determine the expressive power of the logic @xmath0 . specifically , we show that it is equal to the expressive power of function - free logic programming with the stable - model semantics .    for processing , theories in @xmath0",
    "could be compiled into propositional theories and `` off - the - shelf '' satisfiability checkers could be used for processing",
    ". however , propositional representations of constraints involving cardinalities are usually very large and the sizes of the compiled theories limit the effectiveness of satisfiability checkers , even the most advanced ones , as processing engines .",
    "thus , we argue against the compilation of the cardinality constraints . instead , we propose an alternative approach .",
    "we design a `` target '' propositional logic for the logic @xmath0 ( propositional logic @xmath0 ) . in this logic ,",
    "cardinality constraints have explicit representations and , therefore , do not need to be compiled any further .",
    "we develop a satisfiability checker for the propositional logic @xmath0 and use it as the processing back - end for the logic @xmath0 .",
    "our solver is designed along the same lines as most satisfiability solvers implementing the davis - putnam algorithm but it takes a direct advantage of the cardinality constraints explicitly present in the language .",
    "experimental results on the performance of the overall system are highly encouraging .",
    "we obtain concise encodings of constraint problems and the performance of our solver is competitive with the performance of _ smodels _ and of state - of - the - art complete satisfiability checkers .",
    "our work demonstrates that building propositional solvers capable of processing of high - level constraints is a promising research direction for the area of propositional satisfiability .",
    "our paper is organized as follows . in the next section",
    "we introduce the logic @xmath1  a fragment of the logic @xmath0 without cardinality constraints .",
    "we determine the expressive power of the logic @xmath1 in section [ eps ] .",
    "we discuss the full logic @xmath0 in section [ eplc ] . in the subsequent section we discuss implementation details and experimental results .",
    "the last section of the paper contains conclusions and comments on the future work .",
    "our approach is based on the logic of _ propositional schemata_. the syntax of this logic is that of first - order logic without function symbols .",
    "the semantics is that of _ herbrand interpretations _ and _ models _ , which we identify with subsets of the _ herbrand base_. in the paper we consider only those theories in which at least one constant symbol appears . among all formulas in the language , of main interest to us are _ clauses _ , that is , expressions of the form @xmath3 where each @xmath4 is an atom and each @xmath5 is an atom or an expression of the form @xmath6 , where @xmath7 is an atom and @xmath8 is a tuple of ( not necessarily all ) variables appearing in @xmath7 . each of @xmath9 and @xmath10 ( or both ) may equal 0 . if @xmath11 , we replace the conjunct in the antecedent of the clause with a special symbol @xmath12 ( _ truth _ ) .",
    "if @xmath13 , we replace the empty disjunct in the consequent of the clause with a special symbol @xmath14 ( _ contradiction _ ) .",
    "we assume that each clause is universally quantified and drop the universal quantifiers from the notation .",
    "we further simplify the notation by replacing each expression @xmath6 in the antecedent by @xmath15 , where in @xmath16 we write a special symbol ` @xmath17 ' for each variable from @xmath8 in @xmath18 .",
    "let @xmath19 be a _ finite _ theory consisting of clauses .",
    "for a formula @xmath20 appearing in the consequent of a clause in @xmath19 , we define @xmath21 to be the disjunction @xmath22 , where @xmath23 , @xmath24 , range over all term tuples that can be obtained from @xmath18 by replacing variables in @xmath8 with constants appearing in @xmath19 .",
    "since @xmath19 is finite , the disjunction is well defined ( it has only finitely many disjuncts ) .    for a clause @xmath25 of the form ( [ cl-1 ] )",
    ", we define a clause @xmath26 by @xmath27 a _ ground instance _ of @xmath28 is any formula obtained from @xmath26 by replacing every variable in @xmath26 by a constant appearing in @xmath19 ( different occurrences of the same variable must be replaced by the same constant ) .",
    "we define the _ grounding _ of @xmath19 , @xmath29 as the collection of all ground instances of clauses in @xmath19 , except for tautologies ; they are not included in @xmath29 .",
    "we have the following well - known result .",
    "let @xmath19 be a finite clausal theory .",
    "then a set of ground atoms @xmath30 is a herbrand model of @xmath19 if and only if @xmath30 is a ( propositional ) model of @xmath29 .",
    "the language may contain several _ predefined _ predicates and function symbols such as the equality operator and arithmetic comparators and operations .",
    "we assign to these symbols their standard interpretation . however , we emphasize that the domains are restricted only to those constants that appear in a theory .",
    "we evaluate all expressions involving predefined function symbols and all atoms involving predefined relation symbols in the grounding process .",
    "if any argument of a predefined relation is not of the appropriate type , we interpret the corresponding atom as false .",
    "if a function yields as a result a constant that does not appear in the theory or if one of its arguments is not of the required type , we also interpret the corresponding atom as false .",
    "we then eliminate tautologies and simplify the remaining clauses by removing true `` predefined '' atoms from the antecedents and false `` predefined '' atoms from the consequents .",
    "let us consider an example .",
    "let @xmath19 be a theory consisting of the following two clauses :    _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ @xmath31 + @xmath32 .",
    "_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _    there are three constants , @xmath33 , @xmath34 and @xmath35 , and two predicate symbols , @xmath36 and @xmath37 , in the language",
    ". symbols @xmath38 and @xmath8 denote variables .",
    "the clause @xmath39 can also be written ( using the simplified notation ) as    _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ @xmath40 .",
    "_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _    to compute @xmath29 we need to compute all ground instances of @xmath39 ( @xmath41 is itself its only ground instance ) .",
    "first , we compute the formula @xmath42 : @xmath43 to obtain all ground instances of @xmath39 ( or @xmath42 ) , we replace @xmath38 with @xmath33 , @xmath34 and @xmath35 .",
    "the first substitution results in a tautology ( due to occurrence of ` @xmath44 ' in the consequent of the clause ) .",
    "two other substitutions yield the following two ground instances of @xmath28 ( we drop atoms ` @xmath45 ' and ` @xmath46 ' from the consequents ; they are false by the standard interpretation of equality ) :    _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ @xmath47 + @xmath48 .",
    "_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _    these two clauses together with @xmath41 form @xmath29 .",
    "the sets of ground atoms @xmath49 and @xmath50 are two examples of models of @xmath19 ( or @xmath29 ) .    in order for the logic of propositional schemata to be useful as a programming tool ,",
    "we modify it to separate input data from the program encoding the problem to be solved .",
    "we distinguish in the set of predicates @xmath51 of the language a subset , @xmath52 .",
    "we call its elements _ data _ predicates .",
    "we assume that predefined predicates are _ not _ data predicates .",
    "all predicates other than data predicates and predefined predicates are called _ program _ predicates .",
    "theory _ of our logic is a pair @xmath53 , where @xmath54 is a _",
    "finite _ collection of ground atoms whose predicate symbols are data predicates ( _ data _ ) , and @xmath55 is a _ finite _ collection of clauses ( a _ program _ ) .    to define the semantics for the logic , we use grounding and a form of cwa .",
    "we say that a set of ground atoms ( built of data and program predicates ) is a _ model _ of a theory @xmath53 if    m :  0.03 in    @xmath30 is a model of @xmath56 ( or , equivalently , @xmath30 is an herbrand model of @xmath57 ) , and    for every ground atom @xmath58 such that @xmath59 ( @xmath36 is a data predicate ) , @xmath60 if and only if @xmath61 .",
    "we call the logic described above the _ logic of propositional schemata with cwa _ and denote it by @xmath1 . due to ( m2 ) , not every model of @xmath62 is a model of @xmath53 .",
    "consequently , one can show that our logic is nonmonotonic .",
    "this difference between the logic of propositional schemata and the logic @xmath1 , while seemingly small , has significant consequences for the expressive power of the logic and its applicability as a programming tool .",
    "before addressing these two issues , let us consider an example .",
    "let @xmath63 and @xmath64 be two disjoint and finite sets .",
    "we define @xmath65 .",
    "we define @xmath55 to consist of two clauses : + ex1 : @xmath66  ex2 : @xmath67 .",
    "the constants are elements of @xmath68 ; @xmath38 is a variable .",
    "the predicates are @xmath69 , @xmath70 , @xmath71 and @xmath72 .",
    "the first two are data predicates .    by ( m2 ) , each model of a @xmath1 theory @xmath53 contains @xmath54 .",
    "however , it does not contain any ground atom @xmath73 , where @xmath74 , nor any ground atom @xmath75 , where @xmath76 .",
    "each ground instance of the clause ( ex1 ) is of the form @xmath77 , where @xmath35 is a constant ( @xmath78 ) . since @xmath79 if and only if @xmath80 , it follows that if @xmath81 , then @xmath80 .",
    "similarly , we obtain that if @xmath82 , then @xmath80 .",
    "thus , @xmath30 is a model of @xmath53 if and only if @xmath83 , for some @xmath84 and @xmath85 .",
    "let us choose an element from @xmath63 , say @xmath86 , and an element from @xmath64 , say @xmath87 .",
    "let us then add to @xmath55 the clause    ex3 : @xmath88    we denote the new program by @xmath89 .",
    "the @xmath1 theory @xmath53 has no models even though @xmath90 is propositionally consistent .",
    "the reason is that all propositional models satisfying @xmath62 contain @xmath91 .",
    "thus , none of these models satisfies condition ( m2 ) .",
    "this example illustrates that our semantics is different from circumscription as circumscription preserves consistency .",
    "circumscription applied to @xmath69 would result in models in which the extension of @xmath69 in @xmath54 would be minimally extended by one more constant @xmath87 .",
    "our ( strong ) minimization principle does not allow for any additions to the extension of data predicates .",
    "intuitively , it is exactly as it should be . *",
    "data predicates are meant to represent input data .",
    "the program should not be able to extend it .",
    "*    logic @xmath1 is a tool to model problems . to illustrate this use of the logic ,",
    "we show how to encode the _ vertex - cover _ problem for graphs .",
    "let @xmath92 be a graph .",
    "a set @xmath93 is a _ vertex cover _ of @xmath94 if for every edge @xmath95 , @xmath96 or @xmath97 ( or both ) are in @xmath98 .",
    "the vertex - cover problem is defined as follows : given a graph @xmath92 and an integer @xmath2 , decide whether @xmath94 has a vertex cover with no more than @xmath2 vertices .    for the vertex - cover problem the input data",
    "is described by the following set of ground atoms :    @xmath99 .",
    "this set specifies the set of vertices and the set of edges of an input graph .",
    "it provides the limit on the size of a vertex cover sought .",
    "lastly , it uses a predicate @xmath100 to specify a range of _ integers _ that will be used to label vertices .",
    "the problem itself is described by the program @xmath101 :    vc :  0.03 in    @xmath102    @xmath103    @xmath104    @xmath105    @xmath106    @xmath107    ( vc1 ) and ( vc2 ) ensure that @xmath108 is false if @xmath109 is not an integer from the set @xmath110 or if @xmath96 is not a vertex .",
    "( vc3)-(vc5 ) together enforce that the atoms @xmath108 that are true in a model of the @xmath1 theory @xmath111 define a permutation of the vertices in @xmath112 .",
    "finally , ( vc6 ) ensures that each edge has at least one vertex assigned by @xmath113 to positions @xmath114 ( in other words , that vertices labeled @xmath115 form a vertex cover ) .",
    "the correctness of this encoding is formally established in the following result .",
    "[ p - vtx ] let @xmath92 be an undirected graph and let @xmath2 be a positive integer .",
    "a set of vertices @xmath116 is a vertex cover of @xmath94 if and only if @xmath117 is a model of the theory @xmath111 .",
    "for another example , we will consider the @xmath10-queens problem , that is , the problem of placing @xmath10 queens on a @xmath118 chess board so that no queen attacks another .    in this case",
    ", the representation of input data describes the set of row and column indices :    @xmath119 .",
    "the problem itself is described by the program @xmath120 .",
    "the predicate @xmath37 describes a distribution of queens on the board : @xmath121 is true precisely when there is a queen in the position @xmath122 .",
    "nq :  0.03 in    @xmath123    @xmath124    @xmath125    @xmath126    @xmath127    @xmath128    the first two clauses ensure that if @xmath129 is true in a model of @xmath130 then @xmath131 and @xmath35 are integers from the set @xmath132 .",
    "the following two clauses enforce the constraint that no two queens are placed in the same row or the same column .",
    "finally , the last two clauses guarantee that no two queens are placed on the same diagonal . as in the case of the vertex cover problem ,",
    "also in this case we can formally show the correctness of this encoding .",
    "these examples demonstrate that @xmath1 programs can serve as representations of computational problems .",
    "two key questions arise : ( 1 ) what is the expressive power of the logic @xmath1 , and ( 2 ) how to use the logic @xmath1 as a practical computational tool .",
    "we address both questions in the remainder of the paper .",
    "a _ search _ problem , @xmath133 , is given by a set of finite _ instances _ , @xmath134 , such that for each instance @xmath135 , there is a finite set @xmath136 of all _ solutions _ to @xmath133 for the instance @xmath137 @xcite .",
    "the graph - coloring , vertex - cover and @xmath10-queens problems considered in the previous section are search problems . more generally , all constraint satisfaction problems including basic ai problems such as planning , scheduling and product configuration can be cast as search problems .",
    "we say that a @xmath1 program @xmath55 _ solves _ a search problem @xmath133 if there exist :    .0.03 in 0.1in0.1in0.2 in    a mapping @xmath138 that can be computed in polynomial time and that encodes instances to @xmath133 as sets of ground atoms built of data predicates    a partial mapping @xmath139 , computable in polynomial time , that assigns to ( some ) sets of ground atoms solutions to @xmath133 ( elements of @xmath140 )    such that for every instance @xmath141 , @xmath142 if and only if there exists a model @xmath30 of the @xmath1 theory @xmath143 such that @xmath30 is in the domain of the mapping @xmath139 and @xmath144 .",
    "a search problem @xmath133 is in the class _ np - search _ if there is a nondeterministic turing machine @xmath145 such that ( 1 ) @xmath145 runs in polynomial time ; ( 2 ) for every instance @xmath146 , the set of strings left on the tape when accepting computations for @xmath137 terminate is precisely the set of solutions @xmath136 .",
    "we now have the following theorem that determines the expressive power of the logic @xmath1 .",
    "its proof is provided in the appendix .",
    "[ ep - main ] a search problem @xmath133 can be solved by a @xmath1 program if and only if @xmath147 np - search .",
    "decision problems can be viewed as special search problems . for the class of decision problems , theorem [ ep - main ]",
    "implies the following corollary ( a counterpart to the result on the expressive power of @xmath148 @xcite ) .",
    "a decision problem @xmath133 can be solved by a @xmath1 program if and only if @xmath133 is in np .",
    "we will now discuss ways to enhance effectiveness of logic @xmath1 as a modeling formalism and propose ways to improve computational performance . when considering the @xmath1 theories developed for the @xmath10-queens and vertex - cover problems",
    "one observes that these theories could be simplified if the language of the logic @xmath1 contained direct means to model constraints such as : `` exactly one element is selected '' or `` at most @xmath2 elements are selected '' .    with this motivation ,",
    "we extend the language of the logic @xmath1 .",
    "we define a _ c - atom _ ( cardinality atom ) as an expression @xmath149 , where @xmath9 and @xmath10 are non - negative integers , @xmath38 and @xmath8 are tuples of variables and @xmath36 is a program predicate .",
    "the interpretation of a c - atom is that for every ground tuples @xmath96 and @xmath97 that can be substituted for @xmath38 and @xmath8 , at least @xmath9 and at most @xmath10 atoms from the set @xmath150 are true .",
    "one of @xmath9 and @xmath10 may be missing from the expression .",
    "if @xmath9 is missing , there is no lower - bound constraint on the number of atoms that are true .",
    "if @xmath9 is missing , there is no upper - bound constraint on the number of atoms that are true .",
    "it is also possible to have more `` underscore '' symbols in c - atoms . in such case ,",
    "when forming the set of atoms on which cardinality constraints are imposed , all possible ways to replace the `` underscore '' symbols by constants are used .",
    "an _ extended clause _ is a clause built of c - atoms .",
    "the notions of a _ program _ and _ theory _ are defined as in the case of the logic @xmath1 .",
    "a theory in the extended syntax can be grounded , that is , represented as a set of propositional clauses , in a similar way as before .",
    "in particular , data and predefined predicates are treated in the same way and are subject to the same version of cwa that was used for the logic @xmath1 . while grounding , c - atoms are interpreted as explained earlier .",
    "grounding allows us to lift the semantics of propositional logic to the theories in the extended syntax .",
    "we call the resulting logic the _ extended logic @xmath1 _ and denote it by @xmath0 .    in the logic @xmath0 we can encode the vertex cover problem in a more straightforward and more concise way .",
    "namely , the problem can be represented without the need for integers to label the vertices of an input graph ! this new representation @xmath151",
    "is given by :    @xmath152 ,    and @xmath153    vc@xmath154 :  0.03 in    @xmath155    @xmath156    @xmath157 .",
    "atoms @xmath158 that are true in a model of the @xmath1 theory @xmath159 define a set of vertices that is a candidate for a vertex cover .",
    "( vc@xmath1542 ) guarantees that no more than @xmath2 vertices are included .",
    "( vc@xmath1543 ) enforces the vertex - cover constraint .",
    "we close this section with an observation on the expressive power of the logic @xmath0 .",
    "since it is a generalization of the logic @xmath1 , it can capture all problems that are in the class np - search .",
    "on the other hand , the problem of computing models of a @xmath0 theory with a fixed program part is an np - search problem , it follows that the expressive power of the logics @xmath0 does not extend beyond the class np - search .",
    "in other words , the logic @xmath0 also captures the class np - search .",
    "to process @xmath0 theories , one approach is to ground them into collections of propositional clauses .",
    "however , cnf representations of c - atoms may be quite large ; the constraint `` at most @xmath10 atoms in the set @xmath160 are true '' , is captured by @xmath161 clauses @xmath162 , one for each @xmath163-element subset @xmath164 of @xmath165 .",
    "thus , we propose another approach .",
    "the idea is to develop an extension of propositional logic representing c - atoms directly .",
    "let @xmath166 be a set of propositional variables . by a _ propositional c - atom _ we mean any expression of the form @xmath167 , where @xmath9 and @xmath10 are non - negative integers and @xmath168 are atoms in @xmath166 ( one of @xmath9 and @xmath10 may be missing ) . by an _ extended propositional clause _ we mean an expression of the form @xmath169 where all @xmath170 and @xmath171 are propositional c - atoms .",
    "let @xmath172 be a set of atoms .",
    "we say that @xmath30 _ satisfies _ a generalized atom @xmath167 if @xmath173 further , @xmath30 _ satisfies _ a generalized clause @xmath28 if @xmath30 satisfies at least one atom @xmath5 or does not satisfy at least one atom @xmath170 .",
    "we call the resulting logic the _ propositional logic _ @xmath0 .",
    "clearly , @xmath30 satisfies an atom @xmath174 if and only if @xmath175 .",
    "thus , the propositional logic @xmath0 extends the ( clausal ) propositional logic .",
    "theories of the logic @xmath0 can be grounded in the extended propositional logic by generalizing the approach described in section [ plc ] .",
    "we represent c - atoms as propositional c - atoms and avoid a blow - up in the size of the representation .",
    "the problem is that sat checkers can not now be used to resolve the satisfiability of the extended propositional logic as they are not designed to work with the extended syntax .",
    "it is clear , however , that the techniques developed in the area of sat checkers can be extended to the propositional logic @xmath0 .",
    "we have developed a davis - putnam like procedure , _ aspps _ , that finds models of propositional @xmath0 .",
    "we also developed a program _",
    "psgrnd _ that accepts theories in the syntax of the logic @xmath0 and grounds them into propositional @xmath0 theories .",
    "thus , the two programs together can be used as a processing mechanism for an answer - set programming system based on the logic @xmath0 .",
    "the programs _ psgrnd _ and _ aspps _ are available at http://www.cs.uky.edu / ai / aspps/.    in our experiments we considered the vertex - cover problem and several combinatorial problems including @xmath10-queens problem , pigeonhole problem and the problem to compute schur numbers .",
    "all our experiments were performed on a pentium iii 500mhz machine running linux .",
    "we were mostly interested in comparing the performance of our system _ psgrnd / aspps _ with that of _ smodels_. the reason is that both programs accept similar syntax and allow for very similar modeling of constraints .",
    "we also experimented with a satisfiability checker _",
    "satz_.    in the case of vertex cover , for each @xmath176 , 60 , 70 and 80 , we randomly generated 100 graphs with @xmath10 vertices and @xmath177 edges .",
    "for each graph @xmath94 , we computed the minimum size @xmath178 for which the vertex cover can be found .",
    "we then tested _ aspps _ , _ smodels _ and _ satz _ on all the instances @xmath179 .",
    "the results represent the average execution times encodings we used for testing _",
    "aspps _ and _ smodels _ where based on the clauses ( vc@xmath1541 ) - ( vc@xmath1543 ) . for _ satz _ we used encodings based on the clauses ( vc1 ) - ( vc6 ) ( cardinality constraints can not be handled by _ satz _ ) .    a propositional cnf theory obtained by grounding the program ( vc1 ) - ( vc6 ) ,",
    "has @xmath180 atoms , @xmath181 clauses and its total size is also @xmath181 . for input instances we used in our experiments ,",
    "these theories were of such large sizes ( over one million rules in the case of graphs with 80 vertices ) that _ satz _ did not terminate in the time we allocated ( 5 minutes ) .",
    "thus , no times for _ satz _ are reported . on the other hand , since the propositional @xmath0 theory obtained by grounding the @xmath0 program ( vc@xmath1541 ) - ( vc@xmath1543 ) has only @xmath182 clauses ( a few hundred clauses for graphs with 80 vertices ) and its total size has the same asymptotic estimate .",
    "this is dramatically less than in the case of theories _ satz _ had to process . both _",
    "aspps _ and _ smodels _ performed very well , with _ aspps _ being about three times faster than _",
    "smodels_. the timing results are summarized in table 1 .    [",
    "cols=\"<,>,>,>,>\",options=\"header \" , ]      +   + * table 4*. timing results ( in seconds ) for the schur - number problem .    in the case of the last three problems , it was possible to eliminate cardinality constraints without significant increase in the size of grounded theories . as a result , _ satz _ performed well .",
    "our work demonstrates that propositional logic and its extensions can support answer - set programming systems in a way in which stable logic programming and disjunctive logic programming do . in the paper we described logic @xmath0",
    "that can be used to this end .",
    "we presented an effective implementation of a grounder , _ psgrnd _ , and a solver , _ aspps _",
    ", for processing theories in the logic @xmath0 .",
    "our experimental results are encouraging .",
    "our system is competitive with _ smodels _ , and in many cases outperforms it .",
    "it is also competitive with satisfiability solvers such as _",
    "satz_.    the results of",
    "the paper show that programming front - ends for constraint satisfaction problems that support explicit coding of complex constraints facilitate modeling and result in concise representations .",
    "they also show that solvers such as _ aspps _ that take advantage of those concise encodings and process high - level constraints directly , without compiling them to simpler representations , exhibit very good computational performance .",
    "these two aspects are important .",
    "satisfiability checkers often can not effectively solve problems simply due to the fact that encodings they have to work with are large .",
    "for instance , for the vertex - cover problem for graphs with 80 vertices and 160 edges , _ aspps _ has to deal with theories that consist of a few hundred of rules only . in the same time",
    "pure propositional encodings of the same problem contain over one million clauses  a factor that undoubtedly is behind much poorer performance of _ satz _ on this problem .",
    "our work raises new questions .",
    "further extensions of logic @xmath0 are possible . for instance",
    ", constraints that impose other conditions on set cardinalities than those considered here ( such as , the _ parity _ constraint ) might be included .",
    "we will pursue this direction .",
    "similarly , there is much room for improvement in the area of solvers for the propositional logic @xmath0 . in particular , we will study local search algorithms as possible satisfiability solvers for propositional @xmath0 theories .",
    "finally , we note that the experimental results presented here are meant to show that _ aspps _ is competitive with other solvers and , we think , they demonstrate this .",
    "however , these results are still too fragmentary to provide basis for any conclusive comparison between the three solvers tested .",
    "such a comparison is further complicated by the fact that the same problem may have several different encodings with different computational properties .",
    "developing the methodology for comparing solvers designed to work with different formal systems is a challenging problem for builders of constraint solvers and declarative programming systems .",
    "this work was partially supported by the nsf grants cda-9502645 , iri-9619233 and eps-9874764 .",
    "elm@xmath18398    k.  apt . logic programming . in j.",
    "van leeuven , editor , _ handbook of theoretical computer science _ , pages 493574 .",
    "elsevier , amsterdam , 1990 .",
    "bayardo , jr and r.c .",
    "schrag . using csp look - back techniques to solve real - world sat instances . in _ proceedings of the fourteenth national conference on artificial intelligence ( aaai-97)_. mit press , 1997 .",
    "negation as failure . in h.",
    "gallaire and j.  minker , editors , _ logic and data bases _ , pages 293322 . plenum press , new york - london , 1978 .",
    "t.  eiter , n.  leone , c.  mateis , g.  pfeifer , and f.  scarcello .",
    "a kr system dlv : progress report , comparisons and benchmarks . in _ proceeding of the sixth international conference on knowledge representation and reasoning ( kr 98 )",
    "_ , pages 406417 .",
    "morgan kaufmann , 1998 .",
    "garey and d.s .",
    "johnson . .",
    "w.h . freeman and co. ,",
    "san francisco , calif . , 1979 .",
    "m.  gelfond and v.  lifschitz .",
    "the stable semantics for logic programs . in r.  kowalski and k.",
    "bowen , editors , _ proceedings of the 5th international conference on logic programming _ , pages 10701080 .",
    "mit press , 1988 .",
    "m.  gelfond and v.  lifschitz .",
    "classical negation in logic programs and disjunctive databases .",
    ", 9:365385 , 1991 .",
    "kautz , d.  mcallester , and b.  selman .",
    "encoding plans in propositional logic . in _ proceedings of kr-96 _ , pages 374384 .",
    "morgan kaufmann , 1996 .",
    "h.a . kautz and b.",
    "unifying sat - based and graph - based planning . in _ proceedings of ijcai-99 _ , san mateo , ca , 1999 .",
    "morgan kaufmann .",
    "li and m.  anbulagan .",
    "look - ahead versus look - back for satisfiability problems . in _ proceedings of the third international conference on principles and practice of constraint programming _",
    ", 1997 .",
    "j.  w. lloyd . .",
    "symbolic computation .",
    "artificial intelligence .",
    "springer - verlag , berlin - new york , 1984 .",
    "w.  marek and j.b . remmel . on the foundations of answer - set programming . in _",
    "answer - set programming : towards efficient and scalable knowledge representation and reasoning_. aaai press , 2001 .",
    "papers from the 2001 aaai spring symposium , technical report ss-01 - 01 .",
    "marek and m.  truszczyski .",
    "stable models and an alternative logic programming paradigm . in k.r .",
    "apt , w.  marek , m.  truszczyski , and d.s .",
    "warren , editors , _ the logic programming paradigm : a 25-year perspective _ , pages 375398 .",
    "springer verlag , 1999 .",
    "i.  niemel",
    ". logic programming with stable model semantics as a constraint programming paradigm .",
    ", 25(3 - 4):241273 , 1999 .",
    "i.  niemel and p.  simons . extending the smodels system with cardinality and weight constraints . in j.",
    "minker , editor , _ logic - based artificial intelligence _ , pages 491521 .",
    "kluwer academic publishers , 2000 .",
    "j.  schlipf .",
    "the expressive powers of the logic programming semantics .",
    ", 51(1):6486 , 1995 .",
    "b.  selman , h.a .",
    "kautz , and b.  cohen .",
    "noise strategies for improving local search . in _ proceedings of the twelfth national conference on artificial intelligence ( aaai-94 )",
    "_ , seattle , usa , 1994 .",
    "we will present here a sketch of a proof of our main result concerning the expressive power of the logic @xmath1 .",
    "the proof relies on some basic notions from logic programming ( we refer the reader to @xcite for details ) .",
    "we restrict our discussion to function - free languages ( the case relevant to our logic @xmath1 ) . given a predicate language @xmath184 ( as defined in section [ plc ] ) , a _ logic program clause _ over this language is an expression @xmath131 of the form @xmath185 where @xmath186 , ( we assume that @xmath36 is not a predefined predicate ) , and @xmath187 are term tuples with the arity matching the arity of the corresponding predicate symbol .",
    "we call the atom @xmath58 the _ head _ of the rule @xmath131 and denote it by @xmath188 . for a rule @xmath131 we also define @xmath189    we will be interested in supported models of logic programs . without loss of generality , we will restrict our attention to programs in the _ normal form_. that is , we assume that ( 1 ) the head of each rule is of the form @xmath58 , where @xmath190 is a tuple of variables , and ( 2 ) if @xmath36 appears in the head of two rules , the heads of these two rules are exactly the same ( the same tuple of variables appear in both of them ) @xcite .",
    "let @xmath55 be a program in the normal form .",
    "for each predicate symbol @xmath191 , we define a formula @xmath192 by : @xmath193 where @xmath38 is a tuple of variables and @xmath194 is the tuple of variables occurring in the body of @xmath131 but not in the head of @xmath131 ( we exploit the normal form of @xmath55 here ) .",
    "we define the _ completion _ of @xmath55 , @xmath195 , by setting @xmath196 .",
    "[ ep - aux ] let @xmath55 be a logic program in the normal form .",
    "let @xmath51 be the set of predicates appearing in @xmath55 and let @xmath52 be the set of predicates of @xmath55 that do not appear in the heads of rules in @xmath55 .",
    "there is a @xmath1 theory @xmath197 such that for every set of ground atoms @xmath54 over predicates from @xmath52 , a set of ground atoms @xmath30 is a supported model of @xmath57 if and only if @xmath198 for some model @xmath199 of the @xmath1 theory @xmath200 .",
    "we build such representation as follows .",
    "let @xmath36 be a predicate symbol in @xmath201 .",
    "the completion @xmath195 contains the formula @xmath202 where @xmath38 is a tuple of variables and @xmath194 is the tuple of variables occurring in the body of @xmath131 but not in the head of @xmath131 . for each rule",
    "@xmath203 such that @xmath36 occurs in @xmath188 , we introduce a new predicate symbol @xmath204 , of the same arity @xmath205 .",
    "we define a theory @xmath206 to consist of the following formulas ( we recall that @xmath207 stands for the conjunction of the literals from the body of @xmath131 ) : @xmath208 where @xmath209 , @xmath203 and @xmath36 occurs in the head of @xmath131 , and @xmath210 where @xmath211 .",
    "it is clear that the theory @xmath206 is equivalent to @xmath195 ( modulo new ground atoms ) .",
    "that is , @xmath212 is a model of @xmath195 if and only if @xmath198 , for some model @xmath199 of @xmath206 .",
    "one can show that @xmath206 can be rewritten ( in polynomial time ) into an equivalent clausal form , @xmath197 .",
    "consequently , @xmath197 is equivalent to @xmath195 ( modulo ground atoms @xmath213 ) .",
    "it is now a routine task to verify that the theory @xmath197 satisfies all the requirements of the statement of the theorem .",
    "@xmath214        proof : ( sketch ) in @xcite it is proved that every np - search problem can be solved uniformly by a finite logic program under the supported - model semantics .",
    "since the theory @xmath197 can be constructed in polynomial time , it follows by theorem [ ep - aux ] that every search problem in np - search can be solved by a finite @xmath1 program .",
    "conversely , for every fixed program @xmath55 , the problem of computing models of a @xmath1 theory @xmath53 ( @xmath54 is the input ) is clearly in the class np - search .",
    "thus , only search problem in the class np - search can be solved by finite @xmath1 programs .",
    "hence , the assertion follows ."
  ],
  "abstract_text": [
    "<S> we show that propositional logic and its extensions can support answer - set programming in the same way stable logic programming and disjunctive logic programming do . to this end </S>",
    "<S> , we introduce a logic based on the logic of propositional schemata and on a version of the closed world assumption . </S>",
    "<S> we call it the _ extended logic of propositional schemata with cwa _ ( @xmath0 , in symbols ) </S>",
    "<S> . an important feature of the logic @xmath0 is that it supports explicit modeling of constraints on cardinalities of sets . in the paper </S>",
    "<S> , we characterize the class of problems that can be solved by finite @xmath0 theories . </S>",
    "<S> we implement a programming system based on the logic @xmath0 and design and implement a solver for processing theories in @xmath0 . </S>",
    "<S> we present encouraging performance results for our approach  we show it to be competitive with _ smodels _ , a state - of - the - art answer - set programming system based on stable logic programming . </S>"
  ]
}