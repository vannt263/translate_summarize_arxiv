{
  "article_text": [
    "the algorithmic complexity of solving bchi games is one of the more intriguing questions in graph algorithms .",
    "the input of the bchi game problem consists of a directed graph whose states @xmath10 are partitioned into player  1 states and player  2 states , and a set @xmath11 of bchi states . in each player  1 state",
    ", the first player chooses an outgoing edge , and each player  2 state , the second player chooses an outgoing edge .",
    "the question is if , from a given start state , player  1 has a strategy to visit a state in @xmath12 infinitely often .",
    "the classical algorithm for solving bchi games has time complexity @xmath0 , where @xmath1 is the number of states and @xmath2 is the number of edges .",
    "the classical algorithm proceeds in a seemingly naive fashion : first it computes the set @xmath13 of states from which player  1 has a strategy to visit @xmath12 once , which requires time  @xmath4 ; then it computes the set of states @xmath14 such that player  2 has a strategy to visit @xmath15 once .",
    "the set @xmath14 is removed from the game graph and the algorithm iterates over the reduced game graph unless @xmath14 is empty for the current game graph .",
    "the algorithm converges in at most @xmath1 iterations , is the answer to the bchi game problem .",
    "this algorithm seemingly performs unnecessarily repetitive work , yet no asymptotically faster algorithm is known .    in  @xcite",
    ", we gave a subquadratic algorithm for the special case of graphs with constant outdegree .",
    "in this special case @xmath16 , and thus the classical algorithm performs in time  @xmath6 .",
    "we gave an algorithm with running time @xmath3 .",
    "while the classical algorithm computes each set @xmath13 by backward search of the graph , our algorithm alternated backward searches with bounded amounts of forward searches .    in this paper , we present two new algorithms for bchi games . while they fall short of the ultimate goal of a better than @xmath0 algorithm , they present progress in that direction .",
    "first , in section  3 we give an algorithm that performs at most @xmath4 more work than the classical algorithm .",
    "however , there exist families of game graphs of outdegree 2 on which our algorithm performs in time  @xmath5 , while the classical algorithm requires time  @xmath17 .",
    "also there exist families of game graphs of @xmath18 states with outdegree at most 2 on which both the classical and the algorithm of  @xcite requires @xmath19 time , where as our algorithm requires @xmath18 time . however , there exist game graphs where our algorithm requires @xmath0 time in the worst case .",
    "our algorithm performs several backward searches , but instead of backward search from @xmath12 it performs backward search from a subset of @xmath20 that are candidates to be in @xmath21 .",
    "second , in section  4 we give an algorithm with running time @xmath7 , where @xmath8 is the outdegree of the graph . if @xmath22 , then this algorithm performs asymptotically like the algorithm of  @xcite ; indeed , the new algorithm is based on the algorithm from  @xcite .",
    "the forward search of the algorithm of  @xcite was very naive ; we develop a more refined forward search which saves repetitive work of the forward search of the algorithm of  @xcite and thus obtain the generalization of the algorithm of  @xcite to general game graphs .",
    "if @xmath9 , then our algorithm performs better than the classical algorithm ; it is to our knowledge the first algorithm that improves on the classical algorithm in this case .",
    "we consider turn - based deterministic games played by two - players with bchi and complementary cobchi objectives for the players , respectively .",
    "we define game graphs , plays , strategies , objectives and notion of winning below .    * game graphs . * a _ game graph _ @xmath23 consists of a directed graph @xmath24 with a finite state space @xmath10 and a set @xmath25 of edges , and a partition @xmath26 of the state space @xmath10 into two sets . the states in @xmath27 are player  1 states , and the states in @xmath28 are player  2 states . for a state @xmath29 , we write @xmath30 for the set of successor states of  @xmath31 .",
    "we assume that every state has at least one out - going edge , i.e. , @xmath32 is non - empty for all states @xmath29",
    ".    _ plays . _ a game is played by two players : player  1 and player  2 , who form an infinite path in the game graph by moving a token along edges .",
    "they start by placing the token on an initial state , and then they take moves indefinitely in the following way .",
    "if the token is on a state in  @xmath27 , then player  1 moves the token along one of the edges going out of the state .",
    "if the token is on a state in  @xmath28 , then player  2 does likewise .",
    "the result is an infinite path in the game graph ; we refer to such infinite paths as plays .",
    "formally , a _ play _ is an infinite sequence @xmath33 of states such that @xmath34 for all @xmath35 .",
    "we write @xmath36 for the set of all plays",
    ".    _ strategies . _",
    "a strategy for a player is a recipe that specifies how to extend plays .",
    "formally , a _ strategy",
    "_ @xmath37 for player  1 is a function @xmath37 : @xmath38 that , given a finite sequence of states ( representing the history of the play so far ) which ends in a player  1 state , chooses the next state .",
    "the strategy must choose only available successors , i.e. , for all @xmath39 and @xmath40 we have @xmath41 .",
    "the strategies for player  2 are defined analogously .",
    "we write @xmath42 and @xmath43 for the sets of all strategies for player  1 and player  2 , respectively",
    ". an important special class of strategies are _ memoryless _ strategies .",
    "the memoryless strategies do not depend on the history of a play , but only on the current state .",
    "each memoryless strategy for player  1 can be specified as a function @xmath37 : @xmath44 such that @xmath45 for all @xmath40 , and analogously for memoryless player  2 strategies .",
    "given a starting state @xmath29 , a strategy @xmath46 for player  1 , and a strategy @xmath47 for player  2 , there is a unique play , denoted @xmath48 , which is defined as follows : @xmath49 and for all @xmath35 , if @xmath50 , then @xmath51 , and if @xmath52 , then @xmath53 .",
    "_ bchi and cobchi objectives .",
    "_ we consider game graphs with a bchi objective for player  1 and the complementary cobchi objective for player  2 . for a play @xmath54 , we define @xmath55 to be the set of states that occur infinitely often in  @xmath56 .",
    "we also define reachability and safety objectives as they will be useful in the analysis of the algorithms .    1 .",
    "_ reachability and safety objectives .",
    "_ given a set @xmath57 of states , the reachability objective @xmath58 requires that some state in @xmath59 be visited , and dually , the safety objective @xmath60 requires that only states in @xmath61 be visited .",
    "formally , the sets of winning plays are @xmath62 and @xmath63 .",
    "the reachability and safety objectives are dual in the sense that @xmath64 .",
    "bchi and co - bchi objectives .",
    "_ given a set @xmath65 of states , the bchi objective @xmath66 requires that some state in @xmath12 be visited infinitely often , and dually , the co - bchi objective @xmath67 requires that only states in @xmath68 be visited infinitely often .",
    "thus , the sets of winning plays are @xmath69 and @xmath70 .",
    "the bchi and cobchi objectives are dual in the sense that @xmath71 .",
    "_ winning strategies and sets .",
    "_ given an objective @xmath72 for player  1 , a strategy @xmath46 is a _ winning strategy _ for player  1 from a state @xmath31 if for all player  2 strategies @xmath47 the play @xmath73 is winning , i.e. , @xmath74 .",
    "the winning strategies for player  2 are defined analogously .",
    "a state @xmath29 is winning for player  1 with respect to the objective @xmath75 if player  1 has a winning strategy from @xmath31 .",
    "formally , the set of _ winning states _ for player  1 with respect to the objective @xmath75 is @xmath76 analogously , the set of winning states for player  2 with respect to an objective @xmath77 is @xmath78 we say that there exists a memoryless winning strategy for player  1 with respect to the objective @xmath75 if there exists such a strategy from all states in @xmath79 ; and similarly for player  2 .",
    "[ thrm : determinacy ] the following assertions hold .    1 .   for all game graphs @xmath23 ,",
    "all bchi objectives @xmath75 for player  1 , and the complementary cobchi objective @xmath80 for player  2 , we have @xmath81 .",
    "2 .   for all game graphs and all bchi objectives",
    "@xmath75 for player  1 and the complementary cobchi objective @xmath82 for player  2 , there exists a memoryless winning strategy for both players .",
    "observe that for bchi objective @xmath75 and the cobchi objective @xmath83 by definition we have @xmath84 .",
    "theorem  [ thrm : determinacy ] states that @xmath85 , i.e. , the order of the universal and the existential quantifiers can be exchanged .",
    "in this section we present the classical iterative algorithm for bchi games and an alternative iterative algorithm , i.e. , algorithms to compute the winning sets in bchi games .",
    "the running time of the alternative algorithm is never more than the running time the classical algorithm by an additive factor of @xmath4 , where @xmath2 is the number of edges in the game graph .",
    "we also present a family of game graphs with bchi objectives where the classical algorithm requires quadratic time and the alternative algorithm works in linear time .",
    "we start with the notion of _ closed sets _ and _ attractors _ which are key notions for the analysis of the algorithm",
    ".    _ closed sets . _",
    "a set @xmath86 of states is a _ closed set _ for player  1 if the following two conditions hold : ( a )  for all states @xmath87 , we have @xmath88 , i.e. , all successors of player  1 states in @xmath89 are again in @xmath89 ; and ( b )  for all @xmath90 , we have @xmath91 , i.e. , every player  2 state in @xmath89 has a successor in @xmath89 .",
    "the closed sets for player  2 are defined analogously .",
    "every closed set @xmath89 for player  @xmath92 , for @xmath93 , induces a sub - game graph , denoted @xmath94 .",
    "[ prop : closed ] consider a game graph @xmath95 , and a closed set @xmath89 for player  1 .",
    "then the following assertions hold .    1",
    ".   there exists a memoryless strategy @xmath96 for player  2 such that for all strategies @xmath37 for player  1 and for all states @xmath97 we have @xmath98 .",
    "2 .   for all @xmath99 , we have @xmath100 .    _ attractors .",
    "_ given a game graph @xmath95 , a set @xmath101 of states , and a player @xmath93 , the set @xmath102 contains the states from which player  @xmath92 has a strategy to reach a state in @xmath89 against all strategies of the other player ; that is , @xmath103 .",
    "the set @xmath104 can be computed inductively as follows : let @xmath105 ; let @xmath106 then @xmath107 .",
    "the inductive computation of @xmath108 is analogous .",
    "for all states @xmath109 , define @xmath110 if @xmath111 , that is , @xmath112 denotes the least @xmath113 such that @xmath31 is included in @xmath114 . define a memoryless strategy @xmath46 for player  1 as follows : for each state @xmath115 with @xmath110 , choose a successor @xmath116 ( such a successor exists by the inductive definition ) .",
    "it follows that for all states @xmath109 and all strategies @xmath47 for player  2 , the play @xmath73 reaches @xmath89 in at most @xmath117 transitions .",
    "[ prop : attractor ] for all game graphs @xmath95 , all players @xmath93 , and all sets @xmath86 of states , the set @xmath118 is a closed set for player  @xmath92 .      in this subsection",
    "we present the classical algorithm for bchi games .",
    "we start with an informal description of the algorithm",
    ".    * informal description of classical algorithm . *",
    "the _ classical algorithm _ ( algorithm  [ algorithm : classical ] ) works as follows .",
    "we describe an iteration @xmath119 of the algorithm : the set of states at iteration @xmath119 is denoted as @xmath120 , the game graph as @xmath121 and the set of bchi states @xmath122 as @xmath123 . at iteration @xmath119",
    ", the algorithm first finds the set of states @xmath114 from which player  1 has a strategy to reach the set @xmath123 , i.e. , computes @xmath124 .",
    "the rest of the states @xmath125 is a closed subset for player  1 , and @xmath126 .",
    "the set @xmath127 is identified as winning for player  2 .",
    "then the set of states @xmath128 , from which player  2 has a strategy to reach the set @xmath127 , i.e. , @xmath129 is computed .",
    "the set @xmath128 is identified as a subset of the winning set for player  2 and it is removed from the state set .",
    "the algorithm then iterates on the reduced game graph .",
    "observe that at every iteration the set of states removed is an attractor set and by proposition  [ prop : attractor ] the reduced game graph ( the complement of an attractor ) is a closed set and hence a game graph . in every iteration it performs a _ backward _ search from the current bchi states to find the set of states which can reach the bchi set .",
    "each iteration takes @xmath4 time and the algorithm runs for at most @xmath5 iterations , where @xmath2 and @xmath1 denote the number of edges and states in the game graph , respectively . the algorithm is formally described as algorithm  [ algorithm : classical ] .",
    "the correctness of the algorithm easily follows from the results in @xcite .",
    "aa = aa = aaa = aaa = aaa = aaa = aaa = aaa a 2-player game graph @xmath130 and @xmath65 .",
    "+ @xmath131 .",
    "+ 1 . @xmath132 ; @xmath133 ; 2 . @xmath134 ; 3 .",
    "@xmath135 + 4 . *",
    "repeat *   + 4.1 @xmath136 + 4.2 @xmath137 ; @xmath138 ; 4.3 @xmath139 ; + * until * @xmath140 + 5 . *",
    "return * @xmath141 . + * procedure * @xmath142 + game graph @xmath121 and @xmath143 . + set @xmath144 .",
    "@xmath145 ; 2 .",
    "@xmath146 ; 3 .",
    "@xmath147    [ thrm : classical ] given a game graph @xmath23 and @xmath65 the following assertions hold :    1 .   @xmath148 and @xmath149 , where @xmath150 is the output of algorithm  [ algorithm : classical ] ; 2 .",
    "the running time of algorithm  [ algorithm : classical ] is @xmath151 where @xmath152 and @xmath153 .    observe that the size of the set of bchi states @xmath12 can be @xmath5 , where @xmath154 is the number of states , i.e. , @xmath155 in theorem  [ thrm : classical ] can be @xmath5 . hence the worst case running time of the classical algorithm can be @xmath156 , where @xmath154 and @xmath153 .",
    "we now present a new alternative iterative algorithm for bchi games .",
    "the algorithm differs from the classical algorithm in its computation of the set @xmath127 ( computed in step 2 of procudure @xmath142 ) at every iteration . recall that the set @xmath127 is a player  1 closed set with empty intersection with the set of bchi states .",
    "the alternative algorithm at every iteration identifies the set @xmath127 in an alternative way .",
    "we first present an informal description of the algorithm .",
    "* informal description of alternative algorithm .",
    "* we describe an iteration @xmath119 of algorithm  [ algorithm : alternative ] .",
    "we denote by @xmath157 the set of cobchi states .",
    "we denote the set of states at iteration @xmath119 by @xmath120 , the game graph as @xmath121 , the set of bchi states @xmath122 as @xmath123 , and the set of cobchi states as @xmath158 as @xmath159 .",
    "the algorithm proceeds as follows : first it computes the set of player  1 states in @xmath159 with all successors in @xmath159 and the set of player  2 states in @xmath159 with a successor in @xmath159 . then the player  2 attractor to the union of the above two sets is computed and let this set be @xmath160 .",
    "the states of @xmath160 such that player  1 has a strategy to leave @xmath160 is not a part of the player  1 closed set , and the remaining states of @xmath160 is a player  1 closed set with empty intersection with @xmath123 , and this is identified as the set similar to the set @xmath127 of algorithm  [ algorithm : classical ] .",
    "the details of the algorithms is as follows . in step  4.2",
    "the set of player  1 states @xmath161 is computed where for all @xmath162 , all successors of @xmath31 in @xmath121 is in @xmath159 ; and in step  4.3 the set of player  2 states @xmath163 is computed where for all @xmath164 , there is a successor of @xmath31 in @xmath159 . then the set @xmath165 is computed as the set of states such that player  2 has a strategy in @xmath121 to reach @xmath166 against all player  1 strategies , i.e. , @xmath167 , and the set @xmath160 is obtained as @xmath168 . the set @xmath169 denotes the set of states such that player  1 can escape @xmath160 in one step , i.e. , either a player  1 state with an edge out of @xmath160 or a player  2 state with all edges out of @xmath160 .",
    "the set @xmath170 denotes the set of states where player  1 has a strategy in @xmath165 to reach @xmath169 against all player  2 strategies , i.e. , @xmath171 .",
    "observe that the set @xmath165 is not always a proper sub - game , however , for all states in @xmath172 we have @xmath173 , and hence for the purpose of the computation of the attractor of @xmath169 we can consider @xmath174 as a sub - game . the set @xmath175 is identified as winning for player  2 .",
    "then the set of states @xmath128 , from which player  2 has a strategy to reach the set @xmath176 , i.e. , @xmath177 is computed .",
    "the set @xmath128 is identified as a subset of the winning set for player  2 and it is removed from the state set .",
    "the algorithm then iterates on the reduced game graph .",
    "the algorithm is described formally as algorithm  [ algorithm : alternative ] .",
    "aa = aa = aaa = aaa = aaa = aaa = aaa = aaa a 2-player game graph @xmath130 and @xmath65 .",
    "+ @xmath131 .",
    "+ 1 . @xmath132 ; @xmath133 ; @xmath178 ; 2 .",
    "@xmath134 ; 3 . @xmath135 + 4 .",
    "* repeat *   + 4.1 @xmath179 ; + 4.2 @xmath180 ; + 4.3 @xmath181 ; + 4.4 @xmath182 ; + 4.5 @xmath183 ; + 4.6 @xmath184 + @xmath185 .",
    "+ 4.7 @xmath186 ; + 4.8 @xmath187 ; + 4.9 @xmath188 ; + 4.10 @xmath137 ; @xmath138 ; @xmath139 ; + * until * @xmath140 + 5 .",
    "* return * @xmath141 .",
    "* correctness arguments . *",
    "the main argument to prove the correctness of algorithm  [ algorithm : alternative ] is as follows : we will show that , given that the game graph @xmath121 are same at iteration @xmath119 of algorithm  [ algorithm : classical ] and algorithm  [ algorithm : alternative ] , set @xmath127 computed in step  2 of the iteration of classical algorithm and the set @xmath176 computed in step  4.8 of the alternative algorithm coincide .",
    "once we prove this result the correctness of the alternative algorithm follows easily .",
    "we prove this result in several steps .",
    "the following proposition states that @xmath127 is the largest player  1 closed subset of @xmath159 and it follows easily from the properties of attractors and proposition  [ prop : closed ] .",
    "[ prop : alt1 ] let @xmath121 be the graph at iteration @xmath119 if algorithm  [ algorithm : classical ] and let @xmath189 such that @xmath190 is player  1 closed , then @xmath191 .    by proposition  [ prop : alt1 ]",
    "to prove our desired claim it suffices to show that @xmath192 , and @xmath176 is a player  1 closed subset of @xmath159 ( this would imply @xmath193 ) .",
    "[ lemm : alt1 ] @xmath194 .",
    "observe that @xmath127 is a player  1 closed of @xmath159 .",
    "hence for all states @xmath195 the following assertions hold : ( a )  if @xmath40 , then @xmath196 ; and ( b )  if @xmath197 , then @xmath198 , and hence @xmath199 . hence if @xmath195 , then @xmath200 .",
    "[ lemm : alt2 ] @xmath201 , where @xmath160 is the set computed at step  4.5 of algorithm  [ algorithm : alternative ] .    by lemma",
    "[ lemm : alt1 ] we have @xmath194 and hence we have @xmath202 . since @xmath203 , we have @xmath204 .",
    "[ lemm : alt3 ] @xmath205 , where @xmath160 and @xmath170 are the sets computed at step  4.5 and 4.7 of algorithm  [ algorithm : alternative ] , respectively .",
    "by lemma  [ lemm : alt2 ] we have @xmath201 and hence we have @xmath206 .",
    "observe that from states in @xmath169 player  1 can force the game to reach @xmath207 .",
    "similarly , in the sub - game @xmath165 with @xmath169 as target set , player  1 can force the game to reach @xmath169 from @xmath170 and then force the game to reach @xmath208 .",
    "since @xmath209 and @xmath127 is a player  1 closed set , player  2 can keep the game in @xmath127 forever ( by proposition  [ prop : closed ] ) .",
    "hence we must have @xmath210 .",
    "hence we have @xmath201 and @xmath211 .",
    "thus we obtain @xmath205 .",
    "[ lemm : alt4 ] @xmath212 and @xmath213 is a player  1 closed set .    since @xmath214",
    ", it follows that for all states @xmath215 we have ( a ) if @xmath216 , then @xmath217 , and ( b ) if @xmath218 , then we have @xmath219 . since @xmath220 , for all states @xmath221 the following assertions hold : ( a )  if @xmath40 , then @xmath222 , as otherwise @xmath31 would have been in @xmath170 ; and ( b )  if @xmath197 , then @xmath223 , as otherwise @xmath31 would have been in @xmath170 .",
    "hence it follows that @xmath224 is player  1 closed , and since @xmath225 , the desired result follows .",
    "[ lemm : alt5 ] @xmath226 .    by lemma  [ lemm : alt3 ]",
    "we have @xmath192 . by lemma  [ lemm : alt4 ]",
    "we have @xmath176 is a player  1 closed subset of @xmath159 .",
    "then , by proposition  [ prop : alt1 ] we have @xmath193 .",
    "this proves the desired result .",
    "the correctness of algorithm  [ algorithm : alternative ] easily follows from lemma  [ lemm : alt5 ] and induction .",
    "[ thrm : alt - correctness ] given a game graph @xmath23 and @xmath65 we have @xmath148 and @xmath149 , where @xmath150 is the output of algorithm  [ algorithm : alternative ] .",
    "* work analysis of algorithm  [ algorithm : alternative ] .",
    "* we first analyze the work for the computation of step  4.2 and step  4.3 over all iterations of algorithm  [ algorithm : alternative ] .",
    "it easily follows that @xmath227 , this follows since if a state @xmath197 has an edge to @xmath228 , then @xmath31 would have been in @xmath228 itself .",
    "the total work in the computation of the sets @xmath161 overall iterations is @xmath4 : this is achieved as follows . for every state @xmath40",
    "we keep a counter for the number of edges to the set @xmath229 , and once an edge to @xmath230 is removed from the graph the counter for the respective state is decremented by  1 .",
    "once the counter for a state reaches  0 it is included in @xmath161 .",
    "hence the total work for step  4.2 and step  4.3 overall iterations is @xmath4 .",
    "we now argue that the excess work of algorithm  [ algorithm : alternative ] as compared to the classical algorithm is at most @xmath4 .",
    "the total work of step  4.2 and step  4.3 is already bounded by @xmath4 .",
    "the rest of the argument is as follows : the classical algorithm for the computation of @xmath127 never works on the edges in @xmath127 , i.e. , on edges in @xmath231 . at iteration",
    "@xmath119 algorithm  [ algorithm : alternative ] does excess work as compared to classical algorithm on the edges in @xmath127 and does only constant amount of work on this edges .",
    "however , edges in @xmath127 are removed at every iteration @xmath119 , and hence the excess work of algorithm  [ algorithm : alternative ] as compared to the classical algorithm is @xmath4 .",
    "[ thrm : run - alternative ] let @xmath232 denote the running time of algorithm  [ algorithm : classical ] on a game graph @xmath95 with @xmath11 and @xmath233 denote the running time of algorithm  [ algorithm : alternative ] .",
    "then we have @xmath234 , where @xmath153 .",
    "we now present an example of a family of game graphs where the classical algorithm requires quadratic time , whereas algorithm  [ algorithm : alternative ] works in linear time .",
    "the family of game graphs is constructed as follows .",
    "given @xmath235 we consider a game graph consisting of @xmath1 gadgets @xmath236 as follows .",
    "the gadget @xmath237 consits of a player  1 state @xmath238 ( shown as a @xmath239-state in fig  [ figure : buchi - example ] ) and a player  2 state @xmath240 ( shown as a @xmath241 state in fig  [ figure : buchi - example ] ) .",
    "the set of edges is as follows :    1 .",
    "for @xmath242 we have @xmath243 and @xmath244 .",
    "2 .   for @xmath245",
    "we have @xmath246 and @xmath247 .",
    "the set of bchi states is @xmath248 .",
    "given @xmath235 , the game graph constructed has @xmath249 states and @xmath250 edges , i.e. , we have @xmath5 states and @xmath5 edges .    the sets @xmath127 and @xmath128 obtained at iteration @xmath119 , for @xmath251 , for the classical algorithm are as follows : @xmath252 and @xmath253 .",
    "at iteration @xmath119 the classical algorithm works on edges of gadgets @xmath254 , for @xmath255 .",
    "hence the total work of the classical algorithm is at least @xmath256 i.e. , the classical algorithm requires time quadratic in the size of the game graph .",
    "we now analyze the work of algorithm  [ algorithm : alternative ] .",
    "the sets of algorithm  [ algorithm : alternative ] of iteration @xmath119 , for @xmath257 , is as follows : ( a )  @xmath258 and @xmath259 ; ( b )  @xmath260 and @xmath261 ; and ( c )  @xmath262 , @xmath263 and @xmath264 .",
    "the work of algorithm  [ algorithm : alternative ] is constant for every iteration @xmath119 : since the computation of steps 4.4 to steps 4.9 only works on edges in @xmath237 and @xmath265 .",
    "hence the total work of algorithm  [ algorithm : alternative ] is @xmath5 , i.e. , the alternative algorithm works in linear time .    also if in every gadget @xmath237 the self - loop at state @xmath238 is replaced by a cycle of @xmath266 states , then both the classical algorithm and the algorithm of  @xcite requires @xmath267 time , whereas algorithm  [ algorithm : alternative ] requires @xmath268 time .",
    "* dovetailing algorithm  [ algorithm : classical ] and algorithm  [ algorithm : alternative ] .",
    "* we already proved that the set @xmath127 and @xmath176 of algorithm  [ algorithm : classical ] and algorithm  [ algorithm : alternative ] coincide .",
    "algorithm  [ algorithm : classical ] never works on the edges in @xmath127 and is favorable when @xmath127 is large and algorithm  [ algorithm : alternative ] is favorable when @xmath127 is small .",
    "hence in every iteration both the algorithms can be run in a dovetailing fashion and obtaining @xmath127 by the algorithm that completes first .",
    "the computation of the sets @xmath269 and @xmath270 can be computed during the computation of the set @xmath128 .",
    "in this section we present the improved algorithm for bchi games .",
    "the algorithm is a generalization of the improved algorithm of  @xcite to general game graphs , as compared to the algorithm of  @xcite which works only for binary game graphs ( game graphs with every state having out - degree at most 2 ) .",
    "we will use the following notations in this section",
    ".    * notation . * for a set @xmath89 and a game graph @xmath95 we denote by @xmath271 is the set of states with edges that enter @xmath89 . given a game graph @xmath95",
    "we denote by @xmath272 the maximum out - degree of a state in @xmath95 .",
    "* informal description of the new algorithm * we observe that in step  1 of every iteration  @xmath119 of the classical algorithm an @xmath4 _ backward _ alternating search is performed to compute the set  @xmath114 , where @xmath2 is the number of edges .",
    "the key idea of our _ improved algorithm _",
    "( algorithm  [ algorithm : improved ] ) is to perform a cheap _ forward _ exploration of edges in order to discover subsets of the winning set for player  2 .",
    "let @xmath89 be the set of sources of edges entering the winning set of player  2 discovered in the previous iteration .",
    "the states in set @xmath89 are new candidates to be included in the winning set of player  2 .",
    "the cheap forward exploration of edges is performed when the size of the set @xmath89 is small .",
    "formally , if @xmath273 , then an iteration of the classical algorithm is executed ( step  4.1 ) , i.e. , the backward search is performed .",
    "otherwise , we perform the cheap forward search as follows : we add an auxiliary state @xmath274 with an edge to every state in @xmath89 . from the state @xmath274 a bfs is performed for @xmath275 steps in step  4.2.2 of algorithm  [ algorithm : improved ] . in steps",
    "4.2.34.2.7 we check if the explored subgraph contains a closed set for player  1 in which player  2 has a winning strategy . if no such set is detected then one iteration of the classical algorithm is executed .",
    "the key for an improved bound of our algorithm is the observation that if step  4.2.7 fails to identify a non - empty winning subset for player  2 , then the set discovered by the following iteration of the classical algorithm has at least @xmath276 states .",
    "a formal presentation of the algorithm is given as algorithm  [ algorithm : improved ] .",
    "aa = aa = aaa = aaa = aaa = aaa = aaa = aaa = aaa a 2-player game graph @xmath130 and @xmath65 .",
    "+ @xmath131 .",
    "@xmath132 ; @xmath133 ; @xmath178 ; 2 .",
    "@xmath134 ; 3 . @xmath135 + 4 . *",
    "repeat *   + 4.1 * if * ( @xmath277 ) + 4.1.1 @xmath278 + 4.1.2 * go to * step 4.3 .",
    "+ 4.2 * else * + 4.2.1 * add * a state @xmath274 and an edge fro @xmath274 to a state in @xmath279 + 4.2.2 find the reachable subgraph @xmath280 by a bfs for @xmath275 steps + 4.2.3 let @xmath281 denote the set of states in the frontier of the bfs + 4.2.4 @xmath282 + 4.2.5 @xmath283 + 4.2.6 @xmath284 + 4.2.7 * if * @xmath285 + 4.2.7.1 * then * @xmath286 + 4.2.8 * else * + 4.2.8.1 @xmath278 + 4.2.9 * remove * the state @xmath274 ; +   + 4.3 @xmath137 ; @xmath138 ; @xmath139 ; + * until * @xmath140 + 5 .",
    "* return * @xmath141 .",
    "_ inductive case : _ we argue that @xmath290 implies that @xmath291 .",
    "the case when step  4.1.1 gets executed , or step 4.2.7 fails and step 4.2.8 gets executed , then the correctness follows from the correcntess of the iteration of the classical algorithm .",
    "we focus on the case when step  4.2.7 gets executed , i.e. , a non - empty set @xmath127 is discovered as @xmath292 . for state @xmath293 , we have @xmath294 .",
    "it follows from step 4.2.4 that @xmath295 .",
    "let @xmath296 . hence the following two conditions hold : @xmath297 by property of attractor we have the following property for @xmath292",
    "; for all states @xmath298 the following assertions hold : ( a )  if @xmath40 , then @xmath299 , and ( b )  if @xmath197 , then @xmath300 .",
    "* work analysis of algorithm  [ algorithm : improved ] .",
    "* we now focus on the work analysis of algorithm  [ algorithm : improved ] .",
    "let us denote by @xmath92 the depth of the search of the bfs at step  4.2.2 of algorithm  [ algorithm : improved ] . since @xmath304 and",
    "the bfs proceeds for @xmath305 steps , the bfs explores at least @xmath306 edges of the game graph @xmath121 .",
    "hence must have @xmath307 .",
    "thus we obtain that @xmath308 . in the following lemma",
    "we denote by @xmath92 the depth of the bfs search at step  4.2.2 of algorithm  [ algorithm : improved ] .",
    "[ lemm : improved1 ] let @xmath280 be the set computed in step 4.2.2 of algorithm  [ algorithm : improved ] and @xmath92 be the depth of the bfs in step 4.2.2 .",
    "let @xmath309 be an player  1 closed set such that @xmath310 and @xmath311 .",
    "then @xmath312 , and hence @xmath150 is discovered in step 4.2.7 .",
    "given a game graph @xmath95 and a set of states @xmath89 we define sequences @xmath190 as follows : @xmath313 by definition @xmath314 .",
    "we prove by induction that @xmath315 . by step 4.2.5",
    "we have @xmath316 .",
    "let @xmath190 be the sequence of set of states in the attractor computation of @xmath317 with @xmath318 .",
    "we show by induction that @xmath319 .",
    "_ base case .",
    "_ given @xmath320 , for all states @xmath321 there is a path from @xmath274 of length at most @xmath322 to @xmath323 .",
    "it follows that in the bfs from @xmath274 depth of any state @xmath321 is less than @xmath92 .",
    "hence we have @xmath324 .",
    "since @xmath325 we have @xmath326 .",
    "since @xmath310 we have @xmath327 .",
    "it follows that @xmath328 .",
    "this proves the base case that @xmath329 .    _",
    "inductive case .",
    "_ given @xmath330 we show that @xmath331 . since @xmath150 is a player  1 closed set , the following assertions hold : for a state @xmath332 , we have @xmath333 and for a state @xmath334 , we have @xmath335 .",
    "consider a state @xmath336 , since @xmath330 , then @xmath337 and @xmath338 and hence @xmath339 .",
    "consider a state @xmath334 , since @xmath335 and @xmath340 , we have @xmath341 .",
    "hence @xmath339 .",
    "hence @xmath342 .",
    "consider an iteration of algorithm  [ algorithm : improved ] : since step  4.2.2 gets executed for @xmath305 steps it follows that size of the graph @xmath280 is @xmath346 .",
    "it follows that in any iteration the total work of step 4.2.2  step 4.2.6 is @xmath347 .",
    "since there can be at most @xmath5 iterations of the algorithm the result for step 4.2.2  step 4.2.6 follows .    the edges on which step 4.2.7 works are removed for further iteration when we remove @xmath128 from the present set of states .",
    "hence in step 4.2.7 no edge is worked for more than once .",
    "thus we obtain that total work of step 4.2.7 of algorithm  [ algorithm : improved ] is @xmath4 .      in algorithm",
    "[ algorithm : improved ] when step 4.2.8 gets executed let @xmath127 be the set of vertices identified by the iteration of the classical algorithm .",
    "if @xmath349 , where @xmath92 is the depth of the bfs search of step 4.2.2 , then it follows from lemma  [ lemm : improved1 ] that it would have been identified by step 4.2.7 in of the iteration . hence every time 4.8",
    "gets executed at least @xmath92 states are removed from the graph .",
    "so step 4.2.8 can be executed at most @xmath350 times , where @xmath351 .",
    "the work at every iteration is @xmath4 and hence the total work of step 4.2.8 of algorithm  [ algorithm : improved ] is @xmath348 .",
    "the condition of step 4.1 ensures that whenever step 4.1 gets executed as least @xmath353 edges are removed from the graph in the previous iteration .",
    "hence step 4.1 gets executed at most @xmath354 times and each iteration takes @xmath4 work .",
    "the result follows .",
    "observe that for a game graph @xmath95 with @xmath154 we have @xmath355 , and hence algorithm  [ algorithm : improved ] is asymptotically no worse than the classical algorithm . in",
    "@xcite an improved algorithm is presented for binary game graphs ( where every state has out - degree at most  2 ) with a running time of @xmath356 , for game graphs with @xmath1-states .",
    "for the special case of binary game graphs the running time of algorithm  [ algorithm : improved ] matches the bound of the algorithm of  @xcite . however , there exists game graphs where algorithm  [ algorithm : improved ] out - performs both the classical algorithm and the algorithm of  @xcite .",
    "for example consider the class of game graphs @xmath95 with @xmath154 and @xmath357 for all states , and hence @xmath358 .",
    "the classical algorithm and the algorithm of  @xcite ( after reduction to binary game graphs ) in the worst case take @xmath267 time , whereas the worst case running time of algorithm  [ algorithm : improved ] is bounded in @xmath359 ."
  ],
  "abstract_text": [
    "<S> the classical algorithm for solving bchi games requires time @xmath0 for game graphs with @xmath1 states and @xmath2 edges . for game graphs with constant outdegree , the best known algorithm has running time @xmath3 . </S>",
    "<S> we present two new algorithms for bchi games . </S>",
    "<S> first , we give an algorithm that performs at most @xmath4 more work than the classical algorithm , but runs in time @xmath5 on infinitely many graphs of constant outdegree on which the classical algorithm requires time  @xmath6 . </S>",
    "<S> second , we give an algorithm with running time @xmath7 , where @xmath8 is the outdegree of the game graph . note that this algorithm performs asymptotically better than the classical algorithm if @xmath9 . </S>"
  ]
}