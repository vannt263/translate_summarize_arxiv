{
  "article_text": [
    "in modern flp languages such as curry  @xcite or toy  @xcite programs are constructor based rewrite systems that may be non - terminating and non - confluent .",
    "semantically this leads to the presence of non - strict and non - deterministic functions .",
    "the semantics adopted for non - determinism is _ call - time choice _",
    "@xcite , informally meaning that in any reduction , all descendants of a given subexpression must share the same value .",
    "the semantic framework was proposed in  @xcite to accomodate this view of non - determinism , and is nowadays considered the standard semantics of flp . for the purpose of this paper ,",
    "the most relevant aspect of is a proof calculus devised to prove reduction statements of the form @xmath0 , meaning that @xmath1 is a possible ( partial ) value to which @xmath2 can be reduced using the program @xmath3 .",
    "we have chosen isabelle / hol as concrete logical framework for our formalization .",
    "using such a broadly used system is not only easier , but also more flexible and stable than developing language specific tools like has been done , e.g. , for logic programming  @xcite or functional programming  @xcite .    the remainder of the paper is organized as follows : sect .",
    "[ preliminaries ] contains some preliminaries about the framework , sect .  [ formalizing ]",
    "presents the isabelle theories developed to formalize , and sect .",
    "[ properties ] gives the mechanized proofs of some important properties of .",
    "finally , sect .",
    "[ conclusions ] summarizes some conclusions and points to future work .",
    "the isabelle code underlying the results presented here is available at https://gpd.sip.ucm.es/trac/gpd/wiki/gpdsystems/isabellecrwl .",
    "we consider a first - order signature @xmath4 , where @xmath5 and @xmath6 are two disjoint sets of _ constructor _ and defined _ function _ symbols respectively , each with associated arity .",
    "we write @xmath7 ( @xmath8 resp . ) for the set of constructor ( function ) symbols of arity @xmath9 .",
    "the set @xmath10 of _ expressions _ is inductively defined as @xmath11 where @xmath12 , @xmath13 and @xmath14 .",
    "the set @xmath15 of _ constructed terms _ ( or _ c - terms _ ) is defined like @xmath10 , but with @xmath16 restricted to @xmath7 ( so @xmath17 ) .",
    "the intended meaning is that @xmath10 stands for evaluable expressions , i.e. , expressions that can contain function symbols , while @xmath15 stands for data terms representing values .",
    "we will write @xmath18 for expressions and @xmath19 for c - terms .",
    "the set of variables occurring in an expression @xmath2 will be denoted as @xmath20 .",
    "we will frequently use _ one - hole contexts _ , defined as @xmath21 \\mid h(e_1,\\ldots,{\\cal c},\\ldots , e_n)\\ ] ] for @xmath13 .",
    "the application of a context @xmath22 to an expression @xmath2 , written @xmath23 $ ] , is defined inductively by @xmath24[e ] = e \\quad\\text{and}\\quad    h(e_1,\\ldots,{\\cal c},\\ldots , e_n)[e ] = h(e_1,\\ldots,{\\cal c}[e],\\ldots , e_n).\\ ] ]    the set _ subst _ of _ substitutions _ consists of finite mappings @xmath25 ( i.e. , mappings such that @xmath26 only for finitely many @xmath12 ) , which extend naturally to @xmath27 .",
    "we write @xmath28 for the application of @xmath29 to @xmath2 , and @xmath30 for the composition of substitutions , defined by @xmath31 .",
    "the domain of @xmath29 is defined as @xmath32 . in most cases",
    "we will use _ c - substitutions _",
    "@xmath33 , for which @xmath34 for all @xmath35 .",
    "a _ -program _ ( or simply a _ program _ ) is a set of rewrite rules of the form @xmath36 where @xmath37 , @xmath38 and @xmath39 is a linear @xmath9-tuple of c - terms , where linearity means that each variable occurs only once in @xmath39 .",
    "notice that we allow @xmath2 to contain _ extra variables _ , i.e. , variables not occurring in @xmath39 . -programs often allow also conditions in the program rules . however , -programs with conditions can be transformed into equivalent programs without conditions , therefore we consider only unconditional rules .      in order to accomodate non - strictness at the semantic level , we enlarge @xmath40 with a new constant constructor symbol @xmath41 . the sets @xmath42 , @xmath43 , @xmath44 , @xmath45 of partial expressions , etc . , are defined naturally .",
    "notice that @xmath41 does not appear in programs .",
    "partial expressions are ordered by the _",
    "approximation _ ordering @xmath46 defined as the least partial ordering satisfying @xmath47 \\sqsubseteq { \\cal c}[e ' ]    \\text { for all } e , e ' \\in exp_\\perp , { \\cal c } \\in cntxt\\ ] ] this partial ordering can be extended to substitutions : given @xmath48 we say @xmath49 if @xmath50 for all @xmath12 .    the semantics of a program @xmath51 is determined in by means of a proof calculus ( see fig .  [",
    "fig : crwl ] ) for deriving reduction statements @xmath52 , with @xmath53 and @xmath54 , meaning informally that @xmath1 is ( or approximates ) a _ possible value _ of @xmath2 , obtained by iterated reduction of @xmath2 using @xmath51 under call - time choice .",
    "rule ( bottom ) allows us to avoid the evaluation of any expression , in order to get a non - strict semantics .",
    "rules ( restricted reflexivity ) and ( decomposition ) allow us to reduce any variable to itself , and to decompose the evaluation of an expression whose root symbol is a constructor . rule ( outer reduction ) expresses that to evaluate a function call we must first evaluate its arguments to get an instance of a program rule , perform parameter passing ( by means of a @xmath45 @xmath29 ) and then reduce the instantiated right - hand side .",
    "the use of partial c - substitutions in or is essential to express call - time choice , as only single partial values are used for parameter passing .",
    "notice also that by the effect of @xmath29 in extra variables in the right - hand side of a rule can be replaced by any c - term , but not by any expression .",
    "the _ crwl - denotation _ of an expression @xmath53 is defined as @xmath55\\!]}^{\\mathcal{p}}=\\{t\\in cterm_\\perp \\mid \\mathcal{p } \\conscrwl e\\crwlto t\\}$ ] .",
    "we describe our formalization of in isabelle . the first step is to define elementary types for the syntactic elements .",
    "signat  fs  string  cs  string  varid  vi  string  exp  perp  var  varid  ap  signat  exp  list  subst  varid  exp  option  rule  exp  exp  program  rule  set    signatures are represented by a datatype that provides two constructors and to distinguish between constructor and function symbols .",
    "the type is used to represent variable identifiers , which will be employed to define substitutions .",
    "then the datatype is naturally defined following the inductive scheme of @xmath42 , therefore with this representation every expression is partial by default .    substitutions ( type ) are represented as partial functions from variable identifiers to expressions , using isabelle s type .",
    "hence the domain of a substitution will be the set of elements from for which returns some value different from .",
    "note that this representation does not ensure that domains of substitutions are finite .",
    "our proofs do not rely on this finiteness assumption .",
    "finally we represent a program rule as a pair of expressions , where the first element is considered the left - hand side of the rule and the second the right - hand side , and a program simply as a set of program rules .",
    "the set of valid programs is characterized by a predicate that checks whether the restrictions of left - linearity and constructor discipline are satisfied .",
    "we define a function for applying a substitution to an expression .",
    "the composition of substitutions is defined through a function .",
    "the following lemma ensures the correctness of this definition .",
    "subscompap   +  apsubst  apsubst  e  apsubst  substcomp  e    just as ml , the isabelle type system does not support subtyping , which could have been useful to represent the sets of c - terms and c - substitutions . instead , we define predicates and characterizing these subtypes . we prove the expected lemmas , such as that the composition of two c - substitutions is a c - substitution , or that the application of a c - substitution to a c - term yields a c - term .",
    "two key notions of have not yet been formalized : the approximation order @xmath56 , which will be used in the formulation of the polarity of , and the notion of one - hole context , which will be used in the compositionality .",
    "the following inductively defined predicate ( with concrete infix syntax ) models the approximation order .",
    "ordap  exp  exp  bool  b  perp  e  v  var  x  var  x  ap  size  es  size  es  all  i  size  es  esi  esi  ap  h  es  ap  h  es    rule asserts that holds for every ; rule is needed for to be reflexive ; finally rule ensures closedness under @xmath40-operations , and thus compatibility with context  @xcite , because is reflexive and transitive , as we will see .",
    "the following results state that our formulation of defines a partial order .",
    "ordaprefl  e  e  ordaptrans  e  e  e  e  e  e  ordapantisym  e  e  e  e  e  e  ordapless  e  e  e  e  e  e  exp  order  ordap  ordapless    contexts are represented as the datatype , defined as follows :    cntxt  hole  cperp  cvar  varid  cap  signat  cntxt  list    note that can not follow the inductive structure of @xmath57 with precision , because the type system of isabelle is not expressive enough to allow us to specify that only one of the arguments of will be a context and the others will be expressions .",
    "then our contexts are defined as expressions with possibly some holes inside",
    ". therefore the datatype represents contexts with any number of holes , even zero holes , and the function is defined so it puts the argument expression in every hole of the argument context . in order to characterize contexts with just one hole ,",
    "we define a function that returns the numbers of holes in a context . using it we can define define predicates and and prove the following lemmas .    noholeapdontcare  nohole  xc  apcon  e  xc  apcon  e  xc    onehole  onehole  cap  h  xcs  xc  ycs  zcs  xcs  ycs  xc  zcs  onehole  xc  ( c  set  ycs  zcs .",
    "nohole  c )      the  logic has been formalized through the inductive predicate with infix notation .",
    "the rules defining faithfully follow the inductive structure of the definition of  as it is presented in fig .",
    "[ fig : crwl ] .    clto  program  exp  exp  bool  bintro  prog  exp  perp  rrintro  prog  var  v  var  v  dcintro  size  es  size  ts  i  size  es  prog  esi  tsi   prog  ap  cs  c  es  ap  cs  c  ts  orintro  ap  fs  f  ps  r  prog  csubst  size  es  size  ps  i  size  es  prog  esi  apsubst  psi  prog  apsubst  r  t  prog  ap  fs  f  es  t    using we can easily define the  denotations in isabelle as follows .    den  program  exp  exp  set  den  p  e  t  p  e  t",
    "the first interesting property that we are proving about expresses that evaluation is _ closed under c - substitutions _ :",
    "reductions are preserved when terms are instantiated by c - substitutions .",
    "crwlclosedcsubst  prog  e  t  csubst  prog  apsubst  e  apsubst  t    the proof of this lemma proceeds by induction on the -proof of the hypothesis , therefore we will have one case for each  rule .",
    "the first three cases are proved automatically . however , to prove the case for rule isabelle needs some help from us .",
    "we need to prove @xmath58 and then let the simplifier apply the definition of . in the proof for that subgoal we used lemma to ensure that the c - substitution used for parameter passing composed with the c - substitution in the hypothesis yields another c - substitution , and lemma to guarantee the correct behaviour of the composition for those c - substitutions .",
    "note that for this result to hold no additional hypotheses about the program or the expressions involved are needed .",
    "in particular , this implies that the result holds even for programs that do not follow the constructor discipline or that have non left - linear rules .",
    "the isabelle proof clearly shows that the important ingredients are the use of c - substitutions for parameter passing and the reflexivity of  wrt .",
    "c - terms , expressed by lemma , which allows us to reduce to itself any expression coming from a premise .",
    "the second property that we address is the _ polarity of _ .",
    "this property is formulated by means of the approximation order and roughly says that if we can compute a value for an expression then we can compute a smaller value for a bigger expression . here",
    "we should understand the approximation order as an information order , in the sense that the bigger the expression , the more information it gives , and so more values can be computed from it .",
    "prog  e  t  e  e  t  t  prog  e  t  assms  induct  arbitrary  e  t    the idea of the proof is to construct a -proof for the conclusion from the -proof of the hypothesis , hence it is natural to proceed by induction on the structure of this proof ( method ) .",
    "the qualifier is used to generalize the assertion for any expressions and .",
    "the proof also relies on the following additional lemmas about the approximation order , which were proved automatically by isabelle .",
    "ordapperp  e  perp  e  perp  ordapvar  var  v  e  e  var  v  ordapvarconverse  e  var  v  e  perp  e  var  v  ordapap  ap  h  es  e  es  e  ap  h  es  size  es  size  es  all  i  size  es  esi  esi  ordapapconverse  e  ap  h  es  e  perp  es  e  ap  h  es  size  es  size  es  all  i  size  es  esi  esi    the inductive proof for theorem   again considers each rule in turn . in the case for we have , hence we just have to apply to get , and then use the  rule . regarding , as then , by we get that either or .",
    "the first case is trivial , and in the latter we just have to apply getting , which is enough for isabelle to finish the proof automatically .",
    "the case of is more complicated .",
    "again we obtain two cases for and a constructor application , by using lemma . while the first case is trivial , the second one requires some involved reasoning over the list of arguments , using the information we get from applying lemma .",
    "finally , the proof for is similar to the second case of the proof for , with a similar manipulation of the list of arguments , and the use of lemma to obtain the induction hypothesis for the arguments .",
    "once again we find that this proof does not require any hypothesis on the linearity or the constructor discipline of the program : this is indeed quite obvious because this property only talks about what happens when we replace some subexpression by .",
    "finally we will tackle the _ compositionality of _ , that says that if we take a context with just one hole and an expression , then the set of values for the expression put it that context will be the union of the set of values for the result of putting each value for the expression in that context .",
    "compcrwl  onehole  xc  den  p  apcon  e  xc  tden  p  e  den  p  apcon  t",
    "xc    we have proved the two set inclusions separately as auxiliary lemmas the proofs of these lemmas are quite laborious but essentially proceed by induction on the -proof in their hypothesis , using it to build a -proof for the statement in the conclusion . in these proofs ,",
    "lemma from subsect .",
    "[ subsect : ordapcontx ] is fundamental again , while theorem   requires the context to have just one hole , it does not assume the linearity or constructor discipline of the program .",
    "this came as a surprise to us , and initially made us doubt about the accuracy of our formalization of .",
    "but it turns out that although  is designed to work with -programs , that fulfil these restrictions , it can also be applied to general programs . for those programs some properties , such as the theorems , , and still hold , but other fundamental properties do not , in particular the strong adequacy results w.r.t .",
    "its operational counterparts of  @xcite .",
    "the point is that for those programs  does not deliver the `` intended semantics '' anymore . and",
    "this is not strange , because that semantics was intended with -programs in mind .",
    "for example , consider the non linear program @xmath59 . there is a -proof for the statement @xmath60 but this value can not be computed in any of the operational notions of  @xcite nor in any implementation of flp , in which the independence of the matching process of the arguments  derived from left - linearity of program rules  is assumed .",
    "it is also not very natural that @xmath61 could yield the value @xmath62 for the arguments @xmath62 and @xmath63 being different values , which implies that the semantics defined by  for non left - linear programs is pretty odd .",
    "but that is not a big problem , because we only care about the properties of  for the kind of programs it has been designed to work with . and if it enjoys some interesting properties for a bigger class of programs that is fine , because that nice properties will be inherited by the class of -programs .    on the other hand , for programs not following the constructor discipline",
    ", we will not even be able to have a matching for an argument of a rule which is not a constructor , because in the rule we have to reduce every argument of a function call to a value , which will be a c - term by lemma , and so could never be an instance of expression containing function symbols .",
    "thus , the rule could not be used for program rules not following the constructor discipline .",
    "this paper presented a formalization of the essentials of  @xcite , a well - known semantic framework for functional logic programming , in the interactive proof assistant isabelle / hol .",
    "we chose that particular logical framework for its stability and its extensive libraries .",
    "the isar proof language allowed us to structure the proofs so that they become quite elegant and readable , as can be observed by looking at the isabelle code .",
    "our formalization is generic with respect to syntax , and includes important auxiliary notions like substitutions or contexts .",
    "this is in contrast to previous work  @xcite in contrast , our paper focuses on developing the metatheory of the formalism , allowing us to obtain results that are more general and also more powerful : we formally prove essential properties of the paradigm like _ polarity _ or _ compositionality _ of the -semantics .",
    "we plan to extend our theories so that we will be able to reason about properties of concrete programs by deriving theorems that express verification conditions in the line of those stated in  @xcite .    while developing the formalization we realized an interesting fact not pointed out before : properties like polarity or compositionality do not depend on the constructor discipline and left - linearity imposed to programs . however",
    ", such requirements will certainly play an essential role when extending our work to formally relate the -semantics with operational semantics like the one developed in  @xcite , one of our intended subjects of future work .",
    "we think that could be interesting in several ways .",
    "first of all it would be a further step in the direction of challenge  3 of  @xcite , `` testing and animating wrt the semantics '' , because we would end up getting an interpreter of  during the process .",
    "we should then also formalize the evaluation strategy for the operational semantics , obtaining an isabelle proof of its optimality .",
    "finally there are precedents  @xcite of how the combination of a denotational and operational perspective is useful for general semantic reasoning in flp .",
    "b.  e. aydemir , a.  bohannon , m.  fairbairn , j.  n. foster , b.  c. pierce , p.  sewell , d.  vytiniotis , g.  washburn , s.  weirich , and s.  zdancewic .",
    "mechanized metatheory for the masses : the poplmark challenge . in j.",
    "hurd and t.  f. melham , editors , _ tphols _ , volume 3603 of _ lecture notes in computer science _ , pages 5065 .",
    "springer , 2005 .",
    "j.  cleva , j.  leach , and f.  lpez - fraguas .",
    "a logic programming approach to the verification of functional - logic programs . in _ proc .",
    "acm sigplan conf . on principles and practice of declarative programming ,",
    "ppdp04 _ , pages 919 .",
    "acm , 2004 .",
    "m.  de  mol , m.  c. j.  d. van eekelen , and m.  j. plasmeijer .",
    "theorem proving for functional programmers . in t.  arts and m.",
    "mohnen , editors , _ implementation of functional languages , 13th international workshop , ifl 2002 _ , volume 2312 of _ lecture notes in computer science _ , pages 5571 .",
    "springer , 2001 .",
    "j.  c. gonzlez - moreno , t.  hortal - gonzlez , f.  lpez - fraguas , and m.  rodrguez - artalejo . a rewriting logic for declarative programming . in _ proc .",
    "european symposium on programming ( esop96 ) _ , pages 156172 .",
    "springer lncs 1058 , 1996 .",
    "f.  lpez - fraguas , j.  rodrguez - hortal , and j.  snchez - hernndez . a simple rewrite notion for call - time choice semantics . in _ proc . principles and practice of declarative programming _ , pages 197208 .",
    "acm press , 2007 .",
    "f.  lpez - fraguas , j.  rodrguez - hortal , and j.  snchez - hernndez . rewriting and call - time choice : the ho case .",
    "in _ proc .",
    "9th international symposium on functional and logic programming ( flops08 ) _ , volume 4989 of _ lncs _ , pages 147162 .",
    "springer , 2008 ."
  ],
  "abstract_text": [
    "<S> modern functional - logic programming languages like toy or curry feature non - strict non - deterministic functions that behave under call - time choice semantics . a standard formulation for this semantics is the  logic , that specifies a proof calculus for computing the set of possible results for each expression . in this paper </S>",
    "<S> we present a formalization of that calculus in the isabelle / hol proof assistant . </S>",
    "<S> we have proved some basic properties of : closedness under c - substitutions , polarity and compositionality . </S>",
    "<S> we also discuss some insights that have been gained , such as the fact that left linearity of program rules is not needed for any of these results to hold . </S>"
  ]
}