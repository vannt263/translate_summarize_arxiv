{
  "article_text": [
    "efficient traditional static compilation of popular dynamic languages like javascript , python and php is very hard if not impossible . in particular , these languages present so many dynamic features which make all traditional static analyses used for program optimization very imprecise .",
    "therefore , practical implementations of dynamic languages should rely on dynamic information in order to produce an optimized version of the program . tracing just - in - time ( jit ) compilation ( tjitc",
    ") @xcite has emerged as a valuable implementation and optimization technique for dynamic languages ( and not only , e.g.  java @xcite ) .",
    "for instance , the facebook hiphop virtual machine for php and the v8 javascript engine of google chrome use some form of tracing compilation  @xcite .",
    "the mozilla firefox javascript engine used to have a tracing engine , called tracemonkey , which has been later substituted by whole - method just - in - time compilation engines ( initially jgermonkey and then ionmonkey ) @xcite .      tracing jit compilers leverage runtime profiling of programs",
    "to detect and record often executed paths , called hot paths , and then they optimize and compile only these paths at runtime .",
    "a path is a linear sequence ( i.e. , no loops or join points are allowed ) of instructions through the program .",
    "profiling may also collect information about the values that the program variables may assume during the execution of that path , which is then used to specialize / optimize the code of the hot path .",
    "of course , this information is not guaranteed to hold for all the subsequent executions of the hot path .",
    "since optimizations rely on that information , the hot path is augmented with guards that check the profiled conditions , such as , for example , variable types and constant variables .",
    "when a guard fails , execution jumps back to the old , non - optimized code .",
    "the main hypotheses of tracing compilers , confirmed by the practice , are : ( i )  loop bodies are the most interesting code to optimize , so they only consider paths inside program loops ; and ( ii )  optimizing straight - line code is easier than a whole - method analysis ( involving loops , goto , _ etc .",
    "_ ) .    hence , tracing jit compilers look quite different than traditional compilers",
    "these differences raise some natural questions on trace compilation : ( i )  what is a viable formal model , which is generic yet realistic enough to capture the behavior of real optimizers ?",
    "( ii )  which optimizations are sound ?",
    "( iii )  how can one prove their soundness ? in this paper we answer these questions .    our formal model is based on program trace semantics  @xcite and abstract interpretation @xcite .",
    "hot path detection is modeled just as an abstraction of the trace semantics of the program , which only retains : ( i )  the sequences of program points which are repeated more than some threshold ; ( ii )  an abstraction of the possible program stores , e.g. , the type of the variables instead of their concrete values . as a consequence ,",
    "a hot path does not contain loops nor join points .",
    "furthermore , in the hot path , all the correctness conditions ( i.e. , guards ) are explicit , for instance before performing integer addition , we should check that the operands are integers .",
    "if the guard condition is not satisfied then the execution leaves the hot path , reverting to the non - optimized code .",
    "guards are essentially elements of some abstract domain , which is then left as a parameter in our model .",
    "the hot path is then optimized using standard compilation techniques ",
    "we only require the optimization to be sound .",
    "we define the correctness of the residual ( or extracted ) program in terms of an abstraction of its trace semantics : the residual program is correct if it is indistinguishable , up to some abstraction of its trace semantics , from the original program .",
    "examples of abstractions are the program store at the exit of a method , or the stores at loop entry and loop exit points .",
    "this paper puts forward a formal model of tjitc whose key features are as follows :    1 .",
    "we provide the first model of tracing compilation based on abstract interpretation of trace semantics of programs .",
    "we provide a more general and realistic framework than the model of tjitc by based on program bisimulations : we employ a less restrictive correctness criterion that enables the correctness proof of practically implemented optimizations ; hot paths can be annotated with runtime information on the stores , notably type information ; optimized hot loops can be re - entered .",
    "3 .   we formalize and prove the correctness of type specialization of hot paths .",
    "our model focusses on source - to - source program transformations and optimizations of a low level imperative language with untyped global variables , which may play the role of intermediate language of some virtual machine .",
    "our starting point is that program optimizations can be seen as transformations that lose some information on the original program , so that optimizations can be viewed as approximations and in turn can be formalized as abstract interpretations .",
    "more precisely , we rely on the insight by that a program source can be seen as an abstraction of its trace semantics , i.e.  the set of all possible execution sequences , so that a source - to - source optimization can be viewed as an abstraction of a transform of the program trace semantics . in our model ,",
    "soundness of program optimizations is defined as program equivalence w.r.t .",
    "an observational abstract interpretation of the program trace semantics . here",
    ", an observational abstraction induces a correctness criterion by describing what is observable about program executions , so that program equivalence means that two programs are indistinguishable by looking only at their observable behaviors .",
    "a crucial part of tracing compilation is the selection of the hot path(s ) to optimize .",
    "this choice is made at runtime based on program executions , so it can be seen once again as an abstraction of trace semantics .",
    "here , a simple trace abstraction selects cyclic instruction sequences , i.e. loop paths , that appear at least @xmath0 times within a single execution trace .",
    "these instruction sequences are recorded together with some property of the values assumed by program variables at that point , which is represented as an abstract store belonging to a suitable store abstraction , which in general depends on the successive optimizations to perform .",
    "a program optimization can be seen as an abstraction of a semantic transformation of program execution traces , as described by .",
    "the advantage of this approach is that optimization properties , such as their correctness , are easier to prove at a semantic level .",
    "the optimization itself can be defined on the whole program or , as in the case of real tracing jit compilers , can be restricted to the hot path .",
    "this latter restriction is achieved by transforming the original program so that the hot path is extracted , i.e.  made explicit : the hot path is added to the program as a path with no join points that jumps back to the original code when execution leaves it .",
    "a guard is placed before each command in this hot path that checks if the necessary conditions , as selected by the store abstraction , are satisfied .",
    "a program optimization can then be confined to the hot path only , making it linear , by ignoring the parts of the program outside it .",
    "the guards added to the hot path allows us to retain precision .",
    "we apply our tjitc model to type specialization .",
    "type specialization is definitely the key optimization for dynamic languages such as javascript @xcite , as they make available generic operations whose execution depends on the type of runtime values of their operands .",
    "moreover , as a further application of our model , we consider the constant variable folding optimization along hot paths , which relies on the standard constant propagation abstract domain @xcite .",
    "a formal model for tracing jit compilation has been put forward by at popl symposium .",
    "it is based on operational bisimulation @xcite to describe the equivalence between source and optimized programs .",
    "we show how this model can be expressed within our framework through the following steps : guo and palsberg s language is compiled into ours ; we then exhibit an observational abstraction which is equivalent to guo and palsberg s correctness criterion ; finally , after some minor changes that address a few differences in path selection , the transformations performed on the source program turn out to be the same .",
    "our framework overcomes some significant limitations in guo and palsberg s model .",
    "the bisimulation equivalence model used in  @xcite implies that the optimized program has to match every change to the store made by the original program , whereas in practice we only need this match to hold in certain program points and for some variables , such as in output instructions .",
    "this limits the number of real optimizations that can be modeled in this framework .",
    "for instance , dead store elimination is proven unsound in @xcite , while it is implemented in actual tracing compilers ( * ? ? ?",
    "* section  5.1 ) .",
    "furthermore , their formalization fails to model some important features of actual tjitc implementation : ( i )  traces are mere linear paths of instructions , i.e. , they can not be annotated with store properties ; ( ii )  hot path selection is completely non - deterministic , since they do not model a selection criterion ; and , ( iii )  once execution leaves an optimized hot path the program will not be able to re - enter it .",
    "it is also worth citing that abstract interpretation of program trace semantics roots at the foundational work by cousot @xcite and has been widely used as a technique for defining a range of static program analyses @xcite . also , describes various program optimizations as the trace abstractions they preserve . in the cousot and cousot terminology  @xcite ,",
    "rival s approach corresponds to offline transformations whereas tracing compilation is an online transformation .",
    "the rest of the paper is organized as follows .",
    "sections  [ language ] and  [ abs - sec ] contain some necessary background : the language considered in the paper and its operational trace semantics are defined in section  [ language ] , while section  [ abs - sec ] recalls some basic notions of abstract interpretation , in particular for defining abstract domains of program stores .",
    "hot paths are formally defined in section  [ hp - sect ] as a suitable abstract interpretation of program traces , while section  [ trace - ext - sec ] defines the program transform for extracting a given hot path .",
    "the correctness of the hot path extraction transform is defined and proved correct in section  [ obs ] , which also introduces in subsection  [ chpo - sec ] program optimizations along hot paths together with a methodology for proving their correctness .",
    "section  [ type_specialization ] applies our model of hot path optimization to type specialization of untyped program commands , while section  [ cf - sec ] describes an application to constant variable folding along hot paths .",
    "nested hot paths and the corresponding program transform for their extraction are the subject of section  [ mte - sec ] .",
    "section  [ gp - sec ] provides a thorough formal comparison of our model with s framework for tracing compilation",
    ". finally , section  [ concl - sec ] concludes , also discussing some directions for future work .",
    "this is an expanded and revised version of the popl symposium article @xcite including all the proofs .",
    "given a finite set @xmath1 of objects , we will use the following notation concerning sequences : @xmath2 is the empty sequence ; @xmath3 is the set of nonempty finite sequences of objects of @xmath1 ; @xmath4 ; if @xmath5 then @xmath6 denotes the length of @xmath7 ; indices of objects in a nonempty sequence @xmath8 start from @xmath9 and thus range in the interval @xmath10 $ ] ; if @xmath8 and @xmath11 then @xmath12 ( or @xmath13 ) denotes the @xmath14-th object in @xmath7 ; if @xmath15 and @xmath16 then @xmath17 } \\in x^*$ ] denotes the subsequence @xmath18 , which is therefore the empty sequence if @xmath19 , while if @xmath20 then @xmath21 denotes the suffix @xmath22 , which is the empty sequence when @xmath23 .",
    "if @xmath24 is any function then its collecting version @xmath25 is defined pointwise by @xmath26 , and when clear from the context , by a slight abuse of notation , it is sometimes denoted by @xmath27 itself .",
    "we consider a basic low level language with untyped global variables , a kind of elementary dynamic language , which is defined through the notation used in @xcite .",
    "program commands range in @xmath28 and consist of a labeled action which specifies a next label ( @xmath29 is the undefined label , where the execution becomes stuck : it is used for defining final commands ) .",
    "@xmath30    for any command @xmath31 , we use the following notation : @xmath32 commands @xmath33 whose action is a boolean expression are called conditionals .",
    "a program @xmath34 is a ( possibly infinite , at least in theory ) set of commands . in order to be well - formed ,",
    "if a program @xmath35 includes a conditional @xmath36 then @xmath35 must also include a unique complement conditional @xmath37 , which is denoted by @xmath38 or @xmath39 , where @xmath40 is taken to be equal to @xmath41 , so that @xmath42 .",
    "the set of well - formed programs is denoted by @xmath43 . in our examples ,",
    "programs @xmath35 will be deterministic , i.e. , for any @xmath44 such that @xmath45 : ( 1 )  if @xmath46 then @xmath47 ; ( 2 ) if @xmath48 then @xmath49 . we say that two programs @xmath50 and @xmath51 are equal up to label renaming , denoted by @xmath52 , when there exists a suitable renaming for the labels of @xmath50 that makes @xmath50 equal to @xmath51 .",
    "the language semantics relies on values ranging in @xmath53 , possibly undefined values ranging in @xmath54 , truth values in @xmath55 , possibly undefined truth values ranging in @xmath56 and type names ranging in @xmath57 , which are defined as follows : @xmath58    \\operatorname{bool}{\\triangleq}\\ { \\textit{true},\\ , \\textit{false } \\}\\qquad \\operatorname{bool_{\\mathrm{u}}}{\\triangleq}\\ { \\textit{true},\\ , \\textit{false},{{\\textit{undef}}}\\}\\\\[5pt ]    \\operatorname{\\mathrm{types}}{\\triangleq}\\{\\operatorname{int } ,   \\operatorname{string } , \\operatorname{undef } , { { \\top_{\\!\\mathrm{t } } } } , { { \\bot_{\\!\\mathrm{t}}}}\\ }   \\end{array}\\ ] ] where @xmath59 is a nonempty finite set of characters and @xmath60 is a distinct symbol .",
    "the mapping @xmath61 provides the type of any possibly undefined value : @xmath62 the type names @xmath63 and @xmath64 will be used in section  [ type_specialization ] as , respectively , top and bottom type , that is , subtype and supertype of all types .",
    "@xmath65      & { \\mathbf{b } } : \\operatorname{bexp}{\\rightarrow}\\operatorname{store}{\\rightarrow}\\operatorname{bool_{\\mathrm{u}}}\\\\      & { \\mathbf{b}}\\grasse{{\\text{\\lstinline$tt$}}}\\rho { \\triangleq}\\textit{true}\\quad { \\mathbf{b}}\\grasse{{\\text{\\lstinline$ff$}}}\\rho { \\triangleq}\\textit{false}\\\\      & { \\mathbf{b}}\\grasse{e_1 \\leq e_2}\\rho { \\triangleq}\\begin{cases }         { \\mathbf{e}}\\grasse{e_1}\\rho \\leq_{\\mathbb{z } } { \\mathbf{e}}\\grasse{e_2}\\rho &        \\text{if }   { \\mathit{type}}({\\mathbf{e}}\\grasse{e_i}\\rho)=\\operatorname{int}\\\\         \\exists \\sigma\\in \\operatorname{string}.\\ , { \\mathbf{e}}\\grasse{e_2}\\rho = ( { \\mathbf{e}}\\grasse{e_1}\\rho)\\!\\cdot\\ ! \\sigma &        \\text{if }   { \\mathit{type}}({\\mathbf{e}}\\grasse{e_i}\\rho)=\\operatorname{string}\\\\         { { \\textit{undef } } } &        \\text{otherwise }              \\end{cases } \\\\      & { \\mathbf{b}}\\grasse{\\neg b}\\rho { \\triangleq}\\neg { \\mathbf{b}}\\grasse{b}\\rho \\quad      { \\mathbf{b}}\\grasse{b_1 \\wedge b_2}\\rho { \\triangleq}{\\mathbf{b}}\\grasse{b_1}\\rho \\wedge { \\mathbf{b}}\\grasse{b_2}\\rho\\\\[10pt ]      & { \\mathbf{a } } : \\mathbb{a } { \\rightarrow}\\operatorname{store}{\\rightarrow}\\operatorname{store}\\cup \\,\\{\\bot\\}\\\\      & { \\mathbf{a}}\\grasse{{\\text{\\lstinline$skip$}}}\\rho { \\triangleq}\\rho\\\\       & { \\mathbf{a}}\\grasse{x : = e}\\rho { \\triangleq}\\begin{cases } \\rho[x/{\\mathbf{e}}\\grasse{e}\\rho ] & \\text{if } { \\mathbf{e}}\\grasse{e}\\rho \\neq   { { \\textit{undef}}}\\\\                                              \\bot & \\text{if } { \\mathbf{e}}\\grasse{e}\\rho =   { { \\textit{undef}}}\\end{cases}\\\\        & { \\mathbf{a}}\\grasse{b}\\rho { \\triangleq}\\begin{cases } \\rho & \\text{if } { \\mathbf{b}}\\grasse{b}\\rho = \\textit{true}\\\\                                              \\bot & \\text{if } { \\mathbf{b}}\\grasse{b}\\rho \\in \\{\\textit{false},{{\\textit{undef}}}\\ }                                              \\end{cases }       \\end{aligned}\\ ] ]    let @xmath66 denote the set of possible stores on variables in @xmath67 , where @xmath68 means that the store @xmath69 is not defined on a program variable @xmath70 . hence , let us point out that the symbol @xmath60 will be used to represent both store undefinedness and a generic error when evaluating an expression ( e.g. , additions and comparisons between integers and strings ) , two situations which are not distinguished in our semantics .",
    "a store @xmath71 will be denoted by @xmath72_{\\rho(x)\\neq { { \\textit{undef}}}}$ ] , thus omitting undefined variables , while @xmath73 $ ] will denote the totally undefined store .",
    "if @xmath74 then @xmath75 denotes the set of variables in @xmath67 that occur in @xmath35 , so that @xmath76 is the set of possible stores for @xmath35 .",
    "the semantics of expressions @xmath77 , boolean expressions @xmath78 and program actions @xmath79 is standard and goes as defined in fig .",
    "[ fig : semantics ] .",
    "let us remark that :    * the binary function @xmath80 denotes integer addition , @xmath81 denotes integer comparison , while @xmath82 is string concatenation ; * logical negation and conjunction in @xmath56 are extended in order to handle @xmath60 as follows : @xmath83 and @xmath84 ; * @xmath85 $ ] denotes a store update for the variable @xmath86 with @xmath87 ; * the distinct symbol @xmath88 is used to denote the result of : @xmath89 when the evaluation of the expression @xmath90 for @xmath69 generates an error ; @xmath91 when the evaluation of the boolean expression @xmath41 for @xmath69 is either @xmath92 or generates an error .    with a slight abuse of notation we also consider the collecting versions of the semantic functions in fig .",
    "[ fig : semantics ] , which are defined as follows : @xmath93    & { \\mathbf{b } } : \\operatorname{bexp}{\\rightarrow}\\wp(\\operatorname{store } ) { \\rightarrow}\\wp(\\operatorname{store } )   \\\\    & { \\mathbf{b}}\\grasse{b}s { \\triangleq}\\{\\rho \\in s ~|~ { \\mathbf{b}}\\grasse{b}\\rho = \\textit{true}\\}\\\\[7.5pt ]     & { \\mathbf{a } } : \\mathbb{a } { \\rightarrow}\\wp(\\operatorname{store } ) { \\rightarrow}\\wp(\\operatorname{store } )   \\\\   & { \\mathbf{a}}\\grasse{a}s{\\triangleq}\\{{\\mathbf{a}}\\grasse{a}\\rho ~|~ \\rho \\in s,\\ , { \\mathbf{a}}\\grasse{a}\\rho \\in \\operatorname{store}\\ }       \\end{array}\\ ] ] let us point out that , in the above collecting versions , if @xmath94 then @xmath95 and @xmath96 , while if @xmath97 then @xmath98 and @xmath99 .",
    "generic program states are pairs of stores and commands : @xmath100 .",
    "we extend the previous functions @xmath101 , @xmath102 and @xmath103 to be defined on states , meaning that they are defined on the command component of a state . also , @xmath104 and @xmath105 return , respectively , the store and the command of a state @xmath106 .",
    "the transition semantics @xmath107 is a relation between generic states defined as follows : @xmath108    if @xmath35 is a program then @xmath109 is the set of possible states of @xmath35 . given @xmath74 , the program transition relation @xmath110 between states of @xmath35 is defined as : @xmath111    let us remark that , according to the above definition , if @xmath112 , @xmath113 and @xmath114 are all commands in @xmath35 and @xmath115 then we have that @xmath116 .",
    "a state @xmath117 is stuck for @xmath35 when @xmath118 .",
    "let us point that :    * if the conditional command of a state @xmath119 is such that @xmath120 then @xmath106 is stuck for @xmath35 because there exists no store @xmath121 .",
    "* if the command of a state @xmath122 has the undefined label @xmath29 as next label then @xmath106 is stuck for @xmath35 .",
    "* we have a stuck state @xmath106 when an error happens .",
    "e.g. , this is the case for an undefined evaluation of an addition as in @xmath123 , l : x:=y+z{\\rightarrow}l'}$ ] and for an undefined evaluation of a boolean expression as in @xmath123 , l : y\\leq x { \\rightarrow}l'}$ ] .    programs typically have an entry point , and this is modeled through a distinct initial label @xmath124 from which execution starts .",
    "@xmath125 denotes the set of possible initial states for @xmath35 .",
    "a partial trace is any nonempty finite sequence of generic program states which are related by the transition relation @xmath126 .",
    "hence , the set @xmath127 of partial traces is defined as follows : @xmath128 the partial trace semantics of @xmath74 is in turn defined as follows : @xmath129    a trace @xmath130 is complete if for any state @xmath117 , @xmath131 and @xmath132 .",
    "observe that @xmath133 contains all the possible partial traces of @xmath35 , complete traces included .",
    "let us remark that a trace @xmath130 does not necessarily begin with an initial state , namely it may happen that @xmath134 .",
    "traces of @xmath35 starting from initial states are denoted by @xmath135 also , a complete trace @xmath136 such that @xmath137 corresponds to a terminating run of the program @xmath35 .",
    "[ example - init]let us consider the program @xmath138 below written in some while - language :    its translation as a program @xmath35 in our language is given below , with @xmath139 , where , with a little abuse , we assume an extended syntax that allows expressions like @xmath140 . @xmath141    its trace semantics from initial states @xmath142 includes the following complete traces , where @xmath73 $ ] is the initial totally undefined store . @xmath143,c_0}\\tuple{[x/0],c_1^c } \\\\ \\tuple{[\\,],c_0}\\tuple{[x/0],c_1}\\tuple{[x/0],c_2}\\tuple{[x/1],c_3 } \\\\",
    "\\tuple{[\\,],c_0}\\tuple{[x/0],c_1}\\tuple{[x/0],c_2}\\tuple{[x/1],c_3^c}\\tuple{[x/1],c_1^c}\\\\   \\;\\cdots\\\\    \\;\\cdots\\\\ \\tuple{[\\,],c_0}\\tuple{[x/0],c_1}\\tuple{[x/0],c_2}\\tuple{[x/1],c_3^c}\\tuple{[x/1],c_1}\\cdots \\tuple{[x/21],c_4}\\tuple{[x/24],c_1}\\\\ \\tuple{[\\,],c_0}\\tuple{[x/0],c_1}\\tuple{[x/0],c_2}\\tuple{[x/1],c_3^c}\\tuple{[x/1],c_1}\\cdots \\tuple{[x/21],c_4}\\tuple{[x/24],c_1^c}\\tuple{[x/24],c_5 } \\end{array } } \\ ] ] observe that the last trace corresponds to a terminating run of @xmath35 .",
    "in standard abstract interpretation  @xcite , abstract domains , also called abstractions , are specified by galois connections / insertions ( gcs / gis for short ) or , equivalently , adjunctions .",
    "concrete and abstract domains , @xmath144 and @xmath145 , are assumed to be complete lattices which are related by abstraction and concretization maps @xmath146 and @xmath147 such that , for all @xmath148 and @xmath149 , @xmath150 .",
    "a gc is a gi when @xmath151 .",
    "it is well known that a join - preserving @xmath152 uniquely determines , by adjunction , @xmath153 as follows : @xmath154 ; conversely , a meet - preserving @xmath153 uniquely determines , by adjunction , @xmath152 as follows : @xmath155 .",
    "let @xmath156 be some concrete monotone function  for simplicity , we consider 1-ary functions  and let @xmath157 be a corresponding monotone abstract function defined on some abstraction @xmath158 related to @xmath159 by a gc .",
    "then , @xmath160 is a correct abstract interpretation of @xmath27 on @xmath158 when @xmath161 holds , where @xmath162 denotes the pointwise ordering between functions .",
    "moreover , the abstract function @xmath163 is called the best correct approximation of @xmath27 on @xmath158 because any abstract function @xmath160 is correct iff @xmath164 .",
    "hence , for any @xmath158 , @xmath165 plays the role of the best possible approximation of @xmath27 on the abstraction @xmath158 .      as usual in abstract interpretation @xcite",
    ", a store property is modeled by some abstraction @xmath166 of @xmath167 which is formalized through a galois connection : @xmath168    given a program @xmath35 , when @xmath166 is viewed as an abstraction of @xmath169 we emphasize it by adopting the notation @xmath170 .",
    "a store abstraction @xmath170 also induces a state abstraction @xmath171 and , in turn , a trace abstraction defined by @xmath172 .",
    "nonrelational store abstractions ( i.e. , relationships between program variables are not taken into account ) can be easily designed by a standard pointwise lifting of some value abstraction .",
    "let @xmath173 be an abstraction of sets of possibly undefined values in @xmath174 as formalized by a galois connection @xmath175 the abstract domain @xmath173 induces a nonrelational store abstraction @xmath176 where @xmath162 is the pointwise ordering induced by @xmath177 : @xmath178 iff for all @xmath70 , @xmath179 .",
    "hence , the bottom and top abstract stores are , respectively , @xmath180 and @xmath181 .",
    "the abstraction map @xmath182 is defined as follows : @xmath183 the corresponding concretization map @xmath184 is defined , as recalled in section  [ intro_abs_int ] , by adjunction from the abstraction map @xmath185 and it is easy to check that it can be given as follows : @xmath186 let us observe that :    * @xmath187 because @xmath188 always holds in a gc ; * @xmath189\\ } ) = \\lambda x.{\\alpha_{\\mathit{value}}}(\\{{{\\textit{undef}}}\\})$ ] ; * if @xmath190 , @xmath191 and @xmath192 then @xmath193 ; * if @xmath194 then @xmath195\\}$ ] .",
    "[ cp - ex]the constant propagation ( see @xcite ) lattice @xmath196 is depicted below .",
    "= [ shorten > = -2pt , shorten < = -2pt ] ( 0,0 ) node[name=1 ] @xmath197 ; ( -2.5,1 ) node[name=2 ] @xmath198 ; ( -2,1 ) node[name=3 ] @xmath199 ; ( -1,1 ) node[name=4 ] @xmath200 ; ( 0,1 ) node[name=5 ] @xmath201 ; ( 1,1 ) node[name=6 ] @xmath202 ; ( 2,1 ) node[name=7 ] @xmath203 ; ( 2.5,1 ) node[name=8 ] @xmath198 ; ( 0,2 ) node[name=9 ] @xmath204 ;    \\(1 )  ( 3 ) ; ( 1 )  ( 4 ) ; ( 1 )  ( 5 ) ; ( 1 )  ( 6 ) ; ( 1 )  ( 7 ) ; ( 9 )  ( 3 ) ; ( 9 )  ( 4 ) ; ( 9 )  ( 5 ) ; ( 9 )  ( 6 ) ; ( 9 )  ( 7 ) ;    where @xmath205 is any enumeration of @xmath54 , thus @xmath60 is included . abstraction @xmath206 and concretization @xmath207 functions are defined as follows : @xmath208 and give rise to a gi @xmath209 .",
    "the corresponding nonrelational store abstraction is denoted by @xmath210 , where @xmath211 and @xmath212 denote the abstraction and concretization maps .",
    "for example , for @xmath213 and omitting the bindings @xmath214 also in abstract stores , we have that : @xmath215 , [ x/2 , y/\\mathtt{bar}]\\ } ) = [ x/2,y/\\top , z/\\top ] , \\\\[5pt ] \\gamma_{\\operatorname{cp } } ( [ x/2,y/\\top , w/\\mathtt{foo } ] ) =   \\{\\rho\\in \\operatorname{store}~|~",
    "\\rho(x ) = 2 , \\rho(y)\\in \\operatorname{value_{\\!\\,\\mathrm{u } } } , \\rho(z)={{\\textit{undef } } } , \\rho(w)=\\mathtt{foo}\\ } , \\\\[5pt ] \\gamma_{\\operatorname{cp } } ( [ x/2,y/\\top , w/\\bot ] ) = \\varnothing .",
    "\\qquad \\qed \\end{array}\\ ] ]",
    "a loop path is a sequence of program commands which is repeated in some execution of a program loop , together with a store property which is valid at the entry of each command in the path .",
    "a loop path becomes _ hot _ when , during the execution , it is repeated at least a fixed number @xmath0 of times . in a tjitc , hot path selection is performed by a loop path monitor that also records store properties ( see , e.g. , @xcite ) . here , hot path selection is not operationally defined ,",
    "it is instead semantically modeled as an abstraction map over program traces , i.e. , program executions .",
    "given a program @xmath35 and therefore its trace semantics @xmath133 , we first define a mapping @xmath216 that returns all the loop paths in some execution trace of @xmath35 .",
    "more precisely , a loop path is a proper substring ( i.e. , a segment ) @xmath217 of a program trace @xmath7 such that :    1 .",
    "the successor command in @xmath7 of the last state in @xmath217 exists and coincides with the command    or its complement , when this is the last loop iteration    of the first state in @xmath217 ; 2 .",
    "there is no other such command within @xmath217 ( otherwise the sequence @xmath217 would contain multiple iterations ) ; 3 .",
    "the last state of @xmath217 performs a backward jump in the program @xmath35 .",
    "to recognize backward jumps , we consider a topological order on the control flow graph of commands in @xmath35 , denoted by @xmath218 .",
    "this leads to the following formal definition : @xmath219.\\ ,         c_{k } \\not\\in\\ { c_{i},cmpl(c_{i})\\ }         \\big\\}.   \\end{gathered}\\ ] ]    let us remark that a loop path @xmath220 may contain some sub - loop path , namely it may happen that @xmath221 so that some commands @xmath222 , with @xmath223 $ ] , may occur more than once in @xmath224 ; for example , this could be the case of a while loop whose body includes a nested while loop .",
    "we abuse notation by using @xmath225 to denote a map @xmath226 which `` abstracts '' a program trace @xmath217 into @xmath227 by abstracting the sequence of stores occurring in @xmath217 : @xmath228 given a static integer parameter @xmath229 , we define a function @xmath230 which returns the set of @xmath166-abstracted loop paths appearing at least @xmath0 times in some program trace . in order to count the number of times a loop path appears within a trace",
    "we need an auxiliary function @xmath231 such that @xmath232 yields the number of times an abstract path @xmath217 occurs in an abstract trace @xmath7 : @xmath233 hence , @xmath234 can be defined as follows : @xmath235    finally , an abstraction map @xmath236 collects the results of applying @xmath234 to a set of traces : @xmath237    a @xmath0-hot path @xmath238 in a program @xmath35 is therefore any @xmath239 and is compactly denoted as @xmath240 .",
    "let us observe that if the hot path corresponds to the body of some while loop then its first command @xmath241 is a conditional , namely @xmath241 is the boolean guard of the while loop .",
    "we define the successor function @xmath242 for indices in a hot path @xmath243 as follows : @xmath244 . for a @xmath0-hot path @xmath245 , for any @xmath246 $ ] ,",
    "if @xmath247 is a conditional command @xmath248 then throughout the paper its complement @xmath249 will be also denoted by @xmath250 .",
    "[ ex - zero ] let us consider the program @xmath35 in example  [ example - init ] and a trivial one - point store abstraction @xmath251 , where all the stores are abstracted to the same abstract store @xmath204 , i.e. , @xmath252 . here , we have two @xmath253-hot paths in @xmath35 , that is , it turns out that @xmath254 where : @xmath255 hp_2=\\tuple { & \\top , c_1\\equiv l_1:x\\leq 20 { \\rightarrow}l_2 , \\top , c_2\\equiv l_2 : x:=x+1 { \\rightarrow}l_3 , \\\\ &",
    "\\top , c_3\\equiv l_3 : ( x\\%3 = 0 ) { \\rightarrow}l_4 , \\top , c_4\\equiv x:=x+3 { \\rightarrow}l_1}.\\end{aligned}\\ ] ] therefore , the hot paths @xmath256 and @xmath257 correspond , respectively , to the cases where the boolean test @xmath258 fails and succeeds .",
    "observe that the maximal sequence of different values assumed by the program variable @xmath86 is as follows : @xmath259 hence , if @xmath7 is the complete terminating trace of @xmath35 in example  [ example - init ] then it turns out that @xmath260 and @xmath261 .",
    "for any abstract store @xmath262 , a corresponding boolean expression denoted by @xmath263 @xmath264 is defined ( where the notation @xmath265 should hint at an expression which is induced by the abstract store @xmath148 ) , whose semantics is as follows : for any @xmath266 , @xmath267 in turn , we also have program actions @xmath268 @xmath269 such that : @xmath270    by --    ( 4,22.5 ) node@xmath271 ; ( 4,21.5 )  ( 4,20 ) ; ( 4.75,20.5 ) node @xmath272 ; ( 4,18 )  ( 2,19 )  ( 4,20 )  ( 6,19 )  ( 4,18 ) ; ( 4,19 ) node@xmath273 ; ( 6,19 )  ( 7.5,19 ) ; ( 7,19.5 ) node @xmath274 ; ( 4,18 )  ( 4,16 ) ; ( 4.75,16.5 ) node @xmath275 ; ( 2,14 ) rectangle + ( 4,2 ) ; ( 4,15 ) node@xmath276 ; ( 4,14 )  ( 4,12.5 ) ; ( 4.75,13 ) node @xmath277 ; ( 4,12 ) node@xmath278 ; ( 4,10.5 )  ( 4,9 ) ; ( 4.75,9.5 ) node @xmath279 ; ( 2,7 ) rectangle + ( 4,2 ) ; ( 4,8 ) node@xmath280 ; ( 4,7 )  ( 4,6 )  ( 0,6 )  ( 0,21 ) ; ( 0,21 )  ( 4,21 ) ;    ( 18,28.5 ) node@xmath278 ; ( 18,27.5 )  ( 18,26 ) ; ( 18.75,26.5 ) node @xmath272 ; ( 18,24 )  ( 16,25 )  ( 18,26 )  ( 20,25 ) ",
    "( 18,24 ) ; ( 18,25 ) node@xmath281 ; ( 20,25 )  ( 26,25 ) ; ( 26,25 ) ",
    "( 26,24 ) ; ( 26.75,24.5 ) node @xmath282 ; ( 26,22 )  ( 24,23 ) ",
    "( 26,24 ) ",
    "( 28,23 ) ",
    "( 26,22 ) ; ( 26,23 ) node@xmath273 ; ( 26,22 )  ( 26,17 ) ; ( 28,23 ) ",
    "( 29.5,23 ) ; ( 29,23.5 ) node @xmath274 ; ( 18,24 )  ( 18,22 ) ; ( 18.75,22.5 ) node @xmath283 ; ( 18,20 ) ",
    "( 16,21 ) ",
    "( 18,22 ) ",
    "( 20,21 ) ",
    "( 18,20 ) ; ( 18,21 ) node@xmath273 ; ( 20,21 )  ( 21.5,21 ) ; ( 21,21.5 ) node @xmath274 ; ( 18,20 )  ( 18,18 ) ; ( 18.75,18.5 ) node @xmath284 ;    ( 18,16 ) ",
    "( 16,17 ) ",
    "( 18,18 ) ",
    "( 20,17 ) ",
    "( 18,16 ) ; ( 18,17 ) node@xmath285 ; ( 20,17 )  ( 26,17 ) ; ( 26,17 ) ",
    "( 26,16 ) ; ( 26.75,16.5 ) node @xmath275 ; ( 24,14 ) rectangle + ( 4,2 ) ; ( 26,15 ) node@xmath276 ; ( 26,14 )  ( 26,12.5 ) ; ( 26.75,13 ) node @xmath277 ; ( 26,12 ) node @xmath278 ;    ( 18,16 )  ( 18,14 ) ; ( 18.75,14.5 ) node @xmath286 ; ( 16,12 ) rectangle + ( 4,2 ) ; ( 18,13 ) node@xmath276 ; ( 18,12 )  ( 18,10.5 ) ; ( 18.75,11 ) node @xmath287 ; ( 18,10 ) node@xmath278 ; ( 18,8.5 )  ( 18,7 ) ; ( 18.75,7.5 ) node @xmath288 ; ( 18,5 )  ( 16,6 )  ( 18,7 )  ( 20,6 )  ( 18,5 ) ; ( 18,6 ) node@xmath289 ; ( 20,6 )  ( 26,6 ) ; ( 26,7 )  ( 26,5 ) ; ( 26.75,5.5 ) node @xmath279 ; ( 24,3 ) rectangle + ( 4,2 ) ; ( 26,4 ) node@xmath280 ; ( 26,3 )  ( 26,0 )  ( 18,0 ) ;    ( 18,5 )  ( 18,3 ) ; ( 18.75,3.5 ) node @xmath290 ; ( 16,1 ) rectangle + ( 4,2 ) ; ( 18,2 ) node@xmath280 ; ( 18,1 ) ",
    "( 14,27 ) ; ( 14,27 ) ",
    "( 18,27 ) ;    let @xmath35 be a program and @xmath291 be a hot path on some store abstraction @xmath166 .",
    "we define a syntactic transform of @xmath35 where the hot path @xmath238 is explicitly extracted from @xmath35 .",
    "this is achieved by a suitable relabeling of each command @xmath247 in @xmath238 which is in turn preceded by the conditional @xmath292 induced by the corresponding store property @xmath293 .",
    "to this aim , we consider three _ injective _ relabeling functions @xmath294 { \\rightarrow}\\mathbb{l}_{1}\\qquad\\quad { \\mathbbm{l}}:[1,n ] { \\rightarrow}\\mathbb{l}_{2}\\qquad\\quad \\overline{(\\cdot ) } : \\mathbb{l } { \\rightarrow}\\overline{\\mathbb{l } } \\eqno(*)\\ ] ] where @xmath295 , @xmath296 and @xmath297 are pairwise disjoint sets of fresh labels , so that @xmath298 . the transformed program @xmath299 for the hot path @xmath238 is defined as follows and a graphical example of this transform is depicted in fig .",
    "[ tet - fig ] .",
    "[ tet - def ] the _ trace extraction transform _ of @xmath35 for the hot path @xmath300 is : @xmath301 where the stitch of @xmath238 into @xmath35 is defined as follows : = -10pt @xmath302\\ } \\!\\cup\\ !",
    "\\{\\ell_n : act(c_n ) \\rightarrow l_0\\}\\\\      & \\cup \\{\\ell_i : \\neg act(c_i ) \\rightarrow l_{\\textit{next}(i)}^c ~|~ i\\in [ 0,n],\\ , cmpl(c_{i})\\in p \\ } \\\\       & \\cup \\{{\\mathbbm{l}}_i : { \\mathit guard}\\:e_{a_i } \\rightarrow \\ell_{i},\\ ,        { \\mathbbm{l}}_i : \\neg { \\mathit guard}\\:e_{a_i } \\rightarrow l_{i } ~|~      i\\in [ 1,n]\\}. \\qed     \\end{aligned}\\ ] ]    the new command @xmath303 is therefore the entry conditional of the stitched hot path @xmath304 , while any command @xmath305 such that @xmath306 is a potential exit ( or bail out ) command of @xmath304 .",
    "if @xmath35 is well - formed then , for any hot path @xmath238 , @xmath299 is well - formed .",
    "recall that a program is well - formed when for any its conditional command it also includes a unique complement conditional .",
    "it turns out that @xmath299 is well - formed because : ( 1 )  @xmath35 is well - formed ; ( 2 )  for each conditional in @xmath307 @xmath308 @xmath309 we also have a unique complement conditional in @xmath310 . moreover , observe that if @xmath35 is deterministic then @xmath299 still is deterministic .",
    "let us remark that the stitch of the hot path @xmath238 into @xmath35 is always a linear sequence of different commands , namely , @xmath304 does not contain loops nor join points .",
    "furthermore , this happens even if the hot path @xmath238 does contain some inner sub - loop .",
    "technically , this is achieved as a consequence of the fact that the above relabeling functions @xmath311 and @xmath312 are required to be injective .",
    "hence , even if some command @xmath159 occurs more than once inside @xmath238 , e.g. , @xmath313 for some @xmath314 $ ] with @xmath315 , then these multiple occurrences of @xmath159 in @xmath238 are transformed into differently labeled commands in @xmath304 , e.g. , because @xmath316 and @xmath317 .",
    "let us now illustrate the trace extraction transform on a first simple example .",
    "[ ex - one ] let us consider the program @xmath35 in example  [ example - init ] and the hot path @xmath318 in example  [ ex - zero ] ( denoted there by @xmath256 ) , where stores are abstracted to the trivial one - point abstraction @xmath251 . here , for any @xmath266 , we have that @xmath319 .",
    "the trace extraction transform of @xmath35 w.r.t .",
    "@xmath238 is therefore as follows : @xmath320 where @xmath321    the flow graph of @xmath299 is depicted in figure  [ fig - ex ] , while a higher level representation using while - loops and gotos is as follows :    by --    ( 18,30 )  (",
    "18,29 ) ; ( 18.75,29.5 ) node @xmath272 ; ( 16,28 ) rectangle + ( 4,1 ) ; ( 18,28.5 ) node@xmath322 ; ( 15.25,28.5 ) node ; ( 18,28 ) ",
    "( 18,26 ) ; ( 18.75,26.5 ) node @xmath275 ; ( 18,24 )  ( 16,25 ) ",
    "( 18,26 ) ",
    "( 20,25 ) ",
    "( 18,24 ) ; ( 18,25 ) node@xmath323 ; ( 15.5,25.5 ) node ; ( 15.5,24.5 ) node ;    ( 20,25 ) ",
    "( 26,25 ) ; ( 26,25 )  ( 26,24 ) ; ( 26.75,24.5 ) node @xmath324 ; ( 26,22 ) ",
    "( 24,23 ) ",
    "( 26,24 ) ",
    "( 28,23 ) ",
    "( 26,22 ) ; ( 26,23 ) node@xmath325 ; ( 23.5,23.5 ) node ; ( 23.5,22.5 ) node ;    ( 26,22 )  ( 26,19 ) ; ( 28,23 )  ( 34,23 ) ; ( 34,23 )  ( 34,20 ) ; ( 34.75,20.5 ) node @xmath326 ; ( 32,19 ) rectangle + ( 4,1 ) ; ( 34,19.5 ) node@xmath327 ; ( 31.25,19.5 ) node ; ( 34,19 ) ",
    "( 34,18 ) ; ( 34.75,18.5 ) node @xmath29 ;    ( 18,24 ) ",
    "( 18,22 ) ; ( 18.75,22.5 ) node @xmath283 ; ( 18,20 )  ( 16,21 ) ",
    "( 18,22 ) ",
    "( 20,21 ) ",
    "( 18,20 ) ; ( 18,21 ) node@xmath325 ; ( 15.5,21.5 ) node ; ( 15.5,20.5 ) node ; ( 20,21 )  ( 34,21 ) ; ( 18,20 ) ",
    "( 18,18 ) ; ( 18.75,18.5 ) node @xmath284 ;    ( 18,16 )  ( 16,17 ) ",
    "( 18,18 ) ",
    "( 20,17 ) ",
    "( 18,16 ) ; ( 18,17 ) node@xmath323 ; ( 15.5,17.5 ) node ; ( 15.5,16.5 ) node ; ( 20,17 )  ( 22,17 ) ",
    "( 22,20 ) ",
    "( 26,20 ) ; ( 22,20 ) ",
    "( 26,20 ) ; ( 24,18 ) rectangle + ( 4,1 ) ; ( 26.75,19.5 ) node @xmath277 ; ( 26,18.5 ) node@xmath328 ; ( 23.25,18.5 ) node ; ( 26,18 )  ( 26,15 ) ; ( 26,13 )  ( 24,14 )  ( 26,15 )  ( 28,14 )  ( 26,13 ) ; ( 26,14 ) node@xmath329 ; ( 26.75,15.5 ) node @xmath330 ; ( 23.5,14.5 ) node ; ( 23.5,13.5 ) node ;    ( 26,13 )  ( 26,10 ) ; ( 24,10 ) rectangle + ( 4,1 ) ; ( 26,10.5 ) node@xmath331 ; ( 26.75,11.5 ) node @xmath332 ; ( 23.5,10.5 ) node ; ( 26,10 )  ( 26,9 )  ( 38,9 )  ( 38,27 ) ; ( 38,27 ) ",
    "( 18,27 ) ;    ( 18,16 ) ",
    "( 18,14 ) ; ( 18.75,14.5 ) node @xmath286 ; ( 16,13 ) rectangle + ( 4,1 ) ; ( 18,13.5 ) node@xmath328 ; ( 15.25,13.5 ) node ; ( 18,13 ) ",
    "( 18,11 ) ; ( 18.75,11.5 ) node @xmath287 ; ( 20,10 ) ",
    "( 22,10 ) ",
    "( 22,16 ) ; ( 22,16 ) ",
    "( 26,16 ) ;    ( 18,9 ) ",
    "( 16,10 ) ",
    "( 18,11 ) ",
    "( 20,10 ) ",
    "( 18,9 ) ; ( 18,10 ) node@xmath323 ; ( 15.5,10.5 ) node ; ( 15.5,9.5 ) node ;    ( 20,6 ) ",
    "( 23,12 ) ; ( 23,12 ) ",
    "( 26,12 ) ;    ( 18,9 ) ",
    "( 18,7 ) ; ( 18.75,7.5 ) node @xmath333 ; ( 18,5 )  ( 16,6 ) ",
    "( 18,5 ) ; ( 18,6 ) node@xmath334 ; ( 15.5,6.5 ) node ; ( 15.5,5.5 ) node ;    ( 18,5 )  ( 18,4 ) ",
    "( 14,27 ) ; ( 14,27 ) ",
    "( 18,27 ) ;",
    "as advocated by , correctness of dynamic program transformations and optimizations should be defined with respect to some observational abstraction of program trace semantics : a dynamic program transform is correct when , at some level of abstraction , the observation of the execution of the subject program is equivalent to the observation of the execution of the transformed / optimized program .",
    "the approach by to tracing compilation basically relies on a notion of correctness that requires the same _ store changes _ to happen in both the transformed / optimized program and the original program .",
    "this can be easily encoded by an observational abstraction @xmath335 of partial traces that observes store changes in execution traces : @xmath336    since the function @xmath337 obviously preserves arbitrary set unions , as recalled in section  [ intro_abs_int ] , it admits a right adjoint @xmath338 defined as @xmath339 , that gives rise to a gc @xmath340 @xmath341 . by a slight abuse of notation , @xmath337",
    "is also used as an abstraction of the partial trace semantics of a given program @xmath35 , that is , @xmath342 , which , clearly , gives rise to a corresponding gc @xmath343 @xmath344 .",
    "the store changes abstraction @xmath337 may be too strong in practice .",
    "this can be generalized to any observational abstraction of execution traces @xmath345 ( which gives rise to a gc ) . as a significant example",
    ", one may consider an output abstraction that demands to have the same stores ( possibly restricted to some subset of program variables ) only at some specific output points .",
    "for example , in a language with no explicit output primitives , as that considered by , one could be interested just in the final store of the program ( when it terminates ) , or in the entry and exit stores of any loop containing an extracted hot path . if we consider a language including a distinct primitive command `` @xmath346 '' that `` outputs '' the value of program variables ranging in some set @xmath347 then we may want to have the same stores for variables in @xmath347 at each output point @xmath346 . in this case",
    ", optimizations should preserve the same sequence of outputs , i.e.  optimizations should not modify the order of output commands .",
    "more formally , this can be achieved by adding a further sort of actions : @xmath348 , where @xmath349 is a set of program variables .",
    "the semantics of @xmath346 obviously does not affect program stores , i.e. , @xmath350 .",
    "correspondingly , if @xmath351 denotes stores on variables ranging in @xmath347 then the following output abstraction @xmath352 of partial traces observes program stores at output program points only :    @xmath353    where @xmath354 denotes the restriction of the store @xmath69 to variables in @xmath347 .",
    "similarly to @xmath337 , here again we have a gc @xmath355 @xmath356 .",
    "this approach based on a generic observational abstraction enables to prove the correctness of program optimizations that are unsound in s framework based on the store changes abstraction , such as dead store elimination .",
    "for example , in a program fragment such as    one can extract the hot path @xmath357 ( here we ignore store abstractions ) and perform dead store elimination of the command @xmath358 by optimizing @xmath238 to @xmath359 . as observed by ,",
    "this is clearly unsound in bisimulation - based correctness because this hot path optimization does not output bisimilar code .",
    "by contrast , this optimization can be made sound by choosing and then formalizing an observational abstraction of program traces which requires to have the same stores at the beginning and at the exit of loops containing an extracted hot path , while outside of hot paths one could still consider the store changes abstraction .",
    "one can generalize the store changes abstraction @xmath337 by considering any observational abstraction @xmath345 which is less precise ( i.e. , more approximate ) than @xmath337 : this means that for any @xmath360 , if @xmath361 then @xmath362 , or , equivalently , for any @xmath363 , @xmath364 .",
    "informally , this means that @xmath365 abstracts more information than @xmath337 . as an example , when considering programs with output actions , the following abstraction @xmath366 observes store changes at output program points only :    @xmath367    clearly , it turns out that @xmath368 is more approximate than @xmath337 since @xmath369 records a store change @xmath370 only when the two contiguous subsequences of commands whose common stores are @xmath371 and @xmath372 contain among them at least a @xmath373 command .",
    "it turns out that the observational correctness of the hot path extraction transform in definition  [ tet - def ] can be proved w.r.t .",
    "the observational abstraction @xmath337 of store changes .",
    "[ corr - th ] for any @xmath74 and @xmath374 , we have that @xmath375 .",
    "this is the crucial result concerning the correctness of our hot path extraction transform .",
    "we will show in section  [ gpte - sec ] ( see theorem  [ gp - corr - th ] ) that the correctness of the hot path extraction strategy defined in @xcite can be proved by a simple adaptation of the proof technique that we will use here .    in order to prove theorem  [ corr - th ] , we need to define some suitable `` dynamic '' transformations of execution traces .",
    "let us fix a hot path @xmath376 ( w.r.t .",
    "some store abstraction ) and let @xmath377 denote the corresponding transform of @xmath35 given by definition  [ tet - def ] .",
    "we first define a mapping @xmath378 of the execution traces of the program @xmath35 into execution traces of the transformed program @xmath379 that unfolds the hot path @xmath238 ( or any prefix of it ) according to the hot path extraction strategy given by definition  [ tet - def ] : a function application @xmath380 should replace any occurrence of the hot path @xmath238 in the execution trace @xmath381 with its corresponding guarded and suitably relabeled path obtained through definition  [ tet - def ] .",
    "more precisely , fig .",
    "[ tr - def - figure ] provides the definitions for the following two functions : @xmath382    let us first describe how the trace transform @xmath378 works . a function application @xmath383 on a trace @xmath384 of @xmath35the superscript @xmath385 hints that the first state @xmath106 of the trace @xmath384 is still _ outside _ of the hot path @xmath238 so that @xmath383 could either enter into the transform of @xmath238 or remain outside of @xmath238triggers the unfolding of the hot path @xmath238 in @xmath379 when the first state @xmath106 is such that :    * @xmath386 , where @xmath241 is the first command of @xmath238 ; * the entry conditional @xmath387 of @xmath388 is satisfied in the store @xmath69 of the state @xmath386 , that is , @xmath389 .",
    "if the unfolding for the trace @xmath390 is actually started by applying @xmath391 then :    * the first state @xmath392 is unfolded into the following sequence of two states of @xmath379 : @xmath393 ; * in turn , the unfolding of the residual trace @xmath7 is carried on by applying @xmath394 .",
    "let us now focus on the function @xmath395 . a function application @xmath396here the superscript @xmath397 suggests that we are currently _ inside _ the hot path @xmath238 so that @xmath396 could either exit from the unfolding of @xmath238 or advance with the unfolding of @xmath238carries on the unfolding of @xmath238 as a trace in @xmath379 when the current state @xmath106 is such that :    * @xmath398 , where @xmath399 $ ] , meaning that the command @xmath247 is strictly inside @xmath238 , i.e. , @xmath247 is different from the first command @xmath241 and the last command @xmath400 of @xmath238 ; * the guarded conditional @xmath401 is satisfied in the store @xmath69 of the state @xmath398 , that is , @xmath402 .",
    "if one of these two conditions does not hold then the trace transformation @xmath403 , after a suitable unfolding step for @xmath404 , jumps back to the `` outside of @xmath238 '' modality by progressing with @xmath405 .    @xmath406    & { { \\textrm{\\rm tr}}_{hp}^{\\mathit{out}}}(\\epsilon ) { \\triangleq}\\epsilon   \\\\       & { { \\textrm{\\rm tr}}_{hp}^{\\mathit{out}}}(s\\sigma ) { \\triangleq}\\begin{cases }          \\tuple{\\rho , l_0 : { { { \\mathit guard}}}~ e_{a_0 } { \\rightarrow}\\ell_0 } \\tuple{\\rho,\\ell_0 : act(c_0 ) { \\rightarrow}{\\mathbbm{l}}_1}\\ , { { \\textrm{\\rm tr}}_{hp}^{\\mathit{in}}}(\\sigma)&\\\\         & \\hspace{-11em } \\text{if } s = \\tuple{\\rho , c_0},\\ , { \\alpha_{\\mathit{store}}}(\\{\\rho\\ } ) \\leq a_0        \\\\[5pt ]               \\tuple{\\rho , l_0 : \\neg { { { \\mathit guard}}}~ e_{a_0 } { \\rightarrow}\\overline{l_0 } } \\tuple{\\rho,\\overline{l_0 } : act(c_0 ) { \\rightarrow}l_1 } \\,{{\\textrm{\\rm tr}}_{hp}^{\\mathit{out}}}(\\sigma ) & \\\\        & \\hspace{-11em}\\text{if } s = \\tuple{\\rho , c_0},\\ , { \\alpha_{\\mathit{store}}}(\\{\\rho\\ } ) \\not\\leq a_0        \\\\[5pt ]              \\tuple{\\rho , l_0 :",
    "{ { { \\mathit guard}}}~ e_{a_0 } { \\rightarrow}\\ell_0 } \\tuple{\\rho,\\ell_0 : \\neg act(c_0 ) { \\rightarrow}l_1^c } \\,{{\\textrm{\\rm tr}}_{hp}^{\\mathit{out}}}(\\sigma ) & \\\\        & \\hspace{-11em } \\text{if } s = \\tuple{\\rho , cmpl(c_0)},\\,{\\alpha_{\\mathit{store}}}(\\{\\rho\\ } ) \\leq a_0        \\\\[5pt ]               \\tuple{\\rho , l_0 : \\neg { { { \\mathit guard}}}~ e_{a_0 } { \\rightarrow}\\overline{l_0 } } \\tuple{\\rho,\\overline{l_0 } : \\neg act(c_0 ) { \\rightarrow}l_1^c } \\,{{\\textrm{\\rm tr}}_{hp}^{\\mathit{out}}}(\\sigma ) & \\\\        & \\hspace{-11em } \\text{if } s = \\tuple{\\rho , cmpl(c_0)},\\ , { \\alpha_{\\mathit{store}}}(\\{\\rho\\ } ) \\not\\leq a_0        \\\\[5pt ]                   s\\cdot { { \\textrm{\\rm tr}}_{hp}^{\\mathit{out}}}(\\sigma )          & \\hspace{-11em}\\text{otherwise }             \\end{cases }           \\\\[5pt ]       & { { \\textrm{\\rm tr}}_{hp}^{\\mathit{in}}}(\\epsilon ) { \\triangleq}\\epsilon\\\\       & { { \\textrm{\\rm tr}}_{hp}^{\\mathit{in}}}(s\\sigma ) { \\triangleq}\\begin{cases }          \\tuple{\\rho,{\\mathbbm{l}}_i : { { { \\mathit guard}}}~ e_{a_i } { \\rightarrow}\\ell_i } \\tuple{\\rho,\\ell_i : act(c_i ) { \\rightarrow}{\\mathbbm{l}}_{i+1}}\\,{{\\textrm{\\rm tr}}_{hp}^{\\mathit{in}}}(\\sigma ) & \\\\        & \\hspace{-14.5em}\\text{if } s = \\tuple{\\rho , c_i},\\ , i\\in [ 1,n-1],\\ , { \\alpha_{\\mathit{store}}}(\\{\\rho\\ } ) \\leq a_i        \\\\[5pt ]               \\tuple{\\rho,{\\mathbbm{l}}_n : { { { \\mathit guard}}}~ e_{a_n } { \\rightarrow}\\ell_n } \\tuple{\\rho,\\ell_n : act(c_n ) { \\rightarrow}l_0}\\,{{\\textrm{\\rm tr}}_{hp}^{\\mathit{out}}}(\\sigma ) & \\\\         & \\hspace{-14.5em}\\text{if } s = \\tuple{\\rho , c_n},\\ , { \\alpha_{\\mathit{store}}}(\\{\\rho\\ } ) \\leq a_n        \\\\[5pt ]         \\tuple{\\rho,{\\mathbbm{l}}_i : \\neg { { { \\mathit guard}}}~ e_{a_i } { \\rightarrow}l_i } \\tuple{\\rho , c_i } \\,{{\\textrm{\\rm tr}}_{hp}^{\\mathit{out}}}(\\sigma ) & \\\\            & \\hspace{-14.5em}\\text{if } s = \\tuple{\\rho , c_i},\\ , i\\in [ 1,n],\\ , { \\alpha_{\\mathit{store}}}(\\{\\rho\\ } ) \\not\\leq a_i            \\\\[5pt ]                \\tuple{\\rho,{\\mathbbm{l}}_i : { { { \\mathit guard}}}~ e_{a_i } { \\rightarrow}\\ell_i } \\tuple{\\rho,\\ell_i : \\neg act(c_i ) { \\rightarrow}l_{\\textit{next}(i)}^c}\\,{{\\textrm{\\rm tr}}_{hp}^{\\mathit{out}}}(\\sigma ) & \\\\        & \\hspace{-14.5em}\\text{if } s = \\tuple{\\rho , cmpl(c_i)},\\,i\\in [ 1,n],\\ , { \\alpha_{\\mathit{store}}}(\\{\\rho\\ } ) \\leq a_i        \\\\[5pt ]               \\tuple{\\rho,{\\mathbbm{l}}_i : \\neg { { { \\mathit guard}}}~ e_{a_i } { \\rightarrow}l_i } \\tuple{\\rho , cmpl(c_i ) } \\,{{\\textrm{\\rm tr}}_{hp}^{\\mathit{out}}}(\\sigma ) & \\\\        & \\hspace{-14.5em}\\text{if } s = \\tuple{\\rho , cmpl(c_i)},\\ , i\\in [ 1,n],\\ , { \\alpha_{\\mathit{store}}}(\\{\\rho\\ } ) \\not \\leq a_i        \\\\[5pt ]                   s\\cdot { { \\textrm{\\rm tr}}_{hp}^{\\mathit{out}}}(\\sigma )          & \\hspace{-14.5em}\\text{otherwise }             \\end{cases }          \\end{aligned}\\ ] ]    [ ex - tr ] consider the transform @xmath379 of example  [ ex - one ] for the program @xmath35 in example  [ example - init ] w.r.t .  the hot path @xmath318 . in particular , we refer to the notation @xmath407 used to denote the commands in the stitch of @xmath238 into @xmath35 .",
    "consider the following trace fragment @xmath381 : @xmath408,c_0}\\tuple{[x/0],c_1}\\tuple{[x/0],c_2}\\tuple{[x/1],c_3^c}\\tuple{[x/1],c_1}\\tuple{[x/1],c_2}\\tuple{[x/2],c_3^c}\\\\ \\tuple{[x/2],c_1}\\tuple{[x/2],c_2}\\tuple{[x/3],c_3}\\tuple{[x/3],c_4}\\end{gathered}\\ ] ] then , we have that the dynamic transformation @xmath380 acts as follows : @xmath409,c_0}{{\\textrm{\\rm tr}}_{hp}^{\\mathit{out}}}(\\tau_{\\suff{1 } } ) = \\tuple{[x/3],c_0 } \\tuple{[x/0],h_0 } \\tuple{[x/0],h_1}{{\\textrm{\\rm tr}}_{hp}^{\\mathit{in}}}(\\tau_{\\suff{2}})\\\\ { { \\textrm{\\rm tr}}_{hp}^{\\mathit{in}}}(\\tau_{\\suff{2}})&= \\tuple{[x/0],h_2}\\tuple{[x/0],h_3 } { { \\textrm{\\rm tr}}_{hp}^{\\mathit{in}}}(\\tau_{\\suff{3 } } ) \\\\ { { \\textrm{\\rm tr}}_{hp}^{\\mathit{in}}}(\\tau_{\\suff{3 } } ) & = \\tuple{[x/1],h_4}\\tuple{[x/1],h_5 } { { \\textrm{\\rm tr}}_{hp}^{\\mathit{in}}}(\\tau_{\\suff{4}})\\\\ & \\cdots\\\\ { { \\textrm{\\rm tr}}_{hp}^{\\mathit{in}}}(\\tau_{\\suff{9 } } ) & = { { \\textrm{\\rm tr}}_{hp}^{\\mathit{in}}}(\\tuple{[x/3],c_3}\\tuple{[x/3],c_4 } ) = \\tuple{[x/3],h_4}\\tuple{[x/3],h_5^c}{{\\textrm{\\rm tr}}_{hp}^{\\mathit{out}}}(\\tuple{[x/3],c_4})\\\\ & = \\tuple{[x/3],h_4}\\tuple{[x/3],h_5^c}\\tuple{[x/3],c_4}{{\\textrm{\\rm tr}}_{hp}^{\\mathit{out}}}(\\epsilon)\\\\ & = \\tuple{[x/3],h_4}\\tuple{[x/3],h_5^c}\\tuple{[x/3],c_4}\\end{aligned}\\ ] ] summing up , using the colors in the flow graph of @xmath379 in fig .  [ fig - ex ] and representing traces as sequences of commands only , we have that : @xmath410 @xmath411 where red boxes denote commands of @xmath217 and @xmath380 outside of the hot path @xmath238 , black boxes with red commands denote commands of @xmath217 inside @xmath238 , while black boxes with blue commands denote commands of @xmath380 in @xmath388 .",
    "hence , @xmath380 carries out the unfolding of the hot path @xmath238 for the execution trace @xmath217 of @xmath35 , and therefore provides an execution trace of the transformed program @xmath379 .",
    "it turns out that @xmath378 maps traces of @xmath35 into traces of @xmath379 and does not alter store change sequences .",
    "[ lem - tr ] @xmath378 is well - defined and for any @xmath412 , @xmath413 .",
    "we first show that : ( 1 )  @xmath378 is well - defined , i.e. , for any @xmath412 , @xmath414 , and ( 2 )  for any @xmath415 , if @xmath416 then @xmath417 . in order to prove these two points ,",
    "it is enough an easy induction on the length of the execution trace @xmath7 and to observe that :    1 .",
    "for the first four clauses that define @xmath383 in fig .",
    "[ tr - def - figure ] we have that @xmath418 or @xmath419 , where @xmath420 is a guard command of @xmath379 and @xmath421 is in turn a legal sub - execution trace of @xmath379 ; 2 .",
    "for the last clause that defines @xmath383 in fig .",
    "[ tr - def - figure ] we have that @xmath422 , hence @xmath106 is a legal state in @xmath379 and , in turn , @xmath423 is a trace of @xmath379 ; 3 .   for the clauses 1 , 2 and 4 that define @xmath396 in fig .",
    "[ tr - def - figure ] we have that @xmath424 or @xmath425 , where @xmath420 is a guard command and @xmath426 is an action command such that @xmath421 is a legal sub - execution trace of @xmath379 ; 4 .   for the clauses 3 and 5 that define @xmath396 in fig .",
    "[ tr - def - figure ] we have that @xmath427 where @xmath420 is a guard command and @xmath428 turns out to be a legal sub - execution trace of @xmath379 ; 5 .   for the last clause that defines @xmath396 in fig .",
    "[ tr - def - figure ] we have that @xmath429\\}$ ] ; by hypothesis , @xmath430 , so that @xmath431\\}$ ] , hence @xmath106 is a legal state in @xmath379 and in turn @xmath432 is a trace of @xmath379 ; 6 .",
    "@xmath396 is never recursively called by a function application @xmath433 when @xmath434 .    then , it is immediate to check from the definitions in fig .",
    "[ tr - def - figure ] that if @xmath435 then @xmath436 .",
    "therefore , for any @xmath412 , we obtain that @xmath413 .    @xmath437     & \\hspace{-1em}{{\\textrm{\\rm rtr}}_{hp}}(\\epsilon ) { \\triangleq}\\epsilon   \\\\     & \\hspace{-1em}{{\\textrm{\\rm rtr}}_{hp}}(s\\sigma ) { \\triangleq}\\begin{cases }         \\tuple{\\mathit{store}(s),c_i }   & \\text{if } \\sigma=\\epsilon,\\ ,",
    "act(s ) \\in \\{{{{\\mathit guard}}}~e_{a_i } , \\neg { { { \\mathit guard}}}~e_{a_i}\\},\\ , i\\in [ 1,n ]         \\\\[5pt ]                { { \\textrm{\\rm rtr}}_{hp}}(\\sigma )         & \\text{if } \\sigma \\neq \\epsilon,\\ , act(s ) \\in \\{{{{\\mathit guard}}}~e_{a_i } , \\neg { { { \\mathit guard}}}~e_{a_i}\\},\\ , i\\in [ 1,n ]         \\\\[5pt ]               \\tuple{\\rho , c_0 } { { \\textrm{\\rm rtr}}_{hp}}(\\sigma )         & \\text{if } s = \\tuple{\\rho , \\overline{l_0 } : act(c_0 ) { \\rightarrow}l_1 }        \\\\[5pt ]               \\tuple{\\rho , c_0^c } { { \\textrm{\\rm rtr}}_{hp}}(\\sigma )         & \\text{if } s = \\tuple{\\rho , \\overline{l_0 } : \\neg act(c_0 ) { \\rightarrow}l_1^c }        \\\\[5pt ]               \\tuple{\\rho , c_i } { { \\textrm{\\rm rtr}}_{hp}}(\\sigma )         & \\text{if } s = \\tuple{\\rho , \\ell_i : act(c_i ) { \\rightarrow}{\\mathbbm{l}}_{i+1}},\\ , i\\in [ 1,n-1 ]        \\\\[5pt ]              \\tuple{\\rho , c_i^c } { { \\textrm{\\rm rtr}}_{hp}}(\\sigma )         & \\text{if } s = \\tuple{\\rho , \\ell_i : \\neg act(c_i ) { \\rightarrow}l_{\\textit{next}(i)}^c},\\ ,   i\\in [ 1,n ]        \\\\[5pt ]              \\tuple{\\rho , c_n } { { \\textrm{\\rm rtr}}_{hp}}(\\sigma )         & \\text{if } s = \\tuple{\\rho , \\ell_n : act(c_n ) { \\rightarrow}l_0 }        \\\\[5pt ]                       s\\cdot { { \\textrm{\\rm rtr}}_{hp}}(\\sigma )          & \\text{otherwise }             \\end{cases }          \\end{aligned}\\ ] ]    vice versa , it is a simpler task to define a reverse transformation function @xmath438 that `` decompiles '' an execution trace @xmath7 of @xmath379 into an execution trace of @xmath35 by removing guarded commands in @xmath7 , as generated by the hot path @xmath238 , and by mapping the relabeled commands of @xmath238 in @xmath7 back to their corresponding source commands of @xmath238 .",
    "this function @xmath439 is correctly defined by the clauses in fig .",
    "[ rtr - def - figure ] and it preserves store change sequences .    [ lem - rtr ] @xmath438 is well - defined and for any @xmath440 , @xmath441 .",
    "we show that @xmath438 is well - defined , i.e. , for any @xmath440 , @xmath442 .",
    "this follows by an easy induction on the length of the execution trace @xmath7 by observing that :    1 .   the first clause that defines @xmath443 in fig .",
    "[ rtr - def - figure ] is an extremal base case where @xmath444 and the command action of @xmath106 is a guard command @xmath445 ( or its complement ) ; in this case , we simply retain the store of @xmath106 and pick the command @xmath247 of @xmath35 .",
    "the clause 2 of @xmath443 in fig .",
    "[ rtr - def - figure ] simply removes the states whose commands are some @xmath445 ; since @xmath445 does not alter stores , this removal preserves the sequence of store changes .",
    "3 .   the clauses 3 - 7 of @xmath443 in fig .",
    "[ rtr - def - figure ] map a state @xmath106 of @xmath379 whose command @xmath446 is a relabeled action @xmath447 or @xmath448 of the hot path @xmath238 to a corresponding state of @xmath35 that has the same @xmath104 and whose command is : @xmath247 for @xmath447 and @xmath449 for @xmath448 ; here , we observe that since guards in @xmath7 are removed , by induction , these definitions allow us to obtain that @xmath384 is mapped to a legal trace of @xmath35 that does not alter the sequence of store changes .",
    "the clause 8 of @xmath443 in fig .",
    "[ rtr - def - figure ] states that if @xmath106 is already a state of @xmath35 then it is left unchanged .",
    "hence , the above points also show that the sequence of store changes is not affected by @xmath438 , i.e. , for any @xmath440 , @xmath450 .",
    "[ ex - tr2 ] we carry on example  [ ex - tr ] by considering the following trace fragment @xmath440 , where the transformed program @xmath379 is in example  [ ex - one ] : @xmath451,h_4}\\tuple{[x/2],h_5}\\tuple{[x/2],h_0}\\tuple{[x/2],h_1}\\tuple{[x/2],h_2}\\tuple{[x/2],h_3}\\tuple{[x/3],h_4}\\\\ \\tuple{[x/3],h_5^c}\\tuple{[x/3],c_4}\\tuple{[x/6],c_1}\\end{gathered}\\ ] ] here , the decompilation of @xmath7 back into an execution trace of @xmath35 through @xmath438 yields : @xmath452,c_3^c}{{\\textrm{\\rm rtr}}_{hp}}(\\sigma_{\\suff{2 } } ) =   \\tuple{[x/2],c_3^c}{{\\textrm{\\rm rtr}}_{hp}}(\\sigma_{\\suff{3}})\\\\ & = \\tuple{[x/2],c_3^c}\\tuple{[x/2],c_1}{{\\textrm{\\rm rtr}}_{hp}}(\\sigma_{\\suff{4}})=\\tuple{[x/2],c_3^c}\\tuple{[x/2],c_1}{{\\textrm{\\rm rtr}}_{hp}}(\\sigma_{\\suff{5}})\\\\ & = \\tuple{[x/2],c_3^c}\\tuple{[x/2],c_1 } \\tuple{[x/2],c_2 } { { \\textrm{\\rm rtr}}_{hp}}(\\sigma_{\\suff{6}})\\\\ & = \\tuple{[x/2],c_3^c}\\tuple{[x/2],c_1 } \\tuple{[x/2],c_2 } { { \\textrm{\\rm rtr}}_{hp}}(\\sigma_{\\suff{7}})\\\\ & = \\tuple{[x/2],c_3^c}\\tuple{[x/2],c_1 } \\tuple{[x/2],c_2}\\tuple{[x/3],c_3}{{\\textrm{\\rm rtr}}_{hp}}(\\sigma_{\\suff{8 } } ) \\\\ & = \\tuple{[x/2],c_3^c}\\tuple{[x/2],c_1 } \\tuple{[x/2],c_2}\\tuple{[x/3],c_3}\\tuple{[x/3],c_4}{{\\textrm{\\rm rtr}}_{hp}}(\\sigma_{\\suff{9}})\\\\ & = \\tuple{[x/2],c_3^c}\\tuple{[x/2],c_1 } \\tuple{[x/2],c_2}\\tuple{[x/3],c_3}{{\\textrm{\\rm rtr}}_{hp}}(\\sigma_{\\suff{8 } } ) \\\\ & = \\tuple{[x/2],c_3^c}\\tuple{[x/2],c_1 } \\tuple{[x/2],c_2}\\tuple{[x/3],c_3}\\tuple{[x/3],c_4}\\tuple{[x/6],c_1}\\end{aligned}\\ ] ] indeed , @xmath453,c_3^c}\\tuple{[x/2],c_1 } \\tuple{[x/2],c_2}\\tuple{[x/3],c_3}\\tuple{[x/3],c_4}\\tuple{[x/6],c_1}$ ] is a well - defined execution trace of @xmath35 .",
    "we are now in the position to prove theorem  [ corr - th ] .",
    "proof of theorem  [ corr - th ] . with an abuse of notation for @xmath438 ,",
    "let us define two functions @xmath454 and @xmath455 which are the collecting versions of @xmath378 and @xmath438 , that is , @xmath456 and @xmath457 . as consequences of the above lemmata",
    ", we have the following properties .",
    "1 .   @xmath458 : by lemma  [ lem - tr ] .",
    "@xmath459 : because , by lemma  [ lem - tr ] , @xmath378 is well - defined .",
    "@xmath460 : by lemma  [ lem - rtr ] .",
    "@xmath461 : because , by lemma  [ lem - rtr ] , @xmath438 is well - defined .",
    "we therefore obtain : @xmath462}\\\\ \\alpha_{\\operatorname{\\mathit{sc}}}({{\\textrm{\\rm tr}_{hp}}}({\\mathbf{t}}\\grasse{p } ) ) & \\subseteq\\text{\\quad[by point~(b)]}\\\\ \\alpha_{\\operatorname{\\mathit{sc}}}({\\mathbf{t}}\\grasse{{p_{hp } } } ) & = \\text{\\quad[by point~(c)]}\\\\ \\alpha_{\\operatorname{\\mathit{sc}}}({{\\textrm{\\rm rtr}}_{hp}}({\\mathbf{t}}\\grasse{{p_{hp } } } ) )   & \\subseteq\\text{\\quad[by point~(d)]}\\\\ \\alpha_{\\operatorname{\\mathit{sc}}}({\\mathbf{t}}\\grasse{p } )   & \\end{aligned}\\ ] ] and this closes the proof .",
    "guarded hot paths are a key feature of our tracing compilation model and are meant to be dynamically recorded by a hot path monitor .",
    "an abstract guard for a command @xmath159 of some stitched hot path @xmath463 encodes a property of program stores which is represented as an element of an abstract domain @xmath464 and is guaranteed to hold at the entry of @xmath159 .",
    "this information on program stores , as encapsulated by the abstract guards in @xmath463 , can then be used in hot path optimizations , namely , to optimize the commands in @xmath238 .",
    "we follow a modular approach for proving the correctness of hot path optimizations .",
    "a hot path optimization @xmath465 should optimize @xmath35 along some hot path @xmath238 of @xmath35 , by relying on the abstract store information recorded in @xmath238 , while leaving unchanged the commands outside of @xmath238 .",
    "hence , in our framework , fixed @xmath74 , an optimization @xmath465 is defined to be a program transform of the commands in @xmath304 , that is , @xmath466    where @xmath43 may allow new optimized expressions and/or actions introduced by @xmath465 , as it will be the case of type - specific additions @xmath467 in the type specialization optimization described in section  [ type_specialization ] .",
    "let @xmath468 denote the commands outside of the stitched hot path .",
    "then , the corresponding full optimization @xmath469 of the whole program @xmath35 w.r.t .  the hot path @xmath238 should extract and simultaneously optimize @xmath238 ,",
    "namely , this is defined by @xmath470 where @xmath471 is required to be a well - formed program , i.e. , @xmath472 .",
    "this full optimization @xmath471 has to be proved correct w.r.t .",
    "some observational abstraction @xmath473 of program traces , which is assumed to be more abstract than the store changes abstraction @xmath337 ( cf .  section  [ obs ] ) .",
    "then , this full optimization is correct for @xmath365 when : @xmath474    since theorem  [ corr - th ] ensures that the unoptimized trace extraction transform is already correct for the store changes abstraction @xmath337 , which is more precise than @xmath365 , the intuition is that in order to prove the correctness of @xmath475 w.r.t .",
    "@xmath365 , it is enough to focus on the correctness of the optimization @xmath465 along the stitched hot path @xmath388 .",
    "this therefore leads to the following definition of correctness for a hot path optimization .",
    "[ chpo - def ] @xmath465 is _ correct _ for the observational abstraction @xmath476 if for any @xmath74 and for any @xmath477 , @xmath478 .    in order to prove that this correctness of a hot path optimization implies the correctness of the corresponding full optimization ,",
    "we define two functions @xmath479 which must be well - defined , i.e.  they have to map well - formed traces into well - formed traces , and , intuitively , encode the effect of optimizing ( function @xmath480 ) and de - optimizing ( function @xmath481 ) execution traces along a stitched hot path .",
    "since @xmath482 and @xmath483 , we then extend @xmath480 and @xmath481 to two functions @xmath484 which simply apply @xmath480 and @xmath481 to maximal subtraces , respectively , in @xmath485 and @xmath486 , while leaving unchanged the remaining states .",
    "let us formalize this idea .",
    "if @xmath487 is nonempty and , for some @xmath488 , @xmath489 then @xmath490}$ ] denotes the maximal subtrace of @xmath7 beginning at @xmath491 which belongs to @xmath485 , that is , the index @xmath492 is such that : ( 1 )  @xmath493 , ( 2 )  if @xmath494 then @xmath495 , ( 3 )  for any @xmath496 $ ] , @xmath497 .",
    "analogously , if @xmath498 is nonempty and @xmath499 then @xmath500}$ ] denotes the maximal subtrace of @xmath217 beginning at @xmath501 which belongs to @xmath486 .",
    "then , the formal definition of @xmath502 goes as follows : @xmath503 } )       \\operatorname{\\mathit{to}}_{\\operatorname{{\\mathit{full}}}}(\\sigma_{{(n_{st}+1)}^{^{\\!\\shortrightarrow } } } ) & \\text{if } \\sigma \\neq \\epsilon,\\ , \\mathit{cmd}(\\sigma_0 ) \\in \\operatorname{\\mathit{stitch}}_p(hp )          \\end{cases }      \\end{aligned}\\ ] ] and analogously for @xmath504 .",
    "since @xmath480 and @xmath481 are supposed to be well - defined , it turns out that @xmath502 and @xmath504 are well - defined once we make the weak and reasonable assumption that @xmath480 and @xmath481 do not modify the entry ( which is always @xmath505 ) and exit labels of the stitched hot path .",
    "this assumption , e.g. , for @xmath480 can be formalized as follows : if @xmath506 and @xmath507 then ( i ) if @xmath508 then @xmath509 ; ( ii ) if @xmath510 then @xmath511 . in the following ,",
    "@xmath502 and @xmath504 are also used to denote their corresponding collecting functions defined on sets of traces .",
    "[ lemma - corr ] assume that @xmath512 .",
    "if @xmath465 is correct for @xmath476 then @xmath469 is correct for @xmath476 .",
    "we have that : @xmath513}\\\\ \\alpha_{o}(\\operatorname{\\mathit{tdo}}_{\\operatorname{{\\mathit{full}}}}({\\mathbf{t}}\\grasse{o_{\\operatorname{{\\mathit{full } } } } ( p , hp ) } ) ) & \\subseteq\\text{\\quad[since $ \\operatorname{\\mathit{tdo}}_{\\operatorname{{\\mathit{full}}}}$ is well - defined]}\\\\ \\alpha_{o}({\\mathbf{t}}\\grasse{\\operatorname{\\mathit{extr}}_{hp}(p ) } ) & = \\text{\\quad[by $ \\alpha_{o } \\circ \\operatorname{\\mathit{to}}_{\\operatorname{{\\mathit{full}}}}=\\alpha_o$]}\\\\   \\alpha_{o}(\\operatorname{\\mathit{to}}_{\\operatorname{{\\mathit{full}}}}({\\mathbf{t}}\\grasse{\\operatorname{\\mathit{extr}}_{hp}(p ) } ) ) & \\subseteq\\text{\\quad[since $ \\operatorname{\\mathit{to}}_{\\operatorname{{\\mathit{full}}}}$ is well - defined]}\\\\ \\alpha_{o}({\\mathbf{t}}\\grasse{o_{\\operatorname{{\\mathit{full } } } } ( p , hp ) } )   & \\end{aligned}\\ ] ] thus , @xmath514 . by theorem  [ corr - th ] , @xmath515 , so that , since @xmath337 is more precise than @xmath365 , @xmath516 , and , in turn , @xmath517 .    we will see in sections  [ type_specialization ] and  [ cf - sec ] two significant examples of hot path optimizations , namely , type specialization and constant folding .",
    "one key optimization for dynamic languages like javascript and php is type specialization , that is , the use of type - specific primitives in place of generic untyped operations whose runtime execution can be costly . as a paradigmatic example , a generic addition operation could be defined on more than one type , so that the runtime environment must check the type of its operands and execute a different operation depending on these types : this is the case of the addition operation in javascript ( see its runtime semantics in the ecma-262 standard ( * ? ? ? * section  12.7.3.1 ) ) and of the semantics of @xmath518 in our language as given in section  [ sem - sec ] .",
    "of course , type specialization avoids the overhead of dynamic type checking and dispatch of generic untyped operations .",
    "when a type is associated to each variable before the execution of a command in some hot path , this type environment can be used to replace generic operations with type - specific primitives . in this section",
    ", we show that type specialization can be viewed as a particular hot path optimization which can be proved correct according to our definition in section  [ chpo - sec ] .",
    "let us recall that the set of type names is @xmath519 , which can be viewed as the following finite lattice @xmath520 :    = [ shorten > = -5pt , shorten < = -5pt ] ( 0,0 ) node[name=1 ] @xmath63 ; ( -1.5,1 ) node[name=3 ] @xmath521 ; ( 0,1 ) node[name=5 ] @xmath522 ; ( 1.5,1 ) node[name=6 ] @xmath523 ; ( 0,2 ) node[name=7 ] @xmath64 ;    \\(1 )  ( 3 ) ; ( 1 )  ( 5 ) ; ( 1 )  ( 6 ) ; ( 3 )  ( 7 ) ; ( 5 )  ( 7 ) ; ( 6 )  ( 7 ) ;    the abstraction @xmath524 and concretization @xmath525 functions are defined as follows : @xmath526 thus , @xmath527 provides the smallest type in @xmath520 for a set @xmath528 of values .",
    "in particular , given @xmath529 , @xmath530 coincides with @xmath531 . following the approach described in section  [ abstract - lifting ]",
    ", we then consider a simple nonrelational store abstraction for types @xmath532 where @xmath533 is the standard pointwise lifting of @xmath534 , so that @xmath535 and @xmath536 are , respectively , the bottom and top abstract stores in @xmath537 .",
    "the abstraction and concretization maps @xmath538 and @xmath539 are defined as a straight instantiation of the definitions in section  [ abstract - lifting ] .",
    "the abstract type semantics @xmath540 of expressions is defined as the best correct approximation of the concrete collecting semantics @xmath541 on the type abstractions @xmath537 and @xmath57 , i.e. , @xmath542 hence , this definition leads to the following equalities : @xmath543    for instance , we have that : @xmath544={\\alpha_{\\mathit{type}}}({\\mathbf{e}}\\grasse{x+y}\\varnothing)={\\alpha_{\\mathit{type}}}(\\varnothing)={{\\bot_{\\!\\mathrm{t}}}}\\\\\\end{gathered}\\ ] ] @xmath545 = { \\alpha_{\\mathit{type}}}({\\mathbf{e}}\\grasse{x+y}\\{\\rho~|~\\rho(x),\\rho(y)\\in \\operatorname{char}^*\\})=\\\\ = { \\alpha_{\\mathit{type}}}(\\operatorname{char}^*)=\\operatorname{string},\\end{gathered}\\ ] ] @xmath546 = { \\alpha_{\\mathit{type}}}({\\mathbf{e}}\\grasse{x+y}\\{\\rho~|~\\rho(x)\\in \\mathbb{z } , \\rho(y)\\in \\operatorname{char}^*\\})=\\\\ { \\alpha_{\\mathit{type}}}(\\{{{\\textit{undef}}}\\})= \\operatorname{undef},\\end{gathered}\\ ] ] @xmath547 = { \\alpha_{\\mathit{type}}}({\\mathbf{e}}\\grasse{x+y}\\{\\rho~|~\\rho(x)\\in \\mathbb{z } , \\rho(y)\\in \\operatorname{value_{\\!\\,\\mathrm{u}}}\\ } ) = \\\\   { \\alpha_{\\mathit{type}}}(\\mathbb{z}\\cup \\{{{\\textit{undef}}}\\})= { { \\top_{\\!\\mathrm{t}}}}\\end{gathered}\\ ] ] being defined as best correct approximation , it turns out that the abstract type semantics @xmath548 of expressions is correct by definition .",
    "[ coro - correct ] if @xmath549 then @xmath550 .",
    "according to section  [ trace - ext - sec ] , for any abstract type store ( that we also call type environment ) @xmath551\\in \\operatorname{store^{\\mathrm{t}}}$ ] we consider a corresponding boolean action guard denoted by @xmath552 whose corresponding action semantics is automatically induced , as defined in section  [ trace - ext - sec ] , by the galois connection @xmath553 : for any @xmath71 , @xmath554)\\\\ \\bot & \\!\\!\\text{otherwise } \\end{cases } \\\\ & = \\begin{cases } \\rho & \\!\\!\\text{if }   \\forall i.\\ , \\rho(x_i ) \\in { \\gamma_{\\mathit{type}}}(t_i)\\\\ \\bot & \\!\\!\\exists i.\\ , \\rho(x_i ) \\not\\in { \\gamma_{\\mathit{type}}}(t_i ) \\end{cases}\\end{aligned}\\ ] ]    for example , we have that : @xmath555 = [ x/\\mathtt{foo } , y/\\mathtt{bar}],\\\\ & { \\mathbf{a}}\\grasse{\\text{guard}\\:x:\\operatorname{string } , y:{{\\top_{\\!\\mathrm{t } } } } } [ x/\\mathtt{foo } , y/3 ] = [ x/\\mathtt{foo } , y/3],\\\\ & { \\mathbf{a}}\\grasse{\\text{guard}\\:x:\\operatorname{string } , y:{{\\top_{\\!\\mathrm{t } } } } } [ x/1 , y/3 ] = \\bot,\\\\ & { \\mathbf{a}}\\grasse{\\text{guard}\\:x:\\operatorname{string } , y:\\operatorname{undef } } [ x/\\mathtt{foo } ] = [ x/\\mathtt{foo}].\\end{aligned}\\ ] ]      let us consider some hot path @xmath556 @xmath557 on the type abstraction @xmath558 , where each @xmath559 is therefore a type environment for @xmath35 .",
    "thus , in the transformed program @xmath299 , the stitched hot path @xmath388 contains @xmath560 typed guards , that , for any @xmath246 $ ] , we simply denote as @xmath561 .",
    "typed guards allow us to perform type specialization of commands in the stitched hot path . in order to keep the notation simple , we only focus on type specialization of addition operations occurring in assignments , while one could also consider an analogous type specialization of boolean comparisons in conditional commands .",
    "this is defined as a program transform that instantiates most type - specific addition operations in place of generic untyped additions by exploiting the type information dynamically recorded by typed guards in @xmath388 .",
    "note that if @xmath562 and @xmath563 then @xmath564 , for some @xmath246 $ ] , where @xmath565 .",
    "let @xmath566 denote the extended set of commands which includes type specific additions @xmath567 and @xmath568 and , in turn , let @xmath569 denote the possibly type - specialized programs with commands ranging in @xmath566 .",
    "the semantic function @xmath77 for expressions is then updated to type specific additions as follows : @xmath570 given a hot path @xmath571 , the type specialization function @xmath572 is defined as follows : @xmath573 hence , if a typed guard @xmath561 preceding a command @xmath574 allows us to derive abstractly on @xmath537 that @xmath575 and @xmath576 have the same type ( @xmath521 or @xmath522 ) then the addition @xmath577 is accordingly type specialized .",
    "this function allows us to define the hot path type specialization optimization @xmath578 simply by @xmath579 in turn , as described in section  [ chpo - sec ] , this induces the full type specialization optimization @xmath580 @xmath581 is also called _ typed trace extraction _ since it extracts and simultaneously type specializes a typed hot path @xmath238 in a program @xmath35 .",
    "the correctness of this program optimization can be proved for the store changes observational abstraction by relying on lemma  [ lemma - corr ] .",
    "[ corr - tte ] for any typed hot path @xmath477 , we have that @xmath582 .",
    "let @xmath583 be the following type de - specialization function , where @xmath584 is either @xmath521 or @xmath522 : @xmath585 let us explain the first defining clause of @xmath586 , i.e. , @xmath587 and @xmath588 .",
    "these conditions can never hold in an inductive call of the function @xmath589 : in fact , when @xmath586 is recursively called by @xmath590 , we necessarily have that @xmath591 , so that @xmath592 , and , in turn , by corollary  [ coro - correct ] , @xmath593 , which implies @xmath594 , which is a contradiction .",
    "thus , the first defining clause of @xmath586 only applies to type specialized traces in @xmath595 whose first state is @xmath587 : in this case , we necessarily have that @xmath596 , because @xmath597 so that @xmath598 .",
    "this clarifies the definition of @xmath589 in this particular case .",
    "also , observe that in this case , @xmath599 trivially holds .",
    "in all the remaining cases , it is clear that @xmath589 maps type specialized traces into legal unspecialized traces of @xmath304 since labels are left unchanged .",
    "moreover , @xmath600 holds , in particular because in the second defining clause of @xmath586 , the condition @xmath594 guarantees that @xmath601 .    on the other hand ,",
    "we define a trace specialization function @xmath602 as follows : @xmath603        \\tuple{\\mu_0,\\operatorname{{\\text{\\rm ts}}}_{hp}(h_0 ) } \\!\\cdots\\",
    "!   \\tuple{\\mu_k,\\operatorname{{\\text{\\rm ts}}}_{hp}(h_k ) }       & \\hfill\\text{otherwise }            \\end{cases }      \\end{aligned}\\ ] ]    let us comment on this definition .",
    "if @xmath604 and @xmath605 then it may happen that the first state @xmath606 of @xmath7 is such that the command @xmath607 is @xmath608 and , since @xmath609 ( @xmath521 or @xmath522 ) , @xmath607 is type specialized to @xmath610 , while the store @xmath611 is not approximated by the abstract store @xmath559 , i.e. , @xmath612 .",
    "thus , in this case , the trace in @xmath613 beginning at @xmath614 is stuck , because the concrete semantics of addition is @xmath615 , and in turn @xmath616 , so that we necessarily have to define @xmath617 . otherwise , @xmath618 simply type specializes through @xmath619 all the commands ( actually , addition expressions ) occurring in @xmath7 .",
    "here , it turns out that @xmath620 is well - defined , i.e.  @xmath618 is a legal trace of @xmath613 , because any state @xmath621 of @xmath7 is always preceded by the state @xmath622 and @xmath623 must hold .",
    "thus , by corollary  [ coro - correct ] , @xmath624 , so that @xmath625 holds .",
    "consequently , the trace fragment @xmath626 is legal in @xmath613 .",
    "furthermore , let us also observe that @xmath627 trivially holds .",
    "thus , following the scheme in section  [ chpo - sec ] , these two functions @xmath589 and @xmath628 allow us to define @xmath629 and @xmath630 such that @xmath631 , so that the thesis follows by lemma  [ lemma - corr ] .",
    "[ sieve - ex]let us consider the following sieve of eratosthenes in a javascript - like language  this is taken from the running example in @xcite  where @xmath632 is an array initialized with 100 @xmath633 values :    with a slight abuse , we assume that our language is extended with arrays and boolean values ranging in the type @xmath55 .",
    "the semantics of read and store for arrays is standard : first , the index expression is checked to be in bounds , then the value is read or stored into the array . if the index is out of bounds then the corresponding action command gives @xmath197 , that is , we assume that the program generates an error ( e.g. , it is aborted ) .",
    "the above program is encoded in our language as follows : @xmath634 = { \\text{\\lstinline$tt$ } } { \\rightarrow}l_3,\\ , c_2^c\\equiv l_2 : \\neg(\\mathit{primes}[i ] = { \\text{\\lstinline$ff$ } } ) { \\rightarrow}l_7,\\\\       & c_3 \\equiv l_3 : k:=i+i { \\rightarrow}l_4,\\ ,         c_4 \\equiv l_4 : k<100 { \\rightarrow}l_5,\\ , c_4^c",
    "\\equiv l_4 : \\neg(k<100 ) { \\rightarrow}l_7,\\\\      & c_5 \\equiv l_5 : \\mathit{primes}[k ] : = { \\text{\\lstinline$ff$ } } { \\rightarrow}l_6,\\ , c_6 \\equiv l_6 : k:= k+i { \\rightarrow}l_4,\\\\      & c_7 \\equiv l_7 : i:= i+1 { \\rightarrow}l_1,\\ ,      c_8 \\equiv l_8 : { \\text{\\lstinline$skip$ } } { \\rightarrow}\\l\\big      \\}. \\end{aligned}\\ ] ]    let us consider the following type environment @xmath635/\\operatorname{bool } , i/\\operatorname{int } , k/\\operatorname{int}\\}\\in \\operatorname{store}^t\\ ] ] where @xmath636/\\operatorname{bool}$ ] is a shorthand for @xmath637/\\operatorname{bool},\\ldots,$ ] @xmath638/\\operatorname{bool}$ ] . then the first traced 2-hot path on the type abstraction @xmath537 is @xmath639 . as a consequence , the typed trace extraction of @xmath256 yields : @xmath640 where : @xmath641:\\operatorname{bool } , i:\\operatorname{int } , k:\\operatorname{int } ) \\rightarrow",
    "\\ell_0,\\\\       & h_0^c \\equiv l_{4 } : \\neg { \\mathit guard}\\ : ( \\mathit{primes}[n]:\\operatorname{bool } , i:\\operatorname{int } , k:\\operatorname{int } ) \\rightarrow      \\ok{\\overline{l_4}},\\\\                  & h_1 \\equiv \\ell_0 : k<100 { \\rightarrow}{\\mathbbm{l}}_1,\\,h_1^c \\equiv \\ell_0 : \\neg(k<100 ) { \\rightarrow}l_7,\\\\      & h_2 \\equiv { \\mathbbm{l}}_1 : { \\mathit guard}\\ : ( \\mathit{primes}[n]:\\operatorname{bool } , i:\\operatorname{int } , k:\\operatorname{int } ) \\rightarrow      \\ell_1,\\\\       & h_2^c \\equiv { \\mathbbm{l}}_1 : \\neg { \\mathit guard}\\ : ( \\mathit{primes}[n]:\\operatorname{bool } , i:\\operatorname{int } , k:\\operatorname{int } ) \\rightarrow      l_5,\\\\      & h_3 \\equiv \\ell_1 : \\mathit{primes}[k]:={\\text{\\lstinline$ff$ } } { \\rightarrow}{\\mathbbm{l}}_2,\\\\      & h_4 \\equiv { \\mathbbm{l}}_2 : { \\mathit guard}\\ : ( \\mathit{primes}[n]:\\operatorname{bool } , i:\\operatorname{int } , k:\\operatorname{int } ) \\rightarrow      \\ell_2,\\\\       & h_4^c \\equiv { \\mathbbm{l}}_2 : \\neg { \\mathit guard}\\ : ( \\mathit{primes}[n]:\\operatorname{bool } , i:\\operatorname{int } , k:\\operatorname{int } ) \\rightarrow l_6,\\\\         & h_5 \\equiv \\ell_2 : k:=k+_{\\operatorname{int } } i { \\rightarrow}l_4 \\big\\}.\\qed     \\end{aligned}\\ ] ]",
    "constant variable folding , a.k.a .",
    "constant propagation @xcite , is a standard and well - known program optimization , whose goal is to detect which program variables at some program point are constant on all possible executions and then to propagate these constant values as far forward through the program as possible .",
    "show how to define this optimization along hot paths and then prove its correctness . as a significant example",
    ", we show here how to specify and prove the correctness w.r.t .",
    "the store changes abstraction @xmath642 of this simple hot path optimization according to the approach defined in section  [ chpo - sec ] .",
    "the constant propagation store abstraction @xmath643 and its corresponding gi @xmath644 have been defined in example  [ cp - ex ] .",
    "following section  [ trace - ext - sec ] , any abstract store @xmath645\\in \\operatorname{cp_{\\!\\mathit{st}}}$ ] , where , as usual , the bindings @xmath646 are omitted , defines a corresponding @xmath647 whose semantics is induced by the gi @xmath644 , as defined in section  [ trace - ext - sec ] : for any @xmath71 , @xmath648)\\\\ \\bot & \\!\\!\\text{otherwise } \\end{cases } \\\\ & = \\begin{cases } \\rho & \\!\\!\\text{if }   \\forall i.\\ , \\rho(x_i ) \\in \\gamma_{cp}(a_i)\\\\ \\bot & \\!\\!\\exists i.\\ , \\rho(x_i ) \\not\\in \\gamma_{cp}(a_i ) \\end{cases}\\end{aligned}\\ ] ]    therefore , we have that : @xmath649 = \\bot,\\\\ & { \\mathbf{a}}\\grasse{\\text{guard}\\:x:2 , y:\\mathtt{foo } } [ x/2 , y/\\mathtt{foo } , z/4 ] = \\bot,\\\\ & { \\mathbf{a}}\\grasse{\\text{guard}\\:x:2 , y:\\mathtt{foo } } [ x/2 ] = \\bot,\\\\ & { \\mathbf{a}}\\grasse{\\text{guard}\\:x:2 , y:\\mathtt{foo } } [ x/2 , y/\\mathtt{foo } ] = [ x/2 , y/\\mathtt{foo}],\\\\ & { \\mathbf{a}}\\grasse{\\text{guard}\\:x:2 , y:\\top } [ x/2 , y/\\mathtt{foo } ] = [ x/2 , y/\\mathtt{foo}],\\\\ & { \\mathbf{a}}\\grasse{\\text{guard}\\:x:2 , y:\\top } [ x/2 ] = [ x/2].\\end{aligned}\\ ] ]    let us consider some hot path @xmath650 @xmath557 on the constant propagation abstraction @xmath643 , where each @xmath651 is therefore an abstract store in @xmath643 , whose corresponding guard in @xmath388 will be denoted by @xmath652 .",
    "the constant value information encoded in these guards is used to define the variable folding in the stitched hot path .",
    "following , let @xmath653 denote the function that returns the `` free '' variables occurring in some set of commands ( in particular , a well - defined program ) , i.e. , @xmath654 is the set of variables occurring in @xmath35 which are never - assigned - to in some command of @xmath35 . as in",
    ", constant variable folding is restricted to expressions @xmath90 of some assignment @xmath655 and is defined as a program transform which exploits the constant information recorded by abstract guards in @xmath388 .",
    "the constant folding function @xmath656 is defined as follows : @xmath657 \\!{\\rightarrow}\\ !",
    "l ' & \\!\\!\\text{if }         \\{y_1, ... ,y_k\\}=\\{y\\in { { \\mathit{vars}}}(e)\\cap \\operatorname{fv}(\\operatorname{\\mathit{stitch}}_{p}(hp))~|\\\\        &   \\hfill \\rho_i^c ( y)=v_y\\in \\operatorname{value}\\}\\neq\\varnothing    \\\\",
    "\\ell_i : x:= e { \\rightarrow}l ' & \\!\\!\\text{otherwise }         \\end{cases }   \\end{gathered}\\ ] ]    @xmath658 where @xmath659 $ ] denotes the standard synctatic substitution of variables @xmath660 with constant values @xmath661 .",
    "hence , when the abstract guard @xmath652 which precedes an assignment @xmath662 tells us that a free variable @xmath663 occuring in the expression @xmath90 is definitely a constant value @xmath664 then @xmath665 performs the corresponding variable folding in @xmath90 .",
    "thus , the hot path constant folding optimization is defined by @xmath666 and , in turn , this induces the full constant folding optimization @xmath667 .",
    "the correctness of this constant folding optimization can be proved for the store changes observational abstraction     for any hot path @xmath477 w.r.t .",
    "the constant propagation store abstraction @xmath643 , @xmath668 .",
    "this proof is omitted , since it follows the same pattern of theorem  [ corr - tte ] for the correctness of typed trace extraction , in particular it relies on lemma  [ lemma - corr ] .",
    "let us consider the following program written in a while - language :    whose translation as @xmath74 goes as follows : @xmath669 the first traced 2-hot path for the abstraction @xmath643 is : @xmath670,c_2 , [ x/\\top , a/2 ] , c_3 , [ x/\\top , a/2 ] , c_4}.\\ ] ] in fact , the initial prefix of the complete trace of @xmath35 which corresponds to the terminating run of @xmath35 is as follows : @xmath671,c_0}\\tuple{[x/0],c_1}\\tuple{[x/0,a/2],c_2}\\tuple{[x/0,a/2],c_3}\\tuple{[x/0,a/2],c_4 } \\tuple{[x/2,a/2],c_2}\\\\ \\tuple{[x/2,a/2],c_3}\\tuple{[x/2,a/2],c_4}\\tuple{[x/4,a/2],c_2}\\tuple{[x/4,a/2],c_3}\\tuple{[x/4,a/2],c_4}\\end{gathered}\\ ] ] so that @xmath672 .",
    "hence , the constant folding optimization @xmath673 along @xmath238 provides : @xmath674 where : @xmath675 \\rightarrow      \\ell_0,\\ ,      h_0^c \\equiv l_{2 } : \\neg { \\mathit guard}\\ : [ x\\!:\\!\\top , a\\!:\\!2 ] \\rightarrow      \\overline{l_2},\\\\      & h_1 \\equiv \\ell_0 : x\\leq 15 { \\rightarrow}{\\mathbbm{l}}_1,\\,h_1^c \\equiv \\ell_0 : \\neg(x\\leq 15 ) { \\rightarrow}l_7,\\\\      & h_2 \\equiv { \\mathbbm{l}}_1 : { \\mathit guard}\\ :   [ x\\!:\\!\\top , a\\!:\\!2 ] \\rightarrow      \\ell_1,\\ , h_2^c \\equiv { \\mathbbm{l}}_1 : \\neg { \\mathit guard}\\ : [ x\\!:\\!\\top , a\\!:\\!2 ] \\rightarrow      l_3,\\\\      & h_3 \\equiv \\ell_1 :   x\\leq 5 { \\rightarrow}{\\mathbbm{l}}_2,\\ , h_3^c \\equiv \\ell_1 :   \\neg(x\\leq 5 ) { \\rightarrow}l_5,\\\\      & h_4 \\equiv { \\mathbbm{l}}_2 : { \\mathit guard}\\ : [ x\\!:\\!\\top , a\\!:\\!2 ] \\rightarrow      \\ell_2,\\ ,      h_4^c \\equiv { \\mathbbm{l}}_2 : \\neg { \\mathit guard}\\ : [ x\\!:\\!\\top , a\\!:\\!2 ] \\rightarrow l_4,\\\\         & h_5 \\equiv \\ell_2 : x:=x+2 { \\rightarrow}l_2 \\big\\}.     \\end{aligned}\\ ] ] therefore , this hot path optimization allows us to fold the constant value @xmath253 for the variable @xmath148 , in the hot path command @xmath676 .",
    "once a first hot path @xmath256 has been extracted by transforming @xmath35 to @xmath677 , it may well happen that a new hot path @xmath257 in @xmath50 contains @xmath256 as a nested sub - path .",
    "following tracemonkey s trace recording strategy  @xcite , we attempt to nest an inner hot path inside the current trace : during trace recording , an inner hot path is called as a kind of `` subroutine '' , this executes a loop to a successful completion and then returns to the trace recorder that may therefore register the inner hot path as part of a new hot path .    in order to handle nested hot paths , we need a more general definition of hot path which takes into account previously extracted hot paths and a corresponding program transform for extracting nested hot paths .",
    "let @xmath35 be the original program and let @xmath678 be a hot path transform of @xmath35 so that @xmath679 contains all the commands ( guards included ) in the hot path .",
    "we define a function @xmath680 that cuts from an execution trace @xmath7 of @xmath678 all the states whose commands appear in some previous hot path @xmath238 except for the entry and exit states of @xmath238 : @xmath681    in turn , we define @xmath682 as follows : @xmath683 clearly , when @xmath684 it turns out that @xmath685 so that @xmath686 .",
    "we define the usual collecting version of @xmath687 on @xmath688 as the abstraction map @xmath689 .",
    "then , @xmath690 provides the set of @xmath0-hot paths in @xmath678 .",
    "[ ex - two]let us consider again example  [ ex - one ] , where @xmath166 is the trivial one - point store abstraction @xmath691 .",
    "in example  [ ex - one ] , we first extracted @xmath692 by transforming @xmath35 to @xmath693 .",
    "we then consider the following trace in @xmath694 : @xmath695,c_0}\\tuple{[x/0],h_0}\\tuple{[x/0],h_1}\\tuple{[x/0],h_2}\\tuple{[x/0],h_3 } \\tuple{[x/1],h_4}\\tuple{[x/1],h_5}\\cdots \\tuple{[x/2],h_3}\\\\   & \\tuple{[x/3],h_4}\\tuple{[x/3],h_5^c } \\tuple{[x/3],c_4}\\tuple{[x/6],h_0}\\cdots \\tuple{[x/9],h_5^c}\\tuple{[x/9],c_4 } \\tuple{[x/12],h_0}\\cdots\\end{aligned}\\ ] ]    thus , here we have that @xmath696,c_0}\\tuple{[x/0],h_0}\\tuple{[x/3],h_5^c } \\tuple{[x/3],c_4 } \\tuple{[x/6],h_0 }   \\tuple{[x/9],h_5^c}\\tuple{[x/9],c_4}\\cdots\\ ] ] so that @xmath697 .",
    "hence , @xmath257 contains a nested hot path , which is called at the beginning of @xmath257 and whose entry and exit commands are , respectively , @xmath607 and @xmath698 .",
    "let @xmath699 be a @xmath0-hot path in @xmath678 , where , for all @xmath246 $ ] , we assume that @xmath700 .",
    "let us note that :    * if for all @xmath246 $ ] , @xmath701 then @xmath238 actually is a hot path in @xmath35 , i.e. , @xmath702 .",
    "* otherwise , there exists some @xmath703 . if @xmath701 and @xmath704 then @xmath705 is the entry command of some inner hot path ; on the other hand , if @xmath706 and @xmath707 then @xmath247 is the exit command of some inner hot path .",
    "the transform of @xmath678 for extracting @xmath238 is then given as the following generalization of definition  [ tet - def ] .",
    "[ tet - def2 ] the _ nested trace extraction transform _ of @xmath678 for the hot path @xmath708 is : @xmath709 , c_i , c_{i+1 } \\in p\\ } \\cup \\{\\hbar_n : act(c_n ) { \\rightarrow}l_0~|~c_n\\in p\\}\\\\      ( 5)\\quad\\qquad & \\mkern-30mu\\cup \\{\\hbar_i : \\neg act(c_{i } ) \\rightarrow l_{\\textit{next}(i)}^c~|~      i\\in [ 0,n ] , c_i , cmpl(c_i ) \\in p\\}\\\\      ( 6)\\quad\\qquad & \\mkern-30mu\\cup \\{{\\mathbbm{h}}_i : { { { \\mathit guard}}}~ e_{a_i } { \\rightarrow}\\hbar_i , { \\mathbbm{h}}_i : \\neg { { { \\mathit guard}}}~ e_{a_i } { \\rightarrow}l_i   ~|~ i\\in [ 1,n ] , c_i \\in p\\}\\\\      ( 7)\\quad\\qquad & \\mkern-30mu\\cup \\{\\hbar_i : act(c_{i } ) \\rightarrow l_{i+1}~|~      i\\in [ 0,n-1 ] , c_i\\in p , c_{i+1 } \\not\\in p\\ } \\\\      ( 8)\\quad\\qquad & \\mkern-30mu\\smallsetminus \\{c_i ~|~ i\\in [ 0,n-1 ] , c_i \\not\\in p , c_{i+1}\\in p\\}\\\\     ( 9)\\quad\\qquad & \\mkern-30mu\\cup \\{l_i : act(c_{i } ) \\rightarrow { \\mathbbm{h}}_{i+1}~|~      i\\in [ 0,n-1 ] , c_i\\not\\in p , c_{i+1 } \\in p\\ }          \\end{aligned}\\ ] ] where we define @xmath710 .",
    "let us observe that :    * clauses ( 1)(6 ) are the same clauses of the trace extraction transform of definition  [ tet - def ] , with the additional constraint that all the commands @xmath247 of @xmath238 are required to belong to the original program @xmath35 .",
    "this is equivalent to ask that any @xmath247 is not the entry or exit command of a nested hot path inside @xmath238 , i.e. , @xmath711 . in definition  [ tet - def ] , where no previous hot path extraction is assumed",
    ", any command @xmath247 of @xmath238 belongs to @xmath35 , so that this constraint is trivially satisfied .",
    "* clause ( 7 ) where @xmath701 and @xmath712 , namely @xmath713 is the call program point of a nested hot path @xmath714 and @xmath705 is the entry command of @xmath714 , performs a relabeling that allows to neatly nest @xmath714 in @xmath238 .",
    "* clauses ( 8)(9 ) where @xmath715 and @xmath707 , i.e. , @xmath247 is the exit command of a nested hot path @xmath714 that returns to the program point @xmath716 , performs the relabeling of @xmath717 in @xmath247 in order to return from @xmath714 to @xmath238 ; * @xmath718 , @xmath719 and @xmath720 are meant to be fresh labels , i.e. , they have not been already used in @xmath678 .",
    "[ ex - three ] let us go on with example  [ ex - two ] .",
    "the second traced hot path in @xmath721 is : @xmath722 according to definition  [ tet - def2 ] , trace extraction of @xmath257 in @xmath50 yields the following transform : @xmath723}\\qquad    & p_1 \\smallsetminus \\{h_5^c\\}\\\\     \\text{[by clause~(9)]}\\qquad & \\cup \\ { \\ell_2:(x\\%3 = 0 ) { \\rightarrow}{\\mathbbm{h}}_2\\}\\\\      \\text{[by clause~(6)]}\\qquad&\\cup \\ { { \\mathbbm{h}}_2 : { { { \\mathit guard}}}~e_\\top { \\rightarrow}\\hbar_2 , { \\mathbbm{h}}_2 : \\neg{{{\\mathit guard}}}~e_\\top { \\rightarrow}l_4\\}\\\\      \\text{[by clause~(4)]}\\qquad&\\cup \\ { \\hbar_2 : x:=x+3 { \\rightarrow}l_1\\ }         \\end{aligned}\\ ] ] where we used the additional fresh labels @xmath724 and @xmath725 .",
    "let us consider again example  [ sieve - ex ] .",
    "after the trace extraction of @xmath256 that transforms @xmath35 to @xmath50 , a second traced 2-hot path is the following : @xmath726 where @xmath727/\\operatorname{bool } , i/\\operatorname{int } , k/\\operatorname{int}\\}\\in \\operatorname{store}^t$ ] .",
    "thus , @xmath257 contains a nested hot path which is called at @xmath728 and whose entry and exit commands are , respectively , @xmath607 and @xmath729 . here , typed trace extraction according to definition  [ tet - def2 ] provides the following transform of @xmath50 : @xmath730:\\operatorname{bool } , i:\\operatorname{int } , k:\\operatorname{int } ) \\rightarrow      \\hbar_0,\\\\       & h_6^c\\equiv l_{1 } : \\neg { \\mathit guard}\\ : ( \\mathit{primes}[n]:\\operatorname{bool } , i:\\operatorname{int } , k:\\operatorname{int } ) \\rightarrow      \\overline{h_0},\\\\              & h_7\\equiv \\hbar_0 : i<100 { \\rightarrow}{\\mathbbm{h}}_1,\\,h_7^c\\equiv \\hbar_0 : \\neg(i<100 ) { \\rightarrow}l_8,\\\\      & h_{8}\\equiv { \\mathbbm{h}}_1 : { \\mathit guard}\\ : ( \\mathit{primes}[n]:\\operatorname{bool } , i:\\operatorname{int } , k:\\operatorname{int } )       { \\rightarrow}\\hbar_1,\\\\       & h_{8}^c \\equiv { \\mathbbm{h}}_1 : \\neg       { \\mathit guard}\\ : ( \\mathit{primes}[n]:\\operatorname{bool } , i:\\operatorname{int } , k:\\operatorname{int } )       { \\rightarrow}l_2,\\\\      & h_{9}\\equiv \\hbar_1 : \\mathit{primes}[i]={\\mathit tt } { \\rightarrow}{\\mathbbm{h}}_1,\\ ,      h_{9}^c\\equiv \\hbar_1 : \\neg(\\mathit{primes}[i]={\\mathit tt } ) { \\rightarrow}l_7,\\\\      & h_{10}\\equiv { \\mathbbm{h}}_2 : { \\mathit guard}\\ : ( \\mathit{primes}[n]:\\operatorname{bool } , i:\\operatorname{int } , k:\\operatorname{int } )       { \\rightarrow}\\hbar_2,\\\\       & h_{10}^c \\equiv { \\mathbbm{h}}_2 : \\neg       { \\mathit guard}\\ : ( \\mathit{primes}[n]:\\operatorname{bool } , i:\\operatorname{int } , k:\\operatorname{int } )       { \\rightarrow}l_3,\\\\      & h_{11}\\equiv \\hbar_2 : k:=i+_{\\operatorname{int } } i { \\rightarrow}l_4 \\big \\}\\\\      & \\smallsetminus \\{h_1^c\\ } \\cup \\big\\{(h_1^c ) ' \\equiv \\ell_0 : \\neg(k<100 ) { \\rightarrow}{\\mathbbm{h}}_3,\\\\       & h_{12}\\equiv { \\mathbbm{h}}_3 : { \\mathit guard}\\ : ( \\mathit{primes}[n]:\\operatorname{bool } , i:\\operatorname{int } , k:\\operatorname{int } )       { \\rightarrow}\\hbar_3,\\\\       & h_{12}^c \\equiv { \\mathbbm{h}}_3 : \\neg       { \\mathit guard}\\ : ( \\mathit{primes}[n]:\\operatorname{bool } , i:\\operatorname{int } , k:\\operatorname{int } )       { \\rightarrow}l_7,\\\\      & h_{13}\\equiv \\hbar_3 : i:=i+_{\\operatorname{int } } 1 { \\rightarrow}l_1\\big\\}.     \\end{aligned}\\ ] ] finally , a third traced 2-hot path in @xmath51 is @xmath731 which contains a nested hot path which is called at the beginning of @xmath732 and whose entry and exit commands are , respectively , @xmath733 and @xmath734 . here ,",
    "typed trace extraction of @xmath732 yields : @xmath735= { \\mathit tt } ) { \\rightarrow}{\\mathbbm{j}}_2,\\,\\\\      & { \\mathbbm{j}}_2 : { \\mathit guard}\\ : ( \\mathit{primes}[n]:\\operatorname{bool } , i:\\operatorname{int } , k:\\operatorname{int } )       { \\rightarrow}\\jmath_2,\\\\       & { \\mathbbm{j}}_2 : \\neg       { \\mathit guard}\\ : ( \\mathit{primes}[n]:\\operatorname{bool } , i:\\operatorname{int } , k:\\operatorname{int } )       { \\rightarrow}l_7,\\\\      & \\jmath_2 : i:=i+_{\\operatorname{int } } 1 { \\rightarrow}l_1    \\big\\}.     \\end{aligned}\\ ] ] we have thus obtained the same three trace extraction steps described by .",
    "in particular , in @xmath50 we specialized the typed addition operation @xmath736 , in @xmath51 we specialized @xmath737 and @xmath738 , while in @xmath739 we specialized once again @xmath738 in a different hot path .",
    "thus , in @xmath739 all the addition operations occurring in assignments have been type specialized .",
    "a formal model for tracing jit compilation has been put forward at popl  2011 symposium by .",
    "its main distinctive feature is the use of a bisimulation relation @xcite to model the operational equivalence between source and optimized programs . in this section ,",
    "we show how this model can be expressed within our framework .",
    "rely on a simple imperative language ( without jumps and ) with while loops and a so - called bail construct .",
    "its syntax is as follows : @xmath740 where @xmath2 stands for the empty string .",
    "thus , any statement @xmath741 is a ( possibly empty ) sequence of commands @xmath742 , with @xmath743 .",
    "we follow in making an abuse in program syntax by assuming that if @xmath744 then @xmath745 , where @xmath746 denotes a simple string concatenation of @xmath747 and @xmath748 .",
    "we denote by @xmath749 the set of states for this language .",
    "the baseline small - step operational semantics @xmath750 is standard and is given in continuation - style ( where @xmath751 ) : @xmath752 \\tuple{\\rho , \\kwsty{skip } ; k } { \\rightarrow}_b \\tuple{\\rho , k } &   \\\\[5pt ] \\tuple{\\rho , x:=e ; k } { \\rightarrow}_b \\tuple{\\rho[x/{\\mathbf{e}}\\grasse{e}\\rho],k } &   \\\\[5pt ] \\tuple{\\rho , ( \\kwsty{if}~b~\\kwsty{then}~s ) k } { \\rightarrow}_b   \\begin{cases } \\tuple{\\rho , k } &   \\text{if}~{\\mathbf{b}}\\grasse{b}\\rho = \\textit{false}\\\\ \\tuple{\\rho , s k } &   \\text{if}~{\\mathbf{b}}\\grasse{b}\\rho = \\textit{true}\\\\ \\end{cases}\\\\[15pt ] \\tuple{\\rho , ( \\kwsty{while}~b~\\kwsty{do}~s ) k } { \\rightarrow}_b \\tuple{\\rho , ( \\kwsty{if}~b~\\kwsty{then}~(s\\ , \\kwsty{while}~b~\\kwsty{do}~s))\\ , k } & \\\\[5pt ] \\tuple{\\rho , ( \\kwsty{bail}~b~\\kwsty{to}~s ) k } { \\rightarrow}_b   \\begin{cases } \\tuple{\\rho , k } &   \\text{if}~{\\mathbf{b}}\\grasse{b}\\rho = \\textit{false}\\\\ \\tuple{\\rho , s } &   \\text{if}~{\\mathbf{b}}\\grasse{b}\\rho = \\textit{true } \\end{cases } \\end{array}\\ ] ]    the relation @xmath753 is clearly deterministic and we denote by @xmath754 the set of generic program traces for guo and palsberg s language . then , given a program @xmath755 , so that @xmath756 denotes the set of stores for @xmath528 , its partial trace semantics is @xmath757 notice that , differently from our trace semantics , a partial trace of the program @xmath528 always starts from an initial state , i.e. , @xmath758 .",
    "programs in @xmath759 can be compiled into @xmath43 by resorting to an _ injective _ labeling function @xmath760 that assigns different labels to different statements .    [ compilation ] the `` first command '' compilation function @xmath761 is defined as follows : @xmath762    then , the full compilation function @xmath763 is recursively defined by the following clauses : @xmath764 given @xmath741 , @xmath765 is the initial label of @xmath766 , while @xmath29 is , as usual , the undefined label where the execution becomes stuck . @xmath767",
    "it turns out that the recursive function @xmath768 is well - defined  the easy proof is standard and is omitted , let us just observe that @xmath769 is a base case  so that , for any @xmath741 , @xmath766 is a finite set of commands .",
    "let us observe that , by definition  [ compilation ] , if @xmath770 then @xmath771 ( this can be proved through an easy structural induction on @xmath528 ) .",
    "consequently , if @xmath772 then @xmath771 .",
    "[ ex - compilation ] consider the following program @xmath773 in guo and palsberg s syntax :    @xmath528 is then compiled in our language by @xmath768 in definition  [ compilation ] as follows : @xmath774 notice that in the command @xmath775 , the label @xmath776 stands for @xmath777 so that @xmath778 , i.e. , after the execution of @xmath779 the program terminates .    correctness for the above compilation function @xmath768 means that for any @xmath741 : ( i )  @xmath780 and ( ii )  program traces of @xmath528 and @xmath766 have the same store sequences . in the proof",
    "we will make use of a `` state compile '' function @xmath781 as defined in figure  [ scfun ] . in turn",
    ", @xmath782 allows us to define a `` trace compile '' function @xmath783 which applies state - by - state the function @xmath782 to traces as follows : @xmath784    @xmath785    [ sc - tc - lemma ]    1 .",
    "@xmath786 2 .",
    "@xmath787 is well - defined .",
    "we show the equivalence ( 1 ) by structural induction on @xmath741 .",
    "@xmath788 $ ] : trivially true , since @xmath789 and @xmath790 .    @xmath791 $ ] @xmath792 : if @xmath793,k}$ ] , @xmath794 and @xmath795 , k } ) = \\tuple{\\rho[x/{\\mathbf{e}}\\grasse{e}\\rho ] , { { \\textbf{\\em l}}}(k ) : a { \\rightarrow}{{\\textbf{\\em l}}}(s')}$ ] for some action @xmath158 and statement @xmath796 , then , by definition of the transition semantics @xmath126 , @xmath797 , { { \\textbf{\\em l}}}(k ) : a { \\rightarrow}{{\\textbf{\\em l}}}(s ' ) } \\in   { \\mathbf{s}}\\tuple{\\rho , { { \\textbf{\\em l}}}(s):x:=e { \\rightarrow}{{\\textbf{\\em l}}}(k)}$ ] .",
    "@xmath798 : if @xmath799 then : ( 1 )  @xmath800 , ( 2 )  @xmath801 $ ] , and therefore @xmath802 $ ] ; ( 3 )  @xmath803 , and therefore @xmath804 .",
    "hence , @xmath805,k}=\\tuple{\\rho',s'}$ ] .    @xmath806 $ ] analogous to @xmath807 .",
    "@xmath808 $ ] @xmath792 : assume that @xmath809 , so that @xmath810 , @xmath811 and @xmath812 for some @xmath158 and @xmath813 . hence , by definition of @xmath126 , @xmath814 .",
    "on the other hand , if @xmath815 then @xmath816 , @xmath817 and @xmath818 for some @xmath158 and @xmath819 . hence , @xmath820 .",
    "@xmath798 : assume that @xmath809 , so that @xmath811 , and @xmath821 . hence : ( 1 )  @xmath822 and therefore @xmath823 ; ( 2 )  @xmath803 , and therefore @xmath804 .",
    "hence , @xmath824 . on the other hand , if @xmath815 then @xmath817 and @xmath825 .",
    "we thus have that : ( 1 )  @xmath822 and therefore @xmath823 ; ( 2 )  @xmath826 , and therefore @xmath827 . hence , @xmath828 .",
    "@xmath829 $ ] @xmath792 : we have that @xmath830 and @xmath831 . if @xmath815 then @xmath832 ; on the other hand , if @xmath809 then @xmath833 . in both cases , we have that : @xmath834    @xmath798 : if @xmath835 then : ( 1 )  @xmath822 , and therefore @xmath823 ; ( 2 )  @xmath836 , and therefore @xmath837 . hence , @xmath838",
    ".    @xmath839 $ ] analogous to @xmath840 .",
    "let us now turn to point  ( 2 ) . by the @xmath841 implication of the equivalence @xmath842 , we have that if @xmath843 then @xmath844 : this can be shown by an easy induction on the length of @xmath217 and by using the fact that if @xmath845 then , for any @xmath14 , @xmath846 .",
    "moreover , since @xmath765 is the initial label of the compiled program @xmath766 and @xmath847 , we also notice that @xmath848",
    ". therefore , @xmath787 is a well - defined function",
    ".    let @xmath849 be the function that returns the store sequence of any trace , that is : @xmath850 also , given a set @xmath1 of traces , let @xmath851 .",
    "then , correctness of the compilation function @xmath768 goes as follows :    if @xmath741 then @xmath780 and @xmath852 .",
    "we define a `` trace de - compile '' function @xmath853 as follows .",
    "consider a trace @xmath854 , so that @xmath855 , for any @xmath246 $ ] , @xmath856 and for any @xmath857 , @xmath858 .",
    "since @xmath855 , by definition of @xmath782 , we have that @xmath859 .",
    "then , since @xmath860 , there exists @xmath861 such that @xmath862 , so that , @xmath863 .",
    "hence , from @xmath864 , by the implication @xmath865 of lemma  [ sc - tc - lemma ]  ( 1 ) , we obtain that @xmath866 .",
    "thus , an easy induction allows us to show that for any @xmath867 $ ] there exists @xmath868 such that @xmath869 and @xmath870 .",
    "we therefore define @xmath871 . moreover",
    ", we notice that @xmath872 .",
    "let us also observe that @xmath873 , since @xmath787 does not affect stores .",
    "summing up , we obtain : @xmath874}\\\\ \\alpha_{{\\mathit{st}}}({{\\mathcal{c}^t}}({\\mathbf{t}}_{{{\\mathit{gp}}}}\\grasse{s } ) )   & \\subseteq\\text{\\quad[by lemma~\\ref{sc - tc - lemma}~(2 ) , $ { { \\mathcal{c}^t}}$ is well - defined]}\\\\ \\alpha_{{\\mathit{st}}}({\\mathbf{t}}^\\iota\\grasse{{\\mathcal{c}}(s ) } ) & = \\text{\\quad[since $ st\\circ { { \\mathcal{d}^t}}= st$]}\\\\ \\alpha_{{\\mathit{st}}}({{\\mathcal{d}^t}}({\\mathbf{t}}^\\iota\\grasse{{\\mathcal{c}}(s ) } ) )   & \\subseteq\\text{\\quad[since $ { { \\mathcal{d}^t}}$ is well - defined]}\\\\ \\alpha_{{\\mathit{st}}}({\\mathbf{t}}_{{{\\mathit{gp}}}}\\grasse{s } )   & \\end{aligned}\\ ] ] and this closes the proof .",
    "correctness of trace extraction in @xcite relies on a notion of bisimulation relation , parameterized by program stores .",
    "let us recall this definition .",
    "if @xmath875 then this `` silent '' transition that does not change the store is also denoted by @xmath876 . moreover , for the assignment transition @xmath877,k}$ ] , if @xmath878 $ ] denotes the corresponding store update of @xmath69 then this transition is also denoted by @xmath879,k}$ ] .",
    "let @xmath880 is a store update@xmath881 .",
    "then , for a nonempty sequence of actions @xmath882 , we define : @xmath883 namely , there may be any number of silent transitions either in front of or following any @xmath293-transition @xmath884 .",
    "moreover , if @xmath885 is a nonempty sequence of actions then @xmath886 denotes the possibly empty sequence of actions where all the occurrences of @xmath217 are removed .",
    "a relation @xmath887 is a _ bisimulation _ when @xmath888 implies :",
    "1 .   if @xmath889 then @xmath890 , for some @xmath891 such that @xmath892 ; 2 .   if @xmath893 then @xmath894 , for some @xmath895 such that @xmath892 .",
    "@xmath747 is bisimilar to @xmath748 for a given @xmath71 , denoted by @xmath896 , if @xmath888 for some bisimulation @xmath897 .",
    "let us remark that if @xmath898 then @xmath899 , so that @xmath900 is allowed to be the matching ( empty ) transition sequence .",
    "it turns out that bisimilarity can be characterized through an abstraction of traces that observes store changes . by a negligible abuse of notation ,",
    "the store changes function @xmath901 defined in section  [ obs ] is applied to gp traces , so that @xmath902 . in turn , given @xmath71 , the function @xmath903 is then defined as follows : @xmath904 it is worth remarking that @xmath905 is a weaker abstraction than @xmath337 defined in section  [ obs ] , that is , for any @xmath906 , @xmath907 ( while the converse does not hold in general ) .",
    "[ bis - abs - th ] for any @xmath744 , @xmath71 , we have that @xmath896 iff @xmath908 .",
    "@xmath792 : we prove that if @xmath888 holds for some bisimulation @xmath897 then @xmath909 ( the reverse containment is symmetric ) , that is , if @xmath910 for some @xmath911 such that @xmath912 then there exists some @xmath913 such that @xmath914 and @xmath915 .",
    "let us then consider @xmath911 such that @xmath912 .",
    "if @xmath916 then we pick @xmath917 so that @xmath918 . otherwise , @xmath919 , with @xmath920 .",
    "we prove by induction on @xmath921 that there exists @xmath922 such that @xmath923 and @xmath924 .",
    "@xmath925 : in this case , @xmath926 , so that @xmath927 . since , by hypothesis , @xmath888 holds , we have that @xmath928 , for some @xmath929 , and @xmath924 .",
    "let @xmath930 be the trace corresponding to the sequence of transitions @xmath928 .",
    "then , by definition of @xmath931 , we have that @xmath932 , and , by definition of bisimulation , @xmath933 holds .",
    "@xmath934 : here , @xmath935 and @xmath919 , with @xmath936 .",
    "hence , @xmath937 . by inductive hypothesis",
    ", there exists @xmath938 such that @xmath939 and @xmath940 .",
    "since @xmath941 and @xmath940 holds , we obtain that @xmath942 , for some @xmath929 , and @xmath924 holds .",
    "let @xmath943 be the sequence of states corresponding to the sequence of transitions @xmath942 so that we pick @xmath944 .",
    "the condition @xmath924 already holds .",
    "moreover , by definition of @xmath931 , we have that @xmath945 , and therefore we obtain @xmath946 .",
    "@xmath798 : we first observe the following property @xmath947 , which is a straight consequence of the fact that @xmath753 is a deterministic relation : if @xmath741 and @xmath948 are such that @xmath949 and @xmath950 then there exists some @xmath951 such that @xmath952 .",
    "given @xmath266 , we assume that @xmath908 and we then define the following relation @xmath897 : @xmath953 we show that @xmath897 is a bisimulation , so that @xmath954 follows .",
    "( case a ) assume that @xmath889 .",
    "then , since @xmath955 and @xmath908 , we have that there exists @xmath956 such that @xmath957 .",
    "hence , @xmath217 necessarily has the following shape : @xmath958 where @xmath743 ( @xmath959 means that @xmath960 is indeed the empty sequence ) and @xmath961 . this therefore means that @xmath962 , so that , by definition of @xmath897 , @xmath963 holds .",
    "( case b ) assume now that @xmath964 holds because @xmath965 , @xmath966 and @xmath967 .",
    "hence , let us suppose that @xmath968 . then , since @xmath969 and @xmath908 , we have that there exists @xmath956 such that @xmath970 .",
    "( case b1 ) : :    if @xmath971 then , by the property    @xmath947 above , @xmath952 , for some    @xmath951 . hence ,    @xmath972    is a prefix of    @xmath973 .    consequently ,    @xmath974 can    be a prefix of @xmath975 only    if    @xmath976 ,    so that the action @xmath148 is @xmath217 and    @xmath977 , that is ,    @xmath978 .",
    "we thus consider the empty transition sequence    @xmath979 ,    so that from    @xmath980 ,    by definition of @xmath897 we obtain that    @xmath981 holds .",
    "( case b2 ) : :    if @xmath982 then , by @xmath947 above ,    @xmath983 , for some @xmath951 , i.e. ,    @xmath984 , for some    @xmath985 and @xmath986 .",
    "since    @xmath987    and    @xmath988 ,    we derive that @xmath989 and    @xmath990 .    by definition of @xmath897 , @xmath991    holds .",
    "this closes the proof .",
    "let us recall the set of rules that define the tracing transitions in guo and palsberg  @xcite model .",
    "let @xmath992 denote the set of states in trace recording mode , whose components are , respectively , the current store , the entry point of the recorded trace ( this is always a while statement ) , the current trace ( i.e. , a sequence of commands ) and the current program to be evaluated . in turn",
    ", @xmath993 denotes the corresponding extended notion of state , which encompasses the trace recording mode .",
    "then , the relation @xmath994 is defined by the clauses in figure  [ trace - rel ] , where @xmath995 is a `` sound '' optimization function that depends on a given store .",
    "correspondingly , the trace semantics @xmath996 of a program @xmath741 is naturally extended to the relation @xmath997 .",
    "@xmath998 ( t_3)\\quad \\tuple{\\rho , k_w , t , x:=e ; k } { \\rightarrow}_t \\tuple{\\rho[x/{\\mathbf{e}}\\grasse{e}\\rho],k_w , t ( x:=e;\\ ! ) , k }    \\\\[5pt ] ( t_4)\\quad \\tuple{\\rho , k_w , t , ( \\kwsty{if}~b~\\kwsty{then}~s ) k } { \\rightarrow}_t   \\begin{cases } \\tuple{\\rho , k_w , t ( \\kwsty{bail}~b~\\kwsty{to}~(sk)),k }   & \\text{if}~{\\mathbf{b}}\\grasse{b}\\rho = \\textit{false}\\\\ \\tuple{\\rho , k_w , t ( \\kwsty{bail}~\\neg b~\\kwsty{to}~k),sk } &   \\text{if}~{\\mathbf{b}}\\grasse{b}\\rho = \\textit{true}\\\\[5pt ] \\end{cases } \\\\ ( t_5)\\quad \\tuple{\\rho , k_w , t , ( \\kwsty{while}~b~\\kwsty{do}~s ) k } { \\rightarrow}_t   \\begin{cases } \\tuple{\\rho , k_w , t ( \\kwsty{skip } ; ) , ( \\kwsty{if}~b~\\kwsty{then}~(s\\ , \\kwsty{while}~b~\\kwsty{do}~s))\\ , k } & \\\\ \\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\quad",
    "\\text{if}~k_w \\not\\equiv ( \\kwsty{while}~b~\\kwsty{do}~s ) k\\\\ \\tuple{\\rho , o(\\kwsty{while}~b~\\kwsty{do}~t,\\rho ) k }   \\hfill   \\text{if}~k_w \\equiv ( \\kwsty{while}~b~\\kwsty{do}~s ) k\\\\[5pt ] \\end{cases } \\\\ ( t_6)\\quad \\tuple{\\rho , k_w , t , s } { \\rightarrow}_t \\tuple{\\rho',s'}\\quad \\text{if~ } k_w \\not\\equiv s \\text{~and~ } \\tuple{\\rho , s}{\\rightarrow}_b \\tuple{\\rho',s'}\\\\[5pt ] \\end{array}\\ ] ]    let us notice that in guo and palsberg s model of hot paths :    1 .   by clause @xmath999 , trace recording is always triggered by an unfolded while loop , and the loop itself is not included in the hot path .",
    "2 .   by clause @xmath1000 ,",
    "when we bail out of a hot path @xmath1001 through a @xmath1002 command , we can not anymore re - enter into @xmath1001 .",
    "3 .   by clause",
    "@xmath1003the second condition of this clause is called stitch rule in @xcite  the store used to optimize a hot path @xmath1001 is recorded at the end of the first loop iteration .",
    "this is a concrete store which is used by @xmath465 to optimize the stitched hot path @xmath1004 .",
    "hot paths actually are @xmath1005-hot paths according to our definition , since , by clause  @xmath999 , once the first iteration of the traced while loop is terminated , trace recording necessarily discontinues .",
    "there are no clauses for trace recording commands .",
    "hence , when trying to trace a loop that already contains a nested hot path , by clause @xmath1006 , trace recording is aborted when a command is encountered .",
    "in other terms , in contrast to our approach described in section  [ mte - sec ] , nested hot paths are not allowed .",
    "observe that when tracing a loop @xmath1007 whose body @xmath528 does not contain branching commands , i.e.  @xmath1008 or @xmath1009 statements , it turns out that the hot path @xmath1001 coincides with the body @xmath528 , so that @xmath1010 , namely , in this case the hot path transform does not change the subject while loop .    in the following ,",
    "we show how this hot path extraction model can be formalized within our trace - based approach . to this aim",
    ", we do not consider optimizations of hot paths , which is an orthogonal issue here , so that we assume that @xmath465 performs no optimization , that is , @xmath1011 .",
    "a sequence of commands @xmath1012 is defined to be a gp hot path for a program @xmath1013 when we have the following transition sequence : @xmath1014 since the operational semantics @xmath1015 is given in continuation - style , without loss of generality , we assume that the program @xmath138 begins with a while statement , that is @xmath1016 .",
    "guo and palsberg s hot loops can be modeled in our framework by exploiting a revised loop selection map",
    "@xmath1017 defined as follows : @xmath1018.\\ ,         c_{k } \\not\\in\\ { c_{i},cmpl(c_{i})\\}\\big\\}.   \\end{gathered}\\ ] ]    thus , @xmath1019 contains sequences of commands without store .",
    "the map @xmath1020 then lifts @xmath1021 to sets of traces as usual : @xmath1022 .",
    "then , let us consider a gp hot path @xmath1001 as recorded by a transition sequence @xmath217 : @xmath1023 where @xmath1024 .",
    "hence , the @xmath1025 s occurring in @xmath217 are the current statements to be evaluated . with a negligible abuse of notation , we assume that @xmath1026 , that is , the arrow symbols @xmath753 and @xmath1027 are taken out of the sequence @xmath217 . by lemma  [ sc - tc - lemma ]",
    "( 2 ) , we therefore consider the corresponding execution trace @xmath1028 of the compiled program @xmath1029 , where the state compile function @xmath782 in figure  [ scfun ] , when applied to states in trace recording mode , is assumed to act on the current store and the program to be evaluated , that is , @xmath1030 .",
    "we thus obtain : @xmath1031 we therefore obtain a hot path @xmath1032 , i.e.   @xmath1033 , where @xmath1034 . this is a consequence of the fact that for all @xmath1035 $ ] , @xmath222 can not be the entry command @xmath241 or its complement command , because , by the stitch rule of clause @xmath1003 , @xmath1036 is necessarily the first occurrence of @xmath1037 as current program to be evaluated in the trace @xmath217 , so that , for any @xmath1035 $ ] , @xmath1038 .",
    "we have thus shown that any gp hot path arising from a trace @xmath217 generates a corresponding hot path extracted by our selection map @xmath1021 on the compiled trace @xmath1028 :    [ lemma - gphp ] let @xmath1039 .",
    "if @xmath1001 is a gp hot path for @xmath1040 where @xmath1041 is the transition sequence @xmath1042 that records @xmath1001 , then there exists a hot path @xmath1043 such that , for any @xmath246 $ ] , @xmath1044 , and , in particular , @xmath1045 .",
    "[ trace - ex1 ] let us consider the while statement @xmath1040 of the program in example  [ example - init ] : @xmath1046    this program is already written in guo and palsberg language , so that @xmath1040 is a well formed statement in @xmath759 .",
    "the tracing rules in figure  [ trace - rel ] yield the following trace @xmath1001 for @xmath1040 : @xmath1047 on the other hand , the compiled program @xmath1048 is as follows : @xmath1049 where labels have the following meaning : @xmath1050    hence , in correspondence with the trace @xmath1001 , we obtain the hot path @xmath1051 . in turn",
    ", this hot path @xmath1052 corresponds to the 2-hot path @xmath256 consisting of the analogous sequence of commands , which has been selected in example  [ ex - zero ] .      in the following , we conform to the notation used in section  [ trace - ext - sec ] for our trace extraction transform .",
    "let us consider a while program @xmath1053 and its compilation @xmath1054 .",
    "observe that , by definition  [ compilation ] of compilation @xmath768 , a hot path @xmath1055 for the compiled program @xmath1056 always arises in correspondence with some while loop @xmath1057 occurring in @xmath1040 and therefore has necessarily the following shape : @xmath1058 the gp hot path extraction scheme for @xmath1040 described by the rules in figure  [ trace - rel ] can be defined in our language by the following simple transform of @xmath1056 .",
    "[ gp - tt - def ] the _ gp trace extraction transform _",
    "@xmath1059 of @xmath1056 for the hot path @xmath1060 is defined as follows :",
    "if for any @xmath1061 $ ] , @xmath1062 then @xmath1063 ; 2 .   otherwise : = -10pt @xmath1064\\}\\\\      & \\cup \\{\\ell_i : \\neg act(c_i ) \\rightarrow l_{\\textit{next}(i)}^c ~|~ i\\in [ 0,n],\\ ,   cmpl(c_{i})\\in p_w\\}.      \\end{aligned}\\ ] ] @xmath767    clearly , @xmath1065 remains a well - formed program .",
    "also observe that the case  ( 1 ) of definition  [ gp - tt - def ] means that the traced hot path @xmath238 does not contain conditional commands ( except from the entry conditional @xmath1066 ) and therefore corresponds to point  ( vi ) in section  [ hotpaths - sec ] .",
    "let us consider the programs @xmath1040 and @xmath1067 of example  [ trace - ex1 ] and the hot path @xmath1068 which corresponds to the trace @xmath1069 of @xmath1040 . here",
    ", the gp trace extraction of @xmath1052 , according to definition  [ gp - tt - def ] , provides the following program transform : @xmath1070 on the other hand , the stitch rule @xmath1003 transforms @xmath1040 into the following program @xmath1071 : @xmath1072 whose compilation yields the following program : @xmath1073 with the following new labels : @xmath1074 while observe that @xmath1075 .",
    "it is then immediate to check that the programs @xmath1076 and @xmath1077 are equal up to the following label renaming of @xmath1078 : = -10pt @xmath1079    the equivalence of this gp trace extraction with the stitch of hot paths by goes as follows .",
    "[ gp - equiv - th ] let @xmath1001 be a gp trace such that @xmath1080 and let @xmath1081 be the corresponding gp hot path as determined by lemma  [ lemma - gphp ] . then , @xmath1082 .",
    "let the gp hot path @xmath1001 be recorded by the following transition sequence for @xmath1083 : @xmath1084 \\\\    & \\tuple{\\rho_0 { \\triangleq}\\rho , ( \\kwsty{while}~b~\\kwsty{do}~s ) k , t_0\\equiv \\epsilon , s_{0}\\equiv s ( \\kwsty{while}~b~\\kwsty{do}~s ) k}{\\rightarrow}_t   \\\\ & \\tuple{\\rho_1 , ( \\kwsty{while}~b~\\kwsty{do}~s ) k , t_1\\equiv c_1 , s_{1}}{\\rightarrow}_t   \\\\ & \\ : \\cdots { \\rightarrow}_t\\\\ & \\tuple{\\rho_n , ( \\kwsty{while}~b~\\kwsty{do}~s)k ,",
    "t_n \\equiv t_{n-1 } c_n , s_n}{\\rightarrow}_t \\\\ & \\tuple{\\rho_{n+1}{\\triangleq}\\rho ' , ( \\kwsty{while}~b~\\kwsty{do}~s)k , t \\equiv t_n c_{n+1 } , s_{n+1}\\equiv ( \\kwsty{while}~b~\\kwsty{do}~s)k } \\end{array}\\ ] ] where @xmath743 , so that the body @xmath528 is assumed to be nonempty , i.e. , @xmath1085 ( there is no loss of generality since for @xmath1086 the result trivially holds ) . hence , @xmath1087 , for some commands @xmath1088 , and the corresponding hot path @xmath1089 as determined by lemma  [ lemma - gphp ] is as follows : @xmath1090\\\\   h_{0 } & { \\triangleq}{{\\textbf{\\em l}}}(s_0):a_{0 } { \\rightarrow}{{\\textbf{\\em l}}}(s_1)\\\\ h_{1 } & { \\triangleq}{{\\textbf{\\em l}}}(s_1):a_{1 } { \\rightarrow}{{\\textbf{\\em l}}}(s_2)\\\\ & \\cdots\\\\      h_{n } & { \\triangleq}{{\\textbf{\\em l}}}(s_n ) : a_n { \\rightarrow}{{\\textbf{\\em l}}}(s_{-2})\\end{aligned}\\ ] ] where the action @xmath1091 , with @xmath246 $ ] , and the command @xmath1092 depend on the first command of the statement @xmath1025 as follows ( this range of cases will be later referred to as @xmath947 ) :    * @xmath1093 * @xmath1094 * @xmath1095 + @xmath1096 * @xmath1097 + @xmath1098 * @xmath1099 + @xmath1100    if , for any @xmath246 $ ] , @xmath446 is not a conditional command then , by case  ( 1 ) of definition  [ gp - tt - def ] , we have that @xmath1101 .",
    "also , for any @xmath246 $ ] , @xmath1091 is either a skip or an assignment , so that @xmath1102 , and , in turn , @xmath1103 .",
    "hence , @xmath1104 , so that the thesis follows trivially .    thus , we assume that @xmath1105 , with @xmath1106 $ ] , is the first conditional command occuring in the sequence @xmath1107",
    ". case  ( 2 ) of definition  [ gp - tt - def ] applies , so that : @xmath1108,\\ , a_i \\in \\operatorname{bexp}\\}.\\end{aligned}\\ ] ] moreover , we have that : @xmath1109 @xmath1110 we first show that @xmath1111 .",
    "we consider the following label renaming : @xmath1112 so that it remains to show that @xmath1113 .",
    "since @xmath1114 , with @xmath1115 , let us analyze the five different cases for the first command @xmath1116 of @xmath1001 .",
    "* @xmath1117 .",
    "thus , @xmath1118 , @xmath1119 , @xmath1120 . in this case",
    ", @xmath1121 hence , it is enough to consider the relabeling @xmath1122 and to show that @xmath1123 . *",
    "@xmath1124 and @xmath1125 .",
    "thus , @xmath1119 , so that @xmath1126 .",
    "this case is analogous to the previous case  ( i ) . *",
    "@xmath1124 and @xmath1127 .",
    "thus , @xmath1128 and @xmath1126 . here",
    ", we have that @xmath1129 again , it is enough to consider the relabeling @xmath1122 and to show that @xmath1123 .",
    "* @xmath1130 , with @xmath1131 and @xmath1132 , so that @xmath1133 and @xmath1134 . in this case : @xmath1135    { \\mathcal{c}}(s ( \\kwsty{while}~b~\\kwsty{do}~s ) k ) = &   \\ ; \\{{{\\textbf{\\em l}}}(s ( \\kwsty{while}~b~\\kwsty{do}~s ) k ) : b '   { \\rightarrow}{{\\textbf{\\em l}}}(s ' t ( \\kwsty{while}~b~\\kwsty{do}~s)k),\\ , \\\\   & \\;\\;\\ ; { { \\textbf{\\em l}}}(s ( \\kwsty{while}~b~\\kwsty{do}~s ) k ) : \\neg b '   { \\rightarrow}{{\\textbf{\\em l}}}(t ( \\kwsty{while}~b~\\kwsty{do}~s ) k ) \\}\\\\   & \\mkern-10mu \\cup { \\mathcal{c}}(s ' t ( \\kwsty{while}~b~\\kwsty{do}~s)k ) \\cup   { \\mathcal{c}}(t ( \\kwsty{while}~b~\\kwsty{do}~s ) k).\\end{aligned}\\ ] ] hence , since @xmath1136 and @xmath1137 , it is enough to consider the relabeling @xmath1138 and to show that @xmath1123 . *",
    "@xmath1139 , with @xmath1131 and @xmath1140 , so that @xmath1119 and @xmath1141 . in this case : @xmath1142 while @xmath1143 is the same as in the previous point  ( iv ) .",
    "hence , since @xmath1136 and @xmath1144 , it is enough to consider the relabeling @xmath1138 and to show that @xmath1123 .",
    "thus , in order to prove this containment , it remains to show that @xmath1123 . if @xmath1145 then the containment boils down to @xmath1146 which is therefore proved .",
    "otherwise , @xmath1147 , so that the containment can be inductively proved by using the same five cases ( i)-(v ) above .",
    "let us now show the reverse containment , that is , @xmath1148 . for the trace @xmath1149 , we know by @xmath947 that each command @xmath1150 either is in @xmath1151 or is one of the two following bail commands ( cf",
    ".  cases  ( 3 ) and ( 4 ) in @xmath947 ) : @xmath1152 furthermore , at least a bail command occurs in @xmath1001 because there exists at least a conditional command @xmath1105 in @xmath1052 .",
    "let @xmath1153 , with @xmath1154 $ ] , be the first bail command occurring in @xmath1001 .",
    "thus , since the sequence @xmath1155 consists of skip and assignment commands only , we have that @xmath1156 .",
    "hence , either @xmath1157 or @xmath1157 . in both cases , we obtain that @xmath1158 , so that @xmath1159 .",
    "thus , it remains to show that @xmath1160\\ } \\cup   \\ { \\ell_i : \\neg a_i { \\rightarrow}{{\\textbf{\\em l}}}(s_{\\textit{next}(i)})^c~|~ i\\in [ 0,n],\\ , a_i \\in \\operatorname{bexp}\\}\\end{aligned}\\ ] ] is contained in @xmath1161 .",
    "we consider the following label renaming : @xmath1162 so that it remains to check that for any @xmath246 $ ] , the commands @xmath1163 and @xmath1164 , when @xmath1165 , are in @xmath1161 .",
    "we analyze the possible five cases listed in @xmath947 for the action @xmath1166 :    * @xmath1167 because @xmath1168 . here , @xmath1169 . hence , @xmath1170 and",
    "it is enough to use the relabeling @xmath1171 . *",
    "@xmath1172 because @xmath1173 , so that @xmath1174 .",
    "analogous to case  ( i ) .",
    "* @xmath1126 because @xmath1127 . here , @xmath1175 . here ,",
    "again , @xmath1176 , so that it is enough to use the relabeling @xmath1171 . * @xmath1134 because @xmath1131 and @xmath1132 .",
    "thus , @xmath1177 and @xmath1178 .",
    "note that @xmath1179 .",
    "hence , @xmath1180 once again , the relabeling @xmath1171 allows us to obtain that @xmath1181 and @xmath1182 are in @xmath1161 .",
    "* @xmath1141 because @xmath1131 and @xmath1140 . here ,",
    "@xmath1183 and @xmath1184 .",
    "note that @xmath1185 .",
    "hence , @xmath1186 thus , through the relabeling @xmath1171 we obtain that @xmath1187 and @xmath1188 are in @xmath1161 .",
    "this case analysis ( i)-(v ) for the action @xmath1166 can be iterated for all the other actions @xmath1091 , with @xmath867 $ ] , and this allows us to close the proof .",
    "finally , we can also state the correctness of the gp trace extraction transform for the store changes abstraction as follows .",
    "[ gp - corr - th ] for any @xmath74 , @xmath1189 , we have that @xmath1190 .",
    "the proof of theorem  [ gp - corr - th ] is omitted , since it is a conceptually straightforward adaptation of the proof technique for the analogous theorem  [ corr - th ] on the correctness of trace extraction .",
    "let us observe that since @xmath642 is a stronger abstraction than @xmath1191 and , by theorem  [ bis - abs - th ] , we know that @xmath1191 characterizes bisimilarity , we obtain the so - called stitch lemma in ( * ? ? ?",
    "* lemma  3.6 ) as a straight consequence of theorem  [ gp - corr - th ] : @xmath1192 .",
    "this article put forward a formal model of tracing jit compilation which allows : ( 1 )  an easy definition of program hot paths  that is , most frequently executed program traces ; ( 2 )  to prove the correctness of a hot path extraction transform of programs ; ( 3 )  to prove the correctness of dynamic optimizations confined to hot paths , such as dynamic type specialization along a hot path .",
    "our approach is based on two main ideas : the use of a standard trace semantics for modeling the behavior of programs and the use of abstract interpretation for defining the notion of hot path as an abstraction of the trace semantics and for proving the correctness of hot path extraction and optimization .",
    "we have shown that this framework is more flexible than model of tracing jit compilation , which relies on a notion of correctness based on operational program bisimulations , and allows to overcome some limitations of @xcite on selection and annotation of hot paths and on the correctness of optimizations such as dead store elimination .",
    "we expect that most optimizations employed by tracing jit compilers can be formalized and proved correct using the proof methodology of our framework .",
    "we see a number of interesting avenues for further work on this topic . as a significant example of optimization implemented by a practical tracing compiler",
    ", it would be worth to cast in our model the allocation removal optimization for python described by   in order to formally prove its correctness .",
    "then , we think that our framework could be adapted in order to provide a model of whole - method just - in - time compilation , as used , e.g. , by ionmonkey @xcite , the current jit compilation scheme in the firefox javascript engine",
    ". finally , the main ideas of our model could be useful to study and relate the foundational differences between traditional static vs dynamic tracing compilation .        adams2014 k. adams , j. evans , b. maher , g. ottoni , a. paroski , b. simmers , e. smith , and o. yamauchi . 2014 . . in _ proceedings of the 2014 acm international conference on object oriented programming systems languages ( oopsla 2014)_. acm , new york , ny , usa , 777790 .",
    "bauman2015 s. bauman , r. bolz , c.f .",
    "hirschfeld , v. krilichev , t. pape , j.g .",
    "siek , and s. tobin - hochstadt .",
    "2015 . . in _ proceedings of the 20th acm sigplan international conference on functional programming ( icfp 2015)_. acm , new york , ny , usa , 2234",
    ".    bebenita2010spur m. bebenita , f. brandner , m. fahndrich , f. logozzo , w. schulte , n. tillmann , and h. venter .",
    "2010 . . in _ proceedings of the acm international conference on object oriented programming systems languages and applications ( oopsla 2010)_. acm , new york , ny , usa , 708725",
    "bohm2011 i. bhm , t.j.k .",
    "edler  von koch , s.c .",
    "kyle , b. franke , and n. topham . 2011 . .",
    "in _ proceedings of the 32nd acm sigplan conference on programming language design and implementation ( pldi 2011)_. acm , new york , ny , usa , 7485",
    ".    bolz2011 c.f .",
    "bolz , a. cuni , m. fijakowski , m. leuschel , s. pedroni , and a. rigo .",
    "2011 . . in _ proceedings of the 20th acm sigplan workshop on partial evaluation and program manipulation ( pepm 2011)_. acm , acm , new york , ny , usa , 4352",
    "bolz2009 c.f .",
    "bolz , a. cuni , m. fijalkowski , and a. rigo .",
    "2009 . . in _ proceedings of the 4th workshop on the implementation , compilation , optimization of object - oriented languages and programming systems ( icooolps 2009)_. acm , new york , ny , usa , 1825",
    "gal2009 a. gal , b. eich , m. shaver , d. anderson , d. mandelin , m.r .",
    "haghighat , b. kaplan , g. hoare , b. zbarsky , j. orendorff , j. ruderman , e.w .",
    "smith , r. reitmaier , m. bebenita , m. chang , and m. franz .",
    "2009 . . in _ proceedings of the 2009 acm sigplan conference on programming language design and implementation ( pldi 2009)_. acm , new york , ny , usa , 465478",
    "inoue2011 h. inoue , h. hayashizaki , peng wu , and t. nakatani .",
    "in _ 9th annual ieee / acm international symposium on code generation and optimization ( cgo 2011)_. ieee computer society , washington , dc , usa , 246256 ."
  ],
  "abstract_text": [
    "<S> tracing just - in - time compilation is a popular compilation technique for the efficient implementation of dynamic languages , which is commonly used for javascript , python and php . </S>",
    "<S> it relies on two key ideas . </S>",
    "<S> first , it monitors program execution in order to detect so - called hot paths , i.e. , the most frequently executed program paths . </S>",
    "<S> then , hot paths are optimized by exploiting some information on program stores which is available and therefore gathered at runtime . </S>",
    "<S> the result is a residual program where the optimized hot paths are guarded by sufficient conditions ensuring some form of equivalence with the original program . </S>",
    "<S> the residual program is persistently mutated during its execution , e.g. , to add new optimized hot paths or to merge existing paths . tracing compilation is thus fundamentally different from traditional static compilation . nevertheless , despite the practical success of tracing compilation , </S>",
    "<S> very little is known about its theoretical foundations . </S>",
    "<S> we provide a formal model of tracing compilation of programs using abstract interpretation . </S>",
    "<S> the monitoring phase ( viz . , hot path detection ) corresponds to an abstraction of the trace semantics of the program that captures the most frequent occurrences of sequences of program points together with an abstraction of their corresponding stores , e.g. , a type environment . </S>",
    "<S> the optimization phase ( viz . , residual program generation ) corresponds to a transform of the original program that preserves its trace semantics up to a given observation as modeled by some abstraction . </S>",
    "<S> we provide a generic framework to express dynamic optimizations along hot paths and to prove them correct . </S>",
    "<S> we instantiate it to prove the correctness of dynamic type specialization and constant variable folding . </S>",
    "<S> we show that our framework is more general than the model of tracing compilation introduced by guo and palsberg [ 2011 ] which is based on operational bisimulations . in our model </S>",
    "<S> we can naturally express hot path reentrance and common optimizations like dead - store elimination , which are either excluded or unsound in guo and palsberg s framework .    </S>",
    "<S> the work of francesco logozzo was carried out while being affiliated with microsoft research , redmond , wa , usa . </S>",
    "<S> the work of francesco ranzato was partially supported by microsoft research software engineering innovation foundation  2013 award ( seif  2013 ) and by the university of padova under the prat projects becom and ancore .    </S>",
    "<S> author s addresses : s.  dissegna and f.  ranzato , dipartimento di matematica , university of padova , padova , italy ; f.  logozzo , facebook inc . , seattle , wa , usa . </S>"
  ]
}