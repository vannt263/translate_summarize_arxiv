{
  "article_text": [
    "most theoretical studies of wireless networks assume that transmitters and receivers are synchronized , in the sense that the receiver knows when data transmission is about to start .",
    "this is in general justified by the fact that , if large amounts of data are to be transmitted , then the time and energy required for synchronization are negligible when compared to what is required for communication itself .",
    "several applications , such as wi - fi , fall into this category and , in their context , optimizing the time and energy required for establishing the connection is of small practical importance .    however , in certain applications such as wireless sensor networks and bursty data communication in cellular networks ,",
    "small amounts of time - sensitive data are sporadically available for transmission , at times that are unknown to the receivers . in such scenarios",
    ", the receiver is constantly listening to the output of a noisy channel in an attempt to identify a message .",
    "an extra amount of energy is then spent at the transmitter to make sure that the message is not missed and the noise is not mistaken for the message . in the sporadic data model ,",
    "this extra energy represents a significant part of the total energy spent and becomes a relevant quantity .",
    "there is a large body of work treating synchronization from a practical perspective with the goal of minimizing overheads and synchronization errors .",
    "however , these studies lack a fundamental characterization of the energy and bandwidth costs of synchronization",
    ".    early work on the fundamental limits of _ asynchronous _ communication involved characterizing the data rates that can be achieved when the receiver does not know the beginning of the communication block @xcite .",
    "later , in @xcite , a similar model was considered , but the performance metric was instead the energy ( or , in general , the cost ) per bit required for reliable asynchronous communication .",
    "the characterization of the minimum energy - per - bit is important from a practical point of view , especially since it is often the case that the sensors in a wireless sensor network are battery - operated .",
    "thus , in the case of short and sporadic transmissions , i.e. , bursty traffic , when synchronization costs may in fact dominate the communication costs , the characterization of the minimum energy - per - bit is very relevant .    in this work ,",
    "we follow the asynchronism model from @xcite . however , we focus on the awgn channel model , rather than on discrete channels .",
    "we assume that @xmath2 bits of data become available at the source node at a random arrival time @xmath3 , and must be communicated to a destination with a maximum delay @xmath4 and the delay constraint @xmath5 by @xmath2 since we will consider an asymptotic regime in @xmath2 , as described in section [ setupsec ] . ] .",
    "the arrival time @xmath3 is assumed to be unknown to all network nodes , and unknown to the source before the arrival time itself .",
    "however , @xmath3 is known to be drawn from @xmath6 , where @xmath7 quantifies the asynchronism level . under this setting , and assuming that @xmath3 is drawn uniformly at random from @xmath6 , it was shown in @xcite that the _ asynchronous _ minimum energy - per - bit of a point - to - point awgn channel is given by @xmath8 where @xmath9 is the minimum energy - per - bit for an awgn channel with noise power @xmath10 in the synchronous setting .",
    "our first result is to show that the asynchronous minimum energy - per - bit in ( [ asyncmeb ] ) can be achieved through a scheme where the tasks of synchronization and communication are performed separately .",
    "in such a scheme , which we refer to as a _ separation - based _ coding scheme , as soon as the message arrives ( at time @xmath3 ) the source uses a synchronization signal in order to inform the destination that the message is about to be transmitted",
    ". if this synchronization procedure succeeds , communication can then take place as if we were in the synchronous setting .",
    "we focus on such _ separation - based _ schemes due to their ease of design and practical implementation",
    ".    we then move on to the main topic of the paper : asynchronous communication in multi - hop networks .",
    "this is motivated by the fact that multi - hop communication with relays increases network range and throughput and reduces power consumption .",
    "the fundamental question we focus on is : `` how should relays facilitate the communication between source and destination when they do not know the beginning of the transmission block ? '' .",
    "on the one hand , one could devise a scheme where relays are constantly assuming that communication is taking place .",
    "however , this approach would intuitively waste energy outside the actual communication block . on the other hand",
    ", we could consider a separation - based scheme which first synchronizes all relays and the destination , and then proceeds to communicate over a synchronous network .",
    "however , this may also be potentially wasteful , since the relays are not required to decode the message , so they do not need to know the beginning of the transmission block precisely .",
    "in essence , our goal is to understand whether intermediate relays should be synchronized and whether separation - based coding schemes perform well .",
    ", height=132 ]    we study this problem in the context of the two - relay diamond network shown in figure [ netfig ] .",
    "we say that a coding scheme synchronizes relay @xmath11 if , intuitively , the signals received by relay @xmath11 during times @xmath12 , represented by @xmath13 , reveal a significant amount of information about @xmath3 ; or , more precisely , if @xmath14 as @xmath15 . under this notion of relay synchronization , we show that it is optimal from an energy - per - bit point of view to consider coding schemes that synchronize any relay that is used ( i.e. , that does not stay silent ) .",
    "this result allows us to show that , depending on the specific values of @xmath16 and @xmath17 , it is optimal from the energy - per - bit point of view to either only use relay @xmath1 , only use relay @xmath0 , or use both relay @xmath1 and relay @xmath0 .",
    "this result is in contrast with the intuition provided by the synchronous case , in which , the capacity ( and also the minimum energy - per - bit ) is always improved if we utilize as many relays as are available .",
    "finally , we utilize the fact that relays must be synchronized to derive a lower bound to the minimum energy - per - bit for the asynchronous two - relay diamond network",
    ". we then verify that the energy - per - bit achieved by a separation - based scheme is within a constant factor of this lower bound .",
    "this factor is @xmath0 in the synchronous case , but it drops towards @xmath1 as the asynchronism - per - bit @xmath18 increases . we conclude that , in high - asynchronism regimes , where synchronization costs are high , separation - based schemes perform close to optimally .    the paper is organized as follows . in section [ relworksec ] ,",
    "we summarize some of the previous work on asynchronous communication . in section [ setupsec ] ,",
    "we describe our network model and formally define the notion of the asynchronous minimum energy - per - bit that we use . in section [ simpleboundssection ] ,",
    "we provide some preliminary results .",
    "first , we describe the known results on the minimum energy - per - bit of point - to - point awgn channels .",
    "then we show how similar ideas can be used to derive upper and lower bounds for the minimum energy - per - bit for the asynchronous diamond network .",
    "however , the ratio between these upper and lower bounds is unbounded , and the remainder of the paper is devoted to improving the lower bound ( i.e. , the converse direction ) . in section [ mainresultssection ] , we state our two main results .",
    "the first main result , theorem [ mainthm ] , essentially states that it is optimal to consider coding schemes where any relay that is used ( i.e. , does not stay silent ) must be synchronized .",
    "we then state and prove our second main result , theorem [ lboundthm ] , which bounds the asynchronous minimum energy - per - bit of the two - relay diamond network .",
    "the upper and lower bound are then verified to be within a constant fraction of each other .",
    "the proof of theorem [ mainthm ] is left to section [ syncsection ] .",
    "we then conclude the paper in section [ conclusion ] .",
    "the modeling of bursty data traffic used in this work builds up on the asynchronism models introduced in @xcite and @xcite . in @xcite ,",
    "asynchronism is modeled by having the message transmission block start at a randomly chosen time within a prescribed window .",
    "the receiver knows the transmission window , but not the location of the transmission block .",
    "the authors consider an asymptotic regime in which the size of the window grows exponentially with the number of bits to be transmitted , and they define the communication rate as the ratio between the number of transmitted bits and the average time elapsed between the beginning of the transmission block and the time when the decoder makes a decision . under this model , in @xcite , several aspects of the tradeoff between achievable communication rates and the asynchronism exponent were characterized . later on , in a follow - up work @xcite , the authors drew connections between this asynchronism model and the detection and isolation model introduced in @xcite .",
    "the asynchronism model considered in @xcite is very similar to the model from @xcite . in @xcite , however , the performance metric is the data rate per unit cost , rather than just the data rate .",
    "the authors also allow for the random variable associated with the beginning of the communication block to have more general probability distributions ( not just the uniform distribution ) .",
    "their goal is to characterize the maximum achievable rate per unit cost , or the capacity per unit cost , which is the inverse of the minimum cost per bit . for a discrete channel @xmath19 with input alphabet @xmath20 and output alphabet @xmath21 , and an arbitrary cost function @xmath22 $ ] ,",
    "they show that the capacity per unit cost is given by @xmath23 } , \\frac{i(x;y)+d(y\\|y_\\star)}{e[k(x)](1+\\bar \\beta)}\\right\\},\\end{aligned}\\ ] ] where @xmath24 is the random variable corresponding to the output of the channel outside of the transmission block ( i.e. , when the transmitter is idle ) , and @xmath25 is a parameter that characterizes how the uncertainty of the beginning of the transmission block grows with the number of bits to be sent . in particular , for an awgn channel with noise variance @xmath10 , and quadratic cost function @xmath26 , and assuming that the beginning of the transmission block is drawn uniformly from @xmath27 , for @xmath28 , where @xmath2 is the number of bits to be transmitted , this expression reduces to @xmath29 notice that , if we define the length of the window to be @xmath30 , ( [ result2 ] ) implies that , for an awgn channel , the asynchronous minimum energy per bit is given by @xmath31 where @xmath32 is the usual ( synchronous ) minimum energy - per - bit of an awgn channel .",
    "in addition , the authors of @xcite also characterize the basic trade - off between the capacity per unit cost and the exponent of the delay within which the decoder must make a decision .    in @xcite , the same point - to - point asynchronous model from @xcite is considered , but the authors study the miss and false alarm error exponents . as a consequence , they are able to characterize the suboptimality of tranining - based schemes .    in @xcite , a strengthened version of the asynchronism model from @xcite is proposed , in which the decoder needs to estimate both the message and the location of the codeword exactly .",
    "it is shown that the asynchronous capacity region remains unchanged under this formulation .",
    "in addition , the finite blocklength regime is investigated .",
    "we consider the diamond network , shown in figure [ netfig ] .",
    "we assume a discrete - time model where , at time @xmath33 , each transmitter node @xmath34 transmits a real - valued signal @xmath35 $ ] , each relay @xmath11 , for @xmath36 , receives @xmath37 = \\sqrt{g_i } x_s[t ] + z_i[t ] , $ ] and the destination @xmath38 receives @xmath39 = \\sqrt{h_1 } x_1[t ] + \\sqrt{h_2 } x_2[t ] + z_d[t ] , $ ] where @xmath40 , z_2[t]$ ] and @xmath41 $ ] are independent i.i.d .",
    "@xmath42 noise terms .",
    "our bursty traffic model follows the asynchronous communication model introduced in @xcite .",
    "the source receives a @xmath2-bits message @xmath43 at some random time @xmath44 $ ] , where , for @xmath45 , we define @xmath46 { \\triangleq}\\{a , a+1, ... ,b\\}$ ] . the source then needs to communicate this message to the destination with a delay of at most @xmath5 time - steps . in order to formally define reliable communication",
    ", we consider the asymptotic regime of @xmath15 .",
    "thus , we consider a sequence of arrival distributions @xmath47 , where @xmath3 is uniform on @xmath48 $ ] and @xmath30 , for @xmath49 and some @xmath28 .",
    "notice that , as @xmath15 , @xmath50 , thus capturing the idea of short and sporadic messages .",
    "once the @xmath2 bits arrive at the source at time @xmath3 , they must be communicated to the destination within a delay @xmath4 .",
    "notice that , in order for the problem to be meaningful , @xmath4 should be small in comparison to @xmath7 .",
    "otherwise , it would be possible to devise a strategy where the source only starts its trasmission at pre - defined time - steps separated by @xmath4 time - steps , and the traffic would not be actually bursty .",
    "thus , since @xmath7 is exponential in @xmath2 , we will require the delay @xmath4 to be subexponential in @xmath2 .",
    "an _ asynchronous code _ @xmath51 for the symmetric diamond network is designed to communicate a specific number of bits @xmath2 with a delay of @xmath4 , assuming an arrival distribution @xmath3 .",
    "this code is comprised of    * an encoding function for the source @xmath52 \\times [ 1:a_b ] \\to { { \\mathbb r}}^{d_b+1}$ ] , which defines the source transmit signals for @xmath53 $ ] , given the @xmath2 message bits and their arrival time @xmath3 ; * relaying functions @xmath54 , which define relay @xmath11 s transmit signal at time @xmath33 given its received signals in times @xmath55 , for @xmath56 ; * a sequential decoder @xmath57 , which , at time @xmath33 , decides to either decode the message ( in which case it sets @xmath58 and outputs a decoded message @xmath59 ) or to wait ( in which case @xmath60 ) .",
    "we then have the following definition .    [ achievedef ]",
    "energy - per - bit @xmath61 is achievable if we can find a sequence of codes @xmath62 and a sequence @xmath63 , with @xmath64 as @xmath65 , where code @xmath66 can transmit @xmath67 bits with a maximum delay of @xmath68 , assuming the input distribution is @xmath69 , and we have    1 .",
    "@xmath70 2 .",
    "@xmath71 3 .",
    "@xmath72 } { b_k } \\leq e_b,$ ]    where @xmath73 ^ 2 + x_1[t]^2 + x_2[t]^2\\right)$ ] is the total energy used by code @xmath66 , @xmath74 , and @xmath75 is the event @xmath76 for code @xmath66 .",
    "the asynchronous minimum energy - per - bit is the infimum over all achievable energy - per - bit values .",
    "constraint 2 is what characterizes the data as time - sensitive , thus requiring the communication to be in fact bursty .",
    "notice that our definition of achievable energy - per - bit is similar to the ones in @xcite ( with delay exponent @xmath77 ) , and in @xcite ( by setting @xmath78 , i.e. , in the synchronous case ) .",
    "in this section we first describe some known results for point - to - point awgn channels",
    ". then we extend them in a simple way to the two - relay diamond network , and show that this approach yields upper and lower bounds on the asynchronous minimum energy - per - bit which can be arbitrarily far from each other .      in the synchronous case ,",
    "the minimum energy - per - bit of a point - to - point awgn channel is a special case of the inverse of the capacity per unit cost , studied in @xcite , where the cost is the average power .",
    "consider a simple awgn point - to - point channel , where the channel gain between transmitter and receiver is @xmath79 .",
    "let @xmath80 be the minimum energy - per - bit of this channel in the synchronous setting and @xmath81 be the minimum energy - per - bit of this channel in the asynchronous setting .",
    "the following lemma can be obtained from the results in @xcite .",
    "[ synclemma ] if @xmath82 is the capacity of the synchronous awgn channel with power constraint @xmath83 , then @xmath84 where we define @xmath85 .",
    "the importance of lemma [ synclemma ] for us is that it guarantees that any energy - per - bit @xmath86 can be achieved with codes whose delay ( i.e. , the blocklength ) is linear in the number of bits being sent . to see this ,",
    "consider any @xmath87 .",
    "we can find @xmath88 such that @xmath89 , and , for @xmath90 sufficiently small , we will have @xmath91 . now ,",
    "for the rate @xmath92 , we can find a sequence of ( synchronous ) codes @xmath93 , where @xmath66 transmits @xmath94 bits , with a blocklength equal to @xmath95 , whose error probabilities go to @xmath96 as @xmath65 . therefore , the energy - per - bit of each code @xmath66 satisfies @xmath97 and the delay is @xmath98 is linear in @xmath67 .",
    "next , we consider the same awgn channel , but in the asynchronous setting .",
    "we will make an additional assumption about the sequence of distributions of @xmath3 .",
    "let @xmath99 $ ] and let @xmath100 .",
    "we will require that @xmath101 as @xmath15 . among the sequences of distributions satisfying this property",
    ", we have sequences of distributions whose probability mass functions have the same `` shape '' but stretched over the interval @xmath102 $ ] for each @xmath2 .",
    "in particular , this is the case when @xmath3 is uniformly distributed on @xmath103 , which will be our focus when we consider the diamond network . by using this restriction",
    ", we exclude the distributions for which the expression ( 6 ) in @xcite does not evaluate to the normalized entropy . under this assumption",
    ", we can state the following theorem , which is similar to the results in @xcite .",
    "however , since we are not in the discrete alphabet setting which is the focus of @xcite , our achievability scheme is somewhat different , and it introduces the notion of a _ separation - based _ scheme .",
    "we present the achievability proof here , and the converse in appendix [ apppttopt ] .",
    "[ pttopt ] for an asynchronous awgn channel , the minimum energy - per - bit is given by @xmath104 where @xmath105 .",
    "in particular , if each @xmath69 is uniformly distributed in @xmath106 $ ] , then @xmath107 .    _ achievability _ : we will show that the asynchronous energy - per - bit @xmath108 , for an arbitrarily small @xmath109 , is achievable , which implies @xmath110 .",
    "we will let @xmath111 be the subsequence of @xmath112 along which @xmath113 .",
    "we will then build a sequence of codes @xmath93 , where code @xmath66 assumes arrival distribution @xmath69 and transmits @xmath67 bits .",
    "our scheme is based on having the transmitter send a large pulse as soon as the message arrives .",
    "the receiver will use a threshold detector to detect the pulse .",
    "once the pulse is ( correctly ) detected , communication can proceed as in a synchronous channel . for code",
    "@xmath66 , the total energy available for the pulse will be @xmath114 . if the message arrives at time @xmath33 ( which implies @xmath115 ) , then the transmitter will first send a pulse of magnitude @xmath116 following the pulse , the transmitter sends a codeword from an optimal code designed to send @xmath67 bits with energy - per - bit @xmath117 over the _ synchronous _ version of the channel .",
    "therefore , the expected energy consumed by our code is given by @xmath118 & = \\sum_{t=1}^{a_k } p_{b_k}(t ) \\left [ - ( 1+\\delta)^2 \\log{\\left(p_{b_k}(t)\\right)}\\gamma / h+ b_k ( 1+\\delta)^2 \\gamma / h \\right ] \\\\",
    "& = ( 1+\\delta)^2 \\frac{\\gamma}h \\left [ - \\sum_{t=1}^{a_k } p_{b_k}(t ) \\log\\left(p_{b_k}(t)\\right ) + b_k \\right ] \\\\ & = ( 1+\\delta)^2 \\frac{\\gamma}h \\left(h(\\nu_{b_k } ) + b_k\\right),\\end{aligned}\\ ] ] where we used the convention that @xmath119 , in order to sum over all @xmath120 . the energy - per - bit we will achieve will be @xmath121 / b_k = ( 1+\\delta)^2(1+\\bar h )",
    "\\gamma / h$ ] , as we intended .",
    "all we need to show is that the probability of error of our codes goes to @xmath96 as @xmath65 . since we are using an optimal code for the synchronous channel to actually communicate the bits , the probability of incorrect decoding , given that the pulse was detected goes to @xmath96 as @xmath65 .",
    "moreover , from lemma [ synclemma ] we know that the blocklength required for these codes will be @xmath122 for some @xmath123 , which guarantees that the decoding delay @xmath124 will satisfy @xmath125 , and the probability of late decoding also goes to @xmath96 as @xmath65 .",
    "thus , we only need to show that the probability of error in detecting the pulse goes to @xmath96 . for this to happen",
    ", we will set the detection threshold at the destination to be @xmath126 at time @xmath33 .",
    "we define the following two error events :    * @xmath127 * @xmath128    clearly , the probability of error in detecting the pulse can be upper bounded by @xmath129 .",
    "we will show that each of the terms goes to @xmath96 as @xmath65 . for @xmath130",
    ", we have @xmath131 and , as @xmath65 , we have @xmath132 and @xmath133 , implying that @xmath134 . for @xmath135 , we have @xmath136 which goes to @xmath96 as @xmath65 , since @xmath132 as @xmath65 .",
    "we now start considering the two - relay diamond network shown in figure [ netfig ] in the asynchronous setting .",
    "unless otherwise noted , we will assume throughout the paper ( wlog ) that @xmath137 .",
    "moreover , we will focus in the case where @xmath138 is uniformly distributed on @xmath102 $ ] .",
    "a simple achievable scheme for the two - relay diamond network in figure [ netfig ] is a separation - based scheme , similar to the one we used in the achievability of theorem [ pttopt ] .",
    "thus , we will have a _ synchronization phase _",
    ", where the source will send a pulse at time @xmath69 to synchronize the relays , and the relays will send a pulse at time @xmath139 to synchronize the destination .",
    "after this , provided that the pulses were correctly detected by all nodes , we are in a synchronous setting , and we will have a _ communication phase_. in this phase , any code for the synchronous two - relay diamond network can be used , as long as its delay is subexponential in the number of bits being sent .    to compute an achievable asynchronous energy - per - bit , we will use decode - and - forward for the communication phase .",
    "notice that several relaying schemes that outperform decode - and - forward are known @xcite . however , there is no closed - form expression for the energy - per - bit achieved by these schemes , making it difficult to compare their performance to the lower bound . a careful calculation of the asynchronous energy - per - bit achieved by this separation - based scheme yields the following theorem , whose proof is in appendix [ appseparationachievable ] .",
    "[ separationachievable ] the asynchronous minimum energy - per - bit for the network in figure [ netfig ] satisfies @xmath140    in order to obtain lower bounds on the asynchronous minimum energy - per - bit , we will use a technique similar in flavor to cut - set bounds , but applied to minimum energy - per - bit .",
    "the idea is to consider all four cuts in the network in figure [ netfig ] , and view it as a mimo channel , thus being able to apply a lower bound to the asynchronous minimum energy - per - bit of a point - to - point channel , as in theorem [ pttopt ] .",
    "this approach yields the following result .",
    "[ simplebounds ] the asynchronous minimum energy - per - bit for the network in figure [ netfig ] is lower bounded as @xmath141 , where @xmath142 is the optimal solution to @xmath143       \\nonumber \\\\",
    "\\textrm{subject to}\\quad   & ( g_1+g_2 ) y_1 + g_2 y_3 + g_1 y_4 \\leq 1   \\nonumber   \\\\",
    "\\quad   & ( h_1+h_2 ) y_2+h_1 y_3 \\leq 1   \\nonumber \\\\",
    "\\quad   & ( h_1+h_2 ) y_2+h_2 y_4 \\leq 1 \\nonumber   \\\\                       & y_1,y_2,y_3,y_4      \\geq 0 . \\label{lpbound}\\end{aligned}\\ ] ]    in order to prove this result , we will require the following two results , which bound the asynchronous minimum energy - per - bit of the mimo channels obtained when we consider the different cuts .",
    "their proofs are in appendices [ appptpt2 ] and [ appptpt3 ] respectively .",
    "[ ptpt2 ] consider the networks in figures [ hop1 ] and [ hop2 ] , where the message arrival time @xmath3 is uniformly distributed in @xmath102 $ ] .",
    "then , the minimum asynchronous energy - per - bit @xmath144 of these two networks is given respectively by @xmath145    [ ptpt3 ] consider the mimo channel in figure [ cutgen ] in the asynchronous setting , where the message arrival time @xmath3 is uniformly distributed in @xmath102 $ ] .",
    "consider a sequence of codes @xmath93 that achieves a finite energy - per - bit , and let @xmath146 be the energy spent by code @xmath66 at the source transmitter @xmath147 , for @xmath148 .",
    "then , we must have @xmath149}{b_k } + b \\liminf_{k\\to\\infty}\\frac{e\\left[{{\\mathcal e}}_{{{\\mathcal c}}_k}^{(s_2)}\\right]}{b_k } \\geq \\gamma(1+\\beta).\\end{aligned}\\ ] ]    we will use the networks in figures [ hop1 ] and [ hop2 ] to bound the energy - per - bit used by the sources , and the energy - per - bit used by the relays respectively .",
    "notice that these networks correspond to two out of the four cuts in our diamond network .    now",
    ", suppose we have a sequence of codes @xmath93 achieving a finite energy - per - bit @xmath61 on the diamond network in figure [ netfig ] .",
    "then we consider applying this sequence of codes to the network in figure [ hop1 ] , where we assume the same asynchronism level . in order to do this",
    "we let the source transmit as if it were in the network in figure [ netfig ] .",
    "the destination , which has two receive antennas , which represent the relays from the original network , will first compute what the transmit signals of the relays would have been in the original network .",
    "then it will simulate the second hop from the relays to the destination , and use the same sequential decoder used by the destination in the original network applied to the simulated received signal .",
    "it is clear that the probability of error of this code applied to the network in figure [ hop1 ] is identical to the probability of error of @xmath66 on the network in figure [ netfig ] .",
    "the main difference is that the energy from the relays is not consumed anymore , and the energy used by code @xmath66 when applied to the network in figure [ hop1 ] , is just the energy used by the source @xmath150 .",
    "this will allow us to bound the energy - per - bit used by the source .",
    "from lemma [ ptpt2 ] , we have @xmath151}{b_k } \\geq ( 1+\\beta ) \\frac{\\gamma}{g_1+g_2}. \\label{senergy}\\end{aligned}\\ ] ]    then we consider applying code @xmath66 to the network in figure [ hop2 ] .",
    "this time , the source will simulate the transmit signals of the source in figure [ netfig ] and the received signals at the relays .",
    "then it can compute the transmit signals of the relays in figure [ netfig ] and use them one for each of its antennas . if we let @xmath152 and @xmath153 be the energy used by the relays in code @xmath66 , lemma [ ptpt2 ] tells us that @xmath154}{b_k } \\geq ( 1+\\beta ) \\frac{\\gamma}{h_1+h_2}. \\label{renergy}\\end{aligned}\\ ] ]    up to this point , we have only considered two out of the four possible cuts of the two - relay diamond network .",
    "the other two cuts will yield mimo channels that look like the network in figure [ cutgen ] , for @xmath155 and @xmath156 , and @xmath157 and @xmath158 .",
    ", by setting @xmath155 and @xmath156 , or @xmath159 and @xmath160[cutgen].,height=105 ]    for a point - to - point channel such as the one in figure [ cutgen ] , it is not difficult to see that the asynchronous minimum energy - per - bit would be given by @xmath161 .",
    "this is trivially achievable by just using one of the two source antennas ( @xmath162 or @xmath163 ) .",
    "however , for the purposes of deriving a tighter lower bound , we will be interested in capturing a relationship between the energy that is spent in each of the two source antennas .",
    "this relationship is stated in lemma [ ptpt3 ] .",
    "recall that , in order to derive ( [ senergy ] ) and ( [ renergy ] ) we used the fact that code @xmath66 can be applied to the networks in figures [ hop1 ] and [ hop2 ] .",
    "similarly , by applying code @xmath66 to the network in figure [ cutgen ] , ( with @xmath164 and @xmath156 , and @xmath157 and @xmath158 ) , we can use lemma [ ptpt3 ] to obtain @xmath165}{b_k } + h_1 \\liminf_{k \\to \\infty } \\frac{e\\left[{{\\mathcal e}}_{{{\\mathcal c}}_k}^{(r_1)}\\right]}{b_k } \\geq \\gamma ( 1+\\beta ) ,   \\label{sr1energy } \\\\ & g_1 \\liminf_{k \\to \\infty } \\frac{e\\left[{{\\mathcal e}}_{{{\\mathcal c}}_k}^{(s ) } \\right]}{b_k } + h_2 \\liminf_{k \\to \\infty } \\frac{e\\left[{{\\mathcal e}}_{{{\\mathcal c}}_k}^{(r_2)}\\right]}{b_k }   \\geq \\gamma ( 1+\\beta ) .",
    "\\label{sr2energy } \\end{aligned}\\ ] ] next , we notice that ( [ senergy ] ) , ( [ renergy ] ) , ( [ sr1energy ] ) and ( [ sr2energy ] ) imply that , for any @xmath90 , there exists a @xmath166 such that , for @xmath167 , @xmath168}{b_k } \\geq { \\gamma}(1+\\beta )   -\\delta \\\\ & ( { h_1+h_2})\\frac{e\\left[{{\\mathcal e}}_{{{\\mathcal c}}_k}^{(r_1 ) } + { { \\mathcal e}}_{{{\\mathcal c}}_k}^{(r_2)}\\right]}{b_k } \\geq { \\gamma}(1+\\beta )   -\\delta \\\\ & g_2 \\frac{e\\left[{{\\mathcal e}}_{{{\\mathcal c}}_k}^{(s)}\\right]}{b_k } + h_1 \\frac{e\\left[{{\\mathcal e}}_{{{\\mathcal c}}_k}^{(r_1)}\\right]}{b_k } \\geq \\gamma ( 1+\\beta ) -\\delta \\\\ & g_1 \\frac{e\\left[{{\\mathcal e}}_{{{\\mathcal c}}_k}^{(s ) } \\right]}{b_k } + h_2 \\frac{e\\left[{{\\mathcal e}}_{{{\\mathcal c}}_k}^{(r_2)}\\right]}{b_k }   \\geq \\gamma ( 1+\\beta ) -\\delta.\\end{aligned}\\ ] ] therefore , for any @xmath167 , a lower bound to @xmath169}{b_k } = \\frac{e\\left[{{\\mathcal e}}_{{{\\mathcal c}}_k}^{(s)}\\right]}{b_k } + \\frac{e\\left[{{\\mathcal e}}_{{{\\mathcal c}}_k}^{(r_1)}\\right]}{b_k } + \\frac{e\\left[{{\\mathcal e}}_{{{\\mathcal c}}_k}^{(r_2)}\\right]}{b_k } \\end{aligned}\\ ] ] is the optimal value of the linear program @xmath170 this implies that , for any @xmath90 , the above linear program is also a lower bound to @xmath171}{b_k } , \\label{minenergyexp0}\\end{aligned}\\ ] ] and , after letting @xmath172 , ( [ primallp ] ) is still a lower bound to ( [ minenergyexp0 ] ) . finally , by taking the dual of ( [ primallp ] ) with @xmath77",
    ", we conclude that ( [ lpbound ] ) is a lower bound to the asynchronous minimum energy - per - bit of the diamond network in figure [ netfig ] .",
    "the advantage of using the dual linear program in ( [ lpbound ] ) rather than its primal is that any feasible solution @xmath173 yields a lower bound to the asynchronous minimum energy - per - bit of the diamond network .    in order to explicitly compute a gap between the upper and lower bounds",
    ", we may consider a worse lower bound , obtained from the feasible solution to ( [ lpbound ] ) @xmath174 .",
    "this tells us that @xmath175 the gap between our upper bound and this lower bound is given by @xmath176 this result shows that our separation - based scheme performs well in cases where the channel gains of the first hop are much stronger than the channel gains of the second hop ( since the gap in ( [ gap1 ] ) is small in comparison to the lower bound in ( [ simplebound0 ] ) ) .",
    "however , it is important to realize that our gap depends on @xmath177 , suggesting that the separation - based scheme may be arbitrarily bad in high - asynchronism regimes ( i.e. , when @xmath177 is large ) .",
    "notice that , even if we consider the optimal solution to ( [ lpbound ] ) , our lower bound is still a multiple of @xmath178 and the gap to the upper bound from theorem [ simplebounds ] will still depend on @xmath177 .",
    "our first main result ( theorem [ mainthm ] ) is that a relay can only be helpful in a coding scheme ( from the energy - per - bit point of view ) if it is _",
    "synchronized_. from this , we can derive our second main result ( theorem [ lboundthm ] ) , which consists of a lower bound for the asynchronous minimum energy per bit of the diamond network ( tighter than the one in theorem [ simplebounds ] ) , whose ratio to the upper bound in theorem [ separationachievable ] is bounded by @xmath0 , and decreases to @xmath1 as @xmath177 increases . the proof of theorem [ mainthm ] is very technical , and is deferred to section [ syncsection ] , while the proof of theorem [ lboundthm ] is presented in this section .    in this work",
    ", we will define synchronization as follows .",
    "[ syncdef ] relay @xmath11 is synchronized in the sequence of codes @xmath93 if @xmath179 where @xmath180 is the vector of received signals of relay @xmath11 from time @xmath1 to time @xmath181 , when using code @xmath66 .",
    "our first main result states that it is optimal ( in terms of minimum energy - per - bit ) to consider only schemes where we either use both relays and synchronize them , or we just use relay @xmath1 and synchronize it .",
    "we rule out the case where only relay @xmath0 is synchronized because , since @xmath137 , we have the markov chain @xmath182 .",
    "thus , we must have @xmath183 , which implies that if relay @xmath0 is synchronized , so is relay @xmath1 .",
    "[ mainthm ] suppose we have a sequence of codes @xmath93 achieving a finite energy - per - bit @xmath61 on the asynchronous diamond network in figure [ netfig ] . then we can achieve arbitrarily close to the energy - per - bit @xmath61 with a sequence of codes @xmath184 for which one of the following is true :    1 .",
    "relay @xmath11 , for @xmath148 , can create a list @xmath185 $ ] based on their received signals , such that @xmath186 with vanishing error probability and list size @xmath187 subexponential in @xmath67 2 .",
    "relay 1 can create a list @xmath188 $ ] based on its received signals , such that @xmath189 with vanishing error probability and list size @xmath190 subexponential in @xmath67 and relay @xmath0 is inactive ( i.e. , does not transmit any signal )    theorem [ mainthm ] states that we can assume wlog that any sequence of codes @xmath93 achieving a finite energy - per - bit @xmath61 will allow any relay that is used ( i.e. , any relay that does not stay silent ) to create a list @xmath185 $ ] that has size @xmath187 that is subexponential in @xmath67 and contains @xmath69 with vanishing error probability . therefore , if relay @xmath11 is used in the sequence of codes @xmath93 , and if we let @xmath191 be an indicator function for the event @xmath192 , then we must have @xmath193 which goes to @xmath96 as @xmath65 , because @xmath187 is subexponential in @xmath67 , and @xmath194 as @xmath65 .",
    "thus , we have just shown the following .",
    "[ synccor ] it is possible to achieve the minimum energy - per - bit of the asynchronous diamond network in figure [ netfig ] with codes where each relay is either synchronized or remains silent .    in the remainder of this section ,",
    "we show how theorem [ mainthm ] can be used to improve our lower bound , and , in section [ syncsection ] , we prove theorem [ mainthm ] .",
    "we will need some facts related to the capacity of a two - user degraded broadcast channel .",
    "let @xmath82 be the capacity region of a degraded broadcast channel @xmath195 .",
    "we know that this capacity region consists of all pairs @xmath196 such that @xmath197 for some distribution @xmath198 such that @xmath199 \\leq p$ ] , where @xmath200 corresponds to the common rate , and @xmath201 to the private rate to the stronger user",
    ". however , we will be interested in the multi - letter characterization of the same region ; i.e. , all pairs @xmath196 such that @xmath202 for some @xmath203 and some distribution @xmath204 such that @xmath205 \\leq np$ ] .",
    "an important quantity for us will be the @xmath206-capacity of this broadcast channel , which we define as @xmath207 for some @xmath208 . using the multi - letter description of the capacity ( [ mletter ] ) , it is easy to see that we have @xmath209.\\end{aligned}\\ ] ]",
    "now we can state our new lower bound .",
    "[ lboundthm ] the asynchronous minimum energy - per - bit for the network in figure [ netfig ] is lower bounded as @xmath210 where is the optimal solution to @xmath211       \\nonumber \\\\ \\textrm{\\rm",
    "subject to}\\quad   & ( g_1+g_2 ) y_1 + g_2 y_3 + g_1 y_4 \\leq 1   \\nonumber   \\\\",
    "\\quad   & ( h_1+h_2 ) y_2+h_1 y_3 \\leq 1   \\nonumber \\\\                   \\quad   & ( h_1+h_2 ) y_2+h_2 y_4 \\leq 1 \\nonumber   \\\\                       & y_1,y_2,y_3,y_4      \\geq 0 . \\label{lpbound2}\\end{aligned}\\ ] ]",
    "first we assume that @xmath93 falls into case ( a ) of theorem [ mainthm ] , and both relays are synchronized . in this case , we will consider using code @xmath66 on the degraded broadcast channel in figure [ degbc ] , in the synchronous setting .    .",
    "[ degbc],height=158 ]    notice that , for this broadcast channel , @xmath212 is a scalar , while @xmath213 = \\left[\\begin{smallmatrix } \\sqrt{g_1}x + z_{1,1}\\\\ \\sqrt{g_2}x + z_{1,2 } \\end{smallmatrix}\\right]$ ] is a vector .",
    "when we consider using code @xmath66 on this channel in the synchronous setting , we will have the source choosing an arrival time @xmath69 uniformly at random from @xmath106 $ ] and transmitting the message as if we were in the asynchronous setting .",
    "notice that destination @xmath214 can simulate what the relays would have done in the diamond network , thus being able to simulate what the destination from the diamond network would have received .",
    "this guarantees that , with probability @xmath215 , where @xmath216 , destination @xmath214 can decode @xmath43 correctly and output a list @xmath217 $ ] containing @xmath69",
    ".    we will let @xmath218 be the the random vector corresponding to the transmit signals of the source when using code @xmath66 on the broadcast channel , and @xmath219 and @xmath220 be the corresponding outputs at @xmath214 and @xmath221 respectively .",
    "since we are assuming that relay @xmath0 is synchronized in the diamond network , destination @xmath221 will be synchronized here , which implies that @xmath222 now , using ( [ cgamma ] ) with @xmath223 , we obtain @xmath224/\\tilde a_k\\right ) & \\geq \\frac{1}{\\tilde a_k } \\min\\left [ i(x^{\\tilde a_k};y_1^{\\tilde a_k}|\\nu_{b_k } ) , i(\\nu_{b_k};y_2^{\\tilde a_k})/\\beta \\right ] \\nonumber \\\\ & = \\frac{1}{\\tilde a_k } \\min\\left [ b_k - h(x^{\\tilde a_k}|y_1^{\\tilde a_k},\\nu_{b_k } ) , b_k - h\\left(\\nu_{b_k } \\left| y_2^{\\tilde a_k}\\right.\\right)/\\beta \\right ] \\nonumber \\\\ & { \\stackrel{(\\roman{numcount})}{\\geq\\;}\\stepcounter{numcount}}\\frac{1}{\\tilde a_k } \\min\\left [   b_k - \\left ( h({\\epsilon}_k ) + { \\epsilon}_k b_k \\right),b_k - h\\left(\\nu_{b_k } \\left| y_2^{\\tilde a_k}\\right.\\right)/\\beta \\right ] , \\label{capeval}\\end{aligned}\\ ] ] where @xmath225 follows from fano s inequality .",
    "next , we notice that the capacity @xmath82 of the gaussian degraded broadcast channel is known in closed - form , and in the case of figure [ degbc ] , it is comprised of all non - negative pairs @xmath196 satisfying @xmath226 for some @xmath227 $ ] .",
    "it is then not difficult to see that the @xmath228-capacity of our broadcast channel can be expressed as @xmath229.\\end{aligned}\\ ] ] then we have @xmath230 \\nonumber \\\\ & = \\max_{0 \\leq \\alpha \\leq 1 } \\min \\left [ \\frac{\\alpha ( g_1+g_2)}{\\gamma } , \\frac{(1-\\alpha ) g_2}{\\beta \\gamma } \\right ] \\nonumber \\\\ & = \\frac{g_2 ( g_1 + g_2 ) } { \\gamma \\left [ \\beta(g_1 + g_2 ) + g_2\\right]}. \\label{supeval}\\end{aligned}\\ ] ] now , by combining ( [ capeval ] ) and ( [ supeval ] ) , we conclude that @xmath231 } & \\geq \\sup_{p>0 } \\frac{c_{1:\\beta}(p)}{p } \\geq \\frac{c_{1:\\beta}\\left(e\\left[{{\\mathcal e}}_{{{\\mathcal c}}_k}^{(s)}\\right]/\\tilde a_k\\right)}{e\\left[{{\\mathcal e}}_{{{\\mathcal c}}_k}^{(s)}\\right]/\\tilde a_k } \\nonumber \\\\ & \\geq \\frac{\\frac{1}{\\tilde a_k } \\min\\left [ b_k - \\left ( h({\\epsilon}_k ) + { \\epsilon}_k b_k \\right ) ,   b_k - h\\left(\\nu_{b_k } \\left| y_2^{\\tilde a_k}\\right.\\right)/\\beta\\right]}{e\\left[{{\\mathcal e}}_{{{\\mathcal c}}_k}^{(s)}\\right]/\\tilde a_k } \\nonumber \\\\ & = \\frac{\\min\\left [ 1 - \\left ( h({\\epsilon}_k)/b_k + { \\epsilon}_k \\right ) ,   1 - h\\left(\\nu_{b_k}\\left| y_2^{\\tilde a_k}\\right.\\right)/(\\beta b_k)\\right]}{e\\left[{{\\mathcal e}}_{{{\\mathcal c}}_k}^{(s)}\\right]/b_k}.\\end{aligned}\\ ] ] finally , by taking the @xmath232 when @xmath65 and using ( [ syncproof ] ) , we obtain @xmath233 } \\geq \\limsup_{k \\to \\infty}\\frac{b_k}{e\\left[{{\\mathcal e}}_{{{\\mathcal c}}_k}^{(s)}\\right ] } \\nonumber \\\\ & \\rightarrow \\liminf_{k\\to\\infty } { e\\left[{{\\mathcal e}}_{{{\\mathcal c}}_k}^{(s)}\\right]}/{b_k } \\geq \\frac{\\gamma \\left [ \\beta(g_1 + g_2 ) + g_2\\right]}{g_2 ( g_1 + g_2 ) } = \\gamma \\left(\\frac{\\beta}{g_2 } + \\frac{1}{g_1+g_2 } \\right ) .",
    "\\label{senergy2}\\end{aligned}\\ ] ] for the other three cuts in the network , we use the same analysis that we used in the proof of theorem [ simplebounds ] to obtain ( [ renergy ] ) , ( [ sr1energy ] ) and ( [ sr2energy ] ) .",
    "then , by following very similar steps to those in the proof of theorem [ simplebounds ] , we conclude that a lower bound to @xmath234}{b_k}\\end{aligned}\\ ] ] is given by the optimal solution to the linear program @xmath235   \\nonumber   \\\\              \\quad   & ( h_1+h_2 ) ( x_{r_1}+x_{r_2 } ) \\geq \\gamma ( 1+\\beta ) \\nonumber \\\\                   \\quad   & g_2 x_s + h_1 x_{r_1 } \\geq \\gamma ( 1+\\beta ) \\nonumber   \\\\              \\quad   & g_1 x_s +",
    "h_2 x_{r_2 } \\geq \\gamma ( 1+\\beta ) \\nonumber \\\\",
    "\\quad   & x_s , x_{r_1},x_{r_2 } \\geq 0 .",
    "\\label{primallp2}\\end{aligned}\\ ] ] then , by taking the dual of ( [ primallp2 ] ) we obtain ( [ lpbound2 ] ) , which concludes the proof in the case where both relays are synchronized .",
    "if the sequence of codes falls into case ( b ) of theorem [ mainthm ] , we may assume that only relay @xmath1 is synchronized an relay @xmath0 is silent .",
    "then the analysis is much simpler .",
    "we essentially have two concatenated point - to - point asynchronous awgn channels , in which case the asynchronous minimum energy - per - bit is exactly given by @xmath236 and the theorem follows .",
    "the result in theorem [ lboundthm ] allows us to characterize the asynchronous minimum energy - per - bit of the diamond network to within a constant ratio , which ranges from @xmath0 in the synchronous case to @xmath1 in the highly asynchronous case .",
    "first notice that , if we just use relay @xmath1 ( the stronger relay ) , we can achieve energy - per - bit @xmath237 .",
    "therefore , in cases where @xmath238 the optimal strategy for the two - relay diamond network is to just use relay @xmath1 . in these cases , there is no gap between upper and lower bound . in cases",
    "where @xmath239 it is clear that @xmath240 is a lower bound on the asynchronous minimum energy - per - bit for _ any _ sequence of codes ( independent of which relays are synchronized ) .",
    "therefore , if we compare it to the simple upper bound from theorem [ separationachievable ] , and using the feasible solution to ( [ lpbound2 ] ) @xmath174 , the gap will satisfy @xmath241 notice that this gap does not depend on @xmath177 anymore .",
    "therefore , we conclude that the separation - based scheme , although suboptimal , has a performance that does not become worse for large @xmath177 ; it in fact becomes relatively better",
    ".    an important outcome of these results is that , for some values of @xmath242 and @xmath17 , we can decide whether it is optimal to use one or both relays . as we observed before , in the cases where ( [ onerelayoptimal ] ) holds",
    ", it is optimal to only use relay @xmath1 .",
    "the intuition is that the cost of using relay @xmath0 is high , since it must be synchronized in order to be useful , and using it does not improve the achievable energy - per - bit . on the other hand , in cases where our upper bound is below the lower bound when using only relay @xmath1 , i.e. , when @xmath243 we know that the optimal strategy involves using both relays , and paying the price for synchronizing them .",
    "the plots in figure [ optrelays1 ] illustrate these results . for a given value of @xmath177 and for fixed positions of the source , relay @xmath1 and the destination",
    ", we show in green the positions of relay @xmath0 for which it would be optimal to use both relays , in red the region where it would be optimal to use only relay @xmath1 , in blue the region where it would be optimal to use only relay @xmath0 , and in yellow the region for which our result does not provide an answer . to create these plots",
    ", we assumed that the channel gains are proportional to the cube of the inverse of the distance .",
    "next , we consider the ratio @xmath244 .",
    "the upper - bound that we use is simply the minimum between a decode - and - forward scheme using only relay 1 and a decode - and - forward scheme using both relays , i.e. , @xmath245 as shown in @xcite , in the special case where the first hop of the diamond network is symmetric , i.e. , when @xmath246 , the upper and lower bounds are within a constant factor of each other . to see this , notice that , if @xmath246 , the upper - bound always reduces to @xmath247 .",
    "moreover , by computing the bound ( [ lpbound2 ] ) with @xmath248 , we obtain the lower bound of @xmath249 .",
    "we then have @xmath250 therefore , if @xmath251 , separation - based schemes achieve to within a factor of @xmath252 from the minimum energy - per - bit .",
    "this ratio equals @xmath0 when @xmath78 ( i.e. , in the synchronous case ) but it decreases towards @xmath1 as @xmath177 increases . in the general case , however , finding a good analytical bound on the worst - case ratio between the upper and lower bounds is not as easy .",
    "as we noticed before , if ( [ onerelayoptimal ] ) holds , then the gap between upper and lower bound is zero , and the ratio is one .",
    "therefore , we may assume that , for the worst - case ratio , ( [ notonerelayoptimal ] ) holds , and by plugging @xmath174 into ( [ lpbound2 ] ) , we have the lower bound @xmath253 then , an upper bound to the worst - case ratio is @xmath254 this clearly shows that , as @xmath255 , the worst - case ratio tends to @xmath1 .",
    "however , this bound tends to infinity when @xmath256 . to verify that this is not the case for the worst - case ratio , we consider two regimes .",
    "a.   @xmath257 : by considering only the second term in ( [ achievedenergy ] ) , and the lower bound provided by plugging @xmath258 into ( [ lpbound2 ] ) , we can upper bound the worst - case ratio as @xmath259 b.   @xmath260 : by considering only the first term in ( [ achievedenergy ] ) , and the lower bound provided by plugging @xmath261 into ( [ lpbound2 ] ) , we can upper bound the worst - case ratio as @xmath262 }   \\leq \\frac{\\frac1{g_1}+\\frac1{h_1 } } { \\frac{h_1-g_2}{h_1(g_1+g_2 ) } + \\frac{1}{h_1 } }   = \\frac { \\frac1{g_1}+\\frac1{h_1 } } { \\frac{h_1+g_1}{h_1(g_1+g_2 ) } } \\\\   & \\quad \\quad \\quad \\quad = \\frac{\\left(1+\\frac{g_2}{g_1}\\right ) h_1 + g_1 + g_2}{h_1+g_1 } = \\frac{\\left(1+\\frac{g_2}{g_1}\\right ) ( h_1 + g_1)}{h_1+g_1 } = 1 + \\frac{g_2}{g_1 } \\leq 2.\\end{aligned}\\ ] ]    we conclude that , in the worst case , the upper bound in ( [ achievedenergy ] ) and the lower bound from theorem [ lboundthm ] are within a factor of @xmath0 of each other , and that this factor goes to @xmath1 as @xmath255 . since this bound is very crude , we considered finding the approximate worst - case ratio between the upper bound in ( [ achievedenergy ] ) and the lower bound from theorem [ lboundthm ] numerically .",
    "first we notice that for any choice of @xmath263 , if we normalize all the channel gains by @xmath264 we obtain the same ratio between upper bound and lower bound .",
    "therefore , we may restrict our search for the worst - case ratio to the case where all channel gains lie in @xmath265 $ ] .",
    "thus , we considered the ratio between upper bound and lower bound for @xmath266 , and found the worst - case for several values of @xmath177 .",
    "we obtained the plot in figure [ ratiocurve ] .",
    ", height=283 ]    this plot confirms that the worst - case ratio is uniformly upper bounded by @xmath0 , and decreases to @xmath1 as @xmath177 increases .",
    "the ratio decreases to @xmath1 faster than @xmath267 , but not as fast as @xmath268 ( the case where @xmath251 ) .",
    "our main objective in this section is to prove theorem [ mainthm ] .",
    "the main idea is to show that , in order to achieve the minimum energy - per - bit on the network in figure [ netfig ] , there is no point in using a relay if it is not _ synchronized _",
    ", where the notion of a synchronized relay is formalized in definition [ syncdef ] .",
    "recall that , in our definition of what it means for a sequence of codes to achieve an energy - per - bit @xmath61 ( definition [ achievedef ] ) , we require that code @xmath66 , which operates on a channel with arrival distribution @xmath69 , transmits @xmath67 bits . in this section , it will be useful to use an equivalent definition of achievable asynchronous energy - per - bit @xmath61 . under the assumption that the distribution @xmath69 is uniform over @xmath106 $ ] , we obtain the following result , whose proof is in appendix [ appflemma ] .    [ flemma ] suppose we have a sequence of codes @xmath93 , where code @xmath66 operates on a channel with uniform arrival distribution on @xmath106 $ ] but only transmits @xmath269 bits , with @xmath270 and @xmath271 suppose that , in addition , this sequence of codes satisfies the following :      then , for any @xmath274 , this sequence can be used to construct a new sequence of codes @xmath275 , where code @xmath276 operates on a channel with uniform arrivals on @xmath277 $ ] and transmits @xmath278 bits , satisfying        this lemma allows us to regard the three conditions satisfied by the sequence of codes @xmath93 in the statement of lemma [ flemma ] as an equivalent definition of what it means for a sequence of codes to achieve energy - per - bit @xmath61 .    in order to prove theorem [ mainthm ] , we will start with a sequence of asynchronous codes @xmath283 achieving energy - per - bit @xmath61 , and we will make several modifications to it , until we obtain another sequence of codes with the properties stated in the statement of the theorem .",
    "these steps and the lemmas and theorems that construct the proof are summarized in the diagram in figure [ diagramfig ] .",
    "our first goal is to convert any given scheme into another scheme where the transmissions by the source are restricted to start at a few special `` transmission times '' , and last at most @xmath284 time steps .",
    "then , if each pair of consecutive transmission times are separated by more than @xmath284 time steps , at a given time @xmath33 , if the source is transmitting , there is only one possible starting time for the transmission block . intuitively , this will facilitate the relays task .",
    "we formally define this notion as follows .",
    "[ nol ] an asynchronous code @xmath66 is said to have non - overlaping transmission blocks if there is a set of times @xmath285 with @xmath286 and a transmission block length @xmath287 , satisfying the following properties :    * @xmath288 , for @xmath289 * the interval @xmath290 $ ] is divided into @xmath291 subintervals @xmath292 $ ] , @xmath293 ( disregarding edge effects ) , such that @xmath294 , and if the message arrives at time @xmath295 , then the source keeps it buffered until the start of the block @xmath296 $ ] , where the transmissions occur .",
    "moreover , given that the message arrived in @xmath297 , the signals transmitted by the source during @xmath298 $ ] are only a function of the message value , and not the actual arrival time .",
    "* at a time @xmath299 $ ] , the relays only need the signals received in @xmath300 $ ] to compute their relaying functions , and the destination only needs the signals received in @xmath300 $ ] to apply its detecting / decoding functions . if @xmath301 $ ] for @xmath302 , then the relays stay silent , and the destination does not apply any detection / decoding function .",
    "we will in general refer to the set of transmission times of code @xmath66 as @xmath303 .",
    "notice that a non - overlapping transmission blocks scheme effectively induces a new message arrival distribution @xmath304 , where @xmath305 if @xmath306 and @xmath307 otherwise .",
    "then we have the following key result , whose proof is in appendix [ appnollem ] .",
    "[ nollem ] suppose we have a sequence of codes @xmath93 achieving a finite energy - per - bit @xmath61 on the asynchronous diamond network in figure [ netfig ] . then we can build another sequence of codes @xmath184 with delay constraint @xmath308 subexponential in @xmath309 , with non - overlapping transmission blocks of length @xmath287 , for which @xmath310\\right]}{b_k } \\leq ( 1+\\eta)e_b,\\end{aligned}\\ ] ] for any arbitrarily small @xmath274 , and whose probability of error goes to @xmath96 as @xmath65 .",
    "_ remark 2 : _ notice that the energy spent in the code @xmath276 after time @xmath311 is only spent by the relays .",
    "therefore , if somehow the relays were able to decode @xmath304 at time @xmath312 , they could stop transmitting , and theorem [ nollem ] would imply that we have a sequence of codes with non - overlapping transmission blocks achieving arbitrarily close to energy - per - bit @xmath61 .",
    "we will now move toward our main result for the @xmath0-relay diamond network . since we will be frequently dealing with the sequence of codes constructed via lemma [ nollem ]",
    ", the following definition will be useful .",
    "a sequence of codes @xmath93 with non - overlapping transmission blocks achieves a _ causal _ energy - per - bit @xmath61 , if it satisfies properties 1 and 2 in definition [ achievedef ] , and @xmath313\\right]}{b_k } \\leq e_b,\\end{aligned}\\ ] ] where @xmath287 is the transmission block length .",
    "[ causaldef ]    _ remark:_consider a sequence of codes with non - overlapping transmission blocks that achieves a causal energy - per - bit @xmath61 with delay @xmath68 ( which must be , according to definition [ achievedef ] , subexponential in @xmath67 ) .",
    "notice that a message that arrives in the first half of @xmath297 , for any @xmath11 , can not be decoded with a delay smaller than @xmath314 .",
    "since the message arrives in the first half of some @xmath297 with probability @xmath315 , and the error probability goes to @xmath96 , definition [ causaldef ] implicitly requires that @xmath316 , for k sufficiently large",
    ". therefore , since the delay @xmath68 must be subexponential in @xmath67 , we must also have @xmath317 subexponential in @xmath67 .",
    "this fact will be used in subsequent proofs .",
    "lemma [ nollem ] states that we can take any sequence of codes @xmath93 achieving energy - per - bit @xmath61 and use it to build another sequence of codes @xmath184 which achieves a causal energy - per - bit arbitrarily close to @xmath61 and has non - overlapping transmission blocks .",
    "our first goal will be to show that any such sequence of codes can be converted into yet another sequence of codes , achieving the same causal energy - per - bit , where either both relays decode @xmath304 exactly , or relay @xmath1 decodes @xmath304 exactly and relay @xmath0 is not used at all .",
    "this way , the relays that are actually used for communication can decode @xmath304 and stop transmitting at time @xmath318 . this will allow us to convert our sequence of codes that achieve causal energy - per - bit @xmath61 , to a sequence of codes that in fact achieves energy - per - bit @xmath61 .",
    "in addition , this new sequence will have the property that any relay that is used must be synchronized .    in the process of proving theorem [ mainthm ]",
    ", an important step will be to restrict the set of messages that can be sent by a given code to only those with some special properties .",
    "because of that , it will be interesting that the energy spent by the code does not vary too much depending on the message that is sent .",
    "this will allow us to restrict a code to only sending a certain subset of the messages without having the average energy - per - bit change much .",
    "consider a code @xmath66 with non - overlapping transmission blocks . now , suppose that for each transmission time @xmath319 we have an injective mapping @xmath320 .",
    "we will let @xmath321 represent the ensemble of all these mappings , i.e. , @xmath322 .",
    "then we have the following definition .",
    "the restriction of code @xmath66 according to @xmath321 , denoted by @xmath323 , is a new code with message set @xmath324 , which , given that message @xmath325 ( effectively ) arrives at time @xmath326 , transmits the message @xmath327 using code @xmath66 .",
    "the destination applies the same decoder of code @xmath66 , and then uses @xmath328 to decode @xmath43 ( declaring an error if @xmath328 does not map to any element in @xmath324 ) .",
    "a sequence of codes @xmath93 with non - overlapping transmission blocks that achieves a causal energy - per - bit @xmath61 is said to achieve a causal energy - per - bit @xmath61 uniformly over the messages if for any sequence of message restrictions @xmath329 we have @xmath330   \\right]}{\\log b_k } \\leq e_b.\\end{aligned}\\ ] ]      [ uniflemma ] suppose we have a sequence of codes @xmath93 with non - overlapping transmission blocks achieving a causal energy - per - bit @xmath61 on the asynchronous diamond network in figure [ netfig ] .",
    "then we can have a sequence of codes @xmath184 that have non - overlapping transmission blocks , achieving a causal energy - per - bit @xmath282 uniformly over the messages , for any @xmath274 .",
    "[ listthm ] for any sequence of codes @xmath93 for the asynchronous diamond network with non - overlapping transmission blocks achieving a causal energy - per - bit @xmath61 uniformly over the messages , relay @xmath1 can create a list @xmath331 which contains @xmath304 with vanishing error probability , and has a size @xmath332 that is subexponential in @xmath67 .",
    "moreover , each @xmath33 in the list is added to it no later than at time @xmath333 .",
    "let @xmath334 $ ] be the energy used by relay @xmath11 in the transmission block @xmath335 $ ] , when using code @xmath66 .",
    "consider a sequence of non - negative numbers @xmath336 for which @xmath216 .",
    "let the set @xmath337 of arrival times be defined as @xmath338}{b_k } \\leq \\alpha \\text { and } \\frac{{{\\mathcal e}}_{{{\\mathcal c}}_k}^{(r_2)}[w({\\tilde \\nu}_{b_k})]}{b_k } \\leq \\alpha \\",
    ", \\right| { \\tilde \\nu}_{b_k } = t \\right ) \\leq { \\epsilon}_k     \\right\\}. \\label{one}\\end{aligned}\\ ] ] the proof of the following lemma is in appendix [ appalphaeplemma ] .",
    "notice that , for the @xmath341 and the sequence @xmath336 provided by lemma [ alphaeplemma ] , we can actually replace the @xmath232 in ( [ limsup ] ) with a limit , since one can consider the subsequence of @xmath93 for which the limit exists and is the @xmath232 of the original sequence .",
    "therefore , we will assume that ( [ limsup ] ) holds with @xmath232 replaced by @xmath342 .",
    "we will show that , if ( [ limsup ] ) holds , relay @xmath1 can implement a list detector @xmath343 for @xmath69 with probability of error going to @xmath96 , and whose list size is subexponential in @xmath67 .",
    "but first we describe a scheme in which each relay @xmath11 , @xmath148 , implements a list decoder @xmath344 for @xmath69 based on its transmit signals @xmath345 , @xmath346 , and we show that the probability that _ both _ decoders make an error at the same time goes to @xmath96 .",
    "the list decoder @xmath344 for @xmath304 selects the first @xmath347\\right]}{\\alpha}$ ] transmission blocks where the energy consumed by relay @xmath11 is at least @xmath348 , and lists the corresponding transmission times .",
    "let @xmath349}$ ] be the total energy consumed by relay @xmath11 up to time @xmath318 .",
    "notice that , if @xmath350 } < b_k e\\left[{{{\\mathcal e}}_{{{\\mathcal c}}_k}}[1:{\\tilde \\nu}_{b_k}+\\ell_k-1]\\right ] \\text { and } \\label{exp1f } \\\\ & { { \\mathcal e}}_{{{\\mathcal c}}_k}^{(r_i)}{[w({\\tilde \\nu}_{b_k } ) ] } > b_k \\alpha , \\label{exp2f}\\end{aligned}\\ ] ] then @xmath351 } } { { { \\mathcal e}}_{{{\\mathcal c}}_k}^{(r_i)}{[1:{\\tilde \\nu}_{b_k}+\\ell_k-1 ] } } > \\frac{\\alpha}{e\\left[{{{\\mathcal e}}_{{{\\mathcal c}}_k}}[1:{\\tilde \\nu}_{b_k}+\\ell_k-1]\\right ] } = n_k^{-1}$ ] .",
    "moreover , there can be at most @xmath352 transmission blocks @xmath353 in @xmath354 $ ] satisfying @xmath355 } } { { { \\mathcal e}}_{{{\\mathcal c}}_k}^{(r_i)}{[1:{\\tilde \\nu}_{b_k}+\\ell_k-1 ] } } > n_k^{-1}$ ] , which implies that , if ( [ exp1f ] ) and ( [ exp2f ] ) are satisfied , the list decoder @xmath343 will be correct , i.e. , @xmath356 .",
    "the probability of error at both decoders is then given by @xmath357 \\leq \\alpha b_k \\cup   { { \\mathcal e}}_{{{\\mathcal c}}_k}^{(r_1)}{[1:{\\tilde \\nu}_{b_k}+\\ell_k-1 ] } \\geq b_k e\\left[{{{\\mathcal e}}_{{{\\mathcal c}}_k}}[1:{\\tilde \\nu}_{b_k}+\\ell_k-1]\\right ] \\right ) \\right .",
    "\\nonumber \\\\   & \\quad \\quad \\quad \\left .",
    "\\cap \\left ( { { \\mathcal e}}_{{{\\mathcal c}}_k}^{(r_2)}[w({\\tilde \\nu}_{b_k } ) ] \\leq \\alpha b_k \\cup   { { \\mathcal e}}_{{{\\mathcal c}}_k}^{(r_2)}{[1:{\\tilde \\nu}_{b_k}+\\ell_k-1 ] } \\geq b_k e\\left[{{{\\mathcal e}}_{{{\\mathcal c}}_k}}[1:{\\tilde \\nu}_{b_k}+\\ell_k-1]\\right]\\right ) \\right ] \\nonumber \\\\ & { \\stackrel{(\\roman{numcount})}{\\leq\\;}\\stepcounter{numcount}}\\pr\\left [ \\left ( { { \\mathcal e}}_{{{\\mathcal c}}_k}^{(r_1)}[w({\\tilde \\nu}_{b_k } ) ] \\leq \\alpha b_k \\cap { { \\mathcal e}}_{{{\\mathcal c}}_k}^{(r_2)}[w({\\tilde \\nu}_{b_k } ) ] \\leq \\alpha b_k",
    "\\right ) \\right .",
    "\\nonumber \\\\ & \\quad \\quad \\quad \\cup \\left ( { { \\mathcal e}}_{{{\\mathcal c}}_k}^{(r_1)}{[1:{\\tilde \\nu}_{b_k}+\\ell_k-1 ] } \\geq b_k e\\left[{{{\\mathcal e}}_{{{\\mathcal c}}_k}}[1:{\\tilde \\nu}_{b_k}+\\ell_k-1]\\right ] \\right ) \\nonumber \\\\ & \\quad \\quad \\quad \\left .",
    "\\cup \\left ( { { \\mathcal e}}_{{{\\mathcal c}}_k}^{(r_2)}{[1:{\\tilde \\nu}_{b_k}+\\ell_k-1 ] } \\geq b_k e\\left[{{{\\mathcal e}}_{{{\\mathcal c}}_k}}[1:{\\tilde \\nu}_{b_k}+\\ell_k-1]\\right ] \\right ) \\right ] \\nonumber \\\\   & \\leq \\pr\\left ( { { \\mathcal e}}_{{{\\mathcal c}}_k}^{(r_1)}[w({\\tilde \\nu}_{b_k } ) ] \\leq \\alpha b_k \\cap { { \\mathcal e}}_{{{\\mathcal c}}_k}^{(r_2)}[w({\\tilde \\nu}_{b_k } ) ] \\leq \\alpha b_k \\right ) \\nonumber \\\\ & \\quad \\quad \\quad + 2 \\pr\\left ( { { \\mathcal e}}_{{{\\mathcal c}}_k}{[1:{\\tilde \\nu}_{b_k}+\\ell_k-1 ] } \\geq b_k e\\left[{{{\\mathcal e}}_{{{\\mathcal c}}_k}}[1:{\\tilde \\nu}_{b_k}+\\ell_k-1]\\right ]",
    "\\right ) \\nonumber \\\\ & { \\stackrel{(\\roman{numcount})}{\\leq\\;}\\stepcounter{numcount}}\\pr\\left(\\left .   { { \\mathcal e}}_{{{\\mathcal c}}_k}^{(r_1)}[w({\\tilde \\nu}_{b_k } ) ] \\leq \\alpha b_k \\cap { { \\mathcal e}}_{{{\\mathcal c}}_k}^{(r_2)}[w({\\tilde \\nu}_{b_k } ) ] \\leq \\alpha b_k \\ , \\right| { \\tilde \\nu}_{b_k } \\in { { \\mathcal t}}(\\alpha,{{\\mathcal c}}_k,{\\epsilon}_k ) \\right ) \\nonumber \\\\ & \\quad \\quad",
    "\\quad + \\pr\\left({\\tilde \\nu}_{b_k } \\notin { { \\mathcal t}}(\\alpha,{{\\mathcal c}}_k,{\\epsilon}_k)\\right )   + 2/b_k \\nonumber \\\\ & { \\stackrel{(\\roman{numcount})}{\\leq\\;}\\stepcounter{numcount}}2/b_k + { \\epsilon}_k + \\pr\\left({\\tilde \\nu}_{b_k } \\notin { { \\mathcal t}}(\\alpha,{{\\mathcal c}}_k,{\\epsilon}_k)\\right ) , \\label{errorboundbeg } \\end{aligned}\\ ] ] where @xmath225 follows by noticint that if we have four events @xmath358 and @xmath359 , then @xmath360 implies @xmath361 , @xmath225 follows from markov s inequality and @xmath225 follows from the fact that @xmath362 \\leq \\alpha b_k \\cap { { \\mathcal e}}_{{{\\mathcal c}}_k}^{(r_2)}[w({\\tilde \\nu}_{b_k } ) ] \\leq \\alpha b_k \\",
    ", \\right| { \\tilde \\nu}_{b_k } \\in { { \\mathcal t}}(\\alpha,{{\\mathcal c}}_k,{\\epsilon}_k ) \\right ) \\\\   & = \\sum_{t \\in { { \\mathcal t}}(\\alpha,{{\\mathcal c}}_k,{\\epsilon}_k ) } \\pr\\left({\\tilde \\nu}_{b_k } = t \\left| { \\tilde \\nu}_{b_k } \\in { { \\mathcal t}}(\\alpha,{{\\mathcal c}}_k,{\\epsilon}_k ) \\right .",
    "\\right ) \\noindent \\\\ & \\quad \\quad \\quad \\quad\\quad \\quad \\pr \\left(\\left .",
    "{ { \\mathcal e}}_{{{\\mathcal c}}_k}^{(r_1)}[w({\\tilde \\nu}_{b_k})]/b_k \\leq \\alpha \\text { and } { { \\mathcal e}}_{{{\\mathcal c}}_k}^{(r_2)}[w({\\tilde \\nu}_{b_k})]/b_k \\leq \\alpha \\ , \\right| { \\tilde \\nu}_{b_k } = t \\right )   \\leq { \\epsilon}_k.\\end{aligned}\\ ] ] therefore , since @xmath363 , we have that @xmath364 .",
    "next , we want to use a similar argument to show that relay @xmath1 can implement by itself a list detector with a list size linear in @xmath67 and probability of error going to @xmath96 as @xmath65 . in order to do that , notice",
    "that , since the channel gain from source to relay @xmath1 , @xmath365 , is stronger than the channel gain from source to relay @xmath0 , @xmath366 , relay @xmath1 can `` virtually '' simulate the received signal of relay @xmath0 , and then simulate the output of the relaying functions of relay @xmath0 , thus being able to implement the list decoder based on the transmit signals of relay @xmath0 as well . to simulate the received signal at relay @xmath0 , relay @xmath1 multiplies its received signal by @xmath367 and then adds a gaussian noise with variance @xmath368 to it .",
    "it is easy to see that the resulting signal has the same marginal statistics as the signal received at relay @xmath0 .",
    "assume that @xmath369 is the signal that would be transmitted from relay @xmath0 at time @xmath33 according to relay @xmath1 s simulation .",
    "relay @xmath1 can use the list decoder @xmath370 , where @xmath371 is the list decoder based on @xmath369 , @xmath346 .",
    "notice that @xmath372 has the same distribution as @xmath373 , but the joint distributions of @xmath374 and @xmath375 are different , which is why the previous argument does not work to show that the error probability of this list decoder goes to @xmath96 . in particular , if we let @xmath376 $ ] be the energy used in the simulated signal @xmath372 in the window @xmath377 $ ] , we _ can not _ say that if @xmath378 then @xmath379}{b_k } \\leq \\alpha \\text { and } \\frac{\\hat { { \\mathcal e}}_{{{\\mathcal c}}_k}^{(r_2)}[w({\\tilde \\nu}_{b_k})]}{b_k } \\leq \\alpha \\ , \\right| { \\tilde \\nu}_{b_k } = t \\right ) \\leq { \\epsilon}_k.\\end{aligned}\\ ] ] to solve this problem , we start by noticing that we can write , for @xmath378 , @xmath380}{b_k } \\leq \\alpha \\text { and } \\frac{{{\\mathcal e}}_{{{\\mathcal c}}_k}^{(r_2)}[w(\\nu_{b_k})]}{b_k } \\leq \\alpha \\ , \\right| { \\tilde \\nu}_{b_k } = t \\right ) \\nonumber \\\\ & { \\stackrel{(\\roman{numcount})}{=}\\stepcounter{numcount}}\\sum_{m=1}^{2^{b_k } } 2^{-{b_k } } \\pr \\left(\\left .",
    "\\frac{{{\\mathcal e}}_{{{\\mathcal c}}_k}^{(r_1)}[w({\\tilde \\nu}_{b_k})]}{b_k } \\leq \\alpha \\text { and } \\frac{{{\\mathcal e}}_{{{\\mathcal c}}_k}^{(r_2)}[w({\\tilde \\nu}_{b_k})]}{b_k } \\leq \\alpha \\ , \\right| { \\tilde \\nu}_{b_k } = t , m \\text { is sent } \\right ) \\nonumber \\\\ & { \\stackrel{(\\roman{numcount})}{=}\\stepcounter{numcount}}\\sum_{m=1}^{2^{b_k } } 2^{-{b_k } } \\pr \\left(\\left .",
    "\\frac{{{\\mathcal e}}_{{{\\mathcal c}}_k}^{(r_1)}[w({\\tilde \\nu}_{b_k})]}{b_k } \\leq \\alpha \\ , \\right| { \\tilde \\nu}_{b_k } = t , m \\text { is sent } \\right )   \\\\ & \\quad \\quad \\quad \\times \\pr \\left(\\left .",
    "\\frac{{{\\mathcal e}}_{{{\\mathcal c}}_k}^{(r_2)}[w({\\tilde \\nu}_{b_k})]}{b_k } \\leq \\alpha \\ , \\right| { \\tilde \\nu}_{b_k } = t , m \\text { is sent } \\right ) \\nonumber \\\\ & \\geq \\sum_{m=1}^{2^{b_k } } 2^{-{b_k } } \\min_{j\\in\\{1,2\\ } } \\left [ \\pr \\left(\\left .",
    "\\frac{{{\\mathcal e}}_{{{\\mathcal c}}_k}^{(r_j)}[w({\\tilde \\nu}_{b_k})]}{b_k } \\leq \\alpha \\ , \\right| { \\tilde \\nu}_{b_k } = t , m \\text { is sent } \\right ) \\right]^2 , \\label{bound1a}\\end{aligned}\\ ] ] where @xmath225 follows from the independence of @xmath304 and @xmath43 , and @xmath225 follows from the fact that , given @xmath304 and @xmath43 , @xmath381 and @xmath373 are independent .",
    "now we notice that @xmath382}{b_k } \\leq \\alpha \\text { and } \\frac{\\hat { { \\mathcal e}}_{{{\\mathcal c}}_k}^{(r_2)}[w({\\tilde \\nu}_{b_k})]}{b_k } \\leq \\alpha \\ , \\right| { \\tilde \\nu}_{b_k } = t \\right ) \\nonumber \\\\ & = \\sum_{m=1}^{2^{b_k } } 2^{-{b_k } } \\pr \\left(\\left .",
    "\\frac{{{\\mathcal e}}_{{{\\mathcal c}}_k}^{(r_1)}[w({\\tilde \\nu}_{b_k})]}{b_k } \\leq \\alpha \\text { and } \\frac{\\hat { { \\mathcal e}}_{{{\\mathcal c}}_k}^{(r_2)}[w({\\tilde \\nu}_{b_k})]}{b_k } \\leq \\alpha \\ , \\right| { \\tilde \\nu}_{b_k } = t , m \\text { is sent } \\right ) \\nonumber \\\\ & \\leq \\sum_{m=1}^{2^{b_k } } 2^{-{b_k } } \\min_{j\\in\\{1,2\\ } } \\left [ \\pr \\left(\\left .",
    "\\frac{{{\\mathcal e}}_{{{\\mathcal c}}_k}^{(r_j)}[w({\\tilde \\nu}_{b_k})]}{b_k } \\leq \\alpha \\ , \\right| { \\tilde \\nu}_{b_k } = t , m \\text { is sent } \\right ) \\right ] .",
    "\\label{bound2a}\\end{aligned}\\ ] ] from the cauchy - schwarz inequality , for any numbers @xmath383 , we have @xmath384 thus , we can combine ( [ bound1a ] ) and ( [ bound2a ] ) to obtain @xmath382}{b_k } \\leq \\alpha \\text { and } \\frac{\\hat { { \\mathcal e}}_{{{\\mathcal c}}_k}^{(r_2)}[w({\\tilde \\nu}_{b_k})]}{b_k } \\leq \\alpha \\ , \\right| { \\tilde \\nu}_{b_k } = t \\right )   \\nonumber \\\\   & \\leq \\sqrt{\\sum_{m=1}^{2^{b_k } } 2^{-{b_k } } \\min_{j\\in\\{1,2\\ } } \\left [ \\pr \\left(\\left .",
    "\\frac{{{\\mathcal e}}_{{{\\mathcal c}}_k}^{(r_j)}[w({\\tilde \\nu}_{b_k})]}{b_k } \\leq \\alpha \\ ,",
    "\\right| { \\tilde \\nu}_{b_k } = t , m \\text { is sent } \\right ) \\right]^2 } \\leq \\sqrt{{\\epsilon}_k}. \\label{bound3}\\end{aligned}\\ ] ]    now , using ( [ bound3 ] ) , it is possible to repeat the same steps we used in ( [ errorboundbeg ] ) to obtain @xmath385 and we conclude that @xmath386 .",
    "this implies that the list decoder implemented by relay @xmath1 alone , which has list size @xmath387/ \\alpha$ ] ( which is subexponential in @xmath67 ) , contains @xmath69 with vanishing error probability .      in theorem [ listthm ]",
    ", we learned that in any scheme that achieves a finite causal energy - per - bit , relay @xmath1 can approximately decode @xmath69 with vanishing error probability .",
    "next we address relay @xmath0 , the weaker relay .",
    "similar to what we did in theorem [ listthm ] , we will define the set of arrival times @xmath388}{b_k } \\leq \\alpha \\ , \\right| { \\tilde \\nu}_{b_k } = t_i \\right ) \\leq { \\epsilon}_k     \\right\\ } , \\label{two}\\end{aligned}\\ ] ] where @xmath303 is the set of transmission times of code @xmath66 and @xmath389 $ ] is the transmission block associated to @xmath304 . as in theorem [ listthm ] , where we used lemma [ alphaeplemma ] to characterize the asymptotic behavior of @xmath390 $ ] , we have the following result .    [ lim10lem ]",
    "suppose we have a sequence of codes @xmath93 achieving a finite energy - per - bit @xmath61 on the asynchronous diamond network in figure [ netfig ] . consider any @xmath339 and any non - negative sequence @xmath336 , with @xmath216 .",
    "then , for any @xmath274 , we can have a sequence of codes @xmath184 achieving a causal energy - per - bit @xmath282 uniformly over the messages that have non - overlapping transmission blocks , and for which one of the following is true :        lemma [ lim10lem ] will be the basis of the proof of theorem [ mainthm ] .",
    "intuitively , if a sequence of codes satisfies ( a ) then relay @xmath0 should be able to approximately decode the arrival time @xmath69 . otherwise ,",
    "if ( b ) is satisfied , then we can find yet another sequence of codes which does not use relay @xmath0 and achieves the same energy - per - bit .",
    "we can now prove theorem [ mainthm ] , which we restate here .",
    "[ mainthm ] suppose we have a sequence of codes @xmath93 achieving a finite energy - per - bit @xmath61 on the asynchronous diamond network in figure [ netfig ]",
    ". then we can achieve arbitrarily close to the energy - per - bit @xmath61 with a sequence of codes @xmath184 for which one of the following is true :    1 .",
    "relay @xmath11 , for @xmath148 , can create a list @xmath185 $ ] based on their received signals , such that @xmath186 with vanishing error probability and list size @xmath187 subexponential in @xmath67 2 .   relay 1 can create a list @xmath188 $ ] based on its received signals , such that @xmath189 with vanishing error probability and list size @xmath190 subexponential in @xmath67 and relay @xmath0 is inactive ( i.e. , does not transmit any signal )    fix some @xmath339 and some non - negative sequence @xmath336 with @xmath216 .",
    "we start by using lemma [ lim10lem ] in order to assume that our original sequence of codes @xmath93 has non - overlapping transmission blocks of length @xmath287 , achieves a causal energy - per - bit @xmath61 uniformly over the messages , and satisfies either @xmath394 notice that the @xmath232 and @xmath395 in the statement of lemma [ lim10lem ] can be replaced by limits by simply restricting @xmath396 to the corresoponding subsequences .",
    "also notice that , if the set of transmission times for the code @xmath66 is given by @xmath303 , our delay for @xmath93 is at most @xmath397 , which must be subexponential in @xmath67 .",
    "we consider case ( [ lim1 ] ) first .",
    "we follow very similar steps to those used when we created the list decoder for the relays in theorem [ listthm ] .",
    "relay @xmath0 will use its transmit signals to implement a list decoder @xmath343 for @xmath304 with probability of error going to @xmath96 , whose list size is subexponential in @xmath67 . since each effective arrival @xmath304 corresponds to exactly @xmath398 actual arrival times @xmath69",
    ", we see that the list decoder for @xmath304 can then be converted to a list decoder for @xmath69 with a list @xmath398 times longer . since @xmath398 is subexponential in @xmath67 ,",
    "so is the size of the list for the resulting list decoder for the actual arrival time @xmath69 .",
    "the list decoder @xmath343 for @xmath304 selects the first @xmath347\\right]}{\\alpha}$ ] transmission blocks where the energy consumed by relay @xmath0 is at least @xmath348 , and lists the corresponding transmission times .",
    "let @xmath399}$ ] be the total energy consumed by relay @xmath0 up to time @xmath318 .",
    "notice that , if @xmath400 } < b_k e\\left[{{{\\mathcal e}}_{{{\\mathcal c}}_k}}[1:{\\tilde \\nu}_{b_k}+\\ell_k-1]\\right ] \\text { and } \\label{exp1 } \\\\ & { { \\mathcal e}}_{{{\\mathcal c}}_k}^{(r_2)}{[w({\\tilde \\nu}_{b_k } ) ] } > b_k \\alpha , \\label{exp2}\\end{aligned}\\ ] ] then @xmath401 } } { { { \\mathcal e}}_{{{\\mathcal c}}_k}^{(r_2)}{[1:{\\tilde \\nu}_{b_k}+\\ell_k-1 ] } } > \\frac{\\alpha}{e\\left[{{{\\mathcal e}}_{{{\\mathcal c}}_k}}[1:{\\tilde \\nu}_{b_k}+\\ell_k-1]\\right ] } = n_k^{-1}$ ] .",
    "moreover , there can be at most @xmath352 transmission blocks @xmath402 in @xmath354 $ ] satisfying @xmath403 } } { { { \\mathcal e}}_{{{\\mathcal c}}_k}^{(r_2)}{[1:{\\tilde \\nu}_{b_k}+\\ell_k-1 ] } } > n_k^{-1}$ ] , which implies that , if ( [ exp1 ] ) and ( [ exp2 ] ) are satisfied , the list decoder @xmath343 will be correct , i.e. , @xmath356 .",
    "the probability of error of the list detector is thus given by @xmath404 } \\geq b_k e\\left[{{{\\mathcal e}}_{{{\\mathcal c}}_k}}[1:{\\tilde \\nu}_{b_k}+\\ell_k-1]\\right ] \\cup { { \\mathcal e}}_{{{\\mathcal c}}_k}^{(r_2)}{[w({\\tilde \\nu}_{b_k } ) ] }   \\leq b_k \\alpha\\right )   \\nonumber \\\\ & \\leq \\pr\\left ( { { \\mathcal e}}_{{{\\mathcal c}}_k}^{(r_2)}{[w({\\tilde \\nu}_{b_k } ) ] }   \\leq b_k \\alpha \\right ) + \\pr\\left ( { { \\mathcal e}}_{{{\\mathcal c}}_k}^{(r_2)}{[1:{\\tilde \\nu}_{b_k}+\\ell_k-1 ] } \\geq b_k e\\left[{{{\\mathcal e}}_{{{\\mathcal c}}_k}}[1:{\\tilde \\nu}_{b_k}+\\ell_k-1]\\right ] \\right )   \\nonumber \\\\",
    "& \\leq \\pr\\left ( { { \\mathcal e}}_{{{\\mathcal c}}_k}^{(r_2)}{[w({\\tilde \\nu}_{b_k } ) ] }   \\leq b_k \\alpha \\right ) + \\pr\\left ( { { \\mathcal e}}_{{{\\mathcal c}}_k}{[1:{\\tilde \\nu}_{b_k}+\\ell_k-1 ] } \\geq b_k e\\left[{{{\\mathcal e}}_{{{\\mathcal c}}_k}}[1:{\\tilde \\nu}_{b_k}+\\ell_k-1]\\right ] \\right )   \\nonumber \\\\ & { \\stackrel{(\\roman{numcount})}{\\leq\\;}\\stepcounter{numcount}}\\pr\\left(\\left .   { { \\mathcal e}}_{{{\\mathcal c}}_k}^{(r_2)}{[w({\\tilde \\nu}_{b_k } ) ] }   \\leq b_k \\alpha   \\ , \\right| { \\tilde \\nu}_{b_k } \\in { { \\mathcal t}}_2(\\alpha,{{\\mathcal c}}_k,{\\epsilon}_k ) \\right ) + \\pr\\left({\\tilde \\nu}_{b_k } \\notin { { \\mathcal t}}_2(\\alpha,{{\\mathcal c}}_k,{\\epsilon}_k)\\right )   + 1/b_k \\nonumber \\\\ & { \\stackrel{(\\roman{numcount})}{\\leq\\;}\\stepcounter{numcount}}1/b_k + { \\epsilon}_k + \\pr\\left({\\tilde \\nu}_{b_k } \\notin { { \\mathcal t}}_2(\\alpha,{{\\mathcal c}}_k,{\\epsilon}_k)\\right ) , \\label{errorbound } \\end{aligned}\\ ] ] where @xmath225 follows from markov s inequality and @xmath225 follows from the fact that @xmath405 } \\leq \\alpha { b_k}\\ , \\right| { \\tilde \\nu}_{b_k } \\in { { \\mathcal t}}_2(\\alpha,{{\\mathcal c}}_k,{\\epsilon}_k ) \\right ) \\\\   & = \\sum_{t \\in { { \\mathcal t}}_2(\\alpha,{{\\mathcal c}}_k,{\\epsilon}_k ) } \\pr\\left({\\tilde \\nu}_{b_k } = t \\left| { \\tilde \\nu}_{b_k } \\in { { \\mathcal t}}_2(\\alpha,{{\\mathcal c}}_k,{\\epsilon}_k ) \\right .",
    "\\right ) \\pr \\left(\\left . {",
    "{ { \\mathcal e}}_{{{\\mathcal c}}_k}^{(r_2)}[w({\\tilde \\nu}_{b_k } ) ] } \\leq \\alpha{b_k } \\ , \\right| { \\tilde \\nu}_{b_k } = t \\right )   \\leq { \\epsilon}_k.\\end{aligned}\\ ] ] since we are in case ( [ lim1 ] ) , we have @xmath406 , and therefore @xmath407 .",
    "moreover , since @xmath408 , we know that , by adding some extra gaussian noise to its received signal , relay 1 can simulate the received signals at relay @xmath0 , and compute what the output of relay 2 would have been at each time @xmath33 .",
    "thus , relay 1 can create a list decoder for @xmath304 based on the simulated output of relay 2 , and since it will be statistically equal to the actual list decoder from relay 2 , its error probability will also tend to @xmath96 as @xmath65 .",
    "now , we need to take care of the fact that our codes only achieve causal energy - per - bit @xmath61 . to fix this",
    ", we will use the fact that both relays are approximately decoding the effective arrival time @xmath304 ( they have a list of subexponential size in @xmath67 containing @xmath304 with high probability ) , to improve the coding scheme such that both relays can decode @xmath304 exactly . in order to do that",
    ", we will have the source transmitting a pulse after the transmission block .",
    "define @xmath409 .",
    "notice that the fact that @xmath93 achieves a causal energy - per - bit @xmath61 implies that @xmath410 .",
    "this , in turn , implies that for a subsequence of codes @xmath411 , @xmath412 .",
    "therefore , we will restrict ourselves to this subsequence and drop the notation @xmath413 for simplicity .",
    "we will have the source transmitting a pulse of magnitude @xmath414 at time @xmath415 .",
    "notice that this time was previously not used by the scheme due to the non - overlapping transmission blocks requirement that @xmath416 .",
    "the relays , after adding a transmission time @xmath319 to the list , use a threshold detector at time @xmath417 with threshold @xmath418 . if a pulse is found at @xmath417 , the relay declares @xmath419 , and stops transmitting after that point . this way , we will be converting our scheme that achieves a causal energy - per - bit @xmath61 to a scheme that actually achieves an energy - per - bit @xmath61 .",
    "however , a further modification needs to be made , before we can bound the energy used by this code .",
    "we let @xmath420 be the event that both relays correctly detect the pulse , thus decoding @xmath304 correctly .",
    "we also let @xmath421 be the list decoder from relay @xmath11 .",
    "then we have @xmath422 and , from ( [ errorbound ] ) , we know that the first term tends to @xmath96 as @xmath65 . for the second term , we have @xmath423 \\nonumber \\\\ & \\quad \\quad \\quad \\quad + \\pr\\left [ y_i({\\tilde \\nu}_{b_k}+\\ell_k ) <",
    "\\sqrt{4 \\ln u_k } , i \\in \\{1,2\\ } \\right ] \\nonumber\\\\   & \\quad \\quad \\leq 2 |\\lambda_k| \\pr \\left[z \\geq \\sqrt{4 \\ln u_k } \\right ] + 2\\pr\\left [ z < - \\sqrt{4 \\ln u_k } \\right ] \\nonumber \\\\   & \\quad \\quad \\leq 2 u_k e^{-2 \\ln u_k } + 2e^{-2 \\ln u_k } = 2 ( u_k^{-1 } + u_k^{-2 } ) , \\label{errorpulse}\\end{aligned}\\ ] ] and we conclude that @xmath424 as @xmath65 .",
    "then we define @xmath425 , and we will have both relays stay silent in the last @xmath426 transmission blocks , where @xmath303 is the set of transmission times .",
    "it is easy to see that the probability of error of the resulting code still goes to @xmath96 as @xmath65 . since the relays stop transmitting after detecting a pulse at time @xmath417 for @xmath427 , we can now bound the energy used by the resulting code @xmath276 as @xmath428 { \\stackrel{(\\roman{numcount})}{\\leq\\;}\\stepcounter{numcount}}e\\left [ { { \\mathcal e}}_{{{\\mathcal c}}_k}[1:{\\tilde \\nu}_{b_k}+\\ell_k-1]\\right]+ e\\left [ { { \\mathcal e}}_{{{\\mathcal c}}_k'}{[{\\tilde \\nu}_{b_k}+\\ell_k : t_{(1-\\sqrt{\\gamma_k})|s_k|-1}+\\ell_k-1]}\\right ] \\nonumber \\\\ & { \\stackrel{(\\roman{numcount})}{=}\\stepcounter{numcount}}e\\left [ { { \\mathcal e}}_{{{\\mathcal c}}_k}{[1:{\\tilde \\nu}_{b_k}+\\ell_k-1]}\\right]+ \\frac{16 \\ln u_k}{g_2 } + e\\left [ \\left .",
    "{ { \\mathcal e}}_{{{\\mathcal c}}_k'}{[{\\tilde \\nu}_{b_k}+\\ell_k : t_{(1-\\sqrt{\\gamma_k})|s_k|-1}+\\ell_k-1]}\\right| { \\overline}{l_k } \\right ] \\pr({\\overline}{l_k } ) \\nonumber \\\\ & { \\stackrel{(\\roman{numcount})}{\\leq\\;}\\stepcounter{numcount}}e\\left [ { { \\mathcal e}}_{{{\\mathcal c}}_k}{[1:{\\tilde \\nu}_{b_k}+\\ell_k-1]}\\right]+ \\frac{16 \\ln u_k}{g_2 } + e\\left [ \\left.{{\\mathcal e}}_{{{\\mathcal c}}_k}{[1:{\\tilde \\nu}_{b_k}+\\ell_k-1]}\\right|   { \\tilde \\nu}_{b_k } \\geq t_{(1-\\sqrt{\\gamma_k})|s_k| } \\right ] \\gamma_k \\nonumber \\\\ & \\leq e\\left [ { { \\mathcal e}}_{{{\\mathcal c}}_k}{[1:{\\tilde \\nu}_{b_k}+\\ell_k-1]}\\right]+ \\frac{16 \\ln u_k}{g_2 } + \\gamma_k \\frac{e\\left [ { { \\mathcal e}}_{{{\\mathcal c}}_k}{[1:{\\tilde \\nu}_{b_k}+\\ell_k-1]}\\right]}{\\pr({\\tilde \\nu}_{b_k } \\geq t_{(1-\\sqrt{\\gamma_k})|s_k| } ) }   \\nonumber \\\\ & = ( 1+\\sqrt{\\gamma_k } ) e\\left [ { { \\mathcal e}}_{{{\\mathcal c}}_k}{[1:{\\tilde \\nu}_{b_k}+\\ell_k-1]}\\right]+ \\frac{16 \\ln u_k}{g_2 } ,   \\label{energypulse}\\end{aligned}\\ ] ] where @xmath225 follows because , up to time @xmath318 , the energy used by code @xmath276 is the same as the energy used by @xmath66 unless a pulse is incorrectly detected , in which case it is less ; @xmath225 follows because the energy spent from time @xmath429 on is the energy used in the pulse and then either @xmath96 if the pulse is detected , or the energy that would be spent otherwise ; @xmath225 follows from the fact that @xmath66 has non - overlapping transmission blocks , and , if the pulse is missed , @xmath276 behaves as @xmath66 would have behaved if the message had not arrived yet .",
    "now , since the sequence of codes @xmath93 achieves a causal energy - per - bit @xmath61 , it is easy to see that @xmath430}{b_k } \\leq e_b,\\end{aligned}\\ ] ] which means that @xmath276 achieves an energy - per - bit @xmath61 with both relays decoding the effective arrival time @xmath304 exactly .",
    "therefore , this decoder for @xmath304 can be converted into a list decoder for @xmath69 with a list of size @xmath398 which is subexponential in @xmath67 .",
    "the previous arguments imply that if , for some @xmath339 and some non - negative sequence @xmath336 with @xmath216 , we have ( [ lim1 ] ) , then the sequence of codes @xmath93 can be converted into another sequence of codes achieving the same energy - per - bit where both relays can have a list decoder @xmath343 for @xmath304 ( where @xmath332 is subexponential in @xmath67 ) with vanishing error probability . in this case , we fall into case ( a ) .",
    "therefore , for case ( b ) we only need to consider sequences of codes @xmath431 , such that for _ all _ @xmath341 and _ all _ non - negative sequences @xmath336 with @xmath216 , the sequence of codes built according to lemma [ lim10lem ] satisfies ( [ lim2 ] ) .",
    "thus , we assume that , for any @xmath339 and any @xmath336 with @xmath216 , we have a sequence of codes @xmath93 achieving the same energy - per - bit @xmath61 for which ( [ lim2 ] ) holds .",
    "our main modification will be to restrict the messages that our code @xmath66 can send .",
    "first we consider the set @xmath432 to simplify the notation , we will refer to the sets @xmath393 and @xmath433 by simply @xmath434 and @xmath435 .",
    "we notice that @xmath436 which implies that @xmath437 from ( [ lim2 ] ) , ( [ l2bound ] ) and the fact that @xmath438 as @xmath65 , we conclude that @xmath439 we will now use the set @xmath433 to define the messages that can be sent by our code .",
    "since the sequence @xmath336 with @xmath216 can be chosen arbitrarily , we fix it to be @xmath440 , where we define @xmath441 .",
    "if the set of messages for code @xmath66 is @xmath442 , then we will let , for each @xmath443 , @xmath444}{b_k } \\leq \\alpha \\",
    ", \\right| { \\tilde \\nu}_{b_k } = t , \\text{$m$ is sent } \\right ) >",
    "\\frac{{\\epsilon}_k}{2 } \\right . \\right\\}. \\label{boundenergy}\\end{aligned}\\ ] ] in order to lower bound the size of @xmath445 , we notice that , for @xmath446 , @xmath447 \\leq \\alpha b_k \\ , \\right| { \\tilde \\nu}_{b_k } = t \\right ) \\nonumber \\\\ & = \\sum_{m=1}^{2^{b_k } } 2^{-b_k } \\pr \\left(\\left . { { \\mathcal e}}_{{{\\mathcal c}}_k}^{(r_2)}[w({\\tilde \\nu}_{b_k } ) ] \\leq \\alpha b_k \\",
    ", \\right| { \\tilde \\nu}_{b_k } = t , \\text{$m$ is sent } \\right ) \\nonumber \\\\ & = \\sum_{m \\in { { \\mathcal m}}_t } 2^{-b_k } \\pr \\left(\\left .",
    "{ { \\mathcal e}}_{{{\\mathcal c}}_k}^{(r_2)}[w({\\tilde \\nu}_{b_k } ) ] \\leq \\alpha b_k \\ , \\right| { \\tilde \\nu}_{b_k } = t , \\text{$m$ is sent } \\right ) \\nonumber \\\\   & \\quad \\quad + \\sum_{m \\notin { { \\mathcal m}}_t } 2^{-b_k } \\pr \\left(\\left .",
    "{ { \\mathcal e}}_{{{\\mathcal c}}_k}^{(r_2)}[w({\\tilde \\nu}_{b_k } ) ] \\leq \\alpha b_k \\ , \\right| { \\tilde \\nu}_{b_k } = t , \\text{$m$ is sent } \\right ) \\nonumber \\\\ & < |{{\\mathcal m}}_t| 2^{-b_k } + \\left(2^{b_k } - |{{\\mathcal m}}_t| \\right ) 2^{-b_k } \\frac{{\\epsilon}_k}2 \\leq |{{\\mathcal m}}_t| 2^{-b_k }   + \\frac{{\\epsilon}_k}{2}. \\nonumber\\end{aligned}\\ ] ] therefore , we have latexmath:[\\ ] ] where @xmath878 which clearly satisfies @xmath526 as @xmath527 ."
  ],
  "abstract_text": [
    "<S> when data traffic in a wireless network is bursty , small amounts of data sporadically become available for transmission , at times that are unknown at the receivers , and an extra amount of energy must be spent at the transmitters to overcome this lack of synchronization between the network nodes . in practice , </S>",
    "<S> pre - defined header sequences are used with the purpose of synchronizing the different network nodes . however , in networks where relays must be used for communication , the overhead required for synchronizing the entire network may be very significant . in this work , we study the fundamental limits of energy - efficient communication in an asynchronous diamond network with two relays . </S>",
    "<S> we formalize the notion of relay synchronization by saying that a relay is synchronized if the conditional entropy of the arrival time of the source message given the received signals at the relay is small . </S>",
    "<S> we show that the minimum energy - per - bit for bursty traffic in diamond networks is achieved with a coding scheme where each relay is either synchronized or not used at all . </S>",
    "<S> a consequence of this result is the derivation of a lower bound to the _ minimum energy - per - bit _ for bursty communication in diamond networks . </S>",
    "<S> this bound allows us to show that schemes that perform the tasks of synchronization and communication separately ( i.e. , with synchronization signals preceding the communication block ) can achieve the minimum energy - per - bit to within a constant fraction that ranges from @xmath0 in the synchronous case to @xmath1 in the highly asynchronous regime . </S>"
  ]
}