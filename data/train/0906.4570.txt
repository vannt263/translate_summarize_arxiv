{
  "article_text": [
    "a widespread design approach in distributed applications based on the service - oriented paradigm ( so ) , such as web - services , consists of clearly separating the workflow ( wf ) from the policy management ( pm ) .",
    "the former orchestrates complex processing of data performed by the various principals using a set of resources made available in the application , while the latter aims to regulate access decisions to the shared resources , based on policy statements made by the involved principals .",
    "this separation of concerns is beneficial in several respects for the design , maintenance , and verification of the resulting applications such as reusing policies across applications .",
    "one of the key problems in obtaining a correct design of so applications is to be able to foresee all the  sometimes subtle  ways in which their wf and pm levels interact . to understand the difficulty underlying this endevor , let us first consider the wf level . in this respect , so applications can be seen as distributed systems whose transitions can be interleaved in many possible ways .",
    "this already creates a first difficult problem : to understand the behaviors of an so application and then to establish if it meets certain properties .",
    "an additional burden , typical to so applications , is the presence of the pm level , which is supposed to constrain the allowed behaviors of the application so as to meet certain crucial security requirements .",
    "declarative policy languages ( such as datalog and other languages built on top of it , like binder  @xcite , secpal  @xcite and dkal  @xcite ) , usually based on a ( fragment of ) first - order logic , are used to design the pm level of so applications in a more flexible , reusable , and verification - friendly way . the high flexibility and expressiveness of such languages",
    "may grant access to a resource to someone who , in the intention of the policy designer , is not allowed to do so .",
    "to further complicate the situation , there are the subtle ways in which the wf and the pm levels may interact so as to give rise to behaviors that are unintended and may breach some crucial security requirements of an so application . as a concrete example of this point , consider a system for virtual program committee meetings",
    ". a policy governing access to the reviews of a paper may be the following : a reviewer assigned to a paper is required to submit his own review before being able to read those of the others .",
    "so , in order to resolve an access request to the reviews of a paper , the system should be able not only to know the identities and the roles of the various members of the program committee but also to maintain and consult the information about which reviewers have already submitted their reviews .",
    "indeed , information of the first kind must be derived from the wf level .",
    "given all the difficulties to obtain correct designs for so applications , formal methods have been advocated to help in this task .",
    "unfortunately , most ( see , e.g. ,  @xcite ) of the specification and verification techniques ( with some notable exceptions , e.g. ,  @xcite ) have concentrated on one level at a time and abstracted away the possible interplays between the wf and the pm level .",
    "the _ first contribution _ of this paper is a framework capable of formalizing both the wf and the pm level as well as their interface so as to enable a more precise analysis of the possible behaviors of so applications .",
    "in particular , we use a temporal extension of first - order logic , similarly to what has been proposed in  @xcite for the specification and verification of reactive systems .",
    "the motivations for this choice are three - fold .",
    "first , workflows can be easily specified by using first - order formulae to describe sets of states and transitions of so applications .",
    "second , a simple extension of this well - known framework allows us to easily specify policy - relevant facts and statements .",
    "third , we hope to adapt and reuse to the case of so applications the cornucopia of specification and verification techniques developed for reactive systems . as a first step in this direction ,",
    "the _ second contribution _ of this paper is to define and investigate some verification problems for so applications and give sufficient conditions for their decidability . in particular , we show how executability and some security properties ( which can be expressed as invariants ) can be automatically verified within the proposed framework .",
    "we proceed as follows . in section  [ subsec : comb - fol - ltl ] , we summarize the key points of a restricted combination of first - order and temporal logic , which provides a formal basis for our approach . in section",
    "[ sec : framework ] , we present our formal two - level specification framework for so applications , which we apply , in section  [ sec : verification ] , on a number of interesting verification problems for so applications . in section  [ sec : conclusions",
    "] , we discuss related and future work , and draw conclusions .    due to lack of space , proofs",
    "are given in the accompanying technical report  @xcite , which also contains the detailed formalization of a case study that illustrates our framework at work , as well as a number of useful pragmatical observations .",
    "due to lack of space , proofs are given in the appendix , together with the detailed formalization of a case study that illustrates our framework at work , and with a number of useful pragmatical observations .",
    "as a formal basis for our approach we use a standard  @xcite minimal extension of _ linear time logic _ ( _ ltl _ ) with a _ many - sorted version of first - order logic with equality _ ( _ fol@xmath0 _ ) .",
    "we recall now some useful definitions and properties of fol@xmath0 where , for brevity , we do not explicitly consider sorts although all notions can be easily adapted to the many - sorted version . we assume the usual first - order syntactic notions of _ signature _ , _ term _ ,",
    "_ literal _ , _ formula _ , _ quantifier - free formula _ ,",
    "_ substitution _ and _ grounding _ substitution , _ sort _ and so on , and call _ sentence _ a formula that does not contain free variables .",
    "also the semantic notions of _ structure _ , _ satisfiability _ , _ validity _ , and _ logical consequence _ are the standard ones .",
    "let @xmath1 be a fol@xmath0 signature .",
    "an _ expression _ is a term , an atom , a literal , or a formula .",
    "@xmath2-expression _ is an expression built out of the symbols in @xmath1 where at most the variables in the sequence @xmath3 of variables may occur free , and we write @xmath4 to emphasize that @xmath5 is a @xmath2-expression .",
    "similarly , for a finite sequence @xmath6 of predicate symbols in @xmath1 , we write @xmath7 to denote a @xmath1-formula where at most the predicate symbols in @xmath6 may occur .",
    "we juxtapose sequences to denote their concatenation , e.g.  @xmath8 , and abuse notation and write @xmath9 to denote the empty sequence besides the empty set .",
    "if @xmath10 is a substitution and @xmath11 is a ( finite ) sequence of expressions , then @xmath12 is the sequence of expressions obtained from @xmath11 by applying the substitution @xmath10 to each element of @xmath11 .",
    "following  @xcite , we use a tuple @xmath3 of variables , called _ wf state variables _ , to represent the values of application variables at a given instant of time , and use a fol formula @xmath13 to represent sets of states .",
    "wf state variables take values in the domain of a first - order structure , which formalizes the data structures , the values of the control locations , and those of the auxiliary variables of the wf of a certain so application .",
    "formally , let @xmath1 be a signature ( containing , e.g. , the operators of certain data structures or the names of some control locations ) and @xmath14 be a @xmath1-structure ; @xmath15 means that the state formula @xmath13 is true in @xmath14 for the valuation @xmath16 mapping the variables in @xmath3 to elements of the domain of @xmath14 . as shown in  @xcite , this is enough for the specification of virtually any reactive system and hence also for the wf level .",
    "however , the state of so applications should also support the pm level whose relevant part is represented by tables where certain facts are recorded ( e.g. , `` is - reviewer - of '' for the example in the introduction ) . following the relational model of databases ,",
    "we formalize tables as predicates and we add to the wf state variables a set @xmath17 of fresh predicate symbols ( i.e.  @xmath18 ) , called _ pm state variables_. any @xmath1-formula @xmath19 is an _ so state formula_. for a @xmath1-structure @xmath20 , a valuation @xmath16 mapping the wf state variables in @xmath3 to elements of the domain @xmath21 , and a relational valuation @xmath22 mapping the pm state variables in @xmath17 ( such that @xmath23 ) to the powerset of @xmath21 , we write @xmath24 to denote that @xmath25 where @xmath26 is the @xmath27-structure obtained from @xmath14 by taking @xmath28 , @xmath29 , and @xmath30 for each @xmath31 .",
    "the tuple @xmath32 ( or simply @xmath33 , when @xmath14 is clear from context ) is an _ so state_.    let @xmath1 be a signature and @xmath14 be a @xmath1-structure .",
    "we formalize an so application by a tuple @xmath34 , called an _ so transition system _ , where @xmath3 are the wf state variables , @xmath17 are the pm state variables , @xmath35 is a @xmath36-formula , and @xmath37 is a finite set of @xmath38-formulae , called _ transitions _ , which relate a set of so states ( identified by the `` values '' of @xmath39 ) to that of a set of so `` next '' states ( identified by the `` values '' of @xmath40 ) . if @xmath41 and @xmath42 , then our notion of so transition system reduces to that of transition system in  @xcite ; in the rest of this paper , we assume that @xmath43 .",
    "a _ run _ of an so transition system @xmath44 is an infinite sequence of so states @xmath45 such that @xmath46 and for every @xmath47 , there exists a transition @xmath48 such that @xmath49 where @xmath50 ( respectively , @xmath51 ) map state variables and predicates in @xmath39 ( respectively , @xmath40 ) .",
    "to specify properties of so transition systems , we use an extension of linear time logic .",
    "formally , let @xmath39 be so state variables and @xmath1 be a signature ; the set @xmath52 of _ ltl ( state - based ) formulae for @xmath1 and @xmath39 _ is inductively defined as follows : state formulae are in @xmath52 and if @xmath53 is a state formula then @xmath54 is in @xmath52 .",
    "note that we prohibit alternation of fol quantifiers and temporal operators : this makes the logic less expressive but it helps to derive decidability results for the satisfiability problem , which is a necessary condition to develop ( semi-)automatic verification methods for so applications .",
    "let @xmath14 be a @xmath1-structure .",
    "a _ model _ of an @xmath52-formula is an infinite sequence @xmath55 of so states such that each @xmath50 map all the so state variables in @xmath39 , for @xmath47 .",
    "we then say that an @xmath52-formula @xmath19 is _ true in a model @xmath55 _ , and write @xmath56 iff    * @xmath57 whenever @xmath19 is a state formula ; * @xmath58 iff @xmath59 , for every @xmath60 .",
    "let @xmath61 be an so transition system , @xmath14 be a @xmath1-structure , and @xmath19 be an @xmath52-formula .",
    "then , @xmath62 iff @xmath63 for every run @xmath64 of @xmath65 .",
    "a state formula @xmath66 is an _",
    "invariant for the so transition system @xmath65 _ if @xmath67 .",
    "recall that one of the main goals of this paper is to provide a natural specification framework for so applications whose architecture is organized in two levels .",
    "indeed , it is possible to model a large class of so applications by using the notion of so transition system introduced in the previous section .",
    "however , a good framework should provide an adequate support to restrict the design space for a two - level so application and allow the designer to easily specify the wf level , the pm level , and their interface in isolation according to a divide - and - conquer strategy . in our framework , this consists of identifying suitable first - order structures formalizing both the data structures at the wf level and the tables at the pm level .",
    "unfortunately , working with first - order structures for specification is quite difficult since there is no obvious way to mechanically represent and reason about them .",
    "fortunately , first - order theories are sets of fol@xmath0 sentences that can be used as reasonably precise approximations of first - order structures and for which there is automated reasoning support .",
    "hence , we decided to use theories to describe the wf , the pm levels , and their interface , as illustrated in fig .",
    "[ fig : ths - rels ] : if @xmath68 and @xmath69 are the theories formalizing the wf and the pm levels , respectively , then their intersection @xmath70 , called the _ substrate theory _ , formalizes their interface .",
    "intuitively , the theory @xmath71 ensures that the wf and pm levels `` agree '' on certain notions .",
    "for example , @xmath71 univocally identifies the principals involved in the so application and possibly ( an abstraction of ) the structure of the resources that the so application can access or make available .",
    "as we will see , the use of theories allows us to easily import declarative policy specifications expressed in logical languages based on ( extensions of ) datalog in our framework .",
    "[ sec : modelling ]    fol formalization of the wf and pm levels of so applications ]    a similar approach can also be used to restrict the formulae characterizing transitions .",
    "intuitively , the transitions that can be specified by formulae in the identified class are such that the updates on the values of both the wf and the pm state variables are functional ( if we regard relations as first - order objects ) .",
    "since the identities of the principals involved in the so application being specified play a crucial role in enabling or disabling the possibility to execute a certain transition , the functional updates will depend not only on the values of the actual so state but also on the existence of certain principals .    before being able to formalize these intuitions",
    ", we recall the concept of fol@xmath0 theory and some standard related notions .      a _ @xmath1-theory _",
    "@xmath72 is a set of first - order @xmath1-sentences , called the _",
    "axioms _ of @xmath72 .",
    "a @xmath1-structure @xmath14 is a _ model _ of the @xmath1-theory @xmath72 iff all the sentences in @xmath72 are true in @xmath14 .",
    "a @xmath1-theory @xmath72 is _ consistent _ if it admits at least one model .",
    "the @xmath72-_satisfiability problem _ for a quantifier - free @xmath1-formula @xmath19 ( such that @xmath18 ) consists of checking whether there exists a model @xmath14 of @xmath72 and mappings @xmath16 and @xmath22 such that @xmath73 . by transformation in disjunctive normal form ( i.e.  as disjunctions of conjunctions of literals )",
    ", the @xmath72-satisfiability problem for quantifier - free formulae can be reduced to the @xmath72-satisfiability problem for ( quantifier - free ) conjunctions of literals .    for specifying so applications , we usually need to introduce a finite set of unique identifiers to name the various principals .",
    "formally , this can be done by using a theory of the following kind .",
    "an _ enumerated data - type theory @xmath74 _ is axiomatized by the sentences @xmath75 for @xmath76 a sort symbol in the given signature ( omitted for simplicity ) and @xmath77 , @xmath78 of sort @xmath79 for @xmath80 and @xmath81 .",
    "it is easy to see that the @xmath74-satisfiability problem is decidable .",
    "enumerated data - type theories will be sub - theories of the theory formalizing the interface between the wf and pm levels .    for the wf level",
    ", we can reuse all the theories available in the literature formalizing data structures and the decision procedures for their satisfiability problem ( see , e.g. ,  @xcite for an overview ) .",
    "enumerated data - type theories are also useful for the wf level as they can formalize the ( finitely many ) control locations of an application .",
    "we now give a concrete example of a theory capable of formalizing a simple message passing network that is relevant for so applications    ( see  @xcite for a more detailed case study ) .",
    "( see appendix  [ subsec : running - ex ] for a more detailed case study ) .",
    "[ ex : msg - pass ] a net can be seen abstractly as a set of messages : sending a message amounts to adding the message to the set while receiving a message consists of checking if it is a member of the net ; hence , messages are never deleted , only added to the set representing the net .",
    "this view is simple but still allows one to model interesting facts such as the reception of messages in any order ( since a set does not require an ordering on its elements ) or duplication of messages ( as a message is never removed from the net ) .    to model the simple fragment of set theory necessary to formalize this idea in fol",
    ", we use a theory @xmath82 $ ] , parametrized over the sort @xmath83 of messages which contains @xmath84 as the sort for sets of messages , the constant @xmath85 of sort @xmath84 denoting the empty set , the binary function symbol @xmath86 of sort @xmath87 denoting the operation of adding a message to a set of messages , and the binary predicate symbol @xmath88 of sort @xmath89 for checking if a message is in a set of messages .",
    "the axioms of @xmath82 $ ] are the following three sentences : @xmath90 where @xmath91 are variables of sort @xmath83 and @xmath76 is a variable of sort @xmath84 .",
    "it is easy to describe the states of a variable ` net ` : just introduce a logical variable @xmath92 and use suitable formulae from the theory @xmath82 $ ] .",
    "for example , the formula @xmath93 constrains ` net ` to contain at least two messages ( plus possibly others ) .",
    "note that the only free variable in the formulae describing sets of states is @xmath92 .",
    "the @xmath82$]-satisfiability problem is decidable  @xcite .    for the pm level",
    ", we recall the class of bernays - schnfikel - ramsey ( bsr ) sentences  @xcite , which has been used , among other applications , to model relational databases . a _",
    "bsr - theory _ is a set of sentences of the form @xmath94 where @xmath3 and @xmath95 are tuples of variables and @xmath53 is a quantifier - free formula containing only predicate and constant symbols ( or , equivalently , no function symbols of arity greater than or equal to @xmath96 ) .",
    "the decidability of the satisfiability problem for any bsr - theory is a well - known decidability result  @xcite .",
    "the following sub - class of bsr - theories can be used to specify policies as shown in , e.g. ,  @xcite .",
    "datalog - theory _ is a bsr - theory whose sentences are of the form @xmath97 where @xmath98 , for @xmath99 , are predicate symbols , and @xmath100 are disjoint tuples of variables such that the length of @xmath3 is equal to the arity of @xmath101 .",
    "usually , sentences of the form ( [ eq : horn - cl ] ) are written as @xmath102 where @xmath103 can be read as the reverse of the implication connective ( sometimes also the universal quantifiers will be dropped ) .",
    "formulae written in this way are called _ rules _ in the literature , while their hypotheses and @xmath104 are called the _ body _ and the _ head _ of the rule , respectively .",
    "we conclude by recalling some notions that are relevant for the combination of theories that provide us with the formal tools to separately specify the wf and pm levels of an so application and then modularly combine them .",
    "let @xmath105 and @xmath106 be two theories ; we say that they _ share _ the theory @xmath107 if @xmath108 and their _ combination",
    "_ @xmath109 is _ non - disjoint_. otherwise ( i.e.  when @xmath110 ) , we say that the combination @xmath111 is _",
    "disjoint_. for verification , it is important to combine decision procedures for each theory @xmath105 and @xmath106 so as to obtain a decision procedure for their combination .",
    "this is crucial to derive decidability results for verification problems of so applications as we will reduce them to satisfiability problems in the combination of the theories formalizing the wf and the pm levels .",
    "a class of theories that will be relevant in this task ( see lemma  [ th : dec - soa - sat - univ ] below ) is the following . a theory @xmath72 is _ stably infinite _ if a @xmath72-satisfiable quantifier - free formula is satisfiable in a model of @xmath72 whose domain has infinite cardinality .",
    "examples of stably infinite theories are @xmath82 $ ] of example  [ ex : msg - pass ] , any bsr theory ( see , e.g. ,  @xcite ) , and many theories formalizing data structures , such as arrays or sets .",
    "enumerated data - type theories are not stably infinite as they admit only models whose domains have finite cardinality .",
    "we are now ready to define an instance of the framework of  section  [ subsec : comb - fol - ltl ] to formally specify so applications designed according to the two - level architectures considered in this paper .",
    "this framework relies on the following assumptions .",
    "[ framework - one ] as depicted in fig .",
    "[ fig : ths - rels ] , we assume that the wf and pm levels are formalized by a @xmath112-theory @xmath68 and a @xmath113-theory @xmath69 , which share a @xmath114-theory @xmath71 , called the _ substrate_. formally , @xmath115 and @xmath116 , and @xmath117 and @xmath118 .",
    "the shared theory @xmath71 plays the role of _ interface _ between the two levels .",
    "a minimal requirement on the interface is to provide some knowledge about the identities of the principals involved in the so application .",
    "this is formalized as follows .",
    "[ framework - two ] @xmath114 contains the sort symbol @xmath119 .",
    "this last assumption is crucial for many aspects of so applications related to pm , such as integrity ( of messages or certificates ) , authenticity ( of certificates ) , and proof - of - compliance ( of credentials ) .    using the notion of combination of theories introduced at the end of  section  [ subsec : fol - theories - for - soas ] , we are now able to define the concept of background theory for an so application that is obtained by modularly combining the theories formalizing the wf and the pm levels .",
    "let @xmath120 , and @xmath69 be consistent theories satisfying framework assumptions  [ framework - one ] and  [ framework - two ] .",
    "background @xmath121-theory @xmath122 _ is the union of the theories @xmath68 and @xmath69 , i.e.@xmath123 and @xmath124 .",
    "note that , by robinson consistency theorem ( see , e.g. ,  @xcite ) , @xmath122 is consistent since both @xmath68 and @xmath69 are assumed to be so .",
    "we will sometimes refer to @xmath68 as the _ wf background theory _ and to @xmath69 as the _ pm background theory_.    we introduce a particular class of so transition systems ( defined in  section  [ subsec : comb - fol - ltl ] ) by using background theories obtained by combining theories for the wf and pm levels satisfying the two framework assumptions above . a technical problem in doing",
    "this is the following .",
    "so transition systems ( in particular their states and runs ) are defined with respect to a certain first - order structure . instead , we want to use theories that , in general , identify classes of first - order structures and not just one particular structure .",
    "however , since the verification problems for so applications considered below will be reduced to satisfiability problems , the following notion tells us that  under suitable conditions  we can use theories in place of structures .",
    "a @xmath1-theory @xmath72 is _ adequate _ for a @xmath1-structure @xmath14 if @xmath15 , for some valuation @xmath16 mapping the variables in @xmath3 to elements of the domain of @xmath14 , is equivalent to the @xmath72-satisfiability of @xmath13 , for any quantifier - free formula @xmath13 .",
    "for example , it is possible to see that enumerated data - type theories are adequate for any of their models ( as they are all isomorphic ) or that the theory @xmath82 $ ] is adequate to the structure containing finite sets of messages .    as notation ,",
    "let us write @xmath125 ( respectively , @xmath126 ) to abbreviate the finite conjunction , for @xmath127 , of formulae of the form @xmath128 ( respectively , @xmath129 ) when @xmath130 , @xmath131 ( respectively , @xmath132 ) , @xmath133 , and the length of @xmath134 is equal to the arity of @xmath135 .    let @xmath71 , @xmath68 , and @xmath69 be consistent theories satisfying framework assumptions  [ framework - one ] and  [ framework - two ] and @xmath14 be a @xmath121-structure .",
    "a _ two - level so transition system ( with background theory @xmath122 adequate for @xmath14 ) _ is an so transition system @xmath136 such that ( a ) @xmath137 ; ( b ) @xmath35 is a state @xmath121-formula of the form : @xmath138 where @xmath139 is a finite sequence of variables of sort @xmath119 , @xmath140 is a quantifier - free @xmath141-formula , and @xmath142 is a quantifier - free @xmath143-formula ; and ( c ) @xmath37 is a finite state of transition formula of the form @xmath144 called _ guarded assignment transition _ , where @xmath139 is a tuple of variables of sort @xmath119 ; @xmath145 are sets of variables of a sort dependent on the wf and pm levels of the application ; @xmath146 is a quantifier - free formula , called the _",
    "guard _ of the transition ; @xmath147 is a tuple of @xmath148-terms , called the _",
    "wf updates _ of the transition , whose sorts are pairwise equal to those of the state variables in @xmath3 ; and @xmath149 is a tuple of quantifier - free @xmath150-formulae , called the _",
    "pm updates _ of the transition .",
    "if @xmath151 ( recall that we have assumed that @xmath43 for so transition systems , cf .  section  [ subsec : comb - fol - ltl ] ) , then we say that the so application is _",
    "( purely ) relational_. intuitively , the form ( [ eq : initial - formula ] ) for the initial state formula is inspired by the observation that usually the principals at the beginning of the computation have some common ( or no ) knowledge about the facts that are relevant to the pm level .",
    "note that @xmath147 and @xmath149 may not contain the state variables in @xmath152 and the state predicates in @xmath153 , i.e.updates are not recursive .",
    "below , for simplicity , we will no more mention the @xmath121-structure @xmath14 and implicitly assume that @xmath122 is adequate for @xmath14 . to help intuition",
    ", we illustrate the notion of two - level so transition system by means of a simple example ( extracted from a larger one in  @xcite ) .",
    "below , for simplicity , we will no more mention the @xmath121-structure @xmath14 and implicitly assume that @xmath122 is adequate for @xmath14 . to help intuition",
    ", we illustrate the notion of two - level so transition system by means of a simple example ( extracted from the case study in the appendix ) .",
    "[ ex : so - appl ] consider a situation where the clerks of an office may send messages over a network .",
    "the messages may contain , among many other things , certificates about their identities , roles , or capability to access certain resources in the organization they belong to .",
    "certificates about the identities and roles are issued by a trusted certification authority while those about the access to a certain resource are issued by heads ( who are clerks with this special right ) . in order to comply with the policies of accessing resources",
    ", each clerk maintains a table about his / her identity , role , and access capability as well as about other clerks .",
    "we describe a two - level so transition system to formalize this situation .",
    "first of all , we specify the wf background theory : @xmath154 \\cup \\mathit{msg } \\cup \\mathit{cert }     \\end{aligned}\\ ] ] where @xmath155 and @xmath156 are two clerks , @xmath157 is the trusted certification authority , @xmath158 is a shared resource ( e.g. , a repository ) , @xmath159 and @xmath160 are the possible roles of clerks , and @xmath82 $ ] is the theory for message passing introduced in example  [ ex : msg - pass ] . in particular , @xmath83 is a theory to describe the structure of messages as follows : a message contains a field identifying the sender , a field identifying the receiver , and a field carrying their contents .",
    "formally , this is done by introducing two new sort symbols @xmath161 and the ternary function @xmath162 of sort @xmath163 .",
    "finally , @xmath164 is a theory to provide functionalities to analyze the body of messages and extract some relevant information : the predicate @xmath165 of sort @xmath166 is capable of recognizing that the body of a message contains a certificate that its second argument is the identifier of a clerk whose role is that of its third argument .",
    "for example , if @xmath167 is a constant of sort @xmath161 representing the certificate that the employee @xmath155 has the role @xmath159 , then the message sent by @xmath157 to @xmath156 containing the certificate @xmath167 is encoded by the following term : @xmath168 and we will also have that , e.g. , @xmath169 holds .",
    "@xmath170    where @xmath171 are variables of sort @xmath119 , @xmath172 is a variable of sort @xmath161 , and @xmath173 is a variable of sort @xmath174    the state of the two - level so transition system specifying the situation above should contain a wf state variable @xmath92 of sort @xmath84 ( containing the set of messages exchanged during a run of the transition system ) and a pm state variable @xmath175 of arity @xmath176 ( storing the join of the tables of each clerk about their roles )",
    ". the initial state of the system should specify that no message has been exchanged over the net and that no role is known to the various clerks .",
    "this can be formalized by a state formula as follows : @xmath177 which is a formula of the form ( [ eq : initial - formula ] ) by taking @xmath178 , @xmath179 , @xmath180 , and @xmath181 .    as an example of interplay between the wf and pm levels , fig .",
    "[ ex : so - appl ] shows the guarded assignment transition of the form ( [ eq : trans - form ] ) that formalizes what happens when a message containing a certificate about the role of an employee ( say , @xmath155 ) is sent to another employee ( say , @xmath156 ) by the certification authority ( @xmath157 ) .",
    "note that the content of the state variable @xmath92 is left unchanged by the transition , whose only effect is to update the access table ( represented by the predicate @xmath175 ) with the entry corresponding to the content of the received ( role ) certificate .",
    "for example , upon reception of the message containing the certificate @xmath167 , the following fact @xmath182 must hold in the next state , while for all the other triples , @xmath183 has the same boolean value of @xmath175 .",
    "so far , we have specified the wf level of the so application . as anticipated above",
    ", we can define @xmath69 to contain @xmath71 and a finite set of datalog rules that declaratively formalize the access policy statements of the so application .",
    "since this way of formalizing policies has been well studied in the literature ( see , e.g. ,  @xcite ) , as a simple example , we only give the following datalog rule @xmath184 where the variable @xmath185 is of sort @xmath119 and @xmath186 .",
    "it says that the clerk @xmath185 can access the shared resource @xmath158 if the latter knows ( by retrieving the right entry in the table represented by @xmath175 ) that @xmath185 has the role of @xmath160 .    in  @xcite",
    ", we discuss in detail a generalization of the above example inspired by an industrial application .",
    "appendix  [ sec : pragmatics - modeling ] contains a generalization of the example above inspired by an industrial application .",
    "let @xmath187 be a two - level so transition system with background theory @xmath122 for an so application ; for brevity , we will sometimes refer to @xmath188 simply as so application .",
    "we define and investigate some verification problems for so applications and give sufficient conditions for their decidability .    in  @xcite , we also discuss pragmatical aspects of how to implement the decision procedures .    in appendices  [ sec : pragmatics - executability ] and",
    "[ sec : pragmatics - invariant ] , we then discuss pragmatical aspects of how to implement the decision procedures .",
    "symbolic execution is a form of execution where many possible behaviors of a system are considered simultaneously .",
    "this is achieved by using symbolic variables to represent many possible states and executions . for each possible valuation of these variables",
    ", there is a concrete system state that is being indirectly simulated .",
    "this technique is particularly useful for the design of so applications when usually several scenarios are identified as typical execution paths that the application should support .",
    "given the high degree of non - determinism and the subtle interplay between the wf and the pm levels , it is often far from being obvious that the so application just designed allows one or many of the chosen scenarios",
    ". a valuable contribution of the proposed framework is that symbolic execution of so applications can be done by using existing techniques for automated deduction .    in any scenario",
    ", there is only a known and finite number of principals .",
    "so , for the verification of the executability of two - level so transition systems , we can assume that :    @xmath189 .    since there are only finitely many principals , universal quantifiers in initial state formulae do not add to expressiveness as @xmath190 is logically @xmath122-equivalent to a quantifier - free formula of the form @xmath191 , where @xmath10 ranges over all possible grounding substitutions mapping the variables in @xmath139 to the constants in @xmath192 .",
    "thus , we can further assume that :    initial state formulae as well as any other state formula used to describe a state of a scenario are quantifier - free .",
    "the key notion for symbolic execution in our framework is the following .",
    "let @xmath193 and @xmath194 two quantifier - free state @xmath121-formulae ; and let @xmath195 be a transition formula of the form .",
    "we write @xmath196 ( in analogy with hoare triples ) to abbreviate the following formula : @xmath197 whose validity modulo @xmath122 implies that _ the transition @xmath198 leads @xmath188 from a state satisfying @xmath53 to one satisfying @xmath199_.    let @xmath187 be a two - level so transition system with background theory @xmath122 , let @xmath200 be a sequence of transition formulae such that @xmath201 , and let @xmath202 be a sequence of quantifier - free state formulae .",
    "the _ ( symbolic ) execution problem _ consists of checking whether @xmath203 leads @xmath188 from a state satisfying @xmath204 to a state satisfying @xmath205 , or , equivalently , to checking @xmath206 for each @xmath207 .",
    "[ prop : pre - comp - se ] let @xmath53 and @xmath199 be two quantifier - free state formulae and @xmath198 be a transition .",
    "then , it is possible to effectively compute a quantifier - free formula @xmath208 that is logically equivalent to the negation of @xmath209 and such that @xmath210 iff @xmath211    that is , for quantifier - free @xmath53 and @xmath199 , the negation of @xmath209 `` is '' still quantifier - free .",
    "that is , for quantifier - free @xmath53 and @xmath199 , the negation of @xmath209 `` is '' still quantifier - free ( e.g. , the negation of @xmath212 in the case study in appendix  [ subsec : running - ex ] )",
    ".    if we are able to check the @xmath122-satisfiability of quantifier - free formulae , then we are also able to solve the symbolic execution problem for the two - level so transition system with @xmath122 as background theory .",
    "we now identify sufficient conditions on the component theories of @xmath122 ( i.e.@xmath213 and @xmath69 ) for the decidability of the @xmath122-satisfiability problem .",
    "[ th : dec - soa - sat ] let @xmath71 be an enumerated data - type theory , and @xmath214 and @xmath215 be consistent theories with decidable satisfiability problems .",
    "the @xmath122-satisfiability problem is decidable for @xmath216 .",
    "pragmatical aspects of how to implement the decision procedures are discussed in  @xcite .",
    "pragmatical aspects of how to implement the decision procedures are discussed in appendix  [ sec : pragmatics - executability ] , extending the observations on the pragmatics of modeling wf and pm of so applications of appendix  [ sec : pragmatics - modeling ] .",
    "we are now in the position to state the main result of this section , which follows from the properties and lemmas above .",
    "let @xmath71 be an enumerated data - type theory , and @xmath214 and @xmath215 be consistent theories with decidable satisfiability problems .",
    "then , the symbolic execution problem for two - level so transition systems with background theory @xmath217 is decidable .",
    "note that the use of an enumerated data - type theory as @xmath71 does not imply that only two - level so transition systems with finite state space can be verified by our method .",
    "in fact , both @xmath68 and @xmath69 can have models with infinite cardinalities ( this is the case , for example , of the theory @xmath218 ) .",
    "so , symbolic execution is decidable even if the state space of the two - level so transition systems is infinite provided that there exist decision procedures for the theories characterizing the wf and the pm levels and it is possible to find a common sub - theory , used for synchronization by the two levels , whose models are finite .",
    "recall that we fixed a two - level so transition system @xmath187 with background theory @xmath122 .",
    "we now consider the problem of verifying that @xmath188 satisfies a certain security property @xmath208 , in symbols @xmath219 .",
    "since many interesting security properties can be expressed as invariance properties ( e.g. , for the verification of security protocols or web services ) , which are a sub - class of safety properties , we assume below that @xmath208 is a state formula of the form @xmath220 two remarks are in order .",
    "first , we are considering a sub - class of invariance properties since , in general , @xmath53 can be a past - formula ( see , e.g. ,  @xcite ) .",
    "second , we can not assume that a finite and known number of principals is fixed so that ( [ eq : inv - form ] ) is equivalent to a quantifier - free formula and thus the verification techniques in  section  [ sec : exec - so - apps ] still apply . rather , we want to verify that for a fixed but unknown number of principals",
    ", @xmath188 satisfies the invariance property @xmath208 , i.e.  we want to solve a",
    "_ parameterized _ invariance verification problem .",
    "for this reason , in the rest of this section , we assume that :    @xmath71 is the theory of an equivalence relation .    in this way",
    ", we are able to distinguish between the identifiers of the various principals .",
    "now , in order to show that formulae of the form ( [ eq : inv - form ] ) are invariant of @xmath188 , we can use the well - known inv rule of manna and pnueli  @xcite : @xmath221            & \\mathcal{a } & \\models & \\box \\varphi    \\end{array}\\end{aligned}\\ ] ] the intuition underlying the correctness of the rule is the following .",
    "assume there exists a formula @xmath199 of the form ( [ eq : inv - form ] ) identifying a set of states that includes both the set of initial states @xmath222 and the set of states characterized by @xmath53 @xmath223 , and , furthermore is an invariant of @xmath188 @xmath223 , i.e.  each transition of @xmath203 in @xmath37 leads from a state satisfying @xmath199 to a state satisfying again @xmath199 .",
    "then , also @xmath53 is an invariant of @xmath188 .    using the inv rule , assuming that the invariant @xmath199 has been guessed , it is possible to reduce the problem of verifying that a certain property is an invariant of the application , to several @xmath122-satisfiability problems .",
    "in fact , reasoning by contradiction we have that @xmath222 and @xmath223 hold iff the quantifier - free formulae @xmath224 are @xmath122-unsatisfiable , respectively , where the variables in @xmath139 are regarded as ( skolem ) constants .",
    "similarly , for a given @xmath198 , @xmath225 holds iff the ( universally ) quantified formula @xmath226 is @xmath122-unsatisfiable , where @xmath227 and @xmath139 are regarded again as ( skolem ) constants , for each @xmath228 .",
    "[ property : sat ] let @xmath229 be a state formula and @xmath230 be a transition formula .",
    "then , it is possible to effectively compute a formula of the form @xmath231 that is logically equivalent to the negation of @xmath232 and such that @xmath233 iff @xmath234    to be able to check that @xmath235 , we need to solve the @xmath122-satisfiability problem of ( universally ) quantified formulae .",
    "we now identify sufficient conditions on the background theory @xmath122 for this problem to be decidable .",
    "[ th : dec - soa - sat - univ ] let @xmath114 contain only ( countably many ) constant symbols ( i.e.  @xmath71 is the theory of an equivalence relation ) , @xmath236 be a consistent and stably - infinite theory with decidable satisfiability problem such that the signature of no function symbol in @xmath112 is of the kind @xmath237 ( for @xmath238 and @xmath99 ) and @xmath215 be a consistent bsr theory . then , the @xmath122-satisfiability problem is decidable for formulae of the form @xmath239 where @xmath216 and @xmath39 are ( finite ) sequences of variables and predicate symbols ( such that @xmath240 ) , respectively .",
    "as we have already said , there are many theories formalizing data structures ( such as @xmath218 ) relevant for modeling the wf of so applications , which are stably infinite .",
    "also , it is frequently the case that the data structures formalized by these theories use identifiers to create new pieces of information ( typical examples are the certificates of the identities or the roles of principals ) but do not create new identifiers . in this way , the requirement that functions in @xmath68 do not create identifiers ( syntactically , this is expressed by forbidding that the return type of the functions is not @xmath119 ) is frequently satisfied .",
    "we point out that this requirement is a sufficient condition to avoid the creation of new identifiers and it may be weakened .",
    "however , we leave the study of more general sufficient conditions to future work .    pragmatical aspects of invariant verification of so applications are discussed in  @xcite .    as before ,",
    "pragmatical aspects of invariant verification of so applications are discussed in appendix  [ sec : pragmatics - invariant ] , extending appendices  [ sec : pragmatics - modeling ] and  [ sec : pragmatics - executability ] .",
    "we conclude this section with the main technical result , which follows from the above properties and lemma .",
    "let @xmath114 contain only ( countably many ) constant symbols ( i.e.  @xmath71 is the theory of an equivalence relation ) , @xmath236 be a consistent and stably - infinite theory with decidable satisfiability problem such that the signature of no function symbol in @xmath112 is of the kind @xmath237 ( for @xmath238 and @xmath99 ) , and @xmath215 be a consistent bsr theory .",
    "let @xmath241 be a two - level so transition system with background theory @xmath242 , and @xmath243 be a state formula .",
    "it is decidable to check whether @xmath244 , provided there exists a state formula @xmath245 such that ( a ) @xmath246 , ( b ) @xmath247 , and ( c ) @xmath248 .    indeed , the usefulness of the theorem depends on the availability of the formula @xmath249 , which is called an _ inductive _ invariant since it is preserved under the application of the transitions of the two - level so transition system .",
    "since the problem of finding such a formula when @xmath41 is undecidable ( see , e.g. ,  @xcite ) , it is also undecidable in our case .",
    "however , several heuristics have been proposed ; see , e.g. ,  @xcite for a recent proposal and pointers to the literature .",
    "an interesting line of future work is to adapt these techniques to find invariants of so applications .",
    "note that it is possible to dispense with the computation of the auxiliary invariant whenever @xmath250 is already inductive ; in which case , conditions ( a ) and ( b ) of the theorem are trivially satisfied and we are only required to discharge proof obligation ( c ) .",
    "we have presented a two - level formal framework that allows us to specify and verify the interplay of authorization policies and workflow in so applications and architectures . in the previous sections",
    ", we already discussed relevant related works and also pointed out different research lines along which we are currently extending the techniques and results presented here .",
    "in particular , as we remarked , formal methods are being increasingly applied extensively to support the correct design of so applications .",
    "these works range from extending the workflow with access control aspects ( e.g. , @xcite ) to , vice versa , embedding the workflow within the access control system ( e.g. , @xcite ) , thus mainly focusing on one level at a time and abstracting away most or all of the possible interplay between the wf and pm levels .",
    "other works ( e.g. @xcite ) have in contrast proposed approaches that attempt to model and analyze the interplay .",
    "we believe that our framework is abstract enough to encompass such approaches and we are currently investigating how they can be recast in our framework .",
    "in particular , we plan to use our framework to model petri nets and access control policies as in  @xcite so as to perform deductive - based model checking of security - sensitive business processes , and also to formally analyze properties of rbac by adapting the framework of  @xcite .",
    "finally , we also plan to extend the framework as we presented it in this paper , e.g.  with interfaces more refined than the @xmath71 we considered here , so as to be able to perform modular reasoning in the assume - guarantee style .",
    "the work presented in this paper was partially supported by the fp7-ict-2007 - 1 project no .",
    "216471 ,  avantssar : automated validation of trust and security of service - oriented architectures \" and the prin07 project `` soft '' .",
    "we thank the members of the avantssar project for useful discussions .",
    "10 [ 1]#1 url@samestyle [ 2]#2 [ 2]l@#1=l@#1#2    a.  armando , s.  ranise , and m.  rusinowitch , `` a rewriting approach to satisfiability procedures , '' _ info . and comp .",
    "183 , no .  2 ,",
    "pp . 140164 , 2003 .",
    "a.  armando and s.  e. ponta , `` model checking of security - sensitive business processes , '' 2009 , submitted .",
    "avantssar , `` deliverable 5.1 : problem cases and their trust and security requirements , '' 2008 , available at http://www.avantssar.eu .",
    "p.  balbiani , y.  chevalier , and m.  el  houri , `` a logical approach to dynamic role - based access control , '' in _ aimsa08 _ ,",
    "lncs 5253.1em plus 0.5em minus 0.4emspringer - verlag , 2008 .",
    " , `` an attribute based framework to express dynamic evolution of services in a distributed environment , '' 2009 , submitted .",
    "m.  y. becker , c.  fournet , and a.  d. gordon , `` security policy assertion language ( secpal ) , '' http://research.microsoft.com / en - us / projects / secpal/.    e.  bertino , j.  crampton , and f.  paci , `` access control and authorization constraints for ws - bpel , '' in _ proceedings of icws06_.1em plus 0.5em minus 0.4emieee computer society , 2006 , pp .",
    "275284 .",
    "m.  p. bonacina , s.  ghilardi , e.  nicolini , s.  ranise , and d.  zucchelli , `` decidability and undecidability results for nelson - oppen and rewrite - based decision procedures , '' in _ ijcar06 _ , ser .",
    "lncs , vol .",
    "4130 , 2006 .",
    "e.  brger , e.  grdel , and y.  gurevich , _ the classical decision problem_.1em plus 0.5em minus 0.4emspringer - verlag , 1997 .",
    "m.  bozzano , r.  bruttomesso , a.  cimatti , t.  a. junttila , s.  ranise , p.  van rossum , and r.  sebastiani , `` efficient theory combination via boolean search , '' _ info . and comp .",
    "204 , no .",
    "14931525 , 2006 .",
    "a.  r. bradley and z.  manna , `` property - directed incremental invariant generation , '' _ formal aspects of computing _ , 2009 , to appear .",
    "chang and j.  h. keisler , _",
    "model theory_.1em plus 0.5em minus 0.4emnorth - holland , 1990 .",
    "j.  detreville , `` binder , a logic - based security language , '' in _ ieee symposium on security and privacy_.1em plus 0.5em minus 0.4em ieee computer society , 2002 .",
    "d.  j. dougherty , k.  fisler , and s.  krishnamurthi , `` specifying and reasoning about dynamic access - control policies , '' in _ ijcar06 _ , ser .",
    "lncs 4130.1em plus 0.5em minus",
    "0.4emspringer - verlag , 2006 , pp .",
    "632646 .",
    "s.  ghilardi , `` model theoretic methods in combined constraint satisfiability , '' _ journal of automated reasoning _ , vol .  33 , no . 3 - 4 , 2004 .",
    "y.  gurevich and i.  neeman , `` distributed - knowledge authorization language ( dkal ) , '' http://research.microsoft.com/~gurevich/dkal.htm .",
    "z.  manna and a.  pnueli , _ temporal verification of reactive systems : safety_.1em plus 0.5em minus 0.4emspringer - verlag , 1995 .",
    "j.  c.  m. ninghui  li , `` understanding spki / sdsi using first - order logic , '' _ int .",
    "journal of information security _ ,",
    "vol .  5 , no .  1 , pp .",
    "4864 , 2006 .",
    "f.  paci , e.  bertino , and j.  crampton , `` an access control framework for ws - bpel , '' _ int .",
    "j.  web service res .",
    "_ , vol .  5 , no .  3 , pp .",
    "2043 , 2008 .",
    "a.  schaad , k.  sohr , and m.  drouineaud , `` a workflow - based model - checking approach to inter- and intra - analysis of organisational controls in service - oriented business processes , '' _ journal of information assurance and security _ ,",
    "vol .  2 , no .  1 , 2007 .    r.  sebastiani , `` lazy satisfiability modulo theories , '' _ journal on satisfiability , boolean modeling and computation _ , vol .  3 , pp .",
    "141224 , 2007 .    c.  tinelli and c.  g. zarba , `` combining non - stably infinite theories , '' _ journal of automated reasoning _ , vol .",
    "34 , no .  3 , 2005 .",
    "n.  zhang , m.  d. ryan , and d.  guelev , `` evaluating access control policies through model checking , '' in _ isc05 _ , ser .",
    "lncs 3650.1em plus 0.5em minus 0.4emspringer - verlag , 2005 , pp . 446460 .",
    "we reason by contradiction and reduce validity to satisfiability . the validity ( modulo @xmath122 ) of formulae of the form ( [ eq : vc - val ] )",
    "is equivalent to the @xmath122-unsatisfiability of the negation of ( [ eq : vc - val ] ) , i.e. @xmath251 which , in turn , is equivalent to the @xmath122-unsatisfiability of @xmath252 after some simple logical manipulations , the problem reduces to checking the @xmath122-unsatisfiability of the following quantifier - free formula @xmath253 where @xmath227 are considered as skolem constants ( or , equivalently , as implicitly existentially quantified variables ) .",
    "now , to simplify our argument and make it easier to grasp , we use a little bit of higher - order logic and regard @xmath254 as @xmath255 . in this way , it is obvious that , after two simple substitutions , the last formula above becomes @xmath256 which is easily seen to be equisatisfiable to the previous one ( intuitively , it is always possible to find an assignment for the variables in @xmath152 when the last formula is satisfiable : just take the values of @xmath257 ; a similar observation holds for the predicate symbols in @xmath153 ) .",
    "now , we are left with the problem of checking whether the last formula is quantifier - free . to see this , recall that @xmath199 is quantifier - free and this implies that every occurrence of a predicate symbol in @xmath153 is applied to a tuple of ground terms .",
    "hence , the effect of substituting @xmath153 with @xmath258 is a tuple of quantifier - free formulae because of @xmath259-reduction .",
    "let @xmath260 ) be the result of exhaustively performing such @xmath259-reductions ; then , the formula @xmath261 is quantifier - free .",
    "this concludes the proof .",
    "we apply one of the results on non - disjoint combination of theories in  @xcite , namely the following : if ( i ) @xmath71 is a universal theory contained in both @xmath68 and @xmath69 , ( ii ) @xmath71 admits a model completion @xmath262 , ( iii ) every model of @xmath68 and @xmath69 embeds into a model of @xmath263 and of @xmath263 , respectively , and ( iv ) @xmath71 is effectively locally finite , then the @xmath264-satisfiability problem is decidable ( by an extension of the nelson - oppen combination schema ) .",
    "let us check each of the conditions ( i)(iv ) :    * this is satisfied by assumption .",
    "* by a well - known result in model - theory ( see , e.g. ,  @xcite ) , a theory @xmath72 admitting elimination of quantifiers also admits a model completion @xmath265 and furthermore @xmath266 .",
    "it is not difficult to check that @xmath71 admits elimination of quantifiers ( it is sufficient to note that @xmath267 is @xmath71-equivalent to @xmath268 for @xmath53 a quantifier - free formula and @xmath78 s the constants denoting the elements of the domain of the enumerated data type ) .",
    "hence , @xmath71 admits a model completion and @xmath269 . * since @xmath269 and , by assumption , @xmath270 and @xmath271 , we have that @xmath272 and , similarly , @xmath273 .",
    "this implies that every model of @xmath68 ( respectively , @xmath69 ) is also a model of @xmath263 ( respectively , @xmath263 ) , which implies that every model of @xmath68 ( respectively , @xmath69 ) can be embedded into a model of @xmath274 ( respectively , @xmath263 ) , just take identity as the embedding . between two @xmath1-structures @xmath275 and @xmath276",
    "is a mapping from @xmath277 to @xmath278 such that @xmath279 iff @xmath280 , for every @xmath281-atom @xmath282 .",
    "( in other words , an embedding between @xmath14 and @xmath283 is an isomorphism of @xmath14 onto a sub - structure of @xmath283 . )",
    "we say that @xmath14 is _ embeddable _ in @xmath283 if there exists an embedding between @xmath14 and @xmath283 .",
    "] * indeed , the signature of an enumerated data - type theory is finite and consists of a finite set of constants , say @xmath284 for some @xmath81 .",
    "the constants @xmath285 are the representatives since , for every term @xmath286 , @xmath287 for some @xmath185.-theory @xmath72 is _ locally finite _ if @xmath1 is finite and , for every set of constants @xmath288 , there are finitely many ground terms @xmath289 , called _ representatives _ , such that for every ground",
    "@xmath290 -term @xmath291 , we have @xmath292 for some @xmath185 . if the representatives are effectively computable from @xmath288 and @xmath293 is computable from @xmath291 , then @xmath72 is effectively locally finite .",
    "]    reason by refutation and expand the definition of the negation of @xmath294 , so as to obtain the following formula : @xmath295 this , in turn , is equivalent to @xmath296 then , by recalling the definition of @xmath198 and performing the obvious substitutions ( in a way similar to what we have done in the proof of property  [ prop : pre - comp - se ] above ) , we obtain : @xmath297 which , by exhaustively applying @xmath259-reduction and considering existentially quantified variables as skolem constants , is equivalent to @xmath298 where @xmath299 and @xmath300 are the result of @xmath259-reducing the corresponding formulae .",
    "it is not difficult to see that the last formula is a conjunction of a universally quantified formula @xmath301 with a quantifier - free formula @xmath302 and that it can not be simplified further or , in other words , that the universal quantifier on @xmath139 can not be removed .",
    "this concludes the proof .",
    "we claim that the quantifier - free formula @xmath303 is @xmath122-equisatisfiable to the universally quantified formula above , where @xmath10 ranges over all possible ground substitutions mapping the variables in @xmath139 to a finite subset of constant symbols in @xmath114 . if the @xmath122-satisfiability problem is decidable ( for quantifier - free ) formulae , then the proof is complete . to this end",
    ", we use the same combination result in  @xcite as that for lemma  [ th : dec - soa - sat ] , i.e.  if ( i ) @xmath71 is a universal theory contained in both @xmath68 and @xmath69 , ( ii ) @xmath71 admits a model completion @xmath262 , ( iii ) every model of @xmath68 and @xmath69 embeds into a model of @xmath263 and of @xmath263 , respectively , and ( iv ) @xmath71 is effectively locally finite , then the @xmath264-satisfiability problem is decidable ( by an extension of the nelson - oppen combination schema ) .",
    "let us check each of the conditions ( i)(iv ) :    * @xmath71 is the theory of an equivalence relation , which can be axiomatized by a finite set of universal sentences corresponding to reflexivity , symmetry , and transitivity .",
    "hence , @xmath71 is universal . *",
    "it is well - known that the model - completion @xmath262 of the theory of an equivalence relation is the theory of an infinite set ( see , e.g. ,  @xcite ) . *",
    "it is possible to show that this is equivalent to stably infiniteness ( again , see  @xcite ) which is an assumption for @xmath68 while it can be easily shown that any bsr theory is stably infinite ( see , e.g. ,  @xcite ) , hence @xmath69 is also so .",
    "* @xmath71 is the theory of an equivalence relation with finitely many equivalence classes .",
    "so , although there are infinitely ( more precisely , countably many ) constant symbols of sort @xmath119 , there exists a finite subset @xmath304 such that for any other constant symbol @xmath173 of sort @xmath119 , we have @xmath305 for some @xmath306 .",
    "this means that @xmath71 is an effectively locally finite theory .",
    "thus , we conclude that the @xmath122-satisfiability problem for quantifier - free formulae is decidable .    to conclude the proof , we are left with the problem of proving the claim above .",
    "to this end , first of all , recall that @xmath71 is effectively locally finite .",
    "then , observe that @xmath69 is a bsr theory and hence @xmath307 has no function symbol of arity greater than @xmath308 .",
    "furthermore , recall that , by assumption , all function symbols of arity greater than @xmath308 in @xmath112 are such that their return type is not @xmath119 .",
    "thus , we have that @xmath309 and @xmath310 , for every constant symbol of sort @xmath119 in @xmath114 and some @xmath311 .",
    "this is so because the reduct to @xmath114 of every @xmath307-model of @xmath69 and @xmath112-model of @xmath68 is a model of @xmath71 .",
    "so , if the quantifier - free formula @xmath303 is @xmath122-unsatisfiable , where @xmath10 is a ground substitution mapping the variables in @xmath139 to the computable finite subset @xmath312 of the constants in @xmath114 of sort @xmath119 , then the universally quantified formula @xmath239 is also unsatisfiable . for the converse ,",
    "it is sufficient to recall that @xmath71 is a universal theory and that universal theories are closed under sub - structures , i.e.  any sub - structure of a model of the theory is also a model .",
    "this implies that if the quantifier - free formula above is @xmath122-satisfiable , then the universally quantified - formula is also so .",
    "the techniques and results that we give in this paper are general and independent of particular concrete applications , but , to illustrate them concretely , it is useful to consider an example from industrial practice : we consider a simplified version of the car registration office case study described in  @xcite , which can be intuitively summarized as follows .    a _ citizen _ ,",
    "called charlie , submits a request to register his new car to an _ employee _ , called ed , of the local _ car registration office cro_. charlie s message contains all the documents to support his request and it is suitably signed . upon reception of the request ,",
    "ed has appropriate support for checking the signature of the document and comparing it with the identity of the sender of the request : if the signature and the identity of the requester do not match , then the request is immediately refused and the sender is acknowledged of this fact ; otherwise , ed starts to consider the content of the request for the car registration . if , according to some criteria ( that are abstracted away in the specification ) , the request is not suitably supported by the documents , then the request is refused and , again , the sender is acknowledged of this fact ; otherwise , the request is accepted , the sender is acknowledged of acceptance and the request is marked as accepted , signed by ed , and finally sent to the _ central repository crep _ to be archived .",
    "this process is completely transparent to charlie and , in order to be successfully completed , ed should have the right to store documents in the _ crep_. this right can only be granted by the _ head _ of the _ cro _ , a ( special ) employee called helen . upon reception of the request by ed to store a processed request in its internal database , the _ crep _ checks whether ed has been granted the right to do so .",
    "if this is the case , the _ crep _ stores the document ; otherwise , it refuses to comply .",
    "roles are assigned to employees ( of the _ cro _ ) by circulating appropriate certificates ; such as , e.g. , `` ed is an employee '' or `` helen is the head of the _ cro_. '' these certificates are emitted by a _ certification authority regoffca _",
    ", that is recognized by the employees of the _ cro _ and the _ crep_. permission to store documents in the _ crep _ are also distributed to employees by creating appropriate certificates ; however , these certificates are created by the head of the _ cro _ ( not by the certification authority ) .",
    "the _ crep _ , before storing a processed request in its internal database , checks whether the employee has the right to do so . for this",
    "to be successfully executed , the following policy should be enforced :    * an employee of the car registration office can store documents in the _ crep _ , if the head of the car registration office permits it ,    and the following trust relationships should have been preliminarily established :    * the _ regoffca _ is trusted by all employees , by the head of the car registration office , and the _ crep _ for what concerns role certificates ; and * the head of the car registration office is trusted by the _",
    "crep _ for action ( e.g. , storing documents ) certificates .",
    "finally , to be able to successfully execute the scenario with charlie and ed described above , the following certificates should be available in the system :    * ed is an employee of the car registration office ( by a certificate emitted by _ regoffca _ ) , * helen is the head of the car registration office ( by a certificate emitted by _ regoffca _ ) , and * helen permits ed to store documents in the _ crep _",
    "( by a certificate emitted by helen ) .",
    "since only the exchange of messages drives the workflow of the system and the most interesting part of the case study concerns its policies , we adopt the @xmath82 $ ] theory described in example [ ex : msg - pass ] . in the body of a message , documents ( such as car registration requests or processed requests )",
    "can be embedded ( @xmath313 ) . since",
    "both citizens and employees should be able to sign documents and the latter should also be able to check signatures , appropriate primitives are provided to generate signatures ( @xmath314 ) , attaching them to documents ( @xmath315 ) , and checking that the signature attached to a document belongs to a certain principal ( @xmath316 ) .",
    "an employee has also the primitive to attach a decision ( @xmath317 or @xmath318 ) to a document containing a citizen request ( @xmath319 ) .",
    "finally , as role certificates should be distributed over the network , we provide an appropriate primitive ( @xmath320 ) to create these documents .",
    "( role certificates are handled at the policy level only ; see below for more details . )",
    "now , we identify the theories involved :    * @xmath321 * @xmath322 $ ] , the theory described in the example [ ex : msg - pass ] above , * @xmath323 + @xmath324 , a set of horn rules defined below . are allowed . ]    as we have said above , the workflow of the system is almost state - less .",
    "there are however two exceptions .",
    "one is the database of the central repository which is modeled by the unary predicate @xmath325 to which documents may only be added ( and never deleted ) .",
    "the other is the unary predicate @xmath326 that allows us to abstract away the criteria according to which a citizen request is accepted or refused .",
    "this completes the description of the ( static part of the ) workflow .",
    "we now describe the policy level of the system .",
    "we adapted the dkal  @xcite approach to specifying policies in our framework .",
    "to this end , dkal provides predicates ( @xmath327 and @xmath328 ) to represent the knowledge of the various agents and predicates ( @xmath329 and @xmath330 ) for the _ communication _ between agents .",
    "it is important to observe the differences between the communication at the workflow and the policy levels of the system .",
    "the former ( modeled via the @xmath82 $ ] theory ) is state - full and thus modeled by an appropriate set of transitions ( see below ) .",
    "the latter ( modeled via @xmath329 or @xmath330 ) is state - less and thus modeled by suitable horn clauses . finally , dkal proposes two functions ( @xmath331 or @xmath332 ) to track trust relationships between agents concerning certain facts .",
    "all this is formally captured in the following set of horn clauses .",
    "first , we provide an ( incomplete ) characterization of the dkal - like predicates expressing knowledge and communication for policies ( this is adapted from  @xcite , to which the interested reader is pointed to for details ) .",
    "+ @xmath333 : internal knowledge is knowledge .",
    "@xmath334    @xmath335 : an agent knows whatever is said to him and he / she also knows whether the piece of knowledge being communicated is based on the internal knowledge of the speaker ( @xmath336 ) or not ( @xmath337 ) .",
    "@xmath338    @xmath339 : an agent @xmath340 knows a piece of information @xmath341 whenever an agent @xmath340 knows that another agent @xmath342 said the piece of information @xmath341 and also that @xmath340 knows that the agent @xmath342 is trusted on saying the piece of information @xmath341 .",
    "@xmath343    then , we consider the policies of each agent .",
    "the first three horn clauses specify the communication of ( role and action ) certificates at the policy level .",
    "( note that while the knowledge of an action certificate for @xmath155 is explicitly given in the initial state above , the knowledge of the role certificates for @xmath155 and @xmath156 will be lifted from the existence of the corresponding messages in the network by appropriate transitions . )",
    "the last three horn clauses are the formal counterparts of the trust relationships described above .",
    "+ * ( simple ) employee *    @xmath344    in the horn rules above , and also in some of the following ones , we use a prolog - like notation where the symbol @xmath345 is employed as an abbreviation for a universally quantified variable that occurs only once in the rule . + * ( head ) employee *    @xmath346    * central repository * +    @xmath347 ( centrreptrustca ) +    @xmath348    ( centrreptrustanyoneviaca )    @xmath349    finally , in fig .",
    "[ fig : transition ] , we give the transitions modeling the dynamics of the system .",
    "the first two transitions ( @xmath350 , @xmath351 ) , are part of the interface between the workflow and the policy levels of the system as they allow employees to convert the content of role certificates received from the network to ( internal ) knowledge , which is relevant for the application of policies ( compare the right - hand sides of these rules with the hypotheses of the horn clauses cert1 and cert2 ) .",
    "the following two transitions specify the processing of a citizen request by an employee ( @xmath352 ) , and how the central repository handles the request of an employee to store a document in its internal database ( @xmath353 ) .",
    "this is ( the remaining ) part of the interface between the workflow and the policy level : the guard    @xmath354    is a query that is possibly solved by the horn clauses above .",
    "@xmath350 : @xmath355 , i_2 ) , \\mathit{net } )           ~\\wedge \\           \\mathit{net } ' = \\mathit{net } ~ \\wedge \\\\                     \\forall p_1,p_2,r .",
    "\\mathsf{hasrole}'(p_1,p_2,r ) \\leftrightarrow              \\left (               \\begin{array}{l }                 \\mathit{if}~ ( p_2=i_1 \\wedge p_1=i_2 \\wedge r=\\mathtt{employee } ) \\\\",
    "\\mathit{then ~~ true } \\\\",
    "\\mathit{else } ~ \\mathsf{hasrole}(p_1,p_2,r )                \\end{array }              \\right )           \\end{array }         \\right )    \\end{aligned}\\ ] ] where , @xmath356 is a term symbol of type @xmath357 that contains a sub - term of interest that represent a role certificate .",
    "+ @xmath351 : @xmath358 , i_2 ) , \\mathit{net } )           ~\\wedge \\           \\mathit{net } ' = \\mathit{net } ~ \\wedge \\\\                     \\forall p_1,p_2,r .",
    "\\mathsf{hasrole}'(p_1,p_2,r ) \\leftrightarrow              \\left (               \\begin{array}{l }                 \\mathit{if}~ ( p_2=i_1 \\wedge p_1=i_2 \\wedge r=\\mathtt{head } ) \\\\",
    "\\mathit{then ~~ true } \\\\",
    "\\mathit{else } ~ \\mathsf{hasrole}(p_1,p_2,r )                \\end{array }              \\right )           \\end{array }         \\right )    \\end{aligned}\\ ] ] @xmath352 : @xmath359,\\mathtt{centrrep}),net ) ~ \\wedge \\\\           \\forall p_1,p_2,r .",
    "\\mathsf{hasrole}'(p_1,p_2,r ) \\leftrightarrow \\mathsf{hasrole}(p_1,p_2,r )           \\end{array }         \\right )    \\end{aligned}\\ ] ] @xmath353 : @xmath360 , \\mathtt{centrrep } ) , \\mathit{net } )            ~ \\wedge \\\\           \\mathsf{dbdoc}'=\\mathsf{dbdoc}(d ) ~ \\wedge \\\\           \\forall p_1,p_2,r .",
    "\\mathsf{hasrole}'(p_1,p_2,r ) \\leftrightarrow \\mathsf{hasrole}(p_1,p_2,r )           \\end{array }         \\right )    \\end{aligned}\\ ] ]      it is relatively easy to check that the scenario described above involving ed and helen can be executed by a suitable sequence of transitions and solving appropriate queries against the policies of the system .",
    "for instance , let us , for the sake of brevity , only analyze the first step , which requires the application of the transition @xmath350 to lead the two - level so transition system from the initial state to a state where the pm knowledge about the identity of ed has been acquired .",
    "the initial state @xmath35 is characterized by the following formula ,    @xmath361    saying that principals knows nothing about their respective roles and the net contains three messages : one is the car registration request of charlie and the other two are the role certificates of ed ( who is an employee ) and helen ( who is the head of the car registration office ) , where @xmath362 and @xmath363 abbreviate the terms @xmath364 and @xmath365 , respectively , @xmath366 @xmath367 , and @xmath368 .",
    "the transition @xmath350 is formalized as in fig .  [ fig : transition ] .",
    "the set of states to which the transition @xmath350 should lead the two - level so transition system must be so as to satisfy the following formula @xmath369 :    @xmath370    saying that @xmath155 has acquired the knowledge about its role at the pm level of the so application .",
    "it is not difficult to show the @xmath122-validity of @xmath371 .",
    "in fact , the transition is enabled since the following formula ( obtained by instantiating both @xmath372 and @xmath373 with the constant @xmath155 and substituting the state variable @xmath92 with the term at the right of the first equality in @xmath35 ) :    @xmath374    is @xmath122-satisfiable .",
    "we are left with the problem of showing the @xmath122-unsatisfiability of the formula :    @xmath375    obtained by negating @xmath369 .",
    "this can be easily done by observing that    @xmath376    holds in the state where the transition @xmath350 has lead the two - level so transition system as the result of executing the pm update .",
    "then , by instantiating the following horn rule ( in @xmath69 ) :    @xmath377    with @xmath372 and @xmath373 substituted with @xmath155 , it is possible to immediately detect unsatisfiability . in this way",
    ", we have proved the @xmath122-unsatisfiability of the formula @xmath378 or , equivalently , the @xmath122-validity of @xmath212 .",
    "we consider the following interesting property about documents stored in the central repository :    integrity : : :     any processed request @xmath379 stored in the    central repository must be consistent , i.e. , it should be double    signed ( by the citizen @xmath380 submitting the    request @xmath381 and by the employee    @xmath382 handling it ) and stamped with the seal of    acceptance .",
    "such a property can be written as the following safety formula in the extended version of ltl introduced above :    @xmath383    showing that the so application ensures integrity is non - trivial , as the central repository treats documents as black - boxes and trusts employees to check signatures and correctly prepare processed requests .",
    "furthermore , it trusts the head of the central repository to judge the capability of employees to perform this job correctly .",
    "ultimately , the central repository also trusts the certification authority to emit role certificates for both employees and the head of the car registration office . besides these difficulties , the state formula inside the `` always - in - the - future '' operator is not of the kind supported by the decidability result of lemma  [ th : dec - soa - sat - univ ] because of the existential quantifier . as a consequence",
    ", more ingenuity is required by the specifier .",
    "we are currently working to derive a hand proof of this property .",
    "we extend the technical results of section  [ sec : modelling ] with some observations on the pragmatics of modeling wf and pm of so applications .",
    "in fact , pragmatically , the theories @xmath68 and @xmath69 are obtained by extending the substrate theory @xmath71 as follows . for the wf theory ,",
    "consider a finite set @xmath384 of universal @xmath112-sentences where @xmath385 ; then @xmath386 the process of adding finitely many axioms to an available theory can be iterated several times to obtain the final wf theory . as an example , recall the theories @xmath83 and @xmath82 $ ] of examples  [ ex : msg - pass ] and  [ ex : so - appl ] .",
    "for the pm theory , along the lines of several other works in the pm literature ( e.g. ,  @xcite ) , regard a logic program @xmath387 ( formalizing policy statements ) as a set of universal horn @xmath307-clauses where @xmath388 for @xmath389 a ( finite ) set of predicate symbols such that @xmath390 ; will be usually abbreviated with @xmath391 with the implicit assumption that @xmath389 is disjoint from @xmath114 . ]",
    "then @xmath392 usually , the state predicates in @xmath393 are intensional , i.e.  occur in the head of the rules of @xmath387 .",
    "this is a sufficient condition to ensure that no transition may add a fact to the theory @xmath69 that gives rise to an inconsistency .    in the ( constraint ) logic programming literature ,",
    "@xmath71 is usually introduced as a certain first - order structure ( e.g. , the integers ) .",
    "this is not compatible with the notion of theory adopted here ( and in most logic textbooks ) as we work with sets of sentences ( axioms ) rather than structures .",
    "however , given a structure @xmath14 , it is possible to find a theory @xmath72 admitting @xmath14 as a model .",
    "so , if we are able to verify that @xmath394 , we also know that @xmath395 ( while the converse , in general , may not hold ) . as a consequence",
    ", if we are able to reduce a certain verification problem for an so application to showing that a formula follows from the background theory of the application and we succeed in doing this , we are entitled to conclude that the verification problem has a positive answer for any structure satisfying the axioms of the background theory .",
    "indeed , we may obtain false negatives , as there may exist formulae that are true in a particular model of a theory @xmath72 that are not logical consequences of @xmath72 .",
    "an advantage of adopting this notion of theory is the possibility of re - using and adapting existing automated reasoning techniques ( see below ) .",
    "recall our remark on how the theories @xmath68 and @xmath69 are formed by augmenting the theory @xmath71 with a finite set of universal axioms ( see end of  section  [ sec : modelling ] ) , i.e.@xmath396 where @xmath384 is a ( finite ) set of universal sentences and @xmath387 is a ( finite ) set of horn clauses .",
    "it is not difficult to argue that both the @xmath68- and @xmath69-satisfiability problems are decidable .",
    "the decidability of the former can be derived by the decidability of the @xmath218-satisfiability problem ( shown in  @xcite ) , the decidability of the satisfiability problem of any enumerated data - type theory ( since it admits elimination of quantifiers ) , and the combination results in  @xcite .",
    "it is possible to use available smt solvers ( such as yices , z3 , or mathsat ) to obtain a decision procedure for the @xmath68-satisfiability problem ( almost ) off - the - shelf ; maybe using characteristic functions for sets and then using arrays of booleans to formally represent such functions , see , e.g. ,  @xcite .",
    "the decidability of the @xmath69-satisfiability is an immediate consequence of the ( well - known ) decidability of the satisfiability problem for bsr theories .",
    "since @xmath71 is an enumerated data - type theory , the hypotheses of lemma  [ th : dec - soa - sat ] are satisfied and we are entitled to conclude the decidability of the @xmath122-satisfiability problem .",
    "again , it is possible to use available smt solvers , such as z3 , to have direct support for the class of bsr theories and hence to implement a decision procedure for the @xmath69-satisfiability problem .",
    "we are then left with the problem of modularly reusing the decision procedures for the satisfiability problem in the component theories to obtain a decision procedure for the @xmath122-satisfiability problem .",
    "when @xmath71 is an enumerated data - type theory , as it is the case of lemma  [ th : dec - soa - sat ] , it is possible to use the non - deterministic version of the combination algorithm in  @xcite to implement a decision procedure for the @xmath122-satisfiability problem . to understand this ,",
    "let us briefly summarize an adaptation of the non - deterministic combination schema of  @xcite . to this end , let w.l.o.g .",
    "@xmath397 be a conjunction of @xmath121-literals .- formula ,",
    "it is always possible to transform this into disjunctive normal form , i.e.  into a disjunction of conjunctions of literals .",
    "hence , being able to check the satisfiability of conjunctions of literals is sufficient to check the satisfiability of quantifier - free formulae . although , this is not efficient ( as the transformation to disjunctive normal form may yield an exponentially large formula ) , it is sufficient theoretically . ]",
    "first of all , we transform @xmath397 into an equisatisfiable conjunction @xmath398 by naming sub - terms by means of additional constants @xmath288 : this process is usually called _ purification _ and it can be implemented in polynomial time .",
    "as there are only finitely many constants @xmath399 in the enumerated data - type theory @xmath71 , we non - deterministically guess an _ arrangement _ @xmath400 , i.e.  a conjunction of literals such that , for each @xmath401 , either @xmath402 or @xmath403 , for each @xmath78 is in @xmath114 . then , we check whether both @xmath404 is @xmath68-satisfiable and @xmath405 is @xmath69-satisfiable .",
    "if , for some arrangement , both tests are successful , then we conclude the @xmath122-satisfiability of @xmath406 ( and hence of @xmath397 ) ; otherwise , if , for all arrangements , the tests are negative , then we are entitled to conclude the @xmath122-unsatisfiability of @xmath407 ( and hence of @xmath397 ) . since the number of arrangements is finite ( one can only generate finitely many distinct equalities or disequalities between two finite sets of constant symbols , namely @xmath288 and @xmath408 ) , the method terminates and thus yields a decision procedure for @xmath122 .",
    "there are two problems with the combination algorithm sketched above .",
    "first , it requires to transform quantifier - free formulae into disjunctive normal form .",
    "this is unacceptable for many practical problems .",
    "second , the algorithm is non - deterministic and we must refine it to obtain an implementation . to circumvent both of these problems , we sketch in fig .  [",
    "fig : smt - based - dec - proc - soa ] an algorithm that can be easily implemented on top of ( most ) smt solvers and is inspired by the delayed theory combination method of  @xcite .    foo = foo = * function * @xmath409 + 1 @xmath410 + 2 @xmath411 + 3 * while * ` bool - sat`@xmath412 * do * + 4 @xmath413 + 5 @xmath414 + 6 @xmath415 + 7",
    "* if * @xmath416 * then return * @xmath417 + 8 * if * @xmath418 * then * @xmath419 + 9 * if * @xmath420 * then * @xmath421 + 10 * end while * + 11 * return * @xmath422 + 12 * end function *    the algorithm in fig .",
    "[ fig : smt - based - dec - proc - soa ] is an abstraction of the so - called lazy smt solvers . before entering the main loop , the input quantifier - free formula @xmath53 is purified into the formula @xmath208 ; the function @xmath423 also returns the set @xmath288 of constants used for purification .",
    "then , the set @xmath424 of atoms is formed : it is the union of the atoms occurring in the purified formula @xmath208 and all possible equalities between the constants in @xmath288 and the constants in @xmath192 ( coming the underlying enumerated data - type theory @xmath71 ) as computed by the function @xmath425 .",
    "the idea underlying the main loop of the algorithm is the following .",
    "theory solver _ for @xmath72 is any procedure capable of establishing whether any given finite conjunction of @xmath1-literals is @xmath72-satisfiable or not .",
    "the _ lazy approach _ to build smt solvers consists of integrating a dpll boolean enumerator with a theory solver ( see , e.g. ,  @xcite for details ) . given a quantifier - free formula @xmath208 , one checks if it satisfiable by considering its atoms as boolean variables ( cf .  `",
    "bool - sat ` at line 3 ) .",
    "if it is not the case , then we exit the main loop and return unsatisfiability of the input quantifier - free formula ( cf .  line 11 )",
    "otherwise , we enter the main loop and we consider a satisfying boolean assignment , i.e.  a set of literals that makes @xmath208 true when atoms are considered as boolean variables ( cf .",
    "@xmath426 , line 4 ) .",
    "note that a boolean assignment consists not only of the atoms in @xmath208 ( cf .",
    "@xmath427 at line 2 ) but also of all possible equalities between the constants in @xmath288 and the constants in @xmath192 ( cf .",
    "@xmath425 at line 2 ) . in this way",
    ", we are guaranteed to consider all possible arrangements as defined by the non - deterministic algorithm sketched above .",
    "then , we check  separately ",
    "the @xmath428-satisfiability of the conjunction of @xmath429-literals @xmath430 ( cf .",
    "lines 5 and 6 ) : the @xmath431 procedure besides returning @xmath417 or @xmath422 also returns a conjunction @xmath432 ( called the conflict set ) of @xmath429-literals , all of which also occur in @xmath430 , which is @xmath428-unsatisfiable ( for @xmath433 ) .",
    "if both satisfiability checks are positive , then we return the satisfiability of the input quantifier - free formula ( cf .  line 7 ) .",
    "otherwise , i.e.  if at least one of the satisfiability checks returned ` unsat ` , the negation of @xmath432 , called a _ conflict clause _ , is added to @xmath208 ( cf.line 8 or 9 ) so as to reduce the number of boolean assignments that are to be considered in the main loop .",
    "this is one of the key ingredients ( among many others , see , e.g. ,  @xcite , for more details ) of the success of current state - of - the - art smt solvers and it avoids the burden of transforming quantifier - free formulae to disjunctive normal form , although the problem indeed is np - hard .",
    "let @xmath71 be an enumerated data - type theory , and @xmath214 and @xmath215 be consistent theories with @xmath68`-sat ` and @xmath69`-sat ` as decision procedures for their corresponding satisfiability problems .",
    "then , the function @xmath122`-sat ` ( depicted in fig .",
    "[ fig : smt - based - dec - proc - soa ] ) is a decision procedure for the @xmath122-satisfiability problem .      here",
    "the basis to implement an algorithm for the @xmath122-satisfiability check of quantifier - free formulae is almost the same as the function depicted in fig .",
    "[ fig : smt - based - dec - proc - soa ] .",
    "the main difference is in the definition of arrangement .",
    "in fact , we say that @xmath434 is an arrangement for the theory @xmath71 of an equivalence relation over the set @xmath288 of finite constants of sort @xmath119 if , for every pair @xmath435 for @xmath436 , either @xmath437 or @xmath438 . to implement this definition of arrangement , it is sufficient to replace line @xmath439 of the function in fig .",
    "[ fig : smt - based - dec - proc - soa ] with the following one : @xmath440 let @xmath122-`qfsat ` be the new function so obtained ; its correctness is a corollary of lemma  [ th : dec - soa - sat - univ ] above .",
    "furthermore , following the proof of lemma  [ th : dec - soa - sat - univ ] , it is sufficient to generate finitely many instances of a universally quantified formula of the form @xmath441 to obtain a decision procedure for such a class of formulae .",
    "indeed , the challenge here is to efficiently integrate the function @xmath122-`qfsat ` and an instantiation strategy for the universally quantified variables in @xmath139 .",
    "this requires some heuristics to filter out instances that are unlikely to contribute to detecting the unsatisfiability of the formula . to understand why heuristics are needed ,",
    "consider that the number of the possible ground substitutions @xmath10 is @xmath442 where @xmath443 is the length of @xmath288 and @xmath444 is the length of @xmath139 . another key ingredient to scale up is to invoke @xmath122-`qfsat ` incrementally so as to add one by one the instances of @xmath53 . since tuning these heuristics and making them work smoothly together require extensive experimental evaluation , we leave the details for future work ."
  ],
  "abstract_text": [
    "<S> a widespread design approach in distributed applications based on the service - oriented paradigm , such as web - services , consists of clearly separating the enforcement of authorization policies and the workflow of the applications , so that the interplay between the policy level and the workflow level is abstracted away . </S>",
    "<S> while such an approach is attractive because it is quite simple and permits one to reason about crucial properties of the policies under consideration , it does not provide the right level of abstraction to specify and reason about the way the workflow may interfere with the policies , and vice versa .    </S>",
    "<S> for example , the creation of a certificate as a side effect of a workflow operation may enable a policy rule to fire and grant access to a certain resource ; without executing the operation , the policy rule should remain inactive . similarly , policy queries may be used as guards for workflow transitions .    in this paper </S>",
    "<S> , we present a two - level formal verification framework to overcome these problems and formally reason about the interplay of authorization policies and workflow in service - oriented architectures . </S>",
    "<S> this allows us to define and investigate some verification problems for so applications and give sufficient conditions for their decidability . </S>"
  ]
}