{
  "article_text": [
    "if probabilities are known , optimal lossless source coding of individual symbols ( and blocks of symbols ) is usually done using david huffman s famous algorithm@xcite .",
    "there are , however , cases that this algorithm does not solve . problems with an infinite number of possible inputs  e.g. , geometrically - distributed variables  are not covered .",
    "also , in some instances , the optimality criterion  or _ _ penalty  is not the linear penalty of expected length .",
    "both variants of the problem have been considered in the literature , but not simultaneously .",
    "this paper discusses cases which are both infinite and nonlinear .",
    "an infinite - alphabet source emits symbols drawn from the alphabet @xmath9 .",
    "( more generally , we use @xmath10 to denote an input alphabet whether infinite or finite . )",
    "let @xmath11 be the sequence of probabilities for each symbol , so that the probability of symbol @xmath5 is @xmath12 .",
    "the source symbols are coded into binary codewords .",
    "the codeword @xmath13 in code @xmath14 , corresponding to input symbol  @xmath5 , has length @xmath4 , thus defining length distribution  @xmath15 .",
    "such codes are called _ _ integer codes ( as in , e.g. , @xcite ) .",
    "perhaps the most well - known integer codes are the codes derived by golomb for geometric distributions@xcite , and many other types of integer codes have been considered by others@xcite .",
    "there are many reasons for using such integer codes rather than codes for finite alphabets , such as huffman codes .",
    "the most obvious use is for cases with no upper bound  or at least no known upper bound  on the number of possible items . in addition , for many cases it is far easier to come up with a general code for integers rather than a huffman code for a large but finite number of inputs .",
    "similarly , it is often faster to encode and decode using such well - structured codes . for these reasons , integer codes and variants of them",
    "are widely used in image and video compression standards@xcite , as well as for compressing text , audio , and numerical data .    to date , the literature on integer codes has considered only finding efficient uniquely decipherable codes with respect to minimizing expected codeword length @xmath16 .",
    "other utility functions , however , have been considered for finite - alphabet codes .",
    "campbell  @xcite introduced a problem in which the penalty to minimize , given some continuous ( strictly ) monotonic increasing _",
    "_ cost function @xmath17 , is @xmath18 and specifically considered the exponential subcases with exponent @xmath8 : @xmath19 that is , @xmath20 .",
    "note that minimizing penalty @xmath21 is also an interesting problem for @xmath22 and approaches the standard penalty @xmath16 for @xmath23@xcite . while @xmath24 decreases for @xmath7",
    ", one can map decreasing @xmath25 to a corresponding increasing function @xmath26 ( e.g. , for @xmath27 ) without changing the penalty value .",
    "thus this problem , equivalent to maximizing @xmath28 , is a subset of those considered by campbell .",
    "all penalties of the form ( [ expcost ] ) are called @xmath2-exponential means , where @xmath29@xcite .",
    "campbell noted certain properties for @xmath2-exponential means , but did not consider applications for these means .",
    "applications were later found for the problem with @xmath8 @xcite ; these applications all relate to a buffer overflow problem discussed in section  [ application ] .    here",
    "we introduce a novel application for problems of the form @xmath7 .",
    "consider a situation related by alfred rnyi , an ancient scenario in which a rebel fortress was besieged by romans .",
    "the rebels only hope was the knowledge gathered by a mute , illiterate spy , one who could only nod and shake his head @xcite .",
    "this apocryphal tale  based upon a historical siege  is the premise behind the hungarian version of the spoken parlor game twenty questions .",
    "a modern parallel in the 21^st^ century occurred when russian forces gained the knowledge needed to defeat hostage - takers by asking hostages `` yes '' or `` no '' questions over mobile phones@xcite .",
    "rnyi presented this problem in narrative form in order to motivate the relation between shannon entropy and binary prefix coding .",
    "note however that twenty questions , traditional prefix coding , and the siege scenario actually have three different objectives . in twenty questions ,",
    "the goal is to be able to determine the symbol ( i.e. , the item or message ) by asking at most twenty questions . in prefix coding ,",
    "the goal is to minimize the expected number of questions  or , equivalently , bits  necessary to determine the message .",
    "for the siege scenario , the goal is survival ; that is , assuming partial information is not useful , the besieged would wish to maximize the probability that the message is successfully transmitted within a certain window of opportunity .",
    "when this window closes  e.g. , when the fortress falls  the information becomes worthless .",
    "an analogous situation occurs when a wireless device is losing power or is temporarily within range of a base station ; one can safely assume that the channel , when available , will transmit at the lowest ( constant ) bitrate , and will be lost after a nondeterministic time period .",
    "assume that the duration of the window of opportunity is independent of the communicated message and is memoryless , the latter being a common assumption  due to both its accuracy and expedience  of such stochastic phenomena .",
    "memorylessness implies that the window duration is distributed exponentially .",
    "therefore , quantizing time in terms of the number of bits @xmath30 that we can send within our window , @xmath31 with known positive parameter @xmath7 .",
    "we then wish to maximize the probability of success , i.e. , the probability that the message length does not exceed the quantized window length : @xmath32 & = & \\sum_{t=0}^\\infty \\p(t = t ) \\cdot \\p[\\len(x ) \\leq t ] \\\\ & = & \\sum_{t=0}^\\infty ( 1-a)a^t \\cdot \\sum_{i \\in \\x } p(i ) 1_{\\len(i ) \\leq t } \\\\ & = & \\sum_{i \\in \\x } p(i ) \\cdot ( 1-a ) \\sum_{t=\\len(i)}^\\infty a^t \\\\ & = & \\sum_{i \\in \\x } p(i ) a^{\\len(i ) } \\cdot ( 1-a ) \\sum_{t=0}^\\infty a^t \\\\ & = & \\sum_{i \\in \\x } p(i ) a^{\\len(i)}\\end{aligned}\\ ] ] where @xmath33 is @xmath34 if @xmath35 , @xmath36 otherwise . minimizing ( [ expcost ] ) is an equivalent objective .",
    "note that this problem can be constrained or otherwise modified for the application in question .",
    "for example , in some cases , we might need some extra time to send the first bit , or , alternatively , the window of opportunity might be of at least a certain duration , increasing or reducing the probability that no bits can be sent , respectively .",
    "thus we might have @xmath37 for some  @xmath38 . in this case ,",
    "@xmath39 = \\frac{(1-t_0)}{a } \\sum_{i \\in \\x } p(i ) a^{\\len(i)}\\ ] ] and the maximizing code is identical to that of the more straightforward case . likewise ,",
    "if we need to send multiple messages , the same code maximizes the expected number of independent messages we can send within the window , due to the memoryless property .",
    "we must be careful regarding the meaning of an `` optimal code '' when there are an infinite number of possible codes under consideration .",
    "one might ask whether there must exist an optimal code or if there can be an infinite sequence of codes of decreasing penalty without any code achieving the limit penalty value .",
    "fortunately the answer is the former , the proof being a special case of theorem  2 in  @xcite ( a generalization of the result for the expected - length penalty@xcite ) .",
    "the question is then how to find one of these optimal source codes given parameter @xmath6 and probability measure  @xmath1 .    as in the linear case ,",
    "a general solution for ( [ expcost ] ) is not known for general @xmath1 over a countably infinite number of events , but methods and properties for finite numbers of events  discussed in the next section  can be used to find optimal codes for certain common infinite - item distributions . in section  [ geometric ] , we consider geometric distributions and find that golomb codes are optimal , although the optimal golomb code for a given probability mass function varies according to @xmath6 .",
    "the main result of section  [ geometric ] is that , for @xmath40 and @xmath41 , g@xmath42 , the golomb code with parameter @xmath42 , is optimal , where @xmath43 in section  [ other ] , we consider distributions that are relatively light - tailed , that is , that decline faster than certain geometric distributions . if there is a nonnegative integer @xmath44 such that for all @xmath45 and @xmath46 , @xmath47 then an optimal binary prefix code tree exists which consists of a unary code tree appended to a leaf of a finite code tree . a specific case of this is the poisson distribution , @xmath48 , where @xmath49 is the base of the natural logarithm ( @xmath50 ) .",
    "we show that in this case the aforementioned @xmath44 is given by @xmath51 .",
    "an application , that of minimizing probability of buffer overflow , as in  @xcite , is considered in section  [ application ] , where we show that the algorithm developed in @xcite readily extends to coding geometric and light - tailed distributions .",
    "section  [ nonexp ] discusses the maximum pointwise redundancy penalty , which has a similar solution for light - tailed distributions and for which the golomb code g@xmath42 with @xmath52 is optimal for with geometric distributions .",
    "we conclude with some remarks on possible extensions to this work .    throughout the following ,",
    "a set or sequence of items @xmath53 is represented by its uppercase counterpart , @xmath54 .",
    "a glossary of terms is given in appendix  [ glossary ] .",
    "if a finite number of events comprise @xmath1 ( i.e. , @xmath55 ) , the exponential penalty ( [ expcost ] ) is minimized using an algorithm found independently by hu _",
    "et al . _",
    "@xcite , parker @xcite , and humblet @xcite,@xcite , although only the last of these considered @xmath56 .",
    "( the simultaneity of these lines of research was likely due to the appearance of the first paper on adapting the huffman algorithm to a nonlinear penalty , @xmath57 for given @xmath58 , in 1976@xcite . )",
    "we will use this finite - alphabet exponential - penalty algorithm in the sections that follow in order to prove optimally for infinite distributions , so let us reproduce the algorithm here :    * procedure for exponential huffman coding ( finite alphabets ) : * this procedure finds the optimal code whether @xmath8 ( a minimization of the average of a growing exponential ) or @xmath7 ( a maximization of the average of a decaying exponential ) . note that it minimizes ( [ expcost ] ) , even if the `` probabilities '' do not add to @xmath34 .",
    "we refer to such arbitrary positive inputs as _",
    "_ weights , denoted by @xmath59 instead of  @xmath60 :    1 .",
    "each item @xmath5 has weight @xmath61 , where @xmath10 is the ( finite ) alphabet and @xmath62 is the set of all such weights .",
    "assume each item @xmath5 has codeword @xmath63 , to be determined later .",
    "2 .   combine the items with the two smallest weights @xmath64 and @xmath65 into one compound item with the combined weight @xmath66 .",
    "this item has codeword @xmath67 , to be determined later , while item @xmath68 is assigned codeword @xmath69 and @xmath70 codeword @xmath71 .",
    "since these have been assigned in terms of @xmath67 , replace @xmath64 and @xmath65 with @xmath72 in @xmath73 to form @xmath74 .",
    "repeat procedure , now with the remaining codewords ( reduced in number by @xmath34 ) and corresponding weights , until only one item is left .",
    "the weight of this item is @xmath75 .",
    "all codewords are now defined by assigning the null string to this trivial item .",
    "this algorithm assigns a weight to each node of the resulting implied code tree by having each item represented by a node with its parent representing the items combined into its subtree , as in fig .",
    "[ buildgolo ] : if a node is a leaf , its weight is given by the associated probability ; otherwise its weight is defined recursively as @xmath6 times the sum of its children .",
    "this concept is useful in visualizing both the coding procedure and its output .",
    "van leeuwen implemented the huffman algorithm in linear time ( to input size ) given sorted weights in @xcite , and this implementation was extended to the exponential problem in @xcite as follows :    * two - queue implementation of exponential huffman coding : * the two - queue method of implementing the huffman algorithm puts nodes / items in two queues , the first of which is initialized with the input items ( eventual leaf nodes ) arranged from head to tail in order of nondecreasing weight , and the second of which is initially empty . at any given step ,",
    "a node with lowest weight among all nodes in both queues is at the head of one of the two queues , and thus two lowest - weighted nodes can be combined in constant time .",
    "this compound node is then inserted into ( the tail of ) the second queue , and the algorithm progresses until only one node is left .",
    "this node is the root of the coding tree and is obtained in linear time .",
    "the presentation of the algorithm in @xcite did not include a formal proof , so we find it useful to present one here :    the two - queue method using the exponential combining rule results in an optimal exponential huffman code given a finite number of input items .",
    "[ twoqueue ]    the method is clearly a valid implementation of the exponential huffman algorithm so long as both queues sets of nodes remain in nondecreasing order .",
    "this is clearly satisfied prior to the first combination step .",
    "here we show that , if nodes are in order at all points prior to a given combination step , they must be in order at the end of that step as well , inductively proving the correctness of the algorithm .",
    "it is obvious that order is preserved in the single - item queue , since nodes are only removed from it , not added to it . in the compound - node queue , order is only a concern if there is already at least one node in it at the beginning of this step , a step that combines nodes we call node @xmath76 and node @xmath77 .",
    "if so , the item at the tail of the compound - node queue at the beginning of the step was two separate items , @xmath78 and @xmath79 , at the beginning of the prior step . at the beginning of this prior step ,",
    "all four items must have been distinct  i.e. , corresponding to distinct sets of ( possibly combined ) leaf nodes  and , because the algorithm chooses the smallest two nodes to combine , neither @xmath78 nor @xmath79 can have a greater weight than either @xmath76 or @xmath77 . thus  since @xmath80 and the node with weight @xmath81 is the compound node with the largest weight in the compound - node queue at the beginning of the step in question  the queues remain properly ordered at the end of the step in question .    if @xmath82 , the compound - node queue will never have more than one item . at each step after the first , the sole compound item will be removed from its queue since it has a weight less than the maximum weight of each of the two nodes combined to create it , which in turn is no greater than the weight of any node in the single - item queue .",
    "it is replaced by the new ( sole ) compound item .",
    "this extends to @xmath83 if we prefer to merge combined nodes over single items of the same weight .",
    "thus , any finite input distribution can be optimally coded for @xmath84 using a _ _ truncated unary code , a truncated version of the _ _ unary code , the latter of which has codewords of the form @xmath85 .",
    "the truncated unary code has identical codewords as the unary code except for the longest codeword , which is of the form @xmath86 .",
    "this results from each compound node being formed using at least one single item ( leaf ) .",
    "taking limits , informally speaking , results in a unary limit code .",
    "formally , this is a straightforward corollary of theorem  [ tailthm ] in section  [ other ] .    if @xmath87 , a code with finite penalty exists if and only if rnyi entropy of order @xmath88 is finite , as shown in @xcite .",
    "it was campbell who first noted the connection between the optimal code s penalty , @xmath89 , and rnyi entropy @xmath90 this relationship is @xmath91 which should not be surprising given the similar relationship between huffman - optimal codes and shannon entropy@xcite , which corresponds to @xmath23 ( @xmath92)@xcite ; due to this correspondence , shannon entropy is sometimes expressed as @xmath93 .",
    "consider the geometric distribution @xmath94 for parameter @xmath95 .",
    "this distribution arises in run - length coding among other circumstances@xcite .    for the traditional linear penalty , a golomb code with parameter  @xmath42  or g@xmath42  is optimal for @xmath96 .",
    "such a code consists of a unary prefix followed by a binary suffix , the latter taking one of @xmath42 possible values .",
    "if @xmath42 is a power of two , all binary suffix possibilities have the same length ; otherwise , their lengths @xmath97 differ by at most @xmath34 and @xmath98 .",
    "binary codes such as these suffix codes are called _ _ complete codes .",
    "this defines the golomb code ; for example , the golomb code for @xmath99 is :    @xmath100    where the space in the code separates the unary prefix from the complete suffix . in general ,",
    "codeword @xmath68 for g@xmath42 is of the form @xmath101 , where @xmath102 is a complete binary code for the @xmath103th of @xmath42 items .",
    "it turns out that such codes are optimal for the exponential penalty :    for @xmath41 , if @xmath104 for @xmath105 , then the golomb code g@xmath42 is the optimal code for @xmath106 .",
    "if no such @xmath42 exists , the unary code g@xmath34 is optimal .",
    "[ optgeo ]    _ remark : _ this rule for finding an optimal golomb g@xmath42 code is equivalent to @xmath107 this is a generalization of the traditional linear result , which corresponds to @xmath23",
    ". cases in which the left inequality is an equality have multiple solutions , as with linear coding ; see , e.g. , @xcite .",
    "the proof of the optimality of the golomb code for exponential penalties is somewhat similar to that of @xcite , although it must be significantly modified due to the nonlinearity involved .    before proving theorem  [ optgeo ] ,",
    "we need the following lemma :    consider a huffman combining procedure , such as the exponential huffman coding procedure , implemented using the two - queue method presented in the previous section just prior to lemma  [ twoqueue ] . now",
    "consider a step at which the first ( single - item ) queue is empty , so that remaining are only compound items , that is , items representing internal nodes rather than leaves in the final huffman coding tree .",
    "then , in this final tree , the nodes corresponding to these compound items will be on levels differing by at most one ; that is , the nodes will form a complete tree . furthermore , if @xmath108 is the number of items remaining at this point , all items that finish at level @xmath109 appear closer to the head of the ( second , nonempty ) queue than any item at level @xmath110 ( if any ) .",
    "[ thelemma ]    we use an inductive proof , in which the base cases of one and two compound items ( i.e. , internal nodes ) are trivial .",
    "suppose the lemma is true for every case with @xmath111 items for @xmath112 , that is , that all nodes are at levels @xmath113 or @xmath114 , with the latter items closer to the head of the queue than the former .",
    "consider now a case with @xmath108 nodes .",
    "the first step of coding is to merge two nodes , resulting in a combined item that is placed at the end of the combined - item queue .",
    "because it is at the end of the queue in the reduced problem of size @xmath111 , this combined node is at level @xmath113 in the final tree , and its children are at level @xmath115 . if @xmath108 is a power of two , the remaining items end up on level @xmath116 , satisfying this lemma . if @xmath111 is a power of two , they end up on level @xmath117 , also satisfying the lemma",
    "otherwise , there is at least one item ending up at level @xmath118 near the head of the queue , followed by the remaining items , which end up at level @xmath119 . in any case",
    ", the lemma is satisfied for @xmath108 items , and thus , inductively , for any number of items .",
    "this lemma applies to any problem in which a two - queue huffman algorithm provides an optimal solution , including the original huffman problem and the tree - height problem of @xcite .",
    "here we apply the lemma to the exponential huffman algorithm to prove theorem  [ optgeo ] :    we start with an optimal exponential huffman code for a sequence of similar finite weight distributions .",
    "these finite weight distributions , called _",
    "_ @xmath120-reduced geometric sources @xmath121 , are defined as : @xmath122 where @xmath42 is as given in the statement of the theorem , or @xmath34 if no such @xmath42 exists .",
    "weights @xmath123 through @xmath124 are decreasing , as are @xmath125 through @xmath126 .",
    "thus we can combine the nodes with weights @xmath127 and @xmath126 if @xmath128 and @xmath129 these conditions are equivalent to the left and right sides , respectively , of ( [ ineq ] ) .",
    "thus the combined item is @xmath130 and the code is reduced to the @xmath131 case .",
    "after merging the two smallest weights for @xmath132 , the reduced source is @xmath133 for @xmath134 ( including all instances of the degenerate @xmath84 case and all instances in which ( [ ineq ] ) can not be satisfied ) , this proves that the optimal tree is the truncated unary tree .",
    "considering now only @xmath135 for @xmath136 , the two - queue algorithm assures that , when the problem is reduced to weights @xmath137 , all corresponding nodes are in the combined - item queue .",
    "lemma  [ thelemma ] thus proves that these nodes form a complete code .",
    "the overall optimal tree for any @xmath120-reduced code with @xmath138 is then a truncated golomb tree , as pictorially represented in fig .",
    "[ buildgolo ] , where @xmath139 and @xmath140 .",
    "note that @xmath141 is the number of leaves in common with what we call the `` golomb tree , '' the tree we show to be optimal for the original geometric source .",
    "the number of remaining leaves in the truncated tree is  @xmath42 , which is thus the number of distinct unary subtrees in the golomb tree .",
    "[ buildgolo ] represents both the truncated and full golomb trees , along with how to merge the weights .",
    "squares represent items to code , while circles represent other nodes of the tree .",
    "smaller weights are below larger ones , so that items are merged as pictured .",
    "rounded squares are items @xmath141 through @xmath142 , the items which are replaced in the golomb tree by unary subtrees , that is , subtrees representing the unary code .",
    "other squares are items @xmath36 through @xmath120 , those corresponding to single items in the integer code .",
    "white circles are the leaves used for the complete tree .",
    "it is equivalent to follow the complete portion of the code with the unary portion  as in the exponential huffman tree in fig .",
    "[ buildgolo ]  or to reorder the bits and follow the unary portion with the complete portion  as in the golomb code@xcite .",
    "the latter is more often used in practice and has the advantage of being alphabetic , that is , @xmath143 if and only if @xmath63 is lexicographically after @xmath144 .",
    "the truncated golomb tree for any @xmath138 represents a code that has the same penalty for the @xmath120-reduced distribution as does the golomb code with the corresponding geometric distribution .",
    "we now show that this is the minimum penalty for any code with this geometric distribution .",
    "let @xmath145 ( or @xmath146 if there is no ambiguity ) be codeword lengths that minimize the penalty for the geometric distribution ( which , as we noted , exist as shown in theorem  2 of  @xcite ) .",
    "let @xmath147 be codeword lengths for the @xmath120-reduced distribution found earlier ; that is , @xmath148 is the golomb length for @xmath149 and @xmath150 for the remaining values .",
    "finally , let @xmath151 be the lengths of the code implied by @xmath152 , that is , the lengths of the golomb code g@xmath42 .",
    "then @xmath153 where the inequalities are due to the optimality of the respective codes and the facts that @xmath154 for @xmath149 and @xmath155 for @xmath156 $ ] .",
    "the difference between the exponent of the first and the last of the expressions in ( [ fininf ] ) is @xmath157 as @xmath152 for @xmath138 , the sums on the right - hand side approach  @xmath36 ; the first is the difference between a limit ( an infinite sum ) and its approaching sequence of finite sums , all upper bounded in  ( [ fininf ] ) , and each of the terms in the second summation is upper - bounded by a multiplicative constant of the corresponding term in the first .",
    "( in the latter finite summation , terms are @xmath36 for @xmath158 . )",
    "their difference therefore also approaches zero , so the summations on the left - hand side approach equality , as do those in ( [ fininf ] ) , and the golomb code must be optimal .",
    "it is equivalent for the bits of the unary portion to be complemented , that is , to use @xmath159 ( as in @xcite ) instead of @xmath101 ( as in @xcite ) .",
    "it is also worth noting that golomb originally proposed his code in the context of a spy reporting run lengths ; this is similar to rnyi s context for communications , related in section  [ intro ] as a motivation for the nonlinear penalty with @xmath7 .",
    "a little algebra reveals that , for a distribution @xmath106 and a golomb code with parameter @xmath42 ( lengths @xmath160 ) , @xmath161 where @xmath162 and @xmath163 .",
    "therefore , theorem  [ optgeo ] provides the @xmath42 that minimizes ( [ geosum ] ) . if @xmath87 , the corresponding rnyi entropy is @xmath164 where we recall that @xmath165 .",
    "( again , @xmath84 is degenerate , an optimal code being unary with no corresponding rnyi entropy . )    in evaluating the effectiveness of the optimal code , one might use the following definition of _ _ average pointwise redundancy ( or just _ _ redundancy ) : @xmath166 for nondegenerate values , we can plot the @xmath167 obtained from the minimization .",
    "this is done for @xmath8 and @xmath7 in fig .",
    "note that as @xmath23 , the plot approaches the redundancy plot for the linear case , e.g. , @xcite , reproduced as fig .",
    "[ shannon ] .    in many potential applications of nonlinear penalties  such as the aforementioned for @xmath8@xcite and @xmath7 ( section  [ intro ] )",
    " @xmath6 is very close to  @xmath34 . since the preceding analysis shows that the golomb code that is optimal for given @xmath6 and @xmath168 is optimal not only for these particular values , but for a range of @xmath6 ( fixing @xmath168 ) and a range of @xmath168 ( fixing @xmath6 ) , the golomb code for the traditional linear penalty is , in some sense , much more robust and general than previously appreciated .",
    "abrahams noted that , in the linear case , slight deviation from the geometric distribution in some cases does not change the optimal code ( * ? ? ? * proposition  ( 2 ) ) .",
    "other extensions to and deviations of the geometric distribution have also been considered@xcite , including optimal codes for nonbinary alphabets@xcite .",
    "many of these approaches can be adapted to the nonlinear penalties considered here . however , in this section we instead consider another type of probability distribution for binary coding , the type with a light tail .",
    "humblet s approach@xcite , later extended in @xcite , uses the fact that there is an optimal code tree with a unary subtree for any probability distribution with a relatively light tail , one for which there is an @xmath44 such that , for all @xmath45 and @xmath46 , @xmath169 and @xmath170 . due to the additive nature of huffman coding , items beyond @xmath44 form the unary subtree , while the remaining tree can be coded via the huffman algorithm . once again",
    ", this has to be modified for exponential penalties .",
    "we wish to show that the optimal code can be obtained when there is a nonnegative integer @xmath44 such that , for all @xmath45 and @xmath46 , @xmath171 the optimal code is obtained by considering the reduced alphabet consisting of symbols @xmath172 with weights @xmath173 apply exponential huffman coding to this reduced set of weights . for items",
    "@xmath36 through @xmath44 , the huffman codewords for the reduced and the infinite alphabets are identical .",
    "each other item @xmath174 has a codeword consisting of the reduced codeword for item @xmath175 ( which , without loss of generality , consists of all @xmath176 ) followed by the unary code for @xmath177 , that is , @xmath177 ones followed by a zero .",
    "we call such codes _ _ unary - ended .",
    "a pictorial example is shown in fig .",
    "[ buildhumb ] for a problem instance for which @xmath178 .",
    "let @xmath179 be a probability measure on the set of nonnegative integers , and let @xmath6 be the parameter of the penalty to be optimized . if there is a nonnegative integer @xmath44 such that for all @xmath45 and @xmath46 , @xmath180 and @xmath181 then there exists a minimum - penalty binary prefix code with every codeword  @xmath45 consisting of @xmath182 @xmath176 followed by one @xmath36 for some fixed nonnegative integer  @xmath183 .",
    "[ tailthm ]    the idea here is similar to that for geometric distributions , to show a sequence of finite codes which in some sense converges to the optimal code for the infinite alphabet . in this case",
    "we consider the infinite sequence of codes implicit in the above ; for a given @xmath184 , the corresponding codeword weights are @xmath185 it is obvious that an optimal code for each @xmath120-reduced distribution is identical to the proposed code for the infinite alphabet , except for the item @xmath186 , which is the code tree sibling of item @xmath187 .    for @xmath7 , we show , as in the geometric case , that the difference between the penalties for the optimal and the proposed codes approaches  @xmath36 . in this case",
    ", the equivalent of inequality  ( [ fininf ] ) is @xmath188 where in this case @xmath189 denotes a codeword of the proposed code , @xmath190 for @xmath191 and @xmath192 for @xmath193 , and , again , @xmath194 denotes the lengths of codewords in an optimal code .",
    "the corresponding difference between the exponent of the first and the last expressions of ( [ fininf2 ] ) is @xmath195 as @xmath152 , both terms in the difference on the second line of ( [ fininf3 ] ) clearly approach @xmath36 , so the terms in  ( [ fininf2 ] ) approach equality , showing the proposed code to be optimal .    for @xmath8 , the same method will work , but it is not so obvious that the terms in the difference on the second line of ( [ fininf3 ] ) approach  @xmath36 .",
    "let us first find an upper bound for @xmath196 in terms of @xmath197 : @xmath198 where the first equality is due to the definition of @xmath199 , the first inequality due to ( [ cond2 ] ) , and the second inequality due to ( [ cond1 ] ) .",
    "thus @xmath196 has an upper bound of @xmath200 for all @xmath184 .",
    "in addition , since the proposed code has a finite penalty  identical to that of any reduced code  the optimal code has a finite penalty , and the sequence of its terms  each one of which has the form @xmath201  approaches @xmath36 as @xmath120 increases .",
    "thus @xmath202 approaches @xmath36 as well .",
    "due to the optimality of @xmath194 , @xmath203 serves as an upper bound for @xmath204 , and thus both terms approach  @xmath36 . as with @xmath7 , then , the terms in  ( [ fininf2 ] ) approach equality for @xmath205 , showing the proposed code to be optimal .    the rate at which @xmath179 must decrease in order to satisfy condition  ( [ cond2 ] ) clearly depends on @xmath6 .",
    "one simple sufficient condition  provable via induction  is that it satisfy @xmath206 for large @xmath5 .",
    "a less general condition is that @xmath60 eventually decrease at least as quickly as @xmath207 where @xmath208 , the same ratio needed for a unary geometric code for @xmath209 , as in  ( [ ineq ] ) .",
    "the ratio @xmath210 is plotted in fig .  [ ga ] .    for @xmath23 , these conditions approach those derived in @xcite . the stronger results of @xcite do not easily extend here due to the nonadditivity of the exponential penalty .",
    "an attempt at such an extension in @xcite gives no criteria for success , so that , while one could produce certain codewords for certain codes , one might fail in producing other codewords for the same codes or for other codes .",
    "thus this extension is not truly a workable algorithm .",
    "consider the example of optimal codes for the poisson distribution , @xmath211 how does one find a suitable value for @xmath44 ( as in section  [ other ] ) in such a case ?",
    "it has been shown that @xmath212 yields @xmath213 for all @xmath45 and @xmath46 , satisfying the first condition of theorem  [ tailthm ] @xcite . moreover , if , in addition , @xmath214 ( and thus @xmath215 ) , then @xmath216 \\\\ & < & \\boldp(j ) \\left[\\frac{a \\lambda}{j+1 } + \\frac{a^2 \\lambda^2}{(j+1)^2 } + \\cdots \\right ] \\\\ & = & \\boldp(j ) \\frac{\\frac{a \\lambda}{j+1}}{1-\\frac{a \\lambda}{j+1 } } \\\\ & \\leq & \\boldp(j ) \\\\ & \\leq & \\boldp(i ) .\\end{aligned}\\ ] ] thus , since we consider @xmath217 , @xmath218 is sufficient to establish an @xmath44 such that the above method yields the optimal infinite - alphabet code .    in order to find the optimal reduced code ,",
    "use @xmath219 for example , consider the poisson distribution with @xmath220 .",
    "we code this for both @xmath221 and @xmath222 . for both values ,",
    "@xmath223 , so both are easy to code . for @xmath221 , @xmath224 , while , for @xmath222 , @xmath225 . after using the appropriate huffman procedure on each reduced source of @xmath226 weights , we find that the optimal code for @xmath221 has lengths @xmath227  those of the unary code  while the optimal code for @xmath222 has lengths @xmath228 .",
    "it is worthwhile to note that these techniques are easily extensible to finding an optimal alphabetic code  that is , one with @xmath229 arranged in lexicographical order  for @xmath8 .",
    "one needs only to find the optimal alphabetic code for the reduced code with weights given in equation  ( [ weights ] ) , as in @xcite , with codewords for @xmath174 consisting of the reduced code s codeword for @xmath175 followed by @xmath177 ones and one zero .",
    "as previously mentioned , golomb codes are also alphabetic and thus are optimal alphabetic codes for the geometric distribution .",
    "the application of the exponential penalty in @xcite concerns minimizing the probability of a buffer overflowing .",
    "it requires that each candidate code for overall optimality be an optimal code for one of a series of exponential parameters ( @xmath230 where @xmath8 ) .",
    "an iterative approach yields a final output code by noting that , for the overall utility function , each candidate code is no worse than its predecessor , and there are a finite number of possible candidate codes .",
    "therefore , eventually a candidate code yields the same value as the prior candidate code , and this can be shown to be the optimal code .",
    "this application of exponential huffman coding can , using the above techniques , be extended to infinite alphabets .    in the application , integers with a known distribution",
    "@xmath1 arrive with independent intermission times having a known probability density function .",
    "encoded bits are sent at a given rate , with bits to be sent waiting in a buffer of fixed size .",
    "constant @xmath231 represents the buffer size in bits , random variable @xmath30 represents the probability distribution of source integer intermission times measured in units of encoded bit transmission time , and function @xmath232 is the laplace - stieltjes transform of @xmath30 , @xmath233 $ ] .    when the integers are coded using @xmath234 , the probability per input integer of buffer overflow is of the order of @xmath235 , where @xmath236 is the largest @xmath237 such that @xmath238 where @xmath239    the previously known algorithm to maximize @xmath236 is as follows :    * procedure for finding code with largest @xmath236 * @xcite    1 .",
    "choose any @xmath240 .",
    "2 .   @xmath241 .",
    "3 .   @xmath242 .",
    "4 .   find codeword lengths @xmath243 minimizing @xmath244 .",
    "compute @xmath245 .",
    "6 .   if @xmath246 then go to step 3 ; otherwise stop .",
    "we can use the above methods in order to accomplish step 4 , but we still need to examine how to modify steps 1 and 5 for an infinite input alphabet .    first note that , unlike in the finite case , @xmath247 , that is , there always exists an @xmath248 such that , for all @xmath249 , @xmath250 . for any stable system , the buffer can not receive integers more quickly than it can transit bits , so there is a positive probability that @xmath251 $ ] .",
    "thus the laplace - stieltjes transform @xmath232 exceeds @xmath252 for some constant @xmath253 .",
    "also , without loss of generality , we can assume that @xmath60 is monotonic nonincreasing and an optimal @xmath4 is monotonic nondecreasing .",
    "this monotonicity means that @xmath254 , and there is no exponential base @xmath255 and offset constant @xmath256 for which @xmath257 for all  @xmath258 .",
    "thus the summation in  ( [ buff ] ) must increase superexponentially , and , multiplying the @xmath232 and summation terms , there is an @xmath237 such that @xmath259 for @xmath249 .    for step 1 ,",
    "the initial guess proposed in @xcite is an upper bound for all possible values of @xmath236 .",
    "the rnyi entropy of @xmath1 is used to find an initial guess using @xmath260 and choosing @xmath261 as the largest @xmath237 such that the left term of ( [ humbbound ] ) is no greater than one .",
    "thus , @xmath262 for any value of @xmath236 corresponding to step 5 .",
    "this technique is well - suited to a geometric distribution , for which entropy has the closed form shown in equation ( [ geoent ] ) , so @xmath263 however , a general distribution with a light tail , such as the poisson distribution , might have no closed form for this bound .",
    "one solution to this is to use more relaxed lower bounds on the sum  such as using a partial sum with a fixed number of terms  yielding looser upper bounds for  @xmath236 .",
    "another approach would be to note that , because of the light tail , the infinite sum can usually be quickly calculated to the precision of the architecture used .",
    "note , however , that no matter what the technique , the bound must be chosen so that @xmath261 is an real number and not infinity .",
    "partial sums may be refined to accomplish this .    in calculating @xmath264 for use in step 5 , the geometric distribution has the closed - form value for @xmath265 obtainable from equation ( [ geosum ] ) , while the other distributions must instead rely on approximations of  @xmath265 .",
    "as before , this is easily done due to the light tail of the distribution . alternatively , a partial sum and a geometric approximation can be used to bound @xmath264 and thus @xmath236 , and these two bounds used to find two codes .",
    "if the two codes are identical , the algorithm may proceed ; otherwise , we must roll back to the summation and improve the bounds until the codes are identical .",
    "these variations make the steps of the algorithm possible , but the algorithm itself must also be proven correct with the variations .    given a geometric distribution or an input distribution satisfying the conditions of theorem  [ tailthm ] for @xmath266 , where @xmath261 is an upper - bound on @xmath236 , the above procedure for finding code with largest @xmath236 terminates with an optimal code .",
    "[ qthm ]    the number of codes that can be generated in the course of running the algorithm should be bounded so that the algorithm is guaranteed to terminate .",
    "optimality for the algorithm then follows as for the finite case  @xcite . as in the finite case , @xmath267 for @xmath268 ( but not @xmath269 ) due to step 5 [ @xmath270 ,",
    "step 4 [ @xmath271 , and the definition of @xmath272 .    in the case of a geometric distribution ,",
    "each @xmath243 is a golomb code g@xmath273 for some positive integer  @xmath273 .",
    "clearly , if we choose @xmath261 as detailed above , it is the greatest value of @xmath274 , being either optimal or unachievable due to its derivation as a bound of the problem . since @xmath275 ( with lengths @xmath276 )",
    "is the optimal code for the code with exponential base @xmath277 , ( [ ineq ] ) means that @xmath278 , and thus @xmath279 and , since @xmath280 , we have @xmath281 ( or , equivalently , @xmath282 ) for all @xmath268 .",
    "therefore , there are only @xmath283 possible codes the algorithm can generate .    in the case of a distribution with a lighter tail ,",
    "the minimum @xmath44 of theorem  [ tailthm ] increases with each iteration after the first , and the first @xmath284 ( corresponding to @xmath261 ) upper bounds the remaining @xmath285 .",
    "thus all candidate codes can be specified by their first @xmath284 codeword lengths , none of which is greater than @xmath284 . the number of codes is then bounded for both cases , and the algorithm terminates with the optimal code .",
    "it is natural to ask whether the above results can be extended to other penalties .",
    "one penalty discussed in the literature is that of maximal pointwise redundancy@xcite , which is @xmath286\\ ] ] where we use @xmath287 when we are not assured the existence of a maximum . this can be shown to be a limit of the exponential case , as in @xcite , allowing us to analyze its minimization using the same techniques as exponential huffman coding .",
    "this limit can be shown by defining _ _",
    "@xmath288th exponential redundancy as follows : @xmath289 thus @xmath290 , and the above methods should apply in the limit .",
    "in particular :    the golomb code g@xmath42 for @xmath52 is optimal for minimizing maximal pointwise redundancy for @xmath106 .",
    "[ optmmr ]    ( 0,0 )    # 1#2#3#4#5 @font    ( 16332,6837)(-8,-6007 ) ( 4051,-5911)(0,0)[b ] ( 12511,-5911)(0,0)[b ]    _ case 1 : _ consider first when @xmath291 is not an integer .",
    "we show that @xmath292 is optimal by finding a @xmath293 such that , for all @xmath294 , the optimal code for the @xmath288th exponential redundancy penalty is g@xmath42 . for a fixed @xmath288 , ( [ ineq ] )",
    "implies that such a code should satisfy @xmath295 and thus we wish to show that this holds for all @xmath294 .",
    "consider @xmath296 .",
    "clearly , @xmath297 , or , equivalently , @xmath298 now consider @xmath299 so that @xmath300 $ ] and therefore @xmath301 taken together with the fact that @xmath95 , ( [ mmr1 ] ) yields @xmath302 and @xmath303 .",
    "multiplication yields the left - hand side of ( [ dineq ] ) for any @xmath294 . for any such @xmath288",
    ", algebra easily shows that we also have the inequality @xmath304 , yielding @xmath3052^d   & = & \\frac{1}{2}(2\\theta^{\\kvals-1})^{1+d } +   \\frac{1}{2}(2\\theta^{\\kvals})^{1+d } \\\\ & = & \\frac{1}{2}(2\\theta^{\\kvals})^{1+d } ( \\theta^{-1-d}+1 ) \\\\ & = & \\frac{1}{2}(2\\theta^{\\kvals-1})^{1+d } ( 1+\\theta^{1+d } ) \\\\",
    "& > & 1 .\\end{aligned}\\ ] ] this is equivalent to the right - hand side of inequality  ( [ dineq ] ) for the values implied by the definition of @xmath306 .",
    "then g@xmath307 is an optimal code for @xmath294 , and thus for the limit case of maximal pointwise redundancy .",
    "_ case 2 : _ now consider when @xmath291 is an integer .",
    "it should be noted that , for the traditional ( linear ) penalty , these are precisely the @xmath42 values that golomb considered in his original paper@xcite and that they are local infima for the minimum maximal pointwise redundancy function in  @xmath168 , as in fig .",
    "here we show they are local minima .",
    "since @xmath308 is a dyadic probability distribution and thus trivial , we can assume that @xmath309 .",
    "we wish to show that optimality is preserved in these right limits of case  1 .",
    "note that , for each @xmath5 with fixed @xmath15 , @xmath310 = \\len(i ) + \\lg \\boldp_{\\theta}(i).\\ ] ] this is of particular interest for the value of @xmath5 maximizing pointwise redundancy for g@xmath42 at @xmath311 , where @xmath312 , allowing us to use the right limit of @xmath168 .",
    "let @xmath313 , the smallest @xmath5 which has codeword length exceeding the codeword length for item  @xmath36 . clearly the pointwise redundancy for this value is greater than that for all items with @xmath314 , since they are one bit shorter but not more than twice as likely .",
    "similarly , items in @xmath315 have identical length but lower probability , and thus smaller redundancy . for items with @xmath316 , note that the redundancy of items in the sequence @xmath317 for any @xmath68 must be nonincreasing because the difference in redundancy is constant yet",
    "redundancy is upper - bounded by the maximum .",
    "thus @xmath318 maximizes pointwise redundancy for g@xmath42 at @xmath311 .",
    "we know the pointwise redundancy of @xmath318 for g@xmath42 at @xmath168 , although we have yet to show that @xmath318 yields the maximal pointwise redundancy for g@xmath42 at @xmath168 or that g@xmath42 minimizes maximal pointwise redundancy .",
    "however , for any code , including the optimal code , as a result of pointwise continuity , @xmath319 & \\geq & \\len(i^ { * * } ) + \\lg \\boldp_\\theta(i^ { * * } ) \\\\ & = & \\lim_{\\theta ' \\uparrow \\theta } [ \\len(i^ { * * } ) + \\lg \\boldp_{\\theta'}(i^ { * * } ) ] .\\end{aligned}\\ ] ] from the above discussion , it is clear that the right - hand side is minimized by the golomb code with @xmath320 , so , because the left - hand side achieves same value with this code , the left - hand side is indeed minimized by g@xmath42 .",
    "thus this code minimizes maximal pointwise redundancy for  @xmath168 .",
    "the corresponding maximal pointwise redundancy is @xmath321 \\\\ \\begin{array}{rcl } & = & \\len_\\theta^{**}(2^{\\lceil \\lg \\kval \\rceil}-\\kval ) + \\lg \\boldp_\\theta(2^{\\lceil \\lg \\kval \\rceil}-\\kval ) \\\\   & = & \\lceil \\lg \\kval \\rceil + 1 + \\lg(1-\\theta ) + ( 2^{\\lceil \\lg \\kval \\rceil}-\\kval ) \\lg \\theta   \\end{array } \\end{array}\\ ] ] where @xmath322 is defined as the lengths of a code minimizing maximal pointwise redundancy .",
    "note that this is the redundancy for all items @xmath323 with integer @xmath324 .",
    "it is worthwhile to observe the behavior of maximal pointwise redundancy in a fixed ( not necessarily optimal ) golomb code with length distribution @xmath160 .",
    "the maximal pointwise redundancy @xmath325\\ ] ] decreases with increasing @xmath168  and is an optimal code for @xmath326 $ ]  until @xmath168 exceeds @xmath327 , after which there is no maximum , that is , pointwise redundancy is unbounded .",
    "this explains the discontinuous behavior of minimum maximal redundancy for an optimal code as a function of @xmath168 , illustrated in fig .",
    "[ mmr ] , where each continuous segment corresponds to an optimal code for @xmath328 $ ] .",
    "note also the oscillating behavior as @xmath329 .",
    "we show in appendix  [ maxred ] that @xmath330 and @xmath331 , and we characterize this oscillating behavior .",
    "this technique is extensible to other redundancy scenarios of the kind introduced in  @xcite .    for distributions with light tails",
    ", one can use a technique much like the technique of theorem  [ tailthm ] in section  [ other ] .",
    "first note that this requires , as a necessary step , the ability to construct a minimum maximal pointwise redundancy code for finite alphabets .",
    "this can be done either with the method in @xcite or any of those in @xcite , the simplest of which uses a variant of the tree - height problem@xcite , solved via a different extension of huffman coding .",
    "simply put , the weight combining rule , rather than @xmath332 or @xmath333 , is @xmath334 this rule is used to create an optimal code with lengths @xmath335 for @xmath336 , assuming a unary subtree for items with index @xmath337 ( and no other items ) is part of an optimal code tree . as in the coding method corresponding to theorem  [ tailthm ] ,",
    "the codewords for items @xmath36 through @xmath44 of this reduced code are identical to those of the infinite alphabet .",
    "each other item @xmath174 has a codeword consisting of the reduced codeword for @xmath175 followed by the unary code for @xmath177 , that is , @xmath177 ones followed by a zero .",
    "a sufficient condition for using this method is finding an @xmath44 such that @xmath338 and @xmath339 for such  @xmath68 , pointwise redundancy is nonincreasing along a unary subtree , as @xmath340 the aforementioned coding method works because , for each @xmath68 , an optimal subtree consisting of the items with index @xmath341 and higher has @xmath342 ; this subtree is optimal because the weight of the root node of _ any _ subtree can not be less than @xmath343 . a formal proof , similar to that of theorem  [ tailthm ] , is omitted in the interest of space .    for a poisson",
    "random variable , @xmath344 satisfies this condition , since , for @xmath345 , @xmath346 ( as in @xcite ) , and @xmath347 thus such a random variable can be coded in this manner .",
    "note that other sufficient conditions can be obtained through alternative methods .",
    "one simple rule is that any code for which @xmath348 for all @xmath349 will necessarily have @xmath350 minimized by letting @xmath351 , and this will be the maximum redundancy if @xmath352 in general .",
    "for example , a unary tree optimizes @xmath353 , since @xmath354 is a lower bound on maximal pointwise redundancy for any code given @xmath355 , and this bound is achieved for the unary code .",
    "if viewed as a rule for a unary subtree , this is looser than the above , since , unlike linear and exponential penalties , not all subtrees of the subtree need be optimal .",
    "other relaxations can be obtained , although , as they are usually not needed , we do not discuss them here .",
    "the aforementioned methods for coding integers are applicable to geometric and light - tailed distributions with exponential and related penalties .",
    "although they are not direct applications of huffman coding , per se , these methods are derived from the properties of generalizations of the huffman algorithm .",
    "this allows examination of subtrees of a proposed optimal code independently of the rest of the code tree , and thus specification of finite codes which in some sense converge to the optimal integer code .",
    "different penalties  e.g. , @xmath356 , implying the minimization of @xmath357  do not share this independence property , as an optimal code tree with optimal subtrees need not exist . thus finding an optimal code for such penalties is more difficult .",
    "there should , however , be cases in which this is possible for convex @xmath25 which grow more slowly than some exponential .",
    "another extension of this work would be to find coding algorithms for other probability mass functions under the nonlinear penalties already considered , e.g. , to attempt to use the techniques of @xcite for a more reliable algorithm .",
    "other possible extensions and generalizations involve variants of geometric probability distributions ; in addition to the one we mentioned that is analogous to proposition  ( 2 ) in @xcite , there are others in @xcite .",
    "extending these methods to nonbinary codes should also be feasible , following the approaches in @xcite and @xcite . finally , as a nonalgorithmic result",
    ", it might be worthwhile to characterize _ all _ optimal codes  not merely finding _ an _ optimal code  as in @xcite .",
    "the author wishes to thank the anonymous reviewers , david morgenthaler , and andrew brzezinski for their suggestions in improving the rigor and clarity of this paper .",
    "let us calculate optimal maximal redundancy as a function of @xmath358 : @xmath359 where @xmath360 denotes the fractional part of @xmath183 , i.e. , @xmath361 , since @xmath362 for @xmath363 ( and thus for @xmath364 ) . using the taylor series expansion about @xmath365",
    ", we find @xmath366 where @xmath49 is the base of the natural logarithm .",
    "additionally , @xmath367 note that this actually oscillates between @xmath34 and @xmath368 in the limit , so this first - order asymptotic term can not be improved upon .",
    "however , the remaining terms @xmath369 oscillate in the zero - order term . assigning @xmath370 , we find that ( [ osc ] ) achieves its minimum value , @xmath36 , at @xmath36 and @xmath34 .",
    "the maximum point is easily found via a first derivative test .",
    "this point is achieved at @xmath371 , at which point ( [ osc ] ) achieves the maximum value @xmath372 .",
    "thus , gathering all terms , @xmath373 @xmath374 and , overall , @xmath375 this oscillating behavior is similar to that of the average redundancy of a complete tree , as in @xcite and @xcite .",
    "contrast this with the periodicity of the minimum _ average _ redundancy for a golomb code:@xcite @xmath376 where @xmath377 is the optimal code for the traditional ( linear ) penalty .",
    "l|l @xmath6 & base of exponential penalty + @xmath378 & @xmath379th codeword of complete binary code + & with @xmath70 items ( i.e. , the order - preserving + & [ alphabetic ] code having the first @xmath380 + & items with length @xmath381 and the last + & @xmath382 items with length @xmath383 ) + @xmath63 & codeword ( for symbol ) @xmath5 + @xmath14 & code @xmath384 + @xmath49 & base of the natural logarithm ( @xmath50 ) + g@xmath42 & golomb code with parameter @xmath42 , one of the + & form @xmath385 + @xmath386 & rnyi entropy @xmath387 + & ( or , if @xmath388 , the limit of this ) + @xmath318 & index of the codeword that , among a + & given code s inputs @xmath389 , maximizes + & pointwise redundancy , @xmath390 + @xmath391 & @xmath392 + @xmath393 & penalty @xmath394 + @xmath4 & length of codeword ( for symbol ) @xmath5 + @xmath15 & @xmath395 , the lengths for a given code + @xmath396 & length of codeword @xmath5 of an optimal code + & minimizing maximum redundancy for @xmath397 + @xmath335 & @xmath398 , the lengths of an optimal code + & minimizing maximum redundancy for @xmath397 + @xmath399 & length of codeword @xmath5 of an optimal code + & for an exponential penalty , @xmath21 + @xmath400 &  ( ... if @xmath168 and @xmath6 are specified ) + @xmath146 & @xmath401 , the lengths of an optimal code + @xmath402 &  ( ... if @xmath168 and @xmath6 are specified ) + @xmath403 & length of codeword @xmath5 of an optimal code + & minimizing @xmath288th exponential redundancy + @xmath404 & @xmath405 , the lengths of an optimal code + & minimizing @xmath288th exponential redundancy + @xmath406 & length of codeword @xmath5 of an optimal code + & minimizing maximum redundancy + @xmath407 & @xmath408 , the lengths of an optimal code + & minimizing maximum redundancy + @xmath409 & order of @xmath410 asymptotic complexity + @xmath60 & probability of input symbol @xmath5 + @xmath411 &  ( ... for geometric dist^r^ with parameter @xmath168 ) + @xmath412 &  ( ... for poisson dist^r^ with parameter",
    "@xmath413 ) + @xmath1 & @xmath414 , the input probability mass function + @xmath415 &  ( ... for geometric dist^r^ with parameter @xmath168 ) + @xmath416 &  ( ... for poisson dist^r^ with parameter",
    "@xmath413 ) + @xmath417&@xmath418 , the average + & pointwise redundancy + @xmath419&@xmath420 , + & the @xmath288th exponential redundancy + @xmath421&@xmath422 $ ] , the maximum + & pointwise redundancy + @xmath423 & the set of real numbers + @xmath424 & the set of positive real numbers + @xmath261 & upper bound on @xmath236 + @xmath236 & @xmath425 for @xmath6 corresponding to optimal coding + & for buffer overflow + @xmath59 & weight ( for symbol ) @xmath5 + @xmath426 & @xmath427 , the set of weights + @xmath428 & @xmath60 for @xmath429 , @xmath430 for @xmath431 + @xmath397 & @xmath432 + @xmath10 & input alphabet ( usually @xmath433 ) + @xmath434 & @xmath435 ( parameter for rnyi entropy ) + @xmath168 & geometric dist^r^ parameter ( @xmath436 ) + @xmath413 & poisson dist^r^ parameter ( @xmath48 ) + @xmath437 & golden ratio , @xmath438 +                  t.  wiegand , g.  j. sullivan , g.  bjntegaard , and a.  luthra , `` overview of the h.264/avc video coding standard , '' _ ieee trans .",
    "circuits and systems for video technology _ , vol .  13 , no .  7 , pp .",
    "560576 , july 2003 .",
    "m.  weinberger , g.  seroussi , and g.  sapiro , `` the loco - i lossless image compression algorithm : principles and standardization into jpeg - ls , '' _ ieee trans .",
    "image processing _",
    ", vol .  9 , no .  8 , pp . 13091324 , aug",
    ". 2000 , originally as hewlett - packard laboratories technical report no .",
    "hpl-98 - 193r1 , november 1998 , revised october 1999 .",
    "available from http://www.hpl.hp.com / loco/.              a.  rnyi , _ a diary on information theory_.1em plus 0.5em minus 0.4emnew york , ny : john wiley & sons inc .",
    ", 1987 , original publication : _ napl az informcielmletrl _ ,",
    "gondolat , budapest , hungary , 1976 .",
    "m.  j. golin and k.  k. ma , `` algorithms for constructing infinite huffman codes , '' hong kong university of science & technology theoretical computer science center , tech .",
    "rep . hkust - tcsc-2004 - 07 , aug .",
    "2004 , available from http://www.cs.ust.hk/tcsc/rr/index_7.html ."
  ],
  "abstract_text": [
    "<S> let @xmath0 be a measure of strictly positive probabilities on the set of nonnegative integers . </S>",
    "<S> although the countable number of inputs prevents usage of the huffman algorithm , there are nontrivial @xmath1 for which known methods find a source code that is optimal in the sense of minimizing expected codeword length . for some applications , however , a source code should instead minimize one of a family of nonlinear objective functions , @xmath2-exponential means , those of the form @xmath3 , where @xmath4 is the length of the @xmath5th codeword and @xmath6 is a positive constant . applications of such minimizations include a novel problem of maximizing the chance of message receipt in single - shot communications ( @xmath7 ) and a previously known problem of minimizing the chance of buffer overflow in a queueing system ( @xmath8 ) . </S>",
    "<S> this paper introduces methods for finding codes optimal for such exponential means . </S>",
    "<S> one method applies to geometric distributions , while another applies to distributions with lighter tails . </S>",
    "<S> the latter algorithm is applied to poisson distributions and both are extended to alphabetic codes , as well as to minimizing maximum pointwise redundancy . </S>",
    "<S> the aforementioned application of minimizing the chance of buffer overflow is also considered .    </S>",
    "<S> communication networks , generalized entropies , generalized means , golomb codes , huffman algorithm , optimal prefix codes , queueing , worst case minimax redundancy . </S>"
  ]
}