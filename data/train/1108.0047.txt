{
  "article_text": [
    "next - generation sequencing ( ngs ) technologies allow massive and parallel sequencing of biological molecules ( dna and rna ) , and have a huge impact on molecular biology and bioinformatics  @xcite .",
    "in particular , rna - seq is a recent technique to sequence expressed transcripts , characterizing both the type and the quantity of transcripts expressed in a cell ( its transcriptome ) . challenging tasks of transcriptome analysis via rna - seq data analysis  @xcite are reconstructing full - length transcripts ( or isoforms ) of genes and their expression levels .",
    "the most recent studies indicate that alternative splicing is a major mechanism generating functional diversity in humans and vertebrates , as at least 90% of human genes exhibit splicing variants .",
    "the annotation of alternative splicing variants and as events , to differentiate and compare organisms , is part of the central goal in transcriptome analysis of identifying and quantifying all full - length transcripts .",
    "however , the extraction of splicing variants or significant as events from the different transcripts produced by a set of genes requires to compare hundreds of thousands of full - length transcripts . graph representations of splice variants , such as splicing graphs  @xcite , have emerged as a convenient approach to summarize several transcripts from a gene into the putative gene structure they support .",
    "the current notions of splicing graphs rely on some sort of gene annotations , such as the annotation of full - length transcripts by their constitutive exons on the genome .    in this paper",
    ", we first define the notion of _ isoform graph _ which is a gene structure representation of genome annotated full - length transcripts of a gene .",
    "the isoform graph is a variant of the notion of splicing graph that has been originally introduced in  @xcite in a slightly different setting .",
    "when using only rna - seq data , the genome annotation can not be given , and thus it is quite natural to investigate and characterize the notion of splicing graph which naturally arises when a reference genome is not known or available .",
    "thus , in the paper we focus on the following main question : _ under which conditions the reconstruction of a gene structure can be efficiently accomplished using only information provided by rna - seq data ? _    in order to face this problem , we give some necessary or sufficient conditions to infer the isoform graph , we introduce an optimization problem that guides towards finding a good approximation of the isoform graph and finally we describe an efficient heuristic for our problem on data violating the conditions necessary to exactly infer the isoform graph .",
    "the novelty of our approach relies on the fact that it allows the reconstruction of the splicing graph in absence of the genome , and thus it is applicable also to highly fragmented or altered data , as found in cancer genomes .",
    "moreover we focus on methods that can effectively be used for a genome - wide analysis on a standard workstation .    our computational approach to as is different from current methods of transcriptome analysis that focus on using rna - seq data for reconstructing the set of transcripts ( or isoforms ) expressed by a gene , and estimating their abundance .",
    "in fact , we aim on summarizing genome - wide rna - seq data into graphs each representing an expressed gene and the alternative splicing events occurring in the specific processed sample . on the contrary , current tools",
    "do not give a concise result , such as a structure for each gene , nor they provide a easy - to - understand listing of as events for a gene .",
    "observe that in absence of a reference , the information given by the predicted full - length transcripts spanning the whole genes does not imply a direct procedure to built the isoform graph .",
    "in fact , the annotation against a genome is required to compute such a graph , as we need to determine from which gene a given transcript is originated , may lead to a complex and time consuming procedure .",
    "our paper is not focused on full - length transcripts reconstruction  @xcite , such as cufflinks  @xcite , and scripture  @xcite or de novo assembly methods that build a de brujin graph such as transabyss  @xcite , velvet  @xcite , and trinity  @xcite .",
    "these tools are computationally expensive and are able to find only the majority of the annotated isoforms while providing a large amount of non annotated full - length transcripts that would need to be experimentally validated .    on the other end ,",
    "the use of de brujin graph to build approximations of splicing graphs reveals clear shortcomings due to repeated sequences in distinct genes that lead to assembly chimeric transcripts and hence fusions of rna - seq data from distinct gene structures into unique graphs .    in the paper",
    ", we aim to advance towards the understanding of the possibilities and limitations of computing the distinct gene structures from which genome - wide rna - seq or short reads data have been extracted . in this sense",
    "our approach aims to keep separate gene structures in the reconstruction from genome wide rna - seq even in absence of a reference .    in this paper",
    ", we validate our approach from both theoretical and experimental points of view .",
    "first we will prove that some conditions must be met in order to guarantee the reconstruction of the isoform graph from rna - seq data .",
    "then we describe a simple and efficient algorithm that reconstructs the isoform graph under some more restrictive conditions . at the same time , a more refined algorithm ( sharing the main ideas of the basic one ) is able to handle instances where the aforementioned conditions do not hold due to , for example , errors in the reads or lower coverage that typically affect real data .",
    "we show experimentally , as well as theoretically , the scalability of our implementation to huge quantity of data .",
    "in fact limiting the time and space computational resources used by our algorithm is a main aim of ours , when compared to other tools of transcriptome analysis .",
    "more precisely , our algorithmic approach works in time that is linear in the number of reads , while having space requirements bounded by the size of hashing tables used to memorize reads .",
    "moreover , we are able to show that are method is able to distinguish among different gene structures though processing a set of reads from various genes , limiting the process of fusion of graphs structures from distinct genes due to the presence of repeated sequences .",
    "the theoretical and experimental analysis have pointed out limitations that are inherent the input data .",
    "as such , we plan to further improve our algorithms and our implementations to be able to deal with the different situations coming from these limitations .",
    "a conceptual tool that has been used to investigate the reconstruction of full - length transcripts from ests ( expressed sequence tags ) @xcite or rna - seq data is the _",
    "splicing graph_. in this paper we use a notion of a splicing graph that is close to the one in  @xcite , where splicing graphs provide a representation of variants . since our main goal is the reconstruction of the splicing graph from the nucleotide sequences of a set of short reads without the knowledge of a genomic sequence , some definitions will be slightly different from  @xcite where the notion of abundance of reads spanning some splicing junction sites is central .",
    "moreover our goal is to study transcripts data originating from different tissues or samples , where the expression level of each single transcript greatly varies among samples . therefore introducing abundance into consideration",
    "is likely to introduce a number of complications in the model as well as in the algorithms , while increasing the presence of possible confounding factors .",
    "informally , a splicing graph is the graph representation of a gene structure , inferred from a set of rna - seq data , where isoforms correspond to paths of the splicing graphs , while splicing events correspond to specific subgraphs .",
    "let @xmath0 be a sequence of characters , that is a _",
    "string_. then @xmath1 $ ] denotes the substring @xmath2 of @xmath3 , while @xmath4 $ ] and @xmath5 $ ] denote respectively the _ prefix _ of @xmath3 consisting of @xmath6 symbols and the _ suffix _ of @xmath3 starting with the @xmath7-th symbol of @xmath3 .",
    "we denote with @xmath8 and @xmath9 respectively the prefix and the suffix of length @xmath6 of @xmath3 . among all prefixes and suffixes , we are especially interested into @xmath10 and @xmath11 which are called the _ left half _ and the _ right half _ of @xmath3 . given two strings @xmath12 and @xmath13 ,",
    "the _ overlap _ @xmath14 is the length of the longest suffix of @xmath12 that is also a prefix of @xmath13 .",
    "the _ fusion _ of @xmath12 and @xmath13 , denoted by @xmath15 , is the string @xmath16s_2 $ ] obtained by concatenating @xmath12 and @xmath13 after removing from @xmath12 its longest suffix that is also a prefix of @xmath13 .",
    "we extend the notion of fusion to a sequence of strings @xmath17 as @xmath18 if @xmath19 , and @xmath20 .    in this paper",
    "we consider discrete genomic regions ( i.e. a gene or a set of genes ) and their full - length isoforms or transcript products of the genes along these regions .",
    "a gene isoform is a concatenation of some of the coding regions of the gene respecting their order in the genomic region .",
    "alternative splicing regulates how different coding regions are included to produce different full - length isoforms or transcripts , which are modeled here as sequences of _ blocks_. formally , a _ block _",
    "consists of a string , typically taken over the alphabet @xmath21 , and an integer called rank , such that no two blocks share the same rank .",
    "the purpose of introducing the rank of a block is to disambiguate between blocks sharing the same nucleotide sequence ( i.e. string ) and to give an order among blocks , reproducing the order of exons in the genomic region .",
    "= [ draw , rectangle , minimum height=0.4 cm , minimum width=1.1 cm , fill = white , anchor = south west ] = [ draw , rectangle , minimum height=0.4 cm , minimum width=2.2 cm , fill = white , anchor = south west ]    = [ draw , rectangle , minimum height=0.4 cm , minimum width=1.1 cm , fill = white , anchor = south west ]    = [ draw , rectangle , minimum height=0.4 cm , minimum width=2.2 cm , fill = white , anchor = south west ]    given a block @xmath22 , we denote by @xmath23 and @xmath24 its string and rank respectively .    in our framework a _ gene coding region _ is a sequence ( that is , an ordered set ) @xmath25 of blocks with @xmath26 for each @xmath6 .",
    "then , the _ string coding region for @xmath27 _ is the string @xmath28 obtained by orderly concatenating the strings of the blocks in @xmath27 .",
    "intuitively a gene coding region is the sequence of all the coding regions on the whole genomic sequence for the studied gene .",
    "we define a _ block isoform _ @xmath29 _ compatible _ with @xmath27 , as a subsequence of @xmath27 , that is @xmath30 where @xmath31 for @xmath32 .",
    "we distinguish between classical isoforms ( defined on exons or genomic regions ) and block isoforms ( defined on blocks ) .",
    "nonetheless , we will use interchangeably the terms isoforms and block isoforms whenever no ambiguity arises . by a slight abuse of language we define the string of @xmath29 , denoted by @xmath33 , as the concatenation of the strings of the blocks of @xmath29 .",
    "[ expressed ] an _ expressed gene _",
    "is a pair @xmath34 , where @xmath27 is a gene coding region , @xmath35 is a set of block isoforms compatible with @xmath27 where ( 1 ) each block of @xmath27 appears in some isoform of @xmath35 , and ( 2 ) for each pair @xmath36 of blocks of @xmath27 , appearing consecutively in some isoform of @xmath35 , there exists a isoform @xmath37 s.t .",
    "exactly one of @xmath38 or @xmath39 appears in @xmath29 .",
    "we point out that def .",
    "[ expressed ] is mostly compatible with that of  @xcite , where a _",
    "block _ is defined as a maximal sequence of adjacent exons , or exons fragments , that always appear together in a set of isoforms or variants .",
    "therefore their approach downplays the relevance of blocks with the same string .",
    "observe that def .",
    "[ expressed ] implies that the set @xmath27 of blocks of a string coding region of an expressed region @xmath34 is unique and is a minimum - cardinality set explaining all isoforms in @xmath35 .",
    "thus , the pair @xmath34 describes a specific gene .",
    "the uniqueness of blocks of an expressed gene allows us to define the associated graph representation , or isoform graph .",
    "given an expressed gene @xmath40 , the _ isoform graph _ of @xmath41 is a directed graph @xmath42 , where an ordered pair @xmath43 is an arc of @xmath44 , iff @xmath38 and @xmath45 are consecutive in at least an isoform of @xmath35 .",
    "notice that @xmath46 is a directed acyclic graph , since the sequence @xmath27 is also a topological order of @xmath46 .",
    "notice that isoforms correspond to paths in @xmath46 .",
    "our first aim of the paper is to characterize when and how accurately the isoform graph of an expressed gene can be reconstructed from a set of substrings ( i.e. rna - seq data ) of the isoforms of the gene .",
    "more precisely , we want to investigate the following two main questions .",
    "_ question 1 : _ what are the conditions under which the isoform graph of a gene can be reconstructed from a sample of rna - seqs ( without putting any bounds on the computational resources ) ?",
    "_ question 2 : _ can we build efficiently such a graph or an approximation of it ?",
    "notice that the isoform graph is the real gene structure that we would like to infer from data but , at the same time , we must understand that the transcript data might not be sufficient to determine the isoform graph , as we have no information on the genomic sequence and on the blocks in particular",
    ". therefore we aim at computing a slightly less informative kind of graph : the _ splicing graph _ , which is a directed graph where each vertex @xmath47 is labeled by a string @xmath48 .",
    "notice that the splicing graph gives no assurance that a vertex is a block , not does it contain any indication regarding whether ( and where ) the string labeling a vertex appears in the genomic region .",
    "for instance , let us consider the isoform graph of figure  [ fig : esempio ] ( b ) .",
    "assume that @xmath49 and @xmath50 share a common prefix @xmath51 , that is the exons @xmath52 and @xmath53 can be respectively written as @xmath54 and @xmath55 .",
    "then if no information about the block positions and rank on the genomic sequence is provided as input data , the splicing graph of figure  [ fig : esempio1 ] could be as plausible as the isoform graph of figure  [ fig : esempio ] ( b ) .",
    "this observation leads us to the notion of splicing graph _ compatible _ with a set of isoforms .",
    "[ def : compatible - graph ] let @xmath34 be an expressed gene , and let @xmath56 be a splicing graph",
    ". then @xmath57 is _ compatible _ with @xmath35 if , for each isoform @xmath58 , there exists a path @xmath59 of @xmath57 such that @xmath60 .",
    "since we have no information on the blocks of the expressed gene , computing any graph that is compatible with the isoform graph is an acceptable answer to our problem .",
    "we need some more definitions related to the fact that we investigate the problem of reconstructing a splicing graph compatible with a set of isoforms only from rna - seqs obtained from the gene transcripts .",
    "let @xmath34 be an unknown expressed gene .",
    "then , a _ rna - seq read _ ( or simply _ read _ ) extracted from @xmath34 , is a substring of the string @xmath33 of some isoform @xmath61 .",
    "notice that we know only the nucleotide sequence of each read .",
    "just as we have introduced the notion of splicing graph compatible with a set of isoforms , we can define the notion of splicing graph compatible with a set of reads .",
    "[ def : read - compatible - graph ] let @xmath62 be a set of reads extracted from an expressed gene @xmath34 , and let @xmath56 be a splicing graph .",
    "then @xmath57 is _ compatible _ with @xmath62 if , for each read @xmath63 , there exists a path @xmath59 of @xmath57 such that @xmath64 is a _ substring _ of @xmath65 .",
    "splicing graph reconstruction ( sgr ) problem [ pb : gf - construction ] + input : a set @xmath62 of reads , all of length @xmath66 , extracted from an unknown expressed gene @xmath34 .",
    "output : a splicing graph compatible with @xmath62 .",
    "clearly sgr can only be a preliminary version of the problem , as we are actually interested into finding a splicing graph that is most similar to the isoform graph associated to @xmath34 .",
    "therefore we need to introduce some criteria to rank all splicing graphs compatible with @xmath62 .",
    "the parsimonious principle leads us to a natural objective function ( albeit we do not claim it is the only possibility ) : to minimize the sum of the lengths of strings associated to the vertices ( mimicking the search for the shortest possible string coding region ) . in the rest of paper",
    "the sgr problem will ask for a splicing graph minimizing such sum .",
    "in this section we will show some conditions must be satisfied if we want to be able to optimally solve the sgr problem . notice that , given an isoform graph @xmath67 there is a splicing graph @xmath68 naturally associated to it , where the two graphs @xmath67 and @xmath68 are isomorphic ( except for the labeling ) and the label of each vertex of @xmath68 is the string of the corresponding vertex of @xmath67 .",
    "let @xmath62 be an instance of sgr originating from an expressed gene @xmath34 .",
    "then @xmath62 is a _",
    "solvable _ instance if : ( i ) for each three blocks @xmath22 , @xmath69 and @xmath70 s.t .",
    "@xmath22 and @xmath69 are consecutive in an isoform , @xmath22 and @xmath70 are consecutive in another isoform , then @xmath69 and @xmath70 begin with different characters . also , for each three blocks @xmath22 , @xmath69 and @xmath70 s.t .",
    "@xmath69 and @xmath22 are consecutive in an isoform , @xmath70 and @xmath22 are consecutive in another isoform , then @xmath69 and @xmath70 end with different characters ; ( ii ) for each subsequence @xmath71 of @xmath27 , the string @xmath72 does not contain two identical substrings of length @xmath73 .",
    "we will show here that our theoretical analysis can focus on solvable instances , since for each condition of solvable instance we will show an example where there exists an optimal splicing graph  different from the isoform graph ",
    "compatible with the instance .    condition ( i ) .",
    "let @xmath74 , and let @xmath75 .",
    "moreover @xmath76=s(b_{2})[1]=x$ ] , that is the strings of both blocks @xmath77 and @xmath78 begins with the symbol @xmath79 , which does not appear in any other position of the string coding region .",
    "consider now the expressed gene @xmath80 , and let @xmath81 , where @xmath82 , @xmath83 $ ] , and @xmath84 $ ] ( informally , the symbol @xmath79 is removed from @xmath77 and @xmath78 and attached to the end of @xmath22 ) .",
    "it is immediate to notice that @xmath85 and @xmath86 contains the same @xmath73-long substring @xmath87 , that is @xmath88 and @xmath89 .",
    "there are two isoforms : @xmath90 and @xmath91 .",
    "besides the isoform graph , there is another splicing graph @xmath92 @xmath93 @xmath94 where @xmath95 , @xmath96 , @xmath97 , @xmath98 , @xmath99 that is compatbile with any set of reads extracted from @xmath34 .",
    "the arcs of this splicing graphs are @xmath100 and @xmath101 .",
    "notice that the sum of lenghts of the labels of this new splicing graph is smaller than that of the isoform graph .",
    "in order to investigate the two main questions stated before , we propose a method for solving the sgr problem . our approach to compute the isoform graph @xmath102 first identifies the vertex set @xmath103 and then the edge set @xmath104 of @xmath102 .",
    "moreover we focus on fast and simple methods that can possibly scale to genome - wide data .",
    "for ease of exposition , the discussion of the method assumes that reads have no errors , and @xmath105 .",
    "the basic idea of our method is that we can find two disjoint subsets @xmath106 , and @xmath107 of the input set @xmath62 of reads , where reads of @xmath106 , called _ unspliced _ , can be assembled to form the nodes in @xmath103 , while reads of @xmath107 , called _ spliced _ , are an evidence of a junction between two blocks ( that is an arc of @xmath102 ) .",
    "we will discuss how our method deals with problems as errors , low coverage .",
    "the second main tenet of our algorithm is that each read is encoded by a @xmath108-bit binary number , divided into a _ left fingerprint _ and a _",
    "right fingerprint _",
    "( respectively the leftmost and the rightmost @xmath109 bits of the encoding ) . then two reads @xmath110 and @xmath111 overlap for at least @xmath112 base pairs iff the right fingerprint of @xmath110 is a substring of the encoding of @xmath111 ( a similar condition holds for the left fingerprint of @xmath111 ) .",
    "bit - level operations allows to look for such a substring very quickly .",
    "[ def : spliced - unspliced ] let @xmath64 be a read of @xmath62",
    ". then @xmath64 is _ spliced _ if there exists another @xmath113 , @xmath114 , such that @xmath115 or @xmath116 , for @xmath117 .",
    "moreover a read @xmath64 is _ perfectly spliced _ if there exists another @xmath113 , @xmath114 , such that the longest common prefix ( or suffix ) of @xmath64 and @xmath118 is exactly of length @xmath73 .",
    "a read that is not spliced is called _ unspliced_.    in our framework , a junction site between two blocks @xmath69 and @xmath119 , that appear consecutively within an isoform , is detected when we find a third block @xmath70 that , in some isoform , appears immediately after @xmath69 or immediately before @xmath119 . for illustrative purposes ,",
    "let us consider the case when @xmath70 appears immediately after @xmath69 in an isoform ( figure  [ subfig : skipping ] ) .",
    "the strongest possible signal of such junction consists of two reads @xmath120 and @xmath121 such that @xmath122 and @xmath123 , that is @xmath120 is cut into halves by the junction separating @xmath69 and @xmath119 , while @xmath121 is cut into halves by the junction separating @xmath70 and @xmath119 ( i.e. @xmath120 and @xmath121 are perfectly spliced ) . in a less - than - ideal scenario ,",
    "we still can find two reads @xmath120 and @xmath121 sharing a common prefix ( or suffix ) that is longer than @xmath73 , in which case the two reads are spliced .",
    "notice that all reads extracted from the same block can be sorted so that any two consecutive reads have large overlap .",
    "more formally , we define a _ chain _ as a sequence @xmath124 of unspliced reads where @xmath125 for @xmath126 ( notice that the @xmath127 , which allows for a very fast computation ) .",
    "let @xmath52 be a chain .",
    "then the string of @xmath52 is the string @xmath128 , moreover @xmath52 is _ maximal _ if no supersequence of @xmath52 is also a chain . under ideal conditions",
    "( i.e. no errors and high coverage ) @xmath129 is exactly the string of a block . coherently with our reasoning ,",
    "a perfectly spliced read @xmath64 is called a _ link _ for the pair of chains @xmath130 , if @xmath131 and @xmath132 . in this case",
    "we also say that @xmath52 and @xmath133 are respectively _ left - linked _ and _ right - linked _ by @xmath64 .",
    "given a set @xmath62 of reads extracted from the isoforms @xmath35 of an unknown expressed region @xmath34 , our algorithm outputs a likely isoform graph @xmath134 , where @xmath135 is a set of maximal chains that can be derived from @xmath62 , and @xmath136 iff there exists in @xmath62 a link for @xmath137 .",
    "the remainder of this section is devoted to show how we compute such graph efficiently even under less - than - ideal conditions .",
    "the algorithm is organized into three steps that are detailed below . in the first step",
    "we build a data structure to store the reads in @xmath62 .",
    "we use two hash tables which guarantee a fast access to the input reads .",
    "the second step creates the nodes of @xmath138 by composing the maximal chains of the unspliced reads of @xmath62 . in the last step of the creation of @xmath138 ,",
    "the maximal chains obtained in the second step are linked .      for each read",
    "longer than @xmath109bp we extract some substrings of @xmath109bp ( usually the leftmost and the rightmost ) that are representative of the original read .",
    "then each @xmath109bp read is unambiguously encoded by a @xmath108-bit binary number , exploiting the fact that we can encode each symbol with 2 bits as follows : @xmath139 , @xmath140 , @xmath141 , @xmath142 . since such encoding is a one - to - one mapping between reads and numbers between @xmath143 and @xmath144 , we will use interchangeably a string and its fingerprint .",
    "moreover , given a read @xmath64 , we define @xmath145 ( also called _ left fingerprint _ ) and @xmath146 ( also called _",
    "right fingerprint _ ) respectively as the leftmost and the rightmost @xmath109 bits of the encoding of @xmath64 .",
    "the main data structures are two tables @xmath147 and @xmath148 , both of which are indexed by @xmath109-bit fingerprints .",
    "more precisely , @xmath147 has an entry indexed by each left fingerprint , while @xmath148 has an entry indexed by each right fingerprint .",
    "the entry of @xmath147 , associated to the left fingerprint @xmath149 , consists of a list of all the right fingerprints @xmath150 such that the concatenation @xmath151 is a read in the input set .",
    "the role of @xmath148 is symmetrical .",
    "the purpose of those tables is that they allow for a very fast labeling of each read into unspliced or perfectly spliced reads .",
    "in fact , a read @xmath64 is unspliced iff both the entry of @xmath147 indexed by its left fingerprint and the entry of @xmath152indexed by its right fingerprint are lists with only one element .",
    "moreover , let @xmath149 be a left fingerprint of some reads , let @xmath153 and @xmath154 be two fingerprints in the list of @xmath155indexed by @xmath149 , such that the first character of @xmath153 is different from that of @xmath154 .",
    "then the two reads @xmath156 and @xmath157 are perfectly spliced . also , constructing @xmath155and @xmath152requires time proportional to",
    "the number of the input reads .",
    "the procedure @xmath159 described in algorithm  [ alg : build - chains ] takes as input a set @xmath62 of rna - seq reads and produces the set @xmath158 of all maximal chains that can be obtained from @xmath62 .",
    "let @xmath160 be the set of the _ unspliced _ reads .",
    "the algorithm selects any read @xmath64 of @xmath106 and tries to find a _",
    "right extension _ of @xmath64 , that is another unspliced read @xmath161 such that @xmath162 .",
    "afterwards the algorithm iteratively looks for a right extension of @xmath161 , until such a right extension no longer exists .",
    "then , the algorithm iteratively looks for a left extension of @xmath64 , while it is possible .    also , the time required by this procedure is proportional to the number of unspliced reads .",
    "in fact , each unspliced read is considered only once , and finding the left or right extension of a read @xmath64 can be performed in constant time . at the end",
    ", we will merge all pairs of chains whose strings have an overlap at least @xmath73 bases long , or one is a substring of the other .",
    "we recall that the maximal chains are the vertices of the isoform graph we want to build .",
    "@xmath163 ; @xmath164 is _",
    "_ unspliced__@xmath165 ;      our algorithm computes the arcs of the output graph using the set @xmath107 of _ perfectly spliced _ reads and the set @xmath158 of maximal chains computed in the previous step .",
    "more precisely , given a perfectly spliced read @xmath64 , we denote with @xmath166 and @xmath167 the set of maximal chains that are , respectively , left - linked and right - linked by @xmath64 .",
    "moreover each such pair will be an arc of the graph .",
    "let @xmath62 be an instance of sgr originating from an expressed region @xmath34 .",
    "we can prove that a simple polynomial time variant of our method computes a splicing graph @xmath138 that is isomorphic to the true isoform graph , when @xmath62 is a good instance .",
    "more precisely , @xmath62 is a _ good _ instance if it is solvable and ( iii ) for each isoform @xmath29 there exists a sequence @xmath168 of reads such that each position of @xmath29 is covered by some read in @xmath169 ( i.e. @xmath33 is equal to the fusion of @xmath170 ) and @xmath171 for each @xmath172 .",
    "first of all , notice that two reads @xmath110 and @xmath111 with overlap at least @xmath73 can be extracted from the same isoform .",
    "let us build a graph @xmath57 whose vertices are the reads and an arc goes from @xmath110 to @xmath111 if and only if @xmath173 and there exists no read @xmath174 such that @xmath175 and @xmath176 . by the above observation and by condition ( iii )",
    "there is a 1-to-1 mapping between maximal paths in such graph and isoforms and the string of an isoform is equal to the fusion of the reads of the corresponding path .",
    "compute the set @xmath177 of all @xmath66-mers that are substrings of the string of some isoforms . then classify all reads of @xmath177 into unspliced , perfectly spliced and ( non - perfectly ) spliced reads , just as in our method .",
    "notice that the halves of each perfectly spliced read are the start or the end of a block .",
    "assemble all unspliced reads into chains where two consecutive reads have overlap @xmath178 ( each unspliced read belongs to exactly one chain ) , using the putative start / end @xmath73-mers computed in the previous step to trim the sequences of each block . at the end , each perfectly spliced read links two blocks of the splicing graph .",
    "we omit the proof that this algorithm computes the isoform graph .",
    "we will consider here what happens when the input instance does not satisfy the requirements of a good instance .",
    "there are at least two different situations that we will have to tackle : data errors and insufficient coverage .",
    "one of the effects of the chain merging phase is that most errors are corrected .",
    "in fact the typical effect of a single - base error in a read @xmath64 is the misclassification of @xmath64 as spliced instead of unspliced , shortening or splitting some chains . anyway , as long as there are only a few errors , there exist some overlapping error - free unspliced reads that span the same block as the erroneous read .",
    "those unspliced reads allow for the correction of the error and the construction of the correct chain spanning the block .",
    "notice that the chain merging also lessens the impact of partial coverage  that is when we do not have all possible @xmath66-mers of a block .",
    "when working under full coverage , we can identify a sequence of reads spanning a block and such that two consecutive reads have overlap equal to @xmath178 , while the chain merging step successfully reconstruct the blocks with reads overlapping with at least @xmath73 characters .",
    "a similar idea is applied to pairs of reads @xmath110 , @xmath111 with @xmath179 and that are likely to span more than one block .",
    "those reads can be detected by analyzing the hash tables . in this case",
    "a set of additional reads , compatible with the fusion of @xmath110 and @xmath111 is added to the input set , obtaining an enriched set which includes the perfectly spliced reads required to correctly infer the junction , even when the original reads have low coverage .",
    "also the fact that the definition of perfectly spliced read asks for two reads with the same left ( or right ) fingerprint , makes our approach more resistant to errors , as a single error is not sufficient to generate an arc in the splicing graph .",
    "finally , we point out that our approach allows for snp detection .",
    "the main problem is being able to distinguish between errors and snps : let us consider an example that illustrates a strategy for overcoming this problem .",
    "let @xmath180 be an exon containing a snp , that is @xmath181 can be @xmath182 or @xmath183 , where @xmath184 and @xmath87 are two strings and @xmath185 , @xmath22 are two characters .",
    "moreover notice that , since this situation is a snp , roughly the same number of reads support @xmath182 as @xmath183 .",
    "therefore , as an effect of our read enrichment step , there are two reads @xmath110 and @xmath111 s.t .",
    "@xmath110 supports @xmath182 and @xmath111 supports @xmath183 , and @xmath186 or @xmath187 .",
    "equivalently , @xmath110 and @xmath111 are two spliced reads supporting the snp .",
    "this case can be easily and quickly found examining the list of reads sharing the left ( or right ) fingerprints and then looking for a set of reads supporting the snp ( again exploiting the fact that the fingerprint of a half of the reads in the set is known ) .      when compared with approaches based on de bruijn graphs , our method is stable w.r.t .",
    "repeated sequences shorter than @xmath73 , that is our method is not negatively influenced by those short repeats .",
    "let us state formally this property .",
    "an algorithm to solve the sgr problem is _",
    "@xmath188-stable _ if and only if we obtain a new isoform set @xmath189 from @xmath35 by disambiguating each @xmath188-long substring that appears in more than one isoform but originates from different parts of the string coding region , then the graph obtained from @xmath35 is isomorphic to that obtained from @xmath189 .",
    "notice that de brujin graphs are highly sensitive to this case , as they must merge @xmath188-long repetitions into a single vertex . on the other hand ,",
    "our approach can avoid merging @xmath190-long repetitions , as the chain construction step is based on finding @xmath73-long identical substrings in the input reads . validating this property",
    "is one of the features of our experimental analysis .",
    "let us consider the following example .",
    "let @xmath191 and @xmath192 be respectively a block of gene @xmath193 and @xmath27 , therefore @xmath194 and @xmath194 belong to two different weakly connected components of the isoform graph .",
    "assume that @xmath47 is a sequence of length @xmath195 , where @xmath188 is the parameter length used in the construction of de brujin graphs ( i.e.  the vertices correspond to @xmath188-mers ) , and consider the case where reads coming from both genes are given in input to compute a splicing graph . if the instance is good , our approach is able to reconstruct the isoform graph , while a typical algorithm based on de brujin graphs would have a single vertex for @xmath79 .",
    "notice also that the resulting graph would be acyclic , hence the commonly used technique of detecting cycles in the graph to determine if there are duplicated strings is not useful .",
    "we have run our experimental analysis on simulated ( and error - free ) rna - seq data obtained from the transcript isoforms annotated for a subset of @xmath196 genes extracted from the @xmath197 encode regions used as training set in the egasp competition ( we refer the interested reader to  @xcite for the complete list of regions and genes ) .",
    "we have chosen those genes because they are well annotated and , at the same time , are considered quite hard to be analyzed by tools aiming to compute a gene structure , mainly due to the presence of repeated regions . moreover",
    ", the presence of high similar genes makes this set very hard to be analyzed as a whole .",
    "also , we decided to focus on a relatively small number of ( hard to analyze ) genes so that we could manually inspect the results to determine the causes of incorrect predictions .",
    "a primary goal of our implementation is to use only a limited amount of memory , since this is the main problem with currently available programs  @xcite .",
    "in fact , we have run our program on a workstation with two quad - core intel xeon 2.8ghz processors and 12 gb ram . even on the largest dataset",
    ", our program has never used more @xmath198 seconds or more than @xmath199 mb of memory .",
    "our implementation is available under agplv3 at http://algolab.github.com / rna - seq - graph/.    now let us detail the experiments . for each of the @xmath196 encode genes , the set of the annotated full - length transcripts has been retrieved from ncbi genbank . from those transcripts",
    "we have extracted two sets of @xmath109bp substrings corresponding to our simulated reads .",
    "the first set consists of all possibile @xmath109-mers and corresponds to the maximum possible coverage ( _ full coverage _ dataset ) , while the second set consists of a random set of @xmath109-mers simulating an @xmath200x coverage ( _ low coverage _",
    "dataset ) . in the first experiment",
    "we have analyzed the behavior on the full coverage dataset where data originating from each gene have been elaborated separately and independently .",
    "the second experiment is identical to the first , but on the low coverage dataset .",
    "finally , the third experiment has been run on the whole full coverage dataset , that is all reads have been elaborated together and without any indication of the gene they were originating from .",
    "notice that the whole full coverage dataset consists of @xmath201 million unique @xmath109bp simulated reads .",
    "for each input gene , the true isoform graph has been reconstructed from the annotation . to evaluate how much the splicing graph computed is similar to the isoform graph ,",
    "we have designed a general procedure to compare two labeled graphs , exploiting not only the topology of the graph , but also the labeling of each vertex with the goal of not penalizing small differences in the labels ( which corresponds to a correct detection of the as events and a mostly irrelevant error in computing the nucleotide sequence of a block ) . due to space constraints , we omit the details of the graph comparison procedure .    in all experiments ,",
    "the accuracy of our method is evaluated by two standard measures , _ sensitivity _ ( sn ) and _ positive predictive value _ ( ppv ) considered at vertex and arc level .",
    "sensitivity is defined as the proportion of vertices ( or arcs ) of the isoform graph that have been correctly predicted by a vertex ( or arc ) of the computed splicing graph , while ppv is the proportion of the vertices ( or arcs ) of the splicing graph that correctly predict a vertex ( or an arc ) of the isoform graph .",
    "the goal of the first experiment ( each gene separately , full coverage ) is to show the soundness of our approach , since obtaining satisfying results under full coverage is a requisite even for a prototype .",
    "more precisely our implementation has perfectly reconstructed the isoform graph of @xmath202 genes ( out of @xmath196 ) , that is sn and ppv are @xmath203 both at vertex and arc level .",
    "notice that the input instances are usually not good instances , mostly due to the presence of short blocks or relatively long repeated regions , therefore we have no guarantee of being able to reconstruct the isoform graph .",
    "moreover we have obtained average sn and ppv values that are @xmath204 and @xmath205 at vertex level , respectively , and @xmath206 and @xmath207 at arc level , respectively .",
    "also , the median values of sn and ppv are @xmath208 and @xmath203 at vertex level , @xmath204 and @xmath209 at arc level , respectively .",
    "the second experiment ( separated gene , @xmath200x coverage ) is to study our method under a more realistic coverage . in this case",
    ", we have perfectly reconstructed the isoform graph of @xmath210 genes ( out of @xmath196 ) , and we have obtained average sn and ppv values that are respectively @xmath211 , @xmath208 at vertex level and @xmath212 , @xmath213 at arc level .",
    "the median values of sn and ppv are @xmath214 and @xmath203 at vertex level , @xmath215 and @xmath208 at arc level , respectively .    the main goal of the third experiment ( _ whole dataset _ , full coverage )",
    "is to start the study of the scalability of our approach towards a genome - wide scale , determining if repetitions that occur in different genes are too high obstacles for our approach .",
    "a secondary goal is to determine if our implementation is stable , that is the computed splicing graph is not too different from the disjoint union of those computed in the first experiment . in this experiment",
    "the expected output of is a large isoform graph @xmath216 with @xmath217 vertices and @xmath218 arcs , with a 1-to-1 mapping between connected components and input genes . to determine such mapping ,",
    "we have used a strategy based on blast  @xcite , aligning labels of the vertices and the genomic sequences . due to space constraints ,",
    "we omit the description of such strategy , but we report that only @xmath219 connected component have been mapped to more than one gene  @xmath220 of them are genes with very similar sequence composition ( i.e. ctag1a , ctag1b and ctag2 ) .    in practice , such a 1-to-1 mapping exists for almost all components .",
    "moreover only @xmath221 genes have been associated to more than one connected components .",
    "overall results are quite similar to those of the first experiment .",
    "in fact , the number of correctly identified vertices goes from @xmath222 ( first experiment ) to @xmath223 ( third experiment ) .",
    "similarly , the number of correctly identified arcs goes from @xmath224 to @xmath225  the quality of our predictions is only barely influenced by the fact that the program is run on the data coming from @xmath196 different genes .",
    "the overall vertex sensitivity is @xmath226 , the vertex positive predicted value is @xmath227 , while the arc sensitivity is @xmath228 and the arc positive predicted value is @xmath229 . figure  [ fig : pogz ] shows the isoform graph and the predicted graph for the gene pogz .",
    "the final part of our analysis is a comparison with trinity  @xcite  the most advanced available tool for full - length transcript reconstruction from rna - seqs without a reference genome , to determine how much it is stable .",
    "we have run trinity on the two full coverage datasets , corresponding to the first and third experiments . since trinity computes transcripts and not the splicing graph",
    ", we use the variation of number of predicted full - lengths transcripts as a proxy for the ( in)stability of the method .",
    "we observed that , for the two datasets , trinity has predicted @xmath230 and @xmath231 full - length transcripts ( on the genes from which the simulated read are generated , there are @xmath232 annotated transcripts ) . the variation is significant and hints at a desired property of our algorithm that is not shared with other state - of - the - art tools .                c.  trapnell , b.  a. williams , g.  pertea , a.  mortazavi , et al .",
    "`` transcript assembly and quantification by rna - seq reveals unannotated transcripts and isoform switching during cell differentiation , '' _ nature biotechnology _ , vol .",
    "28 , no .  5 , pp . 516520 , 2010 .",
    "m.  nicolae , s.  mangul , i.  i. mandoiu , and a.  zelikovsky , `` estimation of alternative splicing isoform frequencies from rna - seq data . '' _",
    "algorithms for molecular biology : amb _ , vol .  6 , no .  1 , p.  9",
    ", 2011 .",
    "s.  heber , m.  a. alekseyev , s .- h .",
    "sze , h.  tang , and p.  a. pevzner , `` splicing graphs and est assembly problem , '' in _ proc .",
    "10th int .",
    "conf .  on intelligent systems for mol .",
    "biology ( ismb ) _ , vol .",
    "18 , pp . 181188 , 2002 .",
    "v.  lacroix , m.  sammeth , r.  guig , and a.  bergeron , `` exact transcriptome reconstruction from short sequence reads , '' in _ proc .",
    "8th int .",
    "workshop on algorithms in bioinformatics ( wabi ) _ , ser .",
    "lncs , vol .",
    "5251.1em plus 0.5em minus 0.4em springer , 2008 , pp",
    ". 5063 .",
    "m.  guttman , g.  manuel , j.  levin , j.  donaghey , et al .",
    "`` from ab initio reconstruction of cell type ",
    "specific transcriptomes in mouse reveals the conserved multi - exonic structure of lincrnas , '' _ nature biotechnology _ ,",
    "503510 , 2010 ."
  ],
  "abstract_text": [
    "<S> next - generation sequencing ( ngs ) technologies allow new methodologies for alternative splicing ( as ) analysis . </S>",
    "<S> current computational methods for as from ngs data are mainly focused on predicting splice site junctions or de novo assembly of full - length transcripts . </S>",
    "<S> these methods are computationally expensive and produce a huge number of full - length transcripts or splice junctions , spanning the whole genome of organisms . thus summarizing such data into the different gene structures and as events of the expressed genes </S>",
    "<S> is an hard task .    to face this issue in this paper </S>",
    "<S> we investigate the computational problem of reconstructing from ngs data , in absence of the genome , a gene structure for each gene that is represented by the _ isoform graph _ : we introduce such graph and we show that it uniquely summarizes the gene transcripts . </S>",
    "<S> we define the computational problem of reconstructing the isoform graph and provide some conditions that must be met to allow such reconstruction . </S>",
    "<S> finally , we describe an efficient algorithmic approach to solve this problem , validating our approach with both a theoretical and an experimental analysis .    </S>",
    "<S> [ theorem]lemma [ theorem]proposition [ theorem]observation [ theorem]corollary [ theorem]claim [ theorem]property [ theorem]definition </S>"
  ]
}