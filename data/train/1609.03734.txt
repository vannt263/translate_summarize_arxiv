{
  "article_text": [
    "the block cipher algorithms are a family of cipher algorithms which use symmetric key and work on fixed length blocks of data .",
    "since novembre 26 , 2001 , the block cipher algorithm `` rijndael '' , became the successor of des under the name of `` advanced encryption standard '' ( aes ) .",
    "its designers , joan daemen and vincent rijmen used algebraic tools to give to their algorithm an unequaled level of assurance against the standard statistical techniques of cryptanalysis .",
    "the aes can process data blocks of 128 bits , using cipher keys with lengths of 128 , 192 , and 256 bits  @xcite .",
    "one of the major issues of cryptography is the cryptanalysis of cipher algorithms .",
    "cryptanalysis is the study of methods for obtaining the meaning of encrypted information , without access to the secret information that is normally required .",
    "some mechanisms for breaking codes include differential cryptanalysis , advanced statistics and brute - force .",
    "recent works like @xcite , attempt to use algebraic tools to reduce the cryptanalysis of a block cipher algorithm to the resolution of a system of quadratic equations describing the ciphering structure . as an example ,",
    "nicolas courtois and josef pieprzyk have described the aes-128 algorithm as a system of 8000 quadratic equations with 1600 variables @xcite .",
    "unfortunately , these approaches are infeasible because of the difficulty of solving large systems of equations .",
    "we will also use algebraic tools but in a new way by using boolean functions and their properties .",
    "our aim is to describe a block cipher algorithm as a set of boolean functions then calculate their algebraic normal forms by using the mbius transforms .    in our study",
    ", we will test our approach on the aes algorithm .",
    "our goal is to describe it under the form of systems of boolean functions and to calculate their algebraic normal forms by using the mbius transforms .",
    "the system of equations obtained is more easily implementable and could open new ways to cryptanalysis of the aes .",
    "let be the set @xmath3 and @xmath4 a boolean algebra , then @xmath5 such that @xmath6 and @xmath7 , is a subset of @xmath8 containing all @xmath2-tuples of @xmath9 and @xmath10 .",
    "the variable @xmath11 is called boolean variable if she only accepts values from @xmath12 , that is to say , if and only if @xmath13 or @xmath14 regardless of @xmath7 .",
    "a boolean function of degree @xmath2 with @xmath1 is a function @xmath15 defined from @xmath16 , that is to say built from boolean variables and agreeing to return values only in the set @xmath3 .",
    "for example , the function @xmath17 defined from @xmath18 is a boolean function of degree two with :    @xmath19    let @xmath2 and @xmath20 be two positive integers .",
    "a vector boolean function is a boolean function @xmath15 defined from @xmath21 .",
    "an s - box is a vector boolean function .",
    "finally , we can define a random boolean function as a boolean function @xmath15 whose values are independent and identically distributed random variables , that is to say : @xmath22 = \\frac{1}{2}\\ ] ]    the number of boolean functions is limited and depends on @xmath2 .",
    "thus , there is @xmath23 boolean functions .",
    "similarly , the number of vector boolean functions is limited and depends on @xmath2 and @xmath20 .",
    "thus , there exists @xmath24 vector boolean functions .",
    "if we take , for example , @xmath25 then there exists @xmath26 boolean functions of degree two .",
    "these 16 boolean functions are presented in the table in figure  [ fig:16bool ] page  . among the boolean functions of degree 2 , the best known",
    "are the functions or , and and xor ( see fig .",
    "[ fig : or ] , page  ) , ( see fig .  [",
    "fig : and ] , page  ) and ( see fig .  [",
    "fig : xor ] , page  ) .    [ cols=\"^,^\",options=\"header \" , ]     the weight of the function @xmath15 is @xmath27 .",
    "so we can reduce @xmath15 to the sum of 3 atomic functions @xmath28 , @xmath29 and @xmath30 . the function @xmath31 if and only if @xmath32 , @xmath33 and @xmath34 . from this",
    "we can deduce that the anf of the function @xmath28 can be obtained by expanding the product @xmath35 . applying this reasoning to the functions @xmath29 and",
    "@xmath30 we get the following equation :    @xmath36",
    "after this brief presentation of boolean functions , we have the necessary tools for the development of systems of boolean equations describing the _ advanced encryption standard_.      we have just seen how to generate normal algebraic form ( anf ) of a boolean function",
    ". the presented method is not easily automatable in a computer program .",
    "so we will prefer the use of the mbius transform .",
    "the mbius transform of the boolean function @xmath15 is defined by  @xcite :    @xmath37    with @xmath38 if and only if @xmath39 .",
    "from there , we can define the normal algebraic form of a boolean function @xmath15 in @xmath2 variables :    @xmath40    to better understand the mechanisms involved in the use of the mbius transform , take an example with the ` majparmi3 ` .",
    "this function from @xmath41 is characterized by the truth table shown in figure  [ fig : majparmi3 ] page  .",
    "> p18pt | > p18pt | > p18pt | > p52pt @xmath42 & @xmath43 & @xmath44 & ` majparmi3 ` @xmath9 & @xmath9 & @xmath9 & @xmath9 @xmath9 & @xmath9 & @xmath10 & @xmath9 @xmath9 & @xmath10 & @xmath9 & @xmath9 @xmath9 & @xmath10 & @xmath10 & @xmath10 @xmath10 & @xmath9 & @xmath9 & @xmath9 @xmath10 & @xmath9 & @xmath10 & @xmath10 @xmath10 & @xmath10 & @xmath9 & @xmath10 @xmath10 & @xmath10 & @xmath10 & @xmath10    calculating the mbius transform of the function we get the result of figure  [ fig : rm - mp3 ] page  .     > p10pt | > p10pt | > p10pt | > p52pt > p10pt > p10pt | > p10pt | > p10pt | > p10pt | > p30pt | @xmath42 & @xmath43 & @xmath44 & ` majparmi3 ` & @xmath45 & & @xmath46 @xmath9 & @xmath9 & @xmath9 & @xmath9 & @xmath45 & @xmath9 & @xmath9 & @xmath9 & @xmath9 & @xmath9 @xmath9 & @xmath9 & @xmath10 & @xmath9 & @xmath45 & @xmath9 & @xmath9 & @xmath9 & @xmath9 & @xmath9 @xmath9 & @xmath10 & @xmath9 & @xmath9 & @xmath45 & @xmath9 & @xmath9 & @xmath9 & @xmath9 & @xmath9 @xmath9 & @xmath10 & @xmath10 & @xmath10 & @xmath45 & @xmath10 & @xmath10 & @xmath10 & @xmath10 & @xmath10 @xmath10 & @xmath9 & @xmath9 & @xmath9 & @xmath45 & @xmath9 & @xmath9 & @xmath9 & @xmath9 & @xmath9 @xmath10 & @xmath9 & @xmath10 & @xmath10 & @xmath45 & @xmath10 & @xmath10 & @xmath10 & @xmath10 & @xmath10 @xmath10 & @xmath10 & @xmath9 & @xmath10 & @xmath45 & @xmath10 & @xmath10 & @xmath10 & @xmath10 & @xmath10 @xmath10 & @xmath10 & @xmath10 & @xmath10 & @xmath45 & @xmath10 & @xmath9 & @xmath10 & @xmath9 & @xmath9    after the mbius transform of the function obtained , we take the @xmath47 for which @xmath48 . in our case",
    "we have the triplets @xmath49 , @xmath50 , @xmath51 from which we can deduce the equation :    @xmath52    with the addition corresponding to a ` xor ` and multiplication to a ` and ` .",
    "the implementation of the mbius transform in python is performed by the two functions described in the listing  [ lst : tm ] page  .    .... def xortab(t1 , t2 ) :      \" \" \" takes two tabs t1 and t2 of same lengths and returns t1 xor t2 . \" \" \"      result = ''      for i in xrange(len(t1 ) ) :          result + = str(int(t1[i ] ) ^ int(t2[i ] ) )      return result    def moebiustransform(tab ) :      \" \" \" takes a tab and return tab[0 : len(tab)/2 ] ,      tab[0 : len(tab)/2 ] ^ tab[len(tab)/2 : len(tab ) ] .",
    "usage : moebiustransform(1010011101010100 ) -- > [ 1100101110001010 ] \" \" \"      if len(tab ) = = 1 :          return tab      else :          t1 = tab[0 : len(tab)/2 ]          t2 = tab[len(tab)/2 : len(tab ) ]          t2 = xortab(t1 , t2 )          t1 = moebiustransform(t1 )          t2 = moebiustransform(t2 )          t1 + = t2          return t1 ....      to facilitate the analysis and in particular to try a combinatorial study we will implement a specific presentation for equations thus obtained .",
    "the aes algorithm takes 128 bits as input and provides 128 bits as output .",
    "so we will have boolean functions @xmath53 .",
    "the guiding principle is to generate a file by bit , we will have at the end 128 files .",
    "each file containing the boolean equation of the concerned bit .",
    "in each file , the boolean equation is presented under the form of lines containing sequences of 0 and 1 .",
    "each line describes a monomial of the equation and the transition from one line to another means applying a ` xor ` .    in order to facilitate understanding of the chosen mechanism",
    "we describe the realization of file corresponding to one bit @xmath54 from his equation to the file formalism in figure  [ fig : fichiers_bit ] page  .",
    "we will now apply to the aes the mechanism described above .",
    "the difficulty with our approach is that the encryption functions of the aes algorithm takes 128 bits as input and provides 128 bits as output .",
    "so we will have boolean functions @xmath53 and it is impossible to calculate their truth tables . indeed , in this case , we have @xmath55 possible combinations of 128-bit blocks and the space storage needed to archive these blocks is @xmath56  terabytes .",
    "so we have to find a way to describe the aes encryption functions in the form of boolean functions without using their truth table .",
    "we will now detail the solution implemented for each of the sub - functions of the aes encryption algorithm .",
    "the function ` subbytes ` is a non - linear substitution that works on every byte of the states array using a substitution table ( s - box ) .",
    "this function is applied independently to each byte of the input block .",
    "so , the s - box of the aes is a function taking 8 bits as input and providing 8-bit as output .",
    "so we can describe it as a boolean function @xmath57 .",
    "from there , we can calculate the truth table of the s - box and use the mbius transform for obtain the normal algebraic form of the s - box . then applying the results to the 16 bytes of input block , we get 128 equations , each describing a block bit .",
    "for example , the equation of the processing of the bit @xmath58 by the function ` subbyte ` is given in figure [ fig : bitsubbyte ] page  .",
    "in the ` shiftrows ` function , the bytes of the third column of the state table are shifted cyclically in an offset whose size is dependent on the line number .",
    "the bytes of the first line do not suffer this offset .    for this function , we do not need to calculate specific boolean function .",
    "indeed , the only change made consists to shift bytes in the states array . in our files",
    ", this transformation can be easily solved by using a ` xor ` .",
    "thus , for example , the second byte of the status table becomes the sixth byte after the application of ` shiftrows ` .",
    "this results in the following lines :    0000000000000000**10000000**00000000000000000000000000000000000000000000000000000000**01000000**00000000000000000000000000000000000000000000000000000000**00100000**00000000000000000000000000000000000000000000000000000000**00010000**00000000000000000000000000000000000000000000000000000000**00001000**00000000000000000000000000000000000000000000000000000000**00000100**00000000000000000000000000000000000000000000000000000000**00000010**00000000000000000000000000000000000000000000000000000000**00000001**0000000000000000000000000000000000000000    in the end , the equations of the function ` shiftrows ` for the 128-bit of the block @xmath59 are :    @xmath60      the function ` mixcolumns ` acts on the states array , column by column , treating each column as a polynomial with four terms . each column is multiplied by a square matrix . for each column",
    "we have :    @xmath61    thus , for the first byte of the column we have the equation :    @xmath62    as in @xmath63 , @xmath64 is the identity for multiplication , this equation becomes :    @xmath65    we have the same simplification for all equations describing the multiplication of the column of the states array by the square matrix .",
    "therefore we only need to calculate truth tables for multiplication by @xmath66 and @xmath67 in @xmath63 .    for example",
    ", the equations of the bits @xmath68 to @xmath58 are the following :    @xmath69      to recall , in the algorithm of the aes-128 , @xmath70 words and @xmath71 words , with 1 word = 4 bytes = 32 bits .",
    "the function ` addroundkey ` adds a round key to the state table by a simple bitwise ` xor ` operation .",
    "these rounds keys are computed by a key expansion function .",
    "this latter generates a set of @xmath72 words of 32 bit that to say 11 keys of 128 bits derived from the first key .",
    "the algorithm used for the expansion of the key involves two functions ` subword ` and ` rotword ` together with a round constant ` rcon ` .",
    "the generation of a global boolean function for the key expansion algorithm is impossible because the generation of the key for the round @xmath2 involves the key of the round @xmath73 .",
    "this interweaving of rounds keys does not allow us to generate a global boolean function .",
    "on the other hand it is possible to generate a boolean function corresponding to the calculation of a key of one round .    the first word @xmath74 of the round key @xmath75 is calculated according to the following equation : @xmath76 with @xmath77 and @xmath78 respectively corresponding to the ` subword ` and ` rotword ` functions .",
    "the following words @xmath79 , @xmath80 and @xmath81 are calculated according to the following equation : @xmath82 with @xmath83 .",
    "the ` subword ` and ` rotword ` functions are built on the same principle as the ` subbytes ` and ` shiftrows ` functions , thus we can reuse the methodology finalized previously .    in python language ,",
    "the word generation function is written according to the following code ( see listing  [ lst : keyword ] , p.  ) .    .... def",
    "generateword(num ) :      if ( num < 4 ) :          w = generategenericword(wordsize*num , ' x ' )      if ( num > = 4 ) :          if ( ( num % 4 ) = = 0 ) :              w = generateword(3 )              w = rotword(w )              w = subword(w , rconlist[(num/4)-1 ] )              w = xorwords(w , generateword(0 ) )          else :              w = generateword(num-1 )              w = xorwords(w , generateword(num%4 ) )      return w ....    in this code , several scenarios are considered .",
    "the function ` generateword ` takes in parameter the word number to generate , we know that this number is between 0 and 43",
    ". if the number is less than 4 , the function returns the boolean identity function as the first key used by the aes is the encryption key .",
    "if the number to modulo 4 is zero , the function returns a boolean functions describing the composition of ` subword ` and ` rotword ` functions and the application of the ` xor ` with the ` rcon ` constant .",
    "finally , if the number to modulo 4 is not zero , the function returns the boolean function describing the ` xor ` with the corresponding word in the previous round .",
    "we now have a boolean function describing a round expansion of the key .",
    "as we have seen , the key expansion algorithm involves at round @xmath2 the keys of round @xmath73 . to integrate our boolean function in the encryption process of the aes , we must , at every round , add a temporary variable corresponding to the key of the previous round .    as an example , the boolean equation of the bit @xmath84 of the fourth word on the 44 words generate by the key expansion process , is given in the figure [ fig : word ] page  .",
    "we have now a boolean function for each function ` subbytes ` @xmath85 , ` shiftrows ` @xmath86 and ` mixcolumns ` @xmath87 . in the arrangement of one round , these functions are combined .",
    "so for a 128-bit block @xmath88 as output of the ` addroundkey ` function , the block @xmath89 as output of the combination of these three functions is such that : @xmath90    to realize the files as described above , it is necessary to reduce the composition of these three functions in one boolean equation . to achieve this",
    ", we just have to replace each input variable of a function by the output value of the previous function using the following equation : @xmath91    in python language , the round generation function is written according to the following code ( see listing  [ lst : round ] , p.  ) .",
    ".... def writeroundenc(numround , equasb , equasr , equamc ) :      printcolor ( ' # # round%s ' % numround , green )      resultsr = [ ]      resultmc = [ ]      for i in xrange(blocksize ) :          equasr[i ] = equasr[i].split ( ' _ ' )          resultsr.append(equasb[int(equasr[i][1 ] ) ] )        for i in xrange(blocksize ) :          tmp = ''          for monomial in equamc[i].split('+ ' ) :              tmp + = resultsr[int(monomial.split('_')[1 ] ) ]              tmp + = ' + '          resultmc.append(tmp.rstrip('+ ' ) )      binmon = generatebinarymonomes(resultmc )      return resultmc ....    the boolean equation of one round of the aes for the bit @xmath84 is given in the figure [ fig : round ] page  .",
    "finally , we can now describe under the form of boolean equations the full process of aes encryption .",
    "the function in python language computing this process is given in listing [ lst : ciphering ] page  .",
    ".... def generateencfullfiles ( ) :      printcolor ( ' # # ciphering process ' , yellow )      createaesfiles('enc ' )      addroundkey(0 , ' enc ' )      writeroundenc(0 , subbytes ( ) , shiftrows ( ) , mixcolumns ( ) )      addroundkey(1 , ' enc ' )      writeroundenc(1 , subbytes ( ) , shiftrows ( ) , mixcolumns ( ) )      addroundkey(2 , ' enc ' )      writeroundenc(2 , subbytes ( ) , shiftrows ( ) , mixcolumns ( ) )      addroundkey(3 , ' enc ' )      writeroundenc(3 , subbytes ( ) , shiftrows ( ) , mixcolumns ( ) )      addroundkey(4 , ' enc ' )      writeroundenc(4 , subbytes ( ) , shiftrows ( ) , mixcolumns ( ) )      addroundkey(5 , ' enc ' )      writeroundenc(5 , subbytes ( ) , shiftrows ( ) , mixcolumns ( ) )      addroundkey(6 , ' enc ' )      writeroundenc(6 , subbytes ( ) , shiftrows ( ) , mixcolumns ( ) )      addroundkey(7 , ' enc ' )      writeroundenc(7 , subbytes ( ) , shiftrows ( ) , mixcolumns ( ) )      addroundkey(8 , ' enc ' )      writeroundenc(8 , subbytes ( ) , shiftrows ( ) , mixcolumns ( ) )      addroundkey(9 , ' enc ' )      writefinalroundenc(9 , subbytes ( ) , shiftrows ( ) )      addroundkey(10 , ' enc ' )      writeendflag('enc ' )      printcolor ( ' # # files generated ' , yellow ) ....      we will now detail the solution implemented for each of the sub - functions of the aes decryption algorithm .",
    "the aes deciphering algorithm uses the ` invshiftrows ` , ` invsubbytes ` and ` invmixcolumns ` functions .",
    "those functions are respectively the inverse functions of ` shiftrows ` , ` subbytes ` and ` mixcolumns ` functions , used in the ciphering process .",
    "the pseudo code of the decryption function can be written as follows ( see fig .  [",
    "fig : decipherpseudocode ] , page  ) , ` nb ` corresponding to the 32-bits words numbe and ` nr ` corresponding to the rounds number used in the algorithm .",
    "byte state[4,nb ] state @xmath92 in addrounkey(state , w[nr*nb , ( nr+1)*nb-1 ] ) invshiftrows(state ) invsubbytes(state ) addroundkey(state , w[round*nb , ( round+1)*nb-1 ] ) invmixcolumns(state )",
    "invshiftrows(state ) invsubbytes(state ) addrounkey(state , w[0 , nb-1 ] ) state    the internal mechanisms to the three functions used in the round during decryption are similar to encryption functions .",
    "so we use the same reasoning as the one implemented earlier to generate the corresponding boolean equations .",
    "for example , the boolean equation of the three transformations used in the deciphering process for the bit @xmath84 are given in figure [ fig : threefunctions ] page  .",
    "the key expansion function is the same for both ciphering and deciphering process .",
    "boolean equations we built previously are reusable .",
    "we have now a boolean equation for each of ` invsubbytes ` @xmath93 , ` invshiftrows ` @xmath94 and ` invmixcolumns ` @xmath95 functions .",
    "however , unlike the arrangement of intermediate rounds of the encryption process , these three functions are not combined among them .",
    "indeed , the function ` addroundkey ` no longer occurs at the end of the round but sits between ` invsubbytes ` and ` invmixcolumns ` functions .",
    "thus , for a block @xmath88 and a key @xmath96 as input of the round , the block @xmath89 as output is such that : @xmath97    to reduce the boolean equations , we will not therefore be able to combine the equations of ` invsubbytes ` and ` invshiftrows ` . as before , to achieve this we just have to replace each input variable of a function with its output value of the previous function using the following equation : @xmath98    in python language , the round generation function is written according to the following code ( see listing  [ lst : invround ] , p.  ) .",
    ".... def writerounddec(numround , equasb , equasr ) :      printcolor ( ' # # round % s ' % numround , green )      resultsr = [ ]      for i in xrange(blocksize ) :          equasr[i ] = equasr[i].split ( ' _ ' )          resultsr.append(equasb[int(equasr[i][1 ] ) ] )      binmon = generatebinarymonomes(resultsr )      return resultsr ....    as for the encryption process , we can now describe under the form of boolean equations the full process of the aes decryption .",
    "the function in python language computing this process is given in listing [ lst : deciphering ] page  .",
    ".... def generatedecfullfiles ( ) :      printcolor ( ' # # deciphering process ' , yellow )      createaesfiles('dec ' )      addroundkey(10 , ' dec ' )      writerounddec(9 , invsubbytes ( ) , invshiftrows ( ) )      addroundkey(9 , ' dec ' )      writeinvmixcolumns(9 )      writerounddec(8 , invsubbytes ( ) , invshiftrows ( ) )      addroundkey(8 , ' dec ' )      writeinvmixcolumns(8 )      writerounddec(7 , invsubbytes ( ) , invshiftrows ( ) )      addroundkey(7 , ' dec ' )      writeinvmixcolumns(7 )      writerounddec(6 , invsubbytes ( ) , invshiftrows ( ) )      addroundkey(6 , ' dec ' )      writeinvmixcolumns(6 )      writerounddec(5 , invsubbytes ( ) , invshiftrows ( ) )      addroundkey(5 , ' dec ' )      writeinvmixcolumns(5 )      writerounddec(4 , invsubbytes ( ) , invshiftrows ( ) )      addroundkey(4 , ' dec ' )      writeinvmixcolumns(4 )      writerounddec(3 , invsubbytes ( ) , invshiftrows ( ) )      addroundkey(3 , ' dec ' )      writeinvmixcolumns(3 )      writerounddec(2 , invsubbytes ( ) , invshiftrows ( ) )      addroundkey(2 , ' dec ' )      writeinvmixcolumns(2 )      writerounddec(1 , invsubbytes ( ) , invshiftrows ( ) )      addroundkey(1 , ' dec ' )      writeinvmixcolumns(1 )      writerounddec(0 , invsubbytes ( ) , invshiftrows ( ) )      addroundkey(0 , ' dec ' )      writeendflag('dec ' )      printcolor ( ' # # files generated ' , yellow ) ....      we now have two systems of boolean equations corresponding to the encryption process and decryption of aes .",
    "these two systems each have :    * 128 equations , one for each bit block ; * 1280 variables for the input block ; * 1280 variables for the key .",
    "concerning the variables of keys , the fact that we have a boolean equation by round key involve that we have a set of 128 new variables at each round that is 1280 variables for the aes-128 .",
    "each of the variables of the @xmath2 round key being described in terms of variables of the @xmath73 round key . consequently and due to the ` xor ` bitwise operation between the round key and the bits resulting from the round function , we are obliged to insert a new set of 128 variables to describe the block transformation at each round .",
    "finally we described the aes encryption and decryption process in the form of two systems of boolean equations with 128 equations and 2560 variables .",
    "this mechanism allows us then to describe all of the aes encryption process in the form of files using the same representation as described above .",
    "so we have 128 files , one by bit of block . in these files ,",
    "each line describes a monomial and the transition from one line to the next is done by the ` xor ` operation .    to implement this mechanism of the description of the aes encryption algorithm and generate the 128 files , we have developed and used a python script based on that described earlier in our presentation of aes .",
    "the main program , ` aes_equa.py ` , offers the possibility of one hand to generate the files for aes ciphering and deciphering functions with the ` generateencfullfiles ( ) ` and ` generatedecfullfiles ( ) ` functions and on the other hand , to control that the encryption and the decryption obtained from files is consistent .",
    "thus , the functions ` controlencfullfiles ( ) ` and ` controldecfullfiles ` performs respectively the encryption and the decryption from the previously generated files .",
    "the function ` controlencfullfiles ( ) ` takes as input a block of 128 bits of plain text and a 128-bit block of key while the function ` controldecfullfiles ( ) ` takes as input a block of 128 bits of cipher text and a a 128-bit block of key .",
    "the selected blocks are those provided as test vectors in appendix b of fips 197 @xcite .",
    "the obtained results correspond to those provided in the fips : files we generated well represent the aes encryption and decryption algorithm .",
    "the result obtained by the function ` generateencfullfiles ( ) ` is shown in figure  [ lst : generate_encfiles ] page   and the result obtained by the ` controlencfullfiles ( ) ` is shown in the listing  [ lst : control_encfiles ] page  .",
    "the control function ` controlencfullfiles ( ) ` injects in the boolean functions the 128 initial variables corresponding to the clear text block and the 1280 variables corresponding to the key blocks of each round .",
    "0.38    .... ./aes_equa.py # # ciphering process # # create directory aes_files # # addroundkey0 # # round0 # # addroundkey1 # # round1 # # addroundkey2 # # round2 # # addroundkey3 # # round3 # # addroundkey4 # # round4 # # addroundkey5 # # round5 # # addroundkey6 # # round6 # # addroundkey7 # # round7 # # addroundkey8 # # round8 # # addroundkey9 # # round9 # # addroundkey10 # # files generated ....    0.58    ....",
    "./aes_equa.py # # clear block 00112233445566778899aabbccddeeff # # key block 000102030405060708090a0b0c0d0e0f # # addroundkey0 00102030405060708090a0b0c0d0e0f0 32 # # round0 5f72641557f5bc92f7be3b291db9f91a 32 # # addroundkey1 89d810e8855ace682d1843d8cb128fe4 32 # # round1 ff87968431d86a51645151fa773ad009 32 # # addroundkey2 4915598f55e5d7a0daca94fa1f0a63f7 32 # # round2 4c9c1e66f771f0762c3f868e534df256 32 # # addroundkey3 fa636a2825b339c940668a3157244d17 32 # # round3 6385b79ffc538df997be478e7547d691 32 # # addroundkey4 247240236966b3fa6ed2753288425b6c 32 # # round4 f4bcd45432e554d075f1d6c51dd03b3c 32 # # addroundkey5 c81677bc9b7ac93b25027992b0261996 32 # # round5 9816ee7400f87f556b2c049c8e5ad036 32 # # addroundkey6 c62fe109f75eedc3cc79395d84f9cf5d 32 # # round6 c57e1c159a9bd286f05f4be098c63439 32 # # addroundkey7 d1876c0f79c4300ab45594add66ff41f 32 # # round7 baa03de7a1f9b56ed5512cba5f414d23 32 # # addroundkey8 fde3bad205e5d0d73547964ef1fe37f1 32 # # round8 e9f74eec023020f61bf2ccf2353c21c7 32 # # addroundkey9 bd6e7c3df2b5779e0b61216e8b10b689 32 # # round9 7ad5fda789ef4e272bca100b3d9ff59f 32 # # addroundkey10 69c4e0d86a7b0430d8cdb78070b4c55a 32 69c4e0d86a7b0430d8cdb78070b4c55a ( fips result ) ....      according to the same principle as for boolean functions of encryption , the result obtained by the function ` generatedecfullfiles ( ) ` is shown in the listing  [ lst : generate_decfiles ] page   and the obtained result from the ` controldecfullfiles ( ) ` function is shown in the listing  [ lst : control_decfiles ] page  .",
    "0.38    .... ./aes_equa.py # # deciphering process # # create directory aes_files # # addroundkey10 # # round 9 # # addroundkey9 # # invmixcolumns 9 # # round 8 # # addroundkey8 # # invmixcolumns 8 # # round 7 # # addroundkey7 # # invmixcolumns 7 # # round 6 # # addroundkey6 # # invmixcolumns 6 # # round 5 # # addroundkey5 # # invmixcolumns 5 # # round 4 # # addroundkey4 # # invmixcolumns 4 # # round 3 # # addroundkey3 # # invmixcolumns 3 # # round 2 # # addroundkey2 # # invmixcolumns 2 # # round 1 # # addroundkey1 # # invmixcolumns 1 # # round 0 # # addroundkey0 # # files generated ....    0.58    .... ./aes_equa.py # # cipher block 69c4e0d86a7b0430d8cdb78070b4c55a # # key block 000102030405060708090a0b0c0d0e0f # # addroundkey10 7ad5fda789ef4e272bca100b3d9ff59f 32 # # round9 bd6e7c3df2b5779e0b61216e8b10b689 32 # # addroundkey9 e9f74eec023020f61bf2ccf2353c21c7 32 # # invmixcolumns9 54d990a16ba09ab596bbf40ea111702f 32 # # round8 fde3bad205e5d0d73547964ef1fe37f1 32 # # addroundkey8 baa03de7a1f9b56ed5512cba5f414d23 32 # # invmixcolumns8 3e1c22c0b6fcbf768da85067f6170495 32 # # round7 ... # # round3 fa636a2825b339c940668a3157244d17 32 # # addroundkey3 4c9c1e66f771f0762c3f868e534df256 32 # # invmixcolumns3 3bd92268fc74fb735767cbe0c0590e2d 32 # # round2 4915598f55e5d7a0daca94fa1f0a63f7 32 # # addroundkey2 ff87968431d86a51645151fa773ad009 32 # # invmixcolumns2 a7be1a6997ad739bd8c9ca451f618b61 32 # # round1 89d810e8855ace682d1843d8cb128fe4 32 # # addroundkey1 5f72641557f5bc92f7be3b291db9f91a 32 # # invmixcolumns1 6353e08c0960e104cd70b751bacad0e7 32 # # round0 00102030405060708090a0b0c0d0e0f0 32 # # addroundkey0 00112233445566778899aabbccddeeff 32 00112233445566778899aabbccddeeff ( fips result ) ....    in both cases , encryption and decryption , the results we obtain by using our files to cipher and to decipher blocks are conform to those described in the fips 197 .",
    "so our boolean equation system describing the aes algorithm is right .",
    "after presenting briefly the boolean algebra , boolean functions and two of their presentations , we have developed a process that allows us to translate the aes encryption and decryption algorithms in boolean functions",
    ". then we defined a mode of representation of these boolean functions in the form of computer files .",
    "finally , we have developed a program to implement this process and to check that the expected results are consistent with those provided in the fips .    in the end , we got a two new systems of boolean equations , the first one describing the entire ciphering process while the second describes the entire deciphering process of the _ advanced encryption standard _ and each one including 128 equations and @xmath99 variables",
    ".    the next step could be to search , through statistical and combinatorial analysis , new ways to cryptanalyse the aes .",
    "either by finding a solution to resolve our equations system either by using statistical bias exploitable with this system .",
    "michel dubois and ric filiol , _ proposal for a new equation system modelling of block ciphers and application to aes 128 _ , proceedings of the 11th european conference on information warfare and security , 2012 .",
    "michel dubois and ric filiol , _",
    "proposal for a new equation system modelling of block ciphers and application to aes 128 - long version _ , pioneer journal of algebra , number theory and its applications , 2012 ."
  ],
  "abstract_text": [
    "<S> one of the major issues of cryptography is the cryptanalysis of cipher algorithms . </S>",
    "<S> cryptanalysis is the study of methods for obtaining the meaning of encrypted information , without access to the secret information that is normally required . </S>",
    "<S> some mechanisms for breaking codes include differential cryptanalysis , advanced statistics and brute - force .    </S>",
    "<S> recent works also attempt to use algebraic tools to reduce the cryptanalysis of a block cipher algorithm to the resolution of a system of quadratic equations describing the ciphering structure .    in our study , we will also use algebraic tools but in a new way : by using boolean functions and their properties . </S>",
    "<S> a boolean function is a function from @xmath0 with @xmath1 , characterized by its truth table . </S>",
    "<S> the arguments of boolean functions are binary words of length @xmath2 . </S>",
    "<S> any boolean function can be represented , uniquely , by its algebraic normal form which is an equation which only contains additions modulo 2  the ` xor ` function  and multiplications modulo 2  the ` and ` function .    </S>",
    "<S> our aim is to describe the aes algorithm as a set of boolean functions then calculate their algebraic normal forms by using the mbius transforms . </S>",
    "<S> after , we use a specific representation for these equations to facilitate their analysis and particularly to try a combinatorial analysis . through this approach </S>",
    "<S> we obtain a new kind of equations system . </S>",
    "<S> this equations system is more easily implementable and could open new ways to cryptanalysis .    </S>",
    "<S> * keywords * : block cipher , boolean function , cryptanalysis , aes </S>"
  ]
}