{
  "article_text": [
    "_ coefficient extraction _ can be seen as a general method for designing algorithms , recently in particular in the area of exact algorithms for various np - hard problems @xcite ( cf .",
    "@xcite for an introduction to exact algorithms ) .",
    "the approach of the method is the following ( see also  @xcite ) :    1 .",
    "define a variable ( the so - called coefficient ) whose value ( almost ) immediately gives the solution of the problem to be solved , 2 .",
    "show that the variable can be expressed by a relatively small formula or circuit over a ( cleverly chosen ) large algebraic object like a ring or field , 3 .",
    "show how to perform operations in the algebraic object relatively efficiently .    in a typical application of the method ,",
    "the first two steps are derived from an existing dynamic programming ( dp ) algorithm , and the third step deploys a carefully selected algebraic isomorphism , such as the discrete fourier transform to extract the desired solution / coefficient .",
    "algorithms based on coefficient extraction have two key advantages over dp algorithms ; namely , they are space - efficient and they parallelise well ( see , for example , @xcite ) .",
    "yet , dp has an advantage if the problem instance is _",
    "sparse_. by this we mean that the number of candidate / partial solutions that need to be considered during dp is small , that is , most entries in the dp table are not used at all . in such a case",
    "we can readily adjust the dp algorithm to take this into account through _ memorization _ so that both the running time and space usage become proportional to the number of partial solutions considered .",
    "unfortunately , it is difficult to parallelise or lower the space usage of memorization .",
    "coefficient extraction algorithms relying on interpolation of sparse polynomials @xcite improve over memorization by scaling proportionally only to the number of _ candidate _ solutions , but their space usage is still not satisfactory ( see also @xcite ) .",
    "this paper aims at obtaining what is essentially the best of both worlds , by investigating the systematic use of homomorphisms to `` hash down '' circuit - based coefficient extraction algorithms so that the domain of coefficient extraction  and hence the running time  matches or improves that of memorization - based dp algorithms , while providing space - efficiency and efficient parallelisation .",
    "the key idea is to take an existing algebraic circuit for coefficient extraction ( over a sparsely populated algebraic domain such as a ring or field ) , and transform the circuit into a circuit over a smaller domain by a homomorphic hash function , and only then perform the actual coefficient extraction .",
    "because the function is homomorphic , by hashing the values at the input gates and evaluating the circuit , the output evaluates to the hash of the original output value . because the function is a hash function , the coefficient to be extracted collides with other coefficients only with negligible probability in the smaller domain , and coefficient extraction can be successfully used on the new ( hashed - down ) circuit .",
    "we call this approach _ homomorphic hashing_.      we study sparse dp / coefficient extraction in three domains : ( a ) the univariate polynomial ring @xmath0 $ ] in section  [ sec : sss ] , ( b ) the group algebra @xmath1 $ ] in section  [ sec : setpart ] and ( c ) the mbius algebra of the subset lattice in section  [ sec : unionhashing ] .",
    "the subject of sparse dp or coefficient extraction is highly motivated and well - studied @xcite . in  @xcite ,",
    "a sparse polynomial interpolation algorithm using exponential space was already given for ( a ) and ( b ) ; our algorithms improve these domains to polynomial space . in  @xcite a polynomial - space algorithm for finding a small multilinear monomial in",
    "@xmath1 $ ] was given . in",
    "@xcite a general study of settings ( a ) and ( b ) was initiated , but sparsity was not addressed .",
    "our main technical contribution occurs with ( c ) and hashing down to the `` solomon algebra '' of a poset .",
    "our methods work for general arithmetic circuits similarly as in @xcite , and most of our algorithms work for counting variants as well .",
    "but , for concreteness , we will work here with specific decision problems .",
    "although we mainly give improvements for sparse variants of these problems , we feel the results will be useful to deal with the general case as well ( as we will see in section  [ sec : setpart ] ) .    [",
    "[ subset - sum ] ] subset sum + + + + + + + + + +    the problem is the following : given a vector @xmath2 and integer @xmath3 , determine whether there exists a subset @xmath4 $ ] such that @xmath5 .",
    "it is known to be solvable @xmath6 time and @xmath7 space  @xcite , and solving it faster , or even in @xmath8 time and polynomial space are interesting open questions  @xcite .",
    "recently , a polynomial space algorithm using @xmath9 time was given in  @xcite .",
    "[ thm : mainsss ] an instance @xmath10 of the problem can be solved    1 .   in @xmath11",
    "expected time and polynomial space , and 2 .   in @xmath12 time and",
    "polynomial space ,    where @xmath13 is the number of distinct sums , i.e. @xmath14\\}|$ ] .    here",
    "it should be noted that standard sparse dp gives an @xmath11 time and space algorithm",
    ". informally stated , our algorithms hash the instances by working modulo randomly chosen prime numbers and applying the algoritm of  @xcite . while interesting on their own , these results may be useful in resolving the above open questions when combined with other techniques .",
    "[ [ linear - sat ] ] linear sat + + + + + + + + + +    the linear sat problem is defined as follows : given a matrix @xmath15 , vectors @xmath16 and @xmath17 , and an integer @xmath18 , determine whether there is there a vector @xmath19 such that @xmath20 and @xmath21 .",
    "variants of linear sat have been studied , perhaps most notably in @xcite , where approximability was studied . in @xcite the fixed parameter tractability was studied for parameterizations of various above guarantees .",
    "there , it was also quoted from @xcite that ( a variant of ) linear sat is `` as basic as satisfiability '' .",
    "it can be observed that using the approach from  @xcite , linear sat can be solved in @xmath22 time and @xmath22 space .",
    "also , using standard `` sparse dynamic programming '' , it can be solved in @xmath23 time and @xmath23 space , where @xmath24 is the rank of @xmath25 .",
    "we obtain the following polynomial - space variants :    [ thm : mainls ] an instance @xmath26 of can be solved by algorithms with constant one - sided error probability in    1 .",
    "@xmath23 time and polynomial space , and 2 .   @xmath27 time and polynomial space .",
    "the first algorithm hashes the input down using a random linear map and afterwards determines the answer using the walsh - hadamard transform .",
    "the second algorithm uses a win / win approach , combining the first algorithm with the fact that an @xmath25 with high rank can be solved with a complementary algorithm .",
    "[ [ satisfiability ] ] satisfiability + + + + + + + + + + + + + +    the cnf - sat problem is defined as follows : given a cnf - formula @xmath28 over @xmath29 variables , determine whether @xmath30 is satisfiable .",
    "there are many interesting open questions related to this problem , a major one being whether it can be solved in time @xmath31 ( the ` strong exponential time hypothesis ' @xcite states this is not possible ) , and another being whether the number of satisfying assignments can be counted in time @xmath31 for some @xmath32 ( e.g. @xcite ) .    a _ prefix assignment _ is an assignment of 0/1 values to the variables @xmath33 for some @xmath34 .",
    "a _ projection _ ( _ prefix projection _ ) of a cnf - formula is a subset @xmath35 $ ] such that there exists an assignment ( prefix assignment ) of the variables such that for every @xmath36 it satisfies @xmath37 if and only if @xmath38 .",
    "an algorithm for cnf - sat running in time linear in the number of _ prefix _ projections can be obtained by standard sparse dp .",
    "however , it is sensible to ask about complexity of cnf - sat if the number of projections is small .",
    "we give a positive answer :    [ thm : maincnf ] satisfiability of a formula @xmath39 can be determined in @xmath40 time and @xmath41 space , where @xmath42 : \\pi \\text { is a projection of } \\phi \\}|$ ] .",
    "we are not aware of previous work that studies instances with few projections .",
    "although most instances will have many projections , we think our result opens up a fresh technical perspective that may contribute towards solving the above mentioned and related questions .",
    "underlying theorem  [ thm : maincnf ] is our main technical contribution ( theorem  [ thm : unionhashsmallsupp ] ) that enables us to circumvent partial projections and access projections directly , namely homomorphic hashing from the mbius algebra of the lattice of subsets of @xmath43 $ ] to the solomon algebra of a poset .",
    "a full proof of theorem  [ thm : unionhashsmallsupp ] is given in the appendix ; we give a specialized , more direct proof of theorem  [ thm : maincnf ] in section  5 .",
    "the proofs of claims marked with a `` @xmath44 '' are relegated to the appendix in order to not break the flow of the paper .",
    "lower - case boldface characters refer to vectors , while capital boldface letters refer to matrices , @xmath45 being the identity matrix .",
    "the rank of a matrix @xmath25 is denoted by @xmath24 . if @xmath46 and @xmath13 are sets , and @xmath13 is finite , denote by @xmath47 the set of all @xmath48-dimensional vectors with values in @xmath46 , indexed by elements of @xmath13 , that is , if @xmath49 , then for every @xmath50 we have @xmath51 .",
    "we denote by @xmath52 and @xmath53 the set of integers and non - negative integers , respectively , and by @xmath54 the field of integers modulo a prime @xmath55 . an arbitrary field",
    "is denoted by @xmath56 .    for a logical proposition @xmath57 ,",
    "we use iverson s bracket notation @xmath58 $ ] to denote a @xmath59 if @xmath57 is true and a @xmath60 if @xmath57 is false . for a function @xmath61 and @xmath62 ,",
    "the preimage @xmath63 is defined as the set @xmath64 . for an integer @xmath29 and @xmath65 , denote by @xmath66 the characteristic vector of @xmath67 .",
    "sometimes we will state running times of algorithms with the @xmath68 notation , which suppresses any factor polynomial in the input size .    for a ring @xmath46 and a finite set @xmath13 , we write @xmath47 for the ring consisting of the set @xmath47 ( the set of all vectors over @xmath46 with coordinates indexed by elements of @xmath13 ) equipped with coordinate - wise addition @xmath69 and multiplication @xmath70 ( the _ hadamard product _ ) , that is , for @xmath71 and @xmath72 , @xmath73 we set @xmath74 and @xmath75 for each @xmath76 , where @xmath69 and the juxtaposition denote addition and multiplication in @xmath46 , respectively . the inner - product @xmath71 is denoted by @xmath77 .",
    "for @xmath78 denote by @xmath79 the _ support _ of @xmath80 , that is , @xmath81 , where @xmath60 is the additive identity element of @xmath46 .",
    "a vector @xmath80 is called a _ singleton _ if @xmath82 .",
    "we denote by @xmath83 the singleton with value @xmath84 on index @xmath85 , that is , @xmath86 $ ] for all @xmath87 .",
    "if @xmath46 is a ring and @xmath88 is a finite semigroup , denote by @xmath89 $ ] the ring consisting of the set @xmath47 equipped with coordinate - wise addition and multiplication defined by the convolution operator @xmath90 , where for @xmath71 , @xmath91 we set @xmath92 for every @xmath76 .    if @xmath93 are rings with operations @xmath94 and @xmath95 respectively , a _ homomorphism from @xmath46 to @xmath13 _ is a function @xmath96 such that @xmath97 and @xmath98 for every @xmath99 .",
    "[ obs : hom ] let @xmath46 be a ring , and let @xmath88 and @xmath100 be finite semigroups .",
    "suppose @xmath101 such that for every @xmath102 we have @xmath103 .",
    "then the function @xmath104 \\rightarrow r[t]$ ] defined by @xmath105 where @xmath106 for all @xmath107 is a homomorphism .",
    "a _ circuit _ @xmath108 over a ring @xmath46 is a labeled directed acyclic graph @xmath109 where the elements of @xmath110 are called _ gates _ and @xmath111 has a unique sink called the _ output gate of @xmath108_. all sources of @xmath108 are called _",
    "input gates _ and are labeled with elements from @xmath46 .",
    "all gates with non - zero in - degree are labeled as either an _ addition _ or a _ multiplication gate_. ( if multiplication in @xmath46 is not commutative , the in - arcs of each multiplication gate are also ordered . ) every gate @xmath112 of @xmath108 can be associated with a ring element in the following natural way : if @xmath112 is an input gate , we associate the label of @xmath112 with @xmath112 . if @xmath112 is an addition gate we associate the ring element @xmath113 with @xmath112 , and if @xmath112 is a multiplication gate we associate the ring element @xmath114 with @xmath112 where @xmath115 are the ring elements associated with the @xmath116 in - neighbors of @xmath112 , and @xmath69 and @xmath90 are the operations of the ring @xmath46 .",
    "suppose the ground set of @xmath46 is of the type @xmath117 where @xmath118 are sets .",
    "then @xmath108 is said to have _ singleton inputs _ if the label of every input - gate of @xmath108 is a singleton vector of @xmath46 .",
    "let @xmath46 and @xmath13 be rings , let @xmath119 be a homomorphism , and suppose that @xmath108 is a circuit over @xmath46 .",
    "then , the circuit @xmath120 over @xmath13 _ obtained by applying @xmath121 to @xmath108 _ is defined as the circuit obtained from @xmath108 by replacing for every input gate the label @xmath122 by @xmath123 .",
    "note that the following is immediate from the definition of a homomorphism :    [ obs : homcir ] suppose @xmath108 is a circuit over a ring @xmath46 with output @xmath124 .",
    "then the circuit over @xmath13 obtained by applying a homomorphism @xmath119 to @xmath108 outputs @xmath125 .",
    "in this section we will study the problem and prove theorem  [ thm : mainsss ] .",
    "as mentioned in the introduction , it should be noted that this merely serves as an illustration of how similar problems can be tackled as well since the same method applies to the more general sparse polynomial interpolation problem .",
    "however , to avoid a repeat of the analysis of @xcite , we have chosen to restrict ourselves to the problem .",
    "our central contribution over @xcite is that we take advantage of sparsity .    given @xmath126 and an integer @xmath127 , let @xmath128 be defined by @xmath129 : \\sum_{e \\in x } a_e \\equiv j\\ ( { \\operatorname{mod}}{p } ) \\bigg\\}\\bigg|\\text { \\ for every } j\\in{\\mathbb{z}}_p.\\ ] ] we also use the shorthand @xmath130 .",
    "we use a corollary from  @xcite :    [ cor : ln ] given an instance @xmath10 of and an integer @xmath131 , @xmath132 can be computed in @xmath133 time and @xmath134 space .",
    "we will also need the following two results on primes :    [ thm : pnt ] if @xmath135 , then the number of prime numbers at most @xmath136 is at least @xmath137 .",
    "[ thm : sam ] there exists an algorithm @xmath138 running in @xmath139 time that , given integer @xmath140 as input , outputs either a prime chosen uniformly at random from the set of primes at most @xmath136 or @xmath141 .",
    "moreover , the probability that the output is @xmath141 is at most @xmath142 .    we will run a data reduction procedure similar to the one of claim 2.7 in @xcite , before applying the algorithm of corollary [ cor : ln ] .",
    "the idea of the data reduction procedure is to work modulo a prime of size roughly @xmath143 or larger :    [ lem : hashsss ] let @xmath144 and let @xmath145 be an upper bound on the number of bits needed to represent the integers , i.e. @xmath146 .",
    "then , @xmath147\\geq \\frac{1}{2}$ ] , where the probability is taken uniformly over all primes @xmath148 .",
    "suppose @xmath149 .",
    "then there exists an integer @xmath150 such that @xmath151 and @xmath152 .",
    "this implies that @xmath131 is a divisor of @xmath153 , so let us bound the probability of this event . since @xmath154 , it has at most @xmath155 distinct prime divisors .",
    "let @xmath156 .",
    "it is easy to check that for sufficiently large @xmath145 and @xmath29 : @xmath157 \\leq \\frac { \\beta + \\log n}{\\frac{\\gamma}{\\log \\gamma + 2}}\\leq \\frac { \\beta + \\log n}{\\frac{\\gamma}{3(n + \\log \\beta ) } } \\leq \\frac{1}{2{s}},\\ ] ] where we use theorem [ thm : pnt ] in the first inequality and @xmath158 in the second inequality . applying the union bound over the at most @xmath159 elements of @xmath160 , the event that there exists a @xmath150 with @xmath151 and @xmath161 has probability at most @xmath162 .",
    "now we give two algorithms utilizing homomorphic hashing , one for the case where @xmath159 is known , and one for the case where @xmath159 is not known .",
    "there exists an algorithm that , given an instance @xmath10 of the problem and an integer @xmath144 as input , outputs a nonnegative integer @xmath163 in @xmath164 time and polynomial space such that ( i ) @xmath165 implies @xmath166 and ( ii ) @xmath167 \\geq \\frac{1}{4}$ ] .",
    "the algorithm is : first , obtain prime @xmath168 using lemma  [ thm : sam ] .",
    "second , compute and output @xmath132 using corollary [ cor : ln ] . condition ( i ) holds since @xmath169 implies @xmath166 for any @xmath170 .",
    "moreover , condition ( ii ) follows from lemma  [ lem : hashsss ] and lemma  [ thm : sam ] since @xmath171 . the time and space bounds are met by corollary @xmath172 because @xmath173 .",
    "the algorithm is the following : maintain a guess @xmath159 of @xmath160 , initially set to @xmath29 .",
    "obtain a prime @xmath168 using lemma  [ thm : sam ] , and compute @xmath132 using corollary [ cor : ln ] .",
    "if @xmath169 output * no *  since @xmath166 ; otherwise , attempt to construct a subset @xmath4 $ ] such that @xmath5 using self - reduction .",
    "if this succeeds , return * yes*. otherwise , double @xmath159 and repeat .",
    "the expected running time ( taken over all primes @xmath55 ) is @xmath174 because when @xmath175 the probability of succesfully constructing a solution or concluding that none exist is at least @xmath162 by the arguments in the proof of lemma [ lem : hashsss ] .",
    "the derandomization for theorem  [ thm : mainsss](b ) is given in the appendix .",
    "in this section we assume that @xmath56 is a field of non - even characteristic and that addition and multiplication refer to operations in @xmath56 . for @xmath176 ,",
    "we denote by @xmath177 the _ walsh - hadamard matrix _ , defined for all @xmath178 by @xmath179 .",
    "[ lem : wht ] the walsh - hadamard matrix satisfies @xmath180 and , for every @xmath181 $ ] , it holds that @xmath182 .",
    "we first prove the following general theorem , of which theorem  [ thm : mainls](a ) is a special case .",
    "[ thm : z2 ] there exists a randomized algorithm that , given as input    1 .   a circuit @xmath108 with singleton inputs over @xmath1 $ ] , 2 .",
    "an integer @xmath183 , and 3 .",
    "an element @xmath184 ,    outputs the coefficient @xmath185 with probability at least @xmath162 , where @xmath186 $ ] is the output of @xmath108 .",
    "the algorithm runs in time @xmath164 and uses @xmath164 arithmetic operations in @xmath56 , and requires storage for @xmath134 bits and elements of @xmath56 .",
    "@xmath187 let @xmath188 + 1 .",
    "choose a matrix @xmath189 uniformly at random from the set of all @xmath190 matrices with binary entries .",
    "let @xmath191 \\rightarrow { { \\mathbb{f}}}[{\\mathbb{z}}_2^s]$ ] be the homomorphism defined by @xmath192 where @xmath193 for all @xmath194 .",
    "apply @xmath121 to @xmath108 to obtain the circuit @xmath195 .",
    "@xmath197 let @xmath198\\rightarrow{{\\mathbb{f}}}$ ] be the homomorphism defined by @xmath199 for all @xmath200 $ ] .",
    "apply @xmath201 to @xmath195 to obtain the circuit @xmath202 .",
    "evaluate @xmath202 and return the output .",
    "the algorithm is given in algorithm  [ alg : find1 ] .",
    "let us first analyse the complexity of this algorithm : steps 1 and 2 can be performed in time polynomial in the input .",
    "step 3 also be done in polynomial time since it amounts to relabeling all input gates with @xmath203 where @xmath204 was the old label .",
    "indeed , we know that @xmath205 $ ] is a singleton @xmath206 , so @xmath203 is the singleton @xmath207 and this can be computed in polynomial time .",
    "step 4 takes @xmath164 operations and calls to @xmath208 , so for the complexity bound it remains to show that each call to @xmath208 runs in polynomial time .",
    "step 5 can be implemented in polynomial time similar to step 3 since the singleton @xmath209 is mapped to @xmath210 . finally , the direct evaluation of @xmath202 uses @xmath211 operations in @xmath56 .",
    "hence the algorithm meets the time bound , and also the space bound is immediate .",
    "the fact that @xmath187 returns @xmath212 with probability at least @xmath162 is a direct consequence of the following two claims .",
    "let @xmath213 be the output of @xmath195 .",
    "[ clm : one ]",
    "@xmath214 \\geq \\frac{1}{2}$ ] .",
    "[ clm : two ] algorithm @xmath187 returns @xmath215",
    ".    for @xmath216 and @xmath217 denote by @xmath218 the @xmath219th row of @xmath25 and define @xmath220 \\in \\mathbb{q}[{\\mathbb{z}}_2^m]$ ] by @xmath221}= \\begin{cases }   { \\left\\langle 1,{\\boldsymbol 0 } \\right\\rangle } & \\text{if } i = w=0,\\\\   0 & \\text{if } i=0 \\text { and } w\\neq 0,\\\\   { \\boldsymbol f}[i-1,w ] + { \\boldsymbol f}[i-1,j-\\omega_i ] * { \\left\\langle 1,{\\boldsymbol a^{(i ) } } \\right\\rangle } & \\text{otherwise . } \\end{cases}\\ ] ] it is easy to see that for every @xmath222 , @xmath223 , and @xmath224 , the value @xmath225_{{\\boldsymbol y}}$ ] is the number of @xmath226 such that @xmath227 and @xmath228 where @xmath229 and @xmath230 are obtained by truncating @xmath231 and @xmath25 to the first @xmath219 rows .",
    "hence , we let @xmath108 be the circuit implementing [ eq : setpart ] and let its output be @xmath232}$ ] .",
    "thus , @xmath233 is the number of @xmath19 with @xmath20 and @xmath234 .",
    "also , @xmath235 since any element of the support of @xmath80 is a sum of rows of @xmath25 and hence in the row - space of @xmath25 , which has size at most @xmath236 .",
    "to apply theorem [ thm : z2 ] , let @xmath237 and observe that the computations are in fact carried out over integers bounded in absolute value poly - exponentially in @xmath29 and hence the operations in the base field can also be executed polynomial in @xmath29 .",
    "the theorem follows from theorem  [ thm : z2 ] .    to establish theorem  [ thm : mainls](b ) ,",
    "let us first see how to exploit a high linear rank of the matrix @xmath25 in an instance of linear sat . by permuting the rows of @xmath25 as necessary",
    ", we can assume that the first @xmath24 rows of @xmath25 are linearly independent .",
    "we can now partition @xmath238 into @xmath239 , where @xmath240 has length @xmath24 and @xmath241 has length @xmath242 .",
    "there are @xmath243 choices for @xmath241 , each of which by linear independence has at most one corresponding @xmath240 such that @xmath20 . given @xmath241",
    ", we can determine the corresponding @xmath240 ( if any ) in polynomial time by gaussian elimination .",
    "thus , we have :    [ obs : highrank ] linear sat can be solved in @xmath244 time and polynomial space .",
    "this enables a `` win / win approach '' where we distinguish between low and high ranks , and use an appropriate algorithm in each case .",
    "compute @xmath24 . if @xmath245 , run the algorithm of observation  [ obs : highrank ]",
    "otherwise , run the algorithm implied by theorem  [ thm : mainls](a ) .",
    "we now give a very similar application to the set partition problem : given an integer @xmath3 and a set family @xmath246 where @xmath247 , @xmath248 , determine whether there is a subfamily @xmath249 with @xmath250 such that @xmath251 and @xmath252 .",
    "the _ incidence matrix _ of a set system @xmath253 is the @xmath254 matrix @xmath25 whose entries @xmath255 $ ] are indexed by @xmath256 and @xmath257 .",
    "[ thm : setpartexpspacerank][thm : setpart5 ] there exist algorithms that given an instance @xmath258 of set partition output the number of set partitions of size at most @xmath3 with probability at least @xmath162 , and use ( a ) @xmath23 time and polynomial space , and ( b ) @xmath259 time and space , where @xmath25 is the incidence matrix of @xmath253 .",
    "in this section our objective is to mimic the approach of the previous section for @xmath260 $ ] , where @xmath261 is the semigroup defined by the set union @xmath262 operation on @xmath263 , the power set of an @xmath29-element set @xmath264 . the direct attempt to apply a homomorphic hashing function ,",
    "unfortunately , fails .",
    "indeed , let @xmath121 be an arbitrary homomorphism from @xmath261 to @xmath265 with @xmath266 .",
    "let @xmath267 and consider the minimum value @xmath268 with @xmath269 ; in particular , for @xmath270 we have @xmath271 , which signals failure since we can not isolate @xmath272 from @xmath264 .    instead , we use hashing to an algebraic structure based on a poset ( the `` solomon algebra '' of a poset due to  @xcite ) that is obtained by the technique `` iterative compression '' .",
    "this gives the following main result . for reasons of space",
    "we relegate a detailed proof to the appendix ; here we will give a simplified version of the proof in the special case of theorem  [ thm : maincnf ] in this section .",
    "[ thm : unionhashsmallsupp ] let and @xmath273 .",
    "there are algorithms that , given a circuit @xmath108 with singleton inputs in @xmath260 $ ] outputting @xmath80 , compute    1 .   a list with @xmath274 for every @xmath275 in @xmath276 time , 2 .",
    "@xmath277 in time @xmath278 if @xmath279 such that @xmath280 .",
    "the above result is stated for simplicity in the unit - cost model , that is , we assume that arithmetic operations on integers take constant time . for the more realistic log - cost model , where such operations are assumed to take time polynomial in the number of bits of the binary representation , we only mention here that our results also hold under some mild technical conditions .",
    "let us first show that theorem  [ thm : maincnf](a ) indeed is a special case of theorem  [ thm : unionhashsmallsupp ] :    use a circuit over @xmath281},\\cup)]$ ] that implements the expression @xmath282 where @xmath283 $ ] ( respectively , @xmath284 $ ] ) is the set of all indices of clauses that contain a positive ( respectively , negative ) literal of the variable @xmath285 .",
    "then use theorem  [ thm : unionhashsmallsupp ] to determine @xmath286}$ ] , the number of satisfying assignments of @xmath30 .",
    "now we proceed with a self - contained proof theorem  [ thm : maincnf ] . given poset @xmath287 , the _ mbius function _",
    "@xmath288 of @xmath57 is defined for all @xmath289 by @xmath290 the _ zeta transform _ @xmath291 and _ mbius transform _",
    "@xmath292 are the @xmath293 matrices defined by @xmath294 $ ] and @xmath295 for all @xmath289 . for a cnf - formula @xmath30 denote @xmath296 for the set of all projections of @xmath30 .",
    "recall in theorem  [ thm : maincnf ] we are given a cnf - formula @xmath297 over @xmath29 variables . for @xmath298 define @xmath299 .",
    "then we have the following easy observations    1 .",
    "@xmath300 , 2 .",
    "@xmath301 for every @xmath298 , 3 .",
    "@xmath302 for every @xmath298 .",
    "given the above lemma and observations , we will give an algoritm using a technique called _ iterative compression _ @xcite .",
    "as we will see , by this technique it is sufficient to solve the following `` compression problem '' :    [ lem : compresssimple ] given a cnf - formula @xmath303 and a set family @xmath304}$ ] with @xmath305 , the set @xmath296 can be constructed in @xmath306 time .    in what follows",
    "@xmath307 refers to an assignment of values to the @xmath29 variables in @xmath30 .",
    "define @xmath308}}$ ] for all @xmath309 $ ] by @xmath310 \\text { it holds that }   { \\boldsymbol a } \\text { satisfies } c_i \\text { iff } i \\in x \\}|.\\ ] ] it is easy to see that @xmath311 , so if we know @xmath312 for every @xmath313 we can construct @xmath296 in @xmath314 time . towards this end , first note that for every @xmath315 $ ] it holds that @xmath316 \\text { it holds that } { \\boldsymbol a } \\text { satisfies } c_i \\text { only if } i \\in y \\}|.\\end{aligned}\\ ] ] second , note that the last quantity can be computed in polynomial time : since every clause outside @xmath317 must not be satisfied , each such clause forces the variables that occur in it to unique values ; any other variables may be assigned to arbitrary values .",
    "that is , the count is 0 if the clauses outside @xmath317 force at least one variable to conflicting values , otherwise the count is @xmath318 where @xmath319 is the number of variables that occur in none of the clauses outside @xmath317 .",
    "now the algorithm is the following : for every @xmath313 compute @xmath320 in polynomial time as discussed above",
    ". then we can use algorithm @xmath321 as described below to obtain @xmath312 for every @xmath313 since it follows that @xmath322 from the definition of @xmath292 and the fact that @xmath323 .",
    "algorithm @xmath321 clearly runs in @xmath324 time , so this procedure meets the claimed time bound .",
    "let @xmath326 such that @xmath327 implies @xmath328 .",
    "@xmath330 @xmath241 .",
    "recall that we already know that @xmath331 .",
    "now , for @xmath332 we set @xmath333 and use @xmath334 to obtain @xmath335 using lemma  [ lem : compresssimple ] . in the end",
    "we are given @xmath336 and since @xmath337 is exactly the original formula , the input is a yes - instance if and only if @xmath43 \\in { \\mathrm{supp}}(\\phi_m)$ ] .",
    "the claimed running time follows from observations 1 and 3 above and the running time of algorithm @xmath321 .",
    "we will now give an application of theorem  [ thm : unionhashsmallsupp](b ) to set cover : given a set family @xmath338 where @xmath273 and an integer @xmath339 , find a subfamily @xmath340 such that @xmath341 and @xmath342 .",
    "given an instance of set cover , let @xmath279 be the largest real such that @xmath343 .",
    "then the instance can be solved in @xmath344 time ( and exponential space ) .",
    "let @xmath345 , and for every @xmath346 and @xmath347 define @xmath348}$ ] as follows : @xmath349}= \\begin{cases }   { \\left\\langle 1,\\emptyset \\right\\rangle } & \\text{if } i = j=0,\\\\   { \\boldsymbol f}[i-1,j ] + { \\boldsymbol f}[i-1,j-1 ] * { \\left\\langle 1,s_i \\right\\rangle } & \\text{otherwise . } \\end{cases}\\ ] ] it is easy to see that for every @xmath350 we have that @xmath351_x$ ] is the number of @xmath352 such that @xmath353 and @xmath354 .",
    "hence the theorem follows directly by applying theorem  [ thm : unionhashsmallsupp](b ) by interpreting the above recurrence as a circuit in order to determine the value @xmath355_u$ ] .",
    "* appendix *",
    "by reducing modulo @xmath55 we can assume that @xmath357 .",
    "we have @xmath358 where the first equality holds by definition and the second equality follows from the fact that @xmath359 when @xmath360 or @xmath361 .",
    "the latter expression can be evaluated in the claimed resource bounds using theorem [ thm : ln ] .",
    "take an integer @xmath362 uniformly at random , and check whether it is a prime using the polynomial time algorithm of @xcite .",
    "if @xmath219 is prime , then output @xmath219 and halt ; otherwise repeat . if no prime is found after @xmath363 repetitions , output @xmath141 and halt .",
    "the upper bound on the probability of failure follows from theorem [ thm : pnt ] since the probability that @xmath141 is returned is at most @xmath364 .",
    "let @xmath365 . call a prime @xmath55 _ bad _ if @xmath149 .",
    "analoguously to the proof of lemma [ lem : hashsss ] , there are at most @xmath366 bad primes .",
    "let @xmath367 be the first @xmath122 prime numbers in increasing order where @xmath368 .",
    "since there are only @xmath369 bad primes , the majority of the set of integers @xmath370 will be equal to @xmath356 .",
    "then use the folklore majority voting algorithm  @xcite as in algorithm  [ alg : prfapp ] :        the correctness follows from the above discussion and the correctness of the majority voting algorithm  @xcite that is folklore and implemented in the algorithm . for the running time , note that @xmath379 is @xmath164 by theorem [ thm : pnt ] and hence the running time is @xmath380 since step 6 takes time @xmath164 .",
    "it is clear that the algorithm can be implemented using polynomial space .        for every @xmath381",
    "$ ] we have @xmath382 and hence @xmath121 is easily seen to be a homomorphism by observation  [ obs : hom ] .",
    "thus , by observation [ obs : homcir ] we know that @xmath383 , that is , for every @xmath384 @xmath385 hence , if @xmath386 , there must exist @xmath387 such that @xmath388 and @xmath389 .",
    "equivalently , @xmath390 . for any @xmath391 with @xmath392",
    "we have @xmath393=\\prod_{i=1}^s{\\operatorname{prob}}_{{\\boldsymbol h}}[({\\boldsymbol x}{\\boldsymbol h})_i = 0]=2^{-s},\\ ] ] where the probability is taken uniform over all binary @xmath394 matrices , and the two equalities follow from the fact that the random variables @xmath395 for @xmath396 are independent and uniformly distributed .",
    "now the claim follows by taking the union bound over all elements in the support : @xmath397 \\leq { \\operatorname{prob}}[\\exists { \\boldsymbol x } \\in { \\mathrm{supp}}({\\boldsymbol v}):\\ { \\boldsymbol x}\\neq { \\boldsymbol t } \\wedge { \\boldsymbol x}{\\boldsymbol h}={\\boldsymbol t}{\\boldsymbol h } ] \\leq |s|2^{-s } \\leq \\frac{1}{2}.\\ ] ]      let @xmath398 $ ] such that @xmath399 for every @xmath194 .",
    "it suffices to show that @xmath400 since @xmath187 returns @xmath401 as can bee seen from line 4 , and this is equal to @xmath402 by lemma [ lem : wht ] . for proving that @xmath400",
    ", we first claim that @xmath201 is a homomorphism from @xmath403 $ ] to @xmath53 since , for @xmath404 $ ] , we have that @xmath405 equals @xmath406 and @xmath407 equals @xmath408 then , by observation [ obs : homcir ] , @xmath197 returns @xmath409 . for @xmath410 $ ]",
    "we have @xmath411 so @xmath412 and hence @xmath400 .",
    "use theorem  [ thm : mainls ] .",
    "assume @xmath413 and create the instance @xmath414 of linear sat where @xmath25 is the incidence matrix of the set system @xmath415 , @xmath416 , @xmath417 and @xmath418 .",
    "it is easy to see that the algorithm of theorem  [ thm : mainls ] returns exactly the number of set partitions of size at most @xmath3        consider the following circuit @xmath108 over @xmath422 $ ] : @xmath423&= \\begin{cases }   \\displaystyle { \\left\\langle 1,{\\boldsymbol 0 } \\right\\rangle } & \\text{if } i = j=0\\\\   \\displaystyle 0 & \\text{if } i=0\\text { and } j\\neq0\\\\   \\displaystyle \\sum_{h=0}^j f[i-1,h]g[j - h ] & \\text{otherwise , where }   \\end{cases}\\\\ \\label{eq : expspace2 }      g[j ] & = \\sum_{i=1}^n \\big[|s_i|=j\\big ] { \\left\\langle 1,s_i \\right\\rangle}\\end{aligned}\\ ] ]    for every @xmath424 and non - negative integers @xmath219 and @xmath425 , the coefficient @xmath351_{{\\boldsymbol x}}$ ] counts the number of ways to choose an @xmath219-tuple of sets in @xmath426 such that their sizes sum up to @xmath425 and their characteristic vectors sum to @xmath238 in @xmath427 .",
    "thus @xmath428 ) \\leq 2^{{\\operatorname{rk}}({\\boldsymbol a})}$ ] .",
    "furthermore , @xmath429_{{\\boldsymbol 1}}$ ] is the number of set partitions of size @xmath3 times @xmath430 . indeed , if a @xmath3-tuple of sets from @xmath426 contributes to @xmath431_{{\\boldsymbol 1}}$ ] , each element of @xmath264 must occur in a unique set in the @xmath3-tuple .",
    "it remains to compute @xmath432)_{{\\boldsymbol 1}}$ ] .",
    "for this we will use algorithm @xmath187 with @xmath433 , except that we replace line 4 with the following to compute @xmath434 , where @xmath213 is the output of @xmath195 :",
    "the correctness follows from claim [ clm : one ] and the observation that the inversion formula from theorem [ lem : wht ] is returned on line 7 .",
    "indeed , @xmath121 is a homomorphism and @xmath438 is a bijective homomorphism , so observation [ obs : homcir ] enables us to compute @xmath437 using .    to establish the time and space complexity , we observe that steps 5 and 6 take @xmath439 time by elementary analysis and theorem  [ thm : fastwht ] , and that step 7 takes @xmath440 time since we can compute @xmath441})$ ] via   in @xmath442 operations in @xmath443 by relying on the stored values @xmath444){\\boldsymbol \\phi}$ ] , where each operation requires @xmath445 time by theorem  [ thm : fastwht ] .      this section is dedicated to the proof of theorem  [ thm : unionhashsmallsupp ] . instead of a combinatorial proof similar to the one of section  [ sec : unionhashing ] , we use the algebraic perspective in this proof since we feel it gives a more fundamental insight into the hashing function used . to obtain theorem  [ thm : unionhashsmallsupp ] , we prove the following generalization of lemma  [ lem : compresssimple ] .",
    "[ thm : unionhashing ] there is an algorithm that , given circuit @xmath108 over @xmath260 $ ] with singleton inputs outputting @xmath80 , and a set family @xmath338 such that @xmath446 computes a list with @xmath274 for every @xmath275 in @xmath447 time .",
    "we now combine lemma  [ thm : unionhashing ] with the iterative compression technique to obtain theorem  [ thm : unionhashsmallsupp ] in a way very similar to section  [ sec : unionhashing ] . instead of the subformula @xmath448 from section  [ sec : unionhashing ]",
    ", we need the following notion .",
    "[ defi : restri ] given a circuit @xmath108 over @xmath260 $ ] and @xmath350 , the _ restriction of @xmath108 to @xmath272 _ is the circuit obtained by applying the function @xmath121 to it , where , for @xmath449 @xmath450    assume @xmath267 , and for every @xmath451 , let @xmath452 be the restriction of @xmath108 to @xmath453 and @xmath454 be the output of @xmath455 .",
    "then , since taking restrictions is homomorphic , we have by observation  [ obs : homcir ] that @xmath456 this implies that if @xmath457 , then @xmath458 and hence @xmath459 we now describe how to implement the theorem .",
    "first note that @xmath460 .",
    "for @xmath461 do the following : set @xmath462 .",
    "then by  , @xmath463 . hence , by invoking the algorithm of lemma  [ thm : unionhashing ] using @xmath455 as the circuit and @xmath464 as the set family , we can obtain @xmath465 for every @xmath457 in @xmath466 time which is @xmath467 time . from these values",
    "we can easily obtain the support of @xmath454 .",
    "after @xmath29 steps , we have computed @xmath468 for every @xmath275 .",
    "the claimed running time follows from the fact that @xmath469 for every @xmath461 .",
    "the remainder of this section is devoted to the proof of lemma  [ thm : unionhashing ] .",
    "the idea is to use the set family @xmath334 to create a poset and homomorphically hash @xmath260 $ ] to the so - called solomon algebra of the poset .",
    "we will first recall all necessary notions and properties , second introduce the hash function , and third give the algorithm implementing lemma  [ thm : unionhashing ] .",
    "let @xmath287 be a poset .",
    "an element @xmath470 is said to be an _ upper bound _ of a set @xmath471 if @xmath472 holds for all @xmath473 . the set @xmath272 is said to have a _ join _ in @xmath57 if there exists an upper bound @xmath474 ( called _ the join _ ) of @xmath272 such that , for all upper bounds @xmath116 of @xmath272 , it holds that @xmath475 . for @xmath471 ,",
    "let us write @xmath476 for the join of @xmath272 ; for the join of @xmath477 we write simply @xmath478 .",
    "the _ open interval _",
    "@xmath479 is the poset induced by the set @xmath480 .",
    "we write @xmath481 , @xmath482 $ ] and @xmath483 $ ] for the analogous ( half-)closed interval .",
    "let @xmath57 be a poset .",
    "the _ mbius function _",
    "@xmath288 of @xmath57 is defined for all @xmath289 by @xmath484 the _ zeta transform _ @xmath291 and _ mbius transform _",
    "@xmath292 are the @xmath293 matrices defined by @xmath294 $ ] and @xmath295 for all @xmath289 .",
    "use induction on the number of elements in the interval @xmath479 .",
    "if @xmath486 , @xmath479 contains only the empty chain , which is even . if @xmath487 , group all chains on their smallest element @xmath488 .",
    "the contribution of all these chains is exactly @xmath489 since odd chains are extended to even chains and vice - versa by adding @xmath488 .",
    "it is known that @xmath292 and @xmath291 are mutual inverses . to see this , note that @xmath490 can be interpreted as the number of even chains minus the number of odd chains in the interval @xmath482 $ ] which can be seen to be @xmath60 if @xmath491 by a pairing argument , and @xmath59 otherwise .",
    "this principle is called _",
    "mbius inversion_.",
    "let @xmath287 be a poset .",
    "solomon algebra _",
    "$ ] is the set @xmath493 equipped with coordinate - wise addition @xmath494 and the _ solomon product _ @xmath495 defined for all @xmath496 $ ] and @xmath497 by @xmath498        use induction of @xmath29 . for @xmath502 , the statement clearly holds",
    ". otherwise , we have by definition of @xmath495 that @xmath503 \\mu(r , s ) \\prod_{i=1}^{k } v^i_{a_i}\\\\                                                                                               & = \\sum_{a_1,\\ldots , a_k \\in p } \\left ( \\sum_{a_1,\\ldots , a_{k } \\leq q } \\mu(q , s ) \\right ) \\prod_{i=1}^{k } v^i_{a_i }                                                                                              \\end{aligned}\\ ] ]      for every @xmath506 we have @xmath507 \\mu(q , z ) f_x g_y \\\\                                                           & = \\sum_{x , y , q \\in p } [ x , y \\leq q \\leq w ] \\left(\\sum_{q \\leq z \\leq w } \\mu(q , z)\\right ) f_x g_y \\\\                                                           & = \\sum_{x , y , q \\in p } [ x , y \\leq q \\leq w ] [ q = w ] f_x g_y \\\\                                                           & = \\sum_{x , y \\in p } [ x , y \\leq w ] f_x g_y = \\left(\\sum_{x \\leq w}f_x\\right ) \\left ( \\sum_{y \\leq w }   g_y \\right ) = ( { \\boldsymbol f}{\\boldsymbol{\\zeta}})_{w } ( { \\boldsymbol g}{\\boldsymbol{\\zeta}})_{w}.\\end{aligned}\\ ] ]      the singleton @xmath509 is the multiplicative identity because @xmath510 where the last equality follows from mbius inversion .",
    "to see that @xmath492 $ ] is a commutative ring , note that @xmath291 is an isomorphism from @xmath492 $ ] to the ring @xmath493 . indeed ,",
    "theorem [ thm : zethom ] shows that @xmath291 is a homomorphism , and @xmath511 shows that @xmath291 is bijective .",
    "let @xmath264 be an @xmath29-element set and let @xmath287 be a poset that satisfies @xmath516 and has a minimum element @xmath508 .",
    "define the function @xmath517\\rightarrow { \\mathbb{n}}[p]$ ] by setting , for all @xmath518 $ ] , @xmath519      [ lem : homhashunion ] if @xmath287 is a poset with minimum element , @xmath516 and @xmath520 $ ] such that every @xmath275 has a join in @xmath57 and for every @xmath521 , @xmath522 then for every @xmath523 , @xmath524 .    denote @xmath525 .",
    "then , @xmath526 \\prod_{i=1}^{|x| } [ a_i = e_i]\\\\                                                   & \\ { x \\text { has a join by assumption since it is in the support } \\ } \\\\                                                   & = \\sum_{x \\in { \\mathrm{supp}}({\\boldsymbol v } ) } \\left ( \\sum_{e_1 \\vee \\ldots \\vee e_{|x| } \\leq q \\leq y } \\mu(q , y ) \\right ) v_x\\\\                                                   & \\ { \\text{m\\\"obius inversion } \\ } \\\\                                                   & = \\sum_{x \\in { \\mathrm{supp}}({\\boldsymbol v } ) } [ e_1\\vee\\ldots\\vee e_{|x| } = y ]   v_x\\\\                                                   & \\ { \\text{by the assumption stated in~\\eqref{eqn : reqprop } } \\ } \\\\                                                   & = v_x\\end{aligned}\\ ] ]      for every @xmath527 $ ] we have @xmath528 @xmath529 \\}\\\\                                               & = { \\bigoplus}_{x \\subseteq u } \\biggl\\langle\\sum_{v \\cup w = x}v_vw_w,\\hat 0\\biggr\\rangle{\\otimes}{\\bigotimes}_{e \\in x } { \\left\\langle 1,e \\right\\rangle}\\\\                                               & \\ { \\text{by definition of $ { \\oplus}$ }   \\}\\\\                                               & = { \\bigoplus}_{x \\subseteq u } { \\bigoplus}_{v \\cup w = x}{\\left\\langle v_vw_w,\\hat 0 \\right\\rangle}{\\otimes}{\\bigotimes}_{e \\in x } { \\left\\langle 1,e \\right\\rangle}\\\\                                               & \\ {",
    "\\text{by lemma \\ref{lem : idempot } and commutativity of $ { \\otimes}$ from lemma \\ref{lem : solring } }   \\ } \\\\                                               & = { \\bigoplus}_{x \\subseteq u } { \\bigoplus}_{v \\cup w = x}{\\left\\langle v_vw_w,\\hat 0 \\right\\rangle}{\\otimes}{\\bigotimes}_{e \\in v } { \\left\\langle 1,e \\right\\rangle } { \\otimes}{\\bigotimes}_{e \\in w } { \\left\\langle 1,e \\right\\rangle}\\\\                                               & \\{\\text{using that } v \\text { and } w \\text { determine } x \\}\\\\                                               & = { \\bigoplus}_{v , w \\subseteq u } { \\left\\langle v_vw_w,\\hat 0 \\right\\rangle}{\\otimes}{\\bigotimes}_{e \\in v } { \\left\\langle 1,e \\right\\rangle } { \\otimes}{\\bigotimes}_{e \\in w } { \\left\\langle 1,e \\right\\rangle}\\\\                                               & \\ { \\text { by lemma \\ref{lem : idempot } }   \\}\\\\                                               & = { \\bigoplus}_{v , w \\subseteq u } ( { \\left\\langle v_v,\\hat 0 \\right\\rangle}{\\otimes}{\\left\\langle w_w,\\hat 0 \\right\\rangle}){\\otimes}{\\bigotimes}_{e \\in v } { \\left\\langle 1,e \\right\\rangle } { \\otimes}{\\bigotimes}_{e \\in w } { \\left\\langle 1,e \\right\\rangle}\\\\                                               & \\ { \\text { by distributivity from lemma \\ref{lem : solring } }   \\}\\\\                                               & = \\left({\\bigoplus}_{x \\subseteq u } { \\left\\langle v_x,\\hat 0 \\right\\rangle } { \\otimes}{\\bigotimes}_{e \\in x } { \\left\\langle 1,e \\right\\rangle}\\right ) { \\otimes}\\left({\\bigoplus}_{x \\subseteq u } { \\left\\langle v_x,\\hat 0 \\right\\rangle}{\\otimes}{\\bigotimes}_{e \\in x } { \\left\\langle 1,e \\right\\rangle}\\right)\\\\                                               & = h({\\boldsymbol v}){\\otimes}h({\\boldsymbol w}).\\end{aligned}\\ ] ]      we are now ready to give the proof of lemma  [ thm : unionhashing ] . as mentioned before",
    ", the proof idea is to construct a poset @xmath57 from the given set family and hash the given circuit to a circuit @xmath530 over the solomon algebra @xmath492 $ ] with the homomorphic hash function @xmath121 .",
    "then by theorem  [ thm : zethom ] and lemma  [ lem : solhom ] , the zeta - transform of the output of @xmath530 can be computed fast using point - wise multiplication , and then using mbius inversion the original output can be computed .",
    "because of the hash property from lemma  [ lem : homhashunion ] of @xmath121 , the required output of @xmath108 can then be read from the output of @xmath530 .",
    "@xmath532 construct the poset @xmath533 .",
    "construct the circuit @xmath195 over @xmath492 $ ] obtained from @xmath108 by applying @xmath121 .",
    "@xmath535 @xmath536 construct the circuit @xmath202 over @xmath53 obtained from @xmath195 by applying @xmath537 .",
    "evaluate @xmath202 and return the output .",
    "@xmath325 let @xmath326 such that @xmath327 implies @xmath328 .",
    "@xmath330 @xmath241 .",
    "the algorithm is algorithm @xmath538 .",
    "let us first analyse the complexity .",
    "recall that to establish the claimed bounds we assume that each operation in @xmath53 takes one time unit .",
    "step 1 can easily be implemented in @xmath539 time .",
    "step 2 expands every singleton ( of @xmath260 $ ] ) in @xmath108 according to into a product of at most @xmath540 singletons of @xmath492 $ ] , and thus can be implemented in time and storage @xmath541 .",
    "step 6 can be implemented in time and space @xmath542 because the singleton @xmath543 is mapped to @xmath544v$ ] . in step 7 , the evaluation of @xmath202 over @xmath53 uses @xmath211 operations in @xmath53 .",
    "the complexity of algorithm @xmath321 is easily seen to be @xmath447 , and since the loop at step 3 is the only other time - consuming part the resource bounds are clearly met .",
    "we proceed with the proof of correctness of algorithm @xmath538 .",
    "first note that since @xmath446 , we have by construction that for every @xmath545 , @xmath546 , since every other upper bound in @xmath57 on @xmath547 must be above the element @xmath272 of @xmath57 .",
    "this directly implies that the requirement imposed by   is met by @xmath57 .",
    "hence by lemma  [ lem : homhashunion ] we have that @xmath524 for every @xmath275 .",
    "thus to prove correctness it suffices to show that the vector @xmath548 is equal to @xmath549 .    since @xmath121 is a homomorphism by lemma  [ lem : solhom ] , observation",
    "[ obs : homcir ] implies that @xmath550 outputs @xmath549 .",
    "then , we claim that for every @xmath551 it holds that @xmath552 . to see this note that on line  7 first the zeta transform is applied to @xmath195 which is a homomorphism to @xmath553 by theorem  [ thm : zethom ] , and then we restrict to the coordinate @xmath163 .",
    "the claim than follows by observation  [ obs : homcir ] since both transformations are homomorphisms .",
    "the proof of item ( b ) is fairly similar to the proof of item ( a ) .",
    "the main difference is the use of the poset @xmath57 . in this section",
    ", we will use a poset larger than the support of @xmath80 , but the advantages are that    1 .   we not need to construct the poset using iterative compression , and hence we do not need to determine all components of @xmath80 , 2 .   the poset will be decomposable , implying that the bottleneck in ( a ) , the mbius inversion step , can be improved .",
    "let us now start with the more formal treatment .",
    "given two posets @xmath557 and @xmath558 , the _ direct product _ @xmath559 is the poset on the set @xmath560 such that @xmath561 if @xmath562 and @xmath563 .    [",
    "lem : dirprodmob ] let @xmath57 and @xmath564 be posets and let @xmath565 and @xmath566 denote their respective mbius functions",
    ". denote @xmath567 and @xmath568 for the mbius function and order of @xmath559 , then for @xmath561 it holds that @xmath569        [ lem : yatmob ] there is an algorithm that , given a poset @xmath573 ordered by set inclusion and containing @xmath574 and @xmath264 , computes a table with @xmath575 and @xmath576 for every @xmath577 in @xmath578 time and space    in this proof @xmath579 $ ] denotes the set @xmath580 for an integer @xmath219 .",
    "let @xmath581 $ ] .",
    "we first define @xmath582 \\rightarrow   \\mathbb{n}$ ] by letting @xmath583 it is easy to see that @xmath584 . also , define for every @xmath461 : @xmath585g(s ) & \\text{if } i=0 \\text { and } s\\neq\\emptyset\\\\ f_{i-1}(s ) + [ i \\in s]f_{i-1}(s \\setminus i ) & \\text{otherwise}. \\end{cases}\\ ] ] then it holds that @xmath586 for every @xmath587 .",
    "note that by symmetry ( that is , reversing the order of the poset ) , this procedure can be used as well to compute @xmath576 for every @xmath577 in the same time bounds .          by theorem  [ thm : zethom ]",
    ", @xmath291 is a homomorphism from @xmath492 $ ] to @xmath493 .",
    "hence , similarly as in the proof of theorem  [ thm : unionhashsmallsupp](a ) , we can compute @xmath596 in time polynomial in the input size .",
    "then the claim follows directly by applying lemma  [ lem : yatalg ] .",
    "@xmath597 obtain @xmath594 using claim  [ clm : incexc ] let @xmath598 and @xmath599 and construct the poset @xmath600 .",
    "construct the circuit @xmath195 over @xmath492 $ ] obtained from @xmath108 by applying the homomorphism @xmath121 as defined in  .",
    "@xmath534 . compute @xmath601 for every @xmath602 using lemma  [ lem : yatmob ] . @xmath603",
    "the arguments for the correctness of this algorithm are all similar to the arguments of for the correctness of algorithm @xmath604 : first note that @xmath605 .",
    "this in turn implies the condition of lemma  [ lem : homhashunion ] , and hence if @xmath606 is the output of @xmath550 we indeed have that @xmath607 .",
    "as shown before in the proof of lemma  [ thm : unionhashing ] , @xmath608 .",
    "hence it remains the show that on line  7 the expression is indeed the mbius inversion formula .",
    "this follows from the definition of @xmath292 , the direct product property of the mbius function from lemma  [ lem : dirprodmob ] and the fact that in the subset lattice @xmath609 for @xmath610 .    for the running time of the above algorithm , note that line 1 takes @xmath595 time . for line 2 , we have @xmath611 and @xmath612 , and hence @xmath613 .",
    "thus , lines 2 - 5 take @xmath614 time .",
    "line 6 takes @xmath595 time , and using these values , line 7 can be performed in time at most @xmath614 .      simultaneously try all integers @xmath616 , and for every @xmath588 run the algorithm of lemma  [ lem : trd ] .",
    "terminate whenever any of these algorithms terminates .",
    "this procedure runs in time @xmath617 where the inequality is achieved by taking @xmath618 ."
  ],
  "abstract_text": [
    "<S> we study classes of dynamic programming ( dp ) algorithms which , due to their algebraic definitions , are closely related to coefficient extraction methods . </S>",
    "<S> dp algorithms can easily be modified to exploit sparseness in the dp table through memorization . </S>",
    "<S> coefficient extraction techniques on the other hand are both space - efficient and parallelisable , but no tools have been available to exploit sparseness . </S>",
    "<S> we investigate the systematic use of homomorphic hash functions to combine the best of these methods and obtain improved space - efficient algorithms for problems including linear sat , set partition , and subset sum . </S>",
    "<S> our algorithms run in time proportional to the number of nonzero entries of the last segment of the dp table , which presents a strict improvement over sparse dp . </S>",
    "<S> the last property also gives an improved algorithm for cnf sat with sparse projections . </S>"
  ]
}