{
  "article_text": [
    "the following notation will be adopted .",
    "the single - qubit operators @xmath2 and @xmath3 are the pauli operators @xmath4 , @xmath5 , respectively , and @xmath6 .",
    "we use @xmath7 for the single - qubit hadamard operation , @xmath8 for the rotation through @xmath9 about the @xmath10 axis of the bloch sphere , and @xmath11 for the rotation through @xmath9 about the @xmath12 axis ( phase shift of @xmath13 by @xmath14).thus @xmath15 , @xmath16 and @xmath17 .",
    "the general phase shift of @xmath18 by @xmath19 will be written @xmath20 , so @xmath21 , @xmath22 , etc .",
    "a controlled @xmath23 operation is written @xmath24 , so for example @xmath25 is controlled - not , and @xmath26 is the toffoli gate .    for operations on bare qubits , the most commonly considered universal set of quantum gates is @xmath27 where @xmath28 is a general rotation of a single qubit . however",
    ", this is not a useful set to consider for the purpose of finding fault - tolerant gates on encoded qubits , because @xmath28 is not readily amenable to fault - tolerant methods .",
    "five slightly different proposals for fault - tolerant universal sets have been put forward .",
    "all involve the _ normalizer group _ , generated by @xmath29 @xcite . since @xmath30 and @xmath31 it is sufficient to have @xmath32 to cover this group .",
    "the normalizer group is not sufficient for universal quantum computation , however , nor even for useful quantum computation , since it can be shown that a quantum computer using only operations from this group can be efficiently simulated on a classical computer @xcite . to complete the set",
    "a further operation must be added .    1",
    ".   shor @xcite proposed adding the toffoli gate , making the universal set @xmath33 ( or @xmath34 which is equivalent since @xmath35 ) .",
    "obviously , @xmath36 can be obtained from @xmath37 , but this does not reduce the set since shor s method to obtain @xmath37 assumes that @xmath36 is already available .",
    "knill , laflamme and zurek @xcite proposed @xmath38 together with the ability to prepare the encoded ( or ` logical ' ) states @xmath39 , @xmath40 .",
    "this can be shown to be sufficient since preparation of @xmath41 together with @xmath11 and @xmath2 can produce @xmath7 , and @xmath42 and @xmath36 suffice to produce about some axis can be obtained by combining @xmath25 and single - bit rotations through @xmath43 ; a controlled - controlled rotation through @xmath44 can be obtained by combining @xmath25 and controlled @xmath43 rotations @xcite . ]",
    "@xmath45 , which with @xmath7 makes @xmath46 .",
    "the same paper also considers @xmath47 .",
    "4 .   the same authors subsequently @xcite proposed @xmath48 combined with preparation of @xmath49 .",
    "the latter is prepared by making use of the fact that it is an eigenstate of @xmath7 , and once prepared is used to obtain a @xmath50 operation , from which the toffoli gate can be obtained .",
    "gottesman @xcite showed that @xmath36 , combined with the ability to measure @xmath51 and @xmath52 , is sufficient to produce any operation in the normalizer group .",
    "the universal set is completed by @xmath37 , following shor .    of the above methods , ( 1 ) is a useful starting point and will be used extensively in what follows , but we will need to generalize it to @xmath53 $ ] codes storing more than one qubit per block . ( 2 ) will be considered also , though the codes for which it works turn out to be non - optimal . ( 3 ) will not be adopted because the implementation of @xmath42 involves repeated recoveries against @xmath2 errors before a single recovery against @xmath52 errors is possible .",
    "this means that @xmath52 errors accumulate for a long time before they can be corrected , and the resulting error tolerance is low .",
    "( 4 ) will not be adopted because it is slow , requiring 12 preparations of @xmath54 for every toffoli gate , and the preparation is itself non - trivial .",
    "( 5 ) is important because measurement of @xmath2 , @xmath55 and @xmath52 can be performed fault - tolerantly for any stabilizer code , not just @xmath56 $ ] codes .",
    "gottesman also proposed the use of measurements and whole - block operations to swap logical qubits between and within blocks .",
    "thus the gottesman methods rely heavily on measurement , which might be thought to be disadvantageous .",
    "however , all the methods ( 1 ) to ( 5 ) involve measurement and/or state preparation to implement the toffoli gate @xmath37 . since any useful quantum computation must make significant use of @xmath37 ( otherwise it could be efficiently simulated classically ) , methods ( 1 ) , ( 2 ) and ( 5 ) are all roughly equivalent in this regard .",
    "for example , the speed of shor s algorithm to factorize integers is limited by the toffoli gates required to evaluate modular exponentials @xcite .",
    "so far we have some universal sets of gates , but we lack a construction to show how to achieve the particular operations we might need in a given quantum algorithm . typically quantum algorithms are built up from the normalizer group and the toffoli gate , combined with rotations of single qubits .",
    "preskill @xcite provides a construction using two toffoli gates , measurements and a @xmath11 gate to obtain @xmath57 where @xmath58 . by repeated use of this and the @xmath59 rotations it is easy to build any other rotation to the requisite precision .",
    "note that this trick generalizes as follows : if the @xmath11 gate is replaced by @xmath60 , then the overall result is @xmath57 where @xmath61 .",
    "in the list described in the previous section , ( 1 ) to ( 4 ) gave fault - tolerant operations for certain @xmath56 $ ] calderbank shor steane ( css ) quantum codes @xcite ; this section will discuss the generalization to @xmath53 $ ] codes .",
    "( 5 ) gave fault - tolerant operations for any stabilizer code@xcite ; this section will give details on the application to css codes , and section [ s:3 ] will introduce further refinements .",
    "the css quantum codes are those whose stabilizer generators separate into @xmath2 and @xmath52 parts @xcite .",
    "we restrict attention to these codes , rather than any stabilizer code , because they permit a larger set of easy - to - implement fault tolerant operations , and their coding rate @xmath62 can be close to that of the best stabilizer codes .",
    "the css codes have the property that the zeroth quantum codeword can be written as an equal superposition of the words of a linear classical code @xmath63 , @xmath64 where @xmath65 is a product state , @xmath66 is a binary word , and the other codewords are formed from cosets of @xmath63 .",
    "let @xmath67 be the @xmath68 binary matrix of coset leaders , then the complete set of encoded basis states is given by @xmath69 where @xmath70 is a @xmath71-bit binary word .",
    "we will adopt the convention throughout that symbols with a tilde , such as @xmath67 , refer to binary matrices .",
    "this will avoid confusion between the hadamard operator @xmath7 and a parity check matrix @xmath72 .",
    "we define an operation to be ` legitimate ' if it maps the encoded hilbert space onto itself .",
    "we define an operation to be ` fault tolerant ' if it does not cause errors in one physical qubit to propagate to two or more qubits in any one block .",
    "bitwise application of a two - bit operator is defined to mean the operator is applied once to each pair of corresponding bits in two blocks , and similarly for bitwise three - bit operations across three blocks .",
    "legitimate bitwise operations are fault tolerant",
    ".    the following notation will be useful .",
    "the bar as in @xmath73 is used to denote the operation @xmath23 occurring in the encoded , i.e. logical , hilbert space , thus @xmath74 . a block of @xmath1 physical qubits stores @xmath71 logical qubits .",
    "the notation @xmath75 , where @xmath14 is an @xmath1-bit binary word , means a tensor product of single - qubit @xmath76 operators acting on those physical qubits identified by the 1s in @xmath14 ( for example @xmath77 ) .",
    "the notation @xmath78 , where @xmath70 is a @xmath71-bit binary word , means a tensor product of @xmath79 operators acting on the logical qubits identified by the 1s in @xmath70 .",
    "consider a css code as defined in eq .",
    "( [ ul ] ) .",
    "then the encoded @xmath2 and @xmath3 operators are given by @xmath80 equation ( [ xbar ] ) follows immediately from the code construction , eq .",
    "( [ ul ] ) , and ( [ zbar ] ) follows from @xmath81 , which can be seen from the observation that @xmath82 changes the sign of @xmath83 whenever @xmath84 fails the parity check @xmath14",
    ".    we will now examine operators which can not be expressed as products of @xmath85 and @xmath86 .",
    "* lemma 1 . * for @xmath56 $ ] codes",
    "where all words in @xmath87 have weight @xmath88 , and all words in @xmath89 have weight @xmath90 , bitwise application of the following are legitimate : @xmath91 , @xmath92 , @xmath93 , and achieve respectively @xmath94 , @xmath95 , @xmath96 , where @xmath97 .",
    "_ proof : _ for clarity we will take @xmath98 and @xmath99 , the proof is easily extended to general @xmath100 .",
    "the argument for @xmath101 was given in @xcite , but we shall need it for @xmath102 , so we repeat it here .",
    "consider @xmath101 applied to a tensor product of two codewords .",
    "let @xmath103 be binary words appearing in the expressions for the two codewords , and let @xmath104 be the overlap ( number of positions sharing a 1 ) between @xmath66 and @xmath10 .",
    "let @xmath105 denote the weight of a word @xmath66 .",
    "then @xmath106 .",
    "there are three cases to consider .",
    "first if @xmath107 then @xmath108 and @xmath109 so @xmath110 from which @xmath111 .",
    "therefore the multiplying factor introduced by the bitwise operation is @xmath112 . if @xmath113 and @xmath114 then @xmath115 so @xmath116 so @xmath110 again . if @xmath117 then @xmath118 so @xmath119 and the multiplying factor is @xmath120 .",
    "the resulting operation in the logical hilbert space is therefore @xmath121 .",
    "next consider @xmath93 applied to a tensor product of three codewords .",
    "let @xmath122 be words appearing in the three codeword expressions , and @xmath123 be the overlap between @xmath66 and @xmath10 , @xmath10 and @xmath12 , and @xmath12 and @xmath66 , respectively .",
    "let @xmath124 be the common overlap of @xmath103 and @xmath12 , so @xmath125 there are four cases to consider . if @xmath126 then @xmath127 . if @xmath128 then @xmath129 , @xmath130 from the argument just given , therefore @xmath131 .",
    "if @xmath132 , @xmath133 then @xmath134 , @xmath135 while @xmath136 so again @xmath131 . if @xmath137 then @xmath138 , @xmath139 , therefore @xmath140 .",
    "the overall effect is that of the operation @xmath96 .",
    "@xmath141    lemma 1 applied to codes with @xmath142 or more provides a quicker way to generate the toffoli gate than previously noted , and also provides an extra single - bit gate @xmath143 .",
    "the latter can be used to generate further rotations using the generalized two - toffoli method referred to at the end of section [ s:1 ] . the lemma 1 concept generalizes to @xmath144 and so on , but the codes for which this is useful ( i.e. having @xmath145 ) are either inefficient or too unwieldy to produce good error thresholds .",
    "gottesman @xcite provides an elegant way to find some fault - tolerant operations .",
    "let @xmath146 be the group generated by @xmath1-bit products of @xmath147 where @xmath148 is the identity , let @xmath76 be a member of @xmath146 , and let @xmath149 be the stabilizer .",
    "then for operations @xmath23 satisfying @xmath150 @xmath151 , @xmath23 is legitimate as long as @xmath152 .",
    "this formalism permits one to prove the following straightforwardly :    * lemma 2 . *",
    "bitwise @xmath25 is legitimate for all css codes .",
    "* lemma 3 .",
    "* bitwise @xmath7 and @xmath153 are legitimate for any @xmath154 $ ] css code obtained from a @xmath155 $ ] classical code which contains its dual .",
    "* lemma 4 . *",
    "let @xmath156 be a @xmath155 $ ] classical code which contains its dual , and for which the weights of the rows of the parity check matrix are all integer multiples of 4 .",
    "then bitwise @xmath11 is legitimate for the @xmath154 $ ] css code obtained from @xmath156",
    ".    an alternative proof of these lemmas will emerge as we examine the effect of the relevant operations .",
    "bitwise @xmath25 acts as follows : @xmath157 this is @xmath158 from each logical qubit in the first block to the corresponding one in the second .",
    "bitwise @xmath159 acts as follows on @xmath83 : @xmath160 if @xmath161 contains its dual @xmath63 , as required for lemma 3 , then @xmath67 and @xmath63 together generate @xmath161 , so this can be written @xmath162 where to simplify the power of @xmath163 we used the fact that @xmath63 is generated by the parity check matrix @xmath161 , so @xmath164 satisfies the parity check @xmath132 . equation ( [ hbar ] ) is a hadamard transform acting in the logical hilbert space when @xmath165 , and is a closely related transformation when @xmath166 .",
    "using the above ideas it is easy to show that bitwise @xmath153 produces , for codes satisfying lemma 3 , @xmath167    we will prove lemma 4 by showing that all the quantum codewords have @xmath168 , so the weights modulo 4 of the components in ( [ ul ] ) depend on @xmath70 but not on @xmath66 .",
    "the effect of bitwise @xmath11 will therefore be to multiply @xmath83 by the phase factor @xmath169 .",
    "the zeroth codeword is composed from the code @xmath170 generated by @xmath72 , the parity check matrix of @xmath156 .",
    "let @xmath10 and @xmath12 be two rows of @xmath72 , then the conditions of the lemma guarantee @xmath171 and @xmath172 .",
    "furthermore , since @xmath156 contains its dual , each row of @xmath72 satisfies all the checks in @xmath72 , so @xmath10 and @xmath12 have even overlap @xmath173 .",
    "therefore @xmath174 , therefore @xmath175 for all words in @xmath176 .",
    "next consider a coset , formed by displacing @xmath63 by the vector @xmath177 .",
    "since this coset is in @xmath156 it also satisfies all the checks in @xmath72 , therefore its members have even overlap with any @xmath178 . hence if @xmath179 then @xmath180 for all the terms in the coset , which proves the lemma .",
    "the case @xmath181 , which leads to a simple effect for bitwise @xmath7 , also simplifies bitwise @xmath11 . if @xmath181 then every row of @xmath67 has odd overlap with itself ( i.e. odd weight ) and even overlap with all the other rows . using an argument along similar lines to the one just given",
    ", we deduce that the effect is the @xmath182 operator applied to every logical qubit in the block , where @xmath183 is the weight the relevant row of @xmath67 .",
    "our set of fault tolerant operations now contains sufficient to generate the group @xmath146 of encoded @xmath184 operations on individual logical qubits , and the normalizer group on whole blocks ( @xmath71 logical qubits ) at a time , for the lemma 4 codes .",
    "it remains to extend the normalizer group to individual encoded qubits , and to find a fault tolerant toffoli gate . for the former ,",
    "we adopt gottesman s @xcite proposal of switching logical qubits into otherwise empty blocks , applying whole - block operations , then switching back . for the latter , we use",
    "inter - block switching together with shor s @xcite implementation of the toffoli gate , as simplified by preskill @xcite .",
    "that the shor technique works for lemma 4 ( and lemma 3 ) codes follows from the following :    * lemma 5 . * for css codes in which bitwise @xmath153 is legitimate , bitwise @xmath185 is legitimate when operating on two control blocks in the logical hilbert space , and a target block in the space spanned by @xmath1-bit ` cat ' states @xmath186 .",
    "if bitwise @xmath153 has the effect @xmath187 , then bitwise @xmath185 has the effect @xmath188 , where @xmath189 or @xmath112 and @xmath190 means the @xmath1-bit state @xmath191 or @xmath192 accordingly .    _",
    "proof : _ consider eq .",
    "( [ czbar ] ) and expand @xmath193 into a sum of @xmath194-bit product states @xmath195 .",
    "the bitwise @xmath153 operator can only have the effect ( [ czbar ] ) if the overlap of @xmath66 and @xmath10 is the same , modulo 2 , for every term in the sum .",
    "therefore the bitwise @xmath185 operator as described in lemma 5 produces the same number of @xmath52 operations on the cat state , modulo 2 , for every term in the corresponding expansion , and the effect is as described .",
    "gottesman s switching and swapping techniques make much use of the ability to measure @xmath85 or @xmath86 operators fault tolerantly . a method to perform such measurements",
    "was deduced by divincenzo and shor @xcite , based on preparation of verified ` cat ' states @xmath196 .",
    "however , the preparation and verification of these states involves many elementary gates , and the measurement must be repeated to ensure reliability .",
    "these operations take a considerable number of elementary gates and time steps , during which errors accumulate .",
    "this significantly reduces the tolerance on error rates in the computer .",
    "our next ingredient is an important trick to circumvent this problem :    * lemma 6 .",
    "* for any stabilizer code , measurement of any operator @xmath197 or @xmath198 or @xmath199 can be performed at no cost by merging it with the recovery operation .",
    "we will implement fault tolerant recovery using the method of steane @xcite , which is based on preparing a @xmath194 bit ancilla in a superposition of @xmath200 product states which satisfy the parity checks in the stabilizer . the measurement technique which underlies lemma 6",
    "is illustrated for a css code in figure [ measure ] . in order to measure @xmath201 in this example",
    "we prepare an ancilla in @xmath202 and operate bitwise @xmath25 , then hadamard transform the ancilla and measure it .",
    "this permits us to learn simultaneously the result of measuring @xmath201 on the logical qubits , and the syndrome for @xmath52 errors , which can then be corrected ( the whole network is repeated as necessary , see section [ s:5 ] ) .",
    "replacing @xmath25 by @xmath153 , a measurement of @xmath199 can be accomplished while learning simultaneously the syndrome for @xmath2 errors .",
    "the structure of css codes permits the @xmath194 bit ancilla to consist of two separate blocks of @xmath1 bits , which is why fig .",
    "[ measure ] only shows an @xmath1 bit ancilla . for general",
    "stabilizer codes the method is essentially the same but does not have such an elegant expression in terms of logical qubit states .    a standard recovery , without measurement of any observable other than the syndrome , involves the preparation of @xmath203 .",
    "to prepare @xmath204 from @xmath203 we simply add a one - bit hadamard transform and @xmath25s to target bits at the non - zero coordinates in @xmath205 .",
    "this is only slightly more complicated than preparation of @xmath203 because the number of rows in @xmath72 , which gives the network to construct @xmath203 , is much larger than 1 for powerful error correcting codes .",
    "furthermore , since @xmath204 satisfies fewer parity checks than @xmath203 , the verification of the prepared state is quicker .",
    "hence the claim `` at no cost '' in lemma 6 is justified .    the final ingredient , before we can calculate error tolerance levels for these methods , is to examine exactly how the switching / swapping and toffoli gates work , in order to see how frequently recovery must be performed .",
    "figures [ cnot ] to [ switch ] show example quantum networks .",
    "the examples all show a case in which three logical qubits are stored in each block , and horizontal lines indicate logical rather than physical qubits .",
    "the zigzags on some of the qubits are a visual aid to keep track of the quantum information , which propagates between blocks when operations such as quantum teleportation take place .",
    "the figures show measurements of @xmath85 or @xmath86 taking place by means of cat states .",
    "the networks are drawn in this form to make it clearer how they operate , but it is understood that at this point in the actual implementation the better method of figure [ measure ] and lemma 6 would be used , so a recovery takes place .",
    "the exception is the @xmath185 gate in the network for the toffoli gate , figure [ toff ] , which must have a cat state as target .",
    "this will be discussed shortly .",
    "figure [ cnot ] shows a @xmath25 from the 2nd to the 3rd logical qubit in a data block , using two ancilla blocks prepared in @xmath206 .",
    "the first part of the network is a quantum teleportation from the 2nd bit of the data block to the 3rd bit of the 2nd ancilla .",
    "then a block @xmath25 takes place from this ancilla onto the data block .",
    "finally another teleportation replaces the bit back into the data block .",
    "the whole operation uses four recoveries .",
    "figure [ teleport ] introduces a shorthand symbol for quantum teleportation , and gives two example implementations , depending on which ancilla states ( @xmath207 or @xmath208 , etc . )",
    "one happens to have available .",
    "this is to make the point that teleportation can be carried out via any state in the bell basis , and so the ancillas can be in one of many different initial states .",
    "this reduces the amount of ancilla preparation needed for networks such as figures [ cnot ] and [ toff ] .",
    "figure [ toff ] gives the implementation of the toffoli gate described by preskill @xcite , based on shor s ideas .",
    "the figure does not show the complete network .",
    "the operations in the dashed box are only carried out if the measurement indicated gives a 1 .",
    "if one or other of the two other measurements on the data input block give a one , the network in the dashed box changes , but it still involves simple whole - block operations plus two teleportations .",
    "the other feature not shown on fig . [ toff ] is the repetition of the measurement ( via cat ) used to prepare the ancillas . during its preparation ,",
    "the cat is verified against @xmath2 errors in order that the @xmath209 does not propagate uncorrectable errors into the 3rd ancilla .",
    "however , the cat has a chance of acquiring a @xmath52 error , which makes the measurement fail with probability linear in the error rates .",
    "we therefore repeat this part of the network , using further @xmath1-bit cats prepared in parallel . by choosing a total of @xmath124 repetitions , where @xmath124 is the minimum distance of the error - correcting code",
    "being used , we ensure that by taking the majority vote , the probability of failure is lower than that of accumulating too many errors during recovery .",
    "overall , the toffoli network requires about 8 recoveries , allowing for two recoveries during the ancilla preparation part of the network , one when the data block is measured , two each for the teleportations , and a further one for the final switching operation ( see fig . [ switch ] ) .",
    "figure [ switch ] shows how to switch the @xmath14th logical bit between a data block and an ancillary block , using a single recovery .",
    "in this section we will find css codes which meet the requirements of the fault tolerant methods considered in sections [ s:2 ] and [ s:3 ] .",
    "the general idea is that we would like @xmath210 and its cosets given by @xmath67 to have weight distributions which permit methods such as lemma 1 , while also forming the code @xmath211 , in order to satisfy lemma 3 .",
    "however , the possibilities are restricted by the fact that a self - dual classical code over @xmath212 with weights all a multiple of @xmath213 can only have @xmath214 or @xmath215 @xcite .",
    "css codes @xmath216 $ ] satisfying lemma 1 with @xmath217 can be constructed from punctured binary reed - muller codes , the simplest example is @xmath218 $ ] given in @xcite .",
    "a related possibility is @xmath219 $ ] , @xmath220 in which @xmath63 is a punctured 1st order reed - muller code ( whose dual has minimum distance 3 ) and @xmath63 together with its cosets make a punctured 2nd order reed - muller code .",
    "the simplest example is @xmath221 $ ] .",
    "the properties of these codes are far from optimal , so we will not pursue them further .",
    "let us now concentrate on classical codes suitable for lemma 4 ( and therefore for all of lemmas 26 ) .",
    "let @xmath170 , then by the proof of the lemma , all the weights of @xmath63 are multiples of 4",
    ". such codes @xmath63 are called `` doubly even '' , or `` type ii '' or sometimes merely `` even . ''",
    "doubly even codes are always contained in their duals since the rows of the generator must all have even overlap with themselves and each other .",
    "we will refer to the css codes having doubly even @xmath63 as `` lemma 4 '' codes .",
    "note that once we have a @xmath53 $ ] lemma 4 code , a @xmath222 $ ] lemma 4 code can be obtained by deleting a row from the generator of @xmath63 ( which is the check matrix of @xmath156 ) @xcite .    any extended quadratic residue classical code of length @xmath223 is doubly even @xcite .",
    "this yields a set of good lemma 4 codes beginning @xmath224 $ ] , @xmath225 $ ] , @xmath226 $ ] , @xmath227 $ ]  , in this list only the code of the smallest @xmath1 for given @xmath124 is mentioned .",
    "no better codes exist for @xmath228 , and none better is known to exist for @xmath229 @xcite . from these we obtain lemma 4 codes such as @xmath230 $ ] , @xmath231 $ ] , @xmath232 $ ] which are considered in section [ s:5 ] . in section [ s:5 ] ( eq . ( [ s ] ) ) we will need to know enough about the weight distribution of @xmath210 to estimate the average weight of a row of the generator matrix of @xmath210 .",
    "this average weight is equal to the average weight of the generator of the self - dual code we started from , which is well approximated by its minimum distance in this case ( i.e. respectively 8,12,16,20 for the codes in the first list in this paragraph ) .",
    "bose chaudhuri hocquenghem ( bch ) classical codes @xcite yield a good set of css quantum codes .",
    "the condition for a bch code to contain its dual was discussed in @xcite .",
    "it can be shown that the dual of double- and triple - error correcting bch codes of length @xmath233 is doubly even when @xmath234 @xcite , and i conjecture that the dual of a bch code of length @xmath233 is doubly even whenever the code contains its dual .",
    "i have checked that this conjecture is satisfied for @xmath235 by examining the parity check matrices .",
    "hence we have a large class of lemma 4 codes , containing for example @xmath236 $ ] , @xmath237 $ ] , @xmath238 $ ] , @xmath239 $ ] , @xmath240 $ ] , @xmath241 $ ] , @xmath242 $ ] , and @xmath243 $ ] by conjecture . of these ,",
    "the codes @xmath242 $ ] and @xmath241 $ ] yield the best results in section [ s:5 ] . for length @xmath244 bch codes ,",
    "the weights of the rows of the parity check matrix are @xmath245 .",
    "this value is required in section [ s:5 ] ( equation ( [ s ] ) ) .",
    "we now wish to estimate the amount of noise which can be tolerated by a quantum computer using the methods discussed .",
    "the estimate is made through an analysis based on that in @xcite , but with some new features .",
    "the quantum computer will operate as follows .",
    "a computation involving @xmath246 logical qubits will be carried out using @xmath247 blocks to store the quantum information , plus a further @xmath248 blocks which act as an `` accumulator '' .",
    "each accumulator block uses the same error correcting code as the rest of the computer , but only stores one logical qubit at a time .",
    "quantum gates on the logical information in the computer are carried out via the accumulator using the methods illustrated in figs [ cnot ] to [ switch ] .",
    "a larger accumulator of @xmath249 blocks could be used without greatly changing the overall results .    in order to extract syndromes ,",
    "we prepare , in parallel , 4 ancillary blocks for every data block or accumulator block in the computer .",
    "a single complete syndrome is extracted for the @xmath250 blocks , using 2 of the prepared ancillas for each block .",
    "whenever this first syndrome indicates no errors , we accept it even though it has a small chance of being the wrong syndrome @xcite .",
    "those blocks are left alone , any errors they contain will with high probability be corrected by the next recovery .",
    "there remain a number of blocks whose first syndrome was non - zero .",
    "each of these blocks will be corrected , but only after the syndrome has been extracted a further @xmath251 times , and the best estimate syndrome ( e.g. by majority vote ) is used to correct the block .",
    "the ancillas required for these further extractions have already been prepared : they are the remaining @xmath252 ancillas which were not used for the first syndrome .",
    "each ancilla uses @xmath1 qubits to store the prepared state , plus one used for verification , therefore the total number of physical qubits in the computer is @xmath253 . the ratio @xmath254 is the scale - up in computer size necessary to allow fault tolerance by this method .",
    "the method described in the previous paragraphs makes better use of ancillas than the simplest approach of generating @xmath251 syndromes for every block . in order that the prepared ancillas are sufficient in number , we require that the probability of obtaining a non - zero syndrome is less than @xmath255",
    ". we will confirm that this is the case at the end of the calculation .",
    "we need to estimate the number of elementary gates and time steps required to prepare an ancillary @xmath1-bit block in the state @xmath256 , and to verify the state so that the only @xmath2 errors which remain in it are uncorrelated with each other .",
    "let @xmath72 be the generator of @xmath210 , and let @xmath257 be the average weight of a row of @xmath72 .",
    "we would like @xmath257 to be small so that ancillas can be prepared quickly but the construction of @xmath53 $ ] css codes rules this out for @xmath258 . since all the cosets used to build the quantum codewords ( see eq .",
    "[ ul ] ) are at distance at least @xmath124 from each other , @xmath210 must consist of words separated by significantly more than @xmath124 , so @xmath257 may be several times larger than @xmath124 .    the network to build @xmath207 consists of one hadamard gate and @xmath259 controlled - nots for each row of @xmath72 . in @xcite it was assumed that gates on different blocks could be performed in parallel , while 2- or more - bit gates within a block could not .",
    "here we shall allow a further type of parallelism , namely that a multiple controlled - not , involving one control bit and several target bits in the same block , can be performed in a single time step .",
    "this is physically reasonable since it is possible in implementations such as the ion trap , in which a communal degree of freedom is coupled to every qubit in a block , and we can drive transitions in many qubits simultaneously .",
    "the number of time steps required to build @xmath207 is therefore equal to the number of rows in @xmath72 , which is @xmath260 .",
    "the most time - consuming part of the ancilla preparation is the verification .",
    "this involves the evaluation of parity checks using controlled nots from several control bits to a single target bit , which can not be done in parallel .",
    "we will assume a thorough verification , evaluating all the parity checks in @xmath72 and @xmath67 .",
    "the former confirms that the prepared state is in the encoded hilbert space , the latter that @xmath203 rather than some other encoded state has been prepared . to keep the number of time steps to a minimum , we arrange for @xmath67 to contain as few 1s as possible .",
    "since we have a distance @xmath124 css code , the weight of each row of @xmath67 is at least @xmath124 .",
    "we will assume @xmath67 can be arranged to have a mean weight per row of @xmath261 .",
    "hence the total number of @xmath25 gates used for verification of one ancilla is @xmath262 .",
    "one complete recovery of the computer fails if any block develops more than @xmath263 errors , or any correction is applied on the basis of a wrong syndrome .",
    "it is shown in @xcite that the failure probability is dominated by the former when the syndrome is extracted @xmath264 or more times .",
    "first consider the blocks whose first extracted syndrome was non - zero .",
    "for one of these blocks the probability to develop more than @xmath265 errors is @xcite @xmath266 where @xmath267 is the probability of gate failure , @xmath268 the probability of memory error per time step , and @xmath269,@xmath270 are the number of independent opportunities for gate , memory errors respectively .",
    "the errors either occur directly in the block to be corrected , or they originate in an ancilla and are subsequently propagated into the block . using the assumptions made above concerning the weights of @xmath72 and @xmath67 , and the degree of parallelism , an analysis similar to that in @xcite yields @xmath271 where @xmath183 is the number of repetitions of the syndrome extraction required on average for confidence that one has the right syndrome .",
    "we will take @xmath272 , which is a safe over - estimate , as discussed in @xcite .",
    "the only possibility left out of equation ( [ p ] ) is that a zero syndrome is wrongly obtained for some block during the first round of syndrome extraction ( thus the block remains uncorrected ) , and then the further errors developed during the next recovery bring the total up to more than @xmath265 before correction is applied .",
    "consider the two successive recoveries of such a block , in which no corrective measure is applied after the first recovery .",
    "there are approximately twice as many error opportunities , so the probability that @xmath273 errors develop can be estimated as @xmath274 . however , to wrongly obtain a zero syndrome requires an error in the syndrome which matches the syndrome , which is highly unlikely .",
    "its probability is small compared to @xmath275 , therefore this failure mechanism is much less likely than the one leading to eq .",
    "( [ p ] ) .    to run a quantum algorithm needing @xmath246 qubits and @xmath276 toffoli gates ,",
    "we require @xmath277 since we require @xmath278 recoveries of each block ( see section [ s:3 ] ) and there are @xmath279 blocks , and all these recoveries must succeed so that the overall success probability is greater than a half .",
    "table 1 shows the scale - up and error rates needed to satisfy ( [ p ] ) to ( [ plim ] ) for various quantum error correcting codes , for @xmath280 .",
    "this size of computation is sufficient to factorize a 130 digit ( 430 bit ) number using shor s algorithm @xcite . comparing the @xmath242 $ ] and @xmath241 $ ] codes with the @xmath230 $ ] and @xmath231 $ ] codes we see that the more efficient codes allow one to save about a factor 10 in the scale - up @xmath149 , with no change in noise level , or a factor 17 in @xmath149 if the memory noise @xmath268 is reduced by a factor 3 .",
    "if we wish to factorize thousand - digit numbers , then @xmath281 grows by a factor @xmath282 .",
    "however , @xmath11 scales as @xmath283 so ( [ plim ] ) would still be satisfied by the distance 15 codes if @xmath267 and @xmath268 were reduced by a factor 3 .",
    "the assumption that eq .",
    "( [ scaleup ] ) allows for sufficiently many ancillas needs to be verified .",
    "the probability @xmath284 of obtaining a non - zero syndrome can be estimated using eq .",
    "( [ p ] ) but letting the sum run from 1 to @xmath269 instead of @xmath273 to @xmath269 .",
    "this gives @xmath285 when @xmath286 .",
    "examining table 1 , we find @xmath284 is largest for the distance 15 codes having @xmath287 and @xmath288 , which give respectively @xmath289 using @xmath290 , @xmath291 respectively .",
    "the former case is satisfactory , since if there are @xmath292 blocks in the computer , then after the first syndrome extraction we have @xmath293 available ancillas and we only need @xmath294 to complete the 8-fold repetition of extraction of the non - zero syndromes .",
    "the latter case ( @xmath295 ) is not satisfactory , but becomes so if we reduce @xmath267 to @xmath296 .",
    "this confirms eq .",
    "( [ scaleup ] ) .    to conclude , fault tolerant quantum computing can work well with efficient quantum error correcting codes such as the @xmath242 $ ] css code obtained from the classical @xmath297 $ ] bch code .",
    "the success relies on the ability to merge useful measurements on the logical state with recovery operations , on careful network design and on optimized use of ancillas .",
    "these insights allow large quantum computations , such as factorization of 100 or 1000-digit numbers , to proceed on a quantum computer about an order of magnitude smaller than previously thought , without change in the necessary noise level .",
    "the fault tolerant quantum computer need only be about one order of magnitude larger than the logical computer contained within it .",
    "e. knill , r. laflamme and w. h. zurek , `` resilient quantum computation : error models and thresholds , '' _ proc .",
    "lond a _ * 454 * , 365 - 384 ( 1998 ) ; _ science _ * 279 * , 342 - 345 ( 1998 ) .",
    "( lanl eprint quant - ph/9702058 )                                           table 1 .",
    "error rates and scale up required to run a quantum algorithm of size @xmath299 .",
    "the first column gives the parameters of the quantum code , which is identified in section [ s:4 ] .",
    "the 2nd column gives the required success probability for recovery of a single block ( eq .",
    "( [ plim ] ) ) .",
    "the 3rd and 4th columns give the required error rates ( eqs .",
    "( [ p])([s ] ) ) , and the final column gives the scale - up in computer size ( eq .",
    "( [ scaleup ] ) ) ."
  ],
  "abstract_text": [
    "<S> fault tolerant quantum computing methods which work with efficient quantum error correcting codes are discussed . </S>",
    "<S> several new techniques are introduced to restrict accumulation of errors before or during the recovery . </S>",
    "<S> classes of eligible quantum codes are obtained , and good candidates exhibited . </S>",
    "<S> this permits a new analysis of the permissible error rates and minimum overheads for robust quantum computing . </S>",
    "<S> it is found that , under the standard noise model of ubiquitous stochastic , uncorrelated errors , a quantum computer need be only an order of magnitude larger than the logical machine contained within it in order to be reliable . </S>",
    "<S> for example , a scale - up by a factor of 22 , with gate error rate of order @xmath0 , is sufficient to permit large quantum algorithms such as factorization of thousand - digit numbers .    </S>",
    "<S> = -10 mm    * keywords * quantum error correction , quantum computing , fault tolerant    the future of computing lies in fault - tolerant architectures . </S>",
    "<S> this is true both of classical computing methods , and of future quantum computers . in both cases </S>",
    "<S> the reason is that it is much easier to build a device with significant imperfections , but with the flexibility to work around them , than it is to build an essentially `` perfect '' physical device ( one whose chances of failure during any required task are acceptably small ) . </S>",
    "<S> there is a profound dichotomy at work here , between the power of information processing , and the effects of random noise and imprecision . </S>",
    "<S> the central point is that information processing itself provides powerful techniques to protect against information loss .    </S>",
    "<S> it is a striking feature of biology that from the molecular level ( e.g. transcription of dna ) , up to the operations of organs or the whole organism , the operating principle involves imperfect structures with built - in self - correction , rather than close to perfect structures . in classical computing methods , </S>",
    "<S> self - correction has played a part , but it has not so far been such a central and all - pervasive ingredient . </S>",
    "<S> however , this appears set to change , since as circuit elements get smaller it becomes at once harder to make them precisely and easier to make sufficiently many that a fraction can be devoted to error - correction at little cost @xcite .    in quantum computing </S>",
    "<S> @xcite the need for error correction is paramount right from the start , since it appears that it may be _ impossible _ to find a physical system which could be sufficiently precise and isolated to constitute a useful ` bare ' quantum computer . here , by a ` bare ' quantum device we mean one whose physical operation only involves elements ( qubits , gates , etc . </S>",
    "<S> ) essential to the logical structure of the task in hand , and by a ` useful ' quantum computer we mean a general - purpose quantum computational device which could tackle computing tasks not readily solvable by other means ( such as classical computing ) . it seemed up until only a few years ago that this difficulty ruled out useful quantum computers altogether , since it was unknown how to achieve error correction in quantum processing . </S>",
    "<S> we now know how to realise quantum error correction @xcite and fault tolerant quantum circuits @xcite , at a cost in the size and speed of the computer . </S>",
    "<S> thus , useful quantum computing appears to be allowed by the laws of nature , and there are two questions which present themselves :    1 .   _ what is the maximum quantum computing power achievable in a system of given dimension and noise rates ? </S>",
    "<S> _ 2 .   </S>",
    "<S> _ how is the maximum attained ? _    these questions are important both from the point of view of our understanding of fundamental physics , and from the practical point of view of building quantum computers . </S>",
    "<S> they are the subject of this paper . </S>",
    "<S> their practical importance is large because quantum computers are so hard to make : controllable qubits are a precious resource which we wish to use as efficiently as possible . up till now , </S>",
    "<S> proposed fault tolerant quantum computing methods have been inefficient because they are based on inefficient quantum coding , in which only a single qubit is stored in each block of @xmath1 qubits @xcite . </S>",
    "<S> this results in a physical quantum computer which is a hundred to a thousand times larger than logical machine embedded within it , if we wish to run a large quantum algorithm such as factorization of hundred- or thousand - digit numbers @xcite .    </S>",
    "<S> it is known that more efficient codes exist @xcite . </S>",
    "<S> knill @xcite discussed ways to find operations on general codes and recently gottesman @xcite derived a complete set of fault tolerant operations which can work with efficient quantum codes . </S>",
    "<S> however , these methods require further refinement if we are to profit by them , otherwise the greater complexity of the operations lowers the error tolerance , thus offsetting the gain in coding efficiency .    </S>",
    "<S> this paper discusses fault tolerant computing using efficient quantum codes , including specific example codes and estimates of the noise rates which can be tolerated . </S>",
    "<S> section [ s:1 ] considers universal sets of quantum gates , and sections [ s:2],[s:3 ] discuss a universal set of fault tolerant operations for calderbank shor steane ( css ) quantum codes satisfying certain requirements . </S>",
    "<S> section [ s:4 ] obtains classes of codes satisfying the requirements , and section [ s:5 ] discusses fault tolerant recovery for these codes . </S>",
    "<S> the analysis of the whole method yields an estimate for the error rate which can be tolerated and the total computer size needed . </S>",
    "<S> the main conclusion is remarkable : to run a given large quantum algorithm , with given tolerated error rates in the memory and elementary operations , the physical quantum computer can be an order of magnitude smaller than previously thought . </S>",
    "<S> this represents a significant step forward both for the practical prospects of quantum computation , and towards understanding the fundamental physics underlying questions ( 1 ) and ( 2 ) enumerated above . </S>"
  ]
}