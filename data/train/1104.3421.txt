{
  "article_text": [
    "for more than half a century mathematicians and computer scientists have known that final victory is impossible in the struggle to attain ultimate predictability . even for deterministic systems",
    "we have accepted that there are truths and facts about these systems which will remain unproven , as shown by kurt gdel and alan turing for formal axiom systems and computing machines .",
    "this does nt mean that we have to give up on gaining new insights through the study of predictability and unpredictability in deterministic systems .",
    "more and more powerful computing machines made possible tasks that has hitherto seemed impossible , and it was nt long after gdel and turing s work when people started asking how much time a task would take if performed with one rather than another algorithm .",
    "the need for a notion of complexity became clear .",
    "although not formally spelled out , in a letter written to von neumann ( princeton , march 20 , 1956 ) , gdel himself had already proposed a first version of the p@xmath0np ?",
    "problem in terms of finite problems of quadratic time ( the letter came to light in 1988 ) .",
    "efficiency became a guiding principle in the design of algorithms , but the idea of designing an algorithm capable of producing optimal algorithms was found to be equivalent to the halting problem . for if there were a way to find such an algorithm , gdel and turing s unsolvable and undecidable problems would be solved .",
    "therefore one has no choice but to exchange idealistic goals for realistic approximations . in this paper",
    "we present an experimental approach for dealing with the notion of computational irreducibility as connected to the problem of empirical unpredictability .",
    "we think our approach is a novel one , in which we bring to a formal framework ( a computer experiment ) a notion we believe is largely epistemological in nature ( computational irreducibility ) .",
    "will looking at the behavior of a system for certain times and in certain cases tell you anything about the behavior of the system at a later time and in the general case ?",
    "for example , the phase transition measure presented in @xcite implies that one may , within limits , be able to predict the overall behavior of a system from a segment of initial inputs based on the prior variability of said system .",
    "experience tells us we would do well to predict future behavior on the basis of prior behavior ( a bayesian hypothesis ) , yet we know this is impossible in the general case due to the halting problem .",
    "this is also related to israeli and goldenfeld s @xcite findings .",
    "they showed that some computationally irreducible elementary cellular automata ( eca ) have properties that are predictable at certain coarse - grained levels .",
    "they did so by employing a renormalization group technique , a mathematical apparatus that allows one to investigate the changes in a physical system as one views it at different distance scales .",
    "they sought ways to replace several cells of an automaton with a single cell .",
    "however , their prediction capabilities too are bedeviled by the unavoidable ( and ultimately undecidable ) induction problem of whether one can keep on predicting for all initial conditions and for any number of steps , without having to run the system for all possible initial conditions and for an arbitrary number of steps .",
    "the question is , then , under what circumstances this kind of large - scale prediction is possible . for eca rule 30 in wolfram s",
    "ca enumeration @xcite , for example , this large - scale approach does nt seem to say very much .",
    "in many cases , it may at most predict a few steps ahead , meaning that while the behavior of the system is not completely chaotic , it is unpredictable , in the sense that one can not in general predict an arbitrary number of steps ahead without having to run the entire computation step - by - step . for many systems ,",
    "including the most random - looking ones , overall behavior can not be expected to change much .",
    "one of the main features of systems in wolfram s class 4 @xcite is precisely the existence of pervasive structures that one can predict up to a certain point .",
    "what is surprising is that in all these fully deterministic and extremely simple systems , such as eca , not every aspect of their evolution is trivially predictable , not because of a problem of measurement or hypersensitivity , but because we do nt know whether there are any shortcuts  whether they exist or how to systematically find them . and",
    "some of these questions are reducible to the halting problem .",
    "there are several forms of irreducibility in computing systems , ranging from undecidability to intractability to nonlinearity .",
    "the principle of computational irreducibility as set forth in @xcite states that while some computations may admit shortcuts that allow them to be simulated more rapidly by another system , most non - trivial systems would require a simulation with roughly the same number of steps as that of the simulated one",
    ". in other words , other than by performing every step at a faster speed ( say with a faster computer ) non - trivial computational processes can not be simulated faster than they occur .",
    "wolfram does nt seem to take a position on whether this is an ontological or an epistemological matter .",
    "that is , whether there is no such shortcut or whether in the general case such a shortcut is not known .",
    "the authors think that the principle , in the context originally stated , admits an epistemological interpretation .",
    "although computational irreducibility and traditional computational complexity are concerned with time , wolfram s principle is intrinsic to the computer system , in that it is independent of any external resource such as the input of the system .",
    "traditional time complexity is a measure based on the asymptotic behavior of a system with regard to the length of its inputs .",
    "one can not say , however , whether a machine with a fixed input belongs to a particular time complexity class , while wolfram s computational irreducibility question does still apply .",
    "we will therefore not discuss the traditional complexity measures , as we think they do not capture the notion of computational irreducibility , not being defined for a computation starting from a given fixed initial configuration .",
    "other non - constructive measures of complexity and related results , such as blum s speed - up theorem , while related and pertinent , belong to the highly non - constructive branch of computability theory .",
    "for some , existence without a constructive method may be as meaningful as non - existence .",
    "computability theorists have , however , managed to present negative results in a positive way by means of the highly non - constructive frameworks in which they are set forth .",
    "blum s speed - up theorem asserts that there exist problems for which finding the optimal algorithm can not be achieved . for every algorithm that solves a problem",
    ", there is always another one that is _ significantly _ faster .",
    "the proof of the speed - up theorem is given in @xcite .",
    "arguments used to defend the position that this theorem is not relevant for practical computing are known in the literature @xcite .",
    "more effective versions of blum s theorem concerning _ occasional _ speedup allow an algorithm to compute a function faster for a certain number of arguments , and even an infinite number of them , while possibly computing the rest of the arguments at a slower pace . if one assumes that blum s speedup theorem is effective for an initial segment of values of a function , this leads to a strange situation where the faster program is known to be one among a finite set of programs that are about equally efficient , and which compute functions having a finite number of incorrect values , thereby introducing a degree of uncertainty into their prediction capabilities .",
    "there seems therefore to be a connection between prediction certainty and effectiveness : the more constructive , the greater the unpredictability .    without diminishing the importance of theoretical approaches such as the speed - up theorem , we quote the following observation attributed to david deutsch @xcite :    _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ the theory of computation has traditionally been studied almost entirely in the abstract , as a topic in pure mathematics .",
    "this is to miss the point of it .",
    "computers are physical objects , and computations are physical processes .",
    "what computers can or can not compute is determined by the laws of physics alone , and not by pure mathematics .",
    "_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _    sutner @xcite also points out that deutsch :    _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ [ m]akes an important point : the kinds of computations that can be physically realized , at least in the context of some idealized model of physics , are not well represented by the purely mathematical theory of computation . _",
    "_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _    ours is an experimental approach , and a novel test combining both a philosophical discussion and a computer simulation .",
    "but we are neither interested in entering into an ontological discussion about the relationship between physics and mathematics nor in purely theoretical measures of time complexity . rather , we are interested in the consequences of undertaking an experiment , i.e. , in the performance of this basic computer simulation as a way of gaining insight into the notion of computational irreducibility and as a contribution to the discussion of this epistemic question in a more formal , albeit experimental , context",
    ". our approach may stimulate further empirical investigation into this kind of computational irreducibility .",
    "the tests consist of having an algorithm try to foresee a computation , given a certain computational history . by levin s semi - measure @xcite @xmath1 , we know that one can construct a prior distribution based on this computational history , and that there is no better way ( with no other information available ) to predict an output than by using @xmath1 . but",
    "@xmath1 is not computable .",
    "the alternative option is therefore to apply a battery of known algorithms to a sequence of outputs to see whether the next output can be predicted .",
    "the obvious thing to do is to try to capture the behavior of various systems and see whether one can say something about their future evolution .",
    "this is the approach we adopt .",
    "we will often refer to the collection of turing machines with @xmath2 states and @xmath3 symbols as a turing machine space denoted by ( n,2 ) .",
    "we ran all the one - sided turing machines in ( 2,2 ) and ( 3,2 ) for 1000 steps for the first 21 input values @xmath4 .",
    "if a turing machine did not halt by 1000 steps we say that it diverged ( the computation did nt reach a value upon halting ) .    clearly , at the outset of this project we needed to decide on at least the following issues :    [ item : representingnumbers ] how to represent numbers on a turing machine .    how to decide which function is computed by a particular turing machine .    how to decide when a computation is to be considered finished",
    "we collected all the functions for the 21 inputs and compared the time complexity classes , the number of outputs and the number of different functions computed between ( 2,2 ) and ( 3,2 ) , as well as the number of outputs , in order to determine what function a machine was computing .      in our experiment",
    "we have chosen to work with deterministic one - sided single - tape turing machines , as we have done before @xcite for experiments on trade - offs between time and program - size complexity .",
    "that is to say , we work with turing machines with a tape that is unlimited to the left but limited on the right - hand side .",
    "one - step transitions in the classical turing machine model are defined to cost one time unit each .",
    "one - sided turing machines are among the common conventions in the literature , perhaps second only to two - sided turing machines .",
    "the following considerations led us to work with one - sided turing machines , which we found more suitable than other configurations for our experiment .",
    "there are @xmath5 @xmath6-state @xmath7-symbol one - sided tape turing machines .",
    "that means 4096 in ( 2,2 ) and 2985984 in ( 3,2 ) .",
    "the number of turing machines grows exponentially when states are added . for representing the data without having to store the actual outputs , which were likely to rapidly exceed our hardware capabilities , we needed to devise a representation scheme that was efficient with regard to optimizing space ( hence non - unary ) . on a one - sided tape which is unlimited to the left , but limited on the right , interpreting a tape content that is almost uniformly",
    "zero is straightforward .",
    "for example , the tape @xmath8 would be interpreted as a binary string read as 5 in base 10 .",
    "the interpretation of a digit depends on its position in the number .",
    "e.g. in the decimal number 121 , the leftmost 1 corresponds to the hundredths , the 2 to the tenths , and the rightmost 1 to the units .",
    "for a two - sided infinite tape one can think of many ways to come up with a representation , but all seem rather arbitrary .    with a one - sided tape",
    "there is also no need for an extra halting state .",
    "we say that a computation simply halts whenever the head",
    " drops off \" the right hand side of the tape .",
    "that is , when the head is on the cell on the extreme right and receives the instruction to move right . a two - way unbounded tape would require an extra halting state , which in light of these considerations is undesirable . by exploring a whole finite class",
    ", one avoids the choice of an enumeration that is always arbitrary or difficult to justify otherwise .",
    "this is because the actual enumeration in our exhaustive approach is not relevant , thereby ensuring that we go through each of the machines in the given space once and only once .",
    "of course this is feasible because every ( n,2 ) space is finite .",
    "on the basis of these considerations , and the fact that work has been done along the lines of this experiment @xcite , we decided to fix this turing machine formalism and choose the one - way tape model .",
    "we decided to represent the input in unary . from a theoretical standpoint it is desirable that the empty tape input be different from the zero input .",
    "thus the final choice for our input representation was to represent the number @xmath9 by @xmath10 consecutive 1s .",
    "a discussion of the choice of input representation is available in @xcite .",
    "the general question of whether a function is defined by the computation of a particular turing machine is undecidable because there is no general finite procedure to verify that @xmath11 for all @xmath9 . whether two turing machines define the same function is undecidable for the same reason . in accordance with convention",
    ", we say then that a turing machine @xmath12 computes a function @xmath13 if @xmath14 upon halting produces as output the result of evaluating @xmath13 with the argument @xmath9 .",
    "one also has to impose some restrictions on the number of steps allowed and weaken the definition of a function computed by a turing machine , given that one can not finitely test whether a machine computes a function for every input / argument .",
    "theory tells us that when we let the machine run further the probability of halting drops exponentially @xcite .",
    "there will always be arbitrary choices imposed by the restrictions of the halting problem .",
    "the choice of a 1000 step cutoff , however , is prompted both by the known values of the busy beaver with 4 states and 2 symbols ( that is , 107 steps ) and the results in @xcite , on the basis of which we decided to let the machines run up to about 10 times the number of steps traversed by a busy beaver with 4 states and 2 symbols with empty input , given that we were feeding the machines with other than just empty inputs ( that is , with the 21 different values defining the function ) . for verification and convergence investigation ,",
    "the bound was sometimes taken to a different number of fixed steps during the experiment ( we will point out when this is the case ) .",
    "obviously it is to be expected that given a cutoff of 1000 steps , some machines would halt while others would not . those not halting may fail to do so either because they take more than 1000 steps to halt or because they never halt .",
    "we decided , therefore , to complete what we called the non - genuine _ divergers _ with a predictor program as described in [ predictor ] , one that would look at the values obtained from the machines that did halt and try to predict the values of the machines that did nt .",
    "we say that a machine diverges if after the cutoff it hasnt halted ( and therefore has not converged to any value by this number of steps ) .",
    "we call a machine a _ non - genuine diverger _ if it halts in finite time after the cutoff of 1000 steps .",
    "we call it a _ genuine diverger _ if it never halts .",
    "as expected , given the halting problem one can not really know whether a sequence or a sequence value is a genuine or non - genuine diverger .",
    "one can , however , make an informed guess about whether a computation may halt by looking at the computational history of the machine for the other function values .    while for theoretical reasons one can not guarantee that completion of the sequences with a predictor program will be flawless , error was reduced by comparing the predicted completion with the values obtained by running the machine for a few more steps ( for machines that we suspected to be non - genuine divergers ) .",
    "we are aware that errors may have occurred in the completion , and they can not be eliminated . however , the approximation we arrive at by deciding the halting problem and running all machines upon halting is better than doing nothing and making comparisons among incomplete sequences .",
    "as explained before , we will consider two turing machines to have calculated the same function if ( after completion ) they compute the same outputs on the first 21 inputs ( 0 through 20 in unary , even if divergent in some points ) , within the defined runtime bound .",
    "the experiment results comprise sequences of 21 values , one for each of the 21 unary inputs . for 21 inputs",
    "this means that 86016 and 62705664 machines ran up to 1000 steps each for ( 2,2 ) and ( 3,2 ) , for which a program written in c running on a supercomputer with 24 cpu s was used , taking about 3 hours each for a total of 70 cpu hours .",
    "the function findsequencefunction , built into the computer algebra system _ mathematica _ , takes a sequence of integer values @xmath15 to define a function that yields the sequence @xmath16 .",
    "findsequencefunction finds results in terms of a wide range of integer functions , as well as implicit solutions to difference equations represented by the expression differenceroot in _",
    "mathematica_. by default differenceroot uses early elements in the list to find candidate functions , then validates the functions by looking at later elements .",
    "differenceroot is generated by functions such as sum , rsolve and seriescoefficient .",
    "rsolve can solve linear recurrence equations of any order with constant coefficients .",
    "it can also solve many linear equations ( up to second order ) with non - constant coefficients , as well as many nonlinear equations .",
    "since this is not the place to define exactly what differenceroot , seriescoefficient or rsolve do , one can think of the predictor based on findsequencefunction as a black box computer specializing in the prediction of integer sequences using advanced symbolic and numerical tools together with regression analysis . evidently writing an ultimate algorithm to make perfect predictions is impossible due to the halting problem",
    ", so one can only rely on limited specialized implementations of these kinds of predicting programs . for our purposes ,",
    "findsequencefunction can be seen as a specialized turing machine for integer sequence prediction .",
    "the predictor program takes the successive output values in base 10 of a turing machine for the sequence of 21 inputs in unary up to the first divergent ( non - halting upon the chosen runtime ) value and tries to predict the divergent output .",
    "the same sequence - generating function obtained is used to complete the sequence if other non - convergent values exist .",
    "this is an example of a completed turing machine output sequence . given ( 3 , 6 , 9 , 12 , -1 , 18 , 21 , -1 , 27 , -1 , 33 , -1 )",
    "it is retrieved completed as ( 3 , 6 , 9 , 12 , 15 , 18 , 21 , 24 , 27 , 30 , 33 , 36 ) .",
    "notice how the divergent values denoted by @xmath17 are replaced with values completing the sequence with the predictor algorithm based in _ mathematica _",
    "s findsequencefunction . to begin with , we were interested in investigating how many sequences were :    fully completed    partially completed    not completed at all    and of ( 1 ) and ( 2 ) , what percentage ( a ) had been correctly completed ( b ) had been incorrectly completed .",
    "the only way to verify ( a ) is by running the turing machine for more steps .",
    "an alternative is to look at the rule and try to figure out its behavior , but that does nt always work , and we know it is impossible to get right because of the halting problem .",
    "we also know that because of the halting problem ( a ) can not be determined with absolute certainty .",
    "however , we wanted to quantify the deviation from certainty and ascertain whether the process managed to partially complete some divergent values of some sequences .",
    "we ran the turing machines up to @xmath18 , and in some cases for more steps , to see whether we had managed to shortcut the computation .",
    "an objection that may be raised here is that the function design may favor certain sequences over others .",
    "this is certainly the case , and it could be that the particular set of algorithms is such that they are unable to partially complete a sequence",
    ". the objection would thus not be entirely invalid and would seem to apply to any prediction procedure devised .",
    "let s see , however , what we mean by a partially completed sequence .",
    "the predictor function is defined in such a way that it either finds the sequence - generating function or it does not .",
    "if it does , nothing prevents it from calculating any value , other than perhaps constraints on the hardware ( _ mathematica _ is machine - precision dependent only ) .",
    "if the function does not find the sequence - generating function , then it wo nt calculate any value , leaving no room for partial completion . to work around this problem",
    ", we also focused on the sequences completed incorrectly . to this end , we ran the machines for further steps and compared them , then fed the predictor once again with more values .",
    "it may also be that the machines in ( 3,2 ) are all computationally too simple even for non - empty inputs , in which case we would like to instigate further experiments . however , whether or not they are too simple , there were eight cases in ( 3,2 ) in which the predictor program could not complete the sequences .",
    "these were the cases in which the turing machines used the greatest amount of resources , with the greatest runtimes and space usages , as shown in table 3 .",
    "the predictor program , however , allowed us to identify these cases by failing to complete them .",
    "[ summary ]    .maximum runtimes and space usage produced by ( 3,2 ) . [ cols= \"",
    "> , > , > \" , ]     among the non - genuine divergers , 0.81% of them converged after @xmath18 steps , which means we most likely identified all non - genuine divergers . in the end , among the completed turing machines only eight did nt match the second prediction ( were not completed ) , and needed to run as many as @xmath19 steps to halt , with the exact greatest halting times @xmath20 .",
    "we looked at the maximum runtime of each turing machine in ( 3,2 ) and selected those functions that had some divergent values , with one runtime greater or equal to 480 steps . among the 3368 turing machines computed in ( 3,2 ) after 1000 steps , there were 248 divergent sequences ( i.e. turing machines that did not halt up to that runtime for at least one of the 21 inputs defining the function ) and at least one convergent value taking at least 480 steps .",
    "we chose this runtime to explore because we found that computations with close to maximal runtimes ( 1000 steps ) were likely to be trivial ( e.g. computations that go straight over the tape printing the same symbol ) and therefore less interesting ( and easy ) to complete ( something that we verified by sampling a subset of these machines ) .",
    "moreover , after further calculation , these computations were found to be true divergers , because we ran them for 4000 steps with no new values produced .",
    "refer to the process of completing the sequences of function outputs , runtimes and space usage of a turing machine over the 21 inputs ( as described in [ experiment ] ) as a prediction .",
    "the process of predicting all the sequences ( output , runtime , space usage ) of a turing machine for 21 inputs is obviously more important than predicting a single one of these sequences ( e.g. the output ) .",
    "predicting the three sequences of a turing machine for the 21 values is equivalent to predicting the exact path for computing an outcome , in other words , the exact algorithm .",
    "to reduce costs given the number of predictions we had to perform , we ruled out some symmetrical cases .",
    "for each turing machine in ( n,2 ) there is another one carrying out exactly the same computation ( this is because the generating rules are symmetrical , and they start over the same initial configuration ) .",
    "we called these twin turing machines and reduced the data by half thanks to this symmetry .",
    "so for each pair of twin rules only one rule in each pair was selected .",
    "hence we considered 1684 sequences .",
    "we ran the predictor program based on the findsequencefunction in _ mathematica _ to try to complete the divergences .",
    "that is , to complete output , runtime and space usage for each of the 1684 selected turing machines .      for a prediction to be called successful we require that the output , runtime and space usage sequences coincide in every value with the actual output of the step - by - step computation ( after verification ) .",
    "one among three outcomes is possible :    both the step - by - step computation and the sequences obtained with the predictor completion produced the same data , which leads us to conclude that the prediction was accurate .",
    "the step - by - step computation produces a non - convergent value @xmath17 , meaning that after the time bound the step - by - step computation does nt produce any output that is nt also produced by the predictor ( which means that either the value to be produced requires a larger time bound , or that the predictor has failed , predicting a convergent value where there is actually a divergent one ) .",
    "the step - by - step computation produces a value that the predictor algorithm does not predict .",
    "the number of incorrectly predicted turing machines was only 45 ( if twin rules are considered , this number is 90 ) , provided we do nt tag as incorrect the sequences that could nt be completed with the predictor algorithm but were actually convergent .",
    "hence , of a total of 3368 sequences completed with the predictor , only 90 were incorrect .",
    "one can say then that for the predictor most of the sequences were _",
    "easily predictable_.    in addition to these 45 cases of incorrect completions , we found 108 cases where the step - by - step computation produced new sequence values that the predictor did not predict , that is , 153 cases where differences were observed in at least one of the sequences that define an algorithm ( outputs , runtimes and space usage ) when the predictor program was compared to the step - by - step computation .",
    "this time the step - by - step computation ran for @xmath21 steps .",
    "the predictor algorithm was improved upon by simply looking at the final values rather than considering the whole sequence history since the beginning .",
    "now we consider a prediction successful only if for each of the 21-values :    both the sequences obtained with the predictor algorithm and the step - by - step computation converge , with the same output , runtime and space sequences .",
    "neither the sequences obtained with the predictor algorithm nor those obtained through step - by - step computation converge .",
    "the step - by - step computation diverges but the sequences obtained with the predictor have completed everything with runtime @xmath22 @xmath21    there were only eight cases of failures and non - completed sequences ( not counting twin rules ) .",
    "that is , 0.47% of the turing machines could nt be completed , which is to say that no shortcut was found for them .",
    "these turing machines that could not be completed were characterized by the greatest usage of space and time and the largest outputs , and they behaved like busy beaver machines @xcite in the space we were looking at .",
    "table 4 summarizes our findings on the completion process of the computed sequences in ( 3,2 ) .",
    "these eight sequences were finally completed by running the turing machine for up to @xmath19 steps .",
    "only eight cases could nt be completed after the last test , and none were incorrectly completed sequences .",
    "for example , the predictor could nt find the generating function for the output sequence : 21 , 43 , 1367 , 2735 , 1398111 , 2796223 , 366503875967 , 733007751935 , 6296488643826193618431 , 12592977287652387236863 , 464598858302721315448660797346840864708607 @xmath23 and therefore could nt complete the sequence .",
    "the obvious reason for this is the rate of growth of the sequence .",
    "all eight cases were computations with super fast growing values .",
    "a sample of @xmath24 ( 4,2 ) turing machines was randomly chosen , keeping only those with an initial segment converging up to 1000 steps , equal to one of the 284 functions computed in ( 2,2 ) and ( 3,2 ) ( following a comparison experiment concerning time complexity among different turing machine spaces undertaken in @xcite ) .",
    "the final number of sampled machines was 4203131 .",
    "of these , 30955 that had divergent values which were suspected to be actually convergent were selected to be completed by the predictor program .",
    "once completed by the predictor program , they were checked against the step - by - step computation up to @xmath21 steps .    of the 30955",
    ", only 69 turing machines were found not to have been completed by the predictor program , of which 40 turned out to be incorrectly completed . some of them were failures that could easily have been predicted by a visual inspection , but had an initial value that cheated the predictor program .",
    "these were therefore cataloged as silly failings of the predictor program due to its particular limitations rather than the result of a truly complicated sequence .",
    "nevertheless , among the failures , the predictor program incorrectly completed a few sequences in a way that looked reasonable but that turned out not to be the actual computation of the turing machine being predicted , and these were the cases we were most interested in . the following runtime sequence was completed by letting the actual turing machine run for @xmath21 steps : 5 , 7 , 19 , 27 , 59 , 87 , 179 , 267 , 539 , 807 , 1619 , 2427 , 4859 , 7287 , 14579 , 21867 , 43739 , 65607 , 131219 , 196827 ,  , but was completed by the predictor program as follows : 5 , 7 , 19 , 27 , 59 , 87 , 179 , 267 , 539 , 807 , 1619 , 2427 , 4859 , 7287 , 14579 , 21867 , 45925 , 65607 ,  , with 45925 rather than 43739 , representing one of the very few cases in which the predictor program actually produced an incorrect prediction .",
    "to sum up , 69 failures among 30955 turing machines represents a .78 success rate of the predictor program in a first round , and only a very small fraction remained after a second pass , eventually leading to a full prediction and therefore confirming what we witnessed in smaller spaces such as ( 3,2 ) .",
    "this is in accordance with what we think is our discovery , which is that there were not many actual wrong predictions and that either sequences were too hard to predict ( no value was predicted ) or they were too easy ( and therefore correctly completed ) .      among the drawbacks of the output convention",
    "is that many functions will display ( at least ) exponential growth .",
    "for example , the tape - identity , i.e. a turing machine that outputs the same tape configuration as the input tape configuration , will define the function @xmath25 .",
    "in particular , the turing machine that halts immediately by running off the tape while leaving the first cell black ( with a 1 ) also computes the function @xmath25 .",
    "this is slightly undesirable , but as we shall see , in our current set - up there will be few occasions where we actually wish to interpret the output as a number .    for an output representation it does not suffice to use only encodings and decodings that always halt ( any reasonable encoding or decoding should always halt , anyway ) , because this restriction not only ensures that the encoding and decoding can not be performing all the computations of the system we are attempting to outrun , but also that the representation is not erasing or adding complexity to the computation in the representation chosen .",
    "one may say then that the representation must be easily computable , which may be the case with a change of base . however , we were at a loss to find a single easy way to represent the output of a turing machine , since even for the simplest format compatible with the sequence predictor , the encoding turned out to hide some of the structure of the computations of certain machines , thus impeding the predictor and keeping it from truncating the computation even in these simple ( in the original unary or binary sense ) cases .",
    "we found it interesting and worth reporting that the encoding process , in which the output is interpreted in binary and converted into a decimal number , actually managed in several cases to _ inject _ an apparent complexity into the evolution of the original computation , making the predictor function miss the sequence generator ( the mathematical formula generating the sequence ) and therefore outrun the computation .",
    "as an illustration , the computation in figure 3 can easily be outrun just by looking at it .",
    "each new input produces an alternation of 1 and 0 , yet the sequence of outputs converted to decimals looks more complicated due to the encoding process : @xmath26 @xmath27 . while in binary @xmath28 produces the sequence ,",
    "the generating function found by the predictor program for the sequence of decimal numbers is @xmath29 .",
    "a simpler representation is possible in the form of a recursive piecewise function :    @xmath30    notice that the recursive function @xmath13 itself requires the calculation of the previous @xmath31 values in order to calculate the @xmath32 value . by definition , recursive functions",
    "are irreducible , but they may allow shortcuts  like the formula @xmath29 found when the predictor outran the recursive function @xmath13 because they permit the calculation of the @xmath33 element of the sequence @xmath6 without requiring that anything else be calculated .",
    "the recursive function , in this case , is not a shortcut to @xmath6 , as it retrieves the @xmath33 value of @xmath6 without having to run the actual turing machine producing @xmath32 .",
    "but because of the simplicity of the sequence , the computation of @xmath32 requires about @xmath2 steps , and the recursive function @xmath13 requires @xmath2 calculations .",
    "on the contrary , both @xmath28 and @xmath29 are actual shortcuts of @xmath6 , even though the latter may hide the simplicity of the sequence in binary , whereas in the case of the recursive function the simplicity is somehow preserved despite its transformation into decimals .",
    "the sequence of decimals is a sort of compiler between the output language of the turing machine ( base 2 ) and the language of the predictor program ( base 10 ) .",
    "given the way the predictor program works , based on the _ mathematica _ function findsequencefunction , it can only take as input a sequence of integers constituting an argument .",
    "one may inject or hide apparent complexity when transforming one numerical representation into another .",
    "for the out - runner to _ see _ patterns it should be capable of reading the output in the language of the original system ( in this case binary ) without translating it .",
    "it is not clear whether exploring patterns in other bases would tell us anything about patterns in the original sequence .",
    "we think that in light of such interesting findings , these questions merit further discussion .",
    "for example , we found other artificial phenomena such as phase transitions in the distribution of halting times @xcite , due more to these conventions than to actual properties of the systems studied .",
    "an exhaustive experiment was performed to find possible shortcuts to outrun the computations of all 3-state and a sample of 4-state 2-symbol turing machines by means of predicting the values of the sequences of the machine outputs for a sequence of the same number of inputs .",
    "even though this is ultimately an ill - fated approach thanks to the halting problem , the actual ratio of correct predictions and the rate at which the predictions were achieved was worth studying and reporting in connection with the concept of computational irreducibility .",
    "we found that despite the fact that sequences were sometimes left incomplete in our attempt to outrun the computation of turing machines , no sequence was ever partially completed .",
    "the process of completing sequences of outputs , runtimes and space usage of turing machines also gave us an opportunity to discuss interesting aspects of the theory of computation in connection to empirical rather than merely theoretical computation , including rates of convergence , the concept of decidable sets and the problem of extensionality , as they relate to the concepts of irreducibility , inductive inference and unpredictability in deterministic systems .",
    "we hope this approach will stimulate further discussion and more experiments of both an algorithmic and an epistemological nature .",
    "bailey , p.b .",
    "borwein , and s. plouffe , s. on the rapid computation of various polylogarithmic constants , _ math .",
    "_ 66 , 903913 , 1997 . m. blum .",
    "on effective procedures for speeding up algorithms .",
    "_ j. assoc .",
    "_ 18 , 290305 , 1971 .",
    "calude , m.a .",
    "stay , _ most programs stop quickly or never halt , _ advances in applied mathematics , 40 295 - 308 , 2005 .",
    "d. deutsch . _ the fabric of reality : the science of parallel universes and its implications .",
    "_ penguin ( non - classics ) . 1998 .",
    "delahaye & h. zenil , _ a glance into the structure of algorithmic complexity : numerical evaluations of the complexity of short strings , _ manuscript .",
    "delahaye , the martin - lf - chaitin thesis in h. zenil ( ed . ) _ randomness through computation _ ,",
    "world scientific , 2011 .",
    "van emde boas .",
    "ten years of speedup .",
    "_ proceedings of mfcs . _",
    ", 1975 . n.",
    "israeli and n. goldenfeld , _ computational irreducibility and the predictability of complex physical systems , _ phys .",
    "92 , 2004 .",
    "helm , and p.r .",
    "young . on size versus efficiency for programs admitting speedup",
    ". _ j. symbolic logic . _ 36 , 2127 , 1971 .",
    "j. joosten , f. soler & h. zenil . _ time vs. program - size complexity : speed - up and slowdown phenomena in small turing machines _ , forthcoming in the international journal of unconventional computing .",
    "s. lin and t. rado .",
    "computer studies of turing machine problems .",
    "_ 12 , 196 - 212 , 1965 .",
    "does computational speedup concern programing ? in m. nivat ( ed . ) _ automata , languages and programming .",
    "_ 585 - 592 , north holland/ elsevier , amsterdam , 1973 . k. sutner , _ cellular automata and intermediate degrees .",
    "_ theoretical computer science , 296:365375 , 2003 . l. levin , _ on a concrete method of assigning complexity measures _ , doklady akademii nauk sssr , vol.18(3 ) , pp . 727731 , 1977 .",
    "meyer and p.c .",
    "fischer . computational speedup by effective operators . _ j. of symb .",
    "log_. 5568 , 1972 .",
    "schnorr , _ zuflligkeit und wahrscheinlichkeit .",
    "eine algorithmische begrndung der wahrscheinlichkeitstheorie , _ springer , berlin , 1971 .",
    "s. wolfram , _ computation theory of cellular automata .",
    "physics , 96(1):1557 , 1984 . s. wolfram , _ a new kind of science .",
    "_ , wolfram media , 2002",
    ". h. zenil .",
    "_ compression - based investigation of the dynamical properties of cellular automata and other systems .",
    "_ complex systems , 2010 ."
  ],
  "abstract_text": [
    "<S> this paper is an exploration of the conceptual issues that have arisen in the course of investigating speed - up and slowdown phenomena in small turing machines . </S>",
    "<S> we present the results of a test that may spur experimental approaches to the notion of computational irreducibility . </S>",
    "<S> the test involves a systematic attempt to outrun the computation of a large number of small turing machines ( all 3 and 4 state , 2 symbol ) by means of integer sequence prediction using a specialized function finder program . </S>",
    "<S> this massive experiment prompts an investigation into rates of convergence of decision procedures and the decidability of sets in addition to a discussion of the ( un)predictability of deterministic computing systems in practice . </S>",
    "<S> we think this investigation constitutes a novel approach to the discussion of an epistemological question in the context of a computer simulation , and thus represents an interesting exploration at the boundary between philosophical concerns and computational experiments . </S>",
    "<S> + * keywords : * computational irreducibility ; unpredictability ; problem of induction ; algorithmic epistemology ; halting problem . * </S>",
    "<S> 2010 mathematics subject classification : * 68q01 , 68q17 , 68q15 </S>"
  ]
}