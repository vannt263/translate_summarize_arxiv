{
  "article_text": [
    "_ unification _ plays an important role in various areas of computer science , including theorem proving , logic programming , natural language processing , and database query systems @xcite .",
    "the unification problem is , in the fundamental form , to find a substitution for variables that will make the two given terms identical , where terms are built up from function symbols , variables , and constants @xcite .",
    "for example , two terms @xmath1 and @xmath2 become identical by substituting @xmath3 and @xmath4 by @xmath5 and @xmath6 , respectively .",
    "if one input term contains no variable , the problem is called _",
    "matching_.    although unification has a long history beginning from a seminal work by herbrand in 1930 ( e.g. , see @xcite ) , it is becoming important again because math search recently attracts researchers in information retrieval ( ir ) community @xcite . for example , math search is adopted as a pilot task in an ir evaluation conference ntcir .",
    "the math search is a sort of ir task to retrieve documents containing mathematical formulas and/or formulas themselves similar to a query .",
    "several systems have been developed such as wolfram formula search and formula search for wikipedia . since",
    "mathematical formulas are usually represented with tree structures , structural similarity is important to measure the similarity between formulas .",
    "approximate tree matching @xcite is a key to measure the similarity .",
    "however , when measuring the similarity between mathematical formulas , we need to unify substitution of variables .",
    "for example , a query @xmath7 has same similarity to formulas @xmath8 and @xmath9 by tree edit distance , although these two formulas are mathematically different . therefore",
    ", approximate tree matching is not enough and combination with unification is strongly needed .",
    "returning to unification , many variants have been proposed @xcite . among them , unification with commutative and associative functions are important from the viewpoint of math search because many functions satisfy either one or both of these two properties , where functions satisfying @xmath10 and @xmath11 are called _ commutative _ and _ associative _ , respectively .",
    "extensive studies have been done on the computational complexity of various unification problems . for the fundamental one , beginning from robinson s exponential time algorithm @xcite , a linear time algorithm was finally developed @xcite .",
    "however , all of associative , commutative , and associative - commutative unification ( and matching ) problems are known to be np - hard @xcite .",
    "polynomial time algorithms are known only for very restricted cases @xcite .",
    "for example , it is known that associative - commutative matching can be done in polynomial time if every variable occurs only once @xcite . from a practical viewpoint ,",
    "many studies have been done on various extensions of unification .",
    "furthermore , combination with approximate tree matching has been studied @xcite",
    ". however , these are heuristic algorithms .    in this paper , we study associative , commutative , and associative - commutative unification mainly from a viewpoint of parameterized complexity on the number of variables because the number of variables is often much smaller than the size of terms .",
    "we show the following results along with related results : ( i ) both associative and associative - commutative matching problems are @xmath0$]-hard , ( ii ) both associative and associative - commutative unification can be done in polynomial time if every variable occurs only once , ( iii ) commutative matching can be done in @xmath12 time where @xmath13 is the number of variables and @xmath14 are the size of input terms , ( iv ) commutative unification can be done in polynomial time if the number of variables is bounded by a constant .",
    "in addition , we show that both the string and tree edit distance problems with variables are @xmath0$]-hard .",
    "all algorithms presented in this paper simply decide whether two terms are unifiable and do not output the corresponding substitutions .",
    "however , the algorithms can be modified to output such substitutions ( when unifiable ) by using the standard _ traceback _ technique .",
    "let @xmath15 be an alphabet and @xmath16 be a set of variables , where we mainly consider @xmath16 that is defined as the set of variables appearing in the input .",
    "a string is a sequence of symbols over @xmath17 .",
    "let @xmath18 be a _ substitution _ , which is a mapping from @xmath16 to @xmath15 .",
    "for a string @xmath19 , let @xmath20 denote the string over @xmath15 obtained by replacing all occurrences of variables @xmath21 by @xmath22 .",
    "we call two strings @xmath23 and @xmath24 are _ unifiable _ if there exists a substitution @xmath18 such that @xmath25 .",
    "let @xmath26 , @xmath27 , and @xmath28 , where @xmath29 .",
    "then , @xmath23 and @xmath24 are unifiable since @xmath30 holds by @xmath31 .",
    "means that @xmath3 is substituted by @xmath32 .",
    "] however , @xmath23 and @xmath33 are not unifiable since there does not exist @xmath18 such that @xmath34 .",
    "for string @xmath19 and integer @xmath35 , @xmath36 $ ] denotes the @xmath35-th character of @xmath19 , @xmath37 $ ] denotes @xmath36 \\ldots s[j]$ ] , and @xmath38 denotes the length ( i.e. , the number of characters ) of @xmath19 . for two strings @xmath19 and @xmath39 ( including the case of @xmath19 and/or @xmath39",
    "are single characters ) , @xmath40 denotes the string obtained by concatenating @xmath19 and @xmath39 .",
    "edit operation on a string _",
    "@xmath19 over @xmath15 is either a _ deletion _ , an _ insertion _ , or a _ replacement _ of a character of @xmath19 @xcite .",
    "the _ edit distance between two strings _ @xmath23 and @xmath24 over @xmath15 is defined as the minimum number of operations to transform @xmath23 to @xmath24 , where we consider unit cost operations here .",
    "let @xmath41 denote the edit distance between @xmath23 and @xmath24 . from the definition , @xmath42 holds where @xmath43 is a sequence of edit operations . for example , @xmath44 because @xmath45 is obtained from @xmath46 by deletion of @xmath47 , replacement of @xmath48 to @xmath49 , and insertion of @xmath32 .",
    "we also define the edit distance @xmath50 between two strings over @xmath17 by @xmath51 this variant of edit distance is called _ edit distance with variables_. although it is well known that @xmath41 can be computed in polynomial time , computation of @xmath52 is @xmath0$]-hard as shown below .",
    "the edit distance problem with variables is @xmath0$]-hard with respect to the number of variables even if the number of occurrences of each variable is bounded by 3 .",
    "[ thm : edhard ]    we present an _ fpt - reduction _",
    "@xcite from the longest common subsequence problem ( lcs ) .",
    "lcs is , given a set of strings @xmath53 over @xmath54 and an integer @xmath55 , to decide whether there exists a string @xmath19 of length @xmath55 that is a subsequence of each string @xmath56 .",
    "where @xmath19 is called a _ subsequence _ of @xmath57 if @xmath19 is obtained by deletion operations from @xmath57 .",
    "it is known that lcs is @xmath0$]-hard for parameters @xmath13 and @xmath55 @xcite .",
    "first we consider the case in which there is no constraint on the number of occurrences of variables . from an instance of lcs",
    ", we construct an instance of edit distance with variables as follows .",
    "let @xmath58 and @xmath59 , where @xmath60 is a symbol not appearing in @xmath61 .",
    "we construct @xmath62 and @xmath63 by @xmath64 where @xmath65 appears @xmath13 times in @xmath62 .",
    "then , we can see that there exists an lcs of length @xmath66 iff @xmath67 ( i.e. , there exists @xmath18 such that @xmath68 is a subsequence of @xmath63 ) .",
    "since the number of variables appearing in this instance is @xmath55 , it is an fpt reduction .",
    "the proof for the case of the bounded number of occurrences is given in appendix a1 .",
    "if each variable occurs only once , then the problem is equivalent to approximate string matching with do nt care characters , which can be solved in polynomial time @xcite .",
    "it should be noted that if an alphabet @xmath15 is fixed , the number of possible @xmath18 is bounded by @xmath69 , where @xmath70 . therefore , we have a fixed - parameter algorithm with parameter @xmath13 for a fixed alphabet .    the edit distance problem with variables can be solved in + @xmath71 time where @xmath13 is the number of variables and @xmath72 and @xmath73 are the size of input strings .",
    "in order to define unification , we regard @xmath15 as a set of function symbols , where arity ( i.e. , the number of arguments ) is associated with each symbol .",
    "we call a function symbol with arity 0 a _",
    "constant_. we define a _ term _ as follows :    * a constant is a term , * a variable is a term , * if @xmath74 are terms and @xmath47 is a function symbol with arity @xmath75 , @xmath76 is a term .",
    "we identify each term @xmath39 with a rooted ordered tree where each node corresponds to a function symbol and each leaf corresponds to a constant . for a term @xmath39 , @xmath77 denotes the set of nodes in a tree @xmath39 , @xmath78 denotes the root of @xmath39 , and @xmath79 denotes the function symbol of @xmath78 . for a node @xmath80 , @xmath81 denotes a subterm ( i.e. , subtree ) of @xmath39 rooted at @xmath82 .",
    "the _ size _ of @xmath39 is defined as @xmath83 .",
    "let @xmath84 be a set of terms over @xmath15 and @xmath16 .",
    "then , a _ substitution _ @xmath18 is defined as a ( partial ) mapping from @xmath16 to @xmath84 , where @xmath39 must not contain a variable @xmath3 if @xmath85 . for a term @xmath39 and a substitution @xmath18 , @xmath86 is the term obtained by simultaneously replacing variables according to @xmath18 .",
    "we say that terms @xmath87 and @xmath88 are _ unifiable _ if there exists @xmath18 such that @xmath89 .",
    "such @xmath18 is called a _",
    "unifier_. in this paper , the unification problem is to decide whether two given terms are unifiable and output a unifier if unifiable .",
    "it is well - known that the unification problem can be solved in linear time @xcite . a special case of the unification problem in which @xmath88 is variable - free",
    "is called a _ matching _ problem .",
    "if every variable ( resp . , a variable @xmath3 ) occurs in a term @xmath39 only once , the term ( resp . , the variable ) is called a _ do - term _",
    ", _ do - variable _ ) , where do means distinct occurrence(s ) @xcite . unless otherwise stated , @xmath72 and @xmath73 denote the size of two input terms @xmath87 and @xmath88 .",
    "let @xmath90 , @xmath91 , @xmath92 , @xmath93 , @xmath94 , where @xmath95 .",
    "@xmath87 and @xmath88 are unifiable since @xmath96 holds for @xmath97 . @xmath87 and @xmath98 , and @xmath88 and @xmath98 are also unifiable since @xmath99 and @xmath100 hold for @xmath101 and @xmath102 , respectively .",
    "@xmath103 is not unifiable to @xmath87 , @xmath88 , or @xmath98 .",
    "@xmath104 is unifiable to @xmath88 , but is not unifiable to @xmath87 ( or @xmath98 ) because it is impossible to simultaneously satisfy @xmath105 and @xmath106 .",
    "as in the case of string edit distance , we can combine _ tree edit distance _",
    "@xcite with unification .",
    "let @xmath107 denote the tree edit distance where the distance can be for both ordered and unordered trees .",
    "then , we define the tree edit distance @xmath108 between two trees ( i.e. , two terms ) over @xmath17 by @xmath109 by combining the proofs of thm .",
    "[ thm : edhard ] and thm .",
    "[ thm : asohard ] , we have :    the tree edit distance problem with variables is @xmath0$]-hard for both ordered and unordered trees with respect to the number of variables for a fixed alphabet even if the number of occurrences of each variable is bounded by 3 .",
    "[ thm : tree - ed - hard ]    we also have the following theorem as in several matching problems @xcite , where the proof is given in appendix a2",
    ".    the ordered tree edit distance problem with variables can be solved in polynomial time for do - terms .",
    "[ thm : tree - ed - do ]",
    "a function @xmath47 is called _ associative _ if @xmath11 always holds .",
    "associative unification is a variant of unification in which some functions are associative . in this section",
    ", we assume that all functions are associative although all the results are valid even if usual functions are included .",
    "it is shown that associative matching is np - hard @xcite .",
    "however , the proof in @xcite does not work to show the parameterized hardness .",
    "associative matching is @xmath0$]-hard with respect to the number of variables even for a fixed @xmath15 .",
    "[ thm : asohard ]    as in the proof of thm .",
    "[ thm : edhard ] , we use a reduction from lcs ( see also fig .  [",
    "fig : asohard ] ) .",
    "first we consider an infinite alphabet .",
    "let @xmath110 be an instance of lcs . for each @xmath111 ,",
    "we create a term @xmath112 by @xmath113 where @xmath60 is a character not appearing in @xmath61 .",
    "we create a term @xmath87 by concatenating @xmath114 , which can be done by replacing the last occurrence of @xmath60 of each @xmath112 by @xmath115 for @xmath116 .",
    "then , we transform each @xmath56 into a string @xmath117 of length @xmath118 by inserting a special character @xmath119 in front of each character in @xmath56 , and appending @xmath119 at the end of @xmath56 , where each @xmath119 is considered as a distinct constant ( i.e. , @xmath119 can not match any symbol , but can match any variable ) .",
    "we represent each @xmath117 by a term @xmath120 given as @xmath121,f(s_i'[2],f(s_i'[3],f(\\cdots , f(s_i'[1 + 2\\cdot |s_i'|],g(\\#,\\ # ) ) \\cdots)))).\\ ] ] we create a term @xmath88 by concatenating @xmath122 .    , @xmath123 , and @xmath124 in the proof of thm .",
    "[ thm : asohard].,width=264 ]    then , we can see that @xmath87 and @xmath88 are unifiable iff there exists an lcs of length @xmath55 .",
    "since the number of variables in @xmath87 is @xmath125 , it is an fpt - reduction and thus the problem is @xmath0$]-hard .",
    "finally , we represent each constant by a distinct term using a function symbol @xmath126 and binary - encoding ( e.g. , 10-th symbol ( among 16 symbols ) can be represented as @xmath127 ) .",
    "next , we consider associative unification for do - terms , where it has some similarity with do - associative - commutative matching @xcite .",
    "we begin with the simplest case in which each term does not contain a variable .",
    "associative unification can be done in polynomial time if there exists no variable .",
    "we transform each input term into its _",
    "canonical form _ in which consecutive and same function symbols are simplified into one symbol .",
    "for example , both @xmath128 and @xmath129 are transformed into @xmath130 . since @xmath131 and @xmath132 means @xmath133 , it is enough to test the isomorphism of the canonical forms in order to examine @xmath133 .",
    "since the rooted ordered tree isomorphism between the resulting canonical forms can be trivially tested in linear time , we have the proposition .    in order to treat do - terms ,",
    "we transform terms @xmath87 and @xmath88 into their canonical forms @xmath134 and @xmath135 .",
    "then , we apply the following procedure to @xmath134 and @xmath135 ( see also fig .  [ fig : asopoly ] ) , where it returns ` true ' iff @xmath134 and @xmath135 are unifiable , and @xmath136=1 $ ] iff @xmath137 and @xmath138 are unifiable .",
    "it is to be noted that step ( # ) can be done in constant time because @xmath137 and @xmath138 are unifiable there iff these are the same constant or one of @xmath81 and @xmath139 is a variable .",
    "= = = = = = = procedure @xmath140 + @xmath141 * do *  / * in post - order * / + @xmath142 * do *  / * in post - order * / + @xmath137 or @xmath138 is a constant * then * + @xmath137 and @xmath138 are unifiable  - ( # ) + @xmath136 \\leftarrow 1 $ ] * else * @xmath136 \\leftarrow 0 $ ] ; + @xmath137 or @xmath138 is a variable * then * + @xmath136 \\leftarrow 1 $ ] ; +  / * @xmath143 , @xmath144 * / + @xmath145 and @xmath146 can match @xmath147 + @xmath136 \\leftarrow 1 $ ] * else * @xmath136 \\leftarrow 0 $ ] ; + @xmath148=1 $ ] * then * * return * true * else * * return * false .",
    "match of @xmath146 and @xmath147 can be tested in polynomial time by regarding each of these two sequences as a string and applying string matching with variable length do nt cares @xcite with setting the difference to be 0 and allowing do nt care characters appear in both strings , where @xmath149 ( resp . , @xmath150 )",
    "is regarded as a do nt care symbol that can match any substring of length at least 1 if it is a variable , otherwise @xmath149 can match @xmath150 iff @xmath151=1 $ ] ( see appendix a3 for the details ) . since for - loops are repeated @xmath152 times and string matching with variable length do nt cares can be done in polynomial time , we have :    associative unification for do - terms can be done in polynomial time .",
    "[ thm : asspoly ]     and @xmath88 .",
    "@xmath87 and @xmath88 are transformed into @xmath134 and @xmath135 , which are then unified by @xmath153.,width=415 ]    we can also consider another variant in which @xmath87 can contain a constant number of non - do variables but @xmath88 can not contain any variable . let @xmath154 be the set of non - do variables in @xmath87 .",
    "we examine all possible mappings from @xmath154 to the set of consecutive children of each node in the canonical form @xmath135 of @xmath88 .",
    "if we apply such a mapping , all occurrences of variables in @xmath154 are replaced by terms without variables .",
    "then , we can apply @xmath140 to the resulting terms . since the number of mappings is clearly @xmath155",
    ", we have :    associative matching can be done in polynomial time if @xmath87 contains a constant number of non - do terms and any number of do - terms .",
    "[ cor : asspoly ]",
    "a function @xmath47 is called _ commutative _ if @xmath10 always holds .",
    "commutative unification is a variant of unification in which some functions are commutative .",
    "it is known that even commutative matching is np - hard ( by a reduction from 3sat ) @xcite . in this section",
    ", we present a parameterized algorithm for commutative matching and a polynomial - time algorithm for commutative unification with a bounded number of variables .",
    "first we note that commutative unification can be done in polynomial time if both @xmath87 and @xmath88 are variable - free because it is equivalent to the rooted unordered tree isomorphism problem .",
    "commutative unification can be done in polynomial time if both @xmath87 and @xmath88 are variable - free .",
    "next we consider commutative matching .",
    "we construct a 0 - 1 table @xmath136 $ ] for node pairs @xmath156 by applying dynamic programming in a bottom - up manner , where @xmath136=1 $ ] iff @xmath157 is unifiable to @xmath158 .",
    "it is enough to construct such table entries only for pairs with the same depth .",
    "we also construct a table @xmath159 $ ] , where each element holds a set of possible substitutions @xmath18 such that @xmath160 .",
    "let @xmath161 and @xmath162 be substitutions .",
    "@xmath163 is said to be _ compatible _ with @xmath164 if there exists no variable @xmath3 such that @xmath165 but @xmath166 .",
    "let @xmath167 and @xmath168 be sets of substitutions .",
    "we define @xmath169 by @xmath170 for a node @xmath82 , @xmath171 and @xmath172 denote the left and right children of @xmath82 , respectively .",
    "= = = = = = = procedure @xmath173 + pairs @xmath156 with the same depth + / * in a bottom - up way * / + @xmath157 is a variable * then * + @xmath159 \\leftarrow \\ { \\{(t_1)_u/(t_2)_v\\ } \\}$ ] ; @xmath136 \\leftarrow 1 $ ] + @xmath157 does not contain a variable * then * + @xmath159 \\leftarrow \\emptyset$ ] ; + @xmath174 * then * @xmath136 \\leftarrow 1 $ ] * else * @xmath136 \\leftarrow 0 $ ] + @xmath175 * then * + @xmath159 \\leftarrow \\emptyset$ ] ; @xmath136 \\leftarrow 0 $ ] +   + @xmath159 \\leftarrow \\emptyset$ ] ; @xmath136 \\leftarrow 0 $ ] ; + @xmath176 * do *   - ( # ) + @xmath177=1 $ ] and @xmath178=1 $ ] and @xmath179 \\join \\theta_2[u_2,v_2 ] \\neq \\emptyset$ ] + @xmath159 \\leftarrow \\theta[u , v ] \\cup   ( \\theta_1[u_1,v_1 ] \\join \\theta_2[u_2,v_2])$ ] ; @xmath136 \\leftarrow 1 $ ] ; + @xmath148=1 $ ] * then return * true * else return * false .",
    "commutative matching can be done in @xmath12 time where @xmath13 is the number of variables in @xmath87 .",
    "the correctness follows from the observation that each variable is substituted by a term without variables and @xmath10 is taken into account at step ( # ) .    in order to analyze the time complexity",
    ", we consider the size ( i.e. , the number of elements ) of @xmath159 $ ] .",
    "an important observation is that if @xmath180 does not contain a variable , @xmath181| \\leq \\max(|\\theta[u_r , v_l]|,|\\theta[u_r , v_r]|)$ ] holds ( an analogous property holds for @xmath182 ) .",
    "let @xmath183 denote the maximum size of @xmath159 $ ] when the number of ( distinct ) variables in @xmath157 is @xmath35 .",
    "then , we can see that the following relations hold : @xmath184 from which @xmath185 follows .",
    "therefore , computation of @xmath179 \\join \\theta_2[u_2,v_2]$ ] can be done in @xmath12 time by using ` sorting ' as in usual ` join ' operations .",
    "then , we can see that the total computation time is also @xmath12 .",
    "next , we consider the case where both @xmath87 and @xmath88 contain variables . as in the case of linear time unification @xcite",
    ", we assume that two variable free terms @xmath87 and @xmath88 are represented by a dag ( directed acyclic graph ) @xmath186 , where @xmath87 and @xmath88 respectively correspond to @xmath187 and @xmath188 of indegree 0 ( @xmath189 ) .",
    "then , whether @xmath187 and @xmath188 represent the same term can be tested in polynomial time with respect to the size of @xmath190 by using the following procedure , where @xmath81 denotes the term corresponding to a node @xmath82 in @xmath190 .",
    "= = = = = = = = = procedure @xmath191 + @xmath192 * do *  / * in post - order * / + @xmath193 * do *  / * in post - order * / + @xmath194 * then * @xmath136 \\leftarrow 1 $ ] ; * continue * ; + @xmath81 or @xmath139 is a constant * then * + @xmath195",
    "* then * @xmath136 \\leftarrow 1 $ ] * else * @xmath136 \\leftarrow 0 $ ] ; +   + let @xmath196 and @xmath197 ; + @xmath145 * then * + ( @xmath198=1 $ ] and @xmath199=1 $ ] ) or + ( @xmath200=1 $ ] and @xmath201=1 $ ] ) + @xmath136 \\leftarrow 1 $ ] * else * @xmath136 \\leftarrow 0 $ ] + @xmath136 \\leftarrow 0 $ ] ; + @xmath202=1 $ ] * then * * return * true * else * * return * false .    in order to cope with terms with variables , we consider all possible mappings from the set of variables to @xmath203 . for each mapping",
    ", we replace all appearances of the variables by the corresponding nodes , resulting in a dag to which we can apply @xmath191 .",
    "the following is a pseudo - code of the procedure for terms with variables .",
    "= = = = = = = procedure @xmath204 + mappings @xmath205 from a set of variables to nodes in @xmath87 and @xmath88",
    "* do * + there exists a directed cycle ( excluding a self - loop ) * then * * continue * ; + replace each variable having a self - loop with a distinct constant symbol ; + replace each occurrence of a variable node @xmath82 with node @xmath206 ; + / * if @xmath207 and @xmath208 , @xmath82 is replaced by @xmath209 * / + let @xmath186 be the resulting dag ; + let @xmath187 and @xmath188 be the nodes of @xmath190 corresponding to @xmath87 and @xmath88 ; + @xmath210true * then * * return * true ; + false .",
    "then , we have the following , where the proof is given in appendix a4 .",
    "commutative unification can be done in polynomial time if the number of variables in @xmath87 and @xmath88 is bounded by a constant .",
    "[ thm : com - unif - poly ]",
    "associative - commutative unification is a variant of unification in which some functions can be both associative and commutative .",
    "we show that associative - commutative matching is @xmath0$]-hard even if all every function is associative and commutative , where the proof is a bit involved and is given in appendix a5 .",
    "matching is @xmath0$]-hard with respect to the number of variables even if every function symbol is associative and commutative .",
    "[ thm : ac - hard ]    it is shown in @xcite that associative - commutative matching can be done in polynomial time if @xmath87 is a do - term .",
    "we can extend their algorithm as below . for extension ,",
    "it is enough to add a condition in their algorithm that @xmath211 and @xmath212 can be unified if @xmath213 and @xmath214 are variables for some @xmath215 .",
    "associative - commutative unification can be done in polynomial time if both @xmath87 and @xmath88 are do - terms .",
    "[ prop : do - ac - unif ]    99    aikou , k. , suzuki1 , y. , shoudai , t. , uchida , t. , miyahara , t. : a polynomial time matching algorithm of ordered tree patterns having height - constrained variables . in : cpm 2005 .",
    "lncs , vol . 3537 , pp .",
    "springer , heidelberg ( 2005 )    akustu , t. : approximate string matching with do nt care characters .",
    "information processing letters 55 , 235239 ( 1995 )    akustu , t. : approximate string matching with variable length do nt care characters , ieice trans .",
    "information and systems e79-d , 13531354 ( 1996 )    benanav , d. , kapur , d. , narendran , p. : complexity of matching problems .",
    "journal of symbolic computation 3 , 203216 ( 1987 )    bille , p. : a survey on tree edit distance and related problem .",
    "theoretical computer science 337 , 217239 ( 2005 )    bodlaender , h.l . ,",
    "downey , r.g . , fellows , m.r . ,",
    "wareham , h.t . : the parameterized complexity of sequence alignment and consensus .",
    "theoretical computer science 147 , 3154 ( 1995 )    eker , s. : single elementary associative - commutative matching .",
    "journal of automated reasoning 28 , 3551 ( 2002 )    flum , j. , grohe , m. : parameterized complexity theory .",
    "springer , berlin ( 2006 )    gilbert , d. , schroeder , m. : fury : fuzzy unification and resolution based on edit distance . in : proc .",
    "1st ieee international symposium on bioinformatics and biomedical engineering , pp .",
    "330336 ( 2000 )    iranzo , p.j . , rubio - manzano ,",
    "c. : an efficient fuzzy unification method and its implementation into the bousi  prolog system . in : proc .",
    "2010 ieee international conference on fuzzy systems , pp .",
    "18 ( 2010 )    kamali , s. , tompa , f.w .",
    ": a new mathematics retrieval system . in : proc .",
    "acm conference on information and knowledge management , pp .",
    "14131416 ( 2010 )    kapur , d. , narendran , p. : complexity of unification problems with associative - commutative operators .",
    "journal of automated reasoning 28 , 3551 ( 2002 )    kim , s. , yang , s. , ko , y. : mathematical equation retrieval using plain words as a query . in : proc .",
    "acm conference on information and knowledge management , pp .",
    "24072410 ( 2012 )    knight , k. : unification : a multidisciplinary survey .",
    "acm computing surveys 21 , 93124 ( 1989 )    nguyen , t.t . , chang , k. , hui , s.c . : a math - aware search engine for math question answering system . in : proc .",
    "acm conference on information and knowledge management , pp .",
    "724733 ( 2012 )    paterson , m.s . ,",
    "wegman , m.n . : linear unification .",
    "journal computer and system sciences 16 , 158167 ( 1978 )    robinson , j.a . : a machine - oriented logic based on the resolution principle . j. acm 12 , 2341 ( 1965 )",
    "next we consider the case in which the number of occurrences of each variable is bounded by 3 . for that purpose",
    ", we rename @xmath216-th occurrence of @xmath217 in @xmath62 by @xmath218 and then we append @xmath219 and @xmath220 to the end of @xmath62 and @xmath63 , respectively , where @xmath120 and @xmath112 are defined as follows : @xmath221 let the resulting strings be @xmath222 and @xmath223 . then , it is seen that there exists an lcs of length @xmath224 iff @xmath225 .",
    "since the number of variables is @xmath226 , which is still a polynomial of @xmath55 and @xmath13 , it is an fpt reduction .",
    "let @xmath227 and @xmath228 be ordered forests .",
    "let @xmath229 ( resp . ,",
    "@xmath230 ) be the rightmost tree of @xmath227 ( resp . , @xmath228 ) .",
    "it is well - known @xcite that the rooted ordered tree edit distance can be computed by the following dynamic programming procedure : @xmath231 & \\leftarrow & 0,\\\\ d[f_1,\\epsilon ] & \\leftarrow & d[f_1-r(t_1),\\epsilon ] + \\delta(r(t_1),-),\\\\ d[\\epsilon , f_2 ] & \\leftarrow & d[\\epsilon , f_2-r(t_2 ) ] + \\delta(-,r(t_2)),\\\\ d[f_1,f_2 ] & \\leftarrow & \\min \\left\\ { \\begin{array}{l } d[f_1-r(t_1),f_2]+\\delta(r(t_1),-),\\\\ d[f_1,f_2-r(t_2)]+\\delta(-,r(t_2)),\\\\ d[f_1-t_1,f_2-t_2]+d[t_1-r(t_1),t_2-r(t_2)]+\\delta(r(t_1),r(t_2 ) ) . \\end{array } \\right.\\end{aligned}\\ ] ] where @xmath232 is a delta function ( i.e. , @xmath233 , otherwise @xmath234 ) , @xmath235 denotes the empty tree , @xmath236 ( resp .",
    ", @xmath237 ) denotes the forest obtained by deleting @xmath238 ( resp . , @xmath239 ) from @xmath240 , and @xmath241 $ ] gives the required edit distance .",
    "in order to cope with do - variables , it is enough to add the following in taking the minimum at the recursion of computing @xmath242 $ ] : @xmath243,~~~~~ \\mbox{if $ t_1 $ or $ t_2 $ consists of a variable node}.\\end{aligned}\\ ] ] then , it is clear that the order of the time complexity is the same ( i.e. , @xmath244 ) as that of the original one .",
    "let @xmath245 and @xmath246 be strings including variables length do nt care characters ` * ' .",
    "the following is a pseudo - code for deciding whether @xmath32 matches @xmath247 , where @xmath248=1 $ ] iff @xmath249 matches @xmath250 .",
    "= = = = = = = procedure @xmath251 + @xmath252 * do * @xmath248 \\leftarrow 0 $ ] ; + @xmath253 \\leftarrow 1 $ ] ; + @xmath254 * to * @xmath255 * do * + @xmath256 * to * @xmath257 * do * + @xmath258 and @xmath259 * then * + @xmath248 \\leftarrow \\max \\ { \\max_{i'<i } \\ { e[i',j-1 ] \\ } , \\max_{j'<j } \\ { e[i-1,j ' ] \\ } \\}$ ] + @xmath260 * then * @xmath248 \\leftarrow \\max_{j'<j } \\ { e[i-1,j ' ] \\}$ ] + @xmath261 * then * @xmath248 \\leftarrow \\max_{i'<i } \\ { e[i',j-1 ]",
    "\\}$ ] + if @xmath262 matches @xmath263 * then * @xmath248 \\leftarrow e[i-1,j-1]$ ] + @xmath248 \\leftarrow 0 $ ] ; + @xmath264=1 $ ] * then * * return * true * else * * return * false .",
    "the correctness of @xmath191 follows from the fact that @xmath266 matches @xmath267 iff @xmath268 and @xmath269 are the identical function symbols and either @xmath270 matches @xmath271 or @xmath270 matches @xmath272 .",
    "it is clear that this procedure works in @xmath152 time .",
    "therefore , commutative match of two variable - free terms can be tested in polynomial time .",
    "next we consider the correctness of @xmath204 ( see also fig .  [",
    "fig : dag ] ) .",
    "it is straight - forward to see that if there exists @xmath205 which returns ` true ' , @xmath87 and @xmath88 are commutatively unifiable and such a mapping gives a substitution @xmath18 satisfying @xmath89 .",
    "conversely , suppose that @xmath87 and @xmath88 are commutatively unifiable .",
    "then , there exist unifiable non - commutative terms @xmath273 and @xmath274 that are obtained by exchanging left and right arguments in some terms in @xmath87 and @xmath88 .",
    "let @xmath18 be the substitution satisfying @xmath275 .",
    "then , @xmath89 holds .",
    "we assign distinct constants to variables appearing in @xmath276 .",
    "we also construct a mapping from the remaining variables to @xmath203 by regarding @xmath85 as a mapping of @xmath3 to @xmath39 .",
    "we construct @xmath186 according to this mapping .",
    "then , it is obvious that @xmath210true holds .",
    "let @xmath280 be distinct functional symbols and @xmath32 be a constant not appearing in @xmath281 . for each @xmath282 $ ]",
    ", we define the term @xmath283 $ ] by @xmath284 = f_1(s_i[j],f_2(\\overbrace{a , a,\\cdots , a}^{j})).\\ ] ] then , we define the term @xmath88 by @xmath285,\\hat{s}_1[2],\\cdots,\\hat{s}_1[|s_1| ] ) , f_4(\\hat{s}_2[1],\\hat{s}_2[2],\\cdots,\\hat{s}_2[|s_2|]),\\\\ & & \\cdots , f_4(\\hat{s}_k[1],\\hat{s}_k[2],\\cdots,\\hat{s}_k[|s_k|])).\\end{aligned}\\ ] ]    next , we define the term @xmath286 ( @xmath111 , @xmath287 by @xmath288 where @xmath289 and @xmath290s are variables .",
    "then , we define @xmath120 ( @xmath291 ) and @xmath87 by @xmath292 where @xmath293 is a variable .",
    "we show that @xmath87 and @xmath88 are unifiable if and only if lcs of @xmath281 has length at least @xmath55 .",
    "first we show the ` if ' part .",
    "let @xmath294 be a common subsequence of @xmath281 such that @xmath295 .",
    "we consider a partial substitution @xmath296 defined by @xmath297,x_2/s_c[2],\\ldots , x_l / s_c[l]\\}.\\ ] ] then , it is straight - forward to see that @xmath296 can be extended to a substitution @xmath18 such that @xmath298 .",
    "conversely , suppose that there exists a substitution @xmath18 satisfying @xmath298 .",
    "we can see from the construction of @xmath87 and @xmath88 that if @xmath289 matches @xmath299 $ ] and @xmath300 matches @xmath301 $ ] for some @xmath302 where @xmath303 , then @xmath304 must hold .",
    "let @xmath305 ( @xmath306 ) .",
    "then , we can see from the above property that @xmath307 is a common subsequence of @xmath281 ."
  ],
  "abstract_text": [
    "<S> this paper studies the unification problem with associative , commutative , and associative - commutative functions mainly from a viewpoint of the parameterized complexity on the number of variables . </S>",
    "<S> it is shown that both associative and associative - commutative unification problems are @xmath0$]-hard . a fixed - parameter algorithm and a polynomial - time algorithm </S>",
    "<S> are presented for special cases of commutative unification in which one input term is variable - free and the number of variables is bounded by a constant , respectively . related results including those on the string and tree edit distance problems with variables are shown too . </S>"
  ]
}