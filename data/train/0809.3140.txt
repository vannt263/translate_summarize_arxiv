{
  "article_text": [
    "over the past decade , parameterized complexity has evolved as an important subdiscipline in the field of computational complexity , see @xcite . in particular",
    ", it has been shown that many hard problems become tractable if some problem parameter is fixed or bounded by a constant . in the arena of graphs and ,",
    "more generally , of finite structures , the treewidth is one such parameter which has served as the key to many fixed - parameter tractability ( fpt ) results .",
    "the most prominent method for establishing the fpt in case of bounded treewidth is via courcelle s theorem , see @xcite : any property of finite structures , which is expressible by a monadic second order ( mso ) sentence , can be decided in linear time ( data complexity ) if the treewidth of the structures is bounded by a fixed constant .",
    "recipes as to how one can devise concrete algorithms based on courcelle s theorem can be found in the literature , see @xcite .",
    "the idea is to first translate the mso evaluation problem over finite structures into an equivalent mso evaluation problem over colored binary trees .",
    "this problem can then be solved via the correspondence between mso over trees and finite tree automata ( fta ) , see @xcite . in theory , this generic method of turning an mso description into a concrete algorithm looks very appealing . however , in practice , it has turned out that even relatively simple mso formulae may lead to a `` state explosion '' of the fta , see @xcite . consequently , it was already stated in @xcite that the algorithms derived via courcelle s theorem are `` useless for practical applications '' .",
    "the main benefit of courcelle s theorem is that it provides `` a simple way to recognize a property as being linear time computable '' . in other words ,",
    "proving the fpt of some problem by showing that it is mso expressible is the starting point ( rather than the end point ) of the search for an efficient algorithm .    in this work",
    "we propose monadic datalog ( i.e. , datalog where all intensional predicate symbols are unary ) as a practical tool for devising efficient algorithms in situations where the fpt has been shown via courcelle s theorem .",
    "above all , we prove that if some property of finite structures is expressible in mso then this property can also be expressed by means of a monadic datalog program over the structure plus the tree decomposition .",
    "hence , in the first place , we prove an _ expressivity result _ rather than a mere complexity result . however , we also show that the resulting fragment of datalog can be evaluated in linear time ( both w.r.t .",
    "the program size and w.r.t .",
    "the data size ) .",
    "we thus get the corresponding _ complexity result _",
    "( i.e. , courcelle s theorem ) as a corollary of this mso - to - datalog transformation .",
    "our mso - to - datalog transformation for finite structures with bounded treewidth generalizes a result from @xcite where it was shown that mso on trees has the same expressive power as monadic datalog on trees .",
    "several obstacles had to be overcome to prove this generalization :    * first of all , we no longer have to deal with a single universe , namely the universe of trees whose domain consists of the tree nodes .",
    "instead , we now have to deal with  and constantly switch between  two universes , namely the relational structure ( with its own signature and its own domain ) on the one hand , and the tree decomposition ( with appropriate predicates expressing the tree structure and with the tree nodes as a separate domain ) on the other hand .",
    "* of course , not only the mso - to - datalog transformation itself had to be lifted to the case of two universes",
    ". also important prerequisites of the results in @xcite ( notably several results on mso - equivalences of tree structures shown in @xcite ) had to be extended to this new situation . *",
    "apart from switching between the two universes , it is ultimately necessary to integrate both universes into the monadic datalog program . for this purpose",
    ", both the signature and the domain of the finite structure have to be appropriately extended . *",
    "it has turned out that previous notions of standard or normal forms of tree decompositions ( see @xcite ) are not suitable for our purposes .",
    "we therefore have to introduce a modified version of `` normalized tree decompositions '' , which is then further refined as we present new algorithms based on monadic datalog .",
    "in the second part of this paper , we put monadic datalog to work by presenting new algorithms for the 3-colorability problem of graphs and for the primality problem of relational schemas ( i.e. , testing if some attribute in a relational schema is part of a key ) .",
    "both problems are well - known to be intractable ( e.g. , see @xcite for primality ) .",
    "it is folklore that the 3-colorability problem can be expressed by an mso sentence . in @xcite",
    ", it was shown that primality is mso expressible .",
    "hence , in case of bounded treewidth , both problems become tractable .",
    "however , two attempts to tackle these problems via the standard mso - to - fta approach turned out to be very problematical : we experimented with a prototype implementation using mona ( see @xcite ) for the mso model checking , but we ended up with `` out - of - memory '' errors already for really small input data ( see section  [ sec : results ] ) .",
    "alternatively , we made an attempt to directly implement the mso - to - fta mapping proposed in @xcite .",
    "however , the `` state explosion '' of the resulting fta  which tends to occur already for comparatively simple formulae ( cf .",
    "@xcite )  led to failure yet before we were able to feed any input data to the program .",
    "in contrast , the experimental results with our new datalog approach look very promising , see section  [ sec : results ] . by the experience gained with these experiments ,",
    "the following advantages of datalog compared with mso became apparent :    * level of declarativity .",
    "mso as a logic has the highest level of declarativity which often allows one very elegant and succinct problem specifications .",
    "however , mso does not have an operational semantics . in order to turn an mso specification into an algorithm ,",
    "the standard approach is to transform the mso evaluation problem into a tree language recognition problem .",
    "but the fta clearly has a much lower level of declarativity and the intuition of the original problem is usually lost when an fta is constructed .",
    "in contrast , the datalog program with its declarative style often reflects both the _ intuition of the original problem and of the algorithmic solution_. this intuition can be exploited for defining heuristics which lead to problem - specific optimizations . *",
    "general optimizations .",
    "a lot of research has been devoted to generally applicable ( i.e. , not problem - specific ) optimization techniques of datalog ( see e.g.  @xcite ) . in our implementation ( see section  [ sec : results ] ) , we make heavy use of these optimization techniques , which are not available in the mso - to - fta approach .",
    "* flexibility .",
    "the generic transformation of mso formulae to monadic datalog programs ( given in section  [ sec : mondatalog ] ) inevitably leads to programs of exponential size w.r.t .",
    "the size of the mso - formula and the treewidth .",
    "however , as our programs for 3-colorability and primality demonstrate , many relevant properties can be expressed by really short programs . moreover , as we will see in section  [ sec : work ] , also datalog provides us with a _ certain level of succinctness_. in fact , we will be able to express a big monadic datalog program by a small non - monadic program .",
    "* required transformations .",
    "the problem of a `` state explosion '' reported in @xcite already refers to the transformation of ( relatively simple ) mso formulae _ on trees _ to an fta . if we consider mso _ on structures with bounded treewidth _ the situation gets even worse , since the original ( possibly simple ) mso formula over a finite structure first has to be transformed into an equivalent mso formula over trees .",
    "this transformation ( e.g. , by the algorithm in @xcite ) leads to a much more complex formula ( in general , even with additional quantifier alternations ) than the original formula .",
    "in contrast , our approach works with monadic datalog programs on finite structures which need no further transformation .",
    "each program can be executed as it is . * extending the programming language .",
    "one more aspect of the flexibility of datalog is the possibility to define new built - in predicates if they admit an efficient implementation by the interpreter .",
    "another example of a useful language extension is the introduction of generalized quantifiers . for the theoretical background of this concept , see @xcite .",
    "some applications require a fast execution which can not always be guaranteed by an interpreter .",
    "hence , while we propose a logic programming approach , one can of course go one step further and implement our algorithms directly in java , c++ , etc .",
    "following the same paradigm .",
    "the paper is organized as follows . after recalling some basic notions and results in section  [ sec : preliminaries ] ,",
    "we prove several results on the mso - equivalence of substructures induced by subtrees of a tree decomposition in section  [ sec : generalization - ns ] . in section  [ sec : mondatalog ] , it is shown that any mso formula with one free individual variable over structures with bounded treewidth can be transformed into an equivalent monadic datalog program . in section",
    "[ sec : work ] , we put monadic datalog to work by presenting new fpt algorithms for the 3-colorability problem and for the primality problem in case of bounded treewidth . in section  [ sec : results ] , we report on experimental results with a prototype implementation .",
    "a conclusion is given in section  [ sec : conclusion ] .",
    "we briefly recall some basic notions and results from database design theory ( for details , see @xcite ) .",
    "in particular , we shall define the primality problem , which will serve as a running example throughout this paper .",
    "a relational schema is denoted as @xmath0 where @xmath1 is the set of attributes , and @xmath2 the set of functional dependencies ( fds , for short ) over @xmath1 . w.l.o.g . , we only consider fds whose right - hand side consists of a single attribute .",
    "let @xmath3 with @xmath4 .",
    "we refer to @xmath5 and @xmath6 as @xmath7 and @xmath8 , respectively .",
    "the intended meaning of an fd @xmath4 is that , in any valid database instance of @xmath0 , the value of the attribute @xmath9 is uniquely determined by the value of the attributes in @xmath10 .",
    "it is convenient to denote a set @xmath11 of attributes as a string @xmath12 .",
    "for instance , we write @xmath13 rather than @xmath14 .    for any @xmath15 , we write @xmath16 to denote the closure of @xmath17 , i.e. , the set of all attributes determined by @xmath17 .",
    "an attribute @xmath9 is contained in @xmath16 iff either @xmath18 or there exists a `` derivation sequence '' of @xmath9 from @xmath17 in @xmath2 of the form @xmath19 , s.t.@xmath20 and for every @xmath21 , there exists an fd @xmath22 with @xmath23 and @xmath24 .    if @xmath25 then @xmath17 is called a _",
    "superkey_. if @xmath17 is minimal with this property , then @xmath17 is a _",
    "key_. an attribute @xmath9 is called _ prime _ if it is contained in at least one key in @xmath0 .",
    "an efficient algorithm for testing the primality of an attribute is crucial in database design since it is an indispensable prerequisite for testing if a schema is in third normal form .",
    "however , given a relational schema @xmath0 and an attribute @xmath6 , it is np - complete to test if @xmath9 is prime ( cf .",
    "@xcite ) .",
    "we shall consider two variants of the primality problem in this paper ( see section [ sec : primality ] and [ sec : monadic - prime ] , resp . ) : the decision problem ( i.e , given a relational schema @xmath0 and an attribute @xmath6 , is @xmath9 prime in @xmath0 ? ) and the enumeration problem ( i.e , given a relational schema @xmath0 , compute all prime attributes in @xmath0 ) .",
    "[ bsp : rel - schema ] consider the relational schema @xmath0 with @xmath26 and @xmath27 , @xmath28 .",
    "it can be easily checked that there are two keys for the schema : @xmath29 and @xmath30 .",
    "thus the attributes @xmath31 and @xmath32 are prime , while @xmath33 and @xmath34 are not prime .",
    "let @xmath35 be a set of predicate symbols .",
    "a _ finite structure _ @xmath36 over @xmath37 ( a _ @xmath37-structure _ , for short ) is given by a finite domain @xmath38 and relations @xmath39 , where @xmath40 denotes the arity of @xmath41 .",
    "a finite structure may also be given in the form @xmath42 where , in addition to @xmath36 , we have distinguished elements @xmath43 from @xmath44 .",
    "such distinguished elements are required for interpreting formulae with free variables .    a _ tree decomposition _",
    "@xmath45 of a @xmath37-structure @xmath36 is defined as a pair @xmath46 where @xmath47 is a tree and each @xmath48 is a subset of @xmath9 with the following properties : ( 1 ) every @xmath49 is contained in some @xmath48 .",
    "( 2 ) for every @xmath41 and every tuple @xmath50 , there exists some node @xmath51 with @xmath52 . ( 3 ) for every @xmath49 , the set @xmath53 induces a subtree of @xmath47 .",
    "the third condition is usually referred to as the _ connectedness condition_. the sets @xmath48 are called the _ bags _ ( or _ blocks _ ) of @xmath45 .",
    "the _ width _ of a tree decomposition @xmath46 is defined as @xmath54 .",
    "the _ treewidth _ of @xmath36 is the minimal width of all tree decompositions of @xmath36 .",
    "it is denoted as @xmath55 .",
    "note that trees and forests are precisely the structures with treewidth 1 .    for given @xmath56 ,",
    "it can be decided in linear time if some structure has treewidth @xmath57 . moreover , in case of a positive answer , a tree decomposition of width @xmath58 can be computed in linear time , see @xcite .    in this paper , we assume that a relational schema @xmath0 is given as a @xmath37-structure with @xmath59 , @xmath60 .",
    "the intended meaning of these predicates is as follows : @xmath61 means that @xmath62 is an fd and @xmath63 means that @xmath64 is an attribute .",
    "@xmath65 ( resp .",
    "@xmath66 ) means that @xmath64 occurs in @xmath7 ( resp .  in @xmath8 ) .",
    "the treewidth of @xmath0 is then defined as the treewidth of this @xmath37-structure .",
    "[ bsp : tree - decomposition ] recall the relational schema @xmath0 with @xmath26 and @xmath27 , @xmath28 from example [ bsp : rel - schema ] .",
    "this schema is represented as the following @xmath37-structure with @xmath67 : @xmath68 with @xmath69 , @xmath70 , @xmath71 , @xmath72 , @xmath73 , @xmath74 .",
    "a tree decomposition @xmath75 of this structure is given in figure  [ fig : tree - decomp ] .",
    "note that the maximal size of the bags in @xmath45 is @xmath76 .",
    "hence , the tree - width is @xmath77 . on the other hand ,",
    "it is easy to check that the tree - width of @xmath45 can not be smaller than @xmath78 : in order to see this , we consider the tuples in @xmath79 and @xmath80 as edges of an undirected graph .",
    "then the edges corresponding to @xmath81 and @xmath82 form a cycle in this graph . however , as we have recalled above , only trees and forests have treewidth 1 .",
    "the tree decomposition in figure  [ fig : tree - decomp ] is , therefore , optimal and we have @xmath83 .     of schema @xmath0 in example  [ bsp : rel - schema ] ]    _ remark .",
    "_ a relational schema @xmath0 defines a hypergraph @xmath84 whose vertices are the attributes in @xmath1 and whose hyperedges are the sets of attributes jointly occurring in at least one fd in @xmath2 . recall that the incidence graph of a hypergraph @xmath85 contains as nodes the vertices and hyperedges of @xmath85 .",
    "moreover , two nodes @xmath86 and @xmath87 ( corresponding to a vertex @xmath86 and a hyperedge @xmath87 in @xmath85 ) are connected in this graph iff ( in the hypergraph @xmath85 ) @xmath86 occurs in @xmath87 .",
    "it can be easily verified that the treewidth of the above described @xmath37-structure and of the incidence graph of the hypergraph @xmath84 coincide .    in this paper , we consider the following form of _ normalized tree decompositions _ , which is similar to the normal form introduced in theorem 6.72 of @xcite :    [ def : normalized ] let @xmath36 be an arbitry structure with tree decomposition @xmath45 of width @xmath58 .",
    "we call @xmath45 _ normalized _ if the conditions 1  4 are fulfilled : ( 1 ) the bags are considered as tuples of @xmath88 pairwise distinct elements @xmath89 rather than sets .",
    "( 2 ) every internal node @xmath51 has either 1 or 2 child nodes .",
    "( 3 ) if a node @xmath90 with bag @xmath89 has one child node , then the bag of the child is either obtained via a permutation of @xmath89 or by replacing @xmath91 with another element @xmath92 .",
    "we call such a node @xmath90 a _ permutation node _ or an _ element replacement node _ , respectively .",
    "( 4 ) if a node @xmath90 has two child nodes then these child nodes have identical bags as @xmath90 . in this case , we call @xmath90 a _ branch node_.    let @xmath36 be an arbitry structure with tree decomposition @xmath45 of width @xmath58 . w.l.o.g . , we may assume that the domain @xmath93 has at least @xmath88 elements .",
    "then @xmath45 can be transformed in linear time into a normalized tree decomposition @xmath94 , s.t .",
    "@xmath45 and @xmath94 have identical width .",
    "we can transform an arbitrary tree decomposition @xmath45 into a normalized tree decomposition @xmath94 by the following steps ( 1 ) - ( 5 ) .",
    "clearly this transformation works in in linear time and preserves the width .",
    "\\(1 ) all bags can be padded to the `` full '' size of @xmath88 elements by adding elements from a neighboring bag , e.g. : let @xmath95 and @xmath96 be adjacent nodes and let @xmath97 have @xmath88 elements ( in a tree decomposition of width @xmath58 , at least one such node exists ) and let @xmath98 with @xmath99 . then @xmath100 and we may simply add @xmath101 elements from @xmath102 to @xmath103 without violating the connectedness condition .",
    "( 2 ) suppose that some internal node @xmath95 has @xmath104 child nodes @xmath105 with @xmath106 .",
    "it is a standard technique to turn this part of the tree into a binary tree by inserting copies of @xmath95 into the tree ,",
    "i.e. , we introduce @xmath107 nodes @xmath108 with @xmath109 , s.t.the second child of @xmath95 is @xmath110 , the second child of @xmath110 is @xmath111 , the second child of @xmath111 is @xmath112 , etc .",
    "moreover , @xmath113 remains the first child of @xmath95 , while @xmath114 becomes the first child of @xmath110 , @xmath115 becomes the first child of @xmath111 ,  , @xmath116 becomes the first child of @xmath117 .",
    "finally , @xmath118 becomes the second child of @xmath119 .",
    "clearly , the connectedness condition is preserved by this construction .",
    "\\(3 ) if an internal node @xmath95 has two children @xmath113 and @xmath114 , s.t .",
    "the bags of @xmath95 , @xmath113 , and @xmath114 are not identical , then we simply insert a copy @xmath110 of @xmath95 between @xmath95 and @xmath113 and another copy @xmath111 of @xmath95 between @xmath95 and @xmath114 .",
    "\\(4 ) let @xmath95 be the parent of @xmath96 and let @xmath120 with @xmath121 .",
    "then we can obviously `` interpolate '' @xmath95 and @xmath96 by new nodes @xmath122 , s.t .",
    "@xmath123 is the new parent of @xmath96 , @xmath124 is the parent of @xmath123 ,  , @xmath95 is the parent of @xmath110 . moreover ,",
    "the bags @xmath125 can be defined in such a way that the bags of any two neighboring nodes differ in exactly one element , e.g. @xmath126 .",
    "\\(5 ) let the bags of any two neighboring nodes @xmath95 and @xmath96 differ by one element , i.e. , @xmath127 with @xmath128 and @xmath129 with @xmath130 .",
    "then we can insert two `` interpolation nodes '' @xmath90 and @xmath131 , s.t .",
    "@xmath48 has the same elements as @xmath97 but with @xmath132 at position @xmath133 .",
    "likewise , @xmath134 has the same elements as @xmath103 but with @xmath135 at position @xmath133 .",
    "@xmath136    [ bsp : normalized - tree - decomposition ] the tree decomposition @xmath75 in figure  [ fig : tree - decomp ] is clearly not normalized . in contrast ,",
    "tree decomposition @xmath137 in figure  [ fig : normalized - tree - decomp ] is normalized in the above sense .",
    "let us ignore the node identifiers @xmath138 for the moment .",
    "note the @xmath75 and @xmath137 have identical width .     of schema @xmath0 in example",
    "[ bsp : rel - schema ] ]      we assume some familiarity with monadic second order logic ( mso ) , see e.g.   @xcite .",
    "mso extends first order logic ( fo ) by the use of _ set variables _",
    "( usually denoted by upper case letters ) , which range over sets of domain elements .",
    "in contrast , the _ individual variables _ ( which are usually denoted by lower case letters ) range over single domain elements . an fo - formula @xmath139 over a @xmath37-structure has as atomic formulae either atoms with some predicate symbol from @xmath37 or equality atoms .",
    "an mso - formula @xmath139 over a @xmath37-structure may additionally have atoms whose predicate symbol is a monadic predicate variable . for the sake of readability ,",
    "we denote such an atom usually as @xmath140 rather than @xmath141 .",
    "likewise , we use set operators @xmath142 and @xmath143 with the obvious meaning .    the _ quantifier depth _ of an mso - formula @xmath139 is defined as the maximum degree of nesting of quantifiers ( both for individual variables and set variables ) in @xmath139 . in this work",
    ", we will mainly encounter mso formulae with free individual variables . a formula @xmath144 with exactly one free individual variable",
    "is called a _",
    "unary query_. more generally , let @xmath145 with @xmath146 for some @xmath147 be an mso formula with free variables @xmath148 .",
    "furthermore , let @xmath36 be a @xmath37-structure and @xmath43 be distinguished domain elements .",
    "we write @xmath149 to denote that @xmath150 evaluates to true in @xmath36 .",
    "usually , we refer to @xmath151 simply as a `` structure '' rather than a `` structure with distinguished domain elements '' .",
    "[ bsp : primality - mso ] it was shown in @xcite that primality can be expressed in mso .",
    "we give a slightly different mso - formula @xmath144 here , which is better suited for our purposes in section  [ sec : work ] , namely    @xmath152 $ ] with    @xmath153 $ ] and    @xmath154 $ ] .",
    "this formula expresses the following characterization of primality : an attribute @xmath132 is prime , iff there exists an attribute set @xmath155 , s.t .",
    "@xmath156 is closed w.r.t .",
    "@xmath2 ( i.e. , @xmath157 ) , @xmath158 and @xmath159 . in other words",
    ", @xmath160 is a superkey but @xmath156 is not .    recall the @xmath37-structure @xmath36 from example [ bsp : tree - decomposition ] representing a relational schema .",
    "it can be easily verified that @xmath161 and @xmath162 hold .",
    "we call two structures @xmath42 and @xmath163 _ @xmath107-equivalent _ and write @xmath164 , iff for every mso - formula @xmath139 of quantifier depth @xmath165 , the equivalence @xmath166 holds . by definition",
    ", @xmath167 is an equivalence relation . for any @xmath107",
    ", the relation @xmath167 has only finitely many equivalence classes .",
    "these equivalence classes are referred to as _",
    "@xmath107-types _ or simply as _",
    "types_. the @xmath167-equivalence between two structures can be effectively decided .",
    "there is a nice characterization of @xmath167-equivalence by ehrenfeucht - frass games : the _ @xmath107-round mso - game _ on two structures @xmath42 and @xmath163 is played between two players  the spoiler and the duplicator . in each of the @xmath107 rounds , the spoiler can choose between a point move and a set move .",
    "if , in the @xmath168-th round , he makes a _ point move _ , then he selects some element @xmath169 or some element @xmath170 .",
    "the duplicator answers by choosing an element in the opposite structure .",
    "if , in the @xmath168-th round , the spoiler makes a _ set move _ , then he selects a set @xmath171 or a set @xmath172 .",
    "the duplicator answers by choosing a set of domain elements in the opposite structure .",
    "suppose that , in @xmath107 rounds , the domain elements @xmath173 and @xmath174 from @xmath93 and @xmath175 , respectively , were chosen in the point moves .",
    "likewise , suppose that the subsets @xmath176 and @xmath177 of @xmath93 and @xmath175 , respectively , were chosen in the set moves .",
    "the _ duplicator wins _ this game , if the mapping which maps each @xmath178 to @xmath179 is a partial isomorphism from @xmath180 to @xmath181 .",
    "we say that the duplicator has a _ winning strategy _ in the @xmath107-round mso - game on @xmath42 and @xmath163 if he can win the game for any possible moves of the spoiler .",
    "the following relationship between @xmath167-equivalence and @xmath107-round mso - games holds : _ two structures @xmath42 and @xmath163 are @xmath107-equivalent iff the duplicator has a winning strategy in the @xmath107-round mso - game on @xmath42 and @xmath163 _ , see @xcite .",
    "we assume some familiarity with datalog , see e.g.   @xcite .",
    "syntactically , a datalog program @xmath182 is a set of function - free horn clauses .",
    "the ( minimal - model ) semantics can be defined as the least fixpoint of applying the immediate consequence operator .",
    "predicates occurring only in the body of rules in @xmath182 are called extensional , while predicates occurring also in the head of some rule are called intensional .",
    "let @xmath36 be a @xmath37-structure with domain @xmath9 and relations @xmath183 , @xmath184 with @xmath39 , where @xmath40 denotes the arity of @xmath41 .",
    "in the context of datalog , it is convenient to think of the relations @xmath185 as sets of ground atoms .",
    "the set of all such ground atoms of a structure @xmath36 is referred to as the extensional database ( edb ) of @xmath36 , which we shall denote as @xmath186 ( or simply as @xmath36 , if no confusion is possible ) .",
    "we have @xmath187 iff @xmath188 .    evaluating a datalog program @xmath182 over a structure @xmath36",
    "comes down to computing the least fixpoint of @xmath189 . concerning the complexity of datalog , we are mainly interested in the combined complexity ( i.e. , the complexity w.r.t .  the size of the program @xmath182 plus the size of the data @xmath36 ) .",
    "in general , the combined complexity of datalog is exptime - complete ( implicit in @xcite ) .",
    "however , there are some fragments which can be evaluated much more efficiently .",
    "( 1 ) _ propositional datalog _ (",
    "i.e. , all rules are ground ) can be evaluated in linear time ( combined complexity ) , see @xcite .",
    "( 2 ) the _ guarded fragment _ of datalog ( i.e. , every rule @xmath190 contains an extensional atom @xmath191 in the body , s.t",
    ".  all variables occurring in @xmath190 also occur in @xmath191 ) can be evaluated in time @xmath192 .",
    "( 3 ) _ monadic datalog _",
    "( i.e. , all intensional predicates are unary ) is np - complete ( combined complexity ) , see @xcite .",
    "in this section , we study the @xmath107-types of substructures induced by certain subtrees of a tree decomposition ( see definitions  [ def : subtree - envelope ] and [ def : induced ] ) .",
    "moreover , it is convenient to introduce some additional notation in definition  [ def : equivalent - tuples ] below .",
    "[ def : subtree - envelope ] let @xmath47 be a tree and @xmath90 a node in @xmath47 .",
    "then we denote the _ subtree rooted at @xmath90 _ as @xmath193 .",
    "moreover , analogously to @xcite , we write @xmath194 to denote the _ envelope of @xmath193_. this envelope is obtained by removing all of @xmath193 from @xmath47 except for the node @xmath90 .",
    "likewise , let @xmath195 be a tree decomposition of a finite structure .",
    "then we define @xmath196 and @xmath197 .    in other words",
    ", @xmath90 is the root node in @xmath193 while , in @xmath194 , it is a leaf node .",
    "clearly , the only node occurring in both @xmath193 and @xmath194 is @xmath90 .",
    "[ def : induced ] let @xmath198 be a finite structure and let @xmath199 be a tree decomposition of @xmath198",
    ". moreover , let @xmath95 be a node in @xmath200 with bag @xmath201 and let @xmath202 be one of the subtrees @xmath203 or @xmath204 of @xmath200 .    then we write @xmath205 to denote the structure @xmath206 , where @xmath207 is the substructure of @xmath198 induced by the elements occurring in the bags of @xmath202 .",
    "[ bsp : induced - substructure ]    recall the relational schema @xmath0 represented by the structure @xmath36 from example [ bsp : tree - decomposition ] with ( normalized ) tree decomposition @xmath94 in figure  [ fig : normalized - tree - decomp ] .",
    "consider , for instance , the node @xmath95 in @xmath94 , as depicted in figure [ fig : normalized - tree - decomp - induced ] , with bag @xmath208 .",
    "then the induced substructure @xmath209 is the substructure of @xmath36 which is induced by the elements occurring in the bags of @xmath210 , whereas @xmath211 the substructure of @xmath36 which is induced by the elements occurring in the bags of @xmath212 .     and",
    "@xmath213 of the tree decomposition @xmath75 w.r.t . the node @xmath95 . ]",
    "[ def : equivalent - tuples ] let @xmath56 be a natural number and let @xmath198 and @xmath214 be finite structures over some signature @xmath37",
    ". moreover , let @xmath89 ( resp .",
    "@xmath215 ) be a tuple of pairwise distinct elements in @xmath9 ( resp .",
    "@xmath191 ) .",
    "we call @xmath89 and @xmath215 _ equivalent _ and write @xmath216 , iff for any predicate symbol @xmath217 with arity @xmath40 and for all tuples @xmath218 , the equivalence @xmath219",
    "@xmath220 @xmath221 holds .",
    "we are now ready to generalize results from @xcite ( dealing with trees plus a distinguished node ) to the case of finite structures of bounded treewidth over an arbitrary signature @xmath37 . in the three lemmas below , let @xmath222 and @xmath56 be arbitrary natural numbers and let @xmath37 be an arbitrary signature .",
    "[ lem : folklore - bottomup ] let @xmath198 and @xmath214 be @xmath37-structures , let @xmath202 ( resp .",
    "@xmath200 ) be a normalized tree decomposition of @xmath198 ( resp .  of @xmath214 ) of width",
    "@xmath58 , and let @xmath95 ( resp .",
    "@xmath90 ) be an internal node in @xmath202 ( resp .  in @xmath200 ) .",
    "\\(1 ) _ permutation nodes . _",
    "let @xmath96 ( resp .",
    "@xmath131 ) be the only child of @xmath95 in @xmath202 ( resp .",
    "of @xmath90 in @xmath200 ) .",
    "moreover , let @xmath223 , @xmath224 , @xmath225 , and @xmath226 denote the bags at the nodes @xmath95 , @xmath96 , @xmath90 , and @xmath131 , respectively .",
    "if @xmath227 and there exists a permutation @xmath228 , s.t .",
    "@xmath229 and @xmath230    then @xmath231 .",
    "\\(2 ) _ element replacement nodes .",
    "_ let @xmath96 ( resp .",
    "@xmath131 ) be the only child of @xmath95 in @xmath202 ( resp .",
    "of @xmath90 in @xmath200 ) .",
    "moreover , let @xmath232 , @xmath233 , @xmath234 , @xmath235 @xmath236 , and @xmath237 denote the bags at the nodes @xmath95 , @xmath96 , @xmath90 , and @xmath131 , respectively .    if @xmath238 and @xmath239 then @xmath240 @xmath241 .",
    "\\(3 ) _ branch nodes . _",
    "let @xmath110 and @xmath111 ( resp .",
    "@xmath113 and @xmath114 ) be the children of @xmath95 in @xmath202 ( resp .  of @xmath90 in @xmath200 ) .    if @xmath242 and @xmath243 @xmath244    then @xmath245 .",
    "\\(1 ) let @xmath246 .",
    "hence , there exists a winning strategy of the duplicator on these structures .",
    "moreover , @xmath89 and @xmath215 are obtained from @xmath247 resp .",
    "@xmath248 by identical permutations .",
    "thus the duplicator s winning strategy on the structures @xmath249 and @xmath250 , @xmath251 is also a winning strategy on @xmath252 and @xmath253 .",
    "\\(2 ) let @xmath246 .",
    "hence , there exists a winning strategy of the duplicator on these structures .",
    "the duplicator extends this strategy to the structures @xmath252 and @xmath253 in the following way .",
    "( we only consider moves of the spoiler in @xmath252 .",
    "moves in @xmath253 are treated analogously . )",
    "any point or set move which is entirely in @xmath249 is answered according to the winning strategy on the substructures @xmath249 and @xmath254 . for moves involving @xmath91",
    ", we proceed as follows .",
    "if the duplicator picks @xmath91 in a point move , then the duplicator answers with @xmath255 . likewise ,",
    "if the spoiler makes a set move of the form @xmath256 , where @xmath257 is a subset of the elements in @xmath249 then the duplicator answers with @xmath258 , where @xmath259 is the duplicator s answer to @xmath257 in the game played on the substructures @xmath249 and @xmath254 .",
    "let @xmath173 and @xmath174 be the elements selected in point moves and @xmath176 and @xmath260 be the sets selected in set moves . by the above definition of the duplicator s strategy , every move involving @xmath91 is answered by the analogous move involving @xmath255 .",
    "for all other elements , the selected elements clearly define a partial isomorphism on the structures @xmath249 and @xmath254 extended by the selected sets .",
    "it remains to verify that the selected elements also define a partial isomorphism on the structures @xmath252 and @xmath253 extended by the selected sets .",
    "in particular , we have to verify that all relations @xmath217 are preserved by the selected elements . for any tuples of elements not involving @xmath91 ( resp .",
    "@xmath255 ) , this is guaranteed by the fact that the winning strategy on @xmath249 and @xmath254 is taken over to the structures @xmath252 and @xmath253 . on the other hand , by the connectedness condition of tree decompositions , we can be sure that the only relations on @xmath252 ( resp .",
    "@xmath253 ) involving @xmath91 ( resp .",
    "@xmath255 ) are with elements in the bag @xmath89 ( resp .",
    "@xmath215 ) .",
    "but then , by the equivalence @xmath216 , the preservation of @xmath217 is again guaranteed .",
    "\\(3 ) by the definition of branch nodes , the three nodes @xmath261 have identical bags , say @xmath89 . in particular , since the bag of @xmath95 introduces no new elements , all elements contained in @xmath252 are either contained in @xmath262 or in @xmath263 .",
    "moreover , by the connectedness condition , only the elements @xmath264 occur in both substructures . of course , the analogous observation holds for @xmath265 , and @xmath253 .    by assumption , @xmath266 and @xmath267 .",
    "we define the duplicator s strategy on @xmath252 and @xmath253 by simply combining the winning strategies on the substructures in the obvious way ( again we only consider moves of the spoiler in @xmath252 ) , i.e. , if the spoiler picks some element @xmath268 of @xmath252 then the chosen element @xmath268 is in @xmath269 for some @xmath270 .",
    "hence , the duplicator simply answers according to his winning strategy in the game on @xmath269 and @xmath271 . on the other hand ,",
    "suppose that the spoiler picks a set @xmath257 .",
    "then @xmath257 is of the form @xmath272 , where @xmath273 contains only elements in @xmath269 .",
    "thus , the duplicator simply answers with @xmath274 , where @xmath275 is the answer to @xmath273 according to the winning strategy in the game on @xmath269 and @xmath271 .",
    "it remains to verify that the selected vertices indeed define a partial isomorphism on the structures @xmath252 and @xmath253 extended by the selected sets .",
    "again , the only interesting point is that every relation @xmath217 is preserved by the elements selected in the point moves . if all elements in a tuple @xmath276 ( resp .",
    "@xmath277 ) come from the same substructure @xmath269 ( resp .",
    "@xmath271 ) , then this is clearly fulfilled due to the fact that the duplicator s winning strategy on the substructures @xmath269 and @xmath271 is taken over unchanged to the game on @xmath252 and @xmath253 . on the other hand , by the connectedness condition , we can be sure that the only relations between elements from different substructures @xmath262 and @xmath263 ( resp .",
    "@xmath278 and @xmath279 ) are with elements in the bag @xmath89 ( resp .",
    "@xmath215 ) of @xmath110 , @xmath111 , and @xmath95 ( resp .",
    "@xmath113 , @xmath114 , and @xmath90 ) .",
    "but then , by the equivalences @xmath280 and @xmath267 , the preservation of @xmath217 is again guaranteed .",
    "[ lem : folklore - topdown ] let @xmath198 and @xmath214 be @xmath37-structures , let @xmath202 ( resp .",
    "@xmath200 ) be a normalized tree decomposition of @xmath198 ( resp .  of @xmath214 ) of width @xmath58 , and",
    "let @xmath95 ( resp .",
    "@xmath90 ) be an internal node in @xmath202 ( resp .  in @xmath200 ) .",
    "\\(1 ) _ permutation nodes . _",
    "let @xmath96 ( resp .",
    "@xmath131 ) be the only child of @xmath95 in @xmath202 ( resp .",
    "of @xmath90 in @xmath200 ) .",
    "moreover , let @xmath223 , @xmath224 , @xmath225 , and @xmath226 denote the bags at the nodes @xmath95 , @xmath96 , @xmath90 , and @xmath131 , respectively .",
    "if @xmath281 and there exists a permutation @xmath228 , s.t . @xmath229 and @xmath230    then @xmath282 .",
    "\\(2 ) _ element replacement nodes . _",
    "let @xmath96 ( resp .",
    "@xmath131 ) be the only child of @xmath95 in @xmath202 ( resp .",
    "of @xmath90 in @xmath200 ) .",
    "moreover , let @xmath232 , @xmath233 , @xmath234 , @xmath235 @xmath236 , and @xmath237 denote the bags at the nodes @xmath95 , @xmath96 , @xmath90 , and @xmath131 , respectively .    if @xmath283 and @xmath284 then @xmath285 @xmath286 .",
    "\\(3 ) _ branch nodes . _",
    "let @xmath110 and @xmath111 ( resp .",
    "@xmath113 and @xmath114 ) be the children of @xmath95 in @xmath202 ( resp .  of @xmath90 in @xmath200 ) .    if @xmath281 and @xmath287 , @xmath288 then    @xmath289 .    if @xmath281 and @xmath290 , @xmath291 then    @xmath292 .",
    "the proof is by ehrenfeucht - frass games , analogously to lemma  [ lem : folklore - bottomup ] @xmath136    [ lem : gluing ] let @xmath198 and @xmath214 be @xmath37-structures , let @xmath202 ( resp .",
    "@xmath200 ) be a normalized tree decomposition of @xmath198 ( resp .  of @xmath214 ) of width @xmath58 , and",
    "let @xmath95 ( resp .",
    "@xmath90 ) be an arbitrary node in @xmath202 ( resp .  in @xmath200 ) , whose bag is @xmath89 ( resp .",
    "@xmath215 ) .    if @xmath293 and @xmath294 , @xmath295 then @xmath296 for every @xmath297 .",
    "again , the proof is by ehrenfeucht - frass games , analogously to lemma  [ lem : folklore - bottomup ] @xmath136    _ discussion .",
    "_ lemma  [ lem : folklore - bottomup ] provides the intuition how to determine the @xmath107-type of the substructure induced by a subtree @xmath298 via a bottom - up traversal of the tree decomposition @xmath202 .",
    "the three cases in the lemma refer to the three kinds of nodes which the root node @xmath95 of this subtree can have .",
    "the essence of the lemma is that the type of the structure induced by @xmath298 is fully determined by the type of the structure induced by the subtree rooted at the child node(s ) plus the relations between elements in the bag at node @xmath95 .",
    "of course , this is no big surprise .",
    "analogously , lemma  [ lem : folklore - topdown ] deals with the @xmath107-type of the substructure induced by a subtree @xmath299 , which can be obtained via a top - down traversal of @xmath202 .",
    "finally , lemma  [ lem : gluing ] shows how the @xmath107-type of the substructures induced by @xmath298 and @xmath299 fully determines the type of the entire structure @xmath36 extended by some domain element from the bag of @xmath95 .",
    "in this section , we introduce two restricted fragments of datalog , namely _ monadic datalog _ over finite structures with bounded treewidth and the _ quasi - guarded fragment _ of datalog .",
    "let @xmath35 be a set of predicate symbols and let @xmath56 denote the treewidth .",
    "then we define the following extended signature @xmath300 .    @xmath301    where the unary predicates @xmath302 , and @xmath303 as well as the binary predicates @xmath304 and @xmath305 are used to represent the tree @xmath47 of the normalized tree decomposition in the obvious way .",
    "for instance , we write @xmath306 to denote that @xmath110 is either the first child or the only child of @xmath95 . finally , @xmath307 has arity @xmath308 , where @xmath309 means that the bag at node @xmath90 is @xmath89 .",
    "[ def : mondatalog ] let @xmath37 be a set of predicate symbols and let @xmath56 .",
    "a monadic datalog program over @xmath37-structures with treewidth @xmath58 is a set of datalog rules where all extensional predicates are from @xmath300 and all intensional predicates are unary .    for any @xmath37-structure @xmath36 with normalized tree decomposition @xmath310 of width @xmath58 ,",
    "we denote by @xmath311 the @xmath300-structure representing @xmath36 plus @xmath312 as follows : the domain of @xmath311 is the union of @xmath44 and the nodes of @xmath47 .",
    "in addition to the relations @xmath185 with @xmath41 , the structure @xmath311 also contains relations for each predicate @xmath302 , @xmath303 , @xmath304 , @xmath305 , and @xmath307 thus representing the tree decomposition @xmath45 .",
    "by @xcite , one can compute @xmath311 from @xmath36 in linear time w.r.t.the size of @xmath36 .",
    "hence , the size of @xmath311 ( for some reasonable encoding , see e.g.   @xcite ) is also linearly bounded by the size of @xmath36 .",
    "[ bsp : tautd - structure ]    recall the relational schema @xmath0 represented by the structure @xmath36 from example [ bsp : tree - decomposition ] with normalized tree decomposition @xmath94 in figure  [ fig : normalized - tree - decomp ] .",
    "the domain of @xmath311 is the union of @xmath44 and the tree nodes @xmath313 .",
    "the corresponding @xmath300 structure @xmath311 representing the relational schema plus tree decomposition @xmath94 is made up by the following set of ground atoms : @xmath314 , @xmath315 , @xmath316 , @xmath317 , @xmath318 , @xmath319 , @xmath320 , @xmath321 , @xmath320 .    as we recalled in section",
    "[ sec : datalog ] , the evaluation of monadic datalog is np - complete ( combined complexity ) .",
    "however , the target of our transformation from mso to datalog will be a further restricted fragment of datalog , which we refer to as `` quasi - guarded '' .",
    "the evaluation of this fragment can be easily shown to be tractable .",
    "[ def : quasiguarded ] let @xmath191 be an atom and @xmath322 a variable in some rule @xmath190 .",
    "we call @xmath322 `` functionally dependent '' on @xmath191 if in every ground instantiation @xmath323 of @xmath190 , the value of @xmath322 is uniquely determined by the value of @xmath191 .",
    "we call a datalog program @xmath182 `` quasi - guarded '' if every rule @xmath190 contains an extensional atom @xmath191 , s.t .",
    "every variable occurring in @xmath190 either occurs in @xmath191 or is functionally dependent on @xmath191 .",
    "[ theo : mondatalog - complexity ] let @xmath182 be a quasi - guarded datalog program and let @xmath36 be a finite structure . then @xmath182 can be evaluated over @xmath36 in time @xmath324 , where @xmath325 denotes the size of the datalog program and @xmath326 denotes the size of the data .",
    "let @xmath190 be a rule in the program @xmath182 and let @xmath191 be the `` quasi - guard '' of @xmath190 , i.e. , all variables in @xmath190 either occur in @xmath191 or are functionally dependent on @xmath191 . in order to compute all possible ground instances @xmath323 of @xmath190 over @xmath36 , we first instantiate @xmath191 .",
    "the maximal number of such instantiations is clearly bounded by @xmath326 . since all other variables occurring in @xmath190 are functionally dependent on the variables in @xmath191 , in fact the number of all possible ground instantiations @xmath323 of @xmath190 is bounded by @xmath326 .    hence , in total",
    ", the ground program @xmath327 consisting of all possible ground instantiations of the rules in @xmath182 has size @xmath324 and also the computation of these ground rules fits into the linear time bound . as we recalled in section  [ sec : datalog ] , the ground program @xmath327 can be evaluated over @xmath36 in time @xmath328 .",
    "@xmath136    before we state the main result concerning the _ expressive power _ of monadic datalog over structures with bounded treewidth , we introduce the following notation . in order to simplify the exposition below",
    ", we assume that all predicates @xmath41 have the same arity @xmath190 .",
    "first , this can be easily achieved by copying columns in relations with smaller arity .",
    "moreover , it is easily seen that the results also hold without this restriction .",
    "it is convenient to use the following abbreviations .",
    "let @xmath43 be a tuple of domain elements .",
    "then we write @xmath329 to denote the set of all ground atoms with predicates in @xmath35 and arguments in @xmath330 , i.e. , @xmath331 let @xmath36 be a structure with tree decomposition @xmath45 and let @xmath95 be a node in @xmath45 whose bag is @xmath43 . then we write @xmath332 as a short - hand for the structure @xmath151 with distinguished constants @xmath43 .",
    "[ theo : mso - to - datalog ] let @xmath37 and @xmath56 be arbitrary but fixed .",
    "every mso - definable unary query over @xmath37-structures of treewidth @xmath58 is also definable in the quasi - guarded fragment of monadic datalog over @xmath300 .",
    "let @xmath144 be an arbitrary mso formula with free variable @xmath333 and quantifier depth @xmath107 .",
    "we have to construct a monadic datalog program @xmath182 with distinguished predicate @xmath139 which defines the same query .",
    ", we only consider the case of structures whose domain has @xmath334 elements .",
    "we maintain two disjoint sets of @xmath107-types @xmath335 and @xmath336 , representing @xmath107-types of structures @xmath151 of the following form : @xmath36 has a tree decomposition @xmath45 of width @xmath58 and @xmath223 is the bag of some node @xmath95 in @xmath45 .",
    "moreover , for @xmath335 , we require that @xmath95 is the root of @xmath337 while , for @xmath336 , we require that @xmath95 is a leaf node of @xmath45 .",
    "we maintain for each type @xmath338 a witness @xmath339 .",
    "the types in @xmath335 and @xmath336 will serve as predicate names in the monadic datalog program to be constructed .",
    "initially , @xmath340 .",
    "_ `` bottom - up '' construction of @xmath335 . _    base case .",
    "let @xmath341 be pairwise distinct elements and let @xmath337 be a tree decomposition consisting of a single node @xmath95 , whose bag is @xmath342 .",
    "then we consider all possible structures @xmath343 with this tree decomposition .",
    "in particular , @xmath344 .",
    "we get all possible structures with tree decomposition @xmath337 by letting the edb @xmath186 be any subset of @xmath329 . for every such structure @xmath343",
    ", we check if there exists a type @xmath345 with @xmath346 , s.t .  @xmath347 .",
    "if such a @xmath338 exists , we take it .",
    "otherwise we invent a new token @xmath338 , add it to @xmath335 and set @xmath348 . in any case , we add the following rule to the program @xmath182 :    @xmath349    induction step . we construct new structures by extending the tree decompositions of existing witnesses in `` bottom - up '' direction , i.e. , by introducing a new root node .",
    "this root node may be one of three kinds of nodes .",
    "\\(a ) permutation nodes . for each @xmath350 , let @xmath351 with bag @xmath352 at the root @xmath96 in @xmath353 .",
    "then we consider all possible triples @xmath354 , where @xmath337 is obtained from @xmath353 by appending @xmath96 to a new root node @xmath95 , s.t .",
    "@xmath95 is a permutation node , i.e. , there exists some permutation @xmath228 , s.t.@xmath355    for every such structure @xmath343 , we check if there exists a type @xmath345 with @xmath346 , s.t .",
    "if such a @xmath338 exists , we take it .",
    "otherwise we invent a new token @xmath338 , add it to @xmath335 and set @xmath348 . in any case",
    ", we add the following rule to the program @xmath182 :    @xmath356    \\(b ) element replacement nodes . for each @xmath350 , let @xmath357 with bag @xmath358 at the root @xmath96 in @xmath353 .",
    "then we consider all possible triples @xmath354 , where @xmath337 is obtained from @xmath353 by appending @xmath96 to a new root node @xmath95 , s.t .",
    "@xmath95 is an element replacement node . for the tree decomposition @xmath337 , we thus invent some new element @xmath91 and set @xmath359 . for this tree decomposition @xmath337",
    ", we consider all possible structures @xmath36 with @xmath360 where the edb @xmath361 is extended to the edb @xmath186 by new ground atoms from @xmath329 , s.t.@xmath91 occurs as argument of all ground atoms in @xmath362 .",
    "for every such structure @xmath343 , we check if there exists a type @xmath345 with @xmath346 , s.t .  @xmath347 . if such a @xmath338 exists , we take it .",
    "otherwise we invent a new token @xmath338 , add it to @xmath335 and set @xmath348 . in any case , we add the following rule to the program @xmath182 :    @xmath363    \\(c ) branch nodes .",
    "let @xmath364 , @xmath365 be two ( not necessarily distinct ) types in @xmath335 with @xmath366 and @xmath367 .",
    "let @xmath368 and @xmath369 , respectively",
    ". moreover , let @xmath370    let @xmath371 be a renaming function with @xmath372 . by applying @xmath371 to @xmath373 , we obtain a new triple @xmath374 with @xmath375 and @xmath376 .",
    "in particular , we thus have @xmath377 .",
    "clearly , @xmath378 holds .    for every such pair @xmath379 and @xmath374 , we check if the edbs are inconsistent , i.e. , @xmath380 .",
    "if this is the case , then we ignore this pair .",
    "otherwise , we construct a new tree decomposition @xmath337 with a new root node @xmath95 , whose child nodes are @xmath110 and @xmath111 .",
    "as the bag of @xmath95 , we set @xmath381 . by construction",
    ", @xmath337 is a normalized tree decomposition of the structure @xmath36 with @xmath382 and edb @xmath383 .    as in the cases",
    "above , we have to check if there exists a type @xmath345 with @xmath346 , s.t .",
    "if such a @xmath338 exists , we take it .",
    "otherwise we invent a new token @xmath338 , add it to @xmath335 and set @xmath348 . in any case",
    ", we add the following rule to the program @xmath182 :    @xmath384    \\2 . _",
    "`` top - down '' construction of @xmath336 .",
    "_    base case .",
    "let @xmath341 be pairwise distinct elements and let @xmath337 be a tree decomposition consisting of a single node @xmath95 , whose bag is @xmath342 .",
    "then we consider all possible structures @xmath343 with this tree decomposition .",
    "in particular , @xmath385 .",
    "we get all possible structures with tree decomposition @xmath337 by letting the edb @xmath186 be any subset of @xmath329 . for every such structure @xmath343",
    ", we check if there exists a type @xmath386 with @xmath346 , s.t .  @xmath347 .",
    "if such a @xmath338 exists , we take it .",
    "otherwise we invent a new token @xmath338 , add it to @xmath336 and set @xmath348 . in any case , we add the following rule to the program @xmath182 :    @xmath387    induction step .",
    "we construct new structures by extending the tree decompositions of existing witnesses in `` top - down '' direction , i.e. , by introducing a new leaf node @xmath95 and appending it as new child to a former leaf node @xmath96 .",
    "the node @xmath96 may thus become one of three kinds of nodes in a normalized tree decomposition .",
    "\\(a ) permutation nodes . for each @xmath388 , let @xmath351 with bag @xmath352 at some leaf node @xmath96 in @xmath353 .",
    "then we consider all possible triples @xmath354 , where @xmath337 is obtained from @xmath353 by appending @xmath95 as a new child of @xmath96 , s.t .",
    "@xmath96 is a permutation node , i.e. , there exists some permutation @xmath228 , s.t.@xmath355    for every such structure @xmath343 , we check if there exists a type @xmath386 with @xmath389 , s.t .  @xmath347 .",
    "if such a @xmath338 exists , we take it .",
    "otherwise we invent a new token @xmath338 , add it to @xmath336 and set @xmath348 . in any case",
    ", we add the following rule to the program @xmath182 :    @xmath390    \\(b ) element replacement nodes . for each @xmath388 , let @xmath357 with bag @xmath391 , @xmath392 at leaf node @xmath96 in @xmath353 .",
    "then we consider all possible triples @xmath354 , where @xmath337 is obtained from @xmath353 by appending @xmath95 as new child of @xmath96 , s.t .",
    "@xmath96 is an element replacement node . for the tree decomposition @xmath337",
    ", we thus invent some new element @xmath91 and set @xmath359 . for this tree decomposition @xmath337",
    ", we consider all possible structures @xmath36 with @xmath393 where the edb @xmath361 is extended to the edb @xmath186 by new ground atoms from @xmath329 , s.t.@xmath91 occurs as argument of all ground atoms in @xmath362 .    for every such structure @xmath343",
    ", we check if there exists a type @xmath386 with @xmath346 , s.t .  @xmath347 .",
    "if such a @xmath338 exists , we take it .",
    "otherwise we invent a new token @xmath338 , add it to @xmath336 and set @xmath348 . in any case , we add the following rule to the program @xmath182 :    @xmath394    \\(c ) branch nodes .",
    "let @xmath386 and @xmath395 with @xmath396 and @xmath367 .",
    "note that @xmath95 is a leaf in @xmath202 while @xmath111 is the root of @xmath397 .",
    "now let @xmath398 and @xmath369 , respectively , and let @xmath399 .",
    "let @xmath371 be a renaming function with @xmath372 . by applying @xmath371 to @xmath373",
    ", we obtain a new triple @xmath374 with @xmath375 and @xmath376 .",
    "in particular , we thus have @xmath377 .",
    "clearly , @xmath378 holds .    for every such pair @xmath400 and @xmath374",
    ", we check if the edbs are inconsistent , i.e. , @xmath401 .",
    "if this is the case , then we ignore this pair .",
    "otherwise , we construct a new tree decomposition @xmath402 by introducing a new leaf node @xmath110 and appending both @xmath110 and @xmath111 as child nodes of @xmath95 . as the bag of @xmath110 , we set @xmath403 . by construction",
    ", @xmath402 is a normalized tree decomposition of the structure @xmath404 with @xmath405 and edb @xmath406 .    as in the cases",
    "above , we have to check if there exists a type @xmath407 with @xmath408 , s.t .  @xmath409 .",
    "if such a @xmath364 exists , we take it .",
    "otherwise we invent a new token @xmath364 , add it to @xmath336 and set @xmath410 in any case , we add the following rule to the program @xmath182 :    @xmath411    now suppose that @xmath402 is constructed from @xmath337 and @xmath412 by attaching the new node @xmath110 as second child of @xmath95 and @xmath111 as the first child . in this case , the structure @xmath404 remains exactly the same as in the case above , since the order of the child nodes of a node in the tree decomposition is irrelevant .",
    "thus , whenever the above rule is added to the program @xmath182 , then also the following rule is added :    @xmath413    \\3 .",
    "_ element selection .",
    "_    we consider all pairs of types @xmath414 and @xmath415 .",
    "let @xmath366 and @xmath367 .",
    "moreover , let @xmath368 and @xmath369 , respectively , and let @xmath416 .",
    "let @xmath371 be a renaming function with @xmath372 . by applying @xmath371 to @xmath373",
    ", we obtain a new triple @xmath374 with @xmath375 and @xmath376 .",
    "in particular , we thus have @xmath377 .",
    "clearly , @xmath378 holds .    for every such pair @xmath379 and @xmath374",
    ", we check if the edbs are inconsistent , i.e. , @xmath380 .",
    "if this is the case , then we ignore this pair .",
    "otherwise , we construct a new tree decomposition @xmath337 by identifying @xmath110 (= the root of @xmath402 ) with @xmath111 (= a leaf of @xmath412 ) . by construction",
    ", @xmath337 is a normalized tree decomposition of the structure @xmath36 with @xmath417 and @xmath383 .",
    "now check for each @xmath418 in @xmath419 , if @xmath420 . if this is the case",
    ", then we add the following rule to @xmath421 .",
    "@xmath422    we claim that the program @xmath182 with distinguished monadic predicate @xmath139 is the desired monadic datalog program , i.e. , let @xmath36 be an arbitrary input @xmath37-structure with tree decomposition @xmath337 and let @xmath311 denote the corresponding @xmath300-structure .",
    "moreover , let @xmath423 .",
    "then the following equivalence holds : @xmath424    note that the intensional predicates in @xmath335 , @xmath336 , and @xmath425 are layered in that we can first compute the least fixpoint of the predicates in @xmath335 , then @xmath336 , and finally @xmath139 .    the bottom - up construction of @xmath335 guarantees that we indeed construct all possible types of structures @xmath426 with tree decomposition @xmath45 and root @xmath90 .",
    "this can be easily shown by lemma  [ lem : folklore - bottomup ] and an induction on the size of the tree decomposition @xmath45 .",
    "on the other hand , for every subtree @xmath427 of @xmath337 , the type of the induced substructure @xmath428 is @xmath338 for some @xmath345 if and only if the atom @xmath429 is in the least fixpoint of @xmath430 . again",
    "this can be shown by an easy induction argument using lemma  [ lem : folklore - bottomup ] .",
    "analogously , we may conclude via lemma  [ lem : folklore - topdown ] that @xmath336 contains all possible types of structures @xmath426 with tree decomposition @xmath45 and some leaf node @xmath90 . moreover , for every subtree @xmath431 of @xmath337 , the type of the induced substructure @xmath432 is @xmath338 for some @xmath386 if and only if the atom @xmath429 is in the least fixpoint of @xmath430 .",
    "the definition of the predicate @xmath139 in part 3 is a direct realization of lemma  [ lem : gluing ] .",
    "it thus follows that @xmath433 iff @xmath434 is in the least fixpoint of @xmath430 .",
    "finally , an inspection of all datalog rules added to @xmath182 by this construction shows that these rules are indeed quasi - guarded , i.e. , they all contain an atom @xmath191 with an extensional predicate , s.t.all other variables in this rule are functionally dependent on the variables in @xmath191 .",
    "for instance , in the rule added to @xmath335 in case of a branch node , the atom @xmath435 is the quasi - guard .",
    "indeed , the remaining variables @xmath436 and @xmath437 in this rule are functionally dependent on @xmath86 via the atoms @xmath438 and @xmath439 .",
    "@xmath136    above all , theorem  [ theo : mso - to - datalog ] is an expressivity result .",
    "however , it can of course be used to derive also a complexity result .",
    "indeed , we can state a slightly extended version of courcelle s theorem as a corollary ( which is in turn a special case of theorem 4.12 in @xcite ) .",
    "the evaluation problem of unary mso - queries @xmath144 over @xmath37-structures @xmath36 with treewidth @xmath58 can be solved in time @xmath440 for some function @xmath62 .",
    "suppose that we are given an mso - query @xmath144 and some treewidth @xmath58 .",
    "by theorem  [ theo : mso - to - datalog ] , we can construct an equivalent , quasi - guarded datalog program @xmath182 .",
    "the whole construction is independent of the data .",
    "hence , the time for this construction and the size of @xmath182 are both bounded by some term @xmath441 . by @xcite , a tree decomposition @xmath45 of @xmath36 and , therefore , also the extended structure @xmath311 can be computed in time @xmath442 . finally , by theorem  [ theo : mondatalog - complexity ] , the quasi - guarded program @xmath182 can be evaluated over @xmath311 in time @xmath443 , from which the desired overall time bound follows .",
    "@xmath136    _ discussion .",
    "_ clearly , theorem  [ theo : mso - to - datalog ] is not only applicable to mso - definable _ unary queries _ but also to _ @xmath133-ary queries _ , i.e. , mso - queries defining a decision problem .",
    "an inspection of the proof of theorem  [ theo : mso - to - datalog ] reveals that several simplifications are possible in this case .",
    "above all , the whole `` top - down '' construction of @xmath336 can be omitted .",
    "moreover , the rules with head predicate @xmath139 are now much simpler : let @xmath139 be a @xmath133-ary mso - formula and let @xmath335 denote the set of types obtained by the `` bottom - up '' construction in the above proof .",
    "then we define @xmath444 and @xmath445 . finally , we add the following set of rules with head predicate @xmath139 to our datalog program : @xmath446 for every @xmath447 .",
    "we shall make use of these simplifications in section [ sec : three - col ] and [ sec : primality ] when we present new algorithms for two decision problems .",
    "in contrast , these simplifications are no longer possible when we consider an enumeration problem in section  [ sec : monadic - prime ] . in particular , the `` top - down '' construction will indeed be required then .",
    "we now put monadic datalog to work by constructing several new algorithms .",
    "we start off with a simple example , namely the 3-colorability problem , which will help to illustrate the basic ideas , see section [ sec : three - col ] .",
    "our ultimate goal is to tackle two more involved problems , namely the primality decision problem and the primality enumeration problem , see sections [ sec : primality ] and [ sec : monadic - prime ] .",
    "all these problems are well - known to be intractable . however , since they are expressible in mso over appropriate structures , they are fixed - parameter tractable w.r.t.the treewidth . in this section ,",
    "we show that these problems admit succinct and efficient solutions via datalog .",
    "before we present our datalog programs , we slightly modify the notion of normalized tree decompositions from section  [ sec : treewidth ] .",
    "recall that an _ element replacement node _ replaces exactly one element in the bag of the child node by a new element . for our algorithms ,",
    "it is preferable to split this action into two steps , namely , an _ element removal node _",
    ", which removes one domain element from the bag of its child node , and an _ element introduction node _ , which introduces one new element",
    ". moreover , it is now preferable to consider the bags as sets of domain elements rather than as tuples .",
    "hence , we may delete permutation nodes from the tree decomposition .",
    "finally , we drop the condition that all bags in a tree decomposition of width @xmath58 must have `` full size '' @xmath88 ( by splitting the element replacement into element removal and element introduction , this condition would have required some relaxation anyway ) .",
    "such a normal form of tree decompositions was also considered in @xcite .",
    "for instance , recall the tree decomposition @xmath137 from figure  [ fig : normalized - tree - decomp ] .",
    "a tree decomposition @xmath448 compliant with our modified notion of _ normalized tree decompositions _",
    "is depicted in figure  [ fig : normalized - tree - decomp - no - perm ] .",
    "suppose that a graph @xmath449 with vertices @xmath450 and edges @xmath451 is given as a @xmath37-structure with @xmath452 , i.e. , @xmath33 is the binary edge relation .",
    "this graph is 3-colorable , iff there exists a partition of @xmath450 into three sets @xmath453 , @xmath454 , @xmath455 , s.t.no two adjacent vertices @xmath456 are in the same set @xmath453 , @xmath454 , or @xmath455 .",
    "this criterion can be easily expressed by an mso - sentence , namely    @xmath457 \\wedge \\\\ & & ( \\neg r(v ) \\vee \\neg g(v ) ) \\wedge ( \\neg r(v ) \\vee \\neg b(v ) ) \\wedge ( \\neg g(v ) \\vee \\neg b(v))].\\end{aligned}\\ ] ]    suppose that a graph @xmath449 together with a tree decomposition @xmath45 of width @xmath58 is given as a @xmath300-structure with @xmath458 . in figure",
    "[ fig : three - col ] , we describe a datalog program which takes such a @xmath300-structure as input and decides if the graph thus represented is 3-colorable .",
    "some words on the notation used in this program are in order : we are using lower case letters @xmath95 and @xmath86 ( possibly with subscripts ) as datalog variables for a single node in @xmath45 and for a single vertex in @xmath450 , respectively .",
    "in contrast , upper case letters @xmath17 , @xmath1 , @xmath459 , and @xmath191 are used as datalog variables denoting sets of vertices . note that these sets are not sets in the general sense , since their cardinality is restricted by the size @xmath88 of the bags , where @xmath58 is a fixed constant .",
    "hence , these `` fixed - size '' sets can be simply implemented by means of @xmath107-tuples with @xmath460 over @xmath461 . for the sake of readability",
    ", we are using non - datalog expressions with the set operator @xmath462 ( disjoint union ) .",
    "for the fixed - size sets under consideration here , one could , of course , easily replace this operator by `` proper '' datalog expressions of the form @xmath463 .",
    "it is convenient to introduce the following notation .",
    "let @xmath464 be the input graph with tree decomposition @xmath45 .",
    "for any node @xmath95 in @xmath45 , we write as usual @xmath465 to denote the subtree of @xmath45 rooted at @xmath95 .",
    "moreover , we write @xmath466 and @xmath467 to denote the vertices in the bag of @xmath95 respectively in any bag in @xmath465 .",
    "our 3-colorability - program checks if @xmath459 is 3-colorable via the criterion mentioned above , i.e. , there exists a partition of @xmath450 into three sets @xmath453 , @xmath454 , @xmath455 , s.t.no two adjacent vertices @xmath456 are in the same set @xmath453 , @xmath454 , or @xmath455 .    at the heart of this program",
    "is the intensional predicate @xmath468 with the following intended meaning : @xmath95 denotes a node in @xmath45 and @xmath1 , @xmath459 , @xmath191 are the projections of @xmath453 , @xmath454 , @xmath455 onto @xmath466 .",
    "for all values @xmath469 , the ground fact @xmath470 shall be in the least fixpoint of the program plus the input structure , iff the following condition holds :    property a. there exist extensions @xmath471 of @xmath1 , @xmath472 of @xmath459 , and @xmath473 of @xmath191 to @xmath467 , s.t .",
    "1 .   @xmath471 , @xmath472 , and @xmath473 form a partition of @xmath467 and 2 .",
    "no two adjacent vertices @xmath474 are in the same set @xmath471 , @xmath472 , or @xmath473 .    in other words ,",
    "@xmath471 , @xmath472 , and @xmath473 is a valid 3-coloring of the vertices in @xmath467 and @xmath1 , @xmath459 , and @xmath191 are the projections of @xmath471 , @xmath472 , and @xmath473 onto @xmath466 .    the main task of the program is the computation of all facts @xmath475 via a bottom - up traversal of the tree decomposition .",
    "the other predicates have the following meaning :    * @xmath476 is in the least fixpoint iff @xmath1 , @xmath459 , @xmath191 is a partition of the bag @xmath17 at node @xmath95 in the tree decomposition .",
    "* @xmath477 is in the least fixpoint iff @xmath17 contains no adjacent vertices @xmath478 .",
    "recall that the cardinality of the sets @xmath17 , @xmath1 , @xmath459 , @xmath191 occurring as arguments of @xmath479 and @xmath480 is bounded by the fixed constant @xmath481 .",
    "in fact , both the @xmath479 predicate and the @xmath480 predicate can be treated as extensional predicates by computing all facts @xmath476 and @xmath477 for each node @xmath95 in @xmath45 as part of the computation of the tree decomposition .",
    "this additional computation also fits into the linear time bound .",
    "the intuition of the rules with the -predicate in the head is now clear : at the _ leaf nodes _ , the program generates ground facts @xmath482 for all possible partitions of the bag @xmath17 at @xmath95 , such that none of the sets @xmath483 contains two adjacent vertices .",
    "the three rules for _ element introduction nodes _ distinguish the three cases if the new vertex @xmath86 is added to @xmath1 , @xmath459 , or @xmath191 , respectively . of course , by the -atom in the body of these 3 rules , the attempt to add @xmath86 to any of the sets @xmath1 , @xmath459 , or @xmath191 may fail .",
    "the three rules for _ element removal nodes _ distinguish the three cases if the removed vertex was in @xmath1 , @xmath459 , or @xmath191 , respectively .",
    "the rule for _ branch nodes _ combines -facts with identical values of @xmath484 at the child nodes @xmath110 and @xmath111 to the corresponding -fact at @xmath95 .    in summary , the 3-colorability - program has the following properties .",
    "[ theo : three - col ] the datalog program in figure  [ fig : three - col ] decides the 3-colorability problem , i.e. , the fact `` success '' is in the least fixpoint of this program plus the input @xmath300-structure @xmath311 iff @xmath311 encodes a 3-colorable graph @xmath449 .",
    "moreover , for any graph @xmath449 with treewidth @xmath58 , the computation of the @xmath300-structure @xmath311 and the evaluation of the program can be done in time @xmath485 for some function @xmath62 .    by the above considerations ,",
    "it is clear that the predicate @xmath486 indeed has the meaning described by property a. a formal proof of this fact by structural induction on @xmath45 is immediate and therefore omitted here .",
    "then the rule with head @xmath487 reads as follows : @xmath487 is in the least fixpoint , iff @xmath95 denotes the root of @xmath45 and there exist extensions @xmath471 , @xmath472 , and @xmath473 of @xmath488 to @xmath467 ( which is identical to @xmath450 in case of the root node @xmath95 ) , s.t.@xmath471 , @xmath472 , and @xmath473 is a valid 3-coloring of the vertices in @xmath489 .",
    "for the linear time data complexity , the crucial observation is that our program in figure  [ fig : three - col ] is essentially a succinct representation of a quasi - guarded monadic datalog program .",
    "for instance , in the atom @xmath475 , the sets @xmath483 are subsets of the bag of @xmath95 .",
    "hence , each combination @xmath483 could be represented by 3 subsets @xmath490 over @xmath491 referring to indices of elements in the bag of @xmath95 .",
    "recall that @xmath58 is a fixed constant .",
    "hence , @xmath475 is simply a succinct representation of constantly many monadic predicates of the form @xmath492 .",
    "the quasi - guard in each rule can thus be any atom with argument @xmath95 , e.g. , @xmath493 ( possibly extended by a disjoint union with @xmath494 ) .",
    "thus , the linear time bound follows immediately from theorem  [ theo : mondatalog - complexity ] .",
    "@xmath136    _ discussion .",
    "_ let us briefly compare the monadic program constructed in the proof of theorem  [ theo : mso - to - datalog ] with the 3-colorability program in figure  [ fig : three - col ] . actually , since we are dealing with a decision problem here , we only look at the bottom - up construction in the proof of theorem [ theo : mso - to - datalog ] , since the top - down construction is not needed for a 0-ary target formula @xmath495 . as was already mentioned in the proof of theorem  [ theo",
    ": three - col ] , the atoms @xmath475 can be thought of as a succinct representation for atoms of the form @xmath492 .",
    "now the question naturally arises where the type @xmath338 of some node @xmath95 from the proof of theorem [ theo : mso - to - datalog ] is present in the 3-colorability program .",
    "a first tentative answer is that this type essentially corresponds to the set @xmath496 is in the least fixpoint@xmath497 .",
    "however , there are two significant aspects which distinguish our 3-colorability program from merely a succinct representation of the type transitions encoded in the monadic datalog program of theorem [ theo : mso - to - datalog ] :    1 .   by property a",
    ", we are only interested in the types of those structures which  in principle  could be extended in bottom - up direction to a structure representing a satisfiable propositional formula .",
    "hence , in contrast to the construction in the proof of theorem  [ theo : mso - to - datalog ] , our 3-colorability program does clearly not keep track of all possible types that the substructure induced by some tree decomposition @xmath465 may possibly have .",
    "@xmath496 is in the least fixpoint@xmath497 does not exactly correspond to the type of @xmath95 .",
    "instead , it only describes the crucial properties of the type .",
    "thus , the 3-colorability program somehow `` aggregates '' several types from the proof of theorem [ theo : mso - to - datalog ] .",
    "these two properties ensure that the 3-colorability program is much shorter than the program in the proof of theorem  [ theo : mso - to - datalog ] and that the difference between these two programs is not just due to the succinct representation of a monadic program by a non - monadic one .",
    "the deeper reason of this improvement is that we take the target mso formula @xmath139 ( namely , the characterization of 3-colorability ) into account for the entire construction of the datalog program in figure  [ fig : three - col ] .",
    "in contrast , the rules describing the type - transitions in the proof of theorem  [ theo : mso - to - datalog ] for a bottom - up traversal of the tree decomposition are fully generic . only the rules with head predicate @xmath139 are specific to the actual target mso formula @xmath139 .      recall from section  [ sec : treewidth ]",
    "that we represent a relational schema @xmath0 as a @xmath37-structure with @xmath498 @xmath60 .",
    "moreover , recall that , in section  [ sec : work ] , we consider normalized tree decompositions with _ element removal nodes _ and _ element introduction nodes _ rather than _ element replacement nodes _ as in section  [ sec : treewidth ] . with our representation of relational schemas",
    "@xmath0 as finite structures , the domain elements are the attributes and fds in @xmath0 .",
    "hence , in total , the former element replacement nodes give rise to four kinds of nodes , namely , attribute removal nodes , fd removal nodes , attribute introduction nodes , and fd introduction nodes .",
    "moreover , we now consider the bags as a _ pair of sets _",
    "@xmath499 , where @xmath500 is a set attributes and @xmath501 is a set of fds .",
    "again , we may delete permutation nodes from the tree decomposition .",
    "finally , it will greatly simplify the presentation of our datalog program if we require that , whenever an fd @xmath502 is contained in a bag of the tree decomposition , then the attribute @xmath8 is as well . in the worst - case ,",
    "this may double the width of the resulting decomposition .",
    "suppose that a schema @xmath0 together with a tree decomposition @xmath45 of width @xmath58 is given as a @xmath300-structure with @xmath503 . in figure",
    "[ fig : primality ] , we describe a datalog program , where the input is given as an attribute @xmath504 and a @xmath300-structure , s.t .",
    "@xmath132 occurs in the bag at the root of the tree decomposition .",
    "analogously to section  [ sec : three - col ] , we are using lower case letters @xmath95 , @xmath62 , and @xmath64 ( possibly with subscripts ) as datalog variables for a single node in @xmath45 , for a single fd , or for a single attribute in @xmath1 , respectively .",
    "upper case letters are used as datalog variables denoting sets of attributes ( in the case of @xmath505 ) or sets of fds ( in the case of @xmath506 ) . in addition , @xmath507 is considered as an ordered set ( indicated by the superscript @xmath508 ) .",
    "when we write @xmath509 , we mean that @xmath64 is arbitrarily `` inserted '' into @xmath507 , leaving the order of the remaining elements unchanged .",
    "again , the cardinality of these ( ordered ) sets is restricted by the size @xmath88 of the bags , where @xmath58 is a fixed constant .",
    "in addition to @xmath462 ( disjoint union ) we are now also using the set operators @xmath510 , @xmath511 , @xmath142 , and @xmath512 .",
    "for the fixed - size ( ordered ) sets under consideration here , one could , of course , easily replace these operators by `` proper '' datalog expressions .",
    "moreover , for the input schema @xmath0 with tree decomposition @xmath45 we use the following notation : we write @xmath513 to denote the fds in the bag of @xmath95 and @xmath514 to denote the fds that occur in any bag in @xmath465 .",
    "analogously , we write @xmath515 and @xmath516 as a short - hand for the attributes occurring in the bag of @xmath95 respectively in any bag in @xmath465 .",
    "our primality - program checks the primality of @xmath132 by via the criterion used for the mso - characterization in example  [ bsp : primality - mso ] : we have to search for an attribute set @xmath155 , s.t .",
    "@xmath156 is closed w.r.t .",
    "@xmath2 ( i.e. , @xmath157 ) , @xmath158 and @xmath159 , i.e. , @xmath160 is a superkey but @xmath156 is not .    at the heart of our primality - program is the intensional predicate @xmath517 with the following intended meaning : @xmath95 denotes a node in @xmath45 .",
    "@xmath10 ( resp .",
    "@xmath507 ) is the projection of @xmath156 ( resp . of @xmath518 ) onto @xmath515 .",
    "we consider @xmath518 as ordered w.r.t .  an appropriate derivation sequence of @xmath1 from @xmath160 , i.e.",
    ", suppose that @xmath519 , s.t.@xmath520 and @xmath521 . w.l.o.g . , the @xmath522 s may be assumed to be pairwise distinct .",
    "then for any two @xmath523 , we simply set @xmath524 iff @xmath525 . by the connectedness condition on @xmath45",
    ", our datalog program ensures that the order on each subset @xmath507 of @xmath518 is consistent with the overall ordering .    the argument @xmath526 of the -predicate is used to guarantee that @xmath156 is indeed closed .",
    "informally , @xmath526 contains those fds in @xmath513 for which we have already verified ( on the bottom - up traversal of the tree decomposition ) that they do not constitute a contradiction with the closedness of @xmath156 . in other words , either @xmath527 or there exists an attribute in @xmath528 which is not in @xmath156 .",
    "the arguments @xmath529 and @xmath530 of the -predicate are used to ensure that @xmath159 indeed holds : the intended meaning of the set @xmath530 is that it contains those fds in @xmath513 which are used in the above derivation sequence .",
    "moreover , @xmath529 contains those attributes from @xmath515 for which we have already shown that they can be derived from @xmath156 plus smaller atoms in @xmath507 .",
    "more precisely , for all values @xmath531 , the ground fact @xmath517 shall be in the least fixpoint of the program plus the input structure , iff the following condition holds :    property b. there exist extensions @xmath532 of @xmath10 and @xmath533 of @xmath507 to @xmath516 and an extension @xmath534 of @xmath530 to @xmath514 , s.t .     1 .",
    "@xmath532 and @xmath533 form a partition of @xmath516 , 2 .",
    "@xmath535 , if @xmath536 , then @xmath537 .",
    "moreover , @xmath538 and @xmath539 .",
    "3 .   @xmath540 , @xmath62 is consistent with the order on @xmath533 , i.e. , @xmath540 : @xmath541 and @xmath542 : @xmath543 holds .",
    "4 .   @xmath544 ,    the main task of the program is the computation of all facts @xmath517 by means of a bottom - up traversal of the tree decomposition .",
    "the other predicates have the following meaning :    * @xmath545 is in the least fixpoint iff @xmath546 and @xmath547 , i.e. , for every @xmath548 , @xmath8 is outside @xmath10 but this will never conflict with the closedness of @xmath10 because @xmath7 contains an attribute from outside @xmath10 . *",
    "@xmath549 is in the least fixpoint iff @xmath550 we have @xmath551 and @xmath552 : @xmath543 , i.e. , the fds in @xmath530 are only used to derive greater attributes from smaller ones ( plus attributes from @xmath156 ) .",
    "* the fact @xmath553 is in the least fixpoint iff the condition @xmath554 for some @xmath555 holds .",
    "the @xmath556-predicate is only used in the body of the rule for branch nodes .",
    "its purpose is to avoid that an attribute in @xmath518 is derived via two different fds in the two subtrees at the child nodes of the branch node . *",
    "the 0-ary predicate @xmath487 indicates if the fixed attribute @xmath132 is prime in the schema encoded by the input structure .",
    "the primality - program has the following properties .",
    "[ lemma : solve - correct ] the -predicate has the intended meaning described above , i.e. , for all values @xmath95 , @xmath10 , @xmath526 , @xmath507 , @xmath529 , @xmath530 , the ground fact @xmath517 is in the least fixpoint of the primality - program plus the input structure , iff property b holds .",
    "the lemma can be shown by structural induction on @xmath45 .",
    "we restrict ourselves here to outlining the ideas underlying the various rules of the primality - program .",
    "the induction itself is then obvious and therefore omitted .",
    "\\(1 ) _ leaf nodes . _",
    "the rule for a leaf node @xmath95 realizes two `` guesses '' so to speak : ( i ) a partition of @xmath557 into @xmath10 and @xmath507 together with an ordering on @xmath507 and ( ii ) the subset @xmath558 of fds which are used in the derivation sequence of @xmath518 from @xmath160 .",
    "the remaining variables are thus fully determined : @xmath526 is determined via the -predicate , while @xmath529 is determined via the equality @xmath559 .",
    "finally the body of the rule contains the checks @xmath560 and @xmath561 to make sure that ( at least at the leaf node @xmath95 ) the `` guesses '' are allowed .",
    "\\(2 ) _ attribute introduction node . _",
    "the two rules are used to distinguish 2 cases whether the new attribute @xmath64 is added to @xmath10 or to @xmath507 . if @xmath64 is added to @xmath10 then all arguments of the -fact at the child node @xmath110 of @xmath95 remain unchanged at @xmath95 .",
    "in contrast , if @xmath64 is inserted into @xmath507 then the following actions are required :    the atom @xmath562 makes sure that the rules in @xmath530 are consistent with the ordering of @xmath507 , i.e. , it must not happen that the new attribute @xmath64 occurs in @xmath7 for some @xmath563 , s.t.@xmath564 holds .    the new attribute @xmath64 outside @xmath10 may possibly allow us to verify for some additional fds that they do not contradict the closedness of @xmath156 .",
    "the atom @xmath565 determines the set @xmath566 which contains all fds with @xmath567 but with some attribute from @xmath507 ( in particular , the new attribute @xmath64 ) in @xmath7 .",
    "recall that we are requiring that , whenever an fd @xmath502 is contained in a bag of the tree decomposition , then the attribute @xmath8 is as well .",
    "hence , since the attribute @xmath64 has just been introduced on our bottom - up traversal of the tree decomposition , we can be sure that @xmath64 does not occur on the right - hand side of any fd in the bag of @xmath95 .",
    "thus , @xmath529 is not affected by the transition from @xmath110 to @xmath95 .",
    "\\(3 ) _ fd introduction node . _",
    "the three rules distinguish , in total , 3 cases : first , does @xmath568 or @xmath551 hold ?",
    "( recall that we assume that every bag containing some fd also contains the right - hand side of this fd . )",
    "the latter case is then further divided into the subcases if @xmath62 is used for the derivation of @xmath518 or not .",
    "the first rule deals with the case @xmath568",
    ". then all arguments of the -fact at the child node @xmath110 of @xmath95 remain unchanged at @xmath95 .",
    "the second rule addresses the case that @xmath551 and @xmath62 is used for the derivation of @xmath518 .",
    "then the attribute @xmath8 is added to @xmath529 .",
    "the disjoint union makes sure that this attribute has not yet been derived by another rule with the same right - hand side .",
    "the atom @xmath562 is used to check the consistency of @xmath62 with the ordering of @xmath507 .",
    "the atom @xmath565 is used to check if @xmath62 may be added to @xmath526 , i.e. , if some attribute in @xmath7 is in @xmath507 .",
    "the third rule refers to the case that @xmath551 and @xmath62 is _ not _ used for the derivation of @xmath518 .",
    "again , the atom @xmath565 is used to check if @xmath62 may be added to @xmath526 .",
    "\\(4 ) _ attribute removal node . _",
    "the two rules are used to distinguish 2 cases whether the attribute @xmath64 was in @xmath10 or in @xmath507 .",
    "if @xmath64 was in @xmath10 then all arguments of the -fact at the child node @xmath110 of @xmath95 remain unchanged at @xmath95 .",
    "in contrast , if @xmath64 was in @xmath507 then we have to check ( by pattern matching with the fact @xmath569 ) that a rule @xmath62 for deriving @xmath64 has already been found .",
    "recall that , on our bottom - up traversal of @xmath45 , when we first encounter an attribute @xmath64 , it is either added to @xmath10 or @xmath507 . if @xmath64 is added to @xmath507 then we eventually have to determine the fd by which @xmath64 is derived . hence , initially , @xmath64 is in @xmath507 but not in @xmath529 .",
    "however , when @xmath64 is finally removed from the bag then its derivation must have been verified .",
    "the arguments @xmath10 , @xmath526 , and @xmath530 are of course not affected by this attribute removal .",
    "\\(5 ) _ fd removal node . _ similarly to the fd introduction node , we distinguish , in total , 3 cases .",
    "if @xmath568 then all arguments of the -fact at the child node @xmath110 of @xmath95 remain unchanged at @xmath95 . if @xmath551 then we further distinguish the subcases if @xmath62 is used for the derivation of @xmath518 or not .",
    "the second and third rule refer two these two subcases .",
    "the action carried out by these two rules is the same , namely it has to be checked ( by pattern matching with the fact @xmath570 ) that @xmath62 does not constitute a contradiction with the closedness of @xmath156 . in other words , since @xmath551 , we must have encountered ( on our bottom - up traversal of @xmath45 ) an attribute in @xmath571 .",
    "\\(6 ) _ branch node .",
    "_ recall that a branch node @xmath95 and its two child nodes @xmath110 and @xmath111 have identical bags by our notion of normalized tree decompositions . the argument of the -fact at @xmath95 is then determined from the arguments at @xmath572 and @xmath111 as follows : the arguments @xmath10 and @xmath507 must have the same value at all three nodes @xmath95 , @xmath110 , and @xmath111 .",
    "likewise , @xmath530 ( containing the fds from the bags at these nodes which are used in the derivation of @xmath518 ) must be identical .",
    "in contrast , @xmath526 and @xmath529 are obtained as the union of the corresponding arguments in the -facts at the child nodes @xmath110 and @xmath111 , i.e. , it suffices to verify at one of the child nodes @xmath110 or @xmath111 that some fd does not contradict the closedness of @xmath10 and that some attribute in @xmath507 is derived by some fd .",
    "recall that we define an order on the attributes in @xmath518 by means of some derivation sequence of @xmath518 from @xmath160 .",
    "hence , we we have to make sure that every attribute in @xmath518 is derived only once in this derivation sequence .",
    "in other words , for every @xmath573 , we use exactly one fd @xmath62 with @xmath574 in our derivation sequence .",
    "the atom @xmath553 in the rule body ensures that no attribute in @xmath518 is derived via two different fds in the two subtrees at the child nodes of the branch node .",
    "[ theo : primtest ] the datalog program in figure  [ fig : primality ] decides the primality problem for a fixed attribute @xmath132 , i.e. , the fact `` success '' is in the least fixpoint of this program plus the input @xmath300-structure @xmath311 iff @xmath311 encodes a relational schema @xmath0 , s.t .",
    "@xmath132 is part of a key .",
    "moreover , for any schema @xmath0 with treewidth @xmath58 , the computation of the @xmath300-structure @xmath311 and the evaluation of the program can be done in time @xmath575 for some function @xmath62 .    by lemma [ lemma : solve - correct ]",
    ", the predicate @xmath486 indeed has the meaning according to property b. thus , the rule with head @xmath487 reads as follows : @xmath487 is in the least fixpoint , iff @xmath95 denotes the root of @xmath45 , @xmath132 is an attribute in the bag at @xmath95 , and @xmath10 is the projection of the desired attribute set @xmath156 onto @xmath515 , i.e. , ( 1 ) @xmath156 is closed ( this is ensured by the condition that @xmath576 ) , ( 2 ) @xmath577 and , finally , ( 3 ) all attributes in @xmath578 are indeed determined by @xmath160 ( this is ensured by the condition @xmath579 ) .    the linear time data complexity is due to the same argument as in the proof of theorem [ theo : three - col ] : our program in figure  [ fig : primality ] is essentially a succinct representation of a quasi - guarded monadic datalog program .",
    "for instance , in the atom @xmath517 , the ( ordered ) sets @xmath10 , @xmath526 , @xmath507 , @xmath529 , and @xmath530 are subsets of the bag of @xmath95 .",
    "hence , each combination @xmath10 , @xmath526 , @xmath507 , @xmath529 , @xmath530 could be represented by 5 subsets resp .",
    "tuples @xmath580 over @xmath491 referring to indices of elements in the bag of @xmath95 .",
    "recall that @xmath58 is a fixed constant .",
    "hence , @xmath581 @xmath582 , is simply a succinct representation of constantly many monadic predicates of the form @xmath583 .",
    "the quasi - guard in each rule can thus be any atom with argument @xmath95 , e.g. , @xmath584 ( possibly extended by a disjoint union with @xmath585 or @xmath586 , respectively ) .",
    "thus , the linear time bound follows immediately from theorem  [ theo : mondatalog - complexity ] .",
    "@xmath136      in order to extend the primality algorithm from the previous section to a monadic predicate selecting all prime attributes in a schema , a naive first attempt might look as follows : one can consider the tree decomposition @xmath45 as rooted at various nodes , s.t .",
    "each @xmath504 is contained in the bag of one such root node .",
    "then , for each @xmath132 and corresponding tree decomposition @xmath45 , we run the algorithm from figure  [ fig : primality ] .",
    "obviously , this method has _",
    "quadratic _ time complexity w.r.t .",
    "the data size .",
    "however , in this section , we describe a _ linear _ time algorithm .",
    "the idea of this algorithm is to implement a top - down traversal of the tree decomposition in addition to the bottom - up traversal realized by the program in figure  [ fig : primality ] . for this purpose ,",
    "we modify our notion of _ normalized _ tree decompositions in the following way : first , any tree decomposition can of course be transformed in such a way that every attribute @xmath504 occurs in at least one leaf node of @xmath45 . moreover , for every branch node @xmath95 in the tree decomposition , we insert a new node @xmath587 as new parent of @xmath95 , s.t .",
    "@xmath587 and @xmath95 have identical bags .",
    "hence , together with the two child nodes of @xmath95 , each branch node is `` surrounded '' by three neighboring nodes with identical bags .",
    "it is thus guaranteed that a branch node always has two child nodes with identical bags , no matter where @xmath45 is rooted . moreover",
    ", this insertion of a new node also implies that the root node of @xmath45 is not a branch node .",
    "we propose the following algorithm for computing a monadic predicate @xmath588 , which selects precisely the prime attributes in @xmath0 .",
    "in addition to the predicate @xmath486 , whose meaning was described by property b in section  [ sec : primality ] , we also compute a predicate , whose meaning is described by replacing every occurrence of @xmath465 in property b by @xmath204 .",
    "as the notation suggests , the computation of can be done via a top - down traversal of @xmath45 .",
    "note that ( @xmath589 for a leaf node @xmath95 of @xmath200 is exactly the same as if we computed @xmath590 for the tree rooted at @xmath95 .",
    "hence , we can define the predicate @xmath588 as follows .    by the intended meaning of and by the properties of the primality algorithm in section [ sec : primality ]",
    ", we immediately get the following result .",
    "[ theo : relevance ] the monadic predicate @xmath588 as defined above selects precisely the prime attributes .",
    "moreover , it can be computed in linear time w.r.t .",
    "the size of the input structure .",
    "to test our new datalog programs in terms of their scalability with a large number of attributes and rules , we have implemented the primality program from section  [ sec : primality ] in c++ .",
    "the experiments were conducted on linux kernel 2.6.17 with an 1.60ghz intel pentium(m ) processor and 512 mb of memory .",
    "we measured the processing time of the primality program on different input parameters such as the number of attributes and the number of fds .",
    "the treewidth in all the test cases was 3 .",
    "test data generation . due to the lack of available test data",
    ", we generated a balanced normalized tree decomposition .",
    "test data sets with increasing input parameters are then generated by expanding the tree in a depth - first style .",
    "we have ensured that all different kinds of nodes occur evenly in the tree decomposition .    .processing time in ms for primality .",
    "[ cols=\"^,>,>,>,>,>\",options=\"header \" , ]     experimental results .",
    "the outcome of the tests is shown in table [ tab : experiments ] , where tw stands for the treewidth ; # att , # fd , and # tn stand for the number of attributes , fds , and tree nodes , respectively .",
    "the processing time ( in ms ) obtained with our c++ implementation following the monadic datalog program in section  [ sec : primality ] are displayed in the column labelled `` md '' . the measurements nicely reflect an essentially linear increase of the processing time with the size of the input .",
    "moreover , there is obviously no big `` hidden '' constant which would render the linearity useless .    in @xcite",
    ", we proved the fpt of several non - monotonic reasoning problems via courcelle s theorem .",
    "moreover , we also carried out some experiments with a prototype implementation using mona ( see @xcite ) for the mso - model checking .",
    "we have now extended these experiments with mona to the primality problem .",
    "the time measurements of these experiments are shown in the last column of table  [ tab : experiments ] . due to problems discussed in @xcite , mona",
    "does not ensure linear data complexity .",
    "hence , all testes below line 3 of the table failed with `` out - of - memory '' errors .",
    "moreover , also in cases where the exponential data complexity does not yet `` hurt '' , our datalog approach outperforms the mso - to - fta approach by a factor of @xmath591 or even more .    optimizations . in our implementation",
    ", we have realized several optimizations , which are highlighted below . _",
    "( 1 ) succinct representation by non - monadic datalog . _",
    "as was mentioned in the proofs of the theorems  [ theo : three - col ] and [ theo : primtest ] , our datalog programs can be regarded as succinct representations of big monadic datalog programs .",
    "if all possible ground instances of our datalog rules had to be materialized , then we would end up with a ground program of the same size as with the equivalent monadic program .",
    "however , it turns out that the vast majority of possible instantiations is never computed since they are not `` reachable '' along the bottom - up computation .",
    "_ ( 2 ) general optimizations and lazy grounding . _ in principle , our implementation is based on the general idea of grounding followed by an evaluation of the ground program .",
    "this corresponds to the general technique to ensure linear time data complexity , cf .  theorem  [ theo : mondatalog - complexity ] .",
    "a further improvement is achieved by the natural idea of generating only those ground instances of rules which actually produce new facts .    _",
    "( 3 ) problem - specific optimizations of the non - monadic datalog programs .",
    "_ in the discussion below theorem  [ theo : three - col ] , we have already mentioned that the datalog programs presented in section  [ sec : work ] incorporate several problem - specific optimizations .",
    "the underlying idea of these optimizations is that many transitions which are kept track of by the generic construction in the proof of theorem [ theo : mso - to - datalog ] ( and , likewise , in the mso - to - fta approach ) will not lead to a solution anyway .",
    "hence , they are omitted in our datalog programs right from the beginning .    _",
    "( 4 ) language extensions . _ as was mentioned in section  [ sec : work ] , we are using language constructs ( in particular , for handling sets of attributes and fds ) which are not part of the datalog language . in principle",
    ", they could be realized in datalog . nevertheless , we preferred an efficient implementation of these constructs directly on c++ level .",
    "further language extensions are conceivable and easy to realize .    _",
    "( 5 ) further improvements .",
    "_ we are planning to implement further improvements .",
    "for instance , we are currently applying a strict bottom - up intuition as we compute new facts @xmath592 .",
    "however , some top - down guidance in the style of magic sets so as not to compute all possible such facts at each level would be desirable .",
    "note that ultimately , at the root , only facts fulfilling certain conditions ( like @xmath593 , etc . )",
    "are needed in case that an attribute @xmath132 is indeed prime .",
    "in this work , we have proposed a new approach based on monadic datalog to tackle a big class of fixed - parameter tractable problems .",
    "theoretically , we have shown that every mso - definable unary query over finite structures with bounded treewidth is also definable in monadic datalog .",
    "in fact , the resulting program even lies in a particularly efficient fragment of monadic datalog .",
    "practically , we have put this approach to work by applying it to the 3-colorability problem and the primality problem with bounded treewidth .",
    "the experimental results thus obtained look very promising .",
    "they underline that datalog with its potential for optimizations and its flexibility is clearly worth considering for this class of problems .",
    "recall that the primality problem is closely related to an important problem in the area of artificial intelligence , namely the relevance problem of propositional abduction ( i.e. , given a system description in form of a propositional clausal theory and observed symptoms , one has to decide if some hypothesis is part of a possible explanation of the symptoms ) . indeed , if the clausal theory is restricted to definite horn clauses and if we are only interested in minimal explanations , then the relevance problem is basically the same as the problem of deciding primality in a subschema @xmath594 .",
    "extending our @xmath588 program ( and , in particular , the @xmath595-predicate ) from section  [ sec : work ] so as to test primality in a subschema is rather straightforward . on the other hand ,",
    "extending such a program to abduction with arbitrary clausal theories ( which is on the second level of the polynomial hierarchy , see @xcite ) is much more involved .",
    "a monadic datalog program solving the relevance problem also in this general case was presented in @xcite .    our datalog program in section [ sec : work ]",
    "was obtained by an ad hoc construction rather than via a generic transformation from mso .",
    "nevertheless , we are convinced that the idea of a bottom - up propagation of certain conditions is quite generally applicable .",
    "we are therefore planning to tackle many more problems , whose fpt was established via courcelle s theorem , with this new approach .",
    "we have already incorporated some optimizations into our implementation .",
    "further improvements are on the way ( in particular , further heuristics to prune irrelevant parts of the search space ) .",
    "m.  frick and m.  grohe .",
    "the complexity of first - order and monadic second - order logic revisited . in _ proceedings of the 17th annual ieee symposium on logic in computer science ( lics 2002 ) _ , pages 215224 .",
    "ieee computer society , 2002 .",
    "g.  gottlob , r.  pichler , and f.  wei .",
    "tractable database design through bounded treewidth . in _ proceedings of the twenty - fifth acm sigact - sigmod - sigart symposium on principles of database systems ( pods 2006 ) _ , pages 124133 .",
    "acm , 2006 .",
    "g.  gottlob , r.  pichler , and f.  wei .",
    "monadic datalog over finite structures with bounded treewidth . in _ proceedings of the twenty - sixth acm sigact - sigmod - sigart symposium on principles of database systems ( pods 2007 ) _ ,",
    "pages 165174 .",
    "acm , 2007 ."
  ],
  "abstract_text": [
    "<S> bounded treewidth and monadic second order ( mso ) logic have proved to be key concepts in establishing fixed - parameter tractability results . indeed , by courcelle s theorem we know : any property of finite structures , which is expressible by an mso sentence , can be decided in linear time ( data complexity ) if the structures have bounded treewidth . in principle </S>",
    "<S> , courcelle s theorem can be applied directly to construct concrete algorithms by transforming the mso evaluation problem into a tree language recognition problem . </S>",
    "<S> the latter can then be solved via a finite tree automaton ( fta ) . however </S>",
    "<S> , this approach has turned out to be problematical , since even relatively simple mso formulae may lead to a `` state explosion '' of the fta .    in this work </S>",
    "<S> we propose monadic datalog ( i.e. , datalog where all intentional predicate symbols are unary ) as an alternative method to tackle this class of fixed - parameter tractable problems . </S>",
    "<S> we show that if some property of finite structures is expressible in mso then this property can also be expressed by means of a monadic datalog program over the structure plus the tree decomposition . </S>",
    "<S> moreover , we show that the resulting fragment of datalog can be evaluated in linear time ( both w.r.t .   the program size and w.r.t .  </S>",
    "<S> the data size ) . this new approach is put to work by devising new algorithms for the 3-colorability problem of graphs and for the primality problem of relational schemas ( i.e. , </S>",
    "<S> testing if some attribute in a relational schema is part of a key ) . </S>",
    "<S> we also report on experimental results with a prototype implementation . </S>"
  ]
}