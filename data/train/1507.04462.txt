{
  "article_text": [
    "a vast growth of small and portable devices has culminated into the problem of bandwidth scarcity .",
    "hence , it is becoming difficult to provide seamless connectivity while executing various applications , _",
    "e_._g_. , email , web surfing , gaming , and video conferencing ( see exhibit 10 in  @xcite ) .",
    "it is also noted that currently allocated spectrums have their significant portions underutilized  @xcite .",
    "the cognitive radio networks ( _ _ crn__s )  @xcite are a smart solution with a complex network structure to enhance the spectrum utilization .",
    "the termination detection  @xcite is a fundamental and non - trivial problem in distributed systems because the processors do not have the complete knowledge of all the other processors in the network , and there is no global clock in the distributed computing environment .",
    "a solution to the termination detection problem informs termination of the task being executed in the network .",
    "a cognitive radio network ( see  @xcite ) is a collection of heterogeneous cognitive radio nodes ( or processors ) , called secondary users .",
    "the cognitive radio nodes ( crs ) have sufficient computing power and power backup to operate on multiple heterogeneous channels ( or frequency bands ) in the absence of the licensed user(s ) , termed as primary user(s ) , of the respective bands .",
    "the cognitive radio nodes have the _ leira _ ( learning , efficiency , intelligence , reliability , and adaptively ) capability to scan and operate on different channels .    a channel that is not currently occupied by a primary user",
    "is called an _",
    "available channel_. any two nodes that are in the transmission range of each other and tuned to a common available channel during an identical time interval , are called _",
    "neighboring nodes_. the appearance of a primary user ( hereafter , the primary users will be known as pus ) on an available channel is a reason for crs to switch the channel and to tune to another available channel , because the crs are not allowed to interrupt the primary users in any case .",
    "the modern networking benchmark , _ crn _ , presents many unique challenges in the field of communication as well as computing , such as cognitive capability , reliability , and efficiency .",
    "several challenges of _ _ crn__s are presented in  @xcite .",
    "interested readers may refer to  @xcite for more details on cognitive radio networks .    in this paper , unless otherwise indicated , the words `` cognitive radio node , '' `` cognitive radio , '' `` node , '' and `` processor '' have the same meaning , and similarly , the words `` cognitive radio network , '' `` network , '' and `` system '' have been treated as synonyms .      nowadays , a large number of distributed applications  _ e_._g_. , mutual exclusion , leader election , checkpointing , global state detection  @xcite  are executed on portable devices . in general , an application that executes on processors is known as a _ normal computation _ or an _ underlying computation_. a termination detection ( td ) protocol  @xcite is used to announce termination of the normal computation .",
    "the termination declaration of a normal computation , when it has indeed terminated  in a group of mobile devices that are geographically distributed and tuned on different channels  is an interesting challenge in cognitive radio networks .",
    "hereafter , we use the word `` computation '' that refers to the `` normal computation . ''",
    "a node may be in _ active _ or _ passive _ state during a computation . the nodes in the active state are called _ active nodes _ , and the nodes in the passive state are called _ passive nodes_. the active nodes execute an assigned computation , and usually , after completion of the computation , they become passive .",
    "a passive node can become active on reception of a message from an active node .",
    "hence , it is clear that only active nodes can send messages ; however , both the active and passive nodes can receive messages at any time .",
    "initially , all the nodes are passive in the network .",
    "since only active nodes can send messages , we assume that there exist a passive node that becomes active on reception of a message from outside world , and subsequently it initiates the computation .",
    "a computation is said to be terminated if and only if all the nodes are passive and there is no message in - transit .",
    "a brief summary about td protocols can be found in chapter 7 of  @xcite and chapter 9 of  @xcite .",
    "any termination detection protocol can be initiated in two ways , as follows :    * _ delayed initiation . _",
    "the td protocol is triggered by any node , @xmath0 , that has been assigned a computation , and the same node @xmath0 is responsible for the announcement of termination ; such an initiation is known as delayed initiation  @xcite . here",
    ", it is not mandatory that the node @xmath0 was also the initiator of the computation ; refer to figure  [ fig : two_way_of_initation_first ] , where node 1 initiates the computation and node 3 initiates the termination detection protocol . * _ concurrent initiation .",
    "_ in the concurrent initiation , the td protocol is overlaid on a computation and executes concurrently . here",
    ", the initiator of the computation is also responsible for the announcement of termination ; refer to figure  [ fig : two_way_of_initation_second ] , where the lower part represents the execution of the computation and the upper part represents the execution of termination detection protocol that is being executed concurrently with the computation ; and node 1 is the initiator of both , the computation and the termination detection protocol .",
    "any termination detection protocol should satisfy the following properties :    * _ no false termination detection _ ( _ safety _ ) .",
    "the termination of a computation is declared only when the computation has indeed terminated ( and only a single designated node can announce termination ) . * _ eventual termination detection _",
    "( _ liveness _ ) .",
    "a single ( designated ) node announces termination within a finite amount of time .    the termination detection in _ crn _ is more challenging as compared to the conventional wireless networks because of the following reasons :     [ fig : two_way_of_initation_first ]     [ fig : two_way_of_initation_second ]    [ fig : two_way_of_initation ]    * _ network structure and communication links .",
    "_ the _ crn _ is a network of time and space varying channels .",
    "any two neighboring nodes , which must be tuned to an identical available channel , can communicate directly ( using a communication link ) .",
    "the appearance of a pu on a channel forces the neighboring crs to vacate that channel and to tune to another identical available channel .",
    "however , finding another identical alternative available channel , for neighboring crs , is not an easy task due to reasons like topological dynamics and varying capabilities of the nodes  @xcite .",
    "hence , the communication link endurance during execution of any protocol is hard to guarantee . *",
    "_ reaction to a communication link break .",
    "_ in classical wireless networks , the nodes operate on a pre - decided channel that provides them communication links .",
    "the communication links may break due to node mobility or node failure ; hence , a new communication link detection takes place in a highly reactive manner without considering parameters like endurance of the link . on the other hand , in _ crn _",
    ", the communication links may also break due to the appearance of a pu leading to _ spectrum mobility _ that emphasizes on several factors before creating the new communication links  @xcite . * _ sufficient resources . _",
    "the computing nodes in wireless domain suffer from limited resources like bandwidth , memory , and battery power .",
    "thus , several protocols focus on the reduction of the number of messages exchanged to minimize the need of bandwidth , memory , and battery power . however , _",
    "_ crn__s have sufficient resources , especially temporarily unused spectrums ( known as _ spectrum holes _  @xcite ) and computing power .",
    "consequently , the focus of research has been shifted to other challenges related to the execution of various applications . *",
    "_ no definitive logical structure . _",
    "most of the computing protocol use quasi - stable logical structures , _",
    "e_._g_. , tree , ring , to leverage the design difficulties .",
    "the _ _ crn__s restrict a direct engagement of such logical structures due to time and space varying channels .",
    "in addition , unlike other ad hoc networks , the crs show very loose synchronization , poor tolerance to the heterogeneity of mobile devices as well as channels , and an extra cost for searching a new channel ( on the appearance of primary users ) .",
    "the presence of these challenges in cognitive radio networks make the design of computing and communication protocols harder .",
    "the paper presents a concurrent initiation ( see figure  [ fig : two_way_of_initation_second ] ) based termination detection protocol for cognitive radio networks , called _",
    "t - cran _ , henceforth .",
    "moreover , our protocol can also be implemented in other dynamic networks , _",
    "e_._g_. , cellular networks , mobile ad hoc networks ( manets ) , vehicular ad hoc networks ( vanets ) . in this paper",
    ", we provide :    1 .   a credit distribution and aggregation based termination detection protocol for _ crn _ , in section  [ section : the t - cran protocol ] , that declares termination of computations despite the presence of pus .",
    "our protocol recognizes the cognitive radio nodes that lose their single available channel due to the appearance of pus and are unable to find other available channel .",
    "2 .   a new logical structure , called _ virtual tree - like structure _ ( figure  [ fig : the virtual tree - like structure . ] ) , where the root node can be passive when it completes its computation , unlike conventional ( logical ) tree structures , where it is mandatory for the root node to stay in active state till the end of computation ; in section  [ section : the t - cran protocol ] .",
    "the _ t - cran _ protocol as guarded - actions , in section  [ section : t - cran in guard - action paradigm ] .",
    "section  [ section : the working of the t - cran ] explains the complete working of the proposed protocol .",
    "the analysis of message and time complexities of the proposed protocol , in appendix  [ section : complexity analysis ] .",
    "the correctness proofs of the proposed protocol are given in appendix  [ section : correctness_proof ] .",
    "the termination detection ( td ) protocol has been studied extensively in static distributed systems  @xcite .",
    "a detailed classification of td protocols is given in  @xcite .",
    "however , none of the existing td protocols for static networks can be implemented straight forwardly in dynamic networks due to frequent topology changes in dynamic networks .",
    "although , some td protocols  @xcite exist for sensor networks and mobile ad hoc networks , they can also not be implemented in _",
    "_ crn__s due to unique challenges of cognitive radio networks , as mentioned in section  [ subsec : termination detection in the cognitive radio networks ] .",
    "a novel algorithm for td using credit distribution and aggregation was proposed by mattern  @xcite and huang  @xcite .",
    "a similar td protocol for faulty distributed systems was proposed by tseng  @xcite . however , these protocols failed to work in dynamic networks .",
    "a td protocol for mobile cellular networks  @xcite based on credit distribution and aggregation is proposed that assumes the existence of the mobile switching center ( mss ) , which provides a centralize support to the mobile nodes .",
    "johnson and mittal  @xcite have tried to reduce the waiting time for termination declaration in dynamic networks .",
    "however , they consider the existence of an initiator node until termination declaration .",
    "the protocols proposed for dynamic networks  @xcite have three major limitations : ( _ i _ ) they assume the existence of an initiator node until termination declaration ; however , the mandatory existence of the initiator node increases the waiting time for the node that has completed its computation earlier than other nodes in the network . also , the existence of an initiator node until termination declaration is not easy to guarantee in _ _",
    "crn__s , ( _ ii _ ) they work on a single pre - decided channel , whereas , in _ crn _ , computations and nodes work on multi - channels , and ( _ iii _ ) they consider only node mobility ; they do not consider the presence of some special users ( like primary users ) that also prevent the nodes to work .    in _ crn _ , mittal et al .",
    "@xcite presents a neighbor discovery protocol with td ; however , they consider only termination of the particular neighbor discovery scheme . the lightweight termination detection of mittal et al .",
    "@xcite is not related to our termination detection scheme .",
    "note that in  @xcite , the term `` lightweight '' has been used to highlight the fact that the number of control messages used in their protocol is minimal .",
    "this section outlines the preliminary assumptions about the environment , various types of messages ( table  [ tab : messages ] ) , and data structures ( table  [ table : datastructure ] ) .",
    "all the notations used in our protocol are given in table  [ table : notations ] .",
    "cognitive radio nodes . : :    we consider a cognitive radio network of @xmath1 cognitive    radio nodes    ( @xmath2 ) ,    where each node has a unique identity",
    ". however , a group of    @xmath3 crs executes a single computation , where    @xmath4 , in finite time .",
    "the nodes are heterogeneous in    terms of their computing capabilities , and they are allowed to move    during protocol execution .    +    each cr is aware of _ global channel set _ , _ local channel set _ , to be    defined soon , and also the total number of nodes , @xmath1 , in    the network .",
    "each node has a _ scan transceiver _ ( a transceiver is a    transmitter - receiver pair ) that is responsible for scanning multiple    heterogeneous channels .",
    "such a scanning is beneficial for fast channel    switching .",
    "however , a transceiver can not transmit and receive    simultaneously .",
    "communication channels . : :    we divide communication channels into two sets : ( _ i _ ) _ global channel    set _ ( @xmath5 ) : a set of all the , @xmath6 ,    channels in the network , where @xmath7 ; ( _ ii _ ) _ local    channel set _ ( @xmath8 ) : a set of , @xmath9 ,    available channels at a node , @xmath10 , where    @xmath11 and @xmath12 . however , the    appearance of pu(s ) on all @xmath6 channels results in the    value of the local channel set to be zero , at each node . on the    appearance of a pu",
    ", a cr is assumed to tune to another available    channel , from its @xmath8 , without interrupting the    ongoing computation  @xcite , similar to the handoff in mobile cellular    networks .",
    "+    a node , @xmath10 , that does not possess any    available channel in its @xmath13 ( _ i_._e_. ,    @xmath14 ) due to the appearance of pu(s ) , is called an    _ affected node_. an affected node is unable to send and receive    messages . on the other hand , a node , @xmath15 , that    has at least one available channel in its @xmath16    ( _ i_._e_. , @xmath17 )",
    "is called a _ non - affected node_.    the communication channels are non - fifo ( first - in - first - out ) and    unreliable .",
    "however , the sent messages must be received at the    receiver nodes without omissions , duplications , and in the same order    as they were sent  @xcite , if the receiver is not an affected or a    failed node ( see failure model for details ) .",
    "network structure .",
    ": :    we consider an asynchronous multi - hop cognitive radio network of    @xmath1 independent nodes .",
    "we represent the network by a    _ communication graph _ ,    @xmath18 $ ] . in the    communication graph , @xmath19 ,",
    "@xmath20 represents a set of vertices ( or processors    in the network ) , @xmath21 represents a set of edges    where an edge between a pair of neighboring nodes shows a    bidirectional , direct , and non - fifo wireless communication link , and    @xmath8 represents the local channel set of each    cr .",
    "+    further , we define an _ interaction graph _ of size    @xmath4 as : @xmath22 $ ] . in the    interaction graph , @xmath23 ,    @xmath24 represents a set of crs that are    currently executing an identical computation and    @xmath25 represents a set of edges where    each edge connects any two neighboring nodes ,",
    "@xmath26 , if they are    executing an identical computation .",
    "note that we assume different    interaction graphs for different computations . failure model .",
    ": :    we assume that a cognitive radio node may fail in three different    ways , as follows :    +    1 .",
    "due to the appearance of a pu and the node has only a single    channel in its @xmath8 , then the node is unable to    send and receive messages , and such a node is called an affected node .    2 .   due to the swift movement of the node that may result in frequent    topology change and transient non - interaction of the highly mobile    node with other nodes in the network .",
    "we call such nodes the _ failed    nodes_.    3 .   crash , _",
    "i_._e_. , when a node does not possess enough resources ,    like battery and computing power , it results in permanent failure of    the node , and such a node is called a _ crashed node_. when a crashed    node recovers by users intervention , it does not possess the    knowledge of updated data structures .",
    "+    in this protocol , we focus on the impact of pus on the nodes , and    after that the recovery of such nodes when pus disappear .",
    "we do not    consider any specific approach for recovery of failed nodes .",
    "the    approach that works in manet to handle failed nodes is also applicable    in _ crn_. in other words , we consider the _ failure - recovery    model _  @xcite .",
    "whenever a node recovers , its state may be active or    passive .",
    "it is possible that the failures occur frequently and ,    thereafter , the nodes recover soon .",
    "such frequent failures and    recoveries are not useful for any practical application ; hence , we do    not focus on these issues in our protocol .",
    "in addition , we assume that    the affected and crashed nodes are detected by at least one of the    nodes , whose state is active .",
    "we also assume that the nodes do not    exhibit byzantine behavior . storage media .",
    ": :    the termination can not be detected as the decision variable itself can    be corrupted by transient failures leading to a false detection ;    hence , we store all the data structures in the non - volatile storage    ( _ i_._e_. , stable storage ) . however , a consistent copy of the data is    always available in the volatile memory . in the beginning",
    ", all the    data structures are initialized",
    ".    0.85    .notations . [ cols=\"<,<,<,<\",options=\"header \" , ]      there are three types of nodes in the network : ( _ i _ ) nodes whose @xmath27=\\emptyset$ ] , ( _ ii _ ) @xmath28 , and ( _ iii _ ) node whose @xmath27\\neq \\emptyset$ ] or @xmath29\\neq \\emptyset$ ] and they are not the chief executive node",
    ". the nodes with @xmath27 = \\emptyset$ ] may leave the network when they finish their computation by sending @xmath30 messages to at most @xmath31 nodes .",
    "similarly , @xmath28 may also leave by sending @xmath30 or @xmath32 messages to at most @xmath31 nodes . also , the node other than @xmath28 that has @xmath27\\neq \\emptyset$ ] or @xmath29\\neq \\emptyset$ ] exchanges at most @xmath31 messages before leaving the network .",
    "we assume that all the messages are delivered in a unit time .",
    "hence , in the failure - free network , all the nodes of the network take @xmath33 time to leave the network that results in global strong termination declaration . however , the presence of pus increases termination latency . in such scenarios , the declaration of global weak termination would be delayed according to the value of timeout .",
    "we first provide the system invariants ; afterward , we prove the safety and liveness properties of the _ t - cran _ protocol .",
    "we also prove an impossibility result that the appearance of a primary user on a single channel may defy termination forever .",
    "[ inv : active_passive_rule ] let , @xmath34 represents the state of @xmath10 , which may be active or passive . for @xmath10 , @xmath35 indicates passive state of @xmath10 and vice versa .",
    "also , @xmath36 indicates active state of @xmath10 and vice versa .",
    "@xmath37    [ inv : credit_never_exceeds_c ] in _ crn _ , the sum of credits at the nodes and credits associated with in - transit messages must be @xmath38 . @xmath39 + in_j [ ] + \\mathit{send}_i(m ,",
    "j ) + \\mathit{send}_j(m),i ) = c\\ ] ] where , @xmath40 can be a _ computation message _ or an _ i am passive with credit message_.    [ inv : strong_termination ] the global strong termination can be declared , in case , there is no pus in _",
    "crn_. thus , only a single @xmath10 contains credit value @xmath38 if the node is the chief executive node and there is no in - transit message , @xmath40 , in the global channel set , @xmath5 .",
    "@xmath41    [ inv : weak_termination ] for the global weak termination , the total credit value @xmath38 is known to @xmath28 .",
    "however , @xmath38 is distributed among @xmath28 and the affected nodes .",
    "@xmath42= \\emptyset \\wedge in_{c_{e}}[]= \\emptyset \\wedge ( hold_{c_{e } } + c\\_pu_{\\mathit{affected}_{c_{e } } } [ ] = c)\\ ] ]      the safety property ensures that in no case a node other than @xmath28 announces termination if the computation has indeed terminated . in order to prove the safety property ,",
    "we consider all the possible cases that may negate the system invariants and violate the safety requirements , as follows :    1 .   the incorrect recovery from any failure ( _ e_._g_. , the appearance of pus , mobility , and crash ) may temporarily falsify invariants  [ inv : credit_never_exceeds_c ] ,  [ inv : strong_termination ] , and  [ inv : weak_termination ] .",
    "lemma  [ lemma : state_message ] and lemma  [ lemma : recovery_passive_active_nodes ] assert that the incorrect recovery from any failure does not violate the safety requirements .",
    "2 .   before reaching the actual termination ,",
    "the value of @xmath43 or @xmath44 , then invariant  [ inv : strong_termination ] or invariant  [ inv : weak_termination ] are violated .",
    "lemma  [ lemma : credit_does_not_exceed1 ] and lemma  [ lemma : credit_does_not_exceed2 ] ensure that @xmath28 holds credit @xmath38 in case of global strong termination and the credit less than @xmath38 in case of global weak termination .",
    "the proofs of lemmas  [ lemma : state_message]-  [ lemma : credit_does_not_exceed2 ] guarantee the safety requirements of the _ t - cran _ protocol .",
    "the following lemma  [ lemma : state_message ] and lemma  [ lemma : recovery_passive_active_nodes ] prove that the nodes do not violate the safety requirements on their recovery .",
    "assume that on recovery , @xmath10 receives stale messages , @xmath46 , from unreliable channels or other recovered nodes .",
    "the reception of @xmath47 at @xmath10 is able to execute the computation and transmission of @xmath47 , in case @xmath48 .",
    "for the contrary , we assume that a node receives a stale message , @xmath49 , executes the computation and propagates @xmath49 .",
    "we now prove that the reception of stale messages does not violate the safety requirements , as follows :    @xmath10 can further distribute the computation or surrender credit after completion of its computation among its neighboring nodes , in response to @xmath49 .",
    "the neighboring node @xmath15 of @xmath10 may be a recovered node or unaware of the just terminated computation whose @xmath50 .",
    "hence , the recipient @xmath15 can also behave similar to @xmath10 .",
    "however , one of the nodes in the network or @xmath28 terminates the flow of @xmath49 due to @xmath51 ( action @xmath52 in table  [ tab : actions of credit diffusion - aggregation ] ) .",
    "hence , the system maintains invariant  [ inv : credit_never_exceeds_c ] , and once the credit is greater than @xmath38 , it is detected by some nodes ; thus stale messages can not violate the safety requirements of the _ t - cran _ protocol .",
    "the following assumptions help us to prove lemma  [ lemma : recovery_passive_active_nodes ] : we use four different time instants @xmath53 , and @xmath54 such that @xmath55 ( all the other lemmas will also use these time instances ) and three nodes @xmath10 , @xmath15 and @xmath56 that are neighbors of each other .",
    "@xmath10 initiates the _ t - cran _ protocol at time @xmath57 among @xmath15 and @xmath56 with @xmath58 . under a fault - free scenario , at time @xmath59 , @xmath10 announces global strong termination .",
    "suppose , @xmath56 becomes an - affected node at time @xmath60 .",
    "we first mention all the possible situations that may exist at the time of transition of a node from an affected node to a non - affected node or vice versa , which may announce false termination .",
    "afterward , we prove that none of these situations can lead to the violation of the safety requirements in our protocol .",
    "case 1 : :    @xmath56 is not able to recover , _",
    "i_._e_. ,    @xmath56 is an affected node for a very long time .",
    "case 2 : :    @xmath56 recovers , due to availability of another    available channel in @xmath61 or disappearance of the pu ,    at time @xmath54 , where @xmath54 <    @xmath59 .",
    "case 3 : :    @xmath56 recovers , due to availability of another    available channel in @xmath61 or disappearance of the pu ,    at time @xmath54 , where @xmath54 >    @xmath59 .",
    "the case 1 results in permanent failure of @xmath56 , _",
    "i_._e_. , @xmath56 is a crashed node .",
    "hence , the global strong termination is defied forever , and the protocol announces global weak termination of the computation at @xmath10 and @xmath15 .",
    "the case 2 results in the global strong termination , when @xmath62 at the time of recovery of @xmath56 in active state . however , passive state of the node is irrelevant here , because passive state of @xmath56 indicates that @xmath56 has already surrendered its credit before the transition from a non - affected node to an affection node .    in case 3 , @xmath28 has already declared global weak termination before recovery of @xmath56 .",
    "specifically , case 1 and case 3 are almost similar and do not affect @xmath28 , because @xmath63 .",
    "in addition , the recovery of @xmath56 in active state may cause to propagate messages , @xmath64 , to @xmath10 or @xmath15 .",
    "however , according to lemma  [ lemma : state_message ] , @xmath10 , which is @xmath28 , discard @xmath49 eventually because @xmath65 .",
    "( for a better understanding , readers may refer to figure  [ fig : recovery_passive_active_nodes ] )                the credit aggregated at @xmath28 never ever becomes equal to @xmath38 before the global strong termination is reached .",
    "this fact can be justified with the help of lemma  [ lemma : credit_does_not_exceed1 ] and lemma  [ lemma : credit_does_not_exceed2 ] , as follows :      suppose , only two processors @xmath10 and @xmath15 are executing a computation , and @xmath10 is the chief executive node .",
    "@xmath10 sends credit @xmath66 to @xmath15 , and again , @xmath15 sends credit @xmath67 to @xmath10 .",
    "thus , according to invariant  [ inv : credit_never_exceeds_c ] , the following equation  [ eq : credit_never_exceeds_c ] holds true : @xmath68    suppose at time @xmath57 , @xmath10 becomes active .",
    "thus , @xmath69 .",
    "however , at time @xmath60 , the following equation  [ eq : credit_at_i_from_i_to_j_and_at_j ] holds true : @xmath70 the above equation  [ eq : credit_at_i_from_i_to_j_and_at_j ] indicates credit distribution using a _ computation message _ from @xmath10 to @xmath15 .",
    "however , once @xmath15 receives the _ computation message _ , then @xmath69 .",
    "thus , the following equation  [ eq : credit_at_i_j ] holds ture : @xmath71              assume the contrary , at a later time @xmath59 , @xmath72 , and @xmath10 , which is the chief executive node , declares global strong termination , while @xmath73 .",
    "it is possible only when @xmath10 and @xmath15 are two processes at an identical node , _",
    "i_._e_. , @xmath74",
    ". however , the chief executive node , @xmath10 , never declares global strong termination despite @xmath75 , unless @xmath76 ( action @xmath77 , table  [ tab : actions of termination announcement ] ) .",
    "therefore , the protocol never declares termination unless all the nodes are passive , and @xmath78 .",
    "( for a better understanding , readers may refer to figure  [ fig : credit_does_not_exceed1 ] . )",
    "the credit aggregated at @xmath28 never becomes ( _ i _ ) greater than or equals to @xmath38 , in case of the global weak termination and , ( _ ii _ ) greater than @xmath38 , in case of the global strong termination .",
    "we call the _ wrong credit aggregation _",
    "when @xmath79 in case of the global weak termination and @xmath80 in case of the global strong termination .",
    "both the above facts are proved by lemma  [ lemma : credit_does_not_exceed2 ] , as follows :      the conditions that may lead to wrong credit collection at @xmath28 are the aggregation of an identical credit at more than one node , and the stale messages in the network .",
    "however , we have proved that the stale messages are eventually discarded ( lemma  [ lemma : state_message ] ) .",
    "hence , we consider the aggregation of an identical credit at more than one node .",
    "we first present a scenario that may lead to multiple times credit surrender of an identical credit at two different nodes . note that duplicate message reception at a node",
    "is handled in the protocol ; hence , we not consider it .",
    "we present two possible cases that may lead to wrong credit aggregation , and following that we prove by contradiction that these cases never arise in the protocol .",
    "suppose , an ongoing computation with @xmath58 , where @xmath10 completes its computation and sends an @xmath81 to @xmath15 .",
    "in the meantime , suppose @xmath15 becomes an affected or a failed node ( see failure model , section  [ section : the_system_model ] ) . thus , @xmath15 can not send an @xmath82 to @xmath10 .",
    "due to non - reception of an @xmath82 from @xmath15 , @xmath10 sends an @xmath81 to another node , say @xmath56 .",
    "however , the recovery of @xmath15 and the reception of an @xmath81 at @xmath15 signify that @xmath83 is surrendered at two different nodes .",
    "however , in the protocol , there are only two possible cases of the _ imperfect credit surrender _ , as follows :                  case 1 : :    @xmath15 is an affected or a failed node after    sending an @xmath82 to @xmath10 , and    @xmath10 is already an affected or a failed node    after the transmission of an @xmath81 .",
    "case 2 : :    @xmath10 sends an    @xmath81 to @xmath15 ,    and due to the absence of an @xmath82 from    @xmath15 , @xmath10 sends an    @xmath81 to @xmath56 .    after sending @xmath81 messages to two    different nodes , @xmath10 becomes an affected node .    also , @xmath15 receives the    @xmath81 .",
    "the reception of an @xmath82 and an @xmath84 is assumed to be an atomic operation , _",
    "i_._e_. , @xmath15 is not allowed to move to a different location before the reception of an @xmath84 or a timeout , and also , @xmath15 receives an @xmath84 in the presence of pus .",
    "therefore , case 1 never holds true .",
    "the case 2 is essentially an outcome of the case 1 .",
    "@xmath15 receives an @xmath81 and sends an @xmath82 to @xmath10 . as the affected node @xmath10 can not receive an @xmath82 from @xmath15 ; after a timeout value , @xmath15 recognizes that @xmath10 is an affected node .",
    "thus , @xmath15 sends a special message , @xmath40 , with credit @xmath83 , to @xmath28 .",
    "eventually , @xmath28 subtracts @xmath83 from @xmath85 . on recovery",
    ", @xmath10 again surrender its credit ( lemma  [ lemma : recovery_passive_active_nodes ] ) . on the other hand",
    ", @xmath10 receives an @xmath82 from @xmath15 though it has already surrendered its credit to @xmath56 earlier ; thus , @xmath10 behaves as an affected node .",
    "therefore , the credit of @xmath10 remains a constant in the network .",
    "( for a better understanding , readers may refer to figure  [ fig : credit_does_not_exceed2 ] . )          1 .",
    "the _ virtual tree - like structure _ does not grow infinitely . 2 .",
    "the height of the _ virtual tree - like structure _ eventually reduces , to ( _ i _ ) one , in case of the global strong termination , and ( _ ii _ ) two , in case of the global weak termination .",
    "we show that the _ virtual tree - like structure _ grows and has a finite height .",
    "@xmath28 , _",
    "i_._e_. , the root of the _ virtual tree - like structure _ , expands the computation among @xmath1 nodes ( using @xmath86 and @xmath87 , table  [ tab : actions of credit diffusion - aggregation ] ) . the distribution of the computation and credit increases the height of the _ virtual tree - like structure _ , and the maximum height of the _ virtual tree - like structure _ can be @xmath1",
    "however , the joining of new nodes in the network during the computation execution may increase the total number of crs and the maximum height to @xmath88 . in this manner , the _ virtual tree - like structure _ grows infinitely .",
    "however , once the nodes stop to join the network , then the _ virtual tree - like structure _ does not grow infinitely .",
    "we now show that the height of the _ virtual tree - like structure _ eventually reduces .",
    "the nodes are not allowed to delay the computation for an infinite time .",
    "hence , once all the nodes ( except @xmath28 ) , whose heights are identical , complete their computation , they send @xmath30 and @xmath32 messages to their parent node or to any number of neighboring nodes , if they are active ( action @xmath52 , table  [ tab : actions of credit diffusion - aggregation ] ) .",
    "thus , the transmission of @xmath30 and @xmath32 messages by all the nodes ( except @xmath28 ) , whose heights are identical ( not necessary at an identical time ) , results in reduction of the height of the _ virtual tree - like structure _ by at least 1 .                          we now show that when the _ virtual tree - like structure _ has height 1 after credit aggregation , it is a sufficient condition to announce the global strong termination . from the previous facts ,",
    "it is clear that the height of the _ virtual tree - like structure _ reduces by at least 1 when all the nodes ( except @xmath28 ) , whose heights are identical , send @xmath30 and @xmath32 messages .",
    "hence , when all the nodes of all the height levels ( except @xmath28 ) , send @xmath30 and @xmath32 messages that result in the height of the _ virtual tree - like structure _ to be 1 , eventually , and only a single node , @xmath28 , holds the complete credit ( that is equal to the credit that was distributed at the time of initiation ) .",
    "this fact is enough to show that at the time of the global strong termination the _ virtual tree - like structure _ has height 1 .",
    "we now show that when the _ virtual tree - like structure _ has height 2 after credit aggregation , it is a sufficient condition to announce the global weak termination . from the previous facts ,",
    "it is clear that the height of the _ virtual tree - like structure _ reduces when the non - affected nodes sends @xmath30 and @xmath32 messages .",
    "in addition , only a single non - affected node , @xmath28 , holds the credit of all the non - affected nodes eventually .",
    "since the affected nodes can not send @xmath30 and @xmath32 messages , the network is divided into two partitions as : @xmath89 and @xmath90 ( figure  [ fig : the_abstract_view_of_a_primary_user appearance in the cognitive radio network . ] ) .",
    "hence , the _ virtual tree - like structure _ has height 2 , and it is sufficient for the global weak termination .",
    "we provide an abstract view to show the impossibility of the global strong termination in the presence of a single primary user . by this abstract view , it will be clear that the appearance of a primary user is difficult to handle than mobility and crash of nodes .",
    "( note that in a purely asynchronous _",
    ", the global strong termination is impossible  @xcite to detect even if a single primary user exists in the network . )",
    "we consider a _",
    "crn _ as a connected communication graph that has nodes @xmath91 , @xmath92 , @xmath93 , @xmath94 ; and",
    "no node is assumed to be special .",
    "( the node ids are selected in a special way to help readers to understand the abstract view , which will be clear soon . )",
    "also , we assume four pus , namely pu@xmath95 , pu@xmath96 , pu@xmath97 , and pu@xmath98 that affect all the nodes .",
    "the _ virtual clustering _ is performed by considering @xmath99 , @xmath100 , @xmath101 , and @xmath102 as fixed centers  @xcite ( or cluster heads ) that partition the communication graph into four virtual clusters , say @xmath103 , and @xmath104 , see figure  [ fig : illustrating the impossibility of termination in the cognitive radio networka ] .",
    "now , assume that three pus , namely pu@xmath95 , pu@xmath96 , and pu@xmath97 , disappear from the network .",
    "thus , the nodes , namely @xmath91 , @xmath92 , @xmath93 , become non - affected nodes , figure  [ fig : illustrating the impossibility of termination in the cognitive radio networkb ] .",
    "all the non - affected nodes of each cluster send @xmath30 messages to the respective cluster heads .",
    "hence , each cluster head holds a termination report ( or credit ) of its cluster , namely @xmath99 has @xmath105 , @xmath100 has @xmath106 , and @xmath101 has @xmath107 , figure  [ fig : illustrating the impossibility of termination in the cognitive radio networkc ] .    in order to announce the global strong ( or weak ) termination in the network , it is required to aggregate all the termination reports ( or credits ) of each cluster head .",
    "thus , @xmath99 sends @xmath105 to its neighboring virtual cluster head @xmath100 , and @xmath100 aggregates the received credit as : @xmath108 , figure  [ fig : illustrating the impossibility of termination in the cognitive radio networkd ] .",
    "this state of the network is equivalent to the _ virtual merging _ of both the virtual clusters @xmath109 and @xmath110 in one virtual cluster , where @xmath110 is a virtual cluster head .",
    "similarly , @xmath111 is aggregated with @xmath107 at @xmath101 as : @xmath112 , figure  [ fig : illustrating the impossibility of termination in the cognitive radio networke ] .",
    "since a pu , pu@xmath98 , persists in the network and @xmath94 are affected node , an aggregated termination report ( or credit ) of the network can not be generated .",
    "the network is now partitioned into two parts , where the first part holds credit @xmath113 at @xmath101 and the remaining credit is distributed among the affected nodes , @xmath94 .",
    "this state of the network is equivalent to the _ virtual partitioning _ of the network into two virtual clusters : one virtual cluster , where @xmath109 , @xmath110 , and @xmath114 are virtually merged and @xmath101 is a virtual cluster head , and the another virtual cluster @xmath104 with @xmath102 as a virtual cluster head , figure  [ fig : illustrating the impossibility of termination in the cognitive radio networkf ] .",
    "therefore , it is shown that the existence of a single pu results in two isolated sub - networks , which is sufficient to prevent the protocol to announce the global termination . without loss of generality ,",
    "the above _ virtual partition - merge _ technique ( figure  [ fig : virtual_partition_merge ] ) can be applied to a network of arbitrary size and arbitrary number of pus ."
  ],
  "abstract_text": [
    "<S> the cognitive radio networks are an emerging wireless communication and computing paradigm . the cognitive radio nodes execute computations on multiple heterogeneous channels in the absence of licensed users ( a.k.a . </S>",
    "<S> primary users ) of those bands . </S>",
    "<S> termination detection is a fundamental and non - trivial problem in distributed systems . in this paper </S>",
    "<S> , we propose a termination detection protocol for multi - hop cognitive radio networks where the cognitive radio nodes are allowed to tune to channels that are not currently occupied by primary users and to move to different locations during the protocol execution . </S>",
    "<S> the proposed protocol applies credit distribution and aggregation approach and maintains a new kind of logical structure , called the _ virtual tree - like structure_. the _ virtual tree - like structure _ helps in decreasing the latency involved in announcing termination . unlike conventional tree structures , the _ virtual tree - like structure _ does not require a specific node to act as the root node that has to stay involved in the computation until termination announcement ; hence , the root node may become idle soon after finishing its computation . also , the protocol is able to detect the presence of licensed users and announce strong or weak termination , whichever is possible .   +    : cognitive radio network , credit distribution and aggregation , heterogeneous channels , termination detection , virtual partitioning and merging , virtual tree - like structure .    </S>",
    "<S> = 1 </S>"
  ]
}