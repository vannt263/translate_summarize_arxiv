{
  "article_text": [
    "[ app : hys ]      [ app : hys_modspec_code ]    *       [ app : hys_va_code ]    *       *       *       *       *",
    "[ app : rram_v0_modspec_code ]    *       [ app : rram_v0_va_code ]    *       *       *       *       *",
    "[ [ smoothfunctions.va-verilog-a-file-for-smoothing-function-definitions ] ] ` smoothfunctions.va ` : verilog - a file for smoothing function definitions ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~"
  ],
  "abstract_text": [
    "<S> existing compact models for memristive devices ( including rram and cbram ) all suffer from issues related to mathematical ill - posedness and/or improper implementation . </S>",
    "<S> this limits their value for simulation and design and in some cases , results in qualitatively unphysical predictions . </S>",
    "<S> we identify the causes of ill - posedness in these models . </S>",
    "<S> we then show how memristive devices in general can be modelled using only continuous / smooth primitives in such a way that they always respect physical bounds for filament length and also feature well - defined and correct dc behaviour . </S>",
    "<S> we show how to express these models properly in languages like verilog - a and modspec ( matlab@xmath0 ) . </S>",
    "<S> we apply these methods to correct previously published rram and memristor models and make them well posed . </S>",
    "<S> the result is a collection of memristor models that may be dubbed `` simulation - ready '' , _ </S>",
    "<S> i.e. _ , that feature the right physical characteristics and are suitable for robust and consistent simulation in dc , ac , transient , , analyses . </S>",
    "<S> we provide implementations of these models in both modspec / matlab@xmath0 and verilog - a .    </S>",
    "<S> =    =    =    =    [ [ section ] ]    in 1971 , leon chua noted @xcite that while two - terminal circuit elements relating voltage and current ( _ i.e. _ , resistors ) , voltage and charge ( capacitors ) and current and flux ( inductors ) were well known , no element that directly relates charge and flux seemed to exist . </S>",
    "<S> he explored the properties of this hypothetical element and found that its voltage - current characteristics would be those of a resistor , but that if the element were nonlinear , its resistance would change with time and be determined by the history of biasses applied to the device . </S>",
    "<S> in other words , the instantaneous resistance of the element would retain some memory of past inputs . </S>",
    "<S> chua dubbed this missing element a `` memristor '' , and showed that a telltale characteristic was that its @xmath1@xmath2 curves would always pass through @xmath3 , regardless of how it was biassed as a function of time.@xmath2 characteristics are `` pinched '' at the origin . </S>",
    "<S> ] long after chua s landmark observation , devices with memristive behaviour were found in nature , _ </S>",
    "<S> e.g. _ , in the well - publicized nano - crossbar device of stan williams and colleagues @xcite , and others as well @xcite . </S>",
    "<S> it was also realized that many physically observed devices prior to @xcite were in fact memristors @xcite .    </S>",
    "<S> physically , present - day memristive nano - devices typically operate by forming and destroying conducting filaments through an insulating material sandwiched between two contacts separated by a small distance @xmath4 . </S>",
    "<S> the conducting filaments can be of different types . </S>",
    "<S> for example , they can consist of oxide vacancies , by filling which electrons can flow , as in rram ( resistive random access memory @xcite ) . in cbram ( conductive bridging ram @xcite ) , metal ions that infiltrate the insulator form the conducting filament . in memristors made of si - impregnated silica @xcite </S>",
    "<S> , conduction occurs via tunnelling between traps . </S>",
    "<S> depending on the magnitude and polarity of the voltage applied , the conducting filaments can lengthen or shorten ; it is their length that determines the resistance of the device . </S>",
    "<S> basic geometry indicates that the length of the filament(s ) must always be between zero ( _ i.e. _ , there is no filament ) and the distance between the contacts ( _ i.e. _ , the filament connects the two contacts )  in other words , the length of the filament(s ) must never be outside the range @xmath5 $ ] . </S>",
    "<S> another basic property is that when the voltage across the device has one polarity ( say positive ) , the filament grows until it reaches its maximum length @xmath4 , at which it settles ; whereas for the opposite polarity ( say negative ) , the filament shrinks until it reaches its minimum length @xmath6 . </S>",
    "<S> therefore , if a positive dc voltage is applied , the dc ( _ i.e. _ , long term ) response of the memristor s filament length must be @xmath4 ; whereas if a negative dc voltage is applied , its dc response must be @xmath6 .    a number of novel circuits based on memristors have been proposed @xcite , most of which use crossbar architectures for non - volatile memory @xcite and neuromorphic computing @xcite applications . to support their design , various compact models of memristors , purportedly suitable for simulation in spice - like simulators , have been published . however , our attempts to use these models have revealed shortcomings serious enough to preclude their general use for simulation or design . broadly speaking , </S>",
    "<S> these existing models suffer from _ ill - posedness _ issues ; _ </S>",
    "<S> e.g. _ , they are not properly defined at all biasses , or their outputs are not unique , or they suffer from continuity / smoothness problems . </S>",
    "<S> well - posedness @xcite is a fundamental requirement for models meant to represent physical reality and is also crucial for numerical algorithms using the models to work properly .    </S>",
    "<S> the well - posedness requirement applies not only to memristive devices , but to any model meant for simulation . to appreciate why </S>",
    "<S> , it is important to realize that a model represents a _ mathematical abstraction _ of a physical device . while this abstraction must represent reality well enough to be useful for prediction </S>",
    "<S> , it must also be suitable for use with numerical simulation algorithms . </S>",
    "<S> to be so , it needs to satisfy certain important mathematical properties , the most basic and universal of which is well posedness .    to illustrate how a well - posed mathematical model must often be `` more than '' the physical device it represents , </S>",
    "<S> consider the question : is it necessary to model a device outside regions that are physically reasonable in proper operation ? </S>",
    "<S> for example , should a compact model of a memristor ( or a diode , or resistor , or ic mosfet ) , be `` valid '' at a bias of a million volts ( at which , in reality , most physical devices would simply burn up ) ? </S>",
    "<S> the answer to this question is yes  indeed , it has been a standard requirement for device models ( including resistors , capacitors , diodes , bjt and mos devices , ) in spice - like simulators to evaluate successfully and provide unique , smoothly varying outputs at all biasses , including large , physically unrealistic , biasses . </S>",
    "<S> these requirements stem not only from the numerical algorithms used by simulators ( in particular , the newton - raphson ( nr ) algorithm for solving nonlinear equations @xcite ) , but also from the iterative methodology using which circuits are typically designed :    1 .   in the process of converging to a valid solution of the circuit </S>",
    "<S> , nr typically applies a sequence of biasses to devices ; many of these biasses can be large or physically unreasonable . </S>",
    "<S> compact models must be designed to evaluate successfully and be smooth at _ every _ bias applied , whether it is physically reasonable or not , in order for nr to go about trying to find a solution @xcite . </S>",
    "<S> if devices are modelled well and the circuit has been designed properly , then , _ at the solution found by nr _ </S>",
    "<S> , biasses to devices can be expected to be physically reasonable . </S>",
    "<S> 2 .   </S>",
    "<S> even if nr converges to a solution that is physically unreasonable , the `` bad '' solution has value in circuit design , for it typically provides quantitative insight into what is wrong with the design . </S>",
    "<S> a compact model that refuses to evaluate or generates a floating - point error prevents such solutions , and the insights they provide , from being found .    </S>",
    "<S> common ill - posedness mechanisms in models include division - by - zero errors , often due to expressions like @xmath7 , which become unbounded ( and feature a `` doubly infinite '' jump ) at @xmath8 ; the use of @xmath9 or @xmath10 without ensuring that their arguments are always positive , regardless of bias ; the fundamental misconception that non - real ( _ i.e. _ , complex ) numbers or infinity are legal values for device models ( they are not ! ) ; and `` sharp''/``pointy '' functions like @xmath11 , whose derivatives are not continuous .    </S>",
    "<S> another key aspect of well - posedness is that the model s equations must produce mathematically valid outputs for any mathematically valid input to the device . </S>",
    "<S> possibly the most basic kind of input is one that is constant ( `` dc '' ) for all time . </S>",
    "<S> dc solutions ( `` operating points '' ) are fundamental in circuit design ; they are typically the kind of solution a designer seeks first of all , and are used as starting points for other analyses like transient , small signal ac , . </S>",
    "<S> if a model s equations do not produce valid dc outputs given dc inputs , it fails a very fundamental well - posedness requirement . </S>",
    "<S> for example , the equation @xmath12 is ill posed , since no dc ( constant ) solution for the output @xmath13 is possible if the input @xmath14 is any non - zero constant . </S>",
    "<S> such ill posedness is typically indicative of some fundamental physical principle being violated ; for example , in the case of @xmath12 , the system is not strictly stable @xcite . indeed , </S>",
    "<S> a well - posed model that is properly written and implemented should work consistently in every analysis ( including dc , transient , ac , . ) .    in spite of seemingly significant efforts to devise memristor models , </S>",
    "<S> _ every _ model we are aware of in the literature @xcite suffers from one or more of the above - mentioned types of ill - posedness . </S>",
    "<S> the university of michigan model @xcite , many aspects of which have been adopted by later models , suffers from division - by - zero errors and dc response problems . </S>",
    "<S> an rram model from stanford / asu with several variants @xcite that has received considerable publicity suffers from egregious dc response problems . </S>",
    "<S> the uestc memristor models @xcite , though they avoid many issues common to other models , still suffer from subtle ( but serious ) dc response problems . </S>",
    "<S> the team models for general memristors @xcite also suffer from dc , uniqueness and continuity / smoothness issues . over and above well - posedness issues , </S>",
    "<S> released versions of existing memristor compact models frequently suffer from deficiencies in the way their equations are expressed in modelling languages like verilog - a . </S>",
    "<S> examples of deficiencies we have encountered include attempts to perform time - integration of differential equations within the model definition , inserting time - varying noise terms as an integral part of the model , using integral formulations instead of differential ones , . as explained in @xcite , such practices compromise accuracy , limit the model s ability to support all analyses , reduce portability across simulators , and so on . </S>",
    "<S> further details about the shortcomings we have observed in these models are provided later in this paper .    in this paper </S>",
    "<S> , we explain the correct generic way to model memristive devices in a well - posed manner . </S>",
    "<S> our modelling technique sets up the dynamics of the filament length using a differential equation , and the current - voltage relationship of the memristor using an algebraic equation involving the filament length . employing only continuous / smooth mathematical constructs , </S>",
    "<S> we show how filament dynamics can be modelled such that physical bounds are always respected and correct dc behaviour for positive and negative biasses always results . in the process of developing our modelling technique , </S>",
    "<S> we pinpoint several common mechanisms underlying ill - posedness in prior models . </S>",
    "<S> since filament dynamics in memristive devices have features closely related to hysteresis , we explain how to model hysteresis correctly in general , then apply this to memristive devices . </S>",
    "<S> we use our techniques to correct several previous models , making them well posed and suitable for any analysis ( including dc , transient , ac , periodic steady state , ) . </S>",
    "<S> the process of restoring well - posedness to memristor models also provides insights into possible physical mechanisms in memristors that seem not to have been looked into yet .    </S>",
    "<S> the remainder of the paper is organized as follows . in sec .  </S>",
    "<S> [ sec : hys ] , we explain how hysteresis should be modelled in general , _ </S>",
    "<S> i.e. _ , using internal unknown variables and implicit equations . </S>",
    "<S> we illustrate how a model with internal unknowns and implicit equations can be written properly in both verilog - a @xcite and modspec @xcite . in sec .  </S>",
    "<S> [ sec : rram ] , we specialize our general model template for hysteresis to rram devices , showing how to design the continuous / smooth equations involved so that filament length boundaries are always respected and the correct dc behaviour results . </S>",
    "<S> we write well - posed rram models in both verilog - a and modspec and test them in simulation , using dc , transient and homotopy @xcite analyses . then , in sec .  </S>",
    "<S> [ sec : convergence ] , we develop techniques for aiding numerical convergence in the rram model . in particular , we design a spice - compatible limiting function for the rapidly - growing hyperbolic sine function used in the rram model , inspired by the limiting functions used in spice s non - linear semiconductor devices . to our knowledge , this is the first limiting function designed to aid convergence after pnjlim and fetlim , which were developed as part of the original berkeley spice @xcite . </S>",
    "<S> next , in sec .  </S>",
    "<S> [ sec : memristor ] , we study all the published compact models for memristors we are aware of that come with concrete equations or code . </S>",
    "<S> we identify issues of ill - posedness and poor implementation that affect their applicability in simulation . </S>",
    "<S> we then use our modelling techniques to correct their problems and turn them into well - posed models , providing proper implementations in modspec and verilog - a .    </S>",
    "<S> the result of our study is a collection of well - posed , properly implemented , compact models for memristive devices . </S>",
    "<S> specifically , we devise 5 different algebraic current - voltage and 6 different differential equation dynamical models for filament length , _ </S>",
    "<S> i.e. _ , 30 different models for memristors and/or rram devices , all well posed .    </S>",
    "<S> although we use underlying equations published by others , we modify them to remove ill - posedness issues , and also provide proper implementations . understanding the process by which we do </S>",
    "<S> this can be valuable for the development of future models , not only of memristors , but of other hysteretic devices as well .    </S>",
    "<S> [ [ section-1 ] ]    [ sec : hys ] to develop our memristor models , we first study how to model @xmath1@xmath2 hysteresis in two - terminal devices properly . </S>",
    "<S> we show that the @xmath1@xmath2 hysteresis can be modelled with the help of an internal state variable and an implicit differential equation . </S>",
    "<S> then with the help of an example , we illustrate how a model with internal unknowns and implicit equations can be properly written in both verilog - a and the modspec format .      </S>",
    "<S> [ sec : hys_eqn ]    the equation of a general two - terminal resistive device can be written as @xmath15 where @xmath16 is the voltage across the device , @xmath14 the current through it . </S>",
    "<S> for example , the function @xmath17 for a simple linear resistor can be written as @xmath18    for devices with @xmath1@xmath2 hysteresis , @xmath14 and @xmath16 can not have a simple algebraic mapping like ( [ eq : iv_f ] ) . instead , we introduce a state variable @xmath19 into ( [ eq : iv_f ] ) and rewrite the @xmath1@xmath2 relationship as @xmath20    the dynamics of the internal state variable @xmath19 is governed by a differential equation : @xmath21    the internal state variable @xmath19 can have several physical meanings . if we consider the original memristor model proposed by chua in the 1970s @xcite , @xmath19 can be thought of as the flux or charge stored in the device . in the context of metal - insulator - metal-(mim)-structured ram devices , _ </S>",
    "<S> e.g. _ , rrams and cbrams , @xmath19 can represent either the length of the conductive filament / bridge , or the gap between the tip of the filament / bridge to the opposing electrode .    in all these scenarios </S>",
    "<S> , @xmath19 has some influence on @xmath14 . </S>",
    "<S> so we can not directly calculate the current based on the voltage applied to the device at a single time @xmath22 ; @xmath14 also depends on the value of @xmath19 . on the other hand , at time @xmath22 , the value of @xmath19 is determined by the history of @xmath16 according to ( [ eq : sv_f2 ] ) . </S>",
    "<S> therefore , we can think of the device as having internal `` memory '' of the history of its input voltage . </S>",
    "<S> if we choose the formula for @xmath23 and @xmath24 in ( [ eq : iv_f1 ] ) and ( [ eq : sv_f2 ] ) properly , as we sweep the voltage , hysteresis in the current becomes possible .    </S>",
    "<S> in the rest of this paper , ( [ eq : iv_f1 ] ) and ( [ eq : sv_f2 ] ) serve as a model template for two - terminal devices with @xmath1@xmath2 hysteresis . to illustrate its use </S>",
    "<S> , we design a device example , namely `` ` hys_example ` '' , with functions @xmath23 and @xmath24 defined as follows .    </S>",
    "<S> @xmath25    @xmath26    the choice of @xmath23 is easy to understand . </S>",
    "<S> @xmath27 is a monotonically increasing function with range @xmath28 . </S>",
    "<S> we add @xmath29 to it to make its range positive . </S>",
    "<S> we then incorporate it into @xmath23 as a factor such that @xmath19 can modulate the conductance of the device between @xmath6 and @xmath30 .    </S>",
    "<S> the choice of @xmath24 determines the dynamics of @xmath19 . and </S>",
    "<S> when @xmath31 , the corresponding ( @xmath2 , @xmath32 ) pairs will show up as part of the dc solutions of circuits containing this device . </S>",
    "<S> therefore , if we plot the values of @xmath24 in a contour plot , such as in fig .  </S>",
    "<S> [ fig : hys_f2 ] ( a ) , the curve representing @xmath31 is especially important . through the use of a simple cubic polynomial of @xmath19 in ( [ eq : hys_f2 ] ) </S>",
    "<S> , we design the @xmath31 curve to fold back in the middle , crossing the @xmath33 axis three times . in this way , </S>",
    "<S> when @xmath2 is around @xmath6 , there are three possible values @xmath32 can settle on , all satisfying @xmath34 . </S>",
    "<S> this multiple stability in state variable @xmath32 is the foundation of hysteresis found in the dc sweep on the device .    </S>",
    "<S> fig .  </S>",
    "<S> [ fig : hys_f2 ] ( b ) illustrates how hysteresis takes place in dc sweeps . in fig .  </S>",
    "<S> [ fig : hys_f2 ] ( b ) , we divide the @xmath31 curve into three parts : curve ` a ` and ` b ` have positive slopes while ` c ` has a negative one . </S>",
    "<S> when we sweep @xmath2 towards the right at a very slow speed to approximate dc conditions , starting from a negative value left of @xmath35 , at the beginning , there is only one possible dc solution of @xmath32 . </S>",
    "<S> as we increase @xmath2 , the ( @xmath2 , @xmath32 ) pair will move along curve ` a ` , until ` a ` ends when @xmath2 reaches @xmath36 . if @xmath2 increases slightly beyond @xmath36 , multiple stability in @xmath32 disappears . </S>",
    "<S> ( @xmath2 , @xmath32 ) reaches the @xmath37 region and @xmath32 will grow until it reaches the ` b ` part of the @xmath31 curve . </S>",
    "<S> this shows up in the dc solutions as a sudden jump of @xmath32 towards curve ` b ` . </S>",
    "<S> similarly , when we sweep @xmath2 in the other direction starting from the right of @xmath36 , the ( @xmath2 , @xmath32 ) pair will follow curve ` b ` , then have a sudden shift to ` a ` at @xmath35 . because @xmath38 , hysteresis occurs in @xmath32 when sweeping @xmath2 , as illustrated in fig .  </S>",
    "<S> [ fig : hys_f2 ] ( b ) . </S>",
    "<S> since @xmath32 modulates the device s conductance , there will also be hysteresis in the @xmath1@xmath2 relationship .    </S>",
    "<S> note that we are analyzing and predicting hysteresis based on the dc solution curve defined by @xmath39 . </S>",
    "<S> this clarifies a common confusion people have . </S>",
    "<S> as hysteresis is normally defined as a type of time - dependence between output and input , people often believe that it has nothing to do with the circuit s or device s dc properties . </S>",
    "<S> it is true that hysteresis is normally observed in transient analysis . </S>",
    "<S> but from the above discussions , we can see that it is indeed generated by the multiple stability and the abrupt change in dc solutions . </S>",
    "<S> as mentioned earlier , at a certain time @xmath22 , @xmath19 can be thought of as encoding the memory of @xmath16 from the past . </S>",
    "<S> its multiple stability reflects the different possible sets of history of @xmath16 . and </S>",
    "<S> the separation between @xmath36 and @xmath35 in the dc curves ensures that no matter at what speed we sweep @xmath2 , there will always be hysteresis in the @xmath32@xmath2 relationship .    </S>",
    "<S> when we sweep @xmath2 back and forth , curve ` c ` , the one with a negative slope in fig .  </S>",
    "<S> [ fig : hys_f2 ] ( b ) never shows up in solutions . </S>",
    "<S> the reason is that , although it also consists of solutions of @xmath31 , these solutions are not stable . </S>",
    "<S> if a ( @xmath2 , @xmath32 ) point on curve ` c ` is perturbed to move above ` c ` , whether because of physical noise or numerical error , it falls in the @xmath37 region and will continue to grow until it reaches ` b ` . </S>",
    "<S> similarly , if it moves below ` c ` , it will decrease to curve ` a ` . </S>",
    "<S> therefore , it wo nt be observed during voltage sweep , leaving only ` a ` and ` b ` to form the @xmath32@xmath2 hysteresis curves .      </S>",
    "<S> [ sec : hys_mapp ]    with the model equations for ` hys_example ` defined in ( [ eq : hys_f1 ] ) and ( [ eq : hys_f2 ] ) , how do we put them into a compact model so that we can simulate it in circuits ? to answer this question , in this section , we first discuss our formulation of the general form of device compact models , namely the modspec format @xcite . </S>",
    "<S> then we develop the modspec model for ` hys_example ` and implement it in mapp @xcite .    </S>",
    "<S> modspec is mapp s way of specifying device models . </S>",
    "<S> a device model describes the relationship between variables using equations . among the variables of interest , some are the device s inputs / outputs ; they are related to the circuit connectivity . </S>",
    "<S> we call them the device s i / os . in the context of electrical devices , they are branch voltages and currents . among all the i / os , some may be expressed explicitly using the other variables ; they are the outputs of the model s explicit equations . furthermore </S>",
    "<S> , a device model can also have non - i / o internal unknowns and implicit equations . </S>",
    "<S> taking all these possibilities into consideration , we specify model equations in the following modspec format . @xmath40    vectors @xmath41 and @xmath42 contain the device s i / os : @xmath42 comprises those i / os that can be expressed explicitly ( for ` hys_example ` , it contains only @xmath1 ) , while @xmath41 comprises those that can not ( for ` hys_example ` , it is @xmath2 ) . </S>",
    "<S> @xmath43 contains the model s internal unknowns ( for ` hys_example ` , it is @xmath32 ) , while @xmath44 provides a mechanism for specifying time - varying inputs within the device ( _ e.g. _ , as in independent voltage or current sources ) . </S>",
    "<S> the functions @xmath45 , @xmath46 , @xmath47 and @xmath48 define the differential and algebraic parts of the model s explicit and implicit equations .    for ` hys_example ` , </S>",
    "<S> we can write its model equations in the modspec format as follows . @xmath49 with @xmath50 $ ] , @xmath51 $ ] , @xmath52 $ ] , @xmath53 $ ] .    </S>",
    "<S> we can enter the model information in ( [ eq : hys_modspec ] ) into mapp by constructing a modspec object ` mod ` . </S>",
    "<S> the code in appendix  [ app : hys_modspec_code ] shows how to create this device model for ` hys_example ` entirely in the matlab@xmath0 language . for more detailed description of the modspec format </S>",
    "<S> , users can issue the command `` ` help modspec_concepts ` '' in mapp .      </S>",
    "<S> [ sec : hys_simulation ]    in this section , we verify our analysis and prediction of @xmath1@xmath2 hysteresis in sec .  </S>",
    "<S> [ sec : hys_eqn ] by testing the compact models presented in sec .  </S>",
    "<S> [ sec : hys_mapp ] and in a circuit shown in fig .  </S>",
    "<S> [ fig : vsrc_hys ] .    fig .  </S>",
    "<S> [ fig : test_hys_sweep ] shows the results from dc sweep and transient simulation with input voltage sweeping up and down on the circuit in fig .  </S>",
    "<S> [ fig : vsrc_hys ] . </S>",
    "<S> it confirms that hysteresis takes place in both @xmath1@xmath2 and @xmath32@xmath2 relationships of the device .    in fig .  </S>",
    "<S> [ fig : test_hys_sweep ] ( b ) , curve ` c ` ( defined in fig .  </S>",
    "<S> [ fig : hys_f2 ] ( b ) ) with a negative slope never shows up in either forward or backward voltage dc sweep . </S>",
    "<S> this matches our discussion in sec .  </S>",
    "<S> [ sec : hys_eqn ] . in order to plot this curve and complete the dc solutions , also to get rid of the abrupt change of solutions in dc sweeps </S>",
    "<S> , we can use the homotopy analysis @xcite . </S>",
    "<S> homotopy analysis can track the dc solution curve in the state space .    </S>",
    "<S> results from homotopy analysis on the circuit in fig .  </S>",
    "<S> [ fig : vsrc_hys ] are shown in fig .  </S>",
    "<S> [ fig : test_hys_homotopy ] . </S>",
    "<S> we note that all the circuit s dc solutions indeed form a smooth curve in the state space . </S>",
    "<S> the side view of the 3-d plot displays curve ` c ` we have designed in our model equation ( [ eq : hys_f2 ] ) . </S>",
    "<S> the corresponding curve in the top view connects the two discontinuous dc sweep curves in fig .  </S>",
    "<S> [ fig : test_hys_sweep ] ; it consists of all the unstable solutions in the @xmath1@xmath2 relationship . </S>",
    "<S> this curve was previously missing in dc and transient sweep results , and now displayed by the homotopy analysis . </S>",
    "<S> these results from homotopy analysis provide us with important insights into the model . </S>",
    "<S> they reveal that there is a single smooth and continuous dc solution curve in the state space , which is an indicator of the well - posedness of the model . </S>",
    "<S> they also illustrate that it is the folding in the smooth dc solution curve that has created the discontinuities in dc sweep results . </S>",
    "<S> these insights are important for the proper modelling of hysteresis .    </S>",
    "<S> moreover , the top view explains the use of internal state @xmath32 for modelling hysteresis from another angle . without the internal state </S>",
    "<S> , it would be difficult if not impossible to write a single equation describing the @xmath1@xmath2 relationship shown in fig .  </S>",
    "<S> [ fig : test_hys_homotopy ] ( b ) . with the help of @xmath32 , we can easily choose two simple model equations as ( [ eq : hys_f1 ] ) and ( [ eq : hys_f2 ] ) , and the complex @xmath1@xmath2 relationship forms naturally .    </S>",
    "<S> [ [ section-2 ] ]    [ sec : hys_va ]    in this section , we write the ` hys_example ` model in the verilog - a language .    </S>",
    "<S> apart from the differences in syntax , verilog - a differs from modspec in one key aspect  the way of handling internal unknowns and implicit equations . </S>",
    "<S> verilog - a models a device with an internal circuit topology , _ </S>",
    "<S> i.e. _ , with internal nodes and branches defined just like in a subcircuit . </S>",
    "<S> the variables in a verilog - a model , the `` sources '' and `` probes '' , are potentials and flows specified based on this topology . coming from this subcircuit perspective </S>",
    "<S> , the language does nt provide a straightforward way of dealing with general internal unknowns and implicit equations inside the model , _ </S>",
    "<S> e.g. _ , the state variable @xmath32 and the equation ( [ eq : sv_f2 ] ) in ` hys_example ` .    </S>",
    "<S> this limitation gives rise to so much confusion about the modelling of devices with hysteresis , that we would like to examine the common modelling mistakes and pitfalls before describing our approach . </S>",
    "<S> here is the list of how not to model internal unknowns and implicit equations in verilog - a .    </S>",
    "<S> @xmath54    declare the internal unknown as a general variable , _ </S>",
    "<S> e.g. _ , using `` ` real ` '' , then use `` ` idt ( ) ` '' function to describe the differential equation the variable should satisfy . this approach is not recommended because of several reasons .    </S>",
    "<S> first , verilog - a provides most consistent definitions and support for potentials and flows as circuit unknowns ; it is unclear how `` ` real ` '' variables inside differential equations are handled by each verilog - a compiler . </S>",
    "<S> some simulators will return inconsistent or incorrect results . </S>",
    "<S> moreover , another potential hazard from this practice is that the simulator may create a memory state for the variable @xcite , limiting its use in some simulation algorithms , _ </S>",
    "<S> e.g. _ , those for periodic steady state ( pss ) analysis .    </S>",
    "<S> also , people often attempt to use `` ` idt ( ) ` '' in this scenario , apparently because verilog - a does nt allow using `` ` ddt ( ) ` '' to contribute to a none - potential / flow quantity as `` source '' , for good reasons . but </S>",
    "<S> this `` workaround '' with the use of `` ` idt ( ) ` '' is not recommended @xcite , as different simulators have inconsistent support for `` ` idt ( ) ` '' .     </S>",
    "<S> another pitfall is to use implicit contributions . </S>",
    "<S> while an implicit contribution in verilog - a seems to simplify the code , and forces users to model the internal unknown as a potential or flow , which is in line with what we propose , it is not recommended @xcite . in fact , it is not supported properly even by some well - known commercial simulators .    </S>",
    "<S> model the differential relationship by coding time integration inside . in this approach </S>",
    "<S> , the model has access to the absolute time and calculates the time step inside , then approximates the differential equation ( [ eq : sv_f2 ] ) by integrating @xmath24 at each time step . </S>",
    "<S> the approach may seem straightforward , but it has so many problems that i have to create another list for them :    @xmath55     the method inevitably uses `` ` abstime ` '' function in the model . to set the starting point of the integration </S>",
    "<S> , it also has to use the `` ` initial_step ` '' event . </S>",
    "<S> these are both bad practices in analog modelling @xcite .     </S>",
    "<S> the method can only use forward euler ( fe ) @xcite internally for integration , potentially causing convergence issues for stiff systems .     in this method , the internal unknown </S>",
    "<S> is intentionally defined as a memory state , again creating difficulties for pss simulation .     </S>",
    "<S> the model wo nt perform correctly in analyses that do not involve time integration , like dc , small signal ac analysis and harmonic balance .     even for transient simulation </S>",
    "<S> , it defeats the purpose of using the simulator , as it bypasses the simulator s many built - in facilities , _ </S>",
    "<S> e.g. _ , convergence aiding techniques , truncation error estimation , time step control , .     </S>",
    "<S> there are many more issues with this approach . </S>",
    "<S> for example , circuit designers can not set transient analysis initial conditions for the internal unknown the normal way they do for capacitor voltages and inductor currents . also , to `` ensure '' the accuracy of internal time integration , `` ` bound_step ` '' is often used . and the bounded step specified either makes simulation inaccurate or unnecessarily slow .    </S>",
    "<S> we note that these problems and pitfalls arise partly from the limitation of the verilog - a language in intuitively handling general internal unknowns and implicit equations , mostly from bad modelling practices . to circumvent these issues and write a robust verilog - a model for ` hys_example ` that should work consistently in all simulators and all simulation algorithms , we model state variable @xmath32 as a voltage . we declare an internal branch , whose voltage represents @xmath32 . </S>",
    "<S> one end of the branch is an internal node that does nt connect to any other branches . in this way , by contributing @xmath56 and ` ddt(-tau * s ) ` both to this same branch , the kcl at the internal node will enforce the implicit differential equation in ( [ eq : hys_f2 ] ) .    declaring @xmath32 as a voltage is not the only way to model ` hys_example ` in verilog - a . depending on the physical nature of @xmath32 </S>",
    "<S> , one can also use verilog - a s multiphysics support and model it as a mechanical property , such as a position from the kinematic discipline . </S>",
    "<S> this may be closer to the actual meaning of @xmath32 for mim - structured ram devices . </S>",
    "<S> alternatively , we can also use the property for potential from the thermal or magnetic discipline . </S>",
    "<S> one can also switch potential and flow by defining @xmath32 as a flow instead . </S>",
    "<S> these alternatives may make the model look more physical , but they do not make a difference mathematically , except from the scale of tolerances in each discipline , which we will discuss in more detail in sec .  [ </S>",
    "<S> sec : rram_v0_va ] . </S>",
    "<S> the essence of our approach is to recognize that state variable @xmath32 is a circuit unknown , and thus should be modelled as a potential or flow in verilog - a , for the consistent support from different simulators in various circuit analyses .    </S>",
    "<S> the verilog - a code for ` hys_example ` is provided in appendix  [ app : hys_va_code ] . </S>",
    "<S> it generates consistent results in many simulation platforms , including spectre@xmath0 , version : 7.2.0 64bit . </S>",
    "<S> ] hspice , and the open - source simulator xyce . </S>",
    "<S> the test benches with all these simulators can be found in appendix  [ app : hys ] .    </S>",
    "<S> [ [ section-3 ] ]    [ sec : rram ]    the model ` hys_example ` developed in sec .  [ </S>",
    "<S> sec : hys ] is a model template for devices with hysteresis , such as rram devices . by changing its @xmath23 ( [ eq : hys_f1 ] ) and @xmath24 ( [ eq : hys_f2 ] ) functions in model equations , as well as the corresponding function implementations in mapp and verilog - a code , we can then have compact models capturing the physics of rram devices .      </S>",
    "<S> [ sec : rram_v0_eqn ]    an rram device consists of two metal electrodes , namely @xmath22 ( top ) and @xmath57 ( bottom ) , and a thin oxide film separating them . </S>",
    "<S> a conductive filament can form in the film . </S>",
    "<S> when it grows to connect the two electrodes , the device is in low resistance state ( lrs ) ; when part of it dissolves , the device enters high resistance state ( hrs ) . as a ram </S>",
    "<S> , its `` memory '' is stored in the status of its internal conductive filament and the corresponding resistance state .    from the above discussion , the internal state variable for rram models can be either the length of the filament @xcite , or the gap between the tip of the filament and the opposing electrode @xcite . </S>",
    "<S> we choose to use the gap in this section , as it is what really determines the tunnelling current . </S>",
    "<S> then the variables in the rram model are : the voltage @xmath58 across the device , the current @xmath59 through it and the internal unknown @xmath60 . </S>",
    "<S> we can then rewrite the equations ( [ eq : iv_f1 ] ) and ( [ eq : sv_f2 ] ) from the model template in sec .  </S>",
    "<S> [ sec : hys_eqn ] as @xmath61    the physical contexts of these rram model equations are straightforward to understand . equation ( [ eq : rram_f1 ] ) determines how the current is modulated by both the voltage and @xmath60 ; equation ( [ eq : rram_f2 ] ) describes the growth rate of @xmath60 at a given voltage with some existing @xmath60 size . </S>",
    "<S> our goal of rram modelling is to find suitable @xmath23 and @xmath24 functions to capture these physical properties .    </S>",
    "<S> the formula for @xmath23 are mostly consistent across several existing rram models developed in different groups @xcite . among them , @xcite use the same equation , which is only different from that used in @xcite in the choice of internal unknown . and @xmath62 , to make the equation equivalent to the one in @xcite . ] </S>",
    "<S> therefore , in this section , we choose to use the @xmath23 function in @xcite : @xmath63 where @xmath64 , @xmath65 , @xmath66 are fitting parameters .    for @xmath24 </S>",
    "<S> , we can adapt the @xmath60 growth formulation in @xcite and write it as @xmath67 where @xmath68 , @xmath69 , @xmath70 are fitting parameters , @xmath71 is the thickness of the oxide film , @xmath72 is the thermal voltage , and @xmath73    @xmath74 in ( [ eq : rram_v0_gamma ] ) is known as the local field enhancement factor @xcite . </S>",
    "<S> it accounts for the abrupt set ( filament grows enough to connect electrodes ) and gradual reset ( filament dissolves ) behaviors in bipolar rram devices @xcite . </S>",
    "<S> parameters are normally chosen to ensure that this @xmath74 factor is always positive . </S>",
    "<S> so the sign and zero - crossings of @xmath24 in ( [ eq : rram_v0_f2 ] ) are determined only by @xmath58 .    </S>",
    "<S> while there are small differences among the @xmath24 functions in models developed by various groups @xcite , they differ mainly in the definitions of fitting parameters . </S>",
    "<S> a property they all share is that the sign of @xmath24 is the same as that of @xmath75 . put in other words , @xmath60 begins to decrease whenever @xmath58 is positive , and vice versa , as illustrated in fig .  </S>",
    "<S> [ fig : rram_f2 ] ( a ) . </S>",
    "<S> while there is some physical truth to this statement , considering that an rram device will eventually be destroyed if applied a constant voltage for an indefinite amount of time , for the model to work in numerical simulation , the state variable @xmath60 has to be bounded .    ensuring that the upper and lower bounds for @xmath60 are always respected in simulation is one major challenge for the compact modelling of rram devices . to address this challenge , </S>",
    "<S> several techniques have been attempted in the existing rram compact models :    @xmath54    directly use ` if - then - else ` statements on @xmath60 @xcite . </S>",
    "<S> this type of model is normally written in verilog - a . </S>",
    "<S> they declare ` gap ` as a ` real ` variable , then directly enforce `` ` if ( gap < 0 ) gap = 0 ; ` '' . </S>",
    "<S> we have discussed in great detail in sec .  </S>",
    "<S> [ sec : hys_va ] about the problems of modelling internal unknowns as general verilog - a variables . on top of these problems , no matter whether the verilog - a compiler treats ` gap ` as a circuit unknown or a memory state , the use of ` if - then - else ` statements for bounding the variable excludes the model from the differential equation framework . </S>",
    "<S> thus they are not suitable for simulation analyses .    </S>",
    "<S> moreover , the use of ` if - then - else ` also introduces hard discontinuities in the model , causing convergence problems @xcite . also , forcefully setting variable ` gap ` to certain values can result in singular circuit jacobian matrices , creating difficulties for most simulation algorithms .    </S>",
    "<S> use window functions @xcite .    </S>",
    "<S> the goal is to set @xmath76 when @xmath77 and @xmath78 . </S>",
    "<S> the method used in these models is to multiply the @xmath24 in ( [ eq : rram_v0_f2 ] ) with a window function that is close to @xmath29 when @xmath79 , equal to @xmath6 when @xmath60 is at @xmath80 or @xmath81 , and has negative values elsewhere . directly constructing such windows functions with ` step ( ) ` functions @xcite </S>",
    "<S> is not recommended as it introduces discontinuities into the model . </S>",
    "<S> one better example of such window functions for @xmath82 $ ] window size is known as the joglekar window @xcite : @xmath83 where @xmath84 is a positive integer used to adjust the sharpness of the window .    after multiplying window functions , the @xmath24 function used in these models is still smooth and continuous , and the models still in the differential equation format , complying with the model template we have discussed in sec .  [ sec : hys ] . as a result , </S>",
    "<S> the models are often reported to run reasonably well in transient simulations @xcite .    however , there are subtle and deeper problems with this approach . </S>",
    "<S> the problems can also be illustrated by analyzing the sign and zero - crossings of function @xmath24 . </S>",
    "<S> after multiplying @xmath24 by window functions , the zero - crossings of @xmath24 are shown in fig .  </S>",
    "<S> [ fig : rram_f2 ] ( b ) . </S>",
    "<S> the @xmath31 curves consist of three lines : the @xmath81 and @xmath80 lines , and the @xmath85 line . based on the sign of @xmath24 , the left half of the @xmath80 line and the right half of the @xmath81 line consist of unstable dc solutions ; they are unlikely to show up in transient simulations . </S>",
    "<S> therefore , when sweeping the voltage between negative and positive values , @xmath60 will move between @xmath81 and @xmath80 . this is the foundation for the model to work in transient simulations . </S>",
    "<S> however , based on fig .  </S>",
    "<S> [ fig : rram_f2 ] ( b ) , the model has several problems in other types of analyses .    </S>",
    "<S> @xmath55     in dc operating point analysis or dc sweeps , all lines consisting the @xmath86 curves can show up , including those containing unphysical results . </S>",
    "<S> for example , when the voltage is zero , any @xmath60 size is a solution ; @xmath60 is not bounded anymore .     in homotopy analysis , </S>",
    "<S> the intersection of solution lines introduced by the window functions makes the solution curve difficult to track . </S>",
    "<S> in particular , it will attempt to track the @xmath85 line where @xmath60 grows without bound . </S>",
    "<S> the fact that there is no single continuous solution curve in the state space indicates poor numerical properties of the model in other types of simulation algorithms as well .     even in transient analysis , the model wo nt run properly unless we carefully set an initial condition for @xmath60 . </S>",
    "<S> if the initial value of @xmath60 is beyond @xmath87 , or if it falls outside this range due to any numerical error , it can start to grow without bound .    </S>",
    "<S> other window functions are also tried for this approach , _ </S>",
    "<S> e.g. _ , biolek and prodromakis windows @xcite . </S>",
    "<S> but as long as the window function is multiplied to @xmath24 , the picture of dc solutions in fig .  </S>",
    "<S> [ fig : rram_f2 ] ( b ) stays the same . and </S>",
    "<S> it is this introduction of unnecessary dc solutions the modelling artifact that limits the rram model s use in simulation analyses .    in our approach </S>",
    "<S> , we try to bound variable @xmath60 while keeping the dc solutions in a single continuous curve , illustrated as the @xmath31 curve in fig .  </S>",
    "<S> [ fig : rram_f2 ] ( c ) . </S>",
    "<S> this is inspired by studying the model template ` hys_example ` in sec .  </S>",
    "<S> [ sec : hys ] . </S>",
    "<S> the sign and zero - crossing of @xmath24 for our rram model are closely related to those of the @xmath24 function ( [ eq : hys_f2 ] ) for ` hys_example ` ( shown in fig .  </S>",
    "<S> [ fig : hys_f2 ] ) .    </S>",
    "<S> the desired @xmath86 solution curve consists of three parts : curve ` a ` and ` c ` contain the stable solutions ; curve ` b ` contains those that are unstable ( or marginally stable ) . in this way , </S>",
    "<S> when sweeping the voltage past zero , variable @xmath60 will start to switch between @xmath81 and @xmath80 . </S>",
    "<S> if the sweeping is fast enough , i - v hysteresis will show up .    to construct the desired @xmath86 solution curve , </S>",
    "<S> we modify the original @xmath24 in ( [ eq : rram_v0_f2 ] ) by adding clipping terms to it . </S>",
    "<S> our new @xmath88 can be written as @xmath89 where @xmath24 is the original function in ( [ eq : rram_v0_f2 ] ) , @xmath90 and @xmath91 are clipping functions : @xmath92    functions @xmath93 and @xmath94 in ( [ eq : rram_v0_fmin ] ) and ( [ eq : rram_v0_fmax ] ) are smooth versions of step functions : @xmath95    the intuition behind @xmath93 and @xmath94 is to make @xmath96 and @xmath97 when @xmath60 is within @xmath98 $ ] ; then @xmath99 when @xmath100 , @xmath101 when @xmath102 .    </S>",
    "<S> when @xmath99 or @xmath101 , the added clipping term in ( [ eq : rram_v0_fmin ] ) or ( [ eq : rram_v0_fmax ] ) is `` in effect '' . either term will first use @xmath103 to cancel out the effect of @xmath24 , then add a fast growing component modelled using exponential functions to ensure that @xmath88 has the desired sign as in fig .  </S>",
    "<S> [ fig : rram_f2 ] ( c ) . </S>",
    "<S> parameter @xmath104 is used to adjust the speed in which these exponential components grow .    </S>",
    "<S> note that in equations ( [ eq : rram_v0_fmin ] ) , ( [ eq : rram_v0_fmax ] ) and ( [ eq : rram_v0_fw1 ] ) , ( [ eq : rram_v0_fw2 ] ) , instead of using normal exponential and step functions , we use @xmath105 and @xmath106 . </S>",
    "<S> these are smooth functions we have developed with better numerical properties than the original ones . </S>",
    "<S> @xmath105 linearises the exponential function from the point its derivative reaches parameter @xmath107 . </S>",
    "<S> @xmath106 is implemented whether as a parameterised @xmath108 , or as @xmath109    issuing commands `` ` help safeexp ; ` '' and `` ` help smoothstep ; ` '' in mapp will display more usage and implementation details of these functions .    </S>",
    "<S> the @xmath88 we have proposed for rram model is smooth and continuous in both @xmath58 and @xmath60 . </S>",
    "<S> its sign and zero - crossings are designed to mimic those shown in fig .  </S>",
    "<S> [ fig : rram_f2 ] ( c ) . by adjusting the parameters @xmath104 and @xmath110 </S>",
    "<S> , users can tune the sharpness of the dc solution curve in fig .  </S>",
    "<S> [ fig : rram_f2 ] ( c ) . </S>",
    "<S> the clipping terms can also leave the values from the original @xmath24 function in ( [ eq : rram_v0_f2 ] ) almost intact when @xmath79 .    while the intention of adding the clipping terms in ( [ eq : rram_v0_f2star ] ) is to set up bounds for variable @xmath60 and to construct dc solution curve in fig .  </S>",
    "<S> [ fig : rram_f2 ] ( c ) , there is also some physical justification to our approach . as a physical quantity , @xmath60 </S>",
    "<S> is indeed bounded by definition . </S>",
    "<S> therefore , @xmath111 can not look like fig .  </S>",
    "<S> [ fig : rram_f2 ] ( a ) in reality . </S>",
    "<S> the @xmath31 curves must have the ` a ` and ` b ` parts in fig .  </S>",
    "<S> [ fig : rram_f2 ] ( c ) . </S>",
    "<S> one can think of the clipping terms as infinite amount of resisting `` force '' to keep @xmath60 from decreasing below @xmath80 , or increasing beyond @xmath81 . </S>",
    "<S> the analogy is the modelling of mems switches , where the switching beam s position is often used as an internal state variable . </S>",
    "<S> this variable reaches its bound when the switching beam hits the opposing electrode ( often the substrate ) . </S>",
    "<S> the position does not move further . </S>",
    "<S> the beam can not move into the electrode / substrate because of the huge force resisting it from causing any shape change in the structures . similarly , in rram modelling , if the variable @xmath60 represents it physical meaning accurately , one can expect such `` forces '' to exist to make it a bounded quantity . </S>",
    "<S> this physics intuition matches well with our proposed numerical technique of using fast growing exponential components to enforce the bounds .    </S>",
    "<S> the compact model we propose for rram devices , with equations ( [ eq : rram_v0_f1 ] ) and ( [ eq : rram_v0_f2star ] ) , complies with the differential equation format . </S>",
    "<S> it uses the correct model template for hysteretic devices proven to work . </S>",
    "<S> the study of the model template and the use of it for rram help us avoid many of the modelling pitfalls at this equation formulation stage . compared with existing models , </S>",
    "<S> our model does not have to use `` ` idt ( ) ` '' </S>",
    "<S> @xcite , or events and functions like `` ` initial_step ` '' , `` ` bound_step ` '' and `` ` abstime ` '' @xcite . </S>",
    "<S> it is not limited to using spice subcircuits written in simulator - dependent syntax @xcite . with our model formulation , for the first time , it is possible to write robust compact models for rram devices in both modspec and verilog - a , that should run consistently on various simulation platforms in different analyses .    </S>",
    "<S> apart from the use in modelling and simulation , our analysis of the rram equations provides important insights into the physical nature of these devices . comparing fig .  </S>",
    "<S> [ fig : hys_f2 ] ( b ) and fig .  </S>",
    "<S> [ fig : rram_f2 ] ( c ) , we note that the @xmath24 function for rram , unlike that of the model template ` hys_example ` , does not have dc solutions folding back with a negative slope . </S>",
    "<S> we can say that there is no `` dc hysteresis '' for these devices . </S>",
    "<S> put in other words , if voltage is swept slowly enough , there will be no i - v hysteresis ; there will only be an abrupt change in @xmath60 at zero voltage . </S>",
    "<S> we would like to clarify that this does not constitute a problem for using rrams as memory devices . because the growth rate of filament is exponential in the input voltage ; only when the voltage is substantially large will the growth be significant . </S>",
    "<S> when the applied voltage is small , it may take years or decades for set and reset to happen . therefore </S>",
    "<S> , the device can still keep its `` memory '' securely . from our analysis , it is this exponential relationship that accounts for the switching voltages measured in rram devices . </S>",
    "<S> but the lack of `` dc hysteresis '' distinguishes rram from the general hysteresis devices like ` hys_example ` . </S>",
    "<S> this provides new perspective to the debate over whether rrams are memristors or not @xcite . </S>",
    "<S> the lack of `` dc hysteresis '' in rram devices explains why they can not cope with inevitable thermal fluctuations and will erratically change state over time in the presence of noise @xcite . </S>",
    "<S> although showing i - v hysteresis curves like a genuine memristor during voltage sweeps , rrams are more like `` chemical capacitors '' as they violate some essential requirements on a genuine memristor @xcite . </S>",
    "<S> it is arguable whether these criticisms are valid . </S>",
    "<S> nevertheless , our analysis in this section explains the difference between ` hys_example ` , a device with true `` dc hysteresis '' and the rram device model vigorously , while being easy to appreciate graphically .      </S>",
    "<S> [ sec : rram_v0_mapp ]    similar to the hys model in sec .  </S>",
    "<S> [ sec : hys ] , we can put the rram equations @xmath23 ( [ eq : rram_v0_f1 ] ) and @xmath88 ( [ eq : rram_v0_f2star ] ) into a compact model by writing them in the modspec format : @xmath112 with @xmath113 $ ] , @xmath114 $ ] , @xmath115 $ ] , @xmath53 $ ] .    </S>",
    "<S> note that there is @xmath116 in the @xmath47 function . </S>",
    "<S> this is to scale the equation for better convergence . </S>",
    "<S> we explain this technique in more detail in sec .  </S>",
    "<S> [ sec : rram_v0_va ] .    </S>",
    "<S> the code in appendix  [ app : rram_v0_modspec_code ] shows how to enter this rram model into mapp .      </S>",
    "<S> [ sec : rram_v0_va ]    having followed the model template discussed in sec .  </S>",
    "<S> [ sec : hys ] and formulated the rram model in the differential equation format in sec .  </S>",
    "<S> [ sec : rram_v0_eqn ] , in this section , we discuss the verilog - a model for rram . </S>",
    "<S> the verilog - a model is show in appendix  [ app : rram_v0_va_code ] .    </S>",
    "<S> same as in the verilog - a model for ` hys_example ` ( sec .  </S>",
    "<S> [ sec : hys_va ] ) , we also model the internal state variable @xmath60 in rram as a voltage . we have discussed why this approach results in more robust verilog - a models compared with many alternatives , _ </S>",
    "<S> e.g. _ , using `` ` idt ( ) ` '' @xcite , implementing time integration inside models @xcite , . in this section </S>",
    "<S> , we would like to highlight from the provided verilog - a code a few more details in our modelling practices .    </S>",
    "<S> @xmath54    in the verilog - a code , we can see that @xmath60 is modelled in nano - meters , as opposed to meters . </S>",
    "<S> this is not an arbitrary choice ; the intention is to bring the value of this variable to around @xmath29 , at the same scale as other voltages in the circuit . </S>",
    "<S> when the simulator solves for an unknown , only a certain accuracy can be achieved , controlled by absolute and relative tolerances . </S>",
    "<S> the abstol in most simulator for voltages is set to be @xmath117v . </S>",
    "<S> if gap is modelled in meters with nominal values around @xmath116 , it wo nt be solved accurately . </S>",
    "<S> apart from the scaling of unknowns , we can also see from the verilog - a code another @xmath116 factor in the implicit equation , scaling down its value . in this rram model , </S>",
    "<S> the implicit equation is represented as the kcl at the internal node . </S>",
    "<S> the equality in kcl is calculated to a certain accuracy as well  often @xmath118a . however , without scaling down , the equation is expressed in nano - meter per second . for rram models , this is a value around @xmath119 . </S>",
    "<S> the simulator has to ensure an accuracy of at least 18 digits such that the kcl is satisfied , which is not necessary and often not achievable with double precision . </S>",
    "<S> so we scale it by @xmath116 to bring its nominal value to around @xmath120 , just like a regular current in a circuit .    </S>",
    "<S> note that when explaining the scaling of unknowns and equations , we are using the units nm or nm / s , mainly for readers to grasp the idea more easily . </S>",
    "<S> it does nt indicate that certain units are more suitable for modelling than others . </S>",
    "<S> the essence of scaling is to make the model work better with simulation tolerances set for unknowns and equations .     </S>",
    "<S> note that in the verilog - a code , we include the standard ` constants.vams ` file and use physical constants from it . </S>",
    "<S> this practice ensures that we are using these constants with their best accuracy ; their values will also be consistent with other models also including ` constants.vams ` . </S>",
    "<S> although this is straightforward to understand , it is often neglected in existing models . </S>",
    "<S> for example , in the model released in @xcite , many constants are used with only two digits of accuracy . </S>",
    "<S> a variable named alpha , which can be calculated with 16 digits , is hard - coded to @xmath121 . since numerical errors propagate through computations , the best accuracy the model can possibly achieve is limited to two digits , and worse if the inaccurate variables are used in non - linear functions .     in the verilog - a code , </S>",
    "<S> we have used ` limexp ` , ` smoothstep ` . as discussed earlier </S>",
    "<S> , these functions help with convergence greatly and are highly recommended for use in compact models .      </S>",
    "<S> [ sec : rram_v0_simulation ] in this section , we simulate the rram model in a test circuit with the same schematic as in fig .  [ fig : vsrc_hys ] . </S>",
    "<S> the transient simulation results are shown in fig .  </S>",
    "<S> [ fig : rram_v0_tran ] , with the i - v relationship plotted in log scale in fig .  </S>",
    "<S> [ fig : rram_v0_tran ] ( b ) . </S>",
    "<S> the results clearly show pinched hysteresis curves .    </S>",
    "<S> the model we develop also work in dc and homotopy analyses . @xmath60-@xmath122 </S>",
    "<S> relationship under dc conditions acquired from homotopy analysis are shown in fig .  </S>",
    "<S> [ fig : rram_v0_homotopy ] . </S>",
    "<S> dc sweeps from both directions in this case give the same results since the model does nt have dc hysteresis . </S>",
    "<S> the @xmath60-@xmath122 curve in fig .  </S>",
    "<S> [ fig : rram_v0_homotopy ] matches our discussion on the @xmath31 solutions in sec .  </S>",
    "<S> [ sec : rram_v0_eqn ] .    </S>",
    "<S> note that in the transient results , gap is not perfectly flat at @xmath80 or @xmath81 ; same phenomenon can also be observed in the dc solutions obtained using homotopy . </S>",
    "<S> this is because that the clipping functions we use , although fast growing , can not set exact hard limits on the internal unknown . in other words , </S>",
    "<S> even when gap is close to @xmath80 or @xmath81 , changing the voltage can still affect gap slightly . </S>",
    "<S> this is not a modelling artifact . </S>",
    "<S> in fact , this makes the model numerically robust , and at the same time more physical . </S>",
    "<S> it maintains the smoothness of equations and reduces the chance for jacobian matrix to become singular in simulation . </S>",
    "<S> physically , even when @xmath60 is close to the boundary , changing voltage still causes the device s state to change . </S>",
    "<S> the small changes in @xmath60 in this scenario can be interpreted as reflecting the change in device s state , _ </S>",
    "<S> e.g. _ , the width of the filament . </S>",
    "<S> we conclude that , by making the model equations smooth , we are actually making the model more physical .    </S>",
    "<S> [ [ section-4 ] ]    [ sec : convergence ]    a common issue with newly - developed compact models of non - linear devices is that they often do not converge in simulation . in this section , </S>",
    "<S> we discuss several techniques in compact modelling that can often improve the convergence of simulation . among these techniques , we focus on the use of spice - compatible limiting functions . </S>",
    "<S> we explain the intuition behind this technique and use this intuition to design a limiting function specific to the rram model .    in the previous sections , </S>",
    "<S> we have already discussed several convergence aiding techniques used in our rram model . </S>",
    "<S> one of them is the proper scaling of both unknowns and equations . </S>",
    "<S> this improves both the accuracy of solutions and the convergence of simulation . </S>",
    "<S> the use of gmin makes sure that the two terminals are always connected with a finite resistance , reducing the chance for the circuit jacobian matrix to become singular during simulation . </S>",
    "<S> we have also discussed the use of smooth and safe functions ( ` smoothstep ( ) ` , ` safeexp ( ) ` ) . </S>",
    "<S> we highly recommend that compact model developers consider these techniques when they encounter convergence issues with their models .    </S>",
    "<S> however , the above techniques do not solve all the convergence problems with the rram model . </S>",
    "<S> in particular , we have observed that the values and derivatives of @xmath23 ( [ eq : rram_v0_f1 ] ) and @xmath24 ( [ eq : rram_v0_f2 ] ) often become very large while the newton raphson ( nr ) iterations @xcite are trying different guesses during dc operating point analysis . </S>",
    "<S> this is because of the fast - growing sinh functions in the equations . </S>",
    "<S> one solution is to use safesinh instead of sinh . </S>",
    "<S> the safesinh function uses safeexp / limexp inside to eliminate the fast - growing part with its linearized version , keeping the function values from exploding numerically . </S>",
    "<S> although it has some physical justifications , it also has the potential problems of inaccuracy , especially since the exponential relationship is the key to the switching behaviour of rram devices ( sec .  </S>",
    "<S> [ sec : rram_v0_eqn ] ) . </S>",
    "<S> therefore , in this section , we focus on another technique that can keep the fast - growing exp or sinh function intact , but prevent nr from evaluating these functions with large input values . </S>",
    "<S> the techniques are known as initialization and limiting ; they were implemented in berkeley spice , for nonlinear devices such as diodes , bjts and mosfets . </S>",
    "<S> initialization evaluates these fast - growing nonlinear equations of semiconductor devices with `` good '' voltage values at the first nr iteration ; limiting changes the nr guesses for these voltages in the subsequent iterations , based on both the current guess at each iteration and the value used in the last evaluation .    </S>",
    "<S> the limiting functions in spice include ` pnjlim ` , ` fetlim ` and ` limvds ` . among them , ` pnjlim ` calculates new p - n junction voltage based on the current nr guess and the last junction voltage being used , in an attempt to avoid evaluating the exp function in the diode equation with large values . </S>",
    "<S> this mechanism is applicable to sinh as well . </S>",
    "<S> inspired by ` pnjlim ` , we design a ` sinhlim ` that can reduce the chance of numerical exposion for the rram model .    </S>",
    "<S> [ fig : pnjlim ]    [ fig : sinhlim ]    ` pnjlim ` calculates the new junction voltage using the mechanism illustrated in fig .  </S>",
    "<S> [ fig : pnjlim ] . </S>",
    "<S> the current nr guess is @xmath123 , which is too large a value for evaluating an exponential function . </S>",
    "<S> so ` pnjlim ` calculates the limited version , @xmath124 , in between @xmath123 and @xmath125 . </S>",
    "<S> since nr linearized the system equation at @xmath125 in the last nr iteration , and the linearization indicates that the new guess is @xmath123 , what nr actually wants is for the p - n junction to generate the current predicted for @xmath123 . because this prediction is based on the linearization at @xmath125 , the actual current at @xmath123 is apparently far larger than it . </S>",
    "<S> therefore , a more sensible choice for the junction voltage should be one that gives out the predicted current . from the above discussion </S>",
    "<S> , we can write an equation for the desired @xmath124 : @xmath126    solving @xmath124 from the above equation , we get the core of ` pnjlim ` . </S>",
    "<S> @xmath127    from the above formula , the operation of ` pnjlim ` is essentially inverting the diode i - v equation to calculate the desired voltage from the predicted current at @xmath125 . based on the same idea , </S>",
    "<S> we can write the limiting function for sinh . as illustrated in fig .  [ fig : sinhlim ] , given @xmath125 and the current guess @xmath123 , we can calculate the desired `` current '' ( function value ) , then invert sinh to get the corresponding @xmath124 for function evaluation . </S>",
    "<S> such an @xmath124 satisfies @xmath128 which gives out the formulation of ` sinhlim ` : @xmath129    this new limiting function ` sinhlim ` can be easily implemented in any spice - compatible circuit simulator . to demonstrate its effectiveness , we implement a simple two - terminal device with its i - v relationship governed by a sinh function , _ </S>",
    "<S> i.e. _ , the device equation is @xmath130 . </S>",
    "<S> as sinh is a rapidly - growing function , even a simple circuit with a series connection of a voltage source , a resistor of @xmath131 and this device may not converge if the supply voltage is large . </S>",
    "<S> this is because when searching for the solution , plain nr algorithm may try large voltage values as inputs to the model s sinh function , resulting difficulties or failure in convergence . </S>",
    "<S> in contrast , spice - compatible nr can use ` sinhlim ` to calculate @xmath124 for use in iterations , preventing using large @xmath123 directly . </S>",
    "<S> we run dc operating point analyses on this simple circuit , with nr starting from all - zeros as initial guesses . as shown in table  [ </S>",
    "<S> tab : sinhiv ] , with the same convergence criteria , the use of ` sinhlim ` improves convergence greatly .    . </S>",
    "<S> [ tab : sinhiv ] [ cols=\"^,^,^\",options=\"header \" , ]     we implement parameterized versions of the ` sinhlim ` function in our rram model to aid convergence ; the code is included in appendix  [ app : rram_v0_modspec_code ] . </S>",
    "<S> since there are two sinh function used in the rram model , in both @xmath23 and @xmath24 , two limited variables are declared in the model , with two ` sinhlim ` with different parameters used in a vectorized limiting function .    </S>",
    "<S> many simulators available today are spice - compatible , in the sense that they implement the equivalent limiting technique as in spice . </S>",
    "<S> however , we would like to note that the limiting functions available in literature today , 40 years after the introduction of spice , are still limited to only the original ` pnjlim ` , ` fetlim ` and ` limvds ` . </S>",
    "<S> the ` sinhlim ` we have developed for rram models , is a new one . </S>",
    "<S> moreover , among all these limiting functions , ` sinhlim ` is the only one that is smooth and continuous , making it more robust to use in simulation .    </S>",
    "<S> [ [ section-5 ] ]    [ sec : memristor ]    in this section , we apply the modelling techniques and methodology we have developed in previous sections to the modelling of general memristive devices . </S>",
    "<S> we use the same model template we have demonstrated in sec .  </S>",
    "<S> [ sec : hys ] , where @xmath23 specifies the device s i - v relationship , @xmath24 describes the dynamics of the internal unknown . for general memristive devices , </S>",
    "<S> there are several equations available for @xmath23 and @xmath24 , from existing models such as the linear and non - linear ion drift models @xcite , simmons tunnelling barrier model @xcite , team / vteam model @xcite , yakopcic s model @xcite , . in this section , </S>",
    "<S> we examine the reason why they do not work well in simulation , especially in dc analysis . </S>",
    "<S> we first summarize the common issues with the @xmath23 and @xmath24 functions used in them , then examine the individual problems of each @xmath23/@xmath24 function , and list our improvements in table  [ tab : f1 ] and table  [ tab : f2 ] .    as discussed earlier , both @xmath23 , the i - v relationship , and @xmath24 , the internal unknown dynamics , are often highly non - linear and asymmetric _ wrt _ positive and negative voltages ; available @xmath23 and @xmath24 functions often use discontinuous and fast - growing components in them , _ </S>",
    "<S> e.g. _ , exponential , sinh functions , power functions with a large exponent , . </S>",
    "<S> these components result in difficulty of convergence in simulation . to overcome these difficulties , similar to what we did in sec .  </S>",
    "<S> [ sec : rram ] for the rram model , we can use smooth and safe functions .    </S>",
    "<S> the key idea of the design of smooth functions is to combine common elementary functions to approximate the original non - smooth ones . </S>",
    "<S> a parameter common to all these functions , _ aka . </S>",
    "<S> _ smoothing factor , is used to control the trade - off between better approximation and more smoothness , which is often synonymous to better convergence . </S>",
    "<S> similar ideas apply to safe functions . for the fast - growing functions , </S>",
    "<S> their `` safe '' versions limit the maximum slope the functions can reach , then linearize the functions to keep the slopes constant beyond those points . for functions that are not defined for all real inputs , </S>",
    "<S> _ e.g. _ , sqrt , log , , their `` safe '' versions clip the inputs using smoothclip such that these functions will never get invalid inputs .    specifically , for the available @xmath23 and @xmath24 functions , the ` if - then - else ` statements can be replaced with smoothswitch . </S>",
    "<S> the exp and sinh functions can be replaced with safeexp and safesinh . </S>",
    "<S> the power functions , _ </S>",
    "<S> e.g. _ , pow(a , b ) , can also be replaced with safeexp(b*safelog(a ) ) .    </S>",
    "<S> we have implemented common smooth and safe functions in mapp . </S>",
    "<S> for example , issuing `` help smoothclip '' within mapp will display more information on the usage of smoothclip . </S>",
    "<S> for verilog - a , we have implemented these smooth and safe functions as `` ` analog functions ` '' , listed them in a separate file in appendix  [ app : smoothfunctions_va_code ] for model developers to use conveniently .    </S>",
    "<S> the use of smooth and safe functions are more than numerical tricks , and they do not necessarily make models less physical . on the contrary , physical systems are usually smooth . </S>",
    "<S> for example , when switching the voltage of a two - terminal device across zero , the current should change continuously and smoothly . </S>",
    "<S> therefore , compared with the original ` if - then - else ` statements , the smoothswitch version is likely to be closer to physical reality . </S>",
    "<S> the same applies to the safe functions we use in our models . </S>",
    "<S> for example , there are no perfect exponential relationships in physical reality </S>",
    "<S> . even the growth rate of bacteria , which is often characterized as exponential in time , will saturate eventually . </S>",
    "<S> another quantity often modelled using exponential functions is the current through a p - n junction . when the voltage indeed becomes large </S>",
    "<S> , the junction does nt really give out next to infinite current . </S>",
    "<S> instead , other factors come into play  the temperature will become too high that the structure will melt . </S>",
    "<S> this is not considered when writing the exponential i - v relationship ; the use of exponential function is not to capture the physics exactly , but more an approximation and simplification of physical reality . </S>",
    "<S> so the use of safeexp and safesinh is more than just a means to prevent numerical explosion , but also a fix to the original over - simplified models .     </S>",
    "<S> improved @xmath23 * + 1 & @xmath132 & can have division - by - zero when @xmath133 . </S>",
    "<S> we use @xmath134 then @xmath135 + 2 & @xmath136 & we change exponential function to ` safeexp ( ) ` . </S>",
    "<S> + 3 & @xmath137 & we change sinh to ` safesinh ( ) ` , exponential function to ` safeexp ( ) ` . </S>",
    "<S> + 4 & @xmath138 & we change sinh to ` safesinh ( ) ` , then smooth the function . </S>",
    "<S> @xmath139 @xmath140 @xmath141 + 5 & @xmath142 & we express @xmath143 using @xmath32 : @xmath144 then we change sinh to ` safesinh ( ) ` , exponential function to ` safeexp ( ) ` . </S>",
    "<S> +    one common problem with existing @xmath24 functions is the range of the internal unknown . </S>",
    "<S> we have discussed this problem in sec .  </S>",
    "<S> [ sec : rram ] in the context of rram device models . </S>",
    "<S> the @xmath24 functions available either neglect this issue or use window functions to set the bounds for the internal unknown . from the discussion in sec .  </S>",
    "<S> [ sec : rram ] , using window functions introduces modelling artifacts that limit the usage of the model to only transient simulation . to fix this problem </S>",
    "<S> , we apply the same modelling technique using clipping functions in our memristor models .     </S>",
    "<S> improved @xmath24 * + 1 & linear ion drift model : @xmath145 & no dc hysteresis . does nt ensure @xmath146 . </S>",
    "<S> we use the clipping technique to set bounds for @xmath32 . </S>",
    "<S> + 2 & nonlinear ion drift model : @xmath147 & no dc hysteresis . does nt ensure @xmath146 . </S>",
    "<S> we use the clipping technique to set bounds for @xmath32 . </S>",
    "<S> + 3 & simmons tunnelling barrier model : @xmath148 where @xmath149 . & no dc hysteresis . does nt ensure @xmath146 . </S>",
    "<S> contains fast - growing functions . </S>",
    "<S> we change sinh to ` safesinh ( ) ` , exponential function to ` safeexp ( ) ` , then implement the smooth version of this ` if - then - else ` statement . </S>",
    "<S> we use the clipping technique to set bounds for @xmath32 . </S>",
    "<S> + 4 & vteam model : @xmath150 & dc hysteresis is modelled by a @xmath86 flat region . </S>",
    "<S> we redesign the equation based on fig .  </S>",
    "<S> [ fig : memristor_f2 ] . </S>",
    "<S> @xmath151 where @xmath152 such that when @xmath153 and @xmath154 , it is equivalent to vteam equation in the @xmath155 and @xmath156 regions respectively . </S>",
    "<S> we also make the function smooth : @xmath157 @xmath158 @xmath159 and finally , we use the clipping technique to set bounds for @xmath32 . </S>",
    "<S> + 5 & yakopcic s model : @xmath160 where @xmath161 and @xmath162 & dc hysteresis is modelled by a @xmath86 flat region . </S>",
    "<S> we redesign the equation based on fig .  </S>",
    "<S> [ fig : memristor_f2 ] . </S>",
    "<S> @xmath163 where @xmath164    we also change exponential function to ` safeexp ( ) ` , make the function smooth , then use the clipping technique to set bounds for @xmath32 . </S>",
    "<S> + 6 & standford / asu rram model : @xmath165 where @xmath166 & we convert @xmath167 to @xmath168 : @xmath169 then we change sinh to ` safesinh ( ) ` , exponential function to ` safeexp ( ) ` . </S>",
    "<S> we also use the clipping technique to set bounds for @xmath32 . </S>",
    "<S> +    another problem with the available @xmath24 functions is the way they handle dc hysteresis . as discussed earlier </S>",
    "<S> , dc hysteresis is observed in forward and backward dc sweeps ; it accounts for the pinched i - v curves when voltage is moving infinitely slow . from the model example ` hys_example ` in sec .  </S>",
    "<S> [ sec : hys ] , we can conclude that dc hysteresis results from the model s dc solution curve folding backward in voltage , which creates multiple stable solutions of internal state variable at certain voltages . </S>",
    "<S> in fact , from the equations of team / vteam model and yakopcic s model , we can see an attempt to model dc hysteresis . however , the way it is done in both these models is to set @xmath86 within a certain voltage range , _ </S>",
    "<S> e.g. _ , when voltage is close to 0 . in this way , </S>",
    "<S> as long as the voltage is within this range , there are infinitely many solutions for the model , regardless of values of @xmath32 . during transient simulation </S>",
    "<S> , @xmath32 will just keep its old value from the previous time point . in dc analysis , if @xmath32 also keeps its old value from the last sweeping point , there can be dc hysteresis . </S>",
    "<S> however , since @xmath32 actually has infinitely many solutions within this voltage range , the equation system becomes ill - conditioned . </S>",
    "<S> the circuit jacobian matrix can also become singular , since @xmath32 has no control over the value of @xmath24 . </S>",
    "<S> homotopy analysis wo nt work with these device models since there is no solution curve to track . even in dc </S>",
    "<S> operating point ( op ) analysis , the op can have a random @xmath32 as part of the solution , depending on the initial condition , and if it is not provided , on how the op analysis is implemented . </S>",
    "<S> dc sweep results also depend on how dc sweep is written , particularly on the way the old values are used as initial guesses for current steps . may not stay flat . ] in other words , because of the model is ill - conditioned </S>",
    "<S> , the behaviour of the model is specific to the implementation of the analysis and will vary from simulator to simulator . to fix this problem , </S>",
    "<S> we modify the available @xmath24 functions such that the @xmath86 solutions form a single curve in state space , as illustrated in fig .  </S>",
    "<S> [ fig : memristor_f2 ] ( b ) . for each model , this requires different modifications specific to its equations ; we list more detailed descriptions of these modifications in table  [ tab : f2 ] .    to summarize the problems with existing memristor models and our solutions to them , we fix the nonsmoothness and overflow problems of the existing equations with smooth and safe functions ; </S>",
    "<S> we fix the internal state boundry problem with the same clipping function technique we have used for the rram model ; we fix the `` flat '' @xmath24 problem by properly implementing the @xmath86 curve that bends backward for the modelling of dc hysteresis . </S>",
    "<S> table  [ tab : f1 ] and table  [ tab : f2 ] list our approaches in improving the available @xmath23 and @xmath24 functions in more detail . </S>",
    "<S> the result is a collection of memristor models , controlled by two variables ( which can be thought of as higher - level model parameters ) , f1_switch and f2_switch . </S>",
    "<S> all the combinations of 5 @xmath23 functions and 6 @xmath24 functions constitute 30 compact models for various types of memristors . </S>",
    "<S> different @xmath23 and @xmath24 functions describe different underlying physics of the devices , with different levels of accuracy . </S>",
    "<S> we would like to note that one particular combination  f1_switch = 5 , f2_switch = 6 , is equivalent to the rram model we have discussed in sec .  [ </S>",
    "<S> sec : rram ] .    apart from this combination for rram devices , several other combinations in the general memristor model can also be used for rram devices . </S>",
    "<S> for example , when f2_switch = 5 and f2_switch = 4 , our proposed model uses the improved equations from the vteam and yakopcic s models . </S>",
    "<S> the range of the dc hysteresis in these models is controlled by two threshold voltages , _ </S>",
    "<S> e.g. _ , @xmath170 and @xmath171 for yakopcic s model , @xmath172 and @xmath173 for vteam model . when both these two thresholds are equal to zero , the dc hysteresis disappears , and the models are suitable for rram devices . </S>",
    "<S> also , when the two threshold voltages have the same sign , these models can also be used for unipolar memristive devices . </S>",
    "<S> they are more general and flexible than the model equations we have discussed in sec .  </S>",
    "<S> [ sec : rram ] written only for bipolar rram devices . </S>",
    "<S> the ideas and techniques underlying these models are likely to also be applicable to new memristive devices and model equations to be developed in the future .    </S>",
    "<S> [ fig : memristor_osc ]    [ fig : memristor_osc_tran ]    the modspec and verilog - a files of the proposed general memristor models are listed in appendix  [ app : memristor_modspec_code ] and appendix  [ app : memristor_va_code ] respectively . </S>",
    "<S> they can be used in the same test benches for rrams in sec .  </S>",
    "<S> [ sec : rram ] . </S>",
    "<S> their parameters can also be fitted to generate similar results in fig .  </S>",
    "<S> [ fig : rram_v0_tran ] and fig .  </S>",
    "<S> [ fig : rram_v0_homotopy ] . as an extra example </S>",
    "<S> , we use f1_switch=2 , f2_switch=5 , corresponding to the improved yakopcic model , and adjust its parameters for a unipolar rram device , connect it with a resistor as shown in fig .  </S>",
    "<S> [ fig : memristor_osc ] to make an oscillator . </S>",
    "<S> then we run both transient simulation and pss analysis with harmonic balance and show their results in fig .  </S>",
    "<S> [ fig : memristor_osc_tran ] and fig .  </S>",
    "<S> [ fig : memristor_hb ] . </S>",
    "<S> these results demonstrate that our model not only run in dc , transient and homotopy analyses , but also work for pss simulation .    </S>",
    "<S> [ [ section-6 ] ]    [ sec : conclusion ]    our study in this paper centers around the compact modelling of memristive devices . </S>",
    "<S> memristor models available today do not work well in simulation , especially in dc analysis . </S>",
    "<S> their problems come from several main sources . </S>",
    "<S> firstly , some models are not in the differential equation format ; they are essentially hybrid models with memory states used for hysteresis . </S>",
    "<S> we clarified that the proper modelling of hysteresis should be achieved through the use of an internal state variable and an implicit equation . to make this concept clear </S>",
    "<S> , we developed a model template and implemented an example , namely ` hys_example ` , in both modspec and verilog - a . during this process </S>",
    "<S> , we examined the common mistakes model developers make when writing internal unknowns and implicit equations in the verilog - a language . </S>",
    "<S> then we applied the model template to model rram devices , which led to another common difficulty in memristor modelling  enforcing the upper and lower bounds of the internal unknown . </S>",
    "<S> we proposed numerical techniques with clipping functions that can modify the filament growth equation such that the bounds are respected in simulation . </S>",
    "<S> we also discussed the physical justification behind our approaches . </S>",
    "<S> then we demonstrated that the same techniques can be applied to fix the similar problems with many other existing memristor models . as a result , </S>",
    "<S> we not only developed a suite of 30 memristor models , all tested to work with many simulation analyses in major simulators , but also took this process as an opportunity to identify and document many good and bad modelling practices . </S>",
    "<S> both the resulting models and the techniques used in developing them should be valuable to the compact modelling community .    _ </S>",
    "<S> = _ _ _ _ _ </S>"
  ]
}