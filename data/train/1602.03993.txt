{
  "article_text": [
    "let @xmath0 be a field and let @xmath1 $ ] be a polynomial ring in @xmath2 indeterminates .",
    "then let @xmath3 be elements in the field @xmath4 , where @xmath5 is another set of indeterminates which are viewed as parameters .",
    "we consider the @xmath0-algebra homomorphism @xmath6 \\to k(t_1 , \\dots , t_s ) \\hbox{\\rm \\quad given by\\quad }   x_i \\mapsto f_i \\hbox{\\rm \\quad   for\\ }   i=1 , \\dots , n\\ ] ] its kernel , which will be denoted by @xmath7 , is a prime ideal , and the general problem of implicitization is to find a set of generators for this ideal .",
    "the task of computing @xmath7 can be solved by computing a suitable grbner basis ( see proposition  [ prop : implicitintersection ] ) . however , in practice this method does not work well since in most non - trivial cases it is far too slow .",
    "the poor computational speed is aggravated when computing with rational coefficients ( rather than coefficients from a finite field ) .",
    "there is definitely a big need for new , efficient techniques , and many authors have investigated alternative ways .",
    "the literature about implicitization is so vast that it is almost impossible to mention the entire body of research on this topic .",
    "this interest derives from the fact that the parametric representation of a rational variety is important for generating points on it , while the implicit representation is used to check whether a point lies on it . besides its theoretical importance",
    ", the double representation of a rational variety is used intensively for instance in computer aided geometric design . a  good source of bibliography",
    "up to ten years ago is  @xcite .",
    "more recently , new ideas have emerged . as we said , it is almost impossible to cite all of them , and we content ourselves to mention a few .",
    "in particular , new methods for computing implicitizations have been described in  @xcite , @xcite , @xcite , and @xcite .",
    "some of these new ideas respond to the fact that in many cases the computation of @xmath7 is too hard , hence one seeks a way to check whether a point lies on the rational variety without actually computing its equations .",
    "so , what is the content of this paper ? and what are the novelties and the new algorithms presented here ?",
    "first of all , we concentrate on the `` hypersurface case '' where @xmath7 is a principal ideal , and hence generated by an irreducible polynomial which is therefore unique up to an invertible constant factor .",
    "[ rem : s = n-1 ] let  @xmath8 be the ideal @xmath7 and let  @xmath9 be the minimum number of generators for  @xmath8 . from the facts that @xmath10 ) \\le \\dim(k[t_1,\\dots , t_s ] )",
    "= s$ ] and @xmath10 ) = \\dim(k[x_1,\\dots , x_n]/i ) \\ge n - m$ ] it follows that @xmath11 .",
    "so , whenever @xmath12 then  @xmath8 has at least one generator , and in particular  @xmath8 is non - zero .",
    "the hypersurface case typically arises when @xmath13 , in accordance with the remark above .",
    "however , this is not always the case , as the following examples show .",
    "[ ex : bad - parametrizations ] we consider the `` atypical '' case where @xmath14 and @xmath15 .",
    "clearly we have @xmath16 , which is obviously principal .",
    "this does , however , become a typical case if we use a `` better parametrization '' in terms of @xmath17 , where we then have @xmath18 , and consequently also have @xmath13 with this better parametrization .",
    "another `` atypical '' example is the following .",
    "let @xmath19 , @xmath20 and @xmath21 , @xmath22 , @xmath23 . here",
    "we do have @xmath13 but the implicitization is not principal , in fact it turns out that @xmath24 .",
    "the reason here is that there is a `` better parametrization '' in terms of @xmath25 , where we have @xmath26 , @xmath27 , @xmath28 ; and with this better parametrization we have @xmath29 .    in this paper",
    "we do not examine the interesting question of finding a good parametrization , which is a problem of a quite different nature .",
    "the ideas explored in this paper can be summarized in the following way :    * exploit homogenization to improve elimination ( ratpar , elimth ) : + using elimination is known to be an elegant but impractical way to achieve implicitization .",
    "we show that any problem ( polynomial or rational parametrization ) can be homogenized ( see proposition  [ prop : homogpoly ] and theorem  [ th : homogfractions ] ) .",
    "thereafter , the result is given by the first polynomial not involving any of the parameters , so the computation can be stopped as soon as it is found , avoiding the remaining `` useless reductions '' .",
    "* use a direct algorithm which does not need elimination ( direct ) : + wang in  @xcite described an algorithm based on searching for a linear relationship among the images of the power - products .",
    "we refine this idea and make it incremental , thus leading to several important insights and opimizations ( see subsection  [ sec : direct ] ) .",
    "* when the coefficient field is @xmath30 use modular methods ( modimplicit ) : + computing the solution polynomial modulo several primes , and then obtaining the solution over @xmath30 by chinese remaindering is a powerful tool , but needs to be fine - tuned to any specific context . in section  [ sec : rationalreconstruction ]",
    "we use an incremental approach combined with fault - tolerant rational reconstruction to resolve the problem of how many primes are needed and to `` tolerate '' computations with bad primes ( some of which can not be detected _ a priori _ ) .",
    "regarding the first item , one of the referees pointed out that we made no reference to the _ `` projective view of the implicitization problem , which is relatively classical''_. the main reason was to avoid complications for the typical computer - algebra people who , generally , are much more familiar with algebra than geometry .",
    "nevertheless , let us give some hints in this direction to the interested reader .",
    "if @xmath31 $ ] then the map  @xmath32 can be seen as the algebraic counterpart of the map of the affine schemes @xmath33 .",
    "we let @xmath34 for @xmath35 , then homogenize the @xmath36 with a new indeterminate @xmath37 such that @xmath38 , and set @xmath39 .",
    "now we consider the projective space @xmath40 with coordinates @xmath41 and the weighted projective space @xmath42 with coordinates @xmath43 ( see for instance  @xcite for an introduction to the theory of weighted projective spaces ) .",
    "the map  @xmath44 can be viewed as the restriction to @xmath45 of the _ rational map _",
    "@xmath46 given by @xmath47 \\to [ f_1\\homh : f_2\\homh:\\cdots : f_s\\homh : h]$ ] .",
    "observe that  @xmath48 is a rational map , but not necessarily a map , since it may have a non - trivial base locus . the algebraic explanation of this fact is exactly the proof of proposition  [ prop : homogpoly ] .    the situation is more complicated when @xmath49 . using a common denominator , we may assume that @xmath50 with @xmath51 $ ] for @xmath52 .",
    "if we let  @xmath53 denote the open subscheme @xmath54 , then  @xmath32 can be seen as the algebraic counterpart of the map of affine schemes @xmath55 , and the standard way to proceed is to take care of this limitation , as explained in remark  [ rem : generalfrac ] .",
    "but there is a different way to interpret @xmath56 .",
    "we let @xmath57 for @xmath58 and @xmath59 .",
    "then we let @xmath60 , let @xmath61 , @xmath62 for @xmath58 ( see definition  [ def : homd ] ) , so that all the polynomials @xmath63 are homogeneous of the same degree @xmath64 .",
    "next we consider the projective space @xmath40 with coordinates @xmath41 and the projective space @xmath65 with coordinates @xmath66 .",
    "if we let @xmath67 be the affine open chart of @xmath65 defined by @xmath68 , the map @xmath44 can be interpreted as the restriction to @xmath53 of the corresponding rational map @xmath69 defined by @xmath47 \\to [ q : p_1:\\cdots : p_s]$ ] .",
    "the algebraic explanation of this fact is exactly the proof of theorem  [ th : homogfractions ] .",
    "why not try to use other embeddings into suitable projective or weighted projective spaces , as we do in the case of polynomial parametrizations ?",
    "the reason is explained in all the remarks and examples following theorem  [ th : homogfractions ] .",
    "there is a further idea : computing implicitizations with constraints , in particular using a method of `` slicing '' the variety with suitable parallel hyperplanes .",
    "this technique was introduced and used in  @xcite .",
    "however , it is rarely better than our new methods when @xmath7 is a hypersurface .",
    "we shall investigate the `` implicitizations with constraints '' for the general case in a later paper .",
    "the algorithms described in this paper are implemented in cocoalib  @xcite , and are also available in 5  @xcite . with our new methods",
    "most of the examples mentioned in the literature become `` easy '' , that is we can compute the implicitization in less than a second    see table  @xmath70 in section  [ timings ] .",
    "consequently , we introduce new , challenging examples , and the last table shows the performance of our implementation .    we thank the referees for their useful comments and suggestions which helped us to improve this paper .",
    "here we introduce the notation and terminology we shall use .    [ def : elimideal ] let @xmath0 be a field , and let @xmath71}}$ ] be a polynomial ring in  @xmath2 indeterminates .",
    "let @xmath72 be further indeterminates which are viewed as `` parameters '' . given elements @xmath3 in @xmath73}}$",
    "] , we define the ideal @xmath74 of the ring @xmath75 $ ] to be the * eliminating ideal * of the @xmath2-tuple @xmath76 .    we define @xmath7 to be the kernel of the @xmath0-algebra homomorphism @xmath77}}}$ ] which sends @xmath78 .",
    "[ def : elimrat ] we extend naturally definition  [ def : elimideal ] to parametrizations by rational functions .",
    "let @xmath79 be rational functions in the field @xmath4 with common denominator @xmath80 ; so that we have @xmath81}}$ ] .",
    "we define @xmath82 to be the kernel of the @xmath0-algebra homomorphism @xmath83 which sends @xmath84 for @xmath58 .",
    "an * enumerativeordering * is a total ordering such that for every element there are only finitely many elements smaller than it .",
    "in particular , an * enumerativeterm - ordering * is a term - ordering which is also enumerative ; consequently , an enumerativeterm - ordering is defined by a matrix with strictly positive entries in the first row .",
    "any degree - compatible term - ordering is enumerativebecause for any power - product  @xmath85 all smaller power - products , @xmath86 , must have @xmath87 , and so they are finite in number .",
    "in contrast , the lex - ordering ( for 2 or more indeterminates ) is not enumerativebecause if indeterminate @xmath88 is less than @xmath89 then all powers @xmath90 are smaller than @xmath89 .",
    "[ def : homd ] in section  [ sec : param - by - ratfns ] we shall use two different kinds of homogenization :    * traditional * homogenization * and * dehomogenization * : with respect to  @xmath37 we denote them by the superscripts  @xmath91 and  @xmath92 respectively ; and with respect to @xmath93 , by the superscripts  @xmath94 and  @xmath95 . * * @xmath64-shifted - homogenization * : for a non - zero polynomial  @xmath96 and degree @xmath97 we write @xmath98 to mean @xmath99 , which is a homogeneous polynomial of degree  @xmath64 . as a special case , since @xmath100 , we have @xmath101 for all  @xmath64 .    the following easy properties of the shifted - homogenization will help the reader understand the proof of theorem  [ th : homogfractions ]    [ lemma : homogfractions ] let @xmath102 be a polynomial ring over the field  @xmath0 , and let @xmath103 .    * if @xmath104 and @xmath105 then @xmath106 * if @xmath107 and @xmath108 then @xmath109    the proofs are elementary exercises in algebra .",
    "observe that the special definition @xmath101 is indeed compatible with this lemma , since from the equality @xmath110 we deduce the equalities @xmath111 .",
    "in this section we consider a parametrization given by polynomials @xmath112 in the ring @xmath113 $ ] , where @xmath5 is a set of indeterminates which are viewed as parameters .",
    "we will look at parametrizations by rational functions in section  [ sec : param - by - ratfns ] .",
    "[ prop : implicitintersection ] in the setting of definition  [ def : elimideal ] :    1 .",
    "we have @xmath114 .",
    "the ideal @xmath7 can be computed using an elimination ordering for all the @xmath115 .",
    "the ideal @xmath7 is prime .",
    "claims ( a ) and ( b ) are standard results ( see for instance book  @xcite , section 3.4 ) .",
    "claim  ( c ) follows from the isomorphism @xmath116/j",
    "\\cong k[t_1 , \\dots t_s]$ ] , whence  @xmath117 is prime , and so @xmath118 is prime too .",
    "[ rem : exclude - constants ] we shall later find it convenient to assume that in the parametrization no @xmath119 maps to a constant .",
    "this is not a restriction because if , say , @xmath120 then we obtain the simple decomposition : @xmath121 . thus any indeterminates @xmath119 which map to constants can simply be taken out of consideration , letting us concentrate on the interesting part .",
    "henceforth we shall assume that none of the @xmath36 is constant .",
    "the very construction of the eliminating ideal ( in definition  [ def : elimideal ] ) looks intrinsically non - homogeneous . and",
    "it is well - known that the behaviour of buchberger s algorithm can be quite erratic when the input is not homogeneous : usually the computation for a non - homogeneous input is a lot slower than a `` similar '' homogeneous computation ( though there are sporadic exceptions ) ; for instance , see example  [ ex0 ] .",
    "we now look quickly at how to use homogenization during implicitization .    a first idea is to give weights to the @xmath119 indeterminates by setting @xmath122 for each  @xmath123 . if we do so , and if the original @xmath36 are homogeneous polynomials , then the eliminating ideal  @xmath117 turns out to be a homogeneous ideal .",
    "even when the @xmath36 are not all homogeneous , in the process of ordering and choosing the power - products of a given degree , we may reasonably expect that buchberger s algorithm will `` behave '' more similarly to a homogeneous ideal than with the _ standard grading _",
    ", where all indeterminates have degree  1 .    although this trick improves the computation in most cases , it is not a miraculous panacea .",
    "much better ideas come from the following proposition  [ prop : homogpoly ] and theorem  [ th : homogfractions ] which reduce the computation of the implicitization ideal to the case of prime ideals whose generators are homogeneous polynomials .    in the proofs we use the fundamental properties of homogenization and dehomogenization as described in  @xcite , section 4.3 .",
    "a general discussion about the topic treated in the following proposition can be found in  @xcite , tutorial 51 .    in the proposition below we use a single homogenizing indeterminate  @xmath37 ; so , to simplify notation , homogenization and dehomogenization are tacitly taken with respect to  @xmath37 .    [",
    "prop : homogpoly]*(implicitizating polynomial parametrizations by homogenization ) * + let @xmath124 $ ] , let @xmath125}}\\setminus k$ ] . now let  @xmath37 be a new indeterminate , and let @xmath126 $ ] be graded by setting @xmath127 for @xmath128 and @xmath129 .",
    "finally let @xmath130 , and let @xmath131 be the eliminating ideal of @xmath132 . then :    1 .",
    "the ideal @xmath133 $ ] is prime .",
    "we have the equality @xmath134)\\deh$ ] .",
    "the proof of claim ( a ) follows immediately from the fact that @xmath131 is an eliminating ideal , hence prime .",
    "let  @xmath117 be the ( non - homogeneous ) eliminating ideal of the tuple @xmath76 .",
    "now , since @xmath131 is prime , it is saturated with respect to  @xmath37 ; furthermore we have @xmath135 , so we can deduce that @xmath136 .",
    "clearly @xmath137 = \\bar{j}\\cap p[h]$ ] , hence , by dehomogenizing , we deduce that @xmath138)\\deh$ ] . on the other hand ,",
    "if @xmath139)\\deh$ ] then we have @xmath140 , but @xmath141 , and the proof is complete since @xmath114 by proposition  [ prop : implicitintersection].a .",
    "in this section we start to treat the `` hypersurface case '' , namely the case where it is known that the implicitization ideal is principal . in this situation",
    "we typically have @xmath13 , although this equality is not equivalent to the implicitization being a principal ideal , as shown in example  [ ex : bad - parametrizations ] .",
    "there is no easy way to determine whether the implicitization is going to be a principal ideal , but this information might already be independently known for the particular example under consideration .",
    "so this is usually taken as hypothesis by the papers on this topic .",
    "as already observed , the ideal @xmath131 in proposition  [ prop : homogpoly ] is homogeneous , hence the computation of the ( elimination ) grbner basis of  @xmath131 can be performed degree by degree .",
    "moreover , using the methods described in proposition  [ prop : homogpoly ] we get the following extra bonus in the hypersurface case : as soon as we obtain a grbner basis element , @xmath142 , which does not involve the parameters , we may stop the computation of the grbner basis because the solution polynomial is just the dehomogenization of  @xmath142 .",
    "[ cor : princpoly ] with the same assumptions as in proposition  [ prop : homogpoly ] , if @xmath143 is a principal ideal generated by  @xmath144 then @xmath145 is a principal ideal generated by  @xmath146 .",
    "we recall the equality @xmath147)\\deh$ ] proved in proposition  [ prop : homogpoly].b .",
    "this implies that @xmath148)\\deh = { \\langle   g   \\rangle}$ ] .",
    "conversely , the ideal @xmath133 $ ] is prime by proposition  [ prop : homogpoly].a , hence it is saturated with respect to  @xmath37 , and so it is generated by @xmath146 .",
    "[ alg : elimth ] * ( elimth : truncated homogeneous elimination ) *    input : :    @xmath149}}\\setminus k$ ] such    that the ideal @xmath143 is    principal .",
    "elimth-1 : :    initialization :    +    elimth-1.1 ; ;      create the polynomial ring      @xmath150 $ ] graded by      @xmath151 $ ] .",
    "+      let @xmath152 be an elimination ordering for      @xmath153 on  @xmath154 .",
    "elimth-1.2 ; ;      let @xmath155 .",
    "elimth-1.3 ; ;      let @xmath156 , the      eliminating ideal of @xmath157 .",
    "elimth-2 : :    _ main loop : _",
    "+    start buchberger s",
    "algorithm for the computation of a    @xmath152-grbner basis  @xmath158    of  @xmath117 .",
    "+    perform its main loop degree by degree ( _ i.e. _  always choose the    lowest degree pair ) . +    when you add to @xmath158 the first polynomial  @xmath142    such that @xmath159 is not divisible by any    @xmath115 exit from loop .",
    "elimth-3 : :    let @xmath160 mapped into    @xmath161 $ ] .",
    "output : :    @xmath162 $ ]    then @xmath163 generates @xmath143 .",
    "_ termination _ : the _ main loop _ in the algorithm is simply buchberger s algorithm , and that terminates in a finite number of steps .",
    "moreover , corollary  [ cor : princpoly ] guarantees that @xmath131 contains a polynomial not involving the @xmath115 indeterminates , and since @xmath152 is an elimination ordering for the @xmath115 there is such a polynomial in the grbner basis , so the _ main loop _ will set  @xmath142 and exit .    _",
    "correctness : _ in the _ main loop _",
    "we execute buchberger s algorithm with respect to an elimination ordering for all the @xmath115 ; thus the elements of the grbner basis whose leading terms are not divisible by any @xmath115 form a grbner basis for the elimination ideal @xmath164 $ ] . by corollary  [ cor : princpoly ]",
    "this ideal is principal , so buchberger s algorithm ( computing degree by degree ) will produce exactly one polynomial whose leading term is not divisible by any @xmath115 .",
    "the _ main loop _ stops as soon as this polynomial is found . in step * elimth-3 * the polynomial  @xmath142 will be the generator of @xmath145 , and by corollary  [ cor : princpoly ] we have that @xmath160 is the generator of @xmath143 .",
    "[ rem : elimth - bad - input ]    we consider briefly what happens if the input to algorithm  [ alg : elimth ]  ( elimth ) does not correspond to a principal implicitization ideal .",
    "if @xmath143 is the zero ideal then buchberger s algorithm in step * elimth-2 * will terminate without finding any candidate for  @xmath142 ; we could in that case simply set @xmath165 . by remark  [ rem : s = n-1",
    "] this can not happen if @xmath12 .    if , instead , @xmath143 is non - zero and non - principal then the polynomial  @xmath142 found in step * elimth-2 * will be a lowest weighted - degree element of a grbner basis for that ideal ( and consequently a lowest weighted - degree non - zero element of the ideal ) .",
    "this next example illustrates the good behaviour of the algorithm above .",
    "[ ex0 ] we let @xmath166 and in the ring @xmath167 $ ] we consider the eliminating ideal @xmath168 the usual elimination of  @xmath169 takes more than one hour , even if we give the weights @xmath170 and @xmath171 to the indeterminates @xmath89 , @xmath88 respectively ; whereas the truncated homogeneous elimination takes less than a second ( this is one of our test cases : see example  [ ex12abr - poly ] ) .",
    "the solution polynomial has 176 power - products in its support .",
    "if the eliminating ideal is not homogeneous , the idea of truncating the computation as soon as a polynomial in  @xmath102 is found does not work well , since it may happen that the first such polynomial computed by the algorithm is a proper multiple of the solution polynomial .",
    "the phenomenon is similar to the case where the reduced grbner basis of an ideal is  @xmath172 , yet before discovering that  @xmath70 is in the basis it often happens that many other ( non - reduced ) grbner basis elements are computed .",
    "one could take the polynomial found and factorize it , then substitute into the various irreducible factors to see which factor is the good one .",
    "but this is unlikely to be efficient .",
    "we briefly recall the setting of this paper : we have been given a @xmath0-algebra homomorphism @xmath173 { \\longrightarrow } { { k[t_1,\\dots , t_s]}}$ ] sending @xmath174 and we assume that its kernel is a principal ideal : the problem is to find the generator of @xmath175 . following remark  [ rem : exclude - constants ] , we shall find it convenient to assume that each @xmath176}}$ ] is non - constant . in this section",
    "we compute the polynomial  @xmath144 via a _",
    "direct _ approach .",
    "we use the notation @xmath177 to indicate the leading power - product of the polynomial  @xmath96 ( also denoted in the literature by @xmath178 of @xmath179 ) . if @xmath180 , with distinct power - products @xmath181 , then the * support * of  @xmath96 is @xmath182 @xmath183 .",
    "[ rem : lindep ] first of all notice that , if a polynomial @xmath184}}$ ] is such that @xmath185 , then @xmath186 . in other words , there is a @xmath0-linear dependency among the image polynomials @xmath187}}$ ] , and the coefficients of the linear relation are exactly the coefficients of  @xmath96 ( up to a scalar multiple ) .",
    "the idea behind our direct approach is to _ directly _ determine @xmath144 by searching for a linear dependency among all the @xmath188 : we generate , one by one , the polynomials @xmath188 as @xmath189 runs through the power - products in @xmath190}}$ ] until a dependency exists .",
    "we shall now see how to reduce this apparently infinite problem to a finite , tractable one .",
    "[ alg : direct ] * ( direct : implicitization by direct search ) *    input : :    @xmath191}}$ ] such that the    ideal @xmath143 is    principal .",
    "variables : :    the main variables are :    +    @xmath192 : ; ;      the list of power - products in @xmath190}}$ ]      already considered .",
    "@xmath193 : ; ;      the list of power - products in @xmath190}}$ ] yet      to be considered .",
    "@xmath194 : ; ;      the list @xmath195 $ ] ;      its elements are seen as `` sparse vectors '' in the infinite      dimensional @xmath0-vector space      @xmath73}}$ ] with basis comprising all      power - products .",
    "direct-1 : :    _ initialization : _",
    "+    direct-1.1 ; ;      fix an enumerativeterm - ordering @xmath152 on      @xmath190}}$ ] .",
    "direct-1.2 ; ;      set @xmath196 . set      @xmath197 . set      @xmath198 .",
    "direct-2 : :    _ main loop : _",
    "+    direct-2.1 ; ;      let @xmath199 .",
    "remove      @xmath189 from @xmath193 .",
    "direct-2.2 ; ;      compute @xmath200}}$ ] .",
    "direct-2.3 ; ;      is there a linear dependency @xmath201 with      @xmath202 and @xmath203 ?      +      yes : :        exit from loop      no : :        add to @xmath193 the elements of        @xmath204 not already        in  @xmath193 ; +        append @xmath189 to the list        @xmath192 ; append @xmath205 to the list        @xmath194 direct-3 : :    let @xmath206 where    @xmath207 corresponds to    @xmath203 .",
    "output : :    @xmath208}}$ ]    then @xmath163 generates @xmath143 .",
    "_ termination : _ the main loop of the algorithm considers the power - products in the ring @xmath190}}$ ] in increasing @xmath152-order until the condition in step * direct-2.3 * breaks out ; since  @xmath152 is enumerative , every power - product will be considered at some ( finite ) time .",
    "the initial values for @xmath192 and @xmath193 , and the updates to these two variables in step * direct-2.3(no ) * guarantee that whenever we enter step * direct-2.1 * the set  @xmath193 satisfies @xmath209 ; in other words it comprises those power - products outside @xmath192 and which border on @xmath192 . as @xmath152 is a term - ordering , @xmath193",
    "therefore always contains the @xmath152-smallest power - product outside @xmath192 ( as well as many others ) .    in step *",
    "direct-2.3 * the algorithm looks for a @xmath0-linear dependency amongst the polynomials @xmath210 .",
    "every such linear dependency corresponds to a monic element of @xmath211 . by hypothesis @xmath211 contains the polynomial  @xmath144 ( which we may assume to be monic wrt .",
    "@xmath152 ) , so if we reach step * direct-2.3 * with @xmath212 then a linear dependency will surely be found ( _ e.g. _  corresponding to the coefficients of  @xmath144 ) . since @xmath152 is an enumerativeordering ,",
    "there are only finitely many power - products less than @xmath213 ; so we will break out of the main loop when @xmath212 , if not earlier .    _",
    "correctness : _ we shall show that we do not break out of the main loop until @xmath212 , and that when we do break out , the polynomial we construct in step * direct-3 * is  @xmath144 .",
    "the test in step  * direct-2.3 * gives _ true _ if and only if there is a polynomial @xmath214 , of the form @xmath215 with each @xmath216 , satisfying @xmath217 or equivalently @xmath218 .",
    "note that @xmath219 is monic , thus non - zero by construction .    by hypothesis @xmath211 is a principal ideal ( generated by  @xmath144 ) .",
    "so every non - zero element of @xmath211 has leading term @xmath152-greater - than - or - equal to @xmath213 , thus step * direct-2.3 * will not find any linear dependency if @xmath220 .",
    "let @xmath163 be the polynomial constructed in step * direct-3*. we have @xmath221 , and both polynomials are monic .",
    "suppose @xmath222 , and set @xmath223 .",
    "then @xmath224 but also @xmath225 , so @xmath226 which contradicts the fact that  @xmath144 is the ( non - zero ) element of @xmath211 with @xmath152-smallest leading term .",
    "this concludes the proof .",
    "[ rem : direct - bad - input ] we consider briefly what happens if the input to algorithm  [ alg : direct ]  ( direct ) does not correspond to a principal implicitization ideal .    if @xmath143 is the zero ideal then the _ main loop _ never exits ( as no non - trivial linear dependency exists ) .",
    "however , if @xmath12 then the ideal @xmath143 can not be the zero ideal as proved in remark  [ rem : s = n-1 ] .    if , instead , @xmath143 is non - zero and non - principal then the main loop will exit , and the polynomial  @xmath163 found in step * direct-3 * will be the monic polynomial with @xmath152-smallest leading term in the reduced @xmath152-grbner basis for that ideal .    this approach is inspired by the _",
    "generalized buchberger - mller algorithm _",
    "@xcite , and is somewhat simpler ( _ e.g. _  the list  @xmath142 for storing the grbner basis is not needed , and the update to the list  @xmath193 is simpler ) .",
    "but there is an important difference : here we can not specify _ a priori _ a finite dimensional vector space as the codomain of the _ normal form vector map_. for the generalized buchberger - mller algorithm the finiteness of the codomain led to an easy proof of termination ; instead here we had to introduce the concept of enumerativeordering .",
    "[ rem : directopt ] we mention here a few important optimizations which considerably improve the execution time :    1 .   the successive linear systems we check in step  * direct-2.3 * are very similar : in practice we build up a row - reduced matrix adjoining a new row on each iteration .",
    "2 .   the computation of @xmath188 in step  * direct-2.2 * can be effected in several ways .",
    "we suggest exploiting the fact that @xmath32 is a homomorphism to compute the value cheaply .",
    "apart from the very first iteration when @xmath227 , we always have @xmath228 for some indeterminate @xmath229 and some power - product @xmath230 for which we have already computed @xmath231 ; so we can calculate with just a single multiplication @xmath232 .",
    "usually there are several choices for the indeterminate @xmath229 , so we can choose the one which leads to the cheapest multiplication .",
    "note that in step  * direct-2.3(no ) * we manipulate just power - products when updating @xmath193 .",
    "3 .   in step",
    "* direct-1.1 * we pick some enumerativeordering on the power - products of the ring @xmath190}}$ ] . here",
    "we describe a specific good choice ; the idea is that as we pick ( in step  * direct-2.1 * ) the power - products @xmath189 in increasing order then the corresponding @xmath233 are in non - decreasing order . + we start with a ( standard ) degree - compatible term - ordering @xmath234 on the power - products of @xmath73}}$ ] .",
    "let @xmath235 be an @xmath236 integer matrix representing it ( so all entries in the first row are  @xmath70 ) .",
    "we define the * order vector * of a power - product @xmath237 to be @xmath238 ; the ordering @xmath234 is thus equivalent to lex comparison of the order vectors .",
    "+ let @xmath239 be the @xmath240 integer matrix whose columns are the exponents of @xmath241 ; put @xmath242 , an @xmath243 matrix whose @xmath123-th column is the order vector of @xmath244 .",
    "the first row of @xmath245 is strictly positive : the @xmath123-th entry is @xmath246 .",
    "we complete @xmath245 to a term - ordering matrix @xmath247 for the power - products of @xmath190}}$ ] : _ i.e. _  we remove rows linearly dependent on those above it , and adjoin new rows at the bottom to make  @xmath247 square and invertible .",
    "the term - ordering defined by @xmath247 is enumerativesince  @xmath245 and  @xmath247 have the same first row , and it has our desired property .    an example to illustrate remark  [ rem : directopt](b ) .",
    "let @xmath248 $ ] have terms ordered by @xmath249 .",
    "let @xmath250 then the order vectors of the lpps are @xmath251 , @xmath252 and @xmath253 respectively .",
    "so we obtain the matrix @xmath254 where we can fill the last row freely to make the matrix invertible , _ e.g.",
    "_  @xmath255 .",
    "we contrast algorithm  [ alg : direct ]  ( direct ) with the method presented by wang in  @xcite .",
    "the underlying idea is the same : find the generator by searching for a linear relationship among the images of power - products .",
    "wang s method adjoins new power - products in blocks .",
    "each block comprises all power - products of a given standard degree ( where each indeterminate has degree  1 ) .",
    "wang observed that the linear systems produced `` tend to be almost triangular '' .",
    "our approach adjoins new power - products one at a time , and this lets us use several important optimizations ( described in remark  [ rem : directopt ] ) . on each iteration",
    "we do a single multiplication to obtain @xmath188 , and then a single `` row reduction '' . using the term - ordering described in remark  [ rem : directopt](c )",
    "guarantees that our linear system is as triangular as possible , and by adjoining power - products one by one we keep the system small ( and avoid computing extraneous images of power - products under @xmath32 ) .",
    "the importance of these optimizations is illustrated by the computation time for example  [ wang ] : our implementation of algorithm  [ alg : direct ]  ( direct ) took less than 8 seconds , while wang reported about 47000 seconds    no doubt some ( but not all ) of the speed gain is due to improvements in hardware .",
    "the requirement that @xmath152 be a term - ordering is stronger than necessary .",
    "for instance , it is sufficient that @xmath152 orders by degree ( how it orders within a fixed degree is unimportant ) .",
    "however , if we use such a general ordering then the list  @xmath193 will then have be to updated differently in step * direct-2.3(no ) * ( _ e.g. _  fill it with all power - products of the next degree when it becomes empty , much like wang s method  @xcite ) .",
    "in this section we consider a parametrization given by rational functions @xmath112 in the field @xmath4 , where @xmath5 is a set of indeterminates which are viewed as parameters .",
    "we can write this parametrization with a common denominator @xmath80 , so that we have @xmath50 with @xmath256 $ ] .",
    "[ rem : generalfrac ] we recall here a general method for computing @xmath257 .",
    "we start with the ideal @xmath258 $ ] , then we introduce a new indeterminate @xmath259 , and let @xmath260 $ ] .",
    "now we have @xmath261 which can be computed by eliminating the indeterminates @xmath259 and @xmath72 .",
    "the following example illustrates the necessity of adding @xmath262 to  @xmath8 .",
    "[ uqminusone ] we let @xmath263 and we let @xmath264 in @xmath248 $ ] .",
    "we construct the ideal @xmath265 , and observe that @xmath266 .",
    "hence we get @xmath267 = { \\langle z\\,(x - y ) \\rangle}$ ] which is not prime . the correct result ,",
    "which may be obtained by including the generator @xmath268 , is @xmath269 .    in the following",
    "we present a `` homogeneous '' method for the computation of the ideal @xmath7 when @xmath270 are rational functions ; compared to the classical method",
    "the big advantage we have is that the grbner basis computation ( _ i.e. _  the elimination ) is performed on a homogeneous ideal .",
    "[ th : homogfractions ] * ( implicitizating rational parametrizations by homogenization ) * + let @xmath271 be non - zero polynomials in @xmath113 $ ] .",
    "we shall work in the graded ring @xmath272 $ ] with grading defined by @xmath273 for @xmath274 and @xmath275 for @xmath276 where @xmath277 .",
    "now make the input polynomials homogeneous and of equal degree  @xmath64 : set @xmath278 , and set @xmath279 for @xmath52 .",
    "let @xmath131 be the homogeneous eliminating ideal in the ring  @xmath154 generated by @xmath280 .",
    "then :    1 .",
    "the ideal @xmath281 $ ] is prime .",
    "we have the equality @xmath282\\big)\\dehx0 $ ] .",
    "the kernel @xmath257 is an ideal in the ring @xmath1 $ ] , which we view as a subring of  @xmath154 .",
    "we write @xmath283 $ ] to denote the subring @xmath284 $ ] : observe that a polynomial in @xmath283 $ ] is homogeneous in the induced grading if and only if it is homogeneous in the standard grading ( _ i.e. _  in the usual sense of the word ) .",
    "as in proposition  [ prop : homogpoly ] , the proof of claim  ( a ) follows immediately from the fact that @xmath131 is an eliminating ideal , hence prime .    to prove claim ( b ) we introduce the following sets :    * @xmath285 * @xmath286 \\ \\mid \\",
    "a \\text { is homogeneous and \\ }",
    "{ a(q , p_1 , \\dots , p_n)}= 0\\}$ ] * @xmath287   \\ \\mid \\ a \\text { is homogeneous and \\ }   { a(q , p_1 , \\dots , p_n ) } = 0\\}$ ] * @xmath288   \\ \\mid \\ a \\text { is homogeneous and \\ }   { a\\dehx0(\\frac{p_1}{q } , \\dots , \\frac{p_n}{q})}= 0\\}$ ]    clearly , the conclusion is reached if we prove the following claims .    1 .",
    "the set @xmath289 is the ideal @xmath7 .",
    "the set @xmath290 generates the ideal @xmath291 $ ] .",
    "we have @xmath292 .",
    "we have @xmath293 .",
    "we have @xmath294 .",
    "claim  ( 1 ) is just the definition of @xmath295 .    to prove claim  ( 2 ) we recall that the ideal  @xmath131 is homogeneous , hence @xmath291 $ ] is too .",
    "thus @xmath291 $ ] can be generated by homogeneous elements , and @xmath290 contains all homogeneous elements in @xmath291 $ ] , and so it surely generates the ideal .",
    "we now prove claim  ( 3 ) .",
    "let @xmath296 be a homogeneous polynomial , and let @xmath297 .",
    "repeated application of lemma  [ lemma : homogfractions ] on the monomials in @xmath298 shows that @xmath299 whence @xmath300 if and only if @xmath301 .    finally , we prove claim  ( 4 ) .",
    "we have @xmath302 consequently @xmath303 , hence the claimed equality follows .",
    "since claim ( 5 ) is clear , the proof is complete .    if @xmath304 then @xmath305= { \\langle g\\hom \\rangle}$ ] .    the proof can be done exactly as the proof of corollary  [ cor : princpoly].a .    we may relax the restriction in the theorem that each @xmath306 be non - zero ;",
    "it is there just to allow an easy definition of  @xmath64 , the upper bound for the degrees .",
    "[ rem : ratgeneralhomog ] we could be tempted to use the general method highlighted in remark  [ rem : generalfrac ] : namely , we homogenize the generators of  @xmath117 given there to get the eliminating ideal  @xmath307 , and then imitate proposition  [ prop : homogpoly ]",
    ". however , even if the ideal @xmath308)\\deh$ ] is principal , the ideal @xmath309 $ ] need not be principal , as the following example shows .",
    "the main drawback is that @xmath307 need not be saturated with respect to  @xmath37 .    [ exnotsaturated ] we return to example  [ uqminusone ] , but this time homogenize the generators of @xmath310 to produce the following ideal @xmath311",
    ". however , elimination yields @xmath312 =   { \\langle xzh -yzh,\\   xh^2 -yh^2 \\rangle}$ ] which is not principal . even if we homogenize the generators and bring them all to the same degree , we get the ideal @xmath313 , and again elimination produces @xmath314 =   { \\langle xzh -yzh,\\   xh^2 -yh^2 \\rangle}$ ] .",
    "[ weightedhomgnotgood ] in the case of rational functions , we could also be tempted to homogenize the input in a similar way to theorem  [ th : homogfractions ] but applying just @xmath91 instead of equalizing the degrees with  @xmath315 .",
    "this does not work because claim  ( 4 ) of the proof fails , as the following easy example shows .",
    "[ ex : t2t3t4 ] in the ring @xmath316 $ ] we consider the eliminating ideal @xmath317 the correct answer is @xmath318 .",
    "however , if we consider the ring @xmath319 $ ] graded by setting @xmath320 , @xmath321 , @xmath322 , @xmath323 , and @xmath324 , then the ideal @xmath325 is homogeneous , but the polynomial of minimal degree in @xmath326 $ ] is @xmath327 whose degree is @xmath328 while the actual solution is the polynomial @xmath329 whose degree is @xmath330 .",
    "we now turn theorem  [ th : homogfractions ] into an explicit algorithm :    * ( ratpar : rational parametrization ) *    input : :    @xmath331    where  @xmath80 is a common denominator .",
    "ratpar-1 : :    let @xmath277 ,    taking @xmath332 if necessary .",
    "ratpar-2 : :    create the polynomial ring    @xmath333 $ ] , +    graded by @xmath334 for    @xmath274 , and @xmath275 for    @xmath276 .",
    "ratpar-3 : :    let @xmath335 , and let @xmath336 for @xmath52 .",
    "ratpar-4 : :    compute    @xmath337 .",
    "ratpar-5 : :    compute @xmath338 for all    @xmath339 output : :    @xmath340 $ ]    satisfying    @xmath341 .    in step",
    "* ratpar-4 * we may use any algorithm to compute the implicitization from the ( homogeneous ) polynomial parametrization , _",
    "e.g. _  algorithms  [ alg : elimth ] or  [ alg : direct ]",
    "it is well known that computations with coefficients in @xmath30 can be very costly in terms of both time and space . when possible , it is generally a good idea to perform the computation modulo one or more primes , and then `` lift '' the coefficients of these modular results to coefficients in @xmath30 .",
    "there are two general classes of method : hensel lifting and chinese remaindering .",
    "we shall use chinese remaindering .",
    "the modular approach has been successfully used in numerous contexts : polynomial factorization  @xcite , determinant of integer matrices  @xcite , ideals of points  @xcite , and so on . in any specific application",
    "there are two important aspects which must be addressed before a modular approach can be adopted :    * knowing how many different primes to consider to guarantee the result ( _ i.e. _  find a realistic bound for the size of coefficients in the answer ) ; * handling _ bad primes _ : _ i.e. _  those whose related computation follows a different route , yielding an answer with the wrong `` shape '' ( _ i.e. _  which is not simply the modular reduction of the correct non - modular result ) .",
    "there is no universal technique for addressing these issues . for our particular application",
    "there is no useful coefficient bound , and only a partial criterion for detecting bad primes ( see remark  [ rem : detecting ] ) .",
    "we shall use _ fault - tolerant rational recovery _ to overcome our limited knowledge about these two aspects ( see section  [ sec : multipleprimemethod ] ) .    *",
    "( reduction modulo @xmath342 ) * given a prime number  @xmath342 we denote the usual `` reduction mod @xmath342 '' ring homomorphism by @xmath343 .",
    "we can extend @xmath344 naturally to @xmath345 $ ] by mapping the coefficients but preserving the power - products , and extend it further to rational functions ( over @xmath30 ) by localizing away from its kernel in @xmath345 $ ] .",
    "our aim is to reconstruct the monic generator of @xmath143 in @xmath346 $ ] from the modular implicitizations @xmath347 in @xmath348 $ ] .",
    "let @xmath349 be non - constant and such that @xmath350 is a principal ideal , for some @xmath351 $ ] .",
    "clearly the generator  @xmath144 is defined only up to a non - zero scalar multiple ; we resolve this ambiguity by requiring  @xmath144 to be monic ( with respect to some fixed term - ordering on @xmath352 $ ] ) .",
    "we can now define @xmath353 to be the least common denominator of the coefficients of  @xmath144 .",
    "[ def : unsuitable ] we say that the prime  @xmath342 is * unsuitable * if any of the following happens :    ( a ) : :    there is an index  @xmath123 such that @xmath36 is not    in the domain of @xmath344 .",
    "( b ) : :    there is an index  @xmath123 such that    @xmath354 or +    @xmath355 or +    @xmath356 .    in other words",
    "@xmath342 is unsuitable if it divides any denominator , or if the degrees of numerator and denominator of some @xmath36 change modulo  @xmath342 .",
    "it is easy to check whether  @xmath342 is unsuitable .",
    "we exclude all unsuitable primes from subsequent discussions .",
    "we say that the prime  @xmath342 is * bad * if it is suitable but either of the following happens :    ( a ) : :    @xmath144 is not in the domain of @xmath344 , that is    @xmath342 divides a denominator in @xmath144 .",
    "( b ) : :    @xmath357 .",
    "we say that a prime is * good * if it is neither unsuitable nor bad .",
    "we say that  @xmath342 is * very - good * if it is good and @xmath358 ; in other words , it does not divide the numerator of any coefficient in  @xmath144 .    [ ex : badprimes ]    given @xmath359 $ ] we have @xmath360 but modulo  @xmath361 we obtain @xmath362\\ ] ]",
    "so the prime  @xmath361 is bad because , even though the modular implicitization is principal , it is not equivalent modulo  @xmath361 to the correct result .    indeed , even when @xmath143 is principal in @xmath346 $ ] we can not be sure that @xmath363 is principal too .",
    "for instance , given the parametrization @xmath364 and @xmath365 $ ] we have @xmath366 whereas modulo  @xmath367 we find that @xmath368\\ ] ] from remarks  [ rem : elimth - bad - input ] and  [ rem : direct - bad - input ] , we see that in cases such as this , where the modular inputs do not satisfy the assumption that @xmath369 be principal , our algorithms  [ alg : elimth ]  ( elimth ) and  [ alg : direct ]  ( direct ) for computing @xmath370 will simply return the first polynomial in the ideal that they find .    [ finitelymanyunsuitableprimes ]",
    "condition  ( a ) is satisfied if and only if @xmath342 divides the least common denominator for all the @xmath36 ; clearly there are only finitely many such primes .",
    "condition  ( b ) is satisfied if and only if  @xmath342 divides the least common multiple of the integer contents of the leading forms of the numerator and denominator of each @xmath36 ; again , clearly there are only finitely many such primes .",
    "[ finitelymanybadprimes ] clearly condition  ( a ) covers only finitely many primes . for condition",
    "( b ) we consider what happens when algorithm  [ alg : direct ]  ( direct ) runs .",
    "we have a faithful modular implicitization if and only if the check for a linear dependency in step * direct-2.3 * actually finds one on the same iteration that it would have been found while computing over @xmath30 .",
    "this will happen only if there was no linear dependency in any previous iteration ; in other words , if the matrix had been of full rank in the penultimate iteration ; and this happens for all primes except those which divide the numerators of all maximal minors    there are clearly only finitely many such primes .    only finitely",
    "many primes are good but not very - good . by definition",
    "a prime is good but not very - good if it divides the numerator of some coefficient of  @xmath144 , or equivalently if it divides the least common multiple of the numerators of the coefficients of  @xmath144 .",
    "clearly only finitely many primes do so . in conclusion ,",
    "only finitely many primes are not very - good .",
    "[ rem : detecting ] we do not have an absolute means of detecting bad primes , but given the implicitizations modulo two different primes we can sometimes detect that one of them is surely bad ( without being certain that the other is good ) .",
    "what we can say depends on which algorithm we used to compute the implicitizations    we must use the same algorithm for both modular computations !",
    "if we run algorithm  [ alg : elimth ]  ( elimth ) with a bad prime  @xmath342 to produce the output  @xmath371 then we know that @xmath372 . thus if we run algorithm  [ alg : elimth ] with two different primes  @xmath373 and  @xmath374 , and if @xmath375 then surely @xmath373 is a bad prime .",
    "note that even if @xmath376 , we need not have @xmath377 as shown by the non - principal ideal in example  [ ex : badprimes ] above .",
    "if we run algorithm  [ alg : direct ]  ( direct ) with a bad prime  @xmath342 to produce the output @xmath371 then we know that @xmath378 provided we use the same , fixed enumerativeterm - ordering @xmath152 . thus if we run algorithm  [ alg : direct ] with two different primes  @xmath373 and  @xmath374 , and if @xmath379 then surely @xmath373 is a bad prime .      given input @xmath380 we can pick a suitable prime  @xmath342 , and run one of our algorithms to get an output @xmath371 .",
    "if  @xmath342 is very - good then @xmath381",
    ". we can then determine the coefficients of  @xmath382 by solving a linear system over @xmath30 .",
    "let @xmath383 and pick @xmath384 distinct @xmath385-tuples of random integers ; evaluating all the @xmath36 at each such @xmath385-tuple produces a `` random point '' on the hypersurface , _",
    "i.e. _  a zero of  @xmath144 .",
    "if the @xmath386 matrix whose @xmath387-entry is the value of the @xmath123-th power - product ( in @xmath388 ) at the @xmath389-th tuple is of full rank then knowing that every point on the hypersurface is a zero of  @xmath144 , and knowing that the leading coefficient of @xmath382 is  @xmath70 we can solve the linear system to get all coefficients of @xmath163 , our `` informed guess '' for the value of @xmath382 .",
    "we must now verify that @xmath163 is correct ; we do this by simply substituting @xmath380 into it .",
    "if our choice of prime was very - good then the substitution will verify that @xmath163 is correct .",
    "conversely , if our choice of prime  @xmath342 was not very - good then the candidate `` informed guess '' for the support of @xmath382 was wrong , and @xmath163 will lie outside @xmath390 , so the substitution will give a non - zero result ; in this case we must start again with a different prime , hoping that this time it will be very - good .",
    "this technique is advantageous when the implicitization is especially sparse ( since then the linear system will be small ) .",
    "we can make a cheaper initial verification by picking another random point on the hypersurface , and verifying that that point is a zero of @xmath163 . naturally ,",
    "if this `` randomized check '' passes then a full verification must still be done .",
    "a disadvantage of the single prime method is that if the prime chosen is not very - good then we discover this only at the end of a potentially expensive verification .",
    "we can greatly reduce the risk of a failed verification by using several different primes , and combining the corresponding modular answers using chinese remaindering .",
    "our strategy must handle bad primes . using the checks in remark  [ rem : detecting ] we can detect and discard some bad primes ,",
    "however it is possible that a few bad primes pass undetected .",
    "we use fault - tolerant rational reconstruction to cope with any undetected bad primes ; we will find the right answer so long as the good primes sufficiently outnumber the undetected bad ones .",
    "moreover , when using several primes we do not require that any of the primes be very - good ; it is enough for most of the primes to be good and `` complementary '' ( _ i.e. _  the union of the supports of the answers from all the good primes tried must include the support of the true answer ) .",
    "the key ingredient in this approach is a _ fault - tolerant rational reconstruction _ procedure ( _ e.g. _  see  @xcite and  @xcite ) : this enables rational coefficients to be reconstructed from their modular images even if some of those images are bad .",
    "the reconstruction procedure normally returns either the correct rational or an indication of failure , though there is a low probability of it producing an incorrect rational .",
    "so for certainty , the reconstructed implicit polynomial must be verified .",
    "we chose the hrr algorithm from  @xcite because it is better suited to our application : compared to etl from  @xcite it requires fewer primes ( and therefore fewer costly modular implicitizations ) when reconstructing `` unbalanced '' rationals , _",
    "i.e. _  whose numerator and denominator have differing sizes .",
    "[ alg : modular ] * ( modimplicit ) *    input : :    @xmath391 such    that @xmath390 is    principal .",
    "modimplicit-1 : :    fix a term - ordering @xmath152 on the power - product monoid    of @xmath392 $ ] ; +    choose an enumerativeordering if using algorithm  [ alg : direct](direct )    in steps  3 and  5.2 .",
    "modimplicit-2 : :    choose a suitable prime @xmath342    see    definition  [ def : unsuitable ] .",
    "modimplicit-3 : :    compute @xmath371 , the monic generator of    @xmath363 .",
    "modimplicit-4 : :    let @xmath393 and @xmath394 .",
    "modimplicit-5 : :    _ main loop : _",
    "+    modimplicit-5.1 ; ;      choose a new suitable prime @xmath342 so all @xmath36      lie in the domain of @xmath344 .",
    "modimplicit-5.2 ; ;      compute the monic generator @xmath371 of      @xmath395 .",
    "modimplicit-5.3 ; ;      let @xmath396 , and      @xmath397 be the polynomial whose coefficients are      obtained by chinese remainder theorem from the coefficients of      @xmath398 and @xmath371 .",
    "modimplicit-5.4 ; ;      compute the polynomial      @xmath399 $ ] whose      coefficients are obtained as the fault - tolerant rational      reconstructions of the coefficients of @xmath397      modulo @xmath400 .",
    "modimplicit-5.5 ; ;      were all coefficients `` reliably '' reconstructed ?      +      yes : :        if @xmath401 and        @xmath402 exit from loop      no : :        let @xmath403 and        @xmath404 output : :    @xmath405 $ ] which generates    @xmath390     _ correctness : _ let @xmath406 $ ] be the monic generator of @xmath390 .    from the test in step",
    "* modimplicit-5.5 * we have that @xmath402 , so the value returned is surely an element of @xmath390 ; consequently , @xmath163 is a non - zero multiple of  @xmath144 .",
    "we show by contradiction that  @xmath163 is a scalar multiple of  @xmath144 .",
    "suppose not , then @xmath407 for some non - constant polynomial  @xmath96 .",
    "let @xmath152 denote the enumerativeterm - ordering used inside algorithm  [ alg : direct ]  ( direct ) ; and let @xmath408 denote the weighted degree used inside algorithm  [ alg : elimth ]  ( elimth )    note that condition  ( b ) in our definition of `` unsuitable '' makes sure that the same weighted degree is used every time .",
    "let @xmath409 , then clearly @xmath410 .",
    "let @xmath411 be a term of @xmath163 of maximal weighted degree ; then @xmath412 .",
    "note that @xmath413 and @xmath411 could be the same term .",
    "since step  * modimplicit-5.4 * succeeded in reconstructing @xmath163 more than half the modular implicitizations had non - zero coefficients for the term @xmath413 , and similarly for the term @xmath411 .",
    "so at least one modular implicitization , @xmath371 , had non - zero coefficients for both @xmath413 and @xmath411 , but this @xmath371 can not have been produced by algorithm  [ alg : direct ]  ( direct ) because it has @xmath414 , and it can not have been produced by algorithm  [ alg : elimth ]  ( elimth ) because @xmath415 .",
    "thus @xmath163 is just a scalar multiple of @xmath144 .    _",
    "termination : _ the hrr algorithm in  @xcite for fault - tolerant rational reconstruction guarantees to produce the correct output when the product of the good primes is sufficiently greater than the square of the product of the bad primes ( see corollary  3.2 in that article ) .    as there are only finitely many bad primes ( see remark  [ finitelymanybadprimes ] ) , the product of the good primes chosen in the _ main loop _",
    "will eventually become arbitrarily large compared to the square of the product of all bad primes ( which is an upper bound for the square of the product of all bad primes encountered in the _ main loop _ ) .",
    "thus the reconstruction in step  * modimplicit-5.4 * will eventually produce @xmath416 .",
    "we can use the comments in remark  [ rem : detecting ] to discard some bad primes .",
    "if we always use algorithm  [ alg : direct ]  ( direct ) to compute @xmath371 then we may insert the following step :    modimplicit-5.2a : :    if    @xmath417    then go to step  * 5.1*. +    if    @xmath418    then set @xmath419 and @xmath394 ; go to    step  * 5.1*.    if we always use algorithm  [ alg : elimth ]  ( elimth ) to compute @xmath371 then we may insert the following step :    modimplicit-5.2a : :    if @xmath420 then go to step  * 5.1*. +    if @xmath421 then set    @xmath419 and @xmath394 ; go to step  * 5.1*.    since each @xmath371 is defined only up to a scalar multiple , we normalize the polynomial by making it monic ; this guarantees that for every good prime  @xmath342 , the corresponding polynomial @xmath371 is equal to @xmath422 .",
    "in this section we show the practical merits of our algorithms .",
    "we conducted two series of experiments , which we report in the two tables below .",
    "the experiments were performed on a macbook pro  2.9ghz intel core  i7 , using our implementation in 5 .",
    "the columns headed `` elimth '' and `` direct '' report the computation times for the respective algorithms : in each case there are separate columns for computations over a finite field ( char 32003 ) , and over the rationals ( char 0 ) .",
    "the column headed `` len '' says how many terms there are in the resulting polynomial .",
    "the symbol @xmath423 in the tables means that the computation was interrupted after  20 minutes , and  @xmath424 means that the computation takes less than @xmath425 seconds .",
    "a horizontal line in the middle of the tables separates examples with polynomial parametrizations from examples with rational parametrization .",
    "table  1 contains statistics related to examples taken from the literature , which we list in appendix  [ othersexamples ] .",
    "it shows that , with the sole exception of example  [ wang ] , they are computed in almost no time .",
    "we found only two examples which defeated us : listed in our appendix as examples  [ dic2 ] and  [ dic3 ]    originally they were examples  5.2 and  5.3 in  @xcite .",
    "we suspect they are essentially incalculable because the implicitizations are almost certainly polynomials of high degree ( over  100 ) having very many terms ( over 100000 ) .",
    "table 1    [ cols=\"<,^,^,^,^ , > \" , ]     99    j. abbott , _ fault - tolerant modular reconstruction of rational numbers _",
    ", + arxiv:1303.2965v2 ( 2015 ) ; to appear in j.  symb .  comp .",
    "j.  abbott and a.m.  bigatti _ cocoalib : a c++ library for doing computations in commutative algebra .",
    "_ available at ` http://cocoa.dima.unige.it/cocoalib `    j.  abbott , a.m.  bigatti , g.  lagorio _ cocoa-5 : a system for doing computations in commutative algebra .",
    "_ available at ` http://cocoa.dima.unige.it `    j.  abbott , a.  bigatti , m.   kreuzer , l.  robbiano , _ computing ideals of points _ , j.  symb",
    ".  comput .",
    "* 30(4 ) * ( 2000 ) , 341356 .    j.  abbott , m.  bronstein , t.  mulders , _ fast deterministic computation of determinants of dense matrices _ proc .",
    "issac  1999 , ( 1999 ) , 197204    j.  abbott , m.   kreuzer , l.  robbiano , _ computing zero - dimensional schemes _ ,",
    "+ j.  symb",
    ".  comput .",
    "* 39 * ( 2005 ) , 3149 .",
    "m.  beltrametti and l.  robbiano , _ introduction to the theory of weighted projective spaces _ ,",
    "expo . math .",
    "* 4 * ( 1986 ) , 111162 .",
    "j.  bhm , w.  decker , c.  fieker , g.  pfister , _ the use of bad primes in rational reconstruction _ math .  comp . * 84 * ( 2015 ) , 30133027    b. buchberger , _ groebner bases : an algorithmic method in polynomial ideal theory _ , in : ( n.k .",
    "bose , ed . )",
    "_ multidimensional systems theory .",
    "d.  reidel publ .  comp .",
    "( 1985 ) , 184232 .    b.  bastl and f. jezek , _ comparison of implicitization methods _ , j.  geom .  graph .",
    "* 9 * ( 2005 ) , 1129 .",
    "n.  botbol and a. dickenstein , _ implicitization of rational hypersurfaces via linear syzygies : a practical overview _ arxiv:1502.00890v1    l.  bus and t.l .",
    "ba , _ matrix - based implicit representations of rational algebraic curves and applications _ comput .",
    "aided geom .",
    "design * 27(9 ) * ( 2010 ) , 681699 .",
    "l.  bus and m. chardin , _ implicitizing rational hypersurfaces using approximation complexes _ , j. symbolic comput .  *",
    "40(4/5 ) * ( 2005 ) , 11501168 .    c. dandrea , _ moving curve ideals for rational plane parametrizations _ ,",
    "lncs * 8942 * ( 2015 ) , 3049 .",
    "i.  emiris , t.  kalinka , c.  konaxis , _ implicitization of curves and surfaces using predicted support _ , in : ( acm new york ed . )",
    "_ proceedings of the 2011 international workshop on symbolic - numeric computation _ , ( 2012 ) 137146 .",
    "i.  emiris , c.  konaxis , z.  zafeirakopoulos , _ minkowski decomposition and geometric predicates in sparse implicitization _ in : ( acm new york ed . ) _ issac 15 , proceedings of the 2015 international workshop on symbolic and algebraic computation _ , ( 2015 ) 157164 .",
    "m.  kreuzer and l.  robbiano , _ computational commutative algebra 1 _ , springer , heidelberg 2000 .",
    "m.  kreuzer and l.  robbiano , _ computational commutative algebra 2 _ , springer , heidelberg 2005 .",
    "f.  orecchia and i.  ramella , _ a new algorithm for implicitizing a parametric algebraic surface _ ,",
    "j. pure appl",
    "* 98(4 ) * ( 2015 ) , 471475    l.  robbiano , _ hyperplane sections , grbner bases , and hough transforms _ , j. pure appl .",
    "algebra * 219(6 ) * , ( 2015 ) , 24342448 .",
    "d.  wang , _ a simple method for implicitizing rational curves and surfaces _ , j. symbolic comput .  *",
    "38(1 ) * ( 2004 ) , 899914 .",
    "h.  zassenhaus , _ on hensel factorization i _ ,",
    "j.  number theory , vol .  1 , ( 1969 ) , 291311",
    "in this appendix we list the test examples we used .",
    "the symbol  @xmath0 is used to denote either the field @xmath426 or the field @xmath427 .",
    "the examples are of different types : in the first subsection there are examples taken from the literature ; in the second there are our own examples ."
  ],
  "abstract_text": [
    "<S> we present new , practical algorithms for the hypersurface implicitization problem : namely , given a parametric description ( in terms of polynomials or rational functions ) of the hypersurface , find its implicit equation . </S>",
    "<S> two of them are for polynomial parametrizations : one algorithm , `` elimth '' , has as main step the computation of an elimination ideal via a _ truncated , homogeneous _ grbner basis . </S>",
    "<S> the other algorithm , `` direct '' , computes the implicitization directly using an approach inspired by the generalized buchberger - mller algorithm . either may be used inside the third algorithm , `` ratpar '' , to deal with parametrizations by rational functions . </S>",
    "<S> finally we show how these algorithms can be used in a modular approach , algorithm `` modimplicit '' , for avoiding the high costs of arithmetic with rational numbers . </S>",
    "<S> we exhibit experimental timings to show the practical efficiency of our new algorithms .        </S>",
    "<S> hypersurface , implicitization </S>"
  ]
}