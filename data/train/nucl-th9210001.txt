{
  "article_text": [
    "in the course of my research as a nuclear physicist i recently had occasion to write a fortran code for solving coupled , nonlinear ordinary differential equations ( odes ) .",
    "the code , which originally ran on a vax , used appropriate numerical recipes@xcite to carry out a runge - kutta integration of the equations .",
    "this paper describes how i came to develop a user - friendly graphical    interface to this code .",
    "the interface makes it much easier to use the code for finding the solutions to the nonlinear odes .",
    "in particular , the original fortran code solves second - order    coupled odes for two functions , @xmath0 and @xmath1 , by matching at some intermediate distance .",
    "the boundary conditions at the origin are known and the equations themselves determine indicial behaviors near @xmath2 .",
    "there are also desired asymptotic behaviors at large distances    ( exponential falloffs ) .",
    "however , one does nt initially know the sizes of derivatives at the origin    or the asymptotic normalizations , since these are determined by the    nonlinearities of the equations .",
    "so , what the user of the code does is to choose these four scale parameters arbitrarily for a first pass through the equations .",
    "these parameters are then subsequently refined by successive iterations until the equations are well - satisfied.@xcite    this fortran program was invoked as a batch process from a    ( text only ) terminal window .",
    "the user could semi - interactively input parameters , i.e. , the code would use default values and , in the terminal window , query the user    as to whether he or she wanted to make changes.@xcite this mode of operating was tolerable when running the code on a vax mainframe , but the problem with this procedure is that non - linear equations are tricky .",
    "much of the time a choice of starting scale parameters ends up making a disastrous step , which wastes the whole batch run .",
    "because of a change of station , i soon had to transfer my fortran computing from the vax to a next workstation .",
    "consideration of cost led me to use the public domain  compiler \" f2c , which translates fortran code into c code , and then compiles that with the gnu cc compiler that comes bundled with the next operating system.@xcite this , as will be seen , turned out to be a serendipitous , as well as economic ,    choice .    after the move to the next , however , some things about running the program    as a batch job became annoying . for example , performing another calculation meant starting a new job and re - entering all the input parameters .",
    "another annoyance was the graphing of the resulting solutions . on the vax ,",
    "plots of solutions could be made automatically by having the fortran code write out graphics files to the terminal running in a tektronix 4014 emulator mode .",
    "on the next , however , the plotting had to be done by post - processing an output file after each run .",
    "i began looking for a better way to work .",
    "perhaps more of a reason to make a change came from the above - mentioned difficulties of finding solutions to the nonlinear equations themselves .",
    "the code often can not find reasonable newton - raphson corrections to the scale parameters if the initial values are poorly chosen    ( i.e. , too far from the solution values ) . if one could immediately see graphs of the results of the first pass , that would help in making a good initial choice .",
    "( if it s very bad , one would not proceed with that run and try another choice . ) likewise , seeing graphs of intermediate pass results would allow the user to opt out of a calculation that starts to `` blow up '' .",
    "thus , it soon became obvious that i should try putting a interactive interface on the fortran ode solver program .",
    "however , the nextstep operating system and its graphical user interface ( gui ) are based on objective - c , an object - oriented extension of the c programming language .",
    "so the basic question now became how to get objective - c to talk to    fortran ( and vice versa ) ?",
    "to answer that question , consider a simple `` hello , fortran ! '' application , which has the window interface shown in fig .  1 and which does the following :    *   the user inputs ( clicks , then types ) a number into a small text window , a formcell object labeled `` in '' , in an on - screen window representing the `` hello , fortran ! '' application . *   clicking on a run button in that window reads that number and sends it to a fortran program .",
    "*   the fortran code multiplies it by 7 and displays the `` answer '' in another formcell object ( labeled `` out '' ) in the window .    to build such a program as a nextstep application one first builds the window using the interface builder@xcite ( ib ) , a developer s toolkit that comes with every next workstation having the extended distribution .",
    "how the ib is used will only be described briefly in this paper ;    the reader is referred to ref .  3 for details .",
    "after launching the interface builder , one uses the mouse to drag in and drop    various graphical objects from the ib palette in the application s window . for the `` hello , fortran ! '' application it is only necessary to add two forms ( both one cell only ) for input and output and a run button .",
    "now one creates a custom class , call it runfortobject , by subclassing the generic object class .",
    "this object will contain all the specialized behavior we need to control the graphical interface window and access the fortran module . at the time runfortobject",
    "is made , the ib also creates an _ instance _ of it , runfortobjectinstance . in this class one",
    "declares the existence of two outlets , inputform and outputform , and one method , runfortmethod : sender .",
    "( a method is the object - oriented equivalent to a function call ; the argument `` sender '' will refer to the run button object . )",
    "the runfortobjectinstance s outlets , inputform and outputform , now need to be specified , i.e. , the runfortobjectinstance object must know where those    graphical objects are on the screen . likewise , the run button must know what object to tell that it has been clicked and what message should be sent there .",
    "these connections are made by dragging a connecting line , again using the mouse , from the graphical objects in the window to their corresponding target objects . in this way code in the runfortobject which refers to , say , the outputform will know where to send the fortran answer for display . similarly , the run button is connected to the runfortobjectinstance as target and will trigger the action coded in runfortmethod .    finally , by clicking on the parse menu item , the interface builder creates a    class header file , runfortobject.h , which _ defines _ the    interface ( see fig .  2 ) .",
    "the ib also creates a shell of the objective - c that needs to be    filled in for the class implementation file , runfortobject.m .",
    "nothing further has to be done with the header file ( in this case ) , but the runfortobject.m file needs fleshing out .",
    "the following material was added , by hand , to runfortmethod ( see fig .",
    "3 ) :    *   first , read the inputform , write its value to a file , input.data , and close the file .",
    "* call the fortran code , which is actually the subroutine hellosub in the hellosub.f file ( see fig .  4 ) .",
    "the compiler - translator , f2c , creates a c function , hellosub _ ( ) , + corresponding to this subroutine which can then be called by that name in the objective - c code . *",
    "the fortran subroutine opens and reads the input data from input.data and massages it ( multiplies it by 7 in the present case ) .",
    "it then writes its output to the file output.data , closes that file , and returns .",
    "*   the objective - c routine , runfortmethod , continues by opening the output.data file , reads it , and finally displays the number there in outputform , i.e. , in the main window .",
    "three details in this code should be noted .",
    "first , fortran is case - insensitive , but unix filenames do care about case .",
    "second , the codes in figs .",
    "2 and 3 include printf s and print s , seen here as commented out , for debugging purposes .",
    "if the application is launched from a terminal window ( a shell ) , these debug printouts would appear there .",
    "the ability to print out intermediate results turned out to be very useful for debugging .",
    "finally , it is necessary to include the # import statements for the header files appkit / form.h and stdio.h , so that the c compiler will be able to find definitions and other necessary things .",
    "the final step is to `` make '' the application , to test it , and to iterate as necessary .",
    "the interface builder generates a standard unix makefile , which is not to be    touched .",
    "however , the code developer can customize that makefile as needed by creating make.preamble and make.postamble files , which are read and executed by the standard makefile .",
    "in this particular application one needs to declare other_ofiles to force recompilation of hellosub.f , if it is changed ( fig .  5 ) .",
    "also , to be able to load the fortran i / o routines , etc . , one must declare the f2c library .",
    "( alternatively , one could declare the library by adding it to the  other    libscategory in the project inspector window of the ib . )",
    "such a nextstep application does work , and , as a learning tool , it provided the clues for how to frontend a more ambitious fortran code , such as the ode - solver .",
    "details of how this was done are discussed    in the next section .",
    "the rhosky application solves coupled nonlinear odes for two functions , @xmath0 and @xmath1 .",
    "these functions involve four as - yet undetermined scale parameters ,    @xmath3 , @xmath4 , @xmath5 , and @xmath6 , which will be fixed by the iterative process we employ to solve the nonlinear equations .",
    "details regarding these equations and some of the physics behind them are given in an appendix .",
    "the main window for the rhosky application is assembled using the interface builder as in the  hello , fortran ! \" example discussed above , but it involves more objects ( fig .",
    "6 ) :    * an input form object for various input parameters : + coupling constants of the lagrangian ; particle masses ; + the matching radius @xmath7 ; + the starting point in the asymptotic region , + @xmath8 , for the backward integration ; the runge - kutta precision parameter , @xmath9 ; and the boundary value of @xmath10 ( which is usually taken to be @xmath11 , corresponding to baryon number @xmath12 ) . *   an input form for the starting values of the four scale parameters ( @xmath3 , @xmath4 , @xmath5 , @xmath6 ) which are adjusted to make @xmath0 , @xmath1 continuous and smooth at @xmath13 . *   a form for displaying the present values of the adjusted scale parameters , i.e. , what was used in the present iteration that is displayed in the plot window . * a form for displaying the discontinuities of @xmath0 and @xmath1 and their first derivatives , @xmath14 , at the match point and the calculated corrections , @xmath15 , to the scale + parameters based on these discontinuities .",
    "( a warning : these discontinuities @xmath16 are not to be confused with the solution @xmath0 . ) *   an output form for displaying post - processed computations , such as the skyrmion mass , m_sky , that depend on the solutions @xmath0 and @xmath1 .",
    "*   default values in the form cells for input and scale parameters ; these can be changed by the user by clicking on the desired cells and editing them , before clicking on run .",
    "* various control buttons : + does a clear and performs first the pass ( i.e. , a first + iteration ) of a new calculation , with input and scale parameters as + displayed .",
    "+ goes on to next iteration , if desirable .",
    "+ writes out the final solution to file output.data and performs and displays post - processing computations .",
    "+ clears the plot window , discussed below , and the output form cells .    the evolution of the main window as one goes through the steps to find a solution is shown in fig .",
    "5 .    in addition",
    ", the application also has a plot window for displaying the    present ( or final ) calculated @xmath0 and @xmath1 ( fig .",
    "[ plotwin ] ) .",
    "the code for plotting in this window is a custom - built object , nxypalette,@xcite , available in the public domain .",
    "nxypalette in turn is based upon a nextstep plotting application ,    nxyplot , also in the public domain.@xcite the expanded runfortobject.m file , discussed below , includes three methods needed for plotting ( besides those methods already in the nxyview object provided by nxypalette ) .",
    "the graph in the plot window is updated after every pass ( run , continue , or finish up ) . as shown in fig .",
    "[ plotwin ] , the user sees how the curves ,    which are initially discontinuous , smooth out as a solution is achieved .",
    "the runfortobject.m file is now more complex and contains eight methods .",
    "four of these are connected to buttons :    *   startfortmethod : sender , the action of the run button , which calls the fortran subroutine startsub .",
    "*   continuefortmethod : sender , the action of the continue button , which calls subroutine continuesub .",
    "*   finishfortmethod : sender , the action of the finish up button , which calls subroutine finishsub . *   clearfornewrun : sender , the action of the clear button , which simply calls the clearnxyview method provided by nxyview and clears the output form displays .",
    "three methods are need for plotting graphs ( fig .",
    "[ plotmeth ] ) :    *   updateoutputdata , which calls writeplotdata .",
    "*   sendplotdatatowindow , which also checks that the data is plottable .",
    "*   providedatastream , which tells nxyview where to find the data to plot .",
    "( runfortobjectinstance is nxyview s `` delegate '' , which means that for some messages received , nxyview asks its delegate to respond . )",
    "finally , there is one additional method ( not mentioned in the header file , i.e. , not `` public '' ) , displayintmdtefs , for handling the display of intermediate results : the discontinuities , the calculated    changes to the scale parameters , and their present values .",
    "the fortran file that is associated with the rhosky application is    considerably larger than that needed for `` hello , fortran ! '' .",
    "the communication with the objective - c code continues to be , as above , through a set of subroutine calls .",
    "these subroutines were `` written '' by converting the original fortran main program ( which itself largely consisted of subroutine calls ) into several top - level subroutines , already mentioned above with regard to the methods connected with buttons : startsub , continuesub , and finishsub .",
    "there are two additional top - level subroutines , writeplotdata ( called by updateoutputdata ) and observables ( called by finishsub ) .",
    "the observables subroutine originally was a    _ separate _ fortran post - processor program for calculating , from the final @xmath0 and @xmath1 , the quantities that eventually appear in the m_rho , m_sky , and goldrat formcells in the main window .",
    "finally , there are several lower - level routines needed for the runge - kutta integration , such as derivs , which calculates the right - hand - sides of the four first - order equations .",
    "what can _ not _ be shown in the figures of this article is the real - time ease of use of the rhosky application .",
    "calculation proceeds quickly , with results and graphs appearing within a second or so after clicking a button .",
    "the interface in fact _ encourages _ a more exploratory approach to the equations than one might undertake when searching for solutions in a batch mode .",
    "most importantly , it is much more fun to `` drive '' this application    with the gui interface than the old fortran program with the command - line , batch - mode interface .",
    "the interface described above is specific to one    particular physics problem , but it is clear that the principles involved can be applied to many different problems involving the solution of coupled differential equations .",
    "in fact , we already have adapted ( re - used ) the code , with _ very _ little extra work , to solve some coupled equations for a quantum field theoretic    problem involving pions and @xmath17-mesons .",
    "this conversion only took about eight hours and most of that time was spent in writing the prologue ( i.e. , comment lines )    which describes the problem being solved .",
    "essentially , only the fortran subroutines load1 , load2 , and derivs , which depend upon the equations being solved ,    had to be changed .",
    "there were also some problem - specific changes that had to be made , using the interface builder ,    to the input and output forms of the main window ( different coupling constants , different numbers of functions to be solved for , etc . ) , but these were easy to make    using the drag - and - drop and editing capabilities of the interface builder .    in my experience as a programmer ,",
    "this rapid turnaround in a programming    cycle , from original conception to the production of useful results , was    quite remarkable .",
    "the exercise was very convincing , to me at least , that the ease of re - use    of object - oriented code modules is a real gain for the scientific programmer ,    not just salesman s hype .",
    "this work evolved from research done in collaboration with michael mattis and james l. hughes .",
    "i want to thank bryan travis , jeremy brackbill , james gubernatus , and klaus lackner for useful discussions regarding the interface described here and what other projects could be approached with it .",
    "an important component of the rhosky interface has been the nxypalette object which displays the graphs in the plot window ; its author , charles fletcher of techno - sciences , inc .",
    ", was very helpful in getting it to work . finally , kim maltman , juan prez - mercader and an unknown referee    made useful comments for improving the manuscript .",
    "the rhosky application calculates the classical pion and @xmath18-meson field functions for a @xmath18-stablized skyrmion.@xcite this is done using the so - called `` hedgehog ansatz '' , which assumes the field function solutions are particular tensor covariants times spherically symmetric functions . in this case , since there are two meson fields , there are two functions , @xmath0 and @xmath1 .    mathematically , we want to solve two nonlinear differential equations for @xmath19 and @xmath20 knowing the boundary conditions and indicial behavior at @xmath2 and appropriate asymptotic behavior ( exponential damping ) .",
    "the equations are @xmath21 near @xmath2 the solutions must behave as @xmath22 where the scale parameters @xmath3 and @xmath4 are constants to be determined by the nonlinearity of the equations themselves .",
    "similarly , the desired asymptotic behavior at large @xmath23 is @xmath24 where @xmath5 and @xmath6 are the other two scale parameters ( constants ) to be determined by solving the nonlinear equations .",
    "w. h. press , b.  p.  flannery , s.  a.  teukolsky , and w.  t.  veterling , _ numerical recipes : the art of scientific computing _ ( cambridge u.  p. , new york , 1986 ) , esp . chap .",
    "15 ; see also w. h. press and s. a. teukolsky , computers in physics * 6 * , 188 - 191 ( 1992 ) .",
    "this `` two - boundary - value problem '' is solved by shooting out from the origin , using an adaptive runge - kutta routine , to some intermediate distance , @xmath13 ( e.g. , 0.5 fm ) .",
    "then one shoots back to @xmath13 from a large value of @xmath23 ( e.g. , 2 fm )    where the asymptotic behaviors of @xmath0 and @xmath1 are known .",
    "the discontinuities at @xmath13 in @xmath19 and @xmath20 and their derivatives then determine , using a generalized newton - raphson technique , corrections to the initial scale parameters that should tend to drive the discontinuities toward zero in the next iteration .",
    "the code then goes on to make successive passes through the above shooting          next , inc .",
    ", _ nextstep reference manual _ , addison wesley , isbn 0 - 201 - 58136 - 1 , 1992 .",
    "useful supplementary documents available by anonymous ftp from the sonata archive , ref . 4 ,",
    "are : next , inc . ,",
    "nextstep_concepts , in directory /pub / next / docs ; m.  mahoney , ib_tutorial , in /pub / next / newsletters / scanews ; and j.  glover , _ short - course on object - oriented programming _ , uhoopclass , in /pub / next / docs .",
    "y.  igarashi et al . , nucl .",
    "* b259 * , 721 - 729 , 1985 .",
    "this model has a defect : the skyrmion solution is not really stable .",
    "see z.  f.  ezawa and t.  yanagida , phys .",
    "d * 33 * , 237 , 1986 and j.  kunz and d.  masak , phys .",
    "b179 * , 146 - 152 , 1986 .",
    "( my colleagues and i only learned of this defect , of course , after the rhosky application was built and working . )"
  ],
  "abstract_text": [
    "<S> this paper describes a user - friendly frontend to a fortran program that integrates coupled nonlinear ordinary differential equations . </S>",
    "<S> the user interface is built using the nextstep interface builder , together with a public - domain graphical palette for displaying intermediate and final results .    </S>",
    "<S> the main obstacle was implementing communication between the objective - c environment governing the nextstep interface and the fortran code .    </S>",
    "<S> this was overcome by breaking up the fortran into separate subroutines ( which compile as c function calls ) , corresponding to the various control buttons in the interface .    in running the code for </S>",
    "<S> a given set of equation parameters the user sees    a plot of the solutions at each stage of the iterative process . in the case of a successful sequence of iterations , the initially    discontinuous curves smooth out as the scale parameters of the    solutions are adjusted to achieve a solution to the nonlinear equations . </S>",
    "<S> if the iterative process goes astray , as it often does for a poor choice    of starting scale parameters , the user has the opportunity to stop and    start over with a better choice , guided by the result of the previous run . </S>",
    "<S> the ease of interaction with the equations also allows the user to develop an intuition regarding their solutions and to explore the parameter space    for the equations much more quickly .    </S>",
    "<S> 10000    an interactive nextstep interface to a fortran code + for solving coupled differential equations    0.1 in    theoretical division , los alamos national laboratory + university of california , los alamos , new mexico 87545    0.2 in </S>"
  ]
}