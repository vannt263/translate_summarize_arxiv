{
  "article_text": [
    "banking legislation ( bale ii@xcite@xcite ) imposes to financial institutions some daily evaluation of the risk they are exposed to because of their market positions .",
    "the main investment banks own very large portfolios of contingent claims ( several thousands of claims , 5000 being a realistic estimation ) .    for a given contingent claim and model parameters ,",
    "the evaluation of the price ( or other risk features as delta , gamma , vega ,  ) requires a computation time which can greatly vary , from a few millisecond ( as for a standard option in the black and scholes model ) to dozens of minutes ( as for american options price on a large number of underlying assets ) .",
    "a model is specified by several parameters : volatility , interest rate ,  and , in the context of risk evaluation , it is necessary to price the contingent claims for various values of these model parameters to measure its sensibility to the parameters . as a consequence ,",
    "a huge number of atomic computations ( around @xmath0 ) is necessary to evaluate the risk of the whole portfolio .",
    "these computations must be done on a daily basis to provide an evaluation of the position of the bank to the risk control organism .",
    "they are so complex that the financial institutions often need to use very large computer clusters with up to several thousands of nodes .",
    "being able to have a free access to both , a realistic portfolio descriptions and parameters for the models would be especially useful for benchmarking ( software / hardware ) parallel architectures .",
    "unfortunately , in our knowledge , no such information exists mostly because of obvious confidentiality considerations .",
    "moreover , the evaluation of a complex portfolio needs a lot of complex algorithms which are seldom available in a unified for free .    in this work",
    ", we propose a software architecture for constructing realistic models and portfolios based on freely available softwares : premia , mpi and nsp .",
    "the premia@xcite software will be the library used to compute the prices of the financial products and mpi will be the tools used to control parallelism .",
    "finally , we use a software , with a matlab like syntax , nsp  @xcite to provide a unified access to mpi and premia primitives . using this unified framework , we are able to generate parametrised benchmarks , to save them and to control the parallel architecture ( grids , clusters ,  ) .",
    "we emphasise that nsp and some implementations of mpi are available under the gpl license and that premia is freely available for test and experimentation purposes .",
    "moreover , these software have been compiled on the most widely used operating systems ( windows , linux , mac os x ) and their deployment on a cluster is quite easy .",
    "such an environment is a step to define standardised benchmarks useful for the evaluation and , we hope , the conception of parallel architectures .",
    "premia is devoted to the computation of prices and hedges for derivatives ( see @xcite for an introduction ) , which is a major issue for financial institutions .",
    "it is a research project dedicated to the development of algorithms and scientific documentation for option pricing , hedging and model calibration .",
    "it is developed in the framework of the mathfi research team uniting scientists working in probability and finance from inria and cole des ponts .",
    "this project keeps track of the most recent advances in the field of computational finance in a well documented way .",
    "it focuses on the implementation of numerical analysis techniques for both probabilistic and deterministic numerical methods .",
    "an important feature of the premia platform is its detailed documentation which provides extended references in option pricing . besides being a single entry point for accessible overviews and basic implementations of various numerical methods ,",
    "the aim of the premia project is to be a powerful testing platform for comparing different numerical methods to each other .",
    "premia is developed in interaction with a consortium of financial institutions or departments presently composed of : calyon , natixis , socit gnrale , raiffeisen zentralbank , bank austria .",
    "the members of the consortium support the development of premia and help to determine the directions in which the project should evolve .",
    "premia is a fairly complete library with regards to what is currently used in advanced finance . for an exhaustive presentation see@xcite . in its current public release ,",
    "it contains finite difference algorithms , tree methods and monte carlo methods for pricing and hedging european and american options on equities in several models going from the standard black - scholes model to more complex models such as local and stochastic volatility models and even lvy models .",
    "sophisticated algorithms based on quantisation techniques or malliavin calculus for european and american options are also implemented .",
    "more recently , various interest rate and credit risk models and derivatives have been added .",
    "nsp is a matlab like scientific software package developed under the gpl license .",
    "it is a high - level programming language which can be used as a scripting language which gives an easy access to efficient numerical routines .",
    "it can be used as an interactive computing environment or as a programming language .",
    "it supports imperative programming and features a dynamic typing system and automatic memory management .",
    "it contains internally a class system with simple inheritance and interface implementation , this class system is visible at the nsp programming level but not extendable at the nsp level .",
    "when used as an interactive computing environment , it comes with online help facilities and an easy access to gui facilities and graphics .",
    "a large set of libraries are available and it is moreover easy to implement new functionalities .",
    "it requires to write some wrapper code also called interfaces to give glue code between the external library and nsp internal data .",
    "the interface mechanism can be either static or dynamic . using dynamic functionalities we are able to build toolboxes .",
    "nsp shares many paradigms with other matlab like scientific softwares as for example : matlab , octave , scilabgtk@xcite@xcite and also with scripting languages such as python for instance .    two typical toolboxes were used in this work .",
    "the first one is the nsp premia toolbox which gives access at nsp level to the premia financial library .",
    "the second one is a mpi interface , which gives at nsp level access to mainly all mpi-2 functions .",
    "having a direct access to mpi functions within a scripting language can be very useful for many aspects .",
    "the main advantage is that it gives an easy way to get familiar to the large set of mpi functions which can be tested interactively",
    ". it also hides the tedious work of packing and unpacking complex data since a scripting language contains high level data and the packing and unpacking of such data can be hidden to the user .",
    "similar toolboxes are available .",
    "as for example , mpitb@xcite is a toolbox developed initially by javier fernndez baldomero and mancia anguita which provides such a full mpi interface for the matlab and octave languages .",
    "the nsp mpi toolbox follows the same philosophy and was implemented using the nsp interface language .",
    "note however that the matlab version of the mpitb toolbox is implemented through wrapper code which are called mexfiles and since a mexlib interface library is available in nsp it was possible to make the matlab toolbox work in nsp with mainly no additional work .",
    "but , for maximum efficiency and flexibility the mpi function interfaces have been directly written using the nsp interface api .",
    "now , we give some examples to highlight facilities that are given inside nsp to access mpi primitives .",
    "it is possible to launch a master nsp and then to spawn slaves nsp , this is done by using the ` mpi_comm_spawn ` primitive as shown on fig .",
    "[ poo ] :    .... mpi_init ( ) ; comm = mpicomm_create('self ' ) ; info_null = mpiinfo_create('null ' ) ; cmd = \" exec(''src / loader.sce'');mpi_init ( ) ; \" ; cmd = cmd + \" parent = mpi_comm_get_parent ( ) ; \" ; cmd = cmd + \" [ neworld]=mpi_intercomm_merge(parent,1 ) ; \" ; nsp_exe = getenv('sci')+'/bin / nsp ' ; args=[\"-name\",\"nsp - child \",\"- e \" , cmd ] ; [ children , errs]= mpi_comm_spawn(nsp_exe , args,1,info_null,0,comm ) ; // child will execute cmd [ neworld ] = mpi_intercomm_merge ( children , 0 ) ; ....    the code given in fig .",
    "[ poo ] will start a new nsp which will execute the transmitted ` cmd ` to start interacting with the master through a merged communicator .",
    "note that the interface between nsp and mpi does no just consists in a set of functions but also on new nsp object devoted to mpi .",
    "for example ` mpicomm_create ` creates a new nsp communicator object which internally contains a mpi communicator . since starting",
    "a set of nsp slaves is a classic task , the previous given code can be writ en in a nsp function ` nsp_spawn ` and it is then possible to start ` n ` slaves by the simple nsp command    .... neworld = nsp_spawn(n ) ; ....    it is possible to transmit and receive almost all the nsp objects using the ` mpi_send_obj ` and ` mpi_recv_obj ` nsp functions .",
    "these two functions use the fact that almost all the nsp objects can be serialized in a ` serial ` object .",
    "the two functions ` mpi_send_obj ` and ` mpi_recv_obj ` use internal serialization and packing to transparently transmit nsp objects .    ....",
    "-nsp->a = list('string',%t , rand(4,4 ) ) ; -nsp->mpi_send_obj(a , rank , tag , mcw ) -nsp->b = mpi_recv_obj(rank , tag , mcw ) b        =                l ( 3 )   (    ( 1 )    =                s ( 1x1 )        string    ( 2 )    =                 b ( 1x1 )       | t |    ( 3 )    =                r ( 4x4 )       |   0.89259   0.69284   0.10172   0.85434 |     |   0.08482",
    "0.67768   0.63584   0.16133 |     |   0.25667   0.42840   0.73767   0.29179 |     |   0.65078",
    "0.37258   0.67447   0.23511 |   ) ....    it gives us a very easy way to transmit a premia problem to a nsp slave .",
    "moreover it is easy to transmit jobs to nsp slaves as nsp strings .    for standard objects such as non sparse matrices , cells , lists and hash tables it is possible to use ` mpi_send `",
    "directly or combined with the ` mpi_pack ` function .    ....",
    "a=[%t,%f ] ; b={'foo',[1:4],'bar',rand(100,100 ) } ; h = hash_create(a = a , b = b ) ; p = mpi_pack(h , mcw ) , mpi_send(p , randk , tag , mcw ) ....    receiving the transmitted packed data is also easy",
    ". a ` mpibuf ` object can be created at nsp level with a proper size and be given to the ` mpi_recv ` function for receiving the transmitted packed data . a call to ` mpi_unpack `",
    "will then recreate a nsp object .",
    ".... [ stat]=mpi_probe(-1,-1,mcw ) //",
    "size in characters [ elems]=mpi_get_elements(stat , '' ) b = mpibuf_create(elems ) ;   //",
    "create a receive buffer ... stat = mpi_recv(b , randk , tag , mcw ) ; h1=mpi_unpack(b , mcw ) ; ....    moreover , it is possible to serialize objects at nsp level and transmit them . note that in that case ` mpi_recv_obj ` will unseals directly the serial object received .    .... -nsp->a = sparse(rand(2,2 ) ) ; -nsp->s = serialize(a ) ; -nsp->mpi_send_obj(s , rank , tag , mcw ) ...",
    "-nsp->b = mpi_recv_obj(rank , tag , mcw ) ; -nsp->b.equal[a ] ans",
    "=                 b ( 1x1 )     | t | ....    the serialization of objects is very similar to the binary format used to save and load objects in nsp since serialization just redirects the binary savings of objects to a string buffer . therefore , it is possible to save a set of objects in a file and then directly load the file content in a serialized object .",
    "it gives us an efficient way of transmitting nsp data stored in a file to mpi slaves .",
    "we illustrate in the next script the ` sload ` function  :    .... -nsp->h.a = rand(4,5 ) ;",
    "-nsp->h.b = rand(4,1 ) ; -nsp->save('/tmp / saved.bin',h ) ; -nsp->s = sload('/tmp / saved.bin ' )   // we directly create a serial object s    = < 302-bytes >         serial -nsp->h1=s.unserialize [ ] ;",
    "-nsp->h1.equal[h ] ans =         b ( 1x1 )     ....    we have recently introduced in nsp the possibility to compress the serialized buffer used in serialized objects .",
    "the ` unserialize ` method can then transparently manage unserialization of compressed and non compressed serial objects . using this facility to test if it can improve the mpi transmission of premia problems was not studied in this paper but it is left for future developments and tests . in some premia problems ,",
    "a large set of data contained in a file has to be embedded and transmitted with the problem , we imagine that compressed serialization could be useful in those cases .",
    "moreover , compression , which takes most of the cpu time , can be done off line when preparing a set of problems .    .... -nsp->a=1:100",
    "; -nsp->s = serialize(a ) s    = < 842-bytes >         serial -nsp->s1=s.compress [ ] s1   = < 248-bytes >         serial -nsp->a1=s1.unserialize [ ] ; -nsp->a1.equal[a ] ans",
    "=         b ( 1x1 )     ....    a large file called ` tutorial.sce ` can be used to interactively to learn mpi in general and also its nsp interface .",
    "this file is a simple nsp adaptation of the excellent mpitb tutorial for matlab @xcite .      for long ,",
    "the only way to use premia was from the command line . with the growing of premia every year",
    ", the need of real graphical user interface has become more and more pressing .",
    "the idea of embedding the premia library in a matlab like scientific software has come up quite naturally . unlike a standalone graphical user interface ,",
    "embedding premia into matlab like scientific software provides two ways of accessing the library either through the scripting language or using the graphical capabilities of the software ( see figure  [ premia - gui ] ) .",
    "the possibility of accessing the premia functions directly at the interpreter level makes it possible to make premia interact with other toolboxes . since the license of premia gives right to freely distribute the version of premia two year older that the current release , it was important that the scientific software used can be freely obtained and has extensive graphical feature .",
    "nsp fulfilled all these conditions .",
    "the inheritance system of nsp enables to easily add new objects in the interpreter .",
    "this is how we introduced a new type named _ premiamodel _ , through which the wide range of pricing problems described in premia and their corresponding pricing methods are made available from nsp .",
    "the results obtained in a given problem can be used in any post - treatment routines as any other standard data .    for practitioners ,",
    "the daily valuation of a complex portfolio is a burning issue to which we tried to answer using mpi / nsp / premia .",
    "given a bunch of pricing problems to be solved , which are implemented in premia , how can we make the most of nsp and the two previously described toolboxes ?",
    "first , we needed a way to describe a pricing problem in a way that is understandable by nsp so that it can create the correct instance of the _ premiamodel _ class .",
    "we implemented the ` load ` and ` save ` methods for such an instance relying on the xdr library ( external data representation ) .",
    "this way , any _ premiamodel _ object can be saved to a file in a format which is independent of the computer architecture ; these files can be reloaded later by any nsp process .",
    "then , a bunch of pricing problems can be represented by a list of files created either from the scripting language or using the graphical interface .",
    "let us give an example of how to create such a file . to save the pricing of an american call option in the one dimensional heston model using a finite difference method , one can use the following instructions    .... p = premia_create ( ) p.set_asset[str=\"equity \" ] p.set_model[str=\"heston1dim \" ] p.set_option[str=\"putamer \" ] p.set_method[str=\"mc_am_alfonsi_longstaffschwartz \" ] save('fic ' , p ) ....    creating an instance of the _ premiamodel _ class and setting its parameters are very intuitive . the object saved in the file ` fic ` can be reloaded using the command ` load('fic ' ) ` .    to solve this list of problems",
    ", we could use a single nsp process but as the problems are totally independent it is quite natural to try to solve them in parallel using the mpi toolbox presented in section  [ sec - mpi ] .",
    "the master process reads all the files and creates the corresponding instances of the _ premiamodel _ class .",
    "then , each instance is serialized and sent to a given remote node using mpi s communication functions .",
    ".... if ~mpi_initialized ( ) then    mpi_init();end   mpi_comm_world = mpicomm_create('world ' ) ; [ mpi_rank ] = mpi_comm_rank ( mpi_comm_world ) ;      [ mpi_size ] = mpi_comm_size ( mpi_comm_world ) ;       if mpi_rank < > 0                 //",
    "slave part    while % t then       name = mpi_recv_obj(0,tag , mpi_comm_world ) ; // receives the name      if name = = '' then break ; end       [ stat]=mpi_probe(-1,-1,mpi_comm_world )      [ elems]=mpi_get_count(stat ) ;      pack_obj = mpibuf_create(elems ) ;   // creates a buffer to store the packed obejct      stat = mpi_recv ( pack_obj , 0 , tag , mpi_comm_world ) ; // receives the packed object      ser_obj = mpi_unpack ( pack_obj , mpi_comm_world ) ; // unpack      p = unserialize(ser_obj ) ; //",
    "unserialize      p.compute [ ] ; l = p.get_method_results [ ] ;      mpi_send_obj(l(1)(3),0,tag , mpi_comm_world ) ; // sends the results back    end else                 //",
    "master part    nt= size(lpb , ' * ' ) ;     nb_per_node = floor ( nt / ( mpi_size-1 ) ) ;      slv = 1 ;    for pb = lpb(1:mpi_size-1 ) '          // send       send_premia_pb ( pb , slv ) ; slv = slv + 1 ;    end    res = list ( ) ;    lpb(1:mpi_size-1)= [ ] ;    for pb = lpb '      [ sl , result ] = receive_res ( ) ;      res.add_last[list(sl , result ) ] ;      send_premia_pb ( pb , sl ) ;    end    for slv=1:mpi_size-1",
    "// we still have mpi_size-1 receives to perform      [ sl , result ] = receive_res ( ) ;      res.add_last[list(sl , result ) ] ;    end    for slv=1:mpi_size-1    //",
    "tell all slaves to stop working       mpi_send_obj([''],slv , tag , mpi_comm_world ) ;    end    save('pb - res.bin',res ) ; end ....    .... // loads a premia object , serializes and packs it before sending it to the // process wih number slv function send_premia_pb ( name , slv )    load(name ) ;    ser_obj = serialize ( p )    mpi_send_obj ( name , slv , tag , mpi_comm_world ) ; //",
    "send name    pack_obj = mpi_pack ( ser_obj , mpi_comm_world ) ; //",
    "pack    mpi_send ( pack_obj , slv , tag , mpi_comm_world ) ;   // send the packed object endfunction    function [ sl , result ] = receive_res ( )    [ stat ] = mpi_probe(-1,-1,mpi_comm_world ) ;    sl = stat.src ;    result = mpi_recv_obj(sl , tag , mpi_comm_world ) ; endfunction ....    a typical usage example of our mpi / nsp / premia framework is the evaluation of a large portfolio consisting of hundreds or even thousands of options to be priced .",
    "the pricing of a single option is not carried out using parallel computations but instead each option is priced on a single processor and because we have many processors at hand we can price several options simultaneously . although load - balancing for parallel computation is a very active field of research , we have restricted to a simplified `` robbin hood '' strategy for our tests .",
    "the code of fig .",
    "[ load - balance ] and fig .",
    "[ send - premia - obj ] , which enables to price a portfolio using a cluster in a way that the load of the cluster is well balanced between the different nodes , describes the load - balancing strategies we used in all our examples .",
    "first , the master sends one job to each slave and as soon as a slave finishes its computation and sends its answer back , it is assigned a new job .",
    "this mechanism goes on until the whole portfolio has been been treated .",
    "we considered several examples of portfolio described in sections  [ sec - regression ] , [ sec - comms - example ] , [ sec - portfolio - example ] . in section  [ sec - premia - tb ] ,",
    "we explained how a pricing problem can be saved in a file relying on the xdr library , henceforth in our examples , a portfolio will be a collection of files , each file describing a precise pricing problem .",
    "in the following tables , the columns _ time _ give the computation time in seconds whereas the columns _ speedup ratio _ give the ratio @xmath1 .",
    "when this ratio becomes close to @xmath2 , it indicates that a linear speedup has been achieved .",
    "the columns are labelled according to the way the _ premiamodel _ objects are passed from the master to a slave .",
    "there are three different labels : _ full load _ , _ nfs _ , _ serialized load_. the label _ full load _ means that the masters reads the content of the file describing the _ premiamodel _ object , then creates the object , serializes it , packs it and sends it to a slave , which in turn performs the different operations the other way round to recreate the _ premiamodel _ object .",
    "this way of transmitting objects highlights that the object created by the master would actually be useless if we could create a serialized _ premiamodel _ object directly from the file in which it is saved .",
    "going directly from the file to the serialized object without actually creating the object is precisely the purpose of the ` sload ` function ( see fig .",
    "[ fig - sload ] for a description of the function ) .",
    "this more direct way of transmitting an object is referred to by the _ serialized load _ label in the tables below .",
    "the cluster on which all the tests were carried out used a nfs file system , which makes it possible for the master to only send the name of the file to be read and let the slave read the file content instead of creating the object and sending it to the slave .",
    "the use of the nfs file system is referred to by the _",
    "label in the different tables .",
    "all our numerical tests were carried out on a @xmath3pc cluster of supelec .",
    "each node is a dual core processor : intel xeon-3075 2.66 ghz with a front side bus at 1333mhz .",
    "the two cores of each node share 4 gb of ram and all the nodes are interconnected using a gigabit ethernet network . in none of the experiments , did we make the most of the dual core architecture since our code is one threaded .",
    "hence , in our implementation a dual core processor is actually seen as two single core processors .",
    "the first example we studied has been brought to our knowledge by the premia development team which uses a bunch of non - regression tests to make sure that a change in the source code does not alter the behaviour of any algorithms .",
    "these non - regression tests are made of a single instance of any pricing problem which can be solved using premia  a pricing problem corresponds to the choice of a model for the underlying asset , a financial product and a pricing method for computing the pricing and sometimes also the delta ( first derivative of the option price with respect to the spot price ) .",
    "several sets of these tests exist with different parameters and are run at least once a day .",
    "this motivated us to implement a parallel version of these non - regression tests ; the speedups we managed to achieved are reported in tab .",
    "[ tab - tests ] , which shows that for a number of nodes less than @xmath4 we could achieve an almost linear speedup .",
    "the pricing problems are sent using the ` sload ` method but changing the way of sending problems has pretty much no effect on the computation time and speedup ratio because the communication time is negligible compared to the computation time of a single pricing problem .",
    "however , the decreasing of the speedup ratio when more than @xmath4 nodes are used indicates that the computation time of a single problem is too short .",
    "one way of improving the speedup ratio would be to create bunches of several pricing problems and send them all together which would considerably reduce the latency induced by communications : it is always advisable to send a single big message rather several smaller messages .",
    ".speedup table for the non - regression tests of _ premia_. [ cols=\"^,^,^ \" , ]",
    "in this work , we explained how we could use nsp with the two toolboxes mpi and premia to address the difficult problem of paralleling the valuation of a large portfolio .",
    "the use of nsp makes the paralleling very easy as all the code can be written in an intuitive scripting language . for our examples",
    ", we chose a simplified robbin hood approach as far as load balancing is concerned and it already provides very good speedups . one way of improving the speedups would be to improve the load balancing mechanism .",
    "the first idea is to gather several pricing problems and send them all together to reduce the communication latency .",
    "the bottle neck in the approach we used in the examples is that the computation assigned to the first slave process i d done before the master has already assigned the last slave a job .",
    "one way of encompassing this difficulty is to divide the nodes into sub - groups , each group having its own master .",
    "then , each sub - master could apply a naive load balancing but since it has fewer slave processes to monitor the speedups would be better ."
  ],
  "abstract_text": [
    "<S> financial institutions have massive computations to carry out overnight which are very demanding in terms of the consumed cpu . </S>",
    "<S> the challenge is to price many different products on a cluster - like architecture . </S>",
    "<S> we have used the premia software to valuate the financial derivatives . in this work , </S>",
    "<S> we explain how premia can be embedded into nsp , a scientific software like matlab , to provide a powerful tool to valuate a whole portfolio . finally , we have integrated an mpi toolbox into nsp to enable to use premia to solve a bunch of pricing problems on a cluster . </S>",
    "<S> this unified framework can then be used to test different parallel architectures . </S>"
  ]
}