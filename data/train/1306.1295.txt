{
  "article_text": [
    "tensor computations play a crucial role in the studies of general relativity ( gr ) .",
    "however , in typical cases those calculations are tediously complicated . fortunately , with the development of symbolic calculation in computer technology",
    ", a number of computer packages have been built to calculate the gr tensors , including grtensor @xcite , xact @xcite , ricci @xcite , and so on .",
    "general relativitists would most likely find whatever functionality they need in those packages and work with them .",
    "however , in case the researchers do have a need to modify some internals of the packages , or hope to have a complete understanding of the package they use , things become complicated .",
    "although many packages are kindly provided open source , they have in general a heavy code base . for example",
    ", the latest xact package has over 20,000 lines of code ( loc ) , where the xtensor.m file alone has more than 8,000 loc .",
    "as another example , the ricci package has over 7,000 loc .",
    "there is definitely nothing wrong with heavy weight packages which provide as many functionalities as possible .",
    "but on the other hand , it would also be helpful to have lightweight packages which are easy for the users to understand the underlying mechanisms and modify them when needed .",
    "the _ mathgr _",
    "package is built for this purpose .",
    "currently , _",
    "mathgr _ has about 500 loc , and those numbers will not grow significantly in the future . the package is also built modularly , separating the tensor manipulation , gr definitions , integration by parts , specific model definition , general utilities , display parser into different files .",
    "while keeping to be lightweight , _ mathgr _ still provides competing functionalities for gr computations , with fast speed .",
    "the functionalities of _ mathgr _ include    * tensor simplifications with symmetries .",
    "symmetries , anti - symmetries for any subset of indices , and any permutational symmetries defined by the _ mathematica _",
    "cycles can be brought into unique forms , such that if there can be cancellation between terms in an expression , they indeed cancel each other after simplification . * tensor calculations with either abstract or explicit ( or mixed ) indices , and decomposition from abstract indices to explicit ones .",
    "for example , tensors with abstract tensor indices such as the ones inside the calculation of the ricci scalar ( where the dummy indices denotes summation throughout this paper and assumed by the package ) @xmath0 can be calculated and simplified , and later decomposed if needed , with builtin command into @xmath1 where dot denotes derivative with respect to the 0 index , and @xmath2 run from @xmath3 to @xmath4 and @xmath5 run from @xmath6 to @xmath4 .",
    "alternatively , one can also decompose the @xmath2 indices into completely explicit indices @xmath7 , or decompose @xmath5 indices into explicit indices @xmath8 . * simplification with total derivatives .",
    "when expanding an action of a physical system , total derivatives can either be dropped or reduced into boundary terms .",
    "_ mathgr _ can try to reduce a given expression into total derivatives plus the rest of the terms which are minimal under various conditions . , or the remaining terms has minimal leaf count . however ,",
    "in the leaf count case , _ mathgr _ can not guarantee to give the simplest result because there is no general algorithm for such reduction as far as we know . ] for example , @xmath9\\end{aligned}\\ ] ] * cosmic perturbations .",
    "there is a builtin model calculating gr tensors for the frw metric with adm type perturbations .",
    "this model can on the one hand be used directly for the research of inflationary cosmology , and on the other hand provide an example for writing models . *",
    "make use of _ mathematica _ s builtin tensor engine . since _",
    "mathematica _ 9.0 ,",
    "a symbolic tensor engine is introduced .",
    "this engine is powerful and fast in reducing tensors with symmetries into unique forms .",
    "however , the interface of the tensor engine is in the coordinate independent form .",
    "the input looks like : @xmath10 arrays[{dim , dim , dim } , complexes , antisymmetric[{1 , 2 } ] ] ) ; tensorreduce [ tensorcontract[t\\[tensorproduct]t , { { 1 , 5 } , { 2 , 6 } , { 3 , 4 } } ] - tensorcontract[t\\[tensorproduct]t , { { 1 , 4 } , { 2 , 6 } , { 3 , 5 } } ] ] } }    & & \\verb!$assumptions = ( t !     \\in",
    "\\verb!arrays[{dim , dim , dim } , complexes , antisymmetric[{1 , 2 } ] ] ) ; !     \\\\",
    "\\nonumber    & & \\verb!tensorreduce[tensorcontract[t !",
    "\\otimes    \\verb!t , { { 1 , 5 } , { 2 , 6 } , { 3 , 4 } } ] ] !     \\\\",
    "\\nonumber & & \\quad    - \\verb!tensorreduce[tensorcontract[t !    \\otimes    \\verb!t , { { 1 , 4 } , { 2 , 6 } , { 3 , 5 } } ] ] !",
    "\\endaccsupp{}\\end{aligned}\\ ] ] and the corresponding output is @xmath11 = -2 tensorcontract[t !",
    "\\otimes    \\verb!t , { { 1 , 4 } , { 2 , 6 } , { 3 , 5}}]!\\end{aligned}\\ ] ] + for many physicists , the above notation is not obvious , especially in case those notations come together with an expression with thousands of terms .",
    "_ mathgr _ makes use of the above engine , but the input and output now takes the form + @xmath12 t[dn@\"c \" , dn@\"a \" , dn@\"b \" ] - t[dn@\"a \" , dn@\"b \" , dn@\"c \" ] t[dn@\"a \" , dn@\"c \" , dn@\"b \" ] ] ( * -2 t[dn[\"a \" ] , dn[\"b \" ] , dn[\"c \" ] ] t[dn[\"a \" ] , dn[\"c \" ] , dn[\"b \" ] ] * ) } }    \\mathrm{simp}[t_{abc}t_{cab } - t_{abc}t_{acb } ] \\qquad\\rightarrow\\qquad   - 2 t_{abc}t_{acb } \\endaccsupp{}\\end{aligned}\\ ] ] + on the other hand , for people using _",
    "version lower than 9.0 , _ mathgr _ provides a simple tensor simplification engine , which can still do some calculations such as cosmic perturbations , but is not powerful enough to simplify tensor with symmetries ( except totally symmetric ) or permutation of indices .    with the lightweight code base and modularity ,",
    "we hope _ mathgr _ is helpful for researchers who have a demand to modify the internal functionality of a package , or those who want to take part of the internal technology from the package to build their own tools .",
    "moreover , the development is test driven . unit tests and integrated tests are provided thus the modifications by users are safer if all tests are passed .",
    "_ mathgr _ can be installed with the following steps :    * download the _ mathgr _ package from https://github.com/tririver/mathgr/releases/tag/v0.1 .",
    "( future updates will also be hosted on https://github.com/tririver/mathgr . ) * unpack the package . *",
    "rename the directory name ` mathgr-0.1 ` ( or any other version number ) to ` mathgr ` .",
    "note that ` mathgr ` is the directory which contains ` mathgr.m ` together with other files .",
    "* setup path so that _ mathematica _ can find and load _ mathgr_. two options are provided here : * * install : move the ` mathgr ` directory into a directory that _ mathematica _ can find by default .",
    "one can find out the default directory by evaluating ` $ path ` in _",
    "mathematica_. depending on operating systems , the typical directories are + [ cols=\"^,^\",options=\"header \" , ]    * * use without installation : one can put _ mathgr _ anywhere and use ` setdirectory ` to specify the load directory .",
    "the structure of the _ mathgr _ package.,scaledwidth=90.0% ]    the _ mathgr _ package is built in 3 tiers . the structure is illustrated in fig .  [ fig : structure ] , where tier 2 depends on tier 1 only , and tier 3 can depend on anything .    in this section",
    "we introduce the functions provided by each module . to make the notation less cluttered , we have used upper and lower indices in the tensor notations . for example , the inputform of @xmath13 should be input as ] where @xmath14 is a variable .",
    "however , once @xmath14 is a variable and assigned to a value like @xmath15 , the indices will have the same replacement and will not work as desired ( unless one does it by purpose ) .",
    "thus it is in general recommended to use strings as indices ( or clear and protect the indices before usage if variables are preferred ) . ]",
    "@xmath16 , dn[\"a \" ] , dn[\"b \" ] , dn[\"c\"]]!\\end{aligned}\\ ] ] one can load the typeset.m package ( to be introduced later ) using @xmath17!\\end{aligned}\\ ] ] after which the inputform is displayed as @xmath13 .",
    "one may either copy this @xmath13 to future input to increase readability , or keep the style of inputform .",
    "alternatively , one may load most of mathgr packages with one command = ... is the desired output , instead of part of input . ]",
    "@xmath18 !",
    "\\\\ \\nonumber    & & \\verb!out [ ] = mathgr , by yi wang ( 2013 , 2014 ) , https://github.com/tririver/mathgr . ! \\\\",
    "\\nonumber    & & \\verb!bugs can be reported to https://github.com / tririver / mathgr / issues!\\\\ \\nonumber    & & \\verb!loaded components tensor , decomp , gr , ibp , typeset , util.!\\end{aligned}\\ ] ]      the module tensor.m provides functions for general tensor calculation and simplification . to make use of tensor.m",
    ", we first load the package using @xmath19!\\end{aligned}\\ ] ] the publicly defined functions and symbols are    * _ _ define indices _ _ ] '' is not allowed ( and never necessary in gr ) . ] : this step is optional . as we have encountered previously , we have used up and dn as type identifiers of indices .",
    "if this is satisfying , nothing in addition needs to be done . on the other hand",
    ", one can define type identifier of indices oneself , for example @xmath20!\\end{aligned}\\ ] ] here `` \\{myu , myd } '' are the new identifiers , `` mydim '' is the dimensions of the manifold on which those indices are defined .",
    "`` greekidx '' is a list , which shows the indices to use for dummy indices .",
    "other choices are latinidx and latincapitalidx , myu[``a '' ] ] is not allowed . ] .",
    "`` red '' is the color in which the indices are typeset .",
    "any other color that builtin in mathematica can be chosen .",
    "+ actually , the identifiers `` \\{up , dn } '' are similarly defined in the package : @xmath21!\\end{aligned}\\ ] ] + as we shall cover in the next sessions , metrics can be defined associated to types of indices . thus defining",
    "the type of indices essentially defines manifold or sub - manifold .",
    "this provides a mechanism to deal with tensor decomposition from high dimension to lower dimensions . *",
    "_ declare tensor symmetry ( declaresym ) _ :",
    "this step is also optional .",
    "if a tensor has no symmetry , one can use the tensor directly without declaration . on the other hand , for tensors with symmetry , one had better to declare the symmetry such that _ mathgr _ can make use of this symmetry to simplify the tensor .",
    "+ the symmetry of a tensor @xmath22 can be declared using @xmath23!\\end{aligned}\\ ] ] here the list of indices are a sequence of up and dn ( or user defined index identifiers ) , representing upper and lower indices respectively .",
    "the symmetry could be either symmetric or antisymmetric of some slots , or some generic cyclic symmetries .",
    "the grammar for `` symmetry '' here is identical to the one defined in the _ mathematica _ symbolic tensor system thus one can check _ mathematica _ documentation for more details .",
    "+ for example , @xmath24!\\end{aligned}\\ ] ] defines a tensor @xmath25 } }    t_{abc } ~ , \\endaccsupp{}\\end{aligned}\\ ] ] + where the indices @xmath26 can be any other indices , but upper and lower are distinguished here , as usual in gr . here",
    "the tensor is anti - symmetric with permutation of @xmath27 indices . in case of totally symmetric tensor ( declared by symmetric[all ] ) , declaresym also sets the attribute of @xmath22 to be orderless , thus the simplifications are made automatically before sending to the simplification engine . *",
    "_ delete tensor symmetry ( deletesym ) _ : the operation declaresym can be undone by deletesym .",
    "for example , @xmath28!\\end{aligned}\\ ] ] removes the symmetry defined above . *",
    "_ simplify tensors ( simp ) _ : an expression ( optionally with pre - defined symmetries ) is brought into a unique form by the command simp .",
    "this ensures cancellation between different terms in the expression , which can be transformed into each other by using symmetry , or with redefinition of dummy indices .",
    "for example , for the tensor @xmath22 defined above , one can run @xmath29 ! \\\\",
    "\\nonumber      & & \\beginaccsupp{actualtext={t[dn@\"a \" , dn@\"b \" , dn@\"c\"]t[dn@\"m \" , dn@\"n \" , dn@\"b\"]-t[dn@\"b \" , dn@\"a \" , dn@\"c\"]t[dn@\"n \" , dn@\"m \" , dn@\"b\"]}}t_{abc}t_{mnb } - t_{bac}t_{nmb } \\endaccsupp { } \\verb ! //",
    "simp!\\\\ \\nonumber      & & \\verb!out [ ] = 0 !    \\end{aligned}\\ ] ] less trivial examples are considered when introducing gr.m , with simplification of curvature tensors .",
    "+ there is also a list named simphook .",
    "this is a list of rules that the user wants to apply before and after simplification .",
    "the rules are in the format of rule or ruledelayed , e.g. @xmath30 : > t f[dn@\"a \" , dn@\"b \" , dn@\"c \" ] } } t_{abc }   \\verb ! :> !",
    "t*f_{abc } \\endaccsupp { } \\verb ! } !    \\end{aligned}\\ ] ] + note that the simp function does a lot to simplify the expressions , including making assumptions and communicating with the mathematica command tensorreduce .",
    "if a tensor expression is expected to contain lots of terms ( say , more than @xmath31 ) after simp , and each term is very simple , simp becomes then overkilling and slow . in this case",
    ", one may try to speed up by @xmath32 !",
    "\\end{aligned}\\ ] ] in this case dummy indices are re - arranged .",
    "however , different forms of a tensor are not guaranteed to be brought to the same form . especially , the defined symmetries are not considered ( except for the totally symmetric ones ) .",
    "on the other hand , the operation can be order - of - magnitude faster .",
    "+ note that for mathematica versions lower than 9 , simp is default to fast method because of lack of builtin function tensorreduce . * _ partial derivative ( pd ) _ : here we define the partial derivative pd separately , instead of modifying the systemwide partial derivative d. the partial derivative can be called as @xmath33 , dn[index ] ] !    \\end{aligned}\\ ] ] which displayed as @xmath34 , where @xmath35 is actually \\[capitalsampi ] in _ mathematica _ , which looks like @xmath35 ( we try to avoid modifying system symbols such as the real @xmath35 ) .",
    "+ the derivative pd has linearity and leibniz rules builtin .",
    "+ internally , the ` pd ` derivative is evaluated into an object named ` pdt ` , with @xmath36 = pd[ ... pd[pd[f , a1 ] , a2 ] , ... ] ! ~,\\end{aligned}\\ ] ] where ` pdvars ` is a pre - defined orderless function . the reason to convert ` pd ` into ` pdt ` is that , by using ` pdvars ` , the orderlessness of partial derivative is transparent .",
    "then it is possible to define general rules on partial derivatives .",
    "+ by default , the partial derivative acting on all tensors or scalars are nonzero . to define constants with vanishing partial derivative",
    ", one has to declare explicitly .",
    "for example @xmath37 , _ ] : = 0!\\end{aligned}\\ ] ] defines both f1 and f2[@xmath38 as constants .",
    "+ note that this `` define constant '' approach is different from the builtin derivative in _ mathematica _ , where without explicit function dependence , the variable is by default considered as constant .",
    "we consider the former to be safer for our purpose , otherwise one may forget to define non - constants . * _",
    "( anti-)symmetrize tensors ( sym , antisym ) _ : the command @xmath39 !    \\end{aligned}\\ ] ] symmetrizes the tensor .",
    "when indices are not given , all free indices are symmetrized .",
    "for example , sym[@xmath40 gives @xmath41 .",
    "note that we do not add factors as @xmath42 here .",
    "the function antisym does similar things , only that a sign is added in front of each terms , determined by if the permutation is even or odd .",
    "* _ the kronecker @xmath43 symbol ( dta ) _ : the simplification of quantities like @xmath44 is automatic . without the need of calling simp , this quantity is directly evaluated into @xmath45 . on the other hand ,",
    "if there are standalone @xmath46 which can not be simplified , @xmath46 is replaced by @xmath47}_{ab}$ ] .",
    "this holdform is released when doing simp .",
    "finally , dta@xmath48 gives defaultdim , which denotes dimension of space or spacetime , but without predefined value .",
    "note that here we adopt the convention that , the kronecker symbol s indices are not raised or lowered by the metric .",
    "for example , @xmath49 is not @xmath50 , instead , @xmath51 if @xmath52 and @xmath53 if @xmath54 , for any metric .",
    "this convention is used , as far as i know , widely in modified gravity and cosmic perturbations .",
    "also , note that expressions such as @xmath49 and @xmath55 does not raise / lower indices ( e.g. @xmath56 , which has the same outcome as @xmath57 and @xmath58 ) ,    before ending up this subsection , let us also briefly explain the tensor simplification mechanism under the hood .",
    "the @xmath59 function ( unless used with the @xmath60 option ) calls @xmath61 to simplify tensors . and",
    "this is why at least version 9 of _ mathematica _ is needed when one needs the full power of tensor simplification .",
    "the procedure is described in fig .",
    "[ fig : tensor ] .",
    "the tensor symmetries defined at @xmath62 are provided as assumptions of @xmath61 .",
    "the tensors , on the other hand , are put into coordinate - independent abstract forms before sending into @xmath61 .",
    "the procedure to simplify a tensor.,scaledwidth=60.0% ]      this package includes definitions which have made use of a metric . to load the package , use @xmath63!\\end{aligned}\\ ] ]    * _ metric definition and usage _ : one may use a metric without any definition .",
    "however considering the symmetry and the associated inverse metric , it is convenient to define a metric before usage .",
    "moreover , there is also a predefined metric g , which is used by default to calculate metric contractions and curvature tensors .",
    "a metric can be defined either globally or locally .",
    "the global definition of a metric @xmath64 is ( this metric g predefined in gr.m ) @xmath65!\\end{aligned}\\ ] ] with this definition , _ mathgr _ declares symmetry for both the metric @xmath66 and the inverse metric @xmath67 .",
    "also @xmath68 and @xmath69 are both aliased to @xmath70 .",
    "the derivative acting on the inversed metric @xmath71 is replaced using the identity @xmath72 .",
    "also , when calculating gr quantities such as ricci scalar r [ ] ( to be introduced below ) , those quantities are calculated with respect to this metric . + when needed , one can define additional metrics , associated with other identifier of index classes ( and thus on a different manifold ) , as @xmath73 !",
    "\\nonumber \\\\    & & \\verb!usemetric[myg,{myu , myd}]!\\end{aligned}\\ ] ] + alternatively , one can use a metric locally , without affecting the global metric .",
    "there are two related function usages : + one can define a metric , say @xmath74 , with all metric proprieties but without assigning the system s default metric to @xmath74 , using @xmath75!\\end{aligned}\\ ] ] + also , one can temporarily define a metric and do some calculation with it , using , e.g. @xmath76!\\end{aligned}\\ ] ] here the ( some tensors ) are calculated using metric @xmath77 , but outside the withmetric environment , the default metric is still @xmath64 . * _ curvature related symbols and tensors _ : the affine connection @xmath78 ( named affine in _ mathgr _ ) , intrinsic curvature tensors r@xmath79 , r@xmath80 , r@xmath81 , r [ ] , extrinsic curvature tensors k@xmath82 , k [ ] are defined and will be calculated when called . there is also a tensor radm [ ] , which differs from the ricci scalar r [ ] by a total derivative .",
    "+ for example , @xmath83 // simp ] !      \\\\",
    "\\nonumber    & & \\verb!out [ ] = ! \\frac{3}{4 } g^{ab}g^{cd}g^{ef}\\partial_e g_{ac}\\partial_fg_{bd }      \\verb ! + 6 other terms !    \\end{aligned}\\ ] ] calculates and simplifies the ricci scalar with a temporary metric @xmath64 .",
    "note that by default , everything is calculated directly down to metrics . on the other hand , in case one wants to , for example , calculate r [ ] to affine connection and stops , one can locally rename the affine connection to block the calculation going on .",
    "for example , @xmath84 // simp ] !      \\\\",
    "\\nonumber      & & \\verb!out [ ] = !",
    "-g^{ab}\\mathrm{gam}^c{}_{ad}\\mathrm{gam}^d{}_{cb } \\verb",
    "! + 3 other terms !    \\end{aligned}\\ ] ] + the covariant derivative is also defined , via @xmath85 !",
    "\\end{aligned}\\ ] ] as is standard in gr .",
    "+ for example , one can check the second bianchi identity for the curvature tensor @xmath86 , dn@\"e \" ] + covd[r[dn@\"a \" , dn@\"b \" , dn@\"d \" , dn@\"e \" ] , dn@\"c \" ] + covd[r[dn@\"a \" , dn@\"b \" , dn@\"e \" , dn@\"c \" ] , dn@\"d \" ] ] // simp } }      \\verb!withmetric[g , covd[!r_{abcd}\\verb ! , dn[e ] ] + covd[!r_{abde}\\verb ! , dn[c ] ] + covd[!r_{abec}\\verb ! ,",
    "dn[d ] ] // simp ] !",
    "\\endaccsupp { }     \\\\ \\nonumber    & & \\verb!out [ ] = 0 !    \\end{aligned}\\ ] ] * _ contraction with metric _",
    ": one can definitely use the straightforward way to do contraction .",
    "for example , @xmath87 = g[up[#1 ] , up[#2 ] ] f[dn[#1 ] , dn[#2 ] ] & [ unique [ ] , unique [ ] ] !      \\\\",
    "\\nonumber      & & \\verb!out [ ] = g[up[$6 ] , up[$7 ] ] f[dn[$6 ] , dn[$7 ] ] !    \\end{aligned}\\ ] ] note that here we have introduced unique variables .",
    "( the `` $ 6 '' and `` $ 7 '' are unique variables as returned by mathematica , where the number could be not 6 , 7 but rather any other numbers . )",
    "otherwise there is a danger that if we use @xmath88 elsewhere with other tensors , the dummy indices of @xmath88 may coincide with the indices of other tensors and cause mistake . to make the unique [ ] function easier to use",
    ", we defined uq[n ] to stand for a sequence of unique variables .",
    "thus the above equation can be written as @xmath87 = g[up[#1 ] , up[#2 ] ] f[dn[#1 ] , dn[#2 ] ] & @uq[2 ] !      \\\\",
    "\\nonumber      & & \\verb!out [ ] = g[up[$8 ] , up[$9 ] ] f[dn[$8 ] , dn[$9 ] ] !    \\end{aligned}\\ ] ] + however , the above expression is still long , and the length will grow quickly with lots of contractions . to save writing ,",
    "we provide a function metriccontract , which is nothing fundamental , but a shorthand of writing , to allow contraction with the default metric .",
    "the above example can be rewritten as @xmath89 = f[dg[1 ] , dg[1 ] ] // metriccontract //",
    "simp !    \\\\",
    "\\nonumber    & & \\verb!out [ ] = ! f_{ab}g^{ab}\\end{aligned}\\ ] ] where dg and ug are a new type of indices , which is parsed by metriccontract .",
    "the same labels are contracted using the default metric . here",
    "simp is used to rewrite the dummy indices into familiar ones .",
    "+ multiple contractions can be calculated similarly , for example @xmath90 = f[dg[1 ] , dg[2 ] ] f[dg[2 ] , dg[3 ] ] f[dg[3 ] , dg[1 ] ] //",
    "simp !    \\\\",
    "\\nonumber    & & \\verb!out [ ] = !",
    "f_{ab } f_{cd } f_{ef } g^{af } g^{bc } g^{de}\\end{aligned}\\ ] ] the above example calculates @xmath91 , in case only @xmath92 with lower indices are defined .",
    "the decomposition module can be loaded by @xmath93!\\end{aligned}\\ ] ]    _ decomposition of tensors into lower dimensional ones ( decomp ) _ : this function converts the dummy indices of @xmath94 dimensional tensors into @xmath95 and @xmath4 dimensional indices respectively .",
    "explicit indices can also be used .",
    "the explicit indices are marked as ue[n ] and de[n ] for upper and lower indices respectively , where n is a number .",
    "the usage is @xmath96 !",
    "\\end{aligned}\\ ] ] if indices are not given , all dummy indices are decomposed .",
    "the rules are of the form , for example , @xmath97 where the lower or upper index is converted into one explicit index de[0 ] or ue[0 ] , and another abstract index .",
    "there are a number of predefined decomposition schemes , namely    decomp0i[expression , indices ] : convert indices into 0 and i components .",
    "the rule is as illustrated above .",
    "decomp01i[expression , indices ] : convert indices into 0 , 1 , i components .",
    "decomp0123[expression , indices ] : convert indices into all explicit indices , 0 , 1 , 2 , 3 .",
    "decomp1i[expression , indices ] : convert indices into 1 , i components .",
    "decomp123[expression , indices ] : convert indices into all explicit indices , 1 , 2 , 3 .",
    "decompse[expression , indices ] : convert indices into two parts , where both parts has general dimensions .",
    "again if the indices are not explicitly specified , all dummy indices are converted .",
    "the free indices , if exist , are not touched .    in those predefined schemes ,",
    "the original class identifier of indices are \\{utot , dtot}. for example ,    @xmath98 b[dtot[\"a \" ] ] ] !    \\\\",
    "\\nonumber    & & \\verb!out [ ] = a[u1[\"!\\alpha\\verb!\"]]*b[d1[\"!\\alpha\\verb ! \" ] ] + a[u2[\"a\"]]*b[d2[\"a\"]]!\\end{aligned}\\ ] ]    here after decomposition , the indices are identified by \\{u1 , d1 } , and \\{u2 , d2 } ( those index identifiers are defined in decomp.m , with dimensions dim1 and dim2 ) .    as another example , @xmath99 b[dtot[\"a \" ] ] ] !    \\\\",
    "\\nonumber    & & \\verb!out [ ] = a[ue[0]]*b[de[0 ] ] + a[up[\"a\"]]*b[dn[\"a\"]]!\\end{aligned}\\ ] ] here the indices are converted into one explicit index and another abstract index .    to further ease the calculation",
    ", there is a list decomphook , which contains a set of replacement rules to be applied after the decomposition .",
    "a frequent use case is to specify the explicit form of the higher dimensional metric using those set of rules , as illustrated in the model file frwadm.m .",
    "one may define some `` homogeneous and isotropic background '' quantities with @xmath100:=0     ( * but pd[b , de[0 ] ] is not zero * ) !",
    "\\end{aligned}\\ ] ]      one typical use case for a gr package is to expand an action @xmath101 where if @xmath102 does not have boundary , total derivatives in @xmath103 can be dropped ( e.g. @xmath104 ) .",
    "if @xmath102 has a boundary , those total derivatives can be reduced into boundary terms on the boundary @xmath105 .    for this purposes",
    ", we developed a module to factor @xmath103 into total derivatives and the rest part .",
    "as usual , integration - like operations needs more intelligence than derivative - like operations .",
    "this module does not guarantee to find the total derivative for complicated cases .",
    "nevertheless it works for simple cases and provide convenience for research .    in case that @xmath103 is a pure total derivative ,",
    "the final target result is unique .",
    "however , typically , @xmath103 is a total derivative plus some rest part . here depending on use cases ,",
    "we designed different criteria to try minimizing the rest part :    * _ eliminate derivatives on a variable _ : this can be used in a variation principle .",
    "for example , @xmath106!\\\\      & & \\verb!ibp[y pd[x , dn[\"i \" ] ] , ibpvar[x ] ] !    \\end{aligned}\\ ] ] tries to eliminate derivatives acting on @xmath107 , and gives a result @xmath11 = -x pd[y , dn[\"i \" ] ] + pdhold[x y , dn[\"i\"]]!\\end{aligned}\\ ] ] here pdhold is a function defined to hold total derivatives .",
    "one can release this held total derivative by replacing it to pd , or alternatively set it to zero by pdhold[__]=0 if the manifold does not have a boundary . * _ bring the rest part into standard form of a second order action _ : in this case ibp will try to eliminate terms in the rest part with more than two time derivatives on it . and the terms like @xmath108 is transformed into @xmath109pdhold[@xmath110 , de[0 ] ] .",
    "the usage is @xmath111 , ibpstd2 ] !      \\\\",
    "\\nonumber      & & \\verb!out [ ] = -(x^2*pd[f , de[0]])/2 + pdhold[(f*x^2)/2 , de[0 ] ] !    \\end{aligned}\\ ] ] * _ leaf count _ :",
    "if no criteria is given to ibp , i.e. ibp is called as ibp[expression ] , the leafcount function is applied to compare the rest part .    internally , the ibp function works as follows : first , a set of rules with patterns are defined for integration by parts . then every possible rule is applied to the expression and the result is sorted .",
    "the one with simplest rest part is chosen and the same set of rules are tried repeatedly on the new result until a fixed point is reached .",
    "it is easy to extend the above algorithm such that the rules are applied multiple times before the result is sorted and selected .",
    "however in this case the time complexity increase quickly . in typical use cases ,",
    "ibp may deal with expressions with of order 1000 or more terms ( considering the complexity of the gravitational action ) . in this case",
    "multiple - step rules are not realistic .    here",
    "we have introduced the ibp function motivated by expanding an action . on the other hand , this function can be certainly used for other purposes , as long as total derivatives are wanted .      as we mentioned at the beginning of this section , the output of _ mathgr _ can be parsed and brought into a better looking form . for this purpose , the package typeset.m should be loaded .",
    "no functions are provided in typeset.m . instead , this module use makeboxes and makeexpression to define the appearance for the tensors .",
    "there are also predefined typeset styles for partial derivatives .",
    "partial derivative acting on an abstract index is displayed as capital sampi , and time derivative ( w.r.t de[0 ] ) is denoted by dot .      to ease some typical calculations ,",
    "some utilities are provided .",
    "those utilities are not directly about tensor calculation but can save some writing for those calculations . the utilities can be loaded using @xmath112!\\end{aligned}\\ ] ] and provide    * _ solveexpr _ : by default , the variable to be inputted to the _ mathematica _ command solve should be atomic or a simple function .",
    "expressions with head plus , times and power are not allowed .",
    "solveexpr solves this problem .",
    "for example , one can use @xmath113 !      \\\\ \\nonumber      & & \\verb!out [ ] = { { x^2 - > -y } } !",
    "\\end{aligned}\\ ] ] to find a solution of @xmath114 .",
    "to realize this , solveexpr first replace @xmath114 by a unique temporary variable , solve the equation and replace the temporary variable back with @xmath114 .",
    "* _ series expansion and coefficients _",
    ": + in _ mathgr _ , the default variable to control orders of perturbations is named eps . in case of a perturbation theory calculation ,",
    "one multiplies every perturbation variable by eps and expand them together ( an example can be found in frwadm.m ) . the series expansion and extracting the coefficients simply makes use of _ mathematica _ functions series and coefficient .",
    "to save some writing , one can use @xmath115!\\end{aligned}\\ ] ] where n is an explicit integer , to expand expression up to nth order in eps , or @xmath116!\\end{aligned}\\ ] ] to extract the order eps@xmath117 terms in the expression and disregard all other terms .",
    "simplification function simp is called automatically after expansion or extraction of coefficients .",
    "to illustrate an explicit use case of the package , here we calculate the cosmic perturbations of inflationary cosmology up to second order .",
    "the result is well known for decades @xcite ( for a review with the same notation used here , see @xcite ) . nevertheless to present a standard and familiar calculation for illustration purpose may be more useful for a manual compared with presenting a new and unfamiliar calculation .    here",
    "we present the input , the explanations and the final results .",
    "the intermediate outputs are long and is available in the file resources / mathgr_manual.nb    the model specification of a frw universe with adm type perturbations can be loaded by @xmath118!\\end{aligned}\\ ] ] here the metric @xmath66 is defined by @xmath119 where @xmath120 where @xmath121 .",
    "note that for simplicity only the scalar sector is considered in @xmath122 .",
    "we have yet one gauge degree of freedom in the scalar sector .",
    "we can fix the gauge by either set @xmath123 , or set the inflaton field to be homogeneous and isotropic .",
    "we shall consider the latter case as an example .",
    "the action up to second order can be calculated with @xmath124:= 0 ( * total derivatives can be neglected here . * ) ! \\\\    & & \\verb!pd[!\\phi\\verb!|pd[!\\phi\\verb ! , de[0 ] ] , _",
    "dn]:= 0 ( * the inflaton perturbation is gauged away . * ) ! \\\\   & & \\verb!s012 = sqrtg ( radm[]/2 + decompg2h[x[!\\phi\\verb ! ] ] - v[!\\phi\\verb ! ] ) //",
    "ss[2]!\\end{aligned}\\ ] ] here decompg2h is a function provided in frwadm.m ( may move to more general places in case other models also need this function ) .",
    "this function calls decomp0i to decompose a 4-dimensional quantity into 3 + 1 dimensions , where in the 4-dimensional quantities the metric @xmath64 is used and in the 3-dimensional quantities the metric @xmath74 is used .",
    "the background equation of motion can be derived by the first order action . for this purpose",
    ", we extract the first order action and consider the variation principle : @xmath125 ! \\\\    & & \\verb!solbg = solveexpr[{d[s1 , !",
    "\\alpha\\verb!]==0 , d[ibp[s1 , ibpvar[!\\zeta\\verb ! ] ] , !",
    "\\zeta\\verb!]==0 } , { v[!\\phi\\verb ! ] , pd[!\\phi\\verb ! , de@0]^2 } ] ! \\\\    & & \\verb!simphook = union [ simphook , solbg[[1 ] ] ] ! \\end{aligned}\\ ] ] where on the second line the background equation of motion is solved .",
    "note that solveexpr is used because we want to eliminate a composed expression @xmath126 .",
    "also note that there are derivatives on @xmath127 in s1 .",
    "thus we should first do integration by parts before applying the variation principle d [ ... , @xmath127]=0 . on the third line",
    "the background solution is added to simphook .",
    "thus it will be automatically applied when simplifying the second order action .",
    "here we presented the usage of a new tensor package , _ mathgr _ , which is simple and lightweight , such that people can understand and modify the internal more easily .",
    "we shall keep the simplicity of the package .",
    "while new functionalities are expected to be added , we shall not add functionalities which significantly increase the complexity of the package , especially for the core parts tensor.m and gr.m .",
    "we shall in the future add more comments to the existing code , and add broader coverage for unit tests and integrated tests .",
    "those efforts will help for the users who want to hack and fork the package .",
    "finally but most importantly , as the package is being tested and used in realistic research , we expect to encounter bugs and provide bug fixes .",
    "as always , the result from _ mathgr _ should be checked by independent calculations before being trusted and used in research .",
    "we thank j.  m.  martin - garcia for comments on an earlier version of this paper .",
    "this work was supported by the world premier international research center initiative ( wpi initiative ) , mext , japan , a starting grant of the european research council ( erc stg grant 279617 ) , and the stephen hawking advanced fellowship .",
    "peter musgrave , denis pollney and kayll lake , http://grtensor.phy.queensu.ca/ ; peter musgrave , denis pollney and kayll lake 1996 `` grtensorii : a package for general relativity '' fields institute communications 15 313 - 318        v.  f.  mukhanov and g.  v.  chibisov , `` quantum fluctuation and nonsingular universe .",
    "( in russian ) , '' jetp lett .   *",
    "33 * , 532 ( 1981 ) [ pisma zh .",
    "fiz .   * 33 * , 549 ( 1981 ) ] .",
    "y.  wang , arxiv:1303.1523 [ hep - th ] ."
  ],
  "abstract_text": [
    "<S> we introduce the _ mathgr _ package , written in _ mathematica_. the package can manipulate tensor and gr calculations with either abstract or explicit indices , simplify tensors with permutational symmetries , convert tensors from abstract indices to partially or completely explicit indices and convert partial derivatives into total derivatives . </S>",
    "<S> frequently used gr tensors and a model of frw universe with adm type perturbations are predefined . </S>",
    "<S> the package is built around the philosophy to `` keep it simple '' , and makes use of latest tensor technologies of _ </S>"
  ]
}