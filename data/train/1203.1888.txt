{
  "article_text": [
    "dolev et al . @xcite introduced the notion of _ approximate byzantine consensus _ by relaxing the requirement of _ exact _ consensus @xcite . the goal in approximate consensus is to allow the fault - free nodes to agree on values that are approximately equal to each other ( and _ not necessarily _ exactly identical ) . in presence of byzantine faults , while _ exact _ consensus is impossible in _ asynchronous _",
    "systems @xcite , approximate consensus is achievable @xcite .",
    "the notion of approximate consensus is of interest in _ synchronous _ systems as well , since approximate consensus can be achieved using simple distributed algorithms that do _ not _ require complete knowledge of the network topology @xcite",
    ".    in this paper , we are interested in iterative algorithms for achieving approximate byzantine consensus in synchronous point - to - point networks that are modeled by arbitrary _ directed _ graphs .",
    "the _ iterative approximate byzantine consensus _ ( iabc ) algorithms of interest have the following properties , which we will soon state more formally :    * _ initial state _ of each node is equal to a real - valued _ input _ provided to that node . *",
    "_ validity _ condition : after each iteration of an iabc algorithm , the state of each fault - free node must remain in the _ convex hull _ of the states of the fault - free nodes at the end of the _ previous _ iteration .",
    "* _ convergence _ condition : for any @xmath1 , after a sufficiently large number of iterations , the states of the fault - free nodes are guaranteed to be within @xmath2 of each other .",
    "certain iabc algorithms have been shown to satisfy the above properties in _ fully connected _",
    "graphs @xcite , and in _ arbitrary directed _ graphs satisfying a tight necessary condition @xcite",
    ". please refer to @xcite for a summary of the related work .",
    "the main contribution of this paper is to develop an alternate proof of correctness for a iabc algorithm , which was proved correct in arbitrary graphs that satisfy a necessary condition developed in our prior work @xcite . the alternate proof is based on transition matrices that capture the behavior of the iabc algorithm executed by the fault - free nodes .",
    "this work is inspired by , and borrows some matrix analysis tools from , other work that also uses transition matrices in related contexts @xcite .",
    "this paper exploits the following observation : for a _ given _ evolution of the state vector corresponding to the state of the fault - free nodes , many alternate state transition matrices may potentially be chosen to emulate that evolution correctly . for a given state evolution ,",
    "we identify one approach to suitably `` design '' the transition matrices so that the standard tools can be applied to prove convergence of the byzantine fault - tolerant algorithm in _ all networks _ that satisfy a necessary condition ( proved in @xcite ) on the network communication graph . in particular , the transition matrix for each iteration is designed such that each row of the matrix contains a large enough number of elements that are bounded away from 0 .",
    "[ [ network - model ] ] network model : + + + + + + + + + + + + + +    the system is assumed to be _",
    "synchronous_. the communication network is modeled as a simple _ directed _ graph @xmath3 , where @xmath4 is the set of @xmath5 nodes , and @xmath6 is the set of directed edges between the nodes in @xmath7 .",
    "node @xmath8 can reliably transmit messages to node @xmath9 if and only if the directed edge @xmath10 is in @xmath6 .",
    "each node can send messages to itself as well , however , for convenience , we _ exclude self - loops _ from set @xmath6 .",
    "that is , @xmath11 for @xmath12 . with a slight abuse of terminology",
    ", we will use the terms _ edge _ and _ link _ interchangeably in our presentation .    for each node @xmath8 ,",
    "let @xmath13 be the set of nodes from which @xmath8 has incoming edges .",
    "that is , @xmath14 .",
    "similarly , define @xmath15 as the set of nodes to which node @xmath8 has outgoing edges .",
    "that is , @xmath16 .",
    "since we exclude self - loops from @xmath6 , @xmath17 and @xmath18 . however , we note again that each node can indeed send messages to itself .",
    "a necessary condition for correctness of an iabc algorithm for @xmath19 is that @xmath20 @xcite .",
    "node @xmath9 is said to be an _ incoming neighbor _ of node @xmath8 , if @xmath21 .",
    "similarly , @xmath9 is said to be an _ outgoing neighbor _ of node @xmath8 , if @xmath22 .",
    "[ [ failure - model ] ] failure model : + + + + + + + + + + + + + +    we consider the byzantine failure model , with up to @xmath0 nodes becoming faulty .",
    "a faulty node may _ misbehave _ arbitrarily .",
    "possible misbehavior includes sending incorrect and mismatching ( or inconsistent ) messages to different neighbors .",
    "the faulty nodes may potentially collaborate with each other .",
    "moreover , the faulty nodes are assumed to have a complete knowledge of the execution of the algorithm , including the states of all the nodes , contents of messages the other nodes send to each other , the algorithm specification , and the network topology .",
    "each node @xmath8 maintains state @xmath23 , with @xmath24 $ ] denoting the state of node @xmath8 at the _ end _ of the @xmath25-th iteration of the algorithm .",
    "initial state of node @xmath8 , @xmath26 $ ] , is equal to the initial _ input _ provided to node @xmath8 . at the _",
    "start _ of the @xmath25-th iteration ( @xmath27 ) , the state of node @xmath8 is @xmath28 $ ] .",
    "let @xmath29 denote the set of faulty nodes .",
    "thus , the nodes in @xmath30 are non - faulty . and @xmath31 , @xmath32 contains elements that are in @xmath33 but not in @xmath31 .",
    "that is , @xmath34 . ]",
    "* @xmath35 = \\max_{i\\in{\\mathcal{v}}-{\\mathcal{f}}}\\,v_i[t]$ ] . @xmath35 $ ] is the largest state among the fault - free nodes at the end of the @xmath25-th iteration . since the initial state of each node is equal to its input , @xmath36 $ ] is equal to the maximum value of the initial input at the fault - free nodes .",
    "* @xmath37 = \\min_{i\\in{\\mathcal{v}}-{\\mathcal{f}}}\\,v_i[t]$ ] . @xmath37 $ ] is the smallest state among the fault - free nodes at the end of the @xmath25-th iteration .",
    "$ ] is equal to the minimum value of the initial input at the fault - free nodes .",
    "the following conditions must be satisfied by an iabc algorithm in presence of up to @xmath0 byzantine faulty nodes :    * _ validity : _ @xmath39\\ge \\mu[t-1 ] ~\\mbox{~~and~~}~ ~u[t]\\le u[t-1]$ ] * _ convergence : _ @xmath40-\\mu[t ] = 0 $ ] .",
    "equivalently , @xmath41-v_j[t ] = 0 $ ] , for @xmath42 .",
    "an iterative algorithm is said to be _ correct _ if it satisfies the _ validity _ and _ convergence _ conditions .",
    "we will prove the correctness of algorithm 1 below in all graphs that satisfy the necessary condition in theorem 2 of @xcite .",
    "the algorithm should be performed by each node @xmath8 in the @xmath25-th iteration , @xmath43 .",
    "the faulty nodes may deviate from the algorithm specification . if a fault - free node does not receive an expected message from an incoming neighbor ( in the _ receive step _ below ) , then that message is assumed to have some default value .    ' '' ''    * algorithm 1 *    ' '' ''       steps to be performed by node @xmath8 in the @xmath25-th iteration :    1 .",
    "_ transmit step : _ transmit current state @xmath28 $ ] on all outgoing edges .",
    "_ receive step : _ receive values on all incoming edges .",
    "these values form vector @xmath44 $ ] of size @xmath45 .",
    "3 .   _ update step : _ sort the values in @xmath44 $ ] in an increasing order , and eliminate the smallest @xmath0 values , and the largest @xmath0 values ( breaking ties arbitrarily ) .",
    "let @xmath46 $ ] denote the identifiers of nodes from whom the remaining @xmath47 values were received , and let @xmath48 denote the value received from node @xmath49 $ ] .",
    "+ for convenience , define @xmath50 $ ] .",
    "+ observe that if @xmath51 $ ] is fault - free , then @xmath52 $ ] .",
    "+ define @xmath53 ~ = ~\\sum_{j\\in \\{i\\}\\cup n_i^*[t ] } a_i \\ , w_j \\label{e_z}\\end{aligned}\\ ] ] where @xmath54|+1}\\ ] ] recall that @xmath55 $ ] because @xmath11 .",
    "the `` weight '' of each term on the right - hand side of ( [ e_z ] ) is @xmath56 , and these weights add to 1 .",
    "+ observe that @xmath57 .",
    "+ for future reference , let us define @xmath58 as : @xmath59 note that @xmath60 . specifically , @xmath58 is a positive constant that is dependent only on @xmath0 and the graph @xmath3 .       ' '' ''",
    "similar algorithms have been proven to work correctly in _ fully connected _",
    "graphs @xcite and _ arbitrary directed _ graphs satisfying the necessary condition stated in @xcite . in this paper",
    ", we provide an alternate proof of correctness in such arbitrary graphs , using an alternate form of the necessary condition @xcite .",
    "we use boldface upper case letters to denote matrices , rows of matrices , and their elements .",
    "for instance , @xmath61 denotes a matrix , @xmath62 denotes the @xmath8-th row of matrix @xmath61 , and @xmath63 denotes the element at the intersection of the @xmath8-th row and the @xmath9-th column of matrix @xmath61 .    [ d_stochastic ] a vector is said to be _ stochastic _",
    "if all the elements of the vector are _ non - negative _ , and the elements add up to 1 .",
    "a matrix is said to be row stochastic if each row of the matrix is a stochastic vector .    for a row",
    "stochastic matrix @xmath64 , coefficients of ergodicity @xmath65 and @xmath66 are defined as @xcite : @xmath67 it is easy to see that @xmath68 and @xmath69 , and that the rows are all identical if and only if @xmath70",
    ". additionally , @xmath71 if and only if @xmath72 .",
    "the next result from @xcite establishes a relation between the coefficient of ergodicity @xmath73 of a product of row stochastic matrices , and the coefficients of ergodicity @xmath74 of the individual matrices defining the product .",
    "[ claim_delta ] for any @xmath75 square row stochastic matrices @xmath76 , @xmath77    claim [ claim_delta ] is proved in @xcite .",
    "it implies that if , for all @xmath8 , @xmath78 for some @xmath79 , then @xmath80 will approach zero as @xmath75 approaches @xmath81 .",
    "a row stochastic matrix @xmath61 is said to be a _ scrambling _ matrix , if @xmath82 @xcite .    in a scrambling matrix @xmath61 , since @xmath82 , for each pair of rows @xmath83 and @xmath84 , there exists a column @xmath9 ( which may depend on @xmath83 and @xmath84 ) such that @xmath85 and @xmath86 , and vice - versa @xcite . as a special case , if any one column of a row stochastic matrix @xmath61 contains only non - zero elements that are lower bounded by some constant @xmath79 , then @xmath61 must be scrambling , and @xmath87 .",
    "recall that @xmath29 is the set of faulty nodes .",
    "let @xmath88 . without loss of generality ,",
    "suppose that nodes 1 through @xmath89 are fault - free , and if @xmath90 , nodes @xmath91 through @xmath5 are faulty .",
    "denote by @xmath92 $ ] the column vector consisting of the initial states of all the _ fault - free _ nodes .",
    "denote by @xmath93 $ ] , where @xmath43 , the column vector consistsing of the states of all the _ fault - free _ nodes at the end of the @xmath25-th iteration , @xmath43 .",
    "the @xmath8-th element of vector @xmath93 $ ] is state @xmath24 $ ] .",
    "the size of the column vector @xmath93 $ ] is @xmath89 .",
    "[ claim_1 ] we can express the iterative update of the state of a fault - free node @xmath8 @xmath94 performed in ( [ e_z ] ) using the matrix form in ( [ e_matrix_i ] ) below , where @xmath95 $ ] satisfies the following four conditions .",
    "@xmath53 & = & { { \\bf m}}_i[t ] ~ { { { \\bf v}}}[t-1 ] \\label{e_matrix_i}\\end{aligned}\\ ] ] in addition to @xmath25 , the row vector @xmath95 $ ] may depend on the state vector @xmath96 $ ] as well as the behavior of the faulty nodes in @xmath29 . for simplicity , the notation @xmath95 $ ] does not explicitly represent this dependence .    1 .   @xmath95 $ ] is a _",
    "stochastic _ row vector of size @xmath89 .",
    "thus , @xmath97\\geq 0 $ ] , for @xmath98 , and @xmath99 ~ = ~ 1\\ ] ] 2 .   @xmath100 $ ] equals @xmath56 defined in algorithm 1 .",
    "recall that @xmath101 .",
    "3 .   @xmath97 $ ] is non - zero * only if * @xmath102 or @xmath103 .",
    "4 .   at least @xmath104 elements in @xmath95 $ ] are lower bounded by some constant @xmath105 , to be defined later ( @xmath106 is independent of @xmath8 ) . note that @xmath107 is the set of fault - free incoming neighbors of node @xmath8 .",
    "the proof of this claim is presented in section [ ss_claim_1 ] below .",
    "the last condition above plays an important role in the proof , and the main contribution of this paper is to `` design '' @xmath95 $ ] to make this condition true .       by `` stacking '' ( [ e_matrix_i ] ) for different @xmath8 , @xmath108 , we can represent the state update for all the fault - free nodes together using ( [ e_matrix ] ) below , where @xmath109 $ ] is a @xmath110 matrix , with its @xmath8-th row being equal to @xmath95 $ ] in ( [ e_matrix_i ] ) .",
    "@xmath111 & = & { { \\bf m}}[t ] ~ { { { \\bf v}}}[t-1 ] \\label{e_matrix}\\end{aligned}\\ ] ] the four properties of @xmath95 $ ] imply that @xmath109 $ ] is a row stochastic matrix with a non - zero diagonal .",
    "also , the @xmath8-th row of @xmath109 $ ] contains @xmath104 elements lower bounded by @xmath106 ( @xmath106 will be defined later ) .",
    "this property of @xmath109 $ ] turns out to be important in proving convergence of algorithm 1 .",
    "@xmath109 $ ] is said to be a _",
    "transition matrix_.    by repeated application of ( [ e_matrix ] ) , we obtain : @xmath112 & = & \\left(\\,\\pi_{i=1}^t { { \\bf m}}[i]\\,\\right)\\ , { { \\bf v}}[0]\\end{aligned}\\ ] ]      figure [ f_sets ] illustrates the various sets used here .",
    "some of the sets in this figure are not yet defined , and will be defined later in the paper .    , @xmath29 , @xmath13 , @xmath46 $ ] , @xmath113 and @xmath114,scaledwidth=70.0% ]",
    "we prove the correctness of claim [ claim_1 ] by constructing @xmath95 $ ] for @xmath108 that satisfies the conditions in claim [ claim_1 ] .",
    "recall that nodes 1 through @xmath115 are fault - free , and the remaining @xmath116 nodes ( @xmath117 ) are faulty .",
    "consider a fault - free node @xmath8 performing the _ update step _ in algorithm 1 . recall that the largest @xmath0 and the smallest @xmath0 values are eliminated from @xmath44 $ ] .",
    "let us denote by @xmath118 and @xmath119 , respectively , the set of nodes and @xmath119 may be different for each @xmath25 , for simplicity , we do not explicitly represent this dependence on @xmath25 in the notations @xmath118 and @xmath119 . ] from whom the largest @xmath0 values and the smallest @xmath0 values",
    "were received by node @xmath8 in iteration @xmath25 .",
    "thus , @xmath120 , @xmath46 = n_i^- - ( l\\cup s)$ ] , and @xmath121|=|n_i^--(l\\cup s)| = |n_i^-|-2f$ ] .    for any set of nodes @xmath33 here , let @xmath122 and @xmath123 respectively denote the number of faulty nodes , and the number of fault - free nodes , in set @xmath33",
    ". for instance , @xmath124 and @xmath125 denote , respectively , the number of faulty and fault - free nodes in set @xmath118 .",
    "thus , @xmath126 let @xmath127 that is , the number of faulty incoming neighbors of node @xmath8 is denoted as @xmath128 . therefore , @xmath129 , and @xmath130}}\\ ] ]    then , it follows that @xmath131}}+(f-\\delta ) , \\mbox{~and }   \\label{g_l}\\\\ g_s & = & f-\\delta_s~=~\\delta_l+{\\delta_{n_i^*[t]}}+(f-\\delta ) \\label{g_s}\\end{aligned}\\ ] ]    for fault - free node @xmath8 , we now define the elements of row @xmath95 $ ] .",
    "we consider two cases separately : ( i ) @xmath132}}=0 $ ] , and ( ii ) @xmath132}}>0 $ ] .      we know",
    "that @xmath133 and @xmath134}}\\geq 0 $ ] .",
    "therefore , @xmath132}}=0 $ ] implies that @xmath135 and @xmath134}}=0 $ ] .",
    "thus , in this case , all the nodes in @xmath46 $ ] are fault - free .    * for each @xmath136 $ ] , define @xmath97 = a_i$ ] .",
    "element @xmath97 $ ] corresponds to the term @xmath137 in ( [ e_z ] ) .",
    "+ recall that @xmath101 , and that each node in @xmath138 $ ] in this case is fault - free .",
    "* for each @xmath9 such that @xmath139 and @xmath140 $ ] , define @xmath97 = 0 $ ] .",
    "observe that with the above definition of elements of @xmath95 $ ] , @xmath141 { { \\bf v}}[t-1 ] = \\sum_{k\\in \\{i\\}\\cup n_i^*[t ] } a_iw_k\\ ] ] in the above procedure , we have set @xmath121|+1 $ ] elements of @xmath95 $ ] equal to @xmath56 ( recall that @xmath101 ) .    now , because @xmath142 and @xmath121|=|n_i^-|-2f$ ] , we have @xmath143|+1 $ ] . also , in this case @xmath144|+1)$ ] .",
    "thus , it should be easy to see that the conditions in claim [ claim_1 ] are satisfied by defining @xmath145 .",
    "since @xmath146}}\\leq\\delta\\leq f$ ] , @xmath132}}>0 $ ] implies that @xmath19 .",
    "when @xmath19 , the necessary condition in @xcite implies that @xmath147 .",
    "therefore , the set @xmath46 $ ] is non - empty . as per ( [ e_z ] ) , each node @xmath148 $ ] contributes @xmath149 to the new state @xmath24 $ ] of node @xmath8",
    ". we will define elements of @xmath95 $ ] to account for the contribution of each node @xmath148 $ ] .",
    "define subsets @xmath113 and @xmath114 such that @xmath150 , @xmath151 , @xmath152 , and @xmath153}}$ ] .",
    "that is , sets @xmath113 and @xmath114 are subsets of @xmath118 and @xmath119 , respectively , each of size @xmath132}}$ ] , and containing only fault - free nodes . expressions ( [ g_l ] ) and ( [ g_s ] ) for @xmath125 and @xmath154 imply that such subsets exist .",
    "let @xmath155}}\\}\\ ] ] and @xmath156}}\\}.\\ ] ] consider any node @xmath148 $ ] .",
    "for each @xmath9 , @xmath157}}$ ] , @xmath158 \\leq w_k \\leq v_{l_j}[t-1]\\ ] ] therefore , we can find weights @xmath159 and @xmath160 such that @xmath161 and @xmath162 ~ + ~          \\psi_{k , j } \\",
    ", v_{s_j}[t-1]\\ ] ] clearly , at least one of the weights @xmath163 and @xmath164 must be @xmath165 .",
    "now , observe that @xmath166 } } }   ~ \\sum_{1\\leq j\\leq f-\\delta+{\\delta_{n_i^*[t ] } } }   \\left ( \\lambda_{k , j}\\ , v_{l_j}[t-1 ] +          \\psi_{k , j } \\ , v_{s_j}[t-1 ] \\right ) \\label{e_faulty } \\end{aligned}\\ ] ] the above equality is true independent of whether @xmath167 is fault - free or faulty .",
    "we will later use the above equality for the case when @xmath167 is a faulty node .",
    "when @xmath167 is fault - free , @xmath168,\\ ] ] and we can similarly obtain the equality below .",
    "@xmath169               ~+~         \\frac{a_i}{2(f-\\delta+{\\delta_{n_i^*[t ] } } ) } ~ \\sum_{1\\leq j\\leq f-\\delta+{\\delta_{n_i^*[t ] } } }   \\left ( \\lambda_{k , j}\\ , v_{l_j}[t-1 ]   +           \\psi_{k , j } \\ , v_{s_j}[t-1 ] \\right ) \\nonumber\\\\   \\label{e_faultfree}\\end{aligned}\\ ] ]    we now use ( [ e_z ] ) , ( [ e_faulty ] ) and ( [ e_faultfree ] ) to define elements of @xmath95 $ ] in the following four cases :    * * case 1 : node @xmath8 * + define @xmath100=a_i$ ] .",
    "this is obtained by observing in ( [ e_z ] ) that the contribution of node @xmath8 to the new state @xmath24 $ ] is @xmath170 $ ] . * * case 2 : fault - free nodes in @xmath46 $ ] * + for each @xmath148\\cap ( { \\mathcal{v}}-{\\mathcal{f}})$ ] , define @xmath171 = \\frac{a_i}{2}$ ] .",
    "this choice is motivated by ( [ e_faultfree ] ) wherein the contribution of node @xmath167 to @xmath172 is @xmath173 $ ] . in case 2 ,",
    "@xmath121\\cap({\\mathcal{v}}-{\\mathcal{f}})|=|n_i^-|-\\delta$ ] elements of @xmath95 $ ] are defined .",
    "* * case 3 : nodes in @xmath113 and @xmath114 * + for @xmath157}}$ ] , consider @xmath174 . in this case ,",
    "@xmath175 & = & \\sum_{k\\in n_i^*[t ] \\cap { \\mathcal{f } } } \\frac{a_i}{f-\\delta+{\\delta_{n_i^*[t ] } } } \\lambda_{k , j } ~+~ \\sum_{k\\in n_i^*[t]\\cap ( { \\mathcal{v}}-{\\mathcal{f } } ) } \\frac{a_i}{2(f-\\delta+{\\delta_{n_i^*[t ] } } ) } \\lambda_{k , j}\\end{aligned}\\ ] ] similarly , for @xmath157}}$ ] , consider @xmath176 . in this case ,",
    "@xmath177 & = & \\sum_{k\\in n_i^*[t ] \\cap { \\mathcal{f } } } \\frac{a_i}{f-\\delta+{\\delta_{n_i^*[t ] } } } \\psi_{k , j } ~+~ \\sum_{k\\in n_i^*[t]\\cap ( { \\mathcal{v}}-{\\mathcal{f } } ) } \\frac{a_i}{2(f-\\delta+{\\delta_{n_i^*[t ] } } ) } \\psi_{k , j}\\end{aligned}\\ ] ] these expressions are obtained by summing ( [ e_faulty ] ) and ( [ e_faultfree ] ) , respectively , over the faulty and fault - free nodes in @xmath46 $ ] , and then identifying the contribution of each node in @xmath113 and @xmath114 to this sum .",
    "recall the earlier observation that at least one of @xmath163 and @xmath164 must be @xmath165 for each pair @xmath178 where @xmath148 $ ] and @xmath179}}$ ] .",
    "therefore , it follows that at least @xmath132}}$ ] elements of @xmath95 $ ] defined in case 3 must be @xmath180}})}$ ] . *",
    "* case 4 : nodes in @xmath181\\cup l^*\\cup s^*)$ ] * + these fault - free nodes have not yet been considered in cases 1 , 2 and 3 . for each node @xmath182\\cup l^*\\cup s^*)$ ] , we assign @xmath171=0 $ ] .",
    "observe that above the definition of the elements of @xmath95 $ ] ensures that @xmath183}a_iw_j~=~{{\\bf m}}_i[t]{{\\bf v}}[t-1]\\ ] ] however , the contribution by the faulty nodes in @xmath46 $ ] in ( [ e_z ] ) is now replaced by an equivalent contribution by the nodes in @xmath113 and @xmath114 .",
    "now let us verify that the four conditions in claim [ claim_1 ] hold for the above assignments to the elements of @xmath95 $ ] .    1 .",
    "observe that all the elements of @xmath95 $ ] are non - negative .",
    "case 1 specifies just @xmath100=a_i$ ] .",
    "the elements of @xmath95 $ ] specified in case 2 add up to @xmath184\\cap ( { \\mathcal{v}}-{\\mathcal{f}})|\\ ] ] recall that for each @xmath9 , @xmath185}})$ ] , @xmath186 for @xmath148 $ ] .",
    "therefore , when added over all @xmath148 $ ] and @xmath185}})$ ] , the elements of @xmath95 $ ] specified in case 3 add up to @xmath187\\cap { \\mathcal{f}}| ~+~ \\frac{a_i}{2 } ~ |n_i^*[t]\\cap ( { \\mathcal{v}}-{\\mathcal{f}})|\\ ] ] therefore , when all the elements of @xmath95 $ ] defined in cases 1 , 2 and 3 are added together , we get @xmath188\\cap{\\mathcal{f}}| ~+~   a_i   |n_i^*[t]\\cap ( { \\mathcal{v}}-{\\mathcal{f}})| ~=~   a_i ( |n_i^*[t]|+1 ) ~=~1 & & \\end{aligned}\\ ] ] because @xmath144|+1)$ ] .",
    "now observe that the elements specified in cases 1 , 2 and 3 are clearly @xmath189 . in the expression for",
    "@xmath190 $ ] in case 3 , observe that the two summations on the right side together contain @xmath121|$ ] terms , and in these terms , observe that @xmath191 , @xmath132}}\\geq 1 $ ] and @xmath192|+1}$ ] .",
    "therefore , @xmath190<1 $ ] .",
    "similarly , we can show that @xmath193<1 $ ] as well .",
    "+ thus , we have shown that @xmath95 $ ] is a stochastic vector .",
    "@xmath100=a_i$ ] as specified in case 1 . 3 .",
    "since @xmath97 $ ] is defined to be non - zero only in cases 1 , 2 and 3 , which consider the nodes only in @xmath194 , it follows that @xmath97 $ ] is non - zero _ only if _ @xmath102 or @xmath103 .",
    "cases 1 and 2 together set @xmath195\\cap({\\mathcal{v}}-{\\mathcal{f}})|= 1+|n_i^*[t]|-{\\delta_{n_i^*[t]}}$ ] elements of @xmath95 $ ] to be @xmath196 .",
    "we observed earlier that case 3 results in at least @xmath132}}$ ] elements of @xmath95 $ ] being @xmath180}})}$ ] . also , observe that the elements of @xmath95 $ ] specified in cases 1 and 2 are distinct from those specified in case 3 , and that @xmath197}})}$ ] .",
    "thus , overall , at least @xmath198|-{\\delta_{n_i^*[t ] } } ) ~+~ f-\\delta+{\\delta_{n_i^*[t]}}~=~ |n_i^*[t]|+f-\\delta+1 ~=~ |n_i^-|-f-\\delta+1 & & \\\\",
    "~=~ |n_i^-\\cap({\\mathcal{v}}-{\\mathcal{f}})|-f-1 & & \\end{aligned}\\ ] ] elements of @xmath95 $ ] are set @xmath180}})}$ ] .",
    "derivation of the above equation uses the facts that @xmath121|=|n_i^-|-2f$ ] and @xmath199 .",
    "then by defining @xmath106 as below , condition 4 in claim [ claim_1 ] holds true .",
    "@xmath200}})}\\ ] ]    therefore , claim [ claim_1 ] is proved correct .",
    "let us define set @xmath202 of subgraphs of @xmath3 as follows .",
    "@xmath203 thus , @xmath30 is the set of nodes in each graph in @xmath202 .",
    "let @xmath204 denote @xmath205 .",
    "@xmath204 depends on @xmath29 and the underlying network , and it is finite .    [ claim_suff ] suppose that graph @xmath3 satisfies the necessary condition in theorem 2 in @xcite .",
    "then it follows that in each @xmath206 , there exists at least one node that has directed paths to all the nodes in @xmath207 ( consisting of the edges in @xmath207 ) .",
    "the proof follows from theorem 2 of @xcite .    in this discussion , let us denote a graph by an italic upper case letter , and the corresponding _ connectivity matrix _ using the same letter in boldface upper case .",
    "thus , @xmath61 will denote the connectivity matrix for graph @xmath206 ; @xmath61 is defined as follows : ( i ) for @xmath208 , if there is a directed link from node @xmath9 to node @xmath8 in graph @xmath207 then @xmath209 , and ( ii ) @xmath210 for @xmath108 . note that in our notation , the @xmath8-th row of @xmath61 ( that is , @xmath62 ) corresponds to the incoming links at node @xmath8 , and the self - loop at node @xmath8 .",
    "the connectivity matrix @xmath61 for any @xmath206 has a non - zero diagonal .",
    "[ l_one_column ] for any @xmath206 , @xmath211 has at least one non - zero column .    by claim [ claim_suff ] , in graph @xmath207",
    "there exists at least one node , say node @xmath167 , that has a directed path in @xmath207 to all the remaining nodes in @xmath207 .",
    "since the length of the path from @xmath167 to any other node in @xmath207 can contain at most @xmath212 directed edges , the @xmath167-th column of matrix @xmath213 will be non - zero .",
    "are non - negative ) .",
    "also , such a non - zero column will exist in @xmath214 too .",
    "we use the loose bound of @xmath115 to simplify the presentation . ]",
    "we will say that an element of a matrix is `` non - trivial '' if it is lower bounded by @xmath106 .    for matrices @xmath64 and @xmath215 of identical size , and a scalar @xmath216 , @xmath217 provided that @xmath218 for all @xmath219 .",
    "[ l_h ] for any @xmath43 , there exists a graph @xmath220\\in r_{\\mathcal{f}}$ ] such that @xmath221 ~ \\leq ~   { { { \\bf m}}[t]}$ ] .",
    "observe that the @xmath8-th row of the transition matrix @xmath109 $ ] corresponds to the state update performed at fault - free node @xmath8 .",
    "recall from claim [ claim_1 ] that the @xmath222 is non - zero * only if * link @xmath102 .",
    "also , by claim [ claim_1 ] , @xmath95 $ ] ( i.e. , the @xmath8-th row of @xmath109 $ ] ) contains at least @xmath104 _ non - trivial _ elements corresponding to * fault - free * incoming neighbors of node @xmath8 and itself ( i.e. , the diagonal element ) .",
    "now observe that , for any subgraph @xmath206 , @xmath8-th row of @xmath61 contains exactly @xmath104 non - zero elements , including the diagonal element .",
    "considering the above two observations , and the definition of set @xmath202 , the lemma follows .",
    "the proof below uses techniques also applied in prior work ( e.g. , @xcite ) , with some similarities to the arguments used in @xcite .    [ l_product_h ] in the product below of @xmath223 $ ] matrices for consecutive @xmath224 iterations , at least one column is non - zero .",
    "@xmath225\\ ] ]    since the above product consists of @xmath224 matrices in @xmath202 , at least one of the @xmath204 distinct connectivity matrices in @xmath202 , say matrix @xmath226 , will appear in the above product at least @xmath115 times .    now observe that : ( i ) by lemma [ l_one_column ] , @xmath227 contains a non - zero column , say the @xmath167-th column is non - zero , and ( ii ) all the @xmath223 $ ] matrices in the product contain a non - zero diagonal .",
    "these two observations together imply that the @xmath167-th column in the above product is non - zero .",
    "let us now define a sequence of matrices @xmath228 such that each of these matrices is a product of @xmath224 of the @xmath109 $ ] matrices .",
    "specifically , @xmath229\\ ] ] observe that @xmath230 & = & \\left(\\ , \\pi_{i=1}^k ~ { { \\bf q}}(i ) \\,\\right)~{{\\bf v}}[0]\\end{aligned}\\ ] ]    [ l_q ] for @xmath231 , @xmath228 is a scrambling row stochastic matrix , and @xmath232 is bounded from above by a constant smaller than 1 .",
    "@xmath228 is a product of row stochastic matrices ( @xmath109 $ ] ) , therefore , @xmath228 is row stochastic .    from lemma [ l_h ] , for each @xmath25 ,",
    "@xmath233 ~ \\leq ~ { { \\bf m}}[t]\\ ] ] therefore , @xmath234 ~ \\leq   ~ { { \\bf q}}(i)\\ ] ] by using @xmath235 in lemma [ l_product_h ] , we conclude that the matrix product on the left side of the above inequality contains a non - zero column .",
    "therefore , @xmath228 contains a non - zero column as well .",
    "therefore , @xmath228 is a scrambling matrix .",
    "observe that @xmath224 is finite , therefore , @xmath236 is non - zero . since the non - zero terms in",
    "@xmath223 $ ] matrices are all 1 , the non - zero elements in @xmath237 $ ] must each be @xmath238 1 . therefore , there exists a non - zero column in @xmath228 with all the elements in the column being @xmath239 .",
    "therefore @xmath240 .",
    "[ t ] algorithm 1 satisfies the validity and the convergence conditions .    since @xmath93={{\\bf m}}[t]\\,v[t-1]$ ] , and",
    "@xmath109 $ ] is a row stochastic matrix , it follows that algorithm 1 satisfies the validity condition .    by claim [ claim_delta ] , @xmath241 ) & \\leq & \\lim_{t\\rightarrow\\infty } \\pi_{i=1}^t \\lambda({{\\bf m}}[t ] ) \\\\   & \\leq & \\lim_{i\\rightarrow\\infty } \\pi_{i=1}^{\\lfloor\\frac{t}{\\tau(n-\\phi)}\\rfloor } \\lambda({{\\bf q}}(i ) ) \\\\ & = & 0 \\end{aligned}\\ ] ] the above argument makes use of the facts that @xmath242)\\leq 1 $ ] and @xmath243 .",
    "thus , the rows of @xmath244 $ ] become identical in the limit .",
    "this observation , and the fact that @xmath93=(\\pi_{i=1}^t { { \\bf m}}[i]){{\\bf v}}[t-1]$ ] together imply that the state of the fault - free nodes satisfies the convergence condition .",
    "now , the validity and convergence conditions together imply that there exists a positive scalar @xmath245 such that @xmath246 ~ = ~ \\lim_{t\\rightarrow\\infty } \\left ( \\pi_{i=1}^t { { \\bf m}}[i ] ) \\right)\\ , { { \\bf v}}[0 ] ~ = ~ c\\,{\\bf 1}\\ ] ] where * 1 * denotes a column with all its elements being 1 .",
    "in this paper , we analyzed iabc algorithm 1 designed for synchronous systems .",
    "similar analysis also applies for iabc algorithm 2 presented in @xcite for asynchronous systems .",
    "the analysis will also naturally extend to an iabc algorithm for the _ partially synchronous algorithmic _ model presented in @xcite , which assumes a bounded delay in propagation of state between neighbors , and a bounded delay between consecutive state updates at each node in the network .",
    "the generalization of algorithm 1 to the _ partially synchronous algorithmic _ model will allow a node @xmath8 , if performing state update in iteration @xmath25 , to form vector @xmath44 $ ] using the most recent known states of its incoming neighbors ; these states of the neighbors may correspond to any of the prior @xmath247 iterations , for some bounded @xmath247 .",
    "a similar iabc algorithm can also be used in time - varying network topologies ( i.e. , networks wherein the set of links available in iteration @xmath25 varies with @xmath25 ) ; the above analysis will then extend to time - varying topologies as well , with the algorithm performing correctly so long as the connectivity matrices for the graphs at different @xmath25 jointly satisfy some reasonable properties , as in @xcite .",
    "we presented a proof of validity and convergence of algorithm 1 by expressing the algorithm in the matrix form .",
    "the main contribution of the paper is to express the algorithm in matrix form that allows us to prove its convergence under certain necessary conditions on the underlying communication graph .",
    "thus , the proof implies that the necessary conditions are also sufficient .",
    "the key to the proof is to `` design '' the transition matrix for each iteration such that each row of the matrix contains a large enough number of elements that are bounded away from 0 .",
    "a.  azadmanesh and h.  bajwa .",
    "global convergence in partially fully connected networks ( pfcn ) with limited relays . in _ industrial electronics society , 2001 .",
    "iecon 01 .",
    "the 27th annual conference of the ieee _ , volume  3 , pages 2022 2025 vol.3 , 2001 .",
    "f. benezit , v. blondel , p. thiran , j. tsitsiklis , and m. vetterli , `` weighted gossip : distributed averaging using non - doubly stochastic matrices , '' in proc . of ieee international symposium on information theory , june 2010 ,",
    ".        a.  d. fekete .",
    "asymptotically optimal algorithms for approximate agreement . in _ proceedings of the fifth annual acm symposium on principles of distributed computing _ , podc 86 , pages 7387 , new york , ny , usa , 1986 .",
    "acm .",
    "n.  h. vaidya , l.  tseng , and g.  liang .",
    "iterative approximate byzantine consensus in arbitrary directed graphs .",
    ", abs/1201.4183v1 ( january 2012 ) , abs/1201.4183v2 ( februar 2012 ) .",
    "available from http://arxiv.org .",
    "n.  h. vaidya , l.  tseng , and g.  liang .",
    "iterative approximate byzantine consensus in arbitrary directed graphs ",
    "part ii : synchronous and asynchronous systems .",
    "technical report , university of illinois at urbana - champaign , february 2012 .",
    "n. h. vaidya , c. n. hadjicostis , a. d. dominguez - garcia . distributed algorithms for consensus and coordination in the presence of packet - dropping communication links - part ii : coefficients of ergodicity analysis approach .",
    "september 2011 .",
    "available from http://arxiv.org/abs/1109.6392 ."
  ],
  "abstract_text": [
    "<S> this paper presents a proof of correctness of an iterative approximate byzantine consensus ( iabc ) algorithm for directed graphs . </S>",
    "<S> the iterative algorithm allows fault - free nodes to reach approximate conensus despite the presence of up to @xmath0 byzantine faults . </S>",
    "<S> necessary conditions on the underlying network graph for the existence of a correct iabc algorithm were shown in our recent work @xcite . </S>",
    "<S> @xcite also analyzed a specific iabc algorithm and showed that it performs correctly in any network graph that satisfies the necessary condition , proving that the necessary condition is also sufficient . in this paper , we present an alternate proof of correctness of the iabc algorithm , using a familiar technique based on transition matrices @xcite . + the key contribution of this paper is to exploit the following observation : for a _ given _ evolution of the state vector corresponding to the state of the fault - free nodes , many alternate state transition matrices may be chosen to model that evolution correctly . for a given state evolution , we identify one approach to suitably `` design '' the transition matrices so that the standard tools for proving convergence can be applied to the byzantine fault - tolerant algorithm as well . in particular , the transition matrix for each iteration is designed such that each row of the matrix contains a large enough number of elements that are bounded away from 0 . </S>",
    "<S> +    march 8 , 2012 </S>"
  ]
}