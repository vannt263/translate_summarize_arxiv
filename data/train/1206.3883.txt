{
  "article_text": [
    "in recent years , boolean sat solving techniques have improved dramatically . today",
    "s sat solvers are considerably faster and able to manage larger instances than yesterday s .",
    "moreover , encoding and modeling techniques are better understood and increasingly innovative .",
    "sat is currently applied to solve a wide variety of hard and practical combinatorial problems , often outperforming dedicated algorithms .",
    "the general idea is to encode a ( typically , np ) hard problem instance , @xmath0 , to a boolean formula , @xmath1 , such that the solutions of @xmath0 correspond to the satisfying assignments of @xmath1 . given the encoding , a sat solver is then applied to solve @xmath0 .",
    "tailgating the success of sat technology are a variety of tools which can be applied to specify and then compile problem instances to corresponding sat instances .",
    "for example , introduce , a logic - based specification language which allows to specify combinatorial problems in a declarative way . at the core of this system",
    "is a compiler which translates specifications to cnf formula .",
    "the general objective of such tools is to facilitate the process of providing high - level descriptions of how the ( constraint ) problem at hand is to be solved .",
    "typically , a constraint based modeling language is introduced and used to model instances .",
    "drawing on the analogy to programming languages , given such a description , a compiler then provides a low - level executable for the underlying machine .",
    "namely , in our context , a formula for the underlying sat or smt solver .",
    "one obstacle when seeking to optimize cnf encodings derived from high - level descriptions , is that cnf encodings are _",
    "`` bit - level '' _ representations and do not maintain _",
    "`` word - level '' _ information .",
    "for example , from a cnf encoding one can not know that certain bits originate from the same integer value in the original constraint .",
    "this limits the ability to apply optimizations which rely on such word - level information .",
    "we mention two relevant tools .",
    "sugar @xcite , is a sat - based constraint solver . to solve a finite domain linear constraint satisfaction problem",
    "it is first encoded to a cnf formula by sugar , and then solved using the minisat solver @xcite .",
    "is like sugar , but applies optimizations .",
    "sugar is the first system which demonstrates the advantage in adopting the , so - called , unary order - encoding to represent integers .",
    "we follow suite , and introduce additional novel encoding techniques that take advantage of , previously unobserved , properties of the order - encoding .",
    "minizinc  @xcite , is a constraint modeling language which is compiled by a variety of solvers to the low - level target language flatzinc for which there exist many solvers .",
    "it creates a standard for the source language ( which we follow loosely ) .",
    "is like flatzinc , but with a focus on a subset of the language relevant for finite domain constraint problems .",
    "we present a tool ,  ( * * * * en - gurion university * * * * qui - propagation * * * * ncoder ) which translates models in a constraint based modeling language , similar to sugar and flatzinc , to cnf .",
    "conceptually ,  maintains two representations for each constraint in a model so that each constraint is also viewed as a boolean function .",
    "partial evaluation , and other word - level techniques , drive simplification through the constraint part ; whereas , equi - propagation @xcite , and other bit - level techniques , drive simplification through the boolean part . finally , an encoding technique is selected for a constraint , depending on its context , to derive a cnf .",
    "the name , `` '' refers both to the constraint language as well as to its compiler to cnf .",
    "is not a constraint solver , but can be applied in combination with a sat solver to solve finite domain constraint problems .",
    "we report on our experience with applications which indicates that using , like any compiler , has two main advantages . on the one hand",
    ", it facilitates the process of programming ( or modeling ) . on the other hand ,",
    "given a program ( a model ) , it simplifies the corresponding cnf which , in many cases , is faster to solve than with other approaches .",
    "the tool integrates with swi prolog and can be downloaded from  @xcite .",
    "a fundamental design choice when encoding finite domain constraints concerns the representation of integer variables .",
    "surveys several of the possible choices ( the _ direct- _ , _ support- _ and _ log- _ _ encodings _ ) and introduces the _ log - support encoding_. we focus in this paper on the use of unary representations and primarily on the , so - called , _ order - encoding _ ( see e.g.  @xcite ) which has many nice properties when applied to small finite domains .",
    "we describe the setting where all integer variables are represented in the order - encoding except for those involved in a global `` all - different '' constraint which take a dual representation with channeling between the order - encoding and the _",
    "direct encoding_. this choice derives from the observation by that the direct - encoding is superior when encoding the all - different constraint .",
    "let bit vector @xmath2 $ ] represent a finite domain integer variable . in the _ order - encoding _ , @xmath3 constitutes a monotonic non - increasing boolean sequence .",
    "bit @xmath4 is interpreted as @xmath5 .",
    "for example , the value 3 in the interval @xmath6 $ ] is represented in 5 bits as @xmath7 $ ] . in the _ direct - encoding _",
    ", @xmath3 constitutes a characteristic function ( exactly one bit takes value 1 ) and @xmath4 is interpreted as stating @xmath8 .",
    "for example , the value 3 in the interval @xmath6 $ ] is represented in 6 bits as @xmath9 $ ] .",
    "an important property of a boolean representation for finite domain integers is the ability to represent changes in the set of values a variable can take .",
    "it is well - known that the order - encoding facilitates the propagation of bounds .",
    "consider an integer variable @xmath2 $ ] with values in the interval @xmath10 $ ] . to restrict @xmath3 to take values in the range",
    "@xmath11 $ ] ( for @xmath12 ) , it is sufficient to assign @xmath13 and @xmath14 ( if @xmath15 ) .",
    "the variables @xmath16 and @xmath17 for @xmath18 and @xmath19 are then determined true and false , respectively , by _",
    "unit propagation_. for example , given @xmath20 $ ] , assigning @xmath21 and @xmath22 propagates to give @xmath23 $ ] , signifying that @xmath24 .",
    "this property is exploited in sugar @xcite which also applies the order - encoding .",
    "we observe , and apply in , an additional property of the order - encoding : its ability to specify that a variable can not take a specific value @xmath25 in its domain by equating two variables : @xmath26 .",
    "this indicates that the order - encoding is well - suited not only to propagate lower and upper bounds , but also to represent integer variables with an arbitrary , finite set , domain .",
    "for example , given @xmath20 $ ] , equating @xmath27 imposes that @xmath28 .",
    "likewise @xmath29 and @xmath30 impose that @xmath31 and @xmath32 .",
    "applying these equalities to @xmath3 gives , @xmath33 $ ] , signifying that @xmath34 .",
    "the order - encoding has many additional nice features that are exploited in  to simplify constraints and their encodings to cnf . to illustrate one ,",
    "consider a constraint of the form @xmath35 where ` a ` and ` b ` are integer values in the range between 0 and 5 represented in the order - encoding . at the bit level",
    "we have : @xmath36}$ ] and @xmath37}$ ] .",
    "the constraint is satisfied precisely when @xmath38}$ ] . instead of encoding the constraint to cnf",
    ", we substitute the bits @xmath39 by the literals @xmath40 , and remove the constraint . in prolog , this is implemented as a unification and does not generate any clauses in the encoding .",
    "boolean constants `` @xmath41 '' and `` @xmath42 '' are viewed as ( integer ) values `` 1 '' and `` 0 '' .",
    "constraints are represented as ( a list of ) prolog terms .",
    "boolean and integer variables are represented as prolog variables , which may be instantiated when simplifying constraints .",
    "table  [ tab : beestntax ] introduces the syntax for ( a simplified subset of ) . in the table ,",
    "@xmath43 and @xmath44 ( possibly with subscripts ) denote a literal ( a boolean variable or its negation ) and a vector of literals , @xmath45 ( possibly with subscript ) denotes an integer variable , and @xmath46 ( possibly with subscript ) denotes an integer constant .",
    "rlll + ( 1 ) & @xmath47 & & declare boolean ` x ` + ( 2 ) & @xmath48 & & declare integer ` i ` , @xmath49 + ( 3 ) & @xmath50)}$ ] & & @xmath51 ( on booleans ) +   + ( 4 ) & @xmath52  or   @xmath53 & @xmath54 & @xmath55  or   @xmath56 + ( 5 ) & @xmath57)}$ ] & @xmath54 & @xmath58 + ( 6 ) & @xmath59,~x)}$ ] & @xmath54 & @xmath60 + ( 7 ) & @xmath61 & @xmath54 & @xmath62 + ( 8) & @xmath63 & @xmath54 & @xmath64 precedes @xmath65 in the lex order +     +   + ( 9 ) & @xmath66 & @xmath54 & @xmath67 + ( 10 ) & @xmath68 & @xmath54 & @xmath69 + ( 11 ) & @xmath70 & @xmath54 & @xmath71 + ( 12 ) & @xmath72,~i)}$ ] & @xmath54 & @xmath73 +     + ( 13 ) & @xmath74)}$ ] & & @xmath75 + ( 14 ) & @xmath76,~i)}$ ] & @xmath54 & @xmath77 + ( 15 ) & @xmath78 & & @xmath79)=[x_3,x_4]}$ ] +    on the right column of the table are brief explanations regarding the constraints .",
    "the table introduces 15 constraint templates .",
    "constraints ( 1 - 2 ) are about variable declarations : booleans and integers . constraint ( 3 )",
    "signifies that a bit sequence is monotonic non - increasing , and is used to specify that an integer variable is in the order - encoding",
    ". constraints ( 4 - 7 ) are about boolean ( and reified boolean ) statements .",
    "the cases for @xmath80)}$ ] and @xmath81)}$ ] facilitate the specification of clauses and of ` xor ` clauses ( supported in the cryptominisat solver  @xcite ) .",
    "constraint ( 8) specifies that two bit - vectors are ordered lexicographically . constraints ( 9 - 12 ) are about integer relations and operations . constraints ( 13 - 14 ) are the all - different constraint on integers and the cardinality constraint on booleans . constraint ( 15 ) specifies that sorting a bit pair @xmath82}$ ] ( decreasing order ) results in the pair @xmath83}$ ] .",
    "this is a basic building block for the construction of sorting networks @xcite used to encode cardinality constraints during compilation as described in  @xcite and in  @xcite .",
    "we illustrate the application of  to solve a graph labeling problem .",
    "a typical  application has the form depicted as figure  [ fig : generic ] where the predicate ` solve/2 ` takes a problem ` instance ` and provides a ` solution ` .",
    "the specifics of the application are in the call to ` encode/3 ` which given the ` instance ` generates the ` constraints ` that solve it together with a ` map ` relating instance variables with constraint variables .",
    "the calls to ` compile/2 ` and ` sat/1 ` compile the constraints to a ` cnf ` and solve it applying a sat solver . if the instance has a solution , the sat solver binds the constraint variables accordingly .",
    "then , the call to ` decode/2 ` , using the ` map ` , provides a ` solution ` in terms of the instance variables .",
    "the definitions of ` encode/3 ` and ` decode/3 ` are application dependent and provided by the user .",
    "the predicates ` compile/2 ` and ` sat/1 ` provide the interface to and the underlying sat solver .",
    ": - use_module(bee_compiler , [ compile/2 ] ) .",
    "+ : - use_module(sat_solver , [ sat/1 ] ) .",
    "+   + solve(instance , solution ) : - + encode(instance , map , constraints ) , + compile(constraints , cnf ) , + sat(cnf ) , + decode(map , solution ) .",
    "+    graph labeling is about finding an assignment of integers to the vertices and edges of a graph subject to certain conditions .",
    "graph labelings were introduced in the 60 s and hundreds of papers on a wide variety of related problems have been published since then .",
    "see for example the survey by with more than 1200 references .",
    "graph labelings have many applications .",
    "for instance in radars , xray crystallography , coding theory , etc .",
    "we focus here on the vertex - magic total labeling ( vmtl ) problem where one should find for the graph @xmath84 a labeling that is a one - to - one map @xmath85 with the property that the sum of the labels of a vertex and its incident edges is a constant @xmath86 independent of the choice of vertex .",
    "a problem instance takes the form @xmath87 specifying the graph @xmath88 and a constant @xmath86 .",
    "the query @xmath89 poses the question : `` does there exist a vmtl labeling for @xmath88 with magic constant @xmath86 ? ''",
    "it binds @xmath90 to indicate such a labeling if one exists , or to `` unsat '' otherwise .    [",
    "cols=\"<\",options=\"header \" , ]     after constraint simplification variables ` a ` and ` b ` take the form : @xmath91}$ ] and @xmath92}$ ] ( and nothing is left to encode to cnf ) .",
    "[ [ section-3 ] ]    is about replacing complex constraints ( for example about arrays ) with simpler constraints ( for example about array elements ) .",
    "consider , for instance , the constraint @xmath93 .",
    "it is decomposed to a list of @xmath94 constraints applying a straightforward divide and conquer recursive definition . at the base case ,",
    "if ` as=[a ] ` then the constraint is replaced by ` int_eq(a , sum ) ` , or if @xmath95}$ ] then it is replaced by @xmath96 . in the general case ` as ` is split into two halves , then constraints are generated to sum these halves , and then an additional @xmath94 constraint is introduced to sum the two sums .    as another example , consider the @xmath97 constraint .",
    "one approach , supported by , decomposes the constraint as an odd - even merger ( from the context of odd - even sorting networks )  @xcite . here",
    ", the sorted sequences of bits @xmath98 and @xmath99 are merged to obtain their sum @xmath100 .",
    "this results in a model with @xmath101 ` comparator ` constraints ( and later in an encoding with @xmath101 clauses ) .",
    "another approach , also supported in , does not decompose the constraint but encodes it directly to a cnf of size @xmath102 , as in the context of so - called totalizers  @xcite . a hybrid approach , leaves the choice to , depending on the size of the domains of the variables involved .",
    "finally , we note that the user can configure  to fix the way it compiles this constraint ( and others ) .",
    "[ [ section-4 ] ]    is the last phase and applies to all remaining simplified constraints .",
    "the encoding of constraints to cnf is standard and similar to the encodings in sugar  @xcite .",
    "[ [ section-5 ] ]    are about the cardinality of sets of boolean variables and are specified by the template @xmath76,~i)}$ ] .",
    "cardinality constraints are normalized , see e.g. , @xcite , so we only consider @xmath103 .",
    "partial evaluation rules for cardinality constraints are the obvious .",
    "for example , in the special case when ` i ` is a constant :    @xmath104,~3)\\mapsto    bool\\_array\\_sum\\_leq([x_1,x_2,x_4],~2)}$ ]    @xmath105,~3)\\mapsto    bool\\_array\\_sum\\_leq([x_1,x_2,x_4],~3)}$ ]    @xmath106,~3)\\mapsto    bool\\_array\\_sum\\_leq([x_2,x_4],~2)}$ ]    the special case , when ` i ` is the constant  1 is called the `` at - most - one '' constraint and it has been studied extensively ( for a recent survey see @xcite ) . in ,",
    "we support two different encodings for this case ( the user can choose ) .",
    "the first is the standard `` pairwise '' encoding which specifies a clause @xmath107 for each pair of boolean variables @xmath4 and @xmath108 .",
    "this encoding introduces @xmath102 clauses and is sometimes too large .",
    "the second , is a more compact encoding which follows the approach described in  @xcite . in the general case ( when @xmath109 ) the constraint is decomposed , much the same as the @xmath110 constraint , to a network of @xmath94 constraints .",
    "[ [ section-6 ] ]    specifies that a set of integer variables take all different values .",
    "although we adopt the order - encoding for integer variables , it is well accepted that for these constraints the direct encoding is superior @xcite .",
    "for this reason , in , when processing the constraint , a dual representation is chosen .",
    "when integer variable @xmath45 , occurring in an ` alldiff ` constraint , is declared , it was unified with its unary representation in the order - encoding : @xmath111}$ ] .",
    "in addition , we associate ` i ` with a new bit - blast , @xmath112}$ ] , in the direct encoding .",
    "we introduce for each such ` i ` a channeling formula to capture the relation between its two representations .",
    "@xmath113,[d_0,\\ldots , d_{n}])=    \\left(\\begin{array}{r } d_0 = \\neg x_1 \\\\                           \\wedge~ d_n = x_n    \\end{array}\\right ) \\wedge    \\bigwedge_{i=1}^{n-1}(d_i\\leftrightarrow x_{i}\\wedge\\neg x_{i+1})}\\ ] ]    during constraint simplification , the @xmath74)}$ ] constraint is viewed as a bit matrix where each row consists of the bits @xmath114}$ ] for @xmath115 in the direct encoding .",
    "the element @xmath116 is true iff @xmath117 takes the value @xmath118 .",
    "the @xmath119 column specifies which of the @xmath117 take the value @xmath118 and hence , at most one variable in a column may take the value true .",
    "distinguishes the special case when @xmath120}$ ] must take precisely @xmath121 different values . in this case",
    "the constraint is about `` permutation '' .",
    "we denote this by a flag ( * ) as in @xmath122)}$ ] . in this case",
    ", exactly one bit in each column of the representation must take the value true .    to simplify an",
    "` alldiff ` constraint ,  applies simplification rules to the implicit cardinality constraints on the columns and also two specific ` alldiff ` rules .",
    "the first is essentially the usual domain consistent propagator  @xcite focusing on hall sets of size 2 .",
    "the second rule applies only to an @xmath123 constraint which is about permutation .",
    "we denote the values that @xmath115 can take as @xmath124 .",
    "@xmath125 : :    when @xmath126 :    @xmath127 ) }    \\overset{\\theta}{\\longmapsto }    \\mathtt{alldiff([i_3,\\ldots , i_n])}\\ ] ] where    @xmath128 .",
    "@xmath129 : :    when    @xmath130 , and    for @xmath131 ,    @xmath132    @xmath133 ) }    \\overset{\\theta}{\\longmapsto }    \\mathtt{alldiff^*([i_1,\\ldots , i_n])}\\ ] ] where    @xmath134 .    to illustrate the two rules for ` alldiff ` consider the following",
    "consider an ` alldiff ` constraint on 5 integer variables taking values in the interval @xmath135 $ ] where the first two can take only values 0 and 1 .",
    "so , they are a hall set of size two and rule @xmath136 applies .",
    "we present the simplification step on the order encoding representation ( though it is triggered through the direct encoding representation ) : @xmath137 } \\\\ { [ } x_{2,1},\\hspace{-3mm}&0,\\hspace{-3 mm } & \\ldots,\\hspace{-3mm}&0 { ] } \\\\ { [ } x_{3,1},\\hspace{-3mm}&x_{3,2},\\hspace{-3 mm } & \\ldots,\\hspace{-3mm}&x_{3,7 } { ] } \\\\ { [ } x_{4,1},\\hspace{-3mm}&x_{4,2},\\hspace{-3 mm } & \\ldots,\\hspace{-3mm}&x_{4,7 } { ] } \\\\ { [ } x_{5,1},\\hspace{-3mm}&x_{5,2},\\hspace{-3 mm } & \\ldots,\\hspace{-3mm}&x_{5,7 } { ] } \\end{array } \\right ) \\overset{\\theta}{\\longmapsto } \\mathtt{alldiff}\\left ( \\begin{array}{ccc } { [ } 1,x_{3,2},\\hspace{-3 mm } & \\ldots,\\hspace{-3mm}&x_{3,7 } { ] } \\\\ { [ } 1,x_{4,2},\\hspace{-3 mm } & \\ldots,\\hspace{-3mm}&x_{4,7 } { ] } \\\\ { [ } 1,x_{5,2},\\hspace{-3 mm } & \\ldots,\\hspace{-3mm}&x_{5,7 } { ] } \\end{array } \\right)\\ ] ] where @xmath138 .",
    "now consider a setting where an ` alldiff ` constraint is about 5 variables that can take 5 values ( permutation ) and the first two are the only two that can take values 0 and 1",
    ". so rule @xmath139 applies .",
    "we present the simplification step on the order encoding representation ( though it is triggered through the direct encoding representation ) : @xmath140 } \\\\ { [ } x_{2,1},\\hspace{-3mm}&x_{2,2},\\hspace{-3mm}&x_{2,3},\\hspace{-3mm}&x_{2,4 } { ] } \\\\ { [ } 1,\\hspace{-3mm}&1,\\hspace{-3mm}&x_{3,3},\\hspace{-3mm}&x_{3,4 } { ] } \\\\ { [ } 1,\\hspace{-3mm}&1,\\hspace{-3mm}&x_{4,3},\\hspace{-3mm}&x_{4,4 } { ] } \\\\ { [ } 1,\\hspace{-3mm}&1,\\hspace{-3mm}&x_{5,3},\\hspace{-3mm}&x_{5,4 } { ] } \\end{array } \\right ) \\overset{\\theta}{\\longmapsto } \\mathtt{alldiff^*}\\left ( \\begin{array}{lccr } { [ } x_{1,1},\\hspace{-3mm}&0,\\hspace{-3mm}&0,\\hspace{-3mm}&0 { ] } \\\\ { [ } x_{2,1},\\hspace{-3mm}&0,\\hspace{-3mm}&0,\\hspace{-3mm}&0 { ] } \\\\ { [ } 1,\\hspace{-0mm}&1,\\hspace{-0mm}&x_{3,3},\\hspace{-3mm}&x_{3,4 } { ] } \\\\ { [ } 1,\\hspace{-0mm}&1,\\hspace{-0mm}&x_{4,3},\\hspace{-3mm}&x_{4,4 } { ] } \\\\ { [ } 1,\\hspace{-0mm}&1,\\hspace{-0mm}&x_{5,3},\\hspace{-3mm}&x_{5,4 } { ] } \\end{array } \\right)\\ ] ] where @xmath141 .",
    "when no further simplification rules apply the ` alldiff ` constraint is decomposed to the corresponding cardinality constraints on the columns of its bit matrix representation .",
    "consider again the vmtl example and the constraints from figure  [ fig : vmtl - instance ] .",
    "we focus on three constraints and follow the steps made when compiling these ( we write `` 14 '' as short for @xmath142}$ ] ) .",
    "@xmath143 , 14 ) } \\\\ ( 2 ) & \\mathtt{alldiff([v_1,v_2,v_3,v_4,e_1,e_2,e_3,e_4 ] ) , } \\\\ ( 3 ) & \\mathtt{int\\_array\\_plus([v_3,e_2,e_3,e_4 ] , 14 ) , }   \\end{array}$ ]    in the first steps , constraint ( 1 ) is decomposed to an ` int_plus ` constraint which has the same form as the constraint in example  [ ex : plus14 ] .",
    "so , we have the bindings @xmath144}$ ] and @xmath145}$ ] .",
    "now , consider the ` alldiff ` constraint ( 2 )",
    ".  determines that this constraint is about permutation ( 8 integer variables with 8 different values in the range [ 1,8 ] ) .",
    "the simplification rules for ` alldiff ` detect that @xmath146 must take together the two values 6 and 8 ( using a simplification rule similar to @xmath147 ) triggerring the substitution @xmath148 .",
    "now rule @xmath136 detects a hall set @xmath146 of size two : @xmath149 ) } \\xrightarrow{\\theta }   \\mathtt{alldiff([v_1,v_2,v_3,e_1,e_2,e_3])}\\ ] ] where @xmath150 is the unification that imposes @xmath151 .",
    "so we have the following bindings ( where the impact of @xmath150 is underlined ) : @xmath152 } \\qquad & \\mathtt{e_{1}=     [ 1,e_{1,2},e_{1,3},e_{1,4},e_{1,5},\\underline{e_{1,7},e_{1,7}},0 ] } \\\\",
    "\\mathtt{v_{2}=     [ 1,v_{2,2},v_{2,3},v_{2,4},v_{2,5},\\underline{v_{2,7},v_{2,7}},0 ] } & \\mathtt{e_{2}=     [ 1,e_{2,2},e_{2,3},e_{2,4},e_{2,5},\\underline{e_{2,7},e_{2,7}},0 ] } \\\\ \\mathtt{v_{3}=     [ 1,v_{3,2},v_{3,3},v_{3,4},v_{3,5},\\underline{v_{3,7},v_{3,7}},0 ] } & \\mathtt{e_{3}=     [ 1,e_{3,2},e_{3,3},e_{3,4},e_{3,5},\\underline{e_{3,7},e_{3,7}},0 ] } \\\\ \\mathtt{v_{4}=     [ 1,1,1,1,1,1,v_{4,7},v_{4,7 } ] } &   \\mathtt{e_{4}=     [ 1,1,1,1,1,1,\\neg v_{4,7},\\neg v_{4,7 } ] } \\end{array}\\ ] ]    consider now the constraint ( 3 ) .",
    "equi - propagation ( because of bounds ) dictates that @xmath153 , so this constraint then simplifies as follows :    @xmath154},\\\\      ~~\\mathtt{[1,e_{2,2},e_{2,3},e_{2,4},e_{2,5},0,0,0]},\\\\      ~~\\mathtt{[1,e_{3,2},e_{3,3},e_{3,4},e_{3,5},0,0,0]},\\\\      ~~\\mathtt{[1,1,1,1,1,1,\\neg v_{4,7},\\neg v_{4,7}]},~14~     \\mathtt { ] ) }    \\end{array}$ } \\longmapsto     \\fbox{$\\begin{array}{l }      \\mathtt{int\\_array\\_plus([}\\\\      ~~\\mathtt{[v_{3,2},v_{3,3},v_{3,4},v_{3,5}]},\\\\      ~~\\mathtt{[e_{2,2},e_{2,3},e_{2,4},e_{2,5}]},\\\\      ~~\\mathtt{[e_{3,2},e_{3,3},e_{3,4},e_{3,5}]},\\\\      ~~\\mathtt{[\\neg v_{4,7},\\neg v_{4,7}]},~5~      \\mathtt { ] ) }    \\end{array}$}\\ ] ] after applying simplification and decomposition rules on all the constraints from figure  [ fig : vmtl - instance ] until no further rules can be applyed , the constraints will be encoded to cnf .",
    "the generated cnf contains 301 clauses and 48 boolean variables .",
    "compiling the same set of constraints from figure  [ fig : vmtl - instance ] without applying simplification rules generates a larger cnf which contains 642 clauses and 97 boolean variables .",
    "the dna word problem ( problem ` 033 ` of csplib ) seeks the largest parameter @xmath121 , such that there exists a set @xmath155 of @xmath121 eight - letter words over the alphabet @xmath156 with the following properties : * ( 1 ) * each word in @xmath155 has exactly 4 symbols from @xmath157 ; * ( 2 ) * each pair of distinct words in @xmath155 differ in at least 4 positions ; and * ( 3 ) * for every @xmath158 : @xmath159 ( the reverse of @xmath160 ) and @xmath161 ( the word obtained by replacing each @xmath162 by @xmath163 , each @xmath164 by @xmath88 , and vice versa ) differ in at least 4 positions .",
    "in  @xcite , the authors present a strategy to solve this problem where the four letters are modeled by bit - pairs @xmath165 .",
    "each eight - letter word can then be viewed as the combination of a _",
    "`` t - part '' _ , @xmath166 , which is a bit - vector , and a _ `` m - part '' _ , @xmath167 , also a bit - vector .",
    "building on the approach described in  @xcite , we pose conditions on sets of _",
    "`` t - parts '' _ and _ `` m - parts '' _ ,",
    "@xmath163 and @xmath168 , so that their cartesian product @xmath169 will satisfy the requirements of the original problem . from the three conditions below , @xmath163 is required to satisfy ( 1@xmath170 ) and ( 2@xmath170 ) , and @xmath168 is required to satisfy ( 2@xmath170 ) and ( 3@xmath170 ) . for a set of bit - vectors @xmath171 , the conditions are : * ( 1@xmath170 ) * each bit - vector in @xmath171 sums to 4 ; * ( 2@xmath170 ) * each pair of distinct bit - vectors in @xmath171 differ in at least 4 positions ; and * ( 3@xmath170 * ) for each pair of bit - vectors ( not necessarily distinct ) @xmath172 , @xmath173 ( the reverse of @xmath174 ) and @xmath175 ( the complement of @xmath176 ) differ in at least 4 positions .",
    "this is equivalent to requiring that @xmath177 differs from @xmath176 in at least 4 positions .",
    "it is this strategy that we model in our  encoding .",
    "an instance takes the form @xmath178 signifying the numbers of bit - vectors , @xmath179 and @xmath180 in the sets @xmath163 and @xmath168 . without loss of generality ,",
    "we impose , to remove symmetries , that @xmath163 and @xmath168 are lexicographically ordered .",
    "a solution is the cartesian product @xmath169 . in section  [ results ]",
    "we report that using  enables us to solve interesting instances of the problem not previously solvable by other techniques .",
    "is implemented in ( swi ) prolog and can be applied in conjunction with the cryptominisat solver @xcite through a prolog interface @xcite .",
    "can be downloaded from @xcite where one can find also the examples from this paper and others .",
    "the distribution includes also a solver , which we call bumble , which enables to specify a  model as an input file and solve it .",
    "the output is a set of bindings to the declared variables in the model .    in",
    ", boolean variables are represented as prolog variables .",
    "the negation of ` x ` is represented as ` -x ` .",
    "the truth values , @xmath41 and @xmath42 , are denoted ` 1 ` and ` -1 ` .",
    "integer variables ( including negative range values ) are represented in the order - encoding . when processing ( bit - blasting ) a declaration @xmath181 , prolog variable ` i ` is unified with the tuple ` ( min , max , bits , lastbit ) ` where ` min ` and ` max ` are constants indicating the interval domain of ` i ` , ` bits ` is a list of @xmath182 variables , and ` lastbit ` is the last variable of ` bits ` .",
    "this representation is more concise than the one assumed for simplicity in the previous sections and it also supports negative numbers . maintaining direct access to the last bit in the representation ( we already can access the first bit through the list ` bits ` ) facilitates a ( constant time ) check if the lower and upper bound values of a variable has changed . this way we can more efficiently determine when ( certain ) simplification rules apply .",
    "we make a few notes : ( 1 ) integer variables must be declared before use ; ( 2 )  allows the use of constants in constraints instead of declaring them as integer variables ( for example @xmath183 represents a declaration @xmath184 together with the constraint @xmath185 ) ; ( 3 ) integer variables can be negated .    maintains constraints as a prolog list ( of terms ) . each type of constraint is associated with corresponding rules for simplification , decomposition , and encoding to cnf .",
    "after bit - blasting , constraints are first simplified ( equi - propagation and partial evaluation ) using these rules until no further rules apply . during this process , if a pair of literals is equated ( e.g.   as in ` x = y , x =- y , x=1 , x=-1 ` ) , then they are unified , thus propagating the effect to other constraints . after constraint simplification",
    ", some constraints are decomposed , and this process repeats .",
    "we end up with a set of `` basic '' constraints ( which can not be further decomposed or simplified ) .",
    "these are then encoded to cnf .",
    "we report on our experience in applying . to appreciate the ease in its use , and for further details , the reader is encouraged to view the example encodings available with the tool @xcite .",
    "all experiments run on an intel core 2 duo e8400 3.00ghz cpu with 4 gb memory under linux ( ubuntu lucid , kernel 2.6.32 - 24-generic ) .",
    "is written in prolog and run using swi prolog v6.0.2 64-bits .",
    "comparisons with sugar ( v1.15.0 ) are based on the use of identical constraint models , apply the same sat solver ( cryptominisat v2.5.1 ) , and run on the same machine .",
    "for all of the tables describing experiments , columns indicate :    * compile time ( seconds ) * number of cnf clauses    * number of cnf variables * sat solving time ( seconds )    we first focus on the impact of the dual representation for ` alldiff `  constraints .",
    "we report on the application of  to quasi - group completion problems ( qcp ) , proposed by as a constraint satisfaction benchmark , where the model is a conjunction of ` alldiff `  constraints .",
    "[ [ section-7 ] ]    lc|rrrr|rrrr|rrr & & & + & & comp & clauses & vars & sat & comp & clauses & vars & sat & clauses & vars & sat + 25 - 264 - 0 & sat & 0.23 & 6509 & 1317 & 0.33 & 0.36 & 33224 & 887 & 8.95 & 126733 & 10770 & 34.20 + 25 - 264 - 1 & sat & 0.20 & 7475 & 1508 & 3.29 & 0.30 & 34323 & 917 & 97.50 & 127222 & 10798 & 13.93 + 25 - 264 - 2 & sat & 0.21 & 6531 & 1329 & 0.07 & 0.30 & 35238 & 905 & 2.46 & 127062 & 10787 & 8.06 + 25 - 264 - 3 & sat & 0.21 & 6819 & 1374 & 0.83 & 0.29 & 32457 & 899 & 18.52 & 127757 & 10827 & 44.03 + 25 - 264 - 4 & sat & 0.21 & 7082 & 1431 & 0.34 & 0.29 & 32825 & 897 & 19.08 & 126777 & 10779 & 85.92 + 25 - 264 - 5 & sat & 0.21 & 7055 & 1431 & 3.12 & 0.30 & 33590 & 897 & 46.15 & 126973 & 10784 & 41.04 + 25 - 264 - 6 & sat & 0.21 & 7712 & 1551 & 0.34 & 0.33 & 39015 & 932 & 69.81 & 128354 & 10850 & 12.67 + 25 - 264 - 7 & sat & 0.21 & 7428 & 1496 & 0.13 & 0.30 & 36580 & 937 & 19.93 & 127106 & 10794 & 7.01 + 25 - 264 - 8 & sat & 0.21 & 6603 & 1335 & 0.18 & 0.27 & 31561 & 896 & 10.32 & 124153 & 10687 & 9.69 + 25 - 264 - 9 & sat & 0.21 & 6784 & 1350 & 0.19 & 0.27 & 35404 & 903 & 34.08 & 128423 & 10853 & 38.80 + 25 - 264 - 10 & unsat & 0.21 & 6491 & 1296 & 0.04 & 0.30 & 33321 & 930 & 10.92 & 126999 & 10785 & 57.75 + 25 - 264 - 11 & unsat & 0.12 & 1 & 0 & 0.00 & 0.28 & 37912 & 955 & 0.09 & 125373 & 10744 & 0.47 + 25 - 264 - 12 & unsat & 0.16 & 1 & 0 & 0.00 & 0.29 & 39135 & 984 & 0.08 & 127539 & 10815 & 0.57 + 25 - 264 - 13 & unsat & 0.12 & 1 & 0 & 0.00 & 0.29 & 35048 & 944 & 0.09 & 127026 & 10786 & 0.56 + 25 - 264 - 14 & unsat & 0.23 & 5984 & 1210 & 0.07 & 0.28 & 31093 & 885 & 11.60 & 126628 & 10771 & 15.93 + total & & & & & 8.93 & & & & 349.58 & & & 370.63 +    we consider 15 instances from the 2008 csp competition .",
    "table  [ tab : qcpexpr ] considers three settings :  with its dual encoding for ` alldiff `  constraints ,  using only the order encoding ( equivalent to using @xmath186 constraints instead of ` alldiff ` ) , and sugar .",
    "the results indicate that : ( 1 ) application of  using the dual representation for ` alldiff `  is 38 times faster and produces 20 times less clauses ( in average ) than when using the order - encoding alone ( despite the need to maintain two encodings ) ; ( 2 ) without the dual representation , solving encodings generated by  is only slightly faster but  generates cnf encodings 4 times smaller ( on average ) than those generated by sugar .",
    "observe that 3 instances are found unsatisfiable by  ( indicated by a cnf with a single clause and no variables ) .",
    "we comment that sugar preprocessing times are higher than those of  and not indicated in the table .    to further appreciate the impact of the tool we describe results for three additional applications which shift the state - of - the - art with respect to what could previously be solved .",
    "the experiments clearly illustrate that  decreases the size of cnf encodings as well as the subsequent sat solving time .",
    "[ [ section-8 ] ]    in @xcite the authors conjecture that the @xmath121 vertex complete graph , @xmath187 , for @xmath188 has a vertex magic total labeling with magic constants for specific range of values of @xmath189 , determined by @xmath121 .",
    "this conjecture is proved correct for all odd @xmath121 and verified by brute force for @xmath190 .",
    "we address the cases for @xmath191 and @xmath192 which involve 15 instances ( different values of @xmath86 ) for @xmath191 , and 23 ( different values of @xmath86 ) for @xmath192 .",
    "starting from the simple constraint model ( illustrated by the example in figure  [ fig : vmtl - instance ] ) , we add additional constraints to exploit that the graphs are symmetric : ( 1 ) we assume that the edge with the smallest label is @xmath193 ; ( 2 ) we assume that the labels of the edges incident to @xmath194 are ordered and hence introduce constraints @xmath195 ; ( 3 ) we assume that the label of edge @xmath196 is smaller than the labels of the edges incident to @xmath197 ( except @xmath193 ) and introduce constraints accordingly . in this",
    "setting  can solve all except 2 instances with a 4 hour timeout and sugar can solve all except  4 .    table  [ tab : k8 ] depicts results for the 10 hardest instances for @xmath198 and the 20 hardest for @xmath199 with a 4 hour time - out .",
    "compilation times are on the order of 0.5 sec / instance for @xmath198 and 2.5 sec / instance for @xmath199 .",
    "sugar encoding times are slightly larger .",
    "the instances are indicated by the magic constant , @xmath189 ; the columns for  and sugar indicate sat solving times ( in seconds ) .",
    "the bottom two lines indicate average encoding sizes ( numbers of clauses and variables ) .    c|c|r|r @xmath198 & @xmath189 & & + & 143 & 1.26 & 2.87 + & 142 & 10.14 & 1.62 + & 141 & 7.64 & 2.94 + & 140 & 14.68 & 6.46 + & 139 & 25.60 & 6.67 + & 138 & 12.99 & 2.80 + & 137 & 22.91 & 298.58 + & 136 & 14.46 & 251.82 + & 135 & 298.54 &",
    "182.90 + & 134 & 331.80 & @xmath200 +   + & 248 & 402 + & 5688&9370 +    c|c|r|r @xmath199&k & & + & 277 & 5.31 & 9.25 + & 276 & 7.11 & 9.91 + & 275 & 13.57 & 19.63 + & 274 & 4.93 & 9.24 + & 273 & 45.94 & 9.03 + & 272 & 22.74 & 86.45 + & 271 & 7.35 & 9.49 + & 270 & 6.03 & 55.94 + & 269 & 5.20 & 11.05 + & 268 & 94.44 & 424.89 +   +   +   +    r|r|r k   & & + 267   & 88.51 & 175.70 + 266   & 229.80 & 247.56 + 265   & 1335.31 & 259.45 + 264   & 486.09 & 513.61 + 263   & 236.68 & 648.43 + 262   & 1843.70 & 6429.25 + 261   & 2771.60 & 7872.76 + 260   & 4873.99 & @xmath200 + 259   & @xmath200 & @xmath200 + 258   & @xmath200 & @xmath200 +   + & 1229&1966 + & 15529&25688 +    the results indicate that the sugar encodings are ( in average ) about 60% larger , while the average sat solving time for the encodings is about 2 times faster ( average excluding instances where sugar times - out ) .    to address the two vmtl instances not solvable using the  models described above ( @xmath199 with magic labels 259 and 258 ) , we partition the problem fixing the values of @xmath193 and @xmath196 and maintaining all of the other constraints .",
    "analysis of the symmetry breaking constraints indicates that this results in 198 new instances for each of the two cases .",
    "the original vmtl instance is solved if any one of of these 198 instances is solved .",
    "so , we solve them in parallel .",
    "fixing @xmath193 and @xmath196 `` fuels '' the compiler so the encodings are considerably smaller . the instance for @xmath201 is solved in 1379.50 seconds where @xmath202 and @xmath203 .",
    "the compilation time is 2.09 seconds and the encoding consists in 1056107 clauses and 14143 variables .    to the best of our knowledge ,",
    "the hard instances from this suite are beyond the reach of all previous approaches to program the search for magic labels .",
    "the sat based approach presented in @xcite can not handle these .",
    "the comparison with sugar indicates the impact of the compiler .",
    "[ [ section-9 ] ]    provide a comparison of several state - of - the - art solvers applied to the dna word problem with a variety of encoding techniques .",
    "their best reported result is a solution with 87 dna words , obtained in 554 seconds , using an opl  @xcite model with lexicographic order to break symmetry . in  @xcite ,",
    "the authors report a solution composed from two pairs of ( t - part and m - part ) sets @xmath204 and @xmath205 where @xmath206 , @xmath207 , @xmath208 , @xmath209 .",
    "this forms a set @xmath155 with @xmath210 dna words .",
    "marc van dongen reports a larger solution with 112 words .",
    "using , we find , in a fraction of a second , a template of size 14 and a map of size 8 .",
    "this provides a solution of size @xmath211 to the dna word problem . running comet ( v2.0.1 ) we find a 112 word solution in about 10 seconds using a model by hkan kjellerstrand .",
    "we also prove that there does not exist a template of size 15 ( 0.15 seconds ) , nor a map of size 9 ( 4.47 seconds ) .",
    "these facts were unknown prior to .",
    "proving that there is no solution to the dna word problem with more than 112 words , not via the two part t - m strategy , is still an open problem .",
    "[ [ section-10 ] ]    ( mbd ) is an artificial intelligence based approach that aims to cope with the , so - called , diagnosis problem  ( e.g.  @xcite ) . in  @xcite ,",
    "we ( with other researchers ) focus on a notion of minimal cardinality mbd and apply  to model and solve the instances of a standard mbd benchmark . experimental evidence ( see @xcite ) , indicates that our approach is superior to all existing algorithms for minimal cardinality mbd .",
    "we determine , for the first time , minimal cardinality diagnoses for the entire standard benchmark .",
    "prior attempts to apply sat for mbd ( for example , by and where a maxsat solver is used ) indicate that sat solvers perform poorly on the standard benchmarks .",
    "so , really makes the difference .",
    "we introduce , a compiler to encode finite domain constraints to cnf .",
    "a key design point is to apply bit - level techniques , locally as prescribed by the word - level constraints in a model .",
    "optimizations are based on equi - propagation and partial evaluation . implemented in prolog ,",
    "compilation times are typically small ( measured in seconds ) even for instances which result in several millions of cnf clauses . on the other hand ,",
    "the reduction in sat solving time can be larger in orders of magnitude .",
    "it is well - understood that making a cnf smaller is not the ultimate goal : often smaller cnf s are harder to solve .",
    "indeed , one often introduces redundancies to improve sat encodings : so removing them is counter productive .",
    "our experience is that  reduces the size of an encoding in a way that is productive for the subsequent sat solving . in particular , by removing variables that can be determined `` at compile time '' to be definitely equal ( or definitely different ) in any solution .",
    "the simplification rules illustrated in section  [ sec : compiling ] apply standard constraint programming techniques ( i.e.  to reduce variable domains ) .",
    "however , equi - propagation is more powerful .",
    "it focuses , in general , in specializing the bit - level representation of the constraints in view of equations implied by the constraints . in this way",
    "it captures many of the well - known constraint programming preprocessing techniques , and more .",
    "future work will investigate : how to strengthen the implementation of equi - propagation using bdd s and sat solving techniques , how to improve the compiler implementation using better data - structures for the constraint store ( for example applying a chr based approach for the simplification rules ) , and how to enhance the underlying constraint language .",
    ", del val , a. , dot , i. , fernndez , c. , and many , f. 2004 .",
    "modeling choices in quasigroup completion : sat vs. csp . in _ aaai _",
    ", d.  l. mcguinness and g.  ferguson , eds .",
    "aaai press / the mit press , san jose , california , usa , 137142 .        \\1968 .",
    "sorting networks and their applications . in _",
    "afips spring joint computing conference_. afips conference proceedings , vol .",
    "thomson book company , washington d.c . ,",
    "atlantic city , nj , usa , 307314 .            \\1994 .",
    "experimental results on the application of satisfiability algorithms to scheduling problems . in _ aaai _ , b.  hayes - roth and r.  e. korf , eds .",
    "vol .  2 . aaai press / the mit press , seattle , wa , usa , 10921097 .        ,",
    "provan , g. , de  kleer , j. , robert , s. , and van gemund , a. 2010 .",
    "solving model - based diagnosis problems with max - sat solvers and vice versa .",
    "https://www.phmsociety.org/events/workshop/dx/10/proceedings .",
    "encodings of the at - most-_k _ constraint : some old , some new , some fast , some slow . workshop on constraint modeling and reformulation ( modref 2010 ) http://www.it.uu.se/research/group/astra/modref10/programme.html .                      , stern , r. , kalech , m. , and codish , m. 2012 . compiling model - based diagnosis to boolean satisfaction . tech . rep .",
    ", department of computer science , ben - gurion university .",
    "www.cs.bgu.ac.il/~mcodish/papers/sources/satmbd.pdf .    ,",
    "stuckey , p.  j. , becket , r. , brand , s. , duck , g.  j. , and tack , g. 2007 .",
    ": towards a standard cp modelling language . in _ principles and",
    "practice of constraint programming _ , c.  bessiere , ed .",
    "lncs , vol .",
    "springer - verlag , 529543 ."
  ],
  "abstract_text": [
    "<S> we present , a compiler which enables to encode finite domain constraint problems to cnf . using  both </S>",
    "<S> eases the encoding process for the user and also performs transformations to simplify constraints and optimize their encoding to cnf . </S>",
    "<S> these optimizations are based primarily on equi - propagation and on partial evaluation , and also on the idea that a given constraint may have various possible cnf encodings . </S>",
    "<S> often , the better encoding choice is made after constraint simplification .  </S>",
    "<S> is written in prolog and integrates directly with a sat solver through a suitable prolog interface . </S>",
    "<S> we demonstrate that constraint simplification is often highly beneficial when solving hard finite domain constraint problems . </S>",
    "<S> a  implementation is available with this paper .    </S>",
    "<S> [ firstpage ]    sat encoding , fd constraints , equi - propagation , partial evaluation . </S>"
  ]
}