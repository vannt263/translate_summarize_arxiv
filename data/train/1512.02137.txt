{
  "article_text": [
    "in most of the common numerical methods for the solution of partial differential equations on bounded domains @xmath1 , one defines approximate solutions by first subdividing @xmath2 into a finite number of cells , and then setting up a system of equations on these cells .",
    "usually , cells are either triangular or quadrilateral ( for @xmath3 ) , or tetrahedral , prismatic , pyramidal , or hexahedral ( for @xmath4 ) .",
    "because certain aspects of the solution may be associated with cells or edges ( in 2d ) , or cells , faces and edges ( in 3d ) , essentially all sufficiently general codes use data structures for such meshes that explicitly or implicitly store not only cells and vertex locations , but also faces and edges and allow associating data with these objects .    in many cases ,",
    "the data that is associated with a cell , face , edge , or vertex may have a physical location somewhere on this object .",
    "for example , when using a @xmath5 bicubic finite element on a rectangular cell , we need to store the index ( and possibly the value ) of one degree of freedom per vertex , two along the edge ( typically at 1/3 and 2/3 along its extent ) , and 4 inside the cell . in order to define where a distance of 1/3 or 2/3 along the edge is ,",
    "we need to define a coordinate system on the edge .",
    "the same is true when implementing ndlec elements that define degrees of freedom as tangential vectors along edges , and therefore need to define a direction on each edge . for similar reasons ,",
    "we typically also need coordinate systems within each cell .",
    "we then need to define how the coordinate system defined on the edge relates to that of the adjacent cells .",
    "we can either do this by letting every quadrilateral cell store pointers to the four edges along with one bit per edge that indicates how the direction of the edge embeds in the coordinate system of the cell .",
    "or we could seek a convention by which we orient all edges of the mesh once at the beginning so that the orientation of each cell implies the orientation of its bounding edges .",
    "in the latter case , we would not need to store direction flags , and algorithms built on this convention would not need to provision for different possible directions , thereby greatly simplifying code construction and maintenance .",
    "this paper is concerned with the following two questions :    * is it possible to find such a convention for quadrilateral meshes ( an example of such a mesh is shown in fig .",
    "[ fig : wing ] ) ? we will constructively show that this is indeed possible in 2d when adopting the convention that the edges that bound opposite sides of each cell point in the same direction ; see the left panel of fig .",
    "[ fig : convention ] .. ] * is it possible to assign directions to all edges of a mesh that satisfy this convention in a computationally efficient manner ?",
    "we will demonstrate that this is in fact so : our construction of a proof for the answer to the first question ( in section  [ sec:2d ] ) also implies an algorithm that we show to be order optimal , i.e. , it runs in a time proportional to the number of edges in the mesh .         .",
    "right : for hexahedra in @xmath4.__,title=\"fig : \" ] .",
    "right : for hexahedra in @xmath4.__,title=\"fig : \" ]    on the other hand , we will show in section  [ sec:3d ] that the corresponding convention in 3d ( see the right panel of fig .  [ fig : convention ] ) allows for examples where it is not possible to orient edges so that coordinate systems of adjacent cells are implied .",
    "however , we will show that the extension of the 2d algorithm to 3d either produces a consistent set of edge orientations or fails , both within order optimal complexity .",
    "there are , however , important classes of 3d meshes that always allow such edge directions , and we will discuss these in section  [ sec:3d - always - orientable ] .    on the other hand , in 3d",
    "one may want to not only have consistent directions for edges of cells , but also for faces , and the corresponding case is discussed in section  [ sec:3d - faces ] where we show that there are cases where it is possible to find either consistent edge or face orientations , but not both .",
    "the paper is complemented by section  [ sec : notation ] defining notation , conclusions in section  [ sec : conclusions ] , and an appendix in which we we prove a generalization of the main statement of the paper to general manifolds .",
    "[ [ related - literature ] ] related literature + + + + + + + + + + + + + + + + + +    finite element software packages have traditionally taken different routes to dealing with the problem of relative orientations of cells and their edges and faces .",
    "in many cases , software has been developed to only support linear or quadratic @xmath6-type elements , in which case edge and face orientations are not in fact of any concern at all .",
    "others use triangular or tetrahedral meshes for which it is necessary to explicitly store edge orientations ; see , for example , @xcite . for quadrilaterals and hexahedra , strategies for implementation in specific packages are discussed in @xcite for the fenics library and @xcite for the kardos package . we have found that dune @xcite and nektar++ @xcite appear to explicitly store edge directions as part of their mesh data structures or finite element implementations , but we could not find written elaborations of their strategies in publications or overview documents .",
    "finally , descriptions of finite elements that use _ global _ conventions for edge orientations ( i.e. , based on vertex coordinates or indices , instead of in relation to locally adjacent cells ) can be found in @xcite and are used , for example , in libmesh @xcite .",
    "constructions similar to those in this paper have previously been discussed in the discrete geometry literature , see @xcite for examples . however , this part of the literature is not typically concerned with algorithms and their complexity ( such as our discussions in sections  [ sec:2d ] and [ sec:3d ] ) , nor with the particular application of these ideas to finite element meshes ( such as our discussion of specific types of meshes in section  [ sec:3d - always - orientable ] ) .",
    "our contribution therefore provides a relevant extension of what is available in the literature .    [",
    "[ a - historical - note ] ] a historical note + + + + + + + + + + + + + + + + +    the algorithms discussed herein were implemented in the deal.ii library in 2003 , with an incomplete discussion of the topic available in the documentation of deal.iis ` gridreordering ` class .",
    "a more formal description of these algorithms has recently appeared in @xcite ; it extends our 2d algorithms to meshes stored on distributed memory , parallel machines , but it lacks the complexity analysis that we provide here , as well as much of the discussion of the 3d case .",
    "the introduction in deal.ii of the convention discussed above predates 2003 . in its earliest days ,",
    "the library was almost always used on small problems for which edge orientations could be determined by hand on a piece of paper , and little consideration was given to the question whether it always exists and if so whether there is an efficient algorithm to generate it automatically . however , as the project grew and more applications used the 3d part , these questions became more important .",
    "initially , an algorithm that generated edge orientations using a backtracking algorithm was implemented .",
    "this works for meshes with up to a few hundred cells , but fails due to excessive run times for larger ones .",
    "in particular , it is easy to construct meshes for which it had exponential run time",
    ". therefore , more efficient algorithms were needed , leading to the results reported here .    [",
    "[ availability - of - implementations ] ] availability of implementations + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + +    we have implemented the algorithms outlined here in the deal.ii library ( see http://www.dealii.org/ and @xcite ) , and they are available as part of the ` gridreordering ` class under the lgpl open source license .",
    "throughout this paper , we will consider triangulations @xmath7 such as those shown in fig .",
    "[ fig : wing ] , as a collection @xmath8 of quadrilateral or hexahedral cells @xmath9 .",
    "these cells can be considered as open geometric objects @xmath10 so that ( i )  @xmath11 if @xmath12 , ( ii )  the intersection of the closure of two cells , @xmath13 , is either empty , a vertex of the mesh , or a complete edge or face of both cells , and ( iii )  @xmath14 where @xmath15 is the bounded , open domain that is subdivided into the triangulation .",
    "we assume that the triangulation has only finitely many cells .",
    "for the purposes of this paper , we do not require that the union of mesh cells corresponds to a simply connected domain .",
    "we will rely on the very practical assumption that the volume of each cell is positive and that cells are convex .",
    "that said , the bulk of our arguments will not make use of this geometric view of a triangulation . rather , it is convenient to reformulate the problem under consideration using the language of graphs . when viewing a finite element mesh as an undirected graph , we consider it as a pair @xmath16 with the vertices @xmath17 being the vertices of the mesh , and edges @xmath18 being the four ( @xmath3 ) or twelve ( @xmath4 ) edges of the cells . given the construction of this graph as a representation of a mesh , there is then a collection of cells @xmath8 where we can alternatively see each @xmath9 as either an ordered collection of 4 vertices or an ordered collection of 4 edges ( in 2d ; in 3d it is 8 vertices and 12 edges ) .",
    "the index @xmath7 on @xmath19 indicates that we are not considering general graphs but indeed only those graphs that originate from a triangulation of a domain @xmath20 .    for a given cell @xmath21 ,",
    "let @xmath22 be the set of its vertices and @xmath23 the set of its edges .",
    "for a given edge , let @xmath24 be the set of adjacent cells .",
    "in 2d , @xmath25 is either one or two ( depending on whether the edge is at the boundary or not ) ; in 3d , @xmath26 since arbitrarily many cells may be adjacent to a single edge .",
    "as discussed above , we are interested in assigning a direction to each edge in such a way that the direction of the edge is implied from the orientation of a cell . that is , for a mesh with associated graph @xmath19",
    ", we would like to have a directed graph @xmath27 with the same vertex set and edges , but where each edge is now considered directed ( i.e. , represented by an ordered pair of vertices ) . to be precise , this graph is in fact _ oriented _ since we never have both @xmath28 and @xmath29 as may occur in directed graphs .      as discussed in the introduction , practical implementations of the finite element method",
    "need to define a coordinate system on both cells and edges of a mesh .",
    "this is typically done by _ mapping _ a reference cell @xmath30^d$ ] and edge @xmath31 $ ] to each cell @xmath21 and edge @xmath32 , along with the coordinate systems .",
    "the details of this are of no importance here other than the following two statements : ( i ) on each cell , we need to designate one of the four ( or eight ) vertices as the `` origin '' ; each of the two ( three ) edges adjacent to the origin then form the first and second ( and third ) `` coordinate axis '' . if we insist that the mapping from the reference cell @xmath33 to @xmath21 has positive volume , then the choice of the origin fixes the coordinate system in 2d ; in 3d , each of the edges adjacent to the origin can be chosen as the first coordinate axis , with the other two then fixed . in other words , each cell allows for 4 possible choices of coordinate systems in 2d , and @xmath34 in 3d .",
    "( ii ) on each edge , we define a coordinate system by choosing a `` first '' vertex .    with this ,",
    "there are a total of @xmath35 choices in 2d for the coordinate systems on the cells ( and @xmath36 in 3d ) , and @xmath37 for the coordinate systems of the edges .",
    "the question is now whether it is possible to choose them in such a way that if the coordinate systems of all cells are specified , we can infer the coordinate system on each edge unambiguously , regardless of which cell adjacent to the edge we consider . or conversely : is it possible to specify directions for all edges in such a way that this implies a unique choice of coordinate systems for all cells ?    for reasons that will become clear later , we will prescribe directions of the edges of a cell when seen in the `` coordinate system '' of the cell as shown in fig .",
    "[ fig : convention ] . clearly , it will be possible to choose the coordinate systems of two neighboring cells in such a way that they do not agree on the direction of the common edge .",
    "such a choice would require an implementation to store for each cell whether or not an edge s ( global ) direction does or does not match the direction that results from the ( local ) convention .",
    "on the other hand , let us assume that we can find an orientation for all edges of the mesh so that in each cell , `` opposite '' edges are `` parallel '' .",
    "then each cell has one vertex from which all oriented edges originate , and we can choose this as the `` origin '' of the cell . using this choice of cell coordinate system , edge directions",
    "are then again uniquely implied and the problem is solved . in other words , we have reduced the problem of orienting all cells and edges to the problem of finding one particular set of edge orientations that satisfy the _",
    "`` opposite '' edges are `` parallel '' _ property .",
    "this property is easy to understand intuitively .",
    "it is significantly more cumbersome to describe it rigorously in the graph theoretical language , and so we will only do this for the 2d case .",
    "( the 3d case follows the same approach but requires lengthy notation despite the fact that the situation is relatively easy to understand . ) in order to formulate the convention , we need to fix the order in which we consider vertices and edges as part of a cell . we do so using a lexicographic order for vertices , as shown in fig .",
    "[ fig : vertex - edge - convention ] .",
    "edges are numbered so that we first number the edge from vertex 0 to 2 , then its translation in the perpendicular direction ( i.e. , from vertex 1 to 3 ) , and then the edges connecting the vertices of the first two edges . both of these orders reflect the tensor product structure of quadrilaterals and are easily generalized to hexahedra ( or higher dimensions , if desired ) . the choice of edge directions within each cell , as shown in fig .",
    "[ fig : convention ] , then ensures that the coordinate system of the edge is simply the restriction of the cell s coordinate system to the edge .",
    "is the ordered set of vertices that bound the cell , and @xmath38 the ordered set of edges . _",
    "_ ]    with this definition , each cell is described by an ordered tuple of its vertices where we will assume that the first element of this tuple corresponds to the `` origin '' .",
    "equivalently , we can describe each cell as an ordered tuple of four ( unordered ) edges , where the `` origin '' of the cell is now the common vertex of edges 0 and 2 .",
    "because there are 4 possible choices for the origin of the cell , there are four ways to describe a cell that are equivalent up to rotation .    with these preparations",
    ", we can finally define what it means for the edges of a directed graph @xmath39 that represents a quadrilateral mesh to be consistently oriented :    [ conv:1 ] we call a graph @xmath27 _ consistently oriented with respect to cell @xmath40 _ if among the four equivalent choices of vertex tuples of @xmath21 , there is one so that the following directed edges are all elements of @xmath41 : @xmath42 , @xmath43 , @xmath44 , @xmath45 .",
    "[ conv:2 ] we call a graph @xmath27 _ consistently oriented _ if it is consistently oriented with respect to all cells in @xmath7 .    as discussed above , a consistently oriented graph has edges that allow us to choose a coordinate system on each cell so that the edge orientations follow immediately from the cell orientations .",
    "similar definitions can be given for the 3d case .",
    "the purpose of this paper is to ask the question whether it is always possible to consistently orient the edges of a given mesh @xmath7 , and if this is the case , whether it can efficiently be done by an algorithm .",
    "the developments in the following sections all depend on the fact that convention  [ conv:1 ] can equivalently be stated by only looking at sets of `` parallel edges '' of quadrilaterals : .",
    "we can then view each edge of the graph as a ( not necessarily straight ) line connecting the adjacent vertices .",
    "each cell @xmath46 occupies a subset of @xmath47 that is the image of the reference square or cube @xmath48^d$ ] under a homeomorphic mapping @xmath49 .",
    "we can then call two edges @xmath50 parallel in @xmath21 if their preimages , @xmath51 and @xmath52 , i.e. , the corresponding edges of the reference cell , are parallel line segments in the geometric sense .",
    "this may be more intuitive , but we have no further use for mappings and transformations in this paper and will therefore not further explore the geometric setting . ]",
    "[ def : parallel ] two edges @xmath53 are called _ parallel edges of @xmath21 _ if @xmath54 or if they bound @xmath21 but do not share a vertex .",
    "if @xmath53 are parallel edges of @xmath21 , then we denote @xmath55 .",
    "we say that @xmath53 are _ locally parallel _ and denote @xmath56 if there exists a cell @xmath57 so that @xmath58 .",
    "the four edges of a quadrilateral then fall into two classes of two edges each that are parallel .",
    "( in 3d , a corresponding but more notationally cumbersome definition would yield three classes of four parallel edges each . ) in practice , one does not usually have to verify if edges are parallel , but only enumerate classes of parallel edges ; this does not require testing all equivalent edge sets : in 2d , edges @xmath59 and @xmath60 are parallel , as are @xmath61 and @xmath62 , for any arbitrarily chosen equivalent edge set .",
    "we can then define consistent orientations via these classes of parallel edges :    [ conv:3 ] two oriented , parallel edges @xmath63 are called _ consistently oriented with respect to cell @xmath21 _ if @xmath64 , @xmath65 with regard to the one equivalent vertex set within which @xmath66 and @xmath67 .",
    "[ conv:4 ] we call a graph @xmath27 _ consistently oriented with respect to cell @xmath21 _ if all sets of parallel edges of @xmath21 are consistently oriented with regard to @xmath21 .    in other words ,",
    "consistent orientation on a cell can be tested by only verifying consistent orientation of all the edges in all sets of parallel edges .",
    "consequently , _ testing _ that a graph @xmath39 is consistently oriented is relatively easy and can be done by verifying the condition on every cell separately .",
    "a verification algorithm can therefore easily be written with @xmath68 complexity and , consequently , with @xmath69 because @xmath70 .",
    "on the other hand , _ generating _ a consistent orientation requires a _ global _ algorithm because the orientation of one edge implies that of all of its parallel edges on all of its adjacent cells , which itself implies the orientation of edges parallel on cells twice removed , etc . because of this property , it is not a priori clear that one can find a linear - time algorithm that can find a consistently oriented graph @xmath39 given the graph @xmath19 associated with a mesh .",
    "however , as we will show below , this is indeed possible .",
    "as a final note in this section , let us state that for all algorithms that follow , we assume that we have methods to generate the vertex and edge sets @xmath71 for a given cell @xmath21 with @xmath72 complexity .",
    "this can easily be achieved by storing this information as the rows of @xmath73 matrices as is commonly done in all widely used software ( in 3d , the vertex adjacency matrix is of size @xmath74 and the edge adjacency matrix is of size @xmath75 ) .",
    "furthermore , we will assume that finding the cell neighbors of a given edge , @xmath76 , requires @xmath72 time .",
    "it is obvious that in 2d , this can be achieved by storing an @xmath77 matrix storing the indices of the one or two cells that are adjacent to each edge ; populating this matrix from @xmath78 requires only a single loop over all cells . in 3d ,",
    "the number of cells adjacent to each cell can in principle be equal to @xmath79 , requiring data structures that can either not be queried in @xmath72 complexity , or can not be built with @xmath80 complexity ; however , in actual finite element practice , the meshes we consider will never have more than , say , a dozen or so elements joined at any one edge , so that we can consider @xmath25 to be bounded by a constant , thereby allowing storing information in tables of fixed width and ensuring that @xmath76 can be queried with @xmath72 complexity .",
    "these assumptions will be important to guarantee the overall complexity of the algorithms we will consider in the following .    as stated above",
    ", we assume that @xmath76 can be _ evaluated _ in @xmath81 time . to make this possible requires _ building _ appropriate data structures , and depending on what information",
    "is available this may require more than @xmath82 time .",
    "for example , if one only knew the vertices of each cell , i.e. , @xmath83 , then building tables that can evaluate @xmath78 in @xmath72 time requires @xmath84 time ; this is the typical case with file formats that store mesh information . on the other hand",
    ", if each cell already knows all of its edge neighbors , as is often the case inside mesh generators or finite element codes , then building the tables to evaluate @xmath78 in @xmath72 only costs @xmath85 time and is consequently of the same complexity as the algorithms we will discuss in the following .",
    "in this section , we will consider the two - dimensional problem , which can be stated as follows : _ given a graph @xmath19 that originates from a mesh @xmath7 composed of quadrilaterals , find a consistently oriented graph @xmath39 .",
    "_    as mentioned above , consistency of edge directions only requires us to ensure consistency within sets of parallel edges . to this end",
    ", we will in the following describe methods that first find all edges that are , in some sense that goes beyond that defined in definition  [ def : parallel ] , parallel to each other ( section  [ sec:2d - parallel ] ) .",
    "we will then show how we can consistently orient all edges that are in this sense parallel to each other ( section  [ sec:2d - orienting - ribbon ] ) and finally how we can orient all edges in the graph ( section  [ sec:2d - orienting - graph ] ) .",
    "as we will show next , the set of edges @xmath86 of @xmath19 can be decomposed into a collection of mutually exclusive sets of edges , where the edges in each set are all parallel to each other in some global sense .",
    "this follows from the fact that the relation _ locally parallel _ is reflexive ( i.e. , @xmath87 for all edges @xmath32 ) and symmetric ( i.e. @xmath88 implies @xmath89 for all edges @xmath90 ) by construction .",
    "let us define two edges @xmath91 , @xmath92 to be globally parallel if there is a finite , possibly empty sequence of edges @xmath93 such that @xmath94 and denote this by @xmath95 .",
    "one immediately checks that this relation is reflexive , symmetric and transitive ( i.e. @xmath95 and @xmath96 imply @xmath97 for all edges @xmath98 ) and hence forms an equivalence relation . as the _ transitive hull _ of the relation @xmath99 .",
    "] this relation then partitions @xmath86 into disjoint sets of ( globally ) parallel edges ( * ? ? ?",
    "* chapter i ,  3 ) or ( * ? ? ?",
    "* corollary 28.19 ) .",
    "algorithmically , we can recursively construct each of these sets by starting with an edge @xmath32 and build the set @xmath100 of all edges that are globally parallel to @xmath32 by first adding the edges opposite @xmath32 in the cells adjacent to @xmath32 , then those edges that are opposite to the ones added previously , and so on .",
    "sets of parallel edges are central to the rest of the paper , since our edge direction convention requires that they will all have parallel directions .",
    "an intuitive interpretation of the importance of parallel edges is as follows : assume we had already found the directed graph @xmath39 .",
    "then , flipping the direction of an edge @xmath32 would make the triangulation non - consistent , and to make it consistent again we would have to flip the directions of a number of other edges as well ; the entire set of edges that needs to be flipped , including @xmath32 , is precisely @xmath101 .    with this knowledge ,",
    "let us concisely define an algorithm to find all elements of a parallel set for an edge @xmath32 as a first step :    [ alg : parallel - edges ] let @xmath102 be a given edge and generate the set @xmath103 of edges parallel to @xmath32 recursively as follows , where the set @xmath104 consists of those edges that we add to @xmath101 in each step as we grow it away from @xmath32 :    1 .",
    "set @xmath105 , @xmath106 , @xmath107 , @xmath108 .",
    "2 .   while @xmath109 , do : 1 .   set @xmath110 .",
    "2 .   for each @xmath111 : * set @xmath112 . * for each @xmath113 : 1 .   set @xmath114 .",
    "2 .   set @xmath115 . *",
    "set @xmath116 .",
    "3 .   @xmath117 .",
    "4 .   set @xmath118 .",
    "3 .   set @xmath119 .",
    "[ fig : parallel - sets ] gives a graphical depiction of the construction of one such set .",
    "starting from a given edge @xmath32 , the set @xmath103 grows in each step by at most the two edges in @xmath104 along a line that always intersects cells from one side to the opposite one , and connects these parallel edges .",
    "growth of the set in one direction stops whenever this line hits a boundary edge ( in which case the set of opposite edges for this boundary edge @xmath120 , @xmath121 , has only one member , which furthermore is already in @xmath122 ) , or if both ends of the line meet `` head - on '' ( in which case all elements of @xmath123 for all @xmath111 are already in @xmath122 and thus @xmath110 , upon which the iteration terminates ) .",
    ", @xmath124 , indicated by bold edges . the red line connects all of them and grows in both directions.__,title=\"fig : \" ] , @xmath124 , indicated by bold edges .",
    "the red line connects all of them and grows in both directions.__,title=\"fig : \" ] , @xmath124 , indicated by bold edges .",
    "the red line connects all of them and grows in both directions.__,title=\"fig : \" ] , @xmath124 , indicated by bold edges .",
    "the red line connects all of them and grows in both directions.__,title=\"fig : \" ]    to assess the overall run time of this algorithm , we note that in 2d , each edge has exactly two neighboring cells unless it is at the boundary , i.e. , @xmath125 .",
    "furthermore , within each cell , there is exactly one other parallel edge to a given edge @xmath120 , i.e. , @xmath126 .",
    "consequently , in step ( 2)(b ) we have @xmath127 and it follows that @xmath128 . with the appropriate data structures  for example , by representing sets of known maximal cardinality through fixed - sized arrays  , all operations in steps ( 2)(a)(d ) can then be executed in @xmath72 operations .",
    "furthermore , since @xmath129 grows by one or two elements per iteration , the loop represented by step ( 2 ) executes at most @xmath130 times .",
    "the total cost of the algorithm is therefore @xmath131 .",
    "the next step is based on the realization that every edge @xmath32 in the graph @xmath19 can be uniquely sorted into one of a collection of mutually exclusive sets @xmath132 .",
    "each class @xmath133 is constructed as above . because the connecting line for each parallel set is either closed or ends on both sides at the boundary , the number of distinct sets of parallel edges , @xmath134 , is at least half the number of boundary edges , but of course at most half the number of edges in @xmath19 .",
    "algorithmically , we can construct the collection @xmath135 of parallel sets in the following way :    [ alg : all - parallel - edges ] construct the set of parallel edge sets as follows :    1 .",
    "set @xmath136 .",
    "2 .   while @xmath137 , do : 1 .   choose any @xmath138 .",
    "2 .   compute @xmath139 using algorithm  [ alg : parallel - edges ] .",
    "3 .   set @xmath140 .",
    "4 .   set @xmath141 .    here , the set of not - yet - classified edges @xmath142 is reduced one equivalence class  i.e. , by one set of globally parallel edges  at a time .",
    "because the decomposition of edges into equivalence classes is unique , it is clear that in each iteration , @xmath143 .",
    "furthermore , @xmath144 and so @xmath145 ; thus , the iteration is guaranteed to terminate .",
    "more concretely , the cost of each iteration is given by algorithm  [ alg : parallel - edges ] , i.e. , @xmath146 .",
    "the overall cost is therefore @xmath147 . on the other hand , because edges can be uniquely sorted into their equivalence classes , we know that @xmath148 .",
    "thus , the cost of algorithm  [ alg : all - parallel - edges ] is @xmath149 , i.e. , of optimal complexity .",
    "our convention was only that opposite edges in a cell have parallel directions , but there was no requirement on the relative directions of adjacent ( non - opposite ) edges within a cell .",
    "in fact , that was the basis for restating conventions  [ conv:1 ] and [ conv:2 ] in terms of convention  [ conv:3 ] and [ conv:4 ] .",
    "it is thus easy to see that we only have to make sure that we have consistent directions of all edges within each set of parallel edges , and that consistency of edges within each such set is independent of the directions of edges in all other parallel sets .",
    "the following lemma proves that within each such equivalence class a consistent set of directions exists :    [ lemma : existence - for - one - parallel - set ] let @xmath102 .",
    "then there exists a choice of orientations for the elements of @xmath103 that is consistent ; i.e. , for all @xmath150 so that @xmath58 for some cell @xmath21 , then the orientations we associate with @xmath91 and @xmath92 are consistent in @xmath21 .",
    "this statement can be proven in a variety of ways , both constructively and in indirect ways .",
    "the most intuitive way uses the fact that a curve in the plane , closed or not and possibly self - intersecting , such as the dotted line in fig .",
    "[ fig : parallel - sets ] , allows for the definition of a unique direction `` from one side of the curve to the other '' , and we can then orient each edge it crosses according to this direction .",
    "this statement appears obvious on its face . for",
    "closed , non - intersecting curves , it follows from the jordan curve theorem that states that such curves partition the plane into an `` inside '' and `` outside '' area and we can then , for example , choose the direction from the inside to the outside to orient edges .",
    "proving the existence of such a direction field for self - intersecting curves requires more work .",
    "the history of the jordan curve theorem teaches us that care is necessary , and our variations on a proof typically required a page or more of geometry , even when taking into account that we only need to show the statement for the piecewise linear curves that connect edge midpoints .",
    "thus , rather than providing such a proof here , let us for now simply consider the lemma to be true .",
    "a proof will later follow from remark  [ remark : extension - manifold ] and a statement in the appendix where we show a more general statement of which lemma  [ lemma : existence - for - one - parallel - set ] is simply a special case .    given this statement of feasibility",
    ", we can now ask for an algorithm that assigns directions to all edges in a set @xmath103 and that can be implemented with @xmath151 complexity .",
    "we do so by extending algorithm  [ alg : parallel - edges ] to include edge orientation assignment :    [ alg : orient - edges ] let @xmath132 be given .",
    "then perform the following operations for each @xmath152 :    1 .",
    "assign an `` unassigned '' orientation to each edge @xmath153 .",
    "2 .   choose some @xmath153 and set @xmath154 .",
    "3 .   assign an arbitrary orientation to @xmath32 .",
    "4 .   set @xmath110 .",
    "5 .   while @xmath109 , do : 1 .   for each @xmath111 : * set @xmath112 . * for each @xmath113 : 1 .   set @xmath155 .",
    "2 .   assign an orientation to the elements of @xmath156 that is consistent in @xmath21 with that of @xmath120 .",
    "3 .   set @xmath115 . *",
    "set @xmath116 .",
    "2 .   @xmath117 .",
    "3 .   set @xmath118 .",
    "it is important to note that in step ( 5)(a)(ii ) , we assign directions only to the cell neighbors @xmath156 of @xmath120 , all of which either do not yet have an orientation , or that have already been assigned that very same orientation when coming `` from the other side of the parallel set '' in case the connecting line for this set is a closed line through our mesh .",
    "the step therefore never changes an already assigned orientation .",
    "the algorithm above would , in practice , simply be implemented as part of computing the parallel sets @xmath157 . in that case , it is nt even necessary to explicitly build @xmath129 in step ( 5)(b ) as this set is only used in the last part of step ( 5)(a ) where we could simply exclude all elements from @xmath123 that had previously already been assigned an orientation .      with these results",
    ", we can state the main result for the case @xmath3 :    [ theorem:2d ] for every planar , undirected graph @xmath19 generated by subdividing a bounded domain in @xmath158 into finitely many quadrilaterals , there exists a corresponding , consistently oriented directed graph @xmath39 .",
    "the proof follows from the preceding subsections : first , we can uniquely sort all edges into equivalence classes , for which we can choose edge directions independently ; second , we can find a consistent choice of edge directions within each such set .",
    "since both sorting edges into equivalence classes and assigning directions to edges of all equivalence classes are linear in the number of edges in the equivalence set , the overall algorithm is @xmath149 and therefore order optimal in the number of edges .",
    "furthermore , because each edge is shared by no more than two cells and because each cell is bounded by exactly four edges , it is obvious that @xmath159",
    ". it follows directly that the algorithm is not only linear in the number of edges , but also in the number of cells ( which is the more important estimate in practice ) . in 0.035 seconds on a current laptop  far faster than solving any equation on this mesh would take . ]",
    "[ remark : extension - manifold ] the arguments above showing that 2d meshes are always orientable can be carried over to meshes on two - dimensional , orientable surfaces , and we will prove so in the appendix .",
    "in particular , this holds for the practically important case of 2d meshes covering ( part of ) the surface of a 3d domain .",
    "indeed , this is true whether the domain is homeomorphic to the unit ball or not ",
    "i.e. , meshes on the surface of 3d domains with handles are still orientable .",
    "the proof of this more general statement then also covers lemma  [ lemma : existence - for - one - parallel - set ] : the lemma states the orientability of edges of a mesh in the plane @xmath158 , which is obviously an orientable , two - dimensional manifold .",
    "the proof of lemma  [ lemma : existence - for - one - parallel - set ] thus follows from the proof given in the appendix .    on the other hand ,",
    "meshes on non - orientable surfaces , for example on a mbius strip , are not necessarily orientable .",
    "this is because some of the connecting lines of parallel edges ( see fig .  [ fig : parallel - sets ] ) may wrap around the strip and return what we thought to be a vector from `` one side to the other side '' in its reverse orientation .",
    "it is therefore not possible to define a unique `` right '' and `` left '' of a curve on a non - orientable manifold , and not all sets of edges of a mesh defined on it may have a consistent orientation .",
    "[ rem : circular - edges ] as mentioned in a footnote to section  [ sec : introduction ] and fig .",
    "[ fig : convention ] , one can imagine other conventions for the relative orientations of edges and cell . for example , for triangles one often assumes a circular orientation .",
    "such a convention could also be adopted for quadrilaterals .",
    "however , it has two problems : ( i )  it is not obvious how to generalize it to hexahedra .",
    "( ii ) it is easy to construct meshes for which no set of globally consistent edge orientations can be found . to see this , note that a circular choice for edge directions in each cell implies that opposite edges have anti - parallel directions",
    "then imagine a closed string of @xmath160 cells .",
    "one of the sets of parallel edges then contains all of the @xmath160 edges that separate the @xmath160 cells forming a circle .",
    "the convention requires us to orient them alternatingly  something that is only possible if @xmath160 happens to be even .",
    "let us now also look at the case of three spatial dimensions , and a subdivision of the domain into hexahedral cells .",
    "the right panel of fig .",
    "[ fig : convention ] shows the convention for @xmath4 , where again we will want to have all parallel edges point in the same direction .",
    "note that now we have three sets of four edges within each cell .",
    "we will have to investigate both whether the algorithms discussed in the previous section always yield a consistent edge orientation , and what their complexity is given the changed circumstances .",
    "the first step is to construct the sets of parallel edges , @xmath135 .",
    "algorithm  [ alg : parallel - edges ] again finds all elements of an equivalence set @xmath103 for a given starting edge @xmath32 . instead of following a line intersecting opposite edges starting at @xmath32 in both directions , we now have to follow a sheet going through all four parallel edges of a hexahedron .",
    "it is easy to see that again there is a unique classification of all edges into equivalence sets of parallel edges .",
    "the second step was to assign a consistent orientation to the edges in a set of parallel edges .",
    "this was possible for @xmath3 since the line that connects all these edges is always orientable .",
    "however , that is not the case for the sheet connecting the edges in @xmath4 : it may not be orientable , and in this case we will not be able to find a consistent orientation for the edges in this equivalence class because we can no longer choose their directions to be from `` one side '' to the `` other side '' of the sheet .",
    "the following two sections show examples of meshes whose edges are not orientable according to our conventions .      .",
    "taking a string of cells ( top ) and bending them into a torus yields a graph for which a consistent orientation of edges exists ( center left ) .",
    "however , twisting the cells by @xmath161 before re - attaching ends fails to yield such a graph ( center right ) : the sheets connecting the radial and axial parallel edges form two intersecting , non - orientable mbius strips ( bottom).__,title=\"fig : \" ] + . taking a string of cells ( top ) and bending them into a torus yields a graph for which a consistent orientation of edges exists ( center left ) .",
    "however , twisting the cells by @xmath161 before re - attaching ends fails to yield such a graph ( center right ) : the sheets connecting the radial and axial parallel edges form two intersecting , non - orientable mbius strips ( bottom).__,title=\"fig : \" ] .",
    "taking a string of cells ( top ) and bending them into a torus yields a graph for which a consistent orientation of edges exists ( center left ) .",
    "however , twisting the cells by @xmath161 before re - attaching ends fails to yield such a graph ( center right ) : the sheets connecting the radial and axial parallel edges form two intersecting , non - orientable mbius strips ( bottom).__,title=\"fig : \" ] + . taking a string of cells ( top ) and bending them into a torus yields a graph for which a consistent orientation of edges exists ( center left ) .",
    "however , twisting the cells by @xmath161 before re - attaching ends fails to yield such a graph ( center right ) : the sheets connecting the radial and axial parallel edges form two intersecting , non - orientable mbius strips ( bottom).__,title=\"fig:\",scaledwidth=40.0% ] . taking a string of cells ( top ) and bending them into a torus yields a graph for which a consistent orientation of edges exists ( center left ) . however , twisting the cells by @xmath161 before re - attaching ends fails to yield such a graph ( center right ) : the sheets connecting the radial and axial parallel edges form two intersecting , non - orientable mbius strips ( bottom).__,title=\"fig:\",scaledwidth=40.0% ]    a first non - orientable example is shown in fig .",
    "[ fig : torus ] , demonstrating a subdivision of a toroidal domain for which no consistent edge orientation exists .",
    "if we take a string of cells ( top ) and bend it into a torus ( bottom left ) , then all edges can be grouped into one radial , one axial , and @xmath162 tangential classes ( the surfaces connecting the edges of the first two classes are shown in the bottom row of fig .  [",
    "fig : torus ] ) .",
    "one possible consistent orientation would be radially inward and axially into positive @xmath163-direction .",
    "the tangential edges can be oriented arbitrarily for each cell separately .",
    "however , such a consistent choice of direction for edges no longer exists if we twist the string of cells by @xmath161 before attaching ends ( bottom right ) . in that case",
    ", there must be at least one cell with radial edges that both point inward and outward , in violation of our convention .",
    "the same holds for a twist of @xmath164 , in which case the sheet connecting parallel edges has to circle the torus twice , before meeting itself in the wrong orientation again .",
    "the sheet that passes through parallel edges is , in these cases , a mbius strip with either a twist of @xmath161 or @xmath164 , and it is well known that this surface is not orientable .",
    "conjecturing from the first example that triangulations into hexahedra with no consistent orientation must have a hole or be multiply connected , is wrong , though .",
    "[ fig : rainers - example ] shows an example of 14 hexahedra subdividing a simply connected domain without holes for which no consistent orientation exists .",
    "the bottom row of the figure shows the top face of the seven lower hexahedra ( left ) and the bottom face of the upper seven ( right ) . only faces @xmath165 and @xmath166 match and are connected .     with a simply connected domain .",
    "top row : hexahedralization and one of the sheets passing through parallel edges .",
    "bottom row : top face of lower half of domain and bottom face of upper part of domain , both showing consistent directions of edges if one oriented the edge @xmath167 as shown .",
    "this leads to conflicting directions for @xmath168 , and the same happens if one had oriented @xmath167 in the opposite direction .",
    "note that the two parts shown are connected only on faces @xmath165 and @xmath166.__,title=\"fig : \" ]   with a simply connected domain .",
    "top row : hexahedralization and one of the sheets passing through parallel edges .",
    "bottom row : top face of lower half of domain and bottom face of upper part of domain , both showing consistent directions of edges if one oriented the edge @xmath167 as shown .",
    "this leads to conflicting directions for @xmath168 , and the same happens if one had oriented @xmath167 in the opposite direction .",
    "note that the two parts shown are connected only on faces @xmath165 and @xmath166.__,title=\"fig : \" ] +   with a simply connected domain .",
    "top row : hexahedralization and one of the sheets passing through parallel edges .",
    "bottom row : top face of lower half of domain and bottom face of upper part of domain , both showing consistent directions of edges if one oriented the edge @xmath167 as shown .",
    "this leads to conflicting directions for @xmath168 , and the same happens if one had oriented @xmath167 in the opposite direction .",
    "note that the two parts shown are connected only on faces @xmath165 and @xmath166.__,title=\"fig : \" ]   with a simply connected domain .",
    "top row : hexahedralization and one of the sheets passing through parallel edges .",
    "bottom row : top face of lower half of domain and bottom face of upper part of domain , both showing consistent directions of edges if one oriented the edge @xmath167 as shown .",
    "this leads to conflicting directions for @xmath168 , and the same happens if one had oriented @xmath167 in the opposite direction .",
    "note that the two parts shown are connected only on faces @xmath165 and @xmath166.__,title=\"fig : \" ]    let us consider the orientation of the radial edges of the lower left picture : starting , for example , at edge @xmath32 , then all radial edges must either point inward or outward due to the opposite edge rule .",
    "also , the direction of the other two edges of face @xmath165 is then fixed .",
    "one of the two possibilities for directions of these edges is shown in the bottom left part of fig .",
    "[ fig : rainers - example ] .",
    "independent of these two possible choices , we have the _ invariant _ that @xmath169 and @xmath170 are vertices to which both lines in @xmath165 either converge , or from which they emanate , and @xmath171 and @xmath172 are vertices into which one line enters and from which one line emerges .",
    "now let us consider the underside of the upper seven hexahedra , given by the lower right figure .",
    "it is connected to the lower part along faces @xmath165 and @xmath166 . by the same argument ,",
    "starting for example at edge @xmath91 , the directions of the radial edges and the other two edges of face @xmath165 are fixed .",
    "this time vertices @xmath171 and @xmath172 are the vertices from which both adjacent edges in @xmath165 emerge and into which they vanish , and @xmath169 and @xmath170 are the ones through which they pass , i.e.  the character of the vertices is changed . since in the joint domain vertices and edges of the upper- and undersides are identified , this creates a conflict : whatever direction we choose for edges @xmath32 and @xmath91 , no consistent edge orientation of the face @xmath165 is possible .",
    "this is easily understood by looking at the sheet that connects the set of parallel edges , @xmath173 , shown in the upper right part of the figure .",
    "it is a split , self - intersecting sheet that is not orientable .",
    "the examples in the previous subsection show that not all 3d meshes allow for a consistent edge orientation . in a sense",
    ", the complexity of our algorithm may therefore be a moot point : codes do necessarily have to store explicit edge orientation flags for each cell because the orientation of edges can no longer be inferred from the orientation of the cell .    on the other hand",
    ", it may still be of interest to orient edges consistently for those meshes for which this is possible , for example to ensure that the code paths for default edge orientation are always chosen .",
    "we may also be interested in seeing whether our algorithm can at least detect in optimal complexity whether a mesh is orientable .    to investigate these questions",
    ", we note that algorithms  [ alg : parallel - edges ] and [ alg : all - parallel - edges ] separating edges into the set @xmath135 of equivalence classes continue to work .",
    "algorithm  [ alg : parallel - edges ] determines the overall complexity . in 3d",
    ", we need to note that in step ( 2)(b)(i ) , @xmath174 , the set of edges parallel to @xmath120 in cell @xmath21 , now has cardinality 3 .",
    "furthermore , the loop in step ( 2)(b ) now iterates over all cell neighbors @xmath175 , of which in 3d there may in fact be up to @xmath162 .",
    "consequently , we can no longer bound @xmath176 by a constant independent of the number of edges or cells , and this then applies to the cost of the entire step ( 2)(b ) .",
    "this would not be a problem if we added at least a fixed fraction of the elements of @xmath123 to @xmath104 ( i.e. , if we could guarantee that @xmath177 ) , but we are not aware of any theoretical argument that this would be so .",
    "consequently , it is conceivable that there exist sequences of meshes for which @xmath178 but for which step ( 2)(c ) adds only a fixed number of elements to @xmath179 ( or at least a number that grows less quickly than @xmath180 ) .",
    "this would destroy the linear complexity of the overall algorithm .    from a practical perspective , however , this question is not terribly interesting as it requires meshes in which the number of cells adjacent to individual edges becomes very large . while the optimal number of cells adjacent to each edge would be four ( for example in a cubic lattice ) , practical meshes generated by mesh generators rarely have more than 8 or 10 such adjacent cells per edge , and this number is independent of the number of cells .",
    "consequently , for such meshes , @xmath181 and the algorithm is then again guaranteed to run with optimal complexity .",
    "we believe that it would also be possible to reformulate the algorithms in ways that allow for optimal complexity even for these pathological cases , though this is of no interest in the current paper .",
    "finally , we note that when a mesh is not orientable , step ( 5)(a)(ii ) of algorithm  [ alg : orient - edges ] will eventually try to assign a direction to an edge that already has an orientation that is inconsistent with the one that we want to assign to it ( a case that can not happen in 2d ) .",
    "thus , the algorithm will be able to detect non - orientable meshes with the same run time complexity as it can orient meshes .",
    "the fact that not all 3d meshes can be consistently oriented of course does not rule out that there may be important subclasses of 3d meshes that can in fact be oriented .",
    "indeed , we will show these statements in the following subsections :    1 .   refining a non - orientable mesh",
    "uniformly yields a mesh that is consistently orientable .",
    "three - dimensional meshes generated by extruding a two - dimensional mesh into a third direction are always orientable .",
    "hexahedral meshes that result from subdividing each tetrahedron of a tetrahedral mesh into hexahedra are always orientable .",
    "we will discuss these three cases in the following .",
    "if one is given a three - dimensional mesh with a sheet of parallel edges that are not consistently orientable , then it turns out that we can generate an orientable mesh by subdividing all the cells along this sheet .",
    "to understand this intuitively , remember that a non - orientable surface somehow connects to itself `` with a twist of @xmath161 '' .",
    "if we refine all the cells along its way , we duplicate this sheet and replace it by one that `` goes around twice before connecting to itself again '' .",
    "the twist is thus @xmath182 and the resulting sheet is orientable .",
    "this is illustrated in fig .",
    "[ fig : doubling ] for the two examples discussed in section  [ sec:3d - always ] .    .",
    "top right : the mesh one obtains by refining all edges along both of the non - orientable sheets in fig .",
    "[ fig : torus ] .",
    "this mesh is orientable .",
    "bottom : the same for the example shown in fig .",
    "[ fig : rainers - example].__,title=\"fig : \" ] .",
    "top right : the mesh one obtains by refining all edges along both of the non - orientable sheets in fig .",
    "[ fig : torus ] .",
    "this mesh is orientable .",
    "bottom : the same for the example shown in fig .",
    "[ fig : rainers - example].__,title=\"fig : \" ] +   + .",
    "top right : the mesh one obtains by refining all edges along both of the non - orientable sheets in fig .",
    "[ fig : torus ] .",
    "this mesh is orientable .",
    "bottom : the same for the example shown in fig .",
    "[ fig : rainers - example].__,title=\"fig : \" ]    to make this more formal , let us consider an equivalence class @xmath183 of parallel edges which is not consistently orientable . here",
    ", we use the index to indicate that this is a set of edges in the graph @xmath19 .",
    "now split each cell that the sheet associated with @xmath183 intersects , into 2 , 4 , or 8 new cells ( depending on whether the sheet intersects the cell once , twice , or three times , i.e. , whether one , two , or all three of the sets of parallel edges within this cell are part of @xmath183 ) .",
    "we subdivide in the directions orthogonal to the sheet , see figure  [ fig : refinement - cases ] .",
    "this removes the affected edges from the graph , and replaces them by 8 , 24 , or 54 new `` child '' edges . with this refined mesh",
    "is associated a new graph @xmath184 .",
    "then the following results hold :             [ lemma : refinement ] let @xmath185 be a set of parallel edges that are not consistently orientable , and @xmath186 , @xmath187 the sets of parallel edges in the refined graph @xmath184 associated with the `` children '' @xmath90 of @xmath32 . then @xmath188 .",
    "furthermore , @xmath189 is orientable .    by refining each cell with edges in @xmath185 along the non - orientable sheet ,",
    "we replace each edge @xmath190 by two edges @xmath191 .",
    "let us select an arbitrarily chosen element from @xmath185 , and denote it for simplicity by the symbol @xmath32 .",
    "its children , after refinement , @xmath90 are edges in the refined graph @xmath184 , and their respective sets of parallel edges are @xmath192 .",
    "it is easy to see that each of the two children @xmath193 of each edge @xmath194 must be in either @xmath186 or @xmath187 .",
    "we first show that these sets are equal .",
    "assume that @xmath195 . then we could find a unique direction for each edge @xmath194 by assigning it the direction `` from the @xmath186 side to the @xmath187 side . ''",
    "this , however , would be a consistent orientation of the edges in @xmath185 , in contradiction to the assumption that this set is non - orientable .",
    "thus , @xmath196 .",
    "intuitively , this means that splitting the single sheet associated with @xmath185 still yields a single sheet .",
    "the second step is to show that the single set @xmath197 is orientable .",
    "we do this purely locally : choose for the two children @xmath193 of an edge @xmath194 the direction away from their common node ( `` centrifugal direction '' : the direction vectors of the child edges are `` rooted '' in the original sheet through @xmath185 ) .",
    "this orientation of the children of @xmath185 is consistent with our convention for every one of the affected child cells , and , consequently , for all cells which the sheet for @xmath185 intersects .",
    "intuitively , this can be interpreted as follows : while the sheet has no associated normal direction , the direction `` away from the sheet '' exists on both sides .    as can be seen in fig .",
    "[ fig : refinement - cases ] , refinement of a cell along one sheet also adds new edges to other sets of parallel edges . depending on whether the sheet intersects a cell once , twice , or three times",
    ", refinement adds 4 , 5 , or no new edges to other parallel sets .",
    "however , we can show that refining the cells along one non - orientable sheet does not render a previously orientable , other sheet non - orientable :    [ lemma : other - sets ] let @xmath185 be a set of parallel edges that are refined to make it orientable .",
    "let @xmath198 be a set of parallel edges to which edges are added by this refinement step . then , if @xmath198 was orientable before the refinement step , then it is also after the refinement step .",
    "if the edges in @xmath198 were already orientable in @xmath19 , then they must have parallel directions in the cell shown in fig .",
    "[ fig : refinement - cases ] .",
    "if we assign the same , parallel direction to the newly added edges in @xmath184 that belong to this set of parallel edges in @xmath184 , then the resulting directions are consistent in the child cells as well .",
    "because the remainder of the cells intersected by @xmath198 are not affected , the locally consistent edge orientations in the child cells implies that @xmath186 remains orientable .    on the other hand ,",
    "if @xmath198 was not orientable , then this fact is unaltered by the addition of new edges .    with these lemmas",
    ", we can state the final result of this section :    let @xmath19 be the graph associated with a subdivision of a domain into hexahedra .",
    "if it is not orientable , then we can generate a new graph @xmath184 by refining all cells exactly once along the sheets associated with those sets of parallel edges that are not orientable .",
    "the theorem follows from the previous two lemmas .",
    "as was shown in lemma  [ lemma : refinement ] , we can convert a non - orientable set of parallel edges into an orientable one . in lemma  [ lemma : other - sets ] , we showed that this does not create new non - orientable sets .",
    "since the original graph can only have finitely many non - orientable sets of parallel edges , we decrease this number by one in each refinement step and thus obtain an orientable graph in a finite number of steps .",
    "thus , even though there are three - dimensional meshes that can not be oriented according to our convention , above theorem shows that there is a simple and inexpensive remedy for these cases .",
    "while the meshes resulting from such anisotropic refinement have a worse aspect ratio , one can simply refine _ all _ hexahedra uniformly into eight children to obtain an orientable mesh with the same aspect ratio of cells as the original one .",
    "this corresponds to refining the cells intersected by _ all _ sheets associated with sets of parallel edges , not only those corresponding to non - orientable ones .",
    "obviously , this mesh is also orientable : in addition to the originally non - orientable parallel sets , we now also refine the originally orientable parallel sets , which yields two distinct sets of parallel edges @xmath186 and @xmath187 that can independently be oriented , one on `` this '' side of the original sheet and one on `` that '' side of it ( these sides are distinct because the sheet associated with @xmath185 was orientable ) .",
    "the observations of this section also point out an important optimization in practice for codes that create finer meshes by subdividing the cells of an existing mesh . in such cases , it is not necessary to re - run the mesh orientation algorithm on the finer mesh with four ( 2d ) or eight ( 3d ) times as many cells . rather ,",
    "if the original mesh was already consistently oriented , then the new mesh will be consistently oriented by simply choosing the directions of the refined edges to be the same as those of their parent edge .",
    "an important class of meshes consists of those that start with a two - dimensional quadrilateral mesh and then `` extrude '' it into a third direction by replicating it one or more times and connecting the vertices of the original mesh and its replicas in this third direction . indeed , the mesh shown at the top of fig .",
    "[ fig : torus ] is such a mesh : the sequence of quadrilaterals at the bottom has been replicated to the top , and each pair of original and replicated vertices are connected by a new edge .",
    "extruded meshes are often used for `` thin '' domains .",
    "the technique is obviously also applicable if the original two - dimensional mesh lived on an ( orientable ) manifold such as the bottom surface of the object we want to mesh .",
    "the extrusion also need not necessarily be in a perpendicular direction , nor do the replicas have to be parallel to the original mesh .",
    "that said , for the purposes of orienting edges , such geometric considerations are immaterial .    for extruded meshes , we can state the following result :    [ theorem : extruded - always ] let @xmath199 be a hexahedral mesh obtained by extruding a quadrilateral mesh defined on a two - dimensional , orientable manifold in a third direction",
    ". then the edges of this mesh are consistently orientable .    to understand why this is the case , recall that _",
    "all _ two - dimensional quadrilateral meshes on such manifolds are orientable .",
    "in other words , in the original mesh , opposite edges can already be chosen to be parallel , and this is also the case for its replicas .",
    "next , consider the sets of parallel edges we may consider . obviously , the edges of the original mesh and its replicas are parallel , and we can consistently orient them if we choose edge directions of the original mesh and its replicas the same .",
    "an alternative viewpoint is that the sheets that connects these sets of parallel edges are the `` extruded '' version of the line that connected these parallel edges in the two - dimensional mesh , and the orientability of the one - dimensional line then extends to the orientability of the corresponding sheet to which it gives rise .",
    "the only additional sets of parallel edges are the ones that connect the original mesh and its first replica , and then each replica with the next .",
    "the corresponding sheets can be thought of as copies of the two - dimensional domain spanned by the original mesh , located halfway between the replicas .",
    "each of these sheets is obviously orientable : the edges of each of these new sets are independent of each other , and each class can be consistently oriented , for example by always choosing the direction from the original to the first replica , and from each replica to the next ( i.e. , an `` upward '' direction ) .",
    "the examples in section  [ sec:3d - always ] show that there is no _ topological _ characterization of those domains for which we can always find a consistent orientation of edges .",
    "rather , it is a question of _ how _ that domain was subdivided into cells .",
    "indeed , we can show that for the very general class of domains that can be subdivided into tetrahedra , there also exists a subdivision into hexahedra with a consistent orientation of edges :    [ theorem : tet - to - hex ] let @xmath200 be a given subdivision of a domain @xmath2 into a set of tetrahedra so that two distinct tetrahedra either have no intersection , share a common vertex , a complete edge , or a complete face .",
    "divide each tetrahedron @xmath201 into four hexahedra , @xmath202 , by using the vertices , edge midpoints , face midpoints , and cell midpoint of @xmath201 as vertices for the hexahedra .",
    "then the edges of the mesh consisting of the union of these hexahedra , @xmath203 , are consistently orientable .",
    "before we prove this claim , we note that the resulting hexahedra are in almost all cases not close to the optimal cube shape .",
    "also , almost all vertices in the resulting mesh have a number of cells meeting at this vertex that deviates from the optimal number of eight ( encountered , for example , in a regular subdivision into cubes ) .",
    "these meshes are therefore hardly optimal for finite element computations .",
    "however , given the complexity of generating hexahedral meshes , until recently many mesh generators used this approach to generate an initial hexahedral mesh .",
    "( for example , the widely used open source mesh generator gmsh @xcite can use this approach to generate hexahedral meshes . )     for the proof of theorem  [ theorem : tet - to - hex ] .",
    "top : part of a subdivision into triangles before and after cutting each triangle into three quadrilaterals ( top row ) .",
    "bottom : three sets of parallel edges and their connecting line ( bottom row).__,title=\"fig : \" ]   for the proof of theorem  [ theorem : tet - to - hex ] .",
    "top : part of a subdivision into triangles before and after cutting each triangle into three quadrilaterals ( top row ) .",
    "bottom : three sets of parallel edges and their connecting line ( bottom row).__,title=\"fig : \" ] +   for the proof of theorem  [ theorem : tet - to - hex ] .",
    "top : part of a subdivision into triangles before and after cutting each triangle into three quadrilaterals ( top row ) .",
    "bottom : three sets of parallel edges and their connecting line ( bottom row).__,title=\"fig : \" ]   for the proof of theorem  [ theorem : tet - to - hex ] .",
    "top : part of a subdivision into triangles before and after cutting each triangle into three quadrilaterals ( top row ) .",
    "bottom : three sets of parallel edges and their connecting line ( bottom row).__,title=\"fig : \" ]   for the proof of theorem  [ theorem : tet - to - hex ] .",
    "top : part of a subdivision into triangles before and after cutting each triangle into three quadrilaterals ( top row ) .",
    "bottom : three sets of parallel edges and their connecting line ( bottom row).__,title=\"fig : \" ]    in order to explain the proof in @xmath4 , it is instructive to first consider a similar case in @xmath3 , where we would cut all cells of a triangular mesh into three quadrilaterals , see fig .",
    "[ fig : theorem-2 - 2d ] . from the edges of these quadrilaterals",
    ", we then generate independent sets of parallel edges ; the bottom row of the figure shows three of these sets along with their connecting line .",
    "importantly , each of these lines forms a closed , non - self - intersecting loop around one of the original vertices of the triangles , cutting through all the cells in the second layer of quadrilaterals around this vertex ( unless , of course , the vertex is at the boundary of the domain , in which case the line is not closed but starts and ends at the boundary ) . indeed , the edges of each quadrilateral are part of the loops for two vertices of the triangle from which it arose .",
    "each vertex thus gives rise to at least one set of parallel edges in the subdivision into quadrilaterals .",
    "these can , of course , all be oriented in @xmath3 .",
    "( it may give rise to more than one such set if two parts of the domain touch at a vertex , i.e. , if there are two sets of cells adjacent to a vertex that are not mutual face neighbors . )    it is easy to generalize these considerations to the case @xmath4 ( though we have not found good ways to visualize hexahedral meshes resulting from even a small collection of tetrahedra forming an unstructured mesh ) .",
    "first , we note that each original interior vertex now induces a set of parallel edges that is connected by a closed non - self - intersecting sheet around the vertex .",
    "since it is homeomorphic to the surface of the unit sphere , it is of course orientable , and so are the edges of this parallel set . for original vertices on the boundary , the sheet is not closed , but it is obviously still orientable .",
    "in 3d , one not only has the problem of aligning the coordinate system of one - dimensional edges with that of cells , but a similar problem also appears with the coordinate system of two - dimensional faces to which one would like to associate data ( such as degrees of freedom or their numeric values ) .",
    "this then raises similar questions as in the edge case : can we assign an orientation  in the simplest case a normal vector  to each face that can uniquely be determined from each of the adjacent cells simply from its position within this cell ?",
    "the answer to this first question is an unconditional `` yes '' , by a similar argument as the one we used for edge directions in 2d . here , we first have to collect the set of parallel _ faces _ , denoted by @xmath204 , of a particular face @xmath205 .",
    "these faces are constructed by always hopping from one face to the one opposite of it in a cell , so we can draw a line through all of them .",
    "the second step is to give all of them a certain direction . in 2d",
    ", we used that each line is orientable , so we could use the direction pointing from one side of the line to the other as the direction for the edges it intersects . here , we simply use the `` forward '' ( or `` backward '' ) direction as we move along the line connecting the faces in @xmath204 , to provide each face with a normal direction that matches that of all parallel faces within its two adjacent cells . by construction , this line can not split , so even if it is a closed or self - intersecting line , we can always define such a direction ; thus there is a consistent orientation of all faces in @xmath204 for all subdivisions of domains into hexahedra , and an algorithm is easily derived that does this in a time linear in the number of faces or cells .    in reality ,",
    "however , the orientation of the face s coordinate system is not only described by a single bit such as whether its normal vector points into or out of a cell .",
    "rather , the coordinate system of the face may also be rotated by @xmath206 , or @xmath207 against the coordinate system of the cell when restricted to that face .",
    "an alternative way of describing these four rotations is to state the vertex at which the coordinate system originates .",
    "defining properties such as these does not naturally fit into the graph theoretical context we have so far used , and we will therefore use some concepts of discrete geometry in the following .    to concisely define",
    "what properties we would like to have in the finite element context , let us introduce two definitions that assume that a mesh is given by a collection of vertices @xmath208 , linear edges @xmath86 , quadrilateral faces @xmath209 , and hexahedral cells @xmath210 ( where obviously each of faces bound one or two cells , and each edge bounds at least one face ) .",
    "we then want to associate with each cell @xmath211 a right handed coordinate system and denote @xmath212 , and similarly for faces and edges which we will then denote @xmath213 and @xmath214 for @xmath215 . for each edge",
    ", there are two possible ways of defining @xmath214 , namely the two edge orientations . for each face @xmath205",
    ", the previous paragraphs have shown that there are 8 possibilities to define @xmath213 .",
    "one can easily verify that for each cell @xmath21 , there are 24 possible @xmath212 .",
    "one can then define consistent orientations as follows :    an oriented cell @xmath212 and its bounding faces @xmath216 and bounding edges @xmath217 are called _ consistently edge and face oriented _ if the coordinate systems defined on the edges and faces bounding @xmath21 are simply the restrictions of the cell s coordinate system to the edge or face .",
    "-axis and an open arrow the local @xmath218 axis .",
    "the coordinate system of the cell is shown in red to the left , with the local @xmath163 axis using an open box as arrow .",
    "the cell would also be consistently edge oriented if edges were oriented as shown in the right panel of fig .",
    "[ fig : convention ] .",
    "center : a cell that could still be consistently edge oriented but is not consistently face oriented because the right face has an inverted coordinate system .",
    "right : a cell where the right face s coordinate system has its origin at the wrong location .",
    "for this cell , edge orientations can not be chosen in such a way that they would be consistent with both the top and right face , for example.__,title=\"fig : \" ] -axis and an open arrow the local @xmath218 axis .",
    "the coordinate system of the cell is shown in red to the left , with the local @xmath163 axis using an open box as arrow .",
    "the cell would also be consistently edge oriented if edges were oriented as shown in the right panel of fig .",
    "[ fig : convention ] .",
    "center : a cell that could still be consistently edge oriented but is not consistently face oriented because the right face has an inverted coordinate system .",
    "right : a cell where the right face s coordinate system has its origin at the wrong location .",
    "for this cell , edge orientations can not be chosen in such a way that they would be consistent with both the top and right face , for example.__,title=\"fig : \" ] -axis and an open arrow the local @xmath218 axis .",
    "the coordinate system of the cell is shown in red to the left , with the local @xmath163 axis using an open box as arrow .",
    "the cell would also be consistently edge oriented if edges were oriented as shown in the right panel of fig .",
    "[ fig : convention ] .",
    "center : a cell that could still be consistently edge oriented but is not consistently face oriented because the right face has an inverted coordinate system .",
    "right : a cell where the right face s coordinate system has its origin at the wrong location .",
    "for this cell , edge orientations can not be chosen in such a way that they would be consistent with both the top and right face , for example.__,title=\"fig : \" ]    an example of a consistently oriented cell , and two cells that are not consistently oriented are shown in fig .",
    "[ fig:3d - face - edge - orientations ] .",
    "note that for a consistently edge and face oriented cell , the coordinate systems defined on the edges are naturally not only the restrictions of the cell coordinate systems to this edge , but also the restrictions of the face coordinate systems to this edge .",
    "this convention is a natural generalization of the two - dimensional edge orientations we have used in section  [ sec:2d ] .",
    "there , we only considered the coordinate systems on the edge ( described by the edge orientation ) and did not mention a coordinate system on cells , but it is easy to see that we can choose a unique right - handed coordinate system originating at the one vertex with two outgoing edges , as long as opposite edges are parallel . given this local consistency , we can define globally consistently oriented meshes :    a mesh with associated coordinate systems , @xmath219 , is called _ consistently edge and face oriented _ if each cell and its bounding faces and edges are consistently oriented .    clearly , this is a stronger condition than just the edge orientations considered in section  [ sec:3d ] and every mesh that is consistently edge and face oriented is also consistently edge oriented following definition  [ conv:2 ] ( as well as consistently face oriented , using the definition earlier in this section ) .",
    "it is therefore clear that at least those meshes that can not be consistently edge oriented can also not be consistently edge and face oriented . on the other hand ,",
    "we have shown in section  [ sec:3d - always - orientable ] that important classes of meshes are always edge orientable , and one may hope that these are in fact also face orientable .    unfortunately , this turns out to be not true , even for the otherwise relatively well - behaved class of extruded meshes for which we showed in section  [ sec:3d - extrude ] that their edges can always be oriented .",
    "this can be shown for a simple counter - example involving only three cells and that is shown in fig .",
    "[ fig:3d - face - edge - counter ] .",
    "* actually , this appears to require more thought .",
    "i m no longer clear on what is intended or implemented , and they may be different . *",
    "this example shows that there are simple examples of meshes that can not be consistently edge and face oriented at the same time .",
    "it is conceivable that there is a simple characterization for which meshes consistent orientations can be found , in the same way as we showed in section  [ sec:3d ] that meshes can be consistently oriented if no set of parallel edges is connected by a non - orientable surface .",
    "we have not attempted to find such a characterization here since the counterexample showed that the subset of consistently edge and face orientable meshes is too small for practical purposes .",
    "finite element codes can be made significantly simpler if they can make assumptions about the relative orientations of coordinate systems defined on cells , edges , and faces .",
    "if such assumptions always hold , then this reduces the number of cases one has to implement and , consequently , the potential for bugs . in this paper",
    ", we have described a way to orient edges and the cells they bound , and shown that not only is it possible to choose edge directions consistently with regard to this convention for two - dimensional quadrilateral meshes , but also that there is an efficient algorithm to find such edge orientations .    on the other hand , it is not always possible to orient edges of three - dimensional hexahedral meshes according to the three dimensional generalization of this convention .",
    "the obvious generalization of our two - dimensional algorithm is able to detect these cases , again in optimal complexity , but the result implies that codes dealing with hexahedral meshes necessarily have to store flags for each of the edges of each cell that indicate the orientation of that edge relative to the coordinate system of the cell .",
    "this is not a significant overhead in terms of memory and possibly not in terms of algorithmic complexity . nevertheless , in actual practice",
    ", this has turned out to be an endless source of frustration and bugs in deal.ii as the cases where edge orientations are relevant are restricted to the use of higher order elements , as well as complex and three - dimensional geometries . in case of bugs , methods generally converge but at suboptimal orders .",
    "consequently , debugging such cases and detecting where in the interplay of geometry , mappings , degrees of freedoms , shape functions , and quadrature the bug resides has proven to be a very significant challenge .",
    "this experience also supports our claim that being able to enforce a convention in the two - dimensional case almost certainly saved a great deal of development time .    at the same time , this paper at least identifies broad classes of three - dimensional meshes for which one can always consistently orient edges , and for which no special treatment of edges is necessary . through counter - examples , we have shown that there is no topological description for which domains do or do not allow for consistent orientations , but that it is indeed a property of how the domain is subdivided into cells , and our analysis demonstrates ways by which meshes can be constructed in ways so that edges can always be oriented consistently .",
    "this analysis can therefore also provide constructive feedback for the design of mesh generation algorithms .    in an ideal world",
    ", finite element codes would use meshes for which not only edges but also faces are consistently orientable . as shown in section",
    "[ sec:3d - faces ] , this turns out to be a much more restrictive condition , and a simple counterexample demonstrates that we can not hope for such a property for meshes that arise in realistic situations .",
    "[ [ acknowledgments ] ] acknowledgments + + + + + + + + + + + + + + +    wb would like to thank j.  m.  landsberg , j .- l .",
    "guermond , and a.  ern for illuminating discussions .",
    "lemma  [ lemma : existence - for - one - parallel - set ] provided the basis for the proof that we can find consistent orientations of the edges for all meshes that subdivide a domain @xmath220 into quadrilaterals . fundamentally , the reason for its truth is the geometric fact that the piecewise linear curve connecting a set of parallel edges has a unique `` left '' and `` right '' side .    as mentioned in remark  [",
    "remark : extension - manifold ] , this can be generalized to the connecting lines on orientable , two - dimensional manifolds .",
    "geometric proofs for this extension are complicated by two facts : ( i ) the underlying manifold may not be smooth , for example in the case of a mesh on the surface of a body with edges and corners ( such as a cube ) ; ( ii ) we need to be careful how exactly we embed the curve connecting parallel edges into the manifold .",
    "consequently , it is easier to avoid the language of geometry altogether .",
    "rather , we will use the language of combinatorial topology that in its essence only uses what we are given : the quadrilateral mesh .    in the statement of the following result",
    ", we will use the combinatorial topology definition of what an `` orientable '' manifolds is ( see @xcite and below ) .",
    "this class of manifolds includes all smooth two - dimensional manifolds that are orientable in the differential geometry sense @xcite , but also ( parts of ) the boundaries of domains in @xmath221 ( * ? ? ?",
    "* chapter vi , theorem 7.15 ) .",
    "furthermore , the manifolds we can consider need not be naturally embedded in @xmath221 . a special case of an orientable , two - dimensional manifold is of course the plane @xmath158 , covering the situation of lemma  [ lemma : existence - for - one - parallel - set ] .",
    "then the following is true :    let @xmath7 be a quadrilateral mesh with finitely many cells on an arbitrary , two - dimensional , orientable manifold , and @xmath19 the associated graph . then there exists a corresponding directed graph @xmath39 that is consistently oriented .",
    "the proof is in essence analogous to that of theorem  [ theorem:2d ] .",
    "the only piece that has changed is that we need to provide for the orientability of edges in each of the parallel sets , i.e. , the extension of lemma  [ lemma : existence - for - one - parallel - set ] to orientable , two - dimensional manifolds .    to this end , let us construct a subdivision @xmath222 of @xmath7 into 2-simplices ( triangles ) by adding to each quadrilateral one of the two diagonals .",
    "@xmath222 is then a simplicial 2-complex .",
    "a 2-complex is called coherently oriented if ( i )  the edges of each 2-simplex are either oriented clockwise or counterclockwise , and ( ii )  whenever two 2-simplices share a common edge , the relative orientations of this shared edge are complementary ( i.e. , opposing ) , see for example ( * ? ? ?",
    "* chapter 5 ) .",
    "a 2-manifold is called orientable if every 2-complex on it can be coherently oriented .",
    "thus , since @xmath222 is a 2-complex on a surface for which we have previously assumed that it is orientable , we may choose a coherent orientation of all edges of @xmath222 .",
    "given the subdivision of each cell @xmath40 into two triangles with edges oriented either clockwise or counterclockwise , this induces an orientation on @xmath7 where ( i ) opposite edges in each cell @xmath21 are oriented complementarily , and ( ii ) shared edges of two adjacent cells are oriented complementarily .",
    "one quickly checks that this is independent of the choice of diagonals .",
    "we have previously seen that each edge @xmath32 is part of at most two cells and has therefore at most two opposite edges . for each set of parallel edges , @xmath223",
    ", there is then a sequence of cells connected by the edges @xmath157 that is either open or that forms a closed loop .",
    "this is illustrated in fig .",
    "[ fig : algebraic - topology ] .",
    "( cells may occur more than once in this sequence , but only once for each pair of opposite edges in this cell . )    .",
    "center right : because the mesh exists on a 2-manifold that is orientable , it is possible to assign clockwise and counter - clockwise orientations to all triangles so that they imply complementary directions for each shared edge .",
    "right : choosing every other direction for edges between cells , as we walk along the sequence of cells , yields a set of consistent edge orientations , i.e. , opposite edges in quadrilaterals are oriented in a parallel direction.__,title=\"fig:\",scaledwidth=28.0% ] .",
    "center right : because the mesh exists on a 2-manifold that is orientable , it is possible to assign clockwise and counter - clockwise orientations to all triangles so that they imply complementary directions for each shared edge .",
    "right : choosing every other direction for edges between cells , as we walk along the sequence of cells , yields a set of consistent edge orientations , i.e. , opposite edges in quadrilaterals are oriented in a parallel direction.__,title=\"fig:\",scaledwidth=28.0% ] .",
    "center right : because the mesh exists on a 2-manifold that is orientable , it is possible to assign clockwise and counter - clockwise orientations to all triangles so that they imply complementary directions for each shared edge .",
    "right : choosing every other direction for edges between cells , as we walk along the sequence of cells , yields a set of consistent edge orientations , i.e. , opposite edges in quadrilaterals are oriented in a parallel direction.__,title=\"fig:\",scaledwidth=28.0% ] .",
    "center right : because the mesh exists on a 2-manifold that is orientable , it is possible to assign clockwise and counter - clockwise orientations to all triangles so that they imply complementary directions for each shared edge .",
    "right : choosing every other direction for edges between cells , as we walk along the sequence of cells , yields a set of consistent edge orientations , i.e. , opposite edges in quadrilaterals are oriented in a parallel direction.__,title=\"fig:\",scaledwidth=28.0% ]    now let us choose an edge @xmath224 , and let @xmath21 be one ( of possibly two ) neighboring cell of @xmath32 . if the sequence of cells connected by @xmath157 is open , then assign to @xmath32 the direction of this edge as defined in @xmath21 .",
    "the edge @xmath91 opposite of @xmath32 in @xmath21 is then assigned the direction defined in the neighbor of @xmath21 beyond @xmath91 , and so forth in both directions starting at @xmath32 .",
    "it is easy to see that this leads to a consistently oriented set of edges in the sense discussed in section  [ sec:2d ] .",
    "if the sequence of cells connected by @xmath157 is closed , we need to ensure that this does not lead to a conflict .",
    "if we follow the sequence of cells , the previous construction chooses every second encountered edge orientation ; because each orientation is complementary to the previous , choosing every other one leads to a consistent set of edge orientations .",
    "p.  bastian , m.  blatt , a.  dedner , c.  engwer , r.  klfkorn , r.  kornhuber , m.  ohlberger , and o.  sander . a generic grid interface for parallel and adaptive scientific computing .",
    "part ii : implementation and tests in dune .",
    ", 82:121138 , 2008 .        c.  d. cantwell , d.  moxey , a.  comerford , a.  bolis , g.  rocco , g.  mengaldo , d.  d. grazia , s.  yakovlev , j .- e .",
    "lombard , d.  ekelschot , b.  jordi , h.  xu , y.  mohamied , c.  eskilsson , b.  nelson , p.  vos , c.  biotto , r.  m. kirby , and s.  j. sherwin .",
    "nektar++ : an open - source spectral / hp element framework .",
    ", 192:205219 , 2015 ."
  ],
  "abstract_text": [
    "<S> finite element codes typically use data structures that represent unstructured meshes as collections of cells , faces , and edges , each of which require associated coordinate systems . </S>",
    "<S> one then needs to store how the coordinate system of each edge relates to that of neighboring cells . on the other hand </S>",
    "<S> , we can simplify data structures and algorithms if we can a priori orient coordinate systems in such a way that the coordinate systems on the edges follow uniquely from those on the cells _ by rule_.    </S>",
    "<S> such rules require that _ every _ unstructured mesh allows the assignment of directions to edges that satisfy the convention in adjacent cells . </S>",
    "<S> we show that the convention chosen for unstructured quadrilateral meshes in the deal.ii library always allows to orient meshes . </S>",
    "<S> it can therefore be used to make codes simpler , faster , and less bug prone . </S>",
    "<S> we present an algorithm that orients meshes in @xmath0 operations . </S>",
    "<S> we then show that consistent orientations are not always possible for 3d hexahedral meshes . </S>",
    "<S> thus , cells generally need to store the direction of adjacent edges , but our approach also allows the characterization of cases where this is not necessary . the 3d extension of our algorithm either orients edges consistently , or aborts , both within @xmath0 steps . </S>"
  ]
}