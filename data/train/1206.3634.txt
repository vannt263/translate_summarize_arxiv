{
  "article_text": [
    "a ( storage cloud ) is a collection of vms ( represented by consumers in our model in section [ sec : problem - definition ] ) and data - centers ( producers ) that interact with each other through network links with different bandwidths / data - transfer rates ( inversely proportional to the edge weights ) .",
    "vms generate requests for virtual disk space ( requests ) at the time of creation .",
    "the data - centers have limited storage space ( capacity ) .",
    "one of the core problems is to optimally select a data - center for allocating the disk space for a vm .",
    "if we assume that all data - centers are available for the requests generated by each vm then this configuration forms a complete bipartite graph . as the vm users are added gradually to the cloud and their disk - space requirements need to be satisfied instantly to meet the slas this forms the online part of the problem .",
    "we assumes that once a vm is allocated storage space on a particular data - center it can not be moved to a different one , thus vms read / write data using the same network links ( fixed at the time of vm provisioning ) throughout their lifetime .",
    "the overall i / o performance of the cloud storage system can be optimized when the quality of network links used for the majority of read / write operations is maximized which , can be acheived by using the higher quality ( inversely proportional to edge weights ) links for allocating as much producer requests as possible .",
    "this is equivalent to minimizing the the distance weighted sum of request allocated in the system .",
    "this theoretical model can be used to measure the performace of distributed storage provisionig schemes such as vmware s virtualization framework - vsphere @xcite .",
    "in the offline model @xmath4 the requests sizes @xmath5 , capacities @xmath6 and edge weights @xmath7 are arbitrary .",
    "* a complete ( undirected ) bipartite graph @xmath8 . *",
    "set @xmath9\\}$ ] of producers , @xmath10 . set @xmath11\\}$ ] of consumers , @xmath12 , with arbitrary capacity  @xmath13 .",
    "the capacity is a strict bound for the consumer s load and can not be exceeded . *",
    "set of edges @xmath14 , j \\in [ n]\\}$ ] connect each producer to each consumer and with @xmath7 which denote the distance between producer @xmath15 and @xmath6 .",
    "* @xmath16 is the total number of requests .",
    "the requests are produced by the producers and allocated to the consumers .",
    "a request can be split and allocated to different producers .",
    "s(t ) is the size of the request produced at time t. * producers are selected at random in each round .",
    "* @xmath17 is the distance between the producer and consumer that are chosen in time step @xmath18 .",
    "the total cost of the random allocation is @xmath19 .",
    "* we assume that every request can commit to at least one consumer ( regardless of the previous allocation ) , i.  e. at least one consumer must have sufficient space left . the number and size of requests must be limited accordingly .",
    "* @xmath20 is the load on consumer @xmath6 .",
    "all loads @xmath21 are set to @xmath22 in the beginning .",
    "whenever a consumer receives a request , its load is increased by the size of the request .",
    "* @xmath23 is the total request from producer @xmath15 allocated to consumer @xmath24 known as the edge load .",
    "all loads @xmath25 are set to @xmath22 in the beginning . whenever a consumer receives a request from a producer the corresponding edge load is increased by the size of the request .",
    "the objective of this problem is to find an average - case @xcite @xmath26-competitive online algorithm ( assuming startup cost @xmath27 ) , that minimizes the expected value of weighted sum of edge loads while satisfying the producer requests :    @xmath28 , j \\in [ n ] } e_i\\bigg [ d_{i , j}(t )   \\cdot   l_{i , j}(t ) \\bigg ] \\le \\alpha \\cdot   opt_i(t ) , \\forall ( t , i ) \\label{operation 5}\\ ] ]    where , @xmath26 is a constant and @xmath29 is the output of the optimal offline algorithm for the input received in the time interval @xmath30 $ ] for an instance i.    equation ( [ operation 6 ] ) guarantees that the total load on the edges ( @xmath31 } l_{i , j}(t)$ ] ) incident on each producer ( @xmath32 $ ] ) is equal to the total size of the requests generated by the producer ( @xmath33 ) .",
    "this will be referred to as _ producer request _ constraint .",
    "@xmath34 } l_{i , j}(t ) = \\sum_{t } r_i(t ) , \\forall ( i \\in [ m ] , \\ ; t ) \\label{operation 6}\\ ] ]    equation ( [ operation 7 ] ) ensures that the total load on the edges ( @xmath35 } l_{i , j}(t)$ ] ) incident on a consumer ( @xmath36 $ ] ) does not exceed the consumer capacity ( @xmath37 ) .",
    "this will be referred to as _ consumer capacity _ constraint .",
    "@xmath28 } l_{i , j}(t ) \\le c_{j } , \\forall ( j \\in [ n ] , \\ ; t ) \\label{operation 7}\\ ] ]",
    "_ balls - into - bins _ @xcite model is used for studying load balancing in a similar resource allocation configuration where , the objective is to place m balls into n bins while guaranteeing bounds on the maximum , minimum or the average load across all the bins .",
    "the main advantage of the model defined in section [ sec : problem - definition ] is that it also takes into accounts the capacities of the bins ( which are analogous to the consumers in the problem defined in section [ sec : problem - definition ] ) .",
    "further the model described in section [ sec : problem - definition ] compares the performance of a randomized algorithm with the optimal offline algorithm .",
    "one of the well studied online algorithm for assigning resources to users is the _ k_-server problem @xcite where , the servers handle request once for each client .",
    "dynamic assignment @xcite has a similar configuration involving bipartite graphs .",
    "the optimal offline algorithm has to exhaustively look at the available edges for allocating a request .",
    "this paper uses linear programming and primal - dual algorithms for solving the offline version ( section [ sec : problem - definition ] ) .",
    "linear programming @xcite is a method used to solve large - scale optimization problems with a set of constraints and an objective function ( minimization or maximization ) both being linear .",
    "the lp formulation for this problem is as follows ,    objective function :    minimize : @xmath28 , j \\in [ n ] } d_{i , j}(t )   \\cdot   l_{i , j}(t ) , \\ ; \\ ; \\ ; d_{i , j}(t ) \\ge 0 , \\ ; l_{i , j}(t ) \\ge 0 \\label{operation 8}\\ ] ]    constraints : @xmath34 } l_{i , j}(t ) \\ge \\sum_{t } r_i(t ) , \\;\\ ;",
    "r_i(t ) > 0 , \\;\\ ;   \\forall ( i \\in [ m ] , \\ ; t ) \\label{operation 9}\\ ] ]    @xmath28 } l_{i , j}(t ) \\le c_{j } \\implies -\\sum_{i \\in [ m ] } l_{i , j}(t ) \\ge - c_{j } , \\ ; \\forall ( j \\in [ n]\\ ; t ) \\label{operation 10}\\ ] ]    this lp is used for calculating the optimal solution opt(t ) for the input received in the time interval @xmath30 , t$ ] .",
    "as the requests @xmath38 $ ] are non - negative the load assignments @xmath39 in the objective function ( [ operation 8 ] ) are also non - negative . equation ( [ operation 9 ] ) represents the _ producer request _ constraint corresponding to ( [ operation 6 ] ) whereas ( [ operation 10 ] ) corresponds to the _ consumer capacity _ constraint corresponding to ( [ operation 7 ] ) .",
    "in addition to this , new constraints corresponding to the existing load assignment on edges have to be added at each time instance @xmath18 for _ assignment without reallocation _ ( defined in section [ sec : problem - definition ] ) .",
    "lp formulation in section [ sec : offline - lp ] produces a feasible ( without violating the consumer capacity constraints ( [ operation 7 ] ) ) assignment of loads @xmath39 on edges @xmath40 corresponding to the requests @xmath41 , t)$ ] . equation ( [ operation 9 ] ) guarantees that the total request generated by producers @xmath32 $ ] is satisfied and ( [ operation 10 ] ) ensures that the capacities of consumers @xmath36 $ ] are not exceeded . by definition of problem in section [ sec : problem - definition ] , this is a valid assignment of loads on edges .",
    "lp formulation in section [ sec : offline - lp ] produces the optimal assignment of loads @xmath39 on edges @xmath40 corresponding to the requests @xmath41 , t)$ ] . the solution produced by lp is optimal as fractional loads are allowed and the lp considers all possible solutions minimize the objective function ( [ operation 8 ] ) .",
    "primal - dual algorithms are used for a certain class of optimization problems where there are a finite number of feasible solutions available at each step .",
    "the dual is often useful for providing intuitions about the nature of the solution that are implicit in the primal .",
    "consider the dual of the lp formulation in section [ sec : offline - lp ] .",
    "let @xmath42 be the dual variables corresponding to producers @xmath32 $ ] ( [ operation 9 ] ) and @xmath43 be the dual variables corresponding to the consumers @xmath36 $ ] ( [ operation 10 ] ) then the corresponding dual is ,    objective function :    maximize :    @xmath28 } y_i   \\cdot   r_i - \\sum_{j \\in [ n ] } z_j   \\cdot   c_j , \\ ; y_i \\ge 0 , \\ ; z_j \\ge 0 \\label{operation 11}\\ ] ]    @xmath44 is the total size of the requests produced by @xmath15    constraints : @xmath45 ,",
    "j \\in [ n ] ) \\label{operation 12}\\ ] ]    equation ( [ operation 12 ] ) suggests that the potential difference between producers and consumers can be atmost equal to @xmath7 .",
    "this will be referred to as dual _ potential limit _ constraint .    according to complementary slackness conditions , @xmath46    let t be the set of tight constraints ( which represent edges selected by algorithm [ alg1 ] ) ( @xmath47 , j \\in [ n ] ) \\}$ ] ) and * s * , the set of slack constraints ( @xmath48 , j \\in [ n ] ) \\}$ ] ) . then consider an _ unit benefit _ function which measures the increase in dual objective ( [ operation 11 ] ) corresponding to a unit amount of request ( @xmath49 ) produced by producer @xmath32 $ ] at time @xmath18 where , @xmath50 are the corresponding increases in the consumer - dual variables ; required for keeping the dual _ potential limit _ constraints ( [ operation 12 ] ) tight .",
    "@xmath51    the _ unit benefit _ function in [ operation 17 ] is used as a criteria for selecting the request which produces the maximum increase in the dual objective function by the primal - dual algorithm .",
    "@xmath52 @xmath53 , j \\in [ n ] ) \\}$ ] @xmath54 $ ] @xmath55 $ ] @xmath56 , j \\in [ n])$ ] @xmath57 @xmath58 , j \\in [ n ] \\}$ ] @xmath59 @xmath60 @xmath61 @xmath62 @xmath63 @xmath64 @xmath65    the primal - dual algorithm [ alg1 ] chooses the ( producer dual variable @xmath42 corresponding to ) request @xmath66 with the highest benefit function @xmath67 ( step 7 in algorithm [ alg1 ] ) to maximize the increase in value of dual objective function and then chooses the dual _ potential limit _ constraint ( operation 12 ) ( and the corresponding variable @xmath43 ) that is closest to becoming tight at step 8 in algorithm [ alg1 ] ( corresponding to the least cost edge in the primal ) and increases the value of @xmath42 by the amount ( @xmath68 , in steps 9 and 10 in algorithm [ alg1 ] ) that is needed to make this constraint tight ( which corresponds to selecting an edge for allocating a request in the primal using complementary slackness condition [ operation 13 ] ) . if this constraint is tight ( t updated in step 12 ) then corresponding @xmath43 are also increased by @xmath68 ( step 11 in algorithm [ alg1 ] ) to maintain tightness .",
    "increasing @xmath7 by amount @xmath69 is only symbolic / superficial .",
    "the practical output of the algorithm can be traced by looking up the set of dual constraints ( corresponding to edges in primal ) that are selected corresponding to each request .",
    "intuitively , optimal offline primal - dual algorithm [ alg1 ] assigns the lower sized requests to the higher cost edges and uses the lower cost edges for the higher sized requests .",
    "[ optimality of algorithm [ alg1 ] ] the primal - dual algorithm [ alg1 ] reaches the optimal solution for the _ assignment without reallocation _ problem in section [ sec : problem - definition ] when it is not possible to increase the cost of the dual objective function ( [ operation 11 ] ) .",
    "nitializing @xmath70 $ ] and @xmath55 $ ] ( steps 1 and 2 in algorithm [ alg1 ] ) and from the way we increase the dual variables ( step 9 in algorithm [ alg1 ] ) the dual _ potential limit constraint _ ( [ operation 12 ] ) is always satisfied . setting @xmath56 ,",
    "j \\in [ n])$ ] ( step 5 in algorithm [ alg1 ] ) makes sure that the primal is feasible at the start .",
    "the primal _ consumer capacity _ constraints in ( [ operation 10 ] ) are not violated by the way we increase @xmath39 from steps 14 and 15 in algorithm [ alg1 ] .    when the cost of the dual objective function ( [ operation 11 ] ) can not be increased further ,    @xmath71    at this point , if there was a pending request @xmath66 with a positive _ unit benefit _ function that could choose one of the slack ( s ) dual constraints ( without violating any of the _ potential limit _",
    "dual constraints([operation 12 ] ) ) then the corresponding producer dual variable @xmath42 can be increased until the dual constraint became tight . by contradiction",
    "such a request does not exists by definition ( step 6 ) of algorithm [ alg1 ] otherwise , the algorithm would have continued .",
    "so the system is in equilibrium and changing the value of any of the dual variables will violate ( one or more ) dual _ potential limit _ constraints .",
    "however , for the current solution ( @xmath72 ) , the dual variables need to be changed by an equal amount ( @xmath73 , j \\in [ n])$ ] ) for maintaining the potential equilibrium [ keeping the dual constraints in t tight for meeting complementary slackness ( [ operation 13 ] ) condition ] .    @xmath74    when it is not possible to increase the value of dual objective function then using ( 12 ) and ( 13 ) ,    @xmath75    from steps 14 and 15 in algorithm [ alg1 ] , we know that , @xmath76    using ( [ operation 19 ] ) and ( [ operation 20 ] ) we infer that the requests have been met , @xmath77    this means that the primal _ producer request _ constraints in ( [ operation 9 ] ) are feasible and the primal _ consumer capacity constraints _ in ( [ operation 10 ] ) and dual _ potential limit _ constraints are always feasible .",
    "complementary slackness ( [ operation 13 ] ) is satisfied as we only increase @xmath7 when the dual constraint is tight .",
    "this means that the primal is optimal and the dual is optimal .",
    "thus , this is the optimal solution for the problem in section [ sec : problem - definition ] .",
    "[ time complexity of algorithm [ alg1 ] ] the primal - dual algorithm [ alg1 ] takes @xmath0 , time to complete where , d and n the number of requests and consumers respectively .    at each step of the algorithm [ alg1 ] @xmath2 ( where r is the number of requests ) operations are needed to select the ( producer dual variable @xmath42 corresponding to the ) request with maximum _ unit benefit _ function , another @xmath78 operations to find the corresponding consumer dual variable @xmath43 .",
    "hence , it takes @xmath79 operations for the first ( while loop from steps 6 to 16 in algorithm [ alg1 ] ) and @xmath80 operations for the second request by keeping track of the requests that have been covered by setting a flag in a hash table .",
    "this gives a time complexity of @xmath0 using amortized analysis .",
    "in the beginning we look at the following simplified model @xmath81 ,    * let @xmath82 be the request in round @xmath18 and let @xmath83 denote the set of consumers in round @xmath18 that have enough space left to store request @xmath82 . * all requests @xmath82 have the same size s. * all consumers @xmath84 have equal capacities @xmath13 . * an oblivious online adversary who can only manipulate the size of the online requests .",
    "we use randomized algorithms for the online version as for a deterministic algorithm the oblivious online adversary who knows the edge selected in each round can manipulate the online request sizes to distort the value of the objective function ( [ operation 5 ] ) .",
    "the simplified algorithm @xmath85 is :    given : @xmath86 ; @xmath87 ; @xmath13 ; @xmath7 ; @xmath88 initialize : @xmath89 @xmath90 $ ] ; @xmath91 ; @xmath12 choose @xmath92 $ ] independently and uniformly at random @xmath93 \\land \\ell_j + s \\leq c\\}$ ] choose @xmath94 $ ] independently and uniformly at random from @xmath83 .",
    "@xmath95 @xmath96    assuming model @xmath81 and running algorithm @xmath85 , the expected total cost is @xmath97 = \\sum_{t=1}^{r } s \\cdot \\overline{d}$ ] .",
    "using the law of total probability over the different combination of consumer failures @xmath98 when there are @xmath99 consumers available ,    @xmath100    using ( [ operation 900 ] ) and the law of total expectation over the number of consumers available ,    @xmath101   & = \\sum_{k=1}^{n } e\\big[d_{i = p_i , j }   \\bigm\\vert ( |c(t)| = n - k)\\big ] \\cdot p\\big ( |c(t)| = n - k\\big ) \\\\ & = \\frac{\\sum_{j=1}^{n } d_{i , j}}{n } \\cdot \\sum_{k=1}^{n } p\\big(|c(t)| = n - k\\big ) \\\\ & = \\frac{\\sum_{j=1}^{n } d_{i , j}}{n } \\label{operation 115}\\end{aligned}\\ ] ]    we calculate the expected distance of an edge selected in any round over the scenarios corresponding to different number @xmath102 of consumers available using ( 21 ) . as the probability to select an edge does not change in the different scenarios we deduce in ( 18 ) , ( 19 ) and ( 20 ) that , there is uniform probability of selecting any ( consumer ) edge given that producer @xmath15 is selected in a round .",
    "intuitively this follows form symmetry as each consumer is equally likely to be picked in any round assuming equal capacities .    using the law of total expectation over the producer selected in a round ,    @xmath103    & = \\sum_{i=1}^{m } e\\big[d_{i = p_i , j }   \\bigm\\vert i = p_i\\big ] \\cdot p\\big(i = p_i\\big ) \\\\ & = \\sum_{i=1}^{m } \\bigg [   \\frac{1}{n }   \\cdot \\sum_{j=1}^{n } d_{i , j } \\bigg ] \\cdot \\frac{1}{m } \\\\ & = \\frac{1}{m \\cdot n } \\sum_{i=1}^{m } \\sum_{j=1}^{n } d_{i , j } = \\overline{d } \\label{operation 114}\\end{aligned}\\ ] ]    so the expected cost of algorithm @xmath85 ( [ alg2 ] ) in any round is @xmath97 = s \\cdot e[d_{i , j } ] = s \\cdot \\overline{d}$ ] .",
    "the best possible cost of the optimal offline algorithm opt in any round is when it chooses the cheapest edge @xmath104 in each round .",
    "thus , the average - case ( @xcite ) competitive ratio is @xmath105 .",
    "the worst - case competitive ratio is @xmath106 .    extending model @xmath81 to @xmath107 with arbitrary producer request sizes , equal consumer capacities , arbitrary edge distances and allowing a single requests to be allocated across multiple consumers and running algorithm @xmath108 ,",
    "the expected total cost is @xmath97 = \\sum_{t=1}^{r } s(t ) \\cdot \\overline{d}$ ] .",
    "the simplified algorithm @xmath108 is :    given : @xmath86 ; @xmath87 ; @xmath13 ; @xmath7 ; @xmath88 initialize : @xmath89 @xmath90 $ ] ; @xmath91 ; @xmath12 choose @xmath92 $ ] independently and uniformly at random choose an arbitrary request size @xmath109 $ ] @xmath110 \\land \\ell_j + s(t ) \\leq c\\}$ ] choose @xmath94 $ ] independently and uniformly at random @xmath111 @xmath112    by splitting the requests into unit sized blocks of size @xmath113 and using the fact that there is equal probability for the blocks to be allocated to any consumer , it follows from symmetry that a block of unit requests is equally likely to belong to any producer @xmath15 . using ( 20 ) ,",
    "( 22 ) and ( 26 ) from * theorem 3 * we get the expected cost of the edge selected in anay round as @xmath114 .",
    "so the expected cost is @xmath97 = \\sum_{t=1}^{r } s(t ) \\cdot \\overline{d}$ ] and the average case competitive ratio is @xmath105    extending model @xmath107 to @xmath115 with arbitrary producer demands , arbitrary consumer capacities and arbitrary edge distances and running algorithm @xmath116 , the expected total cost is @xmath97 = \\sum_{t=1}^{r }",
    "s(t ) \\cdot \\frac{\\overline{d \\cdot c}}{\\overline{c } } , \\ ; \\forall t$ ] .",
    "the simplified algorithm @xmath116 is ,    given : @xmath86 ; @xmath87 ; @xmath13 ; @xmath7 ; @xmath88 initialize : @xmath89 @xmath90 $ ] ; @xmath91 ; @xmath12 choose @xmath92 $ ] independently and uniformly at random choose an arbitrary request size @xmath109 $ ] @xmath110 \\land \\ell_j + s(t ) \\leq c\\}$ ] choose @xmath117 with probability @xmath118 @xmath111 @xmath112    let @xmath119 be a indicator random variable that indicates that producer @xmath15 selects consumer @xmath24 .",
    "as requests are split into unit sized blocks , the expected load on consumer @xmath24 assigned by producer @xmath15 is equal to value of @xmath119",
    ". then @xmath120 = e\\big[c_j \\bigm\\vert p_i\\big ] = \\frac{c_j}{\\sum_{j \\in n } c_j}$ ] .",
    "let @xmath121 be the indicator random variable for the load placed on consumer @xmath24 in a specific round then,@xmath122 = \\sum_{p_i=1}^{m } e[x_{p_i , j } ] \\cdot p(p_i ) = \\frac{c_j}{\\sum_{j \\in n } c_j}$ ] as each producer is equally likely to be selected in a round .",
    "let @xmath123 denote the load placed on consumer @xmath24 after r requests have been completed then @xmath124 = \\sum_{t=1}^{r } s(t ) \\cdot e[y_j ] = \\frac{c_j}{\\sum_{j \\in [ n ] } c_j } \\cdot \\sum_{t=1}^{r } s(t ) $ ] .",
    "using unit sized requests the consumer load always remains proportional to its capacity .",
    "as the producers are chosen uniformly at random the probability that a consumer @xmath24 was picked by a producer @xmath15 in any round is @xmath125 = \\frac{1}{m}$ ] .",
    "size of the request chosen @xmath126 $ ] at each iteration can be atmost equal to the remaining capacity available as it can be split amonst the consumers .    expected distance of the edge when consumer @xmath24 is picked is ,    @xmath127 & = \\sum_{i=1}^{m } d_{i , j } \\cdot p\\big(p_i \\bigm\\vert c_j\\big ) \\\\ & = \\frac{1}{m } \\cdot \\sum_{i=1}^{m } d_{i , j } \\label{operation 301}\\end{aligned}\\ ] ]    the expected cost of edge picked in a any round assuming equal failure times ,    @xmath128 & = \\sum_{j=1}^{n } e\\big [ d_{i , j } \\bigm\\vert c_{j } \\big ] \\cdot p(c_{j } ) \\\\ & = \\frac{1}{m } \\cdot \\sum_{j=1}^{n }   \\sum_{i=1}^{m } d_{i , j } \\cdot \\frac{c_j}{\\sum_{j=1}^{n } c_j } \\\\ & = \\frac{n}{\\sum_{j=1}^{n } c_j } \\cdot \\frac{\\sum_{j=1}^{n }   \\sum_{i=1}^{m } d_{i , j }",
    "\\cdot c_j}{m \\cdot n } = \\frac{\\overline{d \\cdot c}}{\\overline{c } } \\label{operation 302}\\end{aligned}\\ ] ]    expected cost is @xmath97 = \\sum_{t=1}^{r } s(t ) \\cdot \\frac{\\overline{d \\cdot c}}{\\overline{c}}$ ] and the average - case competitive ratio is @xmath129 .",
    "although the competitve ratio depends on the edge distances and consumer capacities , it is not possible to assume equal failure times using any other edge probability although this online algorithm @xmath130 is not optimal for the objective function in ( [ operation 5 ] ) .",
    "[ h ]     the instances considered ranged from 1 to 100 producers and 1 to 100 consumers .",
    "the size of demands , edge distances and consumer capacities were picked randomly .",
    "the average - case competitive ratio of of @xmath105 for the model with equal consumer capacities and arbitrary producer requests indicates that the performance depends on the quality of majority of links . for arbitrary consumer capacities with an average - case competitve ratio of @xmath131",
    "the performance is decided by the quality of the links connected to the consumers with higher capacites .",
    "the optimal offline primal - dual algorithm runs in @xmath0 time whereas the online algorithms take @xmath2 time where r and n are the number of requests and consumers respectively .    99 raab , c steger , a , `` balls into bins '' - a simple and tight analysis , randomization and approximation techniques in computer science , lncs , * 1518 * , 159 - 170 , 1998 fujiwara , h , iwama , k , bose , p , morin , p average - case competitive analyses for ski - rental problems algorithms and computation , lncs , springer berlin / heidelberg , 2002 , * 2518 * , 157 - 189 .",
    "mills - tettey , g. a. , stentz , a. t. , and dias , c. b. , the dynamic hungarian algorithm for the assignment problem with changing costs , tech .",
    "cmu - ri - tr-07 - 27 , robotics institute , 2007 .",
    "k. schrder , balls into bins : a paradigm for job allocation , data distribution processes , and routing , phd thesis , 2000 .",
    "correa jr , wagner mr , lp - based online scheduling : from single to parallel machines , integer programming and combinatorial optimization , proceedings , lecture notes in computer science , * 3509 * , 196 - 209 , 2005 .",
    "azar y , broder az , karlin ar , upfal e , balanced allocations , siam journal of computing , * 29*,1 , 180 - 200 , sep 1999 .",
    "yair bartal , manor mendel , randomized k - server algorithms for growth - rate bounded graphs , journal of algorithms * 55 * ( 2005 ) 192202 .",
    "http://www.vmware.com/files/pdf/vmware-dynamicstorageprov-wp-en.pdf[dynamic storage provisioning ] , vmware , nov 18 , 2009 .",
    "http://www.vmware.com/files/pdf/scalable_storage_performance.pdf[scalable storage performance ] , vmware , jun 5 , 2008 ."
  ],
  "abstract_text": [
    "<S> we explore a novel theoretical model for studying the performance of distributed storage management systems where the data - centers have limited capacities ( as compared to storage space requested by the users ) . </S>",
    "<S> prior schemes such as balls - into - bins ( used for load balancing ) neither consider bin ( consumer ) capacities ( multiple balls into a bin ) nor the future performance of the system after , balls ( producer requests ) are allocated to bins and restrict number of balls as a function of the number of bins . </S>",
    "<S> our problem consists of finding an optimal assignment of the online producer requests to consumers ( via weighted edges ) in a complete bipartite graph while ensuring that the total size of request assigned on a consumer is limited by its capacity . </S>",
    "<S> the metric used to measure the performance in this model is the ( minimization of ) weighted sum of the requests assigned on the edges ( loads ) and their corresponding weights . we first explore the optimal offline algorithms followed by the analysis of different online techniques ( by comparing their performance against the optimal offline solution ) . </S>",
    "<S> lp and primal - dual algorithms are used for calculating the optimal offline solution in @xmath0 time ( where r and n are the number of requests and consumers respectively ) while randomized algorithms are used for the online case . </S>",
    "<S> + we propose randomized online algorithms in which the consumers are selected based on edge probabilities ( that can change with consumer failures ; due to capacity exhaustion ) and evaluate the performance of these randomized schemes using probabilistic analysis . </S>",
    "<S> the performance of the online algorithms is measured using competitive analysis assuming an oblivious adversary who knows the randomized algorithm but not the results produced . for the simplified model with equal consumer capacities </S>",
    "<S> an average - case competitive ratio ( which compares the average cost of the output produced by the online algorithm and the minimum cost of the optimal offline solution ) of @xmath1 ( where d is the edge weight / distance ) is achieved using an algorithm that has equal probability for selecting any of the available edges with a running time of @xmath2 . in the extending the model to arbitrary consumer capacities we show an average case competitive ratio of @xmath3 . </S>",
    "<S> this theoretical model gives insights to a ( storage ) cloud system designer about , how the different attributes ( producer requests , edge weights and consumer capacities ) effect the overall ( read / write ) performance of a distributed storage management system over a period of time . </S>"
  ]
}