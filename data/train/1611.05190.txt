{
  "article_text": [
    "the conflict driven clause learning ( cdcl ) algorithm  @xcite is the leading solution adopted by state - of - the - art solvers for boolean satisfiability ( sat )  @xcite , satisfiability modulo theories ( smt )  @xcite , and answer set programming ( asp )  @xcite to mention a few .",
    "notably , cdcl solvers have been applied with success for solving several real - world problems ranging from hardware and software model checking , planning , equivalence checking , bioinformatics , configuration problems , hardware and software test , software package dependencies , cryptography and more  @xcite .    as a matter of fact the performance of a cdcl solver heavily depends on the adoption of heuristics that drive the search for solutions . among these ,",
    "the heuristic for the selection of the branching literal ( i.e. , the criterion determining the literal to be assumed true at a given stage of the computation ) can dramatically affect the overall performance of an implementation  @xcite .",
    "state - of - the - art cdcl implementations feature very good general purpose heuristics belonging to the family of vsids  @xcite . since their introduction , vsids heuristics proved to be a key ingredient for solving many relevant problems  @xcite .",
    "nonetheless , no general heuristic is known to be the best possible choice for all problems  @xcite . pioneering work on employing domain - specific heuristics corroborates the validity of that idea .",
    "in particular , beame et al . demonstrated the utility of a domain - specific branching heuristic for solving the pebbling formulas with a cdcl solver  @xcite ; and rintanen proposed to replace the standard vsids by a domain - heuristics for efficiently solving planning as satisfiability  @xcite .",
    "moreover , gerhard friedrich in his joint invited talk at cp - iclp 2015 described a number of experiences in which `` domain - specific heuristics turned out to be the key component in several industrial applications of problem solvers ''  @xcite . however , as argued in  @xcite : `` the main challenge in defining a variable selection scheme is its integration in the cdcl algorithm in a productive way '' .",
    "indeed , domain experts can quickly provide promising heuristic - criteria based on properties of solutions , but they may not have the knowledge and the experience to plug them in cdcl implementations .    the goal of the paper is to ease the design and the evaluation of new heuristics for cdcl solvers as well as to reduce the efforts needed to provide effective implementations . to this end we distill the key ingredients that drive the search of cdcl solvers , and propose a general framework for designing and implementing new heuristics .",
    "useless to say that one could invent new heuristics based on other different `` ingredients '' .",
    "nevertheless , our framework is quite rich and flexible , and indeed it covers the definition of the most popular heuristics for cdcl , as well as enables the definition of interesting problem - specific heuristics .",
    "moreover , further features could be easily incorporated .",
    "a number of examples are provided to demonstrate the applicability of the proposed framework for defining a variety of known heuristic criteria from the literature  @xcite .",
    "pragmatic evidence of the benefits of our framework in devising problem - specific heuristics is provided by reporting on a use case where two hard industrial domains defined by siemens , the partner units problem ( pup )  @xcite and combined configuration problem ( ccp )  @xcite , are solved efficiently .    in our use case ,",
    "the framework has been implemented by extending the asp solver wasp  @xcite .",
    "our implementation offers a wide range of possibilities to end users for developing new heuristics .",
    "in particular , it offers multi - language support including scripting languages for fast prototyping , an embedded c++ interface for performance - oriented implementations , as well as heuristic definition by means of declarative predicate - based paradigms .",
    "experiments on pupand ccpconfirm the viability of the framework in real - world scenarios , and the effectiveness of our implementation that is able to solve successfully hard problem instances which were not solvable by state - of - the - art asp solvers",
    ". furthermore , we were able to solve hardest ccpinstances for which no solution was known before .",
    "in this section we provide some basic knowledge about the conflict - driven clause learning ( cdcl ) algorithm  @xcite for solving the satisfiability problem ( sat )  @xcite .",
    "the conflict - driven clause learning ( cdcl ) @xcite backtracking search algorithm is a de facto standard for the satisfiability problem ( sat )  @xcite . during the recent years",
    ", cdcl has been extended in order to fit specific requirements of formalisms in the neighborhood of sat , e.g. satisfiability modulo theories and answer set programming . in the following ,",
    "we first introduce some basic concepts of the satisfiability problem and then we describe the cdcl algorithm .    [ [ sat . ] ] sat .",
    "+ + + +    let @xmath0 be a fixed , countable set of propositional atoms including @xmath1 .",
    "a literal @xmath2 is either an atom @xmath3 or its negation @xmath4 , and @xmath5 denotes the atom associated to @xmath2 .",
    "the complement of @xmath2 is denoted by @xmath6 , where @xmath7 and @xmath8 for an atom @xmath3 . for a set @xmath9 of literals , @xmath10 , @xmath11 , and @xmath12 .",
    "a ( partial ) interpretation is a set of literals @xmath13 containing @xmath14 .",
    "@xmath13 is inconsistent if @xmath15 , otherwise @xmath13 is consistent .",
    "@xmath13 is total if @xmath16 .",
    "given an interpretation @xmath13 , a literal @xmath2 is true if @xmath17 ; is false if @xmath18 , and is undefined otherwise .",
    "a clause @xmath19 is a set of literals , and a formula @xmath20 is a set of clauses .",
    "an interpretation @xmath13 satisfies a clause @xmath19 if @xmath21 .",
    "a consistent , total interpretation @xmath13 is a model of a formula @xmath20 if all clauses in @xmath20 are satisfied . a formula @xmath20 is said to be consistent if it admits some model , inconsistent otherwise .",
    "given a formula @xmath20 , the sat problem consists in determining whether @xmath20 is consistent .    [",
    "ex : ex1 ] consider the formula @xmath22 @xmath23 .",
    "@xmath24 is a model of @xmath20 .",
    "[ [ cdcl - algorithm . ] ] cdcl algorithm .",
    "+ + + + + + + + + + + + + + +    the cdcl algorithm takes as input a formula @xmath20 , and determines whether it is consistent .",
    "the first step of the algorithm consists of the simplification of @xmath20 .",
    "polynomial algorithms for clause rewriting and variable elimination are applied on @xmath20 , which strengthen and/or remove redundant clauses @xcite .",
    "after the simplifications step , the partial interpretation @xmath13 is set to @xmath25 , and the backtracking search starts .",
    "first , @xmath13 is extended with all the literals that can be deterministically inferred by applying some inference rule ( _ propagation _ step ) .",
    "the main inference rule of a sat solver is _ unit propagation _ that extends @xmath13 by an undefined literal @xmath2 whenever there is a clause @xmath26 such that @xmath27 and @xmath28 .",
    "three cases are possible after a propagation step is completed : @xmath29 @xmath13 is consistent but not total . in that case ,",
    "an undefined literal @xmath2 ( called _ branching literal _ ) is chosen according to some heuristic criterion , and is added to @xmath13 .",
    "then , a propagation step is performed that infers the consequences of this choice .",
    "@xmath30 @xmath13 is inconsistent , thus there is a conflict , and @xmath13 is analyzed .",
    "the reason of the conflict is modeled by a fresh clause @xmath19 that is added to @xmath20 ( clause _ learning _ ) , e.g. by applying the _ first unique implication point ( uip ) _",
    ". moreover , the algorithm backtracks ( i.e. choices and their consequences are undone ) until the consistency of @xmath13 is restored .",
    "then the algorithm propagates inferences starting from the fresh clause @xmath19 .",
    "otherwise , if the consistency of @xmath13 can not be restored , the algorithm terminates returning inconsistent .",
    "finally , in case @xmath31 @xmath13 is consistent and total , i.e. @xmath13 is a model , the algorithm terminates returning consistent .",
    "[ ex : ex2 ] consider the formula @xmath20 of example  [ ex : ex1 ] .",
    "the search starts with @xmath32 .",
    "unit propagation extends @xmath13 with @xmath3 and @xmath33 to satisfy clauses @xmath34 and @xmath35 .",
    "no other inferences can be done , thus a choice is performed among @xmath36 , @xmath37 , @xmath38 , and @xmath39 .",
    "choosing @xmath37 would lead to an inconsistency , while all other choices would directly lead to a model .",
    "[ [ heuristics . ] ] heuristics .",
    "+ + + + + + + + + + +    it is well - known that the selection the branching literal plays a crucial role for efficiency .",
    "nowadays , state - of - the - art solvers , such as lingeling  @xcite and glucose  @xcite , implement branching criteria belonging to the vsids  @xcite family that are a variant of the minisat  @xcite heuristic .",
    "thus , in the following , the minisat  @xcite heuristic is referred to as the _ default branching heuristic _ of a cdcl solver .",
    "the minisatheuristic is based on the _ activity _ value for each atom in the input formula @xmath20 , which is initially set to 0 .",
    "the activity of @xmath40 is incremented by a value @xmath41 when a literal @xmath2 occurs in a learned clause . then , after learning the clause , the value of @xmath41 is multiplied by a constant slightly greater than 1 , to give more and more importance to variables that occur in recently - learned clauses . once a choice is needed , the literal @xmath42 is chosen , where @xmath43 is the undefined atom having the highest activity value ( ties are broken randomly ) .    for the sake of completeness",
    ", we mention that the cdcl is usually complemented with heuristics that control the number of learned clauses , and restart the computation to explore different branches of the search tree  @xcite .",
    "+   + _ triggered when the backtracking search starts . @xmath44 and @xmath45 are the formula and the atoms after the simplifications , resp . _",
    "+   +   + _ triggered when the choice @xmath2 led to an inconsistency . _",
    "+   +   + _ triggered when a conflict is detected after the choice of @xmath2 . _",
    "+   +   + _ triggered when the clause @xmath19 is learned . _",
    "+   +   + _ triggered when the literal @xmath2 is involved in the creation of a clause to learn , e.g. , while applying the first uip schema . _",
    "+   +   + _ triggered when the clause @xmath19 has been removed . _",
    "+   +   + _ triggered when a restart of the search occurs . _",
    "+   +   + _ triggered during backtracking if the literal @xmath2 is set to undefined . _ +    in this section we present the results of our studies pinpointing the key ingredients needed to drive the search of cdcl solvers .",
    "these were distilled by considering the needs of well - known heuristics , as well as by applying the lessons learned while developing domain - specific heuristics in the case study reported in the next section .    in our framework",
    "we identify two main actors : the _ solver _ and the _ driver_. the first is , basically , an implementation of the cdcl algorithm , and the second implements an external branching heuristic .",
    "selection of a branching literal may depend ( or not depend ) on properties of the input , on the ( current ) solver state , on employed optimization techniques ( e.g. , input rewritings ) , as well as on the status of variables that directly model some properties of the problem , etc .",
    "this information is possibly communicated by the solver to the driver by means of _",
    "events_. events can be seen as asynchronous messages sent to the driver when specific points of the computation are reached , as detailed in table  [ tab : events ] .",
    "the driver could exploit this information to implement the heuristic criteria , e.g. , updating counters or modifying its status .",
    "none of the events are mandatory for the driver ( we expect that an efficient implementation smartly sends only those required by the driver ) .",
    "we have also identified two main moments in the computation when the solver gets directions from the driver .",
    "these are modeled in our framework by means of _ requests _ , that are detailed in table  [ tab : responses ] together with the _ responses _ the solver expects to receive .",
    "requests are synchronous , i.e. , the solver waits for a response of ( i.e. , a command from ) the driver .",
    "the request getatomstobefrozen(@xmath0 ) is sent before starting the simplifications of the input formula .",
    "in fact , preprocessing can remove atoms that the heuristic strategy may want to keep ( they may play a role in a domain - specific heuristic ) .",
    "the response # freeze(@xmath46 ) informs the solver to avoid eliminating the variables in @xmath0 .",
    "+   + _ asks the heuristic strategy to provide a list of atoms @xmath46 that must not be removed by simplifications . _ +   +      + _ asks to not remove atoms in @xmath47 during preprocessing .",
    "_ +     +   +   + _ asks the heuristic strategy to provide the next branching literal(s ) given the current interpretation @xmath13 . _ +   +      + _ asks the solver to perform the choices in list @xmath48 .",
    "@xmath48 contains tuples of the form ( @xmath49 ) , where @xmath50 and @xmath51 .",
    "given tuple @xmath52 , the solver chooses @xmath43 if @xmath53 , @xmath54 if @xmath55 , and if @xmath56 the cdcl is left free to choose the sign . _ +   +   + _ asks the solver to backtrack until @xmath2 becomes undefined . to trigger a restart set @xmath57 . _ +   +   + _ asks the solver to use the default heuristics for the next @xmath58 choices .",
    "the default heuristic is enable permanently if @xmath59 .",
    "parameters @xmath60 initialize the default heuristics as follows : @xmath61 provides the initial activity of atoms ; @xmath62 associates to atoms an amplifying factor ; @xmath63 to provide a priority on the sign of literals . _ +   +   + _ asks the solver to add the clause @xmath19 to the formula . _ +     +    the getchoice(@xmath13 ) request is the main one , and is made by the solver when a non - deterministic choice is required .",
    "a number of responses are possible besides the obvious one where the driver provides the solver with an ordered list of branching literals to be chosen .",
    "the list can hold just one element as in many well - known heuristics , or can provide in one call several choices so to reduce communication overheads in domain - heuristics that may provide at once an entire plan of choices .",
    "alternative responses were inspired by domain - specific criteria .",
    "for example , the driver is likely to recognize specific paths in the search space that can not lead to a solution , so it can issue a unroll(@xmath2 ) to cause a backtrack up to the last choice made before @xmath2 .",
    "moreover , the driver could add some additional domain knowledge modeled by a clause @xmath19 in the solver by answering # addclause(@xmath19 ) . finally , there are cases ( see next section ) in which it makes sense to blend custom heuristics with the default heuristic , to exploit the strengths of both . to this end",
    "the driver can respond # fallback(@xmath64 ) so to force the solver to use its default heuristic for the next @xmath58 choices .",
    "the parameters of # fallback ( . ) allow to customize this interaction by ( possibly ) tuning the activity values and the multiplying factors used by the default heuristic .    in the following we",
    "provide a number of examples that show how to encode several well - known conflict - based and domain - specific heuristics . this way the reader can appreciate the generality of our proposal that cover the needs of a wide range of conflict - based heuristics as well as domain - heuristics proposed in the literature",
    "nevertheless , we remark that our framework can be easily extended by adding new events / requests to fit the needs of future applications .",
    "[ ex : minisat ] we first consider the minisatheuristic as described in  @xcite .",
    "this criterion can be implemented in our framework by exploiting the events onstartsearch(@xmath65 ) and onlearnclause(@xmath19 ) , as well as the getchoice(@xmath13 ) request .",
    "the first is used to initialize the activity values of atoms in the input ; the second causes an increment the activity of atoms in the learned clause @xmath19 .",
    "finally , the request getchoice(@xmath13 ) is answered with # choice(@xmath66 ) by the driver , where @xmath3 is the undefined atom in @xmath13 with the highest value of activity .",
    "[ ex : pigeonhole ] consider the famous pigeonhole problem : given @xmath58 pigeons and @xmath67 holes , assign each pigeon to exactly one hole in such a way that two different pigeons do not share the same hole .",
    "it can be verified that state - of - the - art sat solvers are not able to solve this problem efficiently when @xmath68 , despite it is known that no solution exists in that case . a domain - specific heuristic based on this observation only uses the requests and no event . to getatomstobefrozen(@xmath0 )",
    "the driver answers to not remove any atom ( providing # freeze(@xmath0 ) ) , and computes @xmath58 and @xmath67 by interpreting the atoms in @xmath0 .",
    "once the first choice is requested , if @xmath68 the heuristic replies with # addclause(@xmath69 ) causing the termination of the cdcl returning inconsistent ; otherwise , # fallback(@xmath70 ) is sent to go on with the default heuristic .",
    "[ ex : rintanen ] in @xcite , a heuristic for solving the planning problem modeled as sat problem is proposed that intuitively forces the solver to prefer short and simple plans .",
    "this criterion can be implemented in our framework by using the event onsearch(@xmath71 ) , and the request getchoice(@xmath13 ) .",
    "in fact , onsearch ( . ) allows the driver to identify _ actions _ and _ goals _ literals ; while the answer to getchoice ( . )",
    "is computed by running the algorithm in figure  3 of @xcite .",
    "we mention that , one can easily obtain all the vsids - like heuristics described in  @xcite by applying small modifications to the solution presented in example  [ ex : minisat ] .",
    "in this section we report on a case study that provides pragmatical evidence of the applicability of our framework .",
    "the case study is developed in the context of answer set programming ( asp )  @xcite .",
    "asp is a declarative problem solving paradigm proposed in the area of logic programming and non - monotonic reasoning .",
    "asp is an ideal test bed for our framework for two main reasons : @xmath29 asp solvers are nowadays efficient cdcl implementations ; @xmath30 asp has been applied to a variety of complex problems including hard industrial ones . in the following",
    "we first describe the implementation of our framework in a well - known asp solver and , then , we report on the solution of two real - world configuration problems occurring in practice of siemens : the partner units problem ( pup ) and the combined configuration problem ( ccp ) .",
    "these appeared to be among the hardest industrial benchmarks from the asp competition 2015  @xcite ; indeed , on hard problem instances state - of - the - art asp solvers were not effective .",
    "given the practical importance of these two problems , many researchers studied them in detail  @xcite .",
    "their investigations resulted in a number of domain - specific heuristic approaches that , in some cases , significantly outperformed existing asp solvers .",
    "we experimented with these heuristics , thus applying our framework in practice , to see whether these can be integrated successfully in a cdcl solver .",
    "the framework has been implemented as an extension of the asp solver wasp .",
    "waspimplements a variant of cdcl devised for evaluating asp programs , thus featuring additional inference rules required for the evaluation of asp programs , such as _ unfounded - based _ and _ aggregate - based _",
    "inferences  @xcite .",
    "the framework for specifying heuristics has been implemented in _",
    "c++ _ and it offers an infrastructure for easy specification and testing of heuristic strategies . the user can adopt several languages for implementing external heuristics that range from imperative to declarative ones .",
    "in particular , the heuristic strategies can be implemented in _ perl _ and _ python _ for obtaining fast prototypes and in _ c++ _ for obtaining better performances .",
    "( in our tests , we observed that _",
    "c++ _ implementations are often faster than equivalent _ perl _ and _ python _ counterparts , which are usually easier to develop instead ) . in case",
    "the user would like to use a declarative language to implement a heuristic , our implementation provides a _ predicates - based _ interface extending the one proposed in  @xcite .",
    "we next sketch the idea by assuming that ( on the lines of in  @xcite ) one encodes the heuristic strategy in asp by providing a logic program @xmath72 .",
    "each request of the cdcl algorithm causes an evaluation of @xmath72 together with _ facts _ modeling the request ( intuitively , a fact is an atom that is always true ) .",
    "the evaluation of @xmath72 with the aforementioned facts produces a set of atoms ( i.e. , the answer set produced by a solver ) interpreted as responses for the request .",
    "for instance , consider example  [ ex : pigeonhole ] , the request getfrozenatoms(@xmath0 ) is represented by the facts @xmath73 and @xmath74 for each @xmath75 . a call to an external solver",
    "produces an answer set containing @xmath76 , for each @xmath75 , that is interpreted as # freeze(@xmath0 ) . other request and corresponding responses",
    "are handled in a similar manner .",
    "our implementation currently supports any external solver compliant with asp solver output .",
    "the predicate - based interface can easily support variants of asp ( e.g. , with _ preferences _",
    "@xcite , _ casp _",
    "@xcite , etc . ) an could be adapted , in principle , also to support other languages based on predicate logic .",
    "the pupcomes from the railway safety domain  @xcite , but has a variety of other applications including security monitoring systems , peer - to - peer networks , etc .  @xcite . in order to ensure the safety of train movements , railway tracks ( see figure  [ fig : pup_layout ] )",
    "are equipped with hardware _ sensors _",
    "@xmath77 which register when a wagon passes by .",
    "all registered events are forwarded from sensors to _ control units _",
    "@xmath78 belonging to a safety system .",
    "the latter has to prevent wagons of different trains from entering the same safety _",
    "zone _ of the tracks @xmath79 , hence avoiding unwanted collisions . to solve the problem one needs to ( 1 ) assign every zone and sensor to a control unit such that every unit is connected to at most ucapsensors and at most ucapzones .",
    "moreover , ( 2 ) if a sensor contributes to a zone , it must be placed on the same or on a connected unit ( partner unit ) .",
    "however , every unit can be a partner of at most iucapother units .",
    "[ [ heuristics.-1 ] ] heuristics .",
    "+ + + + + + + + + + +    for our evaluation we selected the quickpupheuristic and its derivatives , since search algorithms using these heuristics were able to outperform best asp solvers .",
    "* quickpup  @xcite generates an order of zones and sensors in the first step by selecting some zone as a root and traversing the input zone - sensor relations breadth - first .",
    "then , a depth - first search selects the next unassigned zone or sensor in the order and assigns it to a new unit . if the assignment can not be done due to a violation of requirement ( 2 ) , then the already used units are tested starting from the last created one . in case quickpupis not able to assign a zone or sensor to any unit it unrolls the last made assignment and tries another possibility .",
    "finally , if no more assignments are possible , quickpupfalls back to the default heuristic . *",
    "@xmath80is a modification of quickpupthat tests already used units first and a new one afterwards .",
    "* pred  @xcite tries first to connect an unassigned zone or sensor to one of the units that already have connections to neighbour zones or sensors , i.e.  reachable over at most two input zone - sensor relations .",
    "if this fails , predtries a new unit first and used ones subsequently .",
    "[ [ implementation - details . ] ] implementation details .",
    "+ + + + + + + + + + + + + + + + + + + + + + +    we implemented the four heuristics in waspusing the c++ interface given in section  [ sec : heur ] .",
    "a heuristic is initialized as onsearch(@xmath65 ) event is invoked by the solver .",
    "next , the ordering of vertices is generated and used to determine sets of chosen literals @xmath9 in response to getchoice(@xmath13 ) requests .",
    "in addition , a heuristic registers onunrolllit(@xmath2 ) events in order to synchronize its inner state with decisions made by waspbetween two subsequent getchoice(@xmath13 ) requests .",
    "if a heuristic finds that the current partial interpretation is inconsistent , i.e.  no further assignments can be made , it backtracks and sends # unroll(@xmath2 ) to wasp . in this case , @xmath2 is one of the literals that were selected by a heuristic at the previous choice event .",
    "finally , the fallback from quickpup - based heuristics to the default one was implemented using # fallback(@xmath81 ) response .    [ [ setup . ] ] setup .",
    "+ + + + + +    the evaluation was done by using the set of instances provided by siemens .",
    "this package comprises instances of four types : ( 1 ) double , ( 2 ) double - variant , ( 3 ) triple and ( 4 ) grid .",
    "the first three types are instances representing topologies occurring frequently in practice , whereas grids are parts of real railway systems ( see  @xcite for details ) .",
    "the instances were tested with two encodings : pup - e1  the original straightforward encoding published in  @xcite ( section 3.1 , p.  6 ) and",
    "pup - e2  a complex encoding comprising symmetry breaking and ordering rules used in the asp competition 2015 .",
    "moreover , in all experiments with waspusing heuristics , we removed rule 9 ( line 14 ) from pup - e2 .",
    "this rule is a symmetry breaker that does not allow our heuristics to select the starting zone . for each encoding we grounded all instances with gringo(version 4.5.3 ) .",
    "then each solver was run for 900 sec .   on a system equipped with i7 - 3030k cpu , 64 gb ram and ubuntu 11.10 .",
    "[ [ results . ] ] results .",
    "+ + + + + + + +    a summary of our evaluation results is presented in figures  [ fig : eval : a ] and [ fig : eval : b ] .",
    "the results of clasp  @xcite , which was used as a reference system , show that it was able to solve at most 23 instances using the tested encodings .",
    "moreover , in both experiments claspfailed to find a model for most of the double as well as for some double - variant and triple instances .",
    "also waspwith quickpupsolved only 12 and 15 instances using pup - e1 and pup - e2 respectively .",
    "the main reason for this discrepancy between our results and the ones obtained by  @xcite is due to inability of the underlying asp solver to generate new units on - the - fly .",
    "therefore , the number of ground literals denoting available units is determined in the grounding step and can not be changed later .",
    "@xcite , instead , try to quickly build a solution by using new units whenever possible .",
    "this strategy appears to be successful for greedy algorithms , but works poorly as a heuristic for wasp .",
    "the two remaining heuristics assign zones and sensors to already existing units first .",
    "this allowed waspto outperform claspand quickpupin all experiments .",
    "the best result was observed for waspwith pred , which solved _ all _ instances independently of the encoding .",
    "moreover , pup - e2 allowed waspto reduce its average solving time to only 27 sec . finally , we would like to emphasize the fact that predallowed waspto find solutions for all instances with the pup - e1 encoding .",
    "this is an important feature of our approach .",
    "it allows a programmer to easily model a problem using a declarative language , like asp - core , and then to scale performance of the solver using heuristics defined in a procedural way .",
    "similarly to the pup , this problem was derived from a number of real - world problems including railway interlocking systems , safety automation , resource distribution , etc .",
    "the ccpis an abstract problem that demonstrates an important case occurring in practice of siemens when a complex problem can be represented as a set of subproblems  @xcite .",
    "a ccpinstance is defined by a directed acyclic graph @xmath82 representing a track layout ( see figure  [ fig : ccp ] ) .",
    "each vertex has a type , e.g.  @xmath83 and @xmath84 , with an associated size , e.g. 1 and 3 .",
    "furthermore , an instance includes two disjoint paths @xmath85 and @xmath86 , shown in red and green , as well as several sets of border elements , e.g.  @xmath87 and @xmath88 .",
    "finally , it defines parameters specifying a maximal number of border elements per safety area @xmath89 , a number of colors @xmath90 , a number of available bins @xmath91 per color and capacity of a bin @xmath92 .",
    "the goal is to find a solution that satisfies all requirements of the following subproblems :    ( p1 ) coloring : :    every vertex must have exactly one color .",
    "( p2 ) bin - packing : :    for every set @xmath93 comprising all vertices of    one color , assign each vertex @xmath94 to exactly one    bin such that for each bin the sum of the vertex sizes is less or    equal to @xmath92 and at most @xmath91 bins are used .",
    "( p3 ) disjoint paths : :    colors of any two vertices @xmath95 and    @xmath96 must be different .",
    "( p4 ) matching : :    for every input set of border elements @xmath97    find a safety area @xmath98 such that    all border elements of one area are colored in one color ,    @xmath99 and every border element is exactly in one    area .",
    "( p5 ) connectedness : :    two vertices of the same color must be connected via a path that    comprises only vertices of this color .",
    "let the sample ccpinstance comprise the following parameters : @xmath100 , @xmath101 , @xmath102 and @xmath103 .",
    "the solution presented in figure  [ fig : ccp ] assigns 3 colors to vertices , places them into 2 bins , shown in subscript of each vertex , and defines two safety areas @xmath104 and @xmath105 .",
    "[ [ heuristics.-2 ] ] heuristics .",
    "+ + + + + + + + + + +    the ccphas a number of heuristics suggested in  @xcite which can be used to obtain a partial solution of a problem instance .",
    "it turned out that it is quite simple to find a heuristic that solves one or some of the subproblems .",
    "however , no complete heuristics , like quickpupor predfor pup , are known for ccp .",
    "the heuristics suggested in  @xcite were designed to be used with the heuristic interface of clasp .",
    "this interface allows a programmer to define a heuristic function in the program using @xmath106 predicate .",
    "if a ground `` heuristic '' atom over this predicate becomes true in a partial interpretation , then terms of the atom are used by claspto modify behavior of the vsidsheuristic .",
    "therefore , given a ccpinstance , the proposed approach first runs a heuristic search method to find a partial solution of the instance .",
    "next , claspis forced to start the search from the found partial solution by expending the ccpinstance with facts comprising `` heuristic '' atoms representing it .",
    "gebser et al .",
    "@xcite use three heuristics :    * a1 solves the matching problem ( p4 ) . in every iteration it assigns an unassigned border element to a safety area which comprises the minimum number of already assigned elements . *",
    "this heuristic is designed to solve three subproblems ( p1 ) , ( p2 ) and ( p5 ) .",
    "first , it sets the color to 1 and adds some vertex @xmath107 to a queue @xmath108 .",
    "next , it retrieves an element @xmath109 , assigns it the current color , places it to a bin according to the best - fit heuristic and adds all uncolored neighbors of @xmath110 to @xmath108 .",
    "the process continues , until no further vertices can be placed to bins . in this case",
    "the algorithm increases the value of current color and adds some uncolored node @xmath111 to @xmath108 . *",
    "this is a combination of the previous two which first applies a1 and then uses a2 to extend the output of a1 .",
    "all original heuristics were designed to run only once prior to solving whereas in our solver a heuristic is queried multiple times .",
    "therefore , we suggest the following modifications :    * a2fis based on a2 which is extended with a fallback to a default solver heuristic if ( i ) a partial solution is found or ( ii ) the 10 seconds timeout is reached or ( iii ) a2 can not make a choice",
    ". the latter situation might occur if all atoms used in subproblems ( p1 ) , ( p2 ) and ( p5 ) already have assigned truth values . *",
    "originally a2fprocesses the vertices of @xmath112 in no specific order . to increase its performance we extended a2fwith an ordering that assigns a score of @xmath113 to all vertices with only incoming or outgoing edges , a score of @xmath114 , it is in a path , and",
    "@xmath115 , if both applies .",
    "then , a2foruns a2fsuch that in every iteration it sorts the unprocessed vertices in the decreasing order of their scores . * a2afo . this version of a2fouses a fallback strategy which alternates between a2foand a default solver heuristic .",
    "thus , a2aforuns a2fowith the first ordering until it can not make any further choices .",
    "then , it switches to the default heuristic for the next 10 seconds .",
    "if solver was unable to get a complete solution within this time , a2afocreates a new ordering and executes a2foonce more . in the case",
    "all possible orderings starting with vertices with a score higher than zero has been used , a2afofalls back to the default heuristic permanently .",
    "the idea is to allow the default heuristic of the solver to acquire enough representative conflicts and hence to improve its performance .",
    "[ [ implementation - details.-1 ] ] implementation details .",
    "+ + + + + + + + + + + + + + + + + + + + + + +    the heuristics were implemented similarly to the ones used for the pupusing the c++ version of the waspinterface . when a2afodecides to use the default solver heuristic , it starts a timer and responses all getchoice(@xmath13 ) requests with # fallback(@xmath116 ) . when the timeout is reached , a2afogenerates another ordering , restarts the search using # unroll(@xmath1 ) and answers all subsequent requests itself .",
    "[ [ setup.-1 ] ] setup .",
    "+ + + + + +    we evaluated a2f , a2foand a2afoon the set of hard instances and the encoding submitted to the asp competition 2015 .",
    "the package contains a set of real - world instances used in the evaluation of  @xcite as well as a number of new instances .",
    "the latter have a grid - like graph structure in which all vertices are of the same type .",
    "the evaluation was done in the same settings as the pupand similar to  @xcite .",
    "the average grounding time was about 2 seconds and is excluded from results .",
    "[ [ results.-1 ] ] results .",
    "+ + + + + + + +    the evaluation results , presented in figure  [ fig : eval : c ] , show that the reference system could solve 3 out of 36 instance with an average solution time of 246 sec .",
    "our approach using a2f , a2foand a2afoheuristics was able to solve 22 , 27 and 36 instances with an average solution time 6 , 7 , and 14 sec .",
    "a2afoheuristic has a greater solving time only because it was able to solve the hardest instances .",
    "our approach shows also better results in comparison with  @xcite , which solved 6 out of 16 real - world instances .",
    "moreover , since a2afois based on an alternating usage of two heuristics we performed an additional evaluation . the goal was to test whether conflict learning is essential or the heuristic has to find a `` correct '' ordering as it was often the case for pupheuristics .",
    "therefore , we saved the last ordering a2afoused before the last fallback and then started a new experiment in which this ordering was used first .",
    "the results show that in none of the experiments this strategy allowed waspto find a solution with only one fallback . in all test cases a2aforun a2",
    "at least twice , i.e.  generates at least two orderings , to find a solution .",
    "this indicates that learned clauses are essential .",
    "the branching heuristic is a key ingredient of the cdcl algorithm . despite several effective heuristics",
    "have been proposed in the literature , their integration in existing solvers is usually nontrivial .",
    "the paper proposed a novel framework that simplifies the design of new heuristics for cdcl solvers by distilling the key ingredients useful to drive the search .",
    "the proposal has been validated in a case study where our framework was employed for solving effectively two hard industrial problems .",
    "results are positive : hard instances that were not solvable by previous approaches are efficiently solved by our implementation .",
    "ongoing work concerns the implementation of our framework in other well - known solvers .",
    "moreover , we plan to apply it in further practical use cases .",
    "this work was partially supported by the carinthian science fund ( kwf ) contract kwf-3520/26767/38701 , the austrian science fund ( fwf ) contract i 2144 n-15 , the italian ministry of university , research under pon project `` ba2know ( business analytics to know ) service innovation  lab '' , no .",
    "pon03pe_00001_1 , and by the italian ministry of economic development under project `` piucultura ( paradigmi innovativi per lutilizzo della cultura ) '' n.  f/020016/0102/x27 ."
  ],
  "abstract_text": [
    "<S> the cdcl algorithm is the leading solution adopted by state - of - the - art solvers for sat , smt , asp , and others . </S>",
    "<S> experiments show that the performance of cdcl solvers can be significantly boosted by embedding domain - specific heuristics , especially on large real - world problems . </S>",
    "<S> however , a proper integration of such criteria in off - the - shelf cdcl implementations is not obvious . in this paper </S>",
    "<S> , we distill the key ingredients that drive the search of cdcl solvers , and propose a general framework for designing and implementing new heuristics . </S>",
    "<S> we implemented our strategy in an asp solver , and we experimented on two industrial domains . on hard problem instances , </S>",
    "<S> state - of - the - art implementations fail to find any solution in acceptable time , whereas our implementation is very successful and finds all solutions . </S>"
  ]
}