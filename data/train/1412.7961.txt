{
  "article_text": [
    "due to the advances in sensor technology which have resulted in affordable and easy - to - use sensors , a large segment of research has often been focused on integration of sensors in other intelligent systems .",
    "such systems may consist of a mobile system , such as a robot or a distributed system of heterogeneous networked sensors , such as a smart home . regardless of their purposes , applications of smart environments",
    "a.k.a context - awareness applications are common in continuous observation of the environment , and consequently , in issues related to the sensor observation process @xcite .",
    "therefore , the representation and reasoning model suggested for these applications need to be able to deal with the issues such as data incompleteness , lack of observation and the dynamic situation of smart environments .    in this paper , we present a knowledge driven approach to reasoning about changes detected in the quality of the pervasive air in a smart environment .",
    "the smart environment is a kitchen equipped with a sensor network including a gas sensor which is continuously sniffing the ambient air . by modelling high level knowledge about odours , their causes , and relations to other phenomenon",
    ", it is possible to assist the interpretation of the gas sensor signals .",
    "however , to automate this process , the high level ( symbolic ) knowledge needs to be seamlessly connected to the lower level sensor ( quantitative ) data . furthermore suitable reasoning techniques are also required in order to infer information beyond that which is measured by the gas sensors or the sensor network .",
    "automated reasoning is achieved via answer set programming ( asp ) .",
    "the motivation to using asp is twofold .",
    "first , the proposed application should deal with incomplete data caused by uncertain behaviour of sensors or the lack of observations .",
    "second , the dynamic nature of the sensor network should be taken into account where new observations can influence the reasoning process and if necessary invalidate previously inferred results . in our proposed paradigm , a non - monotonic reasoner is advocated and asp has the further advantage of using an incremental solver which is suitable for stream reasoning @xcite .",
    "the necessary high level knowledge for the reasoner is modelled within an ontology inspired by the semantic sensor network ( ssn ) @xcite .",
    "the proposed ontology provides the basis for declarative definition of entities , features and events in the environment .",
    "also , this ontology enables a reuse of information , compatible with the emerging trend of linking contextual information to sensor data seen in the internet of things ( iot ) paradigm .",
    "the goal of the proposed knowledge representation and reasoning paradigm is important given the trend iot towards a global connectivity between objects from the physical world . as more sensors of varying modality",
    "become connected , it will be of importance to provide automated interpretation of the sensor data and to exploit existing resources to this aim if possible . however , the integration of ontology languages such as owl - dl with non - monotonic reasoning is non - trivial .",
    "therefore a contribution in this work is to implement a conversion between owl - dl ontologies and the incremental asp reasoner .",
    "this paper is organized as follows . in section  [ sec : relatedworx ] we study the related work . the essential components required for implementation of a smart environment are explained in section  [ sec : architecture ] .",
    "section  [ sec : reasoningodours ] describes the details of the reasoning process .",
    "the evaluation results of the proposed approach are discussed in section  [ sec : results ] which is continued by the conclusion .",
    "the relevant subset of works such as @xcite deal with semantic web technologies , and the areas of the semantic sensor web .",
    "these works propose to semantically annotate sensor data with semantic annotations published on the semantic web ( semantic sensor web ) . in this way ,",
    "interoperability between sensor networks and consequently the situation awareness increases in this domain , ontologies are the most popular method to achieve such structures . for example , the semantic sensor network ( ssn ) ontology is a suggestion from the w3c semantic sensor networks incubator group ( ssn - xg ) @xcite for representing the sensor data independent of the domain knowledge .",
    "the concentration of the ssn ontology is on sensors ( and their capabilities ) , observations , and systems rather than the domain - dependent concepts .    due to the expressivity of the ontology languages such as owl - dl , definition of concepts , relations and axioms in the domain knowledge",
    "are declarative . in order to reason upon this knowledge ,",
    "therefore , an expressive reasoning technique is required .",
    "all the deductive ( monotonic ) reasoners based on description logic ( dl ) implemented for ontologies , depending on their formalisations , provide different degrees of complexity and expressiveness .",
    "nevertheless , applications need to deal with the issue of incomplete data caused by inherently uncertain behaviour of sensors or the lack of observation .",
    "furthermore , the dynamic behaviour of sensory systems where the newly added observation can influence the reasoning process such that the new reasoning outputs may contradict the previously inferred results , indicates the need for non - monotonic reasoning techniques .",
    "recently , hybrid approaches to combining monotonic and non - monotonic reasoning have been proposed .",
    "for example , @xcite combine a handmade ontology representing high level concepts and the asp solver as a non - monotonic reasoner to reason over sensor data .",
    "these works illustrate the potential of asp to cope with stream reasoning . in this paper ,",
    "in addition to using an incremental asp solver @xcite , we utilize an ontology synonymous to the ssn ontology and provide the means to automatically generate the logic used by the solver .",
    "this section provides a high level view of the system architecture depicted in fig .  [",
    "fig : framework ] .",
    "the input is the sensor data from the sensor network and the output is the annotations that consist of the reasoner s explanations to changes detected in the gas sensor ( target sensor ) .",
    "the system architecture consists of three blocks : _ a ) observation process _ , _ b ) data / knowledge integration _ and _ c)reasoning _ that are described in the following sections .",
    "the observation process of a smart home is performed through a set of heterogeneous sensors which are synchronously and continuously observing the environment .",
    "each object in the smart home , depending on its attributes of interest can be observed by one or several sensors .",
    "sensors include motion detectors , luminosity sensors , temperature sensors , magnetic contacts etc . in order to lighten the data load , instead of continuously sampling of data , we chose the event capturing approach which is accomplished by passing the data stream through the change detection process ( see fig .",
    "[ fig : framework ] ) . in section  [ sec : cumulative ] ,",
    "we show how each data point related to a change in the signal is represented in form of a _ manifestation _ considered as an event . although the data output of an event capturing approach is not as complete as the data in the continuous data sampling approach , it is possible to cope with gaps in the sensor output via asp in handling incompleteness of data .          both time dependent and independent concepts are modelled within the processes in block _ b_. the static knowledge which represents the time independent concepts are related to the observed phenomena and their properties .",
    "the cumulative knowledge represents the time dependent concepts related to observations in the sensor data and events . for the sake of facilitating the transformation from the ontology to the solvable logic program by the incremental asp solver , we separate the representation of static knowledge from the cumulative knowledge .",
    "the ontology depicted in fig .",
    "[ fig : upper - ontology ] is made up of two layers , namely a context layer and a sensor layer .",
    "the context layer specifies general facts about the context along with their constraints , whereas the sensor layer contains concepts with quantitative values related to sensors .        _ * context layer : * _ the class _ object _ , in the ontology refers to all entities that can be a source of an event ( detected by the target sensor ) in the environment .",
    "for instance : a freezer is considered as an object ( _ freezer _",
    "_ ) , since its stuff inside can be rotten and smell .",
    "each object is defined based on a set of attributes such as temperature ( _ temperature _ @xmath0 _ attribute _ ) , illumination or electric - current , whose situations are significant in event definition . the situation of attributes , furthermore , are defined as individuals of the class _ state _ which independent of the sensor values , represent all possible situations ( e.g. , _ cold _ , _ warm _ , _ dark _ ) of an attribute . as mentioned before , there is at least one sensor in the environment ( e.g. , a gas sensor ) whose data is targeted for the interpretation process .",
    "the difference between modelling the target sensor data and the others is in definition of their states . for the target sensor ,",
    "the possible states are limited into two _ normal _ and _ abnormal _ states .",
    "once the sensor data is out of the value range of the _ normal _ state , the state is switched into _ abnormal _ which needs to be interpreted .    _",
    "* sensor layer : * _ the sensor layer ( fig .  [ fig : upper - ontology ] ) , contains concepts representing quantitative sensor - related data .",
    "the class _ sensor _ is responsible for holding sensors information used for the observation process .",
    "individuals of the class _ state _",
    "( e.g. , _ cold _ , _ warm _ ) symbolically explain objects in terms of their attributes situations .",
    "however , since it is the sensor output which shows the state of the observed object , we need to create a link between the symbolic states and the real observation values . for this , we define the _ measuredstate _ class whose individuals relate sensor values to specific states .",
    "each individual of the _ measuredstate _ class has two properties , _ minimumsensorvalue _ and _ maximumsensorvalue _ , providing a range of values for a state .",
    "for example , the triple _",
    "( min=1 , max=3 , forstate = cold ) _ creates a _ measuredstate _ instance which is related to a particular sensor via the _ hasmeasuredstate _ property .",
    "the cumulative knowledge takes events captured by the change detection and translates them into symbolic concepts that either denote _ explicitevents _ called _ manifestations _ or _",
    "implicitevents_. an explicit event is one which is directly measured by the sensors .",
    "for instance , whenever the temperature of the freezer changes from a cold state to a warm state , the change detection component generates a manifestation such as _ m:(freezer , temperature , cold , t ) _ , regardless of the range of sensor data for a cold freezer .",
    "the last property of the manifestation class is the _ timestep _ ( _ t _ ) which is related to the incremental step considered by the reasoner .",
    "the subclasses of the _ manifestation _ class are generated by literally combining the the name of object , attribute and state concepts involved in the event .",
    "for example , a tentative manifestation can be _ freezertemperaturewarm _ which indicates an event related to a freezer ( object ) whose temperature ( attribute ) gets warm ( state ) .",
    "the _ implicitevent _ class addresses those events that are not directly observable by sensors but triggered based on a rule set that consists of explicit events .",
    "for example , in case of a kitchen , events such as _ cooking _ and _ rotting _ are defined as subclasses of the _ implicitevent _ class , and are the main events that cause a change in the quality of the kitchen s ambient air .",
    "each _ implicitevent _ so as to be inferred by the reasoner , needs a set of specific a priori conditions to be detected in the environment .",
    "these pre - conditions are characterized as instances of the _ eventtemporalcondition _ class .",
    "two properties , _ startingcondition _ and _ endingcondition _ ( fig .",
    "[ fig : upper - ontology ] ) , relate an implicit event to its conditions which indicate the situations required for inferring the event started or ended , respectively .",
    "the class _ eventtemporalcondition _ as such is related to manifestations . in other words , an event s conditions are defined based on manifestations . therefore , the class _ eventtemporalcondition _ , has one relation with the _ manifestation _ class via the _ hasmanifestation _ property .",
    "moreover , the detection of an event s preconditions is expected to be during a specific time around the time step of the event .",
    "therefore , each precondition is also assigned with two integer values indicating the lower and upper bound of a range for the event time step .",
    "the preconditions of each implicit event inferred at time step _",
    "t _ , can happen either at the same time step or before it . in case of the coincidence , the two integer values",
    "are set to zero , otherwise they are set to positive numbers .",
    "for example , given _ rotting _ as an implicit event , we define a subclass for _ eventtemporalcondition _ , e.g. , etc1 .",
    "one of the manifestations that can be related to the rotting process is _ freezertemperaturewarm_. in order to infer _ rotting _ at time step _",
    "its manifestation , for example , has to be detected between time step _",
    "t - b _ and _ t - a _ where both _ a _ and _ b _ ( @xmath1 _ a _ @xmath2 _",
    "b _ ) are integer values assigned to the class ect1 via the _ uppertimestep _ and the _ lowertimestep _ properties by the user , respectively . as shown in fig .",
    "[ fig : upper - ontology ] , each implicit event is assigned to one or several _ eventtemporalcondition _ concepts via its _ startingcondition _ and _ endingcondition _ properties .",
    "these relations between implicit events and their conditions are set by the user based on the features of the scenario .",
    "further details about implicit events are given in section  [ sec : reasoningodours ] .",
    "in this section , the details about the conversion process and the reasoning process , depicted in block _ c _ ( fig .",
    "[ fig : framework ] ) , are discussed based on the notations explained in previous sections .      in order to generate the base logic program @xmath3 which is time independent , for each individual object ,",
    "attribute and state defined as the static knowledge in the ontology , two logical literals including a fact and a unary predicate are added to the program @xmath3 as follows :    & _ o _ _ o _ _ object _ _ b _ = _ b _ \\{_o _ , _",
    "o(o ) _ } + & _ a _ _ a _ _ attribute _ _ b _ = _ b _ \\{_a _ , _",
    "a(a ) _ } + & _ s _ _ state _ _ b _ = _ b _ \\{_s _ , _",
    "state(s ) _ }    therefore , the final @xmath3 logic program will contain a set of both unary and binary grounded predicates .      the cumulative logic program represented with @xmath5",
    "is generated by time dependent concepts in the ontology .",
    "time dependent concepts containing the time step parameter @xmath6 in their definitions include both the explicit ( manifestation ) and the implicit events .",
    "the logic program @xmath5 is incrementally extended meaning that whenever an explicit event is captured , a manifestation indicating an object , its attribute and its state at time step _ t _ , is converted into an appropriate predicate and extends @xmath5 with a new manifestation predicate as follows :    @xmath7    moreover , whenever a manifestation is generated , a rule based on the pattern @xmath8 shown in the following is added to the program @xmath5 .",
    "this rule allows the solver to infer appropriate explicit events related to the manifestation .",
    "the head of the logic rule , _",
    "o_a_s(t ) _ , indicates a predicate whose name is generated by concatenating the name of the subclass of the class _ object _ ( @xmath9 ) , the name of its attribute ( @xmath10 ) and the state name ( @xmath11 ) .",
    "the integer value @xmath6 of @xmath4 $ ] refers to the last parameters in a manifestation which correspond to the time step at which the change is captured .    &",
    "r_1 : o_a_s(t ) : - manifestation(x , y , s , t ) , o(x ) , a(y ) .",
    "apart from explicit events , implicit events ( e.g. , _ rotting _ ) also have a considerable impact on extension of the program @xmath5 .",
    "since implicit events are not directly observable via sensors , and are defined based on temporal relations between explicit events , the time difference plays an essential role in their definition .",
    "for instance , the event _ rotting _ starts after passing a specific amount of time ( e.g. , 1 day ) when the explicit event _ freezertemperaturewarm _ has been detected .",
    "therefore , for the sake of inferring implicit events and measuring the time difference between events , we need to continuously sample sensor data",
    ".    nevertheless , as mentioned in section  [ sec : sensornetwork ] , to hinder the reasoner to be overwhelmed with data , instead of continuous data sampling , we chose the event capturing approach . compensating the lack of continuous data sampling",
    "is achieved by defining each implicit event within three logical rules .",
    "the two first rules indicate the conditions required for inferring the starting and the ending of an implicit event , respectively .",
    "these conditions are defined in the ontology as the relations between an implicit event and manifestations . as we can see in fig .",
    "[ fig : upper - ontology ] , the _ implicitevent _ class is related to the _ manifestation _ class via the _",
    "eventtemporalcondition_. the body part of the first rule which indicates the conditions required to infer an implicit event s inception , is generated based on the conjunction of all manifestations that are connected to the instances of the _ eventtemporalcondition _ class via the _ startingcondition _ property .",
    "likewise , the body part of the second rule regarding the ending conditions of an implicit event , is the conjunction of all manifestations , that are related to the _ eventtemporalcondition _ class , however , via the _ endingcondition _ property .",
    "for instance , assuming the following axioms are defined in the ontology , we generate the two first rules for the implicit event _ garbage _ :    for instance , the rules @xmath12 and @xmath13 related to the inception and ending of the _ garbage _ event will be as follows :    & r_2 : garbage(t ) : - trashbindooropen(t ) , trashbinilluminationdark(t ) .",
    "+ & r_3 : garbageend(t ) : - garbage(t-1 ) , trashbindooropen(t ) , trashbinilluminationbright(t ) .",
    "the third rule ( @xmath14 ) , also indicates the event progression conditions .",
    "the term `` implicitevent '' in @xmath14 refers to a predicate equivalent to an _ implicitevent _ concept ( e.g. , _ garbage _ ) ) :    & r_4 : implicitevent(t ) : - implicitevent(t-1 ) , not impliciteventend(t ) .",
    "implicit events which can declaratively express the ambient smell in the kitchen are used as meaningful explanations for changes detected over the gas sensor . in order to infer that the smell of an implicit event is sensed ,",
    "two conditions have to hold : first , the truth of a manifestation denoting an abnormal state for the target object ( _ airsmellabnormal _ ) at the current time @xmath6 , and second , the truth of an implicit event :    & r_5:smellimplicitevent(t ) : - airsmellabnormal(t ) , implicitevent(t ) .    however , there are situations in which we can not infer the truth of an implicit event , its smells still stays in the environment . due to gradually fading of smells , apart from @xmath15 which indicates the preliminary conditions for the _ smellimplicitevent _ predicate , the rule @xmath16 is also added to the program @xmath5 .",
    "the term `` value '' refers to an integer value showing an approximate time interval during which the smell , even after ending the event , normally stays in the ambient air .",
    "this value is set in the ontology for an implicit event instance , via the _ effectlifespan _ property ( fig .",
    "[ fig : upper - ontology ] ) :    & r_6:smellimplicitevent(t ) : - airsmellabnormal(t ) , smellimplicitevent(t-1 ) , + & 1\\{impliciteventend(t - value .. t)}.    in order to interpret the smell of an inferred implicit event and explain the current state of the ambient air , the following rule ( @xmath17 ) which is defined for each _ smellimplicitevent _ predicate , is also added to the program @xmath5 :    & r_7:explained(t ) : - smellimplicitevent(t ) .    due to",
    "many reasons such as the lack of observations , or misreading of sensors , along with the aforementioned rules , we also add the two last rules ( @xmath18 and @xmath19 ) to the cumulative part of the logic program . in this way",
    ", the answer set will always contain either the _ airsmellnormal _ or _ airsmellabnormal _ as a description of the ambient air . the later , depending on the inference results , can be accompanied by the other explanations .    &",
    "r_8:explained(t ) : - airsmellabnormal(t ) .",
    "+ & r_9:explained(t ) : - airsmellnormal(t ) .      in order to guarantee having an explanation for the ambient air at each time step",
    ", the conversion process generates the volatile program @xmath20 $ ] .",
    "given the predicate _ explained(t ) _ , the volatile part of the logic program will be modelled as given below .",
    "according to the integrity constraint rule given in the volatile part , the asp solver needs to always provide an explanation , otherwise it ends up with dissatisfaction . for this , the solver successively accept new manifestations until the _ explained _ predicate is inferred which consequently implies the inference of a smell .    & # volatile t. + & : - not explained(t ) .",
    "for experimental validation of the proposed method , a smart kitchen equipped with a set of sensors including a gas sensor using zigbee wireless communication standard is deployed .",
    "two batch measurements have been performed .",
    "the first batch is a three day run and the second batch is a five day run . the purpose of the system is to annotate each change detected by the gas sensor with an explanation that outlines the possible reasons for the change .",
    "[ fig : experiment1 ] visualizes the events along with their causes for the three day experimental run .",
    "illustrated in the legend , continuous lines are divided into two main types representing the normal ( in green ) and abnormal ( in red ) smells . as we explained in section",
    "[ sec : programp ] , in case of an abnormal smell , the answer set may be augmented with inferred implicit events as the cause of the detected smell which are represented in different colors in fig .  [",
    "fig : experiment1 ] .",
    "the relation between a cause and its relevant inference results is also shown in dotted lines .",
    "[ table : experiment1 ]     description ) + & ... & ... & ... & ... + & 11:36 & 16560 & manifestation(oven1 , electriccurrent , on , 16560 ) . & airsmellnormal(16560 ) .",
    "+ & & & manifestation(oven1 , motion , on , 16560 ) . &",
    "+ & 12:36 & 20160 & manifestation(trashbin1 , illumination , dark , 20160 ) . & airsmellabnormal(20160 ) .",
    "+ & & & manifestation(trashbin1 , door , open , 20160 ) . &",
    "* smellcooking*(20160 ) .",
    "+ & ... & ... & ... & ... + & 03:16 & 72960 & manifestation(kitchenair1 , smell , abnormal , 72960 ) . & airsmellabnormal(72960 ) .",
    "+ & ... & ... & ... & ... + & 15:20 & 116400 & manifestation(kitchenair1 , smell , abnormal , 116400 ) . & airsmellabnormal(116400 ) .",
    "+ & & & & * smellrotting*(116400 ) .",
    "+ & 16:58 & 122280 & manifestation(kitchenair1 , smell , abnormal , 122280 ) & airsmellabnormal(122280 ) .",
    "+ & & & & * smellrotting*(122280 ) .",
    "+ & & & & * smellgarbage*(122280 ) .",
    "+ & ... & ... & ... & ... + & 15:52 & 204720 & manifestation(trashbin1 , illumination , bright , 204720 ) . & airsmellabnormal(204720 ) .",
    "+ & & & manifestation(trashbin1 , door , open , 204720 ) . & * smellrotting*(204720 ) . + & & & & * smellgarbage*(204720 ) .",
    "+ & 17:12 & 209520 & manifestation(kitchenair1 , smell , abnormal , 209520 ) . & airsmellabnormal(209520 ) .",
    "+ & & & & * smellrotting*(209520 ) .",
    "+    the incremental reasoner provides the answer set for the set of manifestations given at the specific time step .",
    "the answer set expresses the smell in the environment if there is an _",
    "abnormal _ smell , otherwise it expresses the situation as _",
    "normal _ smell .",
    "for instance , at the first step ( @xmath21 ) the initial states of each objects attributes in form of descriptive manifestations are given .",
    "the reasoner results in @xmath22 , meaning that the state of the ambient air at @xmath21 ( or first day at @xmath23:@xmath24 ) , is _",
    "normal_. on the same day , at @xmath25 ( @xmath26:@xmath27 ) , two manifestation indicating the oven is on and some one is moving around , are reported . according to the implicit events definition , the event _ cooking _",
    "is hence inferred at @xmath26:@xmath27 ( fig .",
    "[ fig : experiment1 ] ) .",
    "however , since no abnormal smell in the air is reported , the current ambient air is explained as _",
    "normal_. there are many situations that due to the lack of space we can not go through their details .",
    "table  [ table : experiment1 ] partially shows the answer sets of each time step considered as the explanations for the quality of the ambient air .    in order to further study the performance of the reasoner",
    ", we extended the experiments with the second package of data containing @xmath28 days of observations .",
    "depending on the data package , the ontology contains different amount of individuals . since the event based classes are time dependent , the number of their individuals depends on several parameters including the length of the observation process , the number of events happen in the environment , and the measuring unit of time in the observation process . for the three - day observation , the number of events individuals is @xmath29 , and for a longer observation ( @xmath28 days ) , this number increases to @xmath30 .    in the following",
    "we compare the reasoning time of our system based on the incremental asp solver with that of the monotonic ontology reasoner , pellet @xcite . using the negation as failure ( naf ) operator ( which provides the closed world assumption ) , the reasoner results in less number of grounded individuals whereas a deductive reasoner based on open world assumption ends up with @xmath31 individuals for the same package of data .",
    "the number of required individuals in a deductive reasoner is the ratio of the number of time steps @xmath6 between the two time steps at which the implicit event starts and ends ( @xmath32 ) . in fig .",
    "[ fig : individuals ] the number of individuals increasing during the observation process is shown for both types of reasoners .",
    "the incremental solver , furthermore , extends the grounded logic program ( which contains no variable but the individuals ) incrementally and enables the reasoning process to only consider the recently added manifestations ( events ) during the solving process , rather than the entire grounded individuals .",
    "[ fig : reasoningtime ] shows the difference of the reasoning time between the deductive pellet ontology reasoner and the asp incremental solver .",
    "therefore , in addition of the re - usability feature , our ontology - based knowledge representation and reasoning approach provides a considerable efficiency in reasoning time which consequently enhances the scalability of the system .",
    "the key point in this work is enabling non - monotonic reasoning over an ontology which is inspired from the ssn ontology . integrating the ontology with the asp solver provides the opportunity of intuitively modelling the environment at different phases of the process .",
    "the incremental asp solver also enables the encoding of the environment s history incrementally which leads into an efficient reasoning time .",
    "the asp semantics , in addition , simplifies the automated creation process of the logic program .",
    "the whole logic program except the implicit events creation is done automatically .",
    "the manually added rules related to implicit events are also defined based on the combination of the existing expressive predicates that state explicit events .",
    "however , the temporal relation between manifestations can be further developed .",
    "if the number of states of an object increases , the number of rules considering temporal relation between events and their causes also grows . extending the temporal relations between events , as our future work , can leads to a more enriched temporal reasoning .",
    "m.  compton and p.  barnaghi and l.  bermudez and r.  garcia - castro and o.  corcho and s.  cox and j.  graybeal and m.  hauswirth and c.  henson and a.  herzog and v.  huang and k.  janowicz and w.  kelsey and d.  phuoc and l.  lefort and m.  leggieri and h.  neuhaus and a.  nikolov and k.  page and a.  passant and a.  sheth and k.  taylor , _ the ssn ontology of the w3c semantic sensor network incubator group_. j.web semantics : science , services and agents on the world wide web ( 17 ) , p.25 - 32 , elsevier , 2012 .",
    "m.  gebser and t.  grote and r.  kaminski and ph .",
    "obermeier and o.  sabuncu and t.  schaub , _ stream reasoning with answer set programming : preliminary report_. proc .",
    "13th int . conf . on the principles of knowledge representation and reasoning ( kr ) , aaai press , 2012"
  ],
  "abstract_text": [
    "<S> in this paper an ontological representation and reasoning paradigm has been proposed for interpretation of time - series signals . </S>",
    "<S> the signals come from sensors observing a smart environment . </S>",
    "<S> the signal chosen for the annotation process is a set of unintuitive and complex gas sensor data . </S>",
    "<S> the ontology of this paradigm is inspired form the ssn ontology ( semantic sensor network ) and used for representation of both the sensor data and the contextual information . </S>",
    "<S> the interpretation process is mainly done by an incremental asp solver which as input receives a logic program that is generated from the contents of the ontology . </S>",
    "<S> the contextual information together with high level domain knowledge given in the ontology are used to infer explanations ( answer sets ) for changes in the ambient air detected by the gas sensors .    </S>",
    "<S> sensor ontology , non - monotonic reasoning , answer set programming , knowledge representation    = 1 </S>"
  ]
}