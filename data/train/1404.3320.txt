{
  "article_text": [
    "linear programming was famously solved in the late 1940s by dantzig s simplex method @xcite ; however , many variants of the simplex method were eventually proved to have exponential worst - case performance @xcite , while , around the same time , karp s 1972 paper on np - completeness @xcite mentions linear programming as a rare problem in np which resists classification as either np - complete or polynomial - time solvable .",
    "khachiyan s ellipsoid algorithm @xcite resolved positively this open question in 1979 , but was broadly perceived as a poor competitor to the simplex method . not long after that , karmarkar s interior point algorithm @xcite provided a practically viable polynomial alternative to the simplex method .",
    "however , there was still a sense of dissatisfaction in the community : the number of iterations of both the ellipsoid algorithm and the interior point method depend not just on the dimensions of the problem ( the number of variables @xmath0 and the number of inequalities @xmath1 ) but also on the number of bits needed to represent the numbers in the input ; such algorithms are sometimes called `` weakly polynomial '' .",
    "a _ strongly polynomial algorithm _ for linear programming ( or any problem whose input is an array of integers ) is one that is a polynomial - time algorithm in the ordinary sense ( always stops within a number of steps that is polynomial in the total number of bits in the input ) , but it also takes a number of elementary arithmetic operations that is polynomial in the dimension of the input array .",
    "strongly polynomial algorithms exist for many network - related special cases of linear programming , as was first shown in @xcite .",
    "this was extended by tardos @xcite who established the existence of such an algorithm for `` combinatorial '' linear programs , that is , linear programs whose constraint matrix is 0 - 1 ( or , more generally , contains integers that are at most exponentially large in the dimensions ) . however , no strongly polynomial algorithm is known for general linear programming .",
    "the following summarizes one of the most important open problems in optimization and the theory of algorithms and complexity :    [ con : simplex_strongly_poly ] there is a strongly polynomial algorithm for linear programming .",
    "one particularly attractive direction for a positive answer for this conjecture is the search for polynomial variants of the simplex method",
    ". it would be wonderful to discover a pivoting rule for the simplex method which ( unlike all known such methods ) always finds the optimum after a number of iterations that is polynomial in @xmath0 and @xmath1 .",
    "hence the following is an interesting speculation :    [ con : simplex_strongly_poly_rand ] there is a pivoting rule for the simplex method that terminates after a number of iterations that is , in expectation , polynomial in @xmath0 and @xmath1 .    in relation to conjecture",
    "[ con : simplex_strongly_poly_rand ] , clever randomized pivoting rules of a particular recursive sort were discovered rather recently , with worst - case number of iterations that has a subexponential dependence on @xmath0 @xcite . on another front , the interesting polynomial simplex - like algorithm of kelner and spielman @xcite does not settle conjecture [ con : simplex_strongly_poly_rand ] because it is weakly polynomial , as the complexity of each iteration , and the number of iterations , depends ( polynomially of course ) on the bits of the integers in the input .",
    "other recent results related to conjecture [ con : simplex_strongly_poly ] can be found in @xcite .    in the next section",
    "we formalize the concept of a _ pivoting rule : _ a method for jumping from one basic solution to an adjacent one that ( 1 ) is strongly polynomial per iteration ; ( 2 ) is guaranteed to increase a potential function at each step ; and ( 3 ) is guaranteed to always terminate at the optimum ( or certify infeasibility or unboundedness ) .",
    "we also give several examples of such rules .",
    "it is important to note that in our definition we allow pivoting rules to jump to _ infeasible bases _ in order to include pivoting rules other than of the primal type .",
    "also , our original definition in section 2 restricts pivoting rules to be deterministic ; we discuss the important subject of randomized rules in section 5 .",
    "recently there has been a glimmer of hope that some stronger forms of the two conjectures could be disproved , after the disproof of the hirsch conjecture @xcite .",
    "the hirsch conjecture @xcite posited that the diameter of a @xmath0-dimensional polytope with @xmath1 facets is at most @xmath2 , the largest known lower bound .",
    "the best known upper bound for this diameter is the quasi - polynomial bounds of @xcite .",
    "but even a super - polynomial lower bound would only falsify the conjectures for _ primal _ pivoting rules ( ones going through only feasible bases , i.e. , vertices of the polytope ) , but _ not _ for the many other kinds of pivoting rules ( see the next section ) .",
    "furthermore , it is now clear that the techniques involved in the disproof of the hirsch conjecture are incapable of establishing a nonlinear lower bound on the diameter of polytopes , and it is widely believed that there is a polynomial upper bound on the diameter of polytopes .",
    "_ in this paper we contemplate whether the concepts and methods of complexity theory can be applied productively to illuminate the problem of strongly polynomial algorithms for linear programming and conjecture [ con : simplex_strongly_poly ] . _ we show a result suggesting that pspace - completeness may be relevant .",
    "in particular , we propose to classify deterministic pivoting rules by the complexity of the following problem , which we call the path problem of a pivoting rule : given a linear program and a basic solution , will this latter one appear on the pivot rule s path ?",
    "recall that pspace is the class of problems solvable in polynomial _ memory_.",
    "this class contains np , and it is strongly believed to contain it strictly .",
    "the path problem of a pivoting rule is clearly in pspace , because it can be solved by following the ( possibly exponentially long ) path of the rule , reusing space ; if it is pspace - complete , then the pivoting rule can not be polynomial ( unless , of course , p = pspace ) .",
    "but it is not a priori clear that there are pivoting rules for which the path problem is pspace - complete .",
    "we show ( theorem [ thm : simple_is_pspace_hard ] ) that they do exist ; unfortunately , we prove this not for one of the many classical pivoting rules , but for a new , explicitly constructed  and fairly unnatural  one .",
    "we conjecture that the same result holds for essentially all known deterministic pivoting rules ; such a proof looks quite challenging ; obviously , in such a proof much more will need to be encoded in the linear program ( which , in the present proof , is of logarithmic complexity and isomorphic to @xmath3 ) .",
    "however , we do exhibit ( theorem [ thm : shadow_is_tractable ] ) a pivoting rule whose path problem is in p : it is dantzig s well - known _ self - dual simplex _ @xcite ( also known as _ shadow vertex algorithm _ ) , which is known to be exponential in the worst case @xcite , but has been used in several sophisticated algorithmic upper bounds for linear programming , such as average - case analysis and smoothness @xcite .",
    "we briefly discuss the apparent connection between the average - case performance of a pivoting rule and the complexity of its path problem .",
    "the motivation for our approach came from recent results establishing that it is pspace - complete to compute the final result of certain well known algorithms for finding fix points and equilibria @xcite .",
    "however , the proof techniques used here are completely different from those in @xcite .",
    "consider an algorithm whose input is an array of @xmath1 integers .",
    "the algorithm is called _ strongly polynomial _",
    "if    * it is polynomial - time as a turing machine , and * if one assumes that all elementary arithmetic operations have cost one , the worst - case complexity of the algorithm is bounded by a polynomial in @xmath1 , and is therefore independent of the size of the input integers .    in linear programming one seeks to maximize @xmath4 subject to @xmath5 , where @xmath6 is @xmath7 .",
    "an @xmath8 nonsingular submatrix @xmath9 of @xmath6 is a _",
    "basis_. a _ feasible basis _",
    "@xmath9 is one for which the system @xmath10 ( where by @xmath11 we denote vector @xmath12 restricted to the coordinates that correspond to @xmath9 ) has a nonnegative solution ; in this case , @xmath11 is called a",
    "_ basic feasible solution . _ basic feasible solutions are important because they render linear programming a combinatorial problem , in that the optimum , if it exists , occurs at one of them .",
    "we say that two bases are _ adjacent _ if they differ in only one column .",
    "there are many versions of linear programming ( with inequality constraints , minimization , unrestricted in sign variables , etc . )",
    "but they are all known to be easily interreducible .",
    "we shall feel free to express linear programs in the most convenient of these .",
    "we shall assume that the linear programs under consideration are non - degenerate ( no two bases result in the same basic solution ) .",
    "detecting this condition is nontrivial ( np - hard , as it turns out ) .",
    "however , there are several reasons why this very convenient assumption is inconsequential . first , a random perturbation of a linear program ( obtained , say , by adding a random small vector to @xmath13 ) is non - degenerate with probability one . and",
    "second , simplex - like algorithms can typically be modified to essentially perform ( deterministic versions of ) this perturbation on - line , thus dealing with degeneracy .",
    "we next define a class of algorithms for linear programming that are variants of the simplex method , what we call _ pivoting rules_. to start , we recall from linear programming theory three important kinds of bases @xmath9 , called _ terminal bases _ :    * optimality : @xmath14 .",
    "@xmath9 is the optimal feasible basis of the linear program .",
    "* unboundedness : @xmath15 for some column @xmath16 of @xmath6 .",
    "this implies that the linear program is unbounded if feasible . *",
    "infeasibility : @xmath17 for some row @xmath18 of @xmath19 .",
    "this means the linear program is infeasible .",
    "notice that , given a basis , it can be decided in strongly polynomial time whether it is terminal ( and of which kind ) .    a _ pivoting rule _",
    "@xmath20 is a strongly polynomial algorithm which , given a linear program @xmath21 :    * produces an initial basis @xmath22 ; * given in addition a basis @xmath9 that is not terminal , it produces an adjacent basis @xmath23 such that @xmath24 , where @xmath25 is a potential function .    the _ path _ of pivoting rule @xmath20 for the linear program @xmath21 is the sequence of bases @xmath26 , ending at a terminal basis , produced by @xmath20 .",
    "obviously , any pivoting rule constitutes a correct algorithm for linear programming , since it will terminate ( by monotonicity and finiteness ) , and can only terminate at a terminal basis . notice",
    "that pivoting rules may pass through infeasible basic solutions ( for example , they can start with one ) .",
    "incidentally , the inclusion of infeasible bases implies that such rules operate not on the linear program s polytope , but on its _ linear arrangement_. since the latter has diameter @xmath27 , even the existence of polytopes with super - polynomial diameter will not rule out strongly polynomial pivoting rules .",
    "there are many known deterministic pivoting rules ( ties are broken lexicographically , say ) :    1 .",
    "* dantzig s rule ( steepest descent ) . * in this rule ( as well as in all other primal rules that follow ) , given a feasible basis @xmath9 we first calculate , for each index @xmath28 not in the basis the objective increase gradient @xmath29 .",
    "define @xmath30 .",
    "dantzig s rule selects the @xmath31 with largest @xmath32 and brings it in the basis . by non - degeneracy ( if not a terminal basis ) , this completely determines the next basis . as with all primal pivoting rules ,",
    "the potential function @xmath25 is the objective .",
    "* steepest edge rule . * instead of the maximum @xmath32 , select the largest @xmath33 .",
    "* greatest improvement rule .",
    "* we bring in the index that results in the largest increment of the objective .",
    "* bland s rule .",
    "* select the smallest @xmath31 .",
    "+ for all these rules , however , we have not specified the original basis @xmath22 .",
    "this is obviously a problem , since all these rules are primal and need feasible bases , and a feasible basis may not be a priori available .",
    "primal pivoting rules such as these are best applied not on the original @xmath34 linear program @xmath21 , but to a simple @xmath35 variant called `` the big @xmath36 version , '' defined as @xmath37 , where @xmath36 is a large number ( @xmath36 can either be handled symbolically , or be given an appropriate value computed in strongly polynomial time ) .",
    "it is trivial now to find an initial feasible basis .",
    "in fact , the pivoting rule running on the new linear program can be thought of as a slightly modified pivoting rule acting on the original linear program ( when @xmath31 , @xmath16 is negated , and @xmath38 is replaced by @xmath39 ) .",
    "* shadow vertex rule . * here @xmath22 is any basis .",
    "given @xmath22 , we construct two vectors @xmath40 and @xmath41 such that @xmath22 is a feasible basis , and also a dual feasible basis , of the relaxed linear program @xmath42 subject to @xmath43 .",
    "now consider the line segment between these two linear programs , with right - hand side and objective @xmath44 and @xmath45 , respectively . moving on this line segment from @xmath46",
    ", we have both primal - feasible and dual - feasible ( and hence optimal ) solutions . at some point",
    ", one of the two will become infeasible ( and only one , by non - degeneracy ) .",
    "we find a new basic solution by exchanging variables as dictated by the violation , and continue .",
    "the potential function is the current @xmath47 . when @xmath48 we are at the optimum .",
    "6 .   * criss - cross rules . * a class of pivoting rules outside our framework",
    ", whose first variant appeared in @xcite , goes from one ( possibly infeasible ) basis to the other and convergence to a terminal basis is proved through a combinatorial argument that does not involve an explicit potential function .",
    "however , certain such rules ( such as the criss - cross pivoting rule suggested in @xcite ) have been shown ( @xcite ) to possess a monotone potential function , and so they can be expressed within our framework .",
    "* dual pivoting rules . *",
    "naturally , any of the primal pivoting rules can work on the dual .",
    "* primal - dual pivoting rule .",
    "* this classical algorithm @xcite is an important tool for developing simplex - inspired combinatorial algorithms for a broad set of network problems , acting as a reduction from weighted to unweighted combinatorial problems .",
    "it does not conform to our framework , because it involves an inner loop solving a full - fledged linear program .",
    "* pivoting rules with state . * finally , also outside our framework are pivoting rules relying on data other than @xmath49 and @xmath9 , for example a pivoting rule relying on statistics of the history of pivoting such as selecting to include the index which has in the past been selected least frequently",
    "* randomized pivoting rules .",
    "* there are several proposed randomized pivoting rules .",
    "the ambition here is that the rule s expected path length is polynomial .",
    "the simplest one @xcite is to pick a random index in @xmath50 .",
    "another important class of randomized rules are the _ random facet _",
    "rules used in the proofs of subexponential diameter bounds @xcite .",
    "we discuss randomized pivoting rules in section 5 .",
    "a pivoting rule is _ strongly polynomial _ if for any linear program the length of the path is bounded above by a polynomial in @xmath51 and @xmath1 .",
    "all pivoting rules within our framework mentioned above are known _ not _ to be strongly polynomial , in that for each one of them there is an explicit family of linear programs with non - polynomial path length , see @xcite for a unifying survey .",
    "explicit constructions are one way of ruling out pivoting rules . _ but is there a complexity - theoretic way ?",
    "_ our interest was sparked by the story of a well - known pivoting rule for a problem other than linear programming : the lemke - howson algorithm for two - player nash equilibrium , discovered in the 1960s @xcite .",
    "the first explicit construction was obtained decades later @xcite and was extremely complicated .",
    "more recently , it was established that the problem of finding the nash equilibrium discovered by the lemke - howson algorithm is pspace - complete @xcite ( and thus the algorithm can not be polynomial , as long as p @xmath52 pspace ) . remarkably , the pspace - completeness proof was much simpler than the explicit construction .",
    "we are led to the main definition of this paper :    the _ path problem _ associated with a pivoting rule @xmath20 is the following : given a linear program and a basis @xmath9 , does @xmath9 appear on the path of @xmath20 for this linear program ?    a pivoting rule",
    "is called _ intractable _ if its path problem is pspace - complete .",
    "a pivoting rule is _ tractable _ if its path problem can be solved in strongly polynomial time .",
    "the reason why this concept may be useful in understanding the complexity of linear programming is the following straightforward result :    [ prop : strongly_poly_intractable_pspace = p ] if an intractable pivoting rule is strongly polynomial , then pspace = p.    but are there examples of these two categories ? this is the subject of the next two sections .",
    "this section is devoted to the proof of the following theorem .",
    "[ thm : simple_is_pspace_hard ] there is an intractable pivoting rule @xmath20 .",
    "the pspace - completeness reduction is based on the klee - minty construction , the original explicit exponential example for a variant of the simplex method @xcite , which we recall next .",
    "the _ @xmath0-dimensional klee - minty cube _ is the following linear program :    @xmath53    the feasible region of this linear program is a distorted @xmath0-hypercube ( it obviously describes precisely the @xmath0-hypercube when @xmath54 ) : a polytope whose vertices are within a radius of @xmath55 from those of a hypercube , and are therefore in one - to - one correspondence with the elements of @xmath56 . thus the feasible bases will also be represented as bit strings in @xmath56 .",
    "the objective function has a minimum at @xmath57 ( a string of @xmath0 @xmath58 s ) and a maximum at @xmath59 .",
    "let us now recall a well - known order on @xmath56 called _ gray code _ and denoted @xmath60 .",
    "@xmath61 is simply the order @xmath62 .",
    "inductively , the gray code @xmath63 is @xmath64 , by which we mean , the sequence @xmath65 with each bit string preceded by a @xmath58 , followed by the _ reverse _ of the order @xmath65 , this time with each bit string preceded by @xmath66 .",
    "if @xmath67 , we denote by @xmath68 $ ] the @xmath69-th bit string in @xmath60 .",
    "@xmath60 is a bijection between @xmath70 and @xmath56 , and therefore we can define the _ successor function _ @xmath71 as follows : @xmath72 $ ] .",
    "the following is straightforward :    @xmath73 can be computed in polynomial time .    consider a vertex of the klee - minty cube of dimension @xmath0  equivalently , a bit string @xmath74 .",
    "this vertex has @xmath0 adjacent vertices , each obtained by flipping one of the @xmath75 s .",
    "we call the @xmath76-th coordinate _ increasing _ at this vertex if the objective increases by flipping @xmath75",
    ". the following are known important properties of the klee - minty cube :    * the @xmath76-th coordinate is increasing if and only if @xmath77 is even . *",
    "therefore the sequence of the vertices sorted in increasing objective is precisely @xmath60 .",
    "we next describe the starting pspace - complete problem . recall that a _ boolean circuit _ is a directed acyclic graph whose",
    "nodes are called _ gates _ , and are of several types : _ input _ , with in degree zero , _ not _ , with in degree one , and _ or _ and _ and _ with in - degree two .",
    "the sinks of this directed acyclic graph are called _",
    "outputs_. suppose that we are given a boolean circuit @xmath78 with @xmath1 inputs and @xmath1 outputs .",
    "if the inputs are set to a particular string @xmath79 , @xmath78 will `` compute '' an output string @xmath80 .",
    "suppose that this particular circuit @xmath78 has the property that the hamming ( @xmath81 , that is ) distance between @xmath12 and @xmath82 is always one ( that is , @xmath78 just computes the index of the input to flip ) .",
    "the _ path _ of @xmath78 is the sequence @xmath83 , where @xmath84 and @xmath85 .",
    "the @xmath78-path problem is the following .",
    "@xmath78-path : given @xmath78 and @xmath86 , is @xmath87 on the path of @xmath78 ?",
    "it is obviously in pspace ( one need only try the first @xmath88 bit strings in the path of @xmath78 , reusing space ; if @xmath87 is not reached by that time , we are in a loop and @xmath87 will never be reached ) .",
    "there is a family of circuits @xmath78 of size polynomial in the number of inputs and of polynomial complexity such that @xmath78-path is pspace - complete .",
    "[ [ sketch - of - proof ] ] sketch of proof : + + + + + + + + + + + + + + + +    we start from the halting problem for a linear bounded one - tape turing machine with empty starting tape . without the single - bit restriction",
    "the circuit @xmath78 could just find the first transition that applies and implement it ( the starting and ending strings can be made to be @xmath89 and @xmath87 respectively ) .",
    "the single - bit restriction can be realized through a straightforward coding trick .",
    "the reduction proceeds as follows : given an input @xmath86 , we shall construct a linear program and a basis @xmath90 such that @xmath90 lies on the path of rule @xmath20 ( yet to be described ) if and only if @xmath87 lies on the path of @xmath78 .",
    "the linear program is the klee - minty cube of dimension @xmath91 .",
    "the last ( least significant ) @xmath1 coordinates of the cube will serve to encode the current bit string on the path of @xmath78 , while the first @xmath1 coordinates will maintain a counter in gray code .",
    "we denote the last string of the gray code , @xmath92 , by @xmath93 .",
    "the sought basis @xmath90 is taken to be @xmath94 .",
    "next we describe the pivoting rule @xmath20 .",
    "in fact , it suffices to define @xmath20 only on klee - minty cubes of even dimension  on any other linear program , @xmath20 can be any pivoting rule , say steepest descent .",
    "first , the initial basis of @xmath20 is @xmath95 .",
    "second , here is the description of how @xmath20 modifies the current basis @xmath9 ( which , since the linear program is the klee - minty cube of dimension @xmath91 is represented by a bit string of length @xmath91 ) :    :    1 .   if @xmath96 , this is a terminal basis and we are done",
    ". otherwise , let @xmath97 each a string of length @xmath1 .",
    "2 .   if @xmath98 then @xmath99 .",
    "3 .   otherwise , if @xmath100 then @xmath101 .",
    "4 .   otherwise , construct the circuit with @xmath1 inputs in the family @xmath78 .",
    "5 .   compute @xmath102 ; suppose that @xmath103 and @xmath102 differ in the @xmath76-th place ( by assumption , they only differ in one ) .",
    "6 .   if the @xmath104-th coordinate of b is increasing , then @xmath105 .",
    "otherwise , @xmath99 .    to explain the workings of @xmath20 , the first @xmath1 bits are a counter , and the last @xmath1 bits encode the current bit string on the path of @xmath78 from @xmath89 .",
    "if either the first @xmath1 bits are @xmath93 or the last @xmath1 bits are @xmath87 , then @xmath20 just counts up in the other counter ( steps 2 and 3 ) .",
    "otherwise , ( steps 4 and 5 ) , @xmath102 is computed .",
    "the intention now is to update the last @xmath1 bits to be @xmath102 .",
    "if the flipped coordinate happens to be increasing in @xmath9 , then this is done immediately ( step 6 ) .",
    "but if it is not , then we do the following maneuver : we increment the @xmath106 counter by flipping the bit in @xmath106 that leads to the next string in the gray code ( step 7 ) .",
    "this way , in the next invocation of the pivot rule the flipped bit _ will _ be increasing ( by lemma [ lem : klee - minty_order](a ) ) .    to show that @xmath20 is a pivoting rule",
    ", it remains to show that it is strongly polynomial , and that there is a potential function @xmath25 such that the pivot step of @xmath20 is always monotonically increasing .",
    "the former is immediate . for the latter , @xmath107 is the value of the objective @xmath108 in the basic feasible solution represented by @xmath9 .",
    "it is easy to see by inspection of steps 2 , 3 , 6 , and 7 that in each of these four cases @xmath109 .",
    "finally , we must show that @xmath90 is on the path of @xmath20 if and only if @xmath87 is on the path of @xmath78 .",
    "if @xmath87 is on the path of @xmath78 then eventually @xmath103 will be @xmath87 , after at most @xmath110 steps , and from then on step 2 will be executed to increment the counter @xmath106 .",
    "this counter must go through @xmath90 just before arriving at the terminal basis .",
    "if @xmath87 is not on the path of @xmath78 then the path of @xmath78 will cycle until eventually step 7 will be executed for a @xmath88-th time ( it can be easily checked that the cycling of the path of @xmath78 does not avoid step 7 ) , at which point @xmath111 . from then on @xmath90 can not be reached .",
    "this completes the proof of theorem [ thm : simple_is_pspace_hard ] .",
    "the pivoting rule we proved intractable is not a natural one .",
    "we conjecture that essentially all the pivoting rules described in the last section are intractable ( even though proving such a result seems to us challenging ) .",
    "however , here we point out that there _ is _ a natural , classical pivoting rule that is tractable :    [ thm : shadow_is_tractable ] the shadow vertex pivoting rule is tractable .    given a linear program @xmath21 ,",
    "let @xmath22 be the initial basis , and let @xmath41 and @xmath40 be the corresponding initial values of the primal and dual right - hand - side vectors . given a basis @xmath9",
    ", we claim that the following is a necessary and sufficient condition that @xmath9 lies on the path of shadow vertex :    _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ there is a real number @xmath112 $ ] such that @xmath113 and @xmath114 . _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _    in proof , any basis on the path has a non - empty interval of @xmath47 s for which these inequalities hold . and",
    "if for a given basis @xmath9 this condition is satisfied , then the inequalities are satisfied for a subinterval of @xmath115 $ ] .",
    "if we assume , for contradiction , that @xmath9 is not on the path of shadow vertex , then we can run the shadow vertex pivoting rule forward and backward from @xmath9 , and eventually arrive from a different path to the beginning and end , contradicting non - degeneracy . as the condition is a system of @xmath91 linear inequalities with one unknown",
    ", this completes the proof .",
    "there is an interesting story here , connecting tractability of pivoting rules and the saga of the average - case analysis of the simplex method . during the early 1980s , and in the wake of the ellipsoid algorithm , average analysis of the simplex method ( under some reasonable distribution of linear programs ) was an important and timely open question , and indeed there was a flurry of work on that problem @xcite .",
    "it was noticed early by researchers working on this problem that one obstacle in analyzing the average complexity of various versions of the simplex method was a complete inability to predict the path of pivoting rules  that is , the apparent intractability of the path problem we are studying here . and",
    "this makes sense : if one can not characterize well the circumstances under which a vertex will appear on the path , it is difficult to deduce the average performance of the algorithm by adding expectations over all vertices .",
    "once borgwardt @xcite and smale @xcite had the idea of using the shadow vertex pivoting rule in this context , further progress ensued @xcite .",
    "many pivoting rules are explicitly randomized , aiming at good expected performance . our definition can easily be extended to include randomization : in the definition of a pivoting rule , @xmath116 is not a single adjacent basis , but a _ distribution _ on the set of adjacent bases ( naturally , this set is polynomially small ) .",
    "any basis @xmath117 in the support of @xmath116 must satisfy @xmath118 .",
    "obviously , deterministic pivoting rules are a special case , and therefore theorems [ thm : simple_is_pspace_hard ] and [ thm : shadow_is_tractable ] trivially apply here too .    what is slightly nontrivial is to define what `` intractable '' means in this case .",
    "that is , what is the `` path problem '' for a randomized pivoting rule @xmath20 ?",
    "we believe that the right answer is the following `` promise '' problem :    fix a polynomial @xmath119 and a function @xmath120 $ ] .",
    "the _ @xmath121-path problem _ associated with a randomized pivoting rule @xmath20 is the following : given an @xmath34 linear program and a feasible basis @xmath9 , distinguish between these two cases : @xmath9 appears in the execution of @xmath20 with probability ( a ) at most @xmath122 ; and ( b ) at least @xmath123 .",
    "the analog of proposition [ prop : strongly_poly_intractable_pspace = p ] is now :    if a randomized pivoting rule @xmath20 is strongly polynomial in expectation , then the @xmath121-path problem of rule @xmath20 is in bpp , for all @xmath124 and @xmath119 .",
    "recall that bpp is the class of all problems that can be solved by randomized algorithms , possibly with a small probability or error , see chapter 10 in @xcite .",
    "pivoting rules constitute a rich and interesting class of algorithmic objects , and here we focused on one important attribute : whether or not the path problem of a pivoting rule is tractable .",
    "we have pointed out that there is an intractable pivoting rule , whereas a well - known classical pivoting rule is tractable .",
    "the most important problem we are leaving open is to exhibit a natural intractable pivoting rule .",
    "for example , establishing the following would be an important advance :      this looks quite challenging . obviously , in such a proof",
    "much more will need to be encoded in the linear program ( which , in the present proof , was of logarithmic complexity ) .",
    "the ultimate goal is a generic intractability proof that works for a large class of pivoting rules , thus delimiting the possibilities for a strongly polynomial algorithm .",
    "for example : are all primal pivoting rules ( the ones using only feasible bases ) intractable ?",
    "there are pivoting rules beyond linear programming , usually associated with the linear complementarity problem ( lcp , see @xcite ) .",
    "they generally do not have a potential function , and termination is proved ( when it is proved ) by combinatorial arguments .",
    "lemke s algorithm is a well - known general pivoting rule , known to terminate with a solution ( or with a certification that no solution exists ) in several special cases .",
    "it is known to be intractable in general @xcite , but it can be shown to be tractable when the matrix is positive definite .",
    "we conjecture that it is intractable when the matrix is positive semidefinite .",
    "i.  adler , r.m .",
    "karp and r.  shamir .",
    "`` a family of simplex variants solving an m x d linear program in expected number of pivot steps depending on d only ''",
    ". mathematics of operations research , vol .",
    "11 , no  4 , pp . 570 - 590 .",
    "( 1986 )    i.  adler , and n.  megiddo .",
    "`` a simplex algorithm whose average number of steps is bounded between two quadratic functions of the smaller dimension '' .",
    "journal of the acm , vol .",
    "32 , no  4 , pp . 471 - 495 .",
    "( 1985 )              g.b .",
    "`` maximization of a linear function of variables subject to linear inequalities '' ( 1947 ) . published in t.c .",
    "koopmans ( ed . ) : activity analysis of production and allocation , wiley & chapman - hall , pp .",
    "339 - 347 ( 1951 )      g.  b.  danzig , l.  r.  ford , d.  r.  fulkerson , `` a primal - dual algorithm for linear programming '' . in h.",
    "w.  kuhn and a.  w.  tucker ( ed . ) , linear inequalities and related systems , princeton university press , pp .",
    "171 - 181 .",
    "( 1954 )        p.w .",
    "goldberg , c.h .",
    "papadimitriou and r.  savani .",
    "`` the complexity of the homotopy method , equilibrium selection , and lemke - howson solutions '' .",
    "acm transactions on economics and computation , vol .  1 , no  2 , article 9 . ( 2013 )                                              y.  ye .",
    "`` the simplex and policy - iteration methods are strongly polynomial for the markov decision problem with a fixed discount rate ''",
    ". mathematics of operations research , vol .",
    "36 , issue 4 , pp .",
    "593 - 603 ."
  ],
  "abstract_text": [
    "<S> we show that there are simplex pivoting rules for which it is pspace - complete to tell if a particular basis will appear on the algorithm s path . </S>",
    "<S> such rules can not be the basis of a strongly polynomial algorithm , unless p = pspace . </S>",
    "<S> we conjecture that the same can be shown for most known variants of the simplex method . </S>",
    "<S> however , we also point out that dantzig s shadow vertex algorithm has a polynomial path problem . </S>",
    "<S> finally , we discuss in the same context randomized pivoting rules . </S>"
  ]
}