{
  "article_text": [
    "a formal semantics offers a complete , and rigorous definition of a language .",
    "operational and denotational semantics are two well - known methods of assigning meaning to programming languages and both semantics are necessary for a complete description of the language .",
    "denotational semantics associates an element of a semantic domain to each expression in the language and the semantic is compositional .",
    "traces are one of the ways to define denotational semantics .",
    "a trace gives the global picture of the behaviour .",
    "the common way of defining operational semantics is to provide state transition systems for the language , where the transition system models the computation steps of expressions in the language and allows the formal analysis of the language .    _",
    "compensating csp _",
    "( cscp )  @xcite is a language defined to model long running business transactions within the framework of hoare s csp  @xcite process algebra .",
    "business transactions need to deal with faults that can arise at any stage of the transactions . _",
    "compensation _ is defined in @xcite as an action taken to recover from error in business transactions or cope with a change of plan .",
    "ccsp provides constructs for orchestration of compensations to model business transactions . with",
    "the introduction of the language , both traces  @xcite and operational  @xcite semantics have been defined .",
    "both semantics have valuable non - overlapping application and we want to use them both .",
    "the key question is _ `` how they are related?''_.    this paper draws the correspondence of two different semantic representation of a language which strengthen the formal foundation of the language . in particular , the aim is to accomplish the unification between operational and denotational approach of ccsp . the unification is based on the approach where we use the transition rules from operational semantics to derive the traces and then show that these derived traces correspond to the original traces by using induction over the derived traces . completing",
    "the derivation means that any of the presentations can be accepted as a primary definition of the meaning of the language and each of the definitions can even safely and consistently be used at different times and for different purposes .",
    "the reset of the paper is organised as follows . a brief overview of ccsp along with an example is given in section  [ sec : ccsp ] .",
    "the trace and the operational semantics of ccsp are outlined in section  [ sec : semantics ] .",
    "we describe the how we define and prove a relationship between the semantic models in section  [ sec : relation ] .",
    "we define theorems and supporting lemmas to establish the relationship for both standard and compensable processes .",
    "we outline some lessons from the experiment and then summarise some related work in section  [ sec : lesson ] and section  [ sec : relwork ] respectively .",
    "we draw our conclusion in section  [ sec : concl ] .",
    "the introduction of the ccsp language was inspired by two ideas : transaction processing features , and process algebra . like standard csp ,",
    "processes in ccsp are modelled in terms of the atomic events they can engage in .",
    "the language provides operators that support sequencing , choice , parallel composition of processes . in order to support",
    "failed transaction , compensation operators are introduced .",
    "the processes are categorised into _ standard _ , and _",
    "compensable _ processes .",
    "a standard process does not have any compensation , but compensation is part of a compensable process that is used to compensate a failed transaction .",
    "we use notations , such as , @xmath0 to identify standard processes , and @xmath1 to identify compensable processes .",
    "a subset of the original ccsp is considered in this paper , which includes most of the operators , is summarised in fig .",
    "[ fig : syntax ] .",
    "the basic unit of the standard processes is an atomic event ( @xmath2 ) .",
    "the other operators are the sequential  ( @xmath3 ) , and the parallel composition ( @xmath4 ) , the choice operator ( @xmath5 ) , the interrupt handler ( @xmath6 ) , the empty process @xmath7 , raising an interrupt @xmath8 , and yielding to an interrupt @xmath9 . a process that is ready to terminate is also willing to yield to an interrupt .",
    "in a parallel composition , throwing an interrupt by one process synchronises with yielding in another process .",
    "yield points are inserted in a process through @xmath9 .",
    "for example , ( @xmath10 ) is willing to yield to an interrupt in between the execution of @xmath11 , and @xmath12 .",
    "the basic way of constructing a compensable process is through a compensation pair ( @xmath13 ) , which is constructed from two standard processes , where @xmath11 is called the _ forward _ behaviour that executes during normal execution , and @xmath12 is called the associated compensation that is designed to compensate the effect of @xmath11 when needed .",
    "the sequential composition of compensable processes is defined in such a way that the compensations of the completed tasks will be accumulated in reverse to the order of their original composition , whereas compensations from the compensable parallel processes will be placed in parallel . in this paper , we define only the asynchronous composition of processes , where processes interleave with each other during normal execution , and synchronise during termination . by enclosing a compensable process @xmath14 inside a transaction block @xmath15}$ ] , we get a complete transaction and the transaction block itself is a standard process .",
    "successful completion of @xmath14 represents successful completion of the block .",
    "but , when the forward behaviour of @xmath14 throws an interrupt , the compensations are executed inside the block , and the interrupt is not observable from outside of the block .",
    "@xmath16 , and @xmath17 are the compensable counterpart of the corresponding standard processes and they are defined as follows : @xmath18    to illustrate the use of ccsp , we present an example of a transaction for processing customer orders in a warehouse in  fig.[fig : example ] .",
    "the first step in the transaction is a compensation pair .",
    "the primary action of this pair is to accept the order and deduct the order quantity from the inventory database .",
    "the compensation action simply adds the order quantity back to the total in the inventory database .",
    "after an order is received from a customer , the order is packed for shipment , and a courier is booked to deliver the goods to the customer .",
    "the @xmath19 process packs each of the items in the order in parallel .",
    "each @xmath20 activity can be compensated by a corresponding @xmath21 . simultaneously with the packing of the order , a credit check is performed on the customer .",
    "the credit check is performed in parallel because it normally succeeds , and in this normal case the company does not wish to delay the order unnecessarily . in the case that a credit check fails , an interrupt is thrown causing the transaction to stop its execution , with the courier possibly having been booked and possibly some of the items having being packed . in case of failure , the semantics of the transaction block will ensure that the appropriate compensation activities will be invoked for those activities that already did take place .",
    "this section briefly outlines the trace and the operational semantics of ccsp .      a trace of a process records the history of behaviour up to some point .",
    "we show the operators on traces which are then lifted to operators on set of traces .",
    "traces considered for ccsp are non - empty sets .",
    "the trace of a standard process is of the form @xmath22 where @xmath23 ( @xmath24 is alphabet of normal events ) and @xmath25 ( @xmath26 ) , which means all traces end with any of the events in @xmath27 , which is called a terminal event .",
    "the terminal events represent the termination of a process .",
    "successful termination is shown by a @xmath28 .",
    "termination by either throwing or yielding an interrupt is shown by @xmath29 or @xmath30 respectively . in sequential composition",
    "@xmath31 , the concatenated observable traces @xmath32 and @xmath33 , only when @xmath32 terminates successfully,(ends with @xmath28 ) , otherwise the trace is only @xmath32 .",
    "the traces of two parallel processes are @xmath34 which corresponds to the set ( @xmath35 ) , the possible interleaving of traces of both processes and followed by @xmath36 , the synchronisation of @xmath37 and @xmath38 .",
    "the trace semantics of standard processes are shown in fig .",
    "[ fig : stdtrace ] .",
    "compensable processes are comprised of _ forward _ and _ compensation _ behaviour .",
    "the traces of compensable processes are of pair of traces of the form @xmath39 , where @xmath22 is the forward behaviour and @xmath40 is the compensation behaviour . in sequential composition , the forward traces correspond to the original forward behaviour and followed by the traces of the compensation .",
    "traces of parallel composition are defined as the interleaving of forward traced and then follows the interleaving of compensation .",
    "the traces of a compensation pair are the traces of both of the processes of the pair when the forward process ( @xmath11 ) terminate with a @xmath41 , otherwise the traces of the pair are the traces of the forward process followed by only a @xmath41 .",
    "the traces of a transaction block are only the traces of compensable processes inside the block when the process terminates with a @xmath41 , otherwise when the forward process inside the block terminates with a @xmath42 the traces of the block are the traces of the forward process followed by the traces of the compensation .",
    "[ fig : comptrace ] outlines the traces of compensable processes .",
    "the following healthiness conditions declare that processes consist of some terminating or interrupting behaviour which ensures that the traces of processes are non - empty :    * @xmath43  or   @xmath44 , for some @xmath32 * @xmath45 or @xmath46 for some @xmath47      by using labelled transition systems @xcite , the operational semantics specifies the relation between states of a program .",
    "two types of transitions are define to present the transition relation of process terms : normal and terminal .",
    "a normal transition is defined by a normal event ( @xmath48 ) and a terminal transition is defined by a terminal event ( @xmath25 ) .    for a standard process",
    ", a normal transition makes the transition of a process term from one state to its another state ( @xmath11 to @xmath49 ) .",
    "the terminal transition , on the other hand terminates a standard process to a null process ( 0 ) : @xmath50    in sequential composition ( @xmath3 ) , the process @xmath12 can start only when the process @xmath11 terminates successfully ( with @xmath28 ) .",
    "if @xmath11 terminates with @xmath29 or @xmath30 the process @xmath12 will not start . in parallel composition",
    "each process can evolve independently and processes synchronise only on terminal events .",
    "the transition rules for standard processes are outlined in fig .",
    "[ fig : std - os ] .    for compensable processes ,",
    "the normal transitions are same as standard processes .",
    "however , the terminal events terminate the forward behaviour of compensable processes , additionally , the compensation are stored for future reference .",
    "@xmath51    in sequential composition ( @xmath52 ) , when @xmath14 terminates , its compensation ( @xmath11 ) is stored and @xmath53 starts to execute . in this scenario",
    ", we get an auxiliary construct ( @xmath54 ) where the processes have no particular operational relation between them .",
    "after termination of the process @xmath53 , its compensation ( @xmath12 ) is accumulated in front of @xmath11 i.e. , ( @xmath55 ) . in the parallel composition ,",
    "the main difference with the standard processes is that after termination of the forward behaviour the compensations are accumulated in parallel",
    ". the transition rules of compensable processes are summarised in fig .",
    "[ fig : comp - os ] .",
    "a non - terminal event changes the state of the process inside the block .",
    "successful completion of the forward process inside the block means completion of the whole block , but throwing a interrupt by the compensable process inside the block results the compensation to run . in compensation pair , after successful completion of the forward behaviour the compensation will be stored for future use , however , unsuccessful termination , i.e , terminates by @xmath29 or @xmath30 results an empty compensation ( fig .",
    "[ fig : std - os ] ) .",
    "in this section we describe the steps to derive a relationship between the two semantic models of ccsp . we follow a systematic approach to derive the relationship where traces are first extracted from the transition rules and prove that the extracted traces correspond to the original trace definition .",
    "the steps of deriving the semantic relation are shown in fig .",
    "[ fig : proof - steps ] .",
    "the operational semantics leads to lifted transition relations labelled by sequences of events .",
    "this is defined recursively . for a standard process @xmath11 , @xmath56 the derived traces of a standard process @xmath11 is defined as @xmath57 .",
    "let @xmath58 , then we get the following definition , @xmath59    compensable processes have both forward and compensation behaviour .",
    "a compensable process is defined as a pair of traces .",
    "hence , it is required to extract traces from both forward and compensation behaviour .",
    "the forward behaviour of a compensable process @xmath14 is defined as follows : @xmath60 where @xmath61 is the trace of the forward behaviour .",
    "@xmath62 is the attached compensation .",
    "the behaviour of compensation is similar to standard processes and by reusing that we get the following definition : @xmath63 where @xmath64 is the trace of the compensation . for a compensable process",
    "@xmath14 , the derived traces @xmath65 is defined as follows : @xmath66    by using the definition of derived traces and the original traces we state the following theorem to define the relationship between the semantic models ,    [ th1 ] for any standard process term @xmath11 , where @xmath67 @xmath68 for any compensable process terms @xmath14 , where @xmath69 and does not contain the term @xmath70 , @xmath71    traces are extracted for each term of the language , and its correspondence is shown with the corresponding traces in the trace semantics .",
    "assume @xmath11 and @xmath12 are standard process terms , then for all the operators , we prove that @xmath72 for each such operator @xmath73 , the proof is performed by induction over traces . in the proof we assume that , @xmath74 and @xmath75 .",
    "we follow similar style for compensable processes . assuming @xmath76 and @xmath77 we show that , @xmath78 in the following sections we outline the proof steps showing the correspondence in ( [ eq : genstd ] ) and ( [ eq : gencomp ] ) for both standard and compensable process terms .",
    "* sequential composition : * by using ( [ eq : genstd ] ) the relationship between the semantic models is derived by showing that , @xmath79 from ( [ eq : dtp ] ) we get the derived traces of the sequential composition , @xmath80 we also expand the definition of trace semantics as follows : @xmath81 finally , from the above definitions of traces , the following lemma is formulated for the sequential composition of standard processes :    [ lema : stseq ] @xmath82    the lemma is proved by applying induction over the trace @xmath61 , where @xmath83 is considered as the base case , and @xmath84 is considered as the inductive case . to support the proof of the lemma ,",
    "two equations are derived from the transition rules .",
    "these derived equations are based on the event by which the transition rules are defined : @xmath85     + * basic step * : @xmath83 + @xmath86 + `` from transition rules sequential composition '' @xmath87 from ( [ steqn1 ] ) @xmath88 from ( [ steqn2 ] ) @xmath89 therefore , for @xmath83 from ( [ steqn1 ] ) and ( [ steqn2 ] ) @xmath90 * inductive step : * @xmath84 + @xmath91 +   + `` from operational rules '' @xmath92 from  ( [ steqn3 ] ) @xmath93 from  ( [ steqn4 ] ) @xmath94 therefore for @xmath84 , from ( [ steqn3 ] ) @xmath95 ( [ steqn4 ] )    &  p , qp = p  t=(pq )   p0   q0 + &   p , q  p=",
    "t=(pq )   p0   q0 + = &   + &  p , q  ( p=  p = p )  t=(pq ) + &   p0  q0 + = &   p , qt=(pq )   p0   q0    this completes the proof of the lemma .",
    "we follow the same approach to prove other lemmas in the rest of the paper",
    ".    * parallel composition : * the parallel composition of two processes is defined to be the interleaving of their observable events followed by the synchronisation of their terminal events .",
    "for example , considering asynchronous actions , @xmath96 can execute @xmath2 followed by @xmath97 or @xmath97 followed by @xmath2 . for traces",
    "@xmath32 and @xmath33 we write @xmath35 to denote the set of interleaving of @xmath32 and @xmath33 and it follows the following definition : @xmath98    by following similar steps as sequential composition , we define the following lemma for parallel composition :    [ lema4 ] @xmath99    we derive two supporting equation from the transition rules of parallel composition : @xmath100    the proof of the base case is trivial and omitted from the presentation . the inductive case is described here : @xmath101      * sequential composition : * for compensable processes @xmath14 and @xmath53 , let @xmath102 and according to trace derivation rule we get @xmath103 the following lemma is stated to define the relationship for the lifted forward behaviour of sequential composition of compensable processes :    [ lema : c - seq ] @xmath104    @xmath105 expression is used to state that when process @xmath14 terminates successfully ( terminate by @xmath106 ) , compensation from both @xmath14 and @xmath53 are accumulated in reverse order , otherwise only compensation from @xmath14 is stored .",
    "the following equations are derived from the transition rules to support the proof of the above lemma .",
    "@xmath107    in the inductive case of the lemma we get the following intermediate step involving the auxiliary construct @xmath54 .",
    "@xmath108 to deal with this we need another lemma which will support the removal of auxiliary construct in ( [ eq2 ] ) .",
    "this lemma considers the situation where the forward behaviour of the first process of sequential composition is terminated with @xmath28 and its compensation is stored and the second process of the composition has started . here to mention that @xmath61 in ( [ eq2 ] ) above is a complete trace .",
    "[ lema3 ] @xmath109    the lemma is proved by induction over traces . by using this lemma , we prove lemma  [ lema : c - seq ] by following the similar approach of applying induction over traces .",
    "* * parallel composition:**let @xmath110 by using the trace derivation rule we get , @xmath111 we then define the following lemma to establish the semantic correspondence for parallel composition of compensable processes :    [ lema5 ]   + @xmath112    the lemma is proved by using induction over traces similar to other lemmas .    *",
    "compensation pair : * a compensation pair @xmath113 consists of two standard processes : a standard process ( @xmath11 ) and its compensation @xmath114 .",
    "the semantics of compensation pair is defined in such a way that the behaviour of the compensation @xmath12 is augmented only with successfully completed forward behaviour of @xmath11 , otherwise , the compensation is empty . for a compensation pair ,",
    "we show that @xmath115 to prove the semantic correspondence between the semantics model , we state the following lemma :    [ lema : cpair ] @xmath116    the lemma is proved by induction as previous lemmas . to support the inductive proof ,",
    "the following two equations are derived from the transitions rules shown earlier , @xmath117 unlike the lemmas defined earlier for compensable processes , lemma  [ lema : cpair ] includes the traces of both forward and compensation behaviour .",
    "the following trace rules for the compensation pair are used in the proof of the lamma : @xmath118    * transaction block : * transaction block is a standard process .",
    "we let @xmath119)$ ] and by following the trace derivation rule we get @xmath120 ) & = & [ pp]{\\stackrel{t}{\\longrightarrow}}0\\end{aligned}\\ ] ] the semantic correspondence is then derived by proving the following lemma :    [ lema - block1 ]   + @xmath121{\\stackrel{t}{\\longrightarrow}}0      = \\exists p , p'\\cdot t=[p , p']~~\\wedge~~pp{\\stackrel{p , p'}{\\longrightarrow}}0         $ ]    the operational semantics provide us the following equations to support the proof of the above lemma . @xmath122}{\\stackrel{a}{\\longrightarrow}}r & = & pp{\\stackrel{a}{\\longrightarrow}}pp'~~\\wedge~~r={[~pp'~]}\\\\      & \\vee & pp{\\stackrel{!}{\\longrightarrow}}p~~\\wedge~~p{\\stackrel{a}{\\longrightarrow}}p'~~\\wedge~~r = p'\\\\     { [ ~pp~]}{\\stackrel{\\omega}{\\longrightarrow}}~0 & = & pp{\\stackrel{\\tick}{\\longrightarrow}}p~~      \\wedge~~p{\\stackrel{p'}{\\longrightarrow}}0\\\\      & \\vee & pp{\\stackrel{!}{\\longrightarrow}}p~~\\wedge~~p{\\stackrel{\\omega}{\\longrightarrow}}0\\end{aligned}\\ ] ] the block operator runs the compensation of a terminating forward behaviour and discards the compensation of successfully completed forward behaviour .",
    "it removes the traces of an yielding forward behaviour .",
    "we left two operators from the correspondence proof presented here .",
    "first one is the choice operator ( @xmath123 ) .",
    "the trace of choice is the union of their traces and the operational rules shows that either process ( @xmath11 or @xmath12 ) can evolve independently .",
    "correspondence proof of this operator is trivial .",
    "another operator that was left is interrupt handler ( @xmath6 ) .",
    "it is quite similar to standard sequential composition except that the flow of control from the first to the second process is caused by a throw ( @xmath29 ) rather than a @xmath28 and hence , showing its correspondence proof would be repetitive .",
    "we have adopted a systematic approach to show the correspondence between the two semantic models of ccsp .",
    "traces are derived from the operational rules and then applying induction over the traces we showed the correspondence . due to the way of defining operational rules",
    "the trace derivation was done easily .",
    "we used labelled transition system to define the operational rules . in @xcite operational rules",
    "are defined for a similar language as ours but same symbol is used to define the labels of different transition rules .",
    "however , we used special symbols for different kinds of transitions .",
    "transition between states are caused by two kinds of events : normal and terminal and we used these events as labels in our transition rules .",
    "the advantage of this approach of defining labels is that these labels are the traces of the transition and we can then derive these traces from the transition rules .",
    "the trace operators play a significant role in defining the lemmas as well as in the correspondence proofs .",
    "the operators are used both at the trace levels and at the process levels .",
    "all the lemmas defined in this chapter have a common pattern applicable to both standard and compensable processes .",
    "for example , for standard processes @xmath11 and @xmath12 , and their traces @xmath32 and @xmath33 , the lemmas for all the operators are defined as follows : @xmath124    similar definitions are also given for the forward behaviour of compensable processes .",
    "the use of operators at both trace and process levels allow us to apply appropriate rules for the operators ( rules for terminal and observable events from operational and trace semantics ) .",
    "the correspondence was proved by using structural induction .",
    "first , the induction was applied on process terms of the language and then on the derived traces .",
    "the lower level induction which is on traces support the induction on upper level which is on process terms",
    "the semantic correspondence presented here is based on the technique of applying structural induction .",
    "a similar approach is also applied by s. schneider @xcite , where an equivalence relation was established between the operational and denotational semantics of timed csp  @xcite@xcite .",
    "operational rules are defined for timed csp and then timed traces and refusals are extracted from the transition rules of a program , and it is shown that the pertinent information corresponds to the semantics obtained from the denotational semantic function . by applying structural induction over the terms of timed csp , it was proved that the behaviour of the transition system is identical to those provided by the denotational semantics .",
    "a similar problem was also investigated in @xcite , where a metric structure was employed to relate the operational and denotational models of a given language . in order to relate the semantic models",
    "it was proved that the two models coincide .",
    "the denotational models were extended and structural induction was applied over the terms of the language to relate the semantic models .",
    "other than using induction , hoare and he @xcite presented the idea of unifying different programming paradigms and showed how to derive operational semantics from its denotational presentation of a sequential language .",
    "they derive algebraic laws from the denotational definition and then derive the operational semantics from the algebraic laws . similar to our work , huibiao _ et al . _",
    "@xcite derived denotational semantics from operational semantics for a subset of verilog  @xcite .",
    "however the derivation was done in a different way than our method where the authors defined transitional condition and phase semantics from the operational semantics .",
    "the denotational semantics are derived from the sequential composition of the phase semantics .",
    "the authors also derived operational semantics from denotational semantics @xcite .    unlike our approach",
    ", the unification between the two semantics was shown in @xcite by extending the operational semantics to incorporate the denotational properties .",
    "the equivalence was shown for a language having simple models without any support for concurrency .",
    "similar problem was also investigated in @xcite for a simple sequential language , which support recursion and synchronisation in the form of interleaving .",
    "the relation between operational and denotational semantics is obtained via an intermediate semantics .",
    "it is of great importance to have the description of both operational and denotational semantics . having both of the semantics we need to establish a relationship between these two .",
    "demonstrating the relationship between these two semantics of the same language ensures the consistency of the whole semantic description of the language .",
    "the main contribution of this paper is to show the correspondence between the operational semantics and the trace semantics of a subset of ccsp language .",
    "the correspondence is shown by deriving the traces from the operational rules and then applying the induction over the derived traces .",
    "two level of induction is applied . in one level induction",
    "is applied over the operational rules and in the next level induction is applied over the derived traces .    the correspondence shown here",
    "are completely done by hand which is error prone and there are strong possibilities to miss some of the important parts during the proof . as part of the future work our goal is to use an automated / mechanized prover which will help us to use the similar approach that we followed here i.e , mathematical induction , and at the same time prove the theorems automatically . among several tools we are currently using pvs ( prototype verification system )",
    "@xcite for our purpose .",
    "the specification language of pvs is based on classical , typed , high order logic and contains the constructs intended to ease the natural development of specification .",
    "the pvs proof checker is interactive and provides powerful basic commands and a mechanism for building re - usable strategies based on these .",
    "the parallel operator of ccsp does not support synchronization on normal events .",
    "synchronization of events is significant for the development of a language .",
    "currently we are working on adding synchronization to ccsp . adding synchronization and",
    "then using mechanized theorem prover for showing the correspondence will strengthen the formal foundation of the language .",
    "m.  butler , t.  hoare , and c.  ferreira , `` a trace semactics for long - running transaction , '' in _ proceedings of 25 years of csp _ , ser .",
    "lncs , a.  abdallah , c.  jones , and j.  sanders , eds .",
    "3525.1em plus 0.5em minus 0.4emlondon : springer - verlag , 2004 .",
    "m.  butler and s.  ripon , `` executable semantics for compensating csp , '' in _ ws - fm 2005 _ , ser .",
    "lncs , m.  bravetti , l.  kloul , and g.  zavattaro , eds .",
    "3670.1em plus 0.5em minus 0.4emversailles , france : springer - verlag , september 1 - 3 2005 , pp .",
    "243256 .",
    "f.  van breugel , `` an introduction to metric semantics : operational and denotational models for programming and specification languages , '' _ theoretical computer science _ , vol .",
    "258 , no . 1 - 2 , pp . 198 , may 2001",
    ".        m.  gordon , `` the semantic challenge of verilog hdl , '' in _ proceedings of the 10th annual ieee symposium on logic in computer science ( lics 95 : ) _ .1em plus 0.5em minus 0.4emieee computer society , june 1995 , pp . 136145 .    h.  zhu , j.  p. bowen , and j.  he , `` deriving operational semantics from denotational semantics for verilog , '' in _",
    "8th asia - pacific software engineering conference ( apsec 2001)_.1em plus 0.5em minus 0.4em ieee computer society , 4 - 7 dec 2001 , pp .",
    ".    s.  f. smith , `` from operational to denotational semantics , '' in _ proceedings of the 7th international conference on mathematical foundations of programming semantics _ ,",
    "lncs , vol . 598 , 1992 , pp . 5476",
    ".    j .- j .  c. meyer and e.  vink , _ on relating denotational and operational semantics for programming languages with recursion and concurrency",
    "open problems in topology.1em plus 0.5em minus 0.4emelsevier , 1990 , ch .",
    "24 , pp . 387406 .",
    "s.  owre , j.  rushby , and n.  shankar , `` pvs : a prototype verification system , '' in _",
    "11th international conference on automated deduction ( cade ) _ , ser .",
    "lecture notes in artificial intelligence , d.  kapur , ed .",
    ", vol . 607.1em plus 0.5em minus 0.4emspringer - verlag , june 1992 , pp ."
  ],
  "abstract_text": [
    "<S> formal semantics offers a complete and rigorous definition of a language . </S>",
    "<S> it is important to define different semantic models for a language and different models serve different purposes . building equivalence between different semantic models of a language </S>",
    "<S> strengthen its formal foundation . </S>",
    "<S> this paper shows the derivation of denotational semantics from operational semantics of the language ccsp . </S>",
    "<S> the aim is to show the correspondence between operational and trace semantics . </S>",
    "<S> we extract traces from operational rules and use induction over traces to show the correspondence between the two semantics of ccsp .    compensating csp , semantic relationship , trace semantics , operational semantics . </S>"
  ]
}