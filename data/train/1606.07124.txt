{
  "article_text": [
    "the design of programs that respect real - time specifications is a difficult problem with recent and promising advances .",
    "such programs must handle thin timing behaviours , are prone to errors , and difficult to correct a posteriori .",
    "therefore , one road to the design of correct real - time software is the use of automatic synthesis methods , that _ build _ , from a specification , a program which is correct by construction . to this end ,",
    "_ timed games _ are nowadays recognised as the key foundational model for the synthesis of real - time programs .",
    "these games are played between a _ controller _ and an _ environment _ , that propose actions in the system , modelled as a _",
    "plant_. the _ reactive synthesis problem _ ( @xmath0 ) consists , given a real - time specification , in deciding whether the controller has a winning strategy ensuring that every execution of the plant consistent with this strategy ( i.e. , no matter the choices of the environment ) satisfies the specification . as an example , consider a lift for which we want to design a software verifying certain safety conditions . in this case",
    ", the plant is a ( timed ) automaton , whose states record the current status of the lift ( its floor , if it is moving , the button on which users have pushed  ) , as well as timing information regarding the evolution in - between the different states . on the other hand ,",
    "the specification is usually given using some real - time logic : in this work , we consider mainly specifications given by a formula of @xmath1@xcite , a real - time extension of @xmath3 .",
    "some actions in the plant are controllable ( closing the doors , moving the cart ) , while others belong to the environment ( buttons pushed by users , exact timing of various actions inside intervals , failures  ) .",
    "then , the @xmath0problem asks to compute a controller that performs controllable actions at the right moments , so that , for all behaviours of the environment , the lift runs correctly .    in the _ untimed case _",
    ", many positive theoretical and practical results have been achieved regarding @xmath0 : for instance , when the specification is given as an @xmath3formula , we know that if a winning strategy exists , then there is one that can be described by a finite state machine @xcite ; and efficient @xmath3synthesis algorithms have been implemented @xcite . unfortunately , in the real - time setting , the picture is not so clear .",
    "indeed , a winning strategy in a timed game might need unbounded memory to recall the full prefix of the game , which makes the real - time synthesis problem a _ hard",
    "this is witnessed by three papers presenting negative results : dsouza and madhusudan @xcite and bouyer _ et al .",
    "_ @xcite show that @xmath0is undecidable ( on finite and infinite words ) when the specification is respectively a timed automaton and an @xmath4formula ( the two most expressive formalisms in  [ fig : decsummary ] ) .",
    "more recently , doyen _ et al .",
    "_ show @xcite that @xmath0is undecidable in the infinite words semantics , when the specification is given using @xmath1 ; but leave the finite words case open .",
    "when facing an undecidability result , one natural research direction consists in considering subcases in order to recover decidability : here , this amounts to considering fragments of the logic , or restrictions on the possible controllers .",
    "such results can also be found in the aforementioned works . in @xcite ,",
    "the authors consider a variant of @xmath0 , called _ bounded resources reactive synthesis _",
    "( @xmath2 ) where the number of clocks and the set of guards that the controller can use are fixed a priori , and the specification is given by means of a timed automaton . by coupling this technique with the translation of @xmath1into timed automata  @xcite , one obtains a 3-@xmath5 procedure ( in the finite and infinite words cases ) . unfortunately ,",
    "due to the high cost of translating @xmath1into timed automata and the need to construct its entire deterministic region automaton , this algorithm is unlikely to be amenable to implementation .",
    "then , @xcite presents an on - the - fly algorithm for @xmath2with @xmath4specifications ( @xmath4is a strict superset of @xmath1 ) , on finite words , but their procedure runs in non - primitive recursive time .    hence , the decidability status of the synthesis problem ( with @xmath1requirements ) still raises several questions , namely :    can we relax the restrictions in the definition of @xmath2while retaining decidability ?",
    "is @xmath0decidable on finite words , as raised in @xcite ?",
    "are there meaningful restrictions of the logic that make @xmath0 decidable",
    "?    can we devise an on - the - fly , efficient , algorithm that solves @xmath2 in 3-@xmath5 as in @xcite ?    in the present paper , we provide answers to those questions .",
    "first , we consider the additional @xmath6 , @xmath7and @xmath8problems , that introduce different levels of restrictions .",
    "@xmath6requests the controller to be a timed automaton .",
    "@xmath7and @xmath8are further restrictions of @xmath6where respectively the set of guards and the set of clocks of the controller are fixed a priori .",
    "thus , we consider the following hierarchy of problems : @xmath9 . unfortunately , while @xmath6 , @xmath7and @xmath8seem to make sense in practice , they turn out to be undecidable both on finite and infinite words  an answer to points  ( @xmath10 ) and  ( @xmath11 ) . our proofs are based on a _ novel _ encoding of halting problem for deterministic channel machines . by contrast , the undecidability results of @xcite ( for @xmath4 ) are reductions from the same problem , but their encoding relies heavily on the ability of @xmath4to express _ punctual constraints _ like ` every @xmath12 event is followed by a @xmath13 event _ exactly _ one time unit later ' , which is not allowed by @xmath1 . to the best of our knowledge ,",
    "our proofs are the first to perform such a reduction in a formalism that disallows punctual requirements  a somewhat unexpected result .",
    "then , we answer point  ( @xmath14 ) by considering a hierarchy of syntactic subsets of @xmath1(see  [ fig : decsummary ] ) and showing that , for all these subsets , @xmath7and @xmath8(hence also @xmath6and @xmath0 ) remain undecidable , on finite and infinite words .",
    "note that the undecidability proof of @xcite can not easily be adapted to cope with these cases , because it needs a mix of open and closed constraints ; while we prove undecidable very weak fragments of @xmath1where only closed or only open constraints are allowed .",
    "all these negative results shape a precise picture of the decidability border for real - time synthesis ( in particular , they answer open questions from @xcite,@xcite and  @xcite ) . on the positive side",
    ", we answer point ( @xmath15 ) by devising an on - the - fly algorithm to solve @xmath2(in the finite words case ) that runs in 3-@xmath5 .",
    "it relies on one - clock alternating timed automata ( as in  @xcite , but unlike @xcite that use timed automata ) , and on the recently introduced _ interval semantics _  @xcite .",
    "let @xmath16 be a finite alphabet .",
    "a ( finite ) timed word over @xmath16 is a finite word @xmath17 over @xmath18 with @xmath19 a non - decreasing sequence of non - negative real numbers .",
    "we denote by @xmath20 the set of finite timed words over @xmath16 . a _ timed language _ is a subset @xmath21 of @xmath20",
    ".    * timed logics . *",
    "we consider the reactive synthesis problem against various real - time logics , all of them being restrictions of metric temporal logic ( @xmath4 )  @xcite . the logic @xmath4is a timed extension of @xmath3 , where the temporal modalities are labelled with a timed interval . the formal syntax of @xmath4is given as follows : @xmath22{\\varphi}\\ ] ] where @xmath23 and @xmath24 is an interval over @xmath25 with endpoints in @xmath26 .",
    "we consider the _ pointwise semantics _ and interpret @xmath4formulas over timed words .",
    "the semantics of a formula @xmath27 in @xmath4is defined inductively in the usual way .",
    "we recall only the semantics of @xmath28 : given @xmath29 , and a position @xmath30 , we let @xmath31 { \\varphi}_2 $ ] if there exists @xmath32 such that @xmath33 , @xmath34 , and @xmath35 , for all @xmath36 .    with @xmath37 , we can recover the ` next ' operator @xmath38{\\varphi}:= \\bot\\until[i ] { \\varphi}$ ] , and we rely on the usual shortcuts for the ` finally ' , ` globally ' and ` dual - until ' operators : @xmath39{\\varphi}:= \\top\\until[i]{\\varphi}$ ] , @xmath40{\\varphi}:= \\neg\\finally[i]\\neg{\\varphi}$ ] and @xmath41 { \\varphi}_2 : = \\neg((\\neg{\\varphi}_1)\\until[i](\\neg { \\varphi}_2))$ ] .",
    "we also use the non - strict version of the ` until ' operator @xmath42 { \\varphi}_2 $ ] , defined as @xmath43{\\varphi}_2)$ ] ( if @xmath44 ) or @xmath45{\\varphi}_2 $ ] ( if @xmath46 ) .",
    "this notation yields the corresponding non - strict operators @xmath47 and @xmath48 in the natural way .",
    "when the interval @xmath24 is the entire set of the non - negative real numbers , the subscript is often omitted .",
    "we say that @xmath49 satisfies the formula @xmath27 , written @xmath50 if @xmath51 , and we denote by @xmath52 the set of all timed words @xmath49 such that @xmath50 .",
    "we consider mainly a restriction of @xmath53 called @xmath1(for metric interval temporal logic ) , in which the intervals are restricted to non - singular ones .",
    "we denote by @xmath54 the open fragment of @xmath1 : in negation normal form , each subformula @xmath55 { \\varphi}_2 $ ] has either @xmath24 open or @xmath56 and @xmath24 right - open , and each subformula @xmath57 { \\varphi}_2 $ ] has @xmath24 closed .",
    "then , a formula is in @xmath58 if it is the negation of an @xmath54 formula . by  @xcite ,",
    "@xmath54 formulas ( respectively , @xmath58 formulas ) translate to open ( closed ) timed automata  @xcite , i.e. , all clock constraints are strict ( non - strict ) .",
    "two other important fragments of @xmath4considered in the literature consist of @xmath59  @xcite , where each subformula @xmath55 { \\varphi}_2 $ ] has @xmath24 bounded in negation normal form , and @xmath60@xcite , where the formula satisfies the following in negation normal form :    in each subformula @xmath55 { \\varphi}_2 $ ] , if @xmath24 is unbounded then @xmath61 ; and    in each subformula @xmath57 { \\varphi}_2 $ ] , if @xmath24 is unbounded then @xmath62 .    for all of these logics @xmath63 , we can consider several restrictions .",
    "the restriction in which only the non - strict variants of the operators ( @xmath64 , @xmath65 , _ etc . _ ) are allowed is denoted by @xmath66 .",
    "the fragment in which all the intervals used in the formula are either unbounded , or have a left endpoint equal to 0 is denoted by @xmath67 $ ] . in this case",
    ", the interval @xmath24 can be replaced by an expression of the form @xmath68 , with @xmath69 , and @xmath70 .",
    "it is known that @xmath71 $ ] is expressively equivalent to @xmath72@xcite , which is itself a syntactic fragment of event - clock logic ( @xmath73 ) .",
    "finally , @xmath74 $ ] stands for the logic where ` until ' operators only appear in the form of @xmath39 $ ] or @xmath40 $ ] with intervals @xmath24 of the shape @xmath75 or @xmath76 .    *",
    "symbolic transition systems . *",
    "let @xmath77 be a finite set of variables , called clocks .",
    "the set @xmath78 of _ clock constraints _ @xmath79 over @xmath77 is defined by : @xmath80 , where @xmath81 , @xmath82 and @xmath83 .",
    "a _ valuation _ over @xmath77 is a mapping @xmath84 .",
    "the satisfaction of a constraint @xmath79 by a valuation @xmath85 is defined in the usual way and noted @xmath86 , and @xmath87 is the set of valuations @xmath85 satisfying @xmath79 . for @xmath88 , we let @xmath89 be the valuation defined by @xmath90 for all @xmath82 . for @xmath91 ,",
    "we let @xmath92 $ ] be the valuation defined by @xmath93)(x ) = 0 $ ] if @xmath94 , and @xmath93)(x ) = \\nu(x)$ ] otherwise .    following the terminology of @xcite , a _",
    "granularity _ is a triple @xmath95 where @xmath77 is a finite set of clocks , @xmath96 , and @xmath97 .",
    "a constraint @xmath79 is @xmath98-granular if @xmath99 and each constant in @xmath79 is of the form @xmath100 with an integer @xmath101 .",
    "a _ symbolic alphabet _",
    "@xmath102 based on @xmath103 is a finite subset of @xmath104 , where @xmath105 denotes all atomic @xmath106-granular clock constraints ( i.e. , clock constraints @xmath79 such that @xmath107 or @xmath108 , for every @xmath106-granular clock constraint @xmath109 ) .",
    "such a symbolic alphabet @xmath102 is said @xmath98-granular .",
    "a _ symbolic word _",
    "@xmath110 over @xmath102 generates a set of timed words over @xmath16 , denoted by @xmath111 such that @xmath112 if @xmath17 , and there is a sequence @xmath113 of valuations with @xmath114 the zero valuation , and for all @xmath30 , @xmath115 and @xmath116 $ ] ( assuming @xmath117 ) .",
    "intuitively , each @xmath118 means that action @xmath119 is performed , with guard @xmath120 satisfied and clocks in @xmath121 reset .",
    "a _ symbolic transition system _ ( sts ) over a symbolic alphabet @xmath102 based on @xmath103 is a tuple @xmath122 where @xmath123 is a possibly infinite set of locations , @xmath124 is the initial location , @xmath125 is the transition relation , and @xmath126 is a set of accepting locations ( omitted if all locations are accepting ) .",
    "an sts with finitely many locations is a _ timed automaton _ ( @xmath127 )  @xcite .",
    "for a finite path @xmath128 of @xmath129 ( i.e. , such that @xmath130 for all @xmath30 ) , the _ trace _ of @xmath131 is the word @xmath132 , and @xmath131 is _ accepting _ if @xmath133 .",
    "we denote by @xmath134 the language of @xmath129 , defined as the timed words associated to symbolic words that are traces of finite accepting paths starting in @xmath135 .",
    "we say that a timed action @xmath136 is _ enabled _ in @xmath129 at a pair @xmath137 , denoted by @xmath138 , if there exists a transition @xmath139 such that @xmath140 .",
    "the sts @xmath129 is _ time - deterministic _ if there are no distinct transitions @xmath141 and @xmath142 in @xmath143 and no valuation @xmath85 such that @xmath144 and @xmath145 . in a time - deterministic sts @xmath146 , for all timed words @xmath49 ,",
    "there is at most one path @xmath131 whose trace @xmath147 verifies @xmath148 . in that case , we denote by @xmath149 the unique ( if it exists ) pair @xmath137 ( where @xmath150 and @xmath85 is a valuation ) reached after reading @xmath112 .    [ ex : sts ] a time - deterministic @xmath127@xmath151 with a single clock @xmath152 is depicted in  [ fig : tdsts - plant ] .",
    "[ fig : ex - controller ]    intuitively , it accepts all timed words @xmath49 of the form @xmath153 where each @xmath154 is a timed word such that    either @xmath155 ;    or @xmath154 is a sequence of @xmath12 s ( starting at time stamp @xmath156 ) of duration at most @xmath157 ; and @xmath158 is either of the form @xmath159 , or of the form @xmath160 with @xmath161 .",
    "* reactive synthesis with plant . * to define our reactive synthesis problems , we partition the alphabet @xmath16 into controllable and environment actions @xmath162 and @xmath163 . following @xcite , the system is modelled by a time - deterministic @xmath127@xmath164 , called the _ _ plant _ _ and every valuation @xmath85 , there exists a timed action @xmath136 and a transition @xmath165 such that @xmath140 . ] .",
    "observe that the plant has accepting locations : only those runs ending in a final location of the plant will be checked against the specification .",
    "we start by recalling the definition of the general _ reactive synthesis _ family of problems ( @xmath0 ) @xcite .",
    "it consists in a game played by the controller and the environment , that interact to create a timed word as follows .",
    "we start with the empty timed word , and then , at each round , the controller and the environment propose timed actions to be performed by the system  therefore , they must be firable in the plant @xmath151respectively @xmath166 and @xmath167 , with @xmath168 , @xmath169 and @xmath170 . the timed action with the shortest delay ( or the environment action if the controller decides not to propose any action ) is performed , and added to the current play for the next round .",
    "if both players propose the same delay , we resolve the time non - deterministically .    on those games , we consider a parameterised family of reactive synthesis problems denoted @xmath171 , where @xmath172 ; @xmath173 ; and @xmath174 is one of the formalisms in  [ fig : decsummary ] .",
    "an instance of @xmath171 is given by a specification @xmath175 and a plant @xmath151 , which are interpreted over finite words when @xmath176 and infinite words when @xmath177 .",
    "the timed language @xmath178 is a specification of desired behaviours when @xmath179 and undesired behaviours when @xmath180 .",
    "then , @xmath171 asks whether there exists a strategy for the controller such that all the words in the outcome of this strategy are in @xmath178 ( or outside @xmath178 ) when we consider desired ( or undesired ) behaviours ( when @xmath181 , the definition of @xmath178 must be the infinite words one ) .",
    "if this is the case , we say that @xmath123 is _ ( finite - word ) realisable _ for the problem under study .",
    "for example , @xmath182 is the reactive synthesis problem where the inputs are a formula of @xmath183 and a plant , which are interpreted over the infinite words semantics , and where the @xmath183 formula specifies the behaviours that the controller should avoid .",
    "unfortunately , the variants @xmath0are too general , and a winning strategy might require unbounded memory :    [ ex : rs ] consider the alphabet @xmath184 with @xmath185 and @xmath186 , a plant @xmath151",
    "accepting @xmath20 , and the specification defined by the @xmath4 formula @xmath187 a ) \\rightarrow    \\finally[=1 ] b\\big)$ ] .",
    "clearly , a winning strategy for the controller is to remember the time stamps @xmath188 of all @xmath12 s , and always propose to play action  @xmath13 one time unit later ( note that if the environment blocks the time to prevent the controller from playing its @xmath13 , the controller wins ) .",
    "however this requires to memorise an unbounded number of time stamps with a great precision .",
    "* restrictions on the @xmath0problem . * in practice , it makes more sense to restrict the winning strategy of the controller to be implementable by an sts , which has finitely many clocks ( and if possible finitely many locations ) .",
    "let us define formally what it means for an sts @xmath189 to control a plant @xmath151 .",
    "we let @xmath190 be the _ set of timed words consistent with @xmath129 and @xmath151 _ , defined as the smallest set containing the empty timed word , and closed by the following operations .",
    "let @xmath49 be a word in @xmath190 , with @xmath191 , @xmath192 if @xmath193 , and @xmath194 be the last letter of @xmath49 otherwise .",
    "then , we extend @xmath49 as follows :    * either the controller proposes to play a controllable action @xmath195 , because it corresponds to a transition that is firable both in the controller and the plant . this action can be played ( @xmath49 is extended by @xmath196 ) , as well as any environment action @xmath197 with @xmath198 ( the environment can overtake the controller ) . formally , if @xmath199 is defined and @xmath200 : for all @xmath201 , we let @xmath202 and @xmath203 for all @xmath198 and @xmath204 such that @xmath205 . * or the controller proposes nothing , then the environment can play all its enabled actions . formally ,",
    "if @xmath199 is defined and @xmath206 and @xmath207 , we let @xmath203 for all @xmath208 .",
    "* otherwise , we declare that every possible future allowed by the plant is valid , i.e. , we let @xmath209 for all @xmath210 . this happens when the controller proposes only actions that are not permitted by the plant while the environment has no enabled actions ; or when the controller lost track of a move of the environment during the past .",
    "then , the _ @xmath4implementable reactive synthesis _",
    "problem @xmath211 ( on finite words and with desired behaviours ) is to decide , given a plant @xmath151 and a specification given as an @xmath4formula @xmath27 , whether there exists a set of clocks @xmath77 , a symbolic alphabet @xmath102 based on @xmath103 , and a time - deterministic sts @xmath129 over @xmath102 such that @xmath212 .",
    "is added for convenience , in case it is not already in  @xmath52 . ]",
    "while the definition of  @xmath213 is more practical than that of  @xmath214 , it might still be too general because the clocks and symbolic alphabet the controller can use are not fixed _ a priori_. in the spirit of @xcite , we define three variants of  @xmath6 .",
    "first , the _",
    "@xmath4 bounded - resources synthesis problem _ @xmath215 is a restriction of @xmath213 where the granularity of the controller is fixed : given an @xmath4formula @xmath27 , and a granularity @xmath216 , it asks whether there exists a @xmath98-granular symbolic alphabet @xmath102 based on @xmath103 , and a time - deterministic sts @xmath129 over @xmath102 such that @xmath212 .",
    "second , the less restrictive _ @xmath4bounded - precision synthesis problem _ @xmath217 and _ @xmath4bounded - clocks synthesis problem _ @xmath218 are the variants of @xmath6where _ only _ the precision and _ only _ the number of clocks are fixed , respectively .",
    "formally , @xmath217 asks , given an @xmath4formula @xmath27 , @xmath219 , and @xmath220 , whether there are a finite set @xmath77 of clocks , an @xmath106-granular symbolic alphabet @xmath102 based on @xmath103 , and a time - deterministic sts @xmath129 over @xmath102 such that @xmath212 .",
    "@xmath218 is defined similarly with an @xmath4formula @xmath27 , and a finite set of clocks @xmath77 ( instead of @xmath221 , @xmath222 ) as input .",
    "while we have defined @xmath6 , @xmath7 , @xmath8and @xmath2for @xmath4requirements , and in the finite words , desired behaviours case only , these definitions extend to all the other cases we have considered for @xmath0 : infinite words , undesired behaviours , and all fragments of @xmath4 .",
    "we rely on the same notations as for @xmath0 , writing for instance @xmath223 or @xmath224 , etc .",
    "consider the instance of @xmath225 where the plant accepts @xmath20 and the specification is @xmath226b))$ ] .",
    "this instance is negative ( @xmath27 is not realisable ) , since , for every time - deterministic sts @xmath129 , @xmath227 but is not in @xmath52 . however ,",
    "if we consider now the plant @xmath151 in  [ fig : tdsts - plant](a ) , we claim that the sts @xmath129 with one clock @xmath228 depicted in  [ fig : ex - controller](b ) realises @xmath27 . indeed , this controller resets its clock @xmath228 each time it sees the first @xmath12 in a sequence of @xmath12 s , and proposes to play a @xmath13 when @xmath228 has value @xmath157 , which ensures that all @xmath12 s read so far are followed by a @xmath13 within @xmath157 time unit .",
    "the restrictions enforced by the plant ( which can be regarded as a sort of fairness condition ) ensure that this is sufficient to realise @xmath27 for @xmath225 .",
    "this also means that @xmath27 is realisable for @xmath229 with precision @xmath230 and @xmath231 ; for @xmath232 with set of clocks @xmath233 ; and for @xmath234 with granularity @xmath235 .",
    "let us show that all the variants of @xmath7and @xmath8are undecidable , whatever formalism from  [ fig : decsummary ] we consider for the specification .",
    "this entails that all variants of @xmath0and @xmath6are undecidable too ( in particular @xmath236 which settles an open question of  @xcite negatively ) .",
    "to this aim , we show undecidability on the weakest formalisms in  [ fig : decsummary ] , namely : @xmath60 , @xmath59 , @xmath237 $ ] and @xmath238 $ ] .",
    "similar results have been shown for @xmath4(and for @xmath59as desired specifications ) in  @xcite via a reduction from the halting problem for deterministic channel machines , but their proof depends crucially on _ punctual _ formulas of the form @xmath239 b)$ ] which are not expressible in @xmath1 .",
    "our original contribution here is to adapt these ideas to a formalism without punctual constraints , which is non - trivial .",
    "* deterministic channel machines . * a _ deterministic channel machine _ ( dcm ) @xmath240 can be seen as a finite automaton equipped with an unbounded fifo channel , where @xmath123 is a finite set of states , @xmath135 is the initial state , @xmath241 is the halting state , @xmath242 is a finite set of messages and @xmath243 is the transition relation satisfying the following _ determinism _ hypothesis :    @xmath244 and @xmath245 implies @xmath246 ;    if @xmath247 then it is the only outgoing transition from @xmath248 .",
    "the semantics is described by a graph @xmath249 with nodes labelled by @xmath250 where @xmath251 and @xmath252 is the channel content .",
    "the edges in @xmath249 are defined as follows :    @xmath253 if @xmath247 ; and    @xmath254 if @xmath255 .",
    "intuitively , these correspond to messages being _ written to _ or _ read from _ the channel .",
    "a _ computation _ of @xmath256 is then a path in @xmath249 .",
    "the _ halting problem _ for dcms asks , given a dcm @xmath256 , whether there is a computation from @xmath257 to @xmath258 in @xmath249 for some @xmath252 .",
    "the halting problem for dcms is undecidable .",
    "it should be clear that @xmath256 has a unique computation . without loss of generality , we assume that @xmath241 is the only state in @xmath123 with no outgoing transition .",
    "it follows that exactly one of the following must be true :    @xmath256 has a halting computation ;    @xmath256 has an infinite computation not reaching @xmath241 ;    @xmath256 is blocking at some point , i.e. , @xmath256 is unable to proceed at some state @xmath259 ( with only _ read _ outgoing transitions ) either because the channel is empty or the message at the head of the channel does not match any of the outgoing transitions from @xmath248 .    * finite - word reactive synthesis for @xmath1 . * we now give a reduction from the halting problem for dcms to @xmath260 .",
    "the idea is to devise a suitable @xmath1formula such that in the corresponding timed game , the environment and the controller are forced to propose actions in turn , according to the semantics of the dcm .",
    "each prefix of the ( unique ) computation of the dcm is thus encoded as a play , i.e. , a finite timed word .",
    "more specifically , given a dcm @xmath256 , we require each play to satisfy the following conditions :    * the action sequence of the play ( i.e. , omitting all timestamps ) is of the form @xmath261 where @xmath262 is a special action of the controller and @xmath263 for each @xmath264 .",
    "* each @xmath265 comes with no delay and no two _ write _ or _",
    "read _ actions occur at the same time , i.e. , if @xmath266 is a substring of the play then @xmath267 and @xmath268 . *",
    "each @xmath269 is preceded exactly 1 time unit ( t.u . )",
    "earlier by a corresponding @xmath270 . *",
    "each @xmath270 is followed exactly 1 t.u .  later by a corresponding @xmath269 if there are actions that occur at least 1 t.u .  after the @xmath270 in question .    to this end",
    ", we construct a formula of the form @xmath271 where @xmath272 and @xmath273 are conjunctions of the conditions that the environment and the controller must adhere to , respectively .",
    "in particular , the environment must propose @xmath265 s according to the transition relation ( and ) whereas the controller is responsible for proposing @xmath274 properly so that a correct encoding of the writing and reading of messages is maintained ( , , and ) .",
    "when both players obey these conditions , the play faithfully encodes a prefix of the computation of @xmath256 , and the controller wins the play .",
    "if the environment attempts to ruin the encoding , the formula will be satisfied , i.e. , the play will be winning for the controller .",
    "conversely , if the controller attempts to cheat by , say , reading a message that is not at the head of the channel , the environment can pinpoint this error ( by proposing a special action @xmath275 ) and falsify the formula , i.e. , the play will be losing for the controller . in what follows ,",
    "let @xmath276 , @xmath277 , @xmath278 , @xmath279 , @xmath280 , @xmath281 , @xmath282 and @xmath283 .",
    "let us now present the formulas @xmath284 and @xmath285 needed to define @xmath272 and @xmath273 .",
    "we start by formulas enforcing condition .",
    "the play should start from @xmath135 , alternate between @xmath286-actions and @xmath287-actions , and the controller can win the play if the environment does not proceed promptly , and vice versa for the environment : @xmath288             { \\varphi}_\\textit{e } )      &   \\psi_2 & = \\neg \\wfinally ( { \\varphi}_\\textit{c } \\wedge \\next[{\\leqslant}1 ]                { \\varphi}_\\textit{c } ) \\\\",
    "{ \\varphi}_3 & = \\neg \\wfinally ( { \\varphi}_\\textit{wr } \\wedge \\next \\textit{win } )     & \\psi_3 & = \\neg \\wfinally ( { \\varphi}_s \\wedge \\neg s_\\textit{halt }               \\wedge \\next \\textit{lose } ) \\ , .",
    "\\end{aligned}\\ ] ] both players must also comply to the semantics of @xmath256 : @xmath289 once the encoding has ended , both players can only propose @xmath290 actions :    rcl _ 5 & = & ( ( s__halt _ @xmath291__check__^__lose _ _ _ win _ ) ( _ _ e _ _ nil___e _ ) ) + _ 5 & = & ( ( s__halt _ @xmath291__check__^__lose _ _ _ win _ ) ( _ _ c _ _ nil___c _ ) ) .    for condition",
    ", we simply state that the environment can only propose delay @xmath292 whereas the controller always proposes a positive delay : @xmath293             { \\varphi}_\\textit{e } ) \\quad    &      \\psi_6 & =   \\wglobally ( { \\varphi}_s \\wedge \\neg s_\\textit{halt } \\wedge               \\next { \\varphi}_\\textit{wr } \\implies \\next[>0 ]               { \\varphi}_\\textit{wr } ) \\ , . \\end{aligned}\\ ] ]    let us finally introduce formulae to enforce conditions and .",
    "note that a requirement like ` every write is matched by a read _ exactly _ one time unit later ' is easy to express in @xmath4 , but not so in @xmath1 .",
    "nevertheless , we manage to translate and in @xmath1by exploiting the game interaction between the players .",
    "intuitively , we allow the cheating player to be punished by the other .",
    "formally , to ensure , we allow the environment to play a @xmath275 action after any @xmath269 to check that this read has indeed occurred 1 t.u .  after the corresponding @xmath270 . assuming such a @xmath275 has occurred",
    ", the controller must enforce :    rcl ^ & = & _ m m ( m ! ( m ?",
    "@xmath291 ) ( m ? @xmath291 ) ) .    now , to ensure , the environment may play a @xmath294 action at least 1 t.u .  after a write on the channel . if this @xmath294 is the first action that occurs more than 1  t.u .",
    "after the writing ( expressed by the formula @xmath295 ) , we must check that the writing has been correctly addressed , i.e. , there has been an action exactly 1  t.u .",
    "after , _ and _ this action was the corresponding reading :    rcl @xmath296 & = & ( _ _ w _ _",
    "1^_0^ ) + ^ & = & ( _ _ w _ _",
    "1^_0^ ) ^    where @xmath297 $ ] is the formula obtained by replacing all @xmath275 with @xmath294 in @xmath298 , @xmath299 and @xmath300 . in the overall ,",
    "we consider :    rcl _ 7 & = & _ m m ( m ! _ _",
    "check__^ ) + _ 7 & = & ( @xmath291^ ) ( ( _ _ check__^@xmath296 ) ^ ) .    now let @xmath301 , @xmath302 and @xmath303 .",
    "[ prop : realizability ] @xmath304 is finite - word realisable if and only if either ( @xmath10 ) @xmath256 has a halting computation , or ( @xmath11 ) @xmath256 has an infinite computation not reaching @xmath241 . ) .",
    "this entails undecidability of the ` realisability problem ' , which is more restrictive than @xmath305 and another difference with respect to the proof in @xcite . ]",
    "if ( @xmath10 ) or ( @xmath11 ) is true , @xmath304 can be realised by the controller faithfully encoding a computation of @xmath256 .",
    "if @xmath286 proposes @xmath275 or @xmath294 , the play will satisfy @xmath306 . otherwise ,",
    "if @xmath256 has an infinite computation not reaching @xmath241 , the play can grow unboundedly and will satisfy all @xmath307 s , hence @xmath304 .",
    "conversely , if @xmath256 is blocking , then @xmath304 is not realisable .",
    "indeed , either the controller encodes @xmath256 correctly , but then at some point it will not be able to propose any action , and will be subsumed by the environment that will play @xmath308 . or the controller will try to cheat , by ( 1 ) inserting an action @xmath269 not matched by a corresponding @xmath270 1 t.u . earlier , or ( 2 ) writing a message @xmath270 that will not be read 1 t.u . later . for the first case , the environment can then play @xmath275 right after the incorrect @xmath269 , and the play will violate @xmath298 , hence @xmath306 and @xmath304 .",
    "for the second case , the environment will play @xmath294 after the first action occurring 1 t.u .",
    "after the unfaithful @xmath270 and the play will violate @xmath309 .",
    "now let @xmath310 , i.e. , we further require the computation not to reach @xmath241 .",
    "the following proposition can be proved almost identically .",
    "@xmath311 is finite - word realisable if and only if @xmath256 has an infinite computation not reaching @xmath241 .",
    "[ cor : halting ] @xmath256 has a halting computation if and only if @xmath304 is finite - word realisable but @xmath311 is not finite - word realisable .",
    "it follows that if @xmath260 is decidable , we can decide whether @xmath256 has a halting computation .",
    "but the latter is known to be undecidable . hence :    [ thm : realizability ] @xmath260 is undecidable .    theorem  [ thm : realizability ] and its proof are the core results from which we will derive all other undecidability results announced at the beginning of the section .",
    "[ rem : smtl ] one may show that the @xmath312 problem is undecidable for formulas of the form @xmath271 where @xmath272 and @xmath273 are conjunctions of formulas in @xmath313 $ ] by rewriting @xmath314 s and @xmath315 s ( see appendix  [ app : smtlrealisability ] ) .",
    "this answers an open question of  @xcite .",
    "* @xmath7and @xmath8for @xmath59 , @xmath60 , and @xmath1 . * in the proof of proposition  [ prop : realizability ] , if @xmath256 actually halts , the number of messages present in the channel during the ( unique ) computation is bounded by a number @xmath316 .",
    "it follows that the strategy of @xmath287 can be implemented as a bounded - precision controller ( with precision @xmath317 and @xmath316 clocks ) or a bounded - clocks controller ( with precision @xmath318 and a single clock ) .",
    "corollary  [ cor : halting ] therefore holds also for the bounded - precision and bounded - clocks cases , and the @xmath319 and @xmath320 problems are undecidable . by further modifying the formulas used in the proof of proposition  [ prop : realizability ] ,",
    "we show that the undecidability indeed holds even when we allow only unary non - strict modalities with lower - bound constraints and require the constraints to be exclusively strict or non - strict ( see appendix  [ app : openclosedmitl ] ) , hence @xmath321 and @xmath322 are undecidable too on @xmath237 $ ] and @xmath238 $ ] .",
    "this entails undecidability in the _ undesired specifications _",
    "case because the negation of an @xmath237 $ ] is a @xmath238 $ ] formula and vice - versa .",
    "finally , we can extend our proofs to the infinite words case ( see appendix  [ app : openclosedmitl ] ) , hence :    [ thm : openclosedmitl ] @xmath323 , @xmath324 , @xmath325 and @xmath326 are undecidable for @xmath327 ,    \\mathsf{closed-}{\\ensuremath{\\mathsf{mitl}}\\xspace}^{\\mathrm{ns}}[\\finally[\\infty]]\\}$ ] , @xmath172 and @xmath328 .",
    "this result extends the previous undecidability proofs of @xcite ( @xmath329 is undecidable ) , and of  @xcite ( @xmath330 and @xmath331 are undecidable ) . in light of these previous works ,",
    "our result is somewhat surprising as the undecidability proof in  @xcite is via a reduction from the universality problem for timed automata , yet this universality problem becomes decidable when all constraints are strict  @xcite .",
    "finally , it remains to handle the cases of @xmath59and @xmath60 .",
    "contrary to the case of @xmath4 , the infinite - word satisfiability problem is decidable for @xmath59  @xcite and the infinite - word model - checking problem is decidable for both @xmath59  @xcite and @xmath60  @xcite .",
    "nevertheless , our synthesis problems remain undecidable for these fragments ( see appendix  [ app : smtlcfmtl ] ) . in particular , the result on @xmath59answers an open question of  @xcite negatively :    [ thm : smtlcfmtl ] @xmath323 , @xmath324 , @xmath325 and @xmath326 are undecidable for @xmath332 , @xmath172 and @xmath328 .",
    "we have now characterised rather precisely the decidability border for @xmath1synthesis problems . in light of these results , we focus now on @xmath333 ( since @xmath1is closed under complement , one can derive an algorithm for @xmath334 from our solution ) . recall that the algorithm of dsouza and madhusudan @xcite , associated with the translation of @xmath1into @xmath127@xcite yields a 3  procedure for these two problems .",
    "unfortunately this procedure is unlikely to be amenable to efficient implementation .",
    "this is due to the translation from @xmath1to @xmath127and the need to determinise a region automaton , which is known to be hard in practice . on the other hand , bouyer _ et al .",
    "_ @xcite present a procedure for @xmath335 ( which can thus be applied to @xmath1requirements ) .",
    "this algorithm is on - the - fly , in the sense that it avoids , if possible to build a full automaton for the requirement ; and thus more likely to perform well in practice .",
    "unfortunately , being designed for @xmath4 , its running time can only be bounded above by a non - primitive recursive function .",
    "we present now an algorithm for @xmath333 that combines the advantages of these two previous solutions : it is _ on - the - fly _ and runs in 3 . to obtain an on - the - fly algorithm , bouyer _ et al . _",
    "use _ one - clock alternating automata _ ( ) instead of @xmath127to represent the @xmath1requirement .",
    "we follow the same path , but rely on the newly introduced _",
    "interval - based semantics _",
    "@xcite for these automata , in order to mitigate the complexity .",
    "let us now briefly recall these two basic ingredients ( due to lack of space , we only sketch the algorithm , a more complete presentation is in appendix  [ sec:3exp - algor - brrsst ] ) .",
    "*  and interval semantics . * alternating timed automata @xcite extend ( non - deterministic ) timed automata by adding _",
    "conjunctive transitions_. intuitively , conjunctive transitions spawn several copies of the automaton that run in parallel from the target states of the transition .",
    "a word is accepted iff _ all _ copies accept it .",
    "an example is shown in  [ fig : ocata ] , where the conjunctive transition is the hyperedge starting from @xmath336 . in the classical semantics ,",
    "an execution of an  is a sequence of set of states , named _",
    "configurations _ , describing the current location and clock valuation of all active copies .",
    "for example , a prefix of execution of the automaton in  [ fig : ocata ] would start in @xmath337 ( initially , there is only one copy in @xmath336 with the clock equal to @xmath292 ) ; then @xmath338 ( after letting @xmath339 time units elapse ) ; then @xmath340 ( after firing the conjunctive transition from @xmath336 ) , etc .",
    "it is well - known that all formulas @xmath27 of @xmath4(hence , also @xmath1 ) can be translated into an  @xmath341 that accepts the same language @xcite ( with the classical semantics ) ; and with a number of locations linear in the number of subformulas of @xmath27 .",
    "this translation is thus straightforward .",
    "this is the key advantage of  over @xmath127 : the complexity of the @xmath1formula is shifted from the syntax to the semantics  what we need for an on - the - fly algorithm .",
    "then ; in the _ interval semantics _",
    "@xcite , valuations of the clocks are not _ points _ anymore but _",
    "intervals_. intuitively , intervals are meant to approximate sets of ( punctual ) valuations : @xmath342)$ ] means that there _ are _ clock copies with valuations @xmath12 and @xmath13 in @xmath343 , and that there _ could be _ more copies in @xmath343 with valuations in @xmath344 $ ] . in this semantics",
    ", we can also _ merge _ two copies @xmath345)$ ] and @xmath346)$ ] into a single copy @xmath347)$ ] ( assuming @xmath348 ) , in order to keep the number of clock copies below a fixed threshold @xmath222 .",
    "it has been shown @xcite that , when the has been built from an @xmath1formula , the interval semantics is sufficient to retain the language of the formula , with a number of copies which is at most doubly exponential in the size of the formula .",
    "* sketch of the algorithm . * equipped with these elements , we can now sketch our algorithm for @xmath234 . starting from an @xmath1formula @xmath27 , a plant @xmath151 and a granularity @xmath95 , we first build , in polynomial time , an @xmath349 accepting @xmath350 .",
    "then , we essentially adapt the technique of bouyer _ et al . _",
    "@xcite , relying on the interval semantics of instead of the classical one .",
    "this boils down to building a tree that unfolds the parallel execution of @xmath349 ( in the interval semantics ) , @xmath151 and all possible actions of a @xmath98-granular controller ( hence the _ on - the - fly _ algorithm ) .",
    "since the granularity is fixed , there are only finitely many possible actions ( i.e. , guards and resets on the controller clocks ) for the controller at each step .",
    "we rely on the region construction to group the infinitely many possible valuations of the clocks into finitely many equivalence classes that are represented using ` region words ' @xcite .",
    "the result is a finitely branching tree that might still have infinite branches .",
    "we stop developing a branch once a global configuration ( of @xmath349 , @xmath151 , and the controller ) repeats on the branch . by the region construction _ and _ the interval semantics , this will happen on all branches , and we obtain a _ finite tree _ of size at most triply exponential .",
    "this tree can be analysed ( using backward induction ) as a game with a safety objective for the controller : to avoid the nodes where @xmath151 and @xmath349 accept at the same time .",
    "the winning strategy yields , if it exists , a correct controller .",
    "* experimental results .",
    "* we have implemented our procedure in java , and tested it over a benchmark related to a scheduling problem , inspired by an example of  @xcite .",
    "this problem considers @xmath351 machines , and a list of jobs that must be assigned to the machines .",
    "a job takes @xmath352 time units to finish .",
    "the plant ensures that at least one time unit elapses between two job arrivals ( which are uncontrollable actions ) .",
    "the specification asks that the assignment be performed in 1 time unit , and that each job has @xmath352 time units of computation time .",
    "we tested this example with @xmath353 , in which case the specification is realisable ( no matter the number of clocks , which we make vary for testing the prototype efficiency ) , and with @xmath354 , in which case it is not . table  [ tab : scheduler ] summarises some of our results .",
    "these results show that our prototypes can handle small but non - trivial examples .",
    "unfortunately  as expected by the high complexities of the algorithm ",
    "they do not scale well .",
    "as future works , we will rely on the well - quasi orderings defined in @xcite to introduce heuristics in the spirit of the antichain techniques @xcite .",
    "second , we will investigate zone - based versions of this algorithm to avoid the state explosion which is inherent to region based techniques .    10    r.  alur and d.  l. dill . a theory of timed automata .",
    ", 126(2):183235 , 1994 .",
    "r.  alur , t.  feder , and t.  a. henzinger .",
    "the benefits of relaxing punctuality . , 43(1):116146 , 1996 .",
    "a.  bohy , v.  bruyre , e.  filiot , n.  jin , and j.  raskin .",
    "acacia+ , a tool for ltl synthesis . in _ cav12 _ , lncs 7358 , springer .",
    "p.  bouyer , l.  bozzelli , and f.  chevalier .",
    "controller synthesis for mtl specifications . in _",
    "concur06 _ , lncs 4137 , springer .",
    "p.  bouyer , n.  markey , j.  ouaknine , and j.  worrell .",
    "the cost of punctuality . in _ lics07 _ , pages 109120 .",
    "d.  brand and p.  zafiropulo . on communicating finite state machines . ,",
    "30:323342 , 1983 .",
    "t.  brihaye , m.  estivenart , and g.  geeraerts . on mitl and alternating timed automata . in _",
    "formats13 _ , lncs 8053 , springer .",
    "t.  brihaye , m.  estivenart , g.  geeraerts , h .-",
    "ho , b.  monmege , and n.  sznajder .",
    "real - time synthesis is hard ! ( full version ) http://www.ulb.ac.be/di/verif/ggeeraer/papers/synthmitl.pdf    p.  e. bulychev , a.  david , k.  g. larsen , and g.  li .",
    "efficient controller synthesis for a fragment of @xmath355 .",
    ", 51(3 - 4):165192 , 2014 .",
    "f.  cassez , a.  david , e.  fleury , k.  g. larsen , and d.  lime .",
    "efficient on - the - fly algorithms for the analysis of timed games . in _ concur05 _",
    ", lncs 3653 , springer .    l.  de  alfaro , m.  faella , t.  a. henzinger , r.  majumdar , and m.  stoelinga .",
    "the element of surprise in timed games . in _ concur03 _",
    ", lncs 2761 , springer .",
    "l.  doyen , g.  geeraerts , j .- f .",
    "raskin , and j.  reichert .",
    "realizability of real - time logics . in _ formats09 _",
    ", lncs 5813 , springer .",
    "d.  dsouza and p.  madhusudan . timed control synthesis for external specifications . in _",
    "stacs02 _ , lncs 2285 , springer .",
    "m. estivenart .",
    "verification and synthesis of mitl through alternating timed automata .",
    "thesis , universit de mons , 2015 .",
    "e.  filiot , n.  jin , and j.  raskin .",
    "an antichain algorithm for ltl realizability . in _ cav09 _ , lncs 5643 , springer .",
    "r.  koymans . specifying real - time properties with metric temporal logic . , 2(4):255299 , 1990 .",
    "j.  ouaknine and j.  worrell .",
    "universality and language inclusion for open and closed timed automata . in _",
    ", lncs 2623 , springer .",
    "j.  ouaknine and j.  worrell .",
    "safety metric temporal logic is fully decidable . in _",
    "tacas06 _ , lncs 3920 , springer .",
    "j.  ouaknine and j.  worrell . on the decidability and complexity of metric temporal logic over finite words . , 3(1 ) , 2007 .",
    "a.  pnueli and r.  rosner . on the synthesis of an asynchronous reactive module . in _",
    "icalp89 _ , lncs 372 , springer .",
    "j .- f . raskin . .",
    "phd thesis , fundp ( belgium ) , 1999 .",
    "if ( @xmath10 ) or ( @xmath11 ) is true , then @xmath304 can be realized by the following strategy :    1 .   in round @xmath292",
    ", @xmath287 proposes @xmath356 with any @xmath357 . if @xmath358 then @xmath287 proposes @xmath359 with @xmath360 in round @xmath157 ; if @xmath361 then @xmath287 proposes @xmath362 with @xmath363 in round @xmath364 , and so on . if @xmath286 never supersedes then the play satisfies @xmath304 ( as it never violates any of @xmath307 s ) .",
    "if at any point @xmath286 supersedes with an action other than @xmath135 , the play will again satisfy @xmath304 ( by violating @xmath365 ) .",
    "if @xmath286 supersedes with @xmath135 , since @xmath273 is not violated , @xmath287 can proceed to step 2 . 2 .   in round @xmath10 ( @xmath366 ) with @xmath367 for some @xmath368",
    ", @xmath287 proposes @xmath369 with @xmath244 for some @xmath370 ( this corresponds to a transition in the computation ) .",
    "if the channel is not empty before round @xmath10 , let @xmath371 ( @xmath372 ) be the event that corresponds to the oldest pending message , i.e. , the message at the head of the channel .",
    "if @xmath373 for some @xmath221 , it must happen before the oldest pending message is read , i.e. , @xmath374 ; if the channel is empty then let @xmath375 .",
    "if @xmath376 for some @xmath221 , it must be reading the oldest pending message , i.e. , @xmath377 .",
    "since we have @xmath375 in all these cases , @xmath378 will be violated if @xmath286 supersedes .",
    "if @xmath286 does not supersede , proceed to step 3 .",
    "3 .   in round @xmath10 ( @xmath379 ) with @xmath380 and @xmath381 for some @xmath244",
    ", @xmath287 proposes @xmath382 with @xmath383 .",
    "if @xmath286 does not supersede , @xmath384 will be violated .",
    "if @xmath286 supersedes with some positive delay , @xmath385 will be violated .",
    "if @xmath286 proposes @xmath386 with @xmath387 , @xmath388 will be violated .",
    "now consider the remaining cases : * if @xmath389 and @xmath390 , go back to step @xmath364 . * if @xmath389 and @xmath391 , proceed to step @xmath392 . *",
    "if @xmath393 , then @xmath394 will be violated if @xmath373 for some @xmath221 . otherwise if @xmath376 for some @xmath221 , since @xmath395 is exactly 1 t.u .",
    "after the corresponding @xmath270 ( by step @xmath364 ) , all @xmath307 s ( in particular @xmath306 ) hold and @xmath287 may proceed to step @xmath392 . * if @xmath396 , then if @xmath373 for some @xmath221 , either ( 1 ) @xmath397 where @xmath371 corresponds to the oldest pending message ( by step @xmath364 ) or ( 2 ) all ` write ' actions before this @xmath270 have been followed 1 t.u .",
    "later by a corresponding ` read ' . in both cases",
    "@xmath295 does not hold , hence @xmath306 holds . if @xmath376 for some @xmath221 , then @xmath309 and hence @xmath306 clearly holds ( also by step @xmath364 ) .",
    "4 .   starting from round @xmath10 ( @xmath366 ) with @xmath398 , @xmath287 proposes @xmath399 with @xmath383 in the remaining rounds .",
    "if @xmath286 supersedes with an action other than @xmath400 , @xmath401 will be violated .",
    "note that if @xmath256 has an infinite computation not reaching @xmath241 and @xmath286 never proposes @xmath275 or @xmath294 , a play can grow unboundedly and @xmath287 will never reach step @xmath392 ; but any such play will satisfy all @xmath307 s and hence @xmath304 . for the other direction ,",
    "we show that if @xmath256 is blocking at some point then @xmath304 is not realizable , i.e. , @xmath286 can force a play that violates @xmath304 for any strategy of @xmath287 .    1 .   in round @xmath292",
    ", @xmath286 proposes @xmath402 . by the rules of the timed game",
    ", it is clear that no matter what @xmath287 proposes , there will be a play starting with @xmath403 , and @xmath286 can proceed to step @xmath364 .",
    "2 .   in round @xmath10 ( @xmath366 ) with @xmath367 for some @xmath404 , @xmath286 proposes @xmath405 .",
    "if @xmath287 does not supersede then @xmath406 will be violated .",
    "if @xmath287 supersedes with a delay of @xmath292 , @xmath407 will be violated .",
    "if @xmath287 supersedes with an action other than the available transitions at @xmath248 , @xmath408 will be violated .",
    "it remains to consider the case @xmath409 for some @xmath244 and @xmath410 .",
    "consider the following cases : * if @xmath373 for some @xmath221 and either ( 1 ) @xmath411 where @xmath371 corresponds to the oldest pending message or ( 2 ) all ` write ' actions before this @xmath270 have been followed 1 t.u .",
    "later by a corresponding ` read ' , proceed to step @xmath412 ; otherwise proceed to step @xmath392 . *",
    "if @xmath376 for some @xmath221 and ( 1 ) @xmath377 for some @xmath413 in the play and ( 2 ) @xmath413 is the oldest pending message , proceed to step @xmath412 ; otherwise if @xmath413 is not the oldest pending message , proceed to step @xmath392",
    ". if there is no such @xmath413 in the play , proceed to step @xmath414 .",
    "3 .   in round @xmath10 ( @xmath366 ) with @xmath415 , @xmath286 proposes @xmath416 where @xmath244 .",
    "there will be a play with @xmath389 and @xmath286 can go back to step @xmath364 .",
    "4 .   in round @xmath10 ( @xmath366 ) with @xmath381 and either ( 1 ) @xmath373 and @xmath417 where @xmath418 is the timestamp of the oldest pending message or",
    "( 2 ) @xmath376 and @xmath419 with @xmath420 is in the play but is not the oldest pending message , @xmath286 proposes @xmath421 ; there will be a play with @xmath396 ( violating @xmath306 ) .",
    "5 .   in round",
    "@xmath10 ( @xmath366 ) with @xmath422 and there is no @xmath413 in the play with @xmath423 , @xmath286 proposes @xmath424 ; there will be a play with @xmath425 ( violating @xmath306 ) .",
    "either @xmath286 wins at step @xmath364 ( if @xmath287 does not supersede ) or @xmath286 will eventually proceed to step @xmath392 or @xmath414 and wins .",
    "it is clear that @xmath426 and @xmath427 are already @xmath313 $ ] formulas . for @xmath407",
    ", we can replace it by @xmath428 { \\varphi}_\\textit{wr})$ ] . for @xmath429 and @xmath306 , we can replace @xmath298 by    l @xmath291(@xmath291(@xmath291 ) ) + _ ( ( m ! m ? )",
    "@xmath291 ) ( m ? @xmath291 ) )    and replace @xmath297 $ ] accordingly .",
    "we give reductions from the halting problem for dcms to @xmath430 and @xmath431 ( @xmath432 ) , @xmath433 , and the corresponding @xmath8problems .",
    "the remaining cases follow ( more or less ) directly from existing results  @xcite .",
    "the encoding we use here is very similar to the one used in section  [ sec : undecidability]the main difference is that we now use a plant , in place of formulas , to ensure @xmath434 and @xmath435 ( see below ) . without loss of generality",
    ", we consider a dcm @xmath240 where @xmath436 , @xmath135 has an outgoing ` write ' action , and @xmath241 is the only state in @xmath123 with no outgoing transition .",
    "the plant @xmath437 over @xmath438 is constructed as follows :    * @xmath439 , @xmath440 , @xmath441 ; * @xmath442 , @xmath443 , @xmath444 , and * * @xmath445 and @xmath446 for all @xmath447 with @xmath390 * * @xmath445 and @xmath448 for all @xmath449 * * @xmath450 for all @xmath451 * * @xmath452 for all @xmath453 * * @xmath454 + where @xmath152 is reset on every transition .",
    "in what follows , let @xmath455 , @xmath456 and @xmath457 $ ] .",
    "the encoding we have in mind is as follows :    * the action sequence of the play ( i.e. omitting all timestamps ) is of the form @xmath458 where @xmath459 is a trace of @xmath249 . *",
    "each @xmath290 comes with no delay and no two ` write ' or ` read ' actions occur at the same time , i.e. , if @xmath460 is a substring of the play then @xmath267 and @xmath268 . *",
    "each @xmath269 is preceded exactly 1 t.u .",
    "earlier by a corresponding @xmath270 . *",
    "each @xmath270 is followed exactly 1 t.u .",
    "later by a corresponding @xmath269 if there are actions that occur at least 1 t.u .",
    "after it .",
    "it is clear that @xmath434 and @xmath435 are enforced by the plant @xmath461 .",
    "now let @xmath462 and @xmath463 , where @xmath464 and @xmath465 are obtained from the corresponding formulas in section  [ sec : undecidability ] by replacing @xmath466 and @xmath467 with their `",
    "hatted ' counterparts . in essentially the same way as before , @xmath468 and @xmath469 are ensured by these formulas , and one can prove that @xmath256 has a halting computation if and only if there is a bounded - precision or bounded - clocks controller for @xmath470 and @xmath461 but no such controller for @xmath471 and @xmath461 .",
    "this claim holds in both the finite- and infinite - word cases , thanks to the self - loop @xmath472 in @xmath461 .",
    "* @xmath59 . * to show that @xmath473 and @xmath474 where @xmath432 are undecidable , we rewrite formulas @xmath470 and @xmath475 so that their negations are @xmath59formulas .    for each @xmath476 that ends with @xmath294 ,",
    "we have    l ( _ _ w _ _",
    "1^_0^ ) + _ 0^ ( _ 1^ ( ( _ _ w _ ) ( _ 0^ ) ) )    and    l ( _ _ w _ _",
    "1^_0^ ) + _ 0^ ( _ 1^ ( ( _ _ w _ ) ( _ 0^ ) ) ) .",
    "let @xmath477 and @xmath478 be the formulas obtained by replacing corresponding subformulas in @xmath479 and @xmath480 , respectively .",
    "one can verify that their negations are in @xmath59 .",
    "* @xmath60 . * first note that the negations of @xmath477 and @xmath478 are in @xmath60 , hence @xmath433 and @xmath481 are undecidable . then , to show that both @xmath482 and @xmath483 where @xmath432 are undecidable , we rewrite @xmath479 and @xmath480 into @xmath60formulas .",
    "this can be accomplished by the equivalences in the following proposition .    for each @xmath476 , we have    l _ m m ( m !",
    "@xmath291 ) ( m ? @xmath291 ) ) + @xmath291(_0^(_0^ ) ) _ ( ( m !",
    "( m ? _ 0^ ) )    and    l _ m m ( m !",
    "@xmath484 ) ( m ? @xmath484 ) ) + ( _ _ r _ @xmath484 ) ( _ 0^(_0^ ) ) _ ( ( m ! m ? )",
    "( m ? _ 0^ ) ) .",
    "one can verify that the resulting formulas @xmath485 and @xmath486 ( obtained by replacing corresponding subformulas in @xmath479 and @xmath480 , respectively ) are in @xmath60 .",
    "we give reductions for @xmath487)$ ] ( @xmath488)$ ] ) as well as @xmath489)$ ] ( @xmath490)$ ] ) where @xmath432 , and the corresponding @xmath8problems . without loss of generality",
    ", we consider a dcm @xmath240 where @xmath436 , @xmath135 has an outgoing ` write ' action , and @xmath241 is the only state in @xmath123 with no outgoing transition . in what follows , we will use the plant @xmath461 and the subformulas @xmath491 , @xmath492 and @xmath493 ( defined earlier in appendix  [ app : smtlcfmtl ] ) and let @xmath494 .    * @xmath495 $ ] as the desired specification . * in this case , we can use the encoding based on @xmath434@xmath469 as given in appendix  [ app : smtlcfmtl ] .",
    "we know that @xmath434 and @xmath435 are enforced by @xmath461 .",
    "now we give the formulas for the other conditions :    1 .",
    "( @xmath468 ) : + rcl _ 1 & = & _ m m ( m !",
    "@xmath291 ) ) ( m ?",
    "@xmath291 ) ) ) .",
    "2 .   ( @xmath469 ) : + rcl _ 2 & = & ( _ _ w _ _",
    "1^_0^ ) _ ( m ! _ 2^(m ! _ 1^ ) _ 0^ ) .",
    "the overall formulas are    rcl _ 2 & = & _ 1 _ 2 + _ 2 & = & _ 1 _ 2 _ halt _ .",
    "now we can state a proposition similar to proposition  [ prop : realizability ] .",
    "indeed , the only anomaly that may go undetected is when there is an @xmath270 at time @xmath496 and the controller reaches @xmath241 by an @xmath497 at @xmath498 with @xmath499 ; however in that case , the controller may as well propose @xmath497 at @xmath500 ( for some @xmath501 ) and reach @xmath241 in a way that respects the encoding .",
    "@xmath256 has a halting computation if and only if there is a bounded - precision or bounded - clocks controller for @xmath502 and @xmath461 but no such controller for @xmath503 and @xmath461 .",
    "finally , note that we can replace , e.g. , @xmath504 \\hat{\\theta}_0^\\rightarrow$ ] by @xmath505 \\hat{\\theta}_0^\\rightarrow \\wedge \\neg \\wfinally \\big(\\varphi_\\textit{wr } \\wedge \\wfinally ( \\textit{nil } \\wedge \\wfinally \\hat{\\theta}_0^\\rightarrow)\\big)\\ ] ] since @xmath491 will happen at most once ; and we can replace , e.g. , @xmath506 \\big(m ?",
    "\\wedge ( m ? \\wuntil { \\ensuremath{\\textit{check}^\\leftarrow}})\\big)$ ] by @xmath507 \\big(m ?",
    "\\wedge ( m ? \\wuntil { \\ensuremath{\\textit{check}^\\leftarrow}})\\big)\\ ] ] since @xmath508 will happen at most once .",
    "* @xmath509 $ ] as the desired specification . *",
    "it is known that open timed automata accepts @xmath510-open sets of timed words , i.e. , whenever they accept a timed word , they also accept all neighbouring timed words that are sufficiently ` close ' to that timed word ( see  @xcite for details ) .",
    "recall that @xmath468 asserts that each @xmath270 is followed by a corresponding @xmath269 at exactly 1 t.u . later",
    "; this condition is clearly not @xmath510-open .",
    "indeed , it is not possible to give an @xmath509 $ ] formula @xmath511 such that    rcl ^__open _ _ & & ( m ! , 0)(_nil _ , 0)(m ?",
    ", 1)(@xmath291 , 1 ) + ^__open _ _ & & ( m !",
    ", 0)(_nil _ , 0)(m ?",
    ", 1-)(@xmath291 , 1- )    for any @xmath512 .",
    "since @xmath461 does not affect the timing of events , we have to switch to a @xmath510-open encoding where we use @xmath513 and @xmath514 in place of @xmath468 and @xmath469 :    * each @xmath269 at @xmath496 is preceded by a corresponding @xmath270 at @xmath515 where ( @xmath10 ) @xmath516 is the maximal timestamp in @xmath517 $ ] , ( @xmath11 ) @xmath518 is the timestamp of the first ` write ' or ` read ' action before @xmath269 . *",
    "each @xmath270 at @xmath496 is followed , if there are actions that occur at time @xmath519 , by a corresponding @xmath269 at @xmath520 where ( @xmath10 ) @xmath516 is the minimal timestamp in @xmath521 , ( @xmath11 ) @xmath518 is the timestamp of the first ` write ' or ` read ' action after @xmath270 .",
    "it is clear that @xmath434 and @xmath435 are enforced by the plant @xmath461 .",
    "the rest of the conditions will be ensured by the following formulas :    1 .",
    "( @xmath513 ) : + rcl _ 1 & = & _ m m ( m !",
    "( m ? _ 0^ ) ( _ nil _ _",
    "0^ ) ( _ nil _ ( _ _ wr _ _ 0^ ) ) ) .",
    "( @xmath514 ) : + rcl _ _ _ fst__^ & = & ( _ _ w _ _ 0^(_nil _ _ 0^ ) ) + ^ & = & ( _ _ w _ _ 0^(_nil _ _ 0^ ) ( _ nil _",
    "( _ _ wr _ _ 0^ ) ) ) _ 1[@xmath484/@xmath291 ] .",
    "the overall formulas are    rcl _ 1 & = & _ 1 ( @xmath484(___fst__^^ ) ) + _ 1 & = & _ 1 ( @xmath484(___fst__^^ ) ) _ halt _ .",
    "@xmath256 has a halting computation if and only if there is a bounded - precision or bounded - clocks controller for @xmath523 and @xmath461 but no such controller for @xmath524 and @xmath461 .",
    "finally , note that we can replace all ` until ' subformulas as before .",
    "in this appendix , we present with more details the algorithm for @xmath333 that we have briefly sketched in section  [ sec : boundreacsynt ] . an even more exhaustive presentation of the algorithm can be found in  @xcite .",
    "our decision procedure is based on the translation of @xmath1formulas into equivalent _ one - clock alternating timed automata _ ( ) , a model of timed automata with a single clock but transitions dynamically forking to check several properties in parallel .",
    "a _ one - clock alternating timed automaton _ ( shortly , ) over the alphabet @xmath16 is a tuple @xmath525 where @xmath21 is a finite set of locations , @xmath526 is the initial location , @xmath527 is a set of final locations , and @xmath528 , where @xmath529 is the set of formulas @xmath530 defined by @xmath531 where @xmath532 , @xmath533 is the unique clock , @xmath534 and @xmath535 .",
    "intuitively , @xmath536 means that clock @xmath152 must be reset to @xmath292 .",
    "whereas disjunctions denote classical non - determinism , conjonctions moreover denote that two objectives must be fulfilled in the sequel . indeed",
    ", operations of @xmath529 may always be equivalently written in disjunctive normal form .    for instance",
    ", consider the depicted in  [ fig : ocata ] .",
    "it consists of two locations @xmath336 ( initial and final ) and @xmath537 . the transition function is defined by : @xmath538 , @xmath539 , @xmath540 , and @xmath541 .",
    "intuitively , when reading an @xmath12 from @xmath336 , two copies are created : one continues in location @xmath336 , and another , with a fresh clock @xmath152 reset to @xmath292 , goes to @xmath537 .",
    "location @xmath537 is used to ensure that a letter @xmath13 is read at most 1 time unit after this splitting .",
    "therefore , this recognises the same timed language as the mitl formula @xmath542b)$ ] .",
    "see @xcite for a thorough definition of the semantics .",
    "as already said , all @xmath1formulas may be inductively translated into equivalent : this is the base step to the use of well - quasi order techniques to obtain the decidability ( with a non primitive recursive complexity ) of @xmath335 in  @xcite . using the fact that the coming from @xmath1formulas can be translated into non - deterministic timed automata , the decidability of the problem @xmath333 is more directly obtained by the result of @xcite . combining the blow - up in the size of the non - deterministic timed automaton equivalent to an @xmath1formula and the 2-@xmath5 complexity of the @xmath2realisability check of @xcite for timed automata , we obtain that @xmath333 can be decided in 3-@xmath5 .",
    "however , this technique requires the construction and determinisation of a full region automaton , which prevents its use in practice .",
    "therefore , our second contribution is to give an _ on - the - fly _ algorithm to solve the problem @xmath2over @xmath1 , yet keeping a 3-@xmath5 theoretical upper - bound , that avoids the construction and determinisation of the full region automaton .",
    "the main idea is to use the interval semantics of @xcite for the obtained from the formula .",
    "the classical semantics of an is defined in terms of states ( a pair composed of a location and a valuation of the unique clock @xmath533 of the ) , and configurations ( a set of states ) .",
    "instead , in @xcite is introduced the alternative _ interval semantics _ , that allows for pairs of location and _ interval_. intuitively , several instances of the same location with different valuations are _ merged _ together , to gain in concision .",
    "[ ex : ocata ] for the of  [ fig : ocata ] , one possible configuration in the interval semantics consists of @xmath543),(\\ell_1,[0.1,0.4 ] ) , ( \\ell_1,[0.5,0.9])\\}$ ] . in this configuration , reading a letter @xmath13 after a delay of @xmath544 time units will make disappear the two last pairs , since the guard @xmath545 over the transition exiting from @xmath537 is entirely fulfilled in both intervals after translation of delay @xmath544 .",
    "for the first pair , reading a @xmath13 will simply translate the current interval .",
    "therefore , we have the sequence @xmath546)\\}$ ] .",
    "reading letter @xmath12 after a delay of @xmath544 would in contrary keep the two last pairs , by translating the intervals , and split the first pair : one goes back to @xmath336 after translation , the second copy goes to @xmath537 with a fresh copy of clock @xmath533 .",
    "then , there is a choice : either merging the new copy with the next interval associated to location @xmath537 , or keeping a singleton interval .",
    "therefore , we have two possible transitions : @xmath547),(\\ell_1,[0,0.5 ] ) ,    ( \\ell_1,[0.6,1])\\}$ ] and @xmath548),(\\ell_1,[0,0]),(\\ell_1,[0.2,0.5 ] ) ,    ( \\ell_1,[0.6,1])\\}$ ] .    by applying the translation of @xcite , from every @xmath1formula @xmath27",
    ", we can build an equivalent @xmath549 .",
    "moreover , a good merging function is described in  @xcite that permits to keep the same timed language : it non - deterministically merges intervals in case there are too many ( more than a given constant @xmath550 ) associated with the same location . in particular , this allows authors of @xcite to produce directly a non - deterministic timed automaton @xmath551 that uses @xmath552 clocks ( one for each endpoint of the intervals ) , and is equivalent to @xmath27 .",
    "we now explain our solution for @xmath333 .",
    "therefore , we fix a formula @xmath27 of @xmath1 , a plant @xmath553 with clocks @xmath554 , and a granularity @xmath216 such that @xmath555 .",
    "we suppose built the @xmath556 over the clock @xmath557 , and the merging function associated with the _ negation of the formula_.    * unfolding the system . *",
    "intuitively , our synthesis problem can be solved by considering an infinite tree which unfolds all the possible parallel executions of @xmath151 , @xmath558 , and all the possible controllers .",
    "this tree should contain information on the configuration of the system ( plant , and controller ) .",
    "precisely , _ configurations _ of the system are tuples @xmath559 where @xmath560 , and @xmath286 is a finite set of tuples @xmath561 , with @xmath85 a valuation of the clocks @xmath77 of the controller , @xmath562 a valuation of the clocks @xmath554 of the plant , and @xmath287 a configuration of @xmath558 with at most @xmath550 intervals associated to each location .",
    "we then describe the _ dynamics _ of the system . in each configuration ,",
    "symbolic letters that can be played are in @xmath563 : it is composed of an action in @xmath16 , an atomic guard over the clocks that can observe the controller ( so not on the clocks copies of @xmath558 ) , and a set of clocks chosen by the controller to be reset . for a symbolic letter @xmath564 , and configurations @xmath565 and @xmath566 , we write @xmath567 if there is a transition of the plant @xmath568 , and an ( atomic ) guard of the controller s clock @xmath569 such that :          * making the tree finite . * the previous tree , starting from the unique initial configuration @xmath573 , [ x_{\\mathcal p}\\mapsto 0 ] , \\{(\\ell_0 , [ 0,0])\\})\\}\\big)$ ] , unfolding all the executions of the system , is infinitely branching , because of the density of time , and has infinite depth . here is how we cope with these difficulties . first ,",
    "to deal with the density of time , we use the classical _ region equivalence _",
    "@xcite : we choose regions that are compatible with the precision @xmath574 , we label the nodes of the tree by ( sets of ) regions , and we unfold symbolic actions based on the precision @xmath574 . moreover ,",
    "another source of unboundedness relates with the @xmath558 that may create unboundedly many clock copies during its execution : we rely on the interval semantics and the merging function to cope with that issue , which is equivalent to fixing a finite set of clock copies @xmath575 for @xmath558 .",
    "therefore , labels of the nodes are approximated with _ region words _",
    ", only keeping relevant information in terms of regions and order of the fractional parts of the clocks . the alphabet used for the letters of the region words will be @xmath576 .",
    "pairs @xmath577 of @xmath578 represents , the fact that the valuation of clock @xmath533 is in region @xmath579 .",
    "triples @xmath580 are now used to describe that in the configuration of @xmath558 , there exists an interval ( of index @xmath351 smaller than the number @xmath581 of intervals allowed in the interval semantics ) with one of its bound in region @xmath579 , associated with location @xmath343 . a configuration @xmath559 with @xmath582",
    "is then symbolically represented by the location @xmath583 , and a set of region words @xmath584 over the alphabet @xmath585 , for each tuple @xmath586 , defined as follows .",
    "we first associate to the tuple @xmath587 the set @xmath588      & \\hspace{3 cm } \\,\\mid c_j(\\ell ) = \\{i_1,\\ldots , i_m\\}\\big\\ } \\,.\\end{aligned}\\ ] ] the set @xmath589 is then partitioned into a sequence of subsets @xmath590 depending on the fractional parts : for all @xmath591 , for every pair @xmath592 or triple @xmath593 of @xmath594 , and pair @xmath595 or triple @xmath596 of @xmath597 , we have @xmath598 if , and only if , @xmath599 . then , @xmath584 is the finite word from @xmath600 given by @xmath601 , where for all @xmath602 , @xmath603        this allows us to lift the transition relation to sets of word regions : we let @xmath614 if there exists configurations @xmath147 and @xmath604 such that @xmath615 , @xmath616 , and @xmath617 .",
    "therefore , we unfold the transition relation over sets of word regions , starting from a root labelled by @xmath618 ( recall that @xmath573 , [ x_{\\mathcal p}\\mapsto 0 ] , \\{(\\ell_0 , [ 0,0])\\})\\}\\big)$ ] is the unique initial configuration ) .",
    "region words guarantee that the tree is finitely branching , yet it could still have infinite branches .",
    "contrary to the algorithm of @xcite that deals with @xmath4formulas ( and thus general ) , we do not need to use well - quasi order techniques to cut branches of the tree .",
    "indeed , labels of the nodes of the tree are now taken from a finite alphabet , and we simply stop the exploration of a branch if a node @xmath619 has the same label as one of its ancestor @xmath620 : intuitively , if @xmath620 is declared winning , the controller will win if he plays in @xmath620 as he reacts in @xmath619 .",
    "we also stop the exploration when we reach a deadlock , or a node whose label  that we will call _ losing label_contains at the same time a final location of @xmath151 , and one of the region word where every location of @xmath558 is final : this represents a final configuration of the , and models the violation of the specification @xmath27 . because there is only a finite number of possible labels",
    ", this ensures that the tree @xmath156 hence constructed is finite .    *",
    "turning the finite tree into a game .",
    "* we finally define the game considered on this tree , modeling the realisability question .",
    "a strategy for the controller is a mapping from each node labelled @xmath621 , that is not a leaf of the tree , towards a valid subset of symbolic actions available in this node , i.e. , a subset @xmath622 verifying the following properties :    1 .   for all @xmath623 ,",
    "there exists @xmath624 such that @xmath625 ; 2 .   if @xmath626 , i.e. , an action of the controller is proposed , then there exists @xmath623 with @xmath169 such that , for all actions @xmath627 fireable from @xmath621 _ before _",
    "@xmath572 ( i.e. , such that @xmath79 is a time - successor of @xmath109 ) and with @xmath170 , @xmath628 contains an action @xmath629 fireable from @xmath621 : notice that not all such actions @xmath627 need to appear in @xmath628 , since the controller must retain the choice of clock he wants to reset ; 3 .   if @xmath630 , i.e. , no actions of the controller are proposed , then , for all actions @xmath627 fireable from @xmath621 with @xmath170 , @xmath628 contains an action @xmath629 also fireable from  @xmath621",
    "we declare the tree @xmath156 winning in case there exists a strategy @xmath631 in @xmath156 such that no reachable leaf from the root when following choices of the strategy has a losing label .",
    "we can decide if the finite tree @xmath156 is winning , and in such case compute a winning strategy , using the classical backward induction technique .",
    "* correctness .",
    "* we show that there is a controller for the instance of @xmath333 if and only if there is a winning strategy for the controller in the corresponding ( finite ) tree .",
    "first , it is easy to check that , _ if _ there exists a controller for the @xmath2problem , _ then _ we can extract a winning strategy from it . therefore , we only give a sketch of the other implication : _ if _ the tree is winning , _ then _ there exists a controller for the @xmath2problem .",
    "consider that the tree @xmath156 is winning , and call @xmath131 a winning strategy .",
    "intuitively , the locations of the controller we extract from @xmath156 are labelled by @xmath156 s nodes , and , for all controller locations labelled by node @xmath619 , the outgoing transitions should correspond to the winning set of valid actions @xmath632 .",
    "unfortunately , the situation is not so simple , because the node @xmath619 could be a leaf that has not been developed because of an ancestor @xmath620 with the same label .",
    "in this case , the controller simply mimics in @xmath619 the decision taken in @xmath620 and goes up in the tree .",
    "all details settled , we obtain :    the tree @xmath156 is winning if and only if there exists a controller in the @xmath333 problem , i.e. , there exists a @xmath106-granular symbolic alphabet @xmath102 based on @xmath103 , and a time - deterministic sts @xmath129 over @xmath102 such that @xmath633 .",
    "as already announced , a first advantage of this technique ( contrary to previous methods of @xcite ) is that we do not require to construct the non - deterministic timed automaton equivalent to the @xmath1specification .",
    "another advantage is the possibility to build the tree on - the - fly , i.e. , to return a positive or negative answer to the realisability check , as soon as we are able to compute it , without constructing the whole execution tree .",
    "notice moreover that , following techniques presented , e.g. , in @xcite , it may be possible to conclude very quickly whether or not the tree @xmath156 is winning , by back - propagating as early as possible information regarding the winning status of a node : for instance , if a winning strategy has been found while exploring a node @xmath619 , it might induce a winning strategy for the parent @xmath620 of @xmath619 , inducing that we can stop the exploration of other children of @xmath620 . in the worst - case scenario , the size of the tree will still be bounded by the size of the game constructed in @xcite for @xmath1which ensures the 3-@xmath5 theoretical upper - bound for our algorithm . in practice however , the exploration of the tree might yield much more quickly to a positive or negative answer for the realisability question ."
  ],
  "abstract_text": [
    "<S> we study the reactive synthesis problem ( @xmath0 ) for specifications given in metric interval temporal logic ( @xmath1 ) . @xmath0is </S>",
    "<S> known to be undecidable in a very general setting , but on infinite words only ; and only the very restrictive @xmath2subcase is known to be decidable ( see dsouza _ et al . _ and bouyer _ et al . _ ) . in this paper , we precise the decidability border of @xmath1synthesis . </S>",
    "<S> we show @xmath0is undecidable on finite words too , and present a landscape of restrictions ( both on the logic and on the possible controllers ) that are still undecidable . on the positive side , </S>",
    "<S> we revisit @xmath2 and introduce an efficient on - the - fly algorithm to solve it . </S>"
  ]
}