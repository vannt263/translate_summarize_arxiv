{
  "article_text": [
    "data structures for querying moving objects were extensively investigated in computational geometry and database communities . the orthogonal range reporting problem , i.e. the problem of storing a set of points @xmath4 in a data structure so that all points in a query rectangle @xmath5 can be reported , was also extensively studied for the case of moving points . in this paper",
    "we describe a data structure that supports range reporting queries for a set of moving points on a @xmath0 grid , i.e. , when all point coordinates are positive integers bounded by a parameter @xmath6",
    ".    * previous and related results . *",
    "the kinetic data structure framework proposed by basch",
    "_ et al . _",
    "@xcite is the standard model for studying moving objects in computational geometry .",
    "the main idea of their approach is to update the data structure for a set @xmath4 of continuously moving objects only at certain moments of time : updates are performed only when certain _ events _ changing the relevant combinatorial structure of the set @xmath4 occur . for instance , the data structure may be updated when the order of projections of points on the @xmath7-axis changes or the closest pair of points in @xmath4 changes ; see e.g. ,  @xcite for a more detailed description .",
    "the kinetic variant of the range tree data structure was presented by basch , guibas , and zhang  @xcite ; their data structure uses @xmath8 space , answers @xmath9-dimensional queries in @xmath10 time , and can be updated after each event in @xmath11 time ; henceforth @xmath2 denotes the number of points in the answer .",
    "the two - dimensional data structure of agarwal , arge , and erickson  @xcite supports range reporting queries in @xmath12 time and uses @xmath13 space ; the cost of updating their data structure after each event is @xmath14 .",
    "as follows from standard information - theoretic arguments , the @xmath15 query time is optimal in the infinite - precision kinetic model .",
    "linear space kinetic data structures were considered by agarwal , gao , and guibas  @xcite and abam , de berg , and speckmann  @xcite . however these data structures have significantly higher query times : the fastest linear space construction  @xcite answers @xmath9-dimensional queries in @xmath16 time .",
    "a number of geometric problems can be solved more efficiently when points lie on a grid , i.e. , when coordinates of points are integers bounded by a parameter @xmath6 . in the case of range reporting , significant speed - up",
    "can be achieved if the set of points @xmath4 does not change .",
    "there are static data structures that support orthogonal range reporting queries in @xmath17 time  @xcite . on the other hand ,",
    "if points can be inserted into or deleted from @xmath4 , then any data structure that supports updates in @xmath18 time needs @xmath19 time to answer a two - dimensional range reporting query  @xcite .",
    "this bound is also valid in the case when all points belong to a @xmath0 grid .    *",
    "our result . * in this paper we consider the situation when coordinates of moving points belong to a @xmath0 grid .",
    "our data structure supports orthogonal range reporting queries in @xmath20 time .",
    "this result is valid in the standard kinetic model with additional conditions that all points move with fixed velocities along linear trajectories and all changes in the trajectories are known in advance .",
    "queries can be answered at any time @xmath21 , where @xmath21 is a positive integer bounded by @xmath22 .",
    "updates are performed only when @xmath7- or @xmath23-coordinates of any two points in @xmath4 swap their relative positions , and each update takes poly - logarithmic time .",
    "the total number of events after which the data structure must be updated is @xmath24 .",
    "for instance , for @xmath25 our data structure answers queries in @xmath26 time .",
    "our result also demonstrates that the lower bound for dynamic range reporting queries can be surpassed in the case when the set @xmath4 consists of linearly moving points .",
    "our data structure uses @xmath27 space and supports updates in @xmath28 time , but space usage and update cost can be reduced if only special cases of reporting queries must be supported .",
    "we describe a @xmath29 space data structure that supports updates in @xmath15 time and dominance queries in @xmath20 time .",
    "we also describe a @xmath30 space data structure that supports updates in @xmath14 time and three - sided queries in @xmath20 time .",
    "in section  [ sec : onedim ] we show that we can find the predecessor point of any @xmath31 in the set @xmath4 ( with respect to @xmath7- or @xmath23-coordinates ) in @xmath32 time by answering a point location query among a set of segments .",
    "in fact , identifying the predecessor of a point @xmath33 is the bottleneck of our query answering procedure .    in section  [ sec : domin ]",
    "we describe the data structure that reports all points @xmath34 that dominate the query point @xmath33 , i.e. all points @xmath35 such that @xmath36 and @xmath37 ; henceforth @xmath38 and @xmath39 denote the @xmath7- and @xmath23-coordinates of a point @xmath35 .",
    "the query time of our data structure is @xmath20 .",
    "the data structure is based on the modification of the @xmath9-approximate boundary  @xcite for the kinetic framework .",
    "the @xmath9-approximate boundary  @xcite enables us to obtain an estimation for the number of points in @xmath4 that dominate an arbitrary point @xmath33 .",
    "if a point @xmath33 dominates a point on a @xmath9-approximate boundary @xmath40 , then @xmath33 is dominated by at most @xmath41 points of @xmath4 ; if @xmath33 is dominated by a point on @xmath40 , then @xmath33 is dominated by at least @xmath9 points of @xmath4 . in section  [ sec : domin ] we show that a variant of a @xmath9-approximate boundary can be maintained under kinetic events .",
    "if a query point @xmath33 is dominated by @xmath42 points of @xmath4 , we can reduce the dominance query on @xmath4 to a dominance query on a set that contains @xmath15 points using a @xmath9-approximate boundary for @xmath43 ; see section  [ sec : domin ] . otherwise , if @xmath44 , we can answer a query in @xmath45 time using a standard kinetic data structure  @xcite .    a data structure that supports dominance queries",
    "can be transformed into a data structure that supports arbitrary orthogonal range reporting queries  @xcite by dividing the set @xmath4 into subsets @xmath46 and constructing dominance data structures for each @xmath46 as described in section  [ sec : orth ] .",
    "however , we may have to delete a point @xmath35 from one subset @xmath46 and insert it into a subset @xmath47 after a kinetic event .",
    "unfortunately , the construction of  @xcite is static .",
    "it is not clear how ( and whether ) to modify the @xmath9-approximate boundary , so that insertions and deletions are supported .",
    "however , in our case the deleted ( inserted ) point always has the maximal or minimal @xmath7- or @xmath23-coordinate among all points in @xmath46 ( @xmath47 )",
    ". we will describe in section  [ sec : orth ] how our dominance data structure can be modified to support these special update operations without increasing the query time .",
    "our technique is similar to the logarithmic method and can be of independent interest .",
    "thus we obtain the data structure for general orthogonal range reporting queries .",
    "let @xmath48 and @xmath49 denote the sets of @xmath7- and @xmath23-coordinates of all points at time @xmath21 . in this section",
    "we will describe how we can identify the predecessor of any @xmath50 in @xmath48 ( resp .",
    "of @xmath51 in @xmath49 ) at current time @xmath21 in @xmath52 time using a linear space data structure .",
    "let @xmath53 be the equation that describes the @xmath7-coordinate of the point @xmath54 at time @xmath21 .",
    "the trajectory of the point in @xmath55 plane ( @xmath21-axis is horizontal ) is a sequence of segments .",
    "since we assume that all changes of point trajectories are known in advance , endpoints of all segments are known in advance .",
    "two points swap ranks of their @xmath7-coordinates at time @xmath21 if and only if their segments intersect at time @xmath21 .",
    "we can find intersection points of all segments using the standard sweepline algorithm  @xcite in @xmath56 time , where @xmath57 is the number of segment intersections .",
    "we start the sweepline at @xmath58 and move it to the right until @xmath59 intersection points are identified or the last intersection point is found .",
    "these intersection points and the corresponding segments induce a subdivision of the @xmath60 plane of size @xmath29 .",
    "we can construct the data structure for planar point location  @xcite that supports queries in @xmath32 time .",
    "let @xmath61 be the largest @xmath21-coordinate of the already processed intersection point .",
    "for @xmath62 , we can find the predecessor of any @xmath7 by locating the segment lying immediately below the point @xmath55 .",
    "when @xmath63 , we continue the sweepline algorithm and find the next @xmath59 segment intersection points .",
    "the algorithm described in  @xcite finds @xmath57 next segment intersection points @xmath64 time . since the point location data structure  @xcite for a subdivision of size",
    "@xmath57 can be constructed in @xmath65 time , an amortized cost of processing a kinetic event is @xmath15 .",
    "we can de - amortize the update cost using standard techniques .",
    "in this section we describe the data structure that reports all points from @xmath4 that dominate the query point @xmath33 , i.e. all points in the region @xmath66 .",
    "our data structure is based on maintaining the @xmath9-approximate boundary for a set @xmath4 .",
    "the notion of a @xmath9-approximate boundary is introduced in  @xcite ; in this paper we change the definition and describe a kinetic version of this construction .    for a horizontal segment @xmath67 ,",
    "we denote by @xmath68 and @xmath69 @xmath7-coordinates of the left and the right endpoint of @xmath67 ; we denote by @xmath70 the @xmath23-coordinate of all points on @xmath67 .",
    "we will say that a segment @xmath67 covers a point @xmath35 if the @xmath7-coordinate of @xmath35 belongs to @xmath71 $ ] . in this paper",
    "we define a @xmath9-approximate boundary as a polyline @xmath40 that consists of alternating horizontal and vertical segments , divides the plane into two parts , and satisfies the following properties :    [ inv : segm ] let @xmath67 and @xmath72 be two consecutive horizontal segments",
    ". then @xmath73 .",
    "[ inv : lpoint ] when a new segment @xmath67 is inserted , the left endpoint of @xmath67 is dominated by at most @xmath74 points of @xmath4",
    ". the number of points in @xmath4 that dominate the left endpoint of a segment @xmath75 does not exceed @xmath41 .",
    "[ inv : rpoint ] when a new segment @xmath67 is inserted , the right endpoint of @xmath67 is dominated by at least @xmath9 points .",
    "the number of points in @xmath4 that dominate the right endpoint of a segment @xmath75 remains constant .",
    "using invariants  [ inv : segm]-[inv : rpoint ] , we can prove the following lemma .",
    "every point on a @xmath9-approximate boundary @xmath40 is dominated by at least @xmath9 points and at most @xmath41 points of @xmath4 .",
    "there are @xmath76 horizontal segments in @xmath40 .",
    "if a point @xmath77 is dominated by @xmath2 points from @xmath4 , then the left endpoint of some segment @xmath67 is dominated by at least @xmath2 points and the right endpoint of some segment @xmath72 is dominated by at most @xmath2 points .",
    "hence , it follows from invariants  [ inv : lpoint ] and [ inv : rpoint ] that @xmath78 . by invariant  [ inv : segm ] , for two consecutive segments @xmath72 and @xmath67 there are more than @xmath79 points @xmath34 , such that @xmath38 belongs to the interval @xmath80 $ ] .",
    "for each point @xmath35 , @xmath38 belongs to at most two such intervals ; hence , the total number of segments is less than @xmath81 .",
    "an example of a @xmath9-approximate boundary is shown on fig  [ fig : tapprox - example ] .",
    "-approximate boundary for @xmath82 . ]",
    "we will show below how the concept of a @xmath9-approximate boundary can be used to support dominance queries in @xmath20 time . later in this section",
    "we will show how invariants  [ inv : segm ] -[inv : rpoint ] can be maintained .",
    "+ * kinetic boundary .",
    "* we will use a kinetic variant of the @xmath9-approximate boundary , i.e. segments of the boundary move together with points of @xmath4 . for every horizontal segment @xmath67 in a boundary @xmath40 ,",
    "let @xmath83 denote the point with the largest @xmath23-coordinate such that @xmath84 and let @xmath85 denote the point with the smallest @xmath23-coordinate such that @xmath86 .",
    "let @xmath87 denote the point with the smallest @xmath7-coordinate such that @xmath88 ; let @xmath89 denote the point with the largest @xmath7-coordinate such that @xmath90 .",
    "we assume that @xmath91 and @xmath92 .",
    "that is , the left end and the @xmath23-coordinate of a segment change when @xmath85 and @xmath87 move .",
    "the right end of the previous segment and the @xmath7-coordinate of the connecting vertical segment change accordingly .",
    "* answering queries . *",
    "our data structure is based on a @xmath9-approximate boundary @xmath40 of @xmath4 for @xmath43 . for each segment",
    "@xmath75 we maintain the set @xmath93 of all points that dominate the left endpoint of @xmath67 .",
    "obviously , the set @xmath93 changes only when events concerning @xmath87 or @xmath85 take place .",
    "all points of @xmath93 are stored in a data structure @xmath94 that supports dominance queries in @xmath95 time .",
    "we can use the data structure of  @xcite , so that the space usage is @xmath96 and updates after events are supported in @xmath97 time .",
    "it is possible to modify the data structure of  @xcite , so that points can be inserted into @xmath93 or deleted from @xmath93 in @xmath97 time .",
    "all points of @xmath4 are also stored in a kinetic data structure @xmath98 that uses @xmath29 space and supports dominance queries in @xmath99 time and updates after kinetic events in @xmath15 time .",
    "again , we can use the result of  @xcite to implement @xmath98 .",
    "finally , we must be able to identify for each point @xmath34 the segment @xmath75 that covers @xmath35 . using the dynamic union - split - find data structure of  @xcite or the van emde boas data structure  @xcite",
    ", we can find the segment that covers any @xmath34 in @xmath97 time .",
    "when a new segment is inserted into or deleted from @xmath40 , the data structure is updated in @xmath97 time .    given a query point @xmath33 , we identify the point @xmath35 with the largest @xmath7-coordinate such that @xmath100 ; this can be done in @xmath32 time using the construction described in section  [ sec : onedim ] .",
    "the point @xmath33 dominates a point on @xmath40 if and only if @xmath33 dominates the left endpoint of the segment @xmath67 that covers @xmath35 or the left endpoint of the segment @xmath101 that follows @xmath67 .",
    "suppose that @xmath33 dominates a point on @xmath40 .",
    "then @xmath33 is dominated by at most @xmath41 points of @xmath4 .",
    "let @xmath102 be the left endpoint of a segment @xmath103 , such that @xmath102 is dominated by @xmath33 .",
    "each point @xmath34 that dominates @xmath33 also dominates @xmath102 ; hence , all points that dominate @xmath33 belong to @xmath104 .",
    "we can use the data structure @xmath105 and report all points that dominate @xmath33 in @xmath106 time .",
    "suppose that @xmath33 does not dominate any point on @xmath40 .",
    "then there is at least one point on @xmath40 that dominates @xmath33 .",
    "hence , there are @xmath107 points of @xmath4 that dominate @xmath33 .",
    "using data structure @xmath98 , we can report all points that dominate @xmath33 in @xmath45 time . + * maintaining the @xmath9-approximate boundary .",
    "* it remains to show how to maintain invariants  [ inv : segm]-[inv : rpoint ] after operations @xmath7-move and @xmath23-move .",
    "henceforth , we will use the following notation .",
    "suppose that @xmath108 before some kinetic event and @xmath109 after this event .",
    "then , we say that @xmath35 is @xmath7-moved behind @xmath33 ( @xmath33 is @xmath7-moved before @xmath35 ) .",
    "suppose that @xmath110 before some kinetic event and @xmath111 after this event .",
    "then , we say that @xmath35 is @xmath23-moved above @xmath33 ( @xmath33 is @xmath23-moved below @xmath35 ) . each kinetic event can be represented as a combination of at most one @xmath7-move and at most one @xmath23-move .",
    "first , we consider the invariant  [ inv : lpoint ] .",
    "suppose that the left endpoint of an interval @xmath67 is dominated by @xmath41 points of @xmath4 .",
    "let @xmath101 be the segment that precedes @xmath67 , i.e. , @xmath112 . let @xmath102 be the vertical segment that connects @xmath101 and @xmath67 .",
    "we look for a point @xmath35 with @xmath113 and @xmath114 such that @xmath35 is dominated by @xmath74 points .",
    "if such a point @xmath35 exists , we set @xmath115 and search for a point @xmath116 with @xmath117 and @xmath118 such that @xmath116 is dominated by @xmath9 points of @xmath4 . if there is no such point , i.e. , if the point @xmath119 is dominated by at least @xmath9 points , we replace @xmath67 with a segment @xmath120 such that the left endpoint of @xmath120 is @xmath121 and the right endpoint of @xmath120 is the point @xmath119 ; see fig  [ fig : lpoint]a .",
    "in other words we change the @xmath23-coordinate of @xmath67 to @xmath39 .",
    "the new set @xmath93 contains @xmath74 points and can be constructed in @xmath96 time .",
    "if there is a point @xmath116 with @xmath117 and @xmath118 that is dominated by @xmath9 points of @xmath4 , then we replace @xmath67 with two new segments @xmath120 and @xmath122 . the left and right endpoints of @xmath120 are @xmath123 and @xmath124 respectively .",
    "the left endpoint of @xmath122 is the point @xmath125 such that @xmath126 and @xmath127 .",
    "see fig  [ fig : lpoint]b .",
    "the set @xmath128 contains @xmath74 points .",
    "there are at most @xmath79 points @xmath33 such that @xmath129 and @xmath130 ; hence , there are at most @xmath79 points @xmath33 such that @xmath131 and @xmath130 .",
    "therefore , since @xmath116 is dominated by @xmath9 points of @xmath4 , @xmath125 is dominated by at most @xmath74 points of @xmath4 and @xmath132 contains at most @xmath74 points . since @xmath125 is dominated by the right endpoint of the segment @xmath67",
    ", @xmath132 contains at least @xmath9 points .",
    "we can construct @xmath128 and @xmath132 and data structures @xmath133 and @xmath134 in @xmath96 time .",
    "if the right endpoint of @xmath101 is dominated by at least @xmath74 points , we shift the vertical segment @xmath102 in @xmath135 direction , so that the right endpoint of @xmath101 is dominated by @xmath9 points from @xmath4 or the segment @xmath67 is removed .",
    "that is , we identify the point @xmath72 with @xmath136 such that either @xmath137 and @xmath72 is dominated by at least @xmath9 points of @xmath4 or @xmath138 and @xmath72 is dominated by @xmath9 points of @xmath4 . if @xmath138 , we set @xmath139 and update @xmath93 , @xmath94 accordingly ( @xmath96 points are removed from @xmath93 and @xmath94 ) .",
    "see fig  [ fig : lpoint]c .",
    "the new left endpoint of @xmath67 is dominated by at most @xmath74 points .",
    "if @xmath137 , we remove the segment @xmath67 with @xmath94 and @xmath93 .",
    "the update procedure removes at most one segment and inserts at most two new segments that satisfy the invariant  [ inv : lpoint ] .",
    "hence , the update procedure takes @xmath140 time .    [ cols=\"^,^,^,^,^ \" , ]     we can handle the @xmath7-moves in a similar way .",
    "let @xmath101 be the horizontal segment that follows @xmath67 in @xmath40 , i.e. , @xmath141 .",
    "when a point @xmath35 is @xmath7-moved we change @xmath69 ( and @xmath68 ) so that the number of points that dominate the right endpoint of @xmath67 remains unchanged .",
    "suppose that a point @xmath142 with @xmath143 is @xmath7-moved behind @xmath144 ; let @xmath145 denote the new @xmath7-coordinates of @xmath35 and let @xmath33 be the point with the smallest @xmath7-coordinate such that @xmath146 .",
    "+ ( a ) if @xmath147 , then we set @xmath148 and remove @xmath144 from @xmath149 and @xmath150 . if @xmath151 for the horizontal segment @xmath152 that follows @xmath101 , then we delete the segment @xmath101 and @xmath149 .",
    "+ ( b ) if @xmath153 , then we set @xmath154 ; we also remove @xmath144 from @xmath149 and @xmath150 and insert @xmath35 into @xmath149 and @xmath150 .",
    "+ ( c ) if @xmath155 , then we set @xmath156 .",
    "if @xmath151 for the horizontal segment @xmath152 that follows @xmath101 , then we delete the segment @xmath101 and @xmath149 .",
    "+ suppose that a point @xmath35 with @xmath143 is @xmath7-moved before @xmath89 . + ( d ) if @xmath157 , then we set @xmath154 ; we add @xmath89 to @xmath149 and @xmath150 .",
    "+ ( e ) if @xmath158 , then we set @xmath159 ; we also remove @xmath35 from @xmath149 and @xmath150 and insert @xmath89 into @xmath149 and @xmath150 .",
    "+ ( f ) if @xmath160 , then we set @xmath154 .",
    "we add @xmath89 to @xmath149 and @xmath150 + again the number of points in @xmath94 remains unchanged or increases by @xmath161 .",
    "we will show in the full version that we update @xmath162 because invariants  [ inv : lpoint ] or  [ inv : segm ] are violated at most once for @xmath163 events .",
    "update procedures for maintaining invariants  [ inv : segm ] and  [ inv : lpoint ] involve inserting and deleting a constant number of segments into @xmath40 and the data structure @xmath94 for every segment @xmath67 contains @xmath96 points .",
    "hence , we must perform @xmath164 amortized updates of data structures @xmath94 after each kinetic event .",
    "since every update of @xmath94 takes @xmath165 time , the amortized cost of updating after an event is @xmath97 .",
    "since each data structure @xmath94 can be constructed in @xmath15 time , the worst - case update time is @xmath15 . + * construction of a @xmath9-approximate boundary .",
    "* now we show that @xmath9-approximate boundary can be constructed in @xmath29 time if points are sorted by @xmath7- and @xmath23-coordinates .",
    "since a @xmath9-approximate boundary consists of alternating horizontal and vertical segments , it suffices to determine the endpoints of horizontal segments .",
    "we can guarantee that the left endpoint of each segment is dominated by @xmath74 points of @xmath4 and the right endpoint of each segment is dominated by @xmath9 points of @xmath4 using the following algorithm .",
    "lists @xmath166 and @xmath167 contain points of @xmath4 sorted in descending order of their @xmath7-coordinates and @xmath23-coordinates respectively . with every element of @xmath166 we store a pointer to its position in @xmath167 and",
    "vice versa .",
    "the pointer @xmath168 ( @xmath169 ) points to the first not yet processed element in @xmath166 ( @xmath167 ) .",
    "we construct a sequence of horizontal and vertical segments so that the left endpoint of each segment is dominated by @xmath74 points and the right endpoint of each segment is dominated by @xmath9 points .",
    "we assign @xmath169 to the @xmath170-th element of @xmath167 and @xmath168 to the first element of @xmath166 ; the point @xmath121 with @xmath171 and @xmath172 is the left endpoint of the first segment .",
    "clearly , @xmath121 is dominated by @xmath74 points .",
    "( 1 ) the right endpoint of the segment with left endpoint @xmath121 can be found as follows .",
    "we traverse elements of @xmath166 that follow @xmath168 until @xmath173 points @xmath33 such that @xmath174 are visited and update @xmath168 accordingly .",
    "the point @xmath116 with @xmath175 and @xmath118 is the right endpoint of the currently constructed horizontal segment .",
    "( 2 ) we identify the left endpoint of the next segment by traversing elements of @xmath167 that follow @xmath169 until @xmath79 points @xmath33 such that @xmath176 are visited or we reach the end of the list @xmath167 .",
    "the pointer @xmath169 is updated accordingly .",
    "if we reached the end of @xmath167 , then all points are processed and the algorithm is completed .",
    "otherwise we set @xmath177 and @xmath178 , go to step ( 1 ) and determine the right endpoint of the next segment .",
    "there exists a linear space data structure that supports dominance queries for a set of linearly moving points on @xmath0 grid in @xmath1 time and updates after kinetic events in @xmath15 worst - case time .",
    "the amortized cost of updates is @xmath97 .",
    "if trajectories of the points do not change , then the total number of kinetic events is bounded by @xmath24 .",
    "three - sided range reporting queries and orthogonal range reporting queries can be reduced to dominance queries with help of standard techniques .",
    "however to apply these techniques in our scenario , we must modify the data structure of section  [ sec : domin ] , so that insertions and deletions are supported in some special cases . at the end of this section",
    "we demonstrate how our data structure with additional operations can be used to support arbitrary orthogonal range reporting queries .",
    "* additional update operations . *",
    "we first describe the data structure that supports insertions and deletions in two special cases : let @xmath179 and @xmath180 be the smallest and the largest @xmath7-coordinates of points in @xmath4 . the operation",
    "@xmath181 inserts a point @xmath35 with @xmath182 .",
    "the operation @xmath183 deletes a point @xmath35 with @xmath184 .",
    "operations @xmath185 and @xmath186 insert and delete a point whose @xmath7-coordinate is smaller than @xmath7-coordinates of all other points in @xmath4 .",
    "it is easy to augment our data structure so that @xmath185 and @xmath186 are supported : the inserted ( deleted ) point is either below a @xmath9-approximate boundary @xmath40 or dominates only the leftmost horizontal segment of @xmath40 .",
    "hence , each @xmath185 and @xmath186 affects the data structure @xmath94 for at most one segment @xmath67 .",
    "essentially we can handle @xmath185 and @xmath186 in the same way as @xmath7-moves for the leftmost segment @xmath67 . maintaining the @xmath9-approximate boundary @xmath40 after @xmath181 and @xmath183",
    "is more involved : since the @xmath23-coordinate of a newly inserted ( deleted ) point can be larger than the @xmath23-coordinates of all ( other ) points in @xmath35 , we may have to update data structures @xmath94 for all segments @xmath75 after a single update operation .",
    "below we describe how @xmath181 and @xmath183 can be supported .",
    "our approach is similar to the logarithmic method  @xcite that is used to transform static data structures into data structures that support insertions .",
    "we construct the data structure of section  [ sec : domin ] augmented with @xmath185 and @xmath186 for sets @xmath187 .",
    "a point @xmath35 @xmath7-overlaps with point @xmath33 if @xmath188 .",
    "a point @xmath35 @xmath7-overlaps with a set @xmath4 if it @xmath7-overlaps with at least one point @xmath189 .",
    "each set @xmath190 satisfies the following conditions :    1 .   for @xmath191",
    ", @xmath190 contains between @xmath192 and @xmath193 points ; @xmath194 contains between @xmath195 and @xmath196 points 2 .",
    "each point of @xmath197 @xmath7-overlaps at most @xmath198 points in @xmath199 3 .   at most @xmath200 points from @xmath190 @xmath7-overlap with @xmath199    as follows from conditions 2 and 3 , no element of @xmath201 @xmath7-overlaps with @xmath199 : the rightmost point in @xmath201 @xmath7-overlaps at most @xmath195 leftmost points in @xmath190 by condition 2 .",
    "only @xmath200 rightmost points in @xmath190 can @xmath7-overlap with a point in @xmath199 .",
    "hence , any @xmath202 that @xmath7-overlaps a point in @xmath199 would @xmath7-overlap @xmath203 points in @xmath190 , which contradicts condition 2 .    for @xmath204",
    ", we maintain @xmath205 and @xmath206 .",
    "all @xmath207 are stored in a kinetic binary search tree . for each @xmath208 , @xmath209 , a point @xmath210 such that @xmath211 and @xmath212 is stored in a kinetic data structure @xmath213",
    "; since @xmath213 contains @xmath15 points , @xmath213 supports dominance reporting queries in @xmath106 time .",
    "the data structure @xmath214 , @xmath215 , contains all points from @xmath216 and supports dominance queries , @xmath7-moves and @xmath23-moves as described in section  [ sec : domin ] . to speed - up update operations",
    ", we store only one data structure @xmath98 for all points in @xmath217 .",
    "@xmath98 is implemented as described in  @xcite , supports dominance queries in @xmath99 time and can be modified to support arbitrary updates as well as kinetic events in @xmath15 time .",
    "we also store one data structure @xmath218 that contains @xmath7-coordinates of all points @xmath217 and enables us to search in the set of @xmath7-coordinates at any time @xmath9 .",
    "that is , all @xmath214 share one data structure @xmath98 and one data structure @xmath218 . for each @xmath208",
    "we also store all points of @xmath216 in a list @xmath219 that contains all points from @xmath216 in the descending order of their @xmath23-coordinates .    given a query @xmath220 , we can find in @xmath221 time the smallest index @xmath208 , such that at least one point in @xmath216 has @xmath7-coordinate smaller than @xmath222 . then , as follows from conditions 2 and 3 , @xmath7-coordinates of all points in @xmath223 are greater than @xmath222 , and both @xmath224 and @xmath225 may contain points whose @xmath7-coordinates are greater than or equal to @xmath222 .",
    "sets @xmath226 , @xmath227 , contain only points whose @xmath7-coordinates are smaller than @xmath222 . using @xmath213 , we can identify all @xmath228 such that @xmath229 and @xmath228 contains at least one point @xmath35 with @xmath230 . for every such @xmath57 all points @xmath35 such that @xmath231 and @xmath230 can be reported by traversing the list @xmath232 . hence , reporting all points @xmath231 such that @xmath229 , @xmath233 and @xmath234 takes @xmath106 time .",
    "we can report all points in @xmath216 and @xmath225 that belong to @xmath220 in @xmath235 time using data structures @xmath214 and @xmath236 respectively .",
    "it remains to show how conditions 1 - 3 above can be maintained .",
    "clearly , conditions 1 - 3 are influenced by @xmath7-moves and operations @xmath185 , @xmath186 , @xmath181 and @xmath183 ; @xmath23-moves can not violate them .",
    "we say that a set @xmath4 is _ @xmath7-split _ into sets @xmath237 and @xmath238 if @xmath239 and the @xmath7-coordinates of all points in @xmath237 are larger than the @xmath7-coordinates of all points in @xmath238 .",
    "after an operation @xmath181 or @xmath183 , we re - build the data structure for @xmath240 in @xmath164 time .",
    "when the number of elements in a set @xmath216 , @xmath241 , becomes smaller than @xmath242 or greater than @xmath243 , we @xmath7-split the set @xmath244 into two new sets @xmath245 and @xmath246 , so that @xmath245 contains @xmath247 points and @xmath246 contains @xmath248 points .",
    "if the number of elements in @xmath194 exceeds @xmath249 we @xmath7-split @xmath216 into sets @xmath250 and @xmath251 that contain @xmath252 and @xmath253 points respectively .",
    "suppose that the number of points in @xmath194 is smaller than @xmath254 . if @xmath255 , we set @xmath256 and decrement @xmath257 by @xmath161 . if @xmath258 , we @xmath7-split @xmath259 into @xmath260 and @xmath250 that contain @xmath254 and @xmath261 points respectively .",
    "we also take care that conditions 2 and 3 are maintained . if , as a result of @xmath7-moves , the number of points in some @xmath216 that @xmath7-overlap @xmath262 exceeds @xmath263 , or there is at least one point in @xmath216 that @xmath7-overlaps more than @xmath264 points in @xmath262 , then we @xmath7-split @xmath265 into sets @xmath266 and @xmath267 that contain @xmath268 and @xmath269 elements respectively .",
    "each set @xmath216 is rebuilt at most once after a sequence of @xmath270 special insert or delete operations .",
    "each @xmath216 is also re - built at most once after a sequence of @xmath271 @xmath7-moves , i.e. , after @xmath270 kinetic events .",
    "we can maintain the list of points in each @xmath216 sorted by their @xmath23-coordinates ; hence , the data structure @xmath214 for a newly re - built set @xmath216 can be constructed in @xmath272 time .",
    "therefore , the amortized cost of updates and kinetic events is @xmath15 .",
    "we can de - amortize update costs using the same techniques as in the logarithmic method  @xcite .",
    "[ lemma : insx ] there exists a @xmath29 space data structure that supports dominance queries on @xmath0 grid in @xmath20 time .",
    "updates after kinetic events and operations @xmath181 , @xmath183 , @xmath185 and @xmath186 are supported in @xmath15 time .",
    "* three - sided reporting queries .",
    "* now we are ready to describe data structures that support three - sided reporting queries , i.e. , the query range is a product of a closed interval and a half - open interval .",
    "we apply the standard method used in e.g.  @xcite ,  @xcite to augment data structure for dominance queries .",
    "let @xmath273 be an arbitrary balanced tree with constant node degree on the set of @xmath7-coordinates of all points in @xmath4 .",
    "we associate an interval @xmath274}$ ] with each leaf @xmath275 of @xmath273 , where @xmath276 is the predecessor of the smallest value @xmath277 stored in the node @xmath275 , and @xmath278 is the largest value stored in the node @xmath275 .",
    "we associate an interval @xmath279 with the rightmost leaf @xmath275 . with each internal node @xmath102 of @xmath273",
    "we associate an interval @xmath280 for all children @xmath281 of @xmath102 .",
    "let @xmath282 be the set of points @xmath34 such that @xmath283 . in every internal node @xmath102 we store two data structures @xmath284 and @xmath285 that support dominance reporting queries open to the left and open to the right ( i.e. , queries @xmath286}\\times{(-\\infty , b]}$ ] and @xmath287}$ ] ) for the set @xmath282 .",
    "in each node @xmath102 we also store the list of points in @xmath282 sorted by their @xmath23-coordinate .",
    "given a three - sided query with @xmath288\\times{(-\\infty , c]}$ ] we can find in time @xmath32 the node @xmath102 such that @xmath289\\subset { \\idtt{int}}(v)$ ] , but @xmath289\\not\\subset{\\idtt{int}}(v_i)$ ] for all children @xmath281 of @xmath102 .",
    "suppose @xmath290 $ ] for @xmath291 .",
    "then @xmath7-coordinates of all points in children @xmath292 of @xmath102 belong to @xmath289 $ ] .",
    "we can report all points @xmath35 in @xmath292 whose @xmath23-coordinate do not exceed @xmath293 using sorted lists of points in @xmath294 .",
    "we also answer two dominance queries @xmath295}$ ] and @xmath296}\\times { ( -\\infty , c]}$ ] with help of data structures @xmath297 and @xmath298 respectively .    after a kinetic event affecting two points @xmath35 and @xmath33 from the same set @xmath282 , the data structures @xmath284 and @xmath285",
    "are updated .",
    "after a kinetic event that affects points @xmath35 and @xmath33 that belong to two neighbor sets @xmath299 and @xmath300 respectively , we swap @xmath35 and @xmath33 : @xmath35 is removed from @xmath299 and inserted into @xmath300 , and @xmath33 is removed from @xmath300 and inserted into @xmath299 . in this case a constant number of operations @xmath185 and @xmath186 ( resp .",
    "@xmath181 and @xmath183 ) is performed .",
    "each point belongs to @xmath15 sets @xmath282 .",
    "hence , the space usage is @xmath30 and an update after a kinetic event takes @xmath14 time .",
    "[ lemma:3sid ] there exists a @xmath30 space data structure that supports three - sided reporting queries for a set of linearly moving points on a @xmath0 grid in @xmath1 time and updates after kinetic events in @xmath14 time .",
    "if trajectories of the points do not change , then the total number of kinetic events is @xmath24",
    ".    * orthogonal range reporting queries . * in a similar way to lemma  [ lemma : insx ] we can extend the data structure to support update operations in two other special cases . let @xmath301 and @xmath302 be the smallest and the largest @xmath23-coordinates of points in @xmath4 . the operation @xmath303 inserts a point @xmath35 with @xmath304 . the operation",
    "@xmath305 deletes a point @xmath35 with @xmath306 .",
    "operations @xmath307 and @xmath308 insert and delete a point whose @xmath23-coordinate is smaller than @xmath23-coordinates of all other points in @xmath4 .",
    "again , it is easy to modify the data structure of lemma  [ lemma:3sid ] so that it supports @xmath307 and @xmath308 because these operations affect at most one segment of @xmath40 . we can support @xmath303 and @xmath305 using the same construction as in lemma  [ lemma : insx ] .",
    "a point @xmath35 @xmath23-overlaps with a point @xmath33 if @xmath111 .",
    "analogously to lemma  [ lemma : insx ] , points are stored in sets @xmath309 and we maintain the invariants :    1 .   for @xmath191 , @xmath310 contains between @xmath192 and @xmath193 points ; @xmath311 contains between @xmath195 and @xmath196 points 2 .",
    "each point of @xmath312 @xmath23-overlaps at most @xmath198 points from @xmath313 3 .   at most @xmath200 points from @xmath310 @xmath23-overlap with @xmath313    elements of @xmath310",
    "are stored in an augmented data structure @xmath314 of lemma  [ lemma : insx ] so that kinetic events and operations @xmath185 , @xmath186 , @xmath181 , @xmath183 , @xmath307 and @xmath308 are supported . for @xmath204 , we maintain @xmath315 and @xmath316 .",
    "all @xmath317 are stored in a kinetic binary tree . for each @xmath208 , we store a point @xmath210 with @xmath318 and @xmath319 in a kinetic data structure @xmath320 ; @xmath320 supports dominance reporting queries in @xmath106 time and updates in @xmath15 time . for each @xmath208 we also store all points of @xmath321 in a list @xmath322 that contains all points from @xmath321 in the descending order of their @xmath7-coordinates .",
    "given a query @xmath323 , we can find in @xmath97 time the smallest index @xmath208 , such that at least one point in @xmath321 has @xmath23-coordinate smaller than @xmath324 . according to conditions 2 and 3 above",
    ", @xmath321 and @xmath325 may contain points whose @xmath23-coordinate are greater than or equal to @xmath324 .",
    "the @xmath23-coordinates of all points in @xmath326 are greater than @xmath324 .",
    "the @xmath23-coordinates of all points in sets @xmath310 , @xmath327 , are smaller than @xmath324 .    using @xmath320",
    ", we can identify all @xmath328 such that @xmath229 and @xmath328 contains at least one point @xmath35 with @xmath233 .",
    "for every such @xmath57 , all points @xmath35 such that @xmath231 and @xmath233 can be reported by traversing the list @xmath329 .",
    "hence , reporting all points @xmath330 such that @xmath229 , @xmath233 and @xmath234 takes @xmath106 time . we can report all points in @xmath216 and @xmath225 that belong to @xmath220 in @xmath17 time using data structures @xmath331 and @xmath332 respectively .",
    "when a point @xmath35 is inserted with an operation @xmath181 or @xmath185 , we identify the data structure @xmath314 , such that @xmath333 but @xmath334 for all @xmath335 , and insert @xmath35 into @xmath314 as described in lemma  [ lemma : insx ] .",
    "when a point @xmath35 is deleted with operations @xmath183 or @xmath186 , we delete @xmath35 from the data structure @xmath314 such that @xmath336 . when a point is inserted or deleted with operations @xmath307 or @xmath308 , we insert or delete this point into the set @xmath311 . if a point is inserted or deleted with operations @xmath303 or @xmath305 , we rebuild the data structure @xmath337 .",
    "invariants 1 - 3 for sets @xmath310 can be maintained under @xmath303 , @xmath305 , and kinetic events with the same method that was used in lemma  [ lemma : insx ] to maintain sets @xmath190 .",
    "hence , we obtain    [ lemma : insy ] there exists a data structure that supports dominance queries on @xmath0 grid in @xmath1 time .",
    "kinetic events and operations @xmath181 , @xmath183 , @xmath185 , @xmath186 , @xmath303 , @xmath305 , @xmath307 , and @xmath308 are supported in @xmath15 time .",
    "we can obtain a @xmath30 space data structure for three - sided queries that supports operations @xmath303 , @xmath305 , @xmath307 , and @xmath308 as well as kinetic events in @xmath14 time in the same way as in the proof of lemma  [ lemma:3sid ] . using the same technique once again",
    ", we obtain the result for general two - dimensional range reporting queries stated in theorem  [ theor : report ] .",
    "[ theor : report ] there exists a @xmath27 space data structure that supports orthogonal range reporting queries on @xmath0 grid in @xmath1 time and updates after kinetic events in @xmath28 time .",
    "if trajectories of the points do not change , then the total number of kinetic events is @xmath24 .",
    "in this paper we describe a data structure for a set of moving points that answers orthogonal range reporting queries in @xmath1 time . the query time is dominated by the time needed to answer a point location query ; the rest of the query procedure takes @xmath106 time .",
    "thus a better algorithm for the point location problem would lead to a better query time of our data structure . proving any @xmath338 lower bound for our problem ,",
    "i.e. , proving that kinetic range reporting is slower than static range reporting , would be very interesting .",
    "while kinetic data structures usually support arbitrary changes of trajectories and only require that points follow constant - degree algebraic trajectories , we assume that points move linearly and all changes of trajectories are known in advance . an interesting open question is whether we can construct a kinetic data structure that achieves @xmath339 query time without these additional assumptions .",
    "99 m. a. abam , m. de berg , b. speckmann _ kinetic kd - trees and longest - side kd - trees _ , siam j. comput .",
    "39(4 ) , 1219 - 1232 , 2009 .",
    "p. agarwal , l. arge , j. erickson , _ indexing moving points _ , j. comput .",
    "system sci .",
    "66 , 207 - 243 , 2003 .",
    "p. agarwal , j. gao , l. guibas , _ kinetic medians and kd - trees _ ,",
    "esa 2002 , 5 - 16 .",
    "s. alstrup , g.  s. brodal , t. rauhe , _ new data structures for orthogonal range searching _ , proc .",
    "focs 2000 , 198 - 207 .",
    "s. alstrup , t. husfeldt , t. rauhe , _ marked ancestor problems _ , proc .",
    "focs 1998 , 534 - 544 .",
    "l. arge , j.   s. vitter , `` optimal external memory interval management '' , siam j. on computing 32(6 ) , 1488 - 1508 , 2003 . j. basch , l. guibas , j. hershberger , _ data structures for mobile data _",
    ", j. algorithms 31 , 1 - 28 , 1999 .",
    "j. basch , l. guibas , l. zhang , _ proximity problems on moving points _ ,",
    "13th acm symposium on computational geometry 1997 , 344 - 351 .",
    "j. l. bentley , _ decomposable searching problems _ , information processing letters 8(5 ) , 244 - 251 ( 1979 ) .",
    "j. l. bentley t. ottmann , _",
    "algorithms for reporting and counting geometric intersections _ , ieee trans .",
    "28 , 643 - 647 , 1979 .",
    "b. chazelle , l.  j. guibas , _ fractional cascading : i. a data structuring technique _ ,",
    "algorithmica 1(2 ) , 133 - 162 , 1986 . t. m. chan , m. patrascu , _ transdichotomous results in computational geometry , i : point location in sublogarithmic time _ , siam j. comput .",
    "39(2 ) , 703 - 729 , 2009 . p. f. dietz , r. raman , _ persistence , amortization and randomization _",
    "soda 1991 , 78 - 88 .",
    "p. van emde boas , , inf . process .",
    "6(3 ) : 80 - 82 ( 1977 ) .",
    "l.  j. guibas , _ kinetic data structures : a state of the art report _ ,",
    "3rd workshop on the algorithmic foundations of robotics 1998 , 191 - 209 .",
    "m. h. overmars , _ design of dynamic data structures _",
    ", springer - verlag new york , inc . , secaucus , nj , 1987 . m. h. overmars , _ efficient data structures for range searching on a grid _ , j. algorithms 9(2 ) , 254 - 275 ( 1988 ) .",
    "s. subramanian , s. ramaswamy , _ the p - range tree : a new data structure for range searching in secondary memory _ , proc .",
    "soda 1995 , 378 - 387 .",
    "d.   e. vengroff , j.  s. vitter , _ efficient 3-d range searching in external memory _ , proc .",
    "stoc 1996 , 192 - 201 ."
  ],
  "abstract_text": [
    "<S> in this paper we describe a new data structure that supports orthogonal range reporting queries on a set of points that move along linear trajectories on a @xmath0 grid . </S>",
    "<S> the assumption that points lie on a @xmath0 grid enables us to significantly decrease the query time in comparison to the standard kinetic model . </S>",
    "<S> our data structure answers queries in @xmath1 time , where @xmath2 denotes the number of points in the answer . </S>",
    "<S> the above improves over the @xmath3 lower bound that is valid in the infinite - precision kinetic model . </S>",
    "<S> the methods used in this paper could be also of independent interest . </S>"
  ]
}