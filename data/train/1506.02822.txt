{
  "article_text": [
    "hpc system administration has to satisfy two seemingly contradictory demands58 on one hand administrators seek stability , which leads to a conservative approach to software management , and on the other hand users demand recent tool chains and huge scientific software stacks .",
    "in addition , users often need different versions and different variants of a given software package . to satisfy both , support teams end up playing the role of `` distribution",
    "maintainers''58 they build and install tool chains , libraries , and scientific software packages manually  multiple variants thereof  and make them available _ via _ `` environment modules''@xcite , which allows users to pick the specific packages they want .",
    "unfortunately , software is often built and installed in an _ ad hoc _ fashion , leaving users little hope of redeploying the same software environment on another system .",
    "worse , support teams occasionally have to remove installed software or to upgrade it in place , which means that users may eventually find themselves unable to reproduce their software environment , _ even on the same system_.    recently - developed tools such as easybuild @xcite and spack @xcite address part of the problem by automating package builds , supporting non - root users , and adding facilities to create package variants . however , these tools fall short when it comes to build reproducibility",
    ". first , build processes can trivially refer to tools or libraries already installed on the system .",
    "second , the _ ad hoc _ naming conventions they rely on to identify builds fail to capture the directed acyclic graph ( dag ) of dependencies that led to this particular build .    gnu  guix is a general - purpose package manager that implements the functional package management paradigm pioneered by nix @xcite .",
    "many of its properties and features make it attractive in a multi - user hpc context58 per - user profiles , transactional upgrades and roll - backs , and , more importantly , a controlled build environment to maximize reproducibility .",
    "details our motivations .",
    "describes the functional package management paradigm , its implementation in guix , its impact on reproducibility , and how it can be applied to hpc systems . gives concrete use cases where guix empowers users while guaranteeing reproducibility and sharing , while discusses limitations and remaining challenges .",
    "finally , compares to related work , and concludes .",
    "recent work on reproducible research insufficiently takes software environment reproducibility into account . for example , the approach for verifiable computational results described in @xcite focuses on workflows and conventions but does not mention the difficulty of reproducing full software environments .",
    "likewise , the new replicated computational results ( rcr ) initiative of the acm transactions on mathematical software acknowledges the importance of reproducible results , but does not adequately address the issue of software environments , which is a prerequisite . the authors of @xcite propose a methodology for reproducible research experiments in hpc . to address the software - environment reproducibility problem they propose two unsatisfying approaches58 one is to write down",
    "the version numbers of the dependencies being used , which is insufficient , and the other is to save and reuse full system images , which makes verifiability impractical  peers would have to download large images and would be unable to combine them with their own software environment .    yet , common practices on hpc systems hinder reproducibility . for understandable stability reasons , hpc systems often run old gnu / linux distributions that are rarely updated .",
    "thus , packages provided by the distribution are largely dismissed .",
    "instead support teams install packages from third - party repositories ",
    "but then they clobber the global ` /usr ` prefix , which sysadmins may want to keep under control , or install them from source by themselves and make them available through environment modules @xcite .",
    "modules allow users to choose different versions or variants of the packages they use without interfering with each other .",
    "however , when installed software is updated in place or removed , users suddenly find themselves unable to reproduce the software environment they were using .",
    "given these practices , reproducing the exact same software environment on a _ different _ hpc system seems out of reach .",
    "it is nonetheless a very important property58 it would allow users to assess the impact of the hardware on the software s performance  something that is very valuable in particular for developers of run - time systems  and it would allow other researchers to reproduce experiments on their system .",
    "essentially , by deploying software and environment modules , hpc support teams find themselves duplicating the work of gnu / linux distributions , but why is that ?",
    "historical package managers such as apt and rpm suffer from several limitations .",
    "first , package binaries that every user installs , such as ` .deb ` files , are actually built on the package maintainer s machine , and details about the host may leak into the binary that is uploaded ",
    "a shortcoming that is now being addressed ( see . )    second , while it is in theory possible for a user to define their own variant of a package , as is often needed in hpc , this is often difficult in practice .",
    "users of rpm - based systems , for example , may be able to customize a ` .spec ` file to build a custom , relocatable rpm package , but only the administrator can install the package alongside its dependencies and register it in the central ` yumdb ` package database .",
    "the lower - level ` rpm ` tool can use a separate package registry , which could be useful for unprivileged users ; however rpm package databases can not be composed , so users would need to manually track down and register the complete graph of dependencies , which is impractical at best .",
    "third , these tools implement an _ imperative _ and _ stateful _ package management model @xcite .",
    "it is imperative in the sense that it modifies the set of available packages in place .",
    "for example , switching to an alternative mpi implementation , or upgrading the openmp run - time library means that suddenly all the installed applications and libraries start using them .",
    "it is stateful in the sense that the system state after a package management operation depends on its previous state .",
    "namely , the system state at a given point in time is the result of the series of installation and upgrade operations that have been made over time , and there may be no way to reproduce the exact same state elsewhere .",
    "these properties are a serious hindrance to reproducibility .",
    "_ functional paradigm .",
    "_ functional package management is a discipline that transcribes the functional programming paradigm to software deployment58 build and installation processes are viewed as pure functions in the mathematical sense  whose result depends exclusively on the inputs , and their result is a value  that is , an immutable directory .",
    "since build and installation processes are pure functions , their results can effectively be `` cached '' on disk .",
    "likewise , two independent runs of a given build process for a given set of inputs should return the same value_i.e .",
    "_ , bit - identical files .",
    "this approach was first described and implemented in the nix package manager @xcite .",
    "guix reuses low - level mechanisms from nix to implement the same paradigm , but offers a unified interface for package definitions and their implementations , all embedded in a single programming language @xcite .",
    "an obvious challenge is the implementation of this paradigm58 how can build and install processes be viewed as pure ? to obtain that property , nix and guix ensure tight control over the build environment . in both cases ,",
    "build processes are started by a privileged daemon , which always runs them in `` containers '' as implemented by the kernel linux ; that is , they run in a chroot environment , under a dedicated user i d , with a well - defined set of environment variables , with separate name spaces for pids , inter - process communication ( ipc ) , networking , and so on .",
    "the chroot environment contains only the directories corresponding to the explicitly declared inputs .",
    "this ensures that the build process can not inadvertently end up using tools or libraries that it is not supposed to use .",
    "the separate name spaces ensure that the build process can not communicate with the outside world .",
    "although it is not perfect as we will see in , this technique gives us confidence that build processes can indeed be viewed as pure functions , with reproducible results .",
    "each build process produces one or more files in directories stored in a common place called _ the store _ , typically the ` /gnu / store ` directory .",
    "each entry in ` /gnu / store ` has a name that includes a hash of _ all the inputs _ of the build process that led to it . by `` all the inputs '' , we really mean all of them58 this includes of course compilers and libraries , including the c library , but also build scripts and environment variable values .",
    "this is recursive58 the compiler s own directory name is a hash of the tools and libraries used to build , and so on , up to a set of pre - built binaries used for bootstrapping purposes  which can in turn be rebuilt using guix @xcite .",
    "thus , for each package that is built , the system has access to the _ complete dag _ of dependencies used to build it .",
    "package recipes in guix are written in a domain - specific language ( dsl ) embedded in the scheme programming language .",
    "shows , as an example , the recipe to build the open  mpi library . the ` package ` form evaluates to a _ package object _ , which is just a `` regular '' scheme value ; the ` define ` form defines the ` openmpi ` variable to hold that value .    ...",
    "yields58    line 14 specifies that the package is to be built according to the gnu standards_i.e .",
    "the well - known ` ./configure & & make & & make install ` sequence ( similarly , guix defines ` cmake - build - system ` , and so on . )",
    "the ` inputs ` field on line 15 specifies the direct dependencies of the package .",
    "the field refers to the ` hwloc ` , ` gfortran-4.8 ` , and ` pkg - config ` variables , which are also bound to package objects ( their definition is not shown here . ) it would be inconvenient to specify all the standard inputs , such as make , gcc , binutils so these are implicit here ; as it compiles package objects to a lower - level intermediate representation , ` gnu - build - system ` automatically inserts references to specific package objects for gcc , binutils , etc .",
    "since we are manipulating `` normal '' scheme objects , we can use the api of guix to query those package objects , as illustrated with the code in , which queries the name and version of the direct and indirect dependencies of our package .    with that definition in place , running ` guix build openmpi `",
    "returns the directory name ` /gnu",
    "/ store / rmnib3ggm0dq32ls160ja882vanb69fi - openmpi-1.8.1 ` .",
    "if that directory did not already exist , the daemon spawns the build process in its isolated environment with write access to this directory .",
    "of course users never have to type these long ` /gnu / store ` file names .",
    "they can install packages in their _ profile _ using the ` guix package ` command , which essentially creates symbolic links to the selected ` /gnu / store ` items . by default ,",
    "the tree of symbolic links is rooted at ` _ { \\mbox{\\char126}}/.guix - profile ` , but users can also create independent profiles in arbitrary places of the file system .",
    "for instance , a user may choose to have gcc and open  mpi in the default profile , and to populate another profile with clang and mpich2 .",
    "it is then a matter of defining the search paths for the compiler , linker , and other tools _ via _ environment variables .",
    "fortunately , guix keeps track of that and the ` guix package search - paths ` command returns all the necessary environment variable definitions in bourne shell syntax .",
    "for example , when both the gcc tool chain and open  mpi are installed , the command returns definitions for the ` path ` , ` cpath ` , and ` library_path ` environment variables , and these definitions can be passed to the ` eval ` shell built - in command .",
    "we explore practical use cases where guix improves experimentation reproducibility for a user of a given system , supports the deployment of complex software stacks , allows a software environment to be replicated on another system , and finally allows fine customization of the software environment .",
    "one of the key features of guix and nix is that they securely permit unprivileged users to install packages in the store @xcite . to build a package , the ` guix ` commands connect to the build daemon , which then performs the build ( if needed ) on their behalf , in the isolated environment .",
    "when two users build the exact same package , both end up using the exact same `",
    "/gnu / store ` file name , and storage is shared .",
    "if a user tries to build , say , a malicious version of the c library , then the other users on the system will not use it , simply because they can not guess its ` /gnu",
    "/ store ` file name  unless they themselves explicitly build the very same modified c library .",
    "guix is deployed at the max delbrck center for molecular medicine ( mdc ) , berlin , where the store is shared among 250 cluster nodes and an increasing number of user workstations .",
    "it is now gradually replacing other methods of software distribution , such as statically linked binaries on group network shares , relocatable rpms installed into group prefixes , one - off builds on the cluster , and user - built software installed in home directories .",
    "the researchers use tens of bioinformatics tools as well as frameworks such as biopython , numpy , scipy , and sympy . the functional packaging approach",
    "proved particularly useful in the ongoing efforts to move dozens of users and their custom software environments from an older cluster running ubuntu to a new cluster running a version of centos , because software packaged with guix does not depend on any of the host system s libraries and thus can be used on very different systems without any changes to the packages .",
    "research groups now have a shared profile for common applications , whereas individual users can manage their own profiles for custom software , legacy versions of bioinformatics tools to reproduce published results , bleeding - edge tool chains , or even for complete workflows .",
    "guix supports two ways to manage a profile .",
    "the first one is to make transactions that add , upgrade , or remove packages in the profile58 ` guix package install openmpi remove mpich2 ` installs open  mpi and removes mpich2 in a single transaction that can be rolled back .",
    "the second approach is to _ declare _ the desired contents of the profile and make that effective58 the user writes in a file a code snippet that lists the requested packages ( see ) and then runs ` guix package manifest = my - packages.scm ` .",
    "this declarative profile management makes it easy to replicate a profile , but it is symbolic58 it uses whatever package objects the variables are bound to ( ` gnu - make ` , ` gcc - toolchain ` , etc . ) , but these variables are typically defined in the ` ( gnu packages  ) ` modules that guix comes with .",
    "thus the precise packages being installed depend on the version of guix that is available .",
    "specifying the git commit of guix in addition to the declaration in is all it takes to reproduce the exact same ` /gnu / store ` items .",
    "another approach to achieve bit - identical reproduction of a user s profile is by saving the contents of its transitive closure using ` guix archive export ` .",
    "the resulting archive can be transferred to another system and restored at any point in time using ` guix archive import ` .",
    "this should significantly facilitate experimentation and sharing among peers .",
    "our colleagues at inria in the hiepacs and runtime teams develop a complete linear algebra software stack going from sparse solvers such as pastix and dense solvers such as chameleon , to run - time support libraries and compiler extensions such as starpu ] and hwloc .",
    "while developers of simulations want to be able to deploy the whole stack , developers of solvers only need their project s dependencies , possibly several variants thereof . for instance , developers of chameleon may want to test their software against several versions of starpu , or against variants of starpu built with different compile - time options .",
    "finally , developers of the lower - level layers , such as starpu , may want to test the effect of changes they make on higher - level layers .",
    "this use case leads to two requirements58 that users be able to customize and non - ambiguously specify a package dag , and that they be able to reproduce any variant of their package dag .",
    "guix allows them to define variants ; the code for these variants can be stored in a repository of their own and made visible to the ` guix ` commands by defining the ` guix_package_path ` environment variable .",
    "shows an example of such package variants58 based on the pre - existing ` starpu ` variable , the first variant defines a package for a new starpu release candidate , simply by changing its ` source ` field , while the second variant adds the optional dependency on the simgrid simulator  a variant useful to scheduling practitioners , but not necessarily to solver developers .    these starpu package definitions are obviously useful to users of starpu58 they can install them with ` guix package -i starpu ` and similar commands .",
    "but they are also useful to starpu developers58 they can enter a `` pristine '' development environment corresponding to the dependencies given in the recipe by running ` guix environment starpu pure ` .",
    "this command spawns a shell where the usual ` path ` , ` cpath ` etc .",
    "environment variables are redefined to refer precisely to the inputs specified in the recipe .",
    "this amounts to creating a profile on the fly , containing only the tools and libraries necessary when developing starpu .",
    "this is notably useful when dealing with build systems that support optional dependencies .    now that we have several starpu variants , we want to allow direct and indirect users to select the variant that they want .",
    "a simple way to do that is to write , say , a function that takes a ` starpu ` parameter and returns a package that uses it as its input as show in . to allow users to refer to one or the other variant at the command line , we use different values for the ` name ` field .",
    "this approach is reasonable when there is a small number of variants , but it does not scale to more complex dags . as an example , starpu can be built with mpi support , in which case chameleon also needs to be explicitly linked against the same mpi implementation .",
    "one way to do that is by writing a function that recursively adjusts the package labeled ` mpi ` in the ` inputs ` field of packages in the dag .",
    "no matter how complex the transformations are , a package object unambiguously represents a reproducible build process . in that sense",
    ", guix allows environments to be reproduced at different sites , or by different users , while still supporting users needing complex customization .",
    "_ privileged daemon . _ nix and guix address many of the reproducibility issues encountered in package deployment , and guix provides apis that can facilitate the development of package variants as is useful in hpc . yet , to our knowledge , neither guix nor nix are widely deployed on hpc systems .",
    "an obvious reason that limits adoption is the requirement to have the build daemon run with root privileges  without which it would be unable to use the linux kernel container facilities that allow it to isolate build processes and maximize build reproducibility .",
    "system administrators are wary of installing privileged daemons , and so hpc system users trade reproducibility for practical approaches .    _",
    "cluster setup .",
    "_ all the ` guix ` commands are actually clients of the daemon .",
    "in a typical cluster setup , system administrators may want to run a single daemon on one specific node and to share ` /gnu / store ` among all the nodes . at the time of writing",
    ", guix does not yet allow communication with a remote daemon .",
    "for this reason , guix users at the mdc are required to manage their profiles from a specific node ; other nodes can use the profiles , but not modify them . allowing the ` guix ` commands to communicate with a remote daemon will address this issue .    additionally , compute nodes",
    "typically lack access to the internet .",
    "however , the daemon needs to be able to download source code tarballs or pre - built binaries from external servers .",
    "thus , the daemon must run on a node with internet access , which could be contrary to the policy on some clusters .",
    "_ os kernel .",
    "_ by choosing not to use a full - blown vm and thus relying on the host os kernel , our system assumes that the kernel interface is stable and that the kernel has little or no impact on program behavior .",
    "while this may sound like a broad assumption , our experience has shown that it holds for almost all the software packages provided by guix . indeed , while applications may be sensitive to changes in the c library , only low - level kernel - specific user - land software is really sensitive to changes in the kernel .",
    "the build daemon itself relies on features that have been available in the kernel for several years .",
    "_ non - determinism .",
    "_ despite the use of isolated containers to run build processes , there are still a few sources of non - determinism that build systems of packages might use and that can impede reproducibility . in particular , details about the operating system kernel and",
    "the hardware being used can `` leak '' to build processes .",
    "for example , the kernel linux provides system calls such as ` uname ` and interfaces such as ` /proc",
    "/ cpuinfo ` that leak information about the host ; independent builds on different hosts could lead to different results if this information is used .",
    "likewise , the ` cpuid ` instruction leaks hardware details .    fortunately , few software packages depend on this information . yet ,",
    "the proportion of packages depending on it is higher in the hpc world .",
    "a notable example is the atlas linear algebra system , which fine - tunes itself based on details about the cpu micro - architecture .",
    "similarly , profile - guided optimization ( pgo ) , where the compiler optimizes code based on a profile gathered in a previous run , undermines reproducibility .",
    "running build processes in full - blown vms would address some of these issues , but with a potentially significant impact on build performance , and possibly preventing important optimization techniques in the hpc context .",
    "_ proprietary software .",
    "_ gnu  guix does not provide proprietary software packages .",
    "unfortunately , proprietary software is still relatively common in hpc , be it linear algebra libraries or gpu support .",
    "yet , we see it as a strength more than a limitation . often , these `` black boxes '' inherently limit reproducibility  how is one going to reproduce a software environment without permission to run the software in the first place ?",
    "what if the software depends on the ability to `` call home '' to function at all ?",
    "more importantly , we view reproducible software environments and reproducible science as a tool towards improved and shared knowledge ; developers who deny the freedom to study and modify their code work against this goal .",
    "_ reproducible builds .",
    "_ reproducible software environments have only recently become an active research area .",
    "one of the earliest pieces of work in this area is the vesta software configuration system @xcite .",
    "vesta provides a dsl that allows users to describe build operations , similar to nix @xcite .",
    "more recently , projects such as debian s reproducible , fedora s mock , or gitian have intended to improve reproducibility and verifiability of mainstream package distributions .",
    "google s recent bazel build tool relies on container facilities provided by the kernel linux and provides another dsl to describe build operations .",
    "reproducibility can be achieved with heavyweight approaches such as full operating system deployments , be it on hardware or in vms or containers @xcite .",
    "in addition to being resource - hungry , these approaches are coarse - grain and do not compose58 if two different vm / container images or `` software appliances '' provide useful features or packages , the user has to make a binary choice and can not combine the features or packages they offer . furthermore ,",
    "`` docker files '' , `` vagrant files '' , and kameleon `` recipes '' @xcite suffer from being too broad for the purposes of reproducing a software environment  they are about configuring complete operating systems  and from offering an inappropriate level of abstraction  these recipes list commands to _ modify _ the state of the system image to obtain the desired state , whereas guix allows users to _ declare _ the desired environment in terms of software packages .",
    "lastly , the tendency to rely on complete third - party system images is a security concern . ]",
    "building upon third - party binary images also puts a barrier on reproducibility58 users may have recipes to rebuild their own software from source , but the rest of the system is essentially considered as a `` black box '' , which , if it can be rebuilt from source at all , can only be rebuilt using a completely different tool set .",
    "_ hpc package management .",
    "_ in the hpc community , efforts have focused primarily on the automation of software deployment and the ability for users to customize their build environment independently of each other .",
    "the latter has been achieved by `` environment modules '' , a simple but efficient tool set that is still widely used today @xcite . build and deployment automation is more recent with the development of specialized package management tools such as easybuild @xcite and spack @xcite .    both easybuild and spack have the advantage of being installable by unprivileged users since they do not rely on privileged components , unlike guix and nix .",
    "the downside is that they can not use the kernel s container facilities , which seriously hinders build reproducibility .",
    "when used in the user s home directories , each user may end up rebuilding the same compiler , libraries , etc .",
    ", which can be costly in terms of cpu , bandwidth , and disk usage .",
    "conversely , nix and guix support safe sharing of builds .",
    "easybuild aims to support multiple package variants , such as packages built with different compilers , or linked against different mpi implementations . to achieve that",
    ", it relies on directory naming conventions ; for instance , ` openmpi/1.7.3-gcc-4.8.2 ` contains packages built with the specified mpi implementation and compiler .",
    "such conventions fail to capture the full complexity of the dag and configuration space . for instance",
    ", the convention arbitrarily omits the c library , linker , or configuration flags being used .",
    "easybuild is tightly integrated with environment modules @xcite , which are familiar to most users of hpc systems .",
    "while modules provide users with flexible environments , they implement an imperative , stateful paradigm58 users run a sequence of ` module load ` and ` module unload ` commands that _ alter _ the current environment .",
    "this can make it much harder to reason about and reproduce an environment , as opposed to the declarative approaches implemented by ` guix package manifest ` and ` guix environment ` .",
    "like easybuild and similarly to guix , spack implements build recipes as first - class objects in a general - purpose language , python , which facilitates customization and the creation of package variants .",
    "in addition , spack provides a rich command - line interface that allows users to express variants similar to those discussed in .",
    "this appears to be very convenient for common cases , although there are limits to the expressivity and readability of such a compact syntax .",
    "functional package managers provide the foundations for reproducible software environments , while still allowing fine - grain software composition and not imposing high disk and ram costs . today",
    ", gnu  guix comes with 2,060 packages , including many of the common hpc tools and libraries as well as around 50 bioinformatics packages .",
    "it is deployed on the clusters of the mdc berlin , and being discussed as one of the packaging options by the open bioinformatics foundation , a non - profit for the biological research community .",
    "we hope to see more hpc deployments of guix in the foreseeable future .",
    "gnu  guix benefits from contributions by about 20 people each month .",
    "it is the foundation of the guix system distribution , a standalone , reproducible gnu / linux distribution .",
    "we would like to thank florent pruvost , emmanuel agullo , and andreas enge at inria and eric bavier at cray inc .",
    "for insightful discussions and comments on an earlier draft .",
    "we are grateful to the guix contributors who keep improving the system ."
  ],
  "abstract_text": [
    "<S> support teams of high - performance computing ( hpc ) systems often find themselves between a rock and a hard place58 on one hand , they understandably administrate these large systems in a conservative way , but on the other hand , they try to satisfy their users by deploying up - to - date tool chains as well as libraries and scientific software . </S>",
    "<S> hpc system users often have no guarantee that they will be able to reproduce results at a later point in time , even on the same system  software may have been upgraded , removed , or recompiled under their feet , and they have little hope of being able to reproduce the same software environment elsewhere . </S>",
    "<S> we present gnu  guix and the functional package management paradigm and show how it can improve reproducibility and sharing among researchers with representative use cases . </S>"
  ]
}