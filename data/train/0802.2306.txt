{
  "article_text": [
    "[ data ]    modern computer programs are large and highly structured entities . naturally the components of a program depend on each other , and in general if we think of the program components as nodes and dependencies as edges , a directed graph can be constructed .",
    "there is not a single graph for each program , as there are many different ways that ` node ' and ` edge ' might be defined .",
    "for example , for a given _ _",
    "o__bject - oriented program , we might construct the graph in which nodes are top - level types and an edge from type @xmath0 to type @xmath1 indicates that type @xmath0 has a field of type @xmath1 .",
    "thus the number of types of fields declared in @xmath0 can be considered as the ` out ' degree of @xmath0 , while the number of types having fields of type @xmath0 is its ` in ' degree . as another example",
    ", two top - level types could be linked when one contains a method ( out ) with a parameter of the other s type ( in ) .",
    "these different ways of constructing the graph will be referred to as different _",
    "metrics_.    the distributions of in - degree and out - degree show a clear difference in form .",
    "this dimorphism was observed in a range of graphs generated from the source code of a large corpus of open - source java software in @xcite .",
    "it was found that the in - degree distributions were well fitted by power - law distributions , which appear as a straight line when plotted on logarithmic axes .",
    "the out - degree distributions , on the other hand , are noticeably curved on a log - log plot .",
    "this pattern appears regardless of the metric used or the application of the software examined @xcite , and even appears in other kinds of software - derived graph structures @xcite .",
    "software code is a direct product of the actions of programmers , and therefore the resulting ` shapes ' of the code result from these actions .",
    "it is clear that the difference between in - degree and out - degree distributions is not accidental , but is in some way a result of the way in which nodes and edges are created as the program is written .",
    "because this basic shape is observed in such a variety of software and metrics , the mechanism must be quite general , and can not depend on any specific features of the way different kinds of dependencies are created or different design methodologies are used to write software .    while we may be able to characterize the different distributions by fitting functions of different kinds , and examining the parameters of the fitted functions for trends and patterns  for example , the exponent of a power law distribution ",
    "such descriptive models can never explain what we see at any deep level .",
    "we really want to know not just what shapes software has , but how these shapes come about .",
    "one explanation , suggested in @xcite , is that the out - degree is more actively controlled by the programmer .",
    "the outgoing edges of a type consist of references directly coded as the type is written , while for the in - degree , references to a type are created as _ other _ types are written .    in this paper",
    ", we propose a simple generative model based on this observation which reproduces features observed in real software graph degree distributions .",
    "the model aims to capture the simplest actions of a programmer with respect to type and dependency creation .",
    "new edges are added between existing nodes of the graph , and a new node can be created by the division of an existing node into two parts .",
    "the treatment of incoming and outgoing connections between nodes is symmetrical in every way except that the division of nodes depends on the out - degree of the parent node in a specific way , but is independent of the node s in - degree .",
    "this represents the programmer s awareness of the outgoing dependencies but not of the code elsewhere in the program which refers to the current type .",
    "it is found that this single asymmetry is sufficient to reproduce the difference in shape between the two degree distributions observed in real software .",
    "the model proposed is similar to that developed by price @xcite to explain citation rates for papers , though whereas price s model produces power - law distributions for both in - degree and out - degree distributions , the introduction of the splitting step converts the out - degree distribution to an exponential distribution .",
    "we consider the degree distributions of a variety of inter - class relationships in the java source code of 12 different applications .",
    "these 12 programs are the largest of the 50 studied in @xcite .",
    "the actual programs ( and version numbers ) used are listed in appendix  [ programs ] .",
    "each metric counts for each type a certain kind of dependency on other types .",
    "we consider 14 metrics that can be identified as measuring either an out - degree or in - degree .",
    "metrics used in @xcite which could not be classified unambiguously as in- or out - degree distributions were left out .",
    "the metrics are defined in appendix  [ metrics ] , and each is referred to by a short abbreviation .",
    "some pairs of metrics register opposite ends of the same relationship , suggesting that they are the out- and in- degree distributions of the same graph",
    ". however , considerations such as the separation of application code from shared libraries mean that the count of outgoing edges does not always match the total of incoming edges .",
    "we will not go into detail about the differences between the metrics , as our aim is simply to demonstrate the extent to which the model described below reproduces the patterns observed in these various data .",
    "plots of the 5 ` in ' metrics ( see appendix  [ metrics ] ) on logarithmic axes often have a linear form , suggesting a power - law distribution is typical for graph in - degree distributions , regardless of the specific metric used or the particular program .",
    "three examples are shown in fig .",
    "[ figinsamples ] , which shows the degree distributions for three different ` in ' metrics ( see appendix  [ metrics ] ) in three different programs of differing sizes .",
    "the 9 ` out ' metrics ( see appendix  [ metrics ] ) do not appear linear on doubly logarithmic axes , however a number of the plots do have a linear shape when plotted on linear - logarithmic axes , suggesting an exponential distribution .",
    "not all the data sets conform clearly to this pattern , having a slightly different shape or one or more points which do not fall on a neat curve .",
    "nevertheless , the general pattern for in - degree is power - law like , and for out - degree seems to be an exponential shape .",
    "this suggests there is a common underlying process , modified to a greater or lesser degree by specific programmer actions in each case .",
    "software graph structures have been examined in several recent studies @xcite .",
    "in particular , several have reported power - law like degree distributions in graphs derived from source code @xcite or from object relationships at run - time @xcite .",
    "a distinction between in - degree and out - degree distributions has been observed in graphs derived from c and c++ software by myers @xcite , who treated both as approximate power - law distributions , and valverde and sol @xcite , who in common with the present study of java software , characterized the in - degree as a power - law and the out - degree as an exponential distribution .",
    "they showed that these distributions can be generated by certain cases of the gnc ( ` growing network model with copying ' ) network growth model @xcite , although the power law distribution generated by this model has a fixed exponent of 2 .",
    "yan , qi and gu @xcite examined java applications , constructing the directed graph of ` import ' relationships .",
    "once again they note that the in - degree distribution typically resembles a power - law while the out - degree has a largely exponential behavior .",
    "concas et al .",
    "@xcite also studied a java application , and noted a difference between in - degree and out - degree distributions .",
    "these observations are confirmed by the present study of a much larger group of java applications and metrics .",
    "yan et al .",
    "also postulate a generative model for such distributions , but make no claims about its plausibility in relation to programmer actions .",
    "+      +              +             +",
    "as programmers write software code , they will periodically add references between types ( edges ) , and occasionally create new types ( nodes ) .",
    "it is these aspects of the code we are interested in , so the intervening code , which is actually the majority of the program and specifies all its functions , is ignored .",
    "we consider a simplified process , each step of which entails either the addition of an edge between two existing nodes or the addition of a new node .",
    "generally there are a few elements that have many references to other parts of the program ( these might be the most complex types ) , while there are many that reference only a few other types .",
    "this divergence can be approximated by ensuring that the `` the rich get richer '' , invoking the ` cumulative advantage ' mechanism of price @xcite .",
    "new outgoing edges are added to the type which a programmer is ` currently working on ' , and we consider that the larger types ( those with most out - edges already ) are more likely to be added to in future . at each step a new edge",
    "is added , and the node the link originates from is chosen with a probability proportional to its current out - degree .    conversely , there are a few elements that are referenced repeatedly by many of the other parts of the program ( we might think of these as the simplest and most universal elements ) , while there are many that are used only a few times ( these might be more complex elements , at a higher level of hierarchy , and therefore are less reusable ) .",
    "we consider the number of incoming dependencies a type has to be an approximation to it s usefulness .",
    "therefore the node to which a new edge will be linked is chosen with a probability proportional to its current in - degree .",
    "the programmer is conscious of the number of outgoing references he or she is adding to a node , and at some point may decide the type is ` too big ' and create a new one .",
    "this effect is represented by allowing new nodes to occasionally be created by ` splitting ' an existing node into two pieces .",
    "the edges attached to the original node are divided between the two resulting nodes with each possible division between the two nodes of incoming and outgoing edges equally likely , with the constraint that at least one outgoing edge must be transferred to the new type , and one incoming edge must remain in the original type . finally ,",
    "if we think of the new node as carrying out a subset of the ` task ' originally intended for the parent node , the two nodes must be connected , so a new edge is created from the original type to the new type .",
    "this also ensures that at all times every node has at least one incoming edge and one outgoing edge .",
    "let @xmath2 be the out - degree of node @xmath3 , and @xmath4 be its in - degree , with @xmath3 running from @xmath5 up to @xmath6 , the current number of nodes .",
    "all of these quantities can grow as the process proceeds .",
    "let @xmath7 be the number of steps carried out so far . since exactly @xmath5 edge is added at each step , @xmath8 .",
    "the process is initiated at @xmath9 with a single node ( type ) with a single reference to itself ( this is necessary , as links are only added to nodes which already possess links ) , i.e. @xmath10 and @xmath11 . at each step :    * select _ parent _ node @xmath12 with probability @xmath13 * with probability @xmath14 simply add an edge : * * the parent node @xmath12 is the _ out _ node , * * select _ in _ node @xmath15 with probability @xmath16 , * * @xmath17 and @xmath18 .",
    "* otherwise , with probability @xmath19 , split the parent node : * * add a new node @xmath20 ( the last node number increments from @xmath21 ) , * * choose @xmath22 uniformly from @xmath23 and @xmath24 uniformly from @xmath25 and @xmath24 are chosen from different ranges to ensure that all nodes have at least one in- and one out- link after the new edge from @xmath12 to @xmath20 is added . ] , then + @xmath26 , @xmath27 ; + @xmath28 and @xmath29 .",
    "* increment the counter @xmath30 .",
    "these steps are repeated for some predetermined number of steps @xmath31 .",
    "the entire simulation is defined by only two parameters : the total number of links required ( equal to the number of simulation steps ) , @xmath31 , and the splitting probability , @xmath19 .",
    "since new types only appear due to the splitting process , @xmath19 determines the ratio between the number of types and the number of links : @xmath32 .",
    "note that although nodes to be ` worked on ' are selected according to their out - degree , this model is actually symmetric with respect to in- and out - degree , except for the splitting step : nodes acquire outgoing edges at a rate proportional to their existing out - degree , and acquire incoming edges at a rate proportional to their in - degree .",
    "in this model edges are added one by one to different parts of the graph , so all the types grow at the same time .",
    "new nodes are also created during this process .",
    "this does nt necessarily reflect the actual order in which program code is written .    although the graph continues to grow , after a sufficient number of steps , the relative degree frequencies ",
    "normalized by the total number of nodes  reach an equilibrium distribution .",
    "let @xmath33 be the number of types with out - degree @xmath12 after step @xmath7 .",
    "considering the two processes involved in the model , @xmath33 can increase by 1 if an outgoing edge is added to a type with out - degree @xmath34 and is not split , or if a type with out - degree greater than @xmath12 is split at just the right place that one of the resulting types has out - degree @xmath12 .",
    "similarly , @xmath33 decreases if a type of size @xmath12 gains a new out - link , or is split , so long as the point of splitting is not @xmath5 or @xmath12 . with a little consideration , we can write down the expected change in @xmath33 at the next step : @xmath35 the expected fraction of types that have degree @xmath12 is @xmath36 it follows from the definition that @xmath37 .",
    "substituting back into ( [ eqdeltac ] ) we find after collecting like terms that @xmath38 this equation is valid for all @xmath39 .",
    "replacing @xmath12 by @xmath34 in ( [ eqdeltaf ] ) , rearranging for the summation term and substituting back into the original version of ( [ eqdeltaf ] ) gives @xmath40 in terms of @xmath41 and @xmath42 , and after calculating @xmath43 and @xmath44 explicitly we find by induction the solution for general @xmath12 to be @xmath45 which can be written as an exponential @xmath46 where @xmath47 .",
    "a similar calculation can be performed for the in - degree distribution .",
    "the in - degree and out - degree of a type are completely independent , so the selection of a type for splitting is uniform with respect to in - degree . if @xmath48 , in analogy to @xmath40 , is the fraction of types with in - degree @xmath15 we find that @xmath49 = 2\\sum_{l > n}\\frac{g_l}{l } + ( 1-\\gamma)(n-1)g_{n-1}\\;.\\ ] ] using a similar method to before we find @xmath50 so that @xmath51 and normalization can be used to find @xmath52 . for large @xmath15 , the ratio @xmath53 tends to @xmath54 , that is , the in - degree distribution tends to a power - law of the form @xmath55 with exponent @xmath56 .",
    "thus the model predicts a decaying exponential for the out - degree distribution , and an in - degree distribution with a power - law tail with exponent greater than or equal to @xmath57 .",
    "examples of the two distributions ( [ eq_f ] ) and ( [ eq_g ] ) are shown in fig .",
    "[ figmodl ] .    .",
    "solid line is the out - degree model,@xmath58 , dashed line the in - degree model , @xmath48 . on linear - logarithmic axes , top , and double logarithmic axes , bottom.,title=\"fig:\",scaledwidth=38.0% ] .",
    "solid line is the out - degree model,@xmath58 , dashed line the in - degree model , @xmath48 . on linear - logarithmic axes , top , and double logarithmic axes , bottom.,title=\"fig:\",scaledwidth=38.0% ]",
    "the distributions ( [ eq_f ] ) and ( [ eq_g ] ) were fitted to the data described in section [ data ] using a maximum likelihood method , which is asymptotically unbiased @xcite . given some candidate distribution @xmath59 , the likelihood that the histogrammed data @xmath60 at values @xmath61 was generated from this distribution , given the parameter @xmath19 , is @xmath62 and we proceed by finding the value of @xmath19 which maximizes this quantity .",
    "in the case of out metrics , @xmath63 is given by ( [ eq_f ] ) , and the maximum likelihood estimator ( mle ) of @xmath19 is found analytically to be @xmath64 as expected , where @xmath65 is the number of edges in the graph , and @xmath66 is the number of nodes . for in metrics , we use ( [ eq_g ] ) , for which we have not been able to find a similar solution so the mle of @xmath19 must be found numerically .",
    "we again expect @xmath67 because this was assumed in the derivation of ( [ eq_g ] ) , although in some cases this is not the best fit value .",
    "the explanation of this is not known , though this very simple model is not expected to explain every detail of the data .    the cumulative distribution derived from function ( [ eq_f ] ) using the best fit",
    "( mle estimated ) @xmath19 value is plotted along with the out metric data in fig .",
    "[ figoutall ] .",
    "this figure plots all of the out - metrics for the same program , ` netbeans-4.1 ` , and it can be seen that in the majority of cases the agreement with the data is reasonably good , even though the number of nodes in the graphs for different metrics varies widely .",
    "further examples are shown in the top half of fig .",
    "[ figacap ] , which shows the same metric , ac , for three different programs .",
    "notice also that a fit of the ` wrong ' model distribution ( the predicted in - degree distribution ) does not fit as well .",
    "similarly , the cumulative best - fit functions ( [ eq_g ] ) for each of the in metrics for ` netbeans-4.1 ` is plotted in fig .",
    "[ figinall ] , and for three different programs for the same metric ( ap ) in the bottom half of fig .",
    "[ figacap ] . again",
    ", many data sets show good agreement , and the in - degree model fits the data much better than the out - degree model ( solid curve ) .",
    "comparisons were made for all the metrics and programs listed in appendices [ metrics ] and [ programs ] and figs .",
    "[ figoutall ] , [ figinall ] and [ figacap ] are fairly representative .",
    "an example of one of the better fits to an out metric data set is shown in fig .",
    "[ figouteg1 ] , and an example of a good in metric fit in fig .",
    "[ figineg1 ] .            to obtain a quantitative measure of",
    "how well the model fits the data , we follow the method of @xcite and calculate a @xmath68-value ( the probability that the data were drawn from the proposed distribution ) based on the kolmogorov - smirnov ( ks ) statistic @xcite @xmath69 where @xmath70 is the cumulative distribution function ( cdf ) of the data and @xmath71 is the cdf of the proposed distribution ( i.e. @xmath72 ) .",
    "the fitted distribution is correlated with the data , so treating it as the true distribution will give a falsely high @xmath68-value .",
    "instead we use a monte carlo procedure , following @xcite : a large number of synthetic data sets is drawn from the best - fit distribution , each one is fitted individually and the ks statistic ( relative to its own best fit distribution ) calculated for each of these fits .",
    "the @xmath68-value is then the fraction of these ks statistic values that are larger than that found for the original fit to the real data ."
  ],
  "abstract_text": [
    "<S> dependencies between types in object - oriented software can be viewed as directed graphs , with types as nodes and dependencies as edges . </S>",
    "<S> the in - degree and out - degree distributions of such graphs have quite different forms , with the former resembling a power - law distribution and the latter an exponential distribution . </S>",
    "<S> this effect appears to be independent of application or type relationship . </S>",
    "<S> a simple generative model is proposed to explore the proposition that the difference arises because the programmer is aware of the out - degree of a type but not of its in - degree . </S>",
    "<S> the model reproduces the two distributions , and compares reasonably well to those observed in 14 different type relationships across 12 different java applications . </S>"
  ]
}