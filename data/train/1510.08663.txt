{
  "article_text": [
    "in the late 1960s knuth @xcite introduced the idea of classifying the common data structures of computer science in terms of the number of permutations of length @xmath4 that could be sorted by the given data structure , to produce the identity permutation .",
    "knuth demonstrated the usefulness of this approach by showing that a simple stack could sort all such permutations except those which had any three elements in relative order 312 .",
    "this restriction meant that of the @xmath5 possible permutations of length @xmath6 only @xmath7 could be sorted by a simple stack . here",
    "@xmath8 denotes the cardinality of the @xmath4th catalan number .",
    "knuth went on to pose the same question for more complex data structures , such as a double - ended queue or _",
    "deque _ , which is a linear list in which insertions and deletions can take place at either end .",
    "in a later volume of his celebrated book @xcite , he asked the same question about compositions of stacks .",
    "the three most interesting , and most intensively studied permutation - related sorting problems associated with data structures relate to permutations that can be sorted by ( i ) a deque , ( ii ) two stacks in parallel ( 2sip ) and ( iii ) two stacks in series ( 2sis ) .",
    "the data structure corresponding to two stacks in series is shown in fig .",
    "[ fig : tsis ] .",
    "a permutation of length @xmath4 is said to be _",
    "sortable _ if it is possible to start with this permutation as the input , and output the numbers @xmath9 in order , using only the moves @xmath10 , @xmath11 and @xmath12 in some order . here",
    "@xmath10 pushes the next element from the input onto the first stack , @xmath11 pushes the top element of the first stack onto the top of the second stack , and @xmath12 outputs ( pops ) the top element of the second stack to the output stream , as shown in fig .",
    "[ fig : tsis ] .",
    "recently albert and bousquet - mlou @xcite solved the problem relating to two stacks in parallel , while subsequently we @xcite related the solution of the 2sip problem to the solution of the deque problem .",
    "this leaves only the 2sis problem unresolved .",
    "significant progress has been made on subsets of that problem .",
    "for example atkinson , murphy and rukic @xcite solved the problem in the case of _ sorted _ stacks , while elder , lee and rechnitzer @xcite solved the problem in the case when one of the stacks is of depth 2 .",
    "unfortunately , both these cases correspond to an exponentially small subset of the full set of stack - sortable permutations . in @xcite , pierrot and rossin",
    "give a polynomial algorithm to decide if a given permutation is sortable by two stacks in series .",
    "in all cases we ve mentioned , the number of permutations of length @xmath4 that can be sorted by the given data structure grows exponentially ( just as in the simple stack case discussed above ) , and more precisely , it is expected that @xmath13 the number of permutations of length @xmath4 sortable by any of the afore - mentioned data structures , behaves as @xmath14 in general . in @xcite , rigorous upper and lower bounds on @xmath12 are given for deque sorting , and also for 2sip and 2sis . for 2sis",
    "the bounds are @xmath15    in this paper we give an alternative approximation .",
    "we have evaluated the exact number of stack - sortable permutations of length @xmath4 for @xmath16 and describe numerical techniques that give the approximate number for @xmath17 we then apply a range of standard and specialised series analysis techniques @xcite to conjecture the asymptotics of the generating function coefficients .",
    "this is a computationally difficult problem .",
    "the only existing series we can find are for @xmath18 in the phd thesis of pierrot @xcite , and the last two values are incorrect .    if @xmath19 is the ordinary generating function for the number of permutations sortable by two stacks in series , then we find @xmath0 where @xmath20 @xmath21 and @xmath22    in the next section",
    "we describe the derivation of the coefficients @xmath23 and in the subsequent section we give our analysis of the data .",
    "we start with a simple , but inefficient algorithm to calculate the coefficients of the ogf , on which our more efficient algorithm is based .",
    "consider the three moves @xmath10 , which pushes the next element from the input onto the first stack , @xmath11 , which pushes the top element of the first stack onto the second stack , and @xmath12 , which outputs the top element of the second stack as shown in fig .",
    "[ fig : tsis ] .",
    "we have already defined sortable permutations .",
    "we call a permutation of length @xmath4 _ achievable _ if it is possible to output that permutation , starting with the numbers @xmath9 in order . rather than enumerating sortable permutations directly , we will instead enumerate achievable permutations , since the two classes share the same ogf .",
    "we call a word @xmath24 over the alphabet @xmath25 an _ operation sequence _ if @xmath24 corresponds to a permutation .",
    "that is , @xmath24 is called an operation sequence if @xmath24 contains an equal number of occurrences of each of the three letters , and after any point in @xmath24 , the letter @xmath10 has appeared at least as many times as @xmath11 , which has appeared at least as many times as @xmath12 .",
    "call two operation sequences equivalent if they produce the same permutation . note that this also means that they sort the same permutation .",
    "the basic algorithm , which we will call algorithm 1 , works as follows :    * define the function @xmath26 which takes in the state @xmath27 of the sorting machine , and a set of permutations and adds every permutation which can be achieved from that state to the set , by recursively calling the same function on each of the three or fewer states which can be reached from @xmath27 by one of the moves @xmath10 , @xmath12 , or @xmath28 .",
    "* create an empty set @xmath29 of permutations .",
    "* call the function @xmath26 on the initial state of the stack and the set @xmath29 * then the @xmath4th coefficient of the ogf is equal to the size of @xmath29 , since the permutations in @xmath29 are exactly the achievable permutations of size @xmath4 .",
    "this algorithm is very slow because it has to consider all operation sequences of size @xmath30 separately , and the number of operation sequences of length @xmath30 grows like @xmath31 .      the first improvement which we make is to reduce the number of operation sequences which the algorithm has to consider by removing many operation sequences which create the same permutation .",
    "call two operation sequences equivalent if they create the same permutation .",
    "we define the ordering @xmath32 , and we call an operation sequence optimal if it is lexicographically larger than any other equivalent operation sequence . rather than parse all operation sequences of size @xmath30",
    ", we now only insist that we parse all optimal operation sequences , since these will still create all achievable permutations . call a word @xmath33 over the alphabet @xmath25 forbidden if there is another word @xmath34 , which has the same effect on the sorting machine as @xmath33 .",
    "note that if an operation sequence @xmath24 has a forbidden subword @xmath33 , then we can change @xmath33 to @xmath35 in @xmath24 to create an equivalent operation sequence @xmath36 .",
    "moreover , @xmath37 , so @xmath24 is not optimal .",
    "hence , any optimal operation sequence contains no forbidden words .",
    "note that @xmath38 is a forbidden word , since it has the same effect on the sorting machine as @xmath39 . also , @xmath40 is a forbidden word since it has the same effect on the sorting machine as @xmath41 . for letters @xmath42 and @xmath43",
    ", we call a word @xmath33 over the alphabet @xmath44 an @xmath45-catalan word if the following conditions hold :    * @xmath33 contains an equal number of @xmath42 s and @xmath43 s * for any leading subword @xmath46 of @xmath33 , the word @xmath46 contains at least as many @xmath42 s as @xmath43 s .    in other words ,",
    "if we replace each @xmath42 in @xmath33 with an up step and each @xmath43 in @xmath33 with a down step , we get a dyck path .",
    "note that if @xmath46 is a @xmath47-catalan word , and @xmath33 is a @xmath48-catalan word , then the effect of @xmath46 on the sorting machine is to move and permute items from the input to the second stack .",
    "the effect of @xmath33 is to move and permute items from the first stack to the output .",
    "hence , these two operations commute , so @xmath49 and @xmath50 are equivalent .",
    "since @xmath46 begins with @xmath10 and @xmath33 begins with @xmath11 , we have @xmath51 , so @xmath49 is a forbidden word .",
    "we now construct the deterministic infinite state automaton @xmath52 shown in fig . [",
    "fig : automaton ] , which accepts all words which are not forbidden . note that @xmath52 also accepts some words which are forbidden .",
    "\\(x ) @xmath53 ; ( y ) [ below of = x ] @xmath54 ; ( a1 ) [ right of = x ] @xmath55 ; ( b1 ) [ below of = a1 ] @xmath56 ; ( c1 ) [ below of = b1 ] @xmath57 ; ( d1 ) [ below of = c1 ] @xmath58 ; ( a2 ) [ right of = a1 ] @xmath59 ; ( b2 ) [ below of = a2 ] @xmath60 ; ( c2 ) [ below of = b2 ] @xmath61 ; ( d2 ) [ below of = c2 ] @xmath62 ; ( a3 ) [ right of = a2 ] @xmath63 ; ( b3 ) [ below of = a3 ] @xmath64 ; ( c3 ) [ below of = b3 ] @xmath65 ; ( d3 ) [ below of = c3 ] @xmath66 ; ( a4 ) [ right of = a3 ] @xmath67 ; ( b4 ) [ below of = a4 ] @xmath68 ; ( c4 ) [ below of = b4 ] @xmath69 ; ( d4 ) [ below of = c4 ] @xmath70 ; at ( 11.2,0 ) @xmath71 ; at ( 11.2,-2.5 ) @xmath71 ; at ( 11.2,-5 ) @xmath71 ; at ( 11.2,-7.5 ) @xmath71 ; at ( 11.2,-4 ) @xmath71 ; at ( 11.2,-9 ) @xmath71 ;    \\(x ) edge [ loop above ] node [ align = center ] @xmath11 , @xmath12 ( x ) ( x ) edge node @xmath10 ( a1 ) ( y ) edge node [ align = center ] @xmath12 ( x ) ( c1 ) edge [ bend left ] node [ align = center ] @xmath11 ( d1 ) ( d1 ) edge [ bend left ] node [ align = center ] @xmath12 ( c1 )    ( a1 ) edge node [ align = center ] @xmath10 ( a2 ) ( a1 ) edge node [ align = center ] @xmath11 ( b1 ) ( b1 ) edge [ bend left ] node [ align = center ] @xmath10 ( a1 ) ( b1 ) edge [ bend left=25 ] node [ pos=0.45 ] @xmath11 ( c1 ) ( c2 ) edge node [ align = center ] @xmath11 ( c1 ) ( c2 ) edge node @xmath10 ( a1 ) ( d1 ) edge [ bend left ] node [ align = center ] @xmath11 ( d2 ) ( d2 ) edge [ bend left ] node [ align = center ] @xmath12 ( d1 )    ( a2 ) edge node [ align = center ] @xmath10 ( a3 ) ( a2 ) edge node [ align = center ] @xmath11 ( b2 ) ( b2 ) edge [ bend left ] node [ align = center ] @xmath10 ( a2 ) ( b2 ) edge [ bend left=25 ] node [ pos=0.45 ] @xmath11 ( c2 ) ( c3 ) edge node [ align = center ] @xmath11 ( c2 ) ( c3 ) edge node [ align = center ] @xmath10 ( a2 ) ( d2 ) edge [ bend left ] node [ align = center ] @xmath11 ( d3 ) ( d3 ) edge [ bend left ] node [ align = center ] @xmath12 ( d2 )    ( a3 ) edge node [ align = center ] @xmath10 ( a4 ) ( a3 ) edge node [ align = center ] @xmath11 ( b3 ) ( b3 ) edge [ bend left ] node [ align = center ] @xmath10 ( a3 ) ( b3 ) edge [ bend left=25 ] node [ pos=0.45 ] @xmath11 ( c3 ) ( c4 ) edge node [ align = center ] @xmath11 ( c3 ) ( c4 ) edge node [ align = center ] @xmath10 ( a3 ) ( d3 ) edge [ bend left ] node [ align = center ] @xmath11 ( d4 ) ( d4 ) edge [ bend left ] node [ align = center ] @xmath12 ( d3 )    ( a4 ) edge node [ align = center ] @xmath11 ( b4 ) ( b4 ) edge [ bend left ] node [ align = center ] @xmath10 ( a4 ) ( b4 ) edge [ bend left=25 ] node [ pos=0.45 ] @xmath11 ( c4 )    ( c1 ) edge node [ align = center ] @xmath10 ( 1,-5 ) ( d2 ) edge node [ align = center ] @xmath10 ( 5,-9 ) ( d3 ) edge node [ align = center ] @xmath10 ( 7.5,-9 ) ( d4 ) edge node [ align = center ] @xmath10 ( 10,-9 ) ( d1 ) edge node [ align = center ] @xmath10 ( 2.5,-9 ) ( 10.6,-9 ) edge ( 1,-9 ) ( 1,-9 ) edge ( 1,0 )    ( b1 ) edge node [ left ] @xmath12 ( 2.5,-4 ) ( b2 ) edge node [ left ] @xmath12 ( 5,-4 ) ( b3 ) edge node [ left ] @xmath12 ( 7.5,-4 ) ( b4 ) edge node [ left ] @xmath12 ( 10,-4 ) ( 10.6,-4 ) edge ( 0,-4 ) ( 0,-4 ) edge ( y ) ;    ;    for an operation sequence @xmath24 of size at most @xmath30 , the word @xmath24 is accepted by @xmath52 if and only if @xmath24 does not contain any of the words @xmath38 , @xmath40 or any word of the form @xmath49 , where @xmath46 is a @xmath47-catalan word , and @xmath33 is a @xmath48-catalan word .",
    "since all of these words are forbidden , any operation sequence @xmath24 which is not forbidden is accepted by @xmath52 .",
    "for any integer @xmath72 , at least @xmath72 occurrences of the letter @xmath10 are required to reach any of the states @xmath73 , @xmath74 or @xmath75 , and at least @xmath76 occurrences of the letter @xmath11 are required to reach the state @xmath77 .",
    "hence , for operation sequences of size @xmath4 , we only need to construct the finite state automaton @xmath78 , consisting of the @xmath79 states @xmath80 .",
    "note that all forbidden words of length less than 7 are rejected by @xmath52 . for each forbidden word @xmath46 of length at most 9 , which contains no other forbidden words , we construct the dfa @xmath81 which accepts the language of all words which do not contain @xmath46 .",
    "then every word which is not accepted by @xmath81 contains @xmath46 and is hence forbidden .",
    "we then take each of these dfa s @xmath81 along with @xmath78 , and construct the dfa @xmath82 , which accepts the intersection of the languages accepted by all of the other dfa s .    now , our new algorithm works as before , except that the function @xmath26 also takes in the current state @xmath83 of @xmath82 , and only recursively calls itself using one of the letters which is accepted from state @xmath83 . now ,",
    "rather than considering all operation sequences of size @xmath30 , the new algorithm only considers those operation sequences which are accepted by @xmath82 .",
    "the improvements to the algorithm so far significantly decrease the exponential factor in the time requirement , from 27 to about 13 .",
    "however the algorithm still stores every achievable permutation of length @xmath4 in memory at the same time . in the next section",
    "we see that the number of such permutations is approximately @xmath84 , so any improvements of the form which we have presented so far will not reduce the time or memory requirements below this factor .      our next improvement to the algorithm decreases the exponential factor by 1 , and we do not improve on the factor for time any more than this .",
    "let @xmath85 be a permutation and let @xmath86 .",
    "we define the subpermutation @xmath87 to be the pattern of the elements from @xmath88 in @xmath89 , and define @xmath90 . for example , @xmath91 .",
    "note that any subpermutation of an achievable permutation is also achievable .",
    "let @xmath89 be a permutation such that @xmath92 for some @xmath93 . since @xmath89 is achievable , @xmath94 is achievable . on the other hand ,",
    "if @xmath94 is achievable , then there is some operation sequence @xmath24 which creates it .",
    "now replace each letter which moves @xmath95 in @xmath24 with two copies of that letter , to form a new word @xmath36 .",
    "then the two copies of each letter will move @xmath95 and @xmath96 , and @xmath95 will enter the first stack immediately before @xmath96 , then @xmath96 will enter the second stack immediately before @xmath95 and finally , @xmath95 is output immediately before @xmath96 . since the order of everything else stays the same , the word @xmath36 creates the permutation @xmath89 .",
    "therefore , @xmath89 is achievable if and only if @xmath94 is achievable .",
    "now , instead of considering all achievable permutations with the algorithm , we only consider permutations @xmath97 for which there is no @xmath93 such that @xmath92 .",
    "call these increment avoiding permutations .",
    "let @xmath98 be the number of these permutations , and define the generating function @xmath99 .",
    "then we can uniquely create any achievable permutation by choosing a permutation @xmath100 counted by @xmath101 and replacing each number in @xmath100 with any positive number of consecutive integers .",
    "hence @xmath102 . by taking the coefficient for @xmath103 on both sides of this equation",
    ", we deduce that @xmath104 the only change we make to the algorithm presented previously to instead calculate the number of increment avoiding permutations , is to forbid an item from being output if it is exactly one greater than the previous item output .      using the algorithm described so far ,",
    "it is still necessary to list every achievable , increment avoiding permutation of size @xmath4 at the same time . to avoid this restriction",
    ", we choose some positive integer @xmath105 , and write a function @xmath106 , which inputs @xmath4 and a sequence @xmath107 of @xmath72 distinct elements of @xmath108 and outputs the number of achievable , increment avoiding permutations of size @xmath4 which begin with the sequence @xmath107 .",
    "this algorithm works in the same way as before except that the first @xmath72 elements output must be the correct elements of @xmath107 .",
    "we then run this function on all such sequences @xmath107 and add up the results . for small values of @xmath72",
    "this algorithm only takes a little longer than the original algorithm because most of the time is spent while the operation sequence is long and the output is nearly complete .",
    "since we call the function on different sequences @xmath107 separately , it is only necessary to store all of the ( achievable , increment avoiding ) permutations which begin with some sequence @xmath107 at any one time .",
    "note also that we only have to remember the last @xmath109 elements of each permutation . as a result ,",
    "the limiting factor for this algorithm is now the time requirement .",
    "we now parrallelise the algorithm , by running the @xmath106 on different sequences @xmath107 at the same time on different cores .",
    "we ran this algorithm for @xmath110 using @xmath111 .",
    "the program ran for 43 days on 64 cores .",
    "the coefficients of the ogf for @xmath112 are given as a list below .",
    "+ [ 1 , 1 , 2 , 6 , 24 , 120 , 720 , 5018 , 39374 , 337816 , 3092691 , 29659731 , 294107811 , 2988678546 , + 30935695794 , 324832481490 , 3450158410649 , 36993206191004 , 399827092167771 , + 4351269802153188 ] . +",
    "we have obtained approximate values of the next nineteen coefficients , effectively doubling the length of the series , which are sufficiently accurate to be used in the ratio analysis we describe below .",
    "our method for obtaining these approximate values uses _ differential approximants _",
    "@xcite , which are linear , inhomogeneous ode s of 2nd , 3rd or 4th order , constructed to yield all the exactly known coefficients in the series expansion under consideration . by varying the degrees of the polynomials multiplying each derivative , as well as the degree of the inhomogeneous polynomial",
    ", we can construct a family of such approximants . because every differential approximant ( da ) that uses all the available series coefficients implicitly predicts all subsequent coefficients , we can calculate , approximately , all subsequent coefficients .",
    "of course the accuracy of these predicted coefficients decreases as the order of the predicted coefficients increases , but , as we show by example below , we can get useful estimates of the next nineteen or so coefficients .    for every da using all known coefficients , we generated the subsequent nineteen coefficients .",
    "we take the mean of the predicted coefficients , with the outlying 10% or 15% of estimates rejected , as our estimate .",
    "we quote one standard deviation as the error .",
    "that is to say , assume we know the coefficients @xmath113 for @xmath114.$ ] we then predict the coefficients @xmath115 our estimate of each such coefficient is given by the mean of the values predicted by the differential approximants .",
    "we reject obvious outliers , by discarding the top and bottom 10% of estimates .",
    "not surprisingly , we find the smallest error is predicted for @xmath116 with the error slowly increasing as we generate further coefficients .",
    "these predicted coefficients are well - suited to ratio type analyses , as discrepancies in say the seventh or eighth significant digit will not affect the ratio analysis in the slightest .",
    "this is particularly useful in those situations where we suspect there might be a turning point in the behaviour of ratios or their extrapolants with our exact coefficients , as these approximate coefficients are more than accurate enough to reveal such behaviour , if it is present .    as an indication of the validity of this method , we give two applications . in the first ,",
    "we take the series for two stacks in parallel , for which we actually have more than 1000 coefficients @xcite , but assume we only have the first 20 coefficients , just as in the present case for the generating function of two stacks in series . in table [ tab : par - pred ] we show a selection of the estimated coefficients @xmath117 to @xmath118 it can be seen that we predict the next coefficient with an accuracy of 13 digits , decreasing to 7 digit accuracy for the last predicted coefficient . in every case",
    "the actual error is seen to be less than one standard deviation , indeed , it is typically @xmath119 of a standard deviation .",
    ".series coefficients @xmath120 for two stacks in parallel .",
    "approximate , predicted coefficients @xmath121 to @xmath122 from several 4th order inhomogeneous das , the estimated and exact error .",
    "[ cols=\"<,<,<,<\",options=\"header \" , ]      we first performed a simple ratio analysis , under the assumption that the coefficients behave as @xmath123 then the ratio of successive coefficients , @xmath124 behaves as @xmath125 so plotting the ratios against @xmath126 should , for sufficiently large @xmath6 give a straight line intercepting the abscissa at @xmath127 and with gradient @xmath128 we show this plot in fig .",
    "[ fig : r1 ] .",
    "one sees some low @xmath4 curvature , and this suggests the presence of a confluent singularity .",
    "that is to say , the generating function probably behaves as @xmath129 where @xmath130 such behaviour implies , at the coefficient level , @xmath131 and for the ratios @xmath132    , width=384 ]    from fig .",
    "[ fig : r1 ] it is seen that @xmath133 assuming this value , and estimating the gradient from the last plotted point , we find @xmath134 with @xmath135 we get @xmath136 and with @xmath137 we get @xmath138 by this procedure , so it is clear that the estimate of @xmath139 is very sensitive to the estimate of @xmath140    , width=384 ]    calculating linear intercepts usually gives a more precise estimate of @xmath140 one has @xmath141 for a simple algebraic singularity , which means there is no confluent singularity at @xmath142 so that @xmath143 and the subdominant term is @xmath144 and so convergence to @xmath12 is usually more rapid .",
    "however a plot of linear intercepts against @xmath145 shown in fig [ fig : int1 ] has gradient that changes sign for the last few values of @xmath6 and which may change sign again as @xmath4 increases , making it difficult to extrapolate , and strongly suggesting the presence of one or more confluent terms .",
    "it also implies that we would really need many more series coefficients in order to make more precise estimates of the critical parameters .",
    "it also reinforces the usefullness of the sequence extension procedure we have undertaken , as these approximate coefficients are essential to see this change of gradient . despite these qualifications , a limiting value around @xmath146 consistent with the value found by a simple ratio plot , seems plausible .",
    "one can also calculate the gradient directly , from @xmath147 assuming the values @xmath148 @xmath149 and @xmath150 we have plotted these estimators of @xmath139 against @xmath145 as we do nt know the correct sub - dominant exponent to use .",
    "again one sees the necessity of estimating the last few terms , as otherwise the gradient change would not be observed , and a quite inaccurate estimate of @xmath139 would be obtained .",
    "as it is , we do nt know how this plot will behave as @xmath4 increases , so can not give any extrapolation with much confidence .",
    "however , if present trends continue , a value of @xmath151 is plausible .     against @xmath152",
    "the top curve assumes @xmath148 the middle curve assumes @xmath153 and the bottom curve assumes @xmath154 , width=384 ]    it is clear that the @xmath155 term is significantly affecting our extrapolation attempts . in an effort to address this",
    ", we make comparison with two similar problems whose asymptotics we have recently studied @xcite .",
    "these are the corresponding problem of enumerating the number of permutations of various sizes that can be sorted by a deque , and by two stacks in parallel ( 2sip ) .",
    "we have shown @xcite that these two ogfs appear to have the same radius of convergence , which is quite accurately estimated as @xmath156 the generating function coefficients in the two cases are believed to behave as @xmath157 and @xmath158 for deques and 2sip respectively .",
    "further , we have estimated that @xmath159 and @xmath160 all these data are based on an analysis of series of length 500 terms , so are vastly more reliable and precise than the estimates of the corresponding critical parameters in the current problem .",
    "if we form the coefficient - by - coefficient quotients @xmath161 and @xmath162 these will behave as @xmath163 and @xmath164 respectively , where @xmath165    now we can apply simple ratio analysis to the ratios @xmath166 and @xmath167 when plotted against @xmath168 these should approach a common limit @xmath169 with gradient @xmath170 and @xmath171 respectively .",
    "upper plot is for two - stacks - in - series / two - stacks - in - parallel , lower plot is for two - stacks - in - series / deques .",
    "the common intersection point on the abscissa is estimated to be at 1.51,width=384 ]    the ratio plots are shown in fig [ fig : r2 ] , and it can be seen that the common limit is around @xmath172 and that the gradients are of opposite sign .",
    "in fact the difference in gradients is @xmath173 and we know that @xmath174 so we can tune the value of @xmath11 to be consistent with this value , as @xmath175 plotting @xmath176 against @xmath168 shown in fig . [ fig : inter ] , we esimate @xmath177 which implies @xmath178 which is just consistent with previous analyses discussed above .",
    "estimate , as explained in text , against @xmath179 , width=384 ]    this gives @xmath180 and @xmath181 thus we take as our final estimates @xmath182 and @xmath183 where the quoted errors are uncertainty estimates , and not in any sense rigorous error bounds .",
    "alternatively expressed , the ogf for two stacks in series behaves as @xmath184    our estimate of @xmath12 is of course consistent with the rigorous bounds given in @xcite , which are @xmath15 it is not inconceivable that the exponent could be the same as for two stacks in parallel , that is , 1.47327 , but we have insufficient data to estimate the exponent with anything like this precision .",
    "this would correspond to the two problems being in the same universality class , when viewed from a statistical mechanical perspective .    assuming the central estimates of both @xmath12 and the exponent @xmath139 , one can estimate the amplitude by simple extrapolation .",
    "that is to say , if @xmath185 then @xmath186 can be estimated by extrapolating the sequence @xmath187 against @xmath179 in this way we estimated @xmath188 note however that this estimate is very sensitive to the estimates of both @xmath12 and @xmath189 writing the singular part of the generating function as @xmath190 we have @xmath191",
    "we have given an algorithm to generate the number of permutations of length @xmath4 sortable by two stacks in series .",
    "we have obtained the coefficients in the corresponding generating function up to and including permutations of length 19 .",
    "we have used differential approximants to calculate the next 19 coefficients approximately , and the next 30 ratios of successive terms , and then analysed the extended series . in this way we have estimated the asymptotics of the generating function .",
    "we believe that the series length needs to be at least doubled in order to get much more significant accuracy in estimates of the critical parameters .",
    "it is a source of some frustration that this problem appears to be so much harder than the corresponding problem of two stacks in parallel , for which an exact solution @xcite is now available , as well as more than 1000 terms in the generating function .",
    "we wish to thank andrew conway for many helpful discussions and an independent check of the first 10 coefficients of our expansion .",
    "we also thank nathan clisby for providing his variable precision version of the differential approximant program , which we used to extend the series , and vince vatter for corrections to references in an earlier version of this article .",
    "99 m albert , m atkinson and s linton , _ permutations generated by stacks and deques _",
    ", ann . comb .",
    "* 14 * ( 2010 ) 3 - 16 .",
    "m albert and m bousquet - mlou , _ permutations sortable by two stacks in parallel and quarter - plane walks _",
    ", europ . j. comb .",
    "* 43 * ( 2015 ) , 131 - 164 .",
    "m d atkinson , m m murphy and n rukuc , _ sorting with two ordered stacks in series _",
    ", theor . comp .",
    "* 289 * ( 2002 ) 205323 .",
    "m elder , g lee and a r rechnitzer , _ permutations generated by a depth 2 stack and an infinite stack in series are algebraic . _ , ejc ,",
    "* 22 * issue 2 , paper # p2.16 ( 2015 ) . a elvey price and a j guttmann , _ permutations sortable by deques and by two stacks in parallel _",
    "( 2015 ) arxiv:1508.02273v1 .",
    "a j guttmann , _ phase transitions and critical phenomena , vol 13 _ , eds .",
    "c domb and j l lebowitz , academic , london and new york , ( 1989 ) .",
    "d e knuth , _ fundamental algorithms , the art of computer programming vol 1 _ , addison - wesley , massachusetts ( 1968 ) .",
    "d e knuth , _ fundamental algorithms , vol 3 _ , addison - wesley , massachusetts ( 1973 ) .",
    "a pierrot , _ combinatoire et algorithmique dans les classes de permutations _ , phd thesis ( 2013 ) a pierrot and d rossin , _",
    "2-stack sorting is polynomial _ , ( 2013 ) arxiv:1304.2860v1 ."
  ],
  "abstract_text": [
    "<S> we address the problem of the number of permutations that can be sorted by two stacks in series . we do this by first counting all such permutations of length less than 20 exactly , then using a numerical technique to obtain nineteen further coefficients approximately . </S>",
    "<S> analysing these coefficients by a variety of methods we conclude that the ogf behaves as @xmath0 where @xmath1 @xmath2 and @xmath3 . </S>"
  ]
}