{
  "article_text": [
    "in the framework of distributed network computing , local decision is the ability to check the legality of network configurations using a local distributed algorithm .",
    "this concern is of the utmost importance in the context of fault - tolerant distributed computing , where it is highly desirable that the nodes are able to collectively check the legality of their current configuration , which could have been altered by the corruption of variables due to failures . in this paper , we insist on locality , as we want the checking protocols to avoid involving long - distance communications across the network , for they are generally costly and potentially unreliable . more specifically , we consider the standard local model of computation in networks  @xcite .",
    "nodes are assumed to be given distinct identities , and each node executes the same algorithm , which proceeds in synchronous rounds where all nodes start at the same time . in each round , every node sends messages to its neighbors , receives messages from its neighbors , and performs some individual computation .",
    "the model does not limit the amount of data sent in the messages , neither it limits the amount of computation that is performed by a node during a round .",
    "indeed , the model places emphasis on the number of rounds before every node can output , as a measure of locality .",
    "( note however that , up to some exceptions , our positive results involves messages of logarithmic size , and polynomial - time computation ) .",
    "a _ local algorithm _ is a distributed algorithm @xmath0 satisfying that there exists a constant @xmath1 such that @xmath0 terminates in at most @xmath2 rounds in all networks , for all inputs .",
    "the parameter @xmath2 is called the _ radius _ of @xmath0 . in other words , in every network @xmath3 , and for all inputs to the nodes of @xmath3 , every node executing @xmath0 just needs to collect all information present in its @xmath2-ball around it in order to output , where the _ @xmath2-ball _ of @xmath4 is the ball @xmath5 .    following the guidelines of  @xcite",
    ", we define a _ configuration _ as a pair @xmath6 where @xmath7 is a connected simple graph , and @xmath8 is a function assigning an input @xmath9 to every node @xmath10 .",
    "a _ distributed language _",
    "@xmath11 is a turing - decidable set of configurations .",
    "note that the membership of a configuration to a distributed language is independent of the identity that may be assigned to the nodes in the local model ( as one may want to study the same language under different computational models , including ones that assume anonymous nodes ) .",
    "the class @xmath12 is the set of all distributed languages that are locally decidable .",
    "that is , @xmath12 is the class of all distributed languages @xmath11 for which there exists a local algorithm @xmath0 satisfying that , for every configuration @xmath6 , @xmath13 where one says that @xmath0 accepts if it accepts at _ all _ nodes .",
    "more formally , given a graph @xmath3 , let @xmath14 denote the set of all possible identity assignments to the nodes of @xmath3 ( with distinct non - negative integers )",
    ". then @xmath12 is the class of all distributed languages @xmath11 for which there exists a local algorithm @xmath0 satisfying the following : for every configuration @xmath6 , @xmath15 where @xmath16 is the output of algorithm  @xmath0 running on the instance @xmath6 with identity - assignment @xmath17 , at node  @xmath4 .",
    "for instance , the language @xmath18 , composed of all ( connected ) properly colored graphs , is in @xmath12 .",
    "similarly , the class @xmath19 of `` locally checkable labelings '' , defined in  @xcite , satisfies @xmath20 .",
    "in fact , @xmath19 is precisely @xmath12 restricted to configurations on graphs with constant maximum degree , and inputs of constant size .",
    "the class @xmath21 is the non - deterministic version of @xmath12 , i.e. , the class of all distributed languages @xmath11 for which there exists a local algorithm @xmath0 _ verifying _ @xmath11 , i.e. , satisfying that , for every configuration @xmath6 , @xmath22 more formally , @xmath21 is the class of all distributed languages @xmath11 for which there exists a local algorithm @xmath0 satisfying the following : for every configuration @xmath6 , @xmath23 where @xmath24 is the class of all functions @xmath25 , assigning certificate @xmath26 to each node  @xmath4 .",
    "note that the certificates @xmath27 may depend on the network and the input to the nodes , but should be set independently of the actual identity assignment to the nodes of the network .",
    "this guarantees that no information is revealed about far away nodes in the network by the certificates , hence preserving some form of privacy . in the following , for the sake of simplifying the notations",
    ", we shall omit specifying the domain sets @xmath24 and @xmath14 unless they are not clear from the context .",
    "it follows from the above that @xmath21 is a class of distributed languages that can be locally _ verified _ , in the sense that , on legal instances , certificates can be assigned to nodes by a _",
    "so that a _ verifier _ @xmath0 accepts , and , on illegal instances , the verifier @xmath0 rejects ( i.e. , at least one node rejects ) systematically , and can not be fooled by any fake certificate .",
    "for instance , the language @xmath28 is in @xmath21 , by selecting a root @xmath29 of the given tree , and assigning to each node @xmath4 a counter @xmath26 equal to its hop - distance to @xmath29 .",
    "if the given ( connected ) graph contains a cycle , then no counters could be assigned to fool an algorithm checking that , at each node @xmath4 with @xmath30 , a unique neighbor @xmath31 satisfies @xmath32 . in  @xcite , @xmath21 was proved to be exactly the class of distributed languages that are closed under lift .",
    "finally , @xcite defined the randomized versions @xmath33 and @xmath34 , of the aforementioned classes @xmath12 and @xmath21 , respectively , by replacing the use of a deterministic algorithm with the use of a randomized algorithm characterized by its probability @xmath35 of acceptance for legal instances , and its probability @xmath36 of rejection for illegal instances . by defining @xmath37 , the landscape of local decision",
    "was pictured as follows : @xmath38 where all inclusions are strict , and @xmath39 is the set of all distributed languages .",
    "that is , every distributed language can be locally verified with constant success probabilities @xmath35 and @xmath36 , for some @xmath35 and @xmath36 satisfying @xmath40 .",
    "in other words , by combining non - determinism with randomization , one can decide any given distributed language .",
    "however , this holds only up to a certain guaranty of success , which is only guarantied to satisfy @xmath40 .      following up the approach recently applied to _ distributed graph automata _ in  @xcite , we observe that the class @xmath12 and @xmath21 are in fact the basic levels of a `` local hierarchy '' defined as follows .",
    "let @xmath41 , and , for @xmath42 , let @xmath43 be the class of all distributed languages @xmath11 for which there exists a local algorithm @xmath0 satisfying that , for every configuration  @xmath6 , @xmath44 where the quantifiers alternate , and @xmath45 is the universal quantifier if @xmath46 is even , and the existential one if @xmath46 is odd . the class @xmath47 is defined similarly , by starting with a universal quantifier , instead of an existential one .",
    "a local algorithm @xmath0 insuring membership to a class @xmath48 is called a @xmath49-algorithm .",
    "hence , @xmath50 , and , for instance , @xmath51 is the class of all distributed languages @xmath11 for which there exists a @xmath51-algorithm , that is , a local algorithm @xmath0 satisfying the following : for every configuration @xmath6 , @xmath52    our main results are the following .",
    "[ theo : main1 ] @xmath53 , where all inclusions are strict .",
    "that is , @xmath54 , while @xmath55 , and the whole local hierarchy collapses to the second level , at @xmath56 .",
    "this collapsing has a significant impact on our ability to certify the legality , or correctness of a network configuration w.r.t .",
    "any ( turing decidable ) boolean predicate on networks .",
    "indeed , @xmath57 says that , for every network predicate , there is a distributed protocol satisfying the following two properties :    1 .   for every network configuration that is legal w.r.t .  the predicate , and for any attempt by an adversary to prove the illegality of that configuration using distributed certificates , there is a locally verifiable proof that the adversary is wrong , also using distributed certificates , whose setting is _ independent of the node identities_. 2",
    "for every network configuration that is illegal w.r.t .",
    "the predicate , there is a proof of that illegality , using distributed certificates whose setting is _ independent of the node identities _ , such that no matter the way an adversary assigns its own set of distributed certificates in an attempt to prove the legality of the configuration , the actual illegality of the configuration will be locally detected .",
    "we complete our description of the local hierarchy by a collection of separation and completeness results regarding the different classes and co - classes in the hierarchy .",
    "in particular , we revisit the completeness results in  @xcite , and show that the notion of reduction introduced in this latter paper is too strong , and may allow a language outside @xmath21 to be reduced to a language in @xmath21 . we introduce a more restricted form of local reduction , called _ label - preserving _ , which does not have this undesirable property , and we establish the following .    [ theo : main2 ] @xmath21 and @xmath51 have complete distributed languages for local label - preserving reductions .",
    "finally , figure  [ fig : summary ] summarizes all our separation results .",
    "several form of `` local hierarchies '' have been investigated in the literature , with the objective of understanding the power of local computation , and/or for the purpose of designing verification mechanisms for fault - tolerant computing .",
    "in particular , @xcite has investigated the case of _ distributed graph automata _",
    ", where the nodes are finite automata , and the network is anonymous ( which are weaker assumptions than those in our setting ) , but also assuming an arbitrary global interpretation of the individual decisions of the nodes ( which is a stronger assumption than those in our setting ) .",
    "it is shown that all levels @xmath58 , @xmath59 , of the resulting hierarchy are separated , and that the whole local hierarchy is exactly composed of the mso ( monadic second order ) formulas on graphs .    in the framework of distributed computing , where the computing entities are turing machines , _ proof - labeling schemes _ ( pls ) @xcite , extended to _ locally checkable proofs _ ( lcp )  @xcite , give the ability to certify predicates using certificates that can take benefits of the node identities .",
    "that is , for the same network predicate , and the same legal network configuration , the distributed proof that this configuration is legal may be different if the node identities are different . in this context , the whole hierarchy collapses at the first level , with @xmath60",
    ". however , this holds only if the certificates can be as large as @xmath61 bits . in  @xcite , the class loglcp  @xcite , which bounds the certificate to be of size @xmath62 bits",
    "is extended to a hierarchy .",
    "in particular , it is shown that mst stands at the second level @xmath63 of that hierarchy , while there are languages outside the hierarchy .    in @xcite",
    ", the authors introduced the model investigated in this paper .",
    "in particular , they defined and characterized the class @xmath21 , which is noting else than @xmath64 , that is , the class of languages that have a proof - labeling scheme in which the certificates are _ not _ depending on the node identities .",
    "it is proved that , while @xmath65 , randomization helps a lot , as the randomized version @xmath66 of @xmath21 satisfies @xmath67 .",
    "it is also proved that , with the oracle # nodes providing each node with the number of nodes in the network , we get @xmath68 .",
    "interestingly , it was proved  @xcite that restricting the verification algorithms for @xmath21 to be _ identity - oblivious _ , that is , enforcing that each node decides the same output for every identity - assignment to the nodes in the network , does not reduce the ability to verify languages .",
    "this is summarized by the equality @xmath69 where the `` o '' in @xmath70 stands for identity - oblivious .",
    "instead , it was recently proved that restricting the algorithms to be identity - oblivious reduces the ability to decide languages locally , i.e. , @xmath71 ( see  @xcite ) .",
    "finally , it is worth mentioning that the ability to decide a distributed language locally has impact on the ability to design _ construction _ algorithms  @xcite for that language ( i.e. , computing outputs @xmath72 such that the configuration @xmath6 is legal w.r.t .",
    "the specification of the task ) .",
    "for instance , it is known that if @xmath11 is locally decidable , then any randomized local construction algorithm for @xmath11 can be derandomized  @xcite .",
    "this result has been recently extended  @xcite to the case of languages that are locally decidable by a randomized algorithm ( i.e. , extended from @xmath12 to @xmath73 according to the notations in  @xcite ) .",
    "more generally , the reader is invited to consult  @xcite for good introductions to local computing , and/or samples of significant results related to local computing .",
    "in this section , we show the last equality of theorem  [ theo : main1 ] .    [ prop : pi2isall ] _ @xmath57 . _    let @xmath11 be a distributed language .",
    "we give an explicit @xmath51-algorithm for @xmath11 , i.e. , a local algorithm @xmath0 such that , for every configuration @xmath6 , eq .",
    "is satisfied . for this purpose",
    ", we describe the distributed certificates  @xmath74 and  @xmath75 .",
    "intuitively , the certificate  @xmath74 aims at convincing each node that @xmath76 , while  @xmath75 aims at demonstrating the opposite .",
    "more precisely , at each node  @xmath4 in a configuration @xmath6 , the certificate @xmath77 is interpreted as a triple @xmath78 where  @xmath79 is an @xmath80 boolean matrix , @xmath81 is a linear array with @xmath82 entries , and @xmath83 .",
    "informally , @xmath77 aims at proving to node  @xmath4 that it is node labeled @xmath84 in the @xmath82-node graph with adjacency matrix  @xmath79 , and that the whole input data is  @xmath81 .",
    "we denote by  @xmath85 the number of nodes of the actual graph  @xmath3 .    for a legal configuration @xmath86 , given @xmath74 , the certificate  @xmath75",
    "is then defined as follows .",
    "it is based on the identification of a few specific nodes , that we call _",
    "witnesses_. intuitively , a witness is a node enabling to demonstrate that the structure of the configuration @xmath6 does not fit with the given certificate @xmath74 .",
    "let @xmath87 denote the distance between any two nodes @xmath4 and @xmath31 in the actual network  @xmath3 , that is , @xmath87 equals the number of edges of a shortest path between @xmath4 and @xmath31 in @xmath3 .",
    "a certificate @xmath88 is of the form @xmath89 where @xmath90 is a flag , and @xmath91 depends on the value of the flag .     case 0 : there are two adjacent nodes @xmath92 such that @xmath93 , or there are nodes @xmath31 in which @xmath94 can not be read as a triple @xmath95 .",
    "then we set one of these nodes as witness  @xmath96 , and we set @xmath97 at every node  @xmath4 .    otherwise , i.e. , if the pair @xmath98 is identical to some pair @xmath99 at every node  @xmath4 :     case 1 : @xmath6 is isomorphic to @xmath99 , preserving the inputs , denoted by @xmath100 , and @xmath101 is injective .",
    "then we set @xmath102 at every node  @xmath4 .",
    " case 2 : @xmath103 , i.e. , @xmath104 is larger than the dimension @xmath82 of @xmath105 , or @xmath101 is not injective .",
    "then we set the certificate @xmath106 where @xmath107 , and @xmath108 are two distinct nodes such that @xmath109 .",
    "these two nodes @xmath96 and @xmath110 are both witnesses .",
    " case 3 : @xmath111 and @xmath101 is injective",
    ". then we set @xmath112 where @xmath107 is such that @xmath113 for every node  @xmath31 .",
    " case 4 : @xmath114 and @xmath101 is injective , but @xmath6 is not isomorphic to @xmath99 .",
    "then we set as witness a node  @xmath96 whose neighborhood in @xmath6 does not fit with what it should be according to @xmath99 , and we set @xmath115 for every node  @xmath4 .",
    "the local verification algorithm @xmath0 then proceeds as follows .",
    "first , every node @xmath4 checks whether its flag @xmath116 in @xmath88 is identical to all the ones of its neighbors , and between  0 and  4 . if not , then @xmath4 rejects .",
    "otherwise , @xmath4 carries on executing the verification procedure .",
    "its behavior depends on the value of its flag .    ",
    "if @xmath117 , then @xmath4 checks that at least one of its neighbors has a distance to the witness that is smaller than its own distance . a node with distance @xmath118 to the witness",
    "checks that there is indeed an inconsistency with its @xmath74 certificate ( i.e. , its @xmath74 certificate can not be read as a pair matrix - data , or its @xmath74 certificate is distinct from the one of its neighbors ) .",
    "every node accepts or rejects accordingly .    ",
    "if @xmath119 , then @xmath4 accepts or rejects according to whether @xmath120 ( recall that , by definition , we consider only distributed languages @xmath11 that are turing - decidable ) .     if @xmath121 , then @xmath4 checks that it has the same index @xmath122 in its certificate @xmath75 as all its neighbors . if that is not the case , then it rejects .",
    "otherwise , it checks each of the two distances in its certificate @xmath75 separately , each one as in the case where @xmath117 .",
    "a node with one of the two distances equal to @xmath118 also checks that its @xmath74 index is equal to the index  @xmath122 in @xmath75",
    ". if that is not the case , or if its two distances are equal to  @xmath118 , then it rejects .",
    "if all the test are passed , then @xmath4 accepts .    ",
    "if @xmath123 , then @xmath4 accepts if and only if it has the same index @xmath122 in its @xmath75 certificate as all its neighbors , and @xmath124 .    ",
    "if @xmath125 , then @xmath4 checks the distances as in the case where @xmath117 . a node with distance  0 also checks that its neighborhood in the actual configuration @xmath6 is not what it should be according to @xmath99",
    "it accepts or rejects accordingly . to prove the correctness of this algorithm  @xmath0 ,",
    "let us first consider a legal configuration @xmath86 .",
    "we show that the way @xmath75 is defined guarantees that all nodes accept , because @xmath75 correctly pinpoints inconsistencies in @xmath74 , witnessing any attempt of @xmath74 to certify that the actual configuration is illegal . indeed , in case  0 , by the setting of @xmath75 , all nodes but the witness accept .",
    "also , the witness itself accepts because it does witness the inconsistency of the @xmath74 certificate . in case  1 , then all nodes accept because @xmath100 and @xmath86 . in case  2 , by the setting of @xmath75 , all nodes but the witnesses accept , and the witnesses accept too because each one checks that it is the vertex with index  @xmath122 in @xmath105 . in case  3 ,",
    "all nodes accept by construction of the certificate  @xmath75 . finally , in case  4 , by the setting of @xmath75 , all nodes but the witness accept .",
    "also , the witness itself accepts because , as in case  0 , it does witness the inconsistency of the @xmath74 certificate .",
    "so , in all cases , all nodes accept , as desired .",
    "we are now left with the case of illegal configurations .",
    "let @xmath126 be such an illegal configuration .",
    "we set @xmath127 where @xmath128 and @xmath84 is the index of node @xmath4 in the adjacency matrix @xmath105 and the array @xmath129 .",
    "we show that , for any certificate @xmath75 , at least one node rejects . indeed , for all nodes to accept",
    ", they need to have the same flag in @xmath75",
    ". this flag can not be  1 because , if @xmath130 then @xmath4 checks the legality of @xmath99 . in all other cases ,",
    "the distance checking should be passed at all nodes for them to accept .",
    "thus , the flag is distinct from  0 and  4 because every radius-1 ball in @xmath6 fits with its description in @xmath99 .",
    "also , the flag is distinct from  2 because there are no two distinct nodes with the same index  @xmath122 in the @xmath74 certificate . finally , also the flag is distinct from  3 , because , by the setting of @xmath74 , every index in @xmath131 appears at some node , and this node would reject .",
    "hence , all cases lead to contradiction , that is , not all nodes can accept , as desired .    to conclude the section ,",
    "let us define a simple problem in @xmath132 .",
    "let @xmath133 , which stands for `` exactly two selected '' be the following language .",
    "we set @xmath134 if @xmath135 for every @xmath136 , and @xmath137 . proving that @xmath138 is easy using the following characterization of @xmath21 .",
    "let @xmath139 .",
    "a configuration @xmath140 is a @xmath2-lift of a configuration @xmath6 iff there exists a mapping @xmath141 such that , for every @xmath142 , @xmath143 is isomorphic to @xmath144 , preserving inputs .",
    "a distributed language @xmath11 is closed under lift if there exists @xmath139 such that , for every @xmath6 , we have @xmath86 implies @xmath145 for every @xmath140 that is a @xmath2-lift of @xmath6 .    [",
    "lem : lift ] @xmath21 is the class of distributed languages closed under lift .",
    "since @xmath133 is not closed under lift , it results from lemma  [ lem : lift ] that @xmath138 .",
    "in this section , we prove the part of theorem  [ theo : main1 ] related to the two classes @xmath146 and @xmath147 .",
    "these two classes have in common that the universal quantifier is positioned last .",
    "it results that these two classes seem to be limited , as witnessed by the following two propositions .    _",
    "[ prop : sigma2-equal - nld ] @xmath148 . _    by lemma  [ lem : lift ] , it is sufficient to prove that , for any @xmath149 , @xmath11 is closed under lift .",
    "if @xmath149 then let @xmath0 be a local algorithm establishing the membership of @xmath11 in @xmath147 . @xmath0 is satisfying the following .",
    "for every @xmath86 , @xmath150 let @xmath2 be the radius of @xmath0 , and assume , for the purpose of contradiction , that @xmath11 is not closed under lift .",
    "there exists @xmath151 , and a @xmath2-lift @xmath140 of @xmath6 with @xmath152 .",
    "let @xmath141 be this @xmath2-lift .",
    "note that the @xmath2-balls in @xmath6 are identical to the @xmath2-balls in @xmath140 by definition of a @xmath2-lift .",
    "let @xmath74 be the distributed certificate that makes @xmath0 accept @xmath6 at all nodes , for all certificates @xmath75 .",
    "let @xmath153 be the distributed certificate for @xmath140 defined by @xmath154 .",
    "since , with certificate @xmath74 , @xmath0 accepts at all nodes of @xmath3 , for every certificate @xmath75 , and for every identity assignment , it follows that , with certificate @xmath153 , @xmath0 accepts at all nodes of @xmath155 , for every certificate @xmath156 , and for every identity assignment , contradicting the correctness of @xmath0 .",
    "therefore , @xmath11 is closed under lift .",
    "thus , @xmath157 . since , by definition , @xmath158 , the result follows .",
    "to show that @xmath159 , we consider the language @xmath160 , which stands for `` at least two selected '' .",
    "( note that @xmath160 is the complement of the language @xmath161 introduced in  @xcite , where @xmath161 stands for `` at most one selected '' ) .",
    "we set @xmath162 if @xmath135 for every node @xmath136 , and @xmath163 .",
    "note that @xmath164 .",
    "_ [ prop : pi1subsetnld ] @xmath165 ( the inclusion is strict ) .",
    "_    by lemma  [ lem : lift ] , to establish @xmath166 , it is sufficient to prove that , for any @xmath167 , @xmath11 is closed under lift .",
    "the arguments are exactly similar to the ones used in the proof of proposition  [ prop : sigma2-equal - nld ] without even the need to lift a first set of certificates . to show that @xmath159 , we consider the language @xmath160 .",
    "we have @xmath168 because @xmath160 is closed under lift .",
    "however , @xmath169 . indeed",
    ", assume that there exists a local algorithm @xmath0 for @xmath170 . then , consider the cycle @xmath171 , and three distinct nodes @xmath172 in @xmath171 equally spread at distance @xmath173 .",
    "let us fix a set of certificates , say @xmath174 for every node @xmath4 .",
    "@xmath0 can not be correct for all eight configurations resulting from the two possible input assignments @xmath175 or @xmath176 to the three nodes @xmath172 .",
    "while @xmath146 is in @xmath21 , the universal quantifier does add some power compared to @xmath12 .",
    "we show that @xmath177 by exhibiting a language in @xmath178 .",
    "note that the existence of this language is not straightforward as it must involve turing - computability issues .",
    "indeed , if one does not insist on the fact that the local algorithm must be a turing - computable function , then the two classes @xmath12 and @xmath146 would be identical .",
    "for instance , given a @xmath2-round algorithm @xmath0 deciding a language @xmath11 in @xmath146 , one could define the following function @xmath179 for deciding the same language in @xmath12 .",
    "given a @xmath2-ball @xmath180 centered at @xmath4 , node @xmath4 accepts with @xmath179 if and only if there are no certificate assignments to the nodes of @xmath180 that could lead @xmath0 to reject at @xmath4 .",
    "the function @xmath179 is however not an algorithm .",
    "we show that , in fact , @xmath181 .    _",
    "@xmath182 where the inclusion is strict .",
    "_    we describe the distributed language @xmath183 , which stands for `` iteration '' .",
    "let @xmath105 be a turing machine , and let us enumerate lexicographically all the states of the system tape - machine where @xmath105 starts its execution on the blank tape , with the head at the beginning of the tape .",
    "we define the function @xmath184 by @xmath185 , @xmath186 , and , for @xmath187 , @xmath188 equal to the index of the system state after one step of @xmath105 from system state @xmath122 .",
    "we define @xmath183 as the collection of configurations @xmath6 representing two sequences of iterations of a function @xmath189 on different inputs @xmath190 and @xmath191 ( see figure  [ fig : iter ] ) .    _ _ ]    more precisely , let @xmath105 be a turing machine , and let @xmath190 and @xmath191 be two non - negative integers .",
    "we define the following family of configurations  cf . figure  [ fig : iter ] .",
    "a configuration in @xmath183 mainly consists in a path @xmath192 with a special node @xmath31 , called the _ pivot _ , identified in this path .",
    "so @xmath193 where @xmath194 and @xmath195 are subpaths , respectively called left path and right path .",
    "all nodes of the path are given the machine @xmath105 as input , and the pivot @xmath31 is also given @xmath190 and @xmath191 as inputs .",
    "the node of the left path ( resp .",
    ", right path ) at distance @xmath122 from @xmath31 is given a value @xmath196 ( resp .",
    ", @xmath197 ) as input . to be in the language",
    ", it is required that , for every @xmath122 , @xmath198 where @xmath199 denotes the @xmath122th iterated of a function @xmath200 .",
    "let @xmath201 and @xmath202 be the two nodes at the extremity of the left path and of the right path , respectively .",
    "the configuration is in the language if and only if the @xmath179-values at both extremities of the path @xmath192 are  0 or  1 , and at least one of them is equal to  0 .",
    "that is , the configuration is in the language if and only if : @xmath203 in fact , for technical reasons , it is also required that both @xmath204 and @xmath205 are powers of  2 .",
    "indeed , on top of @xmath194 and @xmath195 are two complete binary trees @xmath206 and @xmath207 , respectively , with horizontal paths connecting nodes of the same depth in each tree ( see figure  [ fig : iter ] ) .",
    "the nodes of @xmath194 and @xmath195 are the leaves of these two trees .",
    "finally , every node @xmath4 of the graph receives as input a pair of labels @xmath208 .",
    "the label @xmath209 is the distance modulo  3 from @xmath4 to the right - most node ( resp .",
    ", left - most node ) of the path if @xmath4 is an internal node of @xmath206 ( resp . , @xmath207 ) , and , for nodes in the path @xmath192 , @xmath209 is simply the distance modulo  3 from the pivot @xmath31 .",
    "the label @xmath210 is the height of the node in its tree modulo  3 .",
    "( the pivot , which belongs to none of the trees , has height  0 ) .",
    "a configuration @xmath211 if and only if @xmath6 satisfies all the above conditions with respect to the given machine  @xmath105 .",
    "let us consider a weaker version of @xmath183 , denoted by @xmath212 where the condition of eq .",
    "is replaced by just : @xmath213 thanks to the labeling @xmath214 at each node , which `` rigidifies '' the structure , we have @xmath215 using the same arguments as the ones in  @xcite .",
    "moreover , @xmath216 . to see why , we describe a local algorithm @xmath0 using certificates .",
    "the algorithm first checks whether @xmath217 .",
    "all nodes , but the pivot @xmath31 , decide according to this checking .",
    "if the pivot rejected @xmath217 , then it rejects in @xmath0 as well .",
    "otherwise , it carries on its decision process by interpreting its certificate as a non - negative integer @xmath46 , and accepts in @xmath0 unless @xmath218 and @xmath219 . to show the correctness of @xmath0 ,",
    "let @xmath220 .",
    "we have @xmath221 or @xmath222 , i.e. , @xmath223 or @xmath224 .",
    ", assume @xmath223 . if @xmath225 then @xmath226 since @xmath185 , and thus @xmath31 accepts . if @xmath227 then @xmath228 since @xmath186 , and thus @xmath31 accepts .",
    "therefore , all certificates lead to acceptance .",
    "let us now consider @xmath229 .",
    "if @xmath230 then at least one node rejects , independently of the certificate .",
    "so , we assume that @xmath231 .",
    "thus , @xmath232 and @xmath233 .",
    "the certificate is set to @xmath234 .",
    "let us assume , w.l.o.g .",
    ", that @xmath235 . by this setting",
    ", we have @xmath218 .",
    "moreover , since @xmath236 , and since @xmath186 , we get that @xmath219 .",
    "therefore , @xmath0 rejects , as desired .",
    "thus , @xmath237 .",
    "it remains to show that @xmath238 .",
    "let us assume , for the purpose of contradiction , that there exists a @xmath2-round algorithm @xmath0 deciding @xmath183",
    ". since @xmath239 , this algorithm is able to distinguish an instance with @xmath232 and @xmath233 from instances in which @xmath240 or @xmath241 .",
    "observe that a node at distance greater than @xmath2 from the pivot can gather information related to only one of the two inputs @xmath190 and @xmath191 .",
    "therefore , the distinction between the case @xmath232 and @xmath233 and the case @xmath240 or @xmath241 can only be made by a node at distance at most @xmath2 from the pivot .",
    "therefore , by simulating @xmath0 at all nodes in the ball of radius @xmath2 around @xmath31 , with identities between  1 and the size of the ball of radius @xmath242 around the pivot , a sequential algorithm can determine , given a turing machine @xmath105 , and given @xmath190 and @xmath191 , whether there exist @xmath243 and @xmath29 such that @xmath244 or not , which is actually turing undecidable .",
    "this contradiction implies that , indeed , @xmath238 .",
    "given a class @xmath49 of distributed languages , the class co-@xmath49 is composed of all distributed languages @xmath11 such that @xmath245 , where @xmath246 .",
    "for instance , co-@xmath146 is the class of languages @xmath11 for which there exists a local algorithm @xmath0 such that , for every configuration @xmath6 , @xmath247 note in particular , that the rejection must now be unanimous , while the acceptance requires only one node to accept .",
    "let us define the following two languages : each input to every node belongs to @xmath248 , and a configuration is in @xmath249 ( resp .",
    ", in @xmath250 ) if and only if the logical conjunction ( resp . ,",
    "disjunction ) of the inputs is true .",
    "we have @xmath251 .",
    "these two languages enable to separate @xmath12 from its co - class .",
    "indeed , trivially , @xmath252 , and @xmath253 ( without communication ) .",
    "the class @xmath254 is almost trivial .",
    "it contains simple distributed languages such as @xmath255 , the class of graphs with diameter at most @xmath46 , for any fixed @xmath46 .",
    "we have the following separation .    _",
    "@xmath256 , and @xmath257 .",
    "_    similarly , the languages @xmath160 and @xmath161 introduced in the proof of proposition  [ prop : pi1subsetnld ] enable to separate @xmath21 from its co - class .",
    "indeed , @xmath258 , @xmath160 is closed under lift , and @xmath161 is not closed under lift .",
    "moreover , consider the language @xmath133 defined at the end of section  [ sec : allinpi2 ] .",
    "both @xmath133 and @xmath259 are not closed under lift .",
    "so , overall , by lemma  [ lem : lift ] , we get :    _ @xmath260 , @xmath261 , and @xmath262 .",
    "_    more interesting is the position of the @xmath146 w.r.t . @xmath21 and @xmath263 :    [ prop : unionpiintersectnld]_@xmath264 , where the inclusion is strict . _    from proposition  [ prop : pi1subsetnld ] , we know that @xmath165 . we prove that @xmath265 .",
    "let @xmath266 , and let @xmath0 be a @xmath2-round algorithm deciding @xmath11 .",
    "let @xmath86 , and let @xmath27 be a certificate such that @xmath0 accepts at all nodes .",
    "let @xmath140 be a @xmath2-lift of @xmath6 , and lift @xmath27 into @xmath267 accordingly .",
    "then @xmath0 also accepts @xmath140 , which implies that @xmath11 is closed under @xmath2-lift , and thus , by lemma  [ lem : lift ] , @xmath268 .",
    "therefore @xmath269 to prove that the inclusion is strict , we consider the language @xmath270 .",
    "we have @xmath271 since a tree can not be lifted .",
    "we also have @xmath272 since a tree can not result from a lift .",
    "( by lemma  [ lem : lift ] , @xmath263 is the class of languages @xmath11 closed down under lift , i.e. , if @xmath151 is the lift of a configuration @xmath140 , then we have @xmath145 ) . to see why @xmath273 ,",
    "consider a path and a cycle .",
    "if @xmath274 could be decided in @xmath146 , then the center nodes of the path must accept for all certificates and for any identity - assignment .",
    "hence , all degree-2 nodes that see only degree-2 nodes in their neighborhoods accept , for all certificates . as a consequence , the cycle will be incorrectly accepted for all certificates . somewhat similarly ,",
    "if @xmath274 could be decided in co-@xmath146 , say in @xmath2-rounds , then it would mean that , in a path , the node(s ) that accept(s ) ( with the appropriate certificate ) can only be at distance at most @xmath2 from an extremity of the path . indeed ,",
    "otherwise , one could close the path and create a cycle that will still be accepted .",
    "so , by gluing two paths @xmath192 and @xmath275 of length at least @xmath242 to two antipodal nodes of a cycle @xmath276 , and by giving to the nodes of @xmath192 and @xmath275 the certificates that lead each of them to be accepted , this graph would be incorrectly accepted .",
    "in this section , we prove theorem  [ theo : main2 ] .",
    "let @xmath3 be a connected graph , and @xmath277 be a set ( typically , @xmath278 ) .",
    "let @xmath279 , and let @xmath280 .",
    "that is , @xmath281 assigns an element @xmath282 to every node @xmath136 , and @xmath283 assigns a collection of sets @xmath284 to every node @xmath136 , with @xmath285 and @xmath286 for every @xmath287 .",
    "we say that @xmath283 covers @xmath281 if and only if there exists @xmath136 , and there exists @xmath288 , such that @xmath289 . in  @xcite , the authors defined the language @xmath290 and proved that @xmath291 is the `` most difficult problem '' , in the sense that every distributed language can be locally reduced to @xmath291 .",
    "however @xmath291 is closed under lift as lifting does not create new elements , while lifting preserves the sets .",
    "therefore , by lemma  [ lem : lift ] , @xmath292 .",
    "in fact , one can show that there exists a local verification algorithm for @xmath291 using certificates of size quasi linear in @xmath85 whenever the ground set @xmath277 is of polynomial size .",
    "_ [ prop : smallcertif ] let @xmath277 be the ground set of @xmath291",
    ". then @xmath291 has a local decision algorithm for @xmath21 , using certificates of size @xmath293 bits .",
    "_    given @xmath294 , where @xmath3 is an @xmath85-node graph , the prover assigns the following certificates to the nodes . for any @xmath136",
    ", we have @xmath295 , where , for every @xmath296 , @xmath297 is a non - negative integer , and , for every @xmath298 , @xmath299 .",
    "this certificate is on @xmath293 bits .",
    "the @xmath297 s measure distances : @xmath300 is the distance from @xmath4 to the node @xmath31 which has a set @xmath301 covering @xmath281 , and , for every @xmath298 , @xmath297 is the distance from @xmath4 to a node @xmath302 with @xmath303",
    ".    the verifier acts as follows , in just one communication round .",
    "every node @xmath4 checks that it has the same number of distance entries in its certificate as all its neighbors , and that the @xmath122th elements coincide between neighbors , for every @xmath304 .",
    "next , it checks that one and only one of its distances @xmath297 with @xmath298 is null , and that @xmath305 .",
    "next , if @xmath306 , it checks that it has a set @xmath307 . finally , it checks that the distances are consistent , that is , for every @xmath122 such that @xmath308 , it checks that it has at least one neighbor whose @xmath122th distance is smaller than @xmath297 .",
    "if all tests are passed , then @xmath4 accepts , otherwise it rejects .    by construction , if @xmath294 then all nodes accept .",
    "conversely , let us assume that all nodes accept .",
    "since the distances are decreasing , for each element @xmath309 there must exist at least one node @xmath4 such that @xmath310 .",
    "conversely , every node has its element appearing in the certificate ( because it must have one distance equal to  0 ) .",
    "finally , since the distance @xmath300 is decreasing , there must exist at least one node @xmath4 that has a set @xmath307 .",
    "this implies that @xmath294 .",
    "this latter result is in contradiction with the claim in  @xcite regarding the hardness of @xmath291 .",
    "the reason for this contradiction is that the local reduction used in  @xcite for reducing any language to @xmath291 is too strong .",
    "indeed , it transforms a configuration @xmath6 into a configuration @xmath311 where the certificates used for proving @xmath312 may depend on the identities of the nodes in @xmath3 .",
    "this is in contradiction with the definitions of the classes @xmath43 and @xmath47 , @xmath59 , for which the certificates must be independent of the identity assignment . in this section ,",
    "we show that completeness results can be obtained using a more constrained notion of reduction which preserves the membership to the classes .",
    "recall from @xcite that a local reduction of @xmath11 to @xmath313 is a local algorithm @xmath314 which maps any configuration @xmath6 to a configuration @xmath315 , where @xmath316 may depend of the identity assignment @xmath17 , such that : @xmath86 if and only if , for every identity assignment @xmath17 to the nodes of @xmath3 , @xmath317 where @xmath318 . ideally , we would like @xmath314 the be _ identity - oblivious _ , that is , such that the output of each node does not depend on the identity assignment .",
    "we use a concept somewhat intermediate between identity - oblivious reduction and the unconstraint reduction in  @xcite .    _",
    "[ def : reductino ] let @xmath49 be a class of distributed languages , and let @xmath11 and @xmath313 be two distributed languages .",
    "let @xmath0 be a @xmath49-algorithm deciding @xmath313 , and let @xmath314 be a local reduction of @xmath11 to @xmath313 .",
    "we say that @xmath319 is _ label - preserving _ for @xmath320 if and only if , for any configuration @xmath6 , the certificates used by the prover in @xmath0 for @xmath315 where @xmath318 are the same for all identity assignments @xmath17 to @xmath3 .",
    "_    the following result shows that the notion of reduction in definition  [ def : reductino ] preserves the classes of distributed languages .",
    "[ lem : preserveclasses ] let @xmath49 be a class of distributed languages .",
    "let @xmath11 and @xmath313 be two distributed languages with @xmath321 , and let @xmath319 be a label - preserving local reduction for @xmath320",
    ". then @xmath322 .",
    "we describe a local algorithm @xmath323 for deciding @xmath11 in @xmath49 .",
    "in essence , @xmath324 .",
    "more precisely , let @xmath6 be a configuration , with an arbitrary identity assignment @xmath17 , and let @xmath316 .",
    "let @xmath27 be a certificate assigned by the prover in @xmath0 for configuration @xmath315 .",
    "( note that this certificate may depend on some previously set certificates , as in , e.g. , @xmath146 ) .",
    "the certificate assigned by the prover in @xmath323 for configuration @xmath6 is @xmath27 .",
    "the algorithm @xmath323 then proceeds as follows . given @xmath6",
    ", it computes @xmath315 using @xmath195 , and then applies @xmath0 on @xmath315 using the certificates constructed by the prover in @xmath323 .",
    "algorithm @xmath323 then outputs the decision taken by @xmath0 . since @xmath195 preserves the membership to the languages , and since the certificates assigned by the prover in @xmath0 for configurations resulting from the application of @xmath195 are independent of the identity assignment , the certificates chosen under the identity assignment @xmath17 are also appropriate for any other identity assignment @xmath325 .",
    "this guarantees the correctness of @xmath323 , and thus @xmath326 .    in the following problem ,",
    "every node @xmath4 of a configuration @xmath6 is given a family @xmath327 of configurations , each described by an adjacency matrix representing a graph , and a 1-dimensional array representing the inputs to the nodes of that graph .",
    "in addition , every node @xmath4 has an input string @xmath328 .",
    "hence , @xmath311 is also a configuration .",
    "the actual configuration @xmath6 is legal if @xmath311 is missing in all families @xmath327 for every @xmath136 , i.e. , @xmath329 where @xmath330 . in short ,",
    "we consider the language @xmath331 we show that @xmath332 is among the hardest problems , under local label - preserving reductions .",
    "note that @xmath333 ( it is not closed under lift : it may be the case that @xmath334 but a lift of @xmath311 is in @xmath335 ) .",
    "[ prop : missispi2-complete]_@xmath332 is @xmath51-complete for local label - preserving reductions .",
    "_    let @xmath11 be a distributed language .",
    "we describe a local label - preserving reduction @xmath336 for @xmath337 with respect to @xmath51 .",
    "in essence , the local algorithm @xmath0 for deciding @xmath332 in @xmath51 is the generic algorithm described in the proof of proposition  [ prop : pi2isall ] .",
    "recall that , in this generic algorithm , on a legal configuration @xmath6 , the existential @xmath75 certificate in @xmath0 is pointing to an inconsistency in the given @xmath74 certificate which is supposed to describe the configuration @xmath6 . and",
    ", on an illegal configuration @xmath6 , the existential @xmath74 certificate in @xmath0 does provide an accurate description of the configuration @xmath6 .",
    "for the purpose of label - preservation , we slightly modify the generic algorithm for @xmath332 . instead of viewing @xmath74 as a description of the configuration @xmath6 ,",
    "the algorithm views it as a description of @xmath311 where , at each node @xmath4 , @xmath338 is the second item in @xmath9 ( the first item is the family @xmath327 ) .",
    "the algorithm is then exactly the same as the generic algorithm with the only modification that the test when the flag @xmath130 is not regarding whether @xmath339 , but whether @xmath340 . on a legal configuration , all nodes accept . on an illegal instance",
    ", a node with @xmath341 rejects .",
    "the reduction @xmath195 from @xmath11 to @xmath332 proceeds as follows , in a way similar to the one in  @xcite .",
    "a node @xmath4 with identity @xmath342 and input @xmath9 computes its _ width _",
    "@xmath343 where @xmath344 denotes the length of a bit - string  @xmath345 .",
    "then @xmath4 generates all configurations @xmath346 such that @xmath347 has at most @xmath348 nodes and @xmath349 has value at most @xmath348 , for every node  @xmath31 of @xmath347 .",
    "it places all these configurations in @xmath327 .",
    "the input @xmath338 is simply @xmath350 . if @xmath86 , then @xmath351 since only illegal instances are in @xmath335 , and thus @xmath352 .",
    "conversely , if @xmath126 , then @xmath353 .",
    "indeed , there exists at least one node @xmath4 with identity @xmath354 , which guarantees that @xmath4 generates the graph @xmath3 .",
    "if no other node @xmath302 has width @xmath355 then @xmath4 generates @xmath356 .",
    "if there exists a node @xmath302 with @xmath355 then @xmath302 generates @xmath357 . in each case",
    ", we have @xmath358 , and thus @xmath353 .",
    "it remains to show that the existential certificate used in @xmath0 for all configurations @xmath359 are the same for any given @xmath6 , independently of the identity assignment to @xmath3 used to perform the reduction @xmath195 .",
    "this directly follows from the nature of @xmath0 since the certificates do not depend on the families @xmath327 s but only on the bit strings @xmath338 s .",
    "the following language is defined as @xmath332 by replacing @xmath335 by the closure under lift @xmath360 of  @xmath335 .",
    "that is , @xmath360 is composed of @xmath335 and all the lifts of the configurations in @xmath335 .",
    "@xmath361 we show that @xmath362 is the hardest problem in @xmath21 .",
    "[ prop : missliftiscomplete]_@xmath362 is @xmath21-complete ( and @xmath363 is co-@xmath21-complete ) under label - preserving reduction .",
    "_    we do have @xmath364 because @xmath362 is closed under lift .",
    "let @xmath365 .",
    "the reduction @xmath195 from @xmath11 to @xmath362 is the same as the one in the proof of proposition  [ prop : missispi2-complete ] .",
    "we describe a local algorithm for deciding @xmath362 in @xmath21 which is label - preserving with respect to @xmath195 .",
    "the certificate @xmath26 is a description of @xmath311 of the form @xmath78 as certificate  @xmath74 in the proof of proposition  [ prop : pi2isall ] .",
    "this guarantees label - preservation with respect to @xmath195 . for the verification part ,",
    "each node @xmath4 checks whether @xmath78 fits with its local neighborhood .",
    "if no , it rejects .",
    "otherwise , it checks whether @xmath366 , accepts if yes , and rejects otherwise . on a legal configuration @xmath367 , with the correct certificate @xmath368",
    ", all nodes accept . on an illegal configuration @xmath369 , there are two cases",
    ". if @xmath98 is neither @xmath311 nor a lift of @xmath311 , then some node will detect an inconsistency , and reject .",
    "if @xmath98 is an accurate description of @xmath311 or of a lift of @xmath311 , then some node will detect that @xmath370 , and therefore will reject .",
    "our investigation raises several intriguing questions . in particular , identifying a distributed language in @xmath178 was an uneasy task .",
    "we succeeded to find one such language , but we were unable to identify a @xmath146-complete problem , if any .",
    "in fact , completeness results are very sensitive to the type of local reductions that is used .",
    "we have identified label - preserving local reduction as an appropriate notion .",
    "it would be interesting to know whether @xmath21-complete and @xmath51-complete languages exist for _ identity - oblivious _ reductions .",
    "this latter type of reductions is indeed the most natural one in a context in which nodes may not want to leak information about their identities .",
    "it is easy to see that the class @xmath371 has a complete language for identity - oblivious reductions , namely , @xmath250 is @xmath371-complete for identity - oblivious reductions .",
    "however , we do not know whether this can be achieved for @xmath21 or  @xmath51 .",
    "this paper is aiming at providing a proof of concept for the notion of interactive local verification : @xmath51 can be viewed as the interaction between two players , with conflicting objectives , one is aiming at proving the instance , while the other is aiming at disproving it . as a consequence , for this first attempt",
    ", we voluntarily ignored important parameters such as the size of the certificates , and the individual computation time , and we focussed only on the locality issue .",
    "the impact of limiting the certificate size was recently investigated in  @xcite .",
    "regarding the individual computation time , our completeness results involve local reductions that are very much time consuming at each node . insisting on local reductions involving polynomial - time computation at each node is crucial for practical purpose . at this point",
    ", we do not know whether non trivial hardness results can be established under polynomial - time local reductions .",
    "proving or disproving the existence of such hardness results is let as an open problem .",
    "p. floren , j. kaasinen , p. kaski , j. suomela : an optimal local approximation algorithm for max - min linear programs . in proc .",
    "21st acm symp . on parallelism in algorithms and architectures ( spaa ) ,",
    "pp260 - 269 , 2009 .",
    "p. fraigniaud , m. gs , a. korman , j. suomela : what can be decided locally without identifiers ? in proc .",
    "32nd acm symp . on principles of distributed computing ( podc ) ,",
    "pp157 - 165 , 2013 .",
    "p. fraigniaud , m. halldrsson , a. korman . on the impact of identifiers on local decision . in proc .",
    "conference on principles of distributed systems ( opodis ) .",
    "springer , lncs 7702 , pp224 - 238 , 2012 .",
    "p. fraigniaud , a. korman , d. peleg . towards a complexity theory for local distributed computing .",
    "j. acm 60(5 ) : 35 ( 2013 ) ( preliminary version in focs 2011 ) ."
  ],
  "abstract_text": [
    "<S> in the framework of distributed network computing , it is known that , for every network predicate , each network configuration that satisfies this predicate can be proved using distributed certificates which can be verified locally . </S>",
    "<S> however , this requires to leak information about the identities of the nodes in the certificates , which might not be applicable in a context in which privacy is desirable . </S>",
    "<S> unfortunately , it is known that if one insists on certificates independent of the node identities , then not all network predicates can be proved using distributed certificates that can be verified locally . in this paper </S>",
    "<S> , we prove that , for every network predicate , there is a distributed protocol satisfying the following two properties : ( 1 )  for every network configuration that is legal w.r.t .  </S>",
    "<S> the predicate , and for any attempt by an adversary to prove the illegality of that configuration using distributed certificates , there is a locally verifiable proof that the adversary is wrong , also using distributed certificates ; ( 2 )  for every network configuration that is illegal w.r.t .  </S>",
    "<S> the predicate , there is a proof of that illegality , using distributed certificates , such that no matter the way an adversary assigns its own set of distributed certificates in an attempt to prove the legality of the configuration , the actual illegality of the configuration will be locally detected . in both cases , </S>",
    "<S> the certificates are independent of the identities of the nodes . </S>",
    "<S> these results are achieved by investigating the so - called _ local hierarchy _ of complexity classes in which the certificates do not exploit the node identities . </S>",
    "<S> indeed , we give a characterization of such a hierarchy , which is of its own interest </S>"
  ]
}