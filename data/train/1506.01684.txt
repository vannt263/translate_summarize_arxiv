{
  "article_text": [
    "the microstructure in alloys significantly influences the macroscopic properties . in order to predict and",
    "optimize the resulting macroscopic material parameters , it is important to get a deeper insight into this microscopic structure formation . especially in ternary systems with three chemical species ,",
    "a wide range of patterns can form in the microstructure , depending on the physical and process parameters  @xcite . in this work ,",
    "we show simulation results for the pattern formation in ternary eutectic directional solidification of alloys .",
    "the pattern formation of this ternary eutectic system , during directional solidification , was studied experimentally by genau , dennstedt , and ratke in @xcite .",
    "the thermodynamic data are reported in the calphad database and are derived from @xcite .",
    "this system is of special interest because many essential aspects of solidification processes can be studied due to the low temperature of the ternary eutectic point and similar phase fractions in micrographs . in technical applications ,",
    "this alloy is used for lead free solders in micro - electronics @xcite .",
    "however , an experimental study of three dimensional structure requires significant technical effort , e.g.  with synchrotron tomography .",
    "simulations of the solidification process exhibit another way of studying these structures , providing the whole microstructure evolution .",
    "phase - field models are well established to simulate solidification problems . in 2011 , shimokawabe et al .",
    "@xcite presented the first peta - scale phase - field simulation on the tsubame 2.0 gpu - cluster .",
    "they studied binary dendritic growth , the evolution of multiple nuclei in three dimensions under consideration of temperature , and concentration instabilities .",
    "further investigations of this binary dendritic growth were performed by yamanaka et al .",
    "@xcite and takaki et al .",
    "@xcite at the tsubame 2.0 and tsubame 2.5 gpu supercomputer . in the gordon bell prize 2011",
    "awarded work , @xcite used a phase - field model with two phases and two components based on a simplified free - energy approach , neglecting the temperature dependence in the concentration evolution equation and hence the slope of the solidus- and liquidus lines .",
    "@xcite continued the work of binary dendritic growth in 2d of @xcite by using an improved model .",
    "there , an anti - trapping current was added to obtain better quantitative results , but also leading to a more complex model .",
    "this issue of solving multiple non - linear partial differential equations and hence the increase of required memory and computational time was also mentioned by yamanaka et al .",
    "@xcite .",
    "in our work we focus on simulations of ternary eutectic directional solidfication with a phase - field model based on the grand - potential approach @xcite .",
    "ternary eutectic growth describes the transformation of a melt in three solid phases at a defined ternary eutectic point . to study this ternary solidification with structures approximately",
    "two orders smaller than dendritic growth , four phases and three components have to be considered in the model .",
    "the grand potentials , derived from thermodynamic databases , are coupled to the phase - field to ensure a physical driving force with the slopes of the solidus and liquidus planes @xcite .    in our simulations",
    ", we use an extension to the well established thermodynamic consistent phase - field method , including an anti - trapping current , based on a newly formulated grand potential approach @xcite .",
    "the phase - field and chemical potential formulation consist of a relatively large number of complicated terms and parameters , making the resulting algorithm significantly more compute intensive compared to other stencil codes such as advection - diffusion calculations .",
    "an implementation of the described method was already available in the general purpose phase - field framework pace3d  @xcite , which provides a wide range of phase - field models coupling structural  @xcite , fluid  @xcite , and thermal effects  @xcite .",
    "the available code was , due to its general approach , not optimized to study the considered phenomena in a most efficient way .",
    "simulations of large three dimensional domains are required to capture certain physically relevant effects , which can not be seen in smaller domains due to strong boundary influences @xcite .",
    "therefore , we re - implemented and optimized the specific model in walberla , a massively parallel framework for stencil - based algorithms on block - structured grids  @xcite .",
    "the framework has been shown to efficiently scale up to 1.8 million threads and run lattice boltzmann simulations with up to one trillion cells  @xcite .",
    "beginning at the intra - node level by making use of simd instructions , to multithreading at intra - node level , up to internode parallelism via mpi , several layers of parallelism have to be exploited to efficiently use modern supercomputer architectures .",
    "we apply several optimization techniques at all these levels , resulting in an overall relative speedup of factor 80 compared to the original code and reach approximately 25% of the peak flop rate on the supermuc petascale system located at lrz munich .",
    "we show scaling results on three of the largest supercomputers in germany : on supermuc , juqueen , and hornet .",
    "the results obtained in our simulations show excellent agreement with experimental two dimensional micrographs and three dimensional tomography @xcite .",
    "to simulate the solidification process of ternary eutectic systems , a thermodynamically consistent phase - field model is used .",
    "the presented phase - field model of allen  cahn type consists of two coupled evolution equations , for the vector of order parameters @xmath0 and the vector of chemical potentials @xmath1 .",
    "the equations are solved using finite difference methods and an explicit euler scheme for the time discretization .",
    "the domain @xmath2 is discretized in equidistant regular cells with the spatial position @xmath3 . to indicate the spatial discretization scheme of the evolution equations",
    ", we introduced the `` d@xmath4c@xmath5 '' notation , as a stencil with @xmath4 dimensions and total access on @xmath5 cells . in the domain @xmath2",
    ", the order parameters @xmath6 , @xmath7 $ ] , describe the fractions of the @xmath8 thermodynamic phases in each cell and each time step @xmath9 .",
    "we define @xmath10 on the regular @xmath11 simplex @xmath12 .",
    "the evolution equations of the phase - fields are written as @xmath13 with @xmath14 the reciprocal relaxation parameter @xmath15 couples the phase - field evolution with the physical time scale and @xmath16 is related to the interface width . the gradient energy density @xmath17 and the potential energy density @xmath18 describe the interfacial energy part in .",
    "the driving force @xmath19 describes the thermodynamic process of the phase transition caused by the undercooling and connects the evolution of the order parameter to the chemical potential .",
    "this force is derived by parabolically fitted gibbs energies which are derived from the thermodynamic calphad databases @xcite .",
    "the evolution equations of the @xmath20 chemical potentials @xmath21 are derived from fick s law and the variational derivation of the concentrations @xmath22 . due to the conservation of mass ,",
    "one concentration can be derived from the others .",
    "the number of evolution equations @xmath22 as well as the number of components of @xmath21 can therefore be reduced to @xmath23 .",
    "the @xmath1 evolution is written as @xmath24^{-1 } } _ \\text{d3c1 }           \\bigg (           \\underbrace { - \\left ( \\diffp{{\\ensuremath{{\\boldsymbol{c}}}}}{{\\ensuremath{{\\boldsymbol{\\phi } } } } } \\right)_{t,{\\ensuremath{{\\boldsymbol{\\mu } } } } } \\diffp{{\\ensuremath{{\\boldsymbol{\\phi}}}}}{t } - \\left ( \\diffp{{\\ensuremath{{\\boldsymbol{c}}}}}{t } \\right)_{{\\ensuremath{{\\boldsymbol{\\mu}}}},{\\ensuremath{{\\boldsymbol{\\phi } } } } } \\diffp{t}{t }   } _ \\text{d3c1 }   \\nonumber \\\\            & + \\underbrace { { \\ensuremath{\\nabla\\cdot{\\left({\\boldsymbol{m}}({\\boldsymbol{\\phi}},t){\\ensuremath{\\nabla{{\\ensuremath{{\\boldsymbol{\\mu } } } } } } } \\right ) } } } } _ \\text{d3c7 }   - \\underbrace { { \\ensuremath{\\nabla\\cdot { \\left({\\ensuremath{{\\boldsymbol{j}}_\\textup{at}}}({\\ensuremath{{\\boldsymbol{\\phi}}}},{\\ensuremath{{\\boldsymbol{\\mu}}}},t ) \\right ) } } }   } _ \\text{d3c19 }         \\bigg ) \\label{func : mu}\\end{aligned}\\ ] ] the jacobian matrix @xmath25 describes the susceptibility and is derived from parabolic free energies .",
    "the two flux terms are a gradient flux of the chemical potential depending on the mobility @xmath26 and a flux , called _ anti - trapping current _",
    "it is derived as @xmath27 with the interpolation function @xmath28 @xcite .    for the directional solidification",
    ", we use a frozen temperature assumption by imprinting an analytical temperature gradient with a defined velocity .    for the description of the numerical optimizations ,",
    "we distinguish different regions in the simulation domain .",
    "the region @xmath29 , where only one phase @xmath30 exists , is called _",
    "bulk region_. in this region , the time derivative of the order parameter and the anti - trapping current are zero .    the diffuse interface @xmath31 is located between bulk regions .",
    "the interfacial energy part and the driving force in are exclusively calculated in @xmath32 .",
    "the solidification front is defined as @xmath33 .",
    "the liquid region is defined as @xmath34 and the solid one as @xmath35 . for a more detailed description of the model",
    "we refer to @xcite .",
    "the algorithm to calculate the phase - field model is decomposed into two kernels : one for updating values of the phase - field itself and one to update the chemical potential .",
    "two lattices are allocated for each variable : two destination fields denoted by @xmath36 and @xmath37 and two source fields , denoted by @xmath38 and @xmath39 . in the destination fields values for the next time step @xmath40 are stored , while source fields hold values for the current time step .",
    "each kernel performs a loop over the local simulation domain and updates all cell values of the @xmath41 or @xmath42 field . after each kernel run",
    ", the ghost layers are synchronized with neighboring blocks and boundaries are updated using dirichlet , neumann and periodic boundary conditions as shown in figure  [ fig : sim - setting ] .",
    "the details of this update scheme are depicted in algorithm  [ alg : phasefield ] .",
    "@xmath43 ( see )    @xmath36 ghostlayer communication @xmath36 boundary handling    @xmath44 ( see )    @xmath37 ghostlayer communication @xmath37 boundary handling swap @xmath45 and @xmath46    the @xmath41-kernel needs the previous phase @xmath38 and chemical potential @xmath39 values as input .",
    "direct neighborhood values are required to compute gradients of the phase - field , leading to a d3c7 stencil for the @xmath41-field while only local values are required for @xmath42 ( d3c1 ) .",
    "for updating the chemical potential , previous chemical potential values @xmath39 as well as the phase - field values of two time steps ( @xmath38 and @xmath36 ) are necessary . the two phase - field timesteps and the d3c19 stencil , including diagonal neighbors ,",
    "are required to calculate .",
    "figure  [ fig : data_dependencies_no_overlap ] shows these data dependencies in detail for the two kernels .    as initial setup we use solid nuclei at the bottom of a liquid filled domain as shown in figure  [ fig : sim - setting ] .",
    "these solid nuclei are created by a voronoi tesselation with respect to the given volume fractions of the phases .",
    "the simulation parameters of @xcite are used for our studies in the presented model , describing the system .     with the velocity @xmath47 and its direction",
    "is shown . ]",
    "in the following section , we present our implementation of the phase - field model and apply optimizations necessary to efficiently run on current supercomputing systems .",
    "the phase - field method described above was implemented in the walberla framework ( widely applicable lattice boltzmann from erlangen ) .",
    "as the name suggests , the framework was initially developed for simulations using the lattice boltzmann method . over time , it evolved into a multi - physics framework for efficient implementations of stencil - based algorithms on block structured grids in a massively parallel way .",
    "walberla partitions the simulation domain into equally sized chunks , called blocks . on each block ,",
    "a regular grid is allocated , extended by one or more ghost layers for communication in mpi parallel simulations .",
    "this concept provides the flexibility for supporting complex geometries @xcite and optional mesh refinement .",
    "the regular structure inside the blocks allows for highly efficient compute kernels .",
    "the data structure storing the blocks is fully distributed : every process holds information only about local and adjacent blocks .",
    "thus , the memory usage of a process does not depend on the total size of the simulation but only on the size of local and neighboring blocks . only during the startup phase which is responsible for block setup and load balancing ,",
    "one process has to store global domain information .",
    "this initialization can be executed independently of the actual simulation .",
    "the resulting block structure is then stored in a file to be loaded by the simulation at runtime .",
    "the framework is entirely written in c++ with small portions of the code being automatically generated .",
    "for performance critical code sections , we make use of template meta programming techniques to achieve good performance without losing flexibility and usability .",
    "a big challenge in massively parallel programs is dealing with the huge amount of output data .",
    "in many big simulations , i / o operations can become a significant bottleneck .",
    "therefore , we try to minimize the amount of data that is read and written to the file system .",
    "since the initial domain setup is generated using a voronoi approach , we do not have to load big , voxel - based input files describing the domain .",
    "i / o is only necessary for checkpointing and for result output . for generating checkpoints",
    ", the complete simulation state has to be stored on disk , containing four @xmath41 values and two @xmath42 values per cell .",
    "while all computations are carried out in double precision , checkpoints use only single precision to save disk space and i / o bandwidth . writing a checkpoint can take a significant amount of time compared to a simulation time step , therefore checkpoints are written infrequently .",
    "simulation results have to be written more often , thus a faster technique is required for this task . instead of writing all values of a cell , we only store the position of the interfaces using a triangle surface mesh .",
    "therefore , a custom marching cubes algorithm based on @xcite was developed that generates meshes locally on each block , using the @xmath41 values as input . for each phase , a mesh is generated , describing the interface between this phase and all other phases .",
    "the marching cubes algorithm extends to the ghost regions such that the local meshes can be stitched together to a single mesh describing the complete domain .",
    "these local meshes could be written to disk , leaving the stitching for postprocessing . since the marching cubes algorithm creates triangles with edge lengths in the order of @xmath48 , these meshes are still unnecessarily fine and could be adaptively coarsened without losing much accuracy .",
    "this coarsening step can optionally be performed before writing the mesh to keep output file sizes small . for mesh coarsening",
    ", we use the quadric - error edge - collapse - based simplification algorithm @xcite from the _ visualization and computer graphics library _ ( vcg ) @xcite .",
    "the coarsening is done in a hierarchical way : in a first step , each process calls the edge - collapse algorithm on its local mesh . by assigning a high weight to all vertices that are located on block boundaries ,",
    "the boundaries are preserved such that the later stitching step can work correctly .",
    "then , two local meshes are gathered on a process , stitched together , and again coarsened in the stitched region .",
    "this step is repeated @xmath49 times where in each step only half of the processes take part in the reduction .",
    "this procedure is stopped if the mesh is either fully reduced or has reached a size that can not be stored in the memory of a single node . in the latter case , postprocessing can be resumed on a machine with more memory than a compute node .      starting with a very general phase - field model ,",
    "the goal of this work was to develop a highly optimized code for the specific model , presented in @xcite , which efficiently can simulate sufficiently large 3d domains .",
    "optimizations are done on different levels by exploiting physical , mathematical , and computational facts to decrease the computation time .    for directional solidification",
    ", we can reduce the effective domain size in the solidification direction ( @xmath50 ) @xcite by using a moving window technique @xcite as shown in figure  [ fig : sim - setting ] .",
    "the evolution in the solid is multiple magnitudes lower than in the liquid such that we neglect the evolution in the solid . in order to produce physically correct microstructures ,",
    "the base size of the domain @xmath51 requires a minimal size to reduce the influence of the periodic boundaries .",
    "the evolution of the temperature can be described by a frozen temperature ansatz in solidification direction , by exploiting the time scales of the different evolution equations @xcite . at a given time @xmath52",
    ", we assume the temperature being constant in slices orthogonal to the solidification direction .",
    "the grand potentials for the driving force are only needed in the range of the ternary eutectic point , therefore we use fitted parabolic gibbs energies to derive the potentials instead of describing the total ternary system .",
    "this simplifies the calculations involving the concentrations @xmath53 and the chemical potentials @xmath1  @xcite .",
    "the model equations can be simplified for certain parts of the domain for the two evolution equations .",
    "the computation of the anti - trapping current in the @xmath42-evolution is only required in the interface region @xmath54 of the solidification front . since evaluating this",
    "current is computationally expensive , we detect as early as possible if the complete term has to be evaluated by testing critical subexpressions for zeros .",
    "when computing @xmath55 , we first check if @xmath56 is zero since then @xmath57 and thus @xmath55 are zero . by introducing one additional check , we can omit the calculation of the expensive @xmath55 in all cells which do not contain liquid .",
    "a similar check can be added for @xmath58 : for cells with zero liquid phase gradient , the computation of the anti - trapping current can be skipped as well .",
    "the interface region @xmath32 is bounded due to a sinus - shaped interface profile in which @xmath59 . following the calculation of the @xmath41 evolution",
    "is only required in this small interface region . adding these kind of checks introduces possibly expensive ` if ` conditions in the kernel , so there may be a trade - off between the saved computations and the peak performance . as shown in section [ sec : results ] , the introduced checks reduce the total runtime considerably .",
    "we conducted further optimizations on the source code and hardware level using processor extensions available on the target machines . on these levels",
    ", we used a systematic , performance model driven approach to identify and eliminate relevant bottlenecks . as we show in section [ sec : results ] , our code is bound by in - core execution , therefore the goal is to reduce the total number of floating point operations , potentially at the cost of increased memory traffic .",
    "the fact that in our specific scenario the temperature is a function of the @xmath60 coordinate led us to choose the @xmath60 iteration as the outermost loop in computation kernels , followed by loops over @xmath61 and @xmath62 .",
    "since many values , which are required to calculate the driving force @xmath63 of or the anti - trapping current @xmath55 of , depend on analytic temperatures only , these values can be pre - calculated once for each @xmath60-slice instead of computing them again in every cell .",
    "following the strategy of saving floating point operations at the cost of memory transfers , we identify expressions in the model equations that are evaluated multiple times and can therefore be buffered . in our discretization scheme",
    "we also evaluate quantities at staggered grid positions . to avoid evaluation in each cell ,",
    "they are written to a buffer after computation and are reused .",
    "since the outermost loop in the computation kernels iterates over the @xmath60 coordinate , a buffer of the size @xmath64 is needed .",
    "the computationally most intensive part of equation ( [ func : mu ] ) is the calculation of the divergence of @xmath65 , even if the evaluation of the anti - trapping current can be skipped for many cells . in order to update one cell ,",
    "the six values of @xmath66 at neighboring staggered positions are required . however , three of them can be buffered and reused since they have already been calculated during the update of previous cells ( figure  [ fig : staggeredbuffer ] ) . only in cells located at block boundaries ,",
    "all six values have to be computed explicitly . using this buffering approach",
    ", we effectively halve the required floating point operations at the cost of additional memory accesses for reading and writing the buffered values .",
    "the same technique of buffering staggered values is also applied for evaluating the divergence of @xmath67 in the phase - field update step .",
    "while adhering to the established data parallel approach on inter - process level , the walberla framework offers task parallel programming models on intra - process level to support overlapping communication with computation .",
    "the computation kernels as well as the ghost layer exchange routines are implemented as c++ functors , which are registered at a `` timeloop '' class to manage the communication hiding .",
    "the communication of the chemical potential field can be hidden in a straightforward way since the following update of the phase - field only depends on local @xmath42 values ( figure  [ fig : data_dependencies_no_overlap ] ) .",
    "this allows us to communicate the @xmath42 boundaries while updating the @xmath41-field . in our implementation",
    "the order of communication and boundary handling routines can also be interchanged without altering the results .",
    "since updating @xmath42 accesses neighborhood values of @xmath41 for the current and new time step , the communication of the phase - field values can not simply be overlapped with @xmath42 computation . in order to hide the phase - field communication as well ,",
    "the @xmath42 update step has to be split up into two kernels .",
    "the obvious method would be to update inner values first and after communication has finished , update the values at the border .",
    "implementing this solution would require a staggered value buffer of the same size as the complete field or recomputation of staggered values .",
    "thus , we split up the @xmath42 update into a local and a non - local @xmath41 dependency as indicated in .",
    "this splitting simplifies the data dependencies ( figure  [ fig : data_dependencies_overlap ] ) and does not affect the buffering of staggered values , but still has some overhead , since now the temperature dependent values have to be computed twice for each @xmath60-slice .",
    "therefore , we calculate the @xmath42 evolution without the anti - trapping current first . after transfer of the ghost layers , the anti - trapping current is calculated and added to the @xmath42 evolution .",
    "algorithm [ alg : phasefield_overlap ] shows the resulting time step of the phase - field method using fully overlapping communication .",
    "[ alg : phasefield_overlap ]    @xmath68    @xmath36 boundary handling    @xmath69    @xmath70    @xmath37 boundary handling swap @xmath45 and @xmath46        in order to fully utilize modern hardware architectures , especially when running compute intensive codes , it is important to make full use of their simd ( single instruction , multiple data ) capabilities .",
    "while most compilers can do automatic loop vectorization , it is still necessary to provide additional information to the compiler regarding aliasing , data alignment , and typical loop sizes using non portable pragma directives .",
    "an analysis with the performance measurement tool _ likwid _ @xcite , which can measure the amount of vectorized and non - vectorized floating point operations , showed that large portions of our code were not automatically vectorized . while the pragma approach proves useful for small concise loop kernels , we could not improve the more complex compute kernels for @xmath41 and @xmath42 of several hundred lines of code using this approach .",
    "instead , we explicitly vectorize these two main compute kernels with intrinsic compiler functions .",
    "using intrinsics requires a manual reformulation of the algorithm in terms of vector data types .",
    "since these intrinsic functions directly map to assembler instructions , they are not portable across different architectures . in order to keep the code portable ,",
    "a lightweight abstraction layer was developed that provides a common api supporting the intel processor extensions sse2 , sse4 , avx , avx2 and the qpx extension on blue gene / q cores .",
    "not all functions of this api directly map to a single intrinsic function and therefore to a single assembler instruction for each instruction set .",
    "for example , avx2 provides instructions for permuting elements of vector data types , which require two or more instructions in the sse extension .",
    "our api hides these differences , providing functions for all avx2 and qpx intrinsics which are emulated on older extensions in the most efficient way .",
    "manual inspection of the assembler code shows that calls to this thin simd api are inlined by the compiler and therefore no additional overhead is introduced .",
    "in this section we shortly describe the three tier-0/1 cluster systems at the high performance computing center stuttgart ( hlrs ) , the leibniz supercomputing center ( lrz ) , and the jlich supercomputing centre ( jsc ) . all systems support vectorization , either using avx(2 ) on the intel based chips or qpx on bluegene / q cores .",
    "the supermuc system located at leibnitz supercomputing center in munich is built out of 18,432 intel xeon processors running at 2.7ghz resulting in a total number of 147,456 cores @xcite .",
    "one compute node of supermuc consists of 2 sockets , each equipped with 8 cores .",
    "512 nodes are divided into one island . within each island",
    ", supermuc uses a non - blocking tree network topology , whereas all 18 islands are connected via a pruned tree ( 4:1 ) @xcite .",
    "on supermuc we used the intel compiler in version 14.0.3 together with ibm mpi .",
    "we compiled our code on optimization level 3 together with optimization flags enabling interprocedural optimization at link time and fast floating point operations .",
    "the cray xc40 system at the hlrs consists of 3944 nodes with two sockets , each containing a intel haswell e5 - 2680v3 with 12 cores .",
    "the systems contains 94,656 cores in total which are interconnected by a dragonfly network@xcite called cray aries .",
    "the haswell core clock rate is @xmath71 ghz and it supports hyper - threading as well as the newer avx2 instruction set . on hornet",
    "we have chosen the same compiler and compiler options as on supermuc with additional flags to make use of the avx2 extension .",
    "juqueen is , as of april 2015 , the fastest supercomputing system in germany and is positioned on rank 8 on the top500 list@xcite .",
    "it is a 28 rack blue  gene / q system providing 458,752 powerpc a2 processor cores , with each core capable of multithreading @xcite .",
    "juqueen uses a 5-dimensional torus network topology capable of achieving up to 40gb / s , with latencies in the range of a few hundred nanoseconds .",
    "we compiled our code with the ibm xl compiler in version 12.1 with the compiler optimization level set to 5 .",
    "in this section , we present single core performance results as well as scaling experiments run on these three supercomputing systems .",
    "the presented performance results are measured in mlup / s , which stands for `` million lattice cell updates per second '' . at the end of this section ,",
    "we show simulation results of the system and compare them to experimental data .",
    "since the performance of the compute kernels depends on the composition of the simulation domain as shown in section [ sec : optimizations ] , we executed our benchmarks separately for three representative parts of the domain .",
    "these different scenarios are labeled _ interface _ , _ solid _ , and _ liquid _ and correspond to the regions @xmath54 , @xmath72 , and @xmath73 defined in sec .",
    "[ model ] .",
    "the _ solid _ scenario consists purely of already solidified material , as is the case in a realistic simulation in the lower third of the domain .",
    "the _ interface _",
    "scenario simulates only the solidification front , i.e.  the middle third of the simulation domain .",
    "the upper part of the domain consists only of liquid phase and is represented by the _ liquid _",
    "scenario .",
    "the starting point of our hpc implementation was a general phase - field code written in c. one main design goal of this application code is flexibility to allow rapid prototyping and testing of new models .",
    "a wide range of models is already implemented in this code : various phase - field models , a structural mechanics as well as a fluid mechanics solver , which can all be coupled with each other . as already mentioned above , for the specific model described here ,",
    "simulations of large three dimensional domains are necessary to obtain physically meaningful results .",
    "this motivates the design and implementation of a new code that is highly optimized and parallelized to exploit the largest hpc systems available .",
    "a straightforward re - implementation of the grand chemical potential based phase - field model in the walberla framework already yields significant performance improvements ( figure  [ fig : sweep - optimizations ] ) .",
    "since this new implementation is targeted at one specific model , certain basic optimizations can already be applied easily to the compute kernels : while the original implementation makes heavy use of indirect function calls via function pointers at cell level , we either remove these indirections in the walberla version entirely due to the specialization of the code to one specific model , or replace them with static polymorphism using c++ templates . additionally , we replaced divisions where the denominator is guaranteed to be in a small set of values by table lookup and multiplication with the inverse .",
    "the number of division operations is further reduced by replacing inverse square root calculations , required for vector normalizations , with approximated values provided by a fast inverse square root algorithm  @xcite .    in a second step",
    "we implement more advanced , aggressive optimizations .",
    "these include explicit simd vectorization in both computation kernels .",
    "since the targeted architectures all have a vector width of four double precision values , the straightforward way for vectorizing the algorithm is to unroll the innermost loop , updating four cells in one iteration .",
    "while this technique is the only possible one for the @xmath42-kernel , a more natural approach exists for the @xmath41-kernel of our specific model : instead of handling four cells simultaneously , we can use a simd vector to represent the four phases of a cell . with this technique ,",
    "the field is still updated cellwise , such that branching on a cell - by - cell basis becomes possible .",
    "this branching can significantly speed up the kernels , since some expensive terms have to computed only for certain cell configurations .",
    "vectorized kernels that handle four cells simultaneously can only take these shortcuts if the condition is true for all four cells .",
    "since the single cell kernel version operates on less data per iteration compared to the four cell version , more intermediate values can be kept in vector registers , which would have to be spilled to memory otherwise .",
    "a drawback of the _ cellwise _ version is the need for various permute or rotate operations when computing terms that contain single components of the @xmath41 vector .",
    "this happens for example when expressions like @xmath74 have to be evaluated .",
    "figure  [ fig : simd_comparison ] shows the performance of three vectorized @xmath41-kernel implementations : the first two implementations both use the cellwise vectorization approach .",
    "while the first version evaluates all terms for each cell , the second version contains tests that determine which terms have to be evaluated ( _ cellwise with shortcuts _ ) .",
    "the third version uses _ four - cell - vectorization _ and can only skip terms that are not required for all of the four cells .",
    "in all three parts of the domain , the single cell kernel with shortcuts performes best .",
    "the additional costs of the vector permute operations are alleviated by the ability to branch on a per cell basis and the reduced number of required simd registers .",
    "for all further benchmarks , we use this fastest cellwise kernel with shortcuts to update the phase field .",
    "since we apply two different vectorization strategies to the two compute kernels , the optimal data layout of the @xmath41-field for the two kernels is different : the @xmath42-kernel processes the data four cells at a time , so a structure - of - arrays ( soa ) layout would be the best choice , while the fastest @xmath41-kernel requires an array - of - structures ( aos ) layout to be able to load a simd vector directly from contiguous memory .",
    "we choose a soa layout since the @xmath42-kernel has to load phase field values of 38 cells ( 19 cells from @xmath75 and 19 from @xmath76 ) whereas the @xmath41-kernel only has to load 7 cells . due to the high computational intensity of the @xmath41-kernel",
    ", no notable differences could be measured in the @xmath41-kernel performance after a data layout change of the @xmath41-field .",
    "figure  [ fig : sweep - optimizations ] shows the increase in performance of the new simd kernels compared to the basic implementation . by applying vectorization only , a maximal speedup of factor 4 can be expected .",
    "the high speedup of factor 5 to 7 is due to the fact that in addition to vectorization also additional optimizations like common subexpression precomputation were done at this stage .",
    "this comes at the cost of decreased flexibility : while in the basic implementation the code was structured according to the mathematical formulation of the model , the single terms of the model can hardly be recognized in the manually vectorized simd kernels . to decrease the maintenance effort for the various kernels , a regularly running test suite checks all kernel versions for equivalence .",
    "figure  [ fig : sweep - optimizations ] additionally shows the performance improvement due to optimizations we can make when the temperature is prescribed as a function of time and one space component @xmath60 only . in this case , we precompute all temperature dependent terms once for each x - y - slice instead of computing them in each cell . using this",
    "optimization increases the performance of the @xmath42-kernel by approximately 20% and the performance of the @xmath41-kernel by 80% .    .",
    "]    while this technique improved predominantly the runtime of the @xmath41-kernel , the staggered buffer optimization is targeted at the @xmath42-kernel and the costly computation of the term @xmath77 which is evaluated at staggered positions in the grid .",
    "buffering and reusing half of these values increases the @xmath42-kernel performance by almost a factor of two , which shows that the runtime of this kernel is dominated by the calculation of these staggered values . in the @xmath41-kernel , the same technique is applied for buffering gradient values at staggered positions . in this case , the buffered values are not as expensive to compute as the buffered quantities in the @xmath42-kernel , therefore this optimization leads only to slightly better performance for this kernel .    up to now , all performance improvements affected all cells of the domain . while the kernel runtime for updating @xmath42 is , up to measurement error , equal in the complete domain , the @xmath41-kernel runtimes vary slightly due to branches in a routine that projects the @xmath41 values back into the allowed simplex .",
    "the following optimization introduces additional branches by skipping the evaluation of terms depending on the configuration of the current cell .",
    "this implementation is labeled as version `` with shortcuts '' in figure  [ fig : sweep - optimizations ] and was already included in the comparison of different vectorization strategies , shown above .",
    "these branches lead to different runtimes of the kernels in different parts of the domain .",
    "the performance of the @xmath41-kernel is increased predominantly in liquid parts of the domain since there the computation of the coupling term @xmath63 can be skipped entirely .",
    "the runtime of the @xmath42-kernel is improved especially in solid cells due to a simpler calculation of the anti - trapping current in these cells .",
    "all optimizations combined result in a total speedup of up to 80 depending on the architecture .",
    "this huge speedup compared to the original c implementation enables us to simulate sufficiently large domains in reasonable time to get physically meaningful results .",
    "since the relative speedup does not indicate to what extent the target architecture is utilized , we additionally investigated the absolute performance of our code . in the following , we focus on the singlenode performance of our optimized code , without the `` shortcut '' optimizations , since in this case the total number of executed floating point operations per cell can be determined exactly .",
    "we show the performance analysis for the @xmath42-kernel on a supermuc node in detail , and shortly present the results for the @xmath41-kernel afterwards .",
    "first , we use a roofline performance model to determine if the code is memory or compute bound @xcite .",
    "we measure the maximum attainable bandwidth using stream @xcite on one node , resulting in a bandwidth of approximately 80 gib / s .",
    "we assume that approximately half of the required data for one update can be held in cache , since in a symmetric d3c7 or d3c19 stencil half of the data can be reused if one x - y - slice of both fields completely fits into cache . for a typical block size of @xmath78 , one x - y - slice of all four fields fits into l2 cache . under this assumption ,",
    "half of the required values are held in l2 cache and at most 680 bytes have to be loaded from main memory to update one cell .",
    "for one cell update , 1384 floating point operations are required , resulting in a lower bound for the arithmetic intensity of approximately two floating point operations per byte . taking only the memory bottleneck into account",
    "our code could achieve up to 126.3 mlup / s on one supermuc node :    @xmath79    the benchmark results presented in figure  [ fig : mu_intranode_scaling ] show that our code does not hit the bandwidth limit of @xmath80 mlup / s and therefore is not memory bound . choosing a smaller blocksize of @xmath81 , which fits entirely into l3 cache , only changes the performance slightly .",
    "this is a further indication that the code is limited by in - core execution instead of memory bandwidth . to determine an upper bound for in - core execution we compare the attained flop / s rate with the maximal possible rate .",
    "one supermuc core runs with a frequency of 2.7 ghz @xcite and can perform 8 floating point operations per cycle , resulting in 21.6 gflop / s per core .",
    "the achieved 4.2 mlup / s per core correspond to 5.8 gflop / s and therefore to 27% peak performance of one core .",
    "the in - core execution time is therefore not limited by the total number of floating point operations . to understand why we can not utilize the full computational capability of one core",
    ", we employ the intel architecture code analyzer ( iaca ) @xcite .",
    "this tool inspects the assembly code of the kernel and statically predicts the estimated execution time on a given intel architecture under the assumption that all data resides in l1d cache .",
    "the iaca analysis shows that even though the code is fully vectorized , it can attain at most 43% peak under ideal front - end , out - of - order engine , and memory hierarchy conditions .",
    "this is caused predominantly by imbalance in the number of additions and multiplication as well as latencies for division operations .",
    "the iaca report shows , that further , highly architecture dependent optimizations are possible , for example manually reordering addition and multiplication instructions .",
    "these kind of optimizations would however require significant development effort due to the high complexity of the kernel of several thousand lines of code .",
    "a similar analysis for the @xmath41-kernel shows that this kernel is also compute bound and attains approximately 21% peak performance on one supermuc core .",
    "-kernel without _ shortcut _ optimization on one supermuc node ]      before conducting scaling experiments we evaluate the effect of the presented communication hiding schemes .",
    "all four possible combinations of hiding the communication of the @xmath41- and @xmath42-field were tested .",
    "figure  [ fig : comm_overlap ] shows the time spent in both communication routines . the amount of exchanged data is higher in the @xmath41-communication , thus the overall communciation times are higher in this case .",
    "as expected , the effective communication times decrease for both fields when communication hiding is enabled .",
    "the remaining time in the communication routines is spent for packing and unpacking messages which can not be overlapped .",
    "overlapping @xmath41-communication introduces additional overhead since the @xmath42-kernel has to be split up into two parts . as a consequence ,",
    "the temperature dependent value computation , which is done once for each x - y - slice in the no - overlap case , has to be done twice when @xmath41 communication overlap is enabled .",
    "this overhead is much bigger than the benefit of communication hiding , thus the version with only @xmath42 communication hiding yields the best overall performance .    ]    in order to test the scalability of our implementation we execute weak scaling experiments on three of the largest german supercomputers .",
    "weak scaling scenarios , where the domain size and the process count are increased by the same factor , are of practical relevance for this code , since the goal is to maximize the domain size while keeping the time to solution constant . on supermuc , we scale three different scenarios up to 32,768 cores which were availabe to us .",
    "the full machine could not be utilized at the time of writing due to installation of a hardware upgrade .",
    "figure  [ fig : scaling ] shows that because of the `` shortcut '' optimization , we obtain slightly different runtimes for the three scenarios , the `` interface '' scenario being the slowest due to higher workload in interface cells . in production runs , where all of the three block compositions occur in the domain ,",
    "the runtime is dominated by the interface blocks .",
    "we experimented with various load balancing techniques offered by the walberla framework , which did , however , not decrease the total runtime significantly , because the moving window technique makes it possible to simulate only the interface region , such that , in production runs , most blocks have a composition similar to the `` interface '' benchmark . for the scaling experiments on hornet and juqueen , we only used the `` interface '' scenario , which is representative for the performance achieved in production runs .    on supermuc and hornet",
    "we placed one mpi process on each physical core .",
    "simultaneous multithreading ( smt ) did not improve the overall performance on these machines . on juqueen however",
    ", 4-way smt was employed to make full use of the in - order processing units . on this blue gene / q machine",
    "we scaled up to 262,144 cores using 1,048,576 mpi processes .              due to the highly optimized code , we are able to study the evolution of microstructures in representative volume elements ( rve ) , which are required for a better understanding of the various pattern formations .",
    "the performed simulations allow us to study the evolution of microstructures , especially in three dimensions .",
    "common experimental analyzing methods , like micrographs , only provide two dimensional information .",
    "these micrographs can be used for a visual validation , but do not provide information on the three dimensional structure . in comparison to experimental micrographs , we can show a good visual accordance with cross sections of our three dimensional simulations .",
    "a simulation with @xmath82 cells , simulated on the hornet supercomputer , is depicted in figure  [ fig : superlarge ] . in the experiment as well as the simulation ,",
    "the phases arrange in similar patterns as chained brick - like structures that are connected or form ring - like structures , as shown in figure  [ fig : simexp ] .",
    "obtaining three dimensional information from experiments requires a large technical effort , using synchrotron tomography to resolve the different phases .",
    "a three dimensional reconstructed tomography result of directional solidification of the system from a.  dennstedt is depicted in figure  [ fig : tomography ] . even with these methods ,",
    "only the final sample can be reconstructed , whereas the time evolution can not be observed .    using large - scale simulations , we found multiple microstructure characteristics , which could not be observed up to now due to small domain sizes .",
    "three dimensional simulations are crucial to capture all relevant physical phenomena : in two dimensional cross sections parallel to the growth front , the phases simple arrange in different lamellae as brick - like structures while in three dimensions , various splits and merges of these lamellae can be observed .",
    "single lamellae of the simulation in figure  [ fig : simexp ] are exempted in figure  [ fig : lamellae ] . in figure",
    "[ fig : al2cu - lamellae ] , two connected lamellae of the phase @xmath83 and in figure  [ fig : ag_2al - lamellae ] two lamellae of the phase @xmath84 are shown .",
    "the evolution of the microstructure , especially the splitting of lamellae and merging , is visible , and allows us to study the stability of different phase arrangements .",
    "these phase arrangements influence the shape of the occurring phases and are of special importance to technical applications since the microstructure strongly influences the mechanical properties , e.g. the elastic and plastic deformation behavior .",
    "besides the good visual accordance of the large - scale simulations and two dimensional micrographs , also good agreement with the experimental 3d data is achieved .",
    "a more detailed comparison is shown in @xcite and a quantitative comparison using principal component analysis on two - point correlation is in preparation . in this publication , also",
    "the quantitative necessity of these large domain sizes will be presented .",
    "in addition to the good visual agreement with the experiments , the simulations allow us to conduct parameter variations under well - defined conditions , which provide excellent ways to study the underlying physical mechanisms of the resulting microstructure formation .",
    "in this work , we have developed and evaluated a massively parallel simulation code for a thermodynamic consistent phase - field model , based on the grand potential approach , which runs efficiently on current supercomputing architectures . with this code",
    ", we simulated the directional solidification of ternary eutectics , including four phases and three chemical species .",
    "since big domain sizes are required to observe the formation of mircostructural patterns , a hpc implementation is crucial to get physical results for the considered scenario . starting from a general purpose and validated phase - field code of this complicated multiphase model for the solidification of alloys , we developed a new , highly optimized implementation that can effectively utilize modern supercomputing architectures .",
    "we applied optimizations on various levels to the highly complex stencil code , ranging from scenario dependent model simplifications to architecture specific optimizations like explicit simd vectorization .",
    "systematic node level performance engineering resulted in a factor 80 speedup compared to the original code , as well as 25% of peak performance on node level .",
    "additionally , communication hiding techniques were applied to optimize the performance on system level , too .",
    "we have shown excellent scaling results of our code on three of the largest german supercomputers : supermuc , hornet , and juqueen . only with this optimized implementation",
    ", it was possible to achieve the domain sizes necessary to gain microstructure patterns that are in good visual accordance with experimental data .    for future work",
    ", we plan to switch from the explicit euler time stepping scheme to an implicit solver . with the presented , optimized model ,",
    "further parameter studies will be conducted .",
    "furthermore , support for a wider range of architectures ( xeon phi , gpu ) is in preparation .",
    "we are grateful to the high performance computing center stuttgart , the leibniz rechenzentrum in garching , and the jlich supercomputing center for providing computational resources .",
    "we also thank dr .",
    "anne dennstedt from german aerospace center ( dlr ) in cologne for providing the three dimensional synchrotron tomography reconstruction and the many fruitful discussions .",
    "m.  garland and p.  s. heckbert .",
    "surface simplification using quadric error metrics . in _ proceedings of the 24th annual conference on computer graphics and interactive techniques _ , pages 209216 .",
    "acm press / addison - wesley publishing co. , 1997 .        c.  godenschwager , f.  schornbaum , m.  bauer , h.  kstler , and u.  rde .",
    "a framework for hybrid parallel flow simulations with a trillion cells in complex geometries . in _ proceedings of the international conference on high performance computing , networking , storage and analysis _",
    ", page  35 .",
    "acm , 2013 .",
    "t.  shimokawabe , t.  aoki , t.  takaki , a.  yamanaka , a.  nukada , t.  endo , n.  maruyama , and s.  matsuoka .",
    "peta - scale phase - field simulation for dendritic solidification on the tsubame 2.0 supercomputer . in",
    "_ high performance computing , networking , storage and analysis ( sc ) , 2011 international conference for _ , pages 111 .",
    "ieee , 2011 .",
    "t.  takaki , m.  ohno , t.  shimokawabe , and t.  aoki .",
    "two - dimensional phase - field simulations of dendrite competitive growth during the directional solidification of a binary alloy bicrystal . , 81(0):272  283 , 2014 .",
    "j.  treibig , g.  hager , and g.  wellein . : a lightweight performance - oriented tool suite for x86 multicore environments . in _ proceedings of psti2010 , the first international workshop on parallel software tools and tool infrastructures _ , san diego ca , 2010 ."
  ],
  "abstract_text": [
    "<S> microstructures forming during ternary eutectic directional solidification processes have significant influence on the macroscopic mechanical properties of metal alloys . for a realistic simulation </S>",
    "<S> , we use the well established thermodynamically consistent phase - field method and improve it with a new grand potential formulation to couple the concentration evolution . </S>",
    "<S> this extension is very compute intensive due to a temperature dependent diffusive concentration . </S>",
    "<S> we significantly extend previous simulations that have used simpler phase - field models or were performed on smaller domain sizes . </S>",
    "<S> the new method has been implemented within the massively parallel hpc framework walberla that is designed to exploit current supercomputers efficiently . </S>",
    "<S> we apply various optimization techniques , including buffering techniques , explicit simd kernel vectorization , and communication hiding . </S>",
    "<S> simulations utilizing up to 262,144 cores have been run on three different supercomputing architectures and weak scalability results are shown . </S>",
    "<S> additionally , a hierarchical , mesh - based data reduction strategy is developed to keep the i / o problem manageable at scale . </S>"
  ]
}