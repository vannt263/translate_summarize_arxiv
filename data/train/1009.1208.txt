{
  "article_text": [
    "the study of boolean functions is an active research topic since more than one hundred years . since the early papers of shannon @xcite and lupanov @xcite in the 1940s and 1950s , boolean circuits ( then called _ switching circuits _ ) have been used as a computation model for boolean functions .",
    "the computational complexity theory of boolean circuits developed rapidly , see savage s textbook @xcite . in the meantime",
    "many beautiful results have been proven , e.g. , in the area of lower bounds or of algebraic and logical characterizations of small circuit classes , cf .",
    "@xcite .",
    "another development of equal importance is the search for different representations ( sometimes also called _ data structures _ , see , e.g. , the books @xcite ) for boolean functions that may facilitate solving presumably hard problems .",
    "let us explain this with an example .",
    "the well - known satisfiability problem for propositional logic is known to be np - complete .",
    "this immediately implies that the problem , given a boolean circuit @xmath0 , to decide if there is an input for which @xmath0 outputs @xmath1 is np - complete as well .",
    "thus , using boolean circuits as a representation for a boolean function @xmath2 , to determine if @xmath3 is not empty appears to be a computationally hard problem .",
    "however , if we represent @xmath2 by a decision tree , satisfiability can be solved in polynomial time ( in the size of the decision tree ) .",
    "the same holds for ordered binary decision diagrams and different further types of so called _ branching programs _ , see @xcite .",
    "this advantage of course has its price : generally , boolean circuits are a much more succinct way of representing boolean functions . nevertheless ,",
    "since the pioneering work by r.  e.  bryant , branching programs and in particular ordered binary decision diagrams have turned out to be a suitable representation for many application areas such as model checking , vlsi design , computer - aided design , etc ; we refer the interested reader to @xcite for a discussion .    in this paper , a different approach",
    "is advocated .",
    "while it is known that in general satisfiability for boolean circuits is np - complete , there are prominent easy special cases : for example , if we consider only circuits over a monotone base , the satisfiability problem admits an efficient solution .",
    "another example is that of linear circuits ( i.e. , circuits with a base of linear functions ) .",
    "this phenomenon was studied systematically by h.  r.  lewis in 1979 , who showed that satisfiability is np - complete if the base contains or can implement the negation of implication , i.e. , the function @xmath4 . in all other cases , satisfiability has a polynomial - time algorithm .",
    "this _ dichotomy result _ holds for boolean circuits as well as for propositional formulas .",
    "the work of lewis has been taken up by reith and wagner @xcite who examined further algorithmic problems such as the circuit value problem and the problem of counting the number of satisfying assignments .",
    "here we study further important algorithmic tasks for the representation of boolean functions by boolean circuits : first we examine the _ equivalence problem _",
    ", i.e. , the question if two given boolean circuits represent logically equivalent boolean functions , and the _ isomorphism problem _ ,",
    "i.e. , the problem if two given circuits can be made equivalent through a permutation of their input variables .",
    "while these problems are of enormous interest in the area of verification and model - checking , it should be remarked that also from a theoretical viewpoint they have a long history : they were studied by jevons and clifford in the 19th century and in particular the isomorphism problem became known as the `` jevons - clifford problem '' .",
    "the isomorphism problem admittedly gains its importance from a more theoretical point of view . in complexity",
    "theory , isomorphism problems in general are notorious since often they resist a precise complexity theoretic classification .",
    "most famous of course is graph isomorphism , a candidate for an `` intermediate problem '' between p and the np - complete problems .",
    "here we obtain a dichotomy distinguishing the easy from the hard cases for isomorphism of circuits , but for the hard problems we only have a hardness result , we are not able to prove completeness for a complexity class .",
    "a second group of problems we study concerns so called _ frozen variables_. a variable @xmath5 is frozen in a boolean circuit @xmath0 if @xmath0 is satisfiable and all its satisfying assignments give the same boolean value to @xmath5 .",
    "we study the problem to determine if a given circuit has a variable that is frozen .",
    "we also consider a variant that has become known recently under the name _ audit problem _ : this is the problem to decide if a given circuit has a frozen variable or is unsatisfiable .",
    "originally the audit problem stems from the database area .",
    "one can view the value of a frozen variable as having been compromised by the results of the query expressed by the circuit .",
    "this is considered problematic with respect to data security questions ( see @xcite ) .",
    "the audit problem has further practical importance also in vlsi design and testing : here , a frozen variable is a hint for a stuck - at fault and hence a manufacturing defect within the circuit .",
    "finally , we study a variant of the counting problem that is also relevant in practice : instead of just determining the number of satisfying assignments we are interested in an efficient way of producing ( _ enumerating _ ) all such assignments .",
    "different notions of `` efficient '' enumeration have been considered in a paper by johnson et al .",
    "we recall these notions here ( e.g. , polynomial total time , polynomial delay ) and study them in the context of enumerating solutions of boolean circuits .",
    "for all these problems we obtain complete complexity classifications : we determine exactly those circuit bases that make the problems hard ( np - complete or even harder ) and for all remaining bases we present efficient algorithms solving these problems .",
    "the organization of the paper is as follows : in the next section we define boolean functions and boolean circuits .",
    "we also introduce post s lattice of all closed classes of boolean functions ; this lattice will be our main technical tool to obtain the desired complexity results . in sect .",
    "[ sect : problems ] we formally introduce all algorithmic problems that we will classify . in sect .",
    "[ sect : eqiso ] we then turn to equivalence and isomorphism while in sect .",
    "[ sect : audit ] we study all audit - like problems ; sect .  [",
    "sect : enumeration ] contains our results on enumeration .",
    "finally , sect .",
    "[ sect : conclusion ] contains a conclusion and presents some open problems and future research directions .",
    "a _ boolean function _ is an @xmath6-ary function @xmath7 . in the following",
    "we will often use well - known boolean functions as @xmath8 , @xmath1 , @xmath9 , @xmath10 , @xmath11 , @xmath12 , @xmath13 , the implication function , and the @xmath14-ary @xmath15-threshold function @xmath16 verifying @xmath17 if and only if @xmath18 .",
    "clone _ is a set of boolean functions that is closed under superposition , _",
    "i.e. _ , it contains all projections ( that is , the functions @xmath19 for @xmath20 and @xmath21 ) and is closed under arbitrary composition @xcite .",
    "let @xmath22 be a finite set of boolean functions .",
    "we denote by @xmath23 $ ] the smallest clone containing @xmath22 and call @xmath22 a _ base _ for @xmath23 $ ] .",
    "the set @xmath23 $ ] corresponds to the set of all boolean functions that can be computed by @xmath22-circuits ( as defined below ) .",
    "all closed classes of boolean functions are known , as is their inclusion structure , which forms a lattice .",
    "this lattice is named after its discoverer e.  post @xcite .",
    "the following properties are crucial for the below definitions of the clones :    * @xmath2 is _ @xmath24-reproducing _ if @xmath25 , @xmath26 .",
    "the functions @xmath9 and @xmath10 are @xmath8- and @xmath1-reproducing , the binary exclusive or , @xmath12 , is @xmath8-reproducing , but not @xmath1-reproducing , whereas the unary negation ( @xmath11 ) is neither @xmath1- nor @xmath8-reproducing .",
    "* @xmath2 is _ monotonic _ if @xmath27 implies @xmath28 .",
    "boolean functions built up on composition of only @xmath29 are monotonic , like for instance @xmath30 .",
    "* @xmath2 is _ @xmath24-separating of degree @xmath15 _ if for all @xmath31 of size @xmath32 there exists an @xmath33 such that @xmath34 implies @xmath35 , @xmath36 .",
    "the @xmath14-ary @xmath15-threshold function @xmath16 is @xmath1-separating of degree @xmath15 , but not @xmath1-separating of degree @xmath37 .",
    "for instance @xmath38 , which is the ternary majority function , is @xmath1-separating of degree 2 .",
    "* @xmath2 is _ @xmath24-separating _ if @xmath2 is @xmath24-separating of degree @xmath39 .",
    "the implication @xmath40 is @xmath8-separating .",
    "* @xmath2 is _ self - dual _ if @xmath41 .",
    "the function @xmath42 is self - dual .",
    "* @xmath2 is _ affine _ if @xmath43 with @xmath44 .",
    "the function @xmath45 is affine and self - dual .    for a list of all boolean clones",
    "see table  [ bases ] and for their inclusion structure see figure  [ platt ] . for an extensive introduction to superposition ,",
    "post s lattice and related problems see @xcite . in the naming of the clones the semantic of single indexes is as follows .",
    "index 2 indicates that the clone contains no constants at all .",
    "index 0 ( resp .",
    "1 ) indicates that the clone contains only the constant 0 ( resp .",
    "1 ) but not 1 ( resp . 0 )",
    ". clones with no index contain both constants 0 and 1 .",
    "the only exceptions to this convention are the clones @xmath46 and @xmath47 which do not contain any constants at all .",
    "the index * stands for all valid indexes .",
    "clones of particular importance in this paper are :    * the clone of all boolean functions @xmath48=[\\land,\\lor,\\neg,0,1]$ ] * the monotonic clones @xmath49 , e.g. ,  @xmath50 $ ] , @xmath51 $ ] * the affine clones @xmath52 , e.g. ,  @xmath53 $ ] , @xmath54 $ ] * the disjunctive clones @xmath55 , e.g. ,  @xmath56 $ ] , @xmath57 $ ] * the conjunctive clones @xmath58 , e.g. ,  @xmath59 $ ] , @xmath60 $ ] * the @xmath24-reproducing clones @xmath61 ( the clone of all @xmath1-reproducing functions ) , @xmath62 ( @xmath8-reproducing functions ) , @xmath63 ( functions that are both @xmath1- and @xmath8-reproducing ) * the implication clone @xmath64 $ ] * the negated - implication clone @xmath65 $ ] * the self - dual clones : @xmath46 self - dual , @xmath66 , @xmath67 * the clones @xmath68 $ ] , @xmath69 $ ] , @xmath70 $ ] and @xmath71.$ ] * the clones @xmath72 containing only the identity and some constant functions , e.g. , @xmath73 $ ]    in the following we will often implicitly refer to the inclusion structure of post s lattice . here are some facts that we will use .    * the function @xmath74 is a function of @xmath47 since it is in @xmath75 ( see the base given in table  [ bases ] ) and @xmath76 . *",
    "similarly the ternary majority function @xmath77 is a function of @xmath47 since it is in @xmath78 and @xmath79 .",
    "* for all @xmath22 such that @xmath80\\subseteq { \\ensuremath{\\mathrm{r_1}}\\xspace}$ ] there exists a @xmath81 such that the threshold function @xmath82 $ ] .",
    "indeed in this case @xmath23 $ ] is either @xmath83 for some @xmath81 , or @xmath61 or @xmath63 ( which both contain @xmath84 ) .",
    "we will often add some constant @xmath85 or @xmath1 to a clone @xmath0 and consider the clone @xmath86 $ ] generated out of @xmath0 and @xmath24 .",
    "with post s lattice one can determine this @xmath87 quite easily : it is the lowest clone above @xmath0 that contains @xmath24 , i.e. , the lowest clone above both @xmath0 and @xmath88 . as a consequence a base of @xmath87",
    "is obtained by a base of @xmath0 to which we add the constant @xmath24 .",
    "the following list contains identities we will frequently use .    * @xmath89 $ ] , thus @xmath90 is a base of @xmath91 . *",
    "@xmath92 $ ] , thus @xmath93 is a base of @xmath94 . *",
    "@xmath95 $ ] , thus @xmath96 is a base of @xmath61 .",
    "* @xmath97 $ ] , thus @xmath98 is a base of @xmath62 .",
    "lll * class * & * definition * & * base(s ) * + @xmath91 & all boolean functions & @xmath99 + @xmath62 & @xmath100 is 0-reproducing } & @xmath101 + @xmath61 & @xmath100 is 1-reproducing } & @xmath102 } + @xmath63 & @xmath103 & @xmath104 } + @xmath105 & @xmath100 is monotonic } & @xmath106 } + @xmath107 & @xmath108 & @xmath109 } + @xmath110 & @xmath111 & @xmath112 } + @xmath113 & @xmath114 & @xmath115 + @xmath116 & @xmath100 is 0-separating of degree @xmath6 } & @xmath117 + @xmath118 & @xmath100 is 0-separating } & @xmath119 + @xmath120 & @xmath100 is 1-separating of degree @xmath6 } & \\{@xmath121 , @xmath122 } + @xmath123 & @xmath100 is 1-separating } & \\{@xmath124 } + @xmath125 & @xmath126 & \\{@xmath127 + @xmath128 & @xmath129 & \\{@xmath130 } + @xmath131 & @xmath132 & @xmath133 + @xmath134 & @xmath135 & @xmath136 + @xmath137 & @xmath138 & @xmath139 + @xmath140 & @xmath141 & @xmath142 + @xmath143 & @xmath144 & @xmath145 + @xmath146 & @xmath147 & @xmath148 + @xmath149 & @xmath150 & @xmath151 + @xmath152 & @xmath153 & @xmath154 + @xmath155 & @xmath156 & @xmath157 + @xmath158 & @xmath159 & @xmath160 + @xmath46 & @xmath161 is self - dual } & @xmath162 + @xmath47 & @xmath163 & @xmath164 + @xmath78 & @xmath165 & @xmath166 + @xmath167 & @xmath168 @xmath2 is linear } & @xmath169 + @xmath170 & @xmath171 & @xmath172 + @xmath173 & @xmath174 & @xmath175 + @xmath176 & @xmath177 & @xmath178 + @xmath179 & @xmath180 & @xmath181 + @xmath182 & @xmath168 @xmath2 is an @xmath183-function or a constant function } & @xmath184 + @xmath185 & @xmath186 \\cup [ \\{{0}\\}]$ ] & @xmath187 + @xmath188 & @xmath186 \\cup [ \\{{1}\\}]$ ] & @xmath189 + @xmath190 & @xmath186 $ ] & @xmath191 + @xmath192 & @xmath168 @xmath2 is an @xmath9-function or a constant function } & @xmath193 + @xmath194 & @xmath195 \\cup [ \\{{0}\\}]$ ] & @xmath196 + @xmath197 & @xmath195 \\cup [ \\{{1}\\}]$ ] & @xmath198 + @xmath199 & @xmath195 $ ] & @xmath200 + @xmath201 & @xmath202 \\cup [ \\{{0}\\ } ] \\cup [ \\{{1}\\}]$ ] & @xmath203 , @xmath204 + @xmath205 & @xmath202 $ ] & @xmath206 + @xmath207 & @xmath208 \\cup [ \\{{1}\\ } ] \\cup [ \\{{0}\\}]$ ] & @xmath209 + @xmath210 & @xmath208 \\cup [ \\{{0}\\}]$ ] & @xmath211 + @xmath212 & @xmath208 \\cup [ \\{{1}\\}]$ ] & @xmath213 + @xmath214 & @xmath208 $ ] & @xmath215 +          let us now define the central objects that we deal with in this paper , namely _ boolean circuits _",
    "( see also @xcite ) :    let @xmath22 be a finite set of boolean functions .",
    "a _ boolean circuit _ over @xmath22 , or a _ @xmath22-circuit _ is a tuple @xmath216 where @xmath217 is a finite , acyclic , directed graph , @xmath218 is an injective function , @xmath219 and @xmath220 such that the following conditions hold :    * if @xmath221 has in - degree @xmath222 then @xmath223 , or @xmath224 is a @xmath8-ary function from @xmath225 * if @xmath221 has in - degree @xmath226 then @xmath224 is a @xmath15-ary function in @xmath227    nodes in @xmath228 are also called _ gates_. a gate @xmath229 with @xmath223",
    "is called an _ input - gate _ , and @xmath230 is called _ output - gate_. later the function @xmath231 will be used to specify the order of the predecessors of a gate .    with @xmath232",
    "we denote the variables appearing in the circuit @xmath0 , i.e. , the set @xmath233 .",
    "this definition of a boolean circuit corresponds to the intuitive idea that a circuit consists of a set of gates which are either input gates , or compute some boolean function ( in our case , functions from @xmath22 ) with arguments taken from the predecessor gates .",
    "the set @xmath22 is also called a _",
    "base_. the distinguished gate @xmath230 is the output - gate , i.e. , the value computed by the circuit is the result computed in this gate .",
    "the _ size _ of a circuit is the number of non - input gates .",
    "the function computed by a circuit is defined in the canonical way : once we know the values for the input - gates , we can inductively ( since the graph is acyclic ) compute the value for each gate @xmath234 . for non - commutative functions in @xmath22 ,",
    "the ordering @xmath231 on the edges in the graph gives a well - defined function value .",
    "the following definition captures this formally :    let @xmath235 be a boolean circuit with @xmath236 , and let @xmath237 let @xmath229 be a gate in @xmath0 .",
    "we define the function @xmath238 computed by the gate @xmath229 on input @xmath239 as follows :    * if @xmath229 is an input - gate , i.e. , @xmath240 for @xmath241 we define @xmath242 * if @xmath229 has in - degree @xmath15 , and @xmath243 are the predecessor gates of @xmath229 in @xmath0 such that @xmath244 then @xmath245    we define the function @xmath246 , the _ function computed by @xmath0 _ , as @xmath247 .",
    "if the function @xmath248 associated with a circuit @xmath0 does not depend on its @xmath249th argument , we say that @xmath250 is a _ fictive _ or _ irrelevant _ variable for the circuit .    by writing @xmath251 , we mean that @xmath0 is a circuit such that @xmath252 . for constant values",
    "@xmath253 , we also denote @xmath254 by @xmath255 .",
    "an _ assignment _ for the variables in @xmath256 is a function @xmath257 .",
    "such an assignment is also called _",
    "compatible with @xmath0_. we will write @xmath258 if @xmath259 . in this case",
    "we also say that @xmath260 is a _ satisfying assignment _ or a _ solution _ for @xmath0 .",
    "we denote by @xmath261 the set of assignments satisfying @xmath0 and by @xmath262 the cardinality of this set .",
    "a circuit is _ satisfiable _ if it has a satisfying assignment .",
    "when the order of variables is clear from the context , we write an assignment simply as the tuple of binary values , i.e. , with @xmath239 we denote the corresponding assignment @xmath260 where @xmath263 for all relevant @xmath249 . for convenience",
    "we also often write @xmath264 when we mean @xmath265 .",
    "hence @xmath266 denotes the value @xmath267 .",
    "we sometimes view the circuit as a function of its assignments , and write @xmath268 if @xmath258 , and @xmath269 otherwise . in the following ,",
    "let @xmath270 , let @xmath2 be an @xmath6-ary boolean function , @xmath271 , and @xmath272 be functions @xmath273 .",
    "we define @xmath274 . for assignments",
    "@xmath275 and @xmath276 , we write @xmath277 if @xmath278 for @xmath279 .",
    "finally let @xmath280 be the assignment @xmath281 .    for a circuit @xmath0 and a variable @xmath282 ,",
    "the variable @xmath5 is said to be _ frozen _ in @xmath0 if @xmath0 is satisfiable and there is a constant @xmath283 such that for all assignments @xmath260 , @xmath258 implies @xmath284 .",
    "similarly we define that @xmath285 is _ frozen _ in @xmath0 if every variable in @xmath228 is frozen in @xmath0 .",
    "we now define the list of computational problems involving boolean circuits that we study in this paper .",
    "all our problems are connected to the satisfiability problem and the circuit value problem defined as follows  in the following , let @xmath22 be a base , i.e. , a finite set of boolean functions .    .5em",
    "0em by2.3em 0ex .2ex",
    "@xmath286b    a @xmath22-circuit @xmath287    is @xmath0 satisfiable ?    .5em",
    "0em by2.3em 0ex .2ex",
    "plus.1ex    @xmath288    a @xmath22-circuit @xmath287 and an assignment @xmath289    is @xmath290 ?",
    "the complexity of these problems is well known :    [ prop : csat](@xcite ) let @xmath22 be a finite set of boolean functions",
    ". then @xmath291 is @xmath292-complete if @xmath293}}$ ] , and solvable in @xmath294 otherwise .",
    "[ prop : circval ] let @xmath22 be a finite set of boolean functions , then @xmath295",
    ".    we will be interested in equivalence and isomorphism problems .",
    "let us define precisely these two notions .",
    "[ def : permass ] let @xmath296 be a permutation and @xmath297 be a truth assignment . we define the permuted assignment @xmath298 by @xmath299 for @xmath300 .",
    "let @xmath301 and @xmath302 be @xmath22-circuits .",
    "the two circuits are equivalent , denoted by @xmath303 , if for all truth assignments @xmath304 , @xmath305 if and only if @xmath306 .",
    "the two circuits are isomorphic , denoted by @xmath307 if there exists a permutation @xmath308 such that for all truth assignments @xmath304 , @xmath305",
    "if and only if @xmath309 .    using these equivalence relations , we define the _ boolean equivalence _ and _ boolean isomorphism _",
    "problem for @xmath22-circuits :    .5em",
    "0em by2.3em 0ex",
    ".2ex plus.1ex    @xmath310    two @xmath22-circuits @xmath311 and @xmath312    is @xmath303 ?",
    "the equivalence problem for propositional circuits or formulas is one of the standard @xmath313-complete problems .",
    "the complexity of the next problem we consider , the isomorphism problem , is not completely determined .",
    "it is clearly @xmath313-hard and lies in the second level of the polynomial hierarchy , more precisely in @xmath314 .",
    "however , it is not known to be solvable in @xmath313 , and is not complete for @xmath314 , unless the polynomial hierarchy collapses  @xcite .",
    "we study the version of this problem where the inputs are restricted to @xmath22-circuits :    .5em",
    "0em by2.3em 0ex .2ex",
    "plus.1ex    @xmath315    two @xmath22-circuits @xmath311 and @xmath312    is @xmath307 ?",
    "the next two problems are concerned with frozen variables .",
    "as defined earlier a variable @xmath5 is frozen in a satisfiable circuit if all solutions of the circuit assign @xmath5 the same boolean value .",
    "the problem of recognizing frozen variables in boolean formulas was first studied by jon kleinberg , christos papadimitriou , and prabhakar raghavan in @xcite ; their motivation to consider this problem was to ensure that database queries do not reveal information that should be kept secret .",
    "again , we consider the version of two problems in this context where we restrict the propositional gates allowed to appear in the input circuits :    .5em 0em by2.3em 0ex .2ex plus.1ex    @xmath316    a @xmath22-circuit @xmath0 over a set of variables @xmath228 and @xmath317 such that @xmath318    is @xmath319 frozen in @xmath0 ?    if we restrict the problem @xmath316 to instances with @xmath320 , then we obtain the generalized _ unique satisfiability problem _ over circuits .",
    "this is a natural complete problem for the class @xmath321  ( see  @xcite ) .",
    "we define the problem @xmath322 to be the restriction of this problem to @xmath22-circuits as input .",
    ".5em 0em by2.3em 0ex .2ex",
    "plus.1ex    @xmath322    a @xmath22-circuit , @xmath0    does @xmath0 have exactly one satisfying assignment ?",
    "the question of the existence of such a frozen variable is the following problem    .5em",
    "0em by2.3em 0ex .2ex",
    "plus.1ex    @xmath323    a @xmath22-circuit @xmath0    is there a frozen variable in @xmath0 ?",
    "note that in the above problem @xmath323 it is necessary that the circuit is satisfiable .",
    "if we drop the restriction of being satisfiable , we have the definition of the so called _ audit problem _ : does @xmath0 have a frozen variable or is @xmath0 unsatisfiable ?    besides these decision problems we are also interested in the enumeration problem which asks , for a given boolean circuit to generate the set of its satisfying assignments with no repetition .",
    ".7em 1.5em by3em0ex .2ex",
    "plus.1ex    @xmath324    a @xmath22-circuit , @xmath0    all satisfying assignments of @xmath0    in the following in establishing the complexity of the decision problems defined above we need notions of the following complexity classes : let @xmath294 ( @xmath292 resp . ) be the class of languages which are decidable ( acceptable , resp . ) by deterministic ( nondeterministic , resp . )",
    "turing machines in polynomial time . for an arbitrary complexity class @xmath325 ,",
    "let @xmath326 . recall that @xmath327 , which is the second level of the boolean hierarchy and contains both @xmath292 and @xmath328 ( see @xcite ) .",
    "for our hardness results we mostly employ _ logspace many - one reductions _ , defined as follows : a language @xmath329 is logspace many - one reducible to some language @xmath22 ( written @xmath330 ) if there exists a logspace - computable function @xmath2 such that @xmath331 if and only if @xmath332 .",
    "we write @xmath333 if @xmath334 and @xmath335 . _ polynomial - time many - one reductions _",
    "( written as @xmath336 and @xmath337 ) are defined in the same way , except that the function @xmath2 is only required to be computable in polynomial time .    for the enumeration problem",
    "polynomial time is not a suitable notion of efficiency , since the number of solutions may be exponential in the length of the circuit . for the notion of an `` efficient '' enumeration algorithm",
    ", we use the definitions from @xcite .",
    "an algorithm for the enumeration problem has _",
    "polynomial total time _",
    ", if the running time of the algorithm is polynomial in the length of the input circuit and in the number of its satisfying solutions .",
    "this notion is also referred to as _",
    "output polynomial_. an important feature of an enumeration algorithm is the ability to start generating solutions as soon as possible , and more generally to generate solutions in a regular way with a limited delay between two successive outputs .",
    "it has _ polynomial delay _",
    "if the time needed by the algorithm between its start and the printing of the first solution , the time between the printing of each two consecutive solutions , and the time between printing the last solution and the termination of the algorithm is bounded by a polynomial in the length of the input circuit . in @xcite the authors exhibited polynomial - delay algorithms that used exponential space and therefore distinguished polynomial - delay algorithms using only polynomial space . in our paper polynomial - delay enumeration algorithms all work with polynomial space , hence we do not mention it explicitly . an enumeration algorithm with polynomial delay",
    "can be further required to output the elements in some order ( e.g. lexicographic order ) ( see @xcite ) .",
    "let us now make explicit the main tool that we will use in order to get complexity classifications .",
    "[ prop : circ - property ] let @xmath338 be one of the decision problems introduced above , and let @xmath339 be finite sets of boolean functions such that @xmath340}}$ ] . then @xmath341 . in particular ,",
    "if @xmath342}}={\\ensuremath{\\left [ b_2 \\right]}}$ ] , then @xmath343 .",
    "since all of the problems that we study in this paper only consider the function computed by the corresponding input circuits , it is clear that a transformation converting a circuit into an equivalent one leaves the properties considered in these decision problems invariant .",
    "observe that if @xmath344 and @xmath345 are finite sets of boolean functions such that @xmath340}}$ ] , then every function from @xmath344 can be expressed as a @xmath345-circuit , its so - called @xmath345-representation .",
    "thus we can , in logarithmic space , convert any @xmath344-circuit into an equivalent @xmath345-circuit in replacing every gate of the original circuit ( which is a function from @xmath344 ) by its @xmath345-representation .",
    "this concludes the proof .",
    "note that since @xmath344 and @xmath345 are not part of the input the cost of computing the @xmath345-representations of the functions of @xmath344 is a not taken into account .",
    "since the above result shows that the complexity of the problems we study does not depend on the particular base of a clone that we consider , we sometimes write @xmath346 for a clone @xmath0 .",
    "for example , we write @xmath347 to denote the satisfiability for a set @xmath22 with @xmath348}}={{\\mathrm{bf}}\\xspace}$ ] , e.g. , for @xmath349 . due to the above , choosing a different base @xmath22 of @xmath91 results in a problem with the same complexity .    as a consequence in order to get a complete classification for @xmath350 for every finite set @xmath22 it is enough to examine all possible clones .",
    "when we show a hardness result for @xmath346 for some clone @xmath0 , then hardness also holds for every finite set @xmath22 such that @xmath351}}$ ] .",
    "also when we show tractability of @xmath346 , then tractability also holds for every finite set @xmath22 such that @xmath352}}$ ] .",
    "we also note that a similar result as proposition  [ prop : circ - property ] applies to the enumeration problem .",
    "for example , if @xmath340}}$ ] , and there is a polynomial - delay enumeration algorithm for @xmath345-circuits , then there also is a polynomial - delay enumeration algorithm for @xmath344-circuits .",
    "[ sect : eqiso ] in this section we use the inclusion structure of all closed classes ( see figure  [ platt ] ) to determine the complexity of @xmath310 step by step .",
    "similarly we are able to give lower bounds for the isomorphism problem of @xmath22-circuits",
    ".    the following lemma will be a useful fact in our proofs  the lemma follows from the simple observation that for the equivalence- or isomorphism problems , consistently swapping @xmath8s and @xmath1s does not change the complexity .",
    "let us first introduce some notation .",
    "if @xmath2 is an @xmath6-ary boolean function , then @xmath353 denotes the boolean function such that @xmath354 . for a set @xmath22 of boolean functions , let @xmath355 .",
    "[ lemma : duality ] let @xmath22 be a finite set of boolean functions",
    ". then @xmath356 and @xmath357 .",
    "let us first identify the tractable cases .",
    "the next proposition says that when besides constants only @xmath358-functions or only @xmath359-functions or only @xmath12-functions are allowed , equivalence and isomorphism are easily checkable .",
    "[ prop : eq_n][prop : eq_evl ] let @xmath22 be a finite set of boolean functions .",
    "if @xmath360 or @xmath361 or @xmath362 then @xmath363 and @xmath364 are tractable .",
    "if @xmath22 only contains to @xmath183-functions ( @xmath9-functions , @xmath365-functions resp . ) , the basic idea is that we can first compute an explicit normal form for the functions computed by such a @xmath22-circuit .",
    "this normal form then easily allows to determine equivalence or isomorphism .",
    "first let @xmath366 .",
    "let @xmath367 and @xmath368 be two @xmath22-circuits .",
    "the boolean functions described by @xmath311 and @xmath312 can be expressed as follows : @xmath369 and @xmath370 , where @xmath371 .",
    "+ the values of @xmath372 and @xmath373 , where @xmath374 , can be determined easily by using the following simple facts : @xmath375 ( @xmath376 , resp . )",
    "@xmath377@xmath378 ( @xmath379 , resp . ) and @xmath380 ( @xmath381 , resp . ) for @xmath382 @xmath377@xmath383 ( @xmath384 , resp . ) and @xmath385 ( @xmath386 , resp . ) .",
    "this can be checked in polynomial time with the help of @xmath288 as an oracle . since @xmath387 is tractable ( see proposition [ prop : circval ] )",
    "we conclude that the normal forms can be computed efficiently .",
    "now , clearly @xmath388 @xmath377either @xmath389 or @xmath390 and @xmath391 for @xmath382 , and similarly , @xmath392 @xmath377either @xmath389 or @xmath393 and @xmath394 .",
    "thus we conclude that @xmath363 and @xmath364 are tractable .",
    "tractability for @xmath360 now follows immediately from the above using lemma [ lemma : duality ] .",
    "finally let @xmath395 and let @xmath311 and @xmath312 be @xmath22-circuits .",
    "the boolean functions described by the @xmath22-circuits @xmath367 and @xmath368 can be expressed as follows : @xmath396 and @xmath397 , where @xmath398 .",
    "similar to the above cases the values @xmath372 and @xmath373 for @xmath374 can be determined by a @xmath399-calculation , since we know that @xmath387 is tractable . in particular @xmath400 , @xmath401 , @xmath402 and @xmath403 , where @xmath382 .",
    "now , clearly @xmath388 @xmath377@xmath391 for @xmath404 , and @xmath405 @xmath377@xmath406 and @xmath407 .",
    "again , both problems are tractable .",
    "the main step in obtaining hardness for the remaining cases now is to show that both equivalence and isomorphism are hard for monotone functions .",
    "this is the statement of the next lemma .",
    "[ lemma : eq_and_or ] @xmath408 and @xmath409 are @xmath410-hard for @xmath313 .",
    "we prove that @xmath411 , the problem of deciding whether a @xmath412formula is a tautology , is logspace reducible to @xmath408 and @xmath413 . since @xmath411is well known to be @xmath313-hard this will complete the proof .",
    "let @xmath414 be a @xmath412formula with @xmath415 .",
    "let @xmath416 be the circuit obtained from @xmath417 in replacing every occurrence of a negated variable @xmath418 by the fresh variable @xmath419 .",
    "note that @xmath0 is a @xmath420-circuit that can have fictive variables .",
    "define @xmath421 and @xmath422 .",
    "observe that @xmath423 .",
    "we claim that @xmath417 is a tautology if and only if @xmath424 if and only if @xmath425 .",
    "suppose first that @xmath417 is a tautology .",
    "we prove that every assignment that sets at least one of @xmath250 and @xmath419 to true for every @xmath426 satisfies @xmath0 , thus proving @xmath424 and _ a fortiori _ @xmath425 .",
    "let @xmath260 be such an assignment .",
    "consider the assignment @xmath427 defined by @xmath428 and @xmath429 for @xmath430 .",
    "observe that @xmath427 satisfies @xmath0 since @xmath417 is a tautology .",
    "moreover since for every @xmath249 , @xmath431 we have @xmath432 .",
    "therefore by monotonicity @xmath260 satisfies @xmath0 as well .",
    "conversely , suppose that @xmath417 is not a tautology .",
    "we prove that @xmath433 , thus proving @xmath434 and _ a fortiori _ @xmath435 .",
    "let @xmath260 be an assignment that does not satisfy @xmath417 .",
    "consider @xmath436 defined by @xmath437 and @xmath438 for @xmath426 .",
    "observe that @xmath436 satisfies @xmath311 but not @xmath312 .",
    "since @xmath423 , this proves that @xmath439 .",
    "the next three propositions generalize the hardness result from lemma  [ lemma : eq_and_or ] .",
    "[ prop : eq_s ] let @xmath22 be a set of boolean functions such that @xmath440}}$ ] or @xmath441}}$ ] , then @xmath363 and @xmath364 are @xmath410-hard for @xmath313 .",
    "first let @xmath442}}$ ] . by figure [ bases ]",
    "we know that @xmath443 is a base of @xmath444 . since @xmath445 and @xmath446 we know that @xmath447}}$ ] and @xmath448}}$ ] .",
    "therefore according to proposition [ prop : circ - property ] and lemma [ lemma : eq_and_or ] we get that @xmath449 and @xmath450 are @xmath313-hard .",
    "we now reduce these problems respectively to @xmath363 and @xmath364 .",
    "let @xmath451 and @xmath452 be two @xmath453-circuits .",
    "let @xmath229 be a fresh variable that will be used to replace the constant 1 .",
    "let @xmath454 and @xmath455 .",
    "since @xmath447}}$ ] , @xmath456 and @xmath457 can be represented as @xmath22-circuits , and their @xmath22-representation can be computed in logarithmic space , see proof of proposition  [ prop : circ - property ] .",
    "it is obvious that @xmath424 if and only if @xmath458 . if @xmath425 then clearly @xmath459 . conversely if @xmath459 then there is a permutation @xmath460 such that for all assignment @xmath260 , @xmath461 if and only if @xmath462 .",
    "since the value of @xmath229 is fixed to @xmath1 in every satisfying assignment one can suppose w.l.o.g . that @xmath463 .",
    "in this case we clearly have that for all assignment @xmath260 , @xmath305 if and only if @xmath309 , thus showing that @xmath425 .    now let @xmath441}}$ ] . by inspecting figure [ platt ]",
    "we obtain that @xmath442}}$ ] as well , or @xmath464}})}}$ ] . according to lemma [ lemma : duality ] the proof",
    "is then completed .",
    "[ prop : eq_d ] let @xmath22 be a finite set of boolean functions such that @xmath465 } } \\subseteq { \\ensuremath{\\mathrm{d}}\\xspace}$ ] , then @xmath310 is @xmath410-hard for @xmath328 .    due to lemma  [ lemma : eq_and_or ] , we know that @xmath466 is @xmath410-hard for @xmath328 .",
    "hence let @xmath311 and @xmath312 be @xmath467-circuits , where @xmath468 . by figure [ bases ] we know that @xmath469 , the ternary majority function , is a base for @xmath78 . using the equalities @xmath470 and @xmath471",
    ", we can transform @xmath311 and @xmath312 into equivalent @xmath472-circuits in logarithmic space .",
    "for ease of notation , we denote these ( equivalent ) circuits with @xmath473 and @xmath474 again .",
    "we note that due to the above transformation , every application of @xmath475 in @xmath311 or @xmath312 has exactly one constant argument .",
    "we now construct @xmath476-circuits @xmath477 and @xmath478 such that @xmath424 if and only if @xmath479 . due to proposition  [ prop : circ - property ] , this completes the proof .",
    "let @xmath480 and @xmath229 be fresh variables that will be used to replace the constants 0 and 1 that appear in @xmath311 and @xmath312 . now define    @xmath481 and + @xmath482 .    by construction ,",
    "@xmath456 and @xmath457 are @xmath476-circuits .",
    "we prove that @xmath424 if and only if @xmath458 .",
    "first assume that @xmath424 , and let @xmath260 be an assignment for @xmath483 . if @xmath484 , then @xmath485 iff @xmath486 iff @xmath487 .",
    "now consider the case that @xmath488 . since @xmath475 is a self - dual function it is sufficient to consider the case @xmath489 and @xmath490 . in this case",
    "@xmath491 iff @xmath492 for @xmath493 , and hence @xmath485 iff @xmath486 since @xmath424 .",
    "conversely , suppose that @xmath435 .",
    "then we can suppose that there exists an assignment @xmath260 that satisfies @xmath311 but not @xmath312 .",
    "extend @xmath260 to @xmath436 by setting @xmath494 and @xmath495 .",
    "it is easy to see that @xmath436 satisfies @xmath456 but not @xmath457 , thus proving that @xmath496 .",
    "we have a similar result for the isomorphism problem .",
    "[ prop : iso_d ] let @xmath22 be a finite set of boolean functions such that @xmath465 } } \\subseteq { \\ensuremath{\\mathrm{d}}\\xspace}$ ] , then @xmath315 is @xmath410-hard for @xmath328 .    while the proof of this proposition uses essentially the same reduction as above , it is technically more involved and requires some technical results .",
    "we will reduce from the isomorphism problem for @xmath467-circuits , which we know to be @xmath328-hard due to lemma  [ lemma : eq_and_or ] .",
    "however , in the proof of proposition  [ prop : iso_d ] , we will need some special properties of the instances of @xmath409 that we reduce from .",
    "we therefore present a series of intermediate technical results that allow us to restrict the instances of @xmath409 as required .",
    "first we need to introduce some new notion .",
    "a pair of two variables @xmath497 is _ dominant _ for a circuit @xmath0 , if every truth assignment @xmath260 with @xmath498 satisfies the circuit @xmath0 if and only if @xmath499 .",
    "the following lemma gives some easy properties of dominant pairs .",
    "the proof of the lemma is straight - forward .",
    "[ lemma : dominant pairs not disjoint ]    1 .",
    "let @xmath0 be a circuit , and let @xmath500 and @xmath501 be two dominant pairs for @xmath0 .",
    "then @xmath502 .",
    "2 .   let @xmath311 and @xmath312 be two circuits such that @xmath503 via a permutation @xmath504 . if @xmath500 is a dominant pair for @xmath311 , then @xmath505 is a dominant pair for @xmath312 .",
    "for the first part , assume that @xmath506 .",
    "then there is an assignment @xmath260 with @xmath507 , and @xmath508 .",
    "since @xmath497 is dominant for @xmath0 , it follows that @xmath509 . on the other hand , since @xmath510 is dominant for @xmath0 as well , we know that @xmath258 , a contradiction .",
    "the second part is trivial .",
    "next we need the following result , which says that the isomorphism problem remains hard for monotone functions even for some restricted instances .",
    "[ lemma : iso_and_or_restr ] @xmath409 is @xmath410-hard for @xmath313 , even when instances are restricted to pairs of circuits @xmath511 where neither @xmath311 nor @xmath312 implies or is implied by one variable , and further @xmath512 where @xmath6 is the number of variables in @xmath311 , which is the same as the number of variables in @xmath312 .",
    "we reduce the problem @xmath409 , which is @xmath313-hard due to lemma  [ lemma : eq_and_or ] , to the same problem with restrictions on the instances .",
    "let @xmath513 be a pair of @xmath420-circuits given as an instance of @xmath409 .",
    "without loss of generality one can suppose that they have the same number of variables , @xmath6 , and that @xmath514 is of the form @xmath515 .",
    "thus @xmath514 has fewer than @xmath516 solutions .",
    "since both @xmath514 are monotone , we can , in polynomial time , verify whether @xmath517 or @xmath518 are constant .",
    "if one of them is , then @xmath519 is true if and only if they are equivalent to the same constant .",
    "hence we assume that neither @xmath517 nor @xmath518 is constant . for @xmath520",
    ", we now rewrite @xmath514 into    @xmath521 where @xmath475 is the ternary majority function .",
    "we will show that the @xmath522 s have the desired properties , and that @xmath519 if and only if @xmath503 , thus concluding the proof .    clearly , since the outmost operator of @xmath311 and @xmath312 is the majority function , and neither @xmath517 nor @xmath518 are constant , it follows that no variable implies or is implied by one of the @xmath522 . obviously , @xmath523 , since the solutions of @xmath522 are exactly those of @xmath514 extended with @xmath524 ( giving two solutions for each solution of @xmath514 ) , plus all @xmath525 assignments setting @xmath526 .",
    "since @xmath527 , it follows that @xmath528 . therefore , @xmath529 as required ( note that @xmath530 is the number of variables appearing in @xmath311 and @xmath312 ) .    it remains to show that @xmath519 if and only if @xmath503 . the left - to - right direction is trivial , by extending the permutation to be the identity on @xmath531 .",
    "for the other direction , assume that @xmath532 via a permutation @xmath504 .",
    "observe that @xmath531 is a dominant pair for both circuits .",
    "if @xmath533 , then since @xmath534 and @xmath535 are symmetric , we can assume that @xmath536 , and @xmath504 restricted to the original variables establishes @xmath519 .",
    "hence assume @xmath537 . according to lemma [ lemma : dominant pairs not disjoint ] , @xmath538 .",
    "since @xmath534 and @xmath535 are symmetric , we assume without loss of generality that @xmath539 for a variable @xmath5 of @xmath312 .    we prove that @xmath518 is equivalent to @xmath5 .",
    "first let @xmath260 be an assignment to the variables in @xmath518 with @xmath540 , we prove that @xmath541 .",
    "for this , consider the assignment @xmath542 which extends @xmath260 by @xmath543 and @xmath544 . since @xmath545 is dominant , it follows that @xmath546 , and thus @xmath547 .",
    "therefore , @xmath5 implies @xmath518 . for the other direction ,",
    "let @xmath260 be an assignment with @xmath548 , we show that @xmath549 .",
    "we extend @xmath260 to @xmath542 by setting @xmath550 and @xmath551 .",
    "since @xmath545 is dominant for @xmath312 , it follows that @xmath552 , hence we know that @xmath549 , and thus @xmath518 is equivalent to @xmath5 as claimed .",
    "therefore , @xmath312 has exactly three relevant variables ( recall that a variable @xmath5 is _ relevant _ for a circuit @xmath0 , if there are assignments @xmath275 and @xmath276 such that @xmath553 for all variables @xmath554 , and @xmath555 and @xmath556 , i.e. , if the value of the function computed by the circuit in fact depends on @xmath5 ) .",
    "since @xmath557 , we know that @xmath311 also has exactly three relevant variables . hence @xmath517 has exactly one relevant variable , and since we also know that @xmath517 is a monotone circuit , it follows that @xmath517 is equivalent to a single variable .",
    "in particular , @xmath558 as claimed .",
    "we need a last technical result .",
    "this lemma allows us , in the later proof of proposition  [ prop : iso_d ] , to use a similar argument as in the above proof of lemma  [ lemma : iso_and_or_restr ] : in both proofs it is essential that we can control the possible dominant pairs of a circuit that is of the form @xmath559 , where @xmath475 is the ternary majority function and @xmath0 is some circuit . in the proof of lemma  [ lemma : iso_and_or_restr ] , we knew the dominant sets of @xmath560 since @xmath534 and @xmath535 did not appear in @xmath514 . in the proof of proposition  [ prop :",
    "iso_d ] , the situation will be a bit more complicated , and we will need the following lemma to ensure that the dominant pairs in the circuits resulting from our reduction are exactly the ones that we need .",
    "[ lemma : unique dominant pair ] if @xmath561 is a circuit that does not imply a variable and is not implied by a variable , then @xmath562 is the only dominant pair for @xmath563 where @xmath480 and @xmath229 are new variables .",
    "we note that a circuit @xmath0 implies a variable if and only if the function computed by @xmath0 is @xmath1-separating , and is implied by a variable if and only if the function computed by @xmath0 is @xmath8-separating we note that for the ternary majority function @xmath475 , all pairs of two distinct variables are dominant .",
    "we use the following notation : for an assignment @xmath260 for @xmath0 , with @xmath542 we denote the assignment @xmath260 extended with @xmath564 and @xmath565 . by construction",
    "it follows that @xmath258 if and only if @xmath566 .    clearly , @xmath562 is dominant for @xmath87 .",
    "let @xmath567 be dominant for @xmath87 .",
    "due to lemma  [ lemma : dominant pairs not disjoint ] , we know that @xmath568 .",
    "first assume @xmath569 , then @xmath570 for a variable @xmath5 of @xmath0 .",
    "we prove that @xmath5 implies @xmath0 .",
    "hence let @xmath540 . by construction , we have that @xmath564 , and @xmath571 .",
    "since @xmath572 dominates @xmath87 , it follows that @xmath566 . due to the above",
    ", this means that @xmath258 .",
    "hence @xmath5 implies @xmath0 , a contradiction .",
    "similarly , assume that @xmath573 , then @xmath574 for a variable @xmath5 of @xmath0 .",
    "we claim that @xmath0 implies @xmath5 .",
    "hence let @xmath260 be an assignment with @xmath575 , and assume that @xmath548 . from the above",
    "it follows that @xmath566 . on the other hand",
    ", we have that @xmath576 , and since @xmath577 dominates @xmath87 , this implies @xmath578 , a contradiction .",
    "therefore , @xmath0 indeed implies @xmath5 , which is a contradiction to the prerequisites of the lemma .",
    "we are now in a position to prove proposition [ prop : iso_d ] .    as in the proof of proposition",
    "[ prop : eq_d ] we get that @xmath579 is @xmath313-hard , and we reduce this problem to @xmath364 .",
    "let @xmath473 and @xmath580 be two @xmath581-circuits .",
    "according to lemma [ lemma : iso_and_or_restr ] one can suppose that neither @xmath311 nor @xmath312 implies or is implied by one variable , and further that @xmath512 where @xmath6 is the number of variables in @xmath311 , which is the same as the number of variables in @xmath312 .",
    "let @xmath480 and @xmath229 be fresh variables , and let @xmath582 and @xmath583    as mentioned in the earlier proof of lemma  [ lemma : iso_and_or_restr ] , this construction is very similar to what we used there .",
    "the major difference lies in the role of the variables that are used in the application of the newly introduced majority function : in the proof of lemma  [ lemma : iso_and_or_restr ] , we used new variables @xmath534 and @xmath535 that did not appear anywhere else , and whose role was symmetric .",
    "in fact , the proof of lemma  [ lemma : iso_and_or_restr ] only works since @xmath534 and @xmath535 did not appear in the circuits @xmath514 considered in that proof .    in the current proof , the situation is different : here , the variables @xmath480 and @xmath229 do appear in the circuits @xmath584 , and they are clearly not symmetric  they `` simulate '' the values @xmath8 and @xmath1 , respectively . in the remainder of the current proof , we make crucial use of the facts established in lemma",
    "[ lemma : iso_and_or_restr ] , namely , that the circuits @xmath311 and @xmath312 are not implied by , or imply , a variable .",
    "this then allows us to apply lemma  [ lemma : unique dominant pair ] and ensure that @xmath562 is the only dominant pair of @xmath585 .",
    "another difference is that in the current proof , the circuits @xmath584 are indeed @xmath78-circuits , where in the earlier result , the majority function was applied to ( almost ) arbitrary @xmath586-circuits .",
    "we prove @xmath425 if and only if @xmath459 .",
    "it is obvious that if @xmath425 then @xmath459 .",
    "conversely , suppose that @xmath459 .",
    "then there exists a permutation @xmath587 such that for every truth assignment @xmath588 it holds that @xmath461 if and only if @xmath462 .",
    "observe that because of the majority function , the pair @xmath589 is dominant for both circuits @xmath590 and @xmath591 . according to lemma [ lemma : unique dominant pair ] we have then @xmath592 .",
    "suppose that @xmath593 and @xmath594 .",
    "let @xmath595 be the number of truth assignments satisfying @xmath456 that set @xmath480 to @xmath8 and @xmath229 to 1 , and @xmath596 be the number of truth assignments satisfying @xmath457 that set @xmath480 to @xmath1 and @xmath229 to 0 .",
    "since @xmath456 and @xmath457 are isomorphic through a permutation @xmath504 such that @xmath593 and @xmath594 we have @xmath597 .",
    "we have @xmath598 and @xmath599 .",
    "observe that @xmath600 , while    @xmath601 @xmath602 since @xmath312 is a @xmath581-circuit and @xmath22 contains only self - dual functions .",
    "therefore @xmath603 . but @xmath597 implies @xmath604 , _",
    "i.e. _ , @xmath605 , which is not the case by assumption , thus providing a contradiction . therefore @xmath606 and @xmath463 . with this",
    "it is easy to see that @xmath459 implies that @xmath425 through the same permutation @xmath504 .    by a careful inspection of figure [ platt ]",
    "we see that propositions  [ prop : eq_evl ] , [ prop : eq_s ] , [ prop : eq_d ] , and [ prop : iso_d ] cover all cases .",
    "this leads us to the following classification theorems for the complexity of the equivalence- and isomorphism- problems of @xmath22-circuits :    [ isoeqdich ] let @xmath22 be a finite set of boolean functions .    1 .",
    "if @xmath360 or @xmath607 or @xmath608 then @xmath310 and @xmath315 are tractable .",
    "2 .   in all other cases",
    "@xmath363 is @xmath609-complete for @xmath328 and @xmath364 is @xmath609-hard for @xmath328 .",
    "this section covers our results about the problems related to the audit and frozen variable problems .",
    "we start with the following basic facts about complexity upper bounds .    for every finite set @xmath22 of boolean functions ,",
    "the following upper bounds hold :    2    1 .",
    "@xmath610 , 2 .",
    "@xmath611 , 3 .",
    "@xmath612 , and 4 .",
    "@xmath613 .    as an auxiliary problem",
    "we will first examine the generalization of the satisfiability problem @xmath614 , which asks whether a @xmath22-circuit has a satisfying assignment different from the all 1 s one .",
    "this problem was examined in @xcite in the constraint setting .",
    "[ thm : selectsat ] let @xmath22 be a finite set of boolean functions",
    ". then @xmath614 is @xmath292-complete if @xmath615}}$ ] , and solvable in @xmath294 otherwise .",
    "first assume @xmath615}}$ ] .",
    "in this case by looking at post s lattice ( see figure [ platt ] ) we know that @xmath616={\\ensuremath{{\\mathrm{s}_1}}\\xspace}$ ] , hence following proposition [ prop : csat ] , @xmath617 is @xmath292-complete . we will now reduce @xmath617 to @xmath618 .",
    "given an @xmath619-circuit @xmath620 we use a new variable @xmath5 as a replacement for the constant @xmath8 .",
    "thus we obtain an @xmath621-circuit @xmath622 . looking at table 1 we see that the boolean function @xmath623 belongs to @xmath621 .",
    "hence , let @xmath624 be the @xmath621-circuit defined by @xmath625 .",
    "observe that @xmath624 is equivalent to @xmath626 observe now that @xmath0 has a satisfying assignment if and only if there is an assignment different from the all @xmath1 s one that satisfies @xmath624 .",
    "we conclude that @xmath618 is @xmath292-hard , thus showing that @xmath614 is @xmath292-complete for all @xmath22 such that @xmath615}}$ ] .    if @xmath627 , then an @xmath6-ary circuit @xmath0 has a satisfying assignment besides the all-@xmath1-assignment if and only if it has a satisfying assignment of the form @xmath628 .",
    "hence @xmath614 can be solved with @xmath6 evaluations of the circuit @xmath0 .",
    "if @xmath395 , we can use the linear normal form @xmath629 , which is obviously polynomial time computable , to solve @xmath614 efficiently .    if @xmath630 or @xmath631 then we claim that each @xmath6-ary @xmath22-circuit has at least @xmath516 satisfying assignments , which obviously makes @xmath614 tractable .",
    "if @xmath630 the claim holds for any self - dual circuit has exactly @xmath516 solutions . if @xmath631 , note that for every @xmath22-circuit and compatible assignment @xmath260 , if @xmath260 does not satisfy @xmath0 , then @xmath280 does",
    "indeed , assume that both @xmath260 and @xmath280 do not satisfy @xmath0 . since @xmath0 is a @xmath22-circuit , and @xmath632",
    ", we know that the function described by @xmath0 is @xmath8-separating of degree @xmath633 . thus every set @xmath634 with @xmath635 and @xmath636 is @xmath8-separating . the set @xmath634 defined as",
    "@xmath637 meets these conditions , and hence is @xmath8-separating . from the definition , it follows that there is some @xmath638 such that @xmath639 , which is a contradiction to the definition of @xmath280 .",
    "in particular , the number of solutions of such a circuit is at least @xmath516 .",
    "next we want to study problems which are related to the concept of frozen variables .",
    "[ lemma : conp_cases_fv ] let @xmath22 be a finite set of boolean functions . if @xmath640 } } \\subseteq { \\ensuremath{\\mathrm{d}}\\xspace}$ ] or @xmath641 } } \\subseteq { \\ensuremath{\\mathrm{r_1}}\\xspace}$ ] , then @xmath316 and @xmath323 are @xmath328-complete .",
    "observe that for all @xmath22 that satisfy the conditions above all @xmath22-circuits are trivially satisfiable , hence @xmath316 and @xmath323 are in @xmath328 .",
    "let @xmath642 } } \\subseteq { \\ensuremath{\\mathrm{r_1}}\\xspace}$ ] .",
    "we will reduce the @xmath328-complete problem ( see proposition [ prop : csat ] ) @xmath643 to @xmath323 and @xmath316 . recall that due to the very end of section  [ subsec : post ] , we know that @xmath644 is a base of @xmath62",
    ". hence let @xmath0 be a circuit over @xmath644 .",
    "we build a new circuit @xmath87 out of @xmath0 by taking a fresh variable @xmath5 and by replacing every occurrence of @xmath8 in @xmath0 with @xmath5 .",
    "then @xmath87 is an @xmath645-circuit .",
    "since @xmath646 we have @xmath647}}$ ] ( see figure [ platt ] ) , and hence @xmath648 can be converted into an equivalent @xmath22-circuit note that the only possibly frozen variable in @xmath648 is @xmath5 , since with setting @xmath5 to true , every possible assignment to the other variables satisfies the circuit . finally , @xmath5 is a frozen variable in @xmath648 if and only if @xmath0 is not satisfiable .",
    "now let @xmath640 } } \\subseteq { \\ensuremath{\\mathrm{d}}\\xspace}$ ] .",
    "we will reduce the @xmath328-complete problem @xmath649 ( see theorem [ isoeqdich ] ) to @xmath323 and @xmath316 .",
    "for that let @xmath311 and @xmath312 be two @xmath6-ary @xmath47-circuits .",
    "let @xmath5 be a fresh variable and let @xmath650 . since @xmath651 is a function in @xmath47 ( see figure [ platt ] ) ,",
    "@xmath87 is a @xmath47-circuit .",
    "consider now the @xmath47-circuit @xmath652 ( remind that @xmath653 ) .",
    "the reduction @xmath654 works as follows : @xmath655 we claim that @xmath656 holds if and only if @xmath657 if and only if @xmath658 . for that let @xmath656 , then @xmath659 . since @xmath660 the formula @xmath87 is satisfied if and only if @xmath5 is satisfied .",
    "thus @xmath5 is a frozen variable and therefore @xmath661 and @xmath662 . on the other hand , if @xmath663 then we have two cases . if @xmath664 or @xmath665 then @xmath666 , which is a circuit without frozen variables . if @xmath667 and @xmath668 then @xmath659 .",
    "since @xmath663 , there is an assignment @xmath669 such that @xmath670 .",
    "therefore @xmath671 and there is no frozen variable in @xmath87 .",
    "the following is our main classification result for the problem that asks if there is any frozen variable :    [ thm : existsfv ]",
    "let @xmath22 be a finite set of boolean functions .    1 .",
    "if @xmath672 , @xmath673 , or @xmath674 then @xmath323 is tractable .",
    "if @xmath348}}={\\ensuremath{{\\mathrm{s}_1}}\\xspace}$ ] , then @xmath323 is @xmath292-complete .",
    "if @xmath675}}$ ] then @xmath323 is @xmath676-complete .",
    "4 .   in all other cases",
    "@xmath323 is @xmath328-complete .    1",
    ".   [ existfrozenthmtractcase ] if @xmath395 then in a @xmath22-circuit there is a frozen variable if and only if exactly one of the variables of its linear normal form has a coefficient of 1 .",
    "note that the linear normal form can easily be computed from the circuit using simulation ( see proof of proposition [ prop : eq_evl ] ) .",
    "+ now let @xmath673 and let @xmath256 be a @xmath22-circuit . by monotonicity the variable @xmath250 is frozen if and only if @xmath677 and @xmath678 .",
    "moreover the satisfiability of a monotonic @xmath0 can be easily tested . if @xmath679 then every @xmath22-circuit @xmath0 is satisfiable and has a frozen variable because @xmath0 is @xmath1-separating .",
    "2 .   note that an @xmath680-circuit has a frozen variable by definition if and only if it is satisfiable and it is therefore equivalent to @xmath291 , which is known to be @xmath292-complete by proposition [ prop : csat ] .",
    "3 .   [ efvdpcompletecases ] let @xmath22 such that @xmath681}}$ ] .",
    "it is obvious , that @xmath323 is in @xmath676 .",
    "let us now introduce the problem @xmath682 : @xmath683 by definition @xmath682 is in @xmath676 and is @xmath676-complete as far as @xmath291 is @xmath292-complete ( cf .",
    "we now reduce @xmath682 to @xmath323 , thus completing the proof .",
    "since @xmath675}}$ ] , there is a @xmath684 such that @xmath16 is in @xmath348}}$ ] .",
    "let @xmath311 and @xmath312 be @xmath22-circuits which are @xmath685- and @xmath6-ary respectively . now define @xmath686 where @xmath250 is a fresh variable for @xmath687 .",
    "clearly @xmath0 is a @xmath22-circuit .",
    "next we show that this transformation gives the needed reduction .",
    "+ if @xmath688 are both satisfiable then there are assignments @xmath689 and @xmath690 such that @xmath691",
    ". then none of the variables of @xmath311 is frozen in @xmath0 , since @xmath692 for all @xmath693 .",
    "the same argumentation holds for all variables in @xmath312 .",
    "furthermore for all @xmath694 it holds that @xmath250 is not frozen in @xmath0 , since @xmath695 .",
    "+ if @xmath696 are both unsatisfiable , then @xmath0 is not satisfiable and therefore has no frozen variables .",
    "+ suppose now without loss of generality @xmath311 is satisfiable and that @xmath312 is not , then @xmath697 and obviously at least all of the @xmath250 s ( @xmath687 ) are frozen .",
    "4 .   if @xmath640 } } \\subseteq { \\ensuremath{\\mathrm{d}}\\xspace}$ ] or @xmath642 } } \\subseteq { \\ensuremath{\\mathrm{r_1}}\\xspace}$ ] , then @xmath323 is @xmath328-complete because of lemma  [ lemma : conp_cases_fv ] .",
    "the only remaining case is @xmath698 } } \\subseteq { \\ensuremath{\\mathrm{r_2}}\\xspace}$ ]",
    ". then @xmath22-circuits are trivially satisfiable and therefore @xmath699 .",
    "the proof of the lower bound is similar to case [ efvdpcompletecases ] , but this time the reduction starts with @xmath700 , which is @xmath328-complete ( see theorem  [ thm : selectsat ] ) . since @xmath698}}\\subseteq { \\ensuremath{\\mathrm{r_1}}\\xspace}$ ] there is a @xmath684 such that @xmath16 is in @xmath348}}$ ] .",
    "let @xmath701 be a @xmath22-circuit with the variables",
    "let @xmath703 , @xmath704 and @xmath705 .",
    "observe that @xmath706 and therefore @xmath707 can be converted into equivalent @xmath22-circuits , because @xmath708}}$ ] and @xmath709 = { \\ensuremath{{\\mathrm{s}_{12}}}\\xspace}$ ] .",
    "+ if @xmath0 is unsatisfiable , then because of @xmath87 then @xmath707 is satisfiable only by setting @xmath419 to 1 for all @xmath710 .",
    "the same holds if @xmath0 has the all-1 assignment as only satisfying assignment because of @xmath706 .",
    "hence in both cases all @xmath419 are frozen .",
    "+ on the other hand , if there is an @xmath711 such that @xmath712 and @xmath713 then none of the @xmath250 s is frozen ( @xmath714 ) , since @xmath707 can be satisfied by just setting all the @xmath419 s to 1 .",
    "furthermore , for each @xmath715 holds @xmath716 , hence none of the @xmath717 s is frozen .    concerning the variant of the above problem , where the frozen variable is part of the input , we obtain the following classification :    [ thm : fv ]",
    "let @xmath22 be a finite set of boolean functions .    1 .",
    "if @xmath718 or @xmath395 , then @xmath316 is tractable , 2 .   else",
    "if @xmath719}}$ ] , then @xmath316 is @xmath676-complete , 3 .",
    "else @xmath316 is @xmath328-complete .",
    "if @xmath673 or @xmath395 , then the argumentations from theorem [ thm : existsfv].[existfrozenthmtractcase ] hold .",
    "we have seen in lemma  [ lemma : conp_cases_fv ] that if @xmath720 } } \\subseteq { \\ensuremath{\\mathrm{d}}\\xspace}$ ] or @xmath642 } } \\subseteq { \\ensuremath{\\mathrm{r_1}}\\xspace}$ ] , then @xmath316 is @xmath328-complete .",
    "this leaves the @xmath328-hardness of @xmath316 for @xmath22 such that @xmath615}}$ ] and the @xmath676-hardness of @xmath316 for all @xmath22 such that @xmath719}}$ ] to show .",
    "we reduce @xmath721 to @xmath722 ( @xmath723 to @xmath724 , resp . ) . for that , let @xmath0 be a circuit over the @xmath61-base @xmath725 ( over the @xmath91-base @xmath726 , resp . ) and",
    "let @xmath228 be the set of variables used in @xmath0 .",
    "build a circuit @xmath87 by taking a variable @xmath5 that is not contained in @xmath0 and replace every occurrence of @xmath1 in @xmath0 by @xmath5 .",
    "then @xmath727 is an @xmath621-circuit ( an @xmath680-circuit , resp . ) , which can only be satisfied by assignments that set @xmath5 to 1 .",
    "for all these assignments , @xmath727 is satisfied if and only if @xmath0 is satisfied . therefore @xmath728 ( @xmath729 , resp . ) if and only if @xmath730 ( @xmath731 , resp . ) .    to obtain a classification for the audit problem , we first note the following link between the complexity of the problem @xmath323 and the audit problem :    [ prop : efv_audit_relation ] let @xmath22 be an arbitrary set of boolean functions , then    1 .",
    "@xmath732 , and 2 .   if @xmath733 then @xmath734 .",
    "the classification now is as follows :    let @xmath22 be a finite set of boolean functions .    1 .",
    "if @xmath718 or @xmath395 or @xmath735 , then @xmath736 is tractable , 2 .   else @xmath736 is @xmath328-complete .    1 .",
    "since @xmath733 if @xmath348 } } \\subseteq { \\ensuremath{{\\mathrm{l}}}\\xspace}$ ] or @xmath348 } }      \\subseteq { \\ensuremath{\\mathrm{m}}\\xspace}$ ] ( proposition  [ prop : csat ] ) , the claim for such @xmath22 follows from proposition  [ prop : efv_audit_relation ] and theorem  [ thm : existsfv ] . if @xmath735 , a @xmath22-circuit is either not satisfiable or has always a frozen variable ,",
    "hence the problem is tractable .",
    "if @xmath737 or @xmath630 , every @xmath22-circuit is trivially satisfiable .",
    "therefore we can use proposition  [ prop : efv_audit_relation ] and theorem  [ thm : existsfv ] again .",
    "it remains to show that @xmath736 is @xmath328-hard if @xmath675}}$ ] .",
    "we will reduce the @xmath328-complete problem @xmath738 ( see proposition [ prop : csat ] ) to @xmath736 .",
    "the proof runs along the same lines as in theorem  [ thm : existsfv ] .",
    "take an @xmath22-circuit @xmath0 . since @xmath675}}$ ] there is a @xmath15 with @xmath739}}$ ] .",
    "define @xmath740 , where @xmath250 is a variable not occurring in @xmath0 for @xmath741 .",
    "if @xmath0 is not satisfiable then @xmath250 is frozen for @xmath742 . if @xmath0 is satisfiable by an assignment @xmath231 none of the variables from @xmath0 is frozen in @xmath87 , since @xmath87 can be satisfied by setting all the @xmath250 s to 1 .",
    "furthermore @xmath250 is not frozen for @xmath743 , because @xmath744 .",
    "we finish this section with a classification of the unique satisfiability problem .",
    "let @xmath22 be a finite set of boolean functions .    1 .",
    "if @xmath719}}$ ] , then @xmath745 2 .   else if @xmath615 } } \\subseteq { \\ensuremath{\\mathrm{r_1}}\\xspace}$ ] , then @xmath322 is @xmath328-complete 3 .   in all other cases",
    "@xmath322 is tractable .    1 .",
    "trivially @xmath746 for an arbitrary set @xmath22 of boolean functions .",
    "according to proposition [ prop : circ - property ] , @xmath747 we show that @xmath748 , which in turn will prove that @xmath749 for all @xmath22 such that @xmath719}}$ ] .",
    "let @xmath0 be a @xmath750-circuit and let @xmath5 be a variable not occurring in @xmath0 .",
    "let @xmath706 be the circuit obtained from @xmath0 in replacing every occurrence of 1 by @xmath5 . finally consider @xmath751 .",
    "observe , that since @xmath752 the circuit @xmath87 is an @xmath680-circuit and @xmath753 .",
    "2 .   if @xmath737 we have @xmath754 .",
    "hence for all @xmath755 holds @xmath756 and therefore the @xmath328-completeness for all @xmath22 with @xmath615 } } \\subseteq { \\ensuremath{\\mathrm{r_1}}\\xspace}$ ] follows by theorem [ thm : selectsat ] .",
    "3 .   for all @xmath631 or @xmath630",
    "the claim holds because as we have seen before any such circuit has at least @xmath516 satisfying assignments . if @xmath757 , then an @xmath6-ary @xmath22-circuit @xmath0 has more than one satisfying assignment if and only if there is an @xmath758 such that @xmath759 . if @xmath760 , then the number of satisfying assignments for every @xmath22-circuit can easily be determined using its linear normal form",
    "we now present our results for the enumeration problem .",
    "the analogous problem has been studied in the constraint context by nadia creignou , jean - jacques hbrard , henning schnoor , and ilka schnoor in @xcite . the counting problem ( i.e. , determine the number of solutions of a given circuit has been studied in  @xcite ) .    [ theorem : enumeration b formulas : main result ] let @xmath22 be a finite set of boolean functions .",
    "then the following holds :    1 .",
    "if @xmath718 , or @xmath672 , or @xmath761 , or @xmath762 then @xmath324 has a polynomial - delay enumeration algorithm .",
    "@xmath324 has no polynomial - total - time enumeration algorithm unless @xmath763 .",
    "note that since every polynomial - delay algorithm is also a polynomial - total - time algorithm , the above theorem implies that in the context of enumerating the solutions for @xmath22-formulas , the two notions coincide . in particular , the theorem completely classifies the `` efficient '' cases with respect to either of these notions .    1 .",
    "let us first examine the case where @xmath718 or @xmath672 . in this case",
    "it follows from proposition  [ prop : csat ] and figure  [ platt ] that the satisfiability problem for @xmath764-circuits can be solved in polynomial time .",
    "thus it is easy to see that the following algorithm has polynomial delay : let @xmath256 be a @xmath22-circuit .",
    "we first check if @xmath765 $ ] ( that is , the circuit resulting from @xmath0 when replacing all gates labeled @xmath766 with a gate computing the constant @xmath8-function ) is satisfiable , if yes , we recursively print the satisfying solutions of this circuit with the additional assignment @xmath767 we do the same for the analogously defined @xmath768.$ ] for a circuit without variables , we print the empty assignment .",
    "+ let us now consider the case where @xmath761 , or @xmath769 in this case , as we have seen in the proof of theorem [ thm : selectsat ] , we know that for any @xmath22-circuit @xmath0 and any assignment @xmath260 to the variables of @xmath770 if @xmath260 is no solution for @xmath0 , then @xmath280 is . this gives a polynomial - delay enumeration algorithm for the solutions of @xmath0 , by testing the set of all assignments in an appropriate order",
    ": let the variables of @xmath0 be @xmath702 , then use an arbitrary order , for example the lexicographical order , on the assignments @xmath260 with @xmath771 , and for each of the assignments considered , test if @xmath260 or @xmath280 satisfies the circuit . in the cases where the answer is `` yes , '' print the corresponding assignment .",
    "due to the above mentioned property , this gives at least one solution for each @xmath260 considered , since if @xmath260 is not a solution , then @xmath280 is .",
    "therefore , since it can be verified in polynomial time if a given assignment is a solution for the circuit , this clearly gives a polynomial delay algorithm .",
    "2 .   according to figure [ platt ] in order to complete the proof of the theorem it remains to show that if @xmath22 is such that @xmath772}}$ ] , then @xmath324 has no polynomial - total - time enumeration algorithm unless @xmath763 .",
    "we show that the existence of such an algorithm for @xmath22-circuits implies that @xmath614 can be decided in polynomial time .",
    "the theorem then follows from the proof of theorem  [ thm : selectsat ] , since there it was proven that @xmath614 is np - hard .",
    "+ let @xmath0 be a @xmath22-circuit .",
    "first check if the constant @xmath1-assignment is a solution of @xmath770 this can be done in polynomial time .",
    "let @xmath249 be @xmath1 if this is the case , and let @xmath249 be @xmath8 otherwise ( i.e. , if the constant @xmath1-assignment does not satisfy @xmath0 ) .",
    "clearly , @xmath0 has a solution different from the all-@xmath1-solution if and only if it has at least @xmath773 many solutions . using a a polynomial - total - time enumeration algorithm for @xmath22-circuits",
    ", this question can be decided as follows : + since @xmath773 can be at most @xmath633 , the time that a polynomial - total - time enumeration algorithm can spend for enumerating all of @xmath0 s solution is bounded by a polynomial in @xmath0 .",
    "therefore , we can simply start the algorithm , and wait if it finishes in this time .",
    "if it does , then its output is the full list of solutions for @xmath0 , and we obviously can decide if there is solution different from the constant-@xmath1-solution present in this list .",
    "if it does not finish in this time , then there are more than @xmath773 solutions , and thus there is one which is not the constant-@xmath1-solution .",
    "note that we deduce this fact solely from the observation that the algorithm runs longer than allowed for @xmath773 solutions , independent of any output the algorithm may have printed up to that time .    in the case of the existence of a polynomial - delay enumeration algorithm it is of interest to further examine the complexity of the enumeration when requiring the solutions to be output in lexicographic order .",
    "as observed in @xcite this further requirement can dramatically increase the complexity .",
    "we prove that this is indeed the case for some sets @xmath22 .",
    "[ prop : enumlex ] let @xmath22 be a finite set of boolean functions such that @xmath718 , or @xmath672 , or @xmath761 , or @xmath632 .    1 .",
    "if @xmath718 or @xmath672 , then there exists a polynomial - delay enumeration algorithm that produces all the solutions of a @xmath22-circuit in lexicographic order .",
    "else such an algorithm does not exist unless @xmath763 .",
    "observe that the enumeration algorithm described in the proof of theorem [ theorem : enumeration b formulas : main result ] when @xmath718 or @xmath672 produces the solutions in lexicographic order . according to figure [ platt ]",
    "it remains to consider the case where @xmath774}}$ ] or @xmath775}}$ ] .",
    "we prove that for any set @xmath22 , if one of these algorithms exists , then the satisfiability problem for @xmath776-circuits can be solved in polynomial time .",
    "the result then follows with proposition  [ prop : csat ] , since due to figure  [ platt ] , @xmath777}}={{\\mathrm{bf}}\\xspace},$ ] and therefore this problem is np - complete .",
    "we show how a polynomial - time decision algorithm for this problem can be obtained from a polynomial - delay enumeration algorithm for @xmath22-circuits that produces solutions in lexicographic order . to this end , let @xmath0 be a @xmath776-circuit . introduce a new variable @xmath778 , and construct the circuit @xmath87 , which is obtained from @xmath0 by replacing every occurrence of 0 by @xmath778 .",
    "then @xmath87 is a @xmath22-circuit .",
    "it is clear that @xmath0 has a solution if and only if @xmath87 is satisfiable and the lexicographically first solution of @xmath87 maps @xmath778 to @xmath222 which clearly finishes the proof , since the lexicographic order enumeration algorithm has to produce the first solution in polynomial time , or determine that none exists .",
    "in addition to the cases where the satisfiability problem for @xmath22-circuits is np - complete , and therefore efficient enumeration algorithms obviously can not be hoped for unless @xmath779 we also showed that in the cases where tractability of the satisfiability problem follows from a simple `` trick , '' like the knowledge that the all-@xmath1-assignment is a solution to the circuits , efficient enumeration algorithms do not exist .",
    "an interesting special case here is the case of self - dual circuits .",
    "the satisfiability problem again is easy , simply because any such circuit is always satisfiable .",
    "but the property of self - duality does not only give one solution , it guarantees that half of the possible assignments are solutions .",
    "therefore it is not surprising that these solutions also can be enumerated in an efficient way .",
    "however , since the property of self - duality does not say anything about the set of solutions where a given variable is set to @xmath8 , this does not help us to construct a lexicographical order enumeration algorithm .    given the above results and those on counting given in  @xcite , one can see that counting is `` harder '' than enumeration in the following sense : for all cases in which  @xcite gives a polynomial - time algorithm for the counting problem , we also obtain an efficient ( polynomial - delay ) algorithm for enumeration .",
    "the converse is not true : for monotone functions , efficient enumeration is possible , but counting can not be done in polynomial time , unless @xmath780 . when considering lexicographic enumeration algorithm , the picture is similar , with the notable exception of the clone of the self - dual functions : as already discussed above , enumeration is trivial for these functions . for a similar reason ,",
    "the counting problem is trivial here as well ( a self - dual function is satisfied by exactly half of its possible arguments ) .",
    "however , the self - dual property does not help in obtaining an algorithm for enumeration in lexicographic order .",
    "we have obtained complete classifications for the equivalence and isomorphism problems , the frozen variables problems , the unique satisfiability problem , the audit problem and the enumeration problem for boolean circuits .",
    "the classification into `` hard '' and `` easy '' classes can be refined such that the internal structure of the tractable cases becomes visible .",
    "for this , one has to use stricter reductions ( e.g. , logspace reductions or logtime projections ) , and one obtains problems complete for subclasses of @xmath294 . for some of our problems , this has been done in @xcite .",
    "we think it is interesting to observe that , e.g. , equivalence of obdds is decidable in polynomial time , while we identify here intractability for many clones in the lattice . as a consequence ,",
    "this shows that , if @xmath781 , in all these cases obdds provide a provably less succinct representation than boolean circuits .",
    "analogous remarks hold for cases of the other algorithmic tasks that we consider , where a difference in complexity between obdd representation and circuit representation appears .    in general , given a boolean function @xmath2 , it is @xmath782-hard to determine",
    "if it is in a clone @xmath22 ( if @xmath2 is given by a general circuit ; the problem becomes very easy if @xmath2 is given by truth - table , see @xcite ) .",
    "this might seem to destroy all relevance of our just discussed results .",
    "however , we would like to mention that in practice , circuits computing functions @xmath2 are synthesized in one way or the other , hence we know the minimal clone it belongs to , and thus , our tractability results are relevant .",
    "in this paper we studied the complexity of problems related to circuits .",
    "so it is natural to ask what can be said about the formula case . for this",
    "we define @xmath22-formulas as `` tree - like '' @xmath22-circuits or analogously as @xmath22-circuits , where all gates have a fan - out of at most @xmath1 .",
    "interestingly the study of @xmath22-formulas leads to different dichotomy - theorems .",
    "the main reason for this phenomenon is , that circuits can be regarded as a succinct representation of formulas .",
    "partial results in this direction have been obtained in @xcite .",
    "finally we would like to mention that another possible syntactic restriction of formula related problems is to consider generalized boolean cnf formulas , also known as csps , see @xcite .",
    "many results about the problems considered here have been obtained in the csp framework , see the survey @xcite .",
    "n.  creignou and h.  vollmer .",
    "constraint satisfaction problems : when does post s lattice help ?",
    "in nadia creignou , phokion  g. kolaitis , and heribert vollmer , editors , _ complexity of constraints _ , volume 5250 of _ lecture notes in computer science _ , pages 337 .",
    "springer , 2008 .",
    "h.  schnoor and i.  schnoor . enumerating all solutions for constraint satisfaction problems . in wolfgang thomas and pascal weil ,",
    "editors , _ proceedings of the 24th international symposium on theoretical aspects of computer science _ , pages 694705 , 2007 ."
  ],
  "abstract_text": [
    "<S> we study boolean circuits as a representation of boolean functions and consider different equivalence , audit , and enumeration problems . for a number of restricted sets of gate types ( bases ) we obtain efficient algorithms , while for all other gate types we show these problems are at least np - hard . </S>"
  ]
}