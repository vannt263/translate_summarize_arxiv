{
  "article_text": [
    "for the processing of large graphs , the _ graph streaming _ or _",
    "semi streaming _ model has been studied extensively in the last decade . in this model ,",
    "the graph is given as a stream of its edges meaning that only sequential access is possible .",
    "random - access memory ( ram ) is restricted to @xmath2 edges at a time .",
    "this makes the model non - applicable to problems where already the size of the solution can be larger than that . in the euler tour problem",
    ", we are looking for a closed walk in an undirected graph such that each edge is visited exactly once ( or we wish to determine that the graph does not admit such a walk ) . the solution size ( in the positive case ) can be of order @xmath3 , since it contains all edges of the graph .",
    "this problem hence calls for a relaxation of the graph streaming model .",
    "aggarwal et al .",
    "@xcite presented a less restrictive streaming model , called _ strsort - model_. it consists of alternating streaming and sorting passes .",
    "a streaming pass consists of a turing machine with local memory of size @xmath4 and two tapes . on one tape",
    ", the turing machine reads a sequence @xmath5 of @xmath6 items . on the other tape ,",
    "an output stream is written . on both tapes ,",
    "the turing machine can move only left - to - right . in a sorting pass , a turing machine with a global partial order sorts items on a tape according to this order and",
    "gives the sorted items as output .",
    "[ stso ] strsort@xmath7 is the class of functions computable by the composition of up to @xmath8 streaming passes and @xmath9 sorting passes , each with memory @xmath4 , where :    * the local memory is maintained between streaming passes * streams produced at intermediate stages are of length @xmath10 , where @xmath0 is the length of the input stream .",
    "using only @xmath11 memory space and @xmath11 passes is sufficient for solving many graph problems in this streaming model , such as minimum spanning tree , maximal independent set and mincut  @xcite , hence the following definition of aggarwal et al . :",
    "pl - strsort : = @xmath12    demetrescu et al .",
    "@xcite showed for a few graph problems that the sorting steps are not necessary .",
    "in the so - called w - stream - model , which uses only the streaming steps ( i.e. strsort@xmath13 ) , they show a tradeoff between internal memory and streaming passes for undirected connectivity and single - source shortest paths in directed graphs .",
    "the euler tour problem is one of the fundamental problems of graph theory .",
    "given a graph @xmath14 , find an euler tour or state that the graph is not eulerian . in ram model finding euler tours in polynomial time",
    "is relatively easy , and there are multiple well known algorithms for that task .",
    "but the problem gets more complicated considering a big data environment in the form of a streaming or external memory model . for the latter ,",
    "an algorithm of atallah and vishkin @xcite for solving euler tours in pram is used .",
    "the algorithm has a running time of @xmath15 and uses @xmath16 processors , where @xmath0 is the number of vertices and @xmath4 is the number of edges in @xmath17 .",
    "since pram algorithms can be transferred to external memory @xcite , this result can be remodeled to get an external memory algorithm solving the euler tour problem in @xmath18 i / os . while the different problem `` euler tour on a tree '' is regarded in multiple papers ( e.g. @xcite , also with a transfer of pram algorithms ) , to the best of our knowledge the classical euler tour problem was not considered in a streaming model before .",
    "we give the 2-step strsort - algorithm _ eulerstr _ for finding an euler tour in a given graph @xmath14 with @xmath19 and @xmath20 .",
    "the first step is a single pass w - stream algorithm with memory space @xmath21 , that is , the bound which is usually used in the semi - streaming environment .",
    "the second step is a pl - strsort algorithm with @xmath22 alternating streaming and sorting passes and @xmath22 memory space .",
    "the stream length will be @xmath23 the whole time .",
    "we use the technique of atallah and vishkin for finding euler tours in parallel , but with two differences :    * the algorithm of atallah and vishkin uses memory space of a size inappropriate for a streaming environment .",
    "we limit the memory space needed in the different steps using the storage of suitable subgraphs and different standard techniques of the strsort model . * in contrast to the algorithm of atallah and vishkin , we do nt save the predecessor edge in the euler tour for every edge .",
    "we output the edges in the right order given by a found euler tour .",
    "this can be interesting for further processing the euler tour .",
    "let @xmath14 be an undirected graph with vertex set @xmath24 and edge set @xmath25 .",
    "a walk of length @xmath26 is an alternating sequence @xmath27 of vertices and edges , where @xmath28 for all @xmath29 .",
    "a trail is a walk without repeating edges , i.e. for all @xmath30 : @xmath31 .",
    "a circuit is a trail with the property @xmath32 , i.e. a closed trail .",
    "an euler tour is a circuit that uses each edge in @xmath25 exactly once .",
    "a graph that contains an euler tour is called eulerian . a path is a walk without repeating vertices or edges .",
    "a cycle is a circuit with @xmath33 for all @xmath30 .",
    "a rooted tree is a tree , in which one vertex @xmath34 is assigned as a root . in a rooted tree ,",
    "the depth of a vertex @xmath35 is the length of the unique path to its root .",
    "the vertex @xmath36 adjacent to @xmath35 , which is on the @xmath35-@xmath34-path is called predecessor of @xmath35 . if for an vertex @xmath37 , @xmath35 is the predecessor of @xmath37 , @xmath37 is called an successor of @xmath35 .",
    "an out - tree is a rooted , directed tree , where all edges point to the respective successor . for an directed edge @xmath38 , @xmath36 is called the tail , and @xmath35 the head of @xmath39 .",
    "for an undirected graph @xmath14 , each vertex is presented with a distinct number of the set @xmath40 with @xmath19 .",
    "the input stream consists of the @xmath4 edges of @xmath17 , given in random order .",
    "let @xmath14 be an undirected graph . unless said otherwise , we define @xmath19 and @xmath20 for the rest of the paper . the algorithm eulerstr will test , if the graph is eulerian , and if it is , will output directed edges in order @xmath41 with the following properties :    * @xmath42 for all @xmath43 * for all @xmath44 there is exactly one @xmath45 with @xmath46 * @xmath47 for all @xmath48 , and @xmath49    hence the sequence @xmath50 is a closed trail that uses each edge exactly once , i.e. an euler tour .",
    "we will often describe walks , circuits etc .",
    "analog to this as a sequence of directed edges instead of an alternating sequence of vertices and undirected edges .",
    "this way , when sorting edges we can sort by the label of either the head or the tail , and do nt have to consider the random inner order of undirected edges .",
    "[ remark ] we use a slight alteration of the algorithm of atallah and vishkin @xcite it consists of three general steps :    1 .",
    "partition the graph into @xmath51 edge - disjoint circuits @xmath52 .",
    "2 .   create an out - tree @xmath53 with @xmath54 and for all @xmath55 and @xmath56 share a common vertex in @xmath17 .",
    "iteratively : merge all circuits presented in @xmath57 by vertices with odd depth with the circuit presented in @xmath57 by the predecessor .",
    "step 1 is easily done in w - stream with @xmath58 memory space , because @xmath0 edges fit into internal memory , and every subgraph with @xmath0 edges contains at least one cycle .",
    "so iteratively , edges can be taken from the input stream until @xmath0 edges are present in internal memory .",
    "then , the edges of a circuit can be found , written on the output stream and deleted from internal memory . if there are edges left in internal memory after the w - stream step , the graph was not eulerian .",
    "alternatively , @xmath0 variables can be placed in internal memory , that keep track of the degree of the vertices .",
    "this is helpful because of the following well known result :    let @xmath14 be an undirected graph .",
    "then @xmath17 is eulerian , iff every vertex has even degree and the graph is connected .",
    "@xmath59    that step 2 and 3 with additional properties are giving us an euler tour is shown in the following lemma :    [ genlem ] let @xmath60 be an eulerian graph partitioned into @xmath51 circuits @xmath61 with @xmath62 and @xmath63 .",
    "@xmath64 is the length of the circuit @xmath65 .",
    "let @xmath53 be a rooted tree with @xmath54 , root @xmath66 and for @xmath67 : @xmath68 and @xmath56 share a common vertex in @xmath17 .",
    "for every @xmath69 , let @xmath70 be a vertex that the circuit @xmath65 shares with its predecessor .",
    "then the following recursive algorithm gives an euler tour :    s:=\\{2, ... ,q } ( global ) output vertex @xmath71 eul - suc(@xmath72 )    @xmath73    @xmath59    the route in the tree chosen by the algorithm describes an euler tour on a tree ( for definition see e.g. @xcite ) .",
    "* proof of lemma [ genlem ] : * because of the set @xmath74 , every vertex @xmath75 in @xmath57 is regarded at most once .",
    "when @xmath75 is regarded , with eulsuc(@xmath65 ) every edge of @xmath65 is part of the output at some point .",
    "now we have to show two things :    1 .",
    "the algorithm runs eulsuc(@xmath65 ) for every @xmath62 .",
    "the output is an circuit of @xmath17 .    with both properties",
    "it is shown , that the output is an euler tour .",
    "we use an induction over @xmath51 . for @xmath76 ,",
    "the algorithm starts with @xmath71 , and since @xmath72 is a circuit that contains all edges of @xmath17 in correct order , the output is an euler tour .",
    "now we assume , that both properties are correct for all eulerian graphs with partition of @xmath51 circuits .",
    "let @xmath17 be an eulerian graph with partition of @xmath77 circuits .",
    "let @xmath78 be a leaf in the rooted tree @xmath57 .",
    "then @xmath79 is a connected graph , therefore @xmath80 is connected . when a circuit is deleted from an eulerian graph and the result",
    "is connected , then this graph is also eulerian .",
    "this graph has a partition of @xmath51 circuits , so by assumption the algorithm works for @xmath81 .",
    "let @xmath82 ( @xmath83 ) be the predecessor of @xmath78 .",
    "then at some point the algorithm runs eulsuc(@xmath56 ) .",
    "furthermore there is a @xmath84 with @xmath85 . at eulsuc(@xmath56 ) with variable @xmath86 , the algorithm does nt continue with edge @xmath87 until all successors of @xmath82 are taken care of .",
    "so at some point eulsuc(@xmath88 ) starts , proving the first property . since @xmath78 is a leaf , the algorithm outputs all edges of @xmath88 at once in correct order , ending again at vertex @xmath89 .",
    "therefore , the algorithm combines an euler tour of @xmath81 with the circuit @xmath88 , resulting in an euler tour of @xmath17 , proving the second property . @xmath59",
    "lemma [ genlem ] shows that , if we have an eulerian graph , a partition into circuits @xmath52 and a rooted tree @xmath57 with the mentioned properties , a vertex @xmath75 in @xmath57 can be merged with his predecessor @xmath82 by combining the circuits @xmath65 and @xmath56 , i.e. inserting @xmath65 into @xmath56 at the right place . for this , we want to make sure that the first vertex of @xmath65 is a common vertex of @xmath56 , so we do nt have to change the order of @xmath65 before combining it with @xmath56 .",
    "notice that after the merging into a longer circuit @xmath90 , the first vertex of this circuit is still a common vertex of its predecessor , therefore we just have to take care of the order of all circuits once . since in the actual algorithm eulerstr",
    "we will store circuits as a sequence of directed edges , this translates to : the tail of the first directed edge of a circuit @xmath65 has to be the head of a directed edge of @xmath56 , where @xmath82 is the predecessor of @xmath75 in @xmath57 .",
    "in this section , we describe the one pass step of eulerstr with @xmath21 memory . in this pass ,",
    "we want to perform step 1 and 2 of remark 1 . for finishing step 2",
    ", we will have to use an additional strsort@xmath91-algorithm , which will be described in the following section .",
    "as mentioned , in the input stream we have the @xmath4 edges in random order .",
    "the vertices of @xmath17 are called @xmath92 . in internal memory",
    "we keep the following variables with @xmath93 space each :    * @xmath94 for @xmath95 , starting with @xmath96 for all @xmath95 * @xmath97 for @xmath95 , starting with @xmath98 for all @xmath95 * @xmath99 , the number of circuits found yet    additionally , we build a tree @xmath100 with @xmath10 vertices in internal memory .",
    "it will later be extended to the desired rooted tree @xmath57 .",
    "step 1 of remark [ remark ] is easily done as explained before .",
    "we read up to @xmath0 edges , find a circuit @xmath101 and output the edges in correct order in relation to the circuit as well as the direction in which the respective edge is traversed .",
    "these edges will get @xmath102 additional memory space and be called _",
    "edges_. in these edges , we store the label @xmath103 of the circuit the edge is in , and the position of the edge in the circuit sequence . occasionally",
    ", we also output _",
    "information edges_. the purpose and form of these information edges and the actual memory usage of the graph edges will be explained later .    for @xmath104 let @xmath105 be the graph consisting of all vertices and edges that are used in at least one circuit @xmath106 . for @xmath95 ,",
    "the variable @xmath107 keeps track of the connected component the vertex @xmath108 is currently in , considering the current graph @xmath105 .    the variable @xmath109 stores the label of the first circuit found that uses the vertex @xmath108 .    the tree @xmath100 is constructed as follows :",
    "we create a vertex @xmath110 every time a found circle @xmath111 has at least one of the following properties :    1 .",
    "@xmath98 for some @xmath95 with @xmath112 2 .",
    "@xmath113 for some @xmath114 with @xmath115    so for every circuit @xmath111 that contains a vertex not used before , or connects two connected components in the graph @xmath116 , a vertex @xmath117 in @xmath100 is created . for each property",
    ", there can be at most @xmath0 circuits fulfilling it , so the graph @xmath100 has @xmath10 vertices .",
    "edges in @xmath100 are build the following way : let @xmath118 be the graph that contains all vertices and edges used by the circuits @xmath119 . if a circuit @xmath120 is found , that has vertices of the connected components @xmath121 in @xmath118 , let @xmath122 with @xmath123 for all @xmath124 .",
    "let @xmath125 be the circuits stated in @xmath126 , i.e. the circuits that used the vertices @xmath127 for the first time .",
    "then the edges @xmath128 are added to @xmath100 .",
    "the vertices @xmath129 exist , because the circuits @xmath125 fulfill property 1 .",
    "* example : *    [ figure : example1 ]    figure [ fig1 ] gives an example on a graph with nine vertices @xmath130 .",
    "assume that the circuits found are the cycles @xmath131 in that order .",
    "@xmath72 fulfills property 1 , so a vertex @xmath66 in @xmath100 is created .",
    "we set @xmath132 and @xmath133 for @xmath134 .",
    "@xmath135 only has property 1 and shares the vertex @xmath136 with @xmath72 ( this information is stored in @xmath137 ) , so @xmath138 , @xmath139 and @xmath140 is created in @xmath100 with edge @xmath141 .",
    "furthermore @xmath142 and @xmath143 , because @xmath144 and @xmath145 are used for the first time . with @xmath146 , we set @xmath147 for @xmath148 and have a new connected component in @xmath149 with @xmath150 for @xmath148 .",
    "we place a vertex @xmath151 in @xmath100 without additional edges .",
    "@xmath152 only has property 2 and connects the components 1 and 3. vertices @xmath153 and @xmath154 are selected with @xmath155 and @xmath156 .",
    "we create a vertex @xmath157 , and since @xmath158 and @xmath159 , we connect the vertex with edges @xmath160 and @xmath161 in @xmath100 .",
    "the circuit @xmath162 has neither of the two properties , so there is no additional vertex in @xmath100 .",
    "however , to get the extended graph @xmath57 , we will store an information edge in the output stream , containing the information , that @xmath100 with vertex @xmath163 and edge @xmath164 ( selected because @xmath165 and @xmath166 ) would still be a tree .",
    "the result is shown in figure [ fig2 ]    [ figure : example2 ]    we have to show that the resulting graph is a tree . in that case , the graph can be stored in internal memory    after the streaming procedure , @xmath100 is a tree .",
    "we store two kinds of edges in the stream : graph edges , which are the actual edges in @xmath17 with additional information , and information edges which represent the tree @xmath57 . a graph edge @xmath167 of circuit @xmath65 has @xmath168 memory space and is at first set up as follows ( @xmath64 is the length of circuit @xmath65 ) : @xmath169    * @xmath170 is the original edge in @xmath17 . *",
    "@xmath171 and walking on @xmath172 , @xmath167 is passed from @xmath173 to @xmath174 .",
    "* @xmath26 is the placement of @xmath167 in @xmath172 in the order stored in the output stream . *",
    "later when merging circuits , the last two variables will help representing the predecessor circuit @xmath56 and the placement @xmath175 of the edge of @xmath56 , behind which the circuit @xmath65 will be inserted .",
    "information edges are the edges build in @xmath100 and later @xmath57 .",
    "they also contain additional information . since we need a rooted tree , variables concerning this",
    "are placed in these edges .",
    "they have @xmath176 memory space and are build as follows : @xmath177    * @xmath178 represents the edge @xmath179 and @xmath180 is the predecessor of @xmath181 in @xmath57 .",
    "* @xmath182 is the depth of @xmath180 in @xmath57 .",
    "* @xmath35 is a common vertex of @xmath172 and @xmath183 in @xmath17 . *",
    "similar to graph edges , @xmath184 will be the placement of the edge in @xmath172 , which has @xmath35 as its head , so when merging @xmath172 and @xmath183 , this can be done by inserting @xmath183 into @xmath172 behind this edge .",
    "but for now , this memory space will be used for storing different variables .",
    "@xmath185 for all @xmath95 @xmath186 for all @xmath95 @xmath187 @xmath188 , @xmath189 @xmath190 @xmath191 @xmath192 , @xmath193 @xmath194 @xmath195 write @xmath100 as rooted tree for every @xmath196 , let @xmath197 be the depth of @xmath75 in @xmath100 for every information edge @xmath198 in internal memory output information edge @xmath199    when algorithm circuit - find found a circuit @xmath65 in step 12 , it is tested if @xmath65 uses a vertex of @xmath17 for the first time ( new - test ) or connects connected components in @xmath200 ( comp - test ) . in new - test ,",
    "step 2 to 5 test if a vertex is used for the first time .",
    "if this is the case , @xmath201 indicates that a new vertex @xmath75 is created in the tree @xmath100 .",
    "step 6 to 13 test if the circuit uses a vertex used by a circuit @xmath56 before .",
    "if @xmath75 is created , an edge @xmath202 is stored and an information edge is output ( step 17 to 20 ) .",
    "@xmath203 keeps track of the connected components in @xmath200 touched by @xmath65 .",
    "if @xmath65 only uses new vertices , they will be a connected component in @xmath118 .",
    "this is noted in step 21 to 25 .",
    "algorithm comp - test starts if @xmath65 uses a vertex used before .",
    "let @xmath204 be the connected component of that vertex in @xmath200 .",
    "in comp - test it is tested if @xmath65 uses vertices , which are not in @xmath204 and not used for the first time . if this happens for the first time , and there is not already a vertex @xmath75 in @xmath100 , such a vertex is created in step 4 to 9 with the necessary graph and information edge . otherwise , just the graph and information edge is made . in step 17 to 21 the variables",
    "@xmath205 are updated .",
    "if after new - test and comp - test there is still no vertex @xmath75 in @xmath100 , in step 17 to 20 of circuit - find an information edge is output .",
    "the last entry is 1 , indicating that @xmath65 has no representative in @xmath100 . in step 19 , the circuit is output such that the tail of the first edge is a common vertex of the circuit noted in the information edge .",
    "the connectivity of @xmath17 is tested in step 28 to 32 .",
    "finally the rooted tree is build , and the stored information edges are updated and output .",
    "the information edges indicate a rooted tree @xmath57 like in lemma [ genlem ] .",
    "let us have two circuits @xmath65 , @xmath56 and an information edge @xmath206 , where @xmath75 is the predecessor of @xmath82 in @xmath57 , @xmath207 is the depth of @xmath75 in @xmath57 , @xmath208 is a common vertex of @xmath65 and @xmath56 in @xmath17 and @xmath209 is the position of an edge in @xmath65 which has @xmath35 as its head .",
    "if @xmath35 is the tail of the first edge representing @xmath56 , then the two circuits can be merged in the following way :    the graph edges of @xmath65 stay the same with @xmath210 for @xmath211 and the length of the circuit @xmath212 , and the graph edges of @xmath56 are changed to @xmath213 for @xmath84 . when sorting these edges by the size of the four last labels ( from left to right ) ,",
    "both circuits are placed in the same region because of the label @xmath65 .",
    "furthermore with label 4 , @xmath56 is placed between the edges @xmath214 and @xmath215 of @xmath65 , and since edge @xmath214 of @xmath65 has the common vertex @xmath35 as its head and @xmath216 , the resulting order is a circuit containing the edges of @xmath65 and @xmath56 . with the labels 5 and 6 , inner order of @xmath56 is maintained , even if multiple circuits are inserted at position @xmath214 of circuit @xmath65 .",
    "getting the informations needed for the graph edges of @xmath56 to be changed is the task of the information edge .",
    "but first we have to take care of a few things that could nt be finished in the last algorithm .",
    "we are missing a few key points for the merging to work :    1 .",
    "every circuit @xmath65 with @xmath217 was output before the predecessor in @xmath57 was decided .",
    "the orders of their graph edges have to be changed , so that the tail of the first edge is a common vertex with the predecessor in @xmath57 .",
    "2 .   the information edges with a vertex not contained in @xmath100 were output before the rooted tree was made , so they miss the information about the depth of the predecessor in @xmath57 .",
    "all information edges lack the last information : the position of the graph edge of the predecessor circuit , behind which the successor circuit will be inserted .",
    "wo nt be a problem .",
    "the algorithm will iteratively merge circuits and produce information edges belonging to a rooted tree @xmath218 with height about half the height of the original tree @xmath57 .",
    "at that point , the information edges will again miss the information about graph edge positions .",
    "we will now show strsort algorithms with respectively @xmath219 passes and @xmath15 memory space for each of problem 1 and 2 .",
    "analog to the strategies in @xcite and @xcite , the sorting step is used to put edges needing information next to edges having said information , so both can be put in internal memory for information transfer during the next streaming step .",
    "let @xmath56 be a circuit with @xmath220 . if @xmath221 , @xmath82 has a predecessor @xmath75 in @xmath100 .",
    "the information edge @xmath178 contains a common vertex @xmath35 of @xmath65 and @xmath56 , but the order of @xmath56 stored in the graph edges was nt changed according to @xmath35 during algorithm circuit - find .",
    "the order of @xmath56 can be changed as follows :    * sort the graph edges by circuit label and placement , and the information edges by successor circuit s.t . in the stream",
    "a circuit is stored directly behind the information edge with the regarding successor circuit . *",
    "while streaming a circuit @xmath56 , keep the information edge @xmath178 and the first graph edge @xmath222 of the circuit in internal memory . count the number @xmath223 of edges in the circuit , and find the placement @xmath214 of the edge with @xmath35 as its tail . store both informations in the last two entries of @xmath222 . *",
    "output and delete @xmath178 and @xmath222 after reaching the next circuit in the stream ( in most cases an information edge ) .",
    "continue with the next circuit .",
    "* sort the same way as before .",
    "* the necessary informations @xmath223 and @xmath214 are stored in @xmath222 . in the next streaming step , after reaching @xmath222 and storing these informations , output @xmath224 and delete @xmath222 . *",
    "read graph edges @xmath225 and output @xmath226 for @xmath227 .",
    "* delete @xmath214 and @xmath223 .",
    "continue with the next circuit .",
    "let @xmath56 be a circuit with @xmath228 .",
    "then there is exactly one information edge with second entry @xmath229 .",
    "let @xmath65 be the stored predecessor circuit and @xmath178 be the concerning information edge .",
    "then @xmath217 , and the last entry of @xmath178 is @xmath230. there are two cases :    * @xmath75 is the root of @xmath100 .",
    "then @xmath231 .",
    "* @xmath75 has a predecessor @xmath232 in @xmath100 .",
    "then the information edge concerning @xmath233 contains the depth @xmath234 of @xmath232 .",
    "it is @xmath235 .    with two simple stream steps and one sort step @xmath236 for some @xmath208 will get the needed information from @xmath237",
    "if existing :    * change @xmath236 to @xmath238 , i.e. change predecessor and successor , and mark that at the last variable of @xmath178 .",
    "* sort the information edges lexicographically according to the successor ( the second entry ) and the last entry .",
    "* the information edges with second entry @xmath239 will now appear consecutively on the next input stream . *",
    "if before @xmath238 , there is no edge with a @xmath240 as last entry and second entry @xmath239 , output a depth of @xmath240 , i.e. @xmath241 * if there is an edge with a @xmath240 as last entry , e.g. @xmath242 , then for all edges @xmath238 with @xmath239 as second entry output @xmath243      now we come to the merging step explained in section [ expl - merg ] .",
    "due to algorithm circuit - find and the two preparation steps , the graph edges and information edges have the following properties :    1 .   for",
    "the @xmath51 circuits found , let @xmath62 .",
    "then circuit @xmath65 of length @xmath64 is represented by the @xmath64 graph edges @xmath244 for @xmath245 and @xmath246 .",
    "2 .   let @xmath247 with @xmath248 and @xmath249 there exists an information edge with circuit entries @xmath239 and @xmath229 in that order ) .",
    "then @xmath57 is an out - tree on @xmath51 vertices .",
    "let @xmath250 be the height of @xmath57 .",
    "3 .   for @xmath67",
    "let @xmath178 be an information edge .",
    "then the edge has the form @xmath251 , where @xmath75 is the predecessor of @xmath82 in @xmath57 , @xmath197 is the depth of @xmath75 and @xmath35 is a common vertex of @xmath65 and @xmath56 .",
    "furthermore @xmath216 .",
    "the algorithm will output graph edges and information edges s.t .",
    "these properties are still fulfilled and the out - tree represented by the information edges has height @xmath252 .",
    "the number of graph edges will stay the same , still representing the edges of @xmath17 .",
    "after @xmath253 iterations of the algorithm , the underlying out - tree has a height of 0 , so the graph edges form a single circuit i.e. an euler - tour of @xmath17 .",
    "+    @xmath254    sort:- information edges in front of graph edges- information edges : @xmath255 or @xmath256 or @xmath257- order of graph edges does not matter + stream :    sort:- information edges with odd depth after every other edge , order does not matter- information edges , even depth : @xmath258 or @xmath259- graph edge and information edge with even depth : @xmath260 or @xmath261- graph edges : @xmath262 or @xmath263 or @xmath264 + stream :    sort:- graph edges : @xmath265 or @xmath266- information edges : @xmath267- information edge and graph edge : @xmath268 + stream :    sort:- information edges in front of graph edges , order does not matter- graph edges : @xmath269 or @xmath270 or @xmath271 or @xmath272 + stream : +    since we merge circuits @xmath65 with its predecessor circuit , iff @xmath197 is odd , the information edges with odd predecessor depth are not used in this iteration . instead",
    ", these edges have to be prepared for the next iteration .",
    "steps 5 to 9 are for that purpose .",
    "information edges with odd predecessor depth store the predecessor of the predecessor , because that will be the predecessor in the next iteration . in step 10 to 14 ,",
    "the information edges concerning circuit merges get to know the placement in which the successor circuit has to be inserted .",
    "the information edges share this knowledge with the graph edges in step 15 to 19 . in tree - merge2 ,",
    "the circuit insertions take place , and the graph edges are renamed according to their new circuit and placement .    including the preparation algorithms of section [ prep ] , algorithm tree - merge is a pl - strsort algorithm with @xmath15 alternating streaming and sorting passes and @xmath15 memory space .",
    "algorithm eulerstr , consisting of circuit - find , preparation steps and tree - merge has the following properties :    1 .   in an undirected graph",
    "it finds an euler - tour , if existing . 2 .",
    "the first part is a single step w - stream algorithm with @xmath58 memory space .",
    "the second part is a pl - strsort algorithm .",
    "the stream never exceeds a length of @xmath23 .",
    "we have presented an algorithm for finding euler tours in undirected graphs in the strsort model .",
    "it uses a single pass preparation step with @xmath273 memory space , followed by a pl - strsort algorithm . with this result ,",
    "various open questions appear :    * can the preparation step be replaced by an strsort algorithm using @xmath15 passes and memory space ? in this case , the euler tours problem could be solved entirely by a pl - strsort algorithm . however , as implied by ruhl ( @xcite ) finding cycles might be difficult . * are there more problems where a single pass with larger memory enables it to be solved by a pl - strsort algorithm ?",
    "such a preparation step might be a useful addition to the strsort model .",
    "* since the algorithm of atallah and vishkin can be used for directed graphs , can our algorithm be altered to work on them ?",
    "a direct transfer is not possible , because we ca nt find directed cycles in one pass with only @xmath58 memory space .",
    "we need to look for possibilities for finding directed cycles in the strsort model . * with the algorithm of atallah and vishkin an external memory algorithm can be designed which uses @xmath274 i / o steps for finding an euler tour . since for @xmath15 memory space",
    "the strsort model is more restrictive than the external memory model , can our technique be transferred to external memory to improve the current result ?",
    "again for this we have to run the preparation step with less memory space and probably more passes ."
  ],
  "abstract_text": [
    "<S> * abstract : * we present a first algorithm for finding euler tours in undirected graphs in the strsort model . this model is a relaxation of the semi streaming model . </S>",
    "<S> the graph is given as a stream of its edges and can only be read sequentially , but while doing a pass over the stream we are allowed to write out another stream which will be the input for the next pass . </S>",
    "<S> in addition , items in the stream are sorted between passes . </S>",
    "<S> this model was introduced by aggarwal et al . in 2004 . here </S>",
    "<S> we apply this model to the problem of finding an euler tour in a graph ( or to decide that the graph does not admit an euler tour ) . </S>",
    "<S> the algorithm works in two steps . in the first step , </S>",
    "<S> a single pass is conducted while a linear ( in the number of vertices @xmath0 ) amount of ram is required . in the second step , </S>",
    "<S> @xmath1 passes are conducted while only @xmath1 ram is required .    </S>",
    "<S> we use an alteration of the algorithm of atallah and vishkin from 1984 for finding euler tours in parallel . </S>",
    "<S> it finds a partition of edge - disjoint circuits and arranges them in a tree expressing their connectivity . </S>",
    "<S> then the circuits are merged according to this tree . in order to minimize the needed amount of ram </S>",
    "<S> , we evade the need to store the entire tree and use techniques suggested by aggarwal et al . to exchange information concerning the merging of circuits . </S>"
  ]
}