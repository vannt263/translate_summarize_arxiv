{
  "article_text": [
    "we consider two - player games on graphs with winning objectives formalized as a _ weak - parity _ objective  @xcite . in a two - player game",
    "@xcite , the set of vertices or states are partitioned into player  1 states and player  2 states . at player  1",
    "states player  1 decides the successor and likewise for player  2 .",
    "we consider weak - parity objectives , where we have a priority function that maps every state to an integer priority .",
    "play _ is an infinite sequence of states , and in a weak - parity objective the winner of a play is decided by considering the minimum priority state that appear in the play : if the minimum priority is even , then player  1 wins , and otherwise player  2 is the winner . the classical algorithm to solve weak - parity games with a naive running time analysis works in @xmath0 time , where @xmath1 is the number of priorities and @xmath2 is the number of edges of the game graph .",
    "since @xmath1 can be @xmath3 , in the worst case the naive analysis requires @xmath4 time , where @xmath5 is the number of states .",
    "we present an improved analysis of the algorithm and show that the algorithm works in @xmath6 time .",
    "we consider turn - based deterministic games played by two - players with _",
    "weak - parity _ objectives ; we call them weak - parity games .",
    "we define game graphs , plays , strategies , objectives and notion of winning below .    * game graphs . * a _ game graph _ @xmath7 consists of a directed graph @xmath8 with a finite state space @xmath9 and a set @xmath10 of edges , and a partition @xmath11 of the state space @xmath9 into two sets .",
    "the states in @xmath12 are player  1 states , and the states in @xmath13 are player  2 states . for a state @xmath14 , we write @xmath15 for the set of successor states of  @xmath16 .",
    "we assume that every state has at least one out - going edge , i.e. , @xmath17 is non - empty for all states @xmath14 .",
    "* plays . * a game is played by two players : player  1 and player  2 , who form an infinite path in the game graph by moving a token along edges . they start by placing the token on an initial state , and then they take moves indefinitely in the following way . if the token is on a state in  @xmath12 , then player  1 moves the token along one of the edges going out of the state .",
    "if the token is on a state in  @xmath13 , then player  2 does likewise .",
    "the result is an infinite path in the game graph ; we refer to such infinite paths as plays .",
    "formally , a _",
    "play _ is an infinite sequence @xmath18 of states such that @xmath19 for all @xmath20 .",
    "we write @xmath21 for the set of all plays",
    ".    * strategies . *",
    "a strategy for a player is a recipe that specifies how to extend plays .",
    "formally , a _ strategy _",
    "@xmath22 for player  1 is a function @xmath22 : @xmath23 that , given a finite sequence of states ( representing the history of the play so far ) which ends in a player  1 state , chooses the next state .",
    "the strategy must choose only available successors , i.e. , for all @xmath24 and @xmath25 we have @xmath26 .",
    "the strategies for player  2 are defined analogously .",
    "we write @xmath27 and @xmath28 for the sets of all strategies for player  1 and player  2 , respectively",
    ". an important special class of strategies are _ memoryless _ strategies .",
    "the memoryless strategies do not depend on the history of a play , but only on the current state .",
    "each memoryless strategy for player  1 can be specified as a function @xmath22 : @xmath29 such that @xmath30 for all @xmath25 , and analogously for memoryless player  2 strategies .",
    "given a starting state @xmath14 , a strategy @xmath31 for player  1 , and a strategy @xmath32 for player  2 , there is a unique play , denoted @xmath33 , which is defined as follows : @xmath34 and for all @xmath20 , if @xmath35 , then @xmath36 , and if @xmath37 , then @xmath38 .",
    "* weak - parity objectives .",
    "* we consider game graphs with weak - parity objectives for player  1 and the complementary weak - parity objectives for player  2 .",
    "for a play @xmath39 , we define @xmath40 to be the set of states that occur in  @xmath41 .",
    "we also define reachability and safety objectives as they will be useful in the analysis of the algorithms .",
    "1 .   _ reachability and safety objectives . _ given a set @xmath42 of states , the reachability objective @xmath43 requires that some state in @xmath44 be visited , and dually , the safety objective @xmath45 requires that only states in @xmath46 be visited .",
    "formally , the sets of winning plays are @xmath47 and @xmath48 .",
    "the reachability and safety objectives are dual in the sense that @xmath49 .",
    "_ weak - parity objectives .",
    "_ for @xmath50 , we let @xmath51 = { \\{0 , 1 , \\ldots , d-1\\}}$ ] and @xmath51_+={\\{1,2,\\ldots , d\\}}$ ] .",
    "let @xmath52 $ ] be a function that assigns a _",
    "@xmath53 to every state @xmath54 .",
    "the weak - parity objective requires that the minimal priority occurring is _",
    "even_. formally , the set of winning plays is @xmath55 .",
    "the complementary objective to @xmath56 is @xmath57 defined as the set @xmath58 of winning plays .    * winning strategies and sets . *",
    "given a game graph @xmath59 and an objective @xmath60 for player  1 , a strategy @xmath31 is a _ winning strategy _ for player  1 from a state @xmath16 if for all player  2 strategies @xmath32 the play @xmath61 is winning , i.e. , @xmath62 .",
    "the winning strategies for player  2 are defined analogously .",
    "a state @xmath14 is winning for player  1 with respect to the objective @xmath63 if player  1 has a winning strategy from @xmath16 .",
    "formally , the set of _ winning states _ for player  1 with respect to the objective @xmath63 in a game graph @xmath59 is @xmath64 analogously , the set of winning states for player  2 with respect to an objective @xmath65 is @xmath66 if the game graph is clear from the context we drop the game graph from the superscript .",
    "we say that there exists a memoryless winning strategy for player  1 with respect to the objective @xmath63 if there exists such a strategy from all states in @xmath67 ; and similarly for player  2 .",
    "[ thrm : determinacy ] for all game graphs @xmath7 , for all weak - parity objectives @xmath68 for player  1 , and the complementary objective @xmath69 for player  2 , the following assertions hold .    1 .",
    "we have @xmath70 .",
    "2 .   there exists a memoryless winning strategy for both players .    * closed sets and attractors . *",
    "some notions that will play key roles in the analysis of the algorithms are the notion of _ closed sets _ and _ attractors_. we define them below .    _ closed sets .",
    "_ a set @xmath71 of states is a _ closed set _ for player  1 if the following two conditions hold : ( a )  for all states @xmath72 , we have @xmath73 , i.e. , all successors of player  1 states in @xmath74 are again in @xmath74 ; and ( b )  for all @xmath75 , we have @xmath76 , i.e. , every player  2 state in @xmath74 has a successor in @xmath74 .",
    "a player  1 closed set is also called a _ trap _ for player  1 .",
    "the closed sets for player  2 are defined analogously .",
    "every closed set @xmath74 for player  @xmath77 , for @xmath78 , induces a sub - game graph , denoted @xmath79 .",
    "[ prop : closed ] consider a game graph @xmath59 , and a closed set @xmath74 for player  2 .",
    "for every objective @xmath63 for player  1 , we have @xmath80 .    _",
    "_ given a game graph @xmath59 , a set @xmath81 of states , and a player @xmath78 , the set @xmath82 contains the states from which player  @xmath77 has a strategy to reach a state in @xmath74 against all strategies of the other player ; that is , @xmath83 .",
    "the set @xmath84 can be computed inductively as follows : let @xmath85 ; let @xmath86 then @xmath87 .",
    "the inductive computation of @xmath88 is analogous .",
    "for all states @xmath89 , define @xmath90 if @xmath91 , that is , @xmath92 denotes the least @xmath93 such that @xmath16 is included in @xmath94 . define a memoryless attractor strategy @xmath31 for player  1 as follows : for each state @xmath95 with @xmath90 , choose a successor @xmath96 ( such a successor exists by the inductive definition ) .",
    "it follows that for all states @xmath89 and all strategies @xmath32 for player  2 , the play @xmath61 reaches @xmath74 in at most @xmath97 transitions .",
    "[ prop : attractor ] for all game graphs @xmath59 , all players @xmath78 , and all sets @xmath71 of states , the set @xmath98 is a closed set for player  @xmath77 .",
    "* notation . * for a game graph @xmath7 , a set @xmath81 and @xmath99 , we write @xmath100 to denote the game graph @xmath101 .",
    "* computation of attractors . * given a game graph @xmath102 and a set @xmath42 of states let us denote by @xmath103 the attractor for a player @xmath99 to the set @xmath44 .",
    "a naive analysis of the computation of attractor shows that the computation can be done in @xmath6 time , where @xmath2 is the number of edges .",
    "an improved analysis can be done as follows . for every state @xmath104",
    "we keep a counter initialized to  0 . whenever a state @xmath105 is included for the set of states in @xmath106 , for all states",
    "@xmath16 such that @xmath107 we increase the counter by  1 . for a state @xmath108",
    "if the counter is positive , then we include it in @xmath106 , and for a state @xmath109 if the counter equals the number of edges @xmath110 , then we include it in @xmath106 .",
    "let us consider the following set of edges : @xmath111 .",
    "the work of the attractor computation is only on edges with the start state in @xmath112 and end state in @xmath106 .",
    "that is the total work of attractor computation on edges is @xmath113 where @xmath114 .",
    "also the counter initialization phase does not require to initialize counters for all states , but only initializes a counter for a state @xmath16 , when some state @xmath115 gets included in @xmath106 for the first time .",
    "this gives us the following lemma .",
    "[ lemm : attrcompute ] given a game graph @xmath102 and a set @xmath42 of states let us denote by @xmath103 the attractor for a player @xmath99 to the set @xmath44 .",
    "the set @xmath106 can be computed in time @xmath116 , where @xmath117 .",
    "we first present the classical algorithm for weak - parity games and present an improved analysis to show that the algorithm has a linear - time complexity .",
    "we first present an informal description of the algorithm ; and a formal description of the algorithm is given as algorithm  [ algorithm : classical ] .",
    "* informal description of the classical algorithm .",
    "* we will consider a priority function @xmath118 $ ] .",
    "the objective @xmath63 for player  1 is the weak - parity objective @xmath56 and the objective for player  2 is the complementary objective @xmath119 .",
    "the algorithm proceeds by computing attractors and removing the attractors from the game graph and proceeds on the subgame graph . at iteration @xmath120 ,",
    "we denote the game graph by @xmath121 and the state space as @xmath122 and the set of edges of @xmath121 as @xmath123 . at iteration @xmath120 , the attractor set to the set of states of priority @xmath120 in @xmath121 ( i.e. , attractor to @xmath124 ) is computed .",
    "if @xmath120 is even , the set is included in the winning set for player  1 , and otherwise it is included in the winning set for player  2 and the set is removed from the game graph for the next iterations .",
    "aa = aa = aaa = aa = aa = aa = aa = aa a 2-player game graph @xmath7 and priority function @xmath125 $ ] .",
    "+ a partition @xmath126 of @xmath9 .",
    "@xmath127 ; @xmath128 ; + 2 . * for * ( @xmath129 ) + 2.1 .",
    "@xmath130 ; + 2.2 @xmath131 ; + 2.3 .",
    "@xmath132 ; +   + 3 . * return * @xmath126 ;        observe that in the game graph @xmath121 we have @xmath134 , i.e. , the priorities in @xmath121 are at least @xmath120 .",
    "let us denote by @xmath135 and @xmath136 the sets @xmath137 and @xmath138 at the end of iteration @xmath139 of algorithm  [ algorithm : classical ] .",
    "then for all @xmath140 we have @xmath141 and for all @xmath142 we have @xmath143 .",
    "we prove by induction that the following two conditions hold @xmath144 @xmath145 the base case is trivial and we now prove the inductive case . for @xmath120 even , for a state @xmath146 , the attractor strategy @xmath22 for player  1 in @xmath121 to reach @xmath124 and then choosing edges in @xmath122 , ensures that for all strategies @xmath147 for player  2 we have @xmath148 by the inductive hypothesis it follows that @xmath149 similarly , it follows for @xmath120 odd that @xmath150 .",
    "the desired result follows .",
    "* running time analysis .",
    "* in the running time analysis we will denote by @xmath5 the number of states , and by @xmath2 the number of edges in the game graph .",
    "the naive analysis of the running time of algorithm  [ algorithm : classical ] yields a @xmath151 running time analysis .",
    "this is because the loop of step  2 runs for @xmath1 times , and each iteration can be computed in @xmath6 time . since @xmath1 can be @xmath3 , the worst case bound of the naive analysis is @xmath4 , which is quadratic .",
    "we will now present a linear - time analysis of the algorithm .",
    "the two key issues in the running time analysis of the algorithm is to analyze the computation of the attractors ( step 2.1 of the algorithm ) and obtaining the target sets @xmath124 in the attractor computation .",
    "we now analyze the running time of the algorithm addressing the two above issues .",
    "* the attractor computations . *",
    "we first argue that the attractor computation over all iterations can be done in @xmath6 time .",
    "to prove this claim we observe that the sets @xmath152 computed at step 2.1 of the algorithm satisfies that @xmath153 for @xmath154 , ( since the set @xmath152 once computed is removed from the game graph for further iterations ) .",
    "let us consider the set @xmath155 of edges .",
    "then for @xmath154 we have @xmath156 . by lemma  [ lemm : attrcompute ]",
    "it follows that the @xmath120-th iteration of the attractor can be computed in @xmath157 time .",
    "hence the total time for attractor computations over all iterations is @xmath158 where the first equality follows since the edges @xmath159 and @xmath160 are disjoint for @xmath154 .",
    "* obtaining the target sets .",
    "* we will now argue that the target sets @xmath124 can be computed in @xmath3 time over all iterations . without loss of generality",
    "we assume that the set of states @xmath9 are numbered @xmath161 and the priority function @xmath125 $ ] is given as an array @xmath162 $ ] of integers such that @xmath163=p(i)$ ] .",
    "the procedure for obtaining the target sets will involve several steps . we present the steps below .    1 .   _ renaming phase .",
    "_ first , we construct a renaming of the states such that states in @xmath164 are numbered lower than @xmath165 for @xmath166 . here",
    "is a @xmath3 time procedure for renaming . 1 .",
    "consider an array of counters @xmath167 $ ] all initialized to  @xmath168 , and arrays @xmath169,a[1],\\ldots , a[d-1]$ ] ( each @xmath170 $ ] is an array and will contain states of priority @xmath120 ) .",
    "2 .   the first step is as follows .",
    "+ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ * for * ( @xmath171 ) + \\ { + @xmath172 $ ] ; @xmath173 $ ] ; + @xmath174[j]=i$ ] ; + @xmath175 = { \\mathsf{ct}}[k]+1 $ ] ; + } + _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ + this step assigns to the array in @xmath170 $ ] the set of states with priority @xmath120 ( in the same relative order ) and also works in @xmath3 time .",
    "the counter @xmath176 $ ] is the number of states with priority @xmath120 .",
    "the renaming step .",
    "_ we now construct arrays @xmath177 and @xmath178 in @xmath3 time to store renaming and the inverse renaming . for simplicity",
    "let us assume @xmath179=0 $ ] and the procedure is as follows .",
    "+ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ * for * ( @xmath180 ) + ( @xmath181 ; j:=j+1 $ ] ) + \\ { + @xmath182+j]= a[i][j]$ ] ; + @xmath183[j ] ] = { \\mathsf{ct}}[i-1]+j;$ ] + } + _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ + this creates the renaming such that for @xmath184 - 1]$ ] are states of priority  0 , then we have states of priority  1 for @xmath185 .. { \\mathsf{ct}}[1]-1]$ ] , and so on .",
    "the array @xmath178 stores the inverse of the renaming , i.e. , if @xmath186=j$ ] , then @xmath187=i$ ] . moreover , though it is a nested loop , since @xmath188=n$ ] this procedure also works in @xmath3 time . 2 .   in the renaming phase",
    "we have obtained in @xmath3 time a renaming in the array @xmath177 and the inverse renaming in the array @xmath178 . since renaming and its inverse , for a given state ,",
    "can be obtained in constant time and @xmath178 can be accessed in constant time .",
    "] we can move back and forth the renaming without increasing the time complexity other than in constants .",
    "we now obtain the set of states as targets required for the attractor computation of step 2.1 of algorithm  [ algorithm : classical ] in total @xmath3 time across the whole computation .",
    "first , we create a copy of @xmath177 as an array @xmath189 , and keep a global counter called @xmath190 initialized to  0 .",
    "we modify the attractor computation in step 2.1 such that in the attractor computation when a state @xmath191 is removed from the game graph , then @xmath192 $ ] is set to @xmath193 such that @xmath192=j$ ] , ( the entry of the array @xmath189 that represent state @xmath191 is set to @xmath193 ) .",
    "this is simply done as follows @xmath194=-1 $ ] .",
    "this is a constant work for a state and hence the extra work in the attractor computation of step 2.1 across the whole computation is @xmath3 .",
    "the computation to obtain the target for priority  @xmath120 ( i.e. , @xmath124 ) , denoted as procedure _ obtaintargets _ , is described below .",
    "the procedure _ obtaintargets _ is called by algorithm  [ algorithm : classical ] with parameter @xmath120 in step 2.1 to obtain @xmath124 .",
    "1 .   we have the global counter @xmath195 ( initialized to @xmath168 ) and the value of the global counter persists across calls to the procedure _",
    "obtaintargets_. we present the pseudocode for the procedure _ obtaintargets _ to obtain in an array @xmath44 the set @xmath124 of states .",
    "the procedure assumes that when _ _",
    "obtaintargets__@xmath196 is invoked we have @xmath197 , if @xmath198 , and for @xmath199 , we have @xmath200 $ ] . also , for all @xmath201 we have @xmath194=-1 $ ] ( the set of states in @xmath202 is set to @xmath193 in the attractor computation ) .",
    "the procedure invoked with @xmath120 returns @xmath44 as an array with states in @xmath124 , and sets @xmath203 $ ] .",
    "+ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ obtaintargets_(@xmath120 ) + @xmath204 ; + ( @xmath181 - 1 ; j:=j+1 $ ] ) + \\ { + ( @xmath205 \\neq -1 $ ] ) + \\ { @xmath206 = d[j+g]$ ] ; @xmath207 ; } + } + @xmath208 $ ] ; + @xmath44 .",
    "+ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ + the work for a given @xmath120 is @xmath209)$ ] and since @xmath210 , the total work to get the target sets over all iterations is @xmath3 ."
  ],
  "abstract_text": [
    "<S> we consider games played on graphs with the winning conditions for the players specified as _ weak - parity _ conditions . in weak - parity conditions the winner of a play is decided by looking into the set of states appearing in the play , rather than the set of states appearing infinitely often in the play . a naive analysis of the classical algorithm for weak - parity games yields a quadratic time algorithm . </S>",
    "<S> we present a linear time algorithm for solving weak - parity games . </S>"
  ]
}