{
  "article_text": [
    "finite - turn pushdown automata ( pdas ) were introduced in  @xcite by ginsburg and spanier .",
    "they are defined by fixing a constant bound on the number of switches between push and pop operations in accepting computation paths of pdas .",
    "the class of languages defined by these models is called the class of _ ultralinear languages _ and is a proper subclass of the class of context - free languages .",
    "it can be also characterized in terms of _ ultralinear _ and _ non - terminal bounded grammars _  @xcite .",
    "( in the special case of 1-turn pdas , i.e. , devices making at most one switch between push and pop operations , we get the class of linear context - free languages ) .    in  @xcite , descriptional complexity questions concerning finite - turn pdas",
    "were investigated , by showing , among other results , the existence of non - recursive trade - offs between pdas and finite - turn pdas . roughly speaking",
    ", this means that for any recursive function @xmath0 and for arbitrarily large integers @xmath1 , there exists a pda of size @xmath1 accepting an ultralinear language such that any equivalent finite - turn pda must have at least @xmath0 states .",
    "thus , a pda with arbitrary many turns may represent an ultralinear language more succinctly than any finite - turn pda and the savings in size can not be bounded by any recursive function .",
    "this phenomenon of non - recursive trade - offs was first observed between context - free grammars and deterministic finite automata ( dfas ) in the fundamental paper by meyer and fischer  @xcite .",
    "nowadays , many non - recursive trade - offs are known which are summarized , e.g. , in @xcite and @xcite . in the context of context - free languages non - recursive trade - offs",
    "are known to exist between pdas and deterministic pdas ( dpdas ) , between unambiguous pdas ( updas ) and dpdas , and between pdas and updas .",
    "recursive trade - offs are known , e.g. , between nondeterministic / alternating finite automata and dfas and between dpdas and dfas .",
    "interestingly , the witness languages used in @xcite were defined over an alphabet of two symbols and leave open the unary case which was recently solved in  @xcite by proving an exponential trade - off .",
    "thus , the non - recursive trade - off in the binary case turns into a recursive trade - off in the unary case .",
    "more generally , a careful investigation of the known cases of non - recursive trade - offs reveals that the used witness languages are not bounded resp .",
    "word - bounded , i.e. , they are not included in some subset of @xmath2 for some fixed words @xmath3 .",
    "so , the question arises whether the above non - recursive trade - offs can be translated to the bounded case or whether the structural limitation on boundedness is one that will allow only recursive trade - offs .",
    "in this paper , we tackle this question and restrict ourselves initially to the case of letter - bounded languages , namely , subsets of @xmath4 , where @xmath5 are pairwise distinct symbols .",
    "our main result shows that for these languages the trade - off between pdas ( or context - free grammars ) and finite - turn pdas becomes recursive .",
    "more precisely , in section  [ sec : cfg ] we first show that each context - free grammar in chomsky normal form with @xmath6 variables generating a letter - bounded set can be converted to an equivalent finite - turn pda whose size is @xmath7 .",
    "furthermore , the resulting pda makes at most @xmath8 turns where @xmath9 is the number of letters in the terminal alphabet . in a second step , an exponential trade - off",
    "is also shown for arbitrary context - free grammars .",
    "we prove in section  [ sec : lower ] that this result is tight by showing that the size of the resulting pda and the number of turns can not be reduced .",
    "note that this result is a generalization of the above - mentioned transformation of unary context - free grammars into finite automata which is presented in  @xcite . in section  [ sec : turns ] the investigation is further deepened by studying how to reduce the number of turns in a pda . in particular , given a @xmath10-turn pda accepting a subset of @xmath11 , where @xmath12 , we show how to build an equivalent @xmath13-turn pda .",
    "it turns out that in this case the trade - off is polynomial .",
    "this result is also used to prove the optimality of our simulation of pdas accepting letter - bounded languages by finite - turn pdas .",
    "finally , in section  [ sec : wb ] , we consider word - bounded languages . based on the constructions for letter - bounded languages in the previous sections , we are able to give similar constructions for word - bounded languages . thus , similar upper and lower bounds can be obtained for the general situation of word - bounded languages .",
    "we would like to remark that bounded context - free languages have very appealing properties concerning their decidability questions .",
    "it is known @xcite that equivalence and inclusion problems are decidable whereas both problems are undecidable for context - free languages and inclusion is an undecidable problem for deterministic context - free languages .",
    "furthermore , it is decidable whether a given context - free grammar generates a bounded language . in the positive case , the words @xmath14 can be effectively calculated . for the membership problem",
    "we know the cocke - younger - kasami algorithm which solves the problem in cubic time .",
    "it is shown in @xcite that letter - bounded context - free languages can be accepted by a certain massively parallel computational model .",
    "this result implies that the membership problem for letter - bounded context - free languages can be solved in quadratic time and linear space . since the membership problem for word - bounded context - free languages",
    "can be reduced to the membership problem for letter - bounded context - free languages by using suitable inverse homomorphisms , we obtain identical time and space bounds also in the word - bounded case .",
    "given a set @xmath15 , @xmath16 denotes its cardinality .",
    "let @xmath17 denote the set of all words over the finite alphabet @xmath18 , with the empty string denoted by @xmath19 , and @xmath20 .",
    "given a string @xmath21 , @xmath22 denotes its length . for the sake of simplicity",
    ", we will consider languages without the empty word @xmath19 .",
    "however , our results can be easily extended to languages containing @xmath19 .",
    "let reg denote the family of regular languages .",
    "we assume that the reader is familiar with the common notions of formal language theory as presented in  @xcite .",
    "a _ context - free grammar _ ( cfg , for short ) , is a 4-tuple @xmath23 , where @xmath24 is the set of variables , @xmath18 is the set of terminals , @xmath24 and @xmath18 are disjoint sets , @xmath25 is the initial symbol and @xmath26 is the finite set of productions .",
    "a production @xmath27 is denoted by @xmath28 .",
    "the relations @xmath29 , @xmath30 , and @xmath31 are defined in the usual way .",
    "given @xmath32 , if @xmath33 is a derivation of @xmath34 from @xmath35 , then we write @xmath36 .",
    "a useful representation of derivations of context - free grammars can be obtained using _",
    "parse trees_.    a parse tree ( or _ tree _ , for short ) for a context - free grammar @xmath37 is a labeled tree satisfying the following conditions :    1 .",
    "each internal node is labeled by a variable in @xmath24 .",
    "each leaf is labeled by either a variable , a terminal , or @xmath19 . however",
    ", if the leaf is labeled @xmath19 , then it must be the only child of its parent .",
    "if an internal node is labeled with a variable @xmath38 , and its children , from left to right , are labeled with @xmath39 , then @xmath40 is a production of @xmath37 .",
    "if @xmath41 is a parse tree whose root is labeled with a variable @xmath42 and such that the labels of the leaves , from left to right , form a string @xmath43 , then we write @xmath44 .",
    "furthermore , we indicate as @xmath45 the set of variables which appear as labels of some nodes in @xmath41 .",
    "the language generated by the grammar @xmath37 , i.e. , the set @xmath46 , is denoted by @xmath47 .",
    "the class of languages generated by cfgs is called the class of _ context - free languages . _",
    "it is well - known that the class of context - free languages properly contains the class of regular languages ( i.e. , the languages accepted by finite automata ) , but in the unary case , these two classes collapse @xcite .    a grammar @xmath23 is said to be in _ chomsky normal form _ if and only if its productions have the form @xmath48 or the form @xmath49 , with @xmath50 and @xmath51 .",
    "it is well - known that each context - free language not containing the empty word can be generated by a context - free grammar in chomsky normal form .",
    "a production @xmath52 of a context - free grammar @xmath53 is said to be _ right - linear ( left - linear , linear ) _ if @xmath54 ( @xmath55 , @xmath56 ) .    a context - free grammar @xmath53 is said to be _ ultralinear _",
    "@xcite if @xmath24 is a union of pairwise disjoint ( possibly empty ) subsets @xmath57 of @xmath24 with the following property . for each @xmath58 and each @xmath59",
    ", each production with left side @xmath38 is of the form @xmath60 , where either @xmath61 or @xmath62 .",
    "the family of languages generated by ultralinear grammars is called ultralinear languages and denoted by @xmath63 .    a context - free grammar @xmath53 is said to be _ non - terminal bounded _",
    "@xcite if there exists an integer @xmath10 with the following property : if @xmath64 , @xmath65 , @xmath66 , then @xmath67 has at most @xmath10 occurrences of variables .",
    "the _ rank _",
    "@xmath68 of a word @xmath69 is defined to be the largest integer @xmath70 such that there is a word @xmath71 , with @xmath70 occurrences of variables , such that @xmath72 .",
    "it is known @xcite that a context - free grammar @xmath37 is ultralinear if and only if @xmath37 is non - terminal bounded .    for each ultralinear grammar @xmath37 , the rank of @xmath37",
    "is defined as the largest integer which is the rank of one of the variables .",
    "let @xmath73 be an ultralinear language .",
    "the rank of @xmath73 , @xmath74 , is defined as zero , if @xmath73 is regular .",
    "if @xmath73 is nonregular , then @xmath74 is defined as the smallest integer which is the rank of some ultralinear grammar generating it .",
    "let @xmath75 be a pushdown automaton @xcite .",
    "configuration _ of a pushdown automaton is a triple @xmath76 where @xmath77 is the current state , @xmath67 the unread part of the input , and @xmath78 the current content of the pushdown store .",
    "the leftmost symbol of @xmath78 is the topmost stack symbol .",
    "we write @xmath79 , if @xmath80 for @xmath81 , @xmath82 , @xmath83 , @xmath84 , and @xmath85 .",
    "the reflexive and transitive closure of @xmath86 is denoted by @xmath87 .",
    "the language accepted by @xmath88 with accepting states is @xmath89    a sequence of configurations of @xmath88 @xmath90 is called _ one - turn _",
    "@xcite if there exist @xmath91 such that @xmath92    a sequence of configurations @xmath93 is called _",
    "@xmath10-turn _ if there are integers @xmath94 with @xmath95 such that for @xmath96 the subsequences @xmath97 are one - turn , respectively . @xmath88 is a @xmath10-turn pushdown automaton if every word @xmath98 is accepted by a sequence of configurations which is @xmath10-turn .",
    "by @xmath99 we denote the family of languages accepted by @xmath10-turn pdas .",
    "the union of all @xmath10-turn pdas with fixed @xmath100 is the set of finite - turn pdas . the family of languages accepted is defined as @xmath101 .",
    "thus , @xmath10-turn pdas are allowed to make new turns not depending on the stack height .",
    "the following characterization of ultralinear languages by finite - turn pdas may be found in @xcite and @xcite , respectively .",
    "a language @xmath73 belongs to @xmath63 if and only if there is a @xmath102 such that @xmath73 is accepted by a @xmath10-turn pda .",
    "we want to consider in this paper pdas in a certain normal form .",
    "thus , we make , without loss of generality , the following assumptions about pdas ( cf .",
    "@xcite ) .    1 .   at the start of the computation",
    "the pushdown store contains only the start symbol @xmath103 ; this symbol is never pushed or popped on the stack ; 2 .   the input is accepted if and only if the automaton reaches a final state , the pushdown store only contains @xmath103 and all the input has been scanned ; 3 .",
    "if the automaton moves the input head , then no operations are performed on the stack ; 4 .",
    "every push adds exactly one symbol on the stack .",
    "the transition function @xmath104 of a pda @xmath88 then can be written as @xmath105 in particular , for @xmath106 means that the pda @xmath88 , in the state @xmath77 , with @xmath38 at the top of the stack , by consuming the input @xmath107 , can reach the state @xmath108 without changing the stack contents .",
    "@xmath109 ( @xmath110 , respectively ) means that @xmath88 , in the state @xmath77 , with @xmath38 at the top of the stack , without reading any input symbol , can reach the state @xmath108 by popping off the stack the symbol @xmath38 on the top ( by pushing the symbol @xmath111 on the top of the stack , without changing the stack , respectively ) .",
    "a _ descriptional system _",
    "@xmath112 is a recursive set of finite descriptors ( e.g. automata or grammars ) relating each @xmath113 to a language @xmath114 .",
    "it is additionally required that each descriptor @xmath113 can be effectively converted to a turing machine @xmath115 such that @xmath116 .",
    "the language family being described by @xmath112 is @xmath117 .",
    "for every language @xmath73 we define @xmath118 .",
    "a _ complexity measure _ for @xmath112 is a total , recursive , finite - to - one function @xmath119 such that the descriptors in @xmath112 are recursively enumerable in order of increasing complexity . comparing two descriptional systems @xmath120 and @xmath121 , we assume that @xmath122 is not finite .",
    "we say that a function @xmath123 , @xmath124 is an _ upper bound _ for the blow - up in complexity when changing from one descriptional system @xmath120 to another system @xmath121 , if every description @xmath125 of size @xmath1 has an equivalent description @xmath126 of size at most @xmath0 .",
    "we say that a function @xmath127 , @xmath128 is a _ lower bound _ for the trade - off between two descriptional systems @xmath120 and @xmath121 , if there is an infinite sequence @xmath129 and an infinite sequence @xmath130 of pairwise distinct languages @xmath131 such that for all @xmath132 there is a description @xmath125 for @xmath131 of size @xmath1 and every description @xmath126 for @xmath131 is at least of size @xmath133 .    according to the discussion in @xcite the size of a pda",
    "should be defined depending on the number of states , the number of stack symbols , the number of input symbols , and the maximum number of stack symbols appearing in the right hand side of transition rules . in this paper",
    ", we consider pdas in the above defined normal form over a fixed alphabet @xmath18 .",
    "thus , @xmath134 of a pda @xmath88 in normal form is defined as the product of the number of states and the number of stack symbols .",
    "it can be observed that this measure fulfills the above defined conditions on descriptional measures .",
    "the size of a finite automaton is defined to be the number of states .    as a measure for the size of a context - free grammar @xmath23 we consider the number of symbols of @xmath37 , defined as @xmath135 ( cf .",
    "@xcite ) . furthermore ,",
    "in the paper it will be useful also to consider the number of variables of @xmath37 , defined as @xmath136 ( note that this function in general is not a measure for the size ) .",
    "some general information on descriptional complexity may be found in @xcite .",
    "in this section , we study the transformation of cfgs into finite - turn pdas . our main result shows that given a grammar @xmath37 of size @xmath6 , we can build an equivalent finite - turn pda @xmath88 of size @xmath7 .",
    "furthermore , if the terminal alphabet of @xmath37 contains @xmath9 letters , then @xmath88 is an @xmath13-turn pda .",
    "the tightness of the bounds will be shown in section  [ sec : lower ] .",
    "for the sake of simplicity , we start by considering cfgs in chomsky normal form with the measure @xmath137 . at the end of the section , we will discuss the generalization to arbitrary context - free grammars , taking into consideration the size defined by the measure @xmath138 .    in the following we consider an alphabet @xmath139 and a cfg @xmath23 in chomsky normal form with @xmath6 variables , generating a subset of @xmath4 .",
    "without loss of generality , we can suppose that each variable of @xmath37 is _ useful _",
    ", i.e. , for each @xmath42 , there exist terminal strings @xmath140 , such that @xmath141 .",
    "[ lemma : a ] for each variable @xmath42 there exists an index @xmath142 , @xmath143 ( @xmath70 , @xmath144 , resp . ) such that if @xmath145 , with @xmath146 , then @xmath147 ( @xmath148 , resp . ) . furthermore , if there exists at least one derivation @xmath145 with @xmath149 , ( @xmath150 , resp . )",
    "then such an @xmath142 ( @xmath70 , resp . ) is unique .",
    "it is easy to see that if @xmath145 and @xmath151 contains at least two letters @xmath152 , with @xmath153 , then , because @xmath154 , the language generated by @xmath37 should contain a string not belonging to @xmath4 .",
    "hence , @xmath147 , for some @xmath143 .    now suppose that @xmath149 and @xmath155 . because @xmath156 , using the previous argument it is easy to conclude that @xmath157 .",
    "a similar argument can be given for the right part .",
    "for each variable @xmath38 such that @xmath145 , with @xmath158 , we denote by @xmath159 the unique pair @xmath160 of indices , given in lemma  [ lemma : a ] . on the other hand ,",
    "if for any derivation @xmath145 , the string @xmath161 is empty , then we define @xmath159 as the pair @xmath162 , and if for any derivation @xmath145 the string @xmath151 is empty , then we define @xmath159 as the pair @xmath163 .",
    "if there are no derivations of the form @xmath145 , then we leave @xmath159 undefined .    formally , @xmath164 for the sake of brevity",
    ", @xmath159 will be denoted also as @xmath165 , if defined .",
    "we now consider the relation @xmath166 on the set of possible borders defined as @xmath167 if and only if @xmath168 and if @xmath169 then @xmath170 , for all @xmath171 , with @xmath172 and @xmath173 .",
    "it is not difficult to verify that @xmath166 is a total order on the set of pairs of indices @xmath174 from @xmath175 , such that @xmath172 .    actually , we are interested in computing borders of variables belonging to the same derivation tree . in this case , either a variable is a descendant of the other in the tree , and then the interval defined by its border is inside the interval defined by the border of the other variable , or one variable is to the right of the other one , and then the corresponding interval is to the right of the other one .",
    "more formally , we can prove the following :    [ lemma : border ] let @xmath41 be a derivation tree and @xmath176 be two variables . if @xmath177 , then either :    \\(a ) @xmath178 , or    \\(b ) @xmath179 , @xmath180 , and @xmath181 .",
    "the case @xmath182 is trivial .",
    "thus , for the rest of the proof we suppose that @xmath183 .",
    "if @xmath38 and @xmath111 lie in @xmath41 on the same path from the root , then @xmath38 must be closer to the root than @xmath111 ( otherwise @xmath184 ) .",
    "it is immediate to conclude that in this case @xmath178 .",
    "otherwise , @xmath38 should appear in a path to the left of the path containing @xmath111 .",
    "this easily implies that @xmath185 .",
    "we consider the two subcases @xmath186 and @xmath180 .",
    "if @xmath186 then we get @xmath187 , so ( a ) holds . on the other hand , if @xmath180 then it is not possible that @xmath188 because this should imply , with @xmath177 , the contradiction @xmath189 .",
    "hence , @xmath190 that , with @xmath180 and @xmath181 , gives ( b ) .    a _ partial derivation tree _ ( or _ partial tree _",
    ", for short ) @xmath191 is a parse tree whose root is labeled with a variable @xmath38 and all the leaves , with the exception of one whose label is the same variable @xmath38 , are labeled with terminal symbols .",
    "given a partial tree @xmath191 , any derivation tree @xmath192 with @xmath193 can be `` pumped '' using @xmath194 , by replacing a node labeled @xmath38 in @xmath41 with the subtree @xmath194 . in this way , a new tree @xmath195 is obtained , where @xmath196 , such that @xmath197 , @xmath198 , and @xmath199 .",
    "moreover , @xmath200 .    on the other hand , any derivation tree producing a sufficiently long terminal string can be obtained by pumping a derivation tree of a shorter string with a partial tree .",
    "this fact , which is essentially the pumping lemma of context  free languages ( see , e.g. , @xcite ) , is recalled in the following :    [ lemma : pump ] let @xmath192 be a derivation tree of a string @xmath201 . if @xmath202 then we can write @xmath203 , such that @xmath204 , there is a tree @xmath205 , a variable @xmath206 and a tree @xmath207 such that @xmath208 and @xmath209 , where @xmath6 is the number of the variables of the grammar @xmath37 .",
    "first of all , we recall that given a parse tree of a string @xmath35 according to a context - free grammar @xmath37 in chomsky normal form , if the longest path from the root to a leaf in the tree has length @xmath10 ( measured by the number of edges ) , then @xmath210 ( see , e.g.,@xcite ) . using this property",
    ", we get that if @xmath202 then the tree @xmath192 must contain a path of @xmath211 edges from a node @xmath1 to a leaf . hence",
    ", this path must contain two nodes labeled with the same variable @xmath38 .",
    "this defines the decomposition of @xmath41 in @xmath212 and @xmath213 .",
    "again by the above property , the terminal string @xmath214 generated by the subtree rooted at @xmath1 has length bounded by @xmath215 .",
    "furthermore , @xmath216 , because the grammar is in chomsky normal form .",
    "hence @xmath217 .    by applying the pumping lemma several times",
    ", we can prove that any derivation tree can be obtained by starting from a derivation tree of a `` short '' string ( namely , a string of length at most @xmath218 ) and iteratively pumping it with `` small '' partial trees .",
    "furthermore , a sequence of partial trees can be considered such that the sequence of borders of their roots is not decreasing .",
    "this fact will be crucial to get the main simulation presented in this section .",
    "more precisely , we are able to prove the following result :    [ lemma : der ] given a derivation tree @xmath192 of a string @xmath201 , with @xmath202 , for some integer @xmath219 there are :    * @xmath220 derivation trees @xmath221 , where @xmath222 , @xmath223 , @xmath224 , @xmath225 , @xmath226 ; * @xmath10 partial trees @xmath227 , where , for @xmath228 , @xmath229 , @xmath230 , and @xmath231 is obtained by pumping @xmath232 with @xmath233 .    furthermore , @xmath234    we can build the sequence from the end starting from @xmath41 and decomposing it in a tree @xmath212 and a partial tree @xmath194 , according to lemma  [ lemma : pump ] .",
    "this process can be iterated until a derivation tree @xmath235 producing a string of length bounded by @xmath218 is obtained .    in order to get a sequence of partial trees such that the sequence of the borders of the variables labeling their roots is not decreasing , at each step a partial tree is selected , among all possible candidates , in such a way that the border of its root is maximum .",
    "in other words , for @xmath228 , the variable @xmath236 labeling the root of the tree @xmath229 satisfies : @xmath237 we prove that with this choice @xmath238 , for @xmath239 .",
    "this is obvious if the partial tree @xmath229 of @xmath231 is also a partial tree of @xmath240 , namely , it belongs to the set of candidates when @xmath241 is chosen to reduce @xmath240 .",
    "if this is not the case , then @xmath240 should contain a partial tree @xmath242 , with @xmath243 , such that , after removing @xmath241 , @xmath244 is reduced in @xmath231 to @xmath233 .",
    "it can be observed that in @xmath240 such a reduction is possible only if the root @xmath245 of @xmath241 is a descendant of the root @xmath236 of @xmath244 .",
    "hence , in @xmath240 the terminal string generated by the subtree whose root , labeled @xmath245 , coincides with the root of @xmath241 , must be a factor of the terminal string generated by the subtree whose root , labeled @xmath246 , coincides with the root of @xmath244 .",
    "this implies that @xmath247 .",
    "hence , @xmath238 .",
    "the language @xmath248 can be generated by a grammar in chomsky normal form with the following productions : @xmath249 note that @xmath250 , @xmath251 , and @xmath252 .",
    "it is easy to get a tree @xmath253 and three partial trees @xmath254 , @xmath255 , and @xmath256 .",
    "given integers @xmath257 , a derivation tree for the string @xmath258 can be obtained considering @xmath235 , and pumping it @xmath259 times with the tree @xmath244 , @xmath260 times with the tree @xmath261 , and @xmath262 with the tree @xmath263 .",
    "note that @xmath264 .",
    "lemma  [ lemma : der ] suggests a nondeterministic procedure which can be used to generate all the strings @xmath265 belonging to the language @xmath47 : at the beginning a derivation tree @xmath266 of a `` short '' string is selected .",
    "then the procedure enters a loop which is repeated a nondeterministically chosen number of times . at each iteration ,",
    "the tree @xmath41 so far considered is pumped with a nondeterministically chosen partial tree @xmath267 ( note that , by lemma  [ lemma : a ] , @xmath268 , @xmath269 ) such that @xmath38 is a variable occurring in @xmath41 .",
    "note that , to implement this strategy , the procedure does not need to remember the whole tree @xmath41 but only the set of variables occurring in it .",
    "the procedure is the following :    nondeterministically select a tree @xmath270 , +  with @xmath271 + @xmath272 , @xmath273 , @xmath274 , @xmath275 + _ enabled _",
    "@xmath276 + _ iterate _ @xmath277 nondeterministically choose _ true _ or _ false _ + * whi***le * * _ iterate _ * do * + nondeterministically select a tree @xmath267 , with @xmath204 , +  and @xmath278_enabled _  // @xmath279 + @xmath280 + @xmath281 + @xmath277_enabled _",
    "@xmath282 + @xmath277 nondeterministically choose _ true _ or _ false _ + * endwhile * + output @xmath283 +    now , we will convert the above procedure into an @xmath13-turn pda recognizing the language generated by the grammar @xmath37 . for",
    "the sake of simplicity , let us start by describing the case @xmath284 with @xmath285 and @xmath286 , for each partial tree @xmath267 .",
    "the pda uses two bounded counters @xmath287 in order to remember the string @xmath288 generated by the initial `` small '' tree . in a preliminary phase ,",
    "the pda consumes @xmath289 occurrences of @xmath290 from the input tape , in order to verify that @xmath291 is a prefix of the input ( otherwise it stops and rejects ) .",
    "subsequently , the automaton starts the simulation of the loop above described where , at each iteration , a partial tree @xmath267 , with @xmath292 is used to pump the generated string . to this aim",
    ", the automaton reads @xmath285 from the input tape and pushes @xmath286 on the stack ( if @xmath161 is not a prefix of the remaining part of the input tape , then the automaton stops and rejects ) . at the end of the loop",
    ", the pushdown store will contain a string @xmath293 , for some @xmath294 .",
    "finally , the automaton accepts if and only if the remaining part of the input is @xmath295 .",
    "we can observe that the automaton so described simulates the derivation of a string and verifies its matching with the input string .",
    "for the occurrences of the letter @xmath290 , the matching is verified immediately , by comparing the generated factors with the input string ; for the occurrences of the letter @xmath296 , the verification of the matching is postponed : the generated factors are kept on the stack and compared with the input in the final phase .",
    "this strategy can be extended to the general case by pumping , according to lemma  [ lemma : der ] , with partial trees such that the sequence of the borders of their roots is not decreasing .",
    "more precisely , the pda implements the following nondeterministic procedure , whose correctness is proved in lemma  [ lemma : pda ] and theorem  [ theorem:3 - 5 ] .",
    "nondeterministically select a tree @xmath270 , +  with @xmath271 + read @xmath291 from the input + _ enabled _",
    "@xmath276 + @xmath297 // the `` work context '' + _ iterate _ @xmath277 nondeterministically choose _ true _ or _ false _ + * whi***le * * _ iterate _ * do * + nondeterministically select a tree @xmath267 , with @xmath204 , +  @xmath278_enabled _ , and @xmath298 + = @xmath299 * then * //new context to the right of the previous one + = @xmath300 * to * @xmath301 * do * + consumeinputandcounter(@xmath302 ) +   + = @xmath303 * to * @xmath304 * do * + consumeinputandcounter(@xmath302 ) + consumeinputandstack(@xmath302 ) +   + //@xmath305 : new context inside the previous one + = @xmath300 * to * @xmath304 * do * + consumeinputandcounter(@xmath302 ) +   +   + @xmath306 + read @xmath161 from the input + @xmath307 * then * push @xmath308 on the stack + read @xmath308 from the input +   + @xmath277_enabled _",
    "@xmath282 + @xmath277 nondeterministically choose _ true _ or _ false _ + * endwhile * + * for * = @xmath300 * to * @xmath301 * do * + consumeinputandcounter(@xmath302 ) + * endfor * + * for * = @xmath303 * to * @xmath9 * do * + consumeinputandcounter(@xmath302 ) + consumeinputandstack(@xmath302 ) + * endfor * + *",
    "if * the end of the input has been reached * then * accept + reject + * endif *    in the previous procedure and in the following macros , the instruction `` read @xmath308 from the input tape , '' for @xmath21 , actually means that the automaton verifies whether or not @xmath308 is a prefix of the next part of the input . if the outcome of this test is positive , then the input head is moved immediately to the right of @xmath308 , namely , @xmath308 is `` consumed , '' otherwise the machine stops and rejects .",
    "the macros are defined as follows :    consumeinputandcounter(@xmath302 ) : + * whi***le * * @xmath309 * do * + read @xmath310 from the input tape + @xmath311 + * endwhile * +    in order to prove that the pushdown automaton described in the previous procedure accepts the language @xmath47 generated by the given grammar @xmath37 , it is useful to state the following lemma :    [ lemma : pda ] consider one execution of the previous procedure .",
    "let @xmath312 be the tree selected at the beginning of such an execution .",
    "at every evaluation of the condition of the while loop , there exists a tree @xmath313 , for some @xmath314 , such that    * the scanned input prefix is @xmath315 ; * the pushdown store contains the string @xmath316 , where , for @xmath317 , @xmath318 and @xmath319 ; * for @xmath320 , @xmath321 ; * _ enabled _ @xmath322 .",
    "it is easy to see that at the first evaluation of the condition it holds that @xmath323 , @xmath324 , @xmath325 , @xmath326 , the scanned input prefix is @xmath327 and the pushdown store is empty , namely , it contains @xmath328 .",
    "we now suppose the statement to be true before the execution of one iteration and we show that it still holds true at the end of the iteration .",
    "let @xmath267 be the partial tree selected in the while loop . because @xmath193 , the derivation tree @xmath313 can be pumped with the partial tree @xmath194 , obtaining a new tree @xmath329 , with @xmath200 , where ( in the case @xmath330 ) @xmath331 , @xmath332 and @xmath333 for each @xmath334 and @xmath335 ( in the special case @xmath336 we have that @xmath337 ) .",
    "we now consider two subcases , corresponding to the selection in the while loop .",
    "_ case @xmath299 . _",
    "+ by lemma  [ lemma : border ] , this implies that @xmath338 and @xmath339 .",
    "first , we prove that for each @xmath302 , with @xmath340 , the stack can not contain the symbol @xmath310 , i.e. , @xmath341 .",
    "suppose , by contradiction , that the string @xmath78 contains at least one occurrence of @xmath310 .",
    "this symbol must have been pushed on the stack in a previous iteration , with `` work context '' @xmath342 , for some @xmath343 .",
    "since the procedure never removes variables from the tree , the variable used to pump the tree in such a previous iteration is also in the tree @xmath212 . moreover",
    ", the procedure chooses contexts in a nondecreasing order , so @xmath344 . by lemma",
    "[ lemma : border ] it turns out that either @xmath345 , or @xmath346 , @xmath347 , and @xmath348 .",
    "it is easy to observe that in both the cases we get a contradiction .",
    "hence , for any @xmath302 with @xmath340 , the stack does not contain the symbol @xmath310 , i.e. , @xmath349 .",
    "this implies that @xmath350 with @xmath351 and @xmath352 .",
    "now , we observe the operations on the input and on the stack that are performed during the execution of the body of the loop :    * the input factor @xmath353 is consumed ; * the string @xmath354 is popped off the stack ; * the input factor @xmath268 is consumed ; * if @xmath355 then the string @xmath269 is saved on the stack ( to be consumed later ) , otherwise it is consumed immediately .    by summarizing , in the case @xmath355 , at the end of the iteration the scanned input prefix is @xmath356 , the pushdown store contains the string @xmath357 , for each @xmath302 , @xmath340 , @xmath358 , and @xmath359 . with small changes we can deal with the case @xmath336 .",
    "_ case @xmath305 . _",
    "+ by lemma  [ lemma : border ] , this implies that @xmath360 .    if @xmath355 then the consumed input prefix is @xmath361 and the pushdown store contains the string @xmath362 , where @xmath363 . at this point",
    "it is not difficult to verify that the statement of the lemma is true .",
    "the subcase @xmath336 can be managed with easy changes .    as a consequence :    [ theorem:3 - 5 ] the pushdown automaton @xmath88 described by the previous procedure is an @xmath13turn pda accepting the language @xmath47 .",
    "first , we show that the number of turns of the pda @xmath88 defined in the above procedure is at most @xmath8 . to this aim",
    "we count how many times the automaton can switch from push operations to pop operations .    at each iteration of the while loop ,",
    "the automaton can perform push operations .",
    "pop operations are possible only by calling the macro consumeinputandstack .",
    "this happens first in the while loop , when the condition @xmath299 holds true , i.e. , when the new context @xmath165 is to the right of the previous context @xmath160 , and secondly after the end of the loop .",
    "let @xmath364 be the sequence of the contexts which in the computation make the above - mentioned condition hold true .",
    "hence , @xmath365 , that implies @xmath366 .",
    "if @xmath367 , then the pda @xmath88 makes at most @xmath368 turns in the simulation of the while loop and one more turn after the loop .",
    "so the total number of turns is bounded by @xmath8 .    now",
    ", suppose that @xmath369 .",
    "this implies that @xmath370 . before reaching the context @xmath371 , at most @xmath372 turns can be performed .",
    "when the automaton switches to the new context @xmath373 , it can make pop operations , by calling the macro consumeinputandstack(@xmath9 ) .",
    "this requires one more turn .",
    "after that , the automaton can execute further iterations , using the same context @xmath374 . by reading the procedure carefully",
    ", we can observe that it never executes further push operations .",
    "finally , at the exit of the loop , further pop operations can be executed ( consumeinputandstack ) .",
    "hence , the total number of turns is bounded by @xmath8 .    to prove that the language @xmath47 and the language accepted by the automaton defined in the above procedure coincide",
    "it is enough to observe that given a string @xmath375 , the procedure is able to guess the tree @xmath235 and the partial trees @xmath376 of lemma  [ lemma : der ] , recognizing in this way @xmath377 .",
    "conversely , using lemma  [ lemma : pda ] , it is easy to show that each string accepted by the procedure should belong to @xmath47 .",
    "[ cor : cfg ] given an alphabet @xmath139 , for any context  free grammar @xmath37 in chomsky normal form with @xmath6 variables generating a letter - bounded language @xmath378 , there exists an equivalent @xmath13-turn pda @xmath88 with @xmath7 states and @xmath379 stack symbols .",
    "the most expensive information that the automaton defined in the previous procedure has to remember in its state are the @xmath8 counters bounded by @xmath218 , and the set @xmath380 , which is a subset of @xmath24 . for the pushdown store an alphabet with @xmath381 symbols can be used . with a small modification , the pushdown store can be implemented using only two symbols ( one symbol to keep a counter @xmath382 and another one to separate two consecutive counters ) , and increasing the number of states by a factor @xmath9 , to remember what input symbol @xmath310 the stack symbol @xmath38 is representing .    using standard techniques",
    ", a pda of size @xmath1 can be converted to an equivalent cfg in chomsky normal form with @xmath383 variables .",
    "hence , we easily get :    [ cor : pda ] each pda of size @xmath1 accepting a subset of @xmath4 can be simulated by an equivalent @xmath13-turn pda of size @xmath384 .",
    "we now consider the situation when the given cfg is not necessarily in chomsky normal form .",
    "[ lemma : norm ] given a context - free grammar @xmath23 , there exists an equivalent context free grammar @xmath385 such that the length of the right hand side of any production belonging to @xmath386 is at most @xmath387 , @xmath388 , and the rank of @xmath389 coincides with the rank of @xmath37 .    without loss of generality",
    ", we suppose that for each variable @xmath38 in the set @xmath24 there is a production with @xmath38 on the left hand side .",
    "the set @xmath390 of variables of @xmath389 is defined by considering all variables in the set @xmath24 , plus some extra variables as defined below .",
    "the set of productions @xmath386 is defined as follows : we consider each production @xmath391 belonging to @xmath392 , with @xmath393 , @xmath394 :    * if @xmath395 , then the production @xmath391 belongs to @xmath386 . *",
    "if @xmath396 , then @xmath372 new extra variables @xmath397 are introduced in the set @xmath390 , and the following productions are added to @xmath386 : @xmath398 * no other productions are in @xmath386 .",
    "note that the construction of @xmath386 is similar to the last step in the classical reduction of general context - free grammars to chomsky normal form .",
    "it is easy to verify that @xmath37 and @xmath389 generate the same language .",
    "furthermore , by construction , the right hand side of each production of @xmath389 has length at most @xmath387 .",
    "we recall that each variable of @xmath24 appears on the left hand side of some production .",
    "furthermore , for each production @xmath28 , with @xmath399 , @xmath400 extra variables have been introduced in @xmath390 . hence : @xmath401 finally , it is immediate to observe that the definition of @xmath389 preserves the rank .",
    "[ cor : cfg2 ] given an alphabet @xmath139 , for any context  free grammar @xmath37 with @xmath402 and generating a letter - bounded language @xmath378 , there exists an equivalent @xmath13-turn pda @xmath88 with @xmath7 states and @xmath379 stack symbols .    at first",
    ", it can be observed that lemma  [ lemma : der ] is true not only for cfgs in chomsky normal form but also for cfgs whose productions have right hand sides of length at most 2 .",
    "thus , all arguments in section 3 are also true for such `` normalized '' cfgs .",
    "owing to lemma  [ lemma : norm ] , we then observe that any cfg @xmath37 can be converted to an equivalent cfg @xmath389 such that the length of the right hand side of any production belonging to @xmath389 is at most 2 and @xmath403 . with similar arguments as in corollary  [ cor : cfg ]",
    "we obtain the claim .",
    "we will discuss and present the extension of corollary  [ cor : cfg2 ] to the word - bounded case in section  [ sec : wb ] .",
    "by the results presented in section  [ sec : cfg ] , each context - free subset of @xmath4 can be accepted by an @xmath13-turn pda . in particular , corollary  [ cor : pda ]",
    "shows that the size of an @xmath13-turn pda equivalent to a given pda of size @xmath1 accepting a subset of @xmath4 , is at most exponential in the square of @xmath1 .    in this section",
    ", we further deepen this kind of investigation by studying how to convert an arbitrary @xmath10-turn pda accepting a letter - bounded language @xmath404 to an equivalent @xmath13-turn pda .",
    "it turns out that the increase in size is at most polynomial .",
    "all pdas we consider are in normal form .",
    "let us start by considering the unary case , i.e. , @xmath405 , which turns out to be crucial to get the simulation in the general case . in the following we consider a @xmath10-turn pda @xmath406 in normal form .",
    "then we know that at most one symbol is pushed on the stack in every transition .",
    "[ lem : nfa ] let @xmath88 be a pda accepting a unary language @xmath73 .",
    "let @xmath407 be the set of all words which are processed by 1-turn sequences @xmath408 of configurations starting with some stack height @xmath6 in a state @xmath409 and having @xmath38 as topmost stack symbol and ending with the same stack height @xmath6 in some state @xmath410 and having @xmath38 as topmost stack symbol .",
    "then , @xmath407 can be recognized by an nfa @xmath411 such that @xmath412 and @xmath413 .",
    "consider the following cfg @xmath37 with start symbol @xmath414 $ ] having the following productions .",
    "let @xmath415 , @xmath85 , and @xmath416 .",
    "1 .   @xmath417 \\rightarrow \\sigma [ p',z , q]$ ] , if @xmath418 , 2 .",
    "@xmath417 \\rightarrow \\sigma [ p , z , q']$ ] , if @xmath419 , 3 .",
    "@xmath417 \\rightarrow [ p',z',q']$ ] , if @xmath420 and @xmath421 , 4 .",
    "@xmath417 \\rightarrow \\epsilon$ ] , if @xmath422 .",
    "we want to describe how @xmath411 simulates a 1-turn sequence @xmath408 .",
    "we simulate the parts of @xmath408 with @xmath38 as topmost stack symbol and stack height @xmath6 with productions ( 1 ) and ( 2 ) .",
    "the first part from the beginning up to the first push operation is simulated using productions ( 1 ) .",
    "the second part starting at the end of the computation and going backwards up to the last pop operation is simulated with productions ( 2 ) .",
    "we may change nondeterministically between productions ( 1 ) and ( 2 ) .",
    "this is possible , since the input is unary .",
    "having simulated the parts of @xmath408 with stack height @xmath6 it is decided nondeterministically to proceed with simulating the parts of @xmath408 with stack height @xmath211 .",
    "productions ( 3 ) simulate a push operation and the corresponding pop operation .",
    "then , productions ( 1 ) and ( 2 ) can be again used to simulate the parts of @xmath408 with stack height @xmath211 .",
    "now , we iterate this behavior and simulate all computational steps in @xmath408 while the stack height simulated is growing . finally , we can terminate the derivation with productions ( 4 ) when the stack height has reached its highest level and all computational steps have been simulated .",
    "now , we construct an equivalent nfa @xmath423 as follows : @xmath424 and @xmath425 . for @xmath416",
    "the transition function @xmath426 is defined as :    1 .",
    "@xmath427 , if @xmath418 , 2 .",
    "@xmath428 , if @xmath419 , 3 .",
    "@xmath429 , if @xmath420 and @xmath421 ,    it is not difficult to observe that @xmath430 .",
    "[ cor:1turn ] let @xmath88 be some 1-turn pda accepting a unary language @xmath73 .",
    "then , an equivalent nfa @xmath411 can be constructed such that @xmath431 and @xmath413 .",
    "we can use the above construction , but additionally have to guess in a first step in which state a computation ends .",
    "therefore , we add a new start symbol @xmath15 and add productions @xmath432 $ ] for all @xmath433 . for the nfa construction",
    "we add a new initial state @xmath434 and the following rules @xmath435 , for all @xmath433 to @xmath411 .",
    "it is easy to observe that the parts of @xmath408 with stack height one can be again simulated with productions ( 1 ) and ( 2 ) .",
    "the remaining part of the simulation is identical to the above described construction .",
    "a subcomputation @xmath436 is called _ strong _ of level @xmath38 if it starts with some stack height @xmath6 and topmost stack symbol @xmath38 , ends with the same stack height @xmath6 and topmost stack symbol @xmath38 , and in all other configurations of @xmath436 the stack height is greater than @xmath6 .",
    "[ lem : nfa : turns ] let @xmath88 be some @xmath10-turn pda accepting a unary language @xmath73 .",
    "let @xmath407 be the set of all words which are processed by sequences @xmath408 of strong computations of level @xmath38 which , additionally , start in some state @xmath409 and end in some state @xmath410 .",
    "it can be observed that all words in @xmath407 are accepted with @xmath437 turns .",
    "then , @xmath407 can be accepted by an nfa @xmath411 such that @xmath438 and @xmath413 .",
    "the construction is very similar to the above described construction .",
    "additionally , we store the number of turns , which have to be simulated , in the fourth component of the variables",
    ". there are two cases how @xmath408 may look like . in the first case ( type i , cf .",
    "[ fig : types ] , left ) @xmath408 consists of at least two strong computations of level @xmath38 .",
    "we introduce a new production type ( 5 ) which is used to decompose a sequence of strong computations with @xmath439 turns into two subsequences with @xmath440 and @xmath441 turns , respectively .",
    "a resulting subsequence is then either again of type i and can be again decomposed with the new productions ( 5 ) , or it is of type ii , i.e. , it consists of one strong computation of level @xmath38 ( cf .",
    "[ fig : types ] , right ) .",
    "if this computation is 1-turn , it can be simulated with the productions ( 1 ) to ( 3 ) and finished with productions ( 4 ) .",
    "if it is not 1-turn , we can reduce it to a sequence of strong computations of level @xmath111 by using the productions ( 1 ) to ( 3 ) .",
    "then , the same analysis can be made for strong computations of level @xmath111 .",
    "the formal construction of the cfg @xmath37 is as follows .",
    "we consider the start symbol @xmath442 $ ] and the following productions .",
    "let @xmath415 , @xmath85 , and @xmath416 .    1",
    ".   @xmath443 \\rightarrow \\sigma [ p',z , q , i]$ ] , if @xmath418 , 2 .",
    "@xmath443 \\rightarrow \\sigma [ p , z , q',i]$ ] , if @xmath419 , 3 .",
    "@xmath443 \\rightarrow [ p',z',q',i]$ ] , if @xmath420 and @xmath421 , 4 .",
    "@xmath444 \\rightarrow \\epsilon$ ] , if @xmath422 , 5 .",
    "@xmath443 \\rightarrow [ p , z , r , i_1][r , z , q , i_2]$ ] , for all @xmath445 and @xmath446 such that @xmath447 .    it can be shown by an induction on the number of turns that @xmath37 generates @xmath407 .",
    "we can observe that all productions are right - linear except for productions ( 5 ) . since the last component of a variable @xmath448 $ ] is reduced in every application of a production ( 5 )",
    ", we can conclude that ( 5 ) is applied at most @xmath449 times .",
    "thus , every sentential form contains at most @xmath302 variables .",
    "thus , we can construct some nfa simulating the single derivation steps by representing all variables of a sentential form in its state .",
    "a rough estimation of the number of states is then @xmath450    we now want to do some finer estimation and will obtain @xmath451 as upper bound . to this end , we observe that a simulation of a production ( 5 ) increases the number of variables in the current state of the nfa by one and that a simulation of a production ( 4 ) at the end of some 1-turn computation decreases the number of variables by one .",
    "thus , our strategy is to apply productions of type ( 4 ) as soon as possible .",
    "now , whenever an application of a production ( 5 ) has replaced a variable @xmath443 $ ] by two variables @xmath452 $ ] and @xmath453 $ ] , then the derivation of the variable with the lower number of remaining turns is simulated .",
    "this makes sure that the total number of variables in a state is as small as possible .",
    "the worst case which can occur in this context is that in every application of a production ( 5 ) the number of turns is divided into two equal parts .",
    "this may happen at most @xmath454 many times .",
    "thus , the size of the nfa can be estimated as follows    @xmath455    finally , it can be observed that the last component in a tuple @xmath443 $ ] may be removed , since the maximum number of possible turns only depends on @xmath456 .",
    "this may save the constant factor @xmath302 in the above estimation .",
    "[ cor : nfa ] let @xmath88 be some @xmath10-turn pda accepting a unary language @xmath73 .",
    "then , an equivalent nfa @xmath411 can be constructed with @xmath457 and @xmath413 .",
    "observe that an accepting computation in @xmath88 is a sequence of strong computations of level @xmath103 starting in @xmath458 and ending in some accepting state .",
    "now , we are able to consider the general case , i.e. , @xmath459 and start with some definitions .    given the alphabet @xmath139 , we define the set @xmath460 as follows @xmath461    it is easy to show that the cardinality of @xmath460 is @xmath462 .",
    "let @xmath463 be some string .",
    "then @xmath464 denotes the projection to the first symbol of @xmath67 and @xmath465 denotes the projection to the last symbol of @xmath67 .",
    "for example , let @xmath466 .",
    "then , @xmath467 and @xmath468 .",
    "[ thm : kturn ] let @xmath88 be some @xmath10-turn pda accepting a letter - bounded language @xmath469 . then",
    ", an equivalent @xmath13-turn pda @xmath411 can be constructed such that @xmath470 and @xmath413 .",
    "it has been shown in the previous section that any @xmath469 can be accepted by an @xmath13-turn pda . if @xmath73 is accepted by a @xmath10-turn pda such that @xmath12 , then some turns are in a way `` not necessary . '' we will show in this proof that this finite number of additional turns takes place within unary parts of the input , i.e. , while reading some input @xmath471 with @xmath472 . then , with the help of the construction of lemma  [ lem : nfa : turns ] , these parts can be accepted by nfas and hence do not affect the stack height in the construction of an @xmath13-turn pda accepting @xmath73 .",
    "the construction is similar to the constructions of the previous two lemmas .",
    "additionally , we introduce a fifth component of the variables in which some element @xmath473 is stored .",
    "if @xmath474 ( @xmath475 ) , this means that the variable can only produce terminals @xmath476 .",
    "if @xmath477 ( @xmath478 ) , then such a variable can only produce sentential forms which start with terminals @xmath476 and end with terminals @xmath310 .    for the construction",
    "we first consider a context - free grammar @xmath37 with start symbol @xmath15 and having the following productions .",
    "let @xmath415 , @xmath85 , @xmath479 such that @xmath480 , @xmath481 , and @xmath482 .",
    "1 .   @xmath483 \\rightarrow \\overline{a } [ p',z , q , i , ab]$ ] , if @xmath484 , 2 .",
    "@xmath483 \\rightarrow [ p , z , q',i , ab ] \\overline{b}$ ] , if @xmath485 , 3 .",
    "@xmath483 \\rightarrow [ p',z',q',i , ab]$ ] , if @xmath486 as well as @xmath421 , 4 .",
    "@xmath487 \\rightarrow \\epsilon$ ] , if @xmath422 , for all @xmath488 , 5 .",
    "@xmath483 \\rightarrow [ p , z , r , i_1,u][r , z , q , i_2,v]$ ] , for all @xmath445 , @xmath446 such that @xmath447 , @xmath489 , @xmath490 , @xmath491 , and @xmath492 , 6",
    ".   @xmath483 \\rightarrow ( [ p , z , r , i_1,a],[r , z , q , i_2,v])$ ] , for all @xmath445 , @xmath446 such that @xmath447 , @xmath492 , 7 .   @xmath483 \\rightarrow ( [ p , z , r , i_1,u],[r , z , q , i_2,b])$ ] , for all @xmath445 , @xmath446 such that @xmath447 , @xmath491 . 8 .   @xmath493 $ ] for all @xmath433 , @xmath494 , and @xmath488 ,    the productions ( 1 ) to ( 4 ) , and ( 8) are defined similarly to the previous constructions . in the productions ( 5 ) to ( 7 )",
    ", a computation with @xmath439 turns is decomposed into two subcomputations with @xmath440 and @xmath441 turns , respectively .",
    "additionally , we differentiate whether we obtain subcomputations producing only one type of terminals or not .",
    "the former case is handled with productions ( 6 ) and ( 7 ) , for the latter case we have the productions ( 5 ) .",
    "moreover , we have to define productions for variables of the form @xmath495 $ ] with @xmath496 .",
    "such variables are from now on called `` unary '' variables . owing to lemma  [ lem : nfa : turns ] we know that the language @xmath497 can be accepted by some nfa @xmath38 having at most @xmath498 states .",
    "this nfa can be converted to some right - linear grammar @xmath499 with at most @xmath498 variables .",
    "now , the productions for a unary variable @xmath495 $ ] with @xmath496 are defined to be the productions of the corresponding right - linear grammar @xmath499 .    in order to finally get a pda making at",
    "most @xmath8 turns , we have introduced in the productions ( 6 ) and ( 7 ) some special variables of the form @xmath500,[p',z',q',i',v])$ ] which , at a first glance , are not natural and intuitive .    to derive such a variable @xmath500,[p',z',q',i',v])$ ] ,",
    "we first derive its first component @xmath495 $ ] with the above defined unary productions .",
    "observe that the resulting productions are right - linear . for variables having the form @xmath501)$ ]",
    "we add productions @xmath501)\\rightarrow [ p',z',q',i',v]$ ] .",
    "the remaining second component @xmath502 $ ] is then derived with the productions ( 1 ) to ( 7 ) if @xmath490 and with the above defined productions otherwise .    to derive a variable @xmath503,[p',z',q',i',b])$ ] , we first derive its second component @xmath504 $ ] with the above defined unary productions .",
    "observe that the resulting productions are left - linear .",
    "we add productions of the form @xmath503,\\epsilon)\\rightarrow [ p , z , q , i , u]$ ] and the remaining first component @xmath505 $ ] is then derived with the productions ( 1 ) to ( 7 ) if @xmath489 and with the above defined productions otherwise .",
    "we would like to remark that variables of the form @xmath500,[p',z',q',i',b])$ ] are treated as in the first case , i.e. , we start to derive the first component with unary productions and then derive the second component .",
    "it can be observed that @xmath37 generates @xmath506 . since all productions in @xmath37 are linear except those of type ( 5 )",
    ", the number of variables occurring in a sentential form can only be increased by applications of productions of type ( 5 ) .",
    "it can be observed that the maximum number of variables introduced by productions of type ( 5 ) is bounded by the maximum number of decompositions of the string @xmath507 into substrings @xmath508 such that , for @xmath509 , @xmath510 with @xmath511 and @xmath512 .",
    "it is easy to show that @xmath513 .",
    "thus , every sentential form contains at most @xmath8 variables which implies that @xmath37 is ultralinear of rank @xmath8 .",
    "we next convert @xmath37 to some equivalent one - state pda @xmath411 using the standard conversion algorithm as given for example in @xcite .",
    "since the rank of @xmath37 is @xmath8 , it can be observed that the maximum number of variables on the stack is bounded by @xmath8 .",
    "furthermore , any decreasing of the stack starts by deleting some variable from the stack .",
    "this action corresponds to an application of some production of type ( 4 ) in the grammar .",
    "thus , the number of turns in @xmath411 is bounded by the number of possible applications of productions of type ( 4 ) which is in turn bounded by the number of variables on the stack .",
    "thus , the number of turns in @xmath411 is bounded by @xmath8 .",
    "we now want to estimate the size of @xmath411 which is bounded by the number of variables of @xmath37 and the size of the alphabet @xmath18 .",
    "the number of variables of type @xmath505 $ ] is bounded by @xmath514 and the number of variables resulting from the unary productions is bounded by @xmath515 .",
    "we now want to estimate the number of variables resulting from variables of type @xmath516,[r , z , q , j , v])$ ] .",
    "observe that in each such variable @xmath517 or @xmath518 , respectively . since these unary parts are derived first , the number of variables resulting is bounded by the product of the number of variables resulting from unary productions and of the number of variables of type @xmath505 $ ] .",
    "thus , the number of variables resulting from variables of type @xmath516,[r , z , q , j , v])$ ] is bounded by @xmath519 which implies @xmath520 .",
    "finally , we convert @xmath411 to a pda in normal form .",
    "this may cause at most an additional quadratic blow - up .",
    "thus , we obtain @xmath521 as an upper bound .",
    "[ cor : kturn1 ] the trade - offs between finite - turn pushdown automata that accept letter - bounded languages are at most polynomial .",
    "in this section we show the optimality of the simulation of grammars generating letter - bounded languages by finite - turn pdas ( corollary  [ cor : cfg ] ) , and of some other simulation results presented in the paper . even in this case",
    ", the preliminary investigation of the unary case will be useful to afford the general case .",
    "[ lowerbound_unary ] for any integer @xmath522 , consider the language @xmath523 .    1 .",
    "@xmath131 can be generated by some cfg in chomsky normal form with @xmath524 variables .",
    "2 .   every nfa accepting @xmath131 needs at least @xmath525 states .",
    "3 .   for each @xmath219 ,",
    "every @xmath10-turn pda accepting @xmath526 is at least of size @xmath527 for some constant @xmath528 and any sufficiently large @xmath1 .    to prove ( 1 ) it is enough to observe that @xmath131 can be generated by the grammar @xmath37 with the following productions : @xmath529    the proof of ( 2 ) is trivial .",
    "finally , to prove ( 3 ) consider a @xmath10-turn pda @xmath88 of size @xmath530 accepting @xmath131 . due to corollary  [ cor : nfa ] we can construct an equivalent nfa of size @xmath531 for suitable constants @xmath532 .",
    "since @xmath533 , we obtain @xmath534 for some other constant @xmath535 .    from theorem  [ lowerbound_unary](3 ) , it turns out that for each integer @xmath9 the simulation result stated in corollary  [ cor : cfg ] is optimal .",
    "the witness languages are unary .",
    "hence , they can be also accepted by `` simpler '' devices , i.e. , finite automata or pdas with less than @xmath8 turns .",
    "we now show the optimality in a stronger form , by exhibiting , for each integer @xmath9 , a family of witness languages that can not be accepted with less than @xmath8 turns .",
    "[ lowerbound_m ] given the alphabet @xmath139 , for any integer @xmath522 consider the language @xmath536    1 .",
    "@xmath537 is generated by some cfg in chomsky normal form with @xmath538 variables .",
    "@xmath537 is accepted by an @xmath13-turn pda of size @xmath539 .",
    "3 .   for each integer @xmath540 , every @xmath10-turn pda accepting @xmath541 is at least of size @xmath527 for some constant @xmath528 and any sufficiently large @xmath1 .",
    "@xmath541 can not be accepted by any pda which makes less than @xmath8 turns .",
    "consider the grammar @xmath37 with the following productions :    * @xmath542 , * @xmath543 * @xmath544 * @xmath545 , for @xmath546 * @xmath547 , for @xmath394 .",
    "it is possible to verify that this grammar @xmath37 generates the language @xmath537 . in particular , observe that from each @xmath548 we can derive terminal strings only of the form @xmath549 , with @xmath550 , and from @xmath551 we can derive only the string @xmath552 . by observing that we can use the same variable for @xmath553 and @xmath120",
    ", we easily conclude that the total number of variables is @xmath538 .",
    "this proves ( 1 ) .",
    "furthermore , as an easy consequence , applying corollary  [ cor : cfg ] we get ( 2 ) .",
    "now , given @xmath540 , suppose to have a @xmath10-turn pda of size @xmath554 accepting @xmath537 . by replacing each move consuming a symbol @xmath476 , where @xmath555 , with an @xmath19-move , we get another @xmath10-turn pda with @xmath554 states accepting the language @xmath556 . using a slight modification of theorem  [ lowerbound_unary",
    "] , we can get that @xmath557 for some constant number @xmath528 and any sufficiently large @xmath1 .",
    "this proves ( 3 ) .",
    "we finally prove ( 4 ) . to this aim",
    ", we first prove that each context - free grammar which generates the following language @xmath73 must have rank at least @xmath8 : @xmath558 let @xmath37 be a grammar with @xmath6 variables which generates @xmath73 .",
    "we can suppose that the right hand side of each production of @xmath37 has length at most @xmath387 ( by lemma  [ lemma : norm ] this restriction preserves the rank , furthermore it can be easily seen that lemma  [ lemma : der ] , used in the following , holds even for there grammars ) .",
    "let @xmath559 and @xmath560 .",
    "given a derivation tree @xmath192 , consider an integer @xmath219 , derivation trees @xmath561 of strings @xmath562 , partial derivation trees @xmath229 , @xmath228 , according to lemma  [ lemma : der ] . for @xmath228 , let @xmath563 .",
    "note that @xmath564 , otherwise , by pumping @xmath232 ( which generates the string @xmath565 ) with the partial tree @xmath233 , the resulting string @xmath566 should not belong to @xmath73 .",
    "considering the definition of the relation @xmath166 between borders and lemma  [ lemma : border ] , this easily implies that for each pair of variables @xmath567 , either @xmath236 and @xmath568 have the same border or they lie on two different paths from the root of the tree @xmath41 .",
    "we now prove that for each @xmath569 , there is a variable @xmath570 such that @xmath571 , obtaining in this way @xmath8 variables belonging to different paths from the root of @xmath41 .",
    "suppose , by contradiction , that there is an index @xmath572 such that @xmath573 .",
    "hence , there is an index @xmath70 , @xmath574 , such that @xmath575 and @xmath576 ( @xmath577 in the case @xmath578 ) .",
    "the pumping process described in lemma  [ lemma : der ] starts from the tree @xmath235 , which generates a string @xmath579 .",
    "the number of occurrences of the letters @xmath580 can be incremented only by pumping with the partial trees @xmath581 , while the number of occurrences of the letters @xmath582 only by pumping with the partial trees @xmath583 .",
    "hence , the terminal string generated at the @xmath70th step should be @xmath584 for @xmath585 , let @xmath586 be the number of occurrences of letters @xmath476 and @xmath587 added during the pumping process , which leads from @xmath588 to @xmath589 , by those partial trees among @xmath581 such that the borders of their roots coincide with @xmath590 .",
    "it is easy to verify that @xmath591 , for @xmath585 .",
    "furthermore , by our choice of @xmath572 , it turns out that @xmath592 .",
    "this implies that @xmath593 .",
    "this is a contradiction , because @xmath594 .",
    "hence , we finally get that the tree @xmath41 contains @xmath8 variables @xmath595 which lie on different paths from the root , i.e. , there is a derivation of the form @xmath596 .",
    "thus , we conclude that the rank of the grammar @xmath37 is at least @xmath8 .    using a slight modification of the construction given in the proof of theorem  [ thm : kturn ]",
    ", we can show that from a @xmath10-turn pda it is possible to get an equivalent grammar of rank @xmath10 .",
    "this implies that if a @xmath10-turn pda accepts @xmath73 then @xmath540 .    to complete the proof , we observe that given a pda @xmath597 accepting the language @xmath598",
    ", we can build a pda @xmath88 which accepts @xmath73 by working in two phases : in the first phase @xmath88 simulates the moves of @xmath597 from the initial configuration , as long as @xmath597 consumes the input @xmath552 . in this phase , each move consuming the symbol @xmath290 is replaced by an @xmath19-move ( an internal variable counts , up to @xmath525 , the number of these moves ) . in this way , @xmath88 is able to reach , without consuming any input symbol , every configuration reachable by @xmath597 by consuming the input prefix @xmath552 . at this point ,",
    "the second phase can start . in this phase",
    "@xmath88 makes exactly the same moves as @xmath597 .",
    "it is easy to see that @xmath88 accepts the language @xmath73 .",
    "furthermore , if the given pda @xmath597 is @xmath10-turn , @xmath88 is @xmath10-turn , too .",
    "in conclusion , having proved that @xmath73 can not be accepted by @xmath10-turn pdas with @xmath367 , we can conclude that @xmath598 can not be accepted by @xmath10-turn pdas with @xmath367 , too .",
    "remark that we have considered so far only cfgs in chomsky normal form and the measure @xmath137 .",
    "it is easy to observe that we also obtain exponential trade - offs when considering the measure @xmath138 .",
    "this shows that the result of corollary  [ cor : cfg2 ] is also optimal . since",
    "@xmath541 can be accepted by a pda of size @xmath599 , we obtain that the result of corollary  [ cor : pda ] is nearly optimal .",
    "we complete this section by considering again the unary case .",
    "in particular , we prove that the upper bound stated in corollary  [ cor:1turn ] is tight .",
    "[ unary:1turn ] consider the language family @xmath600 for natural numbers @xmath601 .",
    "then each @xmath602 can be accepted by some 1-turn pda of size @xmath603 , but every nfa accepting @xmath602 needs at least @xmath604 states .",
    "a 1-turn pda accepting @xmath602 starts with checking whether the length of the input is divisable by @xmath1 in its states . at the same time , the input is stored in the stack .",
    "then the pda guesses that the whole input is read and checks whether the length of the input , which is stored on the stack , is divisable by @xmath524 .",
    "finally , the pda accepts if the whole input is read , divisable by @xmath1 and @xmath524 , and the stack is empty .",
    "otherwise , the input is rejected .",
    "it can be observed that such a pda is 1-turn , has one stack symbol ( apart from @xmath103 ) and has @xmath603 states .",
    "since @xmath605 , we can apply a result from @xcite and obtain the latter claim .",
    "in this section we study how to extend our results from the letter - bounded case to the word - bounded case .",
    "the idea is that of reducing the latter case to the former one . to this aim ,",
    "a large part of the section is devoted to prove that for fixed @xmath9 words @xmath606 , @xmath9 symbols @xmath5 and the homomorphism @xmath607 associating with each symbol @xmath476 the string @xmath608 , @xmath394 , and for each context - free grammar @xmath23 in chomsky normal form generating a subset of @xmath2 , we can get another context - free grammar @xmath609 whose number of symbols is linear in the number of symbols of @xmath37 , namely @xmath610 , and such that @xmath611 , i.e. , for all integers @xmath314 : @xmath612 if and only if @xmath613 .",
    "the construction is given in two steps : first we introduce a new grammar @xmath614 equivalent to @xmath37 . in such a grammar ,",
    "the variables of @xmath37 are marked with some indices which are useful to recognize where , in a derivation , a variable can produce the first symbol of one of the @xmath608 s .",
    "this will be useful to get from @xmath389 , in a second step , the required grammar @xmath609 .",
    "we start by considering the following set of variables : @xmath615\\mid a\\in v , 1\\leq l\\leq r\\leq m ,   0\\leq i\\leq|w_l| , 0\\leq j\\leq|w_r|\\}}.\\ ] ]    the definition is given in such a way that a variable @xmath616 $ ] can generate all terminal strings of the form @xmath617 generated by @xmath38 , such that @xmath618 , @xmath35 is the suffix of @xmath619 which starts in position @xmath620 and @xmath78 is the prefix of @xmath621 which ends in position @xmath302 . if @xmath622 , furthermore , the variable @xmath623 $ ] will be able to generate the factor of @xmath619 from position @xmath620 to position @xmath302 if @xmath38 is able to do this .    to this aim , we define the following productions :    1 .",
    "@xmath624\\rightarrow a$ ] , + for all @xmath42 such that @xmath49 is a production in @xmath392 , @xmath143 , @xmath625 , and @xmath626 , i.e. , @xmath627 is the symbol in position @xmath302 of @xmath619 .",
    "2 .   @xmath616\\rightarrow [ b , i , l , h , k][c , k , h , r , j]$ ] , + for all @xmath50 such that @xmath48 is a production in @xmath392 , @xmath628 , @xmath629 , @xmath630 , and @xmath631 .",
    "3 .   @xmath632\\rightarrow [ a , i , l , r,|w_r|]$ ] , + for all @xmath633 , @xmath629 .",
    "4 .   @xmath634\\rightarrow [ a,0,l , r , j]$ ] , + for all @xmath633 , @xmath631 .",
    "@xmath632\\rightarrow [ a , i , l , h,0]$ ] , + for all @xmath635 , @xmath629 . 6 .",
    "@xmath634\\rightarrow [ a , i,|w_h|,h , r , j]$ ] , + for all @xmath636 , @xmath631 .",
    "the initial symbol @xmath637 of @xmath389 is @xmath638 $ ] .",
    "the following lemma states the main property of the variables of the grammar @xmath389 and it is crucial in order to prove that @xmath389 is equivalent to @xmath37 :    for each variable @xmath616 $ ] of the grammar @xmath389 above defined and for each string @xmath639 , it holds that @xmath616{\\stackrel{\\star}{\\rightarrow}_{g'}}w$ ] if and only if @xmath640 , and    * either @xmath641 , with @xmath618 , * or @xmath622 , @xmath642 , and @xmath643 .",
    "we first prove the _ only if _ part .",
    "let @xmath644 be an integer such that @xmath616{\\stackrel{s}{\\rightarrow}_{g ' } } w$ ] .",
    "the proof is by induction on @xmath554 .    if @xmath645 then the derivation consists only of the production @xmath624\\rightarrow w_{l , j}$ ] .",
    "this implies that @xmath646 , @xmath622 , and @xmath647 .",
    "if @xmath648 then we have to consider several possibilities depending on which kind of production is used in the first step of the derivation .",
    "( the following list refers to the above defined productions ( 2 ) ,  , ( 6 ) : )    1 .",
    "@xmath616\\rightarrow [ b , i , l , h , k][c , k , h , r , j]$ ] : + hence @xmath649{\\stackrel{\\star}{\\rightarrow}_{g'}}w'$ ] , @xmath650{\\stackrel{\\star}{\\rightarrow}_{g'}}w''$ ] where @xmath651 .",
    "we observe that , by induction hypothesis , @xmath652 , @xmath653 , and then @xmath640 . the proof can be easily completed by considering the following subcases : * @xmath654 , @xmath655 , where @xmath656 and @xmath657 . by choosing @xmath658 , it turns out that @xmath659 and @xmath641 .",
    "* @xmath660 , @xmath661 , @xmath662 , and @xmath663 . then @xmath643 . *",
    "@xmath664 , @xmath665 , @xmath662 , and @xmath666 , or @xmath667 , @xmath668 , @xmath669 , and @xmath670 . in both these cases",
    ", we get that @xmath641 .",
    "2 .   @xmath632\\rightarrow [ a , i , l , r,|w_r|]$ ] : + hence @xmath671{\\stackrel{s-1}{\\rightarrow}_{g ' } } w$ ] . by induction hypothesis",
    "we get that @xmath640 . if @xmath672 , with @xmath673 , then @xmath674 , with @xmath675 .",
    "otherwise , @xmath622 and then @xmath674 , with @xmath676 .",
    "3 .   @xmath634\\rightarrow [ a,0,l , r , j]$ ] : + this case is similar to the previous one .",
    "4 .   @xmath632\\rightarrow [ a , i , l , h,0]$ ] : + hence @xmath677{\\stackrel{s-1}{\\rightarrow}_{g ' } } w$ ] and , by induction hypothesis , @xmath640 and @xmath674 for some @xmath678 . from @xmath679 , it turns out that @xmath618 .",
    "@xmath634\\rightarrow [ a,|w_h|,h , r , j]$ ] : + hence @xmath680{\\stackrel{s-1}{\\rightarrow}_{g ' } } w$ ] and , by induction hypothesis , @xmath640 and @xmath681 for some @xmath659 . from @xmath682 , it turns out that @xmath618 .",
    "we now prove the _ if _ part . even in this case",
    "the proof is by induction on the number @xmath554 of the steps of the derivation @xmath683 under consideration .    if @xmath645 then @xmath684 and @xmath685 must be a production in @xmath392 . we have to consider two cases :    * @xmath641 , with @xmath618 : + since @xmath684 ,",
    "it turns out that : * * either @xmath686 , @xmath676 , @xmath687 , and @xmath688 , or * * @xmath689 , @xmath676,@xmath690 , and @xmath691 , or * * @xmath692 , for some @xmath693 , @xmath690 , and @xmath688 .",
    "+ in the first case , the grammar @xmath389 should contain the production @xmath694\\rightarrow w$ ] .",
    "hence , using productions ( 5 ) , ( 3 ) , and ( 1 ) , we get : @xmath695=[a,|w_l|-1,l , r,0]&{{\\rightarrow}_{g'}}&[a,|w_l|-1,l , l,0]\\\\    & { { \\rightarrow}_{g'}}&[a,|w_l|-1,l , l,|w_l|]{{\\rightarrow}_{g'}}{w}.    \\end{aligned}\\ ] ]",
    "the second case is similar . in the third case , the grammar @xmath389 contains , by construction , the production @xmath696\\rightarrow w$ ] .",
    "hence , using productions ( 6 ) , ( 5 ) , ( 3 ) , ( 4 ) , we get the following derivation : @xmath695=[a,|w_l|,l , r,0]&{{\\rightarrow}_{g'}}&[a,|w_h|,h , r,0]\\\\    & { { \\rightarrow}_{g'}}&[a,|w_h|,h , h,0]{{\\rightarrow}_{g'}}[a,|w_h|,h , h,1]\\\\    & { { \\rightarrow}_{g'}}&[a,0,h , h,1]{{\\rightarrow}_{g'}}w .",
    "\\end{aligned}\\ ] ] * @xmath622 , @xmath642 , and @xmath643 : + this case is trivial .",
    "now suppose @xmath648 .",
    "the first production applied in the derivation of @xmath67 should be @xmath48 , for two variables @xmath111 and @xmath697 , such that @xmath652 , @xmath653 , and @xmath651 .",
    "as before , the proof is divided into two cases :    * @xmath641 , with @xmath618 : + we have to consider the following three possibilities : * * @xmath654 , @xmath655 , for some @xmath693 , @xmath630 , @xmath698 , and @xmath699 . by the inductive hypothesis",
    ", we obtain @xmath649{\\stackrel{\\star}{\\rightarrow}_{g'}}w'$ ] , @xmath650{\\stackrel{\\star}{\\rightarrow}_{g'}}w''$ ] .",
    "hence , @xmath616{\\stackrel{\\star}{\\rightarrow}_{g'}}w$ ] . *",
    "* @xmath662 , @xmath700 , for some @xmath701 , @xmath618 . by the inductive hypothesis",
    ", we obtain @xmath702{\\stackrel{\\star}{\\rightarrow}_{g'}}w'$ ] , @xmath703{\\stackrel{\\star}{\\rightarrow}_{g'}}w''$ ] .",
    "hence , @xmath616{\\stackrel{\\star}{\\rightarrow}_{g'}}w$ ] . * * @xmath669 @xmath670 , for some @xmath704 , @xmath618 . by the inductive hypothesis",
    ", we obtain @xmath705{\\stackrel{\\star}{\\rightarrow}_{g'}}w'$ ] , @xmath706{\\stackrel{\\star}{\\rightarrow}_{g'}}w''$ ] . hence , @xmath616{\\stackrel{\\star}{\\rightarrow}_{g'}}w$ ] .",
    "* @xmath622 , @xmath642 , and @xmath643 : + there exists an index @xmath10 , @xmath661 , such that @xmath662 and @xmath707 . by the induction hypothesis",
    ", we obtain @xmath702{\\stackrel{\\star}{\\rightarrow}_{g'}}w'$ ] and @xmath708{\\stackrel{\\star}{\\rightarrow}_{g'}}w''$ ] . hence , @xmath623{\\stackrel{\\star}{\\rightarrow}_{g'}}w$ ] .    the context - free grammar @xmath389 is equivalent to @xmath37 .",
    "furthermore , for each string @xmath709 , @xmath710 , with @xmath711 for @xmath712 , there exists a derivation @xmath713\\ldots[a_n , j_n-1,l_n , l_n , j_n]$ ] , for suitable indices @xmath714 , @xmath715 , such that @xmath716\\rightarrow x_k$ ] , for @xmath712 .",
    "given @xmath717 , as a consequence of the previous lemma , it is immediate to conclude that @xmath718 if and only if @xmath719 . each symbol @xmath720 of the string @xmath308 will be generated in a derivation @xmath721 using a production of the form @xmath716\\rightarrow x_k$ ] , for suitable @xmath722 .",
    "hence , from the derivation @xmath33 it is easy to get a derivation @xmath723 \\ldots[a_n , j_n-1,l_n , l_n , j_n]$ ] .    at this point",
    "we are able to define the grammar @xmath609 .",
    "the set of variables is the same as of @xmath389 , the set of production @xmath724 contains all the productions in @xmath386 , with the exception of each production of the form @xmath624\\rightarrow w_{l , j}$ ] , which is replaced with the production @xmath624\\rightarrow a_l$ ] for @xmath691 , and with the production @xmath624\\rightarrow\\epsilon$ ] in the other cases .",
    "it is immediate to prove that the language generated by @xmath609 coincides with @xmath725 .",
    "hence , we get the following result :    [ cor : word ] given @xmath9 strings @xmath726 , @xmath9 symbols @xmath5 , and the homomorphism @xmath607 associating with each symbol @xmath476 the string @xmath608 , @xmath394 , for each context - free grammar @xmath37 generating a word bounded language @xmath727 , there exists another context - free grammar @xmath609 such that @xmath611 , and @xmath728 .",
    "we are now ready to extend corollary  [ cor : cfg2 ] to word - bounded languages :    [ thm : word ] given @xmath9 strings @xmath726 , for any context  free grammar @xmath37 with @xmath402 and generating a word - bounded language @xmath727 , there exists an equivalent @xmath13-turn pda @xmath88 with @xmath7 states and @xmath379 stack symbols .    by corollary  [ cor :",
    "word ] , given @xmath9 symbols @xmath5 , we can get a context - free grammar @xmath609 with @xmath728 , which generates the language @xmath725 . using corollary  [ cor : cfg2 ] , we are able to find an @xmath13-turn pda @xmath729 with @xmath730 states and @xmath379 stack symbols , recognizing @xmath725 .    from @xmath729 we now define a pda @xmath88 accepting @xmath73 : @xmath88 should simulate @xmath729 with the difference that a move of @xmath729 consuming the input symbols @xmath476 is simulated by a sequence of moves of @xmath88 consuming the input factor @xmath608 .",
    "it is easy to implement this with @xmath7 states and without increasing the number of stack symbols .    because the letter - bounded case is a special case of the word - bounded case , by the results presented in section  [ sec : lower ] , the upper bound presented in theorem  [ thm : word ] is tight .",
    "also corollary  [ cor : kturn1 ] can be extended to the word - bounded case .",
    "[ thm : word - kturn ] the trade - offs between finite - turn pushdown automata that accept word - bounded languages are at most polynomial .",
    "given @xmath9 strings @xmath726 , let @xmath88 be some @xmath10-turn pda accepting a word - bounded language @xmath731 .",
    "we consider @xmath9 letters @xmath5 and the morphism @xmath607 associating with each @xmath476 the string @xmath608 , @xmath394 . from the given pda @xmath88 , a @xmath10-turn pda @xmath729 accepting @xmath732",
    "can be defined by simulating @xmath88 step by step , with the only difference that the input tape of @xmath88 is replaced by a buffer of length @xmath733 .",
    "when @xmath729 has to simulate a move of @xmath88 that reads an input symbol , it uses the next symbol from the buffer . however ,",
    "if the buffer is empty , then @xmath729 reads the next symbol @xmath476 from its input tape and puts the corresponding string @xmath608 in the buffer .",
    "note that the size of @xmath729 is polynomial in the size of @xmath88 .",
    "this is essentially the construction for inverse homomorphism as is given , e.g. , in @xcite .",
    "now , using theorem  [ thm : kturn ] , from @xmath729 it is possible to get an equivalent @xmath13-turn pda @xmath734 , which is still polynomial in the size of @xmath88 . finally , using the same construction outlined in the proof of theorem  [ thm : word ]",
    ", this last pda can be converted in another @xmath13-turn pda @xmath411 , accepting the original language @xmath73 , whose size is polynomial in the size of @xmath88 .",
    "in this paper , we have considered context - free grammars generating letter - bounded as well as word - bounded languages .",
    "we have shown that such languages can be accepted by finite - turn pushdown automata .",
    "furthermore , we have given constructions for converting context - free grammars which generate bounded languages to equivalent finite - turn pushdown automata as well as minimizing the number of turns of a given pushdown automaton accepting a bounded language .",
    "the resulting trade - offs concerning the size of description of the corresponding context - free grammars and pushdown automata have been shown to be exponential when starting with an arbitrary context - free grammar or an arbitrary pushdown automaton . when starting with a finite - turn pushdown automaton , a polynomial trade - off has been obtained .",
    "both trade - offs are in strong contrast to the non - bounded case where non - recursive trade - offs are known to exist .",
    "moreover , the existence of non - recursive trade - offs implies that such conversion algorithms and minimization algorithms can not exist in general .",
    "additionally , equivalence or inclusion problems are undecidable for arbitrary context - free languages .",
    "we have shown that boundedness is a structural limitation on context - free languages which reduces non - recursive trade - offs to recursive trade - offs .",
    "together with the known positively decidable questions such as equivalence or inclusion of bounded context - free languages , we obtain that context - free grammars and pushdown automata for bounded languages are much more manageable from a practical point of view than in the general case ."
  ],
  "abstract_text": [
    "<S> finite - turn pushdown automata ( pda ) are investigated concerning their descriptional complexity . </S>",
    "<S> it is known that they accept exactly the class of ultralinear context - free languages . </S>",
    "<S> furthermore , the increase in size when converting arbitrary pdas accepting ultralinear languages to finite - turn pdas can not be bounded by any recursive function . </S>",
    "<S> the latter phenomenon is known as non - recursive trade - off . in this paper , </S>",
    "<S> finite - turn pdas accepting bounded languages are considered . </S>",
    "<S> first , letter - bounded languages are studied . </S>",
    "<S> we prove that in this case the non - recursive trade - off is reduced to a recursive trade - off , more precisely , to an exponential trade - off . </S>",
    "<S> a conversion algorithm is presented and the optimality of the construction is shown by proving tight lower bounds . </S>",
    "<S> furthermore , the question of reducing the number of turns of a given finite - turn pda is studied . </S>",
    "<S> again , a conversion algorithm is provided which shows that in this case the trade - off is at most polynomial . </S>",
    "<S> finally , the more general case of word - bounded languages is investigated . </S>",
    "<S> we show how the results obtained for letter - bounded languages can be extended to word - bounded languages .    _ </S>",
    "<S> key words : _ automata and formal languages , descriptional complexity , finite - turn pushdown automata recursive trade - offs , bounded languages </S>"
  ]
}