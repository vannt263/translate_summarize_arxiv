{
  "article_text": [
    "the shortest path metric of planar graphs is one of the most popular and well - studied metrics in computer science .",
    "countless papers , surveys , and textbooks address the computational challenges that arise when dealing with it . in this paper",
    ", we address a core problem about this metric that has remained poorly understood .",
    "we ask : _ how compressible is it ? _ that is",
    ", how many bits do we need , information theoretically , in order to describe a set of distances in a planar graph ?    as we discuss shortly , a better understanding of this core question is crucial to making progress on some of the biggest open problems in other well - studied subjects such as sparsification , labeling schemes , dynamic algorithms , and compact routing schemes .    first , let us define our problem more formally . in the _ metric compression _",
    "problem , we are given a set @xmath12 of @xmath0 points in some metric space with distance function @xmath13 , such as the metric of distances in an @xmath1 node planar graph , and the goal is to find an encoding @xmath14 that is as short as possible , yet still allows us to compute @xmath15 for any two points @xmath16 .",
    "given an unweighted , undirected planar graph @xmath17 on @xmath1 nodes , and a subset @xmath12 of @xmath0 distinguished nodes in @xmath17 , compute a bit string @xmath14 that encodes the distances between all pairs of nodes in @xmath12 .",
    "that is , there is a decoding function @xmath18 that given the encoding @xmath14 and any two nodes @xmath16 returns the @xmath19-to-@xmath20 distance in @xmath17 ( i.e. , @xmath21 ) .",
    "there are two nave ways to solve this problem .",
    "first , we can store all the distances explicitly as a @xmath22 matrix in the encoding @xmath14 .",
    "the distance in a graph on @xmath1 nodes is some number in @xmath23 , and so this matrix can be encoded using @xmath3 bits .",
    "the second option , which is better whenever @xmath24 , is to let the encoding be the graph @xmath17 itself .",
    "navely , this is @xmath25 bits , and more sophisticated encodings give @xmath2 @xcite . using the @xmath26 notation to hide polylog factors , we get a nave upper bound of @xmath27 for our problem .",
    "is this the best possible , or could there be a much better compression into @xmath28 or even @xmath29 bits ?    for context , let us look at other metrics .",
    "one example of a metric that admits an ultra - efficient compression into @xmath29 bits is the metric of trees or bounded treewidth graphs @xcite . for most metrics of interest , however , the exact or lossless version of the compression problem is too difficult and no non - trivial upper bounds , beyond log - factor improvements , are possible .",
    "for example , in general ( non - planar ) graphs there is a simple @xmath7 lower bound : in any compression , each of the @xmath30 possible graphs on @xmath0 nodes must be encoded differently .",
    "instead , it is popular to seek the optimal _ lossy _ compression from which the metric can be recovered _ approximately _",
    ", e.g. up to a multiplicative @xmath31 error .",
    "for example , the classical johnson - lindenstrauss @xcite embedding allows one to compress a set of @xmath0 points in euclidean @xmath13-dimensional space into roughly @xmath32 bits , so that the distances between the points can be recovered up to a @xmath31 factor , and a recent breakthrough of indyk and wagner @xcite reduced the bound to roughly @xmath33 which is tight up to a @xmath34 factor .    indeed ,",
    "if we are willing to pay a @xmath31 error , there are ingenious compressions of the planar graph metric into @xmath29 bits @xcite . but",
    "do we have to pay this error , or are planar graphs restricted enough to allow for non - trivial compression ?    [ oq1 ] can we beat @xmath35 bits for planar graph metric compression ?    there are some lower bounds in our way . from the seminal work of gavoille , peleg , prennes , and raz @xcite",
    "we know that the metric of _ weighted _ planar graphs , where the edge weights are polynomially bounded , does not admit any non - trivial compression .",
    "the authors show that any boolean @xmath22 matrix can be `` encoded '' using the distances among a set of @xmath36 nodes in a weighted planar graph on @xmath37 nodes , where the edge weights are in @xmath38 $ ] . since we can not compress an arbitrary @xmath22 matrix into @xmath39 bits , we get a nearly - tight lower bound of @xmath40 for _ weighted _ planar graphs . for unweighted planar graphs ,",
    "gavoille et al .",
    "simply subdivide the edges in their construction and the number of nodes in the encoding grows to @xmath41 , which leads to a much weaker lower bound of @xmath42 ( see section  [ sec : lowerbound ] for more details ) .",
    "for example ,",
    "when @xmath4 , the upper bound is @xmath43 and the lower bound is @xmath5 .",
    "this subdivision of edges is rather nave , and the overall lower bound construction does not seem to capture the full power of the planar graph metric .",
    "in fact , it can be simulated by a grid graph @xcite .",
    "this naturally suggests the following intriguing challenge of finding a more clever encoding of matrices into planar graphs , which would lead to a negative resolution to open question  [ oq1 ] .",
    "[ ch1 ] can we encode an arbitrary @xmath22 boolean matrix @xmath44 using the distances among a subset of @xmath36 nodes @xmath45 in an _ unweighted planar graph _ with @xmath46 vertices , so that we can determine @xmath47 $ ] by only looking at the distance between @xmath19 and @xmath48 in our graph ?    before presenting our results , let us discuss the state of the art on questions that are closely related to ours , in which we are interested in data structures that are not only as succinct as possible , but also have other desirable features .",
    "along the way , we give further reasons to be pessimistic about the possibility of a non - trivial compression .    [ [ sparsification . ] ] sparsification .",
    "+ + + + + + + + + + + + + + +    a natural way to compress a graph is by deleting or contracting some of its edges and nodes . finding small subgraphs or minors that preserve or approximate the distances among a given subset of @xmath0 nodes",
    "have been studied for planar graphs @xcite and for general graphs @xcite . such compressions are appealing algorithmically , since we can readily feed them into our usual graph algorithms , and recent research suggests that , in many settings , near - optimal compression bounds can be achieved using such sparsifiers ( e.g. when compressing general graphs with additive error @xcite ) .",
    "a discouraging lower bound of krauthgamer , nguyen , and zondiner @xcite shows that even in the case of unweighted grid graphs , it is impossible to beat the nave bound using a ( possibly weighted ) minor . thus , a positive answer to open question  [ oq1 ] will have to involve a more complicated data structure .",
    "[ [ labelling - schemes . ] ] labelling schemes .",
    "+ + + + + + + + + + + + + + + + + +    an appealing way to represent graphs is to assign a label @xmath49 to each node @xmath50 , so that by looking at the labels of two nodes @xmath51 we can infer certain properties such as the distance between them @xmath52 .",
    "finding so - called _ distance labelling schemes _ in which the labels are as short as possible is a classical subject of study @xcite .",
    "such labels are used for efficient algorithms both in theory @xcite and practice @xcite .",
    "an inspiring lecture by stephen alstrup at halg 2016 surveys breakthroughs @xcite achieved in this field in the last few years , all of which involve shaving constants or logarithmic factors .",
    "a famous open question is to close the rare _ polynomial _ gap in the bounds for planar graphs that has been embarrassingly open since the work of gavoile et al .",
    "@xcite : the upper bound is @xmath10 bits per label ( due to @xcite who shaved a log factor over @xcite ) , and the lower bound is @xmath11 . the only known technique to prove polynomial lower bounds lower bound for nearest common ancestors in trees  @xcite and @xmath53 lower bound for distance in trees  @xcite .",
    "the gist of both of them is being able to argue about how much information can be shared by labels of two nodes .",
    "if the graph is not a tree , this seems very challenging .",
    "] is to argue that labelling schemes are one way to compress graphs , and then use facts about the limits of graph compression .",
    "for example , the lower bound for distance labelling of planar graphs @xcite follows because labels of size @xmath54 can be used to solve the metric compression problem using @xmath55 bits , which contradicts the lower bounds above .",
    "in fact , the tight lower bound for metric compression of _ weighted _ planar graphs leads to a tight lower bound for labelling schemes @xcite .",
    "thus , to prove a tight lower bound of @xmath56 for labelling schemes in unweighted planar graphs , the _ only _ approach we have with current techniques is to negatively resolve open question  [ oq1 ] , e.g. by accomplishing challenge  [ ch1 ] .",
    "[ [ routing - and - dynamic - algorithms . ] ] routing and dynamic algorithms .",
    "+ + + + + + + + + + + + + + + + + + + + + + + + + + + + + + +    a compact routing scheme assigns names and tables to the nodes of a graph , so that each node @xmath57 can find out the first edge on the shortest path ( or some approximate path ) to any target node @xmath58 only using the name of @xmath58 and the local table stored at @xmath57 .",
    "there is a vast literature on the topic , seeking the best possible tradeoff between sizes of the tables and the stretch in many different graph families ( we refer the reader to peleg s book @xcite and the extensive surveys @xcite ) .",
    "for planar graphs , abraham , gavoille , and malkhi @xcite write : `` _ _ surprisingly , for stretch 1 , the complexity of the size of the routing tables is not known .",
    "_ _ '' a simple upper bound is @xmath59 total table size , and an adaptation of the same gavoille et al .",
    "construction gives a lower bound of @xmath60 @xcite .",
    "it is likely that accomplishing challenge  [ ch1 ] would resolve this gap as well .",
    "yet another problem with similar state - of - the - art is the all pairs shortest paths problem in _ dynamic _ planar graphs . here , the goal is to have a data structure that supports efficient updates to the graph ( edge additions or removals ) , and can answer shortest path queries efficiently .",
    "the breakthrough algorithm of fakcharoenphol and rao @xcite , and the later optimizations @xcite , achieve @xmath61 time for updates and queries .",
    "the only framework for showing polynomial lower bound was recently proposed by abboud and dahlgaard @xcite who proved a lower bound of @xmath62 under the popular apsp conjecture @xcite .",
    "using their framework , accomplishing challenge  [ ch1 ] directly leads to a higher lower bound of @xmath63 , as is known in the weighted case .",
    "history suggests that weighted planar graph metrics might be harder to work with , but they are never _ truly _ harder . in so many cases , a new algorithm for the unweighted case",
    "is followed by an almost - as - good algorithm for the weighted case , a few years later .",
    "for example , a ptas for the travelling salesman problem in the unweighted planar metric was found in 1995 @xcite , and then for the weighted case in 1998 @xcite .",
    "perhaps it is only a matter of time until our lower bounds for the unweighted metric match the weighted .",
    "our first result is a new compression scheme for the planar graph metric , which achieves the information theoretically best possible bit complexity , up to log - factors .",
    "we give a _ positive _ resolution to open question  [ oq1 ] , deem challenge  [ ch1 ] to be infeasible , and show that unweighted planar graphs are inherently less complex than weighted ones ; in fact , they admit a polynomially more efficient metric compression .",
    "given an unweighted undirected planar graph on @xmath1 nodes and a subset @xmath12 of @xmath0 nodes , we can return a binary encoding of length @xmath64 from which all pairwise distances in @xmath12 can be recovered exactly .",
    "this shrinks the gap in our understanding of the planar metric compression problem from polynomial to polylogarithmic ( removing this polylogarithmic gap remains an open question ) . for comparison ,",
    "when @xmath65 , we show that @xmath66 bits are necessary and sufficient , while in the weighted case the bound is @xmath67 .",
    "our encoding breaks the lower bound of krauthgamer et al .",
    "@xcite for compressions using minors , and raises the question whether it can be matched via other forms of sparsification or _",
    "graphical _ compressions .",
    "it is unclear whether our new compression scheme will lead to improved upper bounds for labeling , routing , or dynamic algorithms . in section  [ sec : unit ]",
    ", we discuss the difficulty in turning it into a labelling scheme .",
    "still , it certainly shakes our beliefs about the right bounds for those problems .",
    "even if better upper bounds are not possible , it is no longer a mere puzzle as in challenge  [ ch1 ] that is standing in the way of higher lower bounds  substantially new techniques and frameworks must be developed .",
    "[ [ distance - oracles . ] ] distance oracles .",
    "+ + + + + + + + + + + + + + + + +    our first result was a mathematical advance in the understanding of the planar graph metric .",
    "next , we use it algorithmically to achieve a new _ subset distance oracle _ that could be an appealing choice in many applications .",
    "a distance oracle is an encoding of a graph from which a pairwise distance can be queried efficiently . since the seminal paper of thorup and",
    "zwick @xcite , a central subject of study in graph algorithms has been to understand the inherent tradeoff between the parameters of these distance oracles ( see the survey by sommer @xcite ) : the _ size _ of the compression , the _ query time _ for returning a distance , the _ error _ in the answers , the _ preprocessing time _ to construct the compression , and so on .",
    "many _ exact _ distance oracles for planar graphs have been proposed @xcite , mostly focusing on the tradeoff between space and query time , and giving @xmath68 space and @xmath69 query time @xcite .",
    "cohen - addad , dahlgaard , and wulff - nilsen @xcite show that the technique of abstract voronoi diagrams recently introduced into the field of planar graphs by cabello @xcite leads to an oracle with @xmath70 space and @xmath71 query time , suggesting that a better tradeoff is possible .    to get even better tradeoffs",
    "we might allow @xmath31 error @xcite : we can achieve very small @xmath72 space and fast @xmath71 query time .",
    "note that @xmath73 space is impossible in this setting , no matter what query time we allow .",
    "however , another natural way to get better tradeoffs is to restrict our attention to a subset of the nodes .",
    "a _ subset distance oracle _ is a small space data structure that can efficiently return the distance between any pair of nodes from a set @xmath12 of @xmath0 nodes . here , for any @xmath74 ,",
    "e.g. @xmath75 , our new compression scheme suggests that a distance oracle might have @xmath73 space .",
    "subset distance oracles arise naturally . in typical applications of distance oracles",
    ", one can predict that all queries will be among a subset of @xmath74 nodes .",
    "space efficiency is often a high priority .",
    "for example , if our graph is the national road network , one might be interested in a mobile app that can return the distance between any pair of bus stops .",
    "our second result is the first subset distance oracle with non - trivial space bounds .",
    "notably , all previous distance oracles in the literature work equally well for weighted and unweighted graphs , while ours uses new techniques that are provably impossible for weighted graphs .    given an unweighted undirected planar graph on @xmath1 nodes and a subset @xmath12 of @xmath0 nodes",
    ", there is a polynomial - time algorithm that returns a data structure @xmath76 of size @xmath64 such that given @xmath76 and any pair of nodes in @xmath12 we can return the exact distance in @xmath77 time .",
    "the main open question left by our work is whether our query time can be improved , perhaps all the way down to @xmath71 .",
    "this would be an essentially optimal distance oracle .",
    "but even as it is , our query time is sublinear , and our space is sublinear for any @xmath74 , making it an appealing choice in applications with strict space constraints .",
    "finally , an intriguing and wide open question is to extend ( any of ) our upper bounds to _ directed _ planar graphs .",
    "can we accomplish challenge  [ ch1 ] if we allow directed edges ?",
    "our tools heavily rely on the graph being undirected , yet it remains unclear if a higher lower bound can be proven for directed graphs .",
    "we exhibit the first use of the _ unit - monge _ property to the algorithmic study of planar graphs .",
    "it is well known that distances in a planar graph enjoy this property , due to the non - crossing nature of shortest paths in the plane , but prior to our work , only the _ ( non - unit ) monge _ property , was known to be algorithmically exploitable for planar graphs . for the past few decades , it has been heavily utilized in numerous algorithms for problems related to shortest paths or minimum cuts in planar graphs ( e.g.  @xcite ) , and beyond , in dozens of papers on computational geometry ( e.g. @xcite ) and pattern matching ( e.g. @xcite ) . meanwhile , the stronger _ unit - monge _ property has only been exploited for algorithms on sequences where it has already led to several breakthroughs .",
    "we refer the reader to the 159-page monograph of tiskin @xcite for an exposition of these applications .",
    "recall that we want to encode the distances among @xmath0 nodes in a planar graph .",
    "let us assume that we are lucky and all the nodes lie on a single face of the graph .",
    "denote the nodes appearing on the face in order @xmath78 , and for simplicity assume that we only want to encode @xmath79-to-@xmath80 distances .",
    "let @xmath44 be the @xmath81 matrix of distances so that @xmath47=d(s_i , t_j)$ ] .",
    "this matrix has the monge property : for any @xmath82 we have that @xmath83 - m[i , j ] \\le m[i+1,j+1 ] - m[i , j+1]$ ] .",
    "this is because the @xmath79-to-@xmath80 shortest path and the @xmath84-to-@xmath85 shortest path must cross . moreover , it is _ unit - monge _ , that is , @xmath83-m[i , j ] \\in \\{-1,0,1\\}$ ] .",
    "this is because there is an edge between @xmath79 and @xmath84 and so the distances involving these nodes are always at most @xmath86 apart .",
    "our gains come from the fact that unit - monge matrices are compressible into @xmath87 bits ! for non - unit monge matrices , the construction of gavoille et al .",
    "implies an @xmath7 lower bound .",
    "another striking example for the extra power of the unit - monge property is the fact that ( a compact representation of ) the distance product of two @xmath88 such matrices can be computed in @xmath89 time @xcite , while for non - unit monge matrices only @xmath90 algorithms are possible .",
    "the main issue for us , and in general when exploiting monge properties , is that the nodes we care about do not necessarily lie on a cycle .",
    "the simple solution is to _ add _ a cycle connecting our @xmath0 nodes and assign weight @xmath91 to the new edges so that they do not change the distances , or more formally , to _ triangulate _ the graph .",
    "after we do this , we have the monge property , but because of the infinite weight edges , we do not have the unit - monge property .",
    "this solution is common to all the algorithms cited above that use the monge property , and is quite reasonable when the graph is weighted to begin with . for unweighted graphs , on the other hand",
    ", our work proves that it is too lossy and a more involved solution leads to much better results .    at a very high - level ,",
    "our approach is to use a baker - like decomposition into slices ( vertices at consecutive levels of some specific bfs tree ) whose boundaries are cycles , and to store distances to the slice boundaries . observe that when we argued above that the unit monge property holds because there is an edge between @xmath79 and @xmath84 , we did not require that there is also an edge between @xmath80 and @xmath85 . in our solution",
    "there is an edge between consecutive vertices on the boundary cycle of each slice .",
    "therefore , even if we triangulate each slice using infinite weight edges , we can still exploit the unit monge property when storing distances between certain vertices in a slice and the slice boundary .",
    "the decomposition into slices is such that , after triangulation , the slices have small cycle separators .",
    "we recursively separate the vertices of the set @xmath12 within each slice using small cycle separators .",
    "we store distances between separators and the slice boundary ( using the unit monge property ) and between vertices of @xmath12 and separators ( using the fact that separators are small ) .",
    "significant technical issues arise with the nesting structure of slices .",
    "this gives rise to so - called _ holes _ in a slice .",
    "dealing with multiple holes requires a detailed study of additional structural properties , and a more complicated recursive solution based on these properties . in essence , we show that whenever a nave solution does not work in the presence of multiple holes , there is one hole that can be handled efficiently using a different approach .",
    "we believe it is very likely that other problems in unweighted planar graphs can be solved by exploiting the unit - monge property .",
    "our near - optimal metric compression serves as a proof of concept that this is possible .",
    "however , technical challenges might have to be overcome in each specific application .",
    "in particular , the fast distance product algorithm for unit - monge matrices  @xcite appears to be a strong and relevant technique that we are so far unable to exploit for solving problems in planar graphs .",
    "we assume basic familiarity with planar graphs and planar graph duality . we denote the primal graph by @xmath17 and the dual graph by @xmath92 . for a spanning tree @xmath93 of @xmath17",
    ", we use @xmath94 to denote the spanning tree of @xmath92 .",
    "it is well known  @xcite that the set of edges of @xmath17 not in @xmath93 form a spanning tree @xmath94 of @xmath92 .",
    "we often refer to @xmath94 as the _ cotree _ of @xmath93  @xcite . for a spanning tree @xmath93 of @xmath17 and an edge @xmath95 of @xmath17 not in  @xmath93 ,",
    "the _ fundamental cycle _ of @xmath95 with respect to @xmath93 in @xmath17 is the simple cycle consisting of @xmath95 and the unique simple path in @xmath93 between the endpoints of @xmath95 .",
    "given an assignment of nonnegative weights to the faces of @xmath17 , we say that a simple cycle @xmath96 is a _ balanced separator _ if the total weight of faces strictly enclosed by  @xmath96 and the total weight of faces not enclosed by  @xmath96 are each at most @xmath97 of the total weight . or @xmath98",
    ". however , in our particular application @xmath97 turns out to be more convenient .",
    "] we often assign weights to vertices rather than to faces . finding a balanced separator with respect to vertex weights",
    "reduces to the case of face weights ( for each vertex , simply remove its weight and add it to an incident face ) .",
    "it is well known ( see , e.g. ,  @xcite ) that in triangulated planar graphs there exists a balanced separator that is a fundamental cycle assuming that no face has more than @xmath99 of the total weight ( in fact , this is true for any planar graph such that @xmath94 has maximum degree  3 ) . for vertex - weights , if no vertex has more than 1/2 of the total weight and the graph is triangulated and there are no self loops then by evenly transferring the weights to faces we obtain that no face receives more than 1/2 of the total weight ( because every node is incident to at least two faces ) and we can invoke the face - weights version of the balanced separator .",
    "many planar graph algorithms triangulate the graph by adding edges to ensure that short balanced cycle separators exists .",
    "the lengths of the added edges is set to be sufficiently large so as not to change distances in the graph .",
    "this is clearly not possible in unweighted planar graphs , and is one of the obstacles we will need to overcome .",
    "one of the main tools we use for succinct representation of distances in unweighted undirected planar graphs is the _ unit monge property_. we next prove a sequence of lemmas that utilize this property to efficiently store distances between vertices on cycles .",
    "we begin with encoding distances between disjoint sets of vertices on a single face ( lemma  [ lem : unit ] ) , then encoding all - pair distances between the vertices on a single face ( lemma  [ lem : unit2 ] ) , then encoding all - pair distances between the vertices on a single simple cycle ( lemma  [ lem : cycle ] ) , and finally , encoding the distances between the vertices of two faces ( lemma  [ lem : hole ] ) .",
    "[ lem : unit ] let @xmath100 be the cyclic walk of a face of a planar graph partitioned into two parts @xmath101 and @xmath102 . then ,",
    "for any subset @xmath103 of @xmath104 , all distances between vertices of @xmath105 and vertices of @xmath103 can be encoded in @xmath106 bits .",
    "let @xmath107 .",
    "we define an @xmath108 matrix @xmath44 such that @xmath47 $ ] equals the distance in @xmath17 between @xmath19 and @xmath109 .",
    "the matrix @xmath44 is monge , that is @xmath110 - m[i , j ] \\le m[i+1,j+1 ] - m[i , j+1]\\ ] ] for any @xmath111 $ ] and @xmath112 $ ] .",
    "this is because the shortest @xmath19-to-@xmath113 and @xmath114-to-@xmath115 paths must necessarily cross .",
    "furthermore , the matrix @xmath44 is unit - monge , that is    @xmath110-m[i , j ] \\in \\{-1,0,1\\}\\ ] ] for any @xmath111 $ ] and @xmath116 $ ] , because there is an edge @xmath117 .",
    "consequently , for any @xmath111 $ ] , the sequence of differences @xmath83-m[i , j]$ ] is nondecreasing and contains only values from @xmath118 , so can be encoded by storing the positions of the first 0 and the first 1 . storing these positions for every @xmath119 $ ] takes @xmath120 bits . to encode the whole @xmath44 , we additionally store @xmath121 $ ] for every @xmath116 $ ] using @xmath122 bits .",
    "[ lem : unit2 ] let @xmath100 be the cyclic walk of a face of a planar graph .",
    "then , all distances between vertices of @xmath96 can be encoded in @xmath123 bits .",
    "we recursively encode all distances between vertices from a contiguous fragment of @xmath96 using lemma  [ lem : unit ] .",
    "we start with the whole @xmath124 . to encode the distances between all vertices @xmath125 , where @xmath126 , we set @xmath127 and proceed as follows :    1 .",
    "recursively encode the distances between all vertices @xmath128 .",
    "recursively encode the distances between all vertices @xmath129 .",
    "3 .   apply lemma  [ lem : unit ] with @xmath130 and @xmath131 .",
    "the total size of the encoding is described by the recurrence @xmath132 , hence solves to @xmath123 .",
    "[ lem : cycle ] let @xmath100 be a simple cycle in a planar graph .",
    "then , all distances between vertices of @xmath96 can be encoded in @xmath123 bits .",
    "consider the two planar graphs @xmath133 ( @xmath134 ) obtained by removing all vertices enclosed ( not enclosed ) by @xmath96 .",
    "@xmath96 is the cyclic walk of a face in @xmath134 and @xmath133 , hence we can apply lemma  [ lem : unit2 ] to store the distances in @xmath133 and in @xmath134 between vertices of @xmath96 .",
    "this is enough to encode the distances in @xmath17 between vertices of @xmath96 , as any such shortest path can be partitioned into shortest paths between two vertices of @xmath96 such that each of these paths exists in either @xmath134 or @xmath133 .",
    "[ lem : hole ] let @xmath135 and @xmath136 be the cyclic walk of two faces of a planar graph .",
    "then , all distances between a prefix @xmath137 of @xmath138 and any subset @xmath139 of @xmath140 can be encoded in @xmath141 bits .",
    "we first choose a shortest path @xmath142 between @xmath137 and @xmath140 and let @xmath19 and @xmath143 be its endpoints .",
    "we make an incision along @xmath142 and apply lemma  [ lem : unit ] to encode the distances between @xmath137 and @xmath139 corresponding to shortest paths that do not cross @xmath142 using @xmath141 bits of space .",
    "it remains to encode distances corresponding to shortest paths that do cross @xmath142 . without loss of generality",
    "@xmath142 connects @xmath144 and @xmath145 .",
    "we orient @xmath138 and @xmath140 so that after making an incision along @xmath142 the vertices @xmath146 and @xmath147 are adjacent to the endpoints of @xmath142 .",
    ".[fig : cross],scaledwidth=40.0% ]    consider a shortest path @xmath148 from @xmath19 to @xmath143 crossing @xmath142 , see figure  [ fig : cross ] .",
    "because both @xmath142 and @xmath148 are shortest paths , @xmath148 can be assumed to cross @xmath142 exactly once .",
    "similarly , a shortest path @xmath149 from @xmath114 to @xmath150 crossing @xmath142 can be assumed to cross @xmath142 exactly once .",
    "we claim that @xmath148 must cross @xmath149 .",
    "otherwise , by considering an incision along @xmath148 we can conclude that @xmath149 crosses @xmath142 an even number of times but this is a contradiction .",
    "therefore , any such @xmath148 and @xmath149 must cross .",
    "this means that the matrix @xmath44 , where @xmath47 $ ] is set to be the length of a shortest path between @xmath19 and @xmath143 crossing @xmath142 once , is monge .",
    "that is , @xmath151 + m[i , j ] \\geq m[i+1,j]+m[i , j+1].\\ ] ] additionally , @xmath47-m[i+1,j ] \\in \\{-1,0,1\\}$ ] because @xmath117 is an edge .",
    "we can hence apply the reasoning from lemma  [ lem : unit ] to encode @xmath44 using @xmath141 bits .",
    "our encoding is based on decomposing the input graph @xmath17 into _ slices_. to define the slices , recall the _",
    "face - vertex incidence graph",
    "_ @xmath152 of a planar graph @xmath17 : it has a vertex for every vertex @xmath50 of @xmath17 and a vertex for every face @xmath18 of @xmath17 , and if a vertex @xmath50 of @xmath17 is incident to a face @xmath18 of @xmath17 then there is an edge between their corresponding vertices in @xmath152 .",
    "we run a breadth - first search in @xmath152 , starting from the node representing the infinite face of @xmath17 . after every even number of steps",
    ", the yet unexplored part of the graph can be decomposed into a number of connected components , the boundary of each being a simple cycle .",
    "more formally , we assume that the infinite face of @xmath17 is a triangle by enclosing the whole graph in a triangle , which is connected to one of the original vertices with a single edge .",
    "we define the level of a face @xmath18 or a vertex @xmath50 of @xmath17 to be its depth in the bfs tree of @xmath152 .",
    "thus , e.g. , the level of the infinite face of @xmath17 is zero , and the level of the vertices incident to the infinite face of @xmath17 is 1 . for each even integer @xmath153 , we define @xmath154 to be the set of connected components of the subgraph of @xmath17 induced by the faces with level at least @xmath155 .",
    "we call each component @xmath156 a level-@xmath155 component .",
    "we use a tree @xmath157 called the _ component tree _ of @xmath17 to capture the nesting of level components .",
    "the nodes of @xmath157 are the level components of @xmath17 .",
    "a level component @xmath158 is an ancestor of a level component @xmath159 in @xmath157 if the set of faces in @xmath158 contains the set of faces in @xmath159 .",
    "since we assume that the infinite face of @xmath17 is a simple triangle , @xmath160 is indeed a tree whose root is the component corresponding to the set of all faces of @xmath17 except for the infinite face .",
    "the boundary of a component @xmath158 is the set of edges that are incident to a face in @xmath158 and to a face not in @xmath158 .",
    "it is not difficult to see that the boundary of each component @xmath158 is a simple cycle in @xmath17 , and that the boundaries of different components are edge - disjoint .",
    "see  @xcite for these and other properties of components and the component tree . for a node @xmath161 ,",
    "we associate @xmath0 with the boundary cycle @xmath162 of the level component represented by @xmath0 , and define the cost of @xmath0 denoted @xmath163 to be the length of @xmath162 . for example",
    ", for the root @xmath164 of @xmath157 we have that @xmath165 is a triangle and that @xmath166 .",
    "[ lem : slices ] for any @xmath167 , there exists @xmath168 such that the total cost of all nodes of @xmath157 at depth @xmath169 is @xmath170 .",
    "@xmath171 because cycles corresponding to the nodes of @xmath172 are pairwise edge disjoint .",
    "let @xmath173 consist of all nodes of @xmath172 at depth @xmath169 .",
    "then @xmath174 for @xmath175 and @xmath176 , so there exists @xmath168 such that @xmath177 as claimed .    to define the slices we apply lemma  [ lem : slices ] and call the nodes of @xmath172 at depth @xmath169 _ marked_. the root of @xmath172 is also marked .",
    "then , for every marked node @xmath178 , the slice of @xmath50 is the subgraph of @xmath17 enclosed by @xmath179 and not strictly enclosed by @xmath180 for any marked descendent @xmath181 of @xmath50 .",
    "the embedding of slices is inherited from the embedding of @xmath17 .",
    "thus , the boundary of the infinite face of the slice @xmath57 of @xmath50 is @xmath179 .",
    "the cycle @xmath179 is also called _ the boundary of the slice @xmath57_. each cycle @xmath180 corresponding to a marked descendant @xmath181 of @xmath50 such that there are no other marked nodes on the @xmath50-to-@xmath181 path becomes a face in the slice @xmath57 .",
    "such a face is called a _ hole _ of @xmath57 , and @xmath180 is called the _ boundary of the hole_. note that , by definition , @xmath180 is the boundary of the level component that is embedded in the hole @xmath181 .",
    "because the total cost of all marked nodes is @xmath170 and the cost of the root is 3 , the total size of all boundaries in all slices is @xmath170 .",
    "additionally , by construction , for any slice @xmath57 , a breadth - first search of @xmath182 , the face - vertex incidence graph of @xmath57 , starting at the infinite face of @xmath57 , terminates after @xmath183 iterations and every hole is a leaf in the obtained breadth - first search tree",
    ".    by definition of slices , each slice contains faces and vertices at @xmath183 consecutive levels .",
    "we would like to use in our solution short ( i.e. , @xmath183 ) fundamental cycle separators within each slice .",
    "however , the diameter of a slice is not necessarily @xmath183 because face sizes may be large . to deal with this issue",
    "we triangulate the faces so that a bfs tree of a slice will have depth @xmath183 , and will be consistent with the bfs tree of @xmath182 .",
    "[ lem : triangulation ] we can triangulate all faces of a slice @xmath57 so that a bfs starting from the external face produces a spanning tree @xmath184 with the property that vertex @xmath50 is the parent of vertex @xmath181 in @xmath184 if and only if @xmath50 is the grandparent of @xmath181 in the bfs tree of @xmath182 .",
    "let @xmath185 be the bfs tree of @xmath182 .",
    "if @xmath50 and @xmath181 are incident to the same face in @xmath57 , and @xmath50 is a grandparent of @xmath181 , and @xmath186 is not an edge in @xmath57 , we add @xmath186 as an artificial triangulation edge to @xmath57 . adding these edges can be done consistently with the embedding of @xmath57 because the path in @xmath185 can be embedded on the same plane as @xmath57 such that @xmath57 and @xmath185 only intersect at vertices of @xmath57 .",
    "see figure  [ fig : slices ] .",
    "we introduce an artificial vertex @xmath187 embedded in the infinite face of @xmath57 and triangulate the infinite face of @xmath57 by adding edges between @xmath187 and every vertex of the infinite face of @xmath57 .",
    "similarly , we triangulate each hole @xmath188 of @xmath57 by introducing an artificial vertex @xmath189 , embedded in @xmath188 , and adding edges between @xmath189 and every vertex on the boundary of @xmath188 .",
    "any remaining non - triangulated faces can be triangulated arbitrarily . since for every grandparent to grandchild path in @xmath185",
    "there is a corresponding edge in the triangulation of @xmath57 , there exists a bfs tree @xmath184 rooted at the artificial vertex @xmath187 that satisfies the statement of the lemma .",
    "note that all the artificial vertices embedded in holes of @xmath57 are leaves of @xmath184 , and hence satisfy the statement of the lemma vacuously .     with two holes",
    "are shown in solid black . in this example @xmath190 .",
    "edges of @xmath185 , the bfs tree of @xmath191 ) are shown in double red lines .",
    "only some of the edges of @xmath185 are shown to avoid clutter .",
    "artificial triangulation edges are shown in dashed gray .",
    "the bfs tree @xmath184 of the triangulation of @xmath57 is shown in blue .",
    "[ fig : slices ] ]     with two holes are shown in solid black . in this example @xmath190 .",
    "edges of @xmath185 , the bfs tree of @xmath191 ) are shown in double red lines .",
    "only some of the edges of @xmath185 are shown to avoid clutter .",
    "artificial triangulation edges are shown in dashed gray . the bfs tree @xmath184 of the triangulation of @xmath57",
    "is shown in blue .",
    "[ fig : slices ] ]     with two holes are shown in solid black . in this example @xmath190 .",
    "edges of @xmath185 , the bfs tree of @xmath191 ) are shown in double red lines . only some of the edges of @xmath185 are shown to avoid clutter .",
    "artificial triangulation edges are shown in dashed gray .",
    "the bfs tree @xmath184 of the triangulation of @xmath57 is shown in blue . [",
    "fig : slices],scaledwidth=80.0% ]     with two holes are shown in solid black . in this example @xmath190 .",
    "edges of @xmath185 , the bfs tree of @xmath191 ) are shown in double red lines .",
    "only some of the edges of @xmath185 are shown to avoid clutter .",
    "artificial triangulation edges are shown in dashed gray .",
    "the bfs tree @xmath184 of the triangulation of @xmath57 is shown in blue .",
    "[ fig : slices],scaledwidth=80.0% ]    let @xmath192 be the graph obtained from the slice @xmath57 after applying lemma  [ lem : triangulation ] .",
    "let @xmath184 be the bfs tree of @xmath192 .",
    "note that , any fundamental cycle @xmath96 w.r.t .",
    "@xmath184 consists of two paths in @xmath184 , each consisting of @xmath183 vertices due to the triangulation .",
    "however , @xmath96 may use edges that are not original edges of @xmath57 ( i.e. , artificial triangulation edges ) .",
    "we do not want to consider such edges when dealing with distances , because distances in @xmath192 differ from distances in @xmath57 . to this end",
    "we use the notion of a jordan curve . a jordan curve in @xmath57 is an embedded curve that intersects the embedding of @xmath57 only at vertices of @xmath57 .",
    "since the embedding of the triangulation @xmath192 is consistent with that of @xmath57 , each path in @xmath184 is a jordan curve in @xmath57 .",
    "we say that @xmath184 is a _ jordan tree _ in @xmath57 .",
    "in particular , any fundamental cycle w.r.t .",
    "@xmath184 is a jordan cycle ( closed jordan curve ) in @xmath57 .",
    "we next describe how the tree @xmath184 can be used to recursively decompose @xmath57 into subgraphs called _",
    "regions_.    a region @xmath193 is a subgraph of @xmath57 .",
    "the boundary of @xmath193 is defined as the set of vertices of @xmath193 that are incident ( in @xmath17 ) to both an edge in @xmath193 and to an edge not in @xmath193 .",
    "thus , for example , the boundary of the region consisting of the entire slice @xmath57 consists of the external boundary @xmath138 of @xmath57 and of the boundaries of all the holes of @xmath57 .",
    "let @xmath193 be a region .",
    "let @xmath96 be a fundamental cycle w.r.t .",
    "the tree @xmath184 may contain edges that are not edges of @xmath193 ( either because they are triangulation edges , or because they are edges of @xmath57 that do not belong to the region @xmath193 ) . since the embedding of @xmath184 is consistent with the embedding of any subgraph of @xmath57 , @xmath96 is a jordan cycle in @xmath193 .",
    "the operation of separating @xmath193 using @xmath96 yields two subgraphs .",
    "one is the subgraph induced by the faces of @xmath193 strictly enclosed by @xmath96 and the other is the subgraph induced by the faces of @xmath193 not strictly enclosed by @xmath96 .",
    "this view of @xmath184 as a jordan tree in any region allows us to reuse the same tree @xmath184 throughout the recursive decomposition .",
    "this recursive process can be described by a binary tree @xmath194 .",
    "each node @xmath50 of @xmath194 corresponds to a region ( subgraph ) @xmath195 of @xmath57 .",
    "the root of @xmath194 is the entire slice @xmath57 .",
    "each non - leaf node @xmath50 of @xmath194 is associated with a ( jordan ) fundamental cycle separator of @xmath184 , which we denote @xmath196 .",
    "the regions of the two children of @xmath50 are the regions obtained by separating @xmath195 with the jordan cycle @xmath196 .",
    "we begin with the simplified case , in which we assume that each slice has a single hole .",
    "this is the case , for example , when the input planar graph is a grid ( with possibly subdivided edges ) .",
    "first we use lemmas  [ lem : cycle ] and  [ lem : hole ] to store , for each slice @xmath57 with external boundary @xmath138 , and a single hole @xmath188 with external boundary @xmath197 the following distances .",
    "the * boundary - to - boundary * distances : the distances ( in @xmath57 ) among the vertices of @xmath138 , and the * hole - to - boundary * distances : the distances ( in @xmath57 ) between the vertices of @xmath138 and the vertices of @xmath197 .",
    "boundary - to - boundary and hole - to - boundary distances encode distances `` between slices '' .",
    "we also need to encode distances `` within slices '' .",
    "we will use the fact that @xmath57 has a spanning tree of depth @xmath183 to decompose @xmath57 into regions , each containing a single distinguished node ( i.e. , node of @xmath12 ) , and having a boundary that consists of @xmath183 vertices .",
    "then we can afford to store , for each distinguished node , its distance to the boundary of its region , and , using the unit - monge property , to also store the distances between the @xmath183 vertices on the boundary of each region @xmath193 to the vertices of @xmath138 and @xmath197 ( i.e. , the boundary of @xmath57 ) that belong to @xmath193 .",
    "these distances will suffice for reconstructing the distance between any pair of distinguished nodes .",
    "let @xmath198 denote the set of distinguished vertices in slice @xmath57 .",
    "we use fundamental ( jordan ) cycle separators w.r.t . the tree @xmath184 to recursively divide @xmath57 into regions , until each region contains a single distinguished vertex . at each recursive",
    "step we separate a region @xmath193 into two subregions by choosing a fundamental cycle separator w.r.t . @xmath184",
    "that balances the number of distinguished vertices in @xmath193 ( i.e. , assigning unit weight to each distinguished vertex in @xmath193 and zero weight to all other vertices ) .",
    "note that , since we use balanced separators , the depth of the recursion tree @xmath194 is @xmath199 .",
    "recall that the fundamental cycle separators w.r.t .",
    "@xmath184 do not cross each other , and , by construction of @xmath184 in lemma  [ lem : triangulation ] , each fundamental cycle separator crosses each of the external boundary of @xmath57 and the hole of @xmath57 at most twice .",
    "therefore , the boundary of each region @xmath195 corresponding to a node @xmath50 in the recursive decomposition tree @xmath194 contains @xmath200 vertex disjoint maximal subpaths of @xmath138 , and @xmath200 vertex disjoint maximal subpaths of @xmath197 .    at the step of the recursive decomposition corresponding to node @xmath201 with separator @xmath196 and two children @xmath202 ,",
    "we store * @xmath203-to - separator * distances : explicitly store the distances ( in @xmath195 ) between every vertex of @xmath12 in @xmath195 and every vertex of @xmath196 , * separator - to - boundary * distances and * separator - to - hole * distances : for @xmath204 , the distances ( in @xmath205 ) between every vertex of @xmath196 and every maximal subpath of @xmath138 or @xmath197 on the boundary of @xmath205 , using lemma  [ lem : unit ] or lemma  [ lem : hole ] ( depending whether they lie on a single or two faces of @xmath205 ) . finally , for every leaf @xmath206 , we store * @xmath12-to - boundary * distances and * @xmath12-to - hole * distances : the distance between the unique distinguished vertex in @xmath195 to every vertex of @xmath138 or @xmath197 on the boundary of @xmath195 .    [",
    "[ analysis . ] ] analysis .",
    "+ + + + + + + + +    we first show that the total space is @xmath207 , and then show that the distances between any pair of vertices in @xmath12 can be recovered using just the information we stored . since the total size of all slice boundaries is @xmath170 , storing the boundary - to - boundary distances and the hole - to - boundary distances takes @xmath208 using lemmas  [ lem : cycle ] and  [ lem : hole ] .",
    "since the depth of @xmath194 is @xmath200 , each vertex of @xmath198 belongs to @xmath200 regions in the decomposition of @xmath57 .",
    "since , in addition , @xmath209 for every @xmath206 , the total space required for storing the @xmath12-to - separator distances is @xmath210 .",
    "consider a region @xmath193 of a slice @xmath57 .",
    "recall that the vertices of @xmath138 ( @xmath197 ) that belong to @xmath193 lie on @xmath211 vertex disjoint maximal subpaths of @xmath138 ( @xmath197 ) .",
    "the endpoints of each such maximal subpath may belong to another region @xmath212 at the same depth in @xmath194 .",
    "therefore , @xmath193 shares @xmath211 vertices of @xmath138 ( @xmath197 ) with other regions at the same depth in @xmath194 . finally , recall that the number of regions of @xmath57 is @xmath213 .",
    "therefore , using lemma  [ lem : unit ] or lemma  [ lem : hole ] , the total space for storing the separator - to - boundary and separator - to - hole distances is @xmath214 . in more detail , let @xmath215 be the total number of slice / hole boundary vertices in the @xmath155-th slice .",
    "then , in every slice every boundary / hole vertex that is not an endpoint of a maximal subpath contributes at most once at each level of recursion . at each level",
    ", we have at most @xmath0 recursive calls , so at most @xmath216 maximal subpaths and at most @xmath0 fundamental cycle separators .",
    "therefore , the total space is @xmath217 .",
    "storing @xmath12-to - boundary distances and @xmath12-to - hole distances at the leaves of the recursion tree requires total @xmath218 bits since each boundary or hole vertex belongs to exactly one leaf region , except for @xmath219 vertices ( endpoints of maximal subpaths ) . choosing @xmath220 proves the space bound .    finally , we prove that the distances between any pair of vertices in @xmath12 can be recovered using just the information we stored . for any @xmath221",
    ", if a shortest @xmath222-to-@xmath223 path does not leave @xmath57 then @xmath224 , and the distance can be obtained using the @xmath12-to - separator distances stored in the lowest common ancestor of the regions of @xmath222 and @xmath223 in @xmath194 .",
    "otherwise , let @xmath142 be a shortest path between vertices @xmath225 and @xmath226 ( where @xmath192 is either @xmath57 or , wlog , enclosed by the hole of @xmath57 ) .",
    "let @xmath227 $ ] denote the subpath of @xmath142 between vertices @xmath155 and @xmath228 .",
    "let @xmath50 be the first vertex of @xmath142 that belongs to the boundary of @xmath192 or to the boundary of a hole of @xmath192 .",
    "if @xmath229 $ ] contains some vertex of a fundamental cycle separator used in processing @xmath192 , let @xmath181 be the last vertex of @xmath142 that belongs to the earliest such separator .",
    "if @xmath181 does not exist , then the length of @xmath229 $ ] is stored as an @xmath12-to - boundary or an @xmath12-to - hole distance .",
    "if @xmath181 exists then the length of @xmath230 $ ] is stored as a @xmath12-to - separator distance , and the length of @xmath231 $ ] is stored as a separator - to - boundary or separator - to - hole distance .",
    "let @xmath232 be the last vertex of @xmath142 that belongs to the boundary of @xmath57 .",
    "the length of @xmath233 $ ] can be computed from boundary - to - boundary and hole - to - boundary distances since @xmath233 $ ] can be decomposed into subpaths between boundary vertices of slices .",
    "the length of the suffix @xmath234 $ ] can be computed in a similar manner to that of the prefix @xmath229 $ ] .",
    "a difficulty that arises in the presence of multiple holes is that since the number of holes is not bounded by a constant , we can not afford to store distances involving holes .",
    "for example , storing hole - to - boundary distances between the external boundary @xmath138 of a slice @xmath57 and the boundary of each hole of @xmath57 requires @xmath235 bits per hole .",
    "since the number of holes can be @xmath236 , the total space could be @xmath237 .",
    "the role of storing distances involving boundaries of holes was to allow the recovery of distances to distinguished vertices enclosed in these holes .",
    "we modify our approach for processing a slice @xmath57 to take into account the distinguished vertices enclosed in holes of @xmath57 as well as the distinguished vertices in @xmath57 itself . as in the single hole case",
    ", the slice @xmath57 will be recursively divided using fundamental cycle separators . for any region @xmath193 encountered along the recursive process , let @xmath238 denote the subset of the distinguished vertices in @xmath193 , as well as those enclosed by any hole in @xmath193 .",
    "thus , for example , @xmath239 is the set of all vertices in @xmath12 that are enclosed ( in @xmath17 ) by the external boundary of slice @xmath57 .",
    "we say that a jordan cycle separator @xmath96 of a region @xmath193 is _ good _ if it is balanced w.r.t .",
    "@xmath238 and does not go through any hole of @xmath193 .",
    "the problem with jordan separators that go through some hole @xmath188 is that they partition the distinguished vertices enclosed by @xmath188 in an unspecified way since these distinguished vertices are not represented in @xmath193 .",
    "it is not hard to see that if a good separator always exists then we do not need to store any distances involving holes .    in reality",
    "we can not always find a good separator .",
    "consider , for example , the case where some hole @xmath188 of a region @xmath193 encloses most of the vertices of @xmath238 . clearly , a separator that is balanced w.r.t .",
    "@xmath238 must go through @xmath188 .",
    "thus , there is no good separator in such a case .",
    "we show , however , that we can always either find a good separator , or there exists some hole ( which we call a _ disposable _ hole ) that can be dealt with in a special way .",
    "this is reminiscent of recursive procedures based on heavy path decomposition , where heavy nodes ( disposable holes in our case ) are treated differently than light ones .",
    "we guarantee that , in either case , each resulting subregion contains only a constant fraction of @xmath238 , so the depth of the recursion is @xmath211 .",
    "we next explain the details .",
    "[ [ good - separators - and - disposable - holes . ] ] good separators and disposable holes .",
    "+ + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + +    let @xmath193 be a region .",
    "we define the weight of each vertex @xmath50 of @xmath193 to be @xmath86 if @xmath50 is a distinguished vertex . for each hole @xmath188 of @xmath193",
    ", we define the weight of the artificial vertex @xmath189 embedded in @xmath188 to be the number of distinguished vertices strictly enclosed ( in the whole graph @xmath17 ) by the boundary of @xmath188 .",
    "all other vertices are assigned weight zero .",
    "recall that a cycle separator is _ good _ if it does not go through any hole .",
    "we would like to separate @xmath193 using a good fundamental cycle separator @xmath240 of some edge @xmath95 w.r.t .",
    "if we can find such separator @xmath240 where @xmath95 is not incident to @xmath189 for some hole @xmath188 , then @xmath240 is a good separator ( since the vertices @xmath189 are leaves of the spanning tree @xmath184 ) . otherwise , we must separate @xmath193 with a fundamental cycle separator that goes through holes .",
    "we next define _ disposable _",
    "holes , and then show that we can allow the fundamental cycles to go through such holes .",
    "let @xmath0 be a node ( level component ) in @xmath157 .",
    "let @xmath162 be the boundary cycle of @xmath0 .",
    "let @xmath95 be an edge of @xmath162 .",
    "note that @xmath241 .",
    "this is because both endpoints @xmath95 have the same level , so , by lemma  [ lem : triangulation ] , neither can be the parent of the other in @xmath184 .",
    "let @xmath242 be the endpoints of @xmath95 in the dual graph , such that @xmath18 is a face in @xmath0 and @xmath243 a face not in @xmath0 .",
    "since @xmath241 , @xmath95 is in the cotree @xmath244 .",
    "consider breaking @xmath244 into two subtrees by deleting @xmath95 .",
    "we say that the edge @xmath95 is _ light _ if the subtree of @xmath244 that contains @xmath243 has weight at most @xmath245 where @xmath246 is the total weight of the vertices of @xmath193 .",
    "note that we defined weights of primal vertices , whereas the vertices of @xmath244 are primal faces . to define face weights ,",
    "evenly redistribute the weight of each vertex among all of its incident faces .",
    "there is an equivalent , primal view of light edges : the jordan cycle @xmath240 partitions @xmath193 into two subgraphs , exactly one of which contains the faces of the level component corresponding to @xmath0 .",
    "we say @xmath95 is _ light _ if the weight of the subgraph that does not contain the level component @xmath0 is at most half the weight of @xmath193 .",
    "we say that a level component @xmath0 is _ disposable _ in region @xmath193 if there are boundary edges of @xmath0 in @xmath193 , and if every edge @xmath95 of the boundary of @xmath0 that is also in @xmath193 is light .",
    "note that , in particular , this definition applies to holes ( since holes are level components ) .",
    "see figure  [ fig : disposable - hole ] .     are shown in double - line grey .",
    "since the boundary of a hole is a level cycle , none of the edges of the boundary of @xmath188 belongs to the spanning tree @xmath184 ( blue ) .",
    "the artificial triangulation vertex @xmath189 of @xmath188 and the triangulation edges ( grey dashed ) are shown .",
    "the cotree @xmath247 is shown in thin red .",
    "suppose that the number of distinguished nodes enclosed by @xmath188 is at least @xmath245 ( so the weight of @xmath189 is at least @xmath245 ) .",
    "then , for any edge @xmath95 of the boundary of @xmath188 , the part of @xmath248 that does not contain faces of @xmath188 weighs at most @xmath245 , so @xmath95 is a light edge and @xmath188 is a disposable hole . [",
    "fig : disposable - hole],scaledwidth=40.0% ]    before showing why disposable holes exist and that they are useful , we first mention a simple property of @xmath247 and then use it to prove the existence of disposable holes .",
    "[ dualtree ] the cotree @xmath247 enters each level component exactly once .",
    "the spanning tree @xmath184 is monotone with respect to node levels .",
    "thus , if @xmath95 is an edge of the boundary of a level component @xmath0 , then one of the components of @xmath249 contains no other faces , vertices or edges of @xmath0 .",
    "see figure  [ fig : tree - cotree ] for an illustration .",
    "( blue ) , the cotree @xmath244 ( red ) , and boundary of level components ( black cycles ) . since @xmath184 is monotone with respect to levels",
    ", @xmath244 enters each level component exactly once .",
    "[ fig : tree - cotree],scaledwidth=50.0% ]    [ lem : recursion ] if a region @xmath193 contains more than one vertex with non - zero weight , then there exists either a good balanced fundamental cycle separator or a disposable hole in @xmath193 .",
    "let @xmath246 be the total weight of vertices in @xmath193 .",
    "consider the component tree @xmath157 .",
    "let @xmath181 be a deepest disposable component in @xmath157 such that @xmath180 has an edge in @xmath193 . if @xmath181 is a hole of @xmath193 then we found a disposable hole , and we are done .",
    "otherwise , we next show that there exists a good separator .",
    "let @xmath250 be the children of @xmath181 in @xmath157 ( if there is no disposable component in @xmath193 , then define @xmath181 to be @xmath193 , @xmath180 to be the external boundary of @xmath193 , and let @xmath251 be the set of rootmost components in @xmath157 such that @xmath252 has an edge in @xmath193 ) .",
    "since none of the @xmath253 s is disposable , for each @xmath253 there exists exactly one boundary edge @xmath254 ( here we wrote @xmath255 as a dual edge , and @xmath256 is the endpoint of @xmath255 that belongs to @xmath253 ) , such that the subtree of @xmath257 that contains @xmath258 has weight at least @xmath245 .",
    "consider the following two phase process ( see figure  [ fig : structural - lemma ] for an illustration ) : let @xmath259 .",
    "if @xmath260 contains more than a single face of some @xmath143 ( in which case it must contain all faces of @xmath143 by property  [ dualtree ] ) , then @xmath261 is obtained from @xmath260 by rooting @xmath260 at @xmath262 and deleting all the strict descendants of @xmath263 in @xmath260 , so that @xmath263 becomes a leaf .",
    "the weight assigned to @xmath263 in @xmath261 is the total weight of all the vertices in the deleted subtree .",
    "thus , the weight of @xmath261 remains @xmath246 , and , by definition of @xmath264 , the weight of @xmath263 is at most @xmath245 .",
    "the first phase terminates when @xmath260 contains at most one face ( @xmath263 ) from each @xmath143 .",
    "in the second phase , while @xmath260 contains an edge @xmath95 of @xmath180 that is not a leaf edge of @xmath260 , then @xmath261 is obtained from @xmath260 by rooting @xmath260 at the endpoint @xmath243 of @xmath95 that belongs to @xmath181 , and deleting all the strict descendants of the other endpoint @xmath18 of @xmath95 in @xmath260 , so that @xmath18 becomes a leaf .",
    "similarly to the first phase , the weight of @xmath18 in @xmath261 is set to the total weight of all the vertices in the deleted subtree . since @xmath181 is disposable , the weight of @xmath18 is at most @xmath245 .",
    "let @xmath265 be the resulting tree .",
    "since @xmath265 contains at most one face from each @xmath253 , @xmath265 contains no triangulation edges of a hole ( both endpoints of a triangulation edge of a hole belong to the hole ) .",
    "furthermore , the total weight of @xmath265 is @xmath246 , and every leaf of @xmath265 created during the two phase process has weight at most @xmath245 ( by definition ) . for the remaining nodes of @xmath265 ,",
    "the degree is at most 3 and the weight is also at most @xmath245 , because the original weights in @xmath247 are at most @xmath245 ( otherwise , the node corresponds to a hole of weight at least @xmath245 that is , by definition , disposable , and we are done ) .",
    "therefore , there exists an edge @xmath95 whose deletion from @xmath265 results in two trees , none of which weighs more than @xmath266 . by construction of the weights of @xmath265 , the balance of the fundamental cycle of @xmath95 w.r.t .",
    "@xmath184 is exactly the ratio of the weights of the subtrees obtained by deleting @xmath95 from @xmath265 .",
    "therefore , the fundamental cycle @xmath240 of @xmath95 w.r.t .",
    "@xmath184 is a balanced jordan cycle separator . since no edge of @xmath265 is a triangulation edge of a hole",
    ", @xmath240 is a good separator .     according to which a good separator is found .",
    "three level boundaries are shown ( black cycles ) .",
    "the external one is @xmath180 , the two cycles enclosed by @xmath180 are @xmath267 and @xmath268 .",
    "the subfigures show the process of splitting the cotree @xmath247 , first at @xmath269 , then at @xmath270 . in the second phase the cotree is further split at the two remaining edges of @xmath180 .",
    "the resulting tree @xmath265 is an induced subtree of @xmath247 in which a balanced edge - separator can be found .",
    "since none of the edges of @xmath265 has both endpoints in any @xmath253 , none of the edges of @xmath265 are triangulation edges of a hole .",
    "[ fig : structural - lemma],title=\"fig:\",scaledwidth=30.0% ]   according to which a good separator is found .",
    "three level boundaries are shown ( black cycles ) .",
    "the external one is @xmath180 , the two cycles enclosed by @xmath180 are @xmath267 and @xmath268 .",
    "the subfigures show the process of splitting the cotree @xmath247 , first at @xmath269 , then at @xmath270 . in the second phase the cotree is further split at the two remaining edges of @xmath180 .",
    "the resulting tree @xmath265 is an induced subtree of @xmath247 in which a balanced edge - separator can be found .",
    "since none of the edges of @xmath265 has both endpoints in any @xmath253 , none of the edges of @xmath265 are triangulation edges of a hole .",
    "[ fig : structural - lemma],title=\"fig:\",scaledwidth=30.0% ] +   according to which a good separator is found .",
    "three level boundaries are shown ( black cycles ) .",
    "the external one is @xmath180 , the two cycles enclosed by @xmath180 are @xmath267 and @xmath268 .",
    "the subfigures show the process of splitting the cotree @xmath247 , first at @xmath269 , then at @xmath270 . in the second phase the cotree is further split at the two remaining edges of @xmath180 .",
    "the resulting tree @xmath265 is an induced subtree of @xmath247 in which a balanced edge - separator can be found .",
    "since none of the edges of @xmath265 has both endpoints in any @xmath253 , none of the edges of @xmath265 are triangulation edges of a hole .",
    "[ fig : structural - lemma],title=\"fig:\",scaledwidth=30.0% ]   according to which a good separator is found .",
    "three level boundaries are shown ( black cycles ) .",
    "the external one is @xmath180 , the two cycles enclosed by @xmath180 are @xmath267 and @xmath268 .",
    "the subfigures show the process of splitting the cotree @xmath247 , first at @xmath269 , then at @xmath270 . in the second phase the cotree is further split at the two remaining edges of @xmath180 .",
    "the resulting tree @xmath265 is an induced subtree of @xmath247 in which a balanced edge - separator can be found .",
    "since none of the edges of @xmath265 has both endpoints in any @xmath253 , none of the edges of @xmath265 are triangulation edges of a hole .",
    "[ fig : structural - lemma],title=\"fig:\",scaledwidth=30.0% ]   according to which a good separator is found .",
    "three level boundaries are shown ( black cycles ) .",
    "the external one is @xmath180 , the two cycles enclosed by @xmath180 are @xmath267 and @xmath268 .",
    "the subfigures show the process of splitting the cotree @xmath247 , first at @xmath269 , then at @xmath270 . in the second phase the cotree is further split at the two remaining edges of @xmath180 .",
    "the resulting tree @xmath265 is an induced subtree of @xmath247 in which a balanced edge - separator can be found . since none of the edges of @xmath265 has both endpoints in any @xmath253 ,",
    "none of the edges of @xmath265 are triangulation edges of a hole .",
    "[ fig : structural - lemma],title=\"fig:\",scaledwidth=30.0% ]    with this structural lemma we can now describe our oracle . consider a slice @xmath57 and let @xmath271 be the subgraph of @xmath17 enclosed by the boundary of @xmath57 .",
    "the goal of processing slice @xmath57 is to store information ( distances ) so that the following distances ( in @xmath271 ) can be recovered from the information stored for all slices contained in @xmath271 .    1 .   the distance between any two distinguished nodes in @xmath271 , 2 .",
    "the distance between any distinguished node in @xmath271 and any vertex on the boundary of @xmath57 .",
    "3 .   the distance between any two vertices on the boundary of @xmath57 .    encoding this information for all slices guarantees that distances between the distinguished vertices in the whole graph are captured .",
    "[ [ the - encoding . ] ] the encoding .",
    "+ + + + + + + + + + + + +    to process a slice @xmath57 , we first encode * boundary - to - boundary * distances : the distances ( in @xmath271 ) between vertices on the boundary of @xmath57 using lemma  [ lem : cycle ] . we then triangulate @xmath57 and define its spanning tree @xmath184 using lemma  [ lem : triangulation ] .",
    "next , we recursively separate @xmath57 using fundamental cycle separators .",
    "the initial region @xmath193 is the entire slice @xmath57 .",
    "its boundary is the external boundary @xmath138 of @xmath57 .",
    "a region @xmath193 is separated into subregions obtained by cutting @xmath193 along some fundamental cycle separator @xmath96 w.r.t .",
    "@xmath184 . since we only use fundamental cycle separators w.r.t .",
    "the same tree @xmath184 , the separators never cross .",
    "hence , the boundary of each new region @xmath212 consists of the contiguous portion of @xmath96 that belongs to @xmath193 , and possibly portions of the boundary of @xmath193 . since @xmath96 crosses @xmath138 at most twice ( at most once for each of the two paths in the fundamental cycle @xmath96 ) , the number of contiguous maximal fragments of @xmath138 in the boundary of @xmath212 is at most one plus the number of such fragments in the boundary of @xmath193 .",
    "consequently , the number of contiguous maximal fragments of @xmath138 in the boundary of any region is bounded by the depth of the recursion , which we will show is @xmath272 .",
    "we now explain how to choose the fundamental cycle separator @xmath96 with which we separate @xmath193 .",
    "this is achieved using two interleaving recursive processes .",
    "we refer to the first one as the outer recursion , and to the second one as the hole elimination recursion . in a step of the outer recursion",
    "we apply lemma  [ lem : recursion ] .",
    "if we find a good balanced fundamental cycle separator @xmath96 , then we use it to separate the region @xmath193 .",
    "every vertex in @xmath238 explicitly stores * @xmath12-to - separator * distances : its distance ( in @xmath271 ) to every vertex of @xmath96 .",
    "in addition , for each subregion @xmath212 , for each contiguous maximal fragment @xmath273 of @xmath138 in @xmath212 , we encode * separator - to - boundary * distances : the distances ( in @xmath212 ) between @xmath273 and @xmath96 using lemma  [ lem : unit ] or lemma  [ lem : hole ] ( depending on whether the vertices of the separator @xmath96 and the vertices of @xmath273 lie on a single or two faces of @xmath212 ) .",
    "then , we call the outer recursion recursively for each subregion @xmath212 .",
    "the outer recursion terminates when there is at most one vertex with positive weight in the current region @xmath193 .",
    "if the only remaining object is an artificial vertex @xmath189 , we apply lemma  [ lem : hole ] to encode * hole - to - boundary * distances : the distances ( in @xmath193 ) between the boundary @xmath197 of @xmath188 and @xmath273 , for each contiguous maximal fragment @xmath273 of @xmath138 in @xmath193 . if the only remaining object is a distinguished vertex @xmath181 , we store * @xmath12-to - boundary * distances : the distances ( in @xmath271 ) from @xmath181 to every vertex of every @xmath273 . if the current region @xmath193 contains no vertices with positive weight , the outer recursion terminates .",
    "if , on the other hand , we found a disposable hole @xmath188 , we store * hole - to - boundary * distances : distances between the boundary @xmath197 of @xmath188 and every contiguous maximal fragment @xmath273 of @xmath138 in @xmath193 .",
    "the weight of the artificial vertex @xmath189 is set to zero .",
    "this reflects the fact that for the rest of the processing of @xmath57 , distinguished vertices enclosed by the hole @xmath188 will not be treated individually and directly , but rather by encoding distances involving the vertices of @xmath197 . from this point on",
    ", vertices of @xmath12 inside @xmath188 are no longer considered vertices of @xmath238 .",
    "we then call the hole elimination process for the hole @xmath188 in region @xmath193 ( see figure  [ fig : disposable ] ) . in a single step of the hole elimination recursion",
    ", a region @xmath193 is separated using a fundamental cycle separator @xmath96 w.r.t . @xmath184",
    "that is balanced w.r.t .",
    "the number of vertices of @xmath197 in @xmath193 ( i.e. , a weight 1 is assigned to each vertex of @xmath197 and 0 to all other vertices ) . note that @xmath96 is necessarily a fundamental cycle w.r.t .",
    "@xmath184 of some triangulation edge that is incident to @xmath189 .",
    "the boundary of each of the two resulting regions contains a single contiguous portion of @xmath197 consisting of roughly half the vertices of @xmath197 in @xmath193 .",
    "similarly to the single hole case , we store * @xmath12-to - separator * distances : distances ( in @xmath271 ) from every vertex of @xmath238 to every vertex of @xmath96 . for each subregion @xmath212 obtained by separating @xmath193 along @xmath96 , for each contiguous fragment @xmath273 of @xmath138 in @xmath212 , we encode * separator - to - boundary * distances : the distances ( in @xmath212 ) between @xmath273 and @xmath96 using lemma  [ lem : unit ] or lemma  [ lem : hole ] , and * separator - to - hole * distances : the distances ( in @xmath212 ) between @xmath96 and the single contiguous fragment of @xmath197 that belongs to @xmath212 using lemma  [ lem : unit ] .",
    "we then apply the hole elimination process recursively to each subregion @xmath212 .",
    "it terminates when the current region @xmath193 contains at most two consecutive vertices of @xmath197 , or when it contains at most one distinguished vertices .",
    "when this happens , we continue with the outer recursion on @xmath193 .     with artificial vertex @xmath189 in a region @xmath274",
    "is shown in top - left .",
    "the spanning tree @xmath184 is indicated in blue .",
    "@xmath274 is recursively separated using fundamental cycle separators that are balanced w.r.t . the number of nodes of the boundary @xmath197 of @xmath188 .",
    "the elimination process finishes ( bottom - left ) when the current region @xmath193 contains only two consecutive vertices of @xmath197 , which are the endpoints of some edge @xmath95 .",
    "this region @xmath193 differs from the the region @xmath212 obtained by separating @xmath274 using the fundamental cycle of @xmath95 w.r.t .",
    "@xmath184 by a single vertex ( @xmath189).[fig : disposable],title=\"fig:\",scaledwidth=25.0% ]   with artificial vertex @xmath189 in a region @xmath274 is shown in top - left .",
    "the spanning tree @xmath184 is indicated in blue .",
    "@xmath274 is recursively separated using fundamental cycle separators that are balanced w.r.t . the number of nodes of the boundary @xmath197 of @xmath188 .",
    "the elimination process finishes ( bottom - left ) when the current region @xmath193 contains only two consecutive vertices of @xmath197 , which are the endpoints of some edge @xmath95 .",
    "this region @xmath193 differs from the the region @xmath212 obtained by separating @xmath274 using the fundamental cycle of @xmath95 w.r.t .",
    "@xmath184 by a single vertex ( @xmath189).[fig : disposable],title=\"fig:\",scaledwidth=25.0% ]   with artificial vertex @xmath189 in a region @xmath274 is shown in top - left .",
    "the spanning tree @xmath184 is indicated in blue .",
    "@xmath274 is recursively separated using fundamental cycle separators that are balanced w.r.t . the number of nodes of the boundary @xmath197 of @xmath188 .",
    "the elimination process finishes ( bottom - left ) when the current region @xmath193 contains only two consecutive vertices of @xmath197 , which are the endpoints of some edge @xmath95 .",
    "this region @xmath193 differs from the the region @xmath212 obtained by separating @xmath274 using the fundamental cycle of @xmath95 w.r.t .",
    "@xmath184 by a single vertex ( @xmath189).[fig : disposable],title=\"fig:\",scaledwidth=25.0% ]   with artificial vertex @xmath189 in a region @xmath274 is shown in top - left .",
    "the spanning tree @xmath184 is indicated in blue .",
    "@xmath274 is recursively separated using fundamental cycle separators that are balanced w.r.t . the number of nodes of the boundary @xmath197 of @xmath188 .",
    "the elimination process finishes ( bottom - left ) when the current region @xmath193 contains only two consecutive vertices of @xmath197 , which are the endpoints of some edge @xmath95 .",
    "this region @xmath193 differs from the the region @xmath212 obtained by separating @xmath274 using the fundamental cycle of @xmath95 w.r.t .",
    "@xmath184 by a single vertex ( @xmath189).[fig : disposable],title=\"fig:\",scaledwidth=25.0% ]   with artificial vertex @xmath189 in a region @xmath274 is shown in top - left .",
    "the spanning tree @xmath184 is indicated in blue .",
    "@xmath274 is recursively separated using fundamental cycle separators that are balanced w.r.t . the number of nodes of the boundary @xmath197 of @xmath188 .",
    "the elimination process finishes ( bottom - left ) when the current region @xmath193 contains only two consecutive vertices of @xmath197 , which are the endpoints of some edge @xmath95 .",
    "this region @xmath193 differs from the the region @xmath212 obtained by separating @xmath274 using the fundamental cycle of @xmath95 w.r.t .",
    "@xmath184 by a single vertex ( @xmath189).[fig : disposable],title=\"fig:\",scaledwidth=25.0% ]    we next prove that the total depth of the entire recursive procedure is @xmath275 .    [ [ analyzing - the - recursion - depth . ] ] analyzing the recursion depth .",
    "+ + + + + + + + + + + + + + + + + + + + + + + + + + + + + +    we begin with the initial region @xmath274 being the entire slice . in a single step of the outer recursion ,",
    "if we find a good separator then we use it to separate the current region @xmath274 thus decreasing the weight of each resulting region @xmath193 by a constant factor .",
    "if however we do not find a good separator , then we apply the hole elimination process on a disposable hole @xmath188 of the current region @xmath274 . since @xmath276 , and since every recursive call to the hole elimination process decreases the number of nodes of @xmath197 by half",
    ", we get that after @xmath200 recursive calls the hole elimination process terminates , with each resulting region @xmath193 containing only two nodes of @xmath197 .",
    "observe that these two nodes must be adjacent on @xmath197 ( see figure  [ fig : disposable ] ) .",
    "let @xmath95 be the edge between them and let @xmath240 be the fundamental cycle of @xmath95 w.r.t . @xmath184 .",
    "since @xmath188 is disposable , the weight of the region @xmath212 obtained by separating @xmath274 using @xmath240 is at most half the weight of region @xmath274 . since @xmath277 and",
    "since the weight of @xmath189 is zero this means that the weight of @xmath193 is at most half the weight of @xmath274 .",
    "we conclude that every @xmath200 consecutive recursive calls the total weight of a region decreases by a constant factor .",
    "this shows that the depth of the recursion is @xmath278 .",
    "[ [ correctness . ] ] correctness .",
    "+ + + + + + + + + + + +    we next prove that the distance between any two distinguished vertices in @xmath12 can be recovered from our encoding .",
    "[ lem : x_s - to - b ] the length of a shortest path @xmath142 in @xmath271 from any @xmath279 to any @xmath280 can be recovered from the encoding .",
    "if @xmath142 contains some vertex of a fundamental cycle separator used in processing @xmath57 , let @xmath50 be the last vertex of @xmath142 that belongs to the earliest such separator .",
    "by choice of the earliest separator , the @xmath222-to-@xmath50 distance ( in @xmath271 ) is stored ( @xmath12-to - separator distance ) . by choice of the last vertex on @xmath142 that belongs to that separator , the @xmath50-to-@xmath223 distance ( in the region of @xmath57 that contains @xmath281 $ ] )",
    "is stored ( separator - to - boundary distance ) .",
    "thus , the length of @xmath142 can be recovered .",
    "if @xmath142 contains no such vertex , then @xmath222 and @xmath223 are in the same region when the recursion terminates , so the @xmath222-to-@xmath223 distance ( in @xmath271 ) is stored as a @xmath12-to - boundary distance .",
    "we extend the previous lemma and show that it applies also to distinguished vertices enclosed by holes of @xmath57 ( i.e. , for @xmath239 instead of @xmath198 ) .",
    "[ lem : x^s - to - b ] the length of a shortest path @xmath142 in @xmath271 from any @xmath282 to any @xmath280 can be recovered from the encoding .",
    "the proof is by induction on the nesting depth of slice @xmath57 .",
    "the base case follows from lemma  [ lem : x_s - to - b ] . for the inductive step ,",
    "if @xmath279 we are done by lemma  [ lem : x_s - to - b ] , so assume @xmath222 is enclosed by some hole @xmath188 of @xmath57 .",
    "if @xmath142 contains some vertex of a fundamental cycle separator used in processing @xmath57 before hole @xmath188 is eliminated , let @xmath50 be the last vertex of @xmath142 that belongs to the earliest such separator .",
    "by choice of the earliest separator , the @xmath222-to-@xmath50 distance ( in @xmath271 ) is stored ( @xmath12-to - separator distance ) , and by choice of the last vertex of that separator on @xmath142 , the @xmath50-to-@xmath223 distance ( in a region of @xmath57 that contains @xmath281 $ ] ) is stored ( separator - to - boundary distance ) .",
    "thus , the length of @xmath142 can be recovered .",
    "if @xmath142 contains no such vertex , then the artificial vertex @xmath189 and @xmath223 are in the same region @xmath193 when either the recursion terminates , or the hole @xmath188 is eliminated . in either case , the @xmath197-to-@xmath223 distances are stored ( hole - to - boundary distance ) .",
    "decompose @xmath142 into a maximal prefix @xmath229 $ ] enclosed by the slice @xmath192 whose boundary is @xmath197 , a maximal suffix @xmath234 $ ] enclosed by @xmath193 , and an infix @xmath233 $ ] .",
    "the length of the prefix is stored by the inductive hypothesis for @xmath192 .",
    "the length of the infix is represented by the boundary - to - boundary distances for @xmath192 .",
    "the length of the suffix is stored ( hole - to - boundary distance ) .",
    "finally , we extend the previous lemma and show that it applies to any two distinguished vertices .    .",
    "a slice @xmath57 with two holes is shown .",
    "the boundary @xmath138 is double - lined . a @xmath222-to-@xmath223 shortest path @xmath142",
    "is shown in solid black .",
    "the vertices @xmath222 and @xmath223 belong to different holes of @xmath57 ( black cycles ) .",
    "the path @xmath142 crosses a fundamental cycle separator ( blue , parts that do not belong to @xmath57 are dashed ) used in eliminating the hole to which @xmath223 belongs .",
    "[ fig : correct],scaledwidth=50.0% ]    [ lem : x - to - x ] the length of a shortest path @xmath142 in @xmath271 from any @xmath283 to any @xmath284 can be recovered from the encoding .",
    "assume , wlog , that both @xmath222 and @xmath223 are enclosed in holes of @xmath57 ( the other cases are similar and less general ) . if @xmath142 contains some vertex of a fundamental cycle separator used in processing @xmath57",
    "before either hole is eliminated , then let @xmath50 be a vertex of @xmath142 that belongs to the earliest such separator .",
    "by choice of the earliest separator , both the @xmath222-to-@xmath50 and the @xmath223-to-@xmath50 distances ( in @xmath271 ) are stored ( @xmath12-to - separator distance ) .",
    "thus , the length of @xmath142 can be recovered .",
    "otherwise , the hole of @xmath222 and the hole of @xmath223 are in the same region @xmath193 when one of them , say the hole @xmath188 of @xmath222 , is eliminated .",
    "if @xmath142 intersects one of the fundamental cycle separators used during the elimination process of hole @xmath188 , then let @xmath50 be the last vertex on the earliest such separator ( see figure  [ fig : correct ] ) .",
    "by choice of earliest separator , the @xmath222-to-@xmath50 distance is stored ( @xmath12-to - separator distance ) . by lemma  [ lem : x^s - to - b ] ,",
    "the length of the maximal suffix @xmath234 $ ] enclosed in @xmath188 is also stored .",
    "let @xmath181 be the first vertex of @xmath233 $ ] that belongs to either @xmath138 or @xmath197 ( @xmath181 exists because @xmath223 is enclosed by @xmath197 and @xmath50 is not ) .",
    "* if @xmath181 belongs to @xmath138 then the length of @xmath285 $ ] is stored ( separator - to - boundary distance ) . in this case , let @xmath286 be the last vertex of @xmath142 that belongs to @xmath138 .",
    "the length of @xmath287 $ ] is represented by boundary - to - boundary distances for @xmath138 .",
    "let @xmath58 be the first vertex of @xmath288 $ ] that belongs to @xmath197 .",
    "the length of @xmath289 $ ] is represented as a hole - to - boundary distance ( when @xmath188 is eliminated ) .",
    "let @xmath164 be the last vertex of @xmath290 $ ] that belongs to @xmath197 .",
    "the length of @xmath291 $ ] is represented by boundary - to - boundary distances for @xmath197 , and the length of @xmath292 $ ] is represented by lemma  [ lem : x^s - to - b ] .",
    "see figure  [ fig : correct ] for an illustration .",
    "* if @xmath181 belongs to @xmath197 then the length of @xmath285 $ ] is represented as a separator - to - hole distance .",
    "the representation of the suffix @xmath293 $ ] is then similar to the previous case .    finally , we need to treat the case where @xmath142 does not intersect any fundamental cycle used in eliminating the hole @xmath188 . in this case",
    "@xmath142 can be decomposed into a @xmath222-to-@xmath138 prefix , a @xmath197-to-@xmath223 suffix , and subpaths of @xmath142 between vertices of @xmath294 .",
    "the prefix and suffix are represented by lemma  [ lem : x^s - to - b ] .",
    "the other subpaths are represented as hole - to - boundary or boundary - to - boundary distances as in the two cases above .",
    "finally , we now show that the entire encoding requires only @xmath295 bits .",
    "[ [ the - encoding - size . ] ] the encoding size .",
    "+ + + + + + + + + + + + + + + + + +    the space required for the boundary - to - boundary distances for all slices is @xmath296 since the total boundary size is @xmath170 , and by lemma  [ lem : cycle ] .",
    "we next bound the total space required for @xmath12-to - separator distances for all slices .",
    "whenever a distinguished vertex stores its distances to a path @xmath142 explicitly , the total weight of its region decreases by a constant factor within @xmath272 recursive steps ( either immediately , if this happens in the outer recursion , or otherwise by the time the hole - elimination process ends ) .",
    "so this can happen @xmath272 times per distinguished vertex . because @xmath297 ( by the height of @xmath184 ) , this sums up to a total of @xmath298 bits .    the analysis of the remaining distances is done for each slice separately .",
    "we have already argued that the depth of the recursive process to handle a slice @xmath57 is @xmath275 .",
    "similarly to the analysis in section  [ singleholesection ] of the single hole case , the total space required for storing separator - to - boundary distances using lemma  [ lem : unit ] or lemma  [ lem : hole ] at all calls at the same recursive level is @xmath299 . for exactly the same reasons ,",
    "the total space required for storing separator - to - hole distances using lemma  [ lem : unit ] at all calls at the same recursive level ( this only happens in the hole - elimination recursion ) is @xmath300 .",
    "hole - to - boundary distances are stored using lemma  [ lem : hole ] for at most one hole in each region along the recursion .",
    "each invocation of lemma  [ lem : hole ] for hole @xmath197 and boundary fragment @xmath273 requires @xmath301 bits . for a single level of the recursion ,",
    "this sums up to @xmath218 because the total size of all boundaries is @xmath170 and there are @xmath302 vertices that contribute in more than one region ( endpoints of @xmath273 s ) .",
    "the bound for @xmath12-to - boundary distances is @xmath218 for the same reasons .",
    "to conclude , we showed that the total size of the entire encoding is bounded by @xmath303 , which is @xmath295 by choosing @xmath220 .",
    "recall that gavoille et al .",
    "@xcite show how to construct , given a boolean @xmath304 matrix @xmath305 , a planar grid @xmath306 containing @xmath307 vertices , such that @xmath305 can be recovered from the distances between @xmath0 distinguished vertices of @xmath306 .",
    "this shows that , for @xmath308 , encoding all distances between @xmath0 vertices of a planar graph requires @xmath309 bits . for @xmath310 ,",
    "we consider @xmath58 boolean @xmath311 matrices @xmath312 .",
    "for each of these matrices , we construct a planar grid containing @xmath313 vertices .",
    "the disjoint union of all these grids is a planar graph on @xmath314 vertices , such that all boolean matrices can be recovered from the distances between the @xmath0 distinguished vertices .",
    "hence , encoding all such distances requires @xmath315 bits . setting @xmath316",
    "we obtain that encoding all distances between the @xmath0 distinguished vertices of a planar graph on @xmath1 vertices requires @xmath42 bits .",
    "the goal of section  [ sec : upper ] was to guarantee that all distances between distinguished vertices are captured , but we were not concerned with the complexity of retrieving such a distance . in this section",
    "we explain how to augment the encoding to allow efficient extraction of the stored distances .",
    "we start with reformulating our encoding using the notion of _ dense distance graphs_. vertices of a dense distance graph are listed explicitly , but its edges are described implicitly with unit monge matrices .",
    "each such matrix describes lengths of the edges between every @xmath317 and @xmath318 , for some subsets of nodes @xmath319 and @xmath320 .",
    "the matrix is represented using @xmath321 bits as described in lemma  [ lem : unit ] . in particular , we may have @xmath322 and then the matrix simply stores the length of a single edge explicitly .",
    "the size of a dense distance graph is the total number of vertices plus the sum of @xmath323 over all matrices describing length of the edges . by construction ,",
    "our encoding described in section  [ sec : upper ] is based on defining a dense distance graph of size @xmath295 .",
    "every distinguished node of the original graph is a vertex of the dense distance graph , and the distance between two distinguished nodes of the original ( unweighted ) graph is the same as the distance between their corresponding vertices in the ( weighted ) dene distance graph .",
    "fakcharoenphol and rao designed an efficient algorithm for computing the shortest paths in such a graph , nicknames the fr - dijkstra :  -division of a planar graph .",
    "the vertices are the boundary nodes and distances between boundary nodes in the same region are represented with multiple monge matrices . however , it is easy to see that their algorithm work for any dense distance graph as defined above . ]",
    "[ lem : fr ] distance between any two vertices of a dense distance graph of size @xmath57 can be found in @xmath122 time .",
    "applying lemma  [ lem : fr ] gives us an oracle of size @xmath295 answering queries in @xmath295 time .",
    "for very large @xmath0 , say @xmath324 , the query time is clearly not optimal , as there exists an oracle of size @xmath325 answering queries in @xmath326  @xcite time . in the remaining part of this section",
    "we will describe how to construct an oracle of size @xmath295 answering queries in @xmath327 time .    to improve the query time , we apply the vanilla planar separator lemma .    [",
    "lem : separator ] for any planar graph @xmath17 on @xmath1 nodes , there exists a partition of the nodes of @xmath17 into sets @xmath328 , @xmath305 , and @xmath12 , such that @xmath329 , @xmath330 , and there are no edges between the nodes of @xmath328 and @xmath305 .",
    "we recursively apply lemma  [ lem : separator ] to construct a hierarchical decomposition of the whole graph .",
    "the recursion is described by a binary tree @xmath172 , where every node @xmath331 corresponds to an induced subgraph @xmath332 of the original graph .",
    "we let @xmath333 and @xmath334 denote the number of nodes and distinguished nodes in @xmath332 , respectively . we terminate the recursion as soon as @xmath335 .",
    "if @xmath331 is a leaf , we define its set of distinguished nodes @xmath336 to consists of all the distinguished nodes of @xmath332 .",
    "otherwise , @xmath336 consists of the following nodes :    1 .   the separator of @xmath332 , 2 .   for every child @xmath50 of @xmath181 that is a leaf , all the distinguished nodes of @xmath337 , 3",
    "for every child @xmath50 of @xmath181 that is not a leaf , the separator of @xmath337 .    then , we construct a dense distance graph of size @xmath338 capturing distances between any two nodes from @xmath336 in @xmath332 .",
    "to calculate the distance @xmath339 between two distinguished nodes @xmath181 and @xmath50 in @xmath17 , we locate the deepest nodes @xmath340 and @xmath341 of @xmath172 , such that @xmath342 and @xmath343 .",
    "then , we consider the union of all dense distance graphs constructed for the nodes of @xmath172 on the paths from @xmath340 and @xmath341 to the root .",
    "note that the same node of @xmath17 might appear in more than one of these dense distance graphs , and we identify all of its copies . by construction",
    ", the obtained dense distance graph captures the sought distance .",
    "furthermore , its size is bounded by @xmath344 therefore , by lemma  [ lem : fr ] we can answer a query in @xmath327 time . it remains to bound the size of the resulting oracle .",
    "[ lem : nodesize ] the dense distance graph constructed for node @xmath331 is of size @xmath345 .    to prove the lemma it is enough to bound @xmath346 by @xmath347 .",
    "if @xmath181 is a leaf , this is clear .",
    "otherwise , @xmath348 and @xmath336 consists of the following nodes :    1 .",
    "the separator of @xmath332 of size @xmath349 .",
    "2 .   for every child",
    "@xmath50 of @xmath181 that is a leaf , all @xmath350 distinguished nodes of @xmath337 , 3 .   for every child @xmath50 of @xmath181 that is not a leaf , the separator of @xmath337 of size @xmath351 .",
    "node @xmath181 has at most two children , so indeed @xmath352 .",
    "to upper bound the size of the oracle , we need to upper bound the sum @xmath353 . to this end",
    ", we separately consider all nodes @xmath331 such that @xmath354 , for every @xmath355 .",
    "fix @xmath356 and call these nodes @xmath357 .",
    "then , no @xmath358 is a descendant of another @xmath359 , so every node of the original graph appears in at most one @xmath360 .",
    "therefore , @xmath361 and @xmath362 . from the latter inequality and the lower bound on @xmath333",
    "we obtain that @xmath363 .",
    "now we want to upper bound the following sum : @xmath364 from the concavity of @xmath365 , the above sum is maximized when @xmath366 , so we obtain : @xmath367 to obtain an upper bound on @xmath353 , we only need to multiply the above bound by @xmath368 because for every @xmath331 there exists @xmath356 such that @xmath333 belongs to the appropriate interval , so the total size of the oracle is @xmath369 .",
    "a distance labeling scheme is a way to compress graphs that allows for distributed decoding .",
    "the goal is to assign a label @xmath49 for each node @xmath50 , so that by looking at the labels of two nodes @xmath51 ( without access to the original graph ) we can infer the distance between them @xmath52 .",
    "the main question one asks about such schemes is _ how small can the labels be _ ?",
    "a famous open question is to close the gap between the @xmath370 upper bound @xcite and the @xmath11 @xcite lower bound for planar graphs . the only known technique capable of proving a tight lower bound is via a lower bound for the metric compression problem :",
    "if you show that the metric can not be compressed into @xmath371 bits , then you show that no labels of size @xmath372 are possible .",
    "our work deems this approach impassable , since such compressions are indeed possible .",
    "optimistically , it is natural to ask if our upper bound for compression could lead to a better upper bound for labeling .",
    "our encoding assigns @xmath373 bits per node , but can we distribute these bits to the nodes while allowing any pair of nodes to deduce the distance from their local information ? in this section , we discuss why this seems difficult .",
    "the heart of our encoding is lemma  [ lem : unit ] , which is repeatedly used to capture pairwise distances between a large subset of nodes of the graph using space proportional to the size of the subset .",
    "a key part in the proof of the lemma is an efficient encoding of an @xmath88 matrix into @xmath43 bits , as long as it has the _ unit - monge _ property , that is : @xmath374 + m[i , j]- m[i , j+1 ] - m[i+1,j ] & \\geq & 0 & \\qquad\\text { for any } i , j \\in [ 1,n-1 ] , \\\\       and every",
    "@xmath47 $ ] is an non - negative integer not exceeding @xmath1 .",
    "the corresponding labeling problem would be to assign a label to every row and every column of @xmath44 , such that @xmath47 $ ] can be computed from the label of the @xmath155-th row and the @xmath228-th column .",
    "we will show that the @xmath43 bits of the encoding _ can not _",
    "be distributed into @xmath71 bits per label . in any such labeling scheme",
    ", some labels must be of length @xmath375 . for completeness",
    ", we will also provide a matching upper bound of @xmath326 .",
    "we start with recalling the following connection between unit - monge matrices and permutation matrices .",
    "@xmath142 is a permutation matrix if every row and every column contains at most one 1 and 0s elsewhere .",
    "then , it is straightforward to verify that , for any permutation matrix @xmath142 the matrix @xmath44 defined as @xmath47=\\sum_{i ' \\geq i , j'\\geq j } p[i',j']$ ] is a unit - monge matrix .",
    "in fact , essentially any unit - monge matrix can be obtained through such transformation .",
    "this is known , see e.g. section 2 in  @xcite , but we provide a proof for completeness .",
    "[ lem : unitperm ] for any unit - monge matrix @xmath44 , there exists a permutation matrix @xmath142 , such that @xmath376 = h[i]+v[j]+\\sum_{i ' \\geq i , j'\\geq j } p[2i',2j'].\\ ] ] where @xmath377 and @xmath320 are vectors of length @xmath1 with non - negative entries bounded by @xmath1 .",
    "we define an @xmath378 matrix @xmath148 as follows : @xmath379 = m[i+1,j+1 ] + m[i , j ] - m[i , j+1 ] - m[i+1,j].\\ ] ] by monge , clearly @xmath380 \\geq 0 $ ] , and by unit @xmath380\\leq 2 $ ] .",
    "in fact , unit also implies that the sum in every row and every column of @xmath148 is at most 2 . to see this for rows ,",
    "consider @xmath381+p'[i,2]+\\ldots+p'[i , n]$ ] .",
    "after telescoping , this is @xmath381-p[i+1,1]+p[i+1,n]-p[i , n]$ ] , so by unit at most 2 as claimed",
    ". then , consider @xmath382 $ ] .",
    "after substituting the definition of @xmath148 and telescoping , this becomes @xmath47+m[n , n]-m[i , n]-m[n , j]$ ] .",
    "hence , if we define @xmath383=m[i , n]-m[n , n]/2 $ ] and @xmath384=m[n , j]-m[n , n]/2 $ ] it holds that @xmath47 = h[i]+v[j ] + \\sum_{i ' \\geq i , j ' \\geq j } p'[i',j']$ ] .",
    "finally , we create an @xmath385 matrix @xmath142 , where every @xmath386 block corresponds to a single @xmath380 $ ] , that is , the sum of values in the block is equal to @xmath380 $ ] .",
    "it is always possible to define @xmath142 so that it is a permutation matrix . to see this ,",
    "consider a row of @xmath148 .",
    "the values there sum up to at most 2 , say @xmath380=p'[i , j']=1 $ ] for some @xmath387",
    ". then , @xmath380 $ ] should correspond to a 1 in the first row of its block and @xmath388 $ ] to a 1 in the second row of its block .",
    "if @xmath389 then in the corresponding block we create two 1s , one per row .",
    "columns are chosen with a symmetric reasoning .",
    "due to the above lemma , we can focus on assigning a label to every row and column of @xmath142 , such that given the label of the @xmath155-th row and the @xmath228-th column we can compute @xmath390 $ ] .",
    "we call this problem labeling @xmath391 unit - monge matrices for dominance sum queries .",
    "we can assume that there is exactly one 1 in every row and column of @xmath142 .",
    "therefore , the input is fully described by a permutation @xmath393 .",
    "any permutation on @xmath1 elements can be decomposed by up to @xmath394 increasing subsequences @xmath395 and up to @xmath394 decreasing subsequences @xmath396 .",
    "the label of every row and every column consists of @xmath200 bits stored for every such subsequence , thus @xmath392 bits in total .",
    "we think of every subsequence as a set of points @xmath397 and the @xmath200 bits corresponding to this subsequence in the label of the @xmath155-th row and the @xmath228-th column should be enough to determine the number of points @xmath398 such that @xmath399 and @xmath400 .",
    "we separately describe what should be stored for an increasing subsequence and then for a decreasing subsequence .",
    "consider an increasing subsequence consisting of points @xmath397 , such that @xmath401 and @xmath402 for every @xmath403 .",
    "then , the label of the @xmath155-th row stores the smallest @xmath0 such that @xmath399 , and similarly the label of the @xmath228-th row stores the smallest @xmath0 such that @xmath400 . by taking the maximum of these two numbers we can determine the number of points @xmath398 such that @xmath399 and @xmath400 .    now consider a decreasing subsequence consisting of points @xmath397 , such that @xmath401 and @xmath404 for every @xmath403 .",
    "then , the label of the @xmath155-th row stores the smallest @xmath0 such that @xmath399 .",
    "the label of the @xmath228-th row stores the largest @xmath0 such that @xmath400 . denoting the number stored for the @xmath155-th row and the @xmath228-th row by @xmath356 and @xmath164 , respectively , the number of points @xmath398 such that @xmath399 and @xmath400 can be calculated as @xmath405 .",
    "we conceptually divide an @xmath378 matrix @xmath142 into blocks of size @xmath407 , thus creating an @xmath407 matrix @xmath305 , where every entry @xmath408 $ ] corresponds to a block of @xmath142 . for every block",
    "@xmath408 $ ] we choose one bit @xmath409 $ ] .",
    "we will show that then it is always possible to construct the matrix @xmath142 , such that all bits @xmath409 $ ] can be retrieved from the labels of rows of the form @xmath410 and columns of the form @xmath410 .",
    "then it follows that we can encode @xmath1 bits of information in @xmath411 labels , hence one of these labels must consist of @xmath412 bits .",
    "it remains to construct @xmath142 .",
    "we construct @xmath142 incrementally .",
    "we call a row or a column of @xmath142 active if there is no 1 there .",
    "we start with an empty @xmath142 and keep adding 1s there while making ensure that there is at most one 1 in every row and column . given the labels of all rows @xmath410 and all columns of the form @xmath410 we can count 1s in every block of @xmath142 .",
    "the goal is to ensure that this count is equal to @xmath409 $ ] .",
    "assume that this is already the case for every @xmath409 $ ] such that @xmath413 or @xmath414 and @xmath387 and consider @xmath415 $ ] .",
    "if @xmath415=0 $ ] we continue . otherwise , we have to choose exactly one active row @xmath164 in the range @xmath416 $ ] and exactly one active column @xmath417 in the range @xmath418 $ ] , and set @xmath419=1 $ ] , thus making both @xmath164 and @xmath417 inactive .",
    "this clearly guarantees that there is exactly one 1 in the corresponding block of @xmath142 .",
    "the only problem is to guarantee that there is at least one active row and column in the appropriate ranges .",
    "however , we have deactivated less than @xmath420 rows in the range @xmath421 $ ] so far , and similarly less than @xmath422 columns in the range @xmath423 $ ] , so indeed there is at least one active row and column that we can use .",
    "a.  aggarwal and j.  k. park",
    ". notes on searching in multidimensional monotone arrays ( preliminary version ) . in _ 29th annual symposium on foundations of computer science , white plains , new york , usa , 24 - 26 october 1988 _ , pages 497512 , 1988 .",
    "a.  aggarwal and s.  suri .",
    "fast algorithms for computing the largest empty rectangle . in _ proceedings of the third annual symposium on computational geometry , waterloo , ontario , canada , june 8 - 10 , 1987 _ , pages 278290 , 1987 .",
    "s.  arikati , d.  z. chen , l.  p. chew , g.  das , m.  smid , and c.  d. zaroliagis .",
    "planar spanners and approximate shortest path queries among obstacles in the plane . in _",
    "4th esa _ ,",
    "pages 514528 .",
    "springer , 1996 ."
  ],
  "abstract_text": [
    "<S> the planar graph metric compression problem is to compactly encode the distances among @xmath0 nodes in a planar graph of size @xmath1 . </S>",
    "<S> two nave solutions are to store the graph using @xmath2 bits , or to explicitly store the distance matrix with @xmath3 bits . the only lower bounds are from the seminal work of gavoille , peleg , prennes , and raz [ soda01 ] , who rule out compressions into a polynomially smaller number of bits , for _ weighted _ planar graphs , but leave a large gap for unweighted planar graphs . </S>",
    "<S> for example , when @xmath4 , the upper bound is @xmath2 and their constructions imply an @xmath5 lower bound . </S>",
    "<S> this gap is directly related to other major open questions in labelling schemes , dynamic algorithms , and compact routing .    </S>",
    "<S> our main result is a new compression of the planar graph metric into @xmath6 bits , which is optimal up to log factors . </S>",
    "<S> our data structure breaks an @xmath7 lower bound of krauthgamer , nguyen , and zondiner [ sicomp14 ] for compression using minors , and the lower bound of gavoille et al . for compression of weighted planar graphs . </S>",
    "<S> this is an unexpected and decisive proof that weights can make planar graphs inherently more complex . </S>",
    "<S> moreover , we design a new _ subset distance oracle _ for planar graphs with @xmath8 space , and @xmath9 query time .    </S>",
    "<S> our work carries strong messages to related fields . </S>",
    "<S> in particular , the famous @xmath10 vs. @xmath11 gap for distance labelling schemes in planar graphs _ can not _ be resolved with the current lower bound techniques . </S>"
  ]
}