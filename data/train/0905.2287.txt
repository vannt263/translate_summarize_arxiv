{
  "article_text": [
    "since its introduction in a centralized context  @xcite , the minimum spanning tree ( or mst ) construction problem gained a benchmark status in distributed computing thanks to the influential seminal work of  @xcite . given an edge - weighted graph @xmath0 , where @xmath1 denotes the edge - weight function , the mst problem consists in computing a tree @xmath2 spanning @xmath3 , such that @xmath2 has minimum weight among all spanning trees of @xmath4 .",
    "one of the most versatile technique to ensure forward recovery of distributed systems is that of _ self - stabilization _  @xcite .",
    "a distributed algorithm is self - stabilizing if after faults and attacks hit the system and place it in some arbitrary global state , the system recovers from this catastrophic situation without external ( _ e.g. _ human ) intervention in finite time .",
    "a recent trend in self - stabilizing research is to complement the self - stabilizing abilities of a distributed algorithm with some additional _ safety _ properties that are guaranteed when the permanent and intermittent failures that hit the system satisfy some conditions .",
    "in addition to being self - stabilizing , a protocol could thus also tolerate a limited number of topology changes  @xcite , crash faults  @xcite , nap faults  @xcite , byzantine faults  @xcite , and sustained edge cost changes  @xcite .",
    "this last property is specially relevant when building spanning trees in dynamic networks , since the cost of a particular edge is likely to evolve through time .",
    "if a mst protocol is _ only _ self - stabilizing , it may adjust to the new costs in such a way that a previously constructed mst evolves into a disconnected or a looping structure ( of course , in the abscence of new edge cost changes , the self - stabilization property guarantees that _ eventually _ a new mst is constructed ) .",
    "of course , if edge costs change unexpectedly and continuously , a mst can not be maintained at all times .",
    "now , a packet routing algorithm is _ loop free _",
    "@xcite if at any point in time the routing tables are free of loops , despite possible modification of the edge - weights in the graph ( _ i.e. _ , for any two nodes @xmath5 and @xmath6 , the actual routing tables determines a simple path from @xmath5 to @xmath6 , at any time ) .",
    "the _ loop - free _",
    "property  @xcite in self - stabilization guarantees that , a spanning tree being constructed ( not necessarily a mst ) , then the self - stabilizing convergence to a `` minimal '' ( for some metric ) spanning tree maintains a spanning tree at all times ( obviously , this spanning tree is not `` minimal '' at all times ) .",
    "the consequence of this safety property in addition to that of self - stabiization is that the spanning tree structure can still be used ( e.g. for routing ) while the protocol is adjusting , and makes it suitable for networks that undergo such very frequent dynamic changes .",
    "[ [ related - works ] ] related works + + + + + + + + + + + + +    gupta and srimani  @xcite have presented the first self - stabilizing algorithm for the mst problem .",
    "it applies on graphs whose nodes have unique identifiers , whose edges have integer edge weights , and a weight can appear at most once in the whole network . to construct the ( unique ) mst , every node performs the same algorithm .",
    "the mst construction is based on the computation of all the shortest paths ( for a certain cost function ) between all the pairs of nodes . while executing the algorithm , every node stores the cost of all paths from it to all the other nodes . to implement this algorithm",
    ", the authors assume that every node knows the number @xmath7 of nodes in the network , and that the identifiers of the nodes are in @xmath8 .",
    "every node @xmath5 stores the weight of the edge @xmath9 placed in the mst for each node @xmath10",
    ". therefore the algorithm requires @xmath11 bits of memory at node @xmath5 .",
    "since all the weights are distinct integers , the memory requirement at each node is @xmath12 bits .",
    "higham and lyan  @xcite have proposed another self - stabilizing algorithm for the mst problem . as  @xcite , their work applies to undirected connected graphs with unique integer edge weights and unique node identifiers , where every node has an upper bound on the number of nodes in the system .",
    "the algorithm performs roughly as follows : every edge aims at deciding whether it eventually belongs to the mst or not . for this purpose ,",
    "every non tree - edge @xmath13 floods the network to find a potential cycle , and when @xmath13 receives its own message back along a cycle , it uses information collected by this message ( _ i.e. _ , the maximum edge weight of the traversed cycle ) to decide whether @xmath13 could potentially be in the mst or not .",
    "if the edge @xmath13 has not received its message back after the time - out interval , it decides to become tree edge .",
    "the core memory of each node holds only @xmath14 bits , but the information exchanged between neighboring nodes is of size @xmath15 bits , thus only slightly improving that of @xcite .    to our knowledge , _",
    "none _ of the self - stabilizing mst construction protocols is loop - free .",
    "since the aforementioned two protocols also make use of the knowledge of the global number of nodes in the system , and assume that no two edge costs can be equal , these extra hypoteses make them suitable for static networks only .",
    "relatively few works investigate merging self - stabilization and loop free routing , with the notable exception of  @xcite . while  @xcite still requires that a upper bound on the network diameter is known to every participant , no such assumption is made in  @xcite .",
    "also , both protocols use only a reasonable amount of memory ( @xmath14 bits per node )",
    ". however , the metrics that are considered in  @xcite are derivative of the shortest path ( _ a.k.a .",
    "_ sp ) metric , that is considered a much easier task in the distributed setting than that of the mst , since the associated metric is _ locally optimizable _  @xcite , allowing essentially locally greedy approaches to perform well .",
    "by contrast , some sort of _ global optimization _ is needed for mst , which often drives higher complexity costs and thus less flexibility in dynamic networks .",
    "[ [ our - contributions ] ] our contributions + + + + + + + + + + + + + + + + +    we describe a new self - stabilizing algorithm for the mst problem .",
    "contrary to previous self - stabilizing mst protocols , our algorithm does not make any assumption about the network size ( including upper bounds ) or the unicity of the edge weights .",
    "moreover , our solution improves on the memory space usage since each participant needs only @xmath14 bits , and node identifiers are not needed .",
    "in addition to improving over system hypotheses and complexity , our algorithm provides additional safety properties to self - stabilization , as it is loop - free .",
    "compared to previous protocols that are both self - stabilizing and loop - free , our protocol is the first to consider non - monotonous tree metrics .    the key techniques that are used in our scheme include fast construction of a spanning tree , that is continuously improved by means of a pre - order construction over the nodes .",
    "the cycles that are considered over time are precisely those obtained by adding one edge to the evolving spanning tree .",
    "considering solely that type of cycles reduces the memory requirement at each node compared to @xcite because the latter consider all possible paths connecting pairs of nodes .",
    "moreover , constructing and using a pre - order on the nodes allows our algorithm to proceed in a completely asynchronous manner , and without any information about the size of the network , as opposed to  @xcite .",
    "the main characteristics of our solution are presented in table  [ tableresume ] , where a boldface denotes the most useful ( or efficient ) feature for a particular criterium .",
    "we consider an undirected weighted connected network @xmath16 where @xmath3 is the set of nodes , @xmath17 is the set of edges and @xmath18 is a positive cost function .",
    "nodes represent processors and edges represent bidirectional communication links . additionally , we consider that @xmath16 is a network in which the weight of the communication links may change value .",
    "we consider anonymous networks ( i.e. , the processor have no ids ) , with one distinguished node , called the _ _ root__. throughout the paper , the root is denoted @xmath19 .",
    "we denote by @xmath20 the number of @xmath6 s neighbors in @xmath4 . the @xmath20 edges incident to any node @xmath6",
    "are labeled from 1 to @xmath20 , so that a processor can distinguish the different edges incident to a node .",
    "the processors asynchronously execute their programs consisting of a set of variables and a finite set of rules .",
    "the variables are part of the shared register which is used to communicate with the neighbors .",
    "a processor can read and write its own registers and can read the shared registers of its neighbors .",
    "each processor executes a program consisting of a sequence of guarded rules .",
    "each _ rule _ contains a _ guard _ ( boolean expression over the variables of a node and its neighborhood ) and an _ action _ ( update of the node variables only ) . any rule whose guard is _ true _",
    "is said to be _",
    "enabled_. a node with one or more enabled rules",
    "is said to be _",
    "privileged _ and may make a _ move _ executing the action corresponding to the chosen enabled rule .",
    "a _ local state _ of a node is the value of the local variables of the node and the state of its program counter .",
    "a _ configuration _ of the system @xmath21 is the cross product of the local states of all nodes in the system .",
    "the transition from a configuration to the next one is produced by the execution of an action at a node .",
    "a _ computation _ of the system is defined as a _ weakly fair , maximal _ sequence of configurations , @xmath22 , where each configuration @xmath23 follows from @xmath24 by the execution of a single action of at least one node . during an execution step ,",
    "one or more processors execute an action and a processor may take at most one action . _ weak fairness _ of the sequence",
    "means that if any action in @xmath4 is continuously enabled along the sequence , it is eventually chosen for execution .",
    "_ maximality _ means that the sequence is either infinite , or it is finite and no action of @xmath4 is enabled in the final global state .    in the sequel we consider the system can start in any configuration",
    "that is , the local state of a node can be corrupted .",
    "note that we do nt make any assumption on the bound of corrupted nodes . in the worst case all the nodes in the system may start in a corrupted configuration . in order to tackle these faults we use self - stabilization techniques .",
    "let @xmath25 be a non - empty _ _ legitimacy predicate _ _ of an algorithm @xmath26 with respect to a specification predicate @xmath27 such that every configuration satisfying @xmath25 satisfies @xmath27 .",
    "algorithm @xmath26 is _ self - stabilizing _ with respect to @xmath27 iff the following two conditions hold : + every computation of @xmath26 starting from a configuration satisfying @xmath28 preserves @xmath28 ( _ closure _ ) . +",
    "every computation of @xmath26 starting from an arbitrary configuration contains a configuration that satisfies @xmath28 ( _ convergence _ ) .",
    "we define bellow a _ loop - free _ configuration of a system as a configuration which contains paths with no cycle between any couple of nodes in the system .",
    "let @xmath29 be the following predicate defined for two nodes @xmath30 on configuration @xmath31 , with @xmath32 a path from @xmath5 to @xmath6 described by @xmath31 : @xmath33 a loop - free configuration is a configuration of the system which satisifes @xmath34 .",
    "we use the definition of a loop - free configuration to define a _ loop - free stabilizing _ system .",
    "a distributed system is called loop - free stabilizing if and only if it is self - stabilizing and there exists a non - empty set of configurations such that the following conditions hold : every execution starting from a loop - free configuration reaches a loop - free configuration ( closure ) .",
    "every execution starting from an arbitrary configuration contains a loop - free configuration ( convergence ) .    in the sequel we study the loop - free self - stabilizing problem .",
    "the legitimacy predicate @xmath25 for the problem is the conjunction of the following two predicates : a tree @xmath2 spanning the network is constructed .",
    "@xmath2 is a minimum spanning tree of @xmath4 ( i.e. , @xmath35 , with @xmath36 be a spanning tree of @xmath4 and @xmath37 be the cost of the subgraph @xmath38 ) .",
    "in this section , we describe our self - stabilizing algorithm for the mst problem .",
    "we call this algorithm . in the next section",
    ", we shall prove the correctness of this algorithm , and demonstrate that it satisfies all the desired properties listed in section  [ sec : intro ] , including the loop - freedomness property .",
    "let us begin by an informal description of aiming at underlining its main features .",
    "is based on the red rule .",
    "that is , for constructing a mst , the algorithm successively deletes the edges of maximum weight within every cycle . for this purpose ,",
    "a spanning tree is maintained , together with a pre - order labeling of its nodes .",
    "given the current spanning tree @xmath2 maintained by our algorithm , every edge @xmath13 of the graph that is not in the spanning tree creates an unique cycle in the graph when added to @xmath2 .",
    "this cycle is called _ fundamental cycle _ , and is denoted by @xmath39 .",
    "( formally , this cycle depends on @xmath2 ; nevertheless no confusion should arise from omitting @xmath2 in the notation of @xmath39 ) . if @xmath40 is not the maximum weight of all the edges in @xmath39 , then , according to the red rule , our algorithm swaps @xmath13 with the edge @xmath41 of @xmath39 with maximum weight .",
    "this swapping procedure is called an _ improvement_. a straightforward consequence of the red rule",
    "is that if no improvements are possible then the current spanning tree is a minimum one .",
    "algorithm can be decomposed in three procedures :    * tree construction * token label circulation * cycle improvement    the latter procedure ( cycle improvement ) is in fact the core of our contribution .",
    "indeed , the two first procedures are simple modifications of existing self - stabilizing algorithms , one for building a spanning tree , and the other for labelling its nodes .",
    "we will show how to compose the original procedure `` cycle improvement '' with these two existing procedures .",
    "note that `` cycle improvement '' differs from the previous self - stabilizing implementation of the improvement swapping in  @xcite by the fact that it does not require any a priori knowledge of the network , and it is loop - free .",
    "starts by constructing a spanning tree of the graph , using the self - stabilizing loop - free algorithm `` tree construction '' described in  @xcite .",
    "the two other procedures are performed concurrently .",
    "a token circulates along the edges of the current spanning tree , in a self - stabilizing manner .",
    "this token circulation uses algorithms proposed in @xcite as follows .",
    "a non - tree - edge can belong to at most one fundamental cycle , but a tree - edge can belong to several fundamental cycles . therefore , to avoid simultaneous possibly conflicting improvements , our algorithm considers the cycles in order . for this purpose , the token labels the nodes of the current tree in a dfs order ( pre - order ) .",
    "this labeling is then used to find the unique path between two nodes in the spanning tree in a distributed manner , and enables computing the fundamental cycle resulting from adding one edge to the current spanning tree .",
    "is depicted in plain .",
    "rule @xmath42 is depicted in bold . ]",
    "we now sketch the description of the procedure `` cycle improvement '' ( see figure  [ fig : etats ] ) .",
    "when the token arrives at a node @xmath5 in a state , it checks whether @xmath5 has some incident edges not in the current spanning tree @xmath2 connecting @xmath5 with some other node @xmath6 with smaller label .",
    "if it is the case , then enters state .",
    "let @xmath43 .",
    "node @xmath5 then initiates a traversal of the fundamental cycle @xmath39 for finding the edge @xmath41 with maximum weight in this cycle . if @xmath44 then no improvement is performed .",
    "else an improvement is possible , and @xmath5 enters state . exchanging @xmath13 and @xmath41 in @xmath2 results in a new tree @xmath36 .",
    "the key issue here is to perform this exchange in a loop - free manner .",
    "indeed , one can not be sure that two modifications of the current tree ( i.e. , removing @xmath41 from @xmath2 , and adding @xmath13 to @xmath2 ) that are applied at two distant nodes will occur simultaneously . and",
    "if they do not occur simultaneously , then there will a time interval during which the nodes will not be connected by a spanning tree . our solution for preserving loop - freedomless relies on a sequence of successive local and atomic changes , involving a single variable .",
    "this variable is a pointer to the current parent of a node in the current spanning tree . to get the flavor of our method ,",
    "let us consider the example depicted on figure  [ fig : ex1 ] .",
    "in this example , our algorithm has to exchange the edge @xmath45 of weight 9 , with the edge @xmath46 of weight 10 ( figure  [ fig : ex1](a ) ) .",
    "currently , the token is at node @xmath47 .",
    "the improvement is performed in two steps , by a sequence of two local changes .",
    "first , node 10 switches its parent from 8 to 12 ( figure  [ fig : ex1](b ) ) .",
    "next , node 8 switches its parent from 7 to 10 ( figure  [ fig : ex1](c ) ) .",
    "a spanning tree is preserved at any time during the execution of these changes .",
    "note that any modification of the spanning tree makes the current labeling globally inaccurate , i.e. , it is not necessarily a pre - order anymore .",
    "however , the labeling remains a pre - order in the portion of the tree involved in the exchange .",
    "for instance , consider again the example depicted on figure  [ fig : ex1](c ) .",
    "when the token will eventually reach node @xmath48 , it will label it by some label @xmath49 .",
    "the exchange of @xmath45 and @xmath46 has not changed the pre - order for the fundamental cycle including edge @xmath50 . however ,",
    "when the token will eventually reach node @xmath51 and label it @xmath52 , the exchange of @xmath45 and @xmath46 has changed the pre - order for the fundamental cycle including edge @xmath53 : the parent of node labeled @xmath54 is labeled @xmath47 whereas it should have a label smaller than @xmath54 in a pre - order .",
    "when the pre - order is modified by an exchange , the inaccurately labeled node changes its state to , and stops the traversal of the fundamental cycle .",
    "the token is then informed that it can discard this cycle , and carry on the traversal of the tree .",
    "we now enter into the details of algorithm .",
    "first , let us state all variables used by the algorithm .",
    "later on , we will describe its predicates and its rules .",
    "[ [ variables ] ] variables + + + + + + + + +    for any node @xmath55 , we denote by @xmath56 the set of all neighbors of @xmath6 in @xmath4 .",
    "algorithm maintains the set @xmath56 at every node @xmath6 .",
    "we use the following notations :    * @xmath57 : the parent of @xmath6 in the current spanning tree ; * @xmath58 : the integer label assigned to @xmath6 ; * @xmath59 : the distance ( in hops ) from @xmath6 to the root in the current spanning tree ; * @xmath60 : the state of node @xmath6 , with values in @xmath61 ; * @xmath62 : the pair of labels of the two extremities of the non tree - edge corresponding to the current fundamental cycle . *",
    "@xmath63 : a pair of variables : the first one is the maximum edge - weight in the current fundamental cycle ; the second one is a ( boolean ) variable in @xmath64 ; * @xmath65 : the successor of @xmath6 in the current fundamental cycle .    [ [ consistency - rules ] ] consistency rules + + + + + + + + + + + + + + + + +    the first task executed by is to check the consistency of the variables of each node ; see figure  [ fig : etats ] . is the standard state of a node when this node has not the token , or is not currently visited by the traversal of a fundamental cycle .",
    "when the variables of a node are detected to be not coherent , the state of the node becomes thanks to rule @xmath42 .",
    "there is one predicate in @xmath42 for each state , except for state @xmath66 , to check whether the variables of the node are consistent ( see figure [ fig : correct_predicates ] ) .",
    "the rule @xmath67 allows the node to return to the standard state .",
    "more precisely , rule @xmath67 resets the variables , and stops the participation of the node to any improvement .",
    "@xmath42 : ( bad label ) : :     +    * if *    @xmath68_v \\neq { \\mbox{\\sf label}}_v \\wedge { \\mbox{\\sf endpropag}}(v)$ ]    * then * @xmath69 @xmath67 : ( improvement consistency ) : :     +    * if *    @xmath70 +    * then *    @xmath71 ; +    [ [ subsubsec : treeconst ] ] tree construction + + + + + + + + + + + + + + + + +    starts by constructing a spanning tree of the graph , using the self - stabilizing loop - free algorithm `` tree construction '' described in  @xcite .",
    "this algorithm constructs a bfs , and uses two variables @xmath72 and @xmath73 .",
    "during the execution of our algorithm , these two variables are subject to the same rules as in  @xcite .",
    "after each modification of the spanning tree , the new distance to the parent is propagated in sub - trees by rules @xmath74 and @xmath75 .",
    "@xmath74 : ( distance propagation ) : :     + @xmath75 : ( end distance propagation ) : :     +    [ [ token - circulation - and - pre - order - labeling ] ] token circulation and pre - order labeling + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + +    uses the algorithm described in @xcite to provide each node @xmath6 with a label @xmath58 .",
    "each label is unique in the network traversed by the token .",
    "this labeling is used to find the unique path between two nodes in the spanning tree , in a distributed manner . for this purpose",
    ", we use the snap - stabilizing algorithm described in @xcite for the circulation of a token in the spanning tree .",
    "we have slightly modified this algorithm because stops the token circulation at a node during the `` cycle improvement '' procedure .",
    "a node @xmath6 knows if it has the token by applying predicate @xmath76 .",
    "rule @xmath77 guides the circulation of the token .",
    "the token carries on its tree traversal if one of the following three conditions is satisfied : ( i ) there is no improvement which could be initiated by the node which holds the token , ( ii ) an improvement was performed in the current cycle , or ( iii ) inconsistent node labels were detected in the current cycle .",
    "the latter is under the control of predicate @xmath78 .",
    "@xmath77 : ( continue dfs token circulation ) : :     +    * if *    @xmath79 +    * then *    @xmath80_v={\\mbox{\\sf done}};$ ]    [ [ cycle - improvement - rules ] ] cycle improvement rules + + + + + + + + + + + + + + + + + + + + + + +    the procedure `` cycle improvement '' is the core of . its role is to avoid disconnection of the current spanning tree , while successively improving the tree until reaching a mst . the procedure can be decomposed in four tasks : ( 1 ) to check whether the fundamental cycle of the non - tree edge has an improvement or not , ( 2 ) perform the improvement if any , ( 3 ) update the distances , and ( 4 ) resume the token circulation .",
    "let us start by describing the first task .",
    "a node @xmath5 in state @xmath81 changes its state to @xmath82 if its variables are in consistent state , it has a token , and it has identified a candidate ( i.e. , an incident non - tree edge @xmath83 whose other extremity @xmath6 has a smaller label than the one of @xmath5 ) .",
    "the latter is under the control of predicate @xmath84 , and the variable @xmath63 contains the label of @xmath5 and @xmath6 . if the three conditions are satisfied , then the verification of the fundamental cycle @xmath39 is initiated from node @xmath5 , by applying rule @xmath85 .",
    "the goal of this verification is twofold : first , to verify whether @xmath39 exists or not , and , second , to save information about the maximum edge weight and the location of the edge of maximum weight in @xmath39 .",
    "these information are stored in the variable @xmath86 . in order to respect the orientation in the current spanning tree , the node @xmath5 or @xmath6 that initiates the improvement depends on the localization of the maximum weight edge @xmath41 in @xmath39 .",
    "more precisely , let @xmath19 be the least common ancestor of nodes @xmath5 and @xmath6 in the current tree .",
    "if @xmath41 occurs before @xmath19 in @xmath2 in the traversal of @xmath39 from @xmath5 starting by edge @xmath87 , then the improvement starts from @xmath5 , otherwise the improvement starts from @xmath6 . to get the flavor of our method ,",
    "let us consider the example depicted on figure  [ fig : ex1 ] .",
    "in this example , @xmath41 occurs after the least common ancestor ( node 6 ) .",
    "therefore node 10 atomically swaps its parent to respect the orientation . however , if one replaces in the same example the weight of edge @xmath88 by 11 instead of 3 , then @xmath41 would occur before @xmath19 , and thus node 12 would have to atomically swaps its parent .",
    "the relative places of @xmath41 and @xmath19 in the cycle is indicated by predicate @xmath86 that returns two different values : @xmath89 or @xmath90 . during the improvement of the tree , the fundamental cycle is modified .",
    "it is crucial to save information about this cycle during this modification . in particular",
    ", the successor of a node @xmath1 in a cycle , stored in the variable @xmath91 , must be preserved .",
    "its value is computed by predicate @xmath92 which uses node labels to identify the current examined fundamental cycle .",
    "each node is able to compute its predecessor in the fundamental cycle by applying predicate @xmath93 .",
    "the state of a node is compared with the ones of its successor and predecessor to detect potential inconsistent values . at the end of this task",
    ", the node @xmath5 learns the maximum weight of the cycle @xmath39 and can decide whether it is possible to make an improvement or not . if not , but there is another non - tree edge @xmath94 that is candidate for potential replacement , then @xmath5 verifies @xmath95 .",
    "otherwise the token carries on its traversal , and rule @xmath75 is applied .",
    "@xmath85 : : :    ( verify rule )   +    if @xmath39 can yield an improvement , then rule @xmath96 is executed . by this rule , a node enters in state , and changes its parent to its predecessor if @xmath97_v={\\mbox{\\sf before}}$ ] ( respectively to its successor if @xmath97_v={\\mbox{\\sf after}}$ ] ) . for this purpose",
    ", it uses the variable @xmath65 and the predicate @xmath93 .",
    "@xmath96 : ( improve rule ) : :     +    at the end of an improvement , it is necessary to inform the node holding the token that it has to carry on its traversal .",
    "this is the role of rule @xmath98 .",
    "it is also necessary to inform all nodes impacted by the modification that they have to update their distances to the root ( see section  [ subsubsec : treeconst ] ) .",
    "@xmath98 : ( end of improvement rule ) : :     +    [ [ module - composition ] ] module composition + + + + + + + + + + + + + + + + + +    all the different modules presented , except the tree construction parts of the correction module , need the presence of a spanning tree in @xmath4 .",
    "thus , we must execute the tree construction rules first if an incoherency in the spanning tree is detected . to this end",
    ", these rules are composed using the level composition defined in @xcite . if predicate @xmath99 is not verified then the tree construction rules are executed , otherwise the other modules can be executed . the token circulation algorithm and the naming algorithm",
    "are composed together using the conditional composition described in @xcite .",
    "finally , we compose the token circulation algorithm and the cycle improvement module with a conditional composition using predicate @xmath78 defined in the algorithm . this allows to execute the token circulation algorithm only if the cycle improvement module does not need the token on a node .",
    "figure [ fig : composition ] shows how the different modules are composed together .",
    "we presented a new solution to the distributed mst construction that is both self - stabilizing and loop - free .",
    "it improves on memory usage from @xmath15 to @xmath14 , yet does nt make strong system assumptions such as knowledge of network size or unicity of edge weights , making it particularly suited to dynamic networks .",
    "two important open questions are raised :    1 .   for depth",
    "first search tree construction , self - stabilizing solutions that use only constant memory space do exist .",
    "it is unclear how the obvious constant space lower bound can be raised with respect to metrics that minimize a global criterium ( such as mst ) .",
    "2 .   our protocol pionneers the design of self - stabilizing loop - free protocols for _ non _ locally optimizable tree metrics .",
    "we expect the techniques used in this paper to be useful to add loop - free property for other metrics that are only globally optimizable , yet designing a generic such approach is a difficult task",
    ".    10    efthymios anagnostou and vassos hadzilacos .",
    "tolerating transient and permanent failures ( extended abstract ) . in andr",
    "schiper , editor , _ wdag _ , volume 725 of _ lecture notes in computer science _ , pages 174188 .",
    "springer , 1993 .",
    "michael ben - or , danny dolev , and ezra  n. hoch .",
    "fast self - stabilizing byzantine tolerant digital clock synchronization . in rida",
    "a. bazzi and boaz patt - shamir , editors , _ podc _ , pages 385394 .",
    "acm , 2008 .",
    "jorge  arturo cobb and mohamed  g. gouda .",
    "stabilization of general loop - free routing .",
    "62(5):922944 , 2002 .    ajoy  kumar datta , shivashankar gurumurthy , franck petit , and vincent villain .",
    "self - stabilizing network orientation algorithms in arbitrary rooted networks . , 1(1):122 , 2001 .",
    "edsger  w. dijkstra .",
    "self - stabilizing systems in spite of distributed control . , 17(11):643644 , 1974 .",
    "s.  dolev . .",
    "mit press , march 2000 .",
    "shlomi dolev .",
    ". mit press , 2000 .",
    "shlomi dolev and ted herman .",
    "superstabilizing protocols for dynamic distributed systems . , 1997 , 1997 .",
    "shlomi dolev and jennifer  l. welch .",
    "wait - free clock synchronization .",
    ", 18(4):486511 , 1997 .",
    "shlomi dolev and jennifer  l. welch .",
    "self - stabilizing clock synchronization in the presence of byzantine faults .",
    ", 51(5):780799 , 2004 .",
    "eli  m. gafni and p.  bertsekas . distributed algorithms for generating loop - free routes in networks with frequently changing topology .",
    ", 29:1118 , 1981 .",
    "robert  g. gallager , pierre  a. humblet , and philip  m. spira . a distributed algorithm for minimum - weight spanning trees . , 5(1):6677 , 1983 .",
    "j.  j. garcia - luna - aceves .",
    "loop - free routing using diffusing computations .",
    ", 1(1):130141 , 1993 .",
    "ajei  s. gopal and kenneth  j. perry . unifying self - stabilization and fault - tolerance ( preliminary version ) . in _",
    "pages 195206 , 1993 .",
    "mohamed  g. gouda and ted herman . adaptive programming .",
    ", 17(9):911921 , 1991 .    mohamed  g. gouda and marco schneider .",
    "stabilization of maximal metric trees . in anish",
    "arora , editor , _ wss _ , pages 1017 .",
    "ieee computer society , 1999 .",
    "sandeep k.  s. gupta and pradip  k. srimani .",
    "self - stabilizing multicast protocols for ad hoc networks . , 63(1):8796 , 2003 .",
    "lisa higham and zhiying liang .",
    "self - stabilizing minimum spanning tree construction on message - passing networks . in _ disc _ , pages 194208 , 2001 .",
    "colette johnen and sbastien tixeuil .",
    "route preserving stabilization . in shing - tsaan huang and ted herman , editors , _ self - stabilizing systems _ ,",
    "volume 2704 of _ lecture notes in computer science _",
    ", pages 184198 .",
    "springer , 2003 .",
    "colette johnen and sbastien tixeuil .",
    "route preserving stabilization . in _ self - stabilizing systems _",
    ", pages 184198 , 2003 .",
    "joseph  b. kruskal . on the shortest spanning subtree of a graph and the travelling salesman problem . , 7:4850 , 1956 .",
    "marina papatriantafilou and philippas tsigas . on self - stabilizing wait - free clock synchronization .",
    ", 7(3):321328 , 1997 .",
    "franck petit and vincent villain .",
    "optimal snap - stabilizing depth - first token circulation in tree networks .",
    ", 67(1):112 , 2007 .",
    "shortest connection networks and some generalizations . , pages 13891401 , 1957 .",
    "daniel  dominic sleator and robert  endre tarjan .",
    "a data structure for dynamic trees .",
    ", 26(3):362391 , 1983 .",
    "we use the algorithm given in @xcite to construct a breadth first search spanning tree . note that , the algorithm given in @xcite satisfies the loop - free property .",
    "therefore , in the remainder we suppose there is a constructed spanning tree .",
    "let @xmath2 a spanning tree of network @xmath4 and @xmath6 a node of @xmath2 .",
    "if @xmath6 is in an incoherent state then according to lemma [ lem : correct_node ] below , the algorithm bootstraps the state of @xmath6 , otherwise the token continues its circulation in the tree until a verification on a node is needed ( lemma [ lem : token ] ) .",
    "when the token is on a node that has candidate edges not in the tree ( i.e. whose fundamental cycle is not yet checked ) , according to corollary [ cor : verif_cycle_noeud ] the algorithm verifies if an amelioration ( see section [ sec : high ] for the definition of an amelioration ) must be performed using these not tree edges and according to lemma [ lem : do_improve ] an improvement is performed if an improvement is possible .",
    "moreover , the algorithm performs all possible improvements ( lemma [ lem : do_possible_improve ] ) until no improvement is feasable ( lemma [ lem : convergence ] and corollary [ cor : always_mst ] ) , i.e. a minimum spanning tree is reached .    starting from a spanning tree @xmath2 of the network , during the execution of the algorithm no cycle",
    "is created and a spanning tree structure is preserved ( see corollary [ cor : no_cycle ] ) . moreover , according to lemma [ lem : correction ] if @xmath2 is minimum spanning tree then @xmath2 is maintained by the algorithm .",
    "a node may have six different states in the algorithm : @xmath102 , and @xmath66 .",
    "the coherence of a node in these different states is defined respectively by predicates @xmath103 , and @xmath104 . for the state @xmath66",
    ", we detect if the propagation is done using predicate @xmath105 to allow the execution of rule @xmath67 to reinitialize the state of the node .",
    "according to the algorithm description , if a node @xmath6 is not coherent ( i.e. does not respect one of the previous mentioned predicates ) , predicate @xmath101 is not verified since the previous mentioned predicates are exclusive because a node can have one state .",
    "thus , @xmath6 can execute rule @xmath67 to correct its variables to a coherent state satisfying predicate @xmath106 . as a consequence predicate @xmath101",
    "is satisfied too ( see rule @xmath67 ) .",
    "we show that if a node @xmath6 in a fundamental cycle has no successor because of bad labels then @xmath6 changes its status to @xmath110 .",
    "predicate @xmath92 is in charge to give the successor of a node in a fundamental cycle based on the node labels , following observation [ lem : cycle_struct ] below .",
    "thus , if predicate @xmath92 returns no successor this implies that bad labels disturb the computation of the successor .",
    "predicate @xmath112 is in charge to detect bad labels .",
    "we show that a node @xmath6 which is part of a fundamental cycle ( i.e. satisfies predicate @xmath101 ) and detects an error or has its successor in status @xmath110 changes its status to @xmath110 ( except the initiator node , i.e. @xmath113_v \\neq { \\mbox{\\sf label}}_v$ ] ) .",
    "we do not consider the status @xmath81 since in this status no node has a successor ( see predicate @xmath112 .",
    "consider any node @xmath6 ( except the initiator node ) which satisfies predicate @xmath101 . to change its status to @xmath110",
    "a node must execute rule @xmath42 and we must consider two cases : a node with no successor , or a node with a successor in status @xmath110 . in the first case ,",
    "a node @xmath6 satisfies predicate @xmath112 ( see predicate @xmath112 ) and @xmath6 can execute rule @xmath42 . after the execution of rule @xmath42 , @xmath6 satisfies predicate @xmath111 since @xmath114 , @xmath108 and @xmath115 . in the second case ,",
    "suppose that for a node @xmath6 we have @xmath116 . according to predicate @xmath117 , @xmath118 and",
    "thus @xmath6 can execute rule @xmath42 to change its status to @xmath110 .",
    "after the execution of rule @xmath42 , @xmath6 satisfies predicate @xmath111 since @xmath114 , @xmath119 and @xmath115 .",
    "one can show by induction following the same argument that any node part of a fundamental cycle with bad labels changes its status to @xmath110 ( except the initiator node ) .",
    "predicate @xmath78 notices when the dfs token must continue its circulation in the tree .",
    "the dfs token must continue its circulation in four cases : ( 1 ) a node in status @xmath81 has no candidate edge , ( 2 ) a node in status @xmath82 with no possible improvement has no candidate edge , ( 3 ) an improvement was done in the fundamental cycle , or ( 4 ) bad labels are detected in the fundamental cycle .    in case 1 , for node",
    "@xmath6 , @xmath120 ( otherwise according to lemma [ lem : correct_node ] its state is reinitialized ) . in case 2 , for node",
    "@xmath6 , @xmath121 ( otherwise according to lemma [ lem : correct_node ] its state is reinitialized ) and predicate @xmath122 is used to detect possible improvements ( see the proof of lemma [ lem : verif_cycle ] ) .",
    "for case 1 and 2 , if @xmath6 has no candidate predicate @xmath123 ( see predicate @xmath124 and proof of lemma [ lem : verif_cycle ] ) and thus predicate @xmath78 is satisfied . in case 3 , according to lemma [ lem : end_improve ] the initiator node @xmath6 satisfies predicate @xmath125 and predicate @xmath78 returns true . finally in case 4",
    ", according to lemma [ lem : label_error ] the successor of the initiator node @xmath6 is in status @xmath110 so predicate @xmath119 and predicate @xmath112 returns true .",
    "thus , predicate @xmath78 returns true .",
    "therefore , in all the above cases predicate @xmath78 returns true and @xmath6 can execute rule @xmath77 to allow the token circulation .",
    "it then changes its status to @xmath81 and sets @xmath126_v$ ] to @xmath127 to force the verification of all adjacent candidate edges in the next tree traversal by the dfs token .",
    "[ lem : cycle_struct ] let @xmath2 be a tree spanning @xmath3 and correctly labeled .",
    "let an edge @xmath128 , @xmath39 its fundamental cycle and @xmath129 the fundamental cycle root of @xmath39 .",
    "there is always a path @xmath32 in @xmath2 between @xmath5 and @xmath6 , such that @xmath32 can be decomposed in two parts : a sub - path @xmath130 ( resp .",
    "@xmath131 ) with increasing labels from @xmath129 to @xmath5 ( resp . @xmath129 to @xmath6 ) .",
    "[ lem : verif_cycle ] let @xmath6 be a node of @xmath2 such that @xmath6 has the dfs token with at least an adjacent edge @xmath128 whose fundamental cycle is not already verified by the algorithm . eventually the cycle improvement module verifies if there is an improvement in @xmath39 .",
    "suppose first that @xmath6 has the dfs token and @xmath6 is in a coherent state @xmath81 , otherwise according to lemma [ lem : correct_node ] its state is corrected .",
    "let @xmath43 be a not tree edge , which is a candidate edge for @xmath6 , i.e. , we have @xmath132 .",
    "we consider that @xmath133 since a candidate edge for node @xmath6 is an adjacent not tree edge @xmath43 with @xmath133 , see predicate @xmath134 .",
    "since @xmath6 is in a coherent state @xmath81 and @xmath132 , we have variable @xmath126_v$ ] equal to @xmath127 , predicate @xmath101 and @xmath84 return true , whears predicate @xmath112 returns false .",
    "thus , @xmath6 can execute rule @xmath85 . note that rule @xmath77 can not be executed since predicate @xmath78 returns false since @xmath132 . as a consequence @xmath6 stops the dfs token and becomes the initiator node of cycle @xmath39 with @xmath5 as target node ( see rule @xmath85 ) .",
    "after the execution of rule @xmath85 , @xmath6 is in state @xmath82 and according to predicate @xmath92 @xmath6 selects its father as next node in the cycle ( i.e. @xmath135 ) . note that since @xmath6 is in coherent state @xmath81 variable @xmath136 .",
    "cycle @xmath39 is decomposed in two parts ( see lemma [ lem : cycle_struct ] ) : ( 1 ) from the initiator @xmath6 to the root @xmath129 of @xmath39 and ( 2 ) from @xmath129 to the target node @xmath5 . in the following",
    "we prove by induction on the length of cycle @xmath39 that a node @xmath137 belonging to @xmath39 executes rule @xmath85 and eventually is in state @xmath82 .",
    "moreover , variable @xmath138 describes the successor of @xmath137 in @xmath39 ( i.e. encodes the cycle @xmath39 ) .",
    "case 1 : consider a coherent node @xmath137 in state @xmath81 ( see lemma [ lem : correct_node ] ) which has not the dfs token ( i.e. predicate @xmath139 is false ) .",
    "consider the successor node of @xmath39 s initiator node @xmath6 .",
    "as described above , @xmath6 is in state @xmath82 and @xmath140 .",
    "according to predicate @xmath141 , @xmath6 is the predecessor of @xmath137 in cycle @xmath39 since @xmath137 is the parent of @xmath6 in the tree .",
    "thus , predicate @xmath142 returns true and @xmath137 could execute rule @xmath85 .",
    "therefore , @xmath137 is in state @xmath82 and selects its parent as its successor in @xmath39 , like @xmath6 .",
    "moreover , @xmath137 computes the new heaviest edge from @xmath6 to @xmath137 and notices that the heaviest edge location is before ( i.e. @xmath89 ) the root of @xmath39 ( see respectively predicates @xmath143 and @xmath144 ) .",
    "using the same scheme , we can show that all nodes on @xmath39 between @xmath6 and @xmath129 ( including @xmath129 ) execute rule @xmath85 and are in state @xmath82 .",
    "case 2 : consider a coherent node @xmath137 in state @xmath81 ( see lemma [ lem : correct_node ] ) which has not the dfs token ( i.e. predicate @xmath139 is false ) and is the successor node of @xmath129 . as described in case 1 , @xmath129 is in state @xmath82 .",
    "since @xmath129 is the parent of @xmath137 in the tree , predicate @xmath141 returns @xmath129 as predecessor of @xmath137 .",
    "thus , predicate @xmath142 returns true and @xmath137 can execute rule @xmath85 .",
    "@xmath137 selects as its successor in @xmath39 the child with the highest label smaller than target node s @xmath5 label ( see predicates @xmath145 and @xmath146 ) .",
    "moreover , @xmath137 computes the new heaviest edge from @xmath6 to @xmath137 and if @xmath137 has a different heaviest edge @xmath137 notice that the heaviest edge location is after ( i.e. @xmath90 ) the root of @xmath39 otherwise @xmath137 takes the location of its predecessor ( see respectively predicates @xmath143 and @xmath144 ) . using the same scheme",
    ", we can show that all nodes on @xmath39 between @xmath129 and @xmath5 ( including @xmath5 ) execute rule @xmath85 and are in state @xmath82 .",
    "note that the target node @xmath5 selects @xmath6 as its successor in @xmath39 ( see predicate @xmath147 ) .",
    "consider now that @xmath6 has the dfs token , is in a coherent state @xmath82 and predecessor of @xmath6 is in state @xmath82 ( i.e. @xmath148 ) .",
    "note that the predecessor of @xmath6 is the target node @xmath5 . as described in case 2",
    ", target node @xmath5 knows the weight of the heaviest edge @xmath94 in @xmath39 ( @xmath149 ) .",
    "thus , @xmath6 could check if there is an improvement in @xmath39 ( see predicate @xmath150 ) .",
    "[ cor : verif_cycle_noeud ]",
    "let @xmath2 a spanning tree and @xmath6 be a node of @xmath2 such that @xmath6 has the dfs token .",
    "eventually for each adjacent candidate edge @xmath13 of @xmath6 , the cycle improvement module verifies if there is an improvement in @xmath39 .",
    "we prove that while there is no improvement initiated by @xmath6 , each edge @xmath128 is eventually examined by the cycle improvement module .",
    "we consider the two cases below : ( 1 ) there is no improvement initiated by @xmath6 , or ( 2 ) an improvement can be done in @xmath39 for a candidate edge @xmath13 .",
    "consider an arbitrary candidate edge @xmath128 . according to lemma [ lem : verif_cycle ] , @xmath6 eventually",
    "verifies if there is an improvement in @xmath39 .",
    "case 1 : if there is no improvement in @xmath39 and @xmath6 has another candidate edge ( i.e. predicates @xmath124 and @xmath84 return true ) then @xmath6 must check if there is an improvement in the fundamental cycle of the new candidate edge . according to lemma [",
    "lem : verif_cycle ] , @xmath6 could execute again rule @xmath85 with a new target and stay in a coherent state @xmath82 .",
    "therefore for each not tree adjacent edge @xmath13 , @xmath6 eventually verifies if there is an improvement in the fundamental cycle @xmath39 .",
    "case 2 : if an improvement can be done in @xmath39 , when the improvement is done , @xmath6 is in the state @xmath151 . thus , predicate @xmath78 returns true and rule @xmath77 can be executed to continue the token circulation in the tree . however , the next time @xmath6 has the token as described in case 1 , @xmath6 eventually checks again the previously examined edges , but @xmath6 will also check candidate edges not previously visited .          according to definition [ def : red_rule ] , there is an improvement in a cycle @xmath31 if the edge of maximum weight in @xmath31 belongs to the current tree and one can use the red rule .",
    "given an edge @xmath128 and @xmath39 its fundamental cycle , lemma [ lem : verif_cycle ] states that the initiator node @xmath6 detects if there is an improvement in cycle @xmath39 .",
    "assume that an improvement can be performed in cycle @xmath39 ( i.e. predicate @xmath152 ) .",
    "as proved in lemma [ lem : verif_cycle ] , @xmath5 and @xmath6 are in a coherent state @xmath82 and have a successor , thus we have @xmath153 and @xmath148 . since @xmath6 is the initiator node of @xmath39 , @xmath6 has the dfs token and could not be the root of @xmath39 ( i.e. @xmath154 and @xmath155 ) .",
    "so @xmath6 can execute rule @xmath96 , to change its state to @xmath156 and to update its estimation of the heaviest edge of @xmath39 and the heaviest edge location to the values of its predecessor ( i.e. the target node @xmath5 ) .",
    "two cases have to be analyzed : ( 1 ) the heaviest edge location is between @xmath6 and @xmath129 ( i.e. @xmath97_v={\\mbox{\\sf before}}$ ] ) or ( 2 ) between @xmath5 and @xmath129 ( i.e. @xmath97_v={\\mbox{\\sf after}}$ ] ) . in the two cases ,",
    "the improvement must be propagated from @xmath6 to @xmath129 ( resp .",
    "@xmath5 to @xmath129 ) until reaching the ( first ) heaviest edge or the root of @xmath39 ( if the weight of the heaviest edge has been reduced ) . indeed",
    ", the root of @xmath39 must not change its parent to a neighbor in @xmath39 otherwise it disconnects its subtree from the rest of the tree .",
    "case 1 : since @xmath97_v={\\mbox{\\sf before}}$ ] , @xmath6 takes as new parent its predecessor in the cycle . let @xmath137 be a node in coherent state @xmath82 between @xmath6 and @xmath129 ( note : @xmath137 exists otherwise suppose @xmath137 is in an incoherent state , according to lemma [ lem : correct_node ] @xmath137 reinitiates its state to @xmath81 which induces a propagation of state @xmath81 in @xmath39 , since the nodes are no more coherent with their predecessors , and stops the improvement until a new verification of @xmath39 is restarted ) .",
    "if the improvement must continue ( i.e. predicate @xmath157 returns true ) , @xmath137 is not the root of @xmath39 and its predecessor is in state @xmath156 ( see predicate @xmath158 ) then @xmath137 can execute rule @xmath96 .",
    "so , @xmath137 changes its state to @xmath156 , updates its variable @xmath159 to the value of its predecessor and takes its predecessor as its parent .",
    "this propagation continues until reaching a node @xmath137 which stops the improvement ( i.e. @xmath160 or @xmath161 ) .",
    "case 2 : @xmath97_v={\\mbox{\\sf after}}$ ] and as in case 1 @xmath6 executes rule @xmath96 but @xmath6 changes only its state to @xmath156 and updates its variable @xmath63 to the value of its predecessor .",
    "hence @xmath6 does not change its parent . consider the target node @xmath5 , we have @xmath162 since @xmath6 is in state @xmath156 .",
    "so , @xmath5 executes rule @xmath96 , changes its state to @xmath156 , updates @xmath163 to its successor value and changes its parent to its successor ( i.e. @xmath164 ) .",
    "as described in case 1 , the improvement is propagated in the cycle from @xmath5 to @xmath129 until a node @xmath137 is reached which stops the improvement ( i.e. @xmath160 or @xmath161 ) .",
    "we conduct the proof by induction on the length of the fundamental cycle .",
    "a node involved in an improvement executes rule @xmath98 to inform its predecessor or successor the end of the improvement .",
    "an improvement can be propagated by a successor or a predecessor in the cycle .",
    "we show the lemma considering that the improvement is propagated by the successor of a node , but the same idea can be applied by considering predecessor instead of successor .",
    "moreover , we assume that labels are correct in the fundamental cycle otherwise it is not necessary to inform the end of the improvement since according to lemma [ lem : label_error ] the nodes are in state @xmath110 .",
    "let @xmath129 the node which detects the end of the improvement and @xmath166 the initiator node in a fundamental cycle .",
    "consider the node @xmath129 , such that @xmath167 and @xmath168_x$ ] .",
    "predicate @xmath169 since @xmath167 and @xmath170 is satisfied because @xmath171 .",
    "thus , @xmath129 can execute rule @xmath98 and changes its status to @xmath151 .",
    "therefore , @xmath172 is satisfied since @xmath173 , @xmath174 and @xmath175 because @xmath129 and its parent are in the same fundamental cycle . now , suppose by induction hypothesis that any node @xmath5 between @xmath129 and the initiator node @xmath166 are in state @xmath151 and @xmath176 is satisfied .",
    "consider the initiator node @xmath166 , @xmath177 , @xmath178 and @xmath179 .",
    "predicate @xmath180 is satisfied because predicate @xmath181 since @xmath179 and @xmath182 .",
    "thus , @xmath166 can execute rule @xmath98 and changes its status to @xmath151 . therefore , predicate @xmath183 is satisfied since @xmath184 , @xmath181 and @xmath185 because @xmath166 and its parent are in the same fundamental cycle .      according to the token circulation algorithm @xcite ,",
    "eventually each node in the tree is visited and holds the token .",
    "consider a node @xmath6 in the tree @xmath2 , which has the dfs token . according to corollary [ cor : verif_cycle_noeud ] eventually each adjacent candidate edge of @xmath6",
    "is examined by the cycle improvement module .",
    "thus , if an improvement is possible this one is detected according to lemma [ lem : verif_cycle ] and performed by @xmath6 according to lemma [ lem : do_improve ] .",
    "therefore , if an improvement is possible the cycle improvement module performs it .",
    "let @xmath2 be an existing minimum spanning tree of @xmath4 and @xmath6 be a node in @xmath2 which has the dfs token .",
    "let @xmath186 an adjacent candidate edge of @xmath6 and @xmath39 its corresponding fundamental cycle .",
    "suppose the cycle improvement module performs an improvement in @xmath39 .",
    "we prove by contradiction that no improvement could performed by the algorithm .",
    "let @xmath187 the maximum edge weight in @xmath39 , excluding edge @xmath13 . according to definition [ def : red_rule ] , to initiate an improvement from @xmath6 the following condition",
    "must be verified : @xmath188 . according to lemma [ lem : verif_cycle ] ,",
    "the predecessor @xmath5 of @xmath6 holds the maximum edge weight in @xmath39 ( i.e. @xmath189_u = w(c_e)$ ] ) . to perform an improvement , predicate @xmath150 must return true to allow @xmath6 to execute rule @xmath96 .",
    "this implies that @xmath190_v,{\\mbox{\\sf varcycle}}[0]_u)>w(u , v)$ ] ( see predicate @xmath150 ) , i.e. @xmath191 ( since @xmath189_u = w(c_e)$ ] ) which contradicts the fact that no improvement can be performed in @xmath39 .",
    "therefore , @xmath6 can not execute rule @xmath96 if no improvement is possible in a fundamental cycle .",
    "lemma [ lem : no_improve ] shows that no improvement is performed by the algorithm if @xmath2 is a minimum spanning tree of @xmath4 , i.e. rule @xmath96 can not be executed by a node .",
    "therefore , according to lemma [ lem : no_improve ] and by remark [ rem : parent_change ] a spanning tree is maintained .",
    "if the initial configuration contains no spanning tree , there is a node @xmath6 such that predicate @xmath192 and according to the level composition ( defined in @xcite ) we use the algorithm given in @xcite to construct a breadth first search spanning tree .",
    "otherwise , the initial configuration contains a spanning tree which is not a minimum spanning tree . according to lemma [ lem : do_possible_improve ] and [ lem : no_improve ] ,",
    "improvements are performed by the cycle improvement module until a minimum spanning tree is reached . moreover , according to lemma [ lem : no_disconnect_tree ] a spanning tree is preserved by the cycle improvement module .",
    "finally , there is at most @xmath193 fundamental cycles in any graph so a finite number of improvements can be performed by the cycle improvement module .",
    "thus , in a finite time the algorithm returns a minimum spanning tree .",
    "there is two cases in which the existing tree @xmath2 spanning @xmath3 is disconnected .",
    "it is necessary ( 1 ) to delete an edge of @xmath2 by changing the parent of a node ( except the root of @xmath2 ) to itself or ( 2 ) to attribute as new parent of a node a neighbor belonging to its descendant in the tree .",
    "consider the execution of rule @xmath96 ( see remark [ rem : parent_change ] ) .",
    "rule @xmath96 can be executed by a node if this one is in state @xmath82 and is a coherent node ( see predicate @xmath194 in rule @xmath96 ) . as described in the proof of lemma [ lem : verif_cycle ] , a coherent node in state @xmath82",
    "has a predecessor and a successor in a fundamental cycle , note that the initiator has a predecessor because it must wait that this one ( i.e. the target node ) is in state @xmath82 to execute rule @xmath96 ( see predicate @xmath195 ) .",
    "case ( 1 ) is not permitted by the algorithm . the new parent of a node is its predecessor or successor in the fundamental cycle ( see rule @xmath96 ) .",
    "thus the algorithm selects as new parent another node different of the node itself .",
    "case ( 2 ) is not permitted by the algorithm , since the new parent of a node executing rule @xmath96 is its predecessor or successor in the fundamental cycle and the edge between the node and its new parent is not already in the tree ( see predicate @xmath196 ) . in other words",
    ", the algorithm adds and deletes two adjacent edges in the fundamental cycle , which gives after each move a new spanning tree .",
    "moreover , the algorithm can not change the parent of a fundamental cycle root ( see predicate @xmath197 in guard of rule @xmath96 ) , in particular the root of the tree , otherwise the subtree of the fundamental cycle root could be disconnected from the rest of the tree .",
    "thus , the new parent is an ancestor or another node with the same ancestor in the tree .        in a configuration where a spanning tree @xmath2 is constructed ,",
    "we have @xmath198 otherwise it contradicts the fact that @xmath2 is a spanning tree .",
    "moreover , according to case ( 2 ) in the proof of lemma [ lem : no_disconnect_tree ] any move of the cycle improvement module preserves a spanning tree structure .",
    "thus , for any move @xmath198 .",
    "let @xmath2 be an existing tree spanning @xmath3 , such that @xmath2 is a minimum spanning tree of @xmath4 .",
    "thus , @xmath199 . according to the level composition ( defined in @xcite ) , since on a node @xmath6 the predicate @xmath99 determines if the tree must be reconstructed , the only modules executed are the token circulation with labeling module given respectively in @xcite and the cycle improvement module .",
    "the conditional composition ( defined in @xcite ) between the token circulation with labeling module and the cycle improvement module , using predicate @xmath78 on a node @xmath6 determines which module has to be executed . according to lemma [ lem : token ] , for any node @xmath200 eventually predicate @xmath201 and the dfs token continue its circulation .",
    "otherwise , only the cycle improvement module is executed . according to lemma [ lem : no_improve ] and corollary [ cor : always_mst ] ,",
    "a minimum spanning tree of @xmath4 is preserved by the cycle improvement module and therefore by the algorithm composed of the different modules .",
    "[ lem : complex_gen ] starting from a configuration where an arbitrary spanning tree is constructed , in at most @xmath202 rounds the cycle improvement module produces a minimum spanning tree of @xmath4 , with respectively @xmath203 and @xmath7 the number of edges and nodes of the network @xmath4 .    in a given network @xmath21 ,",
    "if a spanning tree of @xmath4 is constructed then there are exactly @xmath204 fundamental cycles in @xmath4 since there are @xmath205 edges in any spanning tree of @xmath4 .",
    "thus , a tree edge can be contained in at most @xmath193 fundamental cycles .",
    "consider a configuration where a spanning tree @xmath2 of @xmath4 is constructed and a tree edge @xmath206 is contained in @xmath193 fundamental cycles and all tree edges have a weight equal to 1 , except @xmath206 of weight @xmath207 .",
    "suppose that @xmath2 is not a minimum spanning tree of @xmath4 such that @xmath208 with @xmath209 and @xmath210 and @xmath211 ( see the graph of figure [ fig : ex_complexite](a ) ) .",
    "consider the following sequence of improvements : @xmath212 , exchange the tree edge @xmath213 by the not tree edge @xmath214 ( see a sequence of improvements in figure [ fig : ex_complexite ] ) . in this sequence",
    ", we have exactly @xmath193 improvements and this is the maximum number of improvements to obtain a minimum spanning tree since there are @xmath193 fundamental cycles and for each one we apply the red rule ( see definition [ def : red_rule ] and theorem [ thm : tarjan_mst ] ) .",
    "an improvement can be initiated in the cycle improvement module by a node with the dfs token .",
    "the dfs token performs a tree traversal in @xmath215 rounds .",
    "moreover , each improvement needs to cross a cycle a constant number of times and each cross requires @xmath215 rounds . since at most @xmath193 improvements are needed to obtain a minimum spanning tree , at most @xmath202 rounds are needed to construct a minimum spanning tree .",
    "improvements , ( b ) the spanning tree obtained after the first improvement , ( c ) the spanning tree obtained after the second improvement , ( d ) the minimum spanning tree of the graph obtained after the third improvement . ]      after a weight edge change the system is no more in a legitimate configuration in the following cases : ( 1 ) the weight of a not tree edge is less than the weight of the heaviest tree edge in its fundamental cycle , or ( 2 ) the weight of a tree edge is greater than the weight of a not tree edge in one of the fundamental cycles including the tree edges .    in each case above , the algorithm must verify if improvements must be performed to reach again a legitimate configuration , otherwise the system is still in a legitimate configuration .",
    "thus , in case ( 1 ) it is only sufficient to verify if an improvement must be performed in the fundamental cycle associated to the not tree edge ( i.e. to apply the red rule a single time ) . to this end , its fundamental cycle must be crossed at most three times : the first time to verify if an improvement is possible , a second time to perform the improvement and a last time to end the improvement , each one needs at most @xmath215 rounds . according to lemma [ lem : do_improve ] and [ lem : end_improve ] ,",
    "the improvement is performed by the algorithm which leads to a legitimate configuration .",
    "case ( 2 ) is more complicated , indeed the weight of a tree edge can change which leads to a configuration where at most @xmath193 improvements must be performed to reach a legitimate configuration , since a tree edge can be contained in at most @xmath193 fundamental cycles as described in proof of lemma [ lem : complex_gen ] . since each improvement phase needs @xmath215 rounds ( see case ( 1 ) ) at most @xmath202 rounds",
    "are needed to reach a legitimate configuration ."
  ],
  "abstract_text": [
    "<S> the minimum spanning tree ( mst ) construction is a classical problem in distributed computing for creating a globally minimized structure distributedly . </S>",
    "<S> self - stabilization is versatile technique for forward recovery that permits to handle any kind of transient faults in a unified manner . </S>",
    "<S> the loop - free property provides interesting safety assurance in dynamic networks where edge - cost changes during operation of the protocol .    </S>",
    "<S> we present a new self - stabilizing mst protocol that improves on previous known approaches in several ways . </S>",
    "<S> first , it makes fewer system hypotheses as the size of the network ( or an upper bound on the size ) need _ not _ be known to the participants . </S>",
    "<S> second , it is loop - free in the sense that it guarantees that a spanning tree structure is always preserved while edge costs change dynamically and the protocol adjusts to a new mst . </S>",
    "<S> finally , time complexity matches the best known results , while space complexity results show that this protocol is the most efficient to date . </S>"
  ]
}