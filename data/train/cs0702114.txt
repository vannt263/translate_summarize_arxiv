{
  "article_text": [
    "in this paper we consider a problem about a computer network .",
    "we use a graph as our model : each computer is a vertex , and we join two vertices @xmath4 by an edge whenever there is a direct communication link joining @xmath5 and @xmath6 .",
    "an _ agent _ in the network is an entity that inhabits one node at a time , and is allowed to move in _ steps _ , where a step consists of the agent leaving its current position @xmath5 and entering a neighbor @xmath6 of @xmath7    the main goal of this paper is to discuss the task of _ agent node traversal _ , which is to make the agent visit all of the nodes of the network at least once .",
    "one practical application of traversal is that the agent can collect information from every node ( like a census ) , without the need for any global network coordination .",
    "one might also use traversal as a way of exploring an initially unknown network .",
    "one well - known technique for performing a traversal is to use _",
    "depth first search _ ( ) , but we claim that it is not practical in all real - world settings . in a depth first search ,",
    "whenever the agent is adjacent to an unvisited node , it moves to that node ; whenever all adjacent nodes are visited , the agent backtracks its path by one step .",
    "it is not hard to see that in a network of @xmath0 nodes , after @xmath8 steps , the network will be traversed and the agent will have returned to its initial position . here",
    "s the problem : what if some edges of the network die ?",
    "the agent may try to backtrack along an edge that no longer exists .",
    "although we could restart  every time this happens , this solution seems somewhat inelegant and inefficient .",
    "one simple alternative mechanism for graph traversal is the following : the agent always travels to the closest unvisited node .",
    "this heuristic , which we call the _",
    "nearest neighbor _",
    "( ) strategy , is the subject of our paper .",
    "it has been studied before under the guise of an approximation algorithm for the traveling salesman problem ( that setting differs from ours only in that , at the end , the agent must return to its initial position ) . for each @xmath9",
    "let the _ approximation ratio _ of  be the least upper bound on the ratio @xmath10 where @xmath11 is an traversal on an @xmath0-node graph , @xmath12 measures the number of steps , and @xmath13 is the cheapest traversal of the graph . abusing this definition slightly , for a fixed graph @xmath14 and  traversal @xmath15 we sometimes call @xmath10 an approximation ratio of _ on @xmath16 _    the authors of @xcite proved that the approximation ratio of  is at most @xmath17 and gave an infinite family of edge - weighted graphs where  has an approximation ratio of at least @xmath18 a simpler ( and non - weighted ) family was later found by @xcite giving an approximation ratio of at least @xmath19      the authors of @xcite point out that the upper bound proof in @xcite is `` technical . '' in section [ sec1 ]",
    "we give a simple and new proof , but where the approximation ratio @xmath20 is replaced by @xmath21 which is slightly worse .",
    "our approach is to bound the number of long steps in a traversal generated by . at the conclusion of the paper",
    "we mention another application of this technique .",
    "_ remark : this paper was submitted to a conference and a referee pointed out that this proof technique can also be found in an analysis @xcite by alon and azar of the imase - waxman online minimum steiner tree heuristic .",
    "_    we also improve the best known lower bound and show a family of ( non - weighted ) graphs upon which  has an approximation ratio of at least @xmath22 this appears in section [ sec2 ] . with slightly more work , and using the upper bound from @xcite",
    ", this establishes that the approximation ratio of  is @xmath22    in section [ sec - appl ] , we analyze a simple distributed implementation of the  heuristic .",
    "if there are no faults , then the algorithm always visits all nodes within @xmath23 time .",
    "however , as our introduction suggests , we are interested in what happens when faults are allowed . to our knowledge ,",
    "ours is the first such analysis .",
    "we allow edges to be destroyed over time , but no edges are ever added to the graph or restored .",
    "we prove an @xmath2 upper bound on the time before the distributed  algorithm terminates ( i.e. , until every node remaining in the agent s connected component is visited ) .    finally , in section [ sec : games",
    "] , we give a result which indicates that  is in some sense optimal .",
    "we show that for every strategy that an agent could use , there is an edge failure pattern which forces the agent to take at least @xmath24 steps .",
    "hence  uses the least number of steps ( in the worst case ) of any heuristic , up to a constant factor .",
    "this is not true of  with the `` restart when you can not backtrack '' modification ; see appendix [ app : dfs ] .",
    "in this section , we assume that the graph @xmath25 does not change over time . for any two nodes @xmath5 and @xmath26 their _ distance _ @xmath27 denotes the minimum number of edges in any @xmath5-@xmath6 path .",
    "the nearest neighbor heuristic is shown below ( algorithm [ alg : nn ] ) .",
    "the algorithm takes a cost function @xmath28 as input , so if we only want to count the number of steps taken by the agent , then we would take @xmath29 we consider only symmetric cost functions in this paper , in other words , we assume @xmath30 for all nodes @xmath31    @xmath32 is the initial location of the agent let @xmath33 be any node in @xmath34 such that @xmath35 is minimized    a _ traversal _ is any permutation of the vertex set @xmath36 we call any sequence @xmath37 that can be produced by the above algorithm a _",
    "nearest neighbor traversal .",
    "_      a vertex sequence @xmath38 has _ cost _ @xmath39 defined by @xmath40 we say that a function @xmath28 satisfies the _ triangle inequality _",
    "if @xmath41 for all nodes @xmath42 the triangle inequality may be equivalent stated as : for a given @xmath5-@xmath6 path , replacing that path by the single edge @xmath43 ( sometimes called _ short - cutting _ ) does nt increase the cost .",
    "note that @xmath44 satisfies the triangle inequality .",
    "the precise statement of the main theorem of this section is as follows .",
    "[ thm1 ] suppose @xmath28 is a non - negative integer - valued function that is symmetric and satisfies the triangle inequality",
    ". then the approximation ratio of @xmath45 is at most @xmath46    now when @xmath47 ( i.e. , the cost is the number of agent steps ) then a  traversal has cost at most @xmath48 and hence in this case theorem [ thm1 ] implies that  always returns a traversal of cost at most @xmath49 we remark that the triangle inequality is necessary here to get a performance bound that depends only on @xmath50 as exemplified in figure [ fig - trinec ] .",
    "( -3.2 , -1.2)(3.2,1.2 ) ( -2,-1)a@xmath51 ( 2,-1)b@xmath51 ( 0,0)c@xmath51 ( 0,1.3)d@xmath51    hereafter we fix the number @xmath0 of vertices , a cost function @xmath28 that satisfies the triangle inequality , and a traversal @xmath52 generated by .",
    "define @xmath53 to be the number of pairs of consecutive nodes with cost at least @xmath54 between them : @xmath55 by switching the order of summation , we see that the traversal s cost is precisely the sum of all @xmath56 @xmath57    [ lemma1 ] let @xmath58 be a partition of @xmath59 and suppose for each @xmath60 for any two nodes @xmath61 that @xmath62 then @xmath63    suppose that @xmath64 and let @xmath65 be contained in class @xmath66 of the partition .",
    "we claim that @xmath65 was the last node of @xmath66 visited by the agent . otherwise , if @xmath67 then after reaching @xmath65 the agent chose @xmath68 such that @xmath69 contradicting the fact that the agent makes greedy choices .",
    "thus for each of the @xmath70 parts @xmath66 there is at most one node @xmath65 in @xmath66 such that @xmath71 furthermore , let @xmath66 be the part containing @xmath72 and we see @xmath73 for each @xmath74 the lemma then follows .",
    "now , let @xmath75 be a traversal of optimal cost @xmath76 by a short - cutting argument it is easy to see that @xmath77 for all vertices @xmath78 and hence @xmath79 when @xmath80 moreover , we obtain the following bound on @xmath53 for other values of @xmath81    [ lemma2 ] for each positive integer @xmath54 we have @xmath82    by lemma [ lemma1 ] , it suffices to exhibit a partition of @xmath59 into at most @xmath83 parts , such that the pairwise costs within each part are at most @xmath84 we can do this by breaking @xmath85 into paths of length about @xmath86 each .",
    "define @xmath87 and iteratively compute integers @xmath88 for @xmath89 such that @xmath90 this is continued as long as possible , that is , until some @xmath70 satisfies @xmath91 note @xmath92 is a strictly increasing sequence , so @xmath70 is well - defined .",
    "let @xmath93 and define @xmath94 for @xmath95 note that the @xmath70 sets @xmath96 partition @xmath36 furthermore , using the triangle inequality in a short - cutting argument , it is easy to see that @xmath97 for each @xmath98    intuitively , each @xmath96 accounts for a portion of @xmath85 of length @xmath99 so we would expect @xmath100 parts plus a remainder . formally , using the definition of @xmath101 and equation ,",
    "we have @xmath102 so @xmath60 the number of parts , is at most @xmath103 as needed .    finally , we estimate the resulting bound on the length of @xmath15 and hence prove theorem [ thm1 ] .    from equation",
    "we have @xmath104 for all @xmath105 further , recall that @xmath79 for @xmath80 we may assume without loss of generality that @xmath106 divides @xmath107 as otherwise we can increase @xmath28 uniformly by a factor of @xmath108 we apply equation   and then lemma [ lemma2 ] , obtaining @xmath109 thus , as claimed , the cost of @xmath11 is at most @xmath110 times the cost of @xmath111    let @xmath112 ( resp .",
    "@xmath113 ) denote the minimum ( resp .",
    "maximum ) value of @xmath114 over all pairs @xmath115 we can tighten theorem [ thm1 ] in some cases and show that the approximation guarantee of  depends logarithmically on the _ aspect ratio _",
    "@xmath116 @xmath117 in comparison , monnot @xcite showed that in the absence of the triangle inequality ,  has approximation ratio @xmath118      in this section we describe a new family of graphs upon which  has an approximation ratio of at least @xmath22 we remark that the original lower bound of @xcite could not be realized as the distance function @xmath44 of any unweighted graph , but ours ( like the example from @xcite ) can be .",
    "we call the family _ layered ring graphs _ because of their shape .",
    "the layered ring graphs are denoted @xmath119 where @xmath120 is the number of layers and @xmath121 is a size parameter .",
    "the basic idea is that the agent in the nearest neighbor algorithm can be forced to walk  around \" the ring @xmath70 times , once for each layer .",
    "each vertex in @xmath119 is assigned a _ position _",
    "@xmath122 and we define two nodes @xmath4 to be adjacent precisely when @xmath123 every layered ring graph includes the _ backbone _ vertices @xmath124 whose positions are @xmath125 it follows that every layered ring graph is hamiltonian , since starting at @xmath126 we can visit all vertices in position 0 , then take an edge to @xmath127 and subsequently visit all vertices in position 1 , and so forth until we return from the last vertex at position @xmath128 to @xmath129    for notational convenience , we fix @xmath112 at this point and use only @xmath70 as a parameter ; so we omit @xmath112 and write @xmath130 instead of @xmath131 the first layered ring graph @xmath132 consists of only the backbone .",
    "each ring graph @xmath133 is constructed from the previous one @xmath134 by the addition of a _",
    "layer_.    we ll show that on @xmath135 the agent can walk around the ring @xmath70 times , and hence the  heuristic can return a traversal of cost about @xmath136 as we will make precise in lemma [ lemma : lower ] , when @xmath70 is roughly equal to @xmath137 we ll have @xmath138 but since @xmath139 is hamiltonian , we get an approximation ratio of at least @xmath140    a _ layer _ is a set @xmath141 such that @xmath142 with the following property : if @xmath143 and @xmath144 then @xmath145 is a power of @xmath146    we are about to define a sequence @xmath147 of layers .",
    "we say that @xmath148 are _",
    "@xmath149-neighbors _ if @xmath150 and we denote this relation by @xmath151 where @xmath152    [ deflay ] define the first layer @xmath153 as follows : @xmath154 for @xmath155 define the @xmath156st layer @xmath157 as follows : @xmath158    observe that @xmath159 for all @xmath160    [ lrdef ] the layered ring graph @xmath132 consists of the backbone . for @xmath161 the layered ring graph @xmath162",
    "consists of the disjoint union of @xmath163 together with one new vertex @xmath164 for each @xmath165 we define @xmath166    in figure [ figlr ] , we show an example of a layered ring graph . for the rest of this section , @xmath28 is the distance function @xmath44 of @xmath167    ( -3.8 , -3.8)(3.8,3.8 )    it is possible for @xmath168 to return a traversal of cost @xmath169 [ mainclaim ]    we will show that the agent may visit the nodes in the following order : backbone , layer @xmath60 layer @xmath170 and so on , visiting layer 1 last . each layer , and also the backbone , is visited in increasing order of position .    in the backbone ,",
    "@xmath171 for @xmath172 and so these steps are valid for the  heuristic as all pairwise distances are at least 1 . similarly , as @xmath173 and @xmath174 for @xmath175 it remains only to show that the intra - layer steps are valid .",
    "precisely , for each @xmath176 and for each @xmath177 such that @xmath178 say that a node @xmath179 is _ bad _ if @xmath180 and @xmath181 is not visited before @xmath182 our goal is to show that no bad nodes exist .",
    "fix @xmath183 as above .",
    "first , consider the nodes of layer @xmath184 that are not visited before @xmath182 since we visit layer @xmath184 in increasing order of position , no node of the form @xmath185 is bad unless @xmath186 but from definition [ deflay ] it follows easily that @xmath187 and so no bad nodes exist in layer @xmath188    it remains to show that no bad nodes exist in layers @xmath189 if @xmath190 then this is trivial . otherwise , by the definition of layers",
    ", it must be that @xmath191 holds where @xmath192 thus there are no nodes in level @xmath193 with position strictly between @xmath194 and @xmath195 from which it follows that level @xmath193 contains no bad nodes .",
    "similarly since @xmath196 for @xmath197 no bad nodes exist in any other layer .",
    "in appendix [ app : form ] , we show a simple way to count the number of nodes in @xmath198 obtaining : @xmath199    in what follows , we write @xmath200 to mean that @xmath201    [ lemma : lower ] fix @xmath202 for each @xmath203 let @xmath204 then as @xmath205 @xmath206    first note that @xmath207 for an upper bound on @xmath208 equation gives @xmath209 in turn , we can bound this expression by reinterpreting the sum using a binomial random variable and applying a chernoff bound ( * ? ? ? * thm . 4.2 ) .",
    "namely , @xmath210 < 2^m \\exp\\left(-\\frac{(m-1)\\delta^2}{4(2+\\delta)^2}\\right ) = o(2^mm^{-1}).\\ ] ] then recalling equation , we see that @xmath211 as claimed .",
    "[ thm : lowerbound ] the approximation ratio @xmath212 of  satisfies @xmath213    the upper bound in @xcite that we have mentioned implies that the left - hand side of equation   is at most 1/2 .",
    "now pick any @xmath214 and consider the family of graphs in lemma [ lemma : lower ] .",
    "the number @xmath0 of vertices satisfies @xmath215 by claim [ mainclaim ] each graph in the family admits an  traversal of cost @xmath216 but each graph is hamiltonian and so has optimal traversal cost @xmath108 hence @xmath217 as @xmath218 so does @xmath219 and by taking @xmath220 and @xmath221 we obtain equation  .    with a little more effort",
    ", we can replace the @xmath222 in the above equation by @xmath223 or in other words we can establish that @xmath224 we defer the details to appendix [ app - fooey ] .",
    "as we stated in the introduction , one motivation for the nearest neighbor algorithm is its potential usefulness in computer networks with edge failures . we give a simple implementation below ( algorithm [ alg2 ] ) .",
    "the variable @xmath225 represents the position of the agent .",
    "each node @xmath6 keeps a flag @xmath226 to indicate whether it has been visited , and a number @xmath227 which represents an estimate of the distance from @xmath6 to the nearest unvisited node .",
    "set @xmath228 and @xmath229 for each vertex let @xmath225 be the agent s initial position , and set @xmath230 let @xmath231 [ line : dis1 ] [ line : dis2 ] some edges may be deleted    line [ line : dis1 ] determines the shortest paths to unvisited nodes , and line [ line : dis2 ] makes the agent travel along these paths . for future reference , we need the following remarks :    1 .   for each node",
    "@xmath26 the value @xmath227 is nondecreasing with time . 2 .   at all times",
    ", @xmath227 is at most the actual distance to the closest unvisited node .",
    "remark r1 can be proved by induction on the number of iterations elapsed , and remark r2 can be proved by induction on the distance to the closest unvisited node .",
    "say that a node is _ explored _ the first time that the agent visits it .",
    "if no failures occur , it is not too difficult to show that the agent generates a greedy tour @xmath11 in the following way : after exploring @xmath232 it remains motionless for @xmath233 rounds , and in the following @xmath233 rounds it travels directly to @xmath234 using theorem [ thm1 ] , we find that @xmath235 so all nodes are visited within @xmath23 iterations .",
    "the purpose of this section is to show that edge failures can dramatically increase the time complexity of network traversal .",
    "we considered a variant of the above implementation where each node instantly knows the _ actual _ distance to the nearest unvisited node , but the results were essentially the same as what we present here .",
    "if the graph becomes disconnected due to edge failures , then it may not be possible for the agent to visit all of the nodes .",
    "given this fact , and furthermore that the agent may not initially know the value of @xmath50 how can we detect termination ?",
    "we use the following idea : the agent keeps a count @xmath236 of how many nodes it has explored so far , and once @xmath237 ( using r2 ) there can be no more reachable unvisited nodes . using this as the definition of termination , we now upper bound the algorithm s running time .",
    "[ thm : alg2fast ] algorithm [ alg2 ] terminates in at most @xmath2 iterations , regardless of how the edge failures occur .    to simplify the arguments ,",
    "suppose we do not permit any @xmath238 label to exceed @xmath239 ( that is , once it hits this value , it does not increase further ) .",
    "it is not hard to see that this does not affect the observed behavior of the algorithm .",
    "first , we claim there are at most @xmath2 iterations in which the agent moves .",
    "when the agent moves , the value @xmath240 decreases by at least 1 .",
    "however , the value @xmath240 can only increase @xmath2 times , since @xmath225 can be any of the @xmath0 nodes , and each node s @xmath238 label increases at most @xmath239 times ( by r1 ) .",
    "second , we can also show there are at most @xmath2 iterations in which the agent does not move .",
    "if the agent does not move in a given iteration , then either the algorithm terminates in that iteration , or @xmath227 increases for some node @xmath241    for the sake of contradiction , consider a non - final iteration in which @xmath227 does not increase for any node @xmath241 by induction on @xmath242 we can show that every node @xmath6 at distance @xmath243 from the nearest unvisited node has @xmath244 and if all nodes in the connected component of @xmath6 are visited , then @xmath245 but this is a contradiction , for it is easy to see that the agent would have taken a step towards a nearest unvisited node .",
    "since there are @xmath0 nodes and each nodes s @xmath238 label can increase at most @xmath239 times , we see that the agent remains still in @xmath2 iterations .    in appendix",
    "[ app : dfs ] we show , in contrast , that  with restarting ( as described in the introduction ) may take @xmath246 time .      the upper bound of theorem [ thm : alg2fast ] , it turns out , has a lower bound that matches it up to a constant factor .",
    "however , the lower bound does nt depend on any properties of the  heuristic .",
    "rather , we can show that _ any _ heuristic for visiting all nodes must take at least @xmath24 steps , if a suitable pattern of edge deletions occurs .",
    "we express this idea as a game : the objective of the agent is to be in a connected component of @xmath14 where every node has been visited , and an _ adversary _ chooses the edges to delete , and wants to foil the agent for as long as possible . an _ adaptive adversary _  one that can see the current state of the network in each iteration before deciding what to delete  is arguably the most powerful adversary possible .",
    "we phrase our proof using an adaptive adversary .",
    "note however that for a _",
    "traversal heuristic , a non - adaptive adversary is just as powerful as an adaptive one , since the adversary can optimize its behavior ahead of time by simulating the agent .",
    "here is what we , as the adversary , should do .",
    "the graph @xmath14 is originally a complete graph on @xmath0 vertices .",
    "we wait until the agent has visited @xmath106 nodes ; let @xmath6 be the @xmath247st node visited , and @xmath248 be the last remaining unvisited node .",
    "we then destroy the edge @xmath249 as a result , the agent can not visit @xmath248 in the next step .",
    "similarly , as soon as the agent moves to any other node @xmath250 such that @xmath250 is adjacent to @xmath251 we destroy the edge @xmath252 we continue this until there are precisely 2 nodes @xmath253 and @xmath254 adjacent to @xmath251 and we wait for the agent to visit one or the other ( clearly the algorithm can not terminate before then , since the agent is connected to the unvisited node @xmath248 ) . without loss of generality , assume the agent steps to @xmath253 before @xmath255 then we perform two edge deletions : we remove both @xmath256 and @xmath257 define @xmath258 intuitively , we now want to keep the agent at distance 2 or more from @xmath248 for as long as possible .    in general , the @xmath184th `` phase '' begins when @xmath259 is defined .",
    "each time the agent moves onto a node @xmath250 adjacent to @xmath260 we delete @xmath261 this continues until there are two nodes other than @xmath262 adjacent to @xmath260 which we call @xmath263 and @xmath264 w.o.l.o.g .",
    "let the agent reach @xmath263 first , and at that point , we delete both @xmath265 and @xmath266 we also define @xmath267 and the @xmath156st phase begins .",
    "we depict a generic phase in figure [ fig : phase ] .",
    "( -3.1 , -1.8)(3.1,2.1 ) ( -3.3 , 0.0)(-2.7 , 0.0)(-3 , 0.35 ) ( -3 , -1.1)(-2.7 , -0.6)(-3.3 , -0.6 ) ( -3 , -0.3)0.4 ( -3 , 2)@xmath248 ( -3 , 1)@xmath268 ( -3 , 0.5)@xmath259 ( -3 , 1.5)@xmath269 ( -3 , 1.65)(-3 , 1.85 ) ( -3 , 1.15)(-3 , 1.35 ) ( -3 , 0.65)(-3 , 0.85 ) ( -3.3 , 0.0)(-3 , 0.35 ) ( -2.7 , 0.0)(-3 , 0.35 ) ( -3.3 , -0.6)(-3 , -1.1 ) ( -2.7 , -0.6)(-3 , -1.1 ) ( -3 , -1.1)@xmath270 ( -3 , -1.1)(-3.5,-0.7)(-3,-0.3 ) ( -3 , -1.1)(-3.5,-0.7)(-3,-0.3 ) ( -3,-0.3)(-3 , 0.35 ) ( -2 , 0.5)@xmath271 ( -1.3 , 0.0)(-0.7 , 0.0)(-1 , 0.35 ) ( -1 , -1.1)(-0.7 , -0.6)(-1.3 , -0.6 ) ( -0.7 , -1.1)(-0.7 , -0.6)(-1.3 , -0.6 ) ( -1 , -0.3)0.4 ( -1 , 2)@xmath248 ( -1 , 1)@xmath268 ( -1 , 0.5)@xmath259 ( -1 , 1.5)@xmath269 ( -1 , 1.65)(-1 , 1.85 ) ( -1 , 1.15)(-1 , 1.35 ) ( -1 , 0.65)(-1 , 0.85 ) ( -1.3 , 0.0)(-1 , 0.35 ) ( -0.7 , 0.0)(-1 , 0.35 ) ( -1.3 , -0.6)(-1 , -1.1 ) ( -0.7 , -0.6)(-1 , -1.1 ) ( -1.3 , -0.6)(-0.7 , -1.1 ) ( -0.7 , -0.6)(-0.7 , -1.1 ) ( -0.7 , -1.1)@xmath272 ( -1,-1.1)(-1,-1.1 ) ( -1,-1.1)(-0.7,-1.1 ) ( -0.7 , -1.1)(-0.5,-0.7)(-1.1,-0.4 ) ( -0.7 , -1.1)(-0.5,-0.7)(-1.1,-0.4 ) ( -1 , 0.35)(-1.1 , -0.4 ) ( 0 , 0.5)@xmath268 ( 0.65 , -1.0)(0.7 , -0.4)(1.35 , -1.0 ) ( 0.65 , -1.0)(1.3 , -0.4)(1.35 , -1.0 ) ( 0.65 , -1.0)(0.7 , -0.4)(1.35 , -1.0 ) ( 0.65 , -1.0)(1.3 , -0.4)(1.35 , -1.0 ) ( 1 , -1)0.4 ( 1 , 2)@xmath248 ( 1 , 1)@xmath268 ( 1 , 0.5)@xmath259 ( 1 , 1.5)@xmath269 ( 0.7 , -0.3)@xmath263 ( 1.3 , -0.3)@xmath273 ( 0.85 , -0.3)(1.15 , -0.3 ) ( 1 , 0.35)(1.3 , -0.15 ) ( 1 , 0.35)(0.7 , -0.15 ) ( 1 , 1.65)(1 , 1.85 ) ( 1 , 1.15)(1 , 1.35 ) ( 1 , 0.65)(1 , 0.85 ) ( 1 , -1.1)@xmath272 ( 1 , -1.1)(0.3,-0.7)(0.55,-0.3 ) ( 2 , 0.5)@xmath271 ( 2.65 , -1.0)(3.3 , -0.4)(3.35 , -1.0 ) ( 2.65 , -1.0)(3.3 , -0.4)(3.35 , -1.0 ) ( 2.7 , -1.3)(3 , -1.7)(3.3 , -1.3 ) ( 2.7 , -1.3)(3 , -1.7)(3.3 , -1.3 ) ( 3 , -1)0.4 ( 3 , 2)@xmath248 ( 3 , 1)@xmath268 ( 3 , 0.5)@xmath259 ( 3 , 1.5)@xmath269 ( 3.3 , -0.3)@xmath274 ( 3 , 0.35)(3.3 , -0.15 ) ( 3 , -1)(3.3 , -0.4 ) ( 3 , 1.65)(3 , 1.85 ) ( 3 , 1.15)(3 , 1.35 ) ( 3 , 0.65)(3 , 0.85 ) ( 3 , -1.7)@xmath272 ( 3 , -1.7)(2.5,-1.4)(3,-1 )    this can be continued until the end of the @xmath275rd phase , at which point the nodes consist of @xmath276 with the agent at @xmath277 the remaining graph is a path , and the agent needs to take @xmath247 more steps to complete its traversal .",
    "in the @xmath184th phase , the agent has to move onto @xmath278 distinct nodes .",
    "there are at least @xmath279 additional steps at the beginning before we define @xmath280 hence the total number of steps is at least @xmath281",
    "a _ nearest neighbor tree _ , introduced in @xcite , is any tree that can be produced by algorithm [ alg : nnt ] shown below .",
    "( note that it always produces a tree . ) using the technique of section [ sec1 ] , we are able to get a simpler proof of the main approximation result from @xcite .",
    "each node @xmath6 is assigned a unique rank @xmath282 let @xmath283 be a node such that @xmath284 connect from @xmath6 to @xmath283 ( i.e. , add the edge @xmath285 to the tree )    the cost of any nearest neighbor tree @xmath286 is at most @xmath287 times the cost of a minimum spanning tree .",
    "let @xmath53 denote the number of edges in @xmath286 of cost @xmath54 or more .",
    "let @xmath13 be a minimum spanning tree and let @xmath85 be a depth - first search traversal of @xmath288 it follows that @xmath289 as in the proof of lemma [ lemma2 ] , for any integer @xmath99 we can partition @xmath59 into @xmath290 parts @xmath96 such that in each part , every pair of nodes is at most a distance @xmath86 apart .",
    "in each part @xmath291 we claim that at most one node in @xmath96 tries to form a connection of cost @xmath54 or greater . indeed ,",
    "only the maximum - rank node @xmath5 in @xmath96 can do so , as all others can connect to @xmath5 instead at cost at most @xmath84 as before we find that @xmath292 which permits us to use the same integral estimate as in the proof of theorem [ thm1 ] .",
    "we get @xmath293    there is an interesting and difficult related problem which we were unable to solve . consider our original problem of counting the number of steps taken by an agent executing the  heuristic  in other words , assume that @xmath28 is the distance function for some ( unweighted ) graph .",
    "the costly  traversal of layered ring graphs , and similarly the  traversal of the example from @xcite , both perform a lot of arbitrary tie - breaking .",
    "if we break all ties randomly , then the performance seems to improve .",
    "is it possible that this would improve the approximation ratio of to @xmath294 ?",
    "( an observation in @xcite shows in the case of edge - weighted graphs , random tie - breaking does nt help . ) similarly , when the edge - deleting adversary is not adaptive , does randomization help in the distributed setting ?    1    n.  alon and y.  azar . on - line",
    "steiner trees in the euclidean plane . in _",
    "symposium on computational geometry _ , pages 337343 , 1992 .",
    "w.  j. cook , w.  h. cunningham , w.  r. pulleyblank , and a.  schrijver . .",
    "john wiley & sons , inc .",
    ", new york , ny , usa , 1998 .",
    "c.  a.  j. hurkens and g.  j. woeginger . on the nearest neighbor rule for the traveling salesman problem .",
    ", 32(1):14 , 2004 .",
    "m.  khan and g.  pandurangan . a fast distributed approximation algorithm for minimum spanning trees . in s.",
    "dolev , editor , _ disc _ , volume 4167 of _ lecture notes in computer science _ , pages 355369 .",
    "springer , 2006 .",
    "j.  monnot .",
    "approximation results toward nearest neighbor heuristic .",
    ", 12(1):1116 , 2002 .",
    "r.  motwani and p.  raghavan . .",
    "cambridge university press , 2000 .",
    "d.  j. rosenkrantz , r.  e. stearns , and p.  m. lewis ii .",
    "an analysis of several heuristics for the traveling salesman problem .",
    ", 6(3):563581 , 1977 .",
    "a _ leg _ of @xmath149 is an ordered pair @xmath295 such that @xmath296 the _ length _ of that leg is @xmath297    let @xmath298 denote the number of legs of length @xmath299 in @xmath300    the iterative construction of the graphs gives the following recurrence relation .    1 .   @xmath301 and @xmath302 2 .",
    "for @xmath303 and @xmath304 we have @xmath305 3 .",
    "for @xmath304 we have @xmath306    the solution of this recurrence relation for @xmath307 is @xmath308    by using the identity @xmath309 it is easily verified that the claimed formulas satisfy conditions ( 1)(3 ) .",
    "we have that @xmath310 we can simplify the part of the sum with @xmath311 since @xmath312 this observation leads to the following formula for @xmath313 ( note that we include the @xmath314 backbone nodes ) . @xmath315",
    "we need to do some interpolation to show that @xmath316 the problem is that as @xmath112 increases by one , the graphs @xmath317 roughly double their number of vertices , leaving a large gap . for this purpose",
    ", we may generalize the construction of layered ring graphs in the following way .",
    "we replace the size parameter @xmath128 by a size parameter @xmath318 and no longer insist that @xmath149-neighbors differ by a power of 2 .",
    "we redefine the layers in the following way .",
    "define the first layer @xmath153 as follows : @xmath319 for @xmath155 define the @xmath156st layer @xmath157 as follows : @xmath320    having defined the layers , we define the layered ring graphs @xmath321 using definition [ lrdef ] exactly as before . it is straightforward to see that this indeed generalizes our previous construction .",
    "that is , if @xmath322 then @xmath323 for all @xmath324 we omit the straightforward proof of the following claim .    [ daclaim ] for fixed @xmath60 latexmath:[$|v(lr^k(\\nu))|+1 \\leq |v(lr^k(\\nu+1))| \\leq     the approximation ratio @xmath212 of  satisfies @xmath316    considering theorem [ thm : lowerbound ] , we need to show that @xmath326 let @xmath327    for any @xmath50 pick @xmath112 so that @xmath328 it follows that @xmath329 fix @xmath330 it also follows from lemma [ lemma : lower ] that @xmath331 has @xmath332 non - backbone vertices .    pick the largest @xmath333 such that @xmath334 by equation  , @xmath335 by claim [ daclaim ] it follows that @xmath321 graph has @xmath332 non - backbone vertices , and hence that @xmath336    from claim [ daclaim ] it also follows that by adding at most @xmath337 vertices to @xmath338 we can obtain a graph on exactly @xmath0 vertices , which we will call @xmath339 connect these new vertices in a clique and connect them to @xmath126 and @xmath340 there is an  traversal of @xmath341 where we visit the new clique first , then the backbone , and then the layers in decreasing order ; the proof is analogous to lemma [ mainclaim ] .",
    "this  traversal takes at least @xmath342 steps , whereas a hamiltonian circuit exists in @xmath343 and so @xmath344 taking @xmath345 completes the proof .",
    "in this section we consider a version of  that is adapted for the distributed setting with edge failures , which is the network model used in section [ sec - appl ] .",
    "recall that edge failures are allowed , but edge additions / restorations are forbidden .",
    "we consider the following protocol for network traversal : the agent performs a depth - first search , but whenever it is required to backtrack an edge @xmath346 that has been deleted since the agent traversed @xmath346 in the forwards direction , the agent begins a completely new depth - first search .",
    "the algorithm terminates once a  successfully completes ( i.e. , returns to its originating vertex , and has explored all of its neighbors ) .",
    "it is not hard to see that this algorithm will eventually terminate successfully ( i.e. , the agent will have visited all nodes of the connected component within which it lies ) .",
    "there is a simple upper bound on the number of steps taken by this protocol : the  can restart at most @xmath347 times since there are at most @xmath348 edges that can be deleted , and each individual  takes at most @xmath349 steps , so the total number of steps is at most @xmath350 we claim that in fact @xmath246 steps can be taken in the worst case .    here is the construction .",
    "consider a graph that consists of two cliques @xmath351 each on @xmath352 nodes , joined by a path having @xmath352 internal vertices . fix a spanning tree @xmath286 such that no path in @xmath286 contains @xmath353 or @xmath354 ; such a tree is easily seen to exist for @xmath355 begin with the agent at some node @xmath356 pick any edge @xmath43 such that @xmath357 and @xmath358 ; without loss of generality assume @xmath6 is not on the @xmath359-@xmath5 path in @xmath360 have the agent walk along this path to @xmath361 and then traverse @xmath362 then , delete @xmath362 by our choice of @xmath363 the agent will eventually need to backtrack to @xmath364 however , the backtracking will first attempt to traverse @xmath365 causing a restart .",
    "the agent is left at @xmath26 and symmetrically to before , we pick any remaining non - tree edge @xmath366 in @xmath367 ( with @xmath368 not on the @xmath6-@xmath369 path in @xmath286 ) , send the agent along @xmath286 to @xmath369 and across @xmath370 and delete @xmath371 we repeat this process , sending the agent between the cliques ( and hence across the @xmath372-edge path ) a total of @xmath373 times , and thus using @xmath374 steps ."
  ],
  "abstract_text": [
    "<S> a mobile agent in a network wants to visit every node of an @xmath0-node network , using a small number of steps . </S>",
    "<S> we investigate the performance of the following `` nearest neighbor '' heuristic : always go to the nearest unvisited node . </S>",
    "<S> if the network graph never changes , then from ( rosenkrantz , stearns and lewis , 1977 ) and ( hurkens and woeginger , 2004 ) it follows that @xmath1 steps are necessary and sufficient in the worst case . </S>",
    "<S> we give a simpler proof of the upper bound and an example that improves the best known lower bound .    </S>",
    "<S> we investigate how the performance of this heuristic changes when it is distributively implemented in a network . </S>",
    "<S> even if network edges are allow to fail over time , we show that the nearest neighbor strategy never runs for more than @xmath2 iterations . </S>",
    "<S> we also show that any strategy can be forced to take at least @xmath3 steps before all nodes are visited , if the edges of the network are deleted in an adversarial way . </S>"
  ]
}