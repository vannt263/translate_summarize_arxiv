{
  "article_text": [
    "a group of @xmath0 mobile robotic agents and @xmath0 target locations , all lying in @xmath1 , @xmath2 .",
    "each agent has a limited communication range , and knows the location of some subset ( possibly all ) of the @xmath0 targets through gps coordinates or a map of the environment .",
    "the _ target assignment problem _ we consider is to design a distributed algorithm that allows the group of agents to divide the @xmath0 targets among themselves and , simultaneously , that leads each agent to reach its unique target .",
    "such a problem could arise in several applications .",
    "for example , one could think of the agents as uav s on a surveillance mission , and the targets as the centers of their desired loitering patterns . or in the context of formation control , the target positions could describe the desired formation for a group of robots .",
    "the first question is ; how do we divide the targets among the agents in a centralized fashion ?",
    "a reasonable strategy would be to minimize the sum of the distances traveled by each agent to arrive at its target .",
    "the problem of optimally dividing @xmath0 persons among @xmath0 objects , subject to a linear cost function , is a problem in combinatorial optimization @xcite .",
    "it is referred to as the _ assignment problem _ , or the _ minimum weight perfect matching problem in bipartite graphs_. the assignment problem can be written as an integer linear program . unlike some integer linear programs , such as the euclidean traveling salesperson problem ( etsp ) , optimal solutions for the assignment problem can be computed in polynomial time . in 1955",
    "kuhn @xcite developed the hungarian method ",
    "the first polynomial solution for the assignment problem .",
    "kuhn s method solves the problem in @xmath3 computation time ( see section [ sec : background ] for a definition of the @xmath4 notation ) .",
    "another approach to the assignment problem is the _ auction algorithm _",
    "@xcite , first proposed by bertsekas .",
    "this method solves the problem in @xmath3 computation time , but can be computed in a parallel fashion , with one processor for each person .",
    "recently , moore and passino @xcite modified the auction algorithm to assign mobile robots to spatially distributed tasks in the presence of communication delays .",
    "however , in order to exchange bids on a particular object ( task ) , the auction algorithm , and thus the work in @xcite , requires that the communication graph between processors ( robots ) is complete .    in this paper",
    "we address the target assignment problem when each agent has knowledge of all target positions , and a limited communication range @xmath5 .",
    "we introduce a class of distributed algorithms , called _ assignment - based motion _ , which provide a natural approach to the problem .",
    "following the recent interest in determining the time complexity of distributed algorithms for robotic networks , as in @xcite and @xcite , we study the worst - case asymptotic performance of the assignment - based motionclass as the environment grows with @xmath0 . we show that for a @xmath6-dimensional cube environment , @xmath7^d$ ] , @xmath8 , if the side length @xmath9 grows at a rate of at least @xmath10 , where @xmath11 , then the completion time is in @xmath12 , for all algorithms in this class .    in section [ sec : etsp_asst ]",
    "we introduce a novel control and communication algorithm , called etsp assignment . in this algorithm",
    ", each agent computes an etsp tour through the @xmath0 targets , turning the cloud of target points into an ordered ring .",
    "agents then move along the ring , looking for the next available target . when agents communicate , they exchange messages of @xmath13 size , containing information on how far it is to the next available target along the ring . in section",
    "[ sec : correctness ] , we verify the correctness of this algorithm for any communication graph which contains , as a subgraph , the @xmath14-disk graph . in section [ sec :",
    "time_complex ] , we show that when @xmath15 , among all algorithms in the assignment - based motionclass , the etsp assignmentalgorithm is asymptotically optimal ( i.e. , a constant factor approximation of the optimal )",
    ". finally , in section [ sec : n_neq_m ] , we note that etsp assignmentsolves the target assignment problem even when there are @xmath0 agents and @xmath16 targets , @xmath17 .",
    "in this section we introduce notation and review some relevant results in combinatorial optimization .",
    "we let @xmath18 denote the set of real numbers , @xmath19 denote the set of positive real numbers , and @xmath20 denote the set of positive integers . for a set finite @xmath21 we let @xmath22 denote its cardinality . for two functions @xmath23",
    ", we write @xmath24 ( respectively , @xmath25 ) if there exist @xmath26 and @xmath27 such that @xmath28 for all @xmath29 ( respectively , @xmath30 for all @xmath29 ) .",
    "if @xmath31 and @xmath32 we say @xmath33 . finally , we use the notation @xmath34 to denote arithmetic performed modulo @xmath35 .",
    "thus , for an integer @xmath35 we have @xmath36 and @xmath37 , and @xmath38 .",
    "following @xcite , the classical assignment problem can be described as follows .",
    "consider @xmath0 persons who wish to divide themselves among @xmath0 objects .",
    "for each person @xmath39 , there is a nonempty set @xmath40}}$ ] of objects that @xmath39 can be assigned to , and cost @xmath41 associated to each object @xmath42}}$ ] .",
    "an _ assignment _",
    "@xmath43 is a set of person - object pairs @xmath44 such that @xmath45}}$ ] for all @xmath46 . for each person @xmath39 ( likewise , object @xmath47 )",
    ", there is at most one pair @xmath46 .",
    "we call the assignment _ complete _ if it contains @xmath0 pairs .",
    "the goal is to find the complete assignment which minimizes @xmath48 .",
    "let @xmath49 be a set of variables for @xmath39 and @xmath47 in @xmath50 .",
    "for an assignment @xmath43 , we write @xmath51 if @xmath46 , and @xmath52 otherwise .",
    "thus , the problem of determining the optimal assignment can be written as a linear program : @xmath53}}}c_{ij}x_{ij},\\\\    \\text{subject to } & \\quad \\sum_{j\\in { { { \\mathcal{q}}}^{[i]}}}x_{ij } = 1\\quad \\forall    \\ ; i\\in{\\mathcal{i } } , \\\\    & \\quad \\sum_{\\{i|j\\in { { { \\mathcal{q}}}^{[i]}}\\}}x_{ij } = 1\\quad \\forall \\ ; j\\in{\\mathcal{i } } , \\\\    & \\quad x_{ij}\\geq 0.\\end{aligned}\\ ] ] we can not use linear inequalities to write the constraint that @xmath49 s attain only the values zero and one .",
    "however , it turns out , @xcite , that there always exists an optimal solution in which the @xmath49 s satisfy our integer assumption .      here",
    "we review some relevant results on the euclidean traveling salesperson problem ( etsp ) .",
    "let @xmath54 be a set of @xmath0 points in a compact environment @xmath55 , @xmath56 , and let @xmath57 be the set of all point sets @xmath58 with @xmath59 .",
    "let @xmath60 denote the cost of the etsp tour over the point set @xmath54 , i.e. , the length of the shortest closed path through all points in @xmath54 .",
    "an important result , from @xcite , is that given a compact set @xmath61 , there exists a finite constant @xmath62 such that , for all @xmath63 , @xmath64 in fact , we have that in the worst - case setting , the @xmath60 belongs to @xmath65 .    in our application of these results",
    "it will be useful to consider the case where the environment grows with the number of points .",
    "that is , we are interested in environments which are cubes , @xmath7^d$ ] , @xmath56 , where @xmath9 is the side length of the cube . applying a simple scaling argument to the result in , we arrive at the following corollary .",
    "[ thm : tsp_grow ] consider an environment @xmath66^d$ ] , where @xmath56 .",
    "for every point set @xmath63 , @xmath67    the problem of computing an optimal tour is known to be np - complete",
    ". however , there exist heuristics which can be computed efficiently and give a constant factor approximation to the optimal tour .",
    "the best known approximation algorithm is due to christofides @xcite .",
    "the _ christofides algorithm _ computes a tour that is no more than @xmath68 times longer than the optimal .",
    "it runs in time @xmath3 .",
    "another method , known as the _ double - tree algorithm _ , produces tours that are no longer than twice the optimal , in run time @xmath69 .",
    "to describe the target assignment problem formally , consider @xmath0 agents in an environment @xmath70 , @xmath56 .",
    "the environment @xmath71 is compact for each @xmath0 but may grow with the number of agents . for ease of presentation let @xmath72^d$ ] , where @xmath73 ( that is , @xmath61 is a @xmath6-dimensional cube with side length @xmath9 ) .",
    "each agent has a unique identifier ( uid ) taken from the set @xmath74 . for simplicity , we assume that @xmath75",
    ". however , each agent does not know the set of uids being used ( i.e. , agent @xmath0 does not know it has the largest uid ) .",
    "agent @xmath76 has position @xmath77}}\\in{\\mathcal{e}}$ ] .",
    "two agents , @xmath39 and @xmath78 in @xmath79 , are able to communicate if and",
    "only if @xmath80}}- { { { \\mathbf{p}}}^{[k]}}\\| \\leq r$ ] , where @xmath81 is called the communication range . we refer to the graph representing the communication links as the @xmath14-disk graph .",
    "agent @xmath39 s kinematic model is @xmath82 } } = { { \\mathbf{u}}^{[i]}}$ ] , where @xmath83}}$ ] is a velocity control input bounded by @xmath84 .",
    "we assume that the agents move in continuous time and communicate according to a discrete time communication schedule consisting of an increasing sequence of time instants with no accumulation points , @xmath85 .",
    "we assume that @xmath86 , for all @xmath87 , where @xmath88 . at each communication",
    "round , agents can exchange messages of length @xmath13 .",
    "agents , grows with the logarithm of @xmath0 .",
    "] we assume that communication round @xmath78 occurs at time @xmath89 , and that all messages are sent and received instantaneously at @xmath89 .",
    "motion then occurs from @xmath90 until @xmath91 .",
    "it should be noted that in this setup we are emphasizing the time complexity due to the motion of the agents .",
    "let @xmath92 be a set of distinct target locations , @xmath93 for each @xmath94 .",
    "agent @xmath39 is equipped with memory @xmath95}}$ ] , of size @xmath96}}|$ ] . in this memory ,",
    "agent @xmath39 stores a set of target positions , @xmath40}}\\subseteq{\\mathcal{q}}$ ] .",
    "these are the targets to which agent @xmath39 can be assigned .",
    "we let @xmath40}}(0)$ ] denote agent @xmath39 s initial target set .",
    "these positions may be known through gps coordinates , or through a map of the environment .    in this paper",
    "we assume that each agent knows the position of every target .",
    "that is , @xmath97}(0)={\\mathcal{q}}$ ] for each @xmath76 .",
    "we refer to this as the _ full knowledge _ assumption . to store this amount of information",
    "we must assume that the size of each agents memory , @xmath96}}|$ ] , grows linearly with @xmath0 .",
    "our goal is to solve the _ full knowledge target assignment problem _ :    _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ determine a control and communication law for @xmath35 agents , with attributes as described above , satisfying the following requirement .",
    "there exists a time @xmath98 such that for every agent @xmath76 , there is a unique target @xmath99}}(0)$ ] with @xmath77}}(t)= { { { \\mathbf{q}}}_{j_i}}$ ] for all time @xmath100 , where @xmath101 if and only if @xmath102 .",
    "_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _    in the remainder of the paper , we will refer to this as the _ target assignment problem_.    [ rem : consist_knowledge ] a more general assumption on the initial target sets , @xmath97}(0)$ ] , which still ensures the existence of a complete assignment , is the _",
    "consistent knowledge _ assumption : for each @xmath103 , @xmath104}(0)\\right| \\geq    1935 that this is the necessary and sufficient condition for the existence of a complete assignment @xcite .    in the full knowledge assumption , each agent knows the position of all targets in @xmath54 .",
    "these positions will be stored in an array within each agents memory , rather than as an unordered set . to represent this",
    ", we replace the target set @xmath54 with the target @xmath0-tuple @xmath105 , and the local target set @xmath40}}$ ] with the @xmath0-tuple @xmath106}}$ ] .",
    "thus , in the full knowledge assumption , @xmath106}}(0):={\\mathbf{q}}$ ] for each @xmath76 .",
    "( it is possible that the order of the targets in the local sets @xmath106}}$ ] may initially be different .",
    "however , given a set of distinct points in @xmath1 , it is always possible to create a unique ordering . )",
    "in this section we introduce and analyze a class of deterministic algorithms for the target assignment problem .",
    "the initialization , motion , and communication for each algorithm in the _ assignment - based motion_class have the following attributes :    [ [ initialization ] ] initialization + + + + + + + + + + + + + +    in this class of algorithms agent @xmath39 initially selects the closest target in @xmath106}}$ ] , and sets the variable @xmath107}}$ ] ( agent @xmath39 s current target ) , to the index of that target .",
    "[ [ motion ] ] motion + + + + + +    agent @xmath39 moves toward the target @xmath107}}$ ] at speed  @xmath108 : @xmath109 } } = \\begin{cases } v\\frac { { { { \\mathbf{q}}}^{[i ] } } _ { { { { \\textup{curr}}}^{[i]}}}- { { { \\mathbf{p}}}^{[i]}}}{\\| { { { \\mathbf{q}}}^{[i ] } } _ { { { { \\textup{curr}}}^{[i ] } } } - { { { \\mathbf{p}}}^{[i]}}\\| } , & \\text{if}\\ ; { { { \\mathbf{q}}}^{[i ] } } _ { { { { \\textup{curr}}}^{[i ] } } } \\neq { { { \\mathbf{p}}}^{[i ] } } , \\\\ 0 , & \\text{otherwise } , \\end{cases}\\ ] ] where @xmath110 is a constant .    [",
    "[ communication ] ] communication + + + + + + + + + + + + +    as agent @xmath39 communicates with other agents , it updates the tuple @xmath106}}$ ] `` removing '' targets which are assigned to other agents .",
    "if agent @xmath39 must change @xmath107}}$ ] , it selects a new target in @xmath106}}$ ] , that has not been removed .",
    "this is described more formally in the following .      in order to classify the time complexity of the assignment - based motionclass of algorithms",
    ", we introduce a few useful definitions .",
    "we say that agent @xmath76 is _ assigned _ to target @xmath106}}_j$ ] , @xmath94 , when @xmath107}}=j$ ] . in this case , we also say target @xmath47 is assigned to agent @xmath39 .",
    "we say that agent @xmath76 _ enters a conflict _ over the target @xmath107}}$ ] , when agent @xmath39 receives a message , @xmath111}}$ ] , with @xmath107}}= { { { \\textup{curr}}}^{[k]}}$ ] .",
    "agent @xmath39 _ loses the conflict _ if agent @xmath39 is farther from @xmath107}}$ ] than agent @xmath78 , and _ wins the conflict _ if agent @xmath39 is closer to @xmath107}}$ ] than agent @xmath78 , where ties are broken by comparing uids .",
    "now we show that if agent @xmath39 is assigned to the same target as another agent , it will enter a conflict in finite time .",
    "[ lem : com_range ] consider any communication range @xmath112 , and any fixed number of agents @xmath113 .",
    "if , for two agents @xmath39 and @xmath78 , @xmath107}}= { { { \\textup{curr}}}^{[k]}}$ ] at some time @xmath114 , then agent @xmath39 ( and likewise , agent @xmath78 ) will enter a conflict over @xmath107}}$ ] in finite time .",
    "for each @xmath0 the region @xmath61 is compact , and the motion for each agent is given by .",
    "hence , agent @xmath39 will reach @xmath107}}$ ] in no more than @xmath115 time units , as will agent @xmath78 .",
    "the condition @xmath80}}- { { { \\mathbf{p}}}^{[k]}}\\|\\leq    r$ ] will be satisfied within @xmath116 time units . at the next communication round ,",
    "agent @xmath39 will enter a conflict over @xmath107}}$ ] .    with these definitions",
    "we give a lower bound on the time complexity of the task assignment problem when the environment grows with the number of agents .",
    "[ thm : comp_lower ] consider @xmath0 agents , with communication range @xmath5 , in an environment @xmath66^d$ ] , @xmath56 . if @xmath117 , where @xmath118 , then for all algorithms in the assignment - based motionclass , the time complexity of the target assignment problem is in @xmath12 .",
    "we will construct a set of target positions and a set of initial agent positions for which the bound holds .",
    "the environment @xmath61 is the @xmath6-cube , @xmath7^d$ ] .",
    "divide the cube @xmath61 into @xmath119 cubes , each with side length @xmath120 , and place a target at the center of each of the cubes until you run out .",
    "this is shown in fig .",
    "[ fig : grid ] .    .",
    "the lattice is split into 4 blocks , each containing @xmath121 agents .",
    "the center agent of each block is shown along with its communication radius @xmath14 .",
    "the distance between these center agents is lower bounded by @xmath122 . ]",
    "notice that the distance between any two targets is lower bounded by @xmath120 , and that , for sufficiently large @xmath0 , @xmath123 .",
    "next , place agent @xmath124 at @xmath125 , agent 3 at @xmath126 and so on so that @xmath77}}={\\mathbf{q}}_i$ ] , for all @xmath127 . from the initialization ,",
    "we have that @xmath107}}=i$ ] for each @xmath127 .",
    "now , if we place agent 1 in @xmath128 , it will lose a conflict over any of the @xmath129 occupied targets @xmath130 .",
    "thus , the assignment will not be complete until agent 1 reaches target @xmath131 .",
    "since the distance between targets is greater than @xmath14 , communication between agents @xmath39 and @xmath78 is not possible for any @xmath132 .",
    "so , agent @xmath133 will communicate only with agent 1 .",
    "thus , prior to communication with agent 1 , each agent @xmath127 will have @xmath106}}={\\mathbf{q}}$ ] .",
    "the first time agent @xmath134 comes within distance @xmath14 of a target @xmath135 , in the best - case , agent @xmath134 will remove target @xmath47 from @xmath106}}$ ] .",
    "now , for any deterministic method of selecting @xmath107}}$ ] , we can place agent @xmath134 in @xmath128 such that target @xmath131 is the last target for which agent @xmath134 will come within distance @xmath14 .",
    "therefore , agent 1 must come within distance @xmath14 of each of the @xmath129 assigned targets , before finally arriving at @xmath136 .",
    "now we will lower bound the distance traveled by agent 1 . to do this , split the large @xmath6-cube into @xmath137 smaller @xmath6-cubes , or blocks , where each block contains @xmath138 targets .",
    "an example is shown in fig .",
    "[ fig : grid ] .",
    "there is one target at the center of each of these blocks , and agent 1 must come within distance @xmath14 of it .",
    "the distance between the center target of each block is lower bounded by the distance between targets , @xmath139 .",
    "agent @xmath134 must travel this distance at least @xmath140 times .",
    "so we have @xmath141 hence , the path length is in @xmath12 .",
    "since @xmath142 , the time complexity is also in @xmath12 .",
    "we have lower bounded the time complexity when @xmath9 grows faster than some critical value , @xmath143 .",
    "this same type of bound appears in percolation theory and the study of random geometric graphs , where it is referred to as the thermodynamic limit @xcite .",
    "when @xmath144 , congestion issues in both motion and communication become more prevalent , and a more complex communication and motion model would ideally be used .    in the next section",
    "we introduce an asymptotically optimal algorithm in the assignment - based motionclass .",
    "in this section we introduce the etsp assignmentalgorithm  an algorithm within the assignment - based motionclass .",
    "we will show that when @xmath9 grows more quickly than a critical value , this algorithm is asymptotically optimal . the algorithm can be described as follows .    for each @xmath76 , agent",
    "@xmath39 computes a constant factor approximation of the optimal etsp tour of the @xmath0 targets in @xmath106}}$ ] , denoted @xmath145}})$ ] .",
    "we can think of @xmath146 as a map which reorders the indices of @xmath106}}$ ] ; @xmath145 } } ) =( { { { \\mathbf{q}}}^{[i]}}_{\\sigma(1)},\\ldots , { { { \\mathbf{q}}}^{[i]}}_{\\sigma(n)})$ ] , where @xmath147 is a bijection .",
    "notice that this map is independent of @xmath39 since all agents use the same method .",
    "an example is shown in fig .",
    "[ fig : tour ] .    , creating an etsp tour of seven targets . ]",
    "agent @xmath39 then replaces its @xmath0-tuple @xmath106}}$ ] with @xmath145}})$ ] .",
    "next , agent @xmath39 computes the index of the closest target in @xmath106}}$ ] , and calls it @xmath107}}$ ] .",
    "agent @xmath39 also maintains the index of the next target in the tour which may be available , @xmath148}}$ ] , and first target in the tour before @xmath107}}$ ] which may be available , @xmath149}}$ ] .",
    "thus , @xmath148}}$ ] is initialized to @xmath107}}+1 { \\;(\\mathrm{mod}\\;{n})}$ ] and @xmath149}}$ ] to @xmath107}}-1 { \\;(\\mathrm{mod}\\;{n})}$ ] .",
    "this is depicted in fig .",
    "[ fig : tour_i ] .    .",
    "]    in order to `` remove '' assigned targets from the tuple @xmath106}}$ ] , agent @xmath39 also maintains the @xmath0-tuple , @xmath150}}$ ] . letting @xmath150}}(j)$ ]",
    "denote the @xmath47th entry in the @xmath0-tuple , the entries are given by @xmath151}}(j ) = \\begin{cases } 0 , & \\begin{aligned } & \\text{if agent $ i$ knows $ { { { \\mathbf{q}}}^{[i]}}_j$ is assigned } \\\\*[-0.16 cm ] & \\text{to another agent } , \\end{aligned } \\\\ 1 , & \\text{otherwise}. \\end{cases}\\ ] ] thus , @xmath150}}$ ] is initialized as the @xmath0-tuple @xmath152 . the initialization is summarized in table  [ tab : init ] .    at each communication round agent @xmath39 executes the algorithm comm - rddisplayed in table  [ tab : comm ] at the end of the paper .",
    "the following is an informal description .",
    "[ fig : conflict ] gives an example of comm - rdresolving a conflict between agents @xmath39 and @xmath78 , over @xmath107}}= { { { \\textup{curr}}}^{[k]}}$ ] . in this figure ,",
    "all other agents are omitted .",
    "we are now ready to define the algorithm etsp assignmentfor solving the target assignment problem .",
    "the etsp assignmentalgorithm is the triplet consisting of the initialization of each agent ( see table [ tab : init ] ) , the motion law in , and comm - rd(see table [ tab : comm ] ) , which is executed at each communication round .",
    "we will now prove the correctness of etsp assignment .",
    "it should be noted that this result is valid for any communication graph which contains the @xmath14-disk graph as a subgraph . in order to prove correctness ,",
    "let us first present some properties of the algorithm .",
    "[ lem : tsp_props ] during an execution of etsp assignmentthe following statements hold :    1 .",
    "once target @xmath94 , is assigned to some agent , the assignment may change , but target @xmath47 remains assigned for all time .",
    "[ lemit : assigned_invariance ] 2 .",
    "agent @xmath39 is assigned to the target @xmath107}}$ ] which satisfies @xmath150 } } ( { { { { \\textup{curr}}}^{[i]}}})=1 $ ] . [",
    "lemit : current_1 ] 3 .   for agent @xmath39 , @xmath150}}(j)=0 $ ] , for each @xmath153}}+1 , { { { \\textup{prev}}}^{[i]}}+2,\\ldots ,    { { { \\textup{next}}}^{[i]}}-1\\}\\setminus\\ { { { { \\textup{curr}}}^{[i]}}\\ } { \\;(\\mathrm{mod}\\;{n})}$ ] . [ lemit : prev_next_i ] 4 .   for agent @xmath39 , @xmath150}}(j)=0 $ ] only if target @xmath47 is assigned to some agent @xmath154 .",
    "[ lemit:0_only_if ] 5 .   if , for agent @xmath39 , @xmath150}}(j)=0 $ ] at some time @xmath155 , then @xmath150}}(j)=0 $ ] for all @xmath156 .",
    "[ lemit : status_0 ] 6 .",
    "if agent @xmath39 receives @xmath111}}$ ] during a communication round , agent @xmath39 will set @xmath150}}(j)=0 $ ] for each @xmath157}}+1 , \\ldots ,    { { { \\textup{next}}}^{[k]}}-1\\}\\setminus\\ { { { { \\textup{curr}}}^{[i]}}\\}{\\;(\\mathrm{mod}\\;{n})}$ ] . [ lemit : prev_next_k ]    statements [ lemit : current_1 ] and [ lemit : status_0 ] and [ lemit : prev_next_k ]",
    "follow directly from the initialization and the algorithm comm - rd .    to see [ lemit : assigned_invariance ] , consider an agent @xmath39 , who is assigned to target  @xmath47 .",
    "agent @xmath39 s assignment can change only if it loses a conflict over target @xmath47 . in every conflict",
    "there is a winner and the winner remains assigned to target @xmath47 .",
    "statement [ lemit : prev_next_i ] is initially satisfied since @xmath149}}+1= { { { \\textup{curr}}}^{[i]}}= { { { \\textup{next}}}^{[i]}}-1 $ ] implies that @xmath158}}+1 , \\ldots , { { { \\textup{next}}}^{[i]}}-1\\}\\setminus\\ { { { { \\textup{curr}}}^{[i]}}\\}=\\emptyset$ ] .",
    "assume that statement [ lemit : prev_next_i ] is satisfied before the execution of comm - rd .",
    "at the end of comm - rd , @xmath149}}$ ] is updated to the first target before @xmath107}}$ ] in the tour with status available ( ` 1 ' ) .",
    "if @xmath150 } } ( { { { \\textup{curr}}}^{[i]}})=1 $ ] then @xmath107}}$ ] remains unchanged . if @xmath150 } } ( { { { \\textup{curr}}}^{[i]}})=0 $ ] then @xmath107}}$ ] is increased to the first target with status available ( ` 1 ' )",
    "finally , @xmath148}}$ ] is set to the first target after @xmath107}}$ ] which is available .",
    "thus , at the end of comm - rdthe status of @xmath149}}$ ] , @xmath107}}$ ] and @xmath148}}$ ] are available , and @xmath150}}(j)=0 $ ] for each target @xmath153}}+1,\\ldots , { { { \\textup{next}}}^{[i]}}-1\\}\\setminus\\ { { { { \\textup{curr}}}^{[i]}}\\}{\\;(\\mathrm{mod}\\;{n})}$ ] .    statement [ lemit:0_only_if ] is also initially satisfied since @xmath150}}=\\mathbf{1}_n$ ] for each @xmath76 .",
    "assume statement [ lemit:0_only_if ] is satisfied before the execution of comm - rdand that during this communication round agent @xmath39 changes the status of a target @xmath47 to assigned ( ` 0 ' ) .",
    "we will show that statement [ lemit:0_only_if ] is still satisfied upon completion of the execution of comm - rd . in order for @xmath150}}(j)$ ] to be changed , agent @xmath39 must have received a message , @xmath111}}$ ] , for which one of the following cases is satisfied : ( 1 ) target @xmath159}}$ ] lies between @xmath160}}$ ] and @xmath161}}$ ] on the tour ; ( 2 ) there is a conflict between agents @xmath39 and @xmath78 over target @xmath47 which agent @xmath39 loses ; or , ( 3 ) there is a conflict between agents @xmath39 and @xmath78 which agent @xmath39 wins and @xmath148}}=j$ ] or @xmath161}}=j$ ] .    in case",
    "( 1 ) either @xmath162}}(j)=0 $ ] or @xmath163}}=j$ ] , and thus target @xmath47 is assigned . in case",
    "( 2 ) agent @xmath78 won the conflict implying @xmath163}}=j$ ] entering the communication round .",
    "thus after the communication round , @xmath107}}\\neq j$ ] and target @xmath47 is assigned to another agent . in case",
    "( 3 ) , @xmath107}}= { { { \\textup{curr}}}^{[k]}}\\neq j$ ] , and agent @xmath78 loses the conflict . in this case , agent @xmath78 will change @xmath163}}$ ] to the next available target on its tour .",
    "all targets from @xmath160}}+1 $ ] to @xmath161}}-1 $ ] have been assigned .",
    "also , during the communication round , agent @xmath78 will receive @xmath164}}$ ] and determine that all targets from @xmath149}}+1 $ ] to @xmath148}}-1 $ ] are assigned .",
    "thus , the next available target is at least as far along the tour as the farther of @xmath148}}$ ] and @xmath161}}$ ] .",
    "thus , after the communication round , both @xmath148}}$ ] and @xmath161}}$ ] are assigned .    with these properties we are now ready to present the main result of this section .",
    "[ thm : strategy_works ] for any fixed @xmath35 , etsp assignmentsolves the target assignment problem",
    ".    assume by way of contradiction that at some time @xmath165 there are @xmath166 targets unassigned , and for all time @xmath167 , @xmath168 targets remain unassigned .",
    "by lemma [ lem : tsp_props ]  [ lemit : assigned_invariance ] the @xmath169 assigned targets remain assigned for all time , and thus it must be the same @xmath168 targets which remain unassigned for all @xmath170 .",
    "let @xmath171 denote the index set of the @xmath168 unassigned targets . from our assumption , and by lemma",
    "[ lem : tsp_props ]  [ lemit:0_only_if ] , for every @xmath170 and for every @xmath76 , @xmath150}}(j)=1 $ ] for each @xmath172 .",
    "now , among the @xmath169 assigned targets , there is at least one target to which two or more agents are assigned .",
    "consider one such target , call it @xmath173 , and consider an agent @xmath174 with @xmath175}}=j_1 $ ] .",
    "by lemma [ lem : com_range ] , agent @xmath174 will enter a conflict over @xmath173 in finite time .",
    "let us follow the loser of this conflict .",
    "the losing agent , call it @xmath176 , will set @xmath177}}(j_1)=0 $ ] , and will move to the next target in the tour it believes may be available , call it @xmath178 .",
    "now , we know @xmath178 is not in @xmath171 , for if it were @xmath179 targets would be unassigned contradicting our assumption . moreover , by lemma [ lem : tsp_props ]  [ lemit : current_1 ] , @xmath180 .",
    "thus , agent @xmath176 will enter a conflict over @xmath178 in finite time .",
    "after this conflict , the losing agent , call it @xmath181 , will set @xmath182}}(j_2)=0 $ ] ( because it lost the conflict ) , and from lemma [ lem : tsp_props ]  [ lemit : prev_next_k ] , @xmath182}}(j_1)=0 $ ] .",
    "again , agent @xmath181 s next target , @xmath183 must not be in @xmath171 , for if it were we would have a contradiction .",
    "thus , repeating this argument @xmath169 times we have that agent @xmath184 loses a conflict over @xmath185 . after this conflict",
    ", we have @xmath186}}(j_k)=0 $ ] for each @xmath187 , where @xmath188 if and only if @xmath189 .",
    "in other words , agent @xmath184 knows that all @xmath169 assigned targets have indeed been assigned .",
    "also , by our initial assumption , @xmath186}}(j)=1 $ ] for each @xmath172 . by lemma [ lem : tsp_props ]  [ lemit : current_1 ] , agent @xmath184 s new current target must have status available ( ` 1 ' ) .",
    "therefore , it must be that agent @xmath184 will set @xmath190}}$ ] to a target in @xmath171 .",
    "thus , after a finite amount of time , @xmath179 targets are unassigned , a contradiction .",
    "the following remark displays that the etsp assignmentalgorithm does not solve the target assignment under the consistent knowledge assumption .",
    "[ rem : not_consist_knowledge ] consider as in remark  [ rem : consist_knowledge ] the consistent knowledge assumption for each agent s target set . specifically",
    ", consider two agents , 1 and 2 , with initial target sets @xmath191}}(0)=\\{{\\mathbf{q}}_2\\}$ ] , @xmath192}}(0)=\\{{\\mathbf{q}}_1,{\\mathbf{q}}_2\\}$ ] , and any initial positions such that @xmath193}}(0)={\\mathbf{q}}_2 $ ] , we will have @xmath107}}= { { { \\textup{curr}}}^{[j]}}=2 $ ] .",
    "however , agent @xmath124 will win the conflict over target 2 .",
    "thus , agent 1 will set @xmath194}}(2)=0 $ ] , and a complete assignment will not be possible .      in this section we will give an upper bound on the time complexity for etsp assignment .",
    "we will show that when @xmath15 , for some @xmath195 , etsp assignmentis asymptotically optimal among algorithms in the assignment - based motionclass . before doing this ,",
    "let us first comment on the lower bound when the environment grows at a slower rate .    in what follows we show that if an agent arrives and remains at its assigned target for sufficiently long time",
    ", then it stays there for all subsequent times .",
    "[ lem : stop ] consider @xmath0 agents executing etsp assignmentwith communication range @xmath112 and assume the time delay between communication rounds , @xmath196 , satisfies @xmath197 .",
    "if there exists a time @xmath155 and an agent @xmath39 such that @xmath77}}(t)= { { { \\textup{curr}}}^{[i]}}$ ] for all @xmath198 $ ] , then @xmath77}}(t)= { { { \\textup{curr}}}^{[i]}}$ ] for all @xmath199 .",
    "consider agent @xmath39 , who has been at target @xmath107}}$ ] during the entire time interval @xmath200 $ ] . by the definition of @xmath196",
    "there was a communication round at some time @xmath201 .",
    "agent @xmath39 must have won any conflicts it entered during this communication round since we have assumed that @xmath77}}(t_1+t_{max } ) = { { { \\textup{curr}}}^{[i]}}$ ] .",
    "thus every agent @xmath78 within distance @xmath14 of @xmath107}}$ ] will have set @xmath162 } } ( { { { \\textup{curr}}}^{[i]}})=0 $ ] .",
    "after the communication round at @xmath202 , every agent @xmath78 with @xmath163}}= { { { \\textup{curr}}}^{[i]}}$ ] must be a distance greater than @xmath14 from @xmath107}}$ ] . since @xmath203 , any agent @xmath78 that enters a conflict with agent @xmath39 at time @xmath204 , will be at a distance @xmath205}}\\in{]0,r[}$ ] from @xmath107}}$ ] .",
    "agent @xmath78 will lose the conflict since @xmath205 } } > 0= { { { \\textup{dist}}}^{[i]}}$ ] . thus , agent @xmath39 will remain at @xmath107}}$ ] for all @xmath199 .    with this lemma",
    "we are now able to provide an upper bound on the time complexity of our scheme .",
    "[ thm : tight_bound ] consider an environment @xmath66^d$ ] , @xmath56 .",
    "if @xmath197 , then etsp assignmentsolves the target assignment problem with time complexity in @xmath206 . if , in addition , @xmath117 , where @xmath207 , the time complexity is in @xmath208 , and etsp assignmentis asymptotically optimal among algorithms in the assignment - based motionclass .",
    "consider any initial agent positions , @xmath209}}(0),\\ldots , { { p}^{[n]}}(0)$ ] , and any @xmath0-tuple of target positions , @xmath210 . in the worst - case , some agent must travel around its entire etsp tour , losing a conflict at each of the first @xmath129 targets in the tour . by lemma [ lem : stop ] , this agent can spend no more than @xmath196 time units at each of the @xmath129 targets , before losing a conflict .",
    "since each agent s tour is a constant factor approximation of the optimal , the tour length is @xmath211 ( see theorem [ thm : tsp_grow ] ) . the agent will not follow the etsp tour exactly because it will enter a conflict over each of the @xmath129 targets before actually reaching the target . however , the resulting path is no longer than the etsp tour ( since the agent could just follow the etsp tour exactly if that happened to be the shortest path ) .",
    "hence , the time complexity is @xmath212 .",
    "if @xmath213 , with @xmath214 , we can combine this with theorem [ thm : comp_lower ] to get a time complexity in @xmath208 .    notice that when @xmath9 satisfies the bound in theorem [ thm : tight_bound ] , and @xmath215 , the time complexity is in @xmath216",
    "we have given complexity bounds for the case when @xmath14 and @xmath108 are fixed constants , and @xmath9 grows with @xmath0 .",
    "we allow the environment @xmath71 to grow with @xmath0 so that , as more agents are involved in the task , their workspace is larger .",
    "an equivalent setup would be to consider @xmath217 to be fixed , and allow @xmath14 and @xmath108 to vary inversely with the @xmath0 .",
    "that is , we can introduce a set of parameters , @xmath218 , and @xmath219 and @xmath220 such that the time complexity will be the same as for the parameters @xmath14 , @xmath108 , @xmath9 .",
    "[ cor : unit_cube_env ] consider @xmath0 agents in the environment @xmath221^d$ ] , with speed @xmath222 , and communication radius @xmath223 , where @xmath224 , and @xmath118 .",
    "then etsp assignmentsolves the target assignment problem with time complexity in @xmath208 .    scaling the communication radius @xmath14 inversely with the number of agents arises in the study of wireless networks @xcite . in wireless applications",
    "there are interference and media access problems between agents in the network .",
    "since the agents are in a compact environment , the only way to limit this interference is to scale the communication radius inversely with the number of agents .",
    "scaling the agent speed inversely with @xmath0 appears in the study of the vehicle routing problem in @xcite .",
    "the inverse scaling is required to avoid collisions in the presence of traffic congestion .      in our notion of time complexity we have emphasized the complexity due to the motion of the agents . here we will briefly classify the complexity of computation and communication for etsp assignment .",
    "( i ) _ initialization : _ as reviewed in section [ sec : tsp_review ] , we can compute a constant factor approximation etsp tour in time @xmath69 .",
    "this is the most expensive computation and thus the complexity of initialization is in @xmath69 .",
    "( ii ) _ communication complexity per round : _ at each round agent @xmath39 broadcast a message of length @xmath13 , @xmath164}}$ ] , and we consider this to be one unit of communication .",
    "in the worst - case , each agent receives @xmath0 messages , and so , the worst - case communication complexity is in @xmath216 @xcite .",
    "( iii ) _ computation complexity per round : _ for each message received , agent @xmath39 sets @xmath150}}(s)=0 $ ] for @xmath225 from @xmath160}}+1 $ ] to @xmath161}}-1 $ ] . in the worst - case ,",
    "this operation is @xmath216 and must be performed for @xmath0 messages .",
    "this is the dominant computation in comm - rdand thus the worst - case computation complexity in each round is @xmath69 .",
    "it should be noted that in the case when the communication graph is not even connected ( let alone complete as is required to achieve these worst - case bounds ) , the complexity will be considerably lower .",
    "we have simulated etsp assignmentin @xmath226 and @xmath227 . to compute the etsp tour we have used the ` concorde ` tsp solver . a representative simulation for 15 agents in @xmath228 ^ 3\\subset{\\mathbb{r}}^3 $ ] with @xmath229 and @xmath230 is shown in fig .  [ fig : simu3d ] .",
    "the initial configuration shown in fig .",
    "[ fig : initial ] consists of uniformly randomly generated target and agent positions .",
    "it should be noted that the etsp assignmentalgorithm works without any modification when there are @xmath0 agents and @xmath16 targets . if @xmath231 , at completion , @xmath0 targets are assigned and @xmath232 targets are not .",
    "when , @xmath233 , at completion , all @xmath16 targets are assigned , and the @xmath234 unassigned agents come to a stop after losing a conflict at each of the @xmath16 targets .",
    "the complexity bounds are changed as follows .",
    "the lower bound on the assignment - based motionclass in theorem [ thm : comp_lower ] , holds when @xmath235 , and @xmath236 ( notice the @xmath16 instead of @xmath0 ) . the bound becomes @xmath237 . if @xmath238 where @xmath239 , ( i.e. , @xmath235 but they grow at the same rate ) , then the bound becomes @xmath240 .",
    "the upper bound on etsp assignmentholds for any @xmath0 and @xmath16 , and becomes @xmath241 , where @xmath242 .",
    "so our final result would be that if @xmath238 where @xmath239 and when @xmath236 , then etsp assignmentsolves the target assignment problem in @xmath243 .",
    "that is , among all algorithms in the assignment - based motionclass , etsp assignmentis asymptotically optimal .",
    "we have developed the etsp assignmentalgorithm for solving the full knowledge target assignment problem .",
    "we derived worst - case asymptotic bounds on the time complexity , and we showed that among a certain class of algorithms , etsp assignmentis asymptotically optimal .",
    "there are many possible extensions of this work .",
    "we have not given a lower bound on the time complexity of etsp assignmentwhen @xmath144 . also , the problem is unsolved under the more general consistent knowledge assumption .",
    "we would like to extend the etsp assignmentalgorithm to agents with nonholonomic motion constraints .",
    "also , it would be interesting to consider a sensor based version of this problem , where agents acquire target positions through local sensing . finally , to derive asymptotic time bounds , we made some assumptions on the communication structure at each communication round .",
    "an interesting avenue for future study would be to more accurately address the communication issues in robotic networks ."
  ],
  "abstract_text": [
    "<S> we are given an equal number of mobile robotic agents , and distinct target locations . </S>",
    "<S> each agent has simple integrator dynamics , a limited communication range , and knowledge of the position of every target . </S>",
    "<S> we address the problem of designing a distributed algorithm that allows the group of agents to divide the targets among themselves and , simultaneously , leads each agent to reach its unique target . </S>",
    "<S> we do not require connectivity of the communication graph at any time . </S>",
    "<S> we introduce a novel assignment - based algorithm with the following features : initial assignments and robot motions follow a greedy rule , and distributed refinements of the assignment exploit an implicit circular ordering of the targets . </S>",
    "<S> we prove correctness of the algorithm , and give worst - case asymptotic bounds on the time to complete the assignment as the environment grows with the number of agents . </S>",
    "<S> we show that among a certain class of distributed algorithms , our algorithm is asymptotically optimal . </S>",
    "<S> the analysis utilizes results on the euclidean traveling salesperson problem . </S>"
  ]
}