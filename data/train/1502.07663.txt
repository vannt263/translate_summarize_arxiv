{
  "article_text": [
    "data structures for range queries and for predecessor queries are among the most studied data structures in computer science . given an @xmath6 matrix @xmath7 , a _ range maximum _",
    "( also called submatrix maximum ) data structure can report the maximum entry in any query submatrix ( a set of consecutive rows and a set of consecutive columns ) of @xmath7 .",
    "given a set @xmath8 of @xmath9 integers from a polynomial universe @xmath10 , a _",
    "predecessor _ data structure can report the predecessor ( and successor ) in @xmath11 of any query integer @xmath12 . in this paper",
    ", we prove that these two seemingly unrelated problems are in fact equivalent when the matrix @xmath7 is a _ monge _ matrix .    [ [ range - maximum - queries . ] ] * range maximum queries . *",
    "+ + + + + + + + + + + + + + + + + + + + + + + +    a long line of research over the last three decades including  @xcite achieved range maximum data structures of @xmath13 space and @xmath14 query time notation hides polylogarithmic factors in @xmath9 . ] , culminating with the @xmath15-space @xmath16-query data structure of yuan and atallah  @xcite . in general matrices ,",
    "this is optimal since representing the input matrix already requires @xmath17 space .",
    "in fact , reducing the additional space to @xmath18 is known to incur an @xmath19 query - time  @xcite and such tradeoffs can indeed be achieved for any value of @xmath20  @xcite .",
    "however , in many applications , the matrix @xmath7 is not stored explicitly but any entry of @xmath7 can be computed when needed in @xmath16 time .",
    "one such case is when the matrix @xmath7 is sparse , or simply has @xmath21 nonzero entries . in this case",
    "the problem is known in computational geometry as the _ orthogonal range searching _ problem on the @xmath6 grid . in this case as well , various data structures with @xmath22-space and @xmath14-query appear in a long history of results including  @xcite . for",
    "a survey on orthogonal range searching see  @xcite .",
    "another case where the additional space can be made @xmath23 ( and in fact even @xmath1 ) is when the matrix is a monge matrix .",
    "[ [ range - maximum - queries - in - monge - matrices . ] ] * range maximum queries in monge matrices . * + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + +    a matrix @xmath7 is monge if for any pair of rows @xmath24 and columns @xmath25 we have that @xmath26 + m[j,\\ell ] \\ge m[i,\\ell]+ m[j , k]$ ] .",
    "( rather than @xmath27 ) in the condition .",
    "our results apply to both definitions , and to minimum ( rather than maximum ) queries . ]",
    "submatrix maximum queries on monge matrices have various important applications in combinatorial optimization and computational geometry such as problems involving distances in the plane , and in problems on convex @xmath9-gons .",
    "see  @xcite for a survey on monge matrices and their uses in combinatorial optimization .",
    "submatrix maximum queries on monge matrices are used in algorithms that efficiently find the largest empty rectangle containing a query point , in dynamic distance oracles for planar graphs , and in algorithms for maximum flow in planar graphs .",
    "see  @xcite for more details on the history of this problem and its applications .",
    "given an @xmath6 monge matrix @xmath7 it is possible to obtain compact data structures of only @xmath28 space that can answer submatrix maximum queries in @xmath29 time .",
    "the first such data structure was given by kaplan , mozes , nussbaum and sharir  @xcite .",
    "they presented an @xmath30-space data structure with @xmath31 query time .",
    "this was improved in  @xcite to @xmath1 space and @xmath5 query time .",
    "[ [ breakpoints - and - partial - monge - matrices . ] ] * breakpoints and partial monge matrices .",
    "* + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + +    given an @xmath32 monge matrix @xmath7 , let @xmath33 be the row containing the maximum element in the @xmath20-th column of @xmath7 .",
    "it is easy to verify that the @xmath34 values are monotone , i.e. , @xmath35 .",
    "columns @xmath20 such that @xmath36 are called the _",
    "breakpoints _ of @xmath7 .",
    "a monge matrix consisting of @xmath37 rows has @xmath38 breakpoints , which can be found in @xmath1 time using the smawk algorithm  @xcite .",
    "some applications involve _ partial _ monge matrices rather than full monge matrices .",
    "a partial monge matrix is a monge matrix where some of the entries are undefined , but the defined entries in each row and in each column are contiguous .",
    "the total number of breakpoints in a partial monge matrix is still @xmath38  @xcite , and they can be found in @xmath39 time is the inverse - ackerman function . ]",
    "using an algorithm of klawe and kleitman  @xcite .",
    "this was used in  @xcite to extend their solutions to partial monge matrices at the cost of an additional @xmath40 factor to the query time .",
    "factor to the space . ]",
    "[ [ our - results . ] ] * our results . *",
    "+ + + + + + + + + + + + + +    in this paper , we fully resolve the submatrix maximum query problem in @xmath0 monge matrices by presenting a data structure of @xmath1 space and @xmath2 query time .",
    "consequently , we obtain an improved query time for other applications such as finding the largest empty rectangle containing a query point .",
    "we compliment our upper bound with a matching lower bound , showing that @xmath2 query - time is optimal for any data structure of size @xmath3 .",
    "in fact , implicit in our upper and lower bound is an equivalence between the predecessor problem in a universe of polynomial size and the range maximum query problem in monge matrices .",
    "the upper bound essentially reduces a submatrix query to a predecessor problem , and vice versa , the lower bound reduces the predecessor problem to a submatrix query problem .",
    "finally , we extend our result to partial monge matrices with the exact same bounds ( i.e. , @xmath1 space and @xmath2 query time ) .",
    "our result is the first to achieve such extension with no overhead .",
    "[ [ techniques . ] ] * techniques . * + + + + + + + + + + + + +    let @xmath7 be an @xmath6 monge matrix matrices , but for simplicity we sometimes state the results for @xmath6 matrices . ] . consider a full binary tree @xmath41 whose leaves are the rows of @xmath7 .",
    "let @xmath42 be the submatrix of @xmath7 composed of all rows ( i.e. , leaves ) in the subtree of a node @xmath43 in @xmath41 . both existing data structures for submatrix maximum queries  @xcite store , for each node @xmath43 in @xmath41 a data structure @xmath44 .",
    "the goal of @xmath44 is to answer submatrix maximum queries for queries that include an arbitrary interval of columns and _ exactly all rows _ of @xmath42 .",
    "this way , an arbitrary query is covered in  @xcite by querying the @xmath44 structures of @xmath5 canonical nodes of @xmath41 .",
    "an @xmath45 bound is thus inherent for any solution that examines the canonical nodes .",
    "we overcome this obstacle by designing a stronger data structure @xmath44 .",
    "namely , one that supports queries that include an arbitrary interval of columns and _ a prefix of rows _ or _ a suffix of rows _ of @xmath42 .",
    "this way , an arbitrary query can be covered by just two @xmath44s .",
    "the idea behind the new design is to efficiently encode the changes in column maxima as we add rows to @xmath42 one by one . retrieving this information",
    "is done using weighted ancestor search and range maximum queries on trees .",
    "this is a novel use of these techniques .",
    "for our lower bound , we show that for any set of @xmath9 integers @xmath46 there exists an @xmath0 monge matrix @xmath7 such that the predecessor of @xmath47 in @xmath11 can be found with submatrix minimum queries on @xmath7 .",
    "the predecessor lower bound of ptracu and thorup  @xcite then implies that @xmath48 space requires @xmath49 query time .",
    "we overcome two technical difficulty here : first , @xmath7 should be monge .",
    "second , there must be an @xmath3-size representation of @xmath7 which can retrieve any entry @xmath50 $ ] in @xmath16 time .    finally , for handling partial monge matrices , and unlike previous solutions for this case",
    ", we do not directly adapt the solution for the full monge case to partial monge matrices .",
    "instead we decompose the partial monge matrix into many full monge matrices , that can be preprocessed to be queried cumulatively in an efficient way .",
    "this requires significant technical work and careful use of the structure of the decomposition .",
    "[ [ roadmap . ] ] * roadmap .",
    "* + + + + + + + + + +    in section  [ sec : structure ] we present an @xmath30-space data structure for monge matrices that answers submatrix maximum queries in @xmath51 time . in section  [ sec : linear ] we reduce the space to @xmath1 .",
    "our lower bound is given in section  [ sec : lower bound ] , and the extension to partial monge matrices in section  [ sec : partial ] .",
    "our goal in this section is to construct , for a given @xmath32 monge matrix @xmath7 , a data structure of size @xmath52 that answers submatrix maximum queries in @xmath2 time . in section  [ sec : linear ]",
    "we show how to reduce the space from @xmath30 to @xmath1 when @xmath53 .",
    "we will actually show a stronger result , namely the structure allows us to reduce in @xmath16 time a submatrix maximum query into @xmath16 predecessor queries on a set consisting of @xmath9 integers from a polynomial universe .",
    "we denote by @xmath54 the complexity of a predecessor query on a set of @xmath55 integers from a universe @xmath56 .",
    "it is well known that there are @xmath38 data structures achieving @xmath57 .",
    "recall that a submatrix maximum query returns the maximum @xmath50 $ ] over all @xmath58 $ ] and @xmath59 $ ] for a given @xmath60 and @xmath61 .",
    "we start by answering the easier _ subcolumn maximum queries _ within these space and time bounds .",
    "that is , finding the maximum @xmath50 $ ] over all @xmath58 $ ] for a given @xmath60 and @xmath62 .",
    "we construct a full binary tree @xmath41 over the rows of @xmath7 .",
    "every leaf of the tree corresponds to a single row of @xmath7 , and every inner node corresponds to the range of rows in its subtree . to find the maximum @xmath50 $ ] over all @xmath58 $ ] for a given @xmath60 and @xmath62",
    ", we first locate the lowest common ancestor ( lca ) @xmath43 of the leaves corresponding to @xmath63 and @xmath64 in the tree .",
    "then we decompose the query into two parts : one fully within the range of rows @xmath65 of the left child of @xmath43 , and one fully within the range of rows @xmath66 of the right child of @xmath43 .",
    "the former ends at the last row of @xmath65 and the latter starts at the first row of @xmath66 .",
    "we equip every node with two data structures allowing us to answer such simpler subcolumn maximum queries . because of symmetry ( if @xmath7 is monge , so is @xmath67 , where @xmath68=m[n+1-i , n+1-j]$ ] ) it is enough to show how to answer subcolumn maximum queries starting at the first row .",
    "[ lem : subcolumn ] given an @xmath32 monge matrix @xmath7 , a data structure of size @xmath38 can be constructed in @xmath52 time to answer in @xmath69 time subcolumn maximum queries starting at the first row of @xmath7 .",
    "consider queries spanning an _ entire _ column @xmath20 of @xmath7 .",
    "to answer such a query , we only need to find the corresponding @xmath33 . if we store the breakpoints of @xmath7 in a predecessor structure , where every breakpoint @xmath20 links to its corresponding value of @xmath33 , a query can be answered with a single predecessor search .",
    "more precisely , to determine the maximum in the @xmath20-th column of @xmath7 , we locate the largest breakpoint @xmath70 , and then set @xmath71 .",
    "hence we can construct a data structure of size @xmath38 to answer _ entire column _",
    "maximum queries in @xmath69 time .",
    "let @xmath72 be a monge matrix consisting of the first @xmath73 rows of @xmath7 . by applying the above reasoning to every @xmath72 separately",
    ", we immediately get a structure of size @xmath74 answering subcolumn maximum queries starting at the first row of @xmath7 in @xmath69 time .",
    "we want to improve on this by utilizing the dependency of the structures constructed for different @xmath73 s .",
    "namely it can be observed that the list of breakpoints of @xmath75 is a prefix of the list of breakpoints of @xmath72 to which we append at most one new element . in other words , if the breakpoints of @xmath76 are stored on a stack , we need to pop zero or more elements and push at most one new element to represent the breakpoints of @xmath75 .",
    "consequently , instead of storing a separate list for every @xmath72 , we can succinctly describe the content of all stacks with a single tree @xmath77 on at most @xmath78 nodes . for every @xmath73",
    ", we store a pointer to a node @xmath79 , such that the ancestors of @xmath80 ( except for the root ) are exactly the breakpoints of @xmath72 .",
    "whenever we pop an element from the current stack , we move to the parent of the current node , and whenever we push an element , we create a new node and make it a child of the current node .",
    "initially , the tree consists of just the root .",
    "every node is labelled with a column number and by construction these numbers are strictly increasing on any path starting at the root ( the root is labelled with @xmath81 ) .",
    "therefore , a predecessor search for @xmath62 among the breakpoints of @xmath72 reduces to finding the leafmost ancestor of @xmath80 whose label is at most @xmath62 .",
    "this is known as the _ weighted ancestor _ problem .",
    "weighted ancestor queries on a tree of size @xmath38 are equivalent to predecessor searching on a number of sets of @xmath38 total size  @xcite to the query time , but this can be avoided .",
    "] , achieving the claimed space and query time bounds .",
    "to finish the proof , we need to bound the construction time .",
    "the bottleneck is constructing the tree @xmath77 .",
    "let @xmath82 for some @xmath83 be the breakpoints of @xmath72 .",
    "as long as @xmath84\\geq m[r(c_{k}),c_{k}]$ ] we decrease @xmath85 by one , i.e. , remove the last breakpoint .",
    "this process is repeated @xmath38 times in total . if @xmath86 we create a new breakpoint @xmath87 .",
    "if @xmath88 and @xmath84 < m[r(c_{k}),c_{k}]$ ] , we check if @xmath89 \\geq m[r(c_{k}),n]$ ] .",
    "if so , we need to create a new breakpoint . to this end",
    ", we need to find the smallest @xmath62 such that @xmath90 \\geq m[r(c_{k}),j]$ ] .",
    "this can be done in @xmath5 using binary search .",
    "consequently , @xmath77 can be constructed in @xmath52 time .",
    "then augmenting it with a weighted ancestor structure takes @xmath38 time .",
    "we apply lemma  [ lem : subcolumn ] twice to every node of the full version tree @xmath41 . once for subcolumn maximum queries starting at the first row and once for queries ending at the last row .",
    "since the total size of all structures at the same level of the tree is @xmath38 , the total size of our subcolumn maximum data structure becomes @xmath91 , and it can be constructed in @xmath92 time to answer queries in @xmath69 time .",
    "hence we have proved the following .",
    "[ thm : subcolumn ] given an @xmath32 monge matrix @xmath7 , a data structure of size @xmath91 can be constructed in @xmath92 time to answer subcolumn maximum queries in @xmath69 time .    by symmetry (",
    "a transpose of a monge matrix is monge ) we can answer subrow maximum queries ( where the query is a single row and a range of columns ) in @xmath93 time .",
    "we are now ready to tackle general submatrix maximum queries .    at a high level ,",
    "the idea is identical to the one used for subcolumn maximum queries : we construct a  full binary tree @xmath41 over the rows of @xmath7 , where every node corresponds to a range of rows . to find maximum @xmath50 $ ] over all",
    "@xmath58 $ ] and @xmath59 $ ] for a given @xmath60 and @xmath94 , we locate the lowest common ancestor of the leaves corresponding to @xmath63 and @xmath64 and decompose the query into two parts , the former ending at the last row of @xmath65 and the latter starting at the first row of @xmath66 .",
    "every node is equipped with two data structures allowing us to answer submatrix maximum queries starting at the first row or ending at the last row .",
    "as before , it is enough to show how to answer submatrix maximum queries starting at the first row .",
    "[ lem : submatrix ] given an @xmath32 monge matrix @xmath7 , and a data structure that answers subrow maximum queries on @xmath7 in @xmath93 time , one can construct in @xmath91 time a data structure consuming @xmath38 additional space , that answers submatrix maximum queries starting at the first row of @xmath7 in @xmath95 time .",
    "we extend the proof of lemma  [ lem : subcolumn ] .",
    "let @xmath96 be the breakpoints of @xmath7 stored in a predecessor structure .",
    "for every @xmath97 we precompute and store the value @xmath98.\\ ] ] these values are augmented with a ( one dimensional ) range maximum query data structure . to begin with ,",
    "consider a submatrix maximum query starting at the first row of @xmath7 and ending at the last row of @xmath7 , i.e. , we need to calculate the maximum @xmath50 $ ] over all @xmath99 $ ] and @xmath59 $ ] .",
    "we find in @xmath69 the successor of @xmath100 , denoted @xmath101 , and the predecessor of @xmath102 , denoted @xmath103 .",
    "there are three possibilities :    1 .",
    "the maximum is reached for @xmath104 , 2 .",
    "the maximum is reached for @xmath105 , 3 .",
    "the maximum is reached for @xmath106 .",
    "the first and the third possibilities can be calculated with subrow maximum queries in @xmath93 , because both ranges span an interval of columns and a single row .",
    "the second possibility can be calculated with a range maximum query on the range @xmath107 $ ] .",
    "consequently , we can construct a data structure of size @xmath38 to answer such submatrix maximum queries in @xmath95 time .",
    "the above solution can be generalized to queries that start at the first row of @xmath7 but do not necessarily end at the last row of @xmath7 .",
    "this is done by considering the monge matrices @xmath72 consisting of the first @xmath73 rows of @xmath7 . for every such matrix ,",
    "we need a predecessor structure storing all of its breakpoints , and additionally a range maximum structure over their associated values . hence now we need to construct a similar tree @xmath77 as in lemma  [ lem : subcolumn ] on @xmath38 nodes , but now every node has both a weight and a value .",
    "the weight of a node is the column number of the corresponding breakpoint @xmath108 , and the value is its @xmath109 ( or undefined if @xmath110 ) . as in lemma",
    "[ lem : subcolumn ] , the breakpoints of @xmath72 are exactly the ancestors of the node @xmath80 . note that every @xmath109 is defined in terms of @xmath111 and @xmath108 , but this is not a problem because the predecessor of a breakpoint does not change during the whole construction . we maintain a weighted ancestor structure using the weights ( in order to find @xmath101 and @xmath103 in @xmath69 time ) , and a _ generalized range maximum structure _ using the values .",
    "a generalized range maximum structure of a tree @xmath77 , given two query nodes @xmath43 and @xmath112 , returns the maximum value on the unique @xmath43-to-@xmath112 path in @xmath77 .",
    "it can be implemented in @xmath38 space and @xmath16 query time after @xmath91 preprocessing  @xcite once we have the values .",
    "the values can be computed with subrow maximum queries in @xmath113 total time .    by applying lemma  [ lem : submatrix ] twice to every node of the full binary tree @xmath41",
    ", we construct in @xmath114 time a data structure of size @xmath91 to answer submatrix maximum queries in @xmath95 time . in order to apply lemma  [ lem : submatrix ] to a node of @xmath41 we need a subrow maximum query data structure for the corresponding rows of the matrix @xmath7 .",
    "note , however , that a single subrow maximum query data structure for @xmath7 can be used for all nodes of @xmath41 .",
    "[ thm : submatrix ] given an @xmath32 monge matrix @xmath7 , and a data structure answering subrow maximum queries on @xmath7 in @xmath93 time , one can construct in @xmath114 time a data structure taking @xmath115 additional space , that answers submatrix maximum queries on @xmath7 in @xmath95 time .    by combining theorem  [ thm : subcolumn ] with theorem  [ thm : submatrix ] , given an @xmath0 monge matrix @xmath7 , a data structure of size @xmath30",
    "can be constructed in @xmath116 time to answer submatrix maximum queries in @xmath117 time .",
    "in this section we show how to decrease the space of the data structure presented in section  [ sec : structure ] to be linear .",
    "we extend the idea developed in our previous paper  @xcite .",
    "the previous linear space solution was based on partitioning the matrix @xmath7 into @xmath118 matrices @xmath119 , where each @xmath72 is a _ slice _ of @xmath7 consisting of @xmath120 consecutive rows . then , instead of working with the matrix @xmath7 , we worked with the @xmath121 matrix @xmath67 , where @xmath68 $ ] is the maximum entry in the @xmath62-th column of @xmath72 .",
    "[ [ subcolumn - queries . ] ] * subcolumn queries .",
    "* + + + + + + + + + + + + + + + + + + + +    consider a subcolumn query .",
    "suppose the query is entirely contained in some @xmath72 .",
    "this means it spans less than @xmath120 rows . in  @xcite , since the desired query time was @xmath5 , a query simply inspected all elements of the subcolumn . in our case however , since the desired query time is only @xmath51 , we apply the above partitioning scheme twice .",
    "we explain this now .",
    "we start with the following lemma , that provides an efficient data structure for queries consisting of a single column and _ all _ rows in rectangular matrices .",
    "the statement of the lemma was taken almost verbatim from the previous solution  @xcite .",
    "its query time was originally stated in terms of query to a predecessor structure , but here we prefer to directly plug in the bounds implied by atomic heaps  @xcite ( which support predecessor searches in constant time provided @xmath47 is @xmath5 ) .",
    "this requires only an additional @xmath1 time and space preprocessing .",
    "[ lem : micro ] given an @xmath122 monge matrix , a data structure of size @xmath123 can be constructed in @xmath124 time to answer entire - column maximum queries in @xmath16 time , if @xmath125 .",
    "our new subcolumn data structure is summarized in the following theorem .",
    "it uses the above lemma and two applications of the partitioning scheme .",
    "[ thm : subcolumn2 ] given an @xmath32 monge matrix @xmath7 , a data structure of size @xmath38 can be constructed in @xmath52 time to answer subcolumn maximum queries in @xmath126 time .",
    "we first partition @xmath7 into @xmath118 matrices @xmath119 , where @xmath127 .",
    "every @xmath72 is a slice of @xmath7 consisting of @xmath47 consecutive rows .",
    "next , we partition every @xmath72 into @xmath128 matrices @xmath129 , where @xmath130 .",
    "every @xmath131 is a slice of @xmath72 consisting of @xmath132 consecutive rows ( without loss of generality , assume that @xmath47 divides @xmath55 and @xmath132 divides @xmath47 ) .",
    "now we define a new @xmath133 matrix @xmath67 , where @xmath68 $ ] is the maximum entry in the @xmath62-th column of @xmath72 .",
    "similarly , for every @xmath72 we define a new @xmath134 matrix @xmath135 , where @xmath136 $ ] is the maximum entry in the @xmath85-th column of @xmath131 .",
    "we apply lemma  [ lem : micro ] on every @xmath72 and @xmath131 in @xmath52 total time and @xmath38 total space , so that any @xmath68 $ ] or @xmath136 $ ] can be retrieved @xmath16 time .",
    "furthermore , it can be easily verified that @xmath67 and all @xmath135s are also monge . to prove this ,",
    "it is enough to argue that if @xmath137 is an @xmath138 monge matrix , the @xmath139 matrix @xmath140 created by partitioning @xmath137 into two slices consisting of two rows and computing the maximum in every column of every slice is also monge . to this end",
    ", we need to compare : @xmath141+n'[2,2]=\\max(n[1,1],n[2,1])+\\max(n[3,2],n[4,2])\\ ] ] and @xmath142+n'[2,1]=\\max(n[3,1],n[4,1])+\\max(n[1,2],n[2,1]).\\ ] ] let @xmath143,n[2,2])=n[i,2]$ ] , where @xmath144 , and similarly @xmath145,n[4,1])=n[i',1]$ ] , where @xmath146",
    ". then @xmath147+n'[2,2 ] ) - ( n'[1,2]+n'[2,1 ] )   \\geq ( n[i',1 ] + n[i,2 ] ) - ( n[i',1]+n[i,2])\\ ] ] which is at least @xmath148 because of @xmath137 being monge .",
    "therefore , because @xmath67 and all @xmath135 are all monge , and by lemma  [ lem : micro ] their entries can be accessed in @xmath16 time , we can apply theorem  [ thm : subcolumn ] on @xmath67 and every @xmath135 .",
    "the total construction time is @xmath149 , and the total size of all structures constructed so far is @xmath150 .    now consider a subcolumn maximum query .",
    "if the range of rows is fully within a single @xmath131 , the query can be answered naively in @xmath151 time . otherwise ,",
    "if the range of rows is fully within a single @xmath72 , the query can be decomposed into a prefix fully within some @xmath131 , an infix corresponding to a range of rows in @xmath135 , and a suffix fully within some @xmath152 .",
    "the maximum in the prefix and the suffix can be computed naively in @xmath151 time , and the maximum in the infix can be computed in @xmath2 using the structure constructed for @xmath135 .",
    "finally , if the range of rows starts inside some @xmath72 and ends inside another @xmath153 , the query can be decomposed into two queries fully within @xmath72 and @xmath153 , respectively , which can be processed in @xmath2 time as explained before , and an infix corresponding to a range of rows of @xmath67 .",
    "the maximum in the infix can be computed in @xmath2 time using the structure constructed for @xmath67 .",
    "[ [ submatrix - queries . ] ] * submatrix queries .",
    "* + + + + + + + + + + + + + + + + + + + +    we are ready to present the final version of our data structure .",
    "it is based on two applications of the partitioning scheme , and an additional trick of transposing the matrix .",
    "[ thm : submatrix2 ] given an @xmath0 monge matrix @xmath7 , a data structure of size @xmath1 can be constructed in @xmath30 time to answer submatrix maximum queries in @xmath2 time .",
    "we partition @xmath7 as described in the proof of theorem  [ thm : subcolumn2 ] , i.e. , @xmath7 is partitioned into @xmath118 matrices @xmath119 , where @xmath120 , and every @xmath72 is then partitioned into @xmath128 matrices @xmath129 , where @xmath154 .",
    "then we define smaller monge matrices @xmath67 and @xmath135 , and provide @xmath16 time access to their entries with lemma  [ lem : micro ] .",
    "we apply theorem  [ thm : subcolumn2 ] to the transpose of @xmath67 to get a subrow maximum query data structure for @xmath67 .",
    "this takes @xmath1 space and @xmath30 time . with this data structure",
    "we can apply theorem  [ thm : submatrix ] on @xmath67 , which takes an additional @xmath155 space and @xmath156 time .",
    "we would have liked to apply theorem  [ thm : subcolumn2 ] to the transpose of all @xmath135 as well , but this would require @xmath1 space for each matrix , which we can not afford . since we do not have subrow maximum query data structure for the @xmath157s , we can not apply theorem  [ thm : submatrix ] to them directly .",
    "however , note that the subrow maximum query data structure is used in theorem  [ thm : submatrix ] in two ways ( see the proof of lemma  [ lem : submatrix ] ) .",
    "the first use is in directly finding the subrow maximum in cases 1 and 3 in the proof of lemma  [ lem : submatrix ] . in the absence of the subrow structure",
    ", we can still report the two rows containing the candidate maximum , although not the maximum itself .",
    "the second use is in computing the values for the generalized range maximum structure required to handle case 2 in that proof . in this case",
    ", we do not really need the fast query of the data structure of theorem  [ thm : subcolumn2 ] , and can use instead the slower linear space data structure from  ( * ? ? ?",
    "* lemma 2 ) to compute the values in @xmath156 time .",
    "thus , we can apply theorem  [ thm : submatrix ] to each @xmath157 , and get at most two candidate rows of @xmath157 ( from cases 1 and 3 ) , and one candidate entry of @xmath157 ( from case 2 ) , with the guarantee that the submatrix maximum is among these candidates .",
    "we repeat the above preprocessing on the transpose of @xmath7 .",
    "now consider a submatrix maximum query .",
    "if the range of rows starts inside some @xmath72 and ends inside another @xmath153 , the query can be decomposed into two queries fully within @xmath72 and @xmath153 , respectively , and an infix corresponding to a range of rows of @xmath67 .",
    "the maximum in the infix can be computed in @xmath2 time using the structure constructed for @xmath67 .",
    "consequently , it is enough to show how to answer a query in @xmath2 time when the range of rows is fully within a single @xmath72 .",
    "in such case , if the range of rows starts inside some @xmath131 and ends inside another @xmath152 , the query can be decomposed into a prefix fully within @xmath131 , an infix corresponding to a range of rows in @xmath135 and a suffix fully within some @xmath152 . as we explained above , even though we can not locate the maximum in the infix exactly , we can isolate at most @xmath158 rows ( plus a single entry ) of @xmath135 , such that the maximum lies in one of these rows .",
    "each row of @xmath135 corresponds to a range of rows fully inside some @xmath131 .",
    "consequently , we reduced the query in @xmath2 time to a constant number of queries such that the range of rows in each query is fully within a single @xmath131 .",
    "since each @xmath131 consists of @xmath2 rows of @xmath7 , we have identified , in @xmath2 time , a set of @xmath2 rows of @xmath7 that contain the desired submatrix maximum .",
    "now we repeat the same procedure on the transpose of @xmath7 to identify a set of @xmath2 columns of @xmath7 that contain the desired submatrix maximum .",
    "since a submatrix of a monge matrix is also monge , the submatrix of @xmath7 corresponding to these sets of candidate rows and columns is an @xmath159 monge matrix . by running the smawk algorithm  @xcite in @xmath2 time on this small monge matrix",
    ", we can finally determine the answer .",
    "a predecessor structure stores a set of @xmath9 integers @xmath8 , so that given @xmath47 we can determine the largest @xmath160 such that @xmath161 . as shown by ptracu and thorup  @xcite , for @xmath162",
    "any predecessor structure consisting of @xmath48 words needs @xmath49 time to answer queries , assuming that the word size is @xmath163 .",
    "we will use their result to prove that our structure is in fact optimal .    given a set of @xmath9 integers",
    "@xmath46 we want to construct @xmath0 monge matrix @xmath7 such that the predecessor of any @xmath47 in @xmath11 can be found using one submatrix minimum query on @xmath7 and @xmath16 additional time ( to decide which query to ask and then return the final answer ) .",
    "then , assuming that for any @xmath0 monge matrix there exists a data structure of size @xmath3 answering submatrix minimum queries in @xmath164 time , we can construct a predecessor structure of size @xmath3 answering queries in @xmath164 time , which is not possible .",
    "the technical difficulty here is twofolds .",
    "first , @xmath7 should be monge .",
    "second , we are working in the indexing model , i.e. , the data structure for submatrix minimum queries can access the matrix . therefore , for the lower bound to carry over , @xmath7 should have the following property : there is a data structure of size @xmath3 which retrieves any @xmath50 $ ] in @xmath16 time .",
    "guaranteeing that both properties hold simultaneously is not trivial .",
    "before we proceed , let us comment on the condition @xmath46 .",
    "while quadratic universe is enough to invoke the @xmath49 lower bound for structures of size @xmath3 , our reduction actually implies that even for larger polynomially bounded universes , i.e. , @xmath165 , for any fixed @xmath20 , it is possible to construct @xmath0 monge matrix @xmath7 such that the predecessor of @xmath47 in @xmath11 can be found with @xmath16 submatrix minimum queries on @xmath7 and @xmath16 additional time ( and , as previously , any @xmath50 $ ] can be retrieved in @xmath16 time with a structure of size @xmath1 ) .",
    "this is a consequence of the following lemma .",
    "[ lem : universe reduction ] for any @xmath20 , predecessor queries on a set of @xmath9 integers @xmath165 can be reduced in @xmath16 time to @xmath16 predecessor queries on a set of @xmath9 integers @xmath166 with a structure of size @xmath1 .",
    "we explain the reduction for @xmath167 .",
    "larger @xmath20 are processed similarly .",
    "let @xmath168 .",
    "we represent every @xmath169 in base @xmath170 as @xmath171 , where @xmath172 .",
    "we create a new set @xmath173 storing all @xmath174s and @xmath175s .",
    "let @xmath176 denotes the rank of @xmath47 in @xmath177 .",
    "we create another set @xmath178 storing elements of the form @xmath179 .",
    "it can be seen that finding the predecessor of @xmath47 in @xmath11 can be solved by first representing @xmath180 , computing @xmath181 and @xmath182 , and finally locating the predecessor of @xmath183 in @xmath184 .",
    "consequently , a predecessor query on @xmath11 can be reduced into two predecessor queries on @xmath177 and @xmath184 , respectively . @xmath177 and @xmath184 can be combined into a single set @xmath185 , such that predecessor queries in either of them can be answered with predecessor queries on @xmath186 , by simply shifting every element of @xmath184 by @xmath170 .",
    "finally , the size of @xmath186 , which is up to @xmath187 right now , can be reduced to @xmath9 by storing every third element .",
    "knowing the predecessor of @xmath47 among these chosen elements allows us to find the true predecessor in @xmath16 time by inspecting at most three elements stored explicitly for every element of the reduced @xmath186 .",
    "the following propositions are easy to verify :    [ prop : adjacent condition ] a matrix @xmath7 is monge iff @xmath50+m[i+1,j+1 ] \\le m[i+1,j]+m[i , j+1]$ ] for all @xmath188 such that all these entries are defined .",
    "[ prop : adjustment ] if a matrix @xmath7 is monge , then for any vector @xmath189 the matrix @xmath67 , where @xmath68=m[i , j]+h[j]$ ] for all @xmath188 , is also monge .",
    "[ thm : reduction ] for any set of @xmath9 integers @xmath46 , there exists a data structure of size @xmath1 returning any @xmath50 $ ] in @xmath16 time , where @xmath7 is a monge matrix such that the predecessor of @xmath47 can be found using @xmath16 time and one submatrix minimum query on @xmath7 .",
    "we partition the universe @xmath190 into @xmath9 parts @xmath191 .",
    "the @xmath73-th part @xmath192 defines a monge matrix @xmath72 consisting of @xmath193 rows and @xmath9 columns .",
    "the idea is to encode the predecessor of @xmath194 by the minimum element in the @xmath195-th column of @xmath196 .",
    "we first describe how these matrices are defined , and then show how to stack them together .",
    "consider any @xmath197 .",
    "every element in @xmath198 has a unique corresponding row in @xmath76 .",
    "let @xmath199 , so that @xmath200 and @xmath201 for all @xmath62 , and also define @xmath202 .",
    "we describe an incremental construction of @xmath76 . for technical reasons , we start with an artificial top row containing @xmath203",
    ". then we add the rows corresponding to @xmath204 .",
    "the row corresponding to @xmath205 consists of three parts .",
    "the middle part starts at the @xmath206-th column , ends at the @xmath207-th column , and contains only @xmath208 s .",
    "the elements in the left part decrease by @xmath208 and end with @xmath158 at the @xmath209-th column , similarly the elements in the right part ( if any ) start with @xmath158 at the @xmath210-th column and increase by @xmath208 .",
    "formally , the @xmath85-th element of the @xmath211-th row , denoted @xmath212 $ ] , is defined as follows .",
    "@xmath213=\\begin{cases } a'_{j}-k+2 & \\mbox { if } k\\in [ 1,a'_{j } ] \\\\ 1 & \\mbox { if } k\\in [ a'_{j}+1,a'_{j+1 } ] \\\\ k - a'_{j+1}+1 & \\mbox { if } k\\in [ a'_{j+1}+1,n ] \\end{cases}\\end{aligned}\\ ] ]    finally , we end with an artificial bottom row containing @xmath214 .",
    "see the upper part of figure  [ fig : reduction ] for an example . we need to argue that every @xmath72 is monge . by proposition",
    "[ prop : adjacent condition ] , it is enough to consider every pair of adjacent rows @xmath215 there .",
    "define @xmath216=r_{1}[j]-r_{1}[j-1]$ ] and similarly @xmath217=r_{2}[j]-r_{2}[j-1]$ ] . to prove that @xmath72 is monge , it is enough to argue that @xmath217\\geq r'_{1}[j]$ ] for all @xmath218 . by construction ,",
    "both @xmath219 and @xmath220 are of the form @xmath221 , and all @xmath148 s in @xmath220 are on the right of all @xmath148 s in @xmath219 .",
    "therefore , @xmath72 is monge .",
    "now one can observe that the predecessor of @xmath194 can be found by looking at the @xmath195-th column of @xmath196 .",
    "we check if @xmath222 , and if so return the predecessor of @xmath223 in the whole @xmath11 .",
    "this can be done in @xmath16 time and @xmath1 additional space by explicitly storing @xmath223 and its predecessor for every @xmath73 .",
    "otherwise we know that the predecessor of @xmath47 is @xmath224 such that @xmath225 , and , by construction , we only need to find @xmath226 $ ] such that the @xmath195-th element of row @xmath227 in @xmath72 is @xmath208 .",
    "this is exactly a subcolumn minimum query .",
    "we can not simply concatenate all @xmath72 s to form a larger monge matrix .",
    "we use proposition  [ prop : adjustment ] instead .",
    "initially , we set @xmath228",
    ". then we consider every other @xmath72 one - by - one maintaining invariant that the current @xmath7 is monge and its last row is @xmath214 . in every step",
    "we add the vector @xmath229 $ ] to the current matrix @xmath7 , obtaining a matrix @xmath67 whose last row is @xmath230 . by proposition",
    "[ prop : adjustment ] , @xmath67 is monge",
    ". then we can construct the new @xmath7 by appending @xmath72 without its first row to @xmath67 . because the first row of @xmath72 is also @xmath230 ,",
    "the new @xmath7 is also monge .",
    "furthermore , because we add the same value to all elements in the same column of @xmath72 , answering subcolumn minimum queries on @xmath72 can be done with subcolumn minimum queries on the final @xmath7 .",
    "the lower part of figure  [ fig : reduction ] depicts the final monge matrix @xmath7 .",
    "we need to argue that elements of @xmath7 can be accessed in @xmath16 using a data structure of size @xmath16 . to retrieve @xmath231 $ ] ,",
    "first we lookup in @xmath16 time the appropriate @xmath72 from which it originates .",
    "this can be preprocessed and stored for every @xmath62 in @xmath1 total space and allows us to reduce the question to retrieving @xmath232 $ ] .",
    "because proposition  [ prop : adjustment ] is applied exactly @xmath233 times after appending @xmath72 to the current @xmath7 , then we can return @xmath232+(n-1-i)h[k]$ ] . to find @xmath232 $ ]",
    ", we just directly use equation  [ eqn : m_i ] , which requires only storing @xmath234 in @xmath1 total space .    @xmath235\\ ] ] @xmath236\\ ] ] @xmath237\\ ] ] @xmath238\\ ] ] @xmath239\\ ] ] @xmath240\\ ] ] @xmath241\\ ] ] @xmath242\\ ] ]    @xmath243\\ ] ]",
    "our goal in this section is to extend the solution described in section  [ sec : linear ] to _ partial _ monge matrices . recall that in a partial monge matrix @xmath7 , for any @xmath24 and @xmath244 , the condition @xmath26+m[j,\\ell ] \\ge m[i,\\ell]+m[j , k]$ ] holds only if all @xmath26,m[j,\\ell],m[i,\\ell],m[j , k]$ ] are defined",
    "not all entries in @xmath7 are defined , but the defined entries in every row and every column are contiguous .",
    "let @xmath245 and @xmath246 denote the first and last columns containing defined entries in the @xmath73th row respectively .",
    "we assume that we know the coordinates of at least one of the defined entries .",
    "this allows us to find all @xmath245 s and @xmath246 s in @xmath30 time .",
    "we begin with noting that subcolumn ( and subrow ) maximum queries can be implemented on partial monge matrices in the same bounds as full monge matrices ( i.e. , the bounds of theorem  [ thm : subcolumn2 ] and lemma  [ lem : micro ] also apply to partial monge matrices ) .",
    "this is because we can implicitly fill appropriate constants instead of the undefined entries to turn a partial monge matrix into a full monge matrix ( see  @xcite for details ) . upon subcolumn query ( a column @xmath20 and a range of rows @xmath247 )",
    "we first restrict @xmath247 to the defined entries in the column @xmath20 and only then query the data structure . for submatrix queries",
    "however , this trick only works if the query range is entirely defined . in general , it does not work because the defined entries in the query range do not necessarily form a submatrix .",
    "handling submatrix queries is therefore more complicated .",
    "we describe our solution next .",
    "[ lem : dominancemaximum ] a collection @xmath11 of @xmath1 weighted points on an @xmath0 grid can be preprocessed in @xmath248 time and @xmath1 space , so that , given any @xmath249 , the maximum weight of a point @xmath250 such that @xmath251 and @xmath252 can be calculated in @xmath2 time .",
    "we use the standard geometric idea of sweeping the grid with a horizontal line while maintaining a data structure describing the current situation .",
    "the data structure is made partially persistent , so that after sweeping given a query @xmath249 we can retrieve the version of the structure corresponding to a horizontal line passing through @xmath249 .",
    "querying that version of the data structure will allow us to answer the request .",
    "the data structure will be a predecessor structure made persistent using the result of chan  @xcite .",
    "see theorem 5 of  @xcite for a more detailed description of a similar lemma .",
    "denote the points by @xmath253 and their corresponding weights by @xmath254 .",
    "we assume that the weight are distinct .",
    "we sweep the grid with a horizontal line starting at @xmath255 .",
    "the predecessor structure stores @xmath47-coordinates of some of the already seen points .",
    "@xmath169 is stored in the predecessor structure iff @xmath256 and there is no @xmath257 such that @xmath258 , @xmath259 and @xmath260 .",
    "this is because otherwise the @xmath257-th point is a better answer than the @xmath73-th point for any query processed using this or any future version of the data structure .",
    "consequently , the points whose @xmath47-coordinates are stored in the predecessor structure can be arranged so that their @xmath47-coordinates are increasing and the weights decreasing .",
    "then it follows that locating the maximum weight of a point @xmath250 such that @xmath261 and @xmath262 can be done by finding the successor of @xmath47 in the version of the predecessor structure corresponding to @xmath263 . maintaining the structure while sweeping the grid",
    "is also done with a predecessor search .",
    "after having seen a new point @xmath253 we locate the predecessor of @xmath169 .",
    "if the weight of the corresponding point is smaller than @xmath254 , we remove it from the structure and repeat .",
    "a persistent predecessor search structure can be implemented in space @xmath1 while keeping the query time @xmath2  @xcite .",
    "consequently , we can build in @xmath248 time a  structure of size @xmath1 answering queries in @xmath2 time .",
    "before we handle arbitrary partial monge matrix we describe a solution to a restricted type of partial monge matrix called a _ staircase _ matrix . in a staircase matrix , the defined entries in every row",
    "either all start in the first column , or all end in the last column .",
    "we begin with a weaker result , which is that one can answer submatrix maximum queries on an @xmath6 staircase matrix in @xmath2 time with a structure of size @xmath156 .",
    "we will then show how to reduce the space to @xmath1 , and finally how to use the solution for staircase matrices in order to handle arbitrary partial monge matrices .",
    "[ thm : staircasesubmatrixlarge ] given an @xmath0 staircase monge matrix @xmath7 , a data structure of size @xmath156 can be constructed in @xmath156 time to answer submatrix maximum queries in @xmath2 time .",
    "because of left - right symmetry , we can assume that the defined entries in row @xmath73 start in the first column and end in column @xmath246 .",
    "notice that either @xmath264 or @xmath265 .",
    "without loss of generality we will assume the latter .",
    "this is enough because we will not be explicitly using the monge property in our solution , except for applying theorem  [ thm : submatrix ] on a copy of @xmath7 ( called @xmath266 ) where the undefined entries are appropriately filled .",
    "we partition @xmath7 into full monge matrices using a standard method : first , create a full monge matrix by taking the upper - left fragment @xmath267\\times [ 1,t_{n/2}]$ ] of @xmath7 .",
    "then , recursively decompose the staircase matrices created by taking the upper - right fragment @xmath267\\times [ t_{n/2}+1,n]$ ] and the lower - left fragment @xmath268\\times [ 1,n]$ ] of @xmath7 .",
    "see figure  [ fig : staircasedecoposition ] .",
    "it is easy to verify that the decomposition consists of at most @xmath269 full monge matrices ( called fragments ) .",
    "the decomposition has other useful properties on which we elaborate further .",
    "monge matrix partitioned into @xmath269 smaller full monge matrices ( fragments ) .",
    "( b ) a query range @xmath270\\times   [ j_{0},j_{1}]$ ] decomposed into two full monge matrices @xmath271 and @xmath272 and one dominance query @xmath273 .",
    "( c ) the dominance query as vertical and horizontal lines ( the green fragment is fully inside the range and the blue and red fragment intersect the horizontal line ) . ,",
    "scaledwidth=100.0% ]    consider a query range @xmath270\\times   [ j_{0},j_{1}]$ ] . to find the maximum ( defined ) @xmath50 $ ] over all @xmath58 $ ] and @xmath59 $ ] we proceed as follows .",
    "the simple case is when the query range is fully within the defined part of @xmath7 . to handle this case , we apply theorem  [ thm : submatrix ] on a copy of @xmath7 ( denoted @xmath266 ) where the undefined entries are appropriately ( and iplicitly ) filled .",
    "this allows us to do submatrix queries in @xmath2 time when the query range is fully defined .",
    "otherwise , we decompose the query into three parts .",
    "the first part , which we call a _ dominance maximum query _ , is to find the maximum @xmath50 $ ] over all @xmath274 and @xmath275 , for @xmath276 to be defined shortly .",
    "the other two are submatrix maximum queries fully within the defined part of @xmath7 ( and hence can be processed by querying the structure built for @xmath266 in @xmath2 time ) .",
    "the decomposition is performed in @xmath16 time by setting @xmath277 and choosing the smallest @xmath278 such that @xmath279 ( which can be preprocessed for every possible @xmath102 in @xmath1 space ) .",
    "the two submatrix maximum queries are therefore over the full monge matrices @xmath270\\times [ j_{0},j'-1]$ ] and @xmath280\\times [ j',j_{1}]$ ] .",
    "hence , it is enough to focus on answering dominance maximum queries .    to answer a dominance maximum query ( i.e. , to find the maximum @xmath50 $ ] over all @xmath274 and @xmath275 ) we use the partition of @xmath7 into full monge matrices ( fragments ) .",
    "every such fragment is either fully inside the query range , fully outside of the query range , or intersected by the query range boundary .",
    "a fragment @xmath281\\times [ c_{0},c_{1}]$ ] is fully inside the query range iff @xmath282 and @xmath283 .",
    "this observation allows us to reduce computing the maximum over all matrices fully inside the query to the problem defined in lemma  [ lem : dominancemaximum ] .",
    "the reduction is simply that for every fragment @xmath281\\times [ c_{0},c_{1}]$ ] we create a point @xmath284 and set its weight to be the maximum inside the fragment . as a result",
    ", we create at most @xmath1 points on the @xmath0 grid . using theorem  [ thm : submatrix ] on @xmath266 to create",
    "every point separately takes total @xmath248 in the preprocessing time , so in @xmath248 time we can construct a structure of size @xmath1 answering queries in @xmath2 time .",
    "we are left only with finding the maximum over all fragments intersected by the boundary of our dominance maximum query .",
    "we partition these fragments into three groups .",
    "the first consists of the single fragment containing @xmath285 $ ] .",
    "the maximum there can be found with a submatrix maximum query on @xmath286 in @xmath2 time .",
    "all other fragments intersected by the boundary are either intersected by the horizontal line @xmath287 or the vertical line @xmath288 , but not both .",
    "we show how to find the maximum over all matrices intersected by the horizontal line @xmath287 and fully to the right of the vertical line @xmath288 ( the other case is symmetric ) .    by the properties of our decomposition scheme ,",
    "there are at most @xmath289 fragments intersected by any horizontal line , and they can be arranged in the natural left - to - right order . for every possible horizontal line , we store these at most @xmath289 fragments in an array . for every fragment we store the coordinates of its corresponding submatrix of @xmath7 and the maximum in all of its entries below the horizontal line . the array is additionally equipped with the maximum over all maxima in each one of its suffixes . such preprocessed data",
    "allows us to find the maximum over all fragments intersected by a horizontal line @xmath287 and fully on the right of a vertical line @xmath288 in @xmath2 time : first , we binary search over the array stored for @xmath287 to locate the leftmost fragment completely on the right of @xmath288 .",
    "then we return the stored corresponding maximum .",
    "notice that the binary search also allow us to locate the fragment containing @xmath285 $ ] .",
    "consequently , the whole query time is @xmath2 using @xmath30 space for this part of the implementation . to guarantee @xmath30 preprocessing time",
    ", we run the smawk algorithm on every fragment in the decomposition in total @xmath30 time .",
    "this gives us the maximum in every row of every fragment .",
    "this is then enough to construct all arrays in @xmath30 time .",
    "we now proceed to improving theorem  [ thm : staircasesubmatrixlarge ] so that the structure needs just linear space .",
    "the main idea is to partition the @xmath0 staircase matrix @xmath7 into cells of size @xmath290 and then define a new smaller @xmath291 staircase matrix @xmath67 ( whose entries correspond to cell - maxima in @xmath7 ) on which we apply theorem  [ thm : staircasesubmatrixlarge ] . to implement this idea",
    "we need a number of additional auxiliary data structures , which take @xmath1 space in total .",
    "we start with an auxiliary lemma , which will be used to provide constant - time access to entries of @xmath67 .",
    "[ lem : cellmaximum ] given an @xmath0 monge matrix @xmath7 partitioned into @xmath290 cells , a data structure of size @xmath1 can be constructed in @xmath30 time to find the maximum in a given cell in @xmath16 time .",
    "we partition @xmath7 into @xmath292 horizontal slices , each consisting of @xmath289 rows ( and all columns ) . consider a single slice , which is a @xmath293 monge matrix .",
    "we store its breakpoints @xmath294 ( where @xmath295 ) in an atomic heap , consequently allowing predecessor queries in @xmath16 time ( this is exactly how the structure from lemma  [ lem : micro ] works ) .",
    "additionally , similarly to lemma  [ lem : submatrix ] , for every @xmath296 we precompute the value of @xmath98\\ ] ] and augment these values with a ( one dimensional ) range maximum data structure . here",
    ", @xmath33 denotes the row containing the maximum element in the @xmath20-th column of the slice in question .",
    "using two predecessor queries and one range maximum query , the problem of finding the maximum in a given cell ( which is fully contained in a single horizontal slice ) reduces in @xmath16 time to finding the maximum in at most two rows .",
    "the total space is @xmath297 and the bottleneck in the preprocessing is computing the breakpoints for all slices .",
    "the breakpoints of a single slice can be computed in @xmath298 by adding one row at a time , as done in the proof of lemma  [ lem : subcolumn ] . in total , this takes @xmath299 total time .",
    "we repeat the above reasoning on the transpose of @xmath7 . as a result , we either already know the maximum element , or we have isolated at most two rows and at most two columns , such that the maximum lies in one of these rows and one of these columns .",
    "this gives us at most four candidates for the maximum , which can be retrieved and compared naively .",
    "we partition @xmath7 into cells of size @xmath290 and then define a smaller @xmath291 staircase matrix @xmath67 .",
    "notice that , unlike lemma  [ lem : cellmaximum ] , @xmath7 is a staircase monge matrix ( and not a full monge matrix ) .",
    "this means that there are three types of cells in @xmath7 : fully defined , partially defined , and fully undefined .",
    "an entry of @xmath67 is defined iff its corresponding cell in @xmath7 is fully defined . in this case",
    "the entry is equal to the maximum in the corresponding cell .",
    "the undefined entries of @xmath67 are the ones corresponding to either partially defined or fully undefined cells of @xmath7 .",
    "we appropriately ( and implicitly ) fill these entries to turn @xmath300 into a full monge matrix , on which we apply lemma  [ lem : cellmaximum ] .",
    "this gives us constant - time access to the entries of @xmath67 , so finally we can apply theorem  [ thm : staircasesubmatrixlarge ] to preprocess it in @xmath1 space and @xmath30 time to answer submatrix maximum queries in @xmath2 time .",
    "regarding partially defined cells , we observe that there are at most @xmath301 of them .",
    "furthermore , they can be arranged in a linear order , so that if the part of @xmath7 corresponding to the @xmath73-th partially defined cell is @xmath302 \\times [ c_{i},c'_{i}]$ ] , then for all @xmath73 either @xmath302=[r_{i+1},r'_{i+1}]$ ] and @xmath303 or @xmath304 and @xmath305=[c_{i+1},c'_{i+1}]$ ] ( to be more precise , we might need to declare some fully defined cells partially defined to guarantee this property ) .",
    "we create a predecessor structure storing all @xmath306s and a separate predecessor structure storing all @xmath101s .",
    "we also compute the maximum in every partially defined cell and store them in an array ( arranged in the aforementioned linear order ) augmented with a ( one dimensional ) range maximum structure . computing the maximum in all partially defined cells",
    "is done in @xmath307 time using  @xcite .    by the same reasoning given in the proof of theorem  [ thm : staircasesubmatrixlarge ] , it is enough to implement dominance maximum queries on @xmath7 .",
    "a dominance maximum query can be decomposed into ( i ) a dominance maximum query on @xmath300 , which can be answered in @xmath2 time , ( ii ) finding the maximum inside all partially defined cells fully within the query range , and ( iii ) finding the maximum inside partially defined cells intersected by the boundaries of the query range .",
    "all partially defined cells fully within the query range create a contiguous interval in the linear order .",
    "the range can be determined in @xmath2 using the predecessor structures storing all @xmath306s and @xmath101s , and then the maximum can be found in @xmath16 time with a ( one dimensional ) range maximum query .",
    "it remains to calculate the maximum inside partially defined cells intersected by the boundaries of the query range .",
    "we will describe how to process all partially defined cells intersected by the horizontal boundary .",
    "handling the vertical boundary is symetric .",
    "let the dominance maximum query be specified by @xmath308 .",
    "we want to compute the maximum inside the query range and belonging to a partially defined cell intersected by the horizontal line @xmath287 .",
    "all such cells create a contiguous interval in the linear order , which can be determined with two predecessor queries in @xmath2 time . in the same complexity",
    ", we can find the leftmost such cell @xmath43 which is not fully on the left of the vertical line @xmath288 .",
    "we decompose the original query into a dominance maximum query inside @xmath43 , and the remaining part .",
    "the remaining part starts at a left boundary of a partially defined cell and consists of the entries at or below @xmath287 in all partially defined cells to the right of @xmath43 .",
    "consequently , the answer can be preprocessed for every point on a left boundary of a partially defined cell using @xmath297 space and @xmath307 time using  @xcite .",
    "the bottleneck in the preprocessing is computing the maximum in every row of every partially defined cell .",
    "it remains to describe how to handle the dominance query in @xmath43 .",
    "in other words , after constructing in @xmath30 time an @xmath1 size structure , we have , in @xmath2 time , reduced an arbitrary dominance maximum query into a dominance maximum query inside a single partially defined cell .",
    "this cell is a smaller @xmath290 staircase matrix , and furthermore there are at most @xmath309 such cells . by recursing on each of these smaller staircase matrices separately ,",
    "we construct in additional @xmath310 time an @xmath311 size structure , which reduces the original dominance query , in additional @xmath312 time , into a dominance maximum query inside one of @xmath313 tiny @xmath314 staircase matrix ( each of them being a submatrix of the original @xmath7 ) . by recursing again on every tiny staircase matrix separately ,",
    "we construct in additional @xmath315 time an @xmath1 size structure , which reduces the original arbitrary dominance query in additional @xmath316 time into a dominance maximum query inside an @xmath317 submatrix of @xmath7 .",
    "such dominance maximum query can be answered naively resulting in @xmath318 total query time .",
    "we are now ready to prove the main theorem of this section , which is that using theorem  [ thm : staircasesubmatrix ] we can actually implement submatrix maximum queries on arbitrary ( and not just staircase ) partial monge matrices .",
    "the idea is to partition the partial monge matrix into staircase matrices , so that each row and each column belong to @xmath16 staircase matrices .",
    "such partitioning was used in  @xcite .",
    "we build the data structure of theorem  [ thm : staircasesubmatrix ] on each staircase matrix in the decomposition , and build an additional data structure for queries spanning more than one staircase matrix .",
    "we partition @xmath7 into staircase matrices as depicted in figure  [ fig : partition ] .",
    "this partition was used in  @xcite .",
    "we define it here formally for completeness : let the defined entries in the @xmath73-th row start in the @xmath245-th column and end in the @xmath246-th column ( without loss of generality , every row contains at least one defined entry ) .",
    "the sequence @xmath245 is first non - increasing and then non - decreasing .",
    "similarly , the sequence @xmath246 is first non - decreasing and then non - increasing .",
    "initially , we partition @xmath7 into three slices . in the first slice , @xmath245 is non - increasing and @xmath246 is non - decreasing . in the second slice , either both @xmath245 and @xmath246 are non - increasing , or both @xmath245 and @xmath246 are non - decreasing . finally , in the third slice @xmath245 is non - decreasing and @xmath246 is non - increasing .",
    "the first and the third slices are then further partitioned into two staircase matrices each . the second slice can be broken into staircase matrices by dividing along alternating rows and columns as shown in figure  [ fig : partition ] .",
    "it is easy to verify that , in the resulting decomposition , each row is covered by at most two staircase matrices , and each column is covered by at most four staircase matrices .",
    "additionally , the staircase matrices contributed by the second slice can be partitioned into two _ collections _ , such that any two matrices in the same collection are row - disjoint and column - disjoint .",
    "the data structure consist of the following components .",
    "we apply theorem  [ thm : staircasesubmatrix ] on every staircase matrix in our partition . we also store additional data for both collections . by left - right symmetry",
    ", we can assume that the ranges of rows and columns of the matrices in the collection are @xmath319 and @xmath320 , respectively .",
    "we create a predecessor structure storing all @xmath306 s and a separate predecessor structure storing all @xmath101 s .",
    "we also compute and store the maximum inside every staircase matrix in the collection ( this is done in total @xmath39 time using the algorithm of klawe and kleitman  @xcite ) , and augment these maxima with a ( one dimensional ) range maximum structure .    now consider a submatrix maximum query @xmath270\\times [ j_{0},j_{1}]$ ] .",
    "we first query the @xmath16 structures built for the staircase matrices corresponding to the first and the third slice of @xmath7 .",
    "next , we consider each of the two collections separately . to find the maximum @xmath50 $ ] over all",
    "@xmath58 $ ] and @xmath59 $ ] , we use the predecessor structures to determine in @xmath51 the following values ( without loss of generality , they all exist ) :      we then query the structures built for the @xmath329-th , @xmath330-th , @xmath331-th , and @xmath332-th staircase matrix in the collection . now",
    "either we have already found the maximum , or it belongs to one of the staircase matrices fully contained in the query range .",
    "consequently , the maximum can be found in @xmath16 time with a single ( one dimensional ) range maximum query ."
  ],
  "abstract_text": [
    "<S> we present an optimal data structure for submatrix maximum queries in @xmath0 monge matrices . </S>",
    "<S> our result is a two - way reduction showing that the problem is equivalent to the classical predecessor problem in a universe of polynomial size . </S>",
    "<S> this gives a data structure of @xmath1 space that answers submatrix maximum queries in @xmath2 time , as well as a matching lower bound , showing that @xmath2 query - time is optimal for any data structure of size @xmath3 . </S>",
    "<S> our result settles the problem , improving on the @xmath4 query - time in soda12 , and on the @xmath5 query - time in icalp14 .    </S>",
    "<S> in addition , we show that partial monge matrices can be handled in the same bounds as full monge matrices . in both previous results , </S>",
    "<S> partial monge matrices incurred additional inverse - ackerman factors . </S>"
  ]
}