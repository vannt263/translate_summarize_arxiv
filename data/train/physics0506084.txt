{
  "article_text": [
    "the present program mfoam , and the foam program of refs .",
    "@xcite , from which mfoam is derived , are both examples of a general - purpose self - adapting monte carlo simulator / integrator .",
    "let us briefly recapitulate main features of foam , which are shared with the present project . in the cellular algorithm of foam ,",
    "points are generated randomly in the multi dimensional space according to an arbitrary , user - defined , unnormalized probability distribution function ( pdf ) @xmath2 .",
    "the algorithm works in two stages : _ exploration _ and _ generation_. in the exploration stage the shape of the distribution function is explored using mc methods , dividing the integration domain into a system of cells referred to as `` foam '' .",
    "the foam of cells is produced in a recursive process of binary splittings of the cells starting from the root cell , which can be a single @xmath3-dim hyperrectangle , an @xmath4-dim simplex or a cartesian product of both . in mfoam",
    "we restrict ourselves to hyperrectangles .",
    "the pdf @xmath2 is approximated by another pdf @xmath5 , which is equal to a constant within each cell .",
    "the main aim of the process of the foam evolution through binary splittings is to minimize either the ratio of the variance of the weight distribution to the average weight @xmath6 , or the ratio of the maximum weight to the average weight @xmath7 , where @xmath8 is the monte carlo weight .    in the generation stage",
    "every single mc weighted event is generated as follows : first a cell is chosen randomly and next , within this cell , a point ( mc event ) is generated according to an uniform distribution equal to @xmath9 and finally the mc weight @xmath10 is evaluated . as usual , the rejection method may turn these weighted events into weight - one events , with a certain rejection rate ( inefficiency )",
    ". the main aim of the rather sophisticated cell - splitting algorithm of foam ( exploration phase ) is the reduction of @xmath7 , assuring a low rejection rate .",
    "another option is the variance - reduction providing for self - adapting mc method of precise evaluation of the integrals . in either case ,",
    "the value of the integrand is already known approximately from the exploration stage and can be estimated with even better precision in the generation phase .",
    "it is instructive to compare the cellular algorithm of foam to algorithms used by two older programs in the family of self - adapting mc tools : vegas @xcite and miser @xcite .",
    "vegas primarily implements the so - called importance sampling ( variance - reducing ) method .",
    "it approximates the exact distribution by a multidimensional sampling function @xmath11 .",
    "the function @xmath11 is separable by construction , i.e. @xmath12 . owing to this feature , the function @xmath11 can be stored effectively in the computer memory as a collection of @xmath4 ( one for each dimension ) histograms with @xmath13 bins , without an explosion in the total number of bins , which would in general grow like @xmath14 .",
    "the sampling distribution is constructed iteratively , step by step , by means of making a number of monte carlo explorations over the integration region , while inspecting @xmath4 1-dimensional histograms of the projections the distribution function , each for one dimension .",
    "these histograms are used to define the new improved function @xmath15 , which in turn are used to generate mc points in the next iteration . in principle , after a few iterations , one obtains the reference distribution @xmath11 approximating the pdf .",
    "an estimated of the value of the integral over pdf is also obtained . in practice",
    "the performance of vegas depends heavily on the goodness of the factorizability assumption for a given pdf .",
    "generally , vegas turns out to be quite efficient for many distributions ( integrands ) featuring a single well localized peak .",
    "the miser program is based on the idea of the `` recursive stratified sampling '' and employs the technique of variance reduction similar to that in foam .",
    "it explores the pdf until a fixed maximal number of available function evaluations @xmath16 is exhausted . in the very beginning @xmath16 is allocated to the root cell being a hypercube and later on redistributed among the daughter cells . in the simplest variant",
    "the starting hypercube is divided by bisecting it across one of the edges into two sub - cells of equal volume .",
    "the division plane is chosen by examining all possible @xmath4 bisections of the @xmath4-dimensional cell and selecting the one that minimizes the resulting total variance of the two cells .",
    "similarly as in foam , the variances are estimated cell by cell during a short mc survey with a small fraction of `` allocated '' events for this cell . the remaining pool of unexploited function calls is allocated to the resulting sub - cells in a proportion that fulfills the condition for minimum variance .",
    "the whole procedure is repeated for each of the two sub - cells and continues recursively until the number of `` allocated function calls '' in a given cell falls below some predefined limit . in each cell",
    "the estimation of the integral is obtained by means of the plain mc method . at the end",
    ", the results for all cells are combined together to obtain the final value of the integrand and the error estimate .",
    "foam employs a combination of both techniques : importance and stratified sampling .",
    "contrary to vegas , there is no assumption in the foam algorithm about the factorizability of the distribution ( integrand ) . in the variance reduction mode foam resembles miser , but it employs a different , far more sophisticated cell division algorithm ; the division plane of the cell is not at the half - point of the edge , but is optimized . the algorithm of foam has passed many practical tests and proved its efficiency in several problems in high - energy physics ; see for instance  @xcite .",
    "the foundations of the foam algorithm are well consolidated and our current work concentrates mainly on the updates of earlier implementations and improvements of the efficiency and functionality . for a detailed description of the algorithm of foam version 2.05",
    "we refer the interested reader to refs .",
    "@xcite and  @xcite .",
    "the use of the original foam program @xcite has been mainly limited by the memory consumption .",
    "foam  v.2.05 divides the @xmath4-dimensional parameter space into hyperrectangular or simplical cells .",
    "final mc efficiency increases mainly with the requested maximum number of cells @xmath17 , so it is very important to economize on the memory used by single cell in order reach a higher number of cells . for the hyperrectangular grid of cells a memory saving arrangement algorithm of coding cells in the memory",
    "was found  @xcite .",
    "it reduces memory consumption down to a mere 80 bytes / cell , independently of space dimension @xmath4 . the present version , limited to hyperrectangles , profits from this memory - saving algorithm of recording the cell parameters .",
    "we would like to mention , that in the mean - time a similar memory - saving algorithm has been also found and implemented for simplices .",
    "it will be included in the forthcoming version 2.06 of the foam  @xcite .",
    "the unspoken assumption in mfoam is that the calculation of the pdf is cheap in terms of cpu time .",
    "this is often true in practice .",
    "if not , then mfoam may be used to model the main features of the singularities in the pdf and the fine details , which can be cpu - costly , are then added by extra mc weight during the mc run , after the exploration . however , in order to deal better with the cases of pdfs which are costly in terms of cpu and feature relatively mild peaks , one should introduce in the future development of mfoam the possibility to limit the total number of pdf calls , in addition to limiting the number of cells .",
    "the paper is organized as follows : section 2 describes changes in basic classes and their functionality .",
    "section 3 describes the configuration of mfoam .",
    "section 4 discusses the usage of mfoam classes under the root system .",
    "conclusions follow .",
    "mfoam ( mini foam ) is a new version of foam with slightly limited functionality , well integrated with root  @xcite .",
    "our principal aim is to provide a compact and easy to use tool , for numerical monte carlo generation and integration of pdfs with arbitrarily complicated structure of peaks , in the number dimensions limited up to say 20 . with the increasing popularity of root in high - energy community",
    "we believe that this implementation tied up with root will attract the interest of the new users who already exploit root in their daily work .",
    "let us comment on our decision of removing the simplical cells from the mfoam algorithm and the code .",
    "it was done because of an empirical observation ( based on practical experience with the wide range of the distributions ) that the use of simplical cells was usually giving rise to worse mc efficiency than that of hyperrectangular cells .",
    "in addition , maintaining simplical cells increases complexity of the source code .    the main motivation for the closer integration of mfoam with the root system was to profit fully from the _ persistency mechanism _ for its objects and help users who already use root daily .",
    "also , thanks to the closer integration with root , the code of mfoam gets more compact , since the internal histogramming and other low - level structures are replaced by the well tested root facilities .",
    "altogether , we have managed to reduce significantly the total size of code ( by about 50% ) and its complexity as well , with respect to the original foam , at the same time improving its stability .    obviously , the above improvements and gains are purely technical , nevertheless they are very important , if object of the mfoam class are to be used as `` rock solid '' building blocks in any more complex , large scale , monte carlo projects .",
    ".summary on c++ classes of mfoam .",
    "[ cols=\"<,<\",options=\"header \" , ]     at present mfoam has _",
    "nine principal configuration parameters_. in addition , the user may optionally ( re)define certain internal configuration parameters of mfoam in order to inhibit and/or predefine the division geometry in the cell split .",
    "all of the nine principal parameters are listed in table  [ tab : tfcellparams ] .",
    "they control all essential features of the program and are preset to some meaningful default values , appropriate for the generation of unweighted events .",
    "the new inexperienced user of mfoam usually does not need to reset them .",
    "the only exception is the dimension of integration space kdim .",
    "it is mandatory to set kdim to a non - zero integer value before invoking initialize .    in comparison with foam-2.05 two steering parameters",
    "were completely removed : ndim , optord , as relevant only for simplical cells .",
    "the other three are hidden from the users eyes , because their usefulness is rather limited .",
    "functionality of the program was frozen for the following choice : optpeek=0 , optedge=0 and optmcell=1 . finally , the default value of another optional input parameter optrej switch is now set to 1 ( weight @xmath18 events ) , instead of 0 .",
    "if the user wants to redefine configuration parameters according to his needs , then the relevant piece of code will look as follows :    ....     foamx->setkdim (      kdim ) ;     foamx->setncells (    ncells ) ;     foamx->setnsampl (    nsampl ) ;     foamx->setnbin (      nbin ) ;     foamx->setoptrej (    optrej ) ;     foamx->setoptdrive ( optdrive ) ;     foamx->setevperbin ( evperbin ) ;     foamx->setmaxwtrej ( maxwtrej ) ;     foamx->setchat (      chat ) ; ....    the user of mfoam can decide to inhibit the division in some variables . this can be done with the method setinhidiv(int_t idim , int_t inhidiv ) of the class tfoam , where idim is the index of the variable for which the inhibition is done and inhidiv is the inhibition switch .",
    "this method should be used before invoking initialize , after setting kdim .",
    "the relevant code may look as follows :    ....     foamx->setinhidiv(0 , 1 ) ; //inhibit division of x_1     foamx->setinhidiv(1 ,",
    "1 ) ; //inhibit division of x_2 ....    the allowed values are inhidiv=0,1 and the default value is inhidiv=0 .",
    "note that the numbering of integration variables with the index idim starts from zero .",
    "the inhibited variables are generated uniformly .",
    "the user may also predefine divisions of the root cell in certain variables using the method setxdivprd(int_t idim , int_t len , double_t xdiv [ ] ) .",
    "the relevant piece of the user code may look as follows :    ....     double_t xdiv[3 ] ;     xdiv[0]=0.30 ; xdiv[1]=0.40 ; xdiv[2]=0.65 ;     foamx->setxdivprd(0 , 3 , xdiv ) ; ....    again , this should be done before invoking initialize , after setting kdim .",
    "to begin work with the mfoam package , a user should have basic knowledge of root and the cint interpreter .",
    "very good documentation of root is available . at this moment",
    "mfoam is already included in the root standard distribution ( beginning from version 4.04 ) .",
    "the root package can be obtained from root s web page .",
    "precompiled binaries are also available as tar archive files for many major platforms : pc computers with both linux and ms windows systems and workstations under unix . all supported operating systems can be found on root s home page .",
    "the installation process is straightforward and on most unix - like systems amounts to unpacking the tarball file and setting environment variables : rootsys , which should point to the root main directory and ld_library_path locating root libraries .",
    "we strongly recommend to use binaries , which exactly match the user operating system .",
    "if precompiled binaries for user system are not available , then a direct installation from source code is necessary .",
    "source code can be obtained as a tarball or through the cvs repository .",
    "a detailed description of the configuration and compilation of the root package is beyond the scope of this article .",
    "therefore we refer the interested user to root s online documentation .    after successful installation ,",
    "the shared library libfoam.so is present in the $ rootsys / lib directory .",
    "this library can be loaded directly to root by issuing the following command from cint command line :    root [ 0 ] .l $ rootsys / lib / libfoam.so    from now on , the user will get an access to all mfoam classes while interpreting / executing c++ scripts / programs under the cint interpreter of root , or simply working interactively from the command line .      the user application program can be compiled / run using one of the following three methods :    1 .",
    "the user program is interpreted by cint of root .",
    "this simple method might be too slow in execution and will inhibit the use of the persistency of the mfoam class .",
    "the user program is compiled / linked in flight employing the automatic compiler of libraries ( aclic ) facility of cint .",
    "this automatizes the process of compilation and linking and the persistency of the mfoam class is available .",
    "it is the preferred mode of work for medium and small - size applications .",
    "3 .   standard compile - link - run method .",
    "this method is well suited for large mc projects , which are run in the batch mode .",
    "we tried to provide the user with examples of all possible compile / run methods .",
    "demonstration scripts in the $ rootsys / tutorials directory cover the first two methods and show the basic features of mfoam .",
    "in addition there is a collection of simple programs showing how to build and run stand - alone applications .",
    "they are distributed as a mfoam-examples-1.2.tar file which is available from the authors web page .",
    "let us now describe in more detail some demonstration scripts in the tutorials subdirectory of the root distribution directory .",
    "there are 3 demonstration programs there .",
    "the first of them , foam_demo.c , demonstrates the full power of the mfoam compiled by aclic facility ( scenario 2 above ) , showing all essential phases of its usage : initialization , the setting up of random - number generator a the distribution to be generated / integrated .",
    "the examples of setting up optional input parameters are also shown .",
    "finally , mc generation and getting the value of the integral and other parameters after mc generation are also demonstrated .",
    "this example is a slightly modified version of the analogous program in the foam distribution  @xcite .",
    "let us explain the content of the foam_demo.c script .",
    "after collection of headers we see the definition of the distribution to be generated / integrated :    ....     class tfdistr : public tfoamintegrand {     public :        tfdistr ( ) ;        double_t density(int_t , double_t * ) {        ......................        }        classdef ( tfdistr,1 ) //class of testing functions for foam     } ;     classimp(tfdistr )     .....................     tfoamintegrand    * rho= new tfdistr ( ) ;     foamx->setrho(rho ) ; ....    class tfdistr inherits from the abstract class tfoamintegrand . note the presence of the classimp and classdef statements , which tell root to create an automatic streamer for this class .",
    "the subsequent piece of the code creates the objects of the random - number generator , the integrand distribution and the mfoam object itself :    ....    trandom     * pseran      = new trandom3 ( ) ;   //",
    "create random number generator    pseran->setseed(4357 ) ;                     // set seed    tfoamintegrand * rho= new tfdistr ( ) ;        //",
    "create integrand distribution    tfoam    * foamx      = new tfoam(\"foamx \" ) ;   //",
    "create mc simulator / generator ....    next , some configuration parameters of the tfoam object foamx are redefined before it is initialized ( exploration ) :    ....    foamx->setkdim(kdim ) ;         // mandatory !",
    "foamx->setncells(ncells ) ;     //",
    "optional    foamx->setrho(rho ) ;           // mandatory !",
    "foamx->setpseran(pseran )      // mandatory !            foamx->initialize ( ) ;          //",
    "initialize mc simulator / generator ....    at this point the attention should be payed to the fact that just _ after the exploration phase _ the object of the mfoam class is written to file rdemo.root :    ....      tfile rootfile(\"rdemo.root\",\"recreate\",\"histograms \" ) ;      .............      foamx->write(\"foamx \" ) ;     // writing mfoam object on the disk      .............",
    "rootfile.write ( ) ;      rootfile.close ( ) ; ....    finally , the series of mc events are generated :    ....    for(loop=0 ; loop < nevtot ; loop++ )    {      foamx->makeevent ( ) ;            //",
    "generate mc event      foamx->getmcvect ( mcvect ) ;     //",
    "get mc point      mcwt = foamx->getmcwt ( ) ;         //",
    "get mc weight      ..........    } ....    the code ends up with the printouts of the value of the integral over pdf and some other statistics concerning the mc run .",
    "the user is invited to manipulate the configuration parameters of mfoam . in particular",
    "we recommend to switch to weighted events ( optrej=0 ) and change the number of cells ncells in the initialization .",
    "the foam_demo.c program is compiled , linked and executed from the cint shell by issuing the following commands :    $ root + root [ 0 ] .l .. /lib",
    "+ root [ 1 ] .x foam_demo.c+ +    note that the suffix `` + '' instructs cint to use the automatic compiler of libraries ( aclic ) facility .",
    "in such a case the process of compilation and linking is completely automatized . during the compilation phase the shared library foam_demo_c.so",
    "is created , which contains the definition of the tfdistr class , together with its automatic streamers .",
    "this is exactly what we need for testing persistency . in the stand - alone application the class of the pdf",
    "would have to be directly compiled and put in the shared library for further use .",
    "here it is done in a simplified way .",
    "the second small program , foam_demopers.c , demonstrates the use of the persistency of the mfoam class .",
    "it reads the mfoam object from the disk , checks its consistency , prints out geometry of cells and starts generation of events .",
    "it can be interpreted directly by cint :    $ root + root [ 0 ] .x foam_demopers.c +    the demo_c.so library , defining the tfdistr class , is loaded at the run - time with the help of    ....     groot->processline(\".l foam_demo.c+ \" ) ....    in the code .",
    "the user may verify that the output from it is _ exactly the same _ as the analogous output of foam_demo.c .",
    "this illustrates the fact that the mfoam object , the mc simulator , can be dumped into the disk at any moment and it resumes its functioning after reloading it from the disk , as if there was no disk - write and disk - read at all .",
    "the other macro foam_kanwa.c is a simplified shorter version of foam_demo.c , without any unnecessary modification of the configuration parameters of the mfoam ( they are internally set to sensible default values ) .",
    "this macro might be useful for the first - time user of the mfoam .",
    "on the other hand , this program adds a simple example of the graphics using root ; the 2-dimensional distribution of the produced mc events is shown dynamically on the screen , as the accumulated mc statistics grows .",
    "notice the use of the tapplication object , in order to stabilize the picture on the screen in the execution .",
    "this macro can be executed / interpreted ( scenario 1 ) directly by means of typing :    $ root + root [ 0 ] .x",
    "foam_kanwa.c +    the example output from running foam_kanwa.c is reproduced in the appendix .",
    "simulation will start and then a plot of the distribution function will pop - up on the graphical _ canvas _ on the screen .",
    "the execution is noticeably slower , as is always the case for the interpreted programs .",
    "the main difference with the foam_kanwa.c is in the distribution function , which is now defined simply as a global function camel2 .",
    "it is made accessible to the mfoam object foamx in the following line of code :    ....      foamx->setrhoint(camel2 ) ;    ....    another difference is that the shared library of mfoam is loaded with the following explicit instruction :    ....      gsystem->load(\"libfoam.so \" ) ; ....    instead of the linking procedure .",
    "this instruction is not really needed if root is already aware of the location of the mfoam library .    in some of the above examples we could not exploit the persistency of the root objects .",
    "this is because of the restrictions in cint , which does not allow an interpreted function to inherit from the tobject class .",
    "this is the reason why , in these examples where pdf is the global function , the automatic streamer can not be generated .",
    "even if one would write the mfoam object on the disk , the information about the pdf will be lost .",
    "of course , the user may always go back to one of the compilation methods and enjoy full persistency of the mfoam objects .",
    "in addition to better persistency , the compiled applications have the advantage of being significantly faster in the execution .",
    "let us now describe in more detail some examples of the use of mfoam classes in stand - alone applications ( scenario 3 ) .",
    "it may be of interest to more advanced users , who plan to use mfoam as part of their large - scale monte carlo projects .",
    "it is assumed that root is installed and the environment variable rootsys is properly set .",
    "after unpacking the distribution file mfoam-examples-1.2.tar one should execute the configure script :    $ cd mfoam - examples-1.2 + $ ./configure +    which inspects the system configuration and looks up for the root library , then generates the makefile file .",
    "version 4.04 of root or later is required .",
    "the configure script can fail for many reasons . in that case the user should first check if the rootsys environment variable indeed points to root installation location .",
    "the default behaviour of the configure script can be changed by additional command line parameters and environment variables",
    ". it may be useful if the computer is equipped with a compiler other than gcc .",
    "a full list of available options is displayed by the configure -h command .",
    "the configure script and the accompanying configuration files were generated using automake tools version 1.91 . in case",
    "the user wants to re - create the configure script and the accompanying files , version 1.61 or later of automake is needed .    to compile and link these codes",
    "one should type the following :    $ make + $ make install +    we have successfully tested the installation of mfoam - examples on computers with several variants of the linux operating system : cern scientific linux slc3 , red hat linux 7.3 , fedora linux fc3 .",
    "the code is highly portable and we think that it should compile without any problems on all other systems supported by root developers . in rare case , certain minor modifications of the source code may be necessary .",
    "after successful compilation one can run demonstration programs with the following commands :    ....      make kanwa      make demo      make testpers ....    the content and functionality of the programs demo.cxx and kanwa.cxx are the same as those of their macro counterparts foam_demo.c and foam_kanwa.c described above .",
    "the code of these programs can serve as a useful template for the user applications .",
    "the command make testpers runs an advanced test of persistency with two generator objects served by one central random generator . in this example",
    "two classes of mc event generators tgenmc and tgenmc2 are defined and the corresponding library libtgenmc.so is created .",
    "an object of each mc event generator uses one own object of mfoam class and one external object of the class trandom  the central rng .    in the program main.cxx ,",
    "two objects of the class tgenmc and tgenmc2 are created .",
    "also a single central rng object is allocated and made available to both mc generators .",
    "all three objects are written into a disk file and used to generate 200k mc events , using each of the two mc generators .",
    "the other program mainw.cxx reads all three objects from the disk file , reassigns the central rng to mfoam objects inside the two mc event generators ; again , 200k mc events are generated , using each of the two mc generators . since the disk - write in main was done after initialization and before mc generation , the mc series of the events from mainw should be the same as from main .",
    "this is checked by `` diffing '' two files which record first 15 events from main and mainw correspondingly .",
    "we find that their content is identical , and this provides an empirical proof that this complicated setup of the two mc event generators using two mfoam objects and single central rng is surviving the disk - write and disk - read operations without any loss of its functionality .",
    "the compile  link  execute chain for the tandem of main and mainw programs and `` diffing '' output files is realized by the single command ` make testpers ' .",
    "the above example of organization with the single central rng is well suited for any large monte carlo projects with many mfoam objects and many monte carlo sub - generators served by the single central rng .",
    "the other interesting feature of the above examples is the implementation of the pdf as the density method of the tgenmc2 class . in our example",
    "the tgenmc2 class inherits from tfoamintegrand .",
    "consequently , the density function is provided to the mfoam object ( which is the member of the tgenmc2 class ) as this . in the other mc generator of the class tgenmc",
    ", the pdf is defined in an object of the separate class tfdistr and the pdf of this class is allocated and its pointer is assigned to the mfoam object in the tgenmc object during its initialization .",
    "the above test demonstrates a few fairly complicated examples of how to organize the relation between several mfoam objects , rngs and pdfs within the mc project .",
    "however , it does not cover all possible situations . in the next section we shall discuss this issue in a general case and",
    "we shall argue that object of the mfoam class are able to cope with all possible scenarios in an efficient and transparent way .",
    "persistency is undoubtedly a very valuable feature of the objects of the class tfoam , and of root objects in general .",
    "it is therefore worthwhile to clarify certain features of its implementation , which the user should know and consider before attempting to exploit the persistency of mfoam objects in any advanced / sophisticated applications .    as we have seen in the explicit examples of the previous section ,",
    "the critical issue in this context is the treatment of the two external objects , which every given object of the class tfoam needs in order to function properly : the object of random number generator ( rng ) and the object providing the probability distribution function ( pdf ) .",
    "these two objects have to be provided to the object of the class tfoam .",
    "in the previous section , we have shown most typical case , when one deals with only one instance ( object ) of the above classes  this was quite straightforward to organize .    in more advanced applications we have to be prepared to deal with the situations in which we deal with many ( hundreds ) of objects of the class tfoam , all of them using single _",
    "rng object ( or a few of them ) and possibly generating many different pdfs . in this case",
    "if one wants to profit fully from the persistency , such a complicated set of interrelated objects of the three types has to emerge fully operational after the disk - write and disk - read operations .",
    "this turns out to be a nontrivial task to realize in practice .",
    "we claim that the way we interface an object of the class tfoam with the two `` satellite '' rng and pdf objects of the trandom and tfoamintegrand classes allows us to deal with any arbitrarily complicated set of interrelated object , while correctly implementing the persistency in _ all _ such situations .",
    "first of all , the two external objects , rng and pdf , are external in this sense that the new operator allocating them is placed outside the tfoam code and the object of the class tfoam knows only their pointers .",
    "hence , the important question related to the persistency implementation using root ( the problem is however more general ) can be immediately formulated : whose responsibility is to _ re - create _ these two objects in the process of the disk - read ?",
    "first possible solution is that this task is handled by the automatic streamer of the object of the class tfoam , which would re - create the objects rng and pdf .",
    "their actual pointer should then be exported to any other objects , which need legitimately an access to them .",
    "this second possibility is to inhibit the re - creation of the objects rng and pdf by the streamers of the class tfoam .",
    "root allows this to be done ! at the end of the line in which the pointer to an object is defined . ] . in the latter case",
    "it would be the sole responsibility of the user to store the two external objects rng and pdf into disk separately , read them separately , and provide their pointers to the object of the class tfoam after the disk - read operation .",
    "the first option looks attractive because of its simplicity .",
    "it is definitely an optimal one in the most common case of just three objects  hence we would like to implement this scenario as the basic one .",
    "however , this solution will fail when several objects of the tfoam class are served by the single rng object , a quite common case in any bigger mc projects . in this case",
    ", the disk - read operation ( done by root streamers ) will clone many independent identical rng objects , each one for every object of the class tfoam .",
    "this is clearly undesirable .",
    "the situation with a set of several pdf objects serving one or more tfoam objects is even more subtle . on the one hand",
    ", one may argue that since the distribution of a given pdf object is essentially memorized inside a given tfoam object , a genuine one - to - one association among them should be maintained .",
    "hence , the pdf object should be `` owned '' by the tfoam object , during the disk - write and disk - read , as in the first scenario . on the other hand ,",
    "we shall sometimes deal with the situations with a single pdf object serving several tfoam objects ; either because it needs huge memory , or it is very slow in execution ( its execution is a two - step process ) , or it is not a genuine c++ object , but rather a `` wrapper '' to another non - oop ( fortran ) program . in such a case",
    "it is better to handle pdf objects outside the tfoam object , as in the second scenario .",
    "summarizing , the treatment of the rng and pdf objects should be quite similar , and the possibility of keeping / controlling both of them outside the tfoam object should be optionally available . in other words",
    ", we would ideally need both above solution for both rng and pdf objects : the first solutions , for simple applications and the second one for advanced applications .",
    "the actual method of handling the rng and pdf external objects in the tfoam class allows the user to implement both above scenarios .",
    "it is done in the following way : the rng and pdf objects are always created for the first time outside the tfoam object , as already described .",
    "their pointers are transferred into the tfoam object as the arguments of initialize(rng , pdf ) .",
    "alternatively it is done with the help of the two dedicated setters setpseran(rng ) and setrho(pdf ) , before invoking initialize ( ) . at first sight",
    ", it seems that we follow the first solution , especially that we do not inhibit the re - creation of the `` private copy '' of the objects rng and pdf by the tfoam object ( by its streamer ) during the disk - read .",
    "indeed the first solution is available in this way . restricting the discussion to rng objects",
    ", the second scenario can be implemented as follows : first , disk - write and disk - read of the rng object is done by the user , then , after the disk - read of all tfoam objects , the pointers of the rng object inside tfoam objects are reassigned to the rng object , using a dedicated setter method , see also the examples of section [ examps ] . in order to avoid a memory leak , the setter which is used to reassign the pointer to external rng has to destroy the existing `` ghost '' rng object , which has been unnecessarily created during the disk - read operation of every tfoam object .",
    "the method resetpseran(rng ) is introduced exactly for this purpose .",
    "the analogous setter method of destroying the existing pdf object and reassigning its pointer is the method resetrho(pdf ) of the tfoam class .",
    "obviously , the rng and pdf objects are treated in the same way .",
    "the above solution is efficient , transparent and useful in almost all cases .",
    "it will not be satisfactory in the case where creating and destroying a pdf object takes an extremely long time and/or huge memory ( no such problem with the rng objects ) .",
    "in such a case a simple modification of the source code of the tfoam class ( inhibiting the storage of the pdf object ) will be a more economic solution ; however , it requires recompiling the tfoam library .",
    "we present all users of the foam package with its new version mfoam .",
    "we have payed special attention to making it more user - friendly , so that it provides with less effort solutions of many every - day problems in the mc simulation .",
    "this may , hopefully , attract new users , especially those who already use root in their work .",
    "we also hope for feedback from them , to be used in the further improvements in the user interface to both foam and mfoam .",
    "we are very grateful to r. brun and f. rademakers for their help in achieving better integration of the mfoam code with root , and many related discussions .",
    "we warmly acknowledge the help of piotr golonka in setting up the example distribution directory .",
    "we thank to ack cyfronet agh computer center for granting us access to their supercomputers and pc clusters funded by computational grants : mnii / sgi2800/ifj/009/2004 , mnii / hp_k460-xp / ifj/009/2004 , eu project crossgrid ist-2001 - 32243 , and kbn grant",
    "spub - m 620/e-77/spb/5pr ue / dz 224/2002 - 2004 , which were helpful while testing mfoam .    10    s.  jadach , _ comput . phys .",
    "* 152 * ( 2003 ) 55 , http://www.arxiv.org/abs/physics/0203033[physics/0203033 ] .",
    "s.  jadach , _ comput .",
    "* 130 * ( 2000 ) 244 , http://www.arxiv.org/abs/physics/9910004[physics/9910004 ] .",
    "g.  p. lepage , _ j. comput .",
    "* 27 * ( 1978 ) 192 .",
    "w.  h. press and g.  r. farrar , _ computers in physics _ * 4 * ( 1990 ) 190 , cfa-3010 .",
    "s.  jadach and w.  placzek , _ comput .",
    "_ * 72 * ( 1992 ) 221237 .",
    "w.  placzek and s.  jadach , _ eur .",
    "phys . j. _",
    "* c29 * ( 2003 ) 325 , http://www.arxiv.org/abs/hep-ph/0302065[hep-ph/0302065 ] . s.  jadach and m.  skrzypek , `` solving constrained markovian evolution in qcd with the help of the non - markovian monte carlo '' , http://www.arxiv.org/abs/hep-ph/0504263[hep-ph/0504263 ] .",
    "s.  jadach and p.  sawicki , `` upgrade of the cellular general purpose monte carlo tool foam to version 2.06 '' , in preparation .",
    "r.  brun and f.  rademakers , _ nucl .",
    ". meth . in phys .",
    "_ * a389 * ( 1997 ) 81 , proceedings aihenp96 workshop , lausanne , sept .",
    "1996 , see also http://root.cern.ch/.    g.  marsaglia , b.  narasimhan , and a.  zaman , _ comput .",
    "* 60 * ( 1990 ) 345 .",
    "m.  matsumoto and t.  nishimura , _ acm transactions on modeling and computer simulation _ * 8 * ( 1998 ) 3 .",
    "m.  luscher , _ comput .",
    "* 79 * ( 1994 ) 100 , http://www.arxiv.org/abs/hep-lat/9309020[hep-lat/9309020 ] .",
    "f.  james , _ comput . phys",
    ". commun . _",
    "* 79 * ( 1994 ) 111 .",
    "the code of the example macro foam_kanwa.c looks like :      .... --- kanwa started --- ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff f                                                                               f f                    * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *                    f f                     * * * * * *       tfoam::initialize     * * * * * *                    f f                    * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *                    f f                                                       foamx                    f f     version =            1.02 m    =                    release date :   2005.04.10 f f        kdim =           2 =   dimension of the hyper - cubical space               f f      ncells =         500 =   requested number of cells ( half of them active )    f f      nsampl =         200 =   no of mc events in exploration of a cell           f f        nbin =           8 =   no of bins in histograms , mc exploration of cell   f f    evperbin =          25 =   maximum no effective_events / bin , mc exploration    f f    optdrive =           2 =   type of driver    = 1,2 for sigma , wtmax              f f      optrej =           1 =   mc rejection on / off for optrej=0,1                 f f    maxwtrej =              1.1    =        maximum wt in rejection for wt=1 evts f f                                                                               f ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff 2222222222222222222222222222222222222222222222222 ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff f                                                                               f f                     * * *   tfoam::initialize finished ! ! !   * * *                    f f      ncalls =       99800 =             total number of function calls           f f      xprime =        1.3922344    =      primary total integral                   f f      xdiver =       0.39314276    =      driver   total integral                   f f    mcresult =       0.99909163    =      estimate of the true mc integral         f f                                                                               f ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff ( x , y ) =   ( 0.26506687 , 0.37983892 ) ( x , y ) =   ( 0.65874831 , 0.76719268 ) ( x , y ) =   ( 0.6405293 , 0.73329734 ) ( x , y ) =   ( 0.29933616 , 0.37537068 ) ( x , y ) =   ( 0.31228105 , 0.39614503 ) ( x , y ) =   ( 0.71258758 , 0.64969589 ) ( x , y ) =   ( 0.34830539 , 0.38099167 ) ( x , y ) =   ( 0.26990382 , 0.42078097 ) ( x , y ) =   ( 0.35661486 , 0.41847364 ) ( x , y ) =   ( 0.5557375 , 0.62757837 )   mcresult= 1.0004446 + - 0.00080837425 --- kanwa ended --- ...."
  ],
  "abstract_text": [
    "<S> the general - purpose self - adapting monte carlo ( mc ) event generator / simulator mfoam ( standing for mini - foam ) is a new compact version of the foam program , with a slightly limited functionality with respect to its parent version . on the other hand , </S>",
    "<S> mfoam is easier to use for the average user . </S>",
    "<S> this new version is fully integrated with the root package , the c++ utility library used widely in the particle physics community . </S>",
    "<S> the internal structure of the code is simplified and the very valuable feature of the persistency of the objects of the mfoam class is improved . with the persistency at hand , it is possible to record very easily the complete state of a mc simulator object based on mfoam and root into a disk - file at any stage of its use : just after object allocation , after full initialization ( exploration of the distribution ) , or at any time during the generation of the long series of mc events . later on the mc simulator object </S>",
    "<S> can be easily restored from the disk - file in the `` ready to go '' state . </S>",
    "<S> objects of tfoam class can be used as a stand - alone solution to many everyday problems in the area of the monte carlo simulation , or as building blocks in large - scale mc projects , taking full advantage of the object - oriented technology and persistency .    * ifjpan - v-05 - 04 + * cern - ph - th/2005 - 094 * *    * s.  jadach * +   + _ and _ + _ cern department of physics , theory division + ch-1211 geneva 23 , switzerland _ +   + * p.  sawicki * +   +    _ to be submitted to computer physics communications _    </S>",
    "<S> keywords : monte carlo ( mc ) simulation and generation , particle physics , phase space .    * ifjpan - v-05 - 04 + * cern - ph - th/2005 - 094 + june  2005 * </S>",
    "<S> *    @xmath0supported in part by eu grant mtkd - ct-2004 - 510126 , in partnership with cern ph / th division .    </S>",
    "<S> * program summary *    _ title of the program : _ + mfoam ( mini foam ) , version 1.02 .    </S>",
    "<S> _ computer : _ </S>",
    "<S> + most unix workstations , supercomputers and pc .    _ </S>",
    "<S> operating system : _ </S>",
    "<S> + most unix systems , linux and windows . </S>",
    "<S> + application programs were thoroughly tested under red hat linux 7.x , cern scientific linux 3.02 , fedora linux fc3 , unix irix-6.5 . </S>",
    "<S> + at present mfoam is distributed with the root package ( version 4.04 and later ) .    _ programming languages used : _ + ansi c++ .    _ high - speed storage required : _ + depends on the complexity of the problem . </S>",
    "<S> for the default 2000 cells it is about 25 mb while for 100,000 cells it allocates about 35 mb . </S>",
    "<S> these data are for running from cint command line and include also memory consumption by cint itself .    </S>",
    "<S> _ no . of lines in combined program and test deck : _ </S>",
    "<S> + mfoam-1.02 2776 lines of c++ code .    </S>",
    "<S> _ nature of the physical problem : _ </S>",
    "<S> + monte carlo integration or generation of unweighted ( weight equals 1 ) events with a given probability distribution is a standard problem in many areas of research , ranging from high - energy physics to economy . in any library of general utilities </S>",
    "<S> it is highly desirable to include a general - purpose numerical tool ( program ) with the mc generation algorithm featuring the built - in capability of automatically adjusting generation procedure to an arbitrary pattern of singularities in the generated distribution . </S>",
    "<S> our primary goal is the simulation of the differential distribution in the multiparticle lorentz - invariant phase space for the purpose of comparison between quantum field theory prediction , and experiments in the high - energy experiments . </S>",
    "<S> however , the solution may have a much wider area of applications .    </S>",
    "<S> _ method of solution : _ + in the algorithm , a grid of cells , called `` foam '' , is built in the process of the binary split of the cells . </S>",
    "<S> the resulting foam is adapted automatically to the shape of the integrand in such a way that the resulting ratio of the average weight to maximum weight or the variance to average weight is minimized .    </S>",
    "<S> _ restrictions on the complexity of the problem : _ </S>",
    "<S> + consumption of computer resources depends on the complexity of the problem . </S>",
    "<S> the use of the program is limited to about a million of cells for a relatively small number of dimensions ( @xmath1 ) in view of the memory and cpu time restrictions of a modern desktop computer .    </S>",
    "<S> _ typical running time : _ + the cpu time necessary to build up a foam of cells depends strongly on the number of dimensions and the requested number of cells . on the pc with a 1.6  ghz intel processor , it takes about 10 seconds to build a hyperrectangular grid of 10,000 cells for simple 3-dimensional distribution . </S>"
  ]
}