{
  "article_text": [
    "in this paper we consider two geometric optimization problems in the plane where unit disks play a prominent role .",
    "for both problems we discuss efficient algorithms to solve them , provide an implementation of these algorithms , and present experimental results on the implementation .",
    "the first problem we consider is computing a _ shortest - path tree _ in the ( unweighted ) intersection graph of unit disks .",
    "the input to the problem is a set @xmath5 of @xmath1 disks of the same size , each disk represented by its center .",
    "the corresponding unit disk ( intersection ) graph has a vertex for each disk , and an edge connecting two disks @xmath6 and @xmath7 of @xmath5 whenever @xmath6 and @xmath7 intersect .",
    "an alternative , more convenient point of view , is to take as vertex set the set of centers of the disks , denoted by @xmath8 , and connecting two points @xmath9 and @xmath10 of @xmath8 whenever the euclidean length @xmath11 is at most the diameter of a disk .",
    "the graph is unweighted . given a root @xmath12 , the task is to compute a shortest - path tree from @xmath13 in this graph .",
    "see figure  [ fig : example1 ] .     and",
    "middle : intersection graph of the disks .",
    "right : a shortest - path tree in the graph.,title=\"fig : \" ]   and @xmath3 .",
    "middle : intersection graph of the disks .",
    "right : a shortest - path tree in the graph.,title=\"fig : \" ]   and @xmath3 .",
    "middle : intersection graph of the disks .",
    "right : a shortest - path tree in the graph.,title=\"fig : \" ]    the second problem we consider is the _ minimum - separation problem_. the input is a set @xmath5 of @xmath1 unit disks in the plane and two points @xmath2 and @xmath3 not covered by any disks of @xmath5 .",
    "we say that @xmath5 _ separates _ @xmath2 and @xmath3 if each curve in the plane from @xmath2 to @xmath3 intersects some disk of @xmath5 .",
    "the task is to find the minimum cardinality subset of @xmath5 that separates @xmath2 and @xmath3 .",
    "see the left of figure  [ fig : example1 ] for an example of an instance .",
    "formally , we want to solve @xmath14    unit disks are the most standard model used for wireless sensor networks ; see for example  @xcite",
    ". often the model is referred as udg .",
    "this model provides an appropriate trade off between simplicity and accuracy .",
    "other models are more accurate , as for example discussed in  @xcite , but obtaining efficient algorithms for them is much more difficult .    while unit disks give a simple model , exploiting the geometric features of the model is often challenging .",
    "shortest paths in unit disk graphs are essential for routing and are a basic subroutine for several other more complex tasks . a somehow unexpected application of shortest paths in unit - disk graphs to boundary recognition",
    "is given in  @xcite .",
    "the minimum - separation problem and variants thereof have been considered in  @xcite .",
    "the problem is dual to the barrier - resilience problem considered in  @xcite .",
    "it is not obvious that the minimum - separation problem can be solved optimally in polynomial time , and the known algorithm for this uses as a subroutine shortest paths in unit disk graphs .",
    "thus , both problems considered in this paper are related and it is worth to consider them together .    [ [ our - contribution ] ] our contribution + + + + + + + + + + + + + + + +    we are aware of three algorithms to compute shortest - path trees in unit disk graphs in @xmath0 worst - case time : one by cabello and jeji  @xcite , one by chan and skrepetos  @xcite , and one efrat , itai and katz  @xcite . here",
    "we report on an implementation of a modification of the algorithm in  @xcite , and compare it against two obvious alternatives .",
    "the only complex ingredients in the algorithm is computing the delaunay triangulation and static nearest - neighbour queries , but efficient libraries are available for this .",
    "the algorithm of  @xcite would be substantially harder to implement and it has worse constants hidden in the @xmath15-notation .",
    "the algorithm of  @xcite for single source shortest paths is implementable and we expect that it would work good in practice .",
    "however , this last algorithm has been published only very recently , when we had completed our research .    as mentioned before , it is not obvious that the minimum - separation problem can be solved in polynomial time .",
    "in particular , the conference version  @xcite of  @xcite gave 2-approximation algorithm for the problem .",
    "cabello and giannopoulos  @xcite provide an exact algorithm that takes @xmath16 worst - case time and works for arbitrary shapes , not just disks . in this paper",
    "we improve this last algorithm to near - quadratic time for the special case of unit disks .",
    "the basic principle of the algorithm is the same , but several additional tools from computational geometry exploiting that we have unit disks have to be employed to reduce the worst - case running time .",
    "furthermore , we implement a variant of the new , near - quadratic - time algorithm and report on the experiments .",
    "[ [ assumptions ] ] assumptions + + + + + + + + + + +    we will assume that _ unit disk _ means that it has radius @xmath17 . up to scaling the input data , this choice is irrelevant .",
    "however , it is convenient for the exposition because then the disks intersect whenever the distance between their centers is @xmath18 . the implementation and",
    "the experiments also make this assumption .",
    "henceforth @xmath8 will be the set of centers of @xmath5 .",
    "all the computation will be concentrated on @xmath8 . in particular , we assume that @xmath8 is known .",
    "( for the shortest path problem , one could possibly consider weaker models based on adjacencies . )",
    "we will work with the graph @xmath19 with vertex set @xmath8 and an edge between two points @xmath20 whenever their euclidean distance @xmath11 is at most @xmath18 . in the notation",
    "we remove the dependency on @xmath8 and on the distance .",
    "thus we just use @xmath21 instead of @xmath19 . for simplicity of the theoretical exposition",
    "we will sometimes assume that @xmath21 is connected .",
    "it is trivial to adapt to the general case , for example treating each connected component separately .",
    "the implementation does not make this assumption .",
    "[ [ organization - of - the - paper ] ] organization of the paper + + + + + + + + + + + + + + + + + + + + + + + + +    in section  [ sec : algorithms ] we discuss the theoretical algorithms for both problems and their guarantees . in section  [ sec :",
    "implementation ] we discuss the implementations and the experimental results .",
    "we describe here the algorithm of cabello and jeji  @xcite to compute a shortest path tree in @xmath21 from a given root point @xmath12 .",
    "as it is usually done for shortest path algorithms , we use tables @xmath22 $ ] and @xmath23 $ ] indexed by the points of @xmath8 to record , for each point @xmath24 , the distance @xmath25 and the ancestor of @xmath9 in a shortest @xmath26-path .",
    "the pseudocode of the algorithm , which we call , is in figure  [ fig : bfs ] .",
    "we explain the intuition , taken almost verbatim from  @xcite .",
    "we start by computing the delaunay triangulation @xmath27 of @xmath8 .",
    "we then proceed in rounds for increasing values of @xmath28 , where at round @xmath28 we find the set @xmath29 of points at distance exactly @xmath28 in @xmath21 from the source @xmath13 .",
    "we start with @xmath30 . at round @xmath28",
    ", we use @xmath27 to grow a neighbourhood around the points of @xmath31 that contains @xmath32 .",
    "more precisely , we consider the points adjacent to @xmath31 in @xmath27 as candidate points for @xmath32 . for each candidate point that is found to lie in @xmath32 , we also take its adjacent vertices in @xmath27 as new candidates to be included in @xmath32 . for checking",
    "whether a candidate point @xmath9 lies in @xmath32 we use a data structure to find a nearest neighbour of @xmath9 in @xmath31 .",
    "if the distance from @xmath9 to its nearest neighbour @xmath33 in @xmath31 is smaller than @xmath18 , then the shortest path tree is extended by connecting @xmath9 to @xmath33 .",
    "cabello and jeji  @xcite show that the algorithm correctly computes the shortest - path tree from @xmath13 .",
    "if for nearest neighbors we use a data structure that , for @xmath1 points , has construction time @xmath34 and query time @xmath35 , and the delaunay triangulation is computed in @xmath36 time , then the algorithm takes @xmath37 time .",
    "standards tools in computational geometry imply that @xmath38 , @xmath39 and @xmath40 .",
    "this leads to the following .",
    "let @xmath8 be a set of @xmath1 points in the plane and let @xmath13 be a point from @xmath8 .",
    "in time @xmath41 we can compute a shortest path tree from @xmath13 in the unweighted graph @xmath19 .",
    "it is clear that , when computing the shortest path tree from several sources , we only need to compute the delaunay triangulation once .",
    "cabello and giannopoulos  @xcite present an algorithm for the minimum separation problem that in the worst - case runs in cubic - time .",
    "the algorithm has one feature that is both an advantage and a disadvantage : it works for any reasonable shapes , like segments or ellipses , and not just unit disks .",
    "this means that it is very generic , which is good , but it can not exploit any properties of unit disks .    in this section",
    "we are going to describe an algorithm to solve the minimum separation problem _ for unit disks _ in roughly quadratic time .",
    "the improvement is based on 3 ingredients .",
    "the first ingredient is a reinterpretation of the algorithm of  @xcite for disks . in the original algorithm",
    ", we had to select a point inside each shape .",
    "for disks there is a natural , obvious choice , the center of the disk .",
    "this allows for a simpler description and interpretation of the algorithm .",
    "we provide the description in section  [ sec : generic ]    the second ingredient is the efficient algorithm for shortest - path trees for the graph @xmath21 .",
    "the third ingredient is a compact treatment of the edges of @xmath21 using a few tools from computational geometry , namely range trees , point - line duality , and nearest - neighbour searches .",
    "this is explained in section  [ sec : quadratic ] .",
    "let us first introduce some notation . recall that @xmath2 and @xmath3 are the two points to separate .",
    "each walk @xmath42 in the graph @xmath43 defines a planar polygonal curve in the obvious way : we connect the points of @xmath8 with segments in the order given by @xmath42 .",
    "we will relax the notation slightly and denote also by @xmath42 the curve itself . for any spanning tree @xmath44 of @xmath21 and any edge @xmath45 , let @xmath46 be the unique cycle in @xmath47 . finally , for any walk in @xmath48 , let @xmath49 be the modulo @xmath50 value of the number of crossings between the segment @xmath51 and ( the curve defined by ) @xmath42 .",
    "the following property is implicit in  @xcite and explicit in  @xcite :    _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ let @xmath44 be any spanning tree of @xmath21 .",
    "the set of unit disks with centers in @xmath8 separate @xmath2 and @xmath3 if and only if there exists some edge @xmath45 such that @xmath52 .",
    "_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _    a consequence of this is that finding a minimum separation amounts to finding a shortest cycle in @xmath21 that crosses the segment @xmath51 an odd number of times .",
    "moreover , one can show that we can restrict our search to a very concrete family cycles , as follows .",
    "consider any optimal cycle @xmath53 and let @xmath54 be any vertex in @xmath53 .",
    "fix a shortest - path tree @xmath55 from @xmath54 in @xmath21 .",
    "when there are many , the choice of @xmath55 is irrelevant .",
    "then , the set of cycles @xmath56 contains an optimal solution .",
    "this follows from the co - called 3-path condition .",
    "we include here the key property that implies this claim and spell out a self - contained proof .",
    "see  @xcite for very similar ideas .",
    "let @xmath53 be a shortest cycle in @xmath21 that crosses the segment @xmath51 an odd number of times and let @xmath54 be any vertex in @xmath53 . fix a shortest - path tree @xmath55 from @xmath54 in @xmath21 .",
    "then , the set of cycles @xmath57 contains a shortest cycle of @xmath21 that crosses @xmath51 an odd number of times .    for any points @xmath9 and @xmath10 of @xmath8 , let @xmath58 $ ]",
    "be the unique path contained in @xmath55 from @xmath9 to @xmath10 .",
    "for every edge @xmath59 of @xmath21 , let @xmath60 be the closed walk that follows @xmath61 $ ] , then the edge @xmath59 , and finally @xmath62 $ ] .",
    "we then have the following relation modulo 2 : @xmath63)+ { \\mbox{\\tt cr}_2}(st , pq ) +                           { \\mbox{\\tt cr}_2}(st , t_{r^*}[q \\rightarrow r^ * ] ) \\bigr ) \\\\          & = ~ \\sum_{pq\\in w^ * } { \\mbox{\\tt cr}_2}(st , pq )   \\\\          & = ~ { \\mbox{\\tt cr}_2}(st , w^ * ) \\\\          & = ~ 1 .",
    "\\end{aligned}\\ ] ] in the second equality we have used that each path @xmath61 $ ] and its reverse @xmath64 $ ] appears an even number of times in the sum , and thus cancel out modulo 2 .",
    "parity implies that , for some edge @xmath65 of @xmath53 , we have @xmath66 .",
    "it must be that @xmath67 because for each edge @xmath59 of @xmath55 it holds @xmath68 .",
    "since @xmath69 because the path from @xmath54 to the lowest common ancestor of @xmath9 and @xmath10 in @xmath55 is counted twice on the left side of the equality , we have @xmath70 .    since @xmath54 is a vertex of @xmath53 and @xmath65",
    "is an edge of @xmath53 , the length of @xmath53 is at least the length of @xmath71 $ ] plus @xmath18 , for the edge @xmath65 , plus the length of @xmath72 $ ] .",
    "however , this second part is exactly the length of @xmath73 , which is at least the length of @xmath74 .",
    "we have shown that , for some edge @xmath75 , the cycle @xmath74 is not longer than @xmath53 and crosses @xmath51 an odd number of times .",
    "the result follows .",
    "since we do not know a vertex @xmath54 in the shortest cycle of @xmath21 , we just try all possible roots as candidates .",
    "( this leads to the option of having a randomized algorithm , by selecting some roots at random , for the case where the optimal solution is large . ) thus , for each vertex @xmath13 of @xmath21 , we fix a shortest - path tree @xmath76 from @xmath13 in @xmath21 , and then the size of the optimal solution is given by @xmath77    the values @xmath78 can be computed in constant amortized time per edge with some easy bookkeeping , as follows . consider a fixed tree @xmath76 . for each point",
    "@xmath24 we store @xmath79 $ ] as the parity of the number of crossings of the path in @xmath76 from @xmath13 to @xmath9 . when @xmath9 is not the root , the value @xmath79 $ ] can be computed from the value of its parent @xmath80 $ ] in @xmath76 using that @xmath79=n[\\pi[p]]+{\\mbox{\\tt cr}_2}(st , p\\pi[p])$ ] . in the algorithm",
    "we have written it this way ( lines 46 ) , but one can also compute the values at the time of computing the shortest path tree @xmath76 .",
    "let us look into the time complexity of the algorithm .",
    "for each point @xmath12 we have to compute a shortest - path tree in @xmath21 .",
    "this can be done in @xmath0 in our case , as discussed in section  [ sec : algorithm - sptree ] . then , for each edge @xmath59 of @xmath21 some constant amount of work is done .",
    "thus for each point @xmath13 we spend @xmath83 .",
    "this is cubic in the worst - case .",
    "we could get an improved running time if we can treat all the edges of @xmath21 compactly .",
    "this is what we explain next .",
    "from now on we will assume that @xmath2 is the origin and @xmath3 is the point @xmath84 , with @xmath85 .",
    "thus , the segment @xmath51 is vertical and @xmath3 is above @xmath2 .",
    "the implementation just assumes that @xmath51 is vertical with @xmath2 below @xmath3 .",
    "a simple rigid transformation can be applied to the input to get to this setting .",
    "we will use the data structure in the following lemma .",
    "it is essentially a multi - level data structure consisting of a 2-dimensional range tree @xmath44 with a data structure for nearest neighbour at each node of the secondary structure of @xmath44 .",
    "[ lem : block ] let @xmath86 be a set of @xmath1 points with positive @xmath87-coordinates .",
    "we can preprocess @xmath86 in @xmath88 time such that , for any query point @xmath89 with negative @xmath87-coordinate , we can decide in @xmath90 time whether the set @xmath91 is empty .",
    "the same data structure can handle queries to know whether the set @xmath92 is empty .",
    "we are going to use point - line duality and range trees .",
    "these are standard concepts in computational geometry ; see for example  ( * ? ? ?",
    "* chapters 5 and 8) .",
    "we assume that the reader is familiar with the topic .",
    "figure  [ fig : duality ] may be helpful in the following discussion .    .",
    "]    we use the following precise point - line duality : the non - vertical line @xmath93 is mapped to the point @xmath94 and vice - versa .",
    "let @xmath95 be the set of non - vertical lines .",
    "let @xmath96 be the line segment @xmath51 .",
    "let @xmath97 be the set of points dual to non - vertical lines that intersect @xmath96 .",
    "thus @xmath98 since we assumed that @xmath99 and @xmath100 , in the dual space @xmath97 is the horizontal slab @xmath101    for every point @xmath102 , outside the @xmath103-axis , let @xmath104 be the set of points dual to the lines through @xmath9 that intersect @xmath96 :",
    "@xmath105 in the dual space , @xmath106 is a segment with endpoints @xmath107 and @xmath108 , for some values @xmath109 and @xmath110 that are easily computable .",
    "namely , @xmath109 is the slope of the line through @xmath9 and @xmath111 while @xmath110 is the slope of the line through @xmath9 and @xmath84 .",
    "the segment @xmath106 is contained in the slab @xmath97 and has the endpoints on different boundaries of @xmath97 .",
    "finally , define the mapping @xmath112 .",
    "thus , @xmath113 maps points in the plane with nonzero @xmath87-coordinate to points in the plane .",
    "let @xmath89 be any point to the left of the @xmath103-axis and let @xmath114 be a point to the right of the @xmath103-axis .",
    "the segment @xmath115 intersects @xmath96 if and only if @xmath116 intersects @xmath117 .",
    "namely , an intersection of @xmath116 and @xmath117 is dual to the line through @xmath89 and @xmath114 .",
    "the segments @xmath116 and @xmath117 intersect if and only if the order of their endpoints on the boundaries of @xmath97 are reversed .",
    "moreover , since @xmath89 is to the left of the @xmath103-axis and @xmath114 is to the right of the @xmath103-axis , if the segment @xmath115 intersects @xmath96 , then @xmath118 , the slope of the line through @xmath89 and @xmath111 , is smaller than @xmath119 , the slope of the line through @xmath114 and @xmath111 .",
    "thus we have the following property : @xmath120 given a point @xmath89 to the left of the @xmath103 axis , the set of points @xmath121 with the property that @xmath115 intersects @xmath96 corresponds to the points @xmath114 with @xmath122 in the bottom - right quadrant with apex @xmath123 .",
    "we can use a @xmath50-dimensional range tree to store the point set @xmath124 , where each point @xmath121 is identified with its image @xmath122 .",
    "moreover , for each node @xmath125 in the secondary level of the range tree , we store a data structure for nearest neighbours for the canonical set @xmath126 of points that are stored below @xmath125 in the secondary structure .    for any query @xmath127 , the points @xmath121 such that @xmath115 intersects @xmath96 are obtained by querying the 2-dimensional range tree for the points of @xmath124 contained in the quadrant @xmath128",
    "this means that we get the set @xmath129 as the union of canonical subsets @xmath130 for @xmath131 nodes in the secondary levels of the 2-dimensional range tree . for each such canonical subset @xmath132",
    ", we query for the nearest neighbour of @xmath89 . if for some @xmath133 we get a nearest neighbour at distance at most @xmath18 from @xmath89 , then we know that @xmath91 is non - empty .",
    "otherwise the set is empty .",
    "the construction time of the 2-dimensional range tree is @xmath0 .",
    "each point appears in @xmath134 canonical subsets @xmath126 .",
    "this means that @xmath135 , where the sum iterates over all nodes @xmath125 in the secondary data structure . since for each node @xmath125 in the secondary level",
    "we build a data structure for nearest neighbours , which takes @xmath136 , the total construction time is @xmath137 . for the query time",
    ", the standard 2-dimensionsal range tree takes @xmath134 time to find the @xmath134 nodes @xmath138 such that @xmath139 and then we need additional @xmath140 time per node to query for a nearest neighbor .",
    "answering the queries for @xmath92 is done similarly ( and the same data structure works ) , we just have to query for 2 of the other quadrants .",
    "( the top - left quadrant of @xmath123 is always empty . )    inside the data structure of lemma  [ lem : block ] we are using a data structure for nearest neighbours with construction time @xmath0 and query time @xmath140 .",
    "if we would use another data structure for nearest neighbours with construction time @xmath34 and query time @xmath35 , then the construction time in lemma  [ lem : block ] becomes @xmath141 and the query time is @xmath142 .    from the theoretical perspective is would be more efficient to compute the union @xmath143 and make point location there .",
    "since the regions can not have many crossings , good asymptotic bounds can be obtained .",
    "however , such approach seems to be only of theoretical interest and the improvement on the overall result is rather marginal .",
    "* for some @xmath155 and some @xmath156 , we have @xmath157 , @xmath158 , @xmath159 , and @xmath59 does not cross @xmath51 ; * for some @xmath155 and some @xmath156 , we have @xmath157 , @xmath160 , @xmath159 , and @xmath59 crosses @xmath51 .",
    "each one of these cases can be solved efficiently .",
    "up to symmetry , we have the following cases :    * if we want to search the candidates @xmath161 ( that can not cross @xmath51 since they are on the same side of the @xmath103-axis ) , we first preprocess @xmath162 for nearest neighbours . then , for each point @xmath9 in @xmath149 , we query the data structure to find its nearest neighbour @xmath163 in @xmath149 .",
    "if for some @xmath9 we get that @xmath164 , then we have obtained an edge @xmath165 of @xmath21 with @xmath166 and @xmath167+\\dist[q_p]+1=i+i'+1 $ ] .",
    "if for each @xmath9 we have @xmath168 , then @xmath169 does not contain any edge of @xmath21 . the overall running time , if @xmath170 , is @xmath171 . *",
    "if we want to search the candidates @xmath172 such that @xmath59 crosses @xmath51 , we first preprocess @xmath173 as discussed in lemma  [ lem : block ] into a data structure . then , for each point @xmath174 we query the data structure ( for crossing @xmath51 ) .",
    "if we get some nonempty set , then there is an edge @xmath59 of @xmath21 with @xmath174 , @xmath175 , @xmath176 and @xmath167+\\dist[q]+1=i+i'+1 $ ] .",
    "otherwise , there is no edge @xmath177 that crosses @xmath51 . the overall running time , if @xmath178 , is @xmath179 . * if we want to search the candidates @xmath180 such that @xmath59 does not cross @xmath51 , we first preprocess @xmath173 as in lemma  [ lem : block ] into a data structure .",
    "then , for each point @xmath174 we query the data structure ( for not crossing @xmath51 ) .",
    "the remaining discussion is like in the previous item .",
    "we conclude that each of the cases can be done in @xmath179 worst - case time , where @xmath181 is the number of points involved in the case .",
    "iterating over all possible values @xmath28 , it is now easy to convert this into an algorithm that spends @xmath88 time per root @xmath13 .",
    "we summarize the result we have obtained .",
    "this improves for the case of unit disks the previous , generic algorithm .",
    "the minimum - separation problem for @xmath1 unit disks can be solved in @xmath182 time .",
    "let @xmath8 be the centers of the disks and , as before , consider the graph @xmath43",
    ". for each root @xmath12 we build the shortest - path tree and the sets @xmath183 for all @xmath28 in @xmath0 time .",
    "we then have at most @xmath1 iterations where , at iteration @xmath28 , we spend @xmath184 time . since the sets @xmath29 are disjoint , adding over @xmath28 , this means that we spend @xmath88 time per root @xmath12 .",
    "correctness follows from the foregoing discussion and the fact that the algorithm is computing the same as the generic algorithm .",
    "the resulting new algorithm is given in figure  [ fig : fullalgorithm ] .",
    "as before , the variable @xmath185 stores the length of the shortest cycle ( or actually rooted closed walk ) that we have found so far",
    ". we can start setting @xmath186 at start .",
    "if eventually we finish with the value @xmath186 , it means that there is no feasible solution for the separation problem .",
    "when we consider a root @xmath13 we are interested in closed walks rooted at @xmath13 and length at most @xmath185 .",
    "since any closed walk through a vertex of @xmath29 has length at least @xmath187 , we only need to consider indices @xmath28 such that @xmath188 .",
    "moreover ( and this is not described in the algorithm , but it is done in the implementation ) , we can consider first the pairs that give walks for length @xmath187 first , like for example @xmath189 and then the ones that give length @xmath190 , like for example @xmath191 .",
    "if we use this order , as soon as we find an edge in the while - loop , we can finish the work for the root @xmath13 , and move onto the next root .",
    "we have implemented the algorithms of section  [ sec : algorithms ] in c++ using cgal version  4.6.3  @xcite because it provides the more complex procedures we need : delaunay triangulations and voronoi diagrams  @xcite , range trees  @xcite , and nearest neighboours  @xcite .",
    "although in some cases we had to make small modifications , it was very helpful to have the cgal code available as a starting point .",
    "the coordinates of the points were cartesian doubles .",
    "data points were generated uniformly at random in the following polygonal domains : rectangles without holes , rectangles with a `` small '' rectangular hole , rectangles with a `` large '' rectangular hole , rectangles with 4 `` small '' rectangular holes , and rectangles with 4 `` large '' rectangular holes .",
    "the precise proportions of the domains with holes are in figures  [ fig : data_generation1 ] and  [ fig : data_generation2 ] .",
    "we generated 1k , 2k , 5k , 10k , 20k and 50k points for the cases where the outer rectangle has sizes @xmath192 , @xmath193 ,  , @xmath194 .",
    "the data was generated once and stored .",
    "for the minimum - separation problem @xmath2 was placed in the middle of a hole and @xmath3 vertically above @xmath2 in the outer face",
    ". some of these domains are not meaningful for the minimum - separation problem because the disks centered at the points cover @xmath2 .",
    "we have implemented the algorithm described in section  [ sec : algorithm - sptree ] . for the shortest - path tree we used the delaunay triangulation as provided by cgal .",
    "the data structure for nearest neighbour queries is a small extension of the one provided by  @xcite , which in turn is based on the delaunay triangulation . when making a query for nearest neighbour of @xmath9 in @xmath31 ( line 17 in figure  [ fig : bfs ] ) , we have the option to provide an extra parameter that acts as some sort of hint : if the nearest neighbour is near the hint , the algorithm is faster . for our implementation , we exploit this as follows .",
    "consider an iteration of the while loop ( lines 1322 ) .",
    "if the point @xmath10 is from @xmath31 then we use a point in a face of @xmath195 incident to @xmath10 as the hint for all the points @xmath9 considered in the iteration .",
    "if the point @xmath10 is not from @xmath31 , then we already know that @xmath196 and thus @xmath197\\in w_{i-1}$ ] .",
    "in this case we use use a point in a face of @xmath195 incident to @xmath197 $ ] as hint for all the points @xmath9 considered in the iteration .",
    "using such hints reduced the running time substantially , so we used this feature in the implementation .",
    "note that this improvement does not come with guarantees in the worst - case .",
    "in the tables we refer to this algorithm as .",
    "we compared the implementation with two obvious alternative algorithms to compute shortest - path trees .",
    "the first alternative is to build the graph @xmath43 explicitly .",
    "thus , for each pair of points @xmath198 we check whether their distance is at most one and add an edge to a graph data structure .",
    "we can then use breadth - first - search ( bfs ) from the given root @xmath13 .",
    "the preprocessing is quadratic , and the time spent to compute a shortest - path tree depends on the density of the graph @xmath21 . in the tables we refer to this algorithm as .",
    "the second alternative we consider is to use a unit - length grid .",
    "two points @xmath199 and @xmath200 are in the same grid cell if and only if @xmath201 .",
    "we store all the points of a grid cell @xmath202 in a list @xmath203 .",
    "the non - empty lists @xmath203 are stored in a dictionary , where the bottom - left corner of the cell is used as key . we can then run some sort of bfs using this structure .",
    "the list @xmath203 for a cell @xmath202 maintains the points that have not been visited by the bfs tree yet .",
    "when processing a point @xmath9 in a cell @xmath202 , we have to treat all the points in the lists of @xmath202 and its @xmath204 adjacent cells as candidate points . any point that is adjacent to @xmath9",
    "is then removed from the list of its cell .",
    "the preprocessing is linear , and the time spent to compute a shortest - path tree depends on the distribution of the points .",
    "it is easy to produce cases where the algorithm would need quadratic time .",
    "for each shortest - path tree we compute the lists and the dictionary anew .",
    "( this step is very fast in any case . ) in the tables we refer to this algorithm as .",
    "the measured times are in tables  [ table1][table5 ] . for sssp and bfs",
    "we report the preprocessing time that is independent of the source ( like building the delaunay triangulation or building the graph ) and the average time spent for a shortest - path tree over 50 choices of the root . for grid",
    "we just report the total running time ; assigning points to the grid cells and putting them into a dictionary is almost negligible .",
    "as it can be seen , the results for sssp are very much independent of the shape and , for dense point sets it outperforms the other algorithms .    while the algorithm sssp has guarantees in the worst case , for bfs and grid one can construct instances where the behavior will be substantially bad . for example , to the instance with 10k points in a rectangle of size @xmath205 with a small hole we added 1k points quite cluttered .",
    "the increase in time with respect to the original instance was for sssp 9,7% ( preprocessing ) and 13,6% ( one root ) , for bfs it was 21,9% ( preprocessing ) and 56,5% ( one root ) , and for grid it was 25% .",
    "l*6r * rectangle without holes * & + size rectangle & @xmath192 & @xmath193 & @xmath206 & @xmath205 & @xmath207 & @xmath194 + sssp preprocessing & 0.018 & 0.018 & 0.018 & 0.018 & 0.019 &",
    "0.021 + sssp average / root & 0.011 & 0.012 & 0.012 & 0.012 & 0.013 & 0.013 + bfs preprocessing & 18.70 & 13.46 & 12.03 & 11.40 & 11.32 & 11.13 + bfs average / root & 2.437 & 1.018 & 0.321 & 0.069 & 0.017 & 0.005 + grid & 1.309 & 1.130 & 0.474 & 0.160 & 0.060 & 0.035 + & + sssp preprocessing & 0.051 & 0.050 & 0.053 & 0.051 & 0.051 & 0.053 + sssp average / root & 0.034 & 0.037 & 0.037 & 0.036 & 0.035 & 0.036 + bfs preprocessing & @xmath2082min & 86.12 & 74.76 & 74.15 & 72.41 & 71.49 + bfs average / root & memory limit & 6.524 & 2.422 & 0.510 & 0.119 & 0.035 + grid & 6.297 & 7.125 & 3.188 & 0.923 & 0.301 & 0.139    l*6r * rectangle 1 small hole * & + size rectangle & @xmath192 & @xmath193 & @xmath206 & @xmath205 & @xmath207 & @xmath194 + sssp preprocessing & 0.011 & 0.012 & 0.009 & 0.010 & 0.010 & 0.009 + sssp average / root & 0.004 & 0.005 & 0.005 & 0.005 & 0.006 & 0.006 + bfs preprocessing & 3.724 & 3.033 & 2.890 & 2.826 & 2.874 & 2.841 + bfs average / root & 0.587 & 0.248 & 0.078 & 0.021 & 0.006 & 0.002 + grid & 0.258 & 0.313 & 0.119 & 0.049 & 0.022 & 0.015 + & + sssp preprocessing & 0.019 & 0.019 & 0.019 & 0.019 & 0.018 & 0.023 + sssp average / root & 0.010 & 0.012 & 0.011 & 0.012 & 0.013 & 0.013 + bfs preprocessing & 15.22 & 13.47 & 11.51 & 11.66 & 11.73 & 11.38 + bfs average / root & 2.402 & 1.045 & 0.369 & 0.088 & 0.023 & 0.006 + grid & 1.122 & 1.339 & 0.461 & 0.181 & 0.074 & 0.036    l*3r|*3r * rectangle 1 large hole * & & + size rectangle & @xmath205 & @xmath207 & @xmath194 & @xmath205 & @xmath207 & @xmath194 + sssp preprocessing & 0.004 & 0.005 & 0.005 & 0.009 & 0.010 & 0.010 + sssp average / root & 0.002 & 0.002 & 0.002 & 0.005 & 0.005 & 0.005 + bfs preprocessing & 0.751 & 0.767 & 0.742 & 2.783 & 3.175 & 2.804 + bfs average / root & 0.006 & 0.003 & 0.002 & 0.025 & 0.012 & 0.006 + grid & 0.018 & 0.012 & 0.008 & 0.053 & 0.032 & 0.022    l*3r|*3r * rectangle 4 small holes * & & + size rectangle & @xmath205 & @xmath207 & @xmath194 & @xmath205 & @xmath207 & @xmath194 + sssp preprocessing & 0.010 & 0.011 & 0.009 & 0.018 & 0.018 & 0.019 + sssp average / root & 0.005 & 0.006 & 0.007 & 0.012 & 0.013 & 0.014 + bfs preprocessing & 2.925 & 2.861 & 2.866 & 11.97 & 11.93 & 11.59 + bfs average / root & 0.020 & 0.006 & 0.002 & 0.085 & 0.022 & 0.006 + grid & 0.048 & 0.024 & 0.016 & 0.190 & 0.070 & 0.040    l*3r|*3r * rectangle 4 large holes",
    "* & & + size rectangle & @xmath205 & @xmath207 & @xmath194 & @xmath205 & @xmath207 & @xmath194 + sssp preprocessing & 0.004 & 0.005 & 0.005 & 0.013 & 0.015 & 0.009 + sssp average / root & 0.003 & 0.003 & 0.003 & 0.006 & 0.005 & 0.005 + bfs preprocessing & 0.715 & 0.734 & 0.717 & 2.897 & 2.910 & 3.182 + bfs average / root & 0.005 & 0.002 & 0.001 & 0.019 & 0.008 & 0.004 + grid & 0.013 & 0.010 & 0.008 & 0.045 & 0.026 & 0.020      we have implemented the algorithm and the new algorithm based on a compact treatment of the edges .",
    "the shortest - path trees are constructed using the algorithm of section  [ sec : algorithm - sptree ] .",
    "the table @xmath146 $ ] and the sets @xmath209 are constructed at the time of computing the shortest - path tree .    in the data structure of lemma  [ lem",
    ": block ] , we do use a 2-dimensional tree as the primary structure , making some modifications of  @xcite . in the secondary structure ,",
    "for nearest neighbour , instead of using voronoi diagrams , we used a small modification of the @xmath210-trees implemented in  @xcite . in some preliminary experiments this seemed to be a better choice . in our modification , we make a range search query for points at distance at most @xmath18 , and finish the search whenever we get the first point .",
    "in the new algorithm , before calling to the function to candidates pairs , like for example @xmath211 , we test that both sets are non - empty . this simple test reduced the time by 30 - 50% in our test cases .    besides the new algorithm we also implemented the generic algorithm of section  [ sec : generic ] .",
    "the measured times are in tables  [ table6][table7 ] . for the case of @xmath212 holes we always put @xmath3 above the rectangle and @xmath2 in one hole .",
    "it seems that the choice of the hole does not substantially affect the experimental time in our setting .",
    "to show that our new algorithm can work substantially faster than the generic algorithm , we created an instance where we expect so .",
    "for this we take the rectangle of size @xmath205 with one small hole , the original 2k points , and add 500 extra points on a vertical strip of width @xmath18 within the domain and symmetric with respect to segment @xmath51 .",
    "the generic algorithm took 435 seconds and the new algorithm took 94 seconds .",
    "if instead we add 1k points , the generic algorithm takes more than 15 minutes and the new algorithm takes 173 seconds .",
    "l*4r * rectangle 1 small hole * & + size rectangle & @xmath193 & @xmath206 & @xmath205 & @xmath207 + new separation algorithm & 41 & 41 & 32 & 30 + generic algorithm & 730 & 215 & 67 & 30 + cycle length & 9 & 20 & 46 & 126    l*3r|*3r * rectangle 4 holes * & & + size rectangle & @xmath205 & @xmath207 & @xmath194 & @xmath205 & @xmath207 & @xmath194 + new separation algorithm & 20 & 25 & 5.6 & 233 & 259 & 240 + generic algorithm & 62 & 25 & 6.4 & 875 & 428 & 248 + cycle length & 24 & 61 & 201 & 29 & 77 & 342"
  ],
  "abstract_text": [
    "<S> we present an implementation of a recent algorithm to compute shortest - path trees in unit disk graphs in @xmath0 worst - case time , where @xmath1 is the number of disks .    in the minimum - separation problem , we are given @xmath1 unit disks and two points @xmath2 and @xmath3 , not contained in any of the disks , and we want to compute the minimum number of disks one needs to retain so that any curve connecting @xmath2 to @xmath3 intersects some of the retained disks . </S>",
    "<S> we present a new algorithm solving this problem in @xmath4 worst - case time and its implementation . </S>"
  ]
}