{
  "article_text": [
    "bayes s rule provides a simple and fundamental mechanism for updating a probability distribution in the light of new data  @xcite .",
    "the rule takes its simplest form for a finite sample space , @xmath1 , where the elements @xmath2 can be identified with the atomic events , or _",
    "let @xmath3 be the prior probability distribution , and assume some piece of data , @xmath4 , is observed .",
    "if @xmath5 is the conditional probability of @xmath4 , given @xmath6 , bayesian updating consists of replacing the prior with the posterior distribution , @xmath7 , where @xmath8    to simplify the notation , we assume from now on that the set of hypotheses is of the form @xmath9 for some positive integer @xmath0 . for @xmath2 , let @xmath10 denote the computational basis states of a register of @xmath0 qubits .",
    "the state @xmath11 provides an encoding of the prior on the quantum register .",
    "even though the size of the sample space grows exponentially with the number of qubits , @xmath0 , there exists an interesting class of priors for which @xmath12 can be prepared efficiently , in the sense that the required computational resources grow only polynomially with @xmath0 @xcite .    to formulate the problem of bayesian updating for a prior encoded on a quantum register",
    ", we make the assumption that we have a classical algorithm that computes , as a function of @xmath6 , the conditional probability @xmath5 for the observed data @xmath4 .",
    "given this classical algorithm , the goal of bayesian updating is then to prepare the register in the state @xmath13 given by eq .",
    "( [ conditionalpd ] ) . if the prior is given to us in the form of a single copy of the state @xmath12 , our problem is equivalent to finding a quantum operation , @xmath14 , that maps any prior state of the form  ( [ priorstate ] ) into the corresponding posterior state of the form  ( [ posteriorstate ] ) , @xmath15 it is easy to see that @xmath14 can not in general be a trace - preserving map .",
    "for example , consider the two prior states @xmath16 where @xmath17 is a constant determined by normalization .",
    "although the prior states ( [ examplepriors ] ) are nonorthogonal , we obtain mutually orthogonal posterior states latexmath:[\\[|\\psi_{\\rm posterior}^1\\rangle = m_d|\\psi_{\\rm prior}^1\\rangle=|1\\rangle\\;,\\;\\;\\ ;    which implies that @xmath14 is trace - decreasing .",
    "bayesian updating of a single copy of @xmath12 is therefore generally probabilistic .",
    "section ii of this paper discusses probabilistic bayesian updating .",
    "a deterministic updating scheme is possible , however , if the prior is given in the form of a unitary quantum circuit that maps a standard state , assumed for simplicity to be the computational basis state @xmath19 , to @xmath20 .",
    "deterministic updating is the topic of section iii .",
    "as we have shown above there is in general no trace preserving quantum operation that can transform all prior states into the corresponding posterior state . to realize probabilistic bayesian updating",
    ", we proceed as follows .",
    "define @xmath21 where @xmath22 is a constant and @xmath23 is a set containing the support of the prior probability distribution .",
    "we see that @xmath24 for sufficiently small @xmath25 , see eq .",
    "( [ boundonc ] ) below , one can view @xmath26 as an element of a trace preserving quantum operation @xmath27 defined , for arbitrary @xmath28 , by @xmath29 where @xmath30 this decomposition shows that the operation @xmath27 can be realized as a measurement with outcomes @xmath31 , where each outcome @xmath32 happens with probability @xmath33 and the corresponding conditional density matrix is @xmath34 . substituting @xmath35",
    "we see that the measurement outcome @xmath36 corresponds to successful bayesian updating .",
    "this happens with probability @xmath37 in order to obtain a bound on @xmath22 , we note that @xmath38 using the positivity of @xmath39 , we find @xmath40 for any vector @xmath41 .",
    "now let @xmath42 be such that @xmath43 . since the above condition is valid for any @xmath41 , one can choose @xmath44 and obtain @xmath45 together with eq .",
    "( [ p0 ] ) this gives an upper bound on the success probability of bayesian updating @xmath46 in the next subsection we describe an explicit algorithm that achieves this bound .",
    "the operation @xmath27 can be realized as a modification of a procedure proposed by rudolph  @xcite as follows .",
    "first we prepare the product of the prior state and an auxiliary qubit state , @xmath47 .",
    "then , using the classical algorithm for computing @xmath5 , one can construct a quantum circuit @xmath48 that performs a conditional rotation of an auxiliary qubit so that @xmath49 where @xmath50 and @xmath51 is a constant",
    ". then measuring the auxiliary qubit we obtain the desired state @xmath52 with probability @xmath53 looking at eqs.([u_d ] ) and ( [ a_1 ] ) we can set @xmath54 . with this setting",
    ", @xmath55 achieves the theoretical bound on the success probability , eq.([successprobabilitybound ] ) .    in the above algorithm",
    ", one can safely achieve the maximal success probability only if the knowledge of the value of @xmath56 is available .",
    "it is relevant to mention here that the lack of such knowledge does not prevent us from using the above algorithm , since we can always use the trivial setting @xmath57 .",
    "the price to pay is a smaller success probability .",
    "an intermediate situation occurs if a nontrivial upper bound on @xmath5 is known , i.e. , a constant @xmath58 such that @xmath59 .",
    "one can then set @xmath60 , which improves the success probability compared to the trivial setting .",
    "let @xmath61 be an upper bound on @xmath56 .",
    "imagine that at the beginning we do not have enough information about @xmath5 and @xmath62 to calculate a nontrivial value for @xmath61 .",
    "in other words , we have to assume that @xmath63 .",
    "imagine also that we expect to acquire a better bound @xmath64 in the future .",
    "we will now address the following question : can we run the probabilistic algorithm of sec .  [",
    "subsec : examplealgorithm ] first with the trivial bound @xmath63 , and later with the improved bound @xmath65 , without reducing the overall success probability that can be achieved by running the algorithm once with the bound @xmath65 ?",
    "we will find that this is indeed the case .",
    "this result remains true for a sequence of bounds , @xmath66 .",
    "below we describe an iterative version of the above algorithm that makes use of better bounds as they become available .",
    "consider the measurement part of the algorithm of sec .",
    "[ subsec : examplealgorithm ] .",
    "if the measurement fails , which happens with probability @xmath67 , we end up with the state @xmath68 where we might have set @xmath69 to maximize @xmath55 . since we know the exact form of @xmath70 we may attempt to achieve our original goal by performing a transformation @xmath71 where we set @xmath72 and @xmath73 is a constant .",
    "first of all , it is important to note that this procedure should not be attempted when @xmath74 was set to @xmath75 , and @xmath61 is still the best available bound .",
    "this is because in the worst case there will be at least one hypotheses @xmath42 which is present in the sum eq.([second_attempt ] ) with @xmath76 and @xmath77 .",
    "it follows that the above procedure should only be applied if a better bound @xmath78 became available ( or when @xmath79 ) . in this case ,",
    "measurement of the auxiliary qubit yields the desired state @xmath52 with probability @xmath80 alternatively , with probability @xmath81 , we may end up with the state @xmath82 this state is similar in structure to the state @xmath70 so we may try to recover in the same way by performing the transformation @xmath83 followed by the measurements of the auxiliary qubit in complete analogy with our earlier analysis . by continuing this procedure",
    "we obtain the sequence of success probabilities @xmath84 together with the coefficients @xmath85 and @xmath86 .",
    "we have @xmath87 and @xmath88 where @xmath89 , @xmath90 and @xmath91 the constants @xmath92 are the only free parameters in this algorithm .",
    "as we have seen in the case @xmath93 , the constants @xmath92 can not be chosen freely , and the optimal choice for them depends on the sequence @xmath94 . from eq.([akbk ] ) we obtain @xmath95 and therefore @xmath96 this condition must be satisfied for all @xmath6 in the support of the prior and so we have @xmath97 from eqs .",
    "( [ baverage ] ) and ( [ bfromcs ] ) we compute @xmath98 together with eq .",
    "( [ p_k1 ] ) , this implies @xmath99 the probability that the algorithm is not successful after the @xmath0th stage is given by @xmath100 which gives the corresponding success probability @xmath101 where we used the inequality  ( [ boundoncs ] ) .",
    "we see that the theoretical bound for the overall success probability of transforming one copy of the prior state @xmath12 into one copy of the posterior state @xmath102 is achieved for as long as at some stage @xmath0 of the algorithm we have @xmath103 given the sequence of upper bounds @xmath104 , and assuming that the information in the first @xmath105 of them was already used without success , the optimal value @xmath106 for the next iteration of the algorithm , which takes into account the bound @xmath107 , can be calculated as @xmath108",
    "in this section we will assume that the prior is given in the form of a unitary quantum circuit , @xmath109 , that maps the computational basis state @xmath19 , to the prior state .",
    "apart from the constraint @xmath110 , @xmath109 is arbitrary .",
    "we first give an algorithm for the special case of hypothesis elimination and then show how to extend it to two - valued and more general models .",
    "imagine the situation where each piece of data @xmath4 partitions the set of hypotheses @xmath1 into two subsets : @xmath111 containing all hypotheses that are consistent with @xmath4 , and @xmath112 containing all hypotheses that are rejected by the data @xmath4 .",
    "this leads to a special case of bayesian updating where @xmath5 takes only two different values  @xcite , @xmath113 where @xmath114 is the number of hypotheses that are consistent with the data @xmath4 .",
    "the posterior state  ( [ posteriorstate ] ) takes the simple form @xmath115 where @xmath116 is the normalization factor .    using the given classical algorithm for computing @xmath5",
    ", we define a quantum oracle , @xmath117 , as @xmath118 furthermore , let @xmath119 be a conditional phase shift defined by @xmath120 these operations are combined with @xmath109 to form an operation , @xmath121 , defined by @xcite @xmath122 the circuit for @xmath121 is the basic block of the quantum algorithm to prepare @xmath102",
    ".    it will be convenient to rewrite the prior state  ( [ priorstate ] ) in the form @xmath123 where @xmath124 @xmath125 and @xmath126 the last equation shows that knowing the total prior probability of the hypotheses that are consistent with the data @xmath4 is equivalent to knowing the value of @xmath127 .",
    "it can now be shown that repeated application of the circuit @xmath121 takes @xmath12 through the sequence of states @xmath128 the number of times , @xmath129 , of applications of @xmath121 that achieve the required transformation , @xmath130 is therefore @xmath131 if @xmath129 is not an integer , there are two possibilities .",
    "either one uses the closest integer approximation to @xmath129 and includes the effect of the noninteger part in the fidelity analysis ( see below ) , or one follows @xmath132 applications of @xmath121 with one application of a modified version of @xmath121 where phases are shifted by less than @xmath133 in both @xmath117 and @xmath119 @xcite .    in order to compute the number of iterations , @xmath129 , the value of @xmath127 must be known . to obtain @xmath127 ,",
    "a version of the standard phase estimation algorithm @xcite can be used as illustrated in figure [ figure1 ] .    to calculate the effect of an error in the value of @xmath127 on the fidelity of the bayesian transformation  ( [ tbayesian ] )",
    ", we assume that there is an upper bound on the absolute error , @xmath134 where @xmath135 denotes the approximate value . with the definition @xmath136 ,",
    "the fidelity is @xmath137 substituting @xmath138 and using the relation @xmath139 we obtain @xmath140      a straightforward generalization of hypothesis elimination is provided by a two - valued conditional probability of the form @xmath141 where @xmath142 are constants , and @xmath111 is the set of hypotheses favored by the data @xmath4 . the _ suppression coefficient _",
    "@xmath143 measures how much hypotheses in @xmath111 are favored by the data . as before , the prior state can be written in the form , eq.([prior ] ) , @xmath144 and for the posterior state we calculate @xmath145 normalization of the posterior state implies that @xmath146 defining @xmath147 so that @xmath148 the number of iterations @xmath129 necessary to transform @xmath12 into @xmath149 can then be calculated as @xmath150 it follows that knowledge of @xmath127 and the suppression coefficient @xmath151 is sufficient for a deterministic implementation of bayesian updating with the conditional distribution  ( [ singlestepmodel ] ) .",
    "as before , the value of @xmath127 can be obtained using the algorithm of figure  [ figure1 ] , and the same fidelity bound ( [ fidelitybound ] ) can be used .      in this section",
    "we show how to generalize the above algorithm to the case of bayesian updating with a general model , i.e. , a general conditional distribution @xmath5 .",
    "the main idea is to represent @xmath5 as a product of two - valued models with known suppression coefficients .",
    "bayesian updating with @xmath5 can then be viewed as a sequence of bayesian updatings for the two - valued models .",
    "let @xmath152 be the coefficients in the binary expansion of @xmath153 , @xmath154 this allows us to express @xmath5 as a product , @xmath155{2^{c_k(h)}}\\,.\\ ] ] let @xmath156 be the set of hypotheses @xmath157 for which @xmath158 .",
    "the @xmath32th term in this product is either @xmath159{2}$ ] or @xmath36 depending on whether @xmath6 is in @xmath156 or not .",
    "bayesian updating with the conditional probability @xmath5 can therefore be viewed as a sequence of stages corresponding to the acquisition of data from the sequence @xmath160 . at each stage ,",
    "an updating step for a two - valued model as described in the previous section is carried out .",
    "we would like to thank terry rudolph for helpful discussions .",
    "this work was supported in part by the european union ist - fet project ediqip ."
  ],
  "abstract_text": [
    "<S> we investigate the problem of bayesian updating of a probability distribution encoded in the quantum state of @xmath0 qubits . </S>",
    "<S> the updating procedure takes the form of a quantum algorithm that prepares the quantum register in the state representing the posterior distribution . depending on how the prior distribution is given , we describe two implementations , one probabilistic and one deterministic , of such an algorithm in the standard model of a quantum computer . </S>"
  ]
}