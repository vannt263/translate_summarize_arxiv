{
  "article_text": [
    "in general parallelization is a subject to be avoided ( as nicely described by p.  hflich , this volume ) , however in order to take advantage of the enormous computing power and vast memory sizes of modern parallel supercomputers , allowing both much faster model calculations as well as more detailed models , we have implemented a parallel version of the general model atmosphere code phoenix ( hauschildt & baron 1999 and references therein ) .",
    "since the code uses a modular design , we have implemented different parallelization strategies for different modules in order to maximize the total parallel speed - up of the code .",
    "our implementation allows us to change the load distribution onto different processor elements ( pes ) both via input files and dynamically during a model run , which gives a high degree of flexibility to optimize the performance on a number of different machines and for a number of different model parameters .    since we have both large cpu and memory requirements we have implemented the parallel version of the code on using the mpi  message passing library ( mpi forum 1995 ) .",
    "we have chosen to work with the mpi  message passing interface , since it is both portable ( public domain implementations of mpi are readily available cf .",
    "gropp et  al .",
    "1996 ) , running on dedicated parallel machines and heterogeneous workstation clusters and it is available for both distributed and shared memory architectures . for our application , the distributed memory model is in fact easier to code than a shared memory model , since then we do not have to worry about locks and synchronization , etc .  on _ small _ scales and",
    "we , in addition , retain full control over interprocess communication .",
    "this is especially clear once one realizes that it is fine to execute the same code on many pes as long as it is not too cpu intensive , and avoids costly communication .",
    "we have added a few simple openmp directives to our code , but do not discuss smp parallelization further here .",
    "an alternative to an implementation with mpi is an implementation using high performance fortran ( hpf ) directives ( in fact , both can co - exist to improve performance ) .",
    "however , the process of automatic parallelization guided by the hpf directives is presently not yet generating optimal results because the compiler technology is still very new .",
    "hpf is also more suited for problems that are purely data - parallel ( simd problems ) and would not benefit much from a mimd approach .",
    "an optimal hpf implementation of phoenix would also require a significant number of code changes in order to explicitly instruct the compiler not to generate too many communication requests , which would slow down the code significantly .",
    "the mpi implementation requires only the addition of a few explicit communication requests , which can be done with a small number of library calls .",
    "the co - moving frame radiative transfer equation for spherically symmetric flows can be found in e.g. , mihalas & mihalas ( 1984 ) .",
    "the equation of radiative transfer is a integro - differential equation , since the differential operator on the left hand side acts on the specific intensity @xmath0 , but the right hand side contains the emissivity @xmath1 which in turn contains @xmath2 , the zeroth angular moment of @xmath0 : @xmath3 and @xmath4 where @xmath5 is the source function , @xmath6 is the absorption opacity , and @xmath7 is the scattering opacity . with the assumption of time - independence @xmath8 and a monotonic velocity field",
    "the transfer equation becomes a boundary - value problem in the spatial coordinate and an initial value problem in the frequency or wavelength coordinate .",
    "the equation can be written in operator form as : @xmath9 where @xmath10 is the lambda - operator .",
    "we use a modified version of the method discussed in hauschildt ( 1992 ) for the numerical solution of the special relativistic radiative transfer equation ( rte ) at every wavelength point ( see also hauschildt , strzer , & baron 1994 and hauschildt & baron 1999 ) .",
    "this iterative scheme is based on the operator splitting approach .",
    "the rte is written in its characteristic form and the formal solution along the characteristics is done using a piecewise parabolic integration ( ppm , this is the `` short characteristic method '' olson & kunasz 1987 ) .",
    "we use the exact band - matrix subset of the discretized @xmath10-operator as the ` approximate @xmath10-operator ' ( alo ) in the operator splitting iteration scheme ( see hauschildt et  al .",
    "this gives very good convergence and high speed - up when compared to diagonal alo s .",
    "the serial radiative transfer code has been optimized for superscalar and vector computers and is numerically very efficient .",
    "it is therefore crucial to optimize the ratio of communication to computation in the parallel implementation of the radiative transfer method . in terms of cpu time ,",
    "the most costly parts of the radiative transfer calculation are the setup of the ppm interpolation coefficients and the formal solutions ( which have to be performed in every iteration ) .",
    "the construction of a tri - diagonal alo requires about the same cpu time as a single formal solution of the rte and is thus not a very important contributor to the total cpu time required to solve the rte at every given wavelength point .    in principle",
    ", the computation of the ppm coefficients does not require any communication and thus could be distributed arbitrarily between the pes",
    ". however , the formal solution is recursive along each characteristic . within the formal solution , communication",
    "is only required during the computation of the mean intensities , @xmath11 , as they involve integrals over the angle @xmath12 at every radial point .",
    "thus , a straightforward and efficient way to parallelize the radiative transfer calculation is to distribute sets of characteristics onto different pes . as auer ( this volume )",
    "has emphasized , the solution of the radiative transfer equation is independent along a ray and in the sense that we treat each characteristic separately for the solution to the rte , this parallelization step is one of domain decomposition .",
    "figure  1 illustrates the characteristics for a typical supernova model calculation .    within one iteration step , the current values of the mean intensities need to be broadcast to all radiative transfer pes and the new contributions of every radiative transfer pe to the mean intensities at every radius",
    "must be sent to the master pe .",
    "the master radiative transfer pe then computes and broadcasts an updated @xmath11 vector using the operator splitting scheme , the next iteration begins , and the process continues until the solution is converged to the required accuracy .",
    "the setup , i.e. , the computation of the ppm interpolation coefficients and the construction of the alo , can be parallelized using the same method and pe distribution .",
    "the communication overhead for the setup is roughly equal to the communication required for a single iteration .    an important point to consider is the load balancing between the n@xmath13 radiative transfer pes .",
    "the workload to compute the formal solution along each characteristic is proportional to the number of intersection points of the characteristic with the concentric spherical shells of the radial grid ( the ` number of points ' along each characteristic ) .",
    "therefore , if the total number of points is @xmath14 , the optimum solution would be to let each radiative transfer pe work on @xmath15 points .",
    "in general , this optimum can not be reached exactly because it would require splitting characteristics between pes ( which involves both communication and synchronization ) .",
    "we therefore compromise by distributing the characteristics to the radiative transfer pes so that the total number of points that are calculated by each pe is _ roughly _ the same and that every pe works on a different set of characteristics .",
    "the contribution of spectral lines by both atoms and molecules is calculated in phoenix  by direct summation of all contributing lines .",
    "each line profile is computed individually at every radial point for each line within a search window ( typically , a few hundred to few thousand doppler widths or about @xmath16 ) .",
    "this method is more accurate than methods that rely on pre - computed line opacity tables ( the `` opacity sampling method '' ) or methods based on distribution functions ( the `` opacity distribution function ( odf ) method '' ) .    in typical model calculations",
    "we find that about 1,000 to 10,000 spectral lines contribute to the line opacity ( e.g. , in m dwarf model calculations ) at any wavelength point , requiring a large number of individual voigt profiles at every wavelength point .",
    "the subroutines for these computations can easily be vectorized and we use a block algorithm with caches and direct access scratch files for the line data to minimize storage requirements .",
    "a block is the number of lines stored in active memory , and the cache is the total number of blocks stored in memory . when the memory size is exceeded , the blocks are written to direct access files on disk .",
    "thus the number of lines that can be included is not limited by ram , but rather by disk space and the cost of i / o .",
    "this approach is computationally efficient because it provides high data and code locality and thus minimizes cache / tlb misses and page faults .",
    "there are several obvious ways to parallelize the line opacity calculations .",
    "the first method is to let each pe compute the opacity at @xmath17 radial points , the second is to let each pe work on a different subset of spectral lines within each search window .",
    "a third way , related to the second method , is to use completely different sets of lines for each pe ( i.e. , use a global workload split between the pes in contrast to a local split in the second method ) .",
    "we discuss the advantages and disadvantages of these three methods .",
    "all three methods require only a very small amount of communication , namely a gather of all results to the master pe with an mpi_reduce library call .    the first and second methods , distributing sets of radial points or sets of lines within the local ( wavelength dependent ) search window over the pes , respectively , are very simple to implement .",
    "they can easily be combined to optimize their performance : if for any wavelength point the number of depth points is larger than the number of lines within the local search window , then it is more effective to run this wavelength point parallel with respect to the radial points , otherwise it is better to parallelize with respect to the lines within the local window .",
    "it is trivial to add logic to decide the optimum method for every wavelength point individually .",
    "this optimizes overall performance with negligible overhead .",
    "the speed - up for this method of parallelization is very close to the optimum value if the total number of blocks of the blocking algorithm is relatively small ( @xmath18 ) .",
    "however , if the total number of line blocks is larger ( typically , about 10 to 20 blocks are used ) , the overhead due to the read operations for the block scratch files becomes noticeable and can reach 20% or more of the total wall - clock time .",
    "this is due to the fact that the ` local parallelization ' required that each pe working on the line opacities needs to read every line block , thus increasing the i / o time and load to the i / o subsystem by the number of pes themselves .",
    "we discuss i / o parallelization in ",
    "our method for iteratively solving the nlte radiative transfer and rate equations with an operator splitting method are discussed in detail in hauschildt ( 1993 ) , and in hauschildt & baron ( 1995 , 1999 ) , therefore , we summarize our approach here only a briefly .",
    "the method uses a `` rate - operator '' formalism that extends the approach of rybicki & hummer ( 1991 ) to the general case of multi - level nlte calculations with overlapping lines and continua , i.e , `` pre - conditioning '' .",
    "we use an `` approximate rate - operator '' that is constructed using the exact elements of the discretized @xmath10-matrix ( these are constructed in the radiative transfer calculation for every wavelength point ) . this approximate rate - operator can be either diagonal or tri - diagonal .",
    "the method gives good convergence for a wide range of applications and is very stable .",
    "it has the additional advantage that it can handle very large model atoms , e.g. , we use up to 11000 levels for nlte model atoms in regular model calculations ( hauschildt et  al .",
    "1996 , baron et  al .",
    "1996 , short et  al .",
    "1999 ) .    parallelizing the nlte calculations",
    "involves parallelizing three different sections : the nlte opacities ; the rates ; and the solution of the rate equations . in the following discussion , we consider only a diagonal approximate rate - operator for simplicity . in this case",
    ", the computation of the rates and the solution of the rate equations as well as the nlte opacity calculations can simply be distributed onto a set of pes without any communication ( besides the gathering of the data at the end of the iteration ) .",
    "this provides a very simple way of achieving parallelism and minimizes the total communication overhead .",
    "the generalization to a tridiagonal approximate rate - operator is in principle straightforward , and involves only communication at the boundaries between two adjacent pes",
    ".    it would be possible to use the other two methods that we discussed in the section on the lte line opacities , namely local and global set of lines distributed to different pes .",
    "however , both would involve an enormous amount of communication between the nlte pes because each nlte transition can be coupled to any other nlte transition .",
    "these couplings require that a pe working on any nlte transition have the required data to incorporate the coupling correctly .",
    "although this only applies to the pes that work on the nlte rates , it would require both communication of each nlte opacity task with each other ( to prepare the necessary data ) and communication from the nlte opacity pes to the nlte rate pes .",
    "this could mean that several mb data would have to be transferred between pes at each wavelength point , which is prohibitive with current communication devices .",
    "we have implemented the parallelization of the nlte calculations by distributing the set of radial points on different pes . in order to minimize communication , we also ` pair ' nlte pes so that each pe works on nlte opacities , rates , and rate equations for a given set of radial points .",
    "this means that the communication at every wavelength point involves only gathering the nlte opacity data to the radiative transfer pes and the broadcast of the result of the radiative transfer calculations ( i.e. , the alo and the @xmath11 s ) to the pes computing the nlte rates .",
    "the overhead for these operations is negligible but it involves synchronization ( the rates can only be computed after the results of the radiative transfer are known , similarly , the radiative transfer pes have to wait until the nlte opacities have been computed ) . therefore , a good balance between the radiative transfer tasks and the nlte tasks is important to minimize waiting .",
    "the rate equation calculations parallelize trivially over the layers and involve no communication if the diagonal approximate rate - operator is used . after the new solution has been computed , the data must be gathered and broadcast to _ all _ pes , the time for this operation is negligible because it is required only once per model iteration .",
    "an important problem arises from the fact that the time spent in the nlte routines is not dominated by the floating point operations ( both the number and placement of floating point operation were optimized in the serial version of the code ) but by _ memory access _ , in particular for the nlte rate construction .",
    "although the parallel version accesses a much smaller number of storage cells ( which naturally reduces the wall - clock time ) , effects like cache and tlb misses and page faults contribute significantly to the total wall - clock time .",
    "all of these can be reduced by using fortran-90 specific constructs in the following way : we have replaced the static allocation of the arrays that store the profiles , rates etc .  used in the nlte calculations ( done with common blocks ) with a fortran-90 module and explicit allocation ( using allocate and save ) of these arrays at the start of the model run .",
    "this allows us to tailor the size of the arrays to fit exactly the number of radial points handled by each individual pe .",
    "this reduces both the storage requirements of the code on every pe and , more importantly , it minimizes cache / tlb misses and page faults .",
    "in addition , it allows much larger calculations to be performed because the ram , virtual memory , and scratch disk space of every pe can be fully utilized , thus effectively increasing the size of the possible calculation by the number of pes .",
    "we find that the use of adapted array sizes significantly improves the overall performance , even for a small number of processes .",
    "the scaling with more pes has also improved considerably .",
    "however , the overhead of loops can not be reduced and thus the speed - up can not increase significantly if more pes are used .",
    "we have verified with a simple test program which only included one of the loops important for the radiative rate computation that this is indeed the case .",
    "therefore , we conclude that further improvements can not be obtained at the fortran-90 source level but would require either re - coding of routines in assembly language ( which is not practical ) or improvements of the compiler / linker / library system .",
    "we note that these performance changes are very system dependent .",
    "so far , ( see also hauschildt , baron , & allard 1997 ) we have described our method for parallelizing three separate modules : ( 1 ) the radiative transfer calculation itself , where we divide up the characteristic rays among processing elements and use an mpi_reduce to send the @xmath2 to all the radiative transfer and nlte rate computation tasks ; ( 2 ) the line opacity which requires the calculation of about 10,000 voigt profiles per wavelength point at each radial grid point , here we split the work amongst the processors both by radial grid point and by dividing up the individual lines to be calculated among the processors ; and ( 3 ) the nlte calculations .",
    "the nlte calculations involve three separate parts : the calculation of the nlte opacities , the calculation of the rates at each wavelength point , and the solution of the nlte rate equations .",
    "so far our description has involved parallelization by distribution of the radial grid points among the different pes or by distributing sets of spectral lines onto different pes .",
    "in addition , to prevent communication overhead , each task computing the nlte rates is paired on the same pe with and the corresponding task computing nlte opacities and emissivities to reduce communication .",
    "the solution of the rate equations parallelizes trivially with the use of a diagonal rate operator .",
    "in the latest version of our code , phoenix 13.0 , we have incorporated the additional strategy of distributing each nlte species ( the total number of ionization stages of a particular element treated in nlte ) on separate pes .",
    "since different species have different numbers of levels treated in nlte ( e.g. fe  ii [ singly ionized iron ] has 617 nlte levels , whereas h  i has 30 levels ) , care is needed to balance the number of levels and nlte transitions treated among the pes to avoid unnecessary synchronization problems .",
    "the division of labor outlined in the previous sections requires synchronization between the radiative transfer tasks and the nlte tasks , since the radiation field and alo operator must be passed between them .",
    "in addition , our standard model calculations use 50 - 100 radial grid points and as the number of pes increases , so too does the communication and loop overhead .    since the number of wavelength points in a calculation is very large and the cpu time scales linearly with the number of wavelength points , a further distribution of labor by wavelength points would potentially lead to large speedups and to the ability to use very large numbers of processors available on massively parallel supercomputers .",
    "thus , we have developed the concept of wavelength `` clusters '' to distribute a set of wavelength points ( for the solution of the frequency dependent radiative transfer ) onto a different set of pes . in order to achieve optimal load balance and , more importantly , in order to minimize memory requirements , each cluster works on a single wavelength point at a time , but it may consist of a number of `` worker '' pes where the worker pes use parallelization methods discussed above . in order to avoid communication overhead ,",
    "the workers on each wavelength cluster are _ symmetric _ : each corresponding worker on each wavelength cluster performs identical tasks but on a different set of wavelengths for each cluster .",
    "this allows us to make use of _ communicator contexts _ , a concept which is built into mpi .",
    "the basic design is illustrated in fig .",
    "each pe on a given wavelength cluster is assigned to a mpi_group and then the spatial parallelization occurs within that mpi_group so that , while the communicators in different wavelength clusters have identical names , they have different contexts and the code is much clearer and cleaner .",
    "for example , worker  0 will be working on the same set of characteristic rays in the radiative transfer equation on all wavelength clusters .",
    "therefore , worker  0 on wavelength cluster  0 needs to send only the intensities that it computed to its corresponding worker  0 on wavelength cluster  1 and so forth .",
    "the code has been designed so that the number of wavelength clusters , the number of workers per wavelength cluster , and the task distribution within a wavelength cluster is arbitrary and can be specified dynamically at run time .    in order to parallelize the spectrum calculations for a model atmosphere with a global velocity field , such as the expanding atmospheres of novae , supernovae or stellar winds",
    ", we need to take the mathematical character of the rte into account . for monotonic velocity fields ,",
    "the rte is an initial value problem in wavelength ( with the initial condition at the smallest wavelength for expanding atmospheres and at the largest wavelength for contracting atmospheres ) .",
    "this initial value problem must be discretized fully implicitly to ensure stability . in the simplest case of a first order discretization",
    ", the solution of the rte for wavelength point @xmath19 depends only on the results of the point @xmath20 . in order to parallelize the spectrum calculations , the wavelength cluster computing the solution for wavelength point @xmath19 must get the specific intensities from the cluster computing the solution for point @xmath20",
    "this suggests a `` pipeline '' solution to the wavelength parallelization .",
    "note that only the solution of the rte is affected by this , the calculation of the opacities and rates remains independent between different wavelength clusters . in this case , the parallelization works as follows : each cluster can independently compute the opacities , it then waits until it receives the specific intensities for the previous wavelength point , computes the solution of the rte and _ immediately _ sends the results to the next wavelength cluster ( to minimize waiting time , this is done with non - blocking send / receives ) , then proceeds to calculate the rates and the new opacities for its _ next _ wavelength point and so on .    in the simplest case that there are simply 2 pes and the load balance has been set so that each pe acts as a wavelength cluster , we have one worker per wavelength cluster and two wavelength clusters . in this case , pe 1 and 2 begin by doing the various preprocessing required .",
    "pe 1 then begins working on wavelength point 1 , pe 2 is working on wavelength point 2 . since pe 1 begins with the boundary condition , it calculates the opacities at this wavelength point and other necessary preprocessing .",
    "it then solves the rte , using the boundary condition and then immediately sends the specific intensities off to pe 2 .",
    "pe 1 then calculates the rates and various other post - processing at this wavelength point . at the same time pe 2",
    "has finished calculating the opacities at its wavelength point , done the preprocessing for solving the rte and then must wait until pe 1 has sent it the specific intensities for the previous wavelength point at which point it can then solve the rte and immediately send its specific intensities back to pe 1 , which will need them for the next wavelength point , pe 2 then calculates the rates at its wavelength point and the process repeats . since pe 1 was busy doing post - processing , it may in fact have the specific intensities from pe 2 , just in time and so minimal waiting may be required and the process proceeds in a round robin fashion . the basic pre- and post - processing required are illustrated in the pseudo - code of figure 3 .    ....      for i : = 1 to numwavelengths       ....       atomiclineopacity ( ... )       molecularlineopacity ( ... )       nlteopacity ( ... )       radiativetransfer ( ... )       nlteupdaterates ( ... )       ....    end ....    this scheme has some predictable properties similar to the performance results for classical serial vector machines .",
    "first , for a very small number of clusters ( e.g. , two ) , the speedup will be small because the clusters would spend a significant amount of time waiting for the results from the previous cluster ( the `` pipeline '' has no time to fill ) .",
    "second , the speedup will level off for a very large number of clusters when the clusters have to wait because some of the clusters working on previous wavelength points have not yet finished their rte solution , thus limiting the minimum theoretical time for the spectrum calculation to roughly the time required to solve the rte for all the wavelength points together ( the `` pipeline '' is completely filled ) .",
    "this means that there is a `` sweet spot '' for which the speedup to number - of - wavelength - clusters ratio is optimal .",
    "this ratio can be further optimized by using the optimal number of worker pes per cluster , thus obtaining an optimal number of total pes .",
    "the optimum will depend on the model atmosphere parameters , the speed of each pe itself and the communication speed , as well as the quality of the compilers and libraries .",
    "the wavelength parallelization has the drawback that it does not reduce the memory requirement per pe compared to runs with a single wavelength cluster .",
    "increasing the number of worker pes per cluster will decrease the memory requirements per pe drastically , however , so that large runs can use both parallelization methods at the same time to execute large simulations on pes with limited memory . on a shared - memory machine with distributed physical memory ( such as the origin ) , this scheme can also be used to minimize memory access latency .",
    "in our model atmosphere code we have implemented and used direct opacity sampling ( dos ) for more than a decade with very good results . during that time",
    ", the size of the combined atomic and molecular line databases that we used has increased from a few mb to @xmath21 gb . whereas the floating point and memory performance of computers has increased dramatically in this time , i / o performance has not kept up with this speed increase .",
    "presently , the wall - clock times used by the line selection and opacity modules are dominated by i / o time , not by floating point or overall cpu performance .",
    "therefore , i / o performance is today more important that it was 10 years ago and has to be considered a major issue .",
    "the availability of large scale parallel supercomputers that have effectively replaced vector machines in the last 5 years , has opened up a number of opportunities for improvements of dos algorithms .",
    "parallel dos algorithms with an emphasis on the handling of large molecular line databases are thus an important problem in computational stellar atmospheres .",
    "these algorithms have to be portable and should perform well for different types of parallel machines , from cheap pc clusters using ethernet links to high performance parallel supercomputers .",
    "this goal is extremely hard to attain on all these different systems , and we compare two different parallel dos algorithms and describe their performance on two very different parallel machines .",
    "there are a number of methods in use to calculate line opacities .",
    "the classical methods are statistical and construct tables that are subsequently used in the calculation .",
    "the opacity distribution function ( odf ) and its derivative the k - coefficient method have been used successfully in a number of atmosphere and opacity table codes ( e.g. , kurucz 1992 ) .",
    "this method works well for opacity table and model construction but can not be used to calculate detailed synthetic spectra .",
    "a second approach is the opacity sampling ( os ) method ( e.g. , peytremann 1974 ) .",
    "this is a statistical approach in which the line opacity is sampled on a fine grid of wavelength points using detailed line profiles for each individual spectral line . in classical os implementation",
    ", tables of sampling opacities are constructed for given wavelengths grids and for different elements .    in direct opacity sampling ( dos )",
    "these problems are avoided by replacing the tables with a direct calculation of the total line opacity at each wavelength point for all layers in a model atmosphere ( hauschildt & baron 1999 ) . in the dos method",
    "the relevant lines ( defined by a suitable criterion ) are first selected from master spectral line databases which include all available lines .",
    "the line selection procedure will typically select more lines than can be stored in memory and thus temporary line database files are created during the line selection phase .",
    "the file size of the temporary database can vary , in theory , from zero to the size of the original database or larger , depending on the amount of data stored for the selected lines and their number . for",
    "large molecular line databases this can easily lead to temporary databases of several gb in size .",
    "this is in part due the storage for the temporary line database : its data are stored for quick retrieval rather than in the compressed space saving format of the master line databases .",
    "the number and identity of lines that are selected from the master databases depends on the physical conditions for which the line opacities are required ( temperatures , pressures , abundances for a model atmosphere ) and thus the line selection has to be repeated if the physical conditions change significantly .",
    "the temporary line databases are used in the next phase to calculate the actual line opacity for each wavelength point in a prescribed ( arbitrary ) wavelength grid .",
    "this makes it possible to utilize detailed line profiles for each considered spectral line on arbitrary wavelength grids .",
    "for each wavelength grid point , all ( selected ) lines within prescribed search windows ( large enough to include all possibly important lines but small enough to avoid unnecessary calculations ) are included in the line opacity calculations for this wavelength point .",
    "there are currently a large number of significantly different types of parallel machines in use , ranging from clusters of workstations or pcs to teraflop parallel supercomputers .",
    "these systems have very different performance characteristics that need to be considered in parallel algorithm design . for the following discussion",
    "we assume this abstract picture of a general parallel machine : the parallel system consists of a number of processing elements ( pes ) , each of which is capable of executing the required parallel codes or sections of parallel code .",
    "each pe has access to ( local ) memory and is able to communicate data with other pes through a communication device .",
    "the pes have access to both local and global filesystems for data storage .",
    "the local filesystem is private to each pe ( and inaccessible to other pes ) , and the global filesystem can be accessed by any pe .",
    "a pe can be a completely independent computer such as a pc or workstation ( with single cpu , memory , and disk ) , or it can be a part of a shared memory multi - processor system .",
    "we assume that the parallel machine has both global and local logical filesystem storage available ( possibly on the same physical device ) .",
    "the communication device could be realized , for example , by standard ethernet , shared memory , or a special - purpose high speed communication network .    in the following description of the 2 algorithms that we consider here we will make use of the following features of the line databases :    * master line databases : 1 .",
    "are globally accessible to all pes 2 .   are are sorted in wavelength 3 .",
    "can be accessed randomly in blocks of prescribed size ( number of lines ) * selected line ( temporary ) databases : 1 .",
    "the wavelength grid is known during line selection ( not absolutely required but helpful ) 2 .",
    "have to be sorted in wavelength 3 .   can be accessed randomly in blocks of prescribed fixed size ( number of lines ) 4 .",
    "are stored either globally ( one database for all pes ) or locally ( one for each pe ) 5 .",
    "are larger than the physical memory of the pes      the first algorithm we describe relies on global temporary databases for the selected lines .",
    "this is the algorithm that was implemented in the versions of phoenix  discussed above . in the general case of @xmath22 available pe s ,",
    "the parallel line selection algorithm uses one pe dedicated to i / o and @xmath23 line selection pes . the i / o pe receives data for the selected lines from the line selection pes , assembles them into properly sorted blocks of selected lines , and writes them into the global temporary database for later retrieval .",
    "the @xmath23 line selection pes each read one block from a set of @xmath23 adjacent blocks of line data from the master database , select the relevant lines , and send the necessary data to the i / o pe .",
    "each line selection pe will select a different number of lines , so the i / o pe has to perform administrative work to construct sorted blocks of selected lines that it then writes into the global temporary database .",
    "the block sizes for the line selection pes and for the global temporary database created by the i / o pe do not have to be equal , but can be chosen for convenience .",
    "the blocks of the master line database are distributed to the @xmath23 line selection pes in a round robin fashion .",
    "statistically this results in a balanced load between the line selection pes due to the physical properties of the line data .",
    "after the line selection phase is completed , the global temporary line database is used in the line opacity calculations . if each of the @xmath22 pes is calculating line opacities ( potentially for different sets of wavelengths points or for different sets of physical conditions ) , they all access the temporary database simultaneously , reading blocks of line data as required . in most cases of practical interest ,",
    "the same block of line data will be accessed by several ( all ) pes at roughly the same time .",
    "this can be advantageous or problematic , depending on the structure of the file system on which the database resides .",
    "the pes also cache files locally ( both through the operating system and in the code itself through internal buffers ) to reduce explicit disk i / o . during the line selection phase the temporary database is a write - only file , whereas during the opacity calculations the temporary database is strictly read - only .",
    "the performance of the gtf algorithm depends strongly on the performance of the global file system used to store the temporary databases and on the characteristics of the individual pes .",
    "this issue is discussed in more detail below .",
    "the second algorithm we consider uses file systems that are local to each pe ; such local file systems exist on many parallel machines , including most clusters of workstations .",
    "this algorithm tries to take advantage of fast communication channels available on parallel computers and utilizes local disk space space for temporary line list files .",
    "this local disk space is frequently large enough for the temporary line database and may have high local i / o performance .",
    "in addition , i / o on the local disks of a pe does not require any inter - pe communication , whereas globally accessible filesystems often use the same communication channel that explicit inter - pe communication uses .",
    "the latter can lead to network congestion if messages are exchanged simultaneously with global i / o operations .    for the line selection",
    ", we could use the algorithm described above with the difference that the i / o pe would create a single global ( or local ) database of selected lines .",
    "after the line selection is finished , the temporary database could then simply be distributed to all pes , and stored on their local disk for subsequent use .",
    "this is likely to be slower in all cases than the gtf algorithm .",
    "instead , we use a `` ring '' algorithm that creates the local databases directly .",
    "in particular , each of the @xmath22 pes selects lines for one block from the master database ( distributed in round robin fashion between the pes ) .",
    "after the selection for this one block is complete , each pe sends the necessary data to it next neighbor ; pe @xmath19 sends its results to pe @xmath24 and simultaneously , receives data from the previous pe in the ring ( the ring is periodic , i.e. , pe @xmath22 sends data to pe @xmath25 ) .",
    "this can be easily realized using the mpi_sendrecv call , which allows the simultaneous sending and receiving of data for each member of the ring .",
    "each pe stores the data it receives into a buffer and the process is repeated until the all selected lines from the @xmath22 blocks are buffered in all @xmath22 pes .",
    "the pes then transfer the buffered line data into their local temporary databases .",
    "this cycle is repeated until the line selection phase is complete .",
    "the line opacity calculations will then proceed in the same way as outlined above , however , the temporary line databases are now local for each pe .",
    "this approach has the advantage that accessing the temporary databases does not incur any ( indirect ) network file system ( nfs ) communication between the pes as each of them has its own copy of the database .",
    "however , during the line selection phase a much larger amount of data has to be communicated over the network between the pes because now each of them has to `` know '' all selected lines , not only the i / o pe used in the first algorithm .",
    "the key insight here is that low - cost parallel computers constructed out of commodity workstations typically have a very fast communication network ( 100 mbs to 1 gbs ) but relatively slow nfs performance .",
    "this means that trading off the extra communication for fewer nfs disk accesses in the ltf algorithm is likely to give better performance .",
    "the performance of the gtf and ltf algorithms will depend strongly on the type of parallel machine used .",
    "a machine using nfs with fast local disks and communication is likely to perform better with the ltf algorithm .",
    "however , a system with a fast ( parallel ) filesystem and fast communication can perform better with the gtf algorithm . in the following",
    "we will consider test cases run on very different machines :    1 .   a cluster of pentium pro 200mhz pcs with 64 mb ram , scsi disks , 100mbs full - duplex ethernet communication network , running solaris 2.5.1 . 2",
    ".   an ibm sp system with 200mhz power3 cpus , 512 mb ram per cpu , 133 mb / s switched communication network , 16 pe ibm general purpose file system ( gpfs ) parallel filesystem , running aix 4.3 .",
    "we have run 2 test cases to analyze the behavior of the different algorithms on different machines .",
    "the small test case was designed to execute on the ppro system .",
    "it uses a small line database ( about 550 mb ) with about 35 million lines of which about 7.5 million lines are selected . the second",
    "test uses a database which is about 16 times larger ( @xmath26 gb ) and also selects 16 times more lines .",
    "this large test could not be run on the ppro system due to file size limitations and limited available disk space .",
    "the line opacity calculations were performed for about 21,000 wavelength points that are representative of typical calculations .",
    "the tests were designed for maximum i / o usage and are thus extreme cases . in practical applications the observed scaling is comparable to or better than that found for these tests and appears to follow the results shown here rather well .",
    "the results for the line selection procedure on the ppro / solaris system are shown in fig .",
    "it is apparent from the figure that the gtf approach delivers higher relative speedups that translate into smaller execution times for more than 2 pes . for serial ( 1 pe ) and 2",
    "pe parallel runs the ltf line selection is substantially faster than the gtf algorithm .",
    "the reason for this behavior can be explained by noting that the access of the global files is done through nfs mounts that use the same network as the mpi messages .",
    "therefore , @xmath27 pes request different data blocks from the nfs server ( no process was run on the nfs server itself ) and send their results to the i / o pe , which writes it out to the nfs server . in the ltf algorithm",
    ", each pe reads a different input block from the nfs server and then sends its results ( around the ring ) to all other pes . upon receiving data from its left neighbor ,",
    "a pe writes it to local disk .",
    "this means that the amount of data streaming over the network can be as much as twice as high for the ltf compared to the gtf algorithm .",
    "this increases the execution time for the ltf approach if the network utilization is close to the maximum bandwidth . in this argument",
    "we have ignored the time required to write the data to local disks , which would make the situation worse for the ltf approach .",
    "the situation is very different for the calculation of the line opacities ( which uses only the local temporary database ) , as also shown in fig .",
    "now the ltf approach scales well ( up to the maximum of 8 available machines ) whereas the gtf algorithm hardly scales to more than 2 pes .",
    "the absolute execution times for the ltf approach are up to a factor of 4 smaller ( more typical are factors around 2 ) than the corresponding times for the gtf algorithm ( the gtf run with 8 pes required roughly as much execution time as the ltf run with 1 pe ! ) .",
    "the reason for this is clearly the speed advantage of local disk i / o compared to nfs based i / o in the gtf code .",
    "if more pes are used in the gtf line opacity approach , the network becomes saturated quickly and the pes have to wait for their data ( the nfs server itself was not the bottleneck ) .",
    "the ltf approach will be limited by the fact that as the number of pes gets larger , the efficiency of disk caching is reduced and more physical i / o operations are required .",
    "eventually this will limit the scaling as the execution time is limited by physical i / o to local disks .",
    "[ cols= \" < , < \" , ]",
    "while the parallelization of a large numerical code such as phoenix would ideally be performed at the compiler level , it is not possible with modern compilers to construct efficient code with good scaling properties .",
    "thus , individual modules of the code have to be examined and parallelized separately . with mpi",
    "this task is manageable and allows the efficient use of both commodity parallel clusters and modern massively parallel supercomputers .",
    "we found good speedup up to about 64 pes for a typical supernova calculation .",
    "however , for more than 64 pes the communication , synchronization , and loop overheads begin to become significant and it is not economical to use more than 128 pes for static models and opacity tables we are able to use very large numbers of pes with scaling at close to the theoretical maximum .",
    "fully 3-d calculations will present yet another parallelization challenge .",
    "we thank our many collaborators who have contributed to the development of phoenix , in particular france allard , jason aufdenberg , andreas schweitzer , travis barman , eric lentz , ian short , david branch , sumner starrfield , and steve shore .",
    "this work was supported in part by nasa , the nsf , ibm , and the ple scientifique de modlisation numrique at ens - lyon and the calculations were performed at nersc and sdsc ."
  ],
  "abstract_text": [
    "<S> we describe the method we have used to parallelize our spherically symmetric special relativistic short characteristics general radiative transfer code phoenix . </S>",
    "<S> we describe some possible parallelization strategies and show why they would be inefficient . </S>",
    "<S> we discuss the multiple parallelization strategy techniques that we have adopted . </S>",
    "<S> we briefly discuss generalizing these strategies to full 3-d ( spatial ) radiation transfer codes . </S>"
  ]
}