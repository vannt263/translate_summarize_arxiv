{
  "article_text": [
    "there are many relevant applications of regular expression matching ( rem ) and finite automata ( fa ) including dna sequence matching @xcite , network intrusion detection @xcite , and information extraction from web based documents@xcite .",
    "the computational complexity of pattern finding grows with increasing the number of states of the automaton and the size of the input . while the stagnation in processor clock rates promises no performance increases for sequential implementations of rem , availability of affordable multicore processors provides opportunities for significant improvement .",
    "for instance , the recently introduced intel  xeon  processor e7 - 8890 v2 manufactured at 22 nm comprises 15 physical cores and supports 30 threads or so called logical cores .",
    "shared - memory systems with up to eight processors of this type are feasible that would lead to a system with 240 logical cores . to exploit these powerful systems , scalable parallel rem implementations are required .",
    "programming and resolving problems within automata theory is a relatively complex and time - consuming process , and still the results may not be reliable because of the chances to have an incorrect fa representation . furthermore , efficient parallel programming of multicore systems is complex and this issue is known in the literature as the _",
    "`` programmability wall ''",
    "_ @xcite . democratization of parallel rem would benefit from tools that hide parallel programming from the end - user and automatically generate the correct parallel implementation that is ready for compilation and efficient execution .",
    "various approaches for increasing the performance of rem evaluation have been proposed .",
    "for instance , maine @xcite is a library for data - parallel fa , which formalizes the evaluation of a fa as a matrix multiplication .",
    "holub and stekr @xcite propose an algorithm for parallel execution of synchronized deterministic finite automata ( dfa ) .",
    "yang and prassana @xcite introduce an approach that uses segmentation for regular expression evaluation via nondeterministic finite automata ( nfa ) . in @xcite authors",
    "propose the range - coalesced representation of transition table to optimize the cost of the transition table lookup for each active state . while there are model to text generators ( such as , acceleo @xcite ) , or re to nfa - dfa converters ( such as , jflap @xcite ) , to our best knowledge there are no automatic parallel code generators for re or fa .    in this paper",
    ", we describe a novel algorithm for rallel egular xpression atching ( parem ) that scales gracefully for various problem sizes and number of threads .",
    "the algorithm was devised to be efficient for general automata independently from the number of states , and for large spectrum of input text - sizes .",
    "our algorithm is optimized to do very accurate speculations on the possible initial states for each of the sub inputs ( split among the available processing units ) , instead of calculating the possible routes considering each state of the automaton as initial state .",
    "this method is more effective when the adjacency matrix ( used for graph representation of the automaton ) is sparse , although it shows major improvements in dense matrices as well . to ease the access to the proposed parallel algorithm for a broad spectrum of users ( including the users without background in parallel programming ) ,",
    "we have developed our tool parem that can transform automatically a regular expression ( re ) or fa into the corresponding code ( c++ and openmp ) for our algorithm that is amenable for parallel execution on shared - memory systems .",
    "experimental results on a dual - socket shared - memory system with 24 physical cores show a close to linear speedup compared to the sequential implementation for problem sizes comparable to the cache size and significant speedup for larger problem sizes that use further levels of memory hierarchy .",
    "the main contributions of this paper include :    * a scalable algorithm for parallel regular expression matching ; * parem tool that automatically generates parallel code from a given regular expression or finite automata ; * empirical evaluation of the proposed parallel algorithm and the parem tool using a modern dual - socket shared - memory system with 24 physical cores .",
    "the rest of the paper is organized as follows .",
    "section [ methodology ] provides background information on regular expressions and finite automata and presents our parallel algorithm .",
    "section [ implementation ] describes the implementation of the parem tool , and section [ exp_evaluation ] the corresponding experimental evaluation .",
    "the work described in this paper is compared and contrasted to the related work in section [ related_work ] .",
    "section [ summary_future_work ] provides a summary of our work and a description of future work .",
    "a regular expression is a string for describing search patterns .",
    "a finite automaton is a graph - based way for specifying patterns @xcite .",
    "finite automata and regular expressions may be used in pattern finding algorithms .    deterministic finite automata ( dfa )",
    "is a quintuple of @xmath1 , where @xmath2 is a finite set of states , @xmath3 is set of symbols ( alphabet ) , @xmath4 is the transition function , @xmath5 is the initial state and @xmath6 is the set of final states @xcite@xcite .",
    "a dfa operates in the following manner : when a program starts , the current state is assumed to be the initial state @xmath5 , on each character the current symbol is supposed to move to another state ( including itself ) . when the input reaches the last character , the string is accepted if and only if the current state is in the set of final states .",
    "it is called deterministic because in each state and for each input symbol a unique transition is defined .",
    "nondeterministic finite automata ( nfa ) is defined by the quintuple @xmath7 as in dfa except the alphabet may contain an empty symbol ; the transition function returns a set of states rather than a single state .",
    "it is called non - deterministic because of the choice of moves that may lead from one state to another .",
    "existing approaches for parallel rem ( such as @xcite ) split the input into smaller substrings among all or a selected number of processing units , run the automaton on each of them , and join the sub- results .",
    "while other approaches calculate the possible initial states from each state of the automaton , our algorithm takes a step ahead by excluding all the states that the automaton has no outgoing or incoming transitions for the specified characters .",
    "calculating the possible routes from each state of the automaton becomes time - consuming and memory - expensive for large finite automatons .",
    "the basic idea of the sequential rem or dfa is that one starts from @xmath5 and after n ( input length ) steps another state from set @xmath2 is reached .",
    "its time complexity depends only on the input length .",
    "our algorithm is based on domain decomposition , which means it slices the input in @xmath8 parts ( see algorithm [ alg_parallel ] ) , where @xmath8 is the number of processing units ( line 3 ) . for each @xmath9",
    "the possible initial states @xmath10 are determined by finding the intersection of possible initial states @xmath11 ( line 5  15 ) .",
    "@xmath12 is the set of initial states for the first character of @xmath13 ( that is , the sliced input for this specific processor ) where @xmath14 if @xmath15 .",
    "@xmath16 is the set of initial states for last character of @xmath17 , where @xmath18 , @xmath19 .",
    "each chunk of the input is mapped to a processing unit , and each processing unit is responsible for finding the possible initial states for its own chunk of the input .",
    "the processing unit with @xmath20 already knows the possible initial state , that is @xmath5 , so a calculation for determining the possible initial states is not necessary . for each state in @xmath10 ,",
    "a rem is done and the result is stored in @xmath21 ( lines 16  25 ) .    when all processors have finished their jobs , a binary reduction of the final results is completed .",
    "the reduction is done by connecting the last active state of @xmath22 to the first active state of @xmath23 .",
    "the connection is accepted only if a transition from last active state of @xmath22 to the first active state of @xmath24 exists with the first character of the sub - result of next processor @xmath25,@xmath26 .",
    "an input is accepted only if for each processor there exist a sub route , which can be connected with the result of the previous and next processor s result , and the last state of the automaton is member of the final state set .",
    "the worst - case scenario would be if all the states have the same input and output transitions .    in parallel @xmath27 @xmath28 @xmath29 = q_{i}$ ]    @xmath11 % intersection of possible initial and last states %",
    "@xmath30 @xmath31 @xmath32 = r = tt[r][char]$ ] @xmath33.push\\_back(rr)$ ]    [ alg_parallel ]      to show how the possible initial states are determined , the following example from fig .",
    "[ fig_automaton ] is used .",
    "let @xmath34 be an input string , @xmath35 and assume that we will use four processing units ( that is threads ) .     for matching the pattern _",
    "_ parallel__,width=288 ]    the transition table corresponding to the automaton from fig .",
    "[ fig_automaton ] is shown on table i. the transition table for this automaton is dense , which will produce a dense adjacency matrix .",
    ".transition table for automaton on fig .",
    "[ fig_automaton ] [ cols=\"<,<,<,<,<,<\",options=\"header \" , ]     we have run the experiment example from section [ methodology].c with the same input sizes and number of threads for the general enumeration approach as well . figure [ comparison : a ]  [ comparison : e ] depicts the impact of finding the most accurate initial states in the time execution .",
    "the sequential version ( running in one thread ) is the same for both algorithms , because they start the calculations from state @xmath5 on processing unit @xmath36 .",
    "the enumeration approach requires more calculations for finite automata with larger number of states , larger input size and for higher number of processing units .",
    "the execution time of the enumeration approach compared to the parem algorithm increases as we increase either the input size or the number of threads .",
    "the execution time of parem is @xmath37 better than enum , which is achieved in the largest number of threads ( 48 ) and the biggest problem size(1.07e+09 ) , and only @xmath38 better than enum for the smallest number of threads ( 6 ) and the smallest input size ( 6.69+e07 ) .",
    "[ fig_comparison_parem_vs_enum ]",
    "holub and stekr @xcite propose an approach for parallel rem via dfa by splitting the input string in small chunks and running these chunks on each core , but due to pre - calculation of initial states for each sub input , this was not efficient for general dfa .",
    "their algorithm runs efficiently for a specific type of dfa , so called synchronizing automata , that relies on the input automaton being k - local .",
    "yang and prassana @xcite propose the segmentation of regular expressions and perform the rem evaluation via nondeterministic finite automata .",
    "the major aim is to optimize the use of memory hierarchy in case of automata with many states and large transition table .",
    "in contrast to our approach , the authors of @xcite focus on large automata but do not address specifically algorithmic optimizations with respect to large input strings .",
    "mytkowicz and schulte @xcite propose an approach that exploits simd , instruction and thread level parallelism in the context of finite state machines computations . to increase the opportunities for data - parallelism authors of",
    "[ 11 ] have devised a method for breaking data - dependencies with enumeration .",
    "this approach is not based on speculation with respect to initial state determination .",
    "kumar et al .",
    "@xcite address the issue of large - scale finite automata ( also known as the state explosion problem ) by splitting regular expressions into two parts : ( 1 ) a prefix that contains frequently visited parts of the automata , and ( 2 ) a suffix that is the rest of the automaton .",
    "the aim is to have a small dfa for frequently accessed parts of automata that fits in cache memory .",
    "luchaup et al .",
    "@xcite propose an approach of finding the correct initial state by speculation .",
    "they believe that guessing the state of the dfa at certain position ( network intrusion detection dfa based scanning spends most of the time in a few hot states ) has a very good chance that after a few steps will reach the correct state .",
    "they validate these guesses using a history of speculated states . in comparison to our algorithm ,",
    "the convergence of the guessed state and the correct state is not guaranteed .",
    "furthermore , if a thread does not converge on its sub input , then the next thread is forced to start from a new state , which limits the scalability @xcite .",
    "our algorithm is based on splitting the input into smaller sub - inputs ( domain decomposition ) ; however , we have devised a method to bypass the need of pre - calculation of all initial states by finding the most accurate possible initial states .",
    "our approach is not limited to a particular type of dfa , and is efficient for a large spectrum of input sizes .",
    "in contrast to the related work , our tool is capable of automatically generating a ready to compile and execute code for shared - memory systems , by taking as input a re or fa .",
    "regular expression matching is essential for many applications such as lexical analysis , data mining @xcite , or network security .",
    "we have presented a parallel algorithm for regular expression matching that is based on our improved speculative determination of initial states .",
    "our tool parem transforms automatically any regular expression or finite automata into the corresponding parallel code ( c++ and openmp ) , and consequently eases the access to the proposed parallel algorithm for the users without background in parallel programming .",
    "preliminary experimental results show that the performance of our algorithm gracefully scales for various string lengths and numbers of threads . for an input string of 6.69e+07 characters",
    ", we obtained a speedup of @xmath0 with 48 threads .    in future , we plan to evaluate our approach for other types of problems , such as dna sequencing or network intrusion detection systems .",
    "we also plan to extend our implementation for heterogeneous systems .",
    "a.  babukaruppiah and s.  rajaram , `` deterministic finite automata for pattern matching in fpga for intrusion detection , '' in _ computer , communication and electrical technology ( icccet ) , 2011 international conference on _ , march 2011 , pp .",
    "167170 .",
    "r.  kosala , m.  bruynooghe , j.  v. den bussche , and h.  blockeel , `` information extraction from web documents based on local unranked tree automaton inference . '' in _ ijcai _ , g.  gottlob and t.  walsh , eds.1em plus 0.5em minus 0.4emmorgan kaufmann , 2003 , pp . 403408 .",
    "s.  pllana , s.  benkner , e.  mehofer , l.  natvig , and f.  xhafa , `` towards an intelligent environment for programming multi - core computing systems . '' in _ euro - par workshops _ ,",
    "lecture notes in computer science , vol .",
    "5415.1em plus 0.5em minus 0.4emspringer , 2008 , pp .",
    "141151 .",
    "t.  mytkowicz and w.  schulte , `` maine : a library for data parallel finite automata , '' tech .",
    "msr - tr-2012 - 62 , july 2012 .",
    "[ online ] .",
    "available : http://research.microsoft.com/apps/pubs/default.aspx?id=168379    j.  holub and s.  stekr , `` on parallel implementations of deterministic finite automata . '' in _ ciaa _ , ser .",
    "lecture notes in computer science , s.  maneth , ed .",
    "5642.1em plus 0.5em minus 0.4emspringer , 2009 , pp",
    ". 5464 .",
    "e. yang and v.  k. prasanna , `` optimizing regular expression matching with sr - nfa on multi - core systems . '' in _ pact _ , l.  rauchwerger and v.  sarkar , eds.1em plus 0.5em minus 0.4emieee computer society , 2011 , pp .",
    "424433 .",
    "t.  mytkowicz , m.  musuvathi , and w.  schulte , `` data - parallel finite - state machines.''1em plus 0.5em minus 0.4emarchitectural support for programming languages and operating systems ( asplos ) , march 2014 .",
    "s.  kumar , b.  chandrasekaran , j.  turner , and g.  varghese , `` curing regular expressions matching algorithms from insomnia , amnesia , and acalculia . '' in _ ancs _ , r.  yavatkar , d.  grunwald , and k.  k. ramakrishnan , eds.1em plus 0.5em minus 0.4emacm , 2007 , pp .",
    "155164 .",
    "r.  trasarti , f.  bonchi , and b.  goethals , `` sequence mining automata : a new technique for mining frequent sequences under regular expressions , '' in _ data mining , 2008 .",
    "eighth ieee international conference on _ , dec 2008 , pp . 10611066 ."
  ],
  "abstract_text": [
    "<S> regular expression matching is essential for many applications , such as finding patterns in text , exploring substrings in large dna sequences , or lexical analysis . </S>",
    "<S> however , sequential regular expression matching may be time - prohibitive for large problem sizes . in this paper </S>",
    "<S> , we describe a novel algorithm for parallel regular expression matching via deterministic finite automata . </S>",
    "<S> furthermore , we present our tool parem that accepts regular expressions and finite automata as input and automatically generates the corresponding code for our algorithm that is amenable for parallel execution on shared - memory systems . </S>",
    "<S> we evaluate our parallel algorithm empirically by comparing it with a commonly used algorithm for sequential regular expression matching . </S>",
    "<S> experiments on a dual - socket shared - memory system with 24 physical cores show speed - ups of up to @xmath0 for 48 threads .    parallel processing , multi - core , regular expression , finite automata </S>"
  ]
}