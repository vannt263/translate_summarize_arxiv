{
  "article_text": [
    "the analysis of execution traces plays a fundamental role in many program manipulation techniques .",
    "trace slicing is a technique for reducing the size of traces by focusing on selected aspects of program execution , which makes it suitable for trace analysis and monitoring  @xcite .",
    "rewriting logic ( rwl ) is a very general _ logical _ and _ semantic framework _ , which is particularly suitable for formalizing highly concurrent , complex systems ( e.g. , biological systems @xcite and web systems @xcite ) .",
    "rwl is efficiently implemented in the high - performance system maude @xcite .",
    "roughly speaking , a _ rewriting logic theory _ seamlessly combines a _ term rewriting system _ ( trs ) together with an _ equational theory _ that may include sorts , functions , and algebraic laws ( such as commutativity and associativity ) so that rewrite steps are applied _ modulo _ the equations . within this framework ,",
    "the system states are typically represented as elements of an algebraic data type that is specified by the equational theory , while the system computations are modeled via the rewrite rules , which describe transitions between states .    due to the many important applications of rwl , in recent years , the debugging and optimization of rwl theories have received growing attention @xcite .",
    "however , the existing tools provide hardly support for execution trace analysis . the original motivation for our work was to reduce the size of the counterexample traces delivered by web - tlr , which is a rwl - based model - checking tool for web applications proposed in @xcite . as a matter of fact",
    ", the analysis ( or even the simple inspection ) of such traces may be unfeasible because of the size and complexity of the traces under examination .",
    "typical counterexample traces in web - tlr are 75  kb long for a model size of 1.5  kb , that is , the trace is in a ratio of 5.000% w.r.t .  the model .    to the best of our knowledge , this paper presents the first trace slicing technique for rwl theories .",
    "the basic idea is to take a trace produced by the rwl engine and traverse and analyze it backwards to filter out events that are irrelevant for the rewritten task .",
    "the trace slicing technique that we propose is fully general and can be applied to optimizing any rwl - based tool that manipulates rewrite logic traces .",
    "our technique relies on a suitable mechanism of backward tracing that is formalized by means of a procedure that labels the calls ( terms ) involved in the rewrite steps .",
    "this allows us to infer , from a term @xmath0 and positions of interest on it , positions of interest of the term that was rewritten to @xmath0 .",
    "our labeling procedure extends the technique in  @xcite , which allows descendants and origins to be traced in orthogonal ( i.e. , left - linear and overlap - free ) term rewriting systems in order to deal with rewrite theories that may contain commutativity / associativity axioms , as well as nonleft - linear , collapsing equations and rules . as in dynamic tracing @xcite , our definition of labeling uses a relation on contexts derived from the reduction relation on terms , where the symbols in the left - hand side of a rule propagate to all symbols of its right - hand side .",
    "this labeling relation allows us to make precise the _ dynamic dependence _ of function symbols occurring in the terms of a reduction sequence on symbols in previous terms in that sequence  @xcite .",
    "_ plan of the paper .",
    "_ section  [ sec : prelim ] summarizes some preliminary definitions and notations about term rewriting systems . in section  [ sec : rewrite - m - e ] , we recall the essential notions concerning rewriting modulo equational theories .",
    "section  [ sec : lab - trac ] describes the main kinds of labeling and tracing in term rewrite systems . in section",
    "[ sec : labeling_and_slicing ] , we formalize our backward trace slicing technique for elementary rewriting logic theories .",
    "section  [ sec : slicing - m - e ] extends the trace slicing technique of section  [ sec : labeling_and_slicing ] by considering extended rewrite theories , i.e. , rewrite theories that may include collapsing , nonleft - linear rules , associative / commutative equational axioms , and built - in operators .",
    "section [ sec : exp ] describes a software tool that implements the proposed backward slicing technique and reports on an experimental evaluation of the tool that allows us to assess the practical advantages of the trace slicing technique . in section  [ sec : related ] , we discuss some related work and then we conclude .",
    "proofs of the main technical results can be found in appendix  [ app : proof ] .",
    "a many - sorted signature @xmath1 consists of a set of sorts @xmath2 and a @xmath3-indexed family of sets @xmath4 , which are sets of _ function symbols _ ( or operators ) with a given string of argument sorts and result sort .",
    "given an @xmath2-sorted set @xmath5 of disjoint sets of variables , @xmath6 and @xmath7 are the sets of terms and ground terms of sorts @xmath8 , respectively .",
    "we write @xmath9 and @xmath10 for the corresponding term algebras .",
    "an _ equation _ is a pair of terms of the form @xmath11 , with @xmath12 . in order to simplify the presentation , we often disregard sorts when no confusion can arise .",
    "terms are viewed as labelled trees in the usual way .",
    "positions are represented by sequences of natural numbers denoting an access path in a term .",
    "the empty sequence @xmath13 denotes the root position . by @xmath14",
    ", we denote the symbol that occurs at the root position of @xmath0 .",
    "we let @xmath15 denote the set of positions of @xmath0 . by notation @xmath16",
    ", we denote the concatenation of positions ( sequences ) @xmath17 and @xmath18 .",
    "positions are ordered by the prefix ordering , that is , given the positions @xmath19 , @xmath20 if there exists a position @xmath21 such that @xmath22 .",
    "@xmath23 is the subterm at the position @xmath24 of @xmath0 .",
    "@xmath25_u$ ] is the term @xmath0 with the subterm rooted at the position @xmath24 replaced by @xmath26 .",
    "a substitution @xmath27 is a mapping from variables to terms @xmath28 such that @xmath29 for @xmath30 ( with @xmath31 if @xmath32 ) , and @xmath33 for any other variable @xmath21 . by @xmath34",
    ", we denote the _ empty _ substitution . given a substitution @xmath27 , the _ domain _ of @xmath27 is the set @xmath35 .",
    "by @xmath36 ( resp .",
    "@xmath37 ) , we denote the set of variables ( resp .",
    "function symbols ) occurring in the term @xmath0 .",
    "a _ context _ is a term @xmath38 with zero or more holes @xmath39 symbol for each sort @xmath40 , and by abuse we simply denote @xmath41 by @xmath39 . ] , and @xmath42 .",
    "we write @xmath43_u$ ] to denote that there is a hole at position @xmath24 of @xmath44 . by notation @xmath43 $ ] , we define an arbitrary context ( where the number and the positions of the holes are clarified _ in situ _ ) , while we write @xmath45 $ ] to denote the term obtained by filling the holes appearing in @xmath43 $ ] with terms @xmath46 . by notation @xmath47",
    ", we denote the context obtained by applying the substitution @xmath48 to @xmath0 , where @xmath49 ( i.e. , @xmath50 ) .",
    "term rewriting system _ ( trs for short ) is a pair @xmath51 , where @xmath52 is a signature and @xmath53 is a finite set of reduction ( or rewrite ) rules of the form @xmath54 , @xmath55 , @xmath56 and @xmath57 .",
    "we often write just @xmath53 instead of @xmath51 .",
    "a rewrite step is the application of a rewrite rule to an expression .",
    "a term @xmath8 _ rewrites _ to a term @xmath0 via @xmath58 , @xmath59 ( or @xmath60 ) , if there exists a position @xmath61 in @xmath8 such that @xmath62 _ matches _ @xmath63 via a substitution @xmath27 ( in symbols , @xmath64 ) , and @xmath0 is obtained from @xmath8 by replacing the subterm @xmath64 with the term @xmath65 , in symbols @xmath66_q$ ] .",
    "the rule @xmath67 ( or equation @xmath68 ) is _ collapsing _ if @xmath69 ; it is _ left - linear _ if no variable occurs in @xmath62 more than once .",
    "we denote the transitive and reflexive closure of @xmath70 by @xmath71 .",
    "let @xmath72 be a rule .",
    "we call the context @xmath73 ( resp .",
    "@xmath74 ) _ redex pattern _",
    "( resp .  _ contractum pattern _ ) of @xmath26 .",
    "for example , the context @xmath75 ( resp .",
    "@xmath76 ) is the redex pattern ( resp .",
    "contractum pattern ) of the rule @xmath77 , where @xmath78 is a constant symbol .",
    "an _ equational theory _ is a pair @xmath79 , where @xmath80 is a signature and @xmath81 consists of a set of ( oriented ) equations @xmath82 together with a collection @xmath83 of equational axioms ( e.g. , associativity and commutativity axioms ) that are associated with some operator of @xmath80 .",
    "the equational theory @xmath84 induces a least congruence relation on the term algebra @xmath9 , which is usually denoted by @xmath85 .",
    "rewrite theory _ is a triple @xmath86 , where @xmath79 is an equational theory , and @xmath53 is a trs",
    ". examples of rewrite theories can be found in @xcite . rewriting modulo equational theories",
    "@xcite can be defined by lifting the standard rewrite relation @xmath87 on terms to the @xmath84-congruence classes induced by @xmath85 .",
    "more precisely , the rewrite relation @xmath88 for rewriting modulo @xmath84 is defined as @xmath89 .",
    "a computation in @xmath90 using @xmath91 is a _ rewriting logic deduction _ , in which the _ equational simplification _ with @xmath82 ( i.e.",
    ", applying the oriented equations in @xmath82 to a term @xmath0 until a canonical form @xmath92 is reached where no further equations can be applied ) is intermixed with the rewriting computation with the rules of  @xmath53 , using an _ algorithm of matching modulo matches @xmath93 ( _ modulo @xmath83 _ ) via the substitution @xmath27 if @xmath94 and @xmath95 for a position @xmath61 of @xmath24 . ]",
    "@xmath83 _ in both cases .",
    "formally , given a rewrite theory @xmath86 , where @xmath96 , a _",
    "rewrite step modulo @xmath84 _ on a term @xmath97 by means of the rule @xmath98 ( in symbols , @xmath99 ) can be implemented as follows : @xmath100 apply ( modulo @xmath83 ) the equations of @xmath82 on @xmath97 to reach a canonical form @xmath101 ; @xmath102 rewrite ( modulo @xmath83 ) @xmath101 to term @xmath103 by using @xmath104 ; and @xmath105 , apply ( modulo @xmath83 ) the equations of @xmath82 on @xmath103 again to reach a canonical form for  @xmath103 , @xmath106 .",
    "since the equations of @xmath82 are implicitly oriented ( from left to right ) , the equational simplification can be seen as a sequence of ( equational ) rewrite steps ( @xmath107 ) .",
    "therefore , a _",
    "rewrite step modulo @xmath84 _ @xmath108 can be expanded into a sequence of rewrite steps as follows : @xmath109    given a finite rewrite sequence @xmath110 in the rewrite theory @xmath90 , the _ execution trace _ of @xmath111 is the rewrite sequence @xmath112 obtained by expanding all the rewrite steps @xmath113 of @xmath111 as is described above .    in this work , a rewrite theory @xmath114 is called _ elementary _ if @xmath90 does not contain equational axioms ( @xmath115 ) and both rules and equations are left - linear and not collapsing .",
    "labeling an object allows us to distinguish it within a collection of identical objects .",
    "this is a useful means to keep track of a given object in a dynamic system . in the following ,",
    "we introduce a rather intuitive example that allows us to illustrate how the labeling and tracing process work .",
    "[ ex : ex - lab ] let @xmath116 , and @xmath117 be two rewrite rules .",
    "let @xmath118 be an initial term .",
    "then , by applying @xmath119 and @xmath120 we get the execution trace @xmath121 .",
    "in term rewriting , we distinguish three kinds of labeling according to the information recorded by them in an execution trace .    * the hyland ",
    "wadsworth labeling  @xcite records the creation level of each symbol . roughly speaking , from an initial ( default )",
    "creation level , the accomplishment of a rewrite step increases by one the creation level of the affected symbols . for example , consider the execution trace @xmath112 of example  [ ex : ex - lab ] together with an initial level @xmath122 for all symbols . then , @xmath123 * the boudol",
    " khasidashvili labeling  @xcite records the history of the term in execution traces . the general idea is to record in the history the applied rule and the symbols of the redex pattern .",
    "this information is taken as the label for the head symbol of the contractum pattern .",
    "consider again example  [ ex : ex - lab ] .",
    "first , the set of rules is labeled as follows : @xmath124then , the labeling of the execution trace @xmath112 is : @xmath125note that the initial term of this sequence is not labeled , i.e. , the initial label is the identity . *",
    "the lvy labeling  @xcite records the history of each symbol in the term .",
    "basically , this labeling combines the previous two labelings and attaches the history on every symbol of the contractum pattern .",
    "let us show an example .",
    "as before , consider example  [ ex : ex - lab ] .",
    "the labeled rules are as follows : @xmath126 and the labeled trace of @xmath112 is : @xmath127 note that due to the accumulation of labels , lvy labels soon become neither readable nor legible .",
    "note also that this labeling keeps the maximal information in a rewrite step .    in this work ,",
    "we rely on klop labeling  @xcite , which is inspired by lvy labeling . roughly speaking",
    ", klop labeling employs greek letters and concatenation of greek letters as labels .",
    "that is , given a rewrite step @xmath128 , the symbols of @xmath0 are decorated by using greek letters as labels .",
    "then , a new label @xmath93 is formed by concatenating the labels of the redex pattern . finally , @xmath93 is attached to every symbol of the contractum pattern of @xmath8 . a formal definition of this labeling adapted to deal with rewriting logic theories is given in section  [ sec : labeling ] .    given a rewrite step @xmath128 , tracing allows one to establish a mapping among symbols of @xmath0 and symbols of @xmath8 . each symbol",
    "is mapped according to its location .",
    "for example , occurrences of symbols in the context of @xmath0 , or in the computed substitution , are traced to the same occurrences in @xmath8 . on the contrary , the mapping for the symbols in the redex and contractum patterns depend on the kind of tracing we adopt .",
    "namely , in _",
    "static _ tracing the symbols do not persist through the execution trace . on other hand , in _ dynamic _ tracing the symbols of the redex pattern are mapped to all symbols of the contractum pattern .",
    "let us illustrate this by means of an example .",
    "consider the rewrite step @xmath129 into the trace  @xmath112 of example  [ ex : ex - lab ] . by",
    "considering the static tracing , the symbol @xmath130 within the term @xmath118 does not leave a trace to the term @xmath131 since @xmath130 belongs to redex pattern of @xmath119 .",
    "contrarily , @xmath130 dynamically traces to @xmath132 .",
    "finally , in both cases the symbol @xmath78 is discarded without leaving a trace in the rewrite step .",
    "as for the dynamic tracing relation , the symbols can be partitioned into _ needed _ and _ non - needed_. a symbol is called _ needed _ if it leaves a trace in the considered rewrite sequence . for instance , in the previous example , @xmath130 is a _ needed _ symbol . instead @xmath78 , which belongs to substitution @xmath133 , is a _ non - needed _ symbol .",
    "given an execution trace , the set of needed symbols in a term of the trace forms a prefix which is also called _ needed _ prefix .",
    "typically , tracing is implemented by means of labeling , i.e. , the objects are labeled to be traced along the execution trace . for instances ,",
    "let us consider klop labeling for a rewrite step @xmath128 .",
    "a symbol in @xmath0 traces to a symbol in @xmath8 , if and only if the label of the former is a sublabel of the label of the latter .",
    "note that this tracing relation is independent of the chosen tracing , while it is strictly tied to the labeling strategy .",
    "labeling and tracing relations in term rewriting systems have been studied in  @xcite . in order to study the orthogonality of execution traces ,",
    "@xcite  investigates the equivalence of labeling and tracing along with other characterizations such as permutation , standardization , and projection .",
    "as far as we know , the use of labeling and tracing for model checking and debugging purposes has not been previously discussed in the related literature .",
    "in this section , we formalize a backward trace slicing technique for _ elementary rewrite theories _ that is based on a term labeling procedure that is inspired by  @xcite . since equations in @xmath82 are treated as rewrite rules that are used to simplify terms , our formulation for the trace slicing technique is purely based on standard rewriting .",
    "let us define a labeling procedure for rules similar to  @xcite that allows us to trace symbols involved in a rewrite step .",
    "first , we provide the notion of labeling for terms , and then we show how it can be naturally lifted to rules and rewrite steps .",
    "consider a set @xmath134 of _ atomic labels _",
    ", which are denoted by greek letters @xmath135",
    ". _ composite labels _ ( or simply _ labels _ ) are defined as finite sets of elements of @xmath134 . by abuse",
    ", we write the label @xmath136 as a compact denotation for the set @xmath137 .    a _ labeling _ for a term @xmath138 is a map @xmath139 that assigns a label to ( the symbol occurring at ) each position @xmath140 of @xmath0 , provided that @xmath141 .",
    "if @xmath0 is a term , then @xmath142 denotes the labeled version of @xmath0 .",
    "note that , in the case when @xmath0 is a context , occurrences of symbol @xmath39 appearing in the labeled version of @xmath0 are not labeled .",
    "the _ codomain _ of a labeling @xmath139 is denoted by @xmath143 .",
    "an _ initial labeling _ for the term @xmath0 is a labeling for @xmath0 that assigns distinct fresh atomic labels to each position of the term .",
    "for example , given @xmath144 , then @xmath145 is the labeled version of @xmath0 via the initial labeling @xmath146 @xmath147 , @xmath148 @xmath149 .",
    "this notion extends to rules and rewrite steps in a natural way as shown below .",
    "the labeling of a rewriting rule is formalized as follows :    [ def : rulelabel ] ( rule labeling ) @xcite given a rule @xmath150 , a labeling @xmath151 for @xmath26 is defined by means of the following procedure .    *",
    "the redex pattern @xmath152 is labeled by means of an initial labeling @xmath139 . * a new label @xmath93 is formed by joining all the labels that occur in the labeled redex pattern @xmath152 ( say in alphabetical order ) of the rule @xmath26 .",
    "label @xmath93 is then associated with each position @xmath140 of the contractum pattern @xmath153 , provided that @xmath154 .    the labeled version of @xmath26 w.r.t .",
    "@xmath151 is denoted by @xmath155 .",
    "note that the labeling procedure shown in definition [ def : rulelabel ] does not assign labels to variables but only to the function symbols occurring in the rule .      before giving the definition of labeling for a rewrite step , we need to formalize the auxiliary notion of substitution labeling .",
    "( substitution labeling ) [ def : susbtl ] let @xmath156 be a substitution .",
    "a labeling @xmath157 for the substitution @xmath27 is defined by a set of initial labelings @xmath158 such that ( i ) for each binding @xmath159 in the substitution @xmath27 , @xmath160 is labeled using the corresponding initial labeling @xmath161 , and ( ii ) the sets @xmath162 are pairwise disjoint .    by using definition  [ def : susbtl ] , we can formulate a labeling procedure for rewrite steps as follows .",
    "[ def : labelled - step ] ( rewrite step labeling ) let @xmath163 be a rule , and @xmath164 be a rewrite step using @xmath26 such that @xmath165_q$ ] and @xmath166_q$ ] , for a context @xmath167 and position @xmath61 .",
    "let @xmath156 .",
    "let @xmath168 be a labeling for the rule @xmath26 , @xmath169 be an initial labeling for the context @xmath167 , and @xmath170 be a labeling for the substitution @xmath27 such that the sets @xmath171 , and @xmath172 are pairwise disjoint , where @xmath173    the _ rewrite step _ labeling @xmath174 for @xmath175",
    "is defined by successively applying the following steps :    * first , positions of @xmath0 or @xmath8 that belong to the context @xmath167 are labeled by using the initial labeling @xmath169 . * then positions of @xmath176 ( resp .",
    "@xmath63 ) that correspond to the redex pattern ( resp .",
    "contractum pattern ) of the rule @xmath26 rooted at the position @xmath61 are labeled according to the labeling  @xmath168 .",
    "* finally , for each term @xmath177 , @xmath178 , which has been introduced in @xmath0 or @xmath8 via the binding @xmath179 , with @xmath180 , @xmath177 is labeled using the corresponding labeling @xmath181    the labeled version of a rewrite step @xmath175 w.r.t .",
    "@xmath174 is denoted by @xmath182 .",
    "let us illustrate these definitions by means of a rather intuitive example .",
    "[ ex : label - whole ] consider the rule @xmath77 .",
    "the labeled version of rule @xmath26 using the initial labeling @xmath183 is as follows : @xmath184 consider a rewrite step @xmath185 \\stackrel{r}{\\rightarrow } c[\\rho\\sigma ] $ ] using @xmath26 , where @xmath186 = d(f(g(a , h(b)),a),a)$ ] , @xmath187= d(d(s(h(b)),h(b)),a)$ ] , and @xmath188 .",
    "let @xmath189 , @xmath190 , and @xmath191 be the labelings for @xmath167 and the bindings in @xmath27 , respectively .",
    "then , the corresponding labeled rewrite step @xmath192 is as follows @xmath193      given a rewrite step @xmath194 and the labeling process defined in the previous section , the _",
    "backward tracing relation _ computes the set of positions in @xmath0 that are origin for a position @xmath140 in @xmath8 . formally .",
    "[ def : tracing ] ( origin positions ) let @xmath195 be a rewrite step and @xmath139 be a labeling for @xmath175 where @xmath196 ( resp .",
    "@xmath197 ) is the labeling of @xmath0 ( resp .",
    "@xmath8 ) . given a position @xmath140 of @xmath8 , the set of origin positions of @xmath140 in @xmath0 w.r.t .",
    "@xmath175 and @xmath139 ( in symbols , @xmath198 ) is defined as follows : @xmath199    note that definition  [ def : tracing ] considers all positions of @xmath8 in the path from its root to @xmath140 for computing the origin positions of @xmath140 .",
    "roughly speaking , a position @xmath103 in @xmath0 is an origin of @xmath140 , if the label of the symbol that occurs in @xmath142 at position @xmath103 is contained in the label of a symbol that occurs in @xmath200 in the path from its root to the position @xmath140 .",
    "[ ex : back - tracing - relation ] consider again the rewrite step @xmath201 of example  [ ex : label - whole ] , and let @xmath140 be the position @xmath202 of @xmath200 .",
    "the set of labeled symbols occurring in @xmath200 in the path from its root to position @xmath140 is the set @xmath203 .",
    "now , the labeled symbols occurring in @xmath142 whose label is contained in the label of one element of @xmath204 is the set @xmath205 . by definition  [ def : tracing ]",
    ", the set of origin positions of @xmath140 in @xmath192 is @xmath206 .",
    "first , let us formalize the slicing criterion , which basically represents the information we want to trace back across the execution trace in order to find out the `` origins '' of the data we observe . given a term @xmath0 , we denote by @xmath207 the set of _ observed _ positions of @xmath0 .",
    "[ def : slicingcriterion ] ( slicing criterion ) given a rewrite theory @xmath208 and an execution trace @xmath209 in @xmath90 , a slicing criterion for @xmath210 is any set @xmath211 of positions of the term @xmath0 .    in the following ,",
    "we show how backward trace slicing can be performed by exploiting the backward tracing relation @xmath212 that was introduced in definition  [ def : tracing ] .",
    "informally , given a slicing criterion  @xmath213 for @xmath214 , at each rewrite step @xmath215 , @xmath216 , our technique inductively computes the backward tracing relation between the relevant positions of @xmath160 and those in @xmath217 .",
    "the algorithm proceeds backwards , from the final term @xmath218 to the initial term @xmath219 , and recursively generates at step @xmath220 the corresponding set of relevant positions , @xmath221 .",
    "finally , by means of a removal function , a simplified trace is obtained where each @xmath177 is replaced by the corresponding _ term slice _ that contains only the relevant information w.r.t . @xmath222 .",
    "[ def : rlvsym ] ( sequence of relevant position sets ) let @xmath208 be a rewrite theory , and @xmath223 be an execution trace in @xmath90 .",
    "let @xmath224 be the labeling for the rewrite step @xmath225 with @xmath226 .",
    "the sequence of relevant position sets in @xmath112 w.r.t .",
    "the slicing criterion @xmath213 is defined as follows : @xmath227 \\\\ \\mbox{where }    \\begin{cases } p_n = { { \\cal o}}_{t_{n } } \\\\ p_j = \\bigcup_{p\\in p_{j+1 } }   \\lhd^{l_j}_{(t_{j } { \\stackrel{}{\\rightarrow } } ~t_{j+1 } ) } p , \\mbox { with }   0 \\leq j <",
    "n    \\end{cases } \\end{array}\\ ] ]    now , it is straightforward to formalize a procedure that obtains a term slice from each term @xmath0 in @xmath112 and the corresponding set of relevant positions of @xmath0 . we introduce the fresh symbol @xmath228 to replace any information in the term that is not relevant , hence does not affect the observed criterion .    [ def : termslice ] ( term slice ) let @xmath229 be a term and @xmath230 be a set of positions of @xmath0 .",
    "a _ term slice _ of @xmath0 with respect to @xmath230 is defined as follows : @xmath231 @xmath232    in the following , we use the notation @xmath233 to denote a term slice of the term  @xmath0 .",
    "roughly speaking , the symbol @xmath234 can be thought of as a variable , so that any term @xmath235 can be considered as a possible concretization of @xmath233 if it is an  instance \" of @xmath236 $ ] , where @xmath236 $ ] is the term that is obtained by replacing all occurrences of @xmath234 in @xmath233 with fresh variables .",
    "[ def : app ] ( term slice concretization ) given @xmath237 and a term slice @xmath233 , we define @xmath238 if @xmath236 $ ] is ( syntactically ) more general than @xmath239 ( i.e. , @xmath236\\sigma = t'$ ] , for some substitution @xmath27 ) .",
    "we also say that @xmath239 is a concretization of @xmath233 .",
    "figure  [ fig : slice ] illustrates the notions of term slice and term slice concretization for a given term @xmath0 w.r.t .",
    "the set of positions @xmath240 .",
    "@xmath241 \\node { $ \\tt d$ } [ sibling distance=1.2 cm ] child { node { $ \\tt f$ } [ sibling distance=1.2 cm ]    child { node { $ \\tt",
    "g$ } [ sibling distance=1.2 cm ]       child { node { $ \\tt a$ } }       child { node { $ \\tt h$ } [ level distance=.6 cm ] child { node { $ \\tt b$ } }       }    }    child { node { $ \\tt a$ } [ sibling distance=1.2 cm ]    } } child { node { $ \\tt a$ } } ; \\end{tikzpicture }    &    \\begin{tikzpicture }   [ level distance=.5 cm ] \\node { $ \\tt d$ } [ sibling distance=1.2 cm ] child { node { $ \\tt f$ } [ sibling distance=1.2 cm ]    child { node { $ \\tt g$ } [ sibling distance=1.2 cm ]       child { node { $ \\bullet$ } }       child { node { $ \\tt h$ } [ level distance=.6 cm ] child { node { $ \\bullet$ } }       }    }    child { node { $ \\tt a$ } [ sibling distance=1.2 cm ]    } } child { node { $ \\bullet$ } } ; \\end{tikzpicture }    &    \\begin{tikzpicture }   [ level distance=.5 cm ] \\node { $ \\tt d$ } [ sibling distance=1.2 cm ] child { node { $ \\tt f$ } [ sibling distance=1.2 cm ]    child { node { $ \\tt g$ } [ sibling distance=1.2 cm ]       child { node { $ \\tt c$ } }       child { node { $ \\tt h$ } [ level distance=.6 cm ] child { node { $ \\tt c$ } }       }    }    child { node { $ \\tt a$ } [ sibling distance=1.2 cm ]    } } child { node { $ \\tt j$ } [ level distance=.6 cm ] [ sibling distance=1.2 cm ]       child { node { $ \\tt   b$ } } } ; \\end{tikzpicture }    \\\\ \\mbox{term } t & \\mbox{term slice } t^\\bullet",
    "\\mbox { of } t & \\mbox{a concretization of } t^\\bullet \\\\   &   \\mbox { w.r.t.\\ } \\tt \\{1.1.2,~ 1.2\\ } &    \\end{array}\\ ] ]    let us define a _",
    "sliced rewrite step _ between two term slices as follows .",
    "[ def : sliced_rewrite ] ( sliced rewrite step ) let @xmath242 be a rewrite theory and @xmath26 a rule of @xmath90 .",
    "the term slice @xmath243 rewrites to the term slice @xmath233 via @xmath26 ( in symbols , @xmath244 ) if there exist two terms @xmath8 and @xmath0 such that @xmath243 is a term slice of @xmath8 , @xmath233 is a term slice of @xmath0 , and @xmath245 .",
    "finally , using definition [ def : sliced_rewrite ] , backward trace slicing is formalized as follows .",
    "[ def : bak - dyn - tech ] ( backward trace slicing ) let @xmath208 be a rewrite theory , and @xmath223 be an execution trace in @xmath90 .",
    "let @xmath246 be a slicing criterion for @xmath112 , and let @xmath247 $ ] be the sequence of the relevant position sets of @xmath112 w.r.t .",
    "a trace slice @xmath248 of @xmath112 w.r.t .",
    "@xmath246 is defined as the sliced rewrite sequence of term slices @xmath249 which is obtained by gluing together the sliced rewrite steps in the set @xmath250    note that in definition  [ def : bak - dyn - tech ] , the sliced rewrite steps that do not affect the relevant positions ( i.e. , @xmath251 with @xmath252 ) are discarded , which further reduces the size of the trace .",
    "a desirable property of a slicing technique is to ensure that , for any concretization of the term slice @xmath253 , the trace slice @xmath248 can be reproduced .",
    "this property ensures that the rules involved in @xmath248 can be applied again to every concrete trace @xmath254 that we can derive by instantiating all the variables in @xmath255 $ ] with arbitrary terms .",
    "[ prop : reproduded ] ( soundness ) let @xmath90 be an elementary rewrite theory .",
    "let @xmath112 be an execution trace in the rewrite theory @xmath90 , and let @xmath256 be a slicing criterion for @xmath112 .",
    "let @xmath257 be the corresponding trace slice w.r.t .",
    "then , for any concretization @xmath258 of @xmath259 , it holds that @xmath260 is an execution trace in @xmath90 , and @xmath261 , for @xmath30 .",
    "the proof of theorem  [ prop : reproduded ] relies on the fact that redex patterns are preserved by backward trace slicing .",
    "therefore , for @xmath30 , the rule @xmath262 can be applied to any concretization @xmath263 of term @xmath264 since the redex pattern of @xmath262 does appear in @xmath264 , and hence in @xmath263 .",
    "a detailed proof of theorem  [ prop : reproduded ] can be found in appendix  [ app : proof ] .",
    "note that our basic framework enjoys neededness of the extracted information ( in the sense of  @xcite ) , since the information captured by every sliced rewrite step in a trace slice is all and only the information that is needed to produce the data of interest in the reduced term .",
    "in this section , we consider an extension of our basic slicing methodology that allows us to deal with extended rewrite theories @xmath265 where the equational theory @xmath79 may contain associativity and commutativity axioms , and @xmath53 may contain collapsing as well as nonleft - linear rules .",
    "moreover , we also consider the built - in operators , which are not equipped with an explicit functional definition ( e.g. , maude arithmetical operators ) .",
    "it is worth noting that all the proposed extensions are restricted to the labeling procedure of section  [ sec : labeling ] , keeping the backbone of our slicing technique unchanged .      * collapsing rules . *",
    "the main difficulty with collapsing rules is that they have a trivial contractum pattern , which consists in the empty context  @xmath39 ; hence , it is not possible to propagate labels from the left - hand side of the rule to its right - hand side .",
    "this makes the rule labeling procedure of definition  [ def : rulelabel ] completely unproductive for trace slicing .    in order to overcome this problem ,",
    "we keep track of the labels in the left - hand side of the collapsing rule @xmath26 , whenever a rewrite step involving @xmath26 takes place .",
    "this amounts to extending the labeling procedure of definition [ def : labelled - step ] as follows .",
    "[ def : collapsext ] ( rewrite step labeling for collapsing rules ) let @xmath164 be a rewrite step s.t .",
    "@xmath156 , where @xmath266 is a collapsing rule .",
    "let @xmath168 be a labeling for the rule @xmath26 .",
    "in order to label the step @xmath175 , we extend the labeling procedure formalized in definition [ def : labelled - step ] as follows :    * let @xmath160 be the term introduced in @xmath8 via the binding @xmath267 , for some @xmath268 .",
    "then , the label @xmath269 of the root symbol of @xmath270 in @xmath8 is replaced by a new composite label @xmath271 , where @xmath272 is formed by joining all the labels appearing in the redex pattern of @xmath273 .",
    "* nonleft - linear rules .",
    "* the trace slicing technique we described so far does not work for nonleft - linear trs .",
    "consider the rule : @xmath274 and the one - step trace @xmath275 .",
    "if we are interested in tracing back the symbol @xmath276 that occurs in the final state @xmath277 , we would get the following trace slice @xmath278 .",
    "however , @xmath279 is a concretization of @xmath280 that can not be rewritten by using @xmath26 . in the following , we augment definition  [ def : collapsext ] in order to also deal with nonleft - linear rules .",
    "[ def : nllext ] ( rewrite step labeling for nonleft - linear rules ) let @xmath164 be a rewrite step s.t .",
    "@xmath281 , where @xmath26 is a nonleft - linear rule .",
    "let @xmath282 be a labeling for the substitution @xmath27 . in",
    "order to label the step @xmath175 , we further extend the labeling procedure formalized in definition [ def : collapsext ] as follows :    * [ @xmath283 . ] for each variable @xmath284 that occurs more than once in the left - hand side of the rule @xmath26 , the following steps must be followed : * * we form a new label @xmath285 by joining all the labels in @xmath286 where @xmath287 ; * * let @xmath288 be the label of the root symbol of @xmath8 . then",
    ", @xmath288 is replaced by a new composite label @xmath289 .",
    "note that , whenever a rewrite step @xmath175 involves the application of a rule that is both collapsing and non left - linear , the labeling for @xmath175 is obtained by sequentially applying step @xmath290 of definition [ def : collapsext ] and step @xmath283 of definition [ def : nllext ] ( over the labeled rewrite step resulting from @xmath290 ) .",
    "consider the labeled , collapsing and nonleft - linear rule @xmath291 together with the rewrite step @xmath292 , and matching substitution @xmath293 .",
    "let @xmath294 be the labeling for the context @xmath295 .",
    "then , for the labeling @xmath296 , with @xmath297 and @xmath298 , the labeled version of @xmath175 is @xmath299 . finally , by considering the criterion @xmath300 , we can safely trace back the symbol @xmath132 of the sliced final state @xmath301 and obtain the following trace slice @xmath302      in practical implementations of rwl ( e.g. , maude @xcite ) , several commonly used operators are pre - defined ( e.g. , arithmetic operators , if - then - else constructs ) , which do not have an explicit specification .",
    "to overcome this limitation , we further extend our labeling process in order to deal with built - in operators .",
    "[ def : nbuilt - in ] ( rewrite step labeling for built - in operators ) for the case of a rewrite step @xmath303 { \\rightarrow}c[t']$ ] involving a call to a built - in , @xmath304-ary operator @xmath305 , we extend definition [ def : nllext ] by introducing the following additional case :    * given an initial labeling @xmath306 for the term @xmath307 , * * each symbol occurrence in @xmath239 is labeled with a new label that is formed by joining the labels of all the ( labeled ) arguments @xmath46 of @xmath305 ; * * the remaining symbol occurrences of @xmath308 $ ] that are not considered in the previous step inherit all the labels appearing in @xmath309 $ ] .    for example , by applying definition [ def : nbuilt - in ] , the addition of two natural numbers implemented through the built - in operator @xmath310 might be labeled as @xmath311 .",
    "let us finally consider an extended rewrite theory @xmath312 , where @xmath83 is a set of associativity ( a ) and commutativity ( c ) axioms that hold for some function symbols in @xmath80 .",
    "now , since @xmath83 only contains associativity / commutativity ( ac ) axioms , terms can be represented by means of a single representative of their ac congruence class , called _ ac canonical form _  @xcite .",
    "this representative is obtained by replacing nested occurrences of the same ac operator by a flattened argument list under a variadic symbol , whose elements are sorted by means of some linear ordering  . the inverse process to the flat transformation is the unflat transformation , which is nondeterministic ( in the sense that it generates all the unflattended terms that are equivalent ( modulo ac ) to the flattened term )  -matching algorithms that are used to implement rewriting modulo @xmath83 . see  @xcite ( section  @xmath313 ) for an in - depth discussion on matching and simplification modulo ac in maude . ] .",
    "for example , consider a binary ac operator @xmath130 together with the standard lexicographic ordering over symbols .",
    "given the @xmath83-equivalence @xmath314 , we can represent it by using the `` internal sequence '' @xmath315 , where the first one corresponds to the _ flattening _ transformation sequence that obtains the ac canonical form , while the second one corresponds to the inverse , unflattening  one .",
    "the key idea for extending our labeling procedure in order to cope with @xmath83-equivalence @xmath316 is to exploit the flat / unflat transformations mentioned above . without loss of generality",
    ", we assume that flat / unflat transformations are stable w.r.t .",
    "the lexicographic ordering over positions @xmath317 is defined as follows : @xmath318 for every position @xmath140 , and given the positions @xmath319 and @xmath320 , @xmath321 iff @xmath322 or ( @xmath323 and @xmath324 ) .",
    "obviously , in a practical implementation of our technique , the considered ordering among the terms should be chosen to agree with the ordering considered by flat / unflat transformations in the rwl infrastructure . ] .",
    "this assumption allows us to trace back arguments of commutative operators , since multiple occurrences of the same symbol can be precisely identified .",
    "[ def : nac ] ( ac labeling . )",
    "let @xmath130 be an associative - commutative operator and @xmath83 be the ac axioms for @xmath130 .",
    "consider the @xmath83-equivalence @xmath325 and the corresponding ( internal ) flat / unflat transformation @xmath326 .",
    "let @xmath139 be an initial labeling for @xmath327 .",
    "the labeling procedure for @xmath328 is as follows .    1 .",
    "[ flat ] ( flattening ) for each flattening transformation step @xmath329 in @xmath112 for the symbol @xmath130 , a new label @xmath330 is formed by joining all the labels attached to the symbol @xmath130 in any position @xmath140 of @xmath331 s.t .",
    "@xmath332 or @xmath333 , and every symbol on the path from @xmath103 to @xmath140 is @xmath130 ; then , label @xmath330 is attached to the root symbol of  @xmath334 .",
    "[ unflat ] ( unflattening ) for each unflattening transformation step @xmath335 in @xmath112 for the symbol @xmath130 , the label of the symbol @xmath130 in the position @xmath103 of @xmath142 is attached to the symbol @xmath130 in any position @xmath140 of @xmath239 such that @xmath332 or @xmath333 , and every symbol on the path from @xmath103 to @xmath140 is @xmath130 .",
    "the remaining symbol occurrences in @xmath239 that are not considered in cases [ flat ] or [ unflat ] above inherit the label of the corresponding symbol occurrence in @xmath0 .",
    "consider the transformation sequence @xmath336 by using definition [ def : nac ] , the associated transformation sequence can be labeled as follows : @xmath337note that the original order between the two occurrences of the constant @xmath132 is not changed by the flat / unflat transformations .",
    "for example , in the first term , @xmath338 is in position  @xmath339 and @xmath340 is in position @xmath341 with @xmath342 , whereas , in the last term , @xmath338 is in position  @xmath343 and @xmath340 is in position @xmath344 with @xmath345 .",
    "finally , note that the methodology described in this section can be easily extended to deal with other equational attributes , e.g. , identity ( u ) , by explicitly encoding the internal transformations performed via suitable rewrite rules .",
    "soundness of the backward trace slicing algorithm for the extended rewrite theories is established by the following theorem which properly extends theorem  [ prop : reproduded ] .",
    "the proof of such an extension can be found in appendix  [ app : proof ] .",
    "[ prop : reproduded2 ] ( extended soundness ) let @xmath86 be an extended rewrite theory .",
    "let @xmath112 be an execution trace in the rewrite theory @xmath90 , and let @xmath256 be a slicing criterion for @xmath112 .",
    "let @xmath257 be the corresponding trace slice w.r.t .",
    "then , for any concretization @xmath258 of @xmath259 , it holds that @xmath260 is an execution trace in @xmath90 , and @xmath261 , for @xmath30 .",
    "we have developed a prototype implementation of our slicing methodology that is publicly available at http://www.dsic.upv.es/~dromero/slicing.html .",
    "the implementation is written in maude and consists of approximately 800 lines of code .",
    "maude is a high - performance , reflective language that supports both equational and rewriting logic programming , which is particularly suitable for developing domain - specific applications  @xcite .",
    "the reflection capabilities of maude allow metalevel computations in rwl to be handled at the object - level .",
    "this facility allows us to easily manipulate computation traces of maude itself and eliminate the irrelevant contents by implementing the backward slicing procedures that we have defined in this paper .",
    "using reflection to implement the slicing tool has one important additional advantage , namely , the ability to quickly integrate the tool within the maude formal tool environment @xcite , which is also developed using reflection .",
    "we developed the operator slice that implements the slicing process .",
    "this operator is invoked as follows : @xmath346 where @xmath347 is the name of the maude module that includes the rules and the equations to be considered in the slicing process ; @xmath348 and @xmath349 are the initial state and the final state , respectively , of the execution trace ; and @xmath350 is the slicing criterion .",
    "the operator works as follows .",
    "first , by considering the rules and equation in @xmath347 , the instrumented execution trace stemming from the initial state that leads to the final state is computed .",
    "then , the slicing procedure is executed with the instrumented computation trace and the slicing criterion as inputs .",
    "finally , a pair that contains the sliced trace and the original execution trace is delivered as outcome of the process .    in order to evaluate the usefulness of our approach",
    ", we benchmarked our prototype with several examples of maude applications , namely : _ war of souls _",
    "( wos ) , a role - playing game that is modeled as a nontrivial producer / consumer application ; _ fault - tolerant communication protocol _ ( ftcp ) , a maude specification that models a fault - tolerant , client - server communication protocol ; and web - tlr , a software tool designed for model - checking real - size web applications ( e.g. , web - mailers , electronic forums ) , which is based on rewriting logic .",
    "we have tested our tool on some execution traces that were generated by the maude applications described above by imposing different slicing criteria . for each application",
    ", we considered two execution traces that were sliced using two different criteria .",
    "as for the @xmath351 example , we have chosen criteria that allow us to backtrace both the values produced and the entities in play  e.g. , the criterion @xmath352 isolates players behaviors along the trace @xmath353 . execution traces in the ` ftcp ` example represent client - server interactions . in this case",
    ", the chosen criteria aim at isolating a server and a client in a scenario that involves multiple servers and clients ( @xmath354 ) , and tracking the response generated by a server according to a given client request ( @xmath355 ) . in the last example , we have used web - tlr to verify two ltl(r ) properties of a webmail application .",
    "the considered execution traces are much bigger for this program , and correspond to the counterexamples produced as outcome by the built - in model - checker of web - tlr . in this case , the chosen criteria allow us to monitor the messages exchanged by the web browsers and the webmail server , as well as to focus our attention on the data structures of the interacting entities ( e.g. , browser / server sessions , server database )",
    ".    table [ tab : exp ] summarizes the results we achieved . for each criterion ,",
    "table  [ tab : exp ] shows the size of the original trace and of the computed trace slice , both measures as the length of the corresponding string .",
    "the _ % reduction _ column shows the percentage of reduction achieved .",
    "these results are very encouraging , and show an impressive reduction rate ( up to @xmath356 ) . actually , sometimes the trace slices are small enough to be easily inspected by the user , who can restrict her attention to the part of the computation she wants to observe getting rid of those data that are useless or even noisy w.r.t .   the considered slicing criterion .",
    "& * trace * & * trace size * & * criterion * & * trace size * & * _ reduction _ * +    & & & @xmath357 & @xmath358 & @xmath359 + & & & @xmath352 & @xmath360 & @xmath361 + & & & @xmath362 & @xmath363 & @xmath364 + & & & @xmath365 & @xmath366 & @xmath367 +    & & & @xmath355 & @xmath368 & @xmath369 + & & & @xmath370 & @xmath371 & @xmath372 + & & & @xmath354 & @xmath373 & @xmath374 + & & & @xmath375 & @xmath376 & @xmath377 +    & & & @xmath378 & @xmath379 & @xmath380 + & & & @xmath381 & @xmath382 & @xmath383 + & & & @xmath384 & @xmath385 & @xmath386 + & & & @xmath387 & @xmath388 & @xmath389 +",
    "we have presented a backward trace - slicing technique for rewriting logic theories .",
    "the key idea consists in tracing back through the rewrite sequence all the relevant symbols of the final state that we are interested in .",
    "preliminary experiments demonstrate that the system works very satisfactorily on our benchmarks e.g .",
    ", we obtained trace slices that achieved a reduction of up to almost @xmath390 in reasonable time ( max .",
    "0.5s on a linux box equipped with an intel core 2 duo 2.26ghz and 4 gb of ram memory ) .",
    "tracing techniques have been extensively used in functional programming for implementing debugging tools  @xcite .",
    "for instance , hat  @xcite is an interactive debugging system that enables exploring a computation backwards , starting from the program output or an error message ( with which the computation aborted ) .",
    "backward tracing in hat is carried out by navigating a redex trail ( that is , a graph - like data structure that records dependencies among function calls ) , whereas tracing in our approach does not require the construction of any auxiliary data structure .",
    "our backward tracing relation extends a previous tracing relation that was formalized in  @xcite for orthogonal trss . in  @xcite",
    ", a label is formed from atomic labels by using the operations of sequence concatenation and underlining ( e.g. , @xmath78 , @xmath132 , @xmath391 , @xmath392 , are labels ) , which are used to keep track of the rule application order .",
    "collapsing rules are simply avoided by coding them away .",
    "this is done by replacing each collapsing rule @xmath393 with the rule @xmath394 , where @xmath34 is a unary dummy symbol .",
    "then , in order to lift the rewrite relation to terms containing @xmath395 occurrences , infinitely many new extra - rules are added that are built by saturating all left - hand sides with @xmath396 .",
    "in contrast to  @xcite , we use a simpler notion of labeling , where composite labels are interpreted as sets of atomic labels , and in the case of collapsing as well as nonleft - linear rules we label the rewrite steps themselves so that we can deal with these rules in an effective way .",
    "the work that is most closely related to ours is  @xcite , which formalizes a notion of dynamic dependence among symbols by means of contexts and studies its application to program slicing of trss that may include collapsing as well as nonleft - linear rules .",
    "both the _ creating _ and the _ created _ contexts associated with a reduction ( i.e. , the minimal subcontext that is needed to match the left - hand side of a rule and the minimal context that is `` constructed '' by the right - hand side of the rule , respectively ) are tracked .",
    "intuitively , these concepts are similar to our notions of redex and contractum patterns .",
    "the main differences with respect to our work are as follows .",
    "first , in @xcite the slicing is given as a context , while we consider term slices .",
    "second , the slice is obtained only on the first term of the sequence by the transitive and reflexive closure of the dependence relation , while we slice the whole execution trace , step by step .",
    "obviously , their notion of slice is smaller , but we think that our approach can be more useful for trace analysis and program debugging .",
    "an extension of  @xcite is described in  @xcite , which provides a generic definition of labeling that works not only for orthogonal trss as is the case of  @xcite but for the wider class of all left - linear trss .",
    "the nonleft - linear case is not handled by @xcite .",
    "specifically , @xcite  describes a methodology of static and dynamic tracing that is mainly based on the notion of _ sample of a traced proof term _ i.e .",
    ", a pair @xmath397 that records a rewrite step @xmath398 , and a set @xmath230 of reachable positions in @xmath0 from a set of observed positions in @xmath8 .",
    "the tracing proceeds forward , while ours employs a backward strategy that is particularly convenient for error diagnosis and program debugging .",
    "finally , @xcite and @xcite apply to trss whereas we deal with the richer framework of rwl that considers equations and equational axioms , namely rewriting modulo equational theories .",
    "10 [ 1]`#1 `    alpuente , m. , ballis , d. , baggi , m. , falaschi , m. : a fold / unfold transformation framework for rewrite theories extended to cct . in : proc .",
    "2010 acm sigplan workshop on partial evaluation and program manipulation , ( pepm 2010 ) .",
    "4352 . acm ( 2010 )    alpuente , m. , ballis , d. , espert , j. , romero , d. : model - checking web applications with web - tlr . in : 8th intl symposium on automated technology for verification and analysis ( atva 2010 ) .",
    "lecture notes in computer science , vol . 6252 , pp .",
    "341346 . springer ( 2010 )    alpuente , m. , ballis , d. , espert , j. , romero , d. : backward trace slicing for rewriting logic theories . in : the 23rd intl conference on automated deduction ( cade 2011 ) .",
    "lncs / lnai , springer ( 2011 ) , to appear .",
    "alpuente , m. , ballis , d. , romero , d. : specification and verification of web applications in rewriting logic . in : formal methods , second world congress ( fm 2009 ) .",
    "lecture notes in computer science , vol . 5850 , pp .",
    "springer ( 2009 )    baggi , m. , ballis , d. , falaschi , m. : quantitative pathway logic for computational biology . in : proc . of 7th intl conference on computational methods in systems biology ( cmsb09 ) .",
    "lecture notes in computer science , vol .",
    "5688 , pp .",
    "springer ( 2009 )    bethke , i. , klop , j.w .",
    ", de  vrijer , r. : descendants and origins in term rewriting . inf .",
    "159(1 - 2 ) , 59124 ( 2000 )    boudol , g. : computational semantics of term rewriting systems , pp .",
    "169236 . cambridge university press , new york , ny , usa ( 1986 )    chen , f. , rosu , g. : parametric trace slicing and monitoring . in : 15th international conference on tools and algorithms for the construction and analysis of systems ( tacas09 ) .",
    "lecture notes in computer science , vol . 5505 , pp .",
    "springer ( 2009 )    chitil , o. , runciman , c. , wallace , m. : freja , hat and hood - a comparative evaluation of three systems for tracing and debugging lazy functional programs . in : implementation of functional languages , 12th international workshop ( ifl 2000 ) .",
    "lecture notes in computer science , vol .",
    "2011 , pp . 176193 .",
    "springer ( 2000 )    clavel , m. , durn , f. , eker , s. , lincoln , p. , mart - oliet , n. , meseguer , j. , talcott , c. : all about maude : a high - performance logical framework , lecture notes in computer science , vol .",
    "springer - verlag ( 2007 )    clavel , m. , durn , f. , hendrix , j. , lucas , s. , meseguer , j. , lveczky , p.c .",
    ": the maude formal tool environment . in : algebra and coalgebra in computer science ( calco07 ) .",
    "lecture notes in computer science , vol .",
    "4624 , pp .",
    "springer ( 2007 )    eker , s. : associative - commutative rewriting on large terms . in : proc . of 14th intl conference ,",
    "rewriting techniques and applications ( rta 03 ) .",
    "lecture notes in computer science , vol .",
    "2706 , pp .",
    "springer ( 2003 )    eker , s. , meseguer , j. , sridharanarayanan , a. : the maude ltl model checker and its implementation . in : model checking software : proc .",
    "10 th intl .",
    "spin workshop .",
    "lecture notes in computer science , vol . 2648 , pp .",
    "springer ( 2003 )    field , j. , tip , f. : dynamic dependence in term rewriting systems and its application to program slicing . in : proc . of the 6th intl symposium on programming language implementation and logic programming ( plilp94 ) .",
    "springer - verlag , london , uk ( 1994 )    hyland , m. : a syntactic characterization of the equality in some models for the lambda calculus .",
    "j. london math .",
    "soc 12 , 361370 ( 1976 )    khasidashvili , z. : @xmath399-reductions and @xmath399-developments of @xmath62-terms with the least number of steps . in : proc . international conference on computer logic ( colog88 ) .",
    "lecture notes in computer science , vol .",
    "105111 . springer ( 1990 )    khasidashvili , z. : optimal normalization in orthogonal term rewriting systems . in : proc .",
    "rewriting techniques and applications ( rta93 ) .",
    "lecture notes in computer science , vol .",
    "springer ( 1993 )    lvy , j. : an algebraic interpretation of the _ lambda beta _",
    "k - calculus ; and an application of a labelled _ lambda_-calculus .",
    "2(1 ) , 97114 ( 1976 )    mart - oliet , n. , meseguer , j. : rewriting logic : roadmap and bibliography .",
    "theoretical computer science 285(2 ) , 121154 ( 2002 )    riesco , a. , verdejo , a. , mart - oliet , n. : declarative debugging of missing answers for maude . in : 21st intl conference on rewriting techniques and applications ( rta 2010 ) .",
    "lipics , vol .  6 , pp . 277294 .",
    "schloss dagstuhl - leibniz - zentrum fuer informatik ( 2010 )    talcott , c. : pathway logic .",
    "formal methods for computational systems biology 5016 , 2153 ( 2008 )    terese ( ed . ) : term rewriting systems .",
    "cambridge university press , cambridge , uk ( 2003 )    wadsworth , c.p . :",
    "the relation between computational and denotational properties for scott s @xmath400-models of the lambda - calculus .",
    "siam j. comput .",
    "5(3 ) , 488521 ( 1976 )",
    "[ le : instance ] let @xmath233 be a term slice , and let @xmath239 be a term such that @xmath238 . for every position @xmath401",
    ", it holds that , either @xmath402 , or there exists a position @xmath24 of @xmath233 such that @xmath403 and @xmath404 .",
    "the following definitions are auxiliary .",
    "let @xmath167 be a context .",
    "we define the set of positions of @xmath167 as the set @xmath405 . given a term @xmath0 , by @xmath406 ,",
    "we denote the set of symbols in @xmath0 that occur in the path from its root to the position @xmath140 of @xmath0 , e.g. , @xmath407 .",
    "let @xmath408 be a rule of @xmath90 .",
    "let @xmath409 be a rewrite step such that @xmath410 $ ] and @xmath411 $ ] .",
    "given a position @xmath140 , we say that @xmath140 _ is involved in _",
    "@xmath175 , if there exist @xmath412 and @xmath413 such that @xmath414 , @xmath415 and @xmath416 .",
    "[ le : singlepos ] let @xmath408 be a rule of an elementary rewrite theory @xmath90 .",
    "let @xmath409 be a rewrite step such that @xmath410 $ ] and @xmath411 $ ] , where @xmath27 is a substitution and @xmath167 is a context .",
    "let @xmath139 be a labeling for the rewrite step @xmath175 , and @xmath417",
    ".      given the rule @xmath421 and the labeling @xmath139 for the rewrite step @xmath409 , let us consider the labeled rewrite step @xmath422 . by definition [ def : labelled - step ] , we can decompose the labeling @xmath139 into three labelings @xmath169 , @xmath168 , and @xmath423 that respectively label the context @xmath167 , the redex and the contractum patterns appearing in @xmath175 , and the terms in @xmath175 introduced by the substitution @xmath27 . in other words , we have @xmath424 $ ] and @xmath425 $ ] .      * claim 1 .",
    "* we assume that @xmath417 and @xmath418 .",
    "since the context @xmath167 has the same initial labeling @xmath426 in both @xmath8 and @xmath0 , and the sets @xmath427 , @xmath428 , and @xmath429 are pairwise disjoint , the set of origin positions @xmath430 in @xmath8 is the set of positions lying on the path from the root position of @xmath8 to @xmath140 .",
    "hence , @xmath419 .",
    "* claim 2 . *",
    "we assume that @xmath414 , @xmath415 , and @xmath416 .",
    "then , since @xmath26 belongs to an elementary rewrite theory @xmath90 , @xmath26 is non - collapsing .",
    "this implies that there exists a labeled symbol @xmath431 belonging to the contractum pattern of the rule @xmath26 . by definition [ def : rulelabel ] , for each labeled symbol @xmath432 in the redex pattern of @xmath26 , we have that @xmath433 .",
    "now , since the redex pattern of @xmath26 is embedded into @xmath8 and the contractum pattern of @xmath26 is embedded into @xmath0 , the inclusion @xmath434 trivially holds by definition  [ def : tracing ] .",
    "the following lemma establishes that , given the rewrite step @xmath435 and a term slice @xmath436 of @xmath219 , any concretization of @xmath436 is reduced by the rule @xmath26 to the corresponding term slice concretization of @xmath327 .",
    "[ le : relevant ] let @xmath421 be a rule of an elementary rewrite theory @xmath90 .",
    "let @xmath437 be a rewrite step such that @xmath438 $ ] and @xmath439 $ ] , where @xmath27 is a substitution and @xmath167 is a context .",
    "let @xmath139 be a labeling for the rewrite step @xmath175 , and @xmath440 $ ] be the sequence of the relevant position sets for @xmath437 w.r.t .",
    "the slicing criterion @xmath256 .",
    "let @xmath441 , and @xmath442 .        * claim 1 . *",
    "let @xmath443 . then , by lemma [ le : singlepos ] ( claim @xmath339 ) , for any @xmath450 , @xmath419 . additionally , by definition [ def : rlvsym ] , @xmath451 , and hence @xmath452 .",
    "therefore , it holds that ( i ) @xmath453 , and for any @xmath454 , there exists a position @xmath455 such that @xmath456 for some @xmath450 ; ( ii ) by definition [ def : termslice ] , the function @xmath457 delivers a term slice @xmath233 where all the symbols of @xmath0 that do not occur in the path connecting the root position of @xmath0 with some position @xmath458 are abstracted by the @xmath234 symbol .",
    "now , since @xmath441 and @xmath442 , by ( i ) and ( ii ) , we can conclude that @xmath459 and @xmath65 are abstracted by @xmath234 , and the context @xmath167 is abstracted by the term slice @xmath460 in both @xmath219 and @xmath327 .",
    "hence , @xmath461=t_1^\\bullet$ ] .",
    "* claim 2 . *",
    "we assume @xmath445 , @xmath446 , and @xmath447 .",
    "then , there exists a position @xmath450 such that @xmath462 , @xmath446 , and @xmath463 .",
    "by lemma [ le : singlepos ] ( claim @xmath464 ) , it follows that @xmath465 . by definition [ def : rlvsym ] , @xmath466 , and hence @xmath467 .",
    "now , by definition [ def : termslice ] and the fact that @xmath467 , the redex pattern of the rule @xmath26 is embedded into @xmath441 . in other words , @xmath468 $ ] , where @xmath460 is a term slice for the context @xmath167 , and @xmath469 represents the term slices for the terms introduced by the substitution @xmath27 .",
    "thus , by lemma [ le : instance ] , any concretization @xmath258 of @xmath259 has the form @xmath470 $ ] , where @xmath471 and for each @xmath472 , there exists @xmath473 such that @xmath474 .",
    "note also that @xmath259 embeds the redex pattern @xmath73 of @xmath26 .",
    "furthermore , since @xmath26 belongs to the elementary rewrite theory @xmath90 , @xmath26 is left - linear .",
    "thus , the following rewrite step @xmath475 can be executed for any substitution @xmath476 .",
    "the rewrite step @xmath475 can be decomposed as follows : @xmath477 \\stackrel{r,\\sigma'}{{\\rightarrow } } c'[\\rho\\sigma']$ ] , for some context @xmath478 and substitution @xmath476 .",
    "moreover , by definition of rewrite step , @xmath479 embeds the contractum pattern of @xmath26 .",
    "finally , @xmath480 $ ] , and thus @xmath481 is a concretization of @xmath482 .",
    "[ pr : onestep ] let @xmath90 be an elementary rewrite theory .",
    "let @xmath112 be an execution trace in @xmath90 , and let @xmath256 be a slicing criterion for @xmath112 .",
    "let @xmath483 be the trace slice w.r.t .",
    "@xmath256 of @xmath112 .",
    "then , for any concretization @xmath258 of @xmath259 , it holds that @xmath484 is an execution trace in @xmath90 such that @xmath449 .",
    "given the trace slice @xmath483 w.r.t .",
    "@xmath256 of @xmath112 , let @xmath440 $ ] be the sequence of the relevant position sets of @xmath112 w.r.t .",
    "we have ( i ) @xmath485 and @xmath486 , where @xmath487 is a rewrite step occurring in @xmath112 ; ( ii ) @xmath488 .",
    "let @xmath119 be the rule @xmath67 .",
    "the rewrite step @xmath487 can be decomposed as follows : @xmath489\\stackrel{r_1}{\\rightarrow } c[\\rho\\sigma]=s_1 $ ] , for some context @xmath167 and substitution @xmath27 .    since @xmath90 is elementary and @xmath488 , by claim @xmath339 of lemma [ le : relevant ] , @xmath490 .",
    "hence , there exists a position @xmath450 such that @xmath456 and @xmath491 . also , because @xmath90 is elementary , we can apply claim @xmath464 of lemma  [ le : relevant ] , and for any concretization @xmath258 of @xmath259 , we get @xmath492 such that @xmath481 is a concretization of @xmath482 .    * theorem [ prop : reproduded ] . *",
    "_ ( soundness )",
    "_ _ let @xmath90 be an elementary rewrite theory .",
    "let @xmath112 be an execution trace in @xmath90 and let @xmath256 be a slicing criterion for @xmath112 .",
    "let @xmath257 be the corresponding trace slice w.r.t .",
    "then , for any concretization @xmath258 of @xmath259 , it holds that @xmath260 is an execution trace in @xmath90 , and @xmath261 , for @xmath30 . _        in oder to prove theorem  2 , we use the same proof scheme as for elementary rewrite theories , since the extended technique described in section  [ sec :",
    "slicing - m - e ] is only concerned with suitable extensions of the labeling procedure given in definition  [ def : labelled - step ] , which do not affect the overall backward trace slicing methodology .",
    "[ le : singlepos - ext ] let @xmath408 be a rule that is either nonleft - linear or collapsing .",
    "let @xmath409 be a rewrite step such that @xmath410 $ ] and @xmath411 $ ] , where @xmath27 is a substitution and @xmath167 is a context .",
    "let @xmath139 be a labeling for the rewrite step @xmath175 , and @xmath417 .",
    "then ,            * case 1 : rule @xmath26 is collapsing . * : :    given the collapsing rule @xmath493    where @xmath494 with    @xmath495 , let us consider the term    @xmath160 introduced by the substitution @xmath27    via the binding @xmath496 , and we have    @xmath497 \\stackrel{r}{\\rightarrow } c[t_i]$ ] .",
    "let us also consider the labeled rewrite step    @xmath498    via the labeling @xmath139 . by definition  [ def : labelled - step ] ,    we have @xmath424 $ ] and    @xmath499 $ ] .",
    "+    let @xmath500 be the labeled root symbol of    @xmath501 . by definition  [ def : collapsext ] ( step    @xmath290 )",
    ", we have that @xmath502 ,    where @xmath503 is formed by joining all the labels    appearing in the redex pattern @xmath504 and    @xmath269 is the label of the root of the labeled term    @xmath501 .",
    "this implies that , for each labeled    symbol @xmath432 in the redex pattern of @xmath26 , we    have that @xmath505 .",
    "furthermore , by hypothesis , we    have that @xmath506 $ ] and    @xmath507 .",
    "hence , by definition  [ def : tracing ] ,    the inclusion    @xmath434    trivially holds . *",
    "case 2 : rule @xmath26 is nonleft - linear . * : :    given the nonleft - linear rule @xmath26 , the proof is perfectly    analogous to the proof of lemma  [ le : singlepos ] since , by    definition  [ def : nllext ] ( step @xmath283 ) , the label of each    symbol in the contractum pattern of the rule @xmath26 includes    all the labels appearing in the redex pattern of @xmath26 . * case 3 : rule @xmath26 is collapsing and nonleft - linear . * : :    since @xmath26 is both collapsing and nonleft - linear ,    @xmath175",
    "is labelled according to definition  [ def : collapsext ]    ( step @xmath290 ) and definition  [ def : nllext ] ( step    @xmath283 ) .",
    "therefore , we can prove the claim by simply    combining the arguments used to prove case @xmath339 ad case    @xmath464 .",
    "[ le : relevant - extended ] let @xmath421 be a rule which is either left - linear or collapsing .",
    "let @xmath437 be a rewrite step such that @xmath438 $ ] and @xmath439 $ ] , where @xmath27 is a substitution and @xmath167 is a context .",
    "let @xmath139 be a labeling for the rewrite step @xmath175 , and @xmath440 $ ] be the sequence of the relevant position sets for @xmath437 w.r.t .",
    "the slicing criterion @xmath256 .",
    "let @xmath441 , and @xmath442 .",
    "then ,          * case 1 : rule @xmath26 is collapsing .",
    "* : :    given the collapsing rule @xmath26 , the proof is perfectly    analogous to the one of lemma [ le : relevant ] claim 2 . by using lemma    [ le : singlepos - ext ] instead of lemma  [ le :",
    "singlepos ] , we are still able    to prove that the redex pattern of @xmath26 embedded in    @xmath219 is also embedded in @xmath259 , and    hence for any concretization @xmath508 of    @xmath259 , the rewrite step    @xmath448 can be    proved . finally , by using the same argument of lemma [ le : relevant ]    claim 2 , we conclude that @xmath449 .",
    "* case 2 : rule @xmath26 is nonleft - linear . *",
    ": :    given the nonleft - linear rule @xmath26 , the proof is similar to    the one of lemma  [ le : relevant ] . by exploiting lemma [ le : singlepos - ext ]    and definition  [ def : nllext ] ( step @xmath283 )",
    ", we can show that    ( i ) the redex pattern of @xmath26 embedded in @xmath219    is also embedded in @xmath259 , and ( ii ) for each term    @xmath0 introduced in @xmath219 by a binding    @xmath509 such that @xmath21 occurs multiple    times in @xmath62 , @xmath0 is preserved in    @xmath259 ( i.e. , @xmath0 is not abstracted by    @xmath234 in @xmath259 ) . by ( i ) and",
    "( ii ) ,    it is immediate to prove that , for any concretization    @xmath258 of @xmath259 , the rewrite step    @xmath448 can be    proved . finally , by using the same argument of lemma [ le :",
    "relevant ]    claim 2 , we can show that @xmath510 .",
    "* case 3 : rule @xmath26 is collapsing and nonleft - linear . * : :    firstly we observe that , as the rule @xmath26 is collapsing , by    lemma  [ le : singlepos - ext ] the redex pattern of @xmath26 embedded    in @xmath219 is also embedded in @xmath259 ,    and hence for any concretization @xmath258 of    @xmath259 , the redex pattern of @xmath26 is    embedded in @xmath258 as well . secondly ,",
    "since    @xmath26 is nonleft - linear , by lemma [ le : singlepos - ext ] and    definition  [ def : nllext ] ( step @xmath283 ) , for each term    @xmath0 introduced in @xmath219 by a binding    @xmath509 such that @xmath21 occurs multiple    times in @xmath62 , @xmath0 is preserved in    @xmath259 .",
    "hence , @xmath0 is also embedded in    @xmath258 , for any concretization @xmath258 of    @xmath259 .",
    "from the two facts above , it directly    follows that for any @xmath258 such that    @xmath511 , the rewrite step    @xmath448 can be    proved . finally , by using the same argument of lemma [ le : relevant ]    claim 2",
    ", we can show that @xmath510 .",
    "[ pr : onestep - ext ] let @xmath90 be an extended rewrite theory .",
    "let @xmath512 be an execution trace in @xmath90 , and let @xmath256 be a slicing criterion for @xmath112 .",
    "let @xmath483 be the trace slice w.r.t .",
    "@xmath256 of @xmath112 .",
    "then , for any concretization @xmath258 of @xmath259 , it holds that @xmath484 is an execution trace in @xmath90 such that @xmath449 .",
    "consider the rewrite step @xmath513 . in the case",
    "when @xmath119 is left - linear and non - collapsing ( i.e. , a rule belonging to an elementary rewrite theory ) , the proof is identical to the proof of proposition  [ pr : onestep - ext ] . hence w.l.o.g .",
    "we assume that @xmath26 corresponds to a collapsing or nonleft - linear rule , built - in operator evaluation , or ac axiom .",
    "let @xmath514 $ ] and @xmath515 $ ] .",
    "hence , @xmath516 { \\rightarrow}c[t']$ ] is a rewrite step mimicking the evaluation of the built - in operator call @xmath517 . by definition  [ def : nbuilt - in ] and definition [ def : tracing ] , it is immediate to show that @xmath517 is embedded in @xmath259 , and thus for any concretization @xmath518 , @xmath519 and @xmath510 .",
    "flat / unflat transformations are interpreted as rewrite steps that reduce ac symbols .",
    "let us first consider the flat transformation @xmath520 that reduces the ac symbol @xmath130 . by definition  [ def : nac ] , the label of the occurrence of @xmath130 in @xmath239 contains all the labels of the different occurrences of @xmath130 appearing in @xmath0 that have been reduced by the transformation . in other words ,",
    "the label of @xmath130 in @xmath239 keeps track of all the occurrences of @xmath130 that have been reduced in @xmath0 , and therefore the claim holds directly .",
    "the claim for unflat transformations can be proved in a similar way",
    ".      * theorem 2 . * _ ( extended soundness ) _ _ let @xmath86 be an extended rewrite theory .",
    "let @xmath112 be an execution trace in the rewrite theory @xmath90 , and let @xmath256 be a slicing criterion for @xmath112 .",
    "let @xmath257 be the corresponding trace slice w.r.t .",
    "then , for any concretization @xmath258 of @xmath259 , it holds that @xmath260 is an execution trace in @xmath90 and @xmath261 , for @xmath30 . _"
  ],
  "abstract_text": [
    "<S> trace slicing is a widely used technique for execution trace analysis that is effectively used in program debugging , analysis and comprehension . in this paper </S>",
    "<S> , we present a backward trace slicing technique that can be used for the analysis of rewriting logic theories .    </S>",
    "<S> our trace slicing technique allows us to systematically trace back rewrite sequences modulo equational axioms ( such as associativity and commutativity ) by means of an algorithm that dynamically simplifies the traces by detecting control and data dependencies , and dropping useless data that do not influence the final result . </S>",
    "<S> our methodology is particularly suitable for analyzing complex , textually - large system computations such as those delivered as counter - example traces by maude model - checkers . </S>"
  ]
}