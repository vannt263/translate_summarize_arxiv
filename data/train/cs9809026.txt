{
  "article_text": [
    "given some word sequence @xmath5 , speech recognition language models are used to hypothesize the next word @xmath6 , which could be any word from the vocabulary @xmath7 .",
    "this is typically done using a probability model @xmath8 .",
    "based on the assumption that modelling the hidden structure of natural language would improve performance of such language models , some researchers tried to use stochastic context - free grammars ( cfgs ) to produce language models @xcite .",
    "the probability model used for a stochastic grammar was @xmath9",
    ". however , language models that are based on trigram probability models out - perform stochastic cfgs .",
    "the common wisdom about this failure of cfgs is that trigram models are lexicalized models while cfgs are not .",
    "tree adjoining grammars ( tags ) are important in this respect since they are easily lexicalized while capturing the constituent structure of language .",
    "more importantly , tags allow greater linguistic expressiveness . the trees associated with words can be used to encode argument and adjunct relations in various syntactic environments .",
    "this paper assumes some familiarity with the tag formalism . @xcite and @xcite are good introductions to the formalism and its linguistic relevance .",
    "tags have been shown to have relations with both phrase - structure grammars and dependency grammars @xcite , which is relevant because recent work on _ structured _ language models @xcite have used dependency grammars to exploit their lexicalization .",
    "we use stochastic tags as such a _ structured _ language model in contrast with earlier work where tags have been exploited in a class - based @xmath10-gram language model  @xcite .",
    "this paper derives an algorithm to compute prefix probabilities @xmath1 .",
    "the algorithm assumes as input a stochastic tag @xmath11 and a string which is a prefix of some string in @xmath12 , the language generated by @xmath11 .",
    "this algorithm enables existing corpus - based estimation techniques @xcite in stochastic tags to be used for language modelling .",
    "a stochastic tree adjoining grammar ( stag ) is represented by a tuple @xmath13 where @xmath14 is a set of nonterminal symbols , @xmath7 is a set of terminal symbols , @xmath15 is a set of * initial * trees and @xmath16 is a set of * auxiliary * trees . trees in @xmath17 are also called * elementary * trees .    we refer to the root of an elementary tree @xmath18 as @xmath19 .",
    "each auxiliary tree has exactly one distinguished leaf , which is called the * foot*. we refer to the foot of an auxiliary tree @xmath18 as @xmath20 .",
    "we let @xmath21 denote the set of all nodes in the elementary trees .    for each leaf @xmath22 in an elementary tree , except when it is a foot , we define @xmath23 to be the label of the node , which is either a terminal from @xmath7 or the empty string @xmath24 . for each other node @xmath22",
    ", @xmath23 is an element from @xmath14 .    at a node @xmath22 in a tree such that @xmath25 an operation called * adjunction * can be applied , which excises the tree at @xmath22 and inserts an auxiliary tree .",
    "function @xmath26 assigns a probability to each adjunction .",
    "the probability of adjunction of @xmath27 at node @xmath22 is denoted by @xmath28 .",
    "the probability that at @xmath22 no adjunction is applied is denoted by @xmath29 .",
    "we assume that each stag @xmath11 that we consider is * proper*. that is , for each @xmath22 such that @xmath25 , @xmath30    for each non - leaf node @xmath22 we construct the string @xmath31 from the ( ordered ) list of children nodes @xmath32 by defining , for each @xmath33 such that @xmath34 , @xmath35 in case @xmath36 , and @xmath37 otherwise .",
    "in other words , children nodes are replaced by their labels unless the labels are nonterminal symbols .    to simplify the exposition , we assume an additional node for each auxiliary tree @xmath18 , which we denote by @xmath38 .",
    "this is the unique child of the actual foot node @xmath20 .",
    "that is , we change the definition of @xmath39 such that @xmath40 for each auxiliary tree @xmath18 .",
    "we set @xmath41    we use symbols @xmath42 to range over @xmath7 , symbols @xmath43 to range over @xmath44 , symbols @xmath45 to range over @xmath46 , and symbols @xmath47 to range over @xmath48 .",
    "we use @xmath49 to denote trees in @xmath17 or subtrees thereof .",
    "we define the predicate @xmath50 on elements from @xmath46 as @xmath51 if and only if ( i )  @xmath52 and @xmath22 dominates @xmath38 , or ( ii )  @xmath53 .",
    "we extend @xmath50 to strings of the form @xmath54 by defining @xmath55 if and only if there is a @xmath33 ( @xmath34 ) such that @xmath56 .    for some logical expression @xmath57 , we define @xmath58 iff @xmath57 is true , @xmath59 otherwise .",
    "the approach we adopt in the next section to derive a method for the computation of prefix probabilities for tags is based on transformations of equations . here",
    "we informally discuss the general ideas underlying equation transformations .",
    "let @xmath60 be a string and let @xmath61 .",
    "we use the following representation which is standard in tabular methods for tag parsing .",
    "an * item * is a tuple @xmath62 $ ] representing the set of all trees @xmath18 such that ( i )  @xmath18 is a subtree rooted at @xmath22 of some derived elementary tree ; and ( ii )  @xmath18 s root spans from position @xmath63 to position @xmath64 in @xmath2 , @xmath18 s foot node spans from position @xmath65 to position @xmath66 in @xmath2 . in case @xmath22 does not dominate the foot , we set @xmath67 . we generalize in the obvious way to items @xmath68 $ ] , where @xmath18 is an elementary tree , and @xmath69 $ ] , where @xmath70 for some @xmath22 and @xmath71 .    to introduce our approach ,",
    "let us start with some considerations concerning the tag parsing problem .",
    "when parsing @xmath2 with a tag @xmath11 , one usually composes items in order to construct new items spanning a larger portion of the input string .",
    "assume there are instances of auxiliary trees @xmath18 and @xmath72 in @xmath11 , where the yield of @xmath72 , apart from its foot , is the empty string .",
    "if @xmath73 for some node @xmath22 on the spine of @xmath72 , and we have recognized an item @xmath74 $ ] , then we may adjoin @xmath18 at @xmath22 and hence deduce the existence of an item @xmath75 $ ] ( see fig .  [",
    "f : wrap](a ) ) .",
    "similarly , if @xmath18 can be adjoined at a node @xmath22 to the left of the spine of @xmath72 and @xmath76 , we may deduce the existence of an item @xmath77 $ ] ( see fig .  [",
    "f : wrap](b ) ) .",
    "importantly , one or more other auxiliary trees with empty yield could wrap the tree @xmath72 before @xmath18 adjoins .",
    "adjunctions in this situation are potentially nonterminating",
    ".        one may argue that situations where auxiliary trees have empty yield do not occur in practice , and are even by definition excluded in the case of lexicalized tags .",
    "however , in the computation of the prefix probability we must take into account trees with non - empty yield which behave like trees with empty yield because their lexical nodes fall to the right of the right boundary of the prefix string . for example , the two cases previously considered in fig .",
    "[ f : wrap ] now generalize to those in fig .",
    "[ f : pwrap ] .        to derive a method for the computation of prefix probabilities , we give some simple recursive equations .",
    "each equation _ decomposes _ an item into other items in all possible ways , in the sense that it expresses the probability of that item as a function of the probabilities of items associated with equal or smaller portions of the input .    in specifying the equations , we exploit techniques used in the parsing of incomplete input  @xcite .",
    "this allows us to compute the prefix probability as a by - product of computing the inside probability .    in order to avoid the problem of nontermination outlined above",
    ", we transform our equations to remove infinite recursion , while preserving the correctness of the probability computation .",
    "the transformation of the equations is explained as follows . for an item @xmath78 ,",
    "the * span * of @xmath78 , written @xmath79 , is the @xmath80-tuple representing the 4 input positions in @xmath78 .",
    "we will define an equivalence relation on spans that relates to the portion of the input that is covered .",
    "the transformations that we apply to our equations produce two new sets of equations .",
    "the first set of equations are concerned with all possible decompositions of a given item @xmath78 into set of items of which one has a span equivalent to that of @xmath78 and the others have an empty span .",
    "equations in this set represent endless recursion .",
    "the system of all such equations can be solved independently of the actual input @xmath2 .",
    "this is done once for a given grammar .",
    "the second set of equations have the property that , when evaluated , recursion always terminates .",
    "the evaluation of these equations computes the probability of the input string modulo the computation of some parts of the derivation that do not contribute to the input itself .",
    "combination of the second set of equations with the solutions obtained from the first set allows the effective computation of the prefix probability .",
    "this section develops an algorithm for the computation of prefix probabilities for stochastic tags .",
    "the prefix probability is given by : @xmath81),\\end{aligned}\\ ] ] where @xmath82 is a function over items recursively defined as follows : @xmath83)\\ = p([r_t , i , j ,   f_1 ,   f_2 ] ) ; } \\\\ \\label{tagrecur1 } \\lefteqn{p([\\alpha n , i , j ,   - ,   -])\\ = } \\\\ & & { \\sum_{\\makebox[5ex]{\\scriptsize$k(i\\leq k \\leq j)$ } } } p([\\alpha , i , k ,   - ,   - ] )   \\cdot p([n , k , j ,   - ,   - ] ) , \\nonumber \\\\ & & \\mbox{if\\ } \\alpha\\neq{\\epsilon}\\wedge \\neg{{\\it dft}}(\\alpha n ) ; \\nonumber \\\\ \\label{tagrecur2 } \\lefteqn{p([\\alpha n , i , j ,   f_1 ,   f_2])\\ = } \\\\ & & { \\sum_{\\makebox[5ex]{\\scriptsize$k(i\\leq k \\leq f_1)$ } } } p([\\alpha , i , k ,   - ,   - ] )   \\cdot p([n , k , j ,   f_1 ,   f_2 ] ) , \\nonumber\\\\ & & \\mbox{if\\ } \\alpha\\neq{\\epsilon}\\wedge { { \\it dft}}(n);\\nonumber   \\\\ \\label{tagrecur3 } \\lefteqn{p([\\alpha n , i , j ,   f_1 ,   f_2])\\ = } \\\\ & & { \\sum_{\\makebox[5ex]{\\scriptsize$k(f_2\\leq k \\leq j)$ } } } p([\\alpha , i , k ,   f_1 ,   f_2 ] )   \\cdot p([n , k , j ,   - ,   - ] ) , \\nonumber \\\\ & & \\mbox{if\\ } \\alpha\\neq{\\epsilon}\\wedge { { \\it dft}}(\\alpha ) ; \\nonumber \\\\ \\label{tagrule1 } \\lefteqn{p([n , i , j , f_1 , f_2])\\ = } \\\\ & & \\phi({\\bf nil},n)\\cdot p([{\\mbox{{\\it cdn\\/}}}(n ) , i , j , f_1 , f_2])\\ + \\nonumber \\\\ & & { \\sum_{\\makebox[5ex]{\\scriptsize$\\lefteqn{f_1',f_2'(i\\leq f_1'\\leq f_1 \\wedge           f_2\\leq f_2'\\leq j)}\\hspace{2cm}$}}}p([{\\mbox{{\\it cdn\\/}}}(n ) , f_1 ' , f_2 ' , f_1 ,   f_2])\\ \\cdot\\nonumber   \\\\ & & \\hspace{1 cm } \\sum_{t\\in { \\cal a } }       \\phi(t , n)\\cdot p([t ,   i , j , f_1 ' ,   f_2']),\\nonumber   \\\\ & & \\mbox{if\\ } n\\in { v}\\wedge{{\\it dft}}(n ) ; \\nonumber   \\\\ \\label{tagrule2 } \\lefteqn{p([n , i , j , - , -])\\ = } \\\\ & & \\phi({\\bf nil},n)\\cdot p([{\\mbox{{\\it cdn\\/}}}(n ) , i , j , - , -])\\ + \\nonumber \\\\ & & { \\sum_{\\makebox[5ex]{\\scriptsize$\\hspace{1cm}f_1',f_2'(i\\leq f_1 ' \\leq f_2'\\leq j)$ } } } p([{\\mbox{{\\it cdn\\/}}}(n ) ,   f_1 ' , f_2 ' , - , -])\\ \\cdot\\nonumber   \\\\ & & \\hspace{1 cm } \\sum_{t\\in { \\cal a } }       \\phi(t , n)\\cdot p([t ,   i , j , f_1 ' ,   f_2']),\\nonumber   \\\\ & & \\mbox{if\\ } n\\in { v}\\wedge   \\neg{{\\it dft}}(n ) ; \\nonumber   \\\\ \\label{tagscan } \\lefteqn{p([a , i , j ,   - ,   -])\\ = } \\\\ & & { \\delta}(i+1=j\\wedge   a_j = a ) + { \\delta}(i = j = n ) ; \\nonumber \\\\ \\label{tagfoot } \\lefteqn{p([\\bot , i , j ,   f_1 ,   f_2])\\ = { \\delta}(i = f_1 \\wedge j = f_2 ) ; } \\\\ \\label{tagstop } \\lefteqn{p([{\\epsilon } , i , j ,   - ,   -])\\",
    "= { \\delta}(i = j).}\\end{aligned}\\ ] ] term @xmath84)$ ] gives the inside probability of all possible trees derived from elementary tree @xmath18 , having the indicated span over the input .",
    "this is decomposed into the contribution of each single node of @xmath18 in equations  ( [ tagtree ] ) through  ( [ tagrule2 ] ) . in equations",
    "( [ tagrule1 ] ) and ( [ tagrule2 ] ) the contribution of a node @xmath22 is determined by the combination of the inside probabilities of @xmath22 s children and by all possible adjunctions at @xmath22 . in",
    "( [ tagscan ] ) we recognize some terminal symbol if it occurs in the prefix , or ignore its contribution to the span if it occurs after the last symbol of the prefix .",
    "crucially , this step allows us to reduce the computation of prefix probabilities to the computation of inside probabilities .      in general , the recursive equations  ( [ tagtree ] ) to  ( [ tagstop ] ) are not directly computable .",
    "this is because the value of @xmath85)$ ] might indirectly depend on itself , giving rise to nontermination .",
    "we therefore rewrite the equations .",
    "we define an equivalence relation over spans , that expresses when two items are associated with equivalent portions of the input :    @xmath86 + @xmath87 + @xmath88 + @xmath89 + @xmath90 + we introduce two new functions @xmath91 and @xmath92 .",
    "when evaluated on some item @xmath78 , @xmath91 recursively calls itself as long as some other item @xmath93 with a given elementary tree as its first component can be reached , such that @xmath94 .",
    "@xmath91 returns @xmath95 if the actual branch of recursion can not eventually reach such an item @xmath93 , thus removing the contribution to the prefix probability of that branch .",
    "if item @xmath93 is reached , then @xmath91 switches to @xmath92 .",
    "complementary to @xmath91 , function @xmath92 tries to decompose an argument item @xmath78 into items @xmath93 such that @xmath96 . if this is not possible through the actual branch of recursion , @xmath92 returns @xmath95 .",
    "if decomposition is indeed possible , then we start again with @xmath91 at items produced by the decomposition .",
    "the effect of this intermixing of function calls is the simulation of the original function @xmath82 , with @xmath91 being called only on potentially nonterminating parts of the computation , and @xmath92 being called on parts that are guaranteed to terminate .",
    "consider some derivation tree spanning some portion of the input string , and the associated derivation tree @xmath97 .",
    "there must be a unique elementary tree which is represented by a node in @xmath97 that is the `` lowest '' one that entirely spans the portion of the input of interest .",
    "( this node might be the root of @xmath97 itself . )",
    "then , for each @xmath98 and for each @xmath99 such that @xmath100 and @xmath101 , we must have : @xmath102)\\ = } \\\\ & & { \\sum_{\\makebox[5ex]{\\scriptsize$\\lefteqn{t'\\in{\\cal a},f_1',f_2 ' (",
    "( i , j , f_1 ' ,   f_2 ' ) \\approx ( i , j , f_1 , f_2))}\\hspace{3.5cm}$ } } } { p_{\\scriptscriptstyle low}}([t , i , j , f_1 ,   f_2],\\ [ t',f_1',f_2 ' ] ) . \\nonumber \\\\[-3.0ex ] \\nonumber\\end{aligned}\\ ] ] similarly , for each @xmath103 and for each @xmath104 such that @xmath100 , we must have : @xmath105)\\ = } \\\\ & & { \\sum_{\\makebox[5ex]{\\scriptsize$t'\\in\\{t\\}\\cup{\\cal a},f\\in\\{-,i , j\\}$ } } } { p_{\\scriptscriptstyle low}}([t , i , j , - ,   -],\\ [ t',f , f ] ) .",
    "\\nonumber \\\\[-3.0ex ] \\nonumber\\end{aligned}\\ ] ] the reason why @xmath91 keeps a record of indices @xmath106 and @xmath107 , i.e. , the spanning of the foot node of the lowest tree ( in the above sense ) on which @xmath91 is called , will become clear later , when we introduce equations  ( [ tagoutsidea ] ) and  ( [ tagoutsideb ] ) .",
    "we define @xmath108,[t',f_1',f_2'])$ ] and @xmath109,[t',f_1',f_2'])$ ] for @xmath100 and @xmath110 , as follows .",
    "@xmath111,\\ [ t',f_1',f_2 ' ] ) \\",
    "= { \\refstepcounter{equation }   \\hspace*{\\fill } ( \\arabic{equation } ) } \\label{tagtreelow } { $ \\\\[.3em ] \\hspace*{1em}$}{p_{\\scriptscriptstyle low}}([r_t ,",
    "\\ i,\\ j,\\   f_1,\\   f_2],\\ [ t',f_1',f_2'])\\ +   { $ \\\\[.3em ] \\hspace*{1em}$}{\\delta } ( ( t , f_1 , f_2 ) = ( t',f_1',f_2 ' ) ) \\ \\cdot { $ \\\\[.3em ] \\hspace*{1em}$}\\hspace{1 cm } { p_{\\scriptscriptstyle split}}([r_t , \\ i,\\ j,\\   f_1,\\   f_2 ] ) ;   { $ \\\\[.4em]$}{p_{\\scriptscriptstyle low}}([\\alpha",
    "n , i , j ,   - ,   -],\\ [ t , f_1',f_2'])\\ = { \\refstepcounter{equation }   \\hspace*{\\fill } ( \\arabic{equation } ) } \\label{tagrecur1low } { $ \\\\[.3em ] \\hspace*{1em}$}{p_{\\scriptscriptstyle low}}([\\alpha , i , j ,   - ,   -],\\ [ t , f_1',f_2'])\\   \\cdot   { $ \\\\[.3em ] \\hspace*{1em}$}\\hspace{1cm}p([n , j , j ,   - ,   -])\\",
    "+ { $ \\\\[.3em ] \\hspace*{1em}$}p([\\alpha , i , i ,   - ,   -])\\ \\cdot { $ \\\\[.3em ] \\hspace*{1em}$}\\hspace{1cm}{p_{\\scriptscriptstyle low}}([n , i , j ,   - ,   -],\\ [ t , f_1',f_2 ' ] ) , { $ \\\\[.3em ] \\hspace*{1em}$}\\mbox{if\\ } \\alpha\\neq{\\epsilon}\\wedge \\neg{{\\it dft}}(\\alpha n ) ;   { $ \\\\[.4em]$}{p_{\\scriptscriptstyle low}}([\\alpha n , i , j ,   f_1 ,   f_2],\\ [ t , f_1',f_2'])\\ = { \\refstepcounter{equation }   \\hspace*{\\fill } ( \\arabic{equation } ) } \\label{tagrecur2low } { $ \\\\[.3em ] \\hspace*{1em}$}{\\delta } ( f_1=j )   \\cdot { p_{\\scriptscriptstyle low}}([\\alpha , i , j ,   - ,   -],\\ [ t , f_1',f_2'])\\ \\cdot { $ \\\\[.3em ] \\hspace*{1em}$}\\hspace{1cm}p([n , j , j ,   f_1 ,   f_2])\\ + { $ \\\\[.3em ] \\hspace*{1em}$}p([\\alpha , i , i ,   - ,   -])\\",
    "\\cdot   { $ \\\\[.3em ] \\hspace*{1em}$}\\hspace{1cm}{p_{\\scriptscriptstyle low}}([n , i , j ,   f_1 ,   f_2],\\ [ t , f_1',f_2 ' ] ) ,           { $ \\\\[.3em ] \\hspace*{1em}$}\\mbox{if\\ } \\alpha\\neq{\\epsilon}\\wedge { { \\it dft}}(n ) ;   { $ \\\\[.4em]$}{p_{\\scriptscriptstyle low}}([\\alpha n , i , j ,   f_1 ,   f_2],\\ [ t , f_1',f_2'])\\ = { \\refstepcounter{equation }   \\hspace*{\\fill } ( \\arabic{equation } ) } \\label{tagrecur3low } { $ \\\\[.3em ] \\hspace*{1em}$}{p_{\\scriptscriptstyle low}}([\\alpha , i , j ,   f_1 ,   f_2],\\ [ t , f_1',f_2'])\\   \\cdot { $ \\\\[.3em ] \\hspace*{1em}$}\\hspace{1cm}p([n , j , j ,   - ,   -])\\ + { $ \\\\[.3em ] \\hspace*{1em}$}{\\delta } ( i = f_2 )   \\cdot \\nonumber          p([\\alpha , i , i ,   f_1 ,   f_2])\\   \\cdot { $ \\\\[.3em ] \\hspace*{1em}$}\\hspace{1cm}{p_{\\scriptscriptstyle low}}([n , i , j ,   - ,   -],\\ [ t , f_1',f_2 ' ] ) , { $ \\\\[.3em ] \\hspace*{1em}$}\\mbox{if\\ } \\alpha\\neq{\\epsilon}\\wedge { { \\it dft}}(\\alpha ) ;   { $ \\\\[.4em]$}{p_{\\scriptscriptstyle low}}([n , i , j , f_1 , f_2],\\ [ t , f_1',f_2 ' ] ) \\",
    "= { \\refstepcounter{equation }   \\hspace*{\\fill } ( \\arabic{equation } ) } \\label{tagrule1low } { $ \\\\[.3em ] \\hspace*{1em}$}\\phi({\\bf nil},n)\\ \\cdot { $ \\\\[.3em ] \\hspace*{1em}$}\\hspace{1 cm } { p_{\\scriptscriptstyle low}}([{\\mbox{{\\it cdn\\/}}}(n ) , i , j , f_1 , f_2],\\ [ t , f_1',f_2'])\\ +           { $ \\\\[.3em ] \\hspace*{1em}$}{p_{\\scriptscriptstyle low}}([{\\mbox{{\\it cdn\\/}}}(n ) , i , j , f_1 ,   f_2],\\ [ t , f_1',f_2'])\\ \\cdot          { $ \\\\[.3em ] \\hspace*{1em}$}\\hspace{1 cm } \\sum_{t'\\in { \\cal a } }       \\phi(t',n)\\cdot p([t ' ,   i , j , i ,   j])\\ + { $ \\\\[.3em ] \\hspace*{1em}$}p([{\\mbox{{\\it cdn\\/}}}(n ) , f_1 , f_2 , f_1 ,   f_2])\\ \\cdot { $ \\\\[.3em ] \\hspace*{1em}$}\\hspace{.5 cm } { \\displaystyle\\sum_{t'\\in { \\cal a } } }       \\phi(t',n)\\cdot { p_{\\scriptscriptstyle low}}([t ' ,   i , j , f_1 ,   f_2],\\ [ t , f_1',f_2 ' ] ) ,          { $ \\\\[.3em ] \\hspace*{1em}$}\\mbox{if\\ } n\\in { v}\\wedge{{\\it dft}}(n ) ;   { $ \\\\[.4em]$}{p_{\\scriptscriptstyle low}}([n , i , j , - , -],\\ [ t , f_1',f_2 ' ] ) \\ = { \\refstepcounter{equation }   \\hspace*{\\fill } ( \\arabic{equation } ) } \\label{tagrule2low } { $ \\\\[.3em ] \\hspace*{1em}$}\\phi({\\bf nil},n)\\ \\cdot { $ \\\\[.3em ] \\hspace*{1em}$}\\hspace{1 cm } { p_{\\scriptscriptstyle low}}([{\\mbox{{\\it cdn\\/}}}(n ) , i , j , - , -],\\ [ t , f_1',f_2'])\\ + { $ \\\\[.3em ] \\hspace*{1em}$}{p_{\\scriptscriptstyle low}}([{\\mbox{{\\it cdn\\/}}}(n ) ,   i , j , - , -],\\ [ t , f_1',f_2'])\\ \\cdot          { $ \\\\[.3em ] \\hspace*{1em}$}\\hspace{1 cm } \\sum_{t'\\in { \\cal a } }       \\phi(t',n)\\cdot p([t ' ,   i , j , i ,   j])\\ + { $ \\\\[.3em ] \\hspace*{1em}$}{\\displaystyle{\\sum_{\\makebox[5ex]{\\scriptsize$\\lefteqn{f_1'',f_2 ''          ( f_1''=   f_2''=i \\vee f_1''=   f_2''=j)}\\hspace{1.5 cm } $ } } } } p([{\\mbox{{\\it cdn\\/}}}(n ) ,   f_1 '' , f_2 '' , - , -])\\ \\cdot { $ \\\\[.3em ] \\hspace*{1em}$}\\hspace{.5 cm } { \\displaystyle\\sum_{{t'}\\in { \\cal a } } }       \\phi(t',n)\\cdot { p_{\\scriptscriptstyle low}}([t ' ,   i , j , f_1 '' ,   f_2''],\\ [ t , f_1',f_2 ' ] ) ,         { $ \\\\[.3em ] \\hspace*{1em}$}\\mbox{if\\ } n\\in { v}\\wedge   \\neg{{\\it dft}}(n ) ;   { $ \\\\[.4em]$}{p_{\\scriptscriptstyle low}}([a , i , j ,   - ,   -],\\ [ t , f_1',f_2 ' ] ) = 0 ;   { \\refstepcounter{equation }   \\hspace*{\\fill } ( \\arabic{equation } ) } \\label{tagscanlow } { $ \\\\[.4em]$}{p_{\\scriptscriptstyle low}}([\\bot , i , j ,   f_1 ,   f_2],\\ [ t , f_1',f_2 ' ] )   =    0 ;   { \\refstepcounter{equation }   \\hspace*{\\fill } ( \\arabic{equation } ) } \\label{tagfootlow } { $ \\\\[.4em]$}{p_{\\scriptscriptstyle low}}([{\\epsilon } , i , j ,   - ,   -],\\ [ t , f_1',f_2 ' ] )   =    0 . { \\refstepcounter{equation }",
    "\\hspace*{\\fill } ( \\arabic{equation } ) } \\label{tagstoplow } $ ]    the definition of @xmath91 parallels the one of @xmath82 given in   [ ss : general ] . in  ( [ tagtreelow ] ) , the second term in the right - hand side accounts for the case in which the tree we are visiting is the `` lowest '' one on which @xmath91 should be called .",
    "note how in the above equations @xmath91 must be called also on nodes that do not dominate the footnode of the elementary tree they belong to ( cf .  the definition of @xmath112 ) .",
    "since no call to @xmath92 is possible through the terms in  ( [ tagscanlow ] ) , ( [ tagfootlow ] ) and  ( [ tagstoplow ] ) , we must set the right - hand side of these equations to @xmath95 .",
    "the specification of @xmath113)$ ] is given below .",
    "again , the definition parallels the one of @xmath82 given in   [ ss : general ] .",
    "+ @xmath114)\\ = } \\\\ & & { \\sum_{\\makebox[5ex]{\\scriptsize$k(i < k < j)$ } } } p([\\alpha , i , k ,   - ,   - ] )   \\cdot p([n , k , j ,   - ,   -])\\ + \\nonumber\\\\ & & { p_{\\scriptscriptstyle split}}([\\alpha , i , j ,   - ,   - ] )   \\cdot p([n , j , j ,   - ,",
    "-])\\ + \\nonumber \\\\ & & p([\\alpha , i , i ,   - ,   - ] )   \\cdot { p_{\\scriptscriptstyle split}}([n , i , j ,   - ,   - ] ) , \\nonumber \\\\ & & \\mbox{if\\ } \\alpha\\neq{\\epsilon}\\wedge \\neg{{\\it dft}}(\\alpha n ) ; \\nonumber \\\\ \\label{tagrecur2high } \\lefteqn{{p_{\\scriptscriptstyle split}}([\\alpha n , i , j ,   f_1 ,   f_2])\\ = } \\\\ & & { \\sum_{\\makebox[5ex]{\\scriptsize$\\hspace{1cm}k(i < k \\leq f_1 \\wedge k < j)$ } } } p([\\alpha , i , k ,   - ,   - ] )    \\cdot p([n , k , j ,   f_1 ,   f_2])\\ + \\nonumber \\\\ & & { \\delta } ( f_1=j ) \\cdot { p_{\\scriptscriptstyle split}}([\\alpha , i , j ,   - ,   -])\\",
    "\\cdot\\nonumber\\\\ & & \\hspace{1 cm } p([n , j , j ,   f_1 ,   f_2])\\ + \\nonumber \\\\ & & p([\\alpha , i , i ,   - ,   - ] )   \\cdot { p_{\\scriptscriptstyle split}}([n , i , j ,   f_1 ,   f_2]),\\nonumber \\\\ & & \\mbox{if\\ } \\alpha\\neq{\\epsilon}\\wedge { { \\it dft}}(n);\\nonumber   \\\\ \\label{tagrecur3high } \\lefteqn{{p_{\\scriptscriptstyle split}}([\\alpha n , i , j ,   f_1 ,   f_2])\\ = } \\\\ & & { \\sum_{\\makebox[5ex]{\\scriptsize$\\hspace{1cm}k(i < k\\wedge f_2\\leq k < j)$ } } } p([\\alpha , i , k ,   f_1 ,   f_2 ] )    \\cdot p([n , k , j ,   - ,   -])\\ + \\nonumber\\\\ & & { p_{\\scriptscriptstyle split}}([\\alpha , i , j ,   f_1 ,   f_2 ] )   \\cdot p([n , j , j ,   - ,   -])\\",
    "+ \\nonumber \\\\ & & { \\delta}(i = f_2 ) \\cdot p([\\alpha , i , i ,   f_1 ,   f_2 ] )   \\cdot\\nonumber\\\\ & & \\hspace{1 cm } { p_{\\scriptscriptstyle split}}([n , i , j ,   - ,   - ] ) , \\nonumber \\\\ & & \\mbox{if\\ } \\alpha\\neq{\\epsilon}\\wedge { { \\it dft}}(\\alpha ) ; \\nonumber \\\\ \\label{tagrule1high } \\lefteqn{{p_{\\scriptscriptstyle split}}([n , i , j , f_1 , f_2 ] ) \\ = } \\\\ & & \\phi({\\bf",
    "nil},n)\\cdot           { p_{\\scriptscriptstyle split}}([{\\mbox{{\\it cdn\\/}}}(n ) , i , j , f_1 , f_2])\\ + \\nonumber\\\\ & & { \\sum_{\\makebox[5ex]{\\scriptsize$ \\hspace{4 cm } f_1',f_2 ' \\begin{array}[t]{l } ( i\\leq f_1'\\leq f_1 \\wedge f_2\\leq f_2'\\leq j\\ \\wedge \\\\[0.3ex ] \\ ( f_1',f_2')\\neq ( i , j ) \\wedge ( f_1',f_2')\\neq ( f_1,f_2 ) ) \\end{array } $ } } } p([{\\mbox{{\\it cdn\\/}}}(n ) , f_1 ' , f_2 ' , f_1 ,   f_2])\\ \\cdot\\nonumber   \\\\ & & \\hspace{1 cm } \\sum_{t\\in { \\cal a } }       \\phi(t , n)\\cdot p([t ,   i , j , f_1 ' ,   f_2'])\\ + \\nonumber   \\\\ & & { p_{\\scriptscriptstyle split}}([{\\mbox{{\\it cdn\\/}}}(n ) , i , j , f_1 ,   f_2])\\ \\cdot\\nonumber   \\\\ & & \\hspace{1 cm } \\sum_{t\\in { \\cal a } }       \\phi(t , n)\\cdot p([t ,   i , j , i ,   j]),\\nonumber   \\\\ & & \\mbox{if\\ } n\\in { v}\\wedge   { { \\it dft}}(n);\\nonumber   \\\\ \\label{tagrule2high } \\lefteqn{{p_{\\scriptscriptstyle split}}([n , i , j , - , - ] ) \\ = } \\\\ & & \\phi({\\bf nil},n)\\cdot           { p_{\\scriptscriptstyle split}}([{\\mbox{{\\it cdn\\/}}}(n ) , i , j , - , -])\\ + \\nonumber\\\\ & & { \\sum_{\\makebox[5ex]{\\scriptsize$ \\hspace{4 cm } f_1',f_2 ' \\begin{array}[t]{l } ( i\\leq f_1 ' \\leq f_2'\\leq j\\wedge ( f_1',f_2')\\neq(i , j)\\ \\wedge \\\\[0.3ex ] \\",
    "\\neg ( f_1 ' = f_2'=i\\vee f_1 ' = f_2'=j ) ) \\end{array } $ } } } p([{\\mbox{{\\it cdn\\/}}}(n ) ,   f_1 ' , f_2 ' , - , -])\\ \\cdot\\nonumber   \\\\ & & \\hspace{1 cm } \\sum_{t\\in { \\cal a } }       \\phi(t , n)\\cdot p([t ,   i , j , f_1 ' ,   f_2'])\\ + \\nonumber   \\\\ & & { p_{\\scriptscriptstyle split}}([{\\mbox{{\\it cdn\\/}}}(n ) ,   i , j , - , -])\\ \\cdot\\nonumber   \\\\ & & \\hspace{1 cm } \\sum_{t\\in { \\cal a } }       \\phi(t , n)\\cdot p([t ,   i , j , i ,   j]),\\nonumber   \\\\ & & \\mbox{if\\ } n\\in { v}\\wedge   \\neg{{\\it dft}}(n ) ; \\nonumber   \\\\ \\label{tagscanhigh } \\lefteqn{{p_{\\scriptscriptstyle split}}([a ,",
    "i , j ,   - ,   - ] ) = { \\delta}(i+1=j\\wedge   a_j = a ) ; } \\\\ \\label{tagfoothigh } \\lefteqn{{p_{\\scriptscriptstyle split}}([\\bot , i , j ,   f_1 ,   f_2 ] ) = 0 ; } \\\\ \\label{tagstophigh } \\lefteqn{{p_{\\scriptscriptstyle split}}([{\\epsilon } , i , j ,   - ,   - ] ) = 0.}\\end{aligned}\\ ] ]    we can now separate those branches of recursion that terminate on the given input from the cases of endless recursion . we assume below that @xmath115 )",
    "even if this is not always valid , for the purpose of deriving the equations below , this assumption does not lead to invalid results .",
    "we define a new function @xmath116 , which accounts for probabilities of subderivations that do not derive any words in the prefix , but contribute structurally to its derivation : @xmath117,\\ [ t',f_1',f_2'])\\ = } \\\\ & & \\frac{{p_{\\scriptscriptstyle low}}([t , i , j , f_1 ,   f_2],\\ [ t',f_1',f_2'])}{{p_{\\scriptscriptstyle split}}([r_{t ' } , i , j , f_1 ' ,   f_2'])};\\nonumber \\\\",
    "\\label{tagoutsideb } \\lefteqn{{p_{\\scriptscriptstyle outer}}([\\alpha , i , j , f_1 ,   f_2],\\ [ t',f_1',f_2'])\\ = } \\\\ & & \\frac{{p_{\\scriptscriptstyle low}}([\\alpha , i , j , f_1 ,   f_2],\\ [ t',f_1',f_2'])}{{p_{\\scriptscriptstyle split}}([r_{t ' } , i , j , f_1 ' ,   f_2'])}.\\nonumber\\end{aligned}\\ ] ]    we can now eliminate the infinite recursion that arises in  ( [ tagnontsum1 ] ) and ( [ tagnontsum2 ] ) by rewriting @xmath118)$ ] in terms of @xmath116 : @xmath119 ) \\",
    "= } \\\\ & &   { \\sum_{\\makebox[5ex]{\\scriptsize$\\hspace{2cm}t'\\in{\\cal a},f_1',f_2 ' ( ( i , j , f_1 ' ,   f_2')\\approx ( i , j , f_1 , f_2))$}}}{p_{\\scriptscriptstyle outer}}([t , i , j , f_1 ,   f_2],\\ [ t',f_1',f_2 ' ] ) \\cdot\\nonumber\\\\ & & \\hspace{1 cm } { p_{\\scriptscriptstyle split}}([r_{t ' } , i , j , f_1 ' ,   f_2 ' ] ) ; \\nonumber \\\\ \\label{outside2 } \\lefteqn{p([t , i , j , - ,   - ] ) \\ = } \\\\ & &   { \\sum_{\\makebox[5ex]{\\scriptsize$t'\\in\\{t\\}\\cup{\\cal a},f\\in\\{-,i , j\\}$ } } } { p_{\\scriptscriptstyle outer}}([t , i , j , - ,   -],\\ [ t',f , f ] ) \\cdot\\nonumber\\\\ & & \\hspace{1 cm } { p_{\\scriptscriptstyle split}}([r_{t ' } , i , j , f ,   f ] ) .",
    "\\nonumber\\end{aligned}\\ ] ] equations for @xmath116 will be derived in the next subsection .    in summary",
    ", terminating computation of prefix probabilities should be based on equations  ( [ outside1 ] ) and  ( [ outside2 ] ) , which replace  ( [ tagtree ] ) , along with equations  ( [ tagrecur1 ] ) to  ( [ tagstop ] ) and all the equations for @xmath92 .      in this section",
    "we derive equations for function @xmath116 introduced in   [ ss : on - line ] and deal with all remaining cases of equations that cause infinite recursion .    in some cases , function @xmath82 can be computed independently of the actual input . for any @xmath120 we can consistently define the following quantities , where @xmath121 and @xmath122 or @xmath70 for some @xmath22 and @xmath71 : @xmath123 ) ; \\\\ h_\\alpha & = & p([\\alpha , i , i , f',f ' ] ) , \\\\[-4.5ex]\\end{aligned}\\ ] ] where @xmath124 if @xmath125 , @xmath126 otherwise , and @xmath127 if @xmath128 , @xmath126 otherwise .",
    "thus , @xmath129 is the probability of all derived trees obtained from @xmath18 , with no lexical node at their yields .",
    "quantities @xmath129 and @xmath130 can be computed by means of a system of equations which can be directly obtained from equations  ( [ tagtree ] ) to  ( [ tagstop ] ) .",
    "similar quantities as above must be introduced for the case @xmath131 .",
    "for instance , we can set @xmath132)$ ] , @xmath133 specified as above , which gives the probability of all derived trees obtained from @xmath18 ( with no restriction at their yields ) .",
    "function @xmath116 is also independent of the actual input .",
    "let us focus here on the case @xmath134 ( this enforces @xmath135 below ) .",
    "for any @xmath136 , we can consistently define the following quantities .",
    "@xmath137,\\ [ t',f_1',f_2 ' ] ) ; \\\\",
    "l_{\\alpha , t ' } & = & { p_{\\scriptscriptstyle outer}}([\\alpha , i , j , f_1 ,   f_2],\\ [ t',f_1',f_2 ' ] ) .   \\\\[-4.5ex]\\end{aligned}\\ ] ] in the case at hand , @xmath138 is the probability of all derived trees obtained from @xmath18 such that ( i )  no lexical node is found at their yields ; and ( ii )  at some ` unfinished ' node dominating the foot of @xmath18 , the probability of the adjunction of @xmath72 has already been accounted for , but @xmath72 itself has not been adjoined .",
    "it is straightforward to establish a system of equations for the computation of @xmath138 and @xmath139 , by rewriting equations  ( [ tagtreelow ] ) to  ( [ tagstoplow ] ) according to  ( [ tagoutsidea ] ) and  ( [ tagoutsideb ] ) .",
    "for instance , combining  ( [ tagtreelow ] ) and  ( [ tagoutsidea ] ) gives ( using the above assumptions on @xmath65 and  @xmath66 ) : @xmath140\\end{aligned}\\ ] ] also , if @xmath141 and @xmath51 , combining  ( [ tagrecur2low ] ) and  ( [ tagoutsideb ] ) gives ( again , using previous assumptions on @xmath65 and  @xmath66 ; note that the @xmath130 s are known terms here ) : @xmath142\\end{aligned}\\ ] ] for any @xmath143 and @xmath144 , we also need to define : @xmath145,\\ [ t',f_1',f_2 ' ] ) ; \\\\",
    "l'_{\\alpha , t ' } & = & { p_{\\scriptscriptstyle outer}}([\\alpha , i , n , f_1 ,   f_2],\\ [ t',f_1',f_2 ' ] ) .",
    "\\\\[-4.5ex]\\end{aligned}\\ ] ] here @xmath146 is the probability of all derived trees obtained from @xmath18 with a node dominating the foot node of @xmath18 , that is an adjunction site for @xmath72 and is ` unfinished ' in the same sense as above , and with lexical nodes only in the portion of the tree to the right of that node . when we drop our assumption on @xmath65 and @xmath66 , we must ( pre)compute in addition terms of the form @xmath147,$ ] @xmath148)$ ] and @xmath147,$ ] @xmath149)$ ] for @xmath150 , @xmath151,$ ] @xmath152)$ ] for @xmath153 , @xmath154,$ ] @xmath152)$ ] for @xmath120 , and similar .",
    "again , these are independent of the choice of @xmath63 , @xmath64 and @xmath65 .",
    "full treatment is omitted due to length restrictions .",
    "we have presented a method for the computation of the prefix probability when the underlying model is a tree adjoining grammar .",
    "function @xmath92 is the core of the method .",
    "its equations can be directly translated into an effective algorithm , using standard functional memoization or other tabular techniques .",
    "it is easy to see that such an algorithm can be made to run in time @xmath155 , where @xmath10 is the length of the input prefix .",
    "all the quantities introduced in   [ ss : off - line ] ( @xmath129 , @xmath138 , etc . ) are independent of the input and should be computed off - line , using the system of equations that can be derived as indicated . for quantities",
    "@xmath129 we have a non - linear system , since equations ( 2 ) to ( 6 ) contain quadratic terms .",
    "solutions can then be approximated to any degree of precision using standard iterative methods , as for instance those exploited in  @xcite . under the hypothesis that the grammar is consistent , that is @xmath156 , all quantities @xmath157 and",
    "@xmath158 evaluate to one .",
    "for quantities @xmath138 and the like ,   [ ss : off - line ] provides linear systems whose solutions can easily be obtained using standard methods .",
    "note also that quantities @xmath139 are only used in the off - line computation of quantities @xmath138 , they do not need to be stored for the computation of prefix probabilities ( compare equations for @xmath138 with  ( [ outside1 ] ) and  ( [ outside2 ] ) ) .",
    "we can easily develop implementations of our method that can compute prefix probabilities incrementally .",
    "that is , after we have computed the prefix probability for a prefix @xmath3 , on input @xmath159 we can extend the calculation to prefix @xmath160 without having to recompute all intermediate steps that do not depend on @xmath159 .",
    "this step takes time @xmath161 .",
    "in this paper we have assumed that the parameters of the stochastic tag have been previously estimated . in practice , smoothing to avoid sparse data problems plays an important role .",
    "smoothing can be handled for prefix probability computation in the following ways .",
    "discounting methods for smoothing simply produce a modified stag model which is then treated as input to the prefix probability computation .",
    "smoothing using methods such as deleted interpolation which combine class - based models with word - based models to avoid sparse data problems have to be handled by a cognate interpolation of prefix probability models .    c.  chelba , d.  engle , f.  jelinek , v.  jimenez , s.  khudanpur , l.  mangu , h.  printz , e.  ristad , a.  stolcke , r.  rosenfeld , and d.  wu .",
    "structure and performance of a dependency language model . in _ proc . of eurospeech",
    "97 _ , volume  5 , pages 27752778 .",
    "o.  rambow and a.  joshi .",
    "a formal look at dependency grammars and phrase - structure grammars , with special consideration of word - order phenomena . in leo wanner , editor , _ current issues in meaning - text theory_. pinter , london ."
  ],
  "abstract_text": [
    "<S> language models for speech recognition typically use a probability model of the form @xmath0 . </S>",
    "<S> stochastic grammars , on the other hand , are typically used to assign structure to utterances . a language model of the above form </S>",
    "<S> is constructed from such grammars by computing the prefix probability @xmath1 , where @xmath2 represents all possible terminations of the prefix @xmath3 . </S>",
    "<S> the main result in this paper is an algorithm to compute such prefix probabilities given a stochastic tree adjoining grammar ( tag ) . </S>",
    "<S> the algorithm achieves the required computation in @xmath4 time . </S>",
    "<S> the probability of subderivations that do not derive any words in the prefix , but contribute structurally to its derivation , are precomputed to achieve termination . </S>",
    "<S> this algorithm enables existing corpus - based estimation techniques for stochastic tags to be used for language modelling . </S>"
  ]
}