{
  "article_text": [
    "in quantum computing , elementary operations are operations that act on only a few ( usually one or two ) qubits .",
    "for example , cnots and one - qubit rotations are elementary operations .",
    "a quantum compiling algorithm is an algorithm for decomposing (  compiling \" ) an arbitrary unitary matrix into a sequence of elementary operations ( seo ) .",
    "a quantum compiler is a software program that implements a quantum compiling algorithm .",
    "henceforth , we will refer to ref.@xcite as tuc99 .",
    "tuc99 gives a quantum compiling algorithm , implemented in a software program called qubiter .",
    "the tuc99 algorithm uses a matrix decomposition called the cosine - sine decomposition ( csd ) which is well known in the field of computational linear algebra@xcite .",
    "tuc99 uses csd in a recursive manner",
    ". henceforth we will refer to the recursive application of csd as re - csd or reap - csd .",
    "a modest desideratum for a quantum compiler is that it should recognize when a matrix is a tensor product of one - bit operators , and decompose such a matrix into a tensor product of one - bit operators .",
    "qubiter does this for the @xmath0-bit hadamard matrix @xmath3 .    in ref.@xcite",
    ", coppersmith showed how to express the @xmath0-bit discrete fourier transform matrix @xmath4 in a very efficient way , as a sequence of order(@xmath2 ) elementary operations .",
    "his decomposition will henceforth be called the quantum fast fourier transform ( qfft ) .",
    "another more difficult desideratum for a quantum compiler is that it should decompose @xmath4 into a sequence of order(@xmath2 ) elementary operations .",
    "qubiter does this too .",
    "numerical evidence that qubiter can compile @xmath3 and @xmath4 for @xmath5 in this ideal way was reported in tuc99 .",
    "the goal of this paper is to explain analytically why qubiter behaves in this ideal way .",
    "qubiter does not behave this way because it is hardwired to recognize @xmath3 and @xmath4 .",
    "such a highly specialized approach would be of limited scope .",
    "instead , the reason it behaves this way is because efficient expansions of both @xmath3 and @xmath4 can both be viewed as special cases of re - csd , and re - csd is qubiter s specialty .",
    "this is a promising result .",
    "it hints that re - csd is a door to compiling efficiently a large class of unitary matrices that includes : @xmath3 , @xmath4 , and an infinitude of other matrices .",
    "in this section , we will introduce some notation that is used throughout this paper . for additional information about notation ,",
    "the reader is referred to ref.@xcite .",
    "ref.@xcite is a review paper by the author of this paper that uses the same notational conventions as this paper .    for integers @xmath6 such that @xmath7 , let @xmath8 .",
    "we will often use @xmath0 to denote the number of bits in a quantum register , and @xmath9 to denote the corresponding number of states .",
    "first , let us introduce the members of our cast of characters that are 2d matrices .",
    "the pauli matrices are = , = , = .",
    "this drama will also feature the 2d identity matrix and the one - bit hadamard matrix :    i = , h = . note that @xmath10 is related to @xmath11 , a @xmath12 rotation about the y axis , as follows :    e^-i= ( ) - i()= = h.    of course",
    ", matrices of dimension greater than 2 will also make an appearance in this play",
    ". some will be built by using the tensor product and direct sum of matrices .",
    "in particular , for any matrix @xmath13 , we can tensor - multiply or direct - sum several copies of @xmath13 . for",
    "any positive integer @xmath14 , let    a^r= _ rcopiesofa , and    a^r= _ rcopiesofa .",
    "for example , @xmath15 . a fact that will be useful later on",
    "is that for any two matrices @xmath16 , the transpose operation distributes over @xmath17 and @xmath18 : @xmath19 and @xmath20 .    for",
    "any positive integer @xmath14 , let @xmath21 :    d_r = ( h)i^r-1= , [ eq - dr - mat ] where @xmath22 .",
    "note that @xmath21 is @xmath23 dimensional .",
    "the main theme of this drama is the recursive application of the csd ( re - csd or reap - csd ) .",
    "the csd ( in the form used here ) is defined as follows . given a unitary matrix @xmath24 of even dimension @xmath25 , @xmath24 can be expressed as    u=(l_0l_1 ) d ( r_0 r_1 ) , [ eq - csd - formula ] with    d = , and    c^2+s^2=1 , where @xmath26 are unitary matrices of dimension @xmath27 , and where @xmath28 and @xmath29 are real diagonal matrices .",
    "eq.([eq - csd - formula ] ) is represented diagrammatically in fig.[fig - csd ] .",
    "matrix @xmath30 is assigned to the node , matrix @xmath24 is assigned to the incoming arrow , matrices @xmath31 and @xmath32 are each assigned to an outgoing arrow .",
    "when the csd is used recursively , then the various applications of csd can each be represent as in fig.[fig - csd ] and connected to form a csd binary tree .",
    "we will refer to the matrix assigned to the arrow entering the root node of the csd tree as the * initial matrix * , @xmath33 , of the tree .",
    "fig.[fig - black - node ] shows another convention for csd trees that will be used here .",
    "namely , a black - filled node will represent a node that is assigned the same matrix that is assigned to the node s single incoming arrow .    in this paper ,",
    "we are mostly concerned with  degenerate \" csd trees that have been pruned so that they contain only the leftmost or rightmost branches ( see fig.[fig - ud - hill ] ) . as discussed in most books about programming algorithms ,",
    "there are several algorithms for traversing all the nodes of a tree .",
    "the algorithm that will be used in this paper ( also used by qubiter ) is one of the most common , and is called the * in - order tree transversal strategy*. in this strategy , one visits ( 1 ) the left sub - tree , ( 2)the root node , ( 3 ) the right sub - tree , in a recursive manner . if one lists , in accordance with the in - order strategy , the node labels of either of the two trees in fig.[fig - ud - hill ] , one obtains for both trees :    u_in = x_1 x_2 x_3  x_9 .",
    "henceforth we will refer to the left and right hand side trees of fig.[fig - ud - hill ] as the * uphill and downhill trees * , respectively .",
    "in this section , we will consider re - csd with initial matrix equal to the @xmath0-bit hadamard matrix @xmath34 .",
    "this problem is closely related to the one considered in the next section , re - csd with initial matrix equal to the @xmath0-bit discrete fourier transform matrix . for simplicity",
    ", we will assume that @xmath35 .",
    "how to generalize our results from @xmath35 to arbitrary @xmath0 will be obvious .",
    "fig.[fig - had ] shows the csd tree that is produced by qubiter when the initial matrix is @xmath36 . we will spend the remainder of this section explaining fig.[fig - had ] .",
    "( as discussed in tuc99 , the csd is not unique . due to this non - uniqueness",
    ", there are many possible csd trees that can be produced from compiling the same initial matrix @xmath36 .",
    "fig.[fig - had ] is just one of these possibilities .",
    "tuc99 discusses what choices must be made in order to steer qubiter towards producing this particular tree . )",
    "we can express the initial matrix @xmath36 as a product of one - qubit hadamard matrices : h^4= h(3 ) h(2 ) h(1 ) h(0 ) .",
    "[ eq - had-3210 ] eq.([eq - had-3210 ] ) can be expressed recursively as    [ eq - had - recursion - ops ] h^4= ( 3210 ) ,    ( 3210)= ( h)(3)(3)(210 ) ,    ( 210)= ( h)(2)(2)(10 ) ,    ( 10)= ( h)(1)(1)(0 ) , and    ( 0)= ( h)(0)(0 ) .",
    "it is convenient to translate the various bit - labelled operators in eqs.([eq - had - recursion - ops ] ) into matrices .",
    "define @xmath37 for @xmath38 by    [ eq - had - gamma - op - to - mat ] ( 3210 ) = _ 4 ,    ( 210)= i _ 3 ,    \\(10 ) = i^2 _ 2 ,    \\(0 ) = i^3 _ 1 , and    _ 0 = 1 .",
    "note that for @xmath39 , @xmath37 is a matrix of dimension @xmath23 . in fact , @xmath40 .",
    "the bit - labelled operators @xmath41 can be expressed in terms of the @xmath21 matrices defined by eq.([eq - dr - mat ] ) :    [ eq - had - hsigz - op - to - mat ] ( h)(3)= d_4 ,    ( h)(2)= id_3 ,    ( h)(1)= i^2d_2 , and    ( h)(0)= i^3d_1    likewise , the bit - labelled operators @xmath42 can be expressed as matrices :    [ eq - had - sigz - op - to - mat ] ( 3)= ,    ( 2)= i ,    ( 1)= i^2 , and    ( 0)= i^3 .    after replacing bit - labelled operators by their matrix equivalents via eqs.([eq - had - gamma - op - to - mat ] ) , ( [ eq - had - hsigz - op - to - mat ] ) and ( [ eq - had - sigz - op - to - mat ] ) ,",
    "the recursion relation defined by eqs.([eq - had - recursion - ops ] ) becomes simply :    _ r+1= d_r+1 , [ eq - had - recursion - mats ] for @xmath43 .",
    "the downhill tree of fig.[fig - had ] was obtained using re - csd in combination with eq.([eq - had - recursion - mats ] ) and the following identities :     + & & h^3 ( -h^3 ) ,     + & & h^2 ( -h^2 ) ( -h^2 ) h^2 ,     + & & h ( -h)(-h ) h ( -h ) h h ( -h ) , and     + & & ( - ) ( - ) ( - ) ( - ) .",
    "listing the node matrices of the downhill tree given by fig.[fig - had ] ( listing them in the order visited by an in - order tree transversal ) gives :    h^4 = d_4 d^2_3 d^4_2 d^8_1 ^4 .",
    "[ eq - had - fin - d ] using re - csd , qubiter expresses @xmath36 in the form given by the right hand side of eq.([eq - had - fin - d ] ) .",
    "then it recognizes that : ( 1)the matrices of the form @xmath44 are one - qubit y - axis rotations , and ( 2 ) the matrix @xmath45 is a @xmath46 matrix applied separately to each qubit .    note that eq.([eq - had-3210 ] ) listed the mutually commuting operators @xmath47 in one of @xmath48 equivalent orders . if we take the transpose of both sides of eq.([eq - had-3210 ] ) , we reverse the order of the @xmath49 operators :    h^4= h(0)h(1 ) h(2 ) h(3 ) .",
    "[ eq - had-3210-transpose ] in fact , we can take the transpose of all equations between and including eqs.([eq - had-3210 ] ) to eqs.([eq - had - fin - d ] ) .",
    "in particular , we get    ^t_r+1= d^t_r+1 for @xmath43 . also ,    h^4 = ^4 ( d^t_1)^8 ( d^t_2)^4 ( d^t_3)^2 d^t_4 .",
    "[ eq - had - fin - d - tanspose ] eq.([eq - had - fin - d - tanspose ] ) also follows if we list the node matrices of the uphill tree given by fig.[fig - had ] ( listing them in the order visited by an in - order tree transversal ) .",
    "in this section , we will consider re - csd with initial matrix equal to the @xmath0-bit discrete fourier transform matrix , defined by @xmath50 , where @xmath51 . for simplicity",
    ", we will assume that @xmath35 .",
    "fig.[fig - fou ] shows the csd tree that is produced by qubiter when the initial matrix is @xmath1 for @xmath35 . we will spend the remainder of this section explaining fig.[fig - fou ] .    in ref.@xcite",
    ", coppersmith showed how to express @xmath1 as a sequence of order(@xmath2 ) elementary operations .",
    "we will call his decomposition the quantum fast fourier transform ( qfft ) . for a pedagogical discussion of the qfft circuit and related matters ,",
    "see ref.@xcite .",
    "ref.@xcite has the virtue that it uses the same notation as this paper .",
    "define the root of unity @xmath52 and the 2d matrix @xmath53 by    = ( i ) , = diag(1 , ) = ^n , [ eq - omega - defs ] where @xmath54 is the number operator .    as in ref.@xcite , for any 2 distinct bits @xmath55 , let us define an operator @xmath56 by    @xmath57 & \\qw \\\\",
    "& \\dotgate & \\qw } \\end{array } = v(\\alpha , \\beta)= \\exp [ i\\pi \\frac{n(\\alpha)n(\\beta)}{2^{|\\alpha-\\beta| } } ] \\;.\\ ] ]    as in ref.@xcite , @xmath58 will denote the bit reversal matrix . for @xmath35 , it maps bits @xmath59 , @xmath60 , @xmath61 , and @xmath62 .",
    "it can be expressed in terms of exchange operators , which in turn can be expressed in terms of cnots .    as shown in ref.@xcite ,",
    "the qfft for @xmath35 is    u_ft= h(3 ) v(3,2)v(3,1)v(3,0 ) h(2 ) v(2,1)v(2,0 ) h(1 )",
    "v(1,0 ) h(0)r .",
    "[ eq - fou-3210 ] a diagrammatical way of saying the same thing is :    @xmath63 & \\qw & \\qw & \\dotgate\\qwx[2 ] & \\qw & \\dotgate\\qwx[1 ] & \\gate{h } & \\multigate{3}{r } \\\\ & \\qw & \\qw & \\dotgate\\qwx[2 ] & \\qw & \\qw & \\dotgate\\qwx[1 ] & \\qw & \\gate{h } & \\dotgate & \\qw & \\ghost{r } \\\\ & \\qw & \\dotgate\\qwx[1 ] & \\qw & \\qw & \\gate{h } & \\dotgate & \\dotgate & \\qw & \\qw & \\qw & \\ghost{r } \\\\ & \\gate{h } & \\dotgate & \\dotgate & \\dotgate & \\qw & \\qw & \\qw & \\qw & \\qw & \\qw & \\ghost{r } } \\end{array } \\;.\\ ] ]    note that eq.([eq - fou-3210 ] ) for @xmath1 and eq.([eq - had-3210 ] ) for @xmath36 are very similar .",
    "they differ in that the expression for @xmath1 contains , in addition to the one - bit hadamard matrices , the bit reversal matrix @xmath58 , and diagonal matrices inserted between the one - bit hadamard matrices .",
    "it is convenient at this point to lump together the diagonal operators that occur between the one - bit hadamard matrices .",
    "define diagonal operators @xmath64 by    [ eq - fou - delta - ops ] ( 3210)= ( 3)v(3,2)v(3,1)v(3,0 ) ,    ( 210)= ( 2)v(2,1)v(2,0 ) ,    ( 10)= ( 1)v(1,0 ) , and    ( 0)= ( 0 ) .",
    "next , let us consider re - csd with the initial matrix @xmath65 .",
    "eq.([eq - fou-3210 ] ) can be expressed recursively as    [ eq - fou - recursion - ops ] u_ftr= ( 3210 ) ,    ( 3210)= ( h)(3)(3210)(210 ) ,    ( 210)= ( h)(2)(210)(10 ) ,    ( 10)= ( h)(1)(10)(0 ) , and    ( 0)= ( h)(0)(0 ) .",
    "it is convenient to translate the various bit - labelled operators in eqs.([eq - fou - recursion - ops ] ) into matrices .",
    "define @xmath37 for @xmath38 by    [ eq - fou - gamma - op - to - mat ] ( 3210 ) = _ 4 ,    ( 210)= i _ 3 ,    \\(10 ) = i^2 _ 2 ,    \\(0 ) = i^3 _ 1 , and    _ 0 = 1 .",
    "note that for @xmath39 , @xmath37 is a matrix of dimension @xmath23 .",
    "the bit - labelled operators @xmath41 can be expressed in terms of the @xmath21 matrices defined by eq.([eq - dr - mat ] ) :    [ eq - fou - hsigz - op - to - mat ] ( h)(3)= d_4 ,    ( h)(2)= id_3 ,    ( h)(1)= i^2d_2 , and    ( h)(0)= i^3d_1 .",
    "the bit - labelled operators @xmath64 can be expressed in terms of the @xmath53 matrix defined by eq.([eq - omega - defs ] ) :    [ eq - fou - delta - op - to - mat ] ( 3210 ) & = & ( 3)e^in(3 ) + & = & ( 3)^in(3 ) + & = & + & = & a_3b_3 ,    \\(210 ) & = & ( 2)e^in(2 ) + & = & ( 2)^in(2 ) + & = & i + & = & i(a_2b_2 ) ,    \\(10 ) & = & ( 1)e^in(1 ) + & = & ( 1)^in(1 ) + & = & i^2 + & = & i^2(a_1b_1 ) , and    ( 0)&=&(0 ) + & = & i^3 + & = & i^3 ( a_0 b_0 ) .    the matrices @xmath66 and @xmath67 , where @xmath43 , are first mentioned in eqs.([eq - fou - delta - op - to - mat ] ) .",
    "they are implicitly defined by those equations .",
    "note that for @xmath43 , @xmath66 and @xmath67 are diagonal unitary matrices of dimension @xmath23 . after replacing bit - labelled operators by their matrix equivalents via eqs.([eq - fou - gamma - op - to - mat ] ) ,",
    "( [ eq - fou - hsigz - op - to - mat ] ) and ( [ eq - fou - delta - op - to - mat ] ) , the recursion relation defined by eqs.([eq - fou - recursion - ops ] ) becomes simply :    _ r+1= d_r+1 , [ eq - fou - recursion - mats ] for @xmath43 .",
    "the downhill tree of fig.[fig - fou ] was obtained using re - csd in combination with eq.([eq - fou - recursion - mats ] ) .    listing the node matrices of the downhill tree given by fig.[fig - fou ]",
    "( listing them in the order visited by an in - order tree transversal ) gives :    u_ftr= _",
    "4= d_4 ( a_3b_3 ) d_3 ^ 2 ( a_2b_2)^2 d_2 ^ 4 ( a_1b_1)^4 ^8 . [ eq - fou - fin - d ] qubiter first finds the necessary permutation @xmath58 using a strategy to be discussed in the next section .",
    "then qubiter uses re - csd to express @xmath65 in the form given by the right hand side of eq.([eq - fou - fin - d ] ) .",
    "then it recognizes that : ( 1 ) the matrices of the form @xmath44 are one - qubit y - axis rotations , ( 2 ) the diagonal matrices @xmath68 and @xmath69 are expressible as products of doubly controlled phase factors ( such as @xmath70 ) .",
    "if we take the transpose of both sides of eq.([eq - fou-3210 ] ) , we reverse the order of all the operators on the right hand side :    u_ft= r h(0)v(1,0)h(1)v(2,0)v(2,1)h(2 ) v(3,0)v(3,1)v(3,2 ) h(3 ) .",
    "diagrammatically ,    @xmath71 & \\qw & \\dotgate\\qwx[2 ] & \\qw & \\qw & \\dotgate\\qwx[3 ] & \\qw & \\qw & \\qw \\\\ & \\ghost{r } & \\qw & \\dotgate & \\gate{h } & \\qw & \\dotgate\\qwx[1 ] & \\qw & \\qw & \\dotgate\\qwx[2 ] & \\qw & \\qw \\\\ & \\ghost{r } & \\qw & \\qw & \\qw & \\dotgate & \\dotgate & \\gate{h } & \\qw & \\qw & \\dotgate\\qwx[1 ] & \\qw \\\\ & \\ghost{r } & \\qw & \\qw & \\qw & \\qw & \\qw & \\qw & \\dotgate & \\dotgate & \\dotgate & \\gate{h } } \\end{array } \\;.\\ ] ]    in fact , we can take the transpose of all equations between and including eqs.([eq - fou-3210 ] ) to eqs.([eq - fou - fin - d ] ) .",
    "in particular , we get    ^t_r+1= d^t_r+1 for @xmath43 .",
    "also ,    r u_ft= ^t_4= ^8 ( a_1b_1)^4 ( d^t_2)^4 ( a_2b_2)^2 ( d^t_3)^2 ( a_3b_3 ) d^t_4 .",
    "[ eq - fou - fin - d - tanspose ] eq.([eq - fou - fin - d - tanspose ] ) also follows if we list the node matrices of the uphill tree given by fig.[fig - fou ] ( listing them in the order visited by an in - order tree transversal ) .",
    "in decomposing @xmath1 via re - csd , we first pre or post multiplied @xmath1 by the bit reversal matrix @xmath58 .",
    "this example makes it clear that in using re - csd , before each application of the csd , it is helpful to permute either the rows or the columns ( or both ) of the input matrix @xmath24 in fig.[fig - csd ] .",
    "only a certain type of permutation will work ; it must also be a bit permutation , so that it can be expressed as a product of bit exchange operators , which in turn can be expressed as a product of cnots .",
    "but what is a good strategy for choosing such a permutation ?",
    "decompositions such as the ones given here for @xmath36 and @xmath1 come from csd trees that contain only a single branch . to promote the growth of such degenerate trees ,",
    "we want to stunt the growth of either the left matrices @xmath72 or the right matrices @xmath73 in fig.[fig - csd ] .",
    "the left matrices are  stunted \" if @xmath74 and @xmath75 are diagonal matrices .",
    "likewise , the right matrices are  stunted \" if @xmath76 and @xmath77 are diagonal .",
    "& = & + & = & . when the left matrices @xmath72 are diagonal , @xmath78 and @xmath79 are diagonal matrices .",
    "analogously , when the right matrices @xmath73 are diagonal , @xmath80 and @xmath81 are diagonal matrices .",
    "so probably a good strategy for selecting a row and/or column permutation to perform before each csd is to find a bit permutation that minimizes the absolute value of the off - diagonal elements of @xmath82 and/or @xmath83 .",
    "the idea is to coax the growth of sparse trees that have only a few branches ( rightmost and leftmost branches might or might not be included in such a tree . )"
  ],
  "abstract_text": [
    "<S> a quantum compiler is a software program for decomposing (  compiling \" ) an arbitrary unitary matrix into a sequence of elementary operations ( seo ) . </S>",
    "<S> coppersmith showed that the @xmath0-bit discrete fourier transform matrix @xmath1 can be decomposed in a very efficient way , as a sequence of order(@xmath2 ) elementary operations . </S>",
    "<S> can a quantum compiler that does nt know a priori about coppersmith s decomposition nevertheless decompose @xmath1 as a sequence of order(@xmath2 ) elementary operations ? </S>",
    "<S> in other words , can it rediscover coppersmith s decomposition by following a much more general algorithm ? </S>",
    "<S> yes it can , if that more general algorithm is the recursive application of the cosine - sine decomposition ( csd ) . </S>"
  ]
}