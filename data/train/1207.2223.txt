{
  "article_text": [
    "lattice gauge theory @xcite is a formulation of gauge theory on a euclidean space - time lattice @xmath0 .",
    "@xmath0 consists of @xmath1 points @xmath2 ordered in some fashion and @xmath3 links @xmath4 where @xmath5 is the number of space - time dimensions .",
    "this formulation of gauge theory is amenable to computer simulations .",
    "lattice gauge theory simulations can perform non - perturbative computations for static observables in quantum chromodynamics ( qcd ) .",
    "the expectation value of an observable @xmath6 can be obtained by evaluating a euclidean path integral as = d_i d|_i o e^-|_i ( d^(u)+ m_i)_i -s_g(u ) .",
    "@xmath7 is a group valued matrix but other values of @xmath8 are also theoretically interesting . ]",
    "defined on the link @xmath4 and plays the role of a parallel transporter ( gauge field ) .",
    "@xmath9 represents a fermionic species with mass @xmath10 and is defined at each lattice point @xmath2 .",
    "@xmath11 is a lattice dirac operator and @xmath12 is a discretized version of the continuum yang - mills lagrangian @xmath13 .",
    "we first integrate out the fermionic fields to obtain = _ i ( d^(u)+ m_i ) oe^-s_g(u ) .",
    "computing the determinant is an @xmath14 process for a @xmath15 matrix and for the 4-dimensional dirac oprator @xmath16 . even for moderate lattice sizes @xmath17 .",
    "an explicit evaluation of this determinant is not feasible .",
    "it is usually re - exponentiated by introducing additional bosonic fields @xmath18 called pseudofermions as = d^_i d_i o e^-^_i ( d^(u ) + m_i)^-1_i  -s_g(u ) .",
    "the path integral now involves evaluating the inverse of the matrix @xmath19 on the vector @xmath20 .",
    "this can be done in at most @xmath21 steps using conjugate gradient ( cg ) type of algorithms .",
    "though lattice gauge theory simulations are computationally expensive , they can be easily parallelized .",
    "such simulations can therefore be efficiently carried out on a graphics processing units ( gpus ) which have about 500 compute cores .",
    "since the first implementation of lattice gauge simulations on gpus in 2007 @xcite there has been numerous implementations of various formulations of lattice gauge theory on gpus .",
    "a collection of gpu subroutines for several lattice actions has been put together in a package called quda @xcite .",
    "implementation of pure gauge codes and spin models on gpus have been reported in @xcite and @xcite .    in this article",
    "we explore a new method of implementing lattice simulations on the gpu using register variables and avoid the slow global memory for storing run - time variables .",
    "we consider one of the most popular formulations namely lattice gauge theory with two mass degenerate fermions .",
    "this partition function can be written as = d^ de^-^ ( )  -s_g(u ) . where @xmath22    in section 2 we briefly describe the algorithm which we use .",
    "section 3 describes the architecture of the gpu cards on which the program was tested and discusses the modifications we have to make in the usual cpu program for efficient running on the gpu .",
    "finally in section 4 we report on the performance of the program and our conclusions .",
    "currently the most efficient algorithm for generating gauge configurations with dynamical quarks on the lattice is known as hybrid monte carlo ( hmc ) @xcite . in this algorithm",
    "the dynamics is generated by equations of motion corresponding to the hamiltonian ( u , p)=trp^2 + s_g(u)+^ ( ) . here",
    "@xmath23 is an auxiliary momentum variable with @xmath24 and @xmath25 being conjugate to each other .",
    "@xmath26 is drawn from a gaussian distribution and @xmath27 where @xmath28 is also drawn from a gaussian distribution .",
    "both @xmath26 and @xmath28 are periodically refreshed .",
    "the equations of motion ( molecular dynamics equations ) define a trajectory in the phase space . integrating these equations",
    "numerically is the most time consuming part in the algorithm accounting for 80 to 90% of the computation time depending on simulation parameters .",
    "this part of the algorithm involves repeated multiplication of a matrix @xmath29 on the vector @xmath18 .",
    "parallelization of the matrix vector multiplication speeds up lattice gauge theory simulations to a great extent .",
    "the hmc algorithm thus refreshes the momenta periodically to ensure ergodicity , uses the hamiltonian equations of motion to move quickly through the phase space and perofrms a monte carlo accept / reject step to correct for the finite time step used in the integration .",
    "it is an exact algorithm .",
    "our program was tested on two gpu cards the c2050 and x2090 ( different versions of the nvidia fermi card ) and we briefly discuss their architecture below .",
    "both cards have intrinsic double precision support and are cuda compute version 2 .    the computation on the cards",
    "are carried out by multiprocessors each of which have 32 cores and a maximum of 64 kbytes of local storage ( shared memory + l1 cache ) .",
    "the c2050 has 14 such multiprocessors giving it a total of 448 cores while the x2090 has 16 such multiprocessors giving it a total of 512 cores .",
    "nvidia gpu cards have several different categories of memory and their access times vary widely .",
    "the c2050 has a global memory of 3 gb while the x2090 has a global memory of 6 gb .",
    "these are the largest memories but their access times are between 100 and 150 clock cycles .",
    "every multiprocessor on the other hand has 32768 4-byte registers whose combined memory capacity is 128 kbytes and access to the register variables takes only 1 clock cycle . each thread can have a maximum of 63 registers .",
    "fermi cards have the added feature that registers spill over to the shared memory which too can be accessed in 2 - 3 clock cycles .",
    "the combined storage capacity of registers and shared memory is about 192 kbytes per multiprocessor or about 2.7 mb for the c2050 and 3 mb for the x2090 . in our program",
    "we have attempted to use the registers as much as possible instead of the global memory .",
    "the cuda compiler usually tries to place all scalar variables in the register @xcite while arrays are typically placed in the global memory . in hmc ,",
    "the molecular dynamics part deals mainly with three large arrays : the force which is an array of dimension @xmath30 and the momenta and the pseudo - fermion fields , both of which are arrays of dimension @xmath31 our main challenge therefore is to make sure that the elements of these arrays are placed in the register and not in the global memory .    the structure of the program is roughly the same for the cpu and the gpu .",
    "there is an initialization step where the gauge field is initialized .",
    "the gauge field is then evolved through a certain number of trajectories . at the end of each trajectory measurements",
    "are carried out on the gauge configuration .",
    "the evolution of the gauge fields consists of the following steps for each trajectory .    1 .   setting up the pseudofermion fields and momenta .",
    "2 .   integrating the molecular dynamics equations of motion by the leap - frog method .",
    "this sets up the proposed configuration .",
    "3 .   accepting or rejecting the proposed configuration depending on @xmath32 , where @xmath33 is the hamiltonian at the beginning of the trajectory and @xmath34 is the hamiltonian at the end of the trajectory .",
    "communication between the cpu and the gpu is through a pci bus .",
    "a major bottleneck if one frequently transfers data between them . to keep a check on this overhead",
    ", we tried to strike a balance between the time taken for transferring the data and the computational time on the gpu . since all the input and output",
    "is carried out by the cpu we had to transfer the data back to the cpu at the end of each trajectory .    for the computation intensive parts we wrote cuda kernels ( enumerated below ) which carried out the following computations in parallel on the gpu .    1 .   the result of operating the dirac operator and its hermitian conjugate on the pseudofermion field @xmath35 a matrix vector multiplication on a vector of size @xmath36 .",
    "2 .   the driving force for the molecular dynamics equation due to the gauge fields .",
    "the driving force for the molecular dynamics equation due to the fermion fields and evolving the momenta .",
    "evolution of the gauge fields .",
    "we now briefly describe the essential modifications to the cpu subroutines for efficient running of the corresponding gpu kernels .",
    "we first try to optimize the two matrix - vector multiplication routines which compute the action of the dirac operator and its hermitian conjugate on the pseudofermion field as a part of the conjugate gradient routine .",
    "so we first try to optimize this routine .",
    "the dirac operator requires four constant @xmath37 matrices ( @xmath38 ) for its definition .",
    "only 8 elements of these matrices are non - zero .",
    "we explicitly work out the result of the matrix - vector multiplication for the @xmath39 matrices retaining only the non - zero elements .",
    "thus the loop over the dirac indices is fully unrolled .",
    "this however is not special to the cuda kernels and is done also for the cpu subroutines .",
    "generally we use the available cuda blas functions as much as possible .",
    "however for the action of the dirac operator on the pseudofermion field , it is not possible to use the blas matrix - vector multiplication routines as the matrix representing the dirac operator is too large to be stored in either the cpu or the gpu memory .",
    "so we store the source and the resultant vectors and compute the necessary matrix elements on the fly . for this kernel ,",
    "the main optimization task was to break down the array representing the pseudofermion field into scalar variables .",
    "since the pseudofermion field typically consists of @xmath40 elements , it is impossible to do this by hand .",
    "we therefore wrote a code generator which runs over the necessary loops and yields the equations for the resultant vector in terms of independent scalar variables .",
    "a naming convention we adopt is to name the scalar variables by concatenating the array indices with the vector name .",
    "the second computationally intensive task is computing the driving force for the molecular dynamics equation due to the fermion fields . on a single thread",
    ", they typically consume 15% of the trajectory time .",
    "after parallelization of the matrix - vector multiplication routines on the gpu , this was consuming the largest amount of time . to optimize this routine",
    ", we followed the same strategy as in the matrix - vector multiplication case .",
    "unrolling the dirac loops in the force calculation is slightly more involved as they involve factors like @xmath41 .",
    "however a bit of algebra again allows us to retain only the non - zero elements and with the help of a code generator we automatically wrote down the momenta evolution equations .",
    "on the cpu this routine consumed significantly less time compared to the conjugate gradient routine .",
    "so this optimization was not carried out on the corresponding cpu subroutines .",
    "in addition to these optimizations , we also had a routine to compute the neighbour indices on the fly to avoid storing the neighbour array on the gpu .",
    "the program is available from the authors on request .",
    "the speed - up of the gpu program was primarily judged by its performance on a c2050 nvidia gpu card running at 1.15 ghz vis a vis its performance on an opteron cluster with qdr infiniband interconnect .",
    "each node of the cluster consisted of two 6-core 2.2 ghz cpus .",
    "we also have comparative results for one lattice size , viz .",
    "@xmath42 , on a cray xe6 and a x2090 nvidia gpu card running at 1.3 ghz on a cray xk6 node .    on the opteron cluster",
    "the highest performance was obtained for one mpi process per node .",
    "we therefore fixed the number of mpi processes to 8 ( number of available nodes ) and varied the number of openmp threads in each node .",
    "for the sake of uniformity , the same test run pattern was followed even on the cray .",
    "in addition to the total time taken , timings for each conjugate gradient call and fermionic force calculations ( the two most time consuming subroutines ) were written out .    .timing ( in seconds ) of the program on a c2050 gpu , single cpu , smp ( 12 threads ) and mixed mpi and omp with 8 mpi processes each having 12 threads for different lattice volumes .",
    "these runs were performed on an opteron cluster with qdr infiniband interconnect .",
    "( @xmath43estimated ) [ cols=\"^,^,^,^,^\",options=\"header \" , ]     in table [ time ] we record the time taken for the various lattice volumes using different compute modes of the opteron cluster and the c2050 gpu card mounted in the opteron cluster .",
    "these volume scaling runs were performed at @xmath44 and @xmath45 with a time step of 0.2 and 50 integrations per trajectory .",
    "the runs were for 200 trajectories each .",
    "the timing for the single cpu run for the @xmath46 lattice is an estimate based on the @xmath47 scaling of the hmc algorithm , since the actual run was taking far too long . in table",
    "[ speedup ] we see the speed - up of the different computing modes over a single cpu thread .",
    "the cpu runs were performed using the intel fortran compiler with the intel mkl while for the gpu runs we used the nvidia cuda compiler ( nvcc ) . for these runs",
    "we found that the performance of the c2050 card is roughly equivalent to the performance of 96 threads of the cluster ( for lattice size 24@xmath48 ) .",
    "we now report the timing information we have on the cray hardware .",
    "each cray xe6 node consisted of two 16 core opteron cpu at 2.1 ghz . on this machine",
    "the cpu code was compiled by the cray fortran compiler and cray libraries were used .",
    "the run parameters on the cray were the same as the opteron cluster .",
    "however instead of 200 , only 2 trajectories were run starting from an ordered start .",
    "we first tested the scaling of this program with the intel fortan compiler on the xe6 and found that the performance was roughly the same as the opteron cluster upto 64 threads . beyond 64 threads the performance gain continued on the xe6 , but not on the opteron .",
    "the gpu run on the cray was done for a different cg convergence limit compared to the cpu runs ( @xmath49 instead of @xmath50 ) and so we could not directly compare the timing of the x2090 run with the other runs . nevertheless , since the cg inversion timing is linear with the number of cg iterations for both gpus ( see figure [ gpu - scale ] ) , it was possible to obtain a rough estimate for the timing for the x2090 for the same number of cg iterations as the other runs .",
    "an additional information that we get from figure [ gpu - scale ] is that the overhead for the cg routine is about 0.5 secs for both the c2050 and x2090 .    in figure [ inv_comp ]",
    "we compare the inverter timings for the two gpus as well as the opteron cluster and the cray xe6 for a fixed number ( 123 ) of cg iterations .",
    "the c2050 gives the performance of 8 cray threads or 32 cluster threads while the x2090 gives a performance of about 20 cray threads or 64 cluster threads .",
    "figure [ time_comp ] shows the full timing of the runs for the cluster , the xe6 , the c2050 and the x2090 . from this plot",
    "we conclude that the performance of the c2050 is roughly equivalent to about 19 threads of the xe6 , while that of the x2090 is that of about 26 threads .    on the cray xe6 nodes , the force calculation time was about 30% of the inversion time with 64 threads , with 128 threads about 60% of the inversion time and the 256 thread inverter took 60% less time than the force calculation .",
    "therefore , on hindsight , on a lattice of size @xmath42 it is worth unrolling the loops over the force calculations as with the inverter beyond 64 threads . on the opteron cluster on the other hand",
    "the force calculation time was never more than 7% of the inversion time .",
    "thus there not much is to be gained by unrolling the force loops .",
    "our conclusion is that gpu programs can be speeded up to a great extent by using the register variables instead of the global memory . to effectively use the register variables we had to map array elements to scalar variables .",
    "this was carried out automatically by a code generator . before doing this mapping",
    "the performance gain was a modest factor of two . using the registers effectively pushed up the performance gain to a factor 10 compared to a single thread performance on the lattice volumes we investigated .",
    "such automated techniques might prove useful in the design of accelerator compilers .",
    "here we did not use optimization techniques like mixed precision solvers or reconstructing the gauge link on the fly .",
    "we believe these optimizations can bring even more gains .    at the moment",
    "we have tested the performance only on a single gpu .",
    "we hope to report our results on multiple gpus shortly .",
    "the authors would like to acknowledge the dst ( india ) grant no .",
    "sr / s2/hep/0035/2008 for funding the servers and gpu cards on which the programs were run .",
    "the authors would also like to acknowledge cray supercomputers for testing the program on their hardware and sharing the results with the authors .",
    "99 p. weisz and p. majumdar , scholarpedia , 7(4 ) ( 2012 ) 8615 .",
    "g. i. egri , z. fodor , c. hoelbling , s. d. katz , d. nogradi , k. k. szabo comput .",
    "comm . 177 ( 2007 ) 631 .",
    "m. a. clark , r. babich , k. barros , r. brower , and c. rebbi , comput .",
    "( 2010 ) 1571 .",
    "n. cardoso , p. bicudo arxiv:1112.4533 [ hep - lat ] n. cardoso , p. bicudo j. comput .",
    "( 2011 ) 3998 .",
    "m. weigel j. comput .",
    "( 2012 ) 3064 .",
    "s.  duane , a.  d.  kennedy , b.  j.  pendleton , d.  roweth , phys .",
    "b 195 ( 1987 ) 216 .",
    "appendix b.2 , cuda c programming guide version 4.2"
  ],
  "abstract_text": [
    "<S> in this article we present our implementation of a hybrid monte carlo algorithm for lattice gauge theory using two degenerate flavours of wilson - dirac fermions on a fermi gpu . </S>",
    "<S> we find that using registers instead of global memory speeds up the code by almost an order of magnitude . to map the array variables to scalars , so that the compiler puts them in the registers , we use code generators . </S>",
    "<S> our final program is more than 10 times faster than a generic single cpu . </S>"
  ]
}