{
  "article_text": [
    "scalable quantum technologies require the ability to maintain and manipulate coherent quantum states over an arbitrarily long period of time . it is problematic then that the small quantum systems that we might use to realize such technologies decohere rapidly due to unavoidable interactions with the environment . to resolve this issue",
    "we have discovered quantum error - correcting codes  @xcite which make use of a redundancy of physical qubits to maintain encoded quantum states with arbitrarily high fidelity over an indefinite period .",
    "ideally , we will design a fault - tolerant quantum computer that requires as few physical qubits as possible to minimize the resource cost of a quantum processor , and indeed , the cost in resources of a computational architecture is very sensitive to the choice of quantum error - correcting code used by a fault - tolerant scheme .",
    "it is therefore of great interest to analyse different quantum error - correction proposals to compare and contrast their resource demands .",
    "color codes  @xcite are a family of topological quantum error - correcting codes  @xcite with impressive versatility  @xcite for performing fault - tolerant logic gates  @xcite .",
    "this is an important consideration as we search for schemes that realise fault - tolerant quantum computation with a low cost in quantum resources .",
    "in particular , a fault - tolerant quantum computer must be able to perform a non - clifford operation , such as the @xmath0-gate , to realise universal quantum computation .    in general ,",
    "performing non - clifford gates can present a considerable resource cost over the duration of a quantum computation .",
    "as such , the resource cost of realising scalable quantum computation is sensitive to the method a fault - tolerant computational scheme uses to realise non - clifford gates . to this",
    "end the gauge color code  @xcite has attracted significant recent interest because , notably , this three - dimensional quantum error - correcting code can achieve a universal gate set via gauge fixing  @xcite .",
    "in contrast to the gauge - color code , surface code quantum computation , a leading approach towards low - resource quantum computation  @xcite , makes use of magic state - distillation  @xcite to perform @xmath1-gates .",
    "magic state distillation can be achieved with @xmath2 space - time resource cost  @xcite .",
    "similarly , the gauge color code performs @xmath1-gates via gauge fixing in constant time  @xcite , and as such has an equivalent scaling in space - time resource cost as the surface code since the gauge color code requires @xmath2 physical qubits .",
    "however , given that gauge fixing requires no additional offline quantum resources to perform a non - clifford rotation , the gauge color code may reduce the quantum resources that are necessary for fault - tolerant quantum computation by a constant fraction .",
    "it is also noteworthy that the gauge color code is local only in three dimensions and as such , unlike the surface code , can not be realised using a two - dimensional array of locally interacting qubits . instead",
    ", the gauge color code may be an attractive model for non - local quantum - computational architectures such as networked schemes  @xcite .    given the significant qualitative differences between the gauge color code and the surface code , it is interesting to perform a comparative analysis of these two proposals .",
    "in this manuscript we investigate error correction with the gauge color code .",
    "dealing with errors that continually occur on physical qubits is particularly difficult in the realistic setting where syndrome measurements can fail and return false readings  @xcite .",
    "attempting to correct errors using inaccurate syndrome information will introduce new physical errors to the code .",
    "however , given enough syndrome information , we can distinguish measurement errors from physical errors with enough confidence that the errors we introduce are few , and can be identified at a later round of error correction  @xcite . in the case of the toric code",
    "@xcite , we accumulate sufficient error data by performing multiple rounds of syndrome measurements . surprisingly , the structure of the gauge color code enables the acquisition of fault - tolerant syndrome data using only one round of local measurements  @xcite .",
    "this capability is known as single - shot error correction .    here",
    ", we obtain a noise threshold for the gauge color code using a phenomenological noise model where both physical errors and measurement faults occur at rate @xmath3 . we develop a single - shot decoder to identify the sustainable operating conditions of the code , i.e. the noise rate below which information can be maintained arbitrarily well , even after many cycles of error correction .",
    "we estimate a sustainable error rate of @xmath4 using an efficient clustering decoding scheme  @xcite that runs in time @xmath5 ,  @xcite , where the distance of the code is @xmath6 ,  @xcite .",
    "remarkably , the threshold we obtain falls within an order or magnitude of the optimal threshold for the toric code under the same error model , @xmath7 ,  @xcite .",
    "furthermore , we also use our decoder to estimate how the logical failure rate of the gauge color code scales below the threshold error rate by fitting to a heuristic scaling hypothesis .",
    "drawn in the dual picture .",
    "qubits lie on simplices of the lattice .",
    "the faces of the tetrahedra in the figure are given one of four colors such that no two faces of a given tetrahedron have the same color .",
    "the tetrahedra are stacked such that faces that touch always have the same color . for the gauge color code to encode a single logical qubit ,",
    "the lattice must have four distinct , uniformly colored boundaries , as is shown in the figure .",
    "we give more details on the lattice construction in the dual picture in supplementary note  1 together with supplementary figures  1 - 6 .",
    "[ colorcodelattice ] ]      the gauge color code is a subsystem code  @xcite specified by its gauge group , @xmath8 . from the center of the gauge group , @xmath9 , we obtain the stabilizer group for the code , @xmath10 , and its logical operators , @xmath11 .",
    "elements of the stabilizer group , @xmath12 , satisfy the property that @xmath13 for all codewords of the code @xmath14 .",
    "the code is defined on a three - dimensional four - valent lattice of linear size @xmath15 with qubits on its vertices  @xcite .",
    "the lattice must also be four - colorable , i.e. each cell of the lattice can be given a color , red , green , yellow , or blue , denoted by elements of the set @xmath16 , such that no two adjacent cells are of the same color .",
    "the lattice we consider is shown in fig .",
    "[ colorcodelattice](a ) , where the cells are the solid colored objects in the figure .",
    "the cells of the lattice define stabilizer generators for the code , while the faces of cells define its gauge generators .",
    "the gauge operators , otherwise known as face operators , are measured to infer the values of stabilizer operators .",
    "the face operators have weight four , six and eight , where the weight - eight face operators lie on the boundary of the lattice .",
    "more specifically , for each cell @xmath17 there are two stabilizer generators , @xmath18 and @xmath19 , where @xmath20 are the qubits on the boundary vertices of cell @xmath17 , and @xmath21 and @xmath22 are pauli - x and pauli - z operators acting on vertex @xmath23 . for each face",
    "@xmath24 there are two face operators , @xmath25 and @xmath26 where @xmath27 are the vertices on the boundary of face @xmath24 .",
    "we will call the outcome of a face operator measurement a face outcome .",
    "given suitable boundary conditions  @xcite , the code encodes one qubit , whose logical operators are @xmath28 and @xmath29 , where @xmath30 is the set of physical qubits of the code . a lattice with correct boundaries is conveniently represented on a dual lattice of tetrahedra using the convention given in ref .",
    "the lattice we consider is illustrated in fig .",
    "[ colorcodelattice](b ) , where we discuss its construction in detail in the supplementary notes  1 and  2 , together with supplementary figures  1 - 7 .",
    "importantly , we require that the lattice has four boundaries , distinguished by colors from set @xmath31 .      ]",
    "a quantum error - correcting code is designed to identify and correct errors . due to the symmetry of the gauge group",
    ", it suffices here to consider only bit - flip , i.e. pauli - x errors .",
    "we consider a phenomenological error model consisting of physical errors and measurement errors .",
    "a physical error is a pauli - x error on a qubit , while a measurement error returns the opposite outcome of the correct reading .",
    "errors will be identically and independently generated with the same probability @xmath3 .    in a stabilizer code",
    ", errors are identified by stabilizer measurements that return eigenvalue @xmath32 , which we call stabilizer defects .",
    "we use the stabilizer syndrome , a list of the positions of stabilizer defects , to predict the incident error . in the gauge color code",
    "we do not measure stabilizer operators directly , but instead infer their values by measuring face operators , which is possible due to the fact that @xmath33 .",
    "in addition to using face outcomes to infer stabilizer eigenvalues , we can also exploit the local constraints in @xmath8 of the gauge color code to detect and account for measurement errors .",
    "remarkably , measurement errors can be detected reliably by measuring each face operator only once , so called single - shot error correction @xcite .",
    "the local constraints stem from the structure of the code .",
    "we first observe that the faces of a cell are necessarily three colorable , as shown in fig .",
    "[ gaugemeasurements](a ) .",
    "it follows from the three colorability of the faces that the product of the gauge operators @xmath34 of any of the differently colored subsets of faces of cell @xmath17 recover the stabilizer operator @xmath35 . by measuring all the faces of the lattice",
    ", we redundantly recover each stabilizer eigenvalue three times where the three outcomes of a given cell are constrained to agree . in fig .",
    "[ gaugemeasurements](b ) we show an example of a gauge measurement configuration where the outcomes are reliable . following this observation",
    ", we can use violations of the local constraints about a cell to indicate the positions of measurement errors . in fig .",
    "[ gaugemeasurements](c ) we show a syndrome where the product ofthe face outcomes of different subsets of of two cells , colored with thick green edges , do not agree .",
    "fault - tolerant decoding with the gauge color code proceeds in two stages .",
    "the first stage , syndrome estimation , uses face outcomes that may be unreliable to estimate the locations of stabilizer defects .",
    "the second stage , stabilizer decoding , takes the estimated stabilizer defect locations and predicts a correction operator to reverse physical errors .",
    "the topological nature of the gauge color code is such that its stabilizer defects satisfy conservation laws that enable us to employ well - studied decoding algorithms  @xcite to complete stabilizer decoding .",
    "the syndrome identified by stabilizer measurements is studied extensively in refs .",
    "stabilizers that return @xmath32 outcomes occur in pairs at the endpoints of strings of errors , whose endpoints take the color of its terminal cells , as shown in fig .  [ syndrome](a ) .",
    "as such , one can also regard an error string as carrying the color of the stabilizer defects at its endpoints .",
    "error strings on the gauge color code can also branch into three strings of conjugate colors , thus creating one syndrome of each color , as shown in fig .",
    "[ syndrome](b ) .",
    "finally , error strings of a given color can terminate at the boundary of their respective color , as shown in fig .",
    "[ syndrome](c ) . in our simulation",
    "we decode stabilizer defects by adapting a clustering decoder  @xcite where clusters grow linearly .",
    "we concentrate now on syndrome estimation .",
    "syndrome estimation uses a gauge syndrome , a list of gauge defects , to estimate a stabilizer sydrome .",
    "a lattice cell can contain as many as three gauge defects .",
    "gauge defects are distinguished by a color pair @xmath36 , with @xmath37 , such that @xmath38 and @xmath39 .",
    "the color pair of a gauge defect relates to the coloring of the lattice faces .",
    "a face is given the color pair opposite to the colors of its adjacent cells , i.e. the face shared by two cells with colors @xmath40 and @xmath41 is colored @xmath42 .",
    "a cell @xmath17 contains a @xmath36 gauge defect if the product of all the @xmath36 face outcomes bounding @xmath17 is @xmath32 .",
    "following this definition , a stabilizer defect is equivalent to three distinct gauge defects in a common cell .    studying the gauge syndrome enables the identification of measurement errors .",
    "we consider face @xmath24 , colored @xmath36 , that is adjacent to cell @xmath17 . in the noiseless measurement case , where @xmath17 contains no stabilizer defect , by definition",
    ", cell @xmath17 should contain no gauge defects .",
    "however , if face @xmath24 returns an incorrect outcome , we identify a @xmath36 gauge defect at @xmath17 .",
    "conversely , if cell @xmath17 contains a stabilizer defect in the ideal case , and @xmath24 returns an incorrect outcome , no @xmath36 gauge defect will appear in @xmath17 . with these examples we see that cells that contain either one or two gauge defects indicate incorrect face outcomes .",
    "an incorrect face outcome affects gauge defects in both of its adjacent cells . in general ,",
    "incorrect face outcomes of color @xmath36 form error strings on the dual lattice , whose end points are @xmath36 gauge defects , where individual incorrect face outcomes are segments of the string .",
    "error strings of incorrect @xmath36 face outcomes changes the parity of @xmath36 gauge defects at both of its terminal cells .",
    "we require an algorithm that can use gauge syndrome data to predict a likely measurement error configuration , and thus estimate the stabilizer syndrome .",
    "we adapt the clustering decoder  @xcite for this purpose .",
    "the decoder combines nearby defects into clusters that can be contained within a small box .",
    "clusters increase linearly in size to contain other nearby defects until they contain a set of gauge defects that can be caused by a measurement error contained within the box .",
    "once clustering is completed , a correction supported inside the boxes is returned .",
    "we briefly elaborate on correctable configurations of gauge defects .",
    "pairs of @xmath36 gauge defects are caused by strings of incorrect @xmath36 face outcomes , and therefore form correctable configurations , as shown in fig .  [",
    "syndrome](d ) . as an example , the gauge syndrome in fig .",
    "[ syndrome](d ) depicts the gauge defects and measurement error string shown in fig .",
    "[ gaugemeasurements](c ) where the measurement errors have occurred on the faces that returned @xmath32 measurement outcomes .",
    "triplets of gauge defects , colored @xmath36 , @xmath43 and @xmath44 , also form correctable configurations .",
    "error strings that cause triplets of correctable gauge defects branch at a cell , and thus indicate a stabilizer defect , shown in fig .",
    "[ syndrome](e ) .",
    "the stabilizer defect where the error string branches lies at a cell colored @xmath45 .",
    "gauge defects can also arise due to incorrect face outcomes on the lattice boundary .",
    "specifically , the boundary colored @xmath46 contains faces of color @xmath36 where @xmath47 . with this coloring",
    "we can find correctable configurations of single @xmath36 gauge defects , together with a boundary of color @xmath46 , see fig .",
    "[ syndrome](f ) . in general",
    ", a cluster can contain many correctable pairs and triplets of gauge defects .",
    "as we have mentioned , correctable clusters of gauge defects can give rise to stabilizer defects .",
    "it is important to note that the error - correction procedure is sensitive to the positions of stabilizer defects within a correctable cluster , as discrepancies in their positions later affect the performance of the stabilizer decoding algorithm .",
    "as such we must place stabilizer defects carefully . for cases where a correctable cluster of gauge defects returns stabilizer defects , we assign their positions such that they lie at the mean position of all the gauge defects within the correctable cluster , at the nearest cell of the appropriate color .",
    "once syndrome estimation is complete , the predicted stabilizer syndrome is passed to the stabilizer decoder , and a correction operator is evaluated .",
    "we remark that gauge defects can be incorrectly analyzed during syndrome estimation . in which case",
    ", measurement errors sometimes masquerade as stabilizer defects , and sometimes stabilizer defects can be misplaced",
    ". we will then attempt to decode the incorrect stabilizer syndrome and mistakenly introduce errors to the code .",
    "in general , any error - correction scheme that takes noisy measurement data will introduce residual physical errors to a code .",
    "these errors can be corrected in the future , provided the remaining noise is of a form that a decoder can correct . in general",
    "however , one must worry that large correlated errors can be introduced that adversarially corrupt encoded information  @xcite .",
    "such errors may occur in the gauge color code if , for instance , we mistakenly predict two stabilizer defects of the same color that are separated by a large distance .",
    "we give an example of a mechanism that might cause a correlated error during syndrome estimation with the gauge color code in the supplementary note  3 , together with supplementary figure  8 .",
    "a special property of the gauge color code is that measurement errors , followed by syndrome estimation , will only introduce false defects in locally correctable configurations .",
    "therefore , residual errors remain local to the measurement error",
    ". moreover , the code is such that the probability of obtaining configurations of face outcomes that correspond to faux stabilizer defects decays exponentially with the separation of their cells .",
    "this is because the number of measurement errors that must occur to produce a pair of false stabilizer defects is extensive with their cell separation . to this end ,",
    "the errors introduced from incorrect measurements are local to the measurement error and typically small .",
    "this property , coined ` confinement ' in ref .",
    "@xcite , is essential for fault - tolerant error correction .",
    "most known codes achieve confinement by performing syndrome measurements many times .",
    "we give numerical evidence showing that our error - correction protocol confines errors in the following subsection .",
    "( a ) two blue syndromes indicate the end points of a string of errors connecting the two points .",
    "( b ) a string error branches to create one syndrome of each color . ( c )",
    "a green string error can terminate at a green boundary , thus generating only a single green syndrome .",
    "( d )  a pair of @xmath42 gauge defects , shown by the vertices , can be caused by a string of incorrect @xmath42 face outcomes on the dual lattice .",
    "the displayed gauge syndrome is equivalent to that shown in fig .",
    "[ gaugemeasurements](c ) where the measurement errors have occurred on the faces that returned @xmath48 outcomes .",
    "( e )  three gauge defects , colored @xmath49 , @xmath50 and @xmath51 , can be caused by an error string that branches at a red cell .",
    "the branching point indicates a stabilizer defect at a red cell .",
    "( f )  strings of incorrect face outcomes of colors @xmath52 and @xmath50 terminate at a yellow boundary . ]",
    "we simulate fault - tolerant error correction with encoded states @xmath53 of linear size @xmath15 where @xmath23 indicates the number of error - correction cycles that have been performed , and where @xmath54 is a codeword .",
    "we seek to find a correction operator @xmath55 such that @xmath56 where @xmath57 is the noise incident to @xmath54 after @xmath58 error - correction cycles .    to maintain the encoded information over long durations , we repeatedly apply error - correction cycles to keep the physical noise sufficiently benign .",
    "after a short period , the state @xmath59 will accumulate physical noise @xmath60 with error rate @xmath3 . to correct the noise",
    ", we first estimate a stabilizer syndrome , @xmath61 , using gauge syndrome data with the syndrome estimation algorithm @xmath62 , where measurement outcomes are incorrect with probability @xmath63 . specifically , we have that @xmath64 .",
    "we then use the stabilizer decoding algorithm @xmath65 to predict a suitable correction operator @xmath66 , such that we obtain @xmath67    it is important to note is that @xmath68 is not necessarily in the code subspace . for @xmath69 ,",
    "stabilizer syndromes will in general be incorrectly estimated , and thus the correction operator @xmath70 introduces some new errors to the code .",
    "we show logical error rates , @xmath71 , as a function of physical error rate , @xmath3 , for system sizes @xmath72 and @xmath73 shown in blue , yellow , green and red , respectively , as is marked in the legend , where we collect data after @xmath74 rounds of error correction during which measurements are performed unreliably .",
    "the error bars show the standard error of the mean given by the expression  @xmath75 where @xmath76 is the number of monte carlo samples we collect .",
    "the data used to determine the threshold error rate is shown in the inset , where we determine the threshold using the fitting described in the methods section .",
    "the fitting is also plotted in the inset . in the main figure",
    "the solid lines show the fitted expression , eqn .",
    "( [ eqn : low - pfitting ] ) , to demonstrate the agreement of our scaling hypothesis with numerically evaluated logical error rates where @xmath77 .",
    "we remark that the fitting is made using data for all values of @xmath58 , and not only the data shown in this plot , as we explain in the methods section . ]",
    "we require that after @xmath58 error - correction cycles we can estimate error @xmath57 of state @xmath78 to perform a logical measurement . to perform the @xmath79 logical measurement  @xcite",
    ", we measure each individual qubit of the code in the pauli - z basis .",
    "this destructive transversal measurement gives us the eigenvalues of stabilizers @xmath80 to diagnose @xmath57 , and to thus recover the eigenvalue of @xmath79 .    during readout ,",
    "measurement errors and physical errors have an equivalent effect ; both appear as bit flips . to simulate errors that occur during the readout process , we apply the noise operator @xmath81 to the encoded state before decoding .",
    "we therefore calculate logical failure rates @xmath82 where @xmath83 .",
    "we evaluate @xmath84 values using monte carlo simulations .    to analyze the performance of the proposed decoding scheme",
    ", we first look to find the sustainable error rate of the code , @xmath85 , below which we can maintain quantum information for an arbitrary number of correction cycles .",
    "the discovery of such a point suggests that the error - correlations caused by our correction protocol do not extend beyond a constant , finite , and decodable length , thus showing that we can preserve information indefinitely with arbitrarily high fidelity in the @xmath86 regime .",
    "we define @xmath85 as the threshold error rate , @xmath87 , at the @xmath88 limit , where the threshold is the error rate below which we can decrease @xmath71 arbitrarily by increasing @xmath15  @xcite . in the inset of fig .",
    "[ thresholdfigure ] we show the near threshold data we use to evaluate a threshold , where we show the data for @xmath74 as an example .",
    "we give the details of the fitting model we use to evaluate thresholds in the methods section of this manuscript .",
    "threshold error rates , @xmath87 , are calculated with system sizes @xmath89 after @xmath58 error - correction cycles using @xmath90 monte carlo samples .",
    "error bars show the standard error of the mean which are determined using the * nonlinearmodelfit * function in * mathematica*. the solid blue line shows the fitting given in eqn .",
    "( [ fitting ] ) .",
    "the dashed red line marks @xmath91 , the sustainable noise rate of the code , the limiting value of @xmath87 from to the fitting as @xmath92 . ]",
    "we next study the evaluated threshold values as a function of @xmath58 .",
    "we show this data in the plot given in fig .",
    "[ phasediagram ] .",
    "the data shows that @xmath87 converges to @xmath4 where we fit for values @xmath93 .",
    "we obtain this value with a fitting that converges to @xmath85 , namely @xmath94 . \\label{fitting}\\ ] ] we find @xmath95 and @xmath96 .",
    "the convergent trend provides evidence that we achieve steady - state confinement in the high-@xmath58 limit , as is required of a practical error - correction scheme .    to verify further the threshold error rates we have determined , we next check that the logical failure rate decays as a function of system size in the regime where @xmath77 . in the large @xmath58 limit",
    ", we fit our data to the following hypothesis @xmath97 where @xmath98 , @xmath99 and @xmath100 are positive constants to be determined and @xmath101 is the distance of the code . we evaluate the variables in eqn .",
    "( [ eqn : low - pfitting ] ) as @xmath102 , @xmath103 and @xmath104 using @xmath105 cpu hours with data for @xmath106 .",
    "details on the fitting calculation are given in the methods section .",
    "we plot the fitted scaling hypothesis on fig .",
    "[ thresholdfigure ] for the case of @xmath74 to show the agreement of eqn .",
    "( [ eqn : low - pfitting ] ) with the available data .",
    "to summarize , using only a simple decoding scheme , we have obtained threshold values that lie within an order of magnitude of the optimal threshold for the toric code under the phenomenological noise model .",
    "moreover , we can expect that higher thresholds are achievable using more sophisticated decoding strategies  @xcite",
    ". it may be possible to achieve a sufficiently high sustainable noise rate to become of practical interest , thus meriting comparison with the intensively - studied surface code  @xcite .",
    "to this end , further investigation is required to learn its experimental viability .    to continue such a comparative analysis , one should study the code using realistic noise models  @xcite that respect the underlying code hardware .",
    "we expect that the threshold will suffer relative to the surface code when compared using a circuit - based noise model where high - weight gauge measurements are more error prone  @xcite .",
    "fortunately , gauge color code lattices are known where face operators have weight no greater than six  @xcite . while this is not as favorable as the weight - four stabilizer measurements of the surface code , given the ability to perform single - shot error correction , and @xmath1-gates through gauge fixing , we argue that the gauge color code is deserved of further comparison .    to the best of our knowledge , we have obtained the first threshold using single - shot error correction .",
    "fundamentally , our favorable threshold is achieved using redundant syndrome data to identify measurement errors .",
    "it is interesting to ask if we can make use of a more intelligent collection of measurement data to improve thresholds further .",
    "discovering single - shot error - correction protocols with simpler codes might help to address such questions .",
    "we gratefully acknowledge s. bartlett , h. bombn , e. campbell , s. devitt , a. doherty , s. flammia and m. kastoryano for helpful discussions .",
    "computational resources are provided by the imperial college hpc service .",
    "this work is supported by the epsrc and the villum foundation . + * author contributions : * original concept conceived by bjb and deb , simulations designed and written by bjb and nhn , data collected and analysed by bjb and nhn , the manuscript was prepared by all the authors .",
    "+ * data availability : * the code and data used in this manuscript is available upon request to the corresponding author . +",
    "* competing financial interests : * the authors declare no competing financial interests . +",
    "the threshold error rate , @xmath87 , is the physical error rate below which the logical failure rate of the code can be arbitrarily suppressed by increasing the code distance .",
    "we identify thresholds by plotting the logical failure rate as a function of physical error rate @xmath3 for several different system sizes , and identify the value @xmath107 such that @xmath71 is invariant under changes in system size . in the main text",
    "we show the data used for a specific threshold calculation in fig .",
    "[ thresholdfigure ] where we use the @xmath74 data as an example , and in fig .",
    "[ phasediagram ] we evaluate threshold error rates for the gauge color code as a function of the number of error correction cycles , @xmath58 .",
    "we evaluate threshold error rates by performing @xmath90 monte carlo simulations for each value of @xmath3 close to the crossing point using codes of system sizes @xmath108 and @xmath73 , except for the case that @xmath109 where we evaluate the logical failure rate with system sizes @xmath110 and @xmath111 . simulating larger system sizes where @xmath112 is possible as in this case we read out information immediately after encoding it , such that @xmath113 as shown in eqn .",
    "( [ eqn : logicalfailurecalculation ] ) .",
    "we therefore need not perform syndrome estimation in the @xmath114 simulation .",
    "the threshold error rate at @xmath109 is thus the threshold error rate of the clustering decoder for the gauge color code where measurements are performed perfectly , i.e. , @xmath115 .",
    "we identify the crossing point by fitting our data to the following formula @xmath116 where @xmath117 and @xmath118 , @xmath87 and @xmath119 are constants to be determined .",
    "we show an example of this fitting in the inset of fig .",
    "[ thresholdfigure ] .    at the threshold error rate",
    "the code produces logical failures at a rate between @xmath120 and @xmath121 depending on @xmath58 .",
    "we expect such behavior as the number of logical failures will increase with repeated use of a decoder .",
    "we therefore obtain between @xmath122 and @xmath123 logical failures per data point close to the threshold error rate .      here",
    "we summarize the resource - scaling analysis we give in the @xmath77 regime .",
    "we suppose the logical failure rate in this regime scales like @xmath124 where @xmath98 , @xmath99 and @xmath125 are constants to be determined , @xmath126 is the distance of the code , @xmath3 is the error rate and @xmath58 is the number of uses of the decoder we make before readout .",
    "the value of @xmath127 is determined by the method given in the previous subsection .",
    "this equation is derived by assuming that a single use of the decoder will fail with probability @xmath128 in the low-@xmath3 regime .",
    "we then calculate to first order the probability that the decoder will fail a single time in @xmath129 uses to give eqn .",
    "( [ eqn : logicalfailurerate ] ) , where we include an additional use of the decoder to account for a possible logical failure during readout .",
    "we manipulate eqn .",
    "( [ eqn : logicalfailurerate ] ) to show a method to evaluate @xmath99 and @xmath125 .",
    "we first take the logarithm of both sides of eqn .",
    "( [ eqn : logicalfailurerate ] ) to find the linear expression @xmath130 where we write @xmath131 and @xmath132 .",
    "we then take the gradient , @xmath133 , from eqn .",
    "( [ eqn : gradientfitting ] ) to find @xmath134    plot showing @xmath135 as a function of @xmath136 for the case that @xmath74 where we have plotted system sizes @xmath72 and @xmath137 shown in blue , yellow , green and red , respectively .",
    "the error bars show the standard error of the mean given by the expression  @xmath138^{1/2 } /   p_{\\text{fail } } $ ] where @xmath76 is the number of monte carlo samples we collected .",
    "the logarithm of the gradients found for the linear fittings are plotted as a function of @xmath139 in fig .",
    "[ fig : gradientfitting ] .",
    "[ fig : exampledata ] ]    in fig .",
    "[ fig : exampledata ] we plot @xmath140 as a function of @xmath141 . for fixed system",
    "sizes we observe a linear fitting that eqn .",
    "( [ eqn : gradientfitting ] ) predicts .",
    "we take the gradient of each of these fittings to estimate @xmath142 , as given in eqn .",
    "( [ eqn : finalfitting ] ) . then , to find @xmath99 and @xmath125 , we plot @xmath143 as a function of @xmath139 where the gradients are taken from the fittings shown in fig .",
    "[ fig : exampledata ] .",
    "this data is shown in fig .",
    "[ fig : gradientfitting ] .",
    "we can now determine @xmath144 and @xmath125 using , respectively , the @xmath145 intersection , and the gradient of a linear fit shown in fig .",
    "[ eqn : gradientfitting ] .    ) .",
    "the figure shows the logarithm of the gradients found in fig .",
    "[ fig : logpfit ] , @xmath146 , plotted as a function of the logarithm of the code distance , @xmath139 , for the case where @xmath74 .",
    "error bars show the standard error of the mean , evaluated using the * linearmodelfit * function in * mathematica*. for this case we obtain a fitting @xmath147 , as is shown in the plot .",
    "[ fig : gradientfitting ] ]    the logical failure rates we use to find @xmath99 and @xmath125 are found using between @xmath148 and @xmath149 monte carlo samples for each value of @xmath3 where we only take values of @xmath150 for each @xmath58 .",
    "we discard data points where we observe fewer than ten failures for a given @xmath3 .",
    "the data was collected over 5000 cpu hours .",
    "unitless values , @xmath99 and @xmath125 , plotted as a function of error - correction cycles , @xmath58 , shown in blue and yellow respectively .",
    "the error bars show the standard error of the mean , which are found using the * nonlinearmodelfit * function included in * mathematica*. the @xmath99 and @xmath125 data points are fitted to eqns .",
    "( [ eqn : alphafitting ] ) and  ( [ eqn : betafitting ] ) , respectively .",
    "the fitted functions are shown in the plot . ]",
    "we plot the values we find for @xmath99 and @xmath125 as a function of @xmath58 in fig .",
    "[ fig : alphabetainn ] .",
    "importantly , we observe convergence in the large @xmath58 limit .",
    "we see this using the fitting functions @xmath151 , \\label{eqn : alphafitting}\\ ] ] and @xmath152 , \\label{eqn : betafitting}\\ ] ] to find the @xmath153 behaviour of our protocol , where @xmath154 , @xmath155 , @xmath156 , @xmath157 , @xmath158 and @xmath159 are constants to be determined , such that @xmath160 we fit these functions to our data to find @xmath161 together with the following values @xmath162 , @xmath163 , @xmath164 and @xmath165 .",
    "the fittings are shown in fig .",
    "[ fig : alphabetainn ] .",
    "figure shows unitless values of @xmath98 numerically determined as a function of the number of error - correction cycles we perform , @xmath58 .",
    "the error bars show the standard error of the mean which is calculated using * mathematica*. we fit the data to eqn .",
    "( [ eqn : afitting ] ) as we show in the figure . ]",
    "finally , given that we have evaluated @xmath166 and @xmath167 for different values of @xmath58 , we use these values together with eqn .",
    "( [ eqn : logicalfailurerate ] ) to determine @xmath98 as a function of @xmath58 .",
    "we show the data in fig .",
    "[ fig : afitting ] .",
    "we fit the values of @xmath168 to the following expression @xmath169 , \\label{eqn : afitting}\\ ] ] to find values @xmath170 ,",
    "@xmath171 and @xmath172 , thus giving all of the variables , @xmath173 , @xmath156 and @xmath157 , we require to estimate the @xmath153 behavior of the decoding scheme in the below threshold regime . +    61ifxundefined [ 1 ] ifx#1 ifnum [ 1 ] # 1firstoftwo secondoftwo ifx [ 1 ] # 1firstoftwo secondoftwo `` `` # 1''''@noop [ 0]secondoftwosanitize@url [ 0 ] ",
    "+ 12$12  & 12#1212_12%12@startlink[1]@endlink[0]@bib@innerbibempty @noop * * ,   ( ) @noop * * ,   ( ) @noop * * ,   ( ) @noop * * ,   ( ) @noop * * ,   ( ) @noop * * ,   ( ) @noop * * ,   ( ) @noop * * ,   ( ) @noop * * ,   ( ) @noop * * ,   ( )  and ,  eds .",
    ", @noop _ _ ( ,  ) @noop * * ,   ( ) @noop * * ,   ( ) @noop * * ,   ( ) @noop * * ,   ( ) @noop * * ,   ( ) @noop ( ) @noop * * ,   ( ) @noop * * ,   ( ) @noop * * ,   ( ) @noop * * ,   ( ) @noop * * ,   ( ) @noop * * ,   ( ) @noop * * ,   ( ) @noop * * ,   ( ) @noop * * ,   ( ) @noop * * ,   ( ) @noop * * ,   ( ) @noop * * ,   ( ) @noop ( ) @noop * * ,   ( ) @noop * * ,   ( ) @noop * * ,   ( ) _ _ , @noop ph.d . thesis ,   ( ) @noop * * ,   ( ) @noop * * ,   ( ) @noop * * ,   ( ) @noop * * ,   ( ) @noop * * ,   ( ) @noop * * ,   ( ) @noop * * ,   ( ) @noop * * ,   ( ) @noop * * ,   ( ) @noop * * ,   ( ) @noop * * ,   ( ) @noop * * ,   ( ) @noop * * ,   ( ) @noop * * ,   ( ) @noop * * ,   ( ) @noop * * ,   ( ) @noop * * ,   ( ) @noop * * ,   ( ) @noop * * ,   ( ) @noop * * ,   ( ) @noop * * ,   ( ) @noop * * ,   ( ) @noop * * ,   ( ) @noop ( ) @noop ( ) @noop * * ,   ( ) @noop ( )",
    "\\(a ) an odd and an even unit cube that each consist of five tetrahedra .",
    "the odd unit cube differs from the even unit cube by a @xmath174 rotation about any of the canonical axes .",
    "( b ) an exploded even unit cell that reveals the internal structure of a unit cube .",
    "( c ) a fundamental tetrahedron of the lattice whose vertices are correctly four colored .",
    "we color each face of every tetrahedron with the color that is not the color of any of its three vertices .",
    "the face that is not visible is colored green .",
    "[ fundamentalunits ]          a cube of linear size @xmath175 formed by stacking odd and even unit cubes . the odd and even unit cubes , shown in grey and white ,",
    "are stacked such that no two even unit cubes meet at a face and no two odd unit cubes meet at a face .",
    "we remove tetrahedra from the cubic lattice shown in supplementary figure 2 to obtain the four - sided tetrahedral structure we require of the gauge color code lattice .",
    "the figure shows some of the tetrahedra that have been removed from the cubic lattice to the right of the figure .",
    "the remaining tetrahedra do not define a gauge color code dual lattice without replacing some of the removed tetrahedra , as we explain in supplementary note  1 and show in supplementary figure  4 .",
    "we modify the lattice of supplementary figure 3 to uniformly color the boundaries by replacing some of the tetrahedra that were removed from the cubic lattice .",
    "patches of six incorrectly colored faces are outlined with white hexagons .",
    "we add additional tetrahedra to these incorrectly colored patches such that all four boundaries are uniformly colored .",
    "the figure shows some hexagons where the additional tetrahedra are already added .",
    "[ boundaries ]          the @xmath175 lattice where the layers of tetrahedra are separated .",
    "interior tetrahedra are colored white and grey .",
    "[ latticelayers ]          a repeating cell of the lattice that consists of eight of the fundamental unit cubes",
    ". stabilizers of weight eight and thirty - two are represented by diamonds and circles on the vertices of the repeating cell respectively , as shown in the key at the right of the figure .",
    "opposite faces of the repeating cell are equivalent .",
    "[ stabilizergeometry ]          qubits on the exterior of the gauge color code lattice .",
    "qubits lie on all the faces , on the edges where two differently colored boundaries meet , fattened and colored in grey in the figure , and on the vertex where three differently colored boundaries meet , marked by a large yellow vertex in the figure .",
    "qubits are numbered in accordance with the text in supplementary note  2 .",
    "qubits 7 , 8 , 13 and 15 lie on lattice edges and qubit 14 lies on the vertex where the red blue and green vertices meet .",
    "all other labeled qubits lie on the external faces of the lattice .",
    "errors introduced during fault - tolerant error correction .",
    "( a ) an error string that , given perfect measurement outcomes , generates two blue stabilizer defects .",
    "( b ) measurement errors appear as strings on the dual lattice picture , which are shown as multi - colored strings in the diagram .",
    "gauge defects are identified where strings of measurement errors terminate .",
    "the original physical error is marked in grey .",
    "( c ) during syndrome estimation , we incorrectly estimate the position of the measurement errors , and thus incorrectly identify the true position of the stabilizer defect .",
    "the correction operator we apply is represented by a blue string .",
    "( d ) the correction operator we apply to correct the estimated stabilizer defect introduces a new error to the system .",
    "the net error that is introduced by the initial physical error and the inaccurate correction operator effectively acts like the discrepancy between the estimated position of the stabilizer defect from its true position .",
    "this discrepancy is marked by the blue error string in the diagram .",
    "[ fig : correlationsdevelop ]",
    "here we elaborate on the dual lattice we use to construct the gauge color code simulated in the main text .",
    "the gauge color code dual lattice is a neatly stacked structure of many tetrahedra .",
    "conveniently though , the lattice dual to the lattice geometry shown in figure  1(a ) in the main text is composed of odd and even cubic units of five tetrahedra , shown in white and grey , respectively , in supplementary figure  1(a ) .",
    "we also show the decomposition of an even unit cell in supplementary figure  1(b ) .",
    "an odd unit cell differs from an even unit cell only by a @xmath176 rotation about any of the canonical axes .",
    "unit cubes on the boundaries of the lattice are modified simply by removing subsets of their tetrahedra .    to ease the explanation of the lattice construction ,",
    "it is instructive to begin with a cubic block of fundamental cubes , as shown in supplementary figure  2 .",
    "the block must have an odd linear dimension of unit cubes .",
    "tetrahedra are removed from this block to find an appropriate four - sided structure , and finally some of the tetrahedra that have been removed are once again replaced to find suitable boundaries that can be correctly colored .    in the dual representation",
    "we require that the vertices of the lattice are four colorable , i.e. we can consistently color every vertex with one of four colors , red , green , yellow or blue , such that no two vertices of the lattice that share an edge can have the same color .",
    "we show a single tetrahedra whose vertices are correctly colored in supplementary figure  1(c ) .",
    "the vertices of the dual lattice in supplementary figure  2 are indeed four colorable .",
    "the gauge color code requires four distinct boundaries where boundaries differ by the subset of colors of the vertices that lie on their surface .",
    "specifically , a boundary of a given color contains no vertices of that color , i.e. a green boundary contains only red , blue and yellow vertices .",
    "we therefore look for a tetrahedral structure with four boundaries of four different colors .",
    "we design the correct structure by first removing large subsets of fundamental tetrahedra to find the global shape of the lattice .",
    "we find a four - sided tetrahedral structure by removing four corners of the cubic block of unit cubes , as shown in supplementary figure  3 .",
    "the lattice shown in supplementary figure  3 does not define the gauge color code .",
    "this is because we can not four - color the lattice such that all four boundaries of the lattice are correctly three colored , as we have explained .",
    "however , by replacing some of the tetrahedra we have removed from the lattice , we recover suitable boundaries . to find three - colored boundaries it is convenient to color the faces of the fundamental tetrahedra .",
    "we assign to each face of the tetrahedra the color that is not given to any of its adjacent vertices , as shown in supplementary figure  1(c ) . with this face coloring , we require that the lattice has four distinct , uniformly colored boundaries , as shown in the main text in figure  1(b ) .",
    "we modify the tetrahedral lattice shown in supplementary figure  3 to find a suitable lattice . in supplementary figure  4 we color the external faces of the fundamental tetrahedra to show the additional tetrahedra we must replace on the surface of the sheered lattice in supplementary figure  3 . in particular , we observe hexagonal ` patches ' of faces which are inconsistently colored compared with the rest of the boundary .",
    "we outline some of these hexagonal patches in white . at the centre of each of these hexagons",
    "lies a single vertex of a color that is not suitable for the given boundary . to rectify this",
    "we replace all of the removed tetrahedra to the lattice that were originally touching the central vertex of each hexagonal patch . upon doing",
    "so we recover the dual lattice shown in the main text . in supplementary figure  4",
    "we show some of the ` bulbs ' of sixteen tetrahedra we reintroduce to the lattice .",
    "some of the bulbs have already been reattached in the figure .",
    "for the convenience of the reader we show the lattice separated into layers in supplementary figure  5 .",
    "we finally remark that the lattice we consider is particularly convenient for simulation because the stabilizers lie on the vertices of a cubic lattice . in supplementary figure  6",
    "we show a repeating unit of the lattice geometry on a cubic lattice . in the figure stabilizers",
    "are represented by circular and diamond - shaped vertices of appropriate color as explained by the key .",
    "here we analyse the lattice by counting the total number of qubits as a function of @xmath15 .",
    "we also count the number of stabilizers , and the number of gauge operators .",
    "we also discuss the qubit support of the stabilizers , and the gauge operators .",
    "the quantities evaluated in this note serve as good sanity checks for readers that are reproducing the gauge color code lattice .",
    "the gauge color code is a complicated system where qubits are placed on tetrahedra , and on subsets of faces , edges and vertices of the dual lattice we described in supplementary note 1 .",
    "a qubit is placed on each of the exterior vertices where three differently colored boundaries meet .",
    "we therefore have vertex qubits @xmath177              each vertex of the lattice supports two stabilizers .",
    "we find the number of vertices @xmath183 each stabilizer represented by a given vertex acts on every vertex , edge , face or tetrahedron qubit that contains the respective stabilizer vertex . to make this statement more rigorous , we can specify each object on the lattice that supports a qubit by a list of vertices , @xmath184 , that are contained by the respective object",
    ". a vertex qubit is specified by a single vertex , @xmath185 , an edge qubit is specified by a pair of vertices , @xmath186 , each triangular face that supports a qubit is specified by three vertices @xmath187 , and a tetrahedron is specified by its four vertices @xmath188 .    given that the different objects of the lattice that support qubits , known as simplices , can be uniformly denoted by a lists of vertices of varying length , we are free to group all vertex qubits , edge qubits , face qubits and tetrahedron qubits into the set of qubits , @xmath30 , using this simplicial description . written as simplices , vertex , edge , face and tetrahedron qubits only differ by the length of their list of vertices . using this notation",
    "we can conveniently write down stabilizer operators @xmath189 where we take the product of all qubits @xmath190 that contain vertex @xmath184 .",
    "we point out that we have used notation here that is inconsistent with the main text , as here we index stabilizers by vertices , @xmath184 , whereas in the main text we chose the index @xmath17 to represent cells that support stabilizers .",
    "this reflects the change from the primal to dual lattice notation .",
    "we finally find the number of face operators we use in the simulation in the main text , and explicitly describe the supports of the gauge operators on the dual lattice .",
    "gauge operators are represented on edges , and on exterior vertices of the dual lattice . instead of counting the number of gauge operators exactly , we count distinct supports of gauge operators .",
    "the number of supports are exactly the number of faces on the primal lattice . for each support , @xmath191 , we have two gauge operators , @xmath192 and @xmath193 . on the dual lattice ,",
    "gauge supports are uniquely represented by either an edge , @xmath194 , or a pair @xmath195 that contains a vertex , @xmath184 , and a color @xmath196 , as is defined in the main text .    to count the gauge supports ,",
    "we first find the number of edges contained on the lattice , @xmath197 .",
    "we find this number using the euler characteristic @xmath198 where @xmath199 for a ` ball - shaped ' triangulation , such as that which describes the gauge color code , and where @xmath200 , @xmath201 and @xmath202 are the number of vertices , faces and tetrahedra of the lattice , respectively .",
    "we already have the number of tetrahedra @xmath203 , and @xmath204 is already counted to find the number of stabilizers .",
    "we easily find the number of faces of the lattice @xmath201 using the fact that each interior face lies on the surface of two tetrahedra , and each tetrahedra has four faces . following this , up to the exterior faces , we can regard each tetrahedra as contributing half to the face count per face of each tetrahedra .",
    "we therefore obtain a contribution of @xmath205 faces for the tetrahedra of the lattice . to account for exterior faces",
    ", we must add an additional half - unit per exterior face of the lattice to count the total number of faces , giving the number of faces @xmath206 .",
    "explicitly , we have @xmath207 using @xmath201 and eqn .",
    "( [ eulerchar ] ) we find the number of edges @xmath208    each edge of the lattice represents one gauge support that acts on all edge , face , and tetrahedron qubits that contain the respective edge .",
    "we use once again the simplicial notation to denote gauge supports represented by edges , @xmath194 , such that @xmath209 where we take the product over all qubits @xmath190 that contain both vertices of edge @xmath210 .",
    "we point out that no vertex qubit on the lattice can contain the two vertices of an edge , and therefore vertex qubits are not found in gauge operator supports associated to edges .",
    "gauge supports are also represented by vertices @xmath184 on the exterior of the lattice .",
    "each exterior vertex represents either one , two or three gauge supports . for exterior vertices that represent multiple gauge operator supports ,",
    "we specify the supports uniquely with a vertex , @xmath184 , and a color @xmath211 .",
    "specifically , a gauge support of a given exterior vertex @xmath184 contains a _ subset _ of the vertex , edge or face qubits that contain @xmath184 . the subset of lattice objects @xmath212 are taken to be all of those that do not contain any vertices of one particular color , @xmath211 .",
    "external vertex gauge operators are written @xmath214 where we use a shorthand notation ` @xmath215 ' to denote qubits @xmath216 that contain vertex @xmath184 , but do not contain any vertices of color @xmath211 , i.e. where @xmath217 for all vertices @xmath218 .",
    "we point out that all tetrahedra contain one vertex of each color , and as such , no tetrahedra appear in any gauge supports represented by exterior vertices .    in some cases there",
    "are exterior vertices with multiple nonempty subsets @xmath215 for different choices of @xmath211 . in what follows",
    "we explicitly consider exterior vertices that contain one , two , and three gauge operator supports .",
    "we will see that exterior vertices in the middle of a boundary will contain only one gauge operator support , exterior vertices found where two different colored boundaries meet contain two distinct gauge operator supports , and vertices that lie where three different boundaries meet contain three different gauge operator supports .",
    "exterior vertices in the middle of a boundary , far away from any edge or vertex qubits , denote one gauge operator support .",
    "we explicitly consider the example of the gauge support associated to the blue vertex shown on the red boundary in supplementary figure  7 . the gauge operator support associated to this vertex act on the qubits labeled 1 , 2 , 3 and 4 .",
    "all qubits that contain the exterior vertex of interest contain a yellow , a green , and a blue vertex , but no red vertex .",
    "vertices that lie at a point where two differently colored boundaries meet represent two distinct gauge operator supports .",
    "we consider the green vertex in supplementary figure  7 that lies where the blue boundary and the red boundary meet .",
    "one of the supports acts on the qubits labeled 3 , 4 , 5 , 6 , 7 and 8 .",
    "common to all of these qubits is that none of their faces or edges contain a red vertex .",
    "the other support acts on qubits 7 , 8 , 9 , 10 , 11 and 12 .",
    "different from the first support we discussed that is associated to the green vertex , none of the faces or edges involved in this support contain a blue vertex .",
    "we finally consider the support of the gauge operators associated to the vertices that lie where three boundaries meet , such as at the large yellow vertex shown in supplementary figure  7 that contains the qubit indexed 14 .",
    "this vertex denotes three supports , two of which are shown in the diagram .",
    "one support acts on qubits 6 , 7 , 14 and 15 , the qubits that contain the yellow vertex of interest , but do not contain a red vertex .",
    "the other support acts on the qubits numbered 7 , 12 , 13 and 14 , the lattice objects that contain the large yellow vertex , but do not contain any blue vertices .",
    "the third support associated to the large yellow vertex acts on the green face qubit that contains the large yellow vertex which can not be seen in the diagram , together with qubits 13 , 14 and 15 .",
    "we can now count the number of gauge supports we must measure to realize fault - tolerant error correction using the gauge color code .",
    "we count the number of exterior vertices @xmath219 with the expression @xmath220 then , using that the @xmath221 vertices that lie where two boundaries meet represent two gauge operator supports , and four vertices that lie where three boundaries meet represent three gauge operator supports , we find the number of gauge operator supports @xmath222 , giving the number of gauge operator supports @xmath223 twice this quantity gives the number of face operators we use to perform fault - tolerant error correction with the gauge color code to identify both pauli - x and pauli - z type errors .      in the main text",
    "we identify the threshold error rate as a function of the number of rounds of error correction that are performed , @xmath58 , to show that the threshold error rate is robust in the limit @xmath92 .",
    "it is important to look at the single - shot error - correction scheme after repeated applications because , when one considers noisy measurements , the error - correction protocol will leave some residual noise on the code . in general ,",
    "this residual noise is not easily characterized .",
    "in fact , the noise introduced to the system is a complex function of the physical error rate , the measurement error rate , and the choice of error - correction protocol . given that the nature of the residual noise is not well understood , it is not clear that the error - correction protocol will be able to successfully deal with the residual noise after many cycles of error correction .    in supplementary figure  8",
    "we give an example of a mechanism that leads to the development of a correlated error .",
    "we show a physical error in supplementary figure  8(a ) .",
    "the error is represented by a string . given perfect measurements , we expect to observe two stabilizer defects at the left and right ends of the error string .    for this example",
    ", some measurement errors occur in the vicinity of the right stabilizer defect when we attempted to learn the positions of stabilizer defects .",
    "the measurement errors , where face operators return incorrect measurement outcomes , are represented by multi - colored strings in supplementary figure  8(b ) .",
    "gauge defects lie at the points where the strings of measurement errors terminate . given",
    "these measurement errors occur , we can not be sure of the true location of the right stabilizer defect . instead , we can make use of the positions of the three gauge defects , and knowledge of the noise model , to attempt to determine the location of the stabilizer defect .",
    "our ability to predict the positions of stabilizer defects depends on our choice of syndrome estimation algorithm . in supplementary",
    "figure  8(c ) we show where the syndrome estimation algorithm mistakenly predicts measurement errors .",
    "the measurement errors that have been predicted are represented by strings that terminate at the gauge defects , and branch at the estimated stabilizer defect .",
    "the incorrect estimation made by the algorithm leads us to believe that the stabilizer defect is not in its true location , but is displaced to some estimated location .",
    "next , we apply a correction operator to attempt to repair the initial physical error drawn in supplementary figure  8(a ) .",
    "however , using the estimated position of the right stabilizer defect , we apply a correction operator that connects the left stabilizer defect to the estimated right stabilizer defect , as shown by a blue string in supplementary figure  8(c ) , thus introducing additional errors to the code .",
    "the initial error , and the applied correction operator is shown in grey in supplementary figure  8(d ) .    due to the topological nature of the string errors in the gauge color code , the net effect of the initial error and the correction operator equates to the discrepancy between the true position of the right stabilizer defect , and the position of the estimated stabilizer defect .",
    "the effective error is shown by the blue error string in supplementary figure  8(d ) .",
    "this is easily checked as we can continuously deform the grey string onto the blue string .",
    "in other words , in the gauge color code the grey error string is equivalent to the blue error string up to multiplication by gauge operators .",
    "in general it is not clear how able a syndrome estimation algorithm is for correctly predicting the positions of stabilizer defects .",
    "a bad syndrome estimation algorithm might displace stabilizer defects over long distances compared to their true positions , in which case large correlated errors that we can not correct may develop . moreover , it is not clear that the character of the residual noise remains constant over many error - correction cycles .",
    "indeed , one should be concerned that an error correction protocol might cause correlations to develop over repeated use of the error - correction procedure while information is stored .",
    "it is therefore important to study a single - shot error - correction protocol over many cycles of error correction to interrogate its performance , and to check that the noise incident to a code achieves a steady state in the long - time limit . in doing so",
    ", we are able to establish that a code has a finite threshold after an arbitrarily long time ."
  ],
  "abstract_text": [
    "<S> the constituent parts of a quantum computer are inherently vulnerable to errors . to this end </S>",
    "<S> we have developed quantum error - correcting codes to protect quantum information from noise . </S>",
    "<S> however , discovering codes that are capable of a universal set of computational operations with the minimal cost in quantum resources remains an important and ongoing challenge . </S>",
    "<S> one proposal of significant recent interest is the gauge color code . </S>",
    "<S> notably , this code may offer a reduced resource cost over other well - studied fault - tolerant architectures using a new method , known as gauge fixing , for performing the non - clifford logical operations that are essential for universal quantum computation . here </S>",
    "<S> we examine the gauge color code when it is subject to noise . </S>",
    "<S> specifically we make use of single - shot error correction to develop a simple decoding algorithm for the gauge color code , and we numerically analyse its performance . remarkably , we find threshold error rates comparable to those of other leading proposals . </S>",
    "<S> our results thus provide encouraging preliminary data of a comparative study between the gauge color code and other promising computational architectures . </S>"
  ]
}