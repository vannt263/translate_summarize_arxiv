{
  "article_text": [
    "designing algorithmic tools with fast and limited size memory ( e.g caches ) but having capability of very fast processing of a massive high quality data is a challenging field of research @xcite .",
    "the problem becomes much more difficult if the input data is given in a read - only array , and very small amount of work - space is available in the system .",
    "such a situation arises in the concurrent programming environment where many processes access the same data , and hence modifying the data by a process during the execution is not permissible @xcite . in this paper",
    ", we show that the general _ prune - and - search _ technique can be implemented where the objects are given in read - only array . as examples we consider convex - hull in 2d , and linear programming in 2d and 3d .    given a set @xmath8 of points in 2d",
    ", the problem of designing sub - quadratic time algorithm for computing convex hull for @xmath2 with sub - linear extra work - space is an important problem and is being studied for a long time .",
    "bronnimann et al .",
    "@xcite showed that graham s scan algorithm for computing convex hull of a planar point set of size @xmath9 can be made in - place maintaining @xmath10 time complexity . here ,",
    "the extra workspace required is @xmath11 , and the output is available in the same input array . in the same paper they also showed that ( i ) the convex hull of a point set in 2d can be computed in an in - place manner in @xmath12 time and with @xmath11 extra workspace where @xmath13 is the number of hull vertices , and ( ii ) the linear programming in 2d with @xmath9 constraints can be solved in @xmath14 time .",
    "very recently , vahrenhold @xcite showed that the prune - and - search algorithm by kirkpatrick and seidel @xcite for computing the convex hull of a planar point set can also be made in - place maintaining the @xmath12 time complexity and using only @xmath11 work - space .",
    "all these algorithms permute the input array after the execution .",
    "if a planar point set @xmath2 is given in a read - only array , then the well - known jarvis march algorithm computes the convex hull in @xmath15 time with @xmath11 extra space .",
    "the problem of designing a sub - quadratic algorithm for computing convex hull in a read - only environment with sub - linear work - space is an open problem for a long time .",
    "chan and chen @xcite proposed an algorithm that can compute the convex hull in @xmath16 time using @xmath17 space where @xmath18 is a chosen integer . in the same paper , they proposed an @xmath14 time randomized algorithm for the linear programming problem in fixed dimension using @xmath5 extra space in a read - only environment .",
    "they also considered the problem of computing the convex hull where the points are sorted by their @xmath3-coordinates .",
    "the proposed algorithm is a randomized one and runs in @xmath19 expected time and @xmath20 extra space for any fixed @xmath21 .",
    "the algorithm can be made deterministic if the running time is increased to @xmath22 .",
    "the convex hull of a simple polygon with @xmath9 vertices can be computed in a read - only setup in @xmath23 time with @xmath24 extra workspace @xcite .    in this paper , we first address the open problem related to the convex hull problem in 2d .",
    "we show that if the points in @xmath2 are given in a read - only array then the convex hull can be computed in @xmath0 time and @xmath1 extra space .",
    "next , we consider a restricted version of the convex hull problem , where the input points are given in sorted order of their @xmath3-coordinates . here",
    ", we can apply _ prune - and - search _ technique to compute the convex hull of @xmath2 in @xmath25 time and @xmath5 space , where @xmath6 is a constant satisfying @xmath26 .",
    "we also show that similar technique works for solving the linear programming problem in 2d and 3d in the read - only setup with the same time complexity . in this context , it needs to be mentioned that a similar technique is adopted to solve the minimum enclosing circle problem for a set of points in 2d , where the input points are given in a read - only array @xcite .",
    "given a set @xmath2 of @xmath9 points in 2d in a read - only array , the objective is to report the vertices of the convex hull of @xmath2 .",
    "we describe the method of reporting the upper - hull ; the lower - hull can be computed in a similar manner .",
    "we use three arrays , namely @xmath27 , @xmath28 and @xmath29 , each of size @xmath30 as the work - space . for the notational simplicity",
    ", we will use @xmath31 and @xmath32 to denote the set of points whose @xmath3-coordinate lies between @xmath33 to @xmath34 , and the set of points whose @xmath3-coordinate is less than @xmath34 respectively , where @xmath35 denotes the @xmath36-th smallest element among the @xmath3-coordinates of the points in @xmath2 .",
    "the upper hull of @xmath31 and @xmath32 are denoted by @xmath37 and @xmath38 respectively .",
    "our algorithm executes in two passes .",
    "each pass consists of @xmath39 stages .",
    "in the @xmath40-th stage of the first pass , we pick up the points in @xmath31 in the array @xmath27 .",
    "we assume that @xmath41 stages are complete ; the vertices of @xmath42 in the convex hull @xmath43 are stored in the array @xmath28 .",
    "the @xmath44-th element of the array @xmath29 ( denoted by @xmath45 $ ] ) contains the first and last hull - vertices @xmath46 among the points in @xmath47 in the convex hull @xmath43 , @xmath48 . if no such hull - vertex exists then @xmath45 $ ] contains @xmath49 .",
    "we execute the following steps in the @xmath40-th stage .",
    "* compute @xmath33 and @xmath34 among the points in the array @xmath2 , and identify all the points in @xmath31 to store them in the array @xmath27 . *",
    "compute the upper hull @xmath37 of the points in @xmath27 using the in - place convex hull algorithm of @xcite . *",
    "merge @xmath37 with @xmath43 as follows : ( i ) draw the common tangent @xmath50 $ ] of @xmath42 ( stored in @xmath28 ) and @xmath37 , where @xmath51 and @xmath52 . if @xmath53 is not the first vertex of @xmath42 , then update @xmath54 $ ] by @xmath55 and put @xmath56 $ ] in @xmath57 $ ] ( @xmath58 is obtained from @xmath27 ) . otherwise ( i.e. , if @xmath53 is the first vertex of @xmath42 ) then traverse the array @xmath29 to identify a hull - vertex @xmath59 of a preceding block @xmath44 ( @xmath60 ) that is connected with @xmath61 .",
    "note that , if @xmath62 , then all the array elements @xmath63 $ ] , @xmath64 will contain @xmath49 .",
    "we recompute @xmath65 and draw the common tangent of @xmath37 and @xmath65 . the same is followed until we get a tangent of @xmath37 and @xmath66 ( @xmath67 ) that does not touch the vertex @xmath68 .",
    "we update @xmath69 $ ] and set @xmath57 $ ] with appropriate vertex pair .    in the second pass , we compute @xmath37 for all the blocks whose @xmath57 \\neq ( -1,-1)$ ] , and report only the portion from @xmath70 to @xmath58 .    given a set @xmath2 of @xmath9 points in 2d in a read - only array , the convex - hull of @xmath2 can be correctly computed in @xmath71 time using @xmath72 extra - space , where @xmath73 .",
    "the correctness follows from the fact that in the @xmath40-th stage , @xmath37 is appropriately merged with @xmath43 .",
    "we now analyze the time complexity of the first pass . in each stage @xmath40 , @xmath33 to @xmath34 can be computed in @xmath25 time using @xmath74 extra space , where @xmath75 ( see the algorithm of @xcite in appendix 1 ) .",
    "next , the convex hull @xmath37 in the array @xmath27 is computed in @xmath76 time @xcite . while merging @xmath37 with @xmath43 , we may need to recompute @xmath65 for different @xmath60 .",
    "however , the recomputation of the convex hull of a block implies that there exists a block whose no vertex participate in the convex hull of @xmath2 .",
    "thus the amortized complexity of pass 1 is @xmath77 .",
    "the second pass needs the same amount of time .",
    "the space complexity follows from the size of @xmath27 , @xmath28 and @xmath29 , and the fact that @xmath78 .",
    "given a set @xmath2 of @xmath9 points in 2d sorted with respect to their @xmath3-coordinates in a read - only array , the objective is to report the edges of the convex hull of the points in @xmath2 .",
    "we will show how kirkpatrick and seidel s  @xcite deterministic prune - and - search algorithm for computing convex hull can be implemented in this framework .",
    "the algorithm in @xcite computes upper - hull and lower - hull separately and report them .",
    "the basic steps of computing upper - hull for a set of points @xmath2 is given in algorithm  [ kuh ] .",
    "lower - hull can be computed in a similar way .",
    "algorithm  [ kuh ] follows divide - and - conquer paradigm .",
    "it uses a procedure  to compute the bridge between two disjoint subsets of @xmath2 using the prune - and - search technique .",
    "the details of this procedure is described in algorithm  [ cb ] .    * ( uses divide - and - conquer technique ) * + * step 1 : * find the point @xmath79 having median @xmath3-coordinate    * step 2 : * partition @xmath2 into two subset @xmath80 and @xmath81 where @xmath80 contains all the points in @xmath2 whose @xmath3-coordinate is less than or equal to @xmath82 and @xmath83    * step 3 : * @xmath84=(@xmath85 ) ; ( * this procedure computes the bridge between @xmath80 and @xmath81 ; @xmath86 , @xmath87 * ) + * step 4 : * report @xmath84    * step 5 : * compute @xmath88 , where @xmath89 , and + @xmath90 , where @xmath91    * step 6 : * ( @xmath80 ) ( @xmath81 )    [ kuh ]    the straight - forward implementation of the algorithm  in a read - only memory requires @xmath14 space for the procedure as it needs to remember which points were pruned in the previous iterations . in addition , the algorithm ( @xmath2 ) reports the hull - edges in an arbitrary fashion ( not in order along the boundary of the convex hull ) and takes @xmath5 space for the recursions .",
    "so , the main hurdle in read - only model is to ( i ) report the hull edges in order , and ( ii ) implement the procedure  using only @xmath5 extra - space . in the next subsections ,",
    "we describe how to resolve these issues .",
    "with this we have following main result :    [ th ] given a set of @xmath9 sorted points @xmath2 of 2d in a read - only array , the convex - hull of @xmath2 can be computed in @xmath25 time using @xmath5 extra - space , where @xmath92 .    * ( uses prune - and - search technique ) * + * step 1 : * +    * step 2 : * + find the bridge in brute - force manner and return the bridge .",
    "[ cb ]      now , we will show how to report the hull vertices in clock - wise order using no more than @xmath5 extra - space .",
    "consider the recursion tree @xmath93 of the algorithm .",
    "its each node represents the reporting of a hull - edge . in the algorithm , as the reporting is done according to pre - order traversal of the tree @xmath93 , the hull edges are not reported in clock - wise order . in order to report them in clock - wise order , we need to traverse the recursion tree in in - order manner , i.e. step 3 and step 4 of the algorithm [ kuh ] should be in between step 5 and step 6 .",
    "but , if we do this , then we can not evoke ( @xmath80 ) on the updated set @xmath80 .",
    "to resolve this problem , we will compute the bridge in step 3 itself but will not report it then .",
    "we push it in the stack in step 3 and pop it from stack in between step 5 and step 6 .",
    "the size of this stack depends on the depth of the recursion tree which is @xmath94 , where @xmath13 is the number of hull - edges .",
    "the details of this change is given as ( @xmath95 ) in algorithm  [ rouh ] .",
    "thus we have the following result :    let @xmath96 ; the point @xmath97",
    "\\in p[start , \\ldots , end ] $ ] have the median @xmath3-coordinate ( * now @xmath98 $ ] and @xmath99 $ ] * ) + * step 3 : * @xmath100=(@xmath101 ) ; ( * this procedure returns a pair of indices of points in array @xmath2 that defines the bridge between @xmath80 & @xmath81 * ) , + push the edge @xmath102,p[j])$ ] in stack ( * modified @xmath103 $ ] and @xmath104 $ ] * ) + * step 5 : * ( @xmath105 $ ] ) report the edge @xmath102,p[j])$ ] popping the top element from stack ( @xmath106 $ ] ) [ rouh ]    given a set of @xmath9 sorted points @xmath2 in a read - only array , the reporting of the hull edges can be done in clock - wise order using only @xmath5 extra - space ( assuming that the procedure  takes no more than @xmath5 space ) .      here",
    "the input set of points @xmath2 of this procedure is first partitioned into two parts @xmath80 and @xmath81 by choosing the point @xmath97 $ ] having median @xmath3-coordinate .",
    "since the array is sorted with respect to the @xmath3-coordinates , this needs @xmath11 time .",
    "now an iterative procedure ( while - loop ) is executed to compute the bridge of @xmath80 and @xmath81 . in each iteration of the while - loop of the procedure , @xmath107th of the points from the set @xmath108",
    "are pruned .",
    "the points which are pruned in @xmath40th iteration are not considered in any @xmath44th iteration , where @xmath109 . after an iteration of the while - loop , either the bridge is returned or the iteration continues until @xmath110 or @xmath111 .",
    "so , the number of iterations of the while loop is @xmath5 , where @xmath9 is the total number of points in @xmath2 .",
    "while executing the @xmath40th iteration , we want to remember the points which were pruned in the previous @xmath112 iterations , @xmath113 .",
    "if we use mark - bits to remember which points are valid / invalid , then we need @xmath14 bits .",
    "but , we have only @xmath5 work - space to be used .",
    "so , we take an array @xmath114 of size @xmath5 and another bit - array @xmath28 of size @xmath5 . at each @xmath40th iteration , ignoring all the pruned points , we pair the valid points and consider the slopes of all the lines defined by the paired points .",
    "we compute the median slope value @xmath115 of these lines and store it at @xmath116 $ ] . if the supporting lines are at points @xmath53 and @xmath117 , we set @xmath118 $ ] as 1 or 0 depending on whether the slope @xmath119 is greater than or less than @xmath115 ( since @xmath120 implies that we already get the bridge ) .",
    "thus , @xmath118 $ ] signifies whether @xmath116 $ ] is greater than or less than the slope @xmath121 of the desired bridge .",
    "now , we will describe a pairing scheme which will satisfy the following invariants :    1 .",
    "if a point @xmath122 is pruned at some iteration @xmath40 , then it will not participate to form a pair for any @xmath44-th iteration , where @xmath123 .",
    "if @xmath124 are paired at the @xmath40-th iteration of the while - loop , and none of the points @xmath125 is pruned at the end of this iteration and we need to go for @xmath126-th iteration , then @xmath124 will again form a valid pair at @xmath126-th iteration .",
    "if @xmath124 is a valid pair at @xmath40-th iteration and @xmath127 ( @xmath128 ) are paired at @xmath126-th iteration of the while - loop , then there exist some @xmath129 such that @xmath130 were paired at @xmath40-th iteration , and @xmath131 and @xmath129 were pruned at the end of @xmath40-th iteration .",
    "[ inv1 ]    the iteration starts with the points @xmath132 , p[start+1 ] , \\ldots,$ ] @xmath133\\}$ ] . in the first iteration of the while - loop , we consider the consecutive points , i.e , @xmath134,$ ] @xmath135)$ ] , @xmath136 , p[start+3])$ ] , @xmath137 as valid pairs",
    "assume that first @xmath112 iterations of the while - loop are over , and we are at the beginning of the @xmath40-th iteration ; @xmath138 $ ] contains median slope of @xmath139-th iteration and @xmath140 $ ] contains 0 or 1 depending on @xmath138 > \\alpha^*$ ] or @xmath138 < \\alpha^*$ ] for all @xmath141 .",
    "now , we want to detect all the valid points and pair them up maintaining the invariant  [ inv1 ] .",
    "we use another array @xmath142 of size @xmath5 whose all elements are set to -1 at the beginning of this iteration .",
    "we consider the point - pairs @xmath143,p[start+2\\nu+1])$ ] , @xmath144 in order .",
    "for each pair , we compute the slope @xmath145,p[start+2\\nu+1]})$ ] of the corresponding line , and perform the level 1 test using @xmath146 $ ] and @xmath147 $ ] to see whether both of them remain _ valid _ at iteration 1 . if the test succeeds , we perform level 2 test for @xmath148 by using @xmath149 $ ] and @xmath150 $ ] .",
    "we proceed similarly until ( i ) we reach up to @xmath112-th level and both the points remain _ valid _ at all the levels , or ( ii ) one of these points becomes _ invalid _ at some level , say @xmath44 ( @xmath151 ) . in case ( i ) , the point pair @xmath143,p[start+2\\nu+1])$ ] will form a valid pair and participates in computing the median value @xmath152 . in case ( ii ) , suppose @xmath153 $ ] remains _ valid _ and @xmath154 $ ] becomes _ invalid_. here two situations need to be considered depending on the value of @xmath155 $ ] . if @xmath155=-1 $ ] ( no point is stored in @xmath155 $ ] ) , we store @xmath156 or @xmath157 in @xmath155 $ ] depending on whether @xmath153 $ ] or @xmath154 $ ] remains _ valid _ at level @xmath44 .",
    "if @xmath155=\\beta ( \\neq -1)$ ] ( index of a _ valid _ point ) , we form a pair @xmath143,p[\\beta])$ ] and proceed to check starting from @xmath158-th level ( i.e. , using @xmath159 $ ] and @xmath160 $ ] ) onwards until it reaches the @xmath40-th level or one of them is marked _ invalid _ in some level between @xmath44 and @xmath40 .",
    "both the situations are handled in a manner similar to cases ( i ) and ( ii ) as stated above .",
    "thus , each _",
    "valid _ point in the @xmath40-th iteration has to qualify as a _",
    "valid _ point in the tests of all the @xmath112 levels . for any other point",
    "the number of tests is at most @xmath161 .",
    "this leads to the following result :    [ lx ] in the @xmath40-th iteration , the amortized time complexity of finding all valid pairs is @xmath162 .",
    "the main task in the @xmath40-th iteration is to find the median of the slope of lines corresponding to valid pair of points .",
    "we essentially use the median finding algorithm of munro and raman @xcite for this purpose ( see appendix 1 ) . notice that , in order to get each slope , we need to get a _",
    "valid _ pair of points , which takes @xmath163 time ( see lemma [ lx ] ) .",
    "the time required for finding the lowest slope is @xmath162 .",
    "similarly , computing the second lowest needs another @xmath162 time .",
    "proceeding similarly , the time complexity of the procedure @xmath164 of @xcite is @xmath165 ( see the appendix ) .",
    "similarly , @xmath166 takes @xmath167 time , and so on .",
    "finally , @xmath168 takes @xmath169 time . choosing @xmath170 , we need @xmath5 space in total .",
    "thus , we have the following result :    [ ly ] the time complexity of the @xmath40-th iteration of the while - loop of the procedure  is @xmath169 , where @xmath171 .",
    "the extra space required is @xmath5 .    at the end of @xmath5 iterations",
    ", we could discard all the points except at most @xmath172 points , where @xmath173 is the number of cells in the array @xmath142 that contain valid indices of @xmath2 ( @xmath174 )",
    ". this can be at most @xmath5 in number .",
    "we can further prune the points in the @xmath142 array using the in - place algorithm for  described in @xcite .",
    "thus , we have the following result :    [ lv ] the read - only version of the procedure  is correct and the time complexity is @xmath175 , where where @xmath171 .",
    "apart from the input array , it requires @xmath5 extra space .",
    "the correctness of this read - only version of the procedure  follows from the fact that the invariant  [ inv1 ] is correctly maintained .    by lemma [ ly ] ,",
    "the time complexity of the @xmath40-th iteration is @xmath169 , where @xmath176 .",
    "thus , the total time complexity of all the @xmath5 iterations is @xmath175 . the time required by the in - place algorithm for considering all the entries in the array @xmath142 is @xmath5 .",
    "the space complexity obviously follows since the same set of arrays @xmath114 , @xmath28 , @xmath142 and the stack for finding the median can be used for all the iterations , and each one is of size at most @xmath5 .",
    "the correctness of the algorithm  follows from the correctness of kirkpatrick and siedel s algorithm  @xcite , as we are following the basic structure of this .",
    "the procedure  is evoked @xmath13 times , where @xmath13 is the number of hull - edges .",
    "consider the recursion tree of the algorithm .",
    "note that the depth of this tree is @xmath5 ( more specifically , @xmath177 ) , and total time complexity of a single level is @xmath175 , where @xmath178 ( see lemma [ lv ] ) . as there are at most @xmath179 levels , so the total time complexity of the algorithm  is @xmath180 . substituting @xmath181 and then @xmath182 , we have time complexity @xmath25 , where @xmath6 satisfies @xmath183 .    for the recursion of",
    "we need @xmath179 space and for each node of the recursion tree we need another @xmath5 space for the procedure .",
    "however , we can re - use the same space for each of the nodes for computing the bridge .",
    "hence the total space complexity of the algorithm  is @xmath5 .",
    "in this section , we consider the problem of solving 2d linear programming in a read - only setup , i.e , the constraints are given in a memory where swapping of elements or modifying any entry is not permissible .",
    "megiddo proposed a linear time prune - and - search algorithm for this problem which takes @xmath14 space  @xcite .",
    "we will show that megiddo s algorithm for 2d linear programming can be implemented when the constraints are stored in a read - only memory using @xmath5 extra - space and the running time would be @xmath25 , where @xmath92 .",
    "the 2d linear programming problem is as follows :    subject to : = xxxxxxxxxxxxxxxxx= @xmath184 + subject to : @xmath185 , @xmath186 .    for ease of designing a linear time algorithm ,",
    "megiddo transformed it to an equivalent form , stated below :    subject to : = xxxxxxxxxxxxxxxxx= @xmath187 + subject to : @xmath188 , @xmath189 , + @xmath190 , @xmath191 , + @xmath192 .    *",
    "( uses prune - and - search technique ) * + * step 1 : * convert the form into the following : @xmath187 , subject to + ( i ) @xmath193 , @xmath189 , ( ii ) @xmath190 , @xmath191 , where @xmath192 . + * step 2 : * set @xmath194 and @xmath195 * ( the case when @xmath196 ) * + the problem can be solved directly .",
    "[ mdlp ]    megiddo s 2d linear programming algorithm uses prune - and - search technique .",
    "it maintains an interval @xmath197 $ ] of feasible values of @xmath3 ( i.e. , @xmath198 ) . at the beginning of the algorithm , @xmath194 and @xmath195",
    "after each iteration of the algorithm , either it finds out that at some @xmath199 ( @xmath200 ) the optimal solution exist ( so the algorithm stops ) or the interval @xmath197 $ ] is redefined ( the new interval is either @xmath201 $ ] or @xmath202 $ ] ) and at least @xmath203 constraints are pruned for the next iteration",
    ". the detail steps of the algorithm is given in the algorithm ( @xmath204 ) .",
    "megiddo s 2d linear programming algorithm needs @xmath14 time and @xmath14 space . in the next subsection",
    "we will show how to tailor this algorithm to work in the read - only setup such that it does not take more than @xmath5 space and running time is @xmath25 , where @xmath183 .",
    "we will give step by step description of implementing  in a read - only setup .",
    "the straight - forward conversion of one form into another mentioned in step 1 would take @xmath14 extra - space . note that remembering only the objective function @xmath205 , will enable one to reformulate the newer version of the constraints on - the - fly substituting @xmath206 in terms of @xmath207 and @xmath208 ( replacing @xmath207 by @xmath3 ) in each constraint .",
    "so , we need not to worry about storing this new form .",
    "it is also to be noted that 2d linear programming can be implemented in an in - place model in @xmath14 time using @xmath11 extra - space  @xcite .",
    "so , we can implement the pruning activities in step 2 in read - only environment in a manner similar to  as described in section 2.2 using @xmath5 space and @xmath25 time , where @xmath6 satisfies @xmath183 .",
    "step 3 can obviously be implemented when the constraints are given in a read - only memory .",
    "hence , we have the following result :    2d linear programming can be implemented in a read - only model in @xmath25 time using @xmath5 extra - space , where @xmath183 .",
    "in the same paper  @xcite megiddo proposed a linear time algorithm for 3d linear programming .",
    "the problem is stated as follows :           algorithm also follows prune - and - search paradigm .",
    "it pairs - up constraints @xmath217 where @xmath218 are from same set @xmath219 ; so , there are at most @xmath220 pairs .",
    "let @xmath221 ( resp .",
    "@xmath222 ) corresponds to @xmath223 ( resp .",
    "@xmath223 ) .",
    "if @xmath224 , then we can easily ignore one of the constraints .",
    "otherwise ( i.e. , if @xmath225 ) , then each pair signifies a line @xmath226 : @xmath227 which divides the plane into two halves .",
    "let @xmath228 be the set of lines obtained in this way .",
    "we compute the median @xmath229 of the gradients of the members in @xmath228 .",
    "next , we pair - up the members in @xmath228 such that one of them have gradient less than @xmath229 and the other one have gradient greater than @xmath229 .",
    "let @xmath230 be the set of these paired lines . each of these pairs will intersect .",
    "we compute the intersection point @xmath53 having median @xmath231 among the @xmath208-coordinates of these intersection points .",
    "next , we execute the procedure  as stated below with respect to the line @xmath232 ( having gradient @xmath229 and passing through @xmath53 ) .",
    "this determines in which side of @xmath233 the optimum solution lies .",
    "next , we identify the pairs in @xmath230 which intersect on the other side of the optimum solution . among these pairs , we compute the intersection point @xmath117 having median @xmath3-coordinates of their intersections , and execute  with the line @xmath234 having gradient @xmath235 and passing through @xmath117 . @xmath233 and @xmath234 determines a quadrant @xmath236 containing the optimum solution .",
    "now consider the paired lines in @xmath230 that intersect in the quadrant @xmath237 , diagonally opposite to @xmath236 .",
    "let @xmath238 be a paired line of @xmath230 that intersect in @xmath237 .",
    "for at least one of the lines @xmath226 and @xmath239 , it is possible to correctly identify the side containing the optimum solution without executing  ( see @xcite ) .",
    "thus , for each of such lines we can prune one constraint . as a result , after each iteration it can prune at - least @xmath240 constraints for next iteration or report optimum .",
    "the procedure  takes a straight line @xmath241 in the @xmath3-@xmath208 plane and tests whether the solution on the line @xmath241 ( i ) does not exist , or ( ii ) unbounded , or ( iii ) unique optimum solution exists using a 2d linear programming . in case ( ii )",
    ", the solution of the given 3d linear programming problem is unbounded . in case ( i ) and",
    "( iii ) , we need to decide in which side of @xmath241 the optimum solution of the given linear programming problem lies by executing two other 2d linear programming . both of them can be executed if the constraints are given in read - only memory .",
    "the detail description of the algorithm  is given in appendix 2 .",
    "as  is a _ prune - and - search _ algorithm , one can easily show that this can be implemented in a read - only setup .",
    "thus , we have the following result :                                * munro and raman s median finding algorithm : * given a set of @xmath9 real numbers in a read - only array @xmath2 , the algorithm in @xcite for finding their median is designed by using a set of procedures @xmath243 , where procedure @xmath244 finds the median by evoking the procedure @xmath245 for @xmath246 . the procedures @xmath247",
    "are stated below .",
    "* procedure @xmath164 : * in the first iteration , after checking all the elements in @xmath2 , it finds the largest element @xmath248 in linear time . in the second iteration",
    "it finds the second largest @xmath249 by checking only the elements which are less than @xmath248 . proceeding in this way ,",
    "in the @xmath44-th iteration it finds the @xmath44-th largest element @xmath250 considering all the elements in @xmath2 that are less than @xmath251 . in order to get the median we need to proceed up to @xmath252 .",
    "thus , this simple median finding algorithm takes @xmath253 time and @xmath11 extra - space .",
    "* procedure @xmath166 : * it divides the array @xmath2 into blocks of size @xmath254 and in each block it finds the median using procedure @xmath164 . after computing the median @xmath255 of a block , it counts the number of elements in @xmath2 that are smaller than @xmath255 , denoted by @xmath256 , by checking all the elements in the array @xmath2 .",
    "it maintains two best block medians @xmath257 and @xmath258 , where @xmath259 , and @xmath260 .",
    "thus , this iteration needs @xmath261 time .    after this iteration , all the elements @xmath262 $ ] satisfying @xmath262 < m_1 $ ] or @xmath262 > m_2 $ ] are marked as _",
    "invalid_. this does not need any mark bit ; only one needs to remember @xmath257 and @xmath258 . in the next iteration",
    "we again consider same set of blocks , and compute the median ignoring the _ invalid _ elements .",
    "since , in each iteration @xmath107 fraction of the existing _ valid _ elements are marked _ invalid _ , we need at most @xmath5 iterations to find the median @xmath229",
    ". thus the time complexity of this procedure is @xmath263 .",
    "* procedure @xmath264 : * it divides the whole array into @xmath265 blocks each of size @xmath266 , and computes the block median using the procedure @xmath267 .",
    "thus , the overall time complexity of this procedure for computing the median is @xmath268 .    proceeding in this way , the time complexity of the procedure",
    "@xmath168 will be @xmath269 . as it needs",
    "a stack of depth @xmath36 for the recursive evoking of @xmath270 , @xmath271 , @xmath137 , @xmath272 , the space complexity of this algorithm is @xmath273 .",
    "setting @xmath274 , gives the running time as @xmath275 .",
    "if we choose @xmath276 , then @xmath6 will be @xmath277 , and this will give the running time @xmath278 , which is of @xmath279 .",
    "so , the general result is as follows :      ( * uses prune - and - search technique * ) + * step 1 : * convert the form into following : @xmath211 , subject to ( i ) @xmath282 , @xmath189 , ( ii ) @xmath283 , @xmath284 , ( iii ) @xmath285 , @xmath215 , where @xmath216 . +",
    "* step 2 : * + * ( the case when @xmath286 ) * + the problem can be solved directly by brute - force manner ."
  ],
  "abstract_text": [
    "<S> _ prune - and - search _ is an important paradigm for solving many important geometric problems . we show that the general _ prune - and - search _ technique can be implemented where the objects are given in read - only memory . as examples we consider convex - hull in 2d , and linear programming in 2d and 3d . for the convex - hull problem , </S>",
    "<S> designing sub - quadratic algorithm in a read - only setup with sub - linear space is an open problem for a long time . </S>",
    "<S> we first propose a simple algorithm for this problem that runs in @xmath0 time and @xmath1 space . </S>",
    "<S> next , we consider a restricted version of the problem where the points in @xmath2 are given in sorted order with respect to their @xmath3-coordinates in a read - only array . for the linear programming problems , </S>",
    "<S> the constraints are given in the read - only array . </S>",
    "<S> the last three algorithms use _ prune - and - search _ , and their time and extra work - space complexities are @xmath4 and @xmath5 respectively , where @xmath6 is a small constant satisfying @xmath7 . </S>"
  ]
}