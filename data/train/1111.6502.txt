{
  "article_text": [
    "the basic offline problem of energy - efficient packet transmission scheduling  @xcite is to assign code rates ( consequently transmission durations ) to a set of packets whose arrival times are known beforehand , so that they are all transmitted within a given time window with minimum total energy .",
    "the solution needs to strike a tradeoff between energy and delay based on the observation that energy per bit with many ideal and suboptimal coding schemes is convex and monotone increasing with rate .",
    "recently , the problem has been reformulated with a model where energy gets  harvested \" or replenished at certain known instants  @xcite .",
    "while in the former formulations transmission rate needs to be adapted to the arrival rate of information here it is adapted to the generation rate of energy . considering both of theses",
    "effects introduces a richness to the problem on top of the initial model .",
    "the point - to - point problem in  @xcite was recast for finite energy storage  @xcite and for a wireless fading channel  @xcite .",
    "the formulation has been extended to an awgn bc in  @xcite , considering a static pool of data to be sent at the beginning of the schedule .",
    "the same bc problem was also studied under a limited battery constraint  @xcite .",
    "the problem in  @xcite and @xcite is reformulated in  @xcite relaxing the assumption that data is ready at the beginning of the schedule .",
    "this paper , extending the work in  @xcite , considers the broadcast problem where , given an average transmit power constraint , rates are picked from an achievable rate region which obeys certain structural properties satisfied by the awgn bc .",
    "the sender ( transmitter ) gets replenished with arbitrary amounts of energy as well as data packets of arbitrary length destined to each user at arbitrary points in time .",
    "the choices of power level and the rates to individual receivers across time is called a _ schedule_. an optimal scheduling policy is defined to be one that transmits all the bits that have arrived within a certain time window , in the minimum possible amount of time @xmath0 .",
    "the policy is allowed to use as many energy harvests as it needs , provided it respects causality ( no energy is used before it is harvested . ) the problem considered in this paper is an _ offline _ problem , where data arrival and energy harvest instants and amounts are assumed to be known in advance . although this kind of prior information of data and energy arrivals may not be a widely applicable assumption to real - world problems , results obtained from this work help us understand the nature of an optimal solution and boundaries on the best performance .",
    "online formulations have also appeared in the literature .",
    "notably ,  @xcite develop online scheduling policies for multihop networks on finite - horizon and infinite horizon problem formulations , respectively .    to minimize the overall transmission duration , rates to the individual users should be chosen in a way such that transmission is fast and energy efficiency is satisfied . however , as we choose higher rates , we loose from energy efficiency .",
    "balancing between fast and energy efficient transmission , the decision of rates needs to be based on the sequence of energy harvests and data arrivals .",
    "this paper essentially bridges the work that considered scheduling on a broadcast channel _ data _ that becomes available at arbitrary points in time  @xcite and work that considered chunks of _ energy _ becoming available at arbitrary points in time  @xcite .",
    "it can also be viewed as the multiuser correspondent of the second problem considered in  @xcite .",
    "the main contributions are : ( 1 ) to establish structural properties of the optimal schedule , ( 2 ) the uniqueness of the optimal policy when all weaker user data is ready at the beginning , ( 3 ) an iterative algorithm which returns the optimal schedule under the same condition .",
    "it is shown in section  [ sec : sm ] that in an optimal policy , transmit power used is constant within each epoch , and may only rise from one epoch to the next , so that once it starts , the transmitter never lowers its power until it finally goes silent . on the other hand , the transmitter should increase its power only under certain conditions .",
    "these conditions , along with other structural properties of power and rate are established in section  [ sec : structure ] .",
    "next , the uniqueness of the optimal policy is established under the condition that all of the weaker user s bits are available at the beginning .",
    "finally , an iterative algorithm ( that we refer to as duopt ) based on the nonlinear block descent method which returns a feasible schedule carrying the same structural properties that the optimal is shown to have , is described .",
    "it has been shown that duopt returns the optimal schedule in case of static pool of weaker user data at the beginning of the schedule .",
    "we start by giving the problem statement in the next section .",
    "consider a broadcast channel with one transmitter and two receivers .",
    "arbitrary amounts of energy , @xmath1 , as well as data for each user @xmath2 become available to the sender at arbitrary times @xmath3 . a possible sequence of data and energy arrivals is illustrated in fig .  [ fig : system_model ] .",
    "@xmath4 denotes the total energy that has been _ harvested _ in @xmath5 ( regardless of how much of it has been used . ) similarly , @xmath6 and @xmath7 denote the total number of bits destined to the first and second user , respectively , that the sender has obtained in @xmath5 .",
    "the interval between any two sequential arrival events ( regardless of energy or data ) will be called an inter - arrival _ epoch_. the length of the @xmath8 epoch is @xmath9 .    in this offline problem ,",
    "all the future arrival times and amounts of energy and bits are known by the sender at @xmath10 .",
    "it is also assumed that harvested energy and data are available for use instantaneously as they arrive , and code rate and transmission power decisions can be changed instantaneously .",
    "however , codeword block lengths will be chosen such that each codeword is sent completely within a single epoch ( note that starting and ending times of epochs are known ahead of time ) , so that no arrival event occurs during a codeword .",
    "consequently , the power and rate pair decision will be fixed throughout each codeword .",
    "we are interested in minimizing the total transmission time for packets arriving by a certain time @xmath11 , so w.l.o.g .",
    ", set @xmath12 for @xmath13 , @xmath14 . a schedule , which is a sequence of power and rate allocations , is feasible if it sends @xmath15 bits to the @xmath16 user and @xmath17 to the @xmath18 user ( with a certain level of reliability ) , without violating causality ( at any time , using available energy and data by that time ) .",
    "we are interested in finding among all feasible schedules one with the smallest completion time , @xmath0 .",
    "the structure of the achievable rate region will be based on the two - user awgn bc .",
    "the capacity region of a two - user discrete time awgn bc with average power constraint @xmath19 , noise variance @xmath20 , where the @xmath16 user s channel gain ( @xmath21 ) is larger than the @xmath18 user s ( @xmath22 ) , consists of rate pairs @xmath23 satisfying : @xmath24 where @xmath25 , ( @xmath26 ) , denotes the fraction of @xmath19 used for the @xmath16 user . since @xmath27 , the @xmath16 user will be referred as the  stronger user \" , and the @xmath18 as the  weaker user \" . from ( [ eq : broadcast_channel ] ) each user s rate can be expressed as a function of the other s and @xmath19 , as @xmath28 , @xmath29 . the rate functions @xmath30 and @xmath31 defined on @xmath32 will be assumed to satisfy the following properties :    1 .",
    "nonnegativity : @xmath33 .",
    "monotonicity : @xmath34 , @xmath35 are both monotone decreasing in @xmath36 , and monotone increasing in @xmath19 .",
    "concavity : @xmath34 , @xmath35 are concave in @xmath19 and @xmath36 : @xmath37,@xmath38 , for @xmath39 .",
    "4 .   @xmath40 , @xmath41 5 .",
    "@xmath42 , @xmath43    the results in the rest of the paper will be valid for any rate function satisfying ( 1)-(5 ) , which are also satisfied by the awgn bc  @xcite .",
    "it is straightforward to show that one can restrict attention to feasible schedules that do not change their power and rate allocations within epochs .",
    "[ lmm : constantpowerrate ] in an optimal schedule , the power and rate pair remain constant within all epochs , except for the epoch during which the schedule ends .",
    "_ during an epoch , there are no energy or data arrivals and the claim is identical with the one stated and proved in lemma 2 of  @xcite .",
    "the power will drop to zero when the schedule ends , which is in general within ( and not necessarily at the end of ) the last epoch used by the schedule .    ' '' ''    with this , we will take rate and power assignments constant during an epoch .",
    "let @xmath44 be the total transmit power and @xmath45 be the rate assigned to the @xmath46 user during epoch @xmath47 .",
    "similarly , @xmath48 represent the power assigned to @xmath46 user during epoch @xmath47 .",
    "we are now ready to state the problem in terms of power and rate allocations to epochs , more precisely , an assignment of power and the stronger user s rate to each epoch ( the weaker user s rate is thus determined )",
    ". a final technical assumption will be useful in stating the problem : we shall assume that there is some @xmath49 such that there is at least one feasible schedule that ends within the first @xmath50 epochs .",
    "in other words , @xmath50 is an upper bound for epochs to be considered . in problem statement",
    ", @xmath51 denotes the last epoch of an optimal schedule , where @xmath52 .",
    "+    [ pr : multiuserscheduling ] * transmission time minimization of data arriving at arbitrary points on an energy harvesting bc : * @xmath53    we will refer to   and   as energy and data causality constraints , respectively , as these ensure no energy is consumed and no bit is transmitted before becoming available .",
    "in addition , when the @xmath54 inequality in   holds with equality , we shall say that @xmath54 _ energy constraint is active_. similarly , equality case in   will be referred as a _",
    "data constraint being active_. finally , the feasibility constraint , ensures all the data bits destined to each user are transmitted .    in the next section ,",
    "we investigate structural properties that any optimal schedule has to satisfy .",
    "lemma  [ lmm : constantpowerrate ] recorded that in an optimal schedule power can only change upon a data arrival or energy harvest . the next result states that when power changes , it can only increase .",
    "the key to the proof is that more  bits per joule \" can be sent by evenly distributing energy across a time interval ( , maintaining a constant power level , which is a consequence of the convexity properties of our rate functions . )",
    "if an even distribution of power requires transferring energy or bits to the latter epoch , it can always be done ; hence , total transmit power never decreases in time .",
    "but , power may increase in time , because even distribution of power may result in unmet causality constraints .",
    "we state these results in lemma  [ lmm : powernondecreasing ] .    due to space constraints",
    ", the proofs of the following results ( lemma  [ lmm : powernondecreasing ] through lemma  [ lmm : constantrate1 ] ) are omitted , and given in  @xcite .",
    "[ lmm : powernondecreasing ] _",
    "( for proof see  @xcite ) _ consider an optimal schedule that ends during epoch @xmath51 .",
    "power is non - decreasing with epoch index , i.e , @xmath55 for @xmath56 .",
    "as stated in lemma  [ lmm : powernondecreasing ] power can not decrease , yet may rise in time . in the next lemma we note what is necessary condition for such a rise to occur in an optimal policy .",
    "[ lmm : closerpowers ] _",
    "( for proof see  @xcite ) _ in an optimal policy , power can only rise at @xmath3 ( end of epoch @xmath47 ) if at least one of the conditions below holds :    1 .   _",
    "energy constraint is active at point @xmath3 .",
    "( the @xmath57 energy constraint is active ) _ [ cnd : a ] 2 .   _",
    "the data constraints for both users are active at point @xmath3 .",
    "( , the set of constraints in  ) _ [ cnd : b ] 3 .   _",
    "the weaker user s data constraint is active and data arrival to the weaker user occurs at time @xmath3._[cnd : c ]    the next set of results illustrate the structure of _ rate allocation _ in conjunction with the power allocation in an optimal policy .",
    "[ corollary : powerincrease ] _",
    "( for proof see  @xcite ) _ in an optimal policy ,    1 .",
    "if power increases upon a data arrival for the second user , data to be sent to the weaker user have been finished by this event .",
    "if power rises upon a data arrival for the stronger user , all available bits have been sent by this event .",
    "if power increases upon an energy harvest , all energy available at the beginning of the former constant power band has been consumed by this energy harvest .    in the rest",
    ", some properties will be proved under the condition that all weaker user data is available at the beginning .",
    "we shall abbreviate this condition as follows : +    _ weaker user full buffer condition ( wufbc ) _ is said to be satisfied whenever all of the data of the weaker user is available at the beginning of transmission .",
    "that is , @xmath58 .",
    "the following lemma states an important feature of the stronger user rate distribution under wufbc .",
    "[ lmm : constantrate1 ] _",
    "( for proof see  @xcite ) _ consider two consecutive epochs @xmath47 and @xmath59 of a given schedule , ending at @xmath60 and @xmath61 by definition , and suppose wufbc holds for the problem instance .",
    "the following is necessary for the rate and power allocation to these two epochs of the given schedule to be locally optimal : the stronger user s rate is constant throughout @xmath62 , and @xmath63 .",
    "furthermore , the rate may jump up at @xmath64 ( staying constant otherwise ) if at least one of the below is true :    1 .",
    "there is data arrival to the stronger user at @xmath64 and all the data that arrived before @xmath64 has been transmitted by @xmath60 .",
    "2 .   an energy harvest occurs at @xmath64 and all of the power has been used for the stronger user during epoch @xmath47 .    we investigate the unique solution of problem  [ pr : multiuserscheduling ] in the next section .",
    "in the following lemma we note that an optimal schedule uses all energy harvested by the time the schedule ends completely .",
    "[ lmm : consumed_energy ] the energy consumed by an optimal schedule that ends at @xmath65 is equal to @xmath66 .    _ proof . _ to reach contradiction , consider an optimal schedule that consumes less energy than it harvested and has leftover energy in its energy buffer at @xmath65 .",
    "the remaining energy in the buffer could have been used in the last epoch to decrease the transmission completion time , which contradicts the minimality of @xmath65 .",
    "hence , this schedule can not be optimal .    ' '' ''",
    "next , we show the uniqueness of the optimal schedule under wufbc .",
    "[ thm : unique_schedule ] _ there is a unique optimum schedule under wufbc , , a unique power - rate allocation achieving @xmath65 . _    _ proof . _",
    "suppose that there are two distinct optimal schedules , @xmath67 and @xmath68 , which have equal power and rate assignments until @xmath69 and differ for the first time at epoch @xmath70 .",
    "consider that the corresponding power allocation vectors , @xmath71 and @xmath72 , also differ at epoch @xmath70 such that @xmath73 and @xmath74 .",
    "first , assume that @xmath71 remains constant after epoch @xmath70 , , @xmath75 . by definition ,",
    "both schedules end at @xmath0 .",
    "the total energy consumption of @xmath67 would be less than that of @xmath68 by @xmath0 , , @xmath76 , which contradicts lemma  [ lmm : consumed_energy ] .",
    "hence , total transmit power of @xmath67 can not remain constant after @xmath77 .",
    "since total transmit power is nondecreasing ( see lemma  [ lmm : powernondecreasing ] ) , it should increase after epoch @xmath70 and before the end of transmission , , @xmath78 .",
    "since there are no data arrivals for the weaker user , the increase in total transmit power is either due to energy constraint being met or due to _ all _ the packets arrived by the time @xmath79 having been transmitted ( cf . conditions ( a ) or ( c ) in lemma  [ lmm : closerpowers ] ) . as @xmath80",
    ", @xmath67 has not consumed all the available energy at the end of epoch @xmath81 .",
    "hence , @xmath67 must have transmitted all the bits arrived until @xmath82 , which means that @xmath67 has transmitted at least the same number of bits to both users while consuming less energy than @xmath68 between @xmath83 and @xmath82 , which contradicts the optimality of @xmath68 .",
    "therefore , if there are two distinct optimal schedules , @xmath67 and @xmath68 , their power allocation vectors can not be different , , @xmath84 .",
    "now , consider two rate pair vectors , @xmath85 and @xmath86 , where @xmath87 and @xmath88 .",
    "let the rate of the stronger user in @xmath67 , @xmath89 stay constant after @xmath69 . by lemma  [ lmm :",
    "constantrate1 ] rate of the stronger user can not decrease , hence the rate of the stronger user in @xmath68 would be larger than that of @xmath67 after epoch @xmath70 , , @xmath90 . since both schedules end transmission at the same time",
    ", @xmath67 transmits fewer bits to the stronger user than @xmath68 does , which contradicts the fact that optimal schedule transmits all the packet arrivals by the end of transmission .",
    "therefore , the rate of the stronger user in @xmath67 can not stay constant after epoch @xmath70 .",
    "now suppose that rate of the stronger user in @xmath67 increases at the end of epoch @xmath81 , , @xmath91 .",
    "this increase can not be due to ( 1 ) in lemma  [ lmm : constantrate1 ] because @xmath68 has transmitted more bits to the stronger user by @xmath82 , , @xmath92 .",
    "moreover , this increase can not be due to ( 2 ) in lemma  [ lmm : constantrate1 ] since rate of the weaker user in @xmath67 is greater than zero in epoch @xmath81 , , @xmath93 .",
    "hence rate of stronger user in @xmath67 can not increase after epoch @xmath70 .",
    "finally , rate of the stronger user in @xmath67 can not _ decrease _ ( see lemma  [ lmm : constantrate1 ] ) as this would also contradict optimality .",
    "hence , there can not be two optimal schedules with different rate pair vectors .",
    "as both the power allocation vector and the rate pair vector of an optimal schedule are unique , we conclude that the optimal schedule is _ unique _ under wufbc .    ' '' ''",
    "the problem in  @xcite which is a special case of problem  [ pr : multiuserscheduling ] , where both users data is available at the beginning , was shown to be solved in  @xcite by the _",
    "algorithm  @xcite .",
    "along similar lines , we develop an algorithm that we call _ duopt _ for solving problem  [ pr : multiuserscheduling ] in its general form . as a matter of fact , _ duopt _ simply reduces to _ flowright _ when the given problem instance has all the data arriving at @xmath94 . similarly to _ flowright _ , _ duopt _ starts with any feasible schedule and reduces the transmission completion time iteratively .",
    "let the number of epochs and the transmission completion time of the initial schedule be @xmath95 and @xmath96 respectively .",
    "in each iteration , _ duopt _ sequentially updates rates and powers of two consecutive epochs at a time , , epochs @xmath97 , until all epochs are updated .",
    "then , starting from the first epoch pair , _ duopt _ continues with the next iteration .",
    "_ duopt _ stops after @xmath98 iterations such that @xmath99 , where @xmath100 is the transmission completion time , @xmath101 is the number of epochs used at the end of @xmath102 iteration and @xmath103 is a predefined threshold .",
    "hereafter , we will briefly outline the local optimizations over epoch pairs . in theorem  [ thm : duopt_stops",
    "] , it will be shown that local optimizations can only improve the schedule .",
    "we will also prove that under wufbc , successive iterations strictly improves the schedule unless it is optimal .",
    "let @xmath104 denote the energy used during the @xmath8 epoch and @xmath105 denote the number of bits transmitted to the @xmath46 user during epoch @xmath47 at the end of @xmath102 iteration .",
    "suppose that _ duopt _ is at the @xmath102 iteration and running a local optimization over epoch pair @xmath106 .",
    "the values of @xmath107 and @xmath108 , @xmath109 have already been found by previous local optimizations . at the end of this optimization , @xmath104 and @xmath105 will be determined ; @xmath110 , @xmath111 and @xmath112 will be reset to new values that conserve total energy consumption and data transmission in these epochs .",
    "the goal of the local optimization is surely to minimize the total transmission completion time of all the packet arrivals .",
    "hence , it is logical to minimize the transmission time in the local optimization problem , which results in a gap if transmission ends before the end of @xmath113 epoch .",
    "this gap is used in the next local optimization to further reduce the transmission time via transferring bits or energy between epochs @xmath114 and @xmath115 ; hence , a new gap occurs at the end of the next local optimization .",
    "this new gap propagates to the end of the transmission resulting a reduction in the total transmission completion time  @xcite .",
    "however , in some cases an epoch long gap occurs and this gap is useless for the next local optimization , , energy or data transfer between epochs in the next local optimization is impossible because of constraints . in that case , it is better to just spread the data out till the end of the second epoch in the local problem and minimize the energy consumption so that the excess energy can be used to further reduce the transmission time in the next local optimization .",
    "this leads to two different local optimization functions : _ time minimization _ and _ energy minimization_. these functions both support the global objective in different ways .",
    "time minimization aims to find the minimum amount of time , @xmath116 , to transmit @xmath117 bits to each user using the energy available in epoch pair @xmath106 , , @xmath118 . on the other hand",
    ", energy minimization aims to find the minimum energy , @xmath119 , to transmit @xmath120 bits to each user in two epoch durations , , @xmath121 , and excess energy , @xmath122 , is transferred to the @xmath123 epoch in order to conserve energy . both of the optimizations respect energy and bit causalities , , @xmath124 and @xmath125 , @xmath126 . for details of the local optimization ,",
    "see  @xcite .",
    "+ suppose that all the feasible packets have been transmitted until the end of the @xmath8 epoch and there are still packets to arrive after @xmath60 . then , further minimization of transmission completion time of sequential epochs before @xmath3 will be suboptimal . on the other hand",
    ", we can minimize the energy consumption until @xmath3 and use the excess energy to minimize the transmission completion time . therefore",
    ", utilization of energy minimization for local optimizations in problem  [ pr : multiuserscheduling ] is very crucial . if it is guaranteed that current schedule uses at least the same amount of energy as optimal schedule until @xmath3 , _ duopt _ uses the energy minimization function upto @xmath8 epoch pair and the time minimization function for the rest . in order to determine when to switch from energy minimization to time minimization",
    ", a _ flag _ is placed at @xmath8 epoch pair .",
    "initially , the _ flag _ is set to zero and _ duopt _ starts with performing time minimization on epoch pairs . during @xmath102 iteration ,",
    "if all the feasible bits are transmitted by the @xmath8 epoch for @xmath127 , then the _ flag _ is set to @xmath47 @xmath128 . in the following iterations ,",
    "energy minimization function is used up to @xmath8 epoch pair .",
    "[ fig : duoptflag ] illustrates the _ flag _ usage and the pseudo - code in algorithm  [ alg : duopt ] outlines the duopt algorithm .",
    "+    initialize ( ) ; @xmath129 @xmath130 @xmath131 @xmath132 @xmath133 ` calculate_t(&`@xmath134 ` ) `    [ thm : duopt_stops ] _ following statements hold : _    1",
    ".   _ successive iterations of duopt can only improve the schedule .",
    "_ duopt stops and returns a schedule with @xmath135 . _    _ proof . _    1 .",
    "suppose that duopt is running its @xmath102 iteration .",
    "after the local optimization on @xmath8 epoch pair , we obtain @xmath136 and reset the values of @xmath137 .",
    "if the _ flag _ is not placed before @xmath8 epoch pair , , @xmath138 , then the aim of the local optimization will be energy minimization . following the local optimization on @xmath8 epoch pair",
    ", the excess energy will be transferred to @xmath111 . in the next local optimization",
    "this excess energy is either further transferred or is used to reduce the transmit time . on the other hand , if @xmath139 , then the aim of the local optimization on @xmath8 epoch pair will be time minimization . after the local optimization",
    "the transmission completion time of the bits in epochs @xmath106 will either be equal to or before the end of the epoch @xmath114 .",
    "that is , a gap may occur within @xmath8 epoch pair . in the next local optimization , this gap would propagate to the @xmath123 epoch  @xcite . during the @xmath102 iteration of _ duopt",
    "_ , if a gap occurs or excess energy is transferred during local optimizations , then the gap ( or the excess energy respectively ) will propagate to the last epoch pair resulting in an ultimate reduction the transmission completion time at the end of the iteration , , @xmath140 .",
    "if neither excess energy nor a gap occurs during local optimizations , then transmission completion time can not be decreased and _ duopt _ will stop by definition . +",
    "both local optimizations are in favor of the next local optimization .",
    "therefore , if in either one of the local optimizations a gap occurs or excess energy is transferred then it would propagate till the last epoch pair and finally the transmission completion time would decrease at the end of @xmath141 iteration , , @xmath140 . if neither excess energy nor gap occurs during local optimizations , then transmission completion time would not be decreased and _ duopt _ would stop . +    ' '' '' 2 .",
    "in part-1 we have shown that transmission completion time , @xmath142 , is strictly decreasing in each iteration ; meanwhile it is bounded below by @xmath143 .",
    "therefore , the iterations of _ duopt _ stop and return a schedule @xmath135 .",
    "+    ' '' ''      [ thm : duopt_optimal ] _ if wufbc is guaranteed , the schedule returned by _ duopt _ is optimal , , _",
    "@xmath144 .",
    "_ suppose that _ duopt _ stopped and returned a schedule @xmath145 , with completion time @xmath146 .",
    "let @xmath147 be the unique optimal schedule with transmission completion time @xmath148 .",
    "we will now prove that @xmath149 .",
    "let us suppose @xmath150 , then these schedules have to differ in either the power allocation or rate allocation ( or both ) .",
    "first , suppose @xmath151 and @xmath152 for some @xmath70 .",
    "we will show that this case is impossible .",
    "there are two possible cases for epoch @xmath70 : ( i ) @xmath153 , ( ii ) @xmath154 . let us begin with the first case .    a.   [ prf : item1 ] we assumed @xmath153 .",
    "if @xmath155 stays constant after epoch @xmath70 till the end of transmission , this would mean that @xmath156 consumes more energy than @xmath147 until @xmath148 , which would contradict the fact that optimal schedule consumes all the harvested energy till the end of transmission .",
    "therefore the power of the optimal schedule must increase at the end of epoch @xmath157 for some @xmath158 before the end of transmission .",
    "as @xmath156 has been able to use more energy than the optimal schedule until @xmath159 , the optimal schedule can not have run into an energy constraint at @xmath159 , hence the rise in the power can only be due to a data constraint at @xmath159 , , all the bits arrived have been transmitted by the optimal schedule until @xmath159 . in order to contradict the assumption that @xmath153 , we will now analyze the rate assignments for both schedules .",
    "first let us focus on the case that both schedules use exactly the same rates for the stronger user up to @xmath159 , , @xmath160 .",
    "as we have shown above , @xmath147 should have transmitted all the bits available until @xmath159 . however ,",
    "if we compare the weaker user bits transmitted by both schedules until @xmath159 , we observe that @xmath156 transmits more bits to the weaker user than @xmath147 does , because @xmath161 . on the other hand , _ duopt _ respects _ bit causality _",
    ", , _ duopt _ does not transmit bits that have not arrived yet , so we reach contradiction .",
    "that is , rates can not stay constant up to @xmath159 , , there is some @xmath162 such that @xmath163 for @xmath164 and @xmath165 .",
    "but we shall now show that this is not possible .",
    "first consider the case that @xmath166 . from lemma  [ lmm : constantrate1 ]",
    ", the stronger user s rate can not decrease under wufbc .",
    "if @xmath167 , then @xmath156 transmits more bits to the weaker user than @xmath147 does by @xmath159 , , @xmath168 .",
    "however , at the end of @xmath169 epoch , @xmath156 can not send more bits to weaker user because @xmath147 should have transmitted all the weaker user bits .",
    "therefore , @xmath170 should increase before @xmath159 , , at the end of epoch @xmath171 , where @xmath172 .",
    "we have @xmath173 , hence either one of the two conditions in lemma  [ lmm : constantrate1 ] must hold . since @xmath174 , until @xmath175 , @xmath147 has transmitted more bits to the stronger user than @xmath156 does ; therefore , all the stronger user s bits arrived have not been transmitted by @xmath156 at the end of epoch @xmath176 . also , @xmath177 . hence neither of the two conditions in lemma  [ lmm : constantrate1 ] holds and stronger user s rate can not increase at @xmath175 , which implies @xmath178 .",
    "thus , we are left with the case @xmath179 . if @xmath180 , then @xmath181 , which contradicts the fact that duopt respects bit feasibility .",
    "hence , stronger user s rate in @xmath147 can not remain constant after epoch @xmath182 .",
    "then we should have @xmath183 and @xmath184 . since there is an increase in the stronger user rate , at least one of the conditions in lemma  [ lmm : constantrate1 ] should hold at @xmath175 .",
    "however , we have @xmath185 and @xmath186 , which tells us that neither one of the conditions in lemma  [ lmm : constantrate1 ] holds , which implies that this final case is also not possible .",
    "hence , we conclude that the case @xmath153 is not possible .",
    "b.   now consider the case @xmath154 .",
    "we will prove that this case is also not possible by following a similar method to the one in case ( [ prf : item1 ] ) .",
    "first , suppose that the power of @xmath156 increases after @xmath187 epoch .",
    "this increase can not be due to an energy constraint , since @xmath147 consumes more energy than @xmath156 does until the increase in power .",
    "hence , it should be due to data constraint and under wufbc both user data constraints should be active .",
    "that is , @xmath156 transmits all the feasible data until the increase in power .",
    "this implies that while consuming less energy , @xmath156 transmits at least the same number of bits than @xmath147 does , which contradicts the optimality of @xmath147 .",
    "thus , power of @xmath156 can not increase after epoch @xmath70 .",
    "also , it can not decrease in time , otherwise a local optimization results in either a gap or excess energy that propagates till the end of the schedule and transmission duration decreases .",
    "therefore , we power of @xmath156 should stay constant after epoch @xmath70 until @xmath148 .",
    "now , we will analyze the rate assignments for both schedules .",
    "let the transmission of @xmath147 end in epoch @xmath157 for @xmath158 and suppose that @xmath188 . at the @xmath54 epoch",
    "there are three possible cases : @xmath179 , @xmath166 and @xmath189 .",
    "we will first consider the case @xmath179 and prove that this is not possible .",
    "let @xmath179 and consider the rate of the stronger user in @xmath147 after @xmath54 epoch .",
    "it can not stay constant until @xmath148 , because it contradicts the fact that @xmath147 transmits all the feasible bits before @xmath148 , , @xmath181 .",
    "since the stronger user s rate in @xmath147 can not decrease by lemma  [ lmm : constantrate1 ] , it should increase at the end of epoch @xmath176 for @xmath190 , , @xmath184 .",
    "however , we have @xmath186 and @xmath191 which implies that none of the conditions in lemma  [ lmm : constantrate1 ] holds and the stronger user s rate in @xmath156 can not increase after epoch @xmath182 . hence , we conclude that @xmath192 .",
    "now we consider the case @xmath166 .",
    "suppose that the stronger user s rate in @xmath147 increase at epoch @xmath176 for @xmath190 .",
    "this increase in stronger user s rate requires that at least one of the conditions in lemma  [ lmm : constantrate1 ] should hold .",
    "however , we have @xmath186 and @xmath191 , so the stronger user s rate in @xmath156 can not increase , , @xmath192 . since the stronger user s rate in @xmath147 can not decrease by lemma  [ lmm : constantrate1 ]",
    ", it should stay constant until @xmath148 .",
    "+ thus far we have shown that if @xmath156 is different than @xmath147 , then @xmath156 can not have higher power level than @xmath147 until @xmath148 . moreover , if power level of @xmath156 becomes lower than that of @xmath147 , then it should stay constant until @xmath148 and if the stronger user s rate of @xmath156 becomes lower than that of @xmath147 , then it should stay constant until @xmath148 .",
    "these results are shown in the general case in fig .",
    "[ fig : duopt_vs_optimal ] .",
    "+ now , let @xmath193 and @xmath194 be the number of bits transmitted to the weaker user till @xmath195 by @xmath156 and till @xmath148 by @xmath147 , respectively .",
    "then , we have @xmath196 + from ( [ eqn : bitfeasibility_5 ] ) , @xmath156 transmits more bits to the weaker user than @xmath147 does , then this final case also can not happen .",
    "therefore , we conclude that the schedule returned by _",
    "duopt _ can not be different than the unique optimal schedule , , @xmath149 .",
    "+    ' '' ''",
    "consider a two - user awgn bc with 1khz bandwidth and @xmath197 watts / hz . path loss factors on the links of stronger and weaker user are assumed to be 70db and 75db , respectively .",
    "amounts and instants of energy harvests and bit arrivals are depicted in fig .",
    "[ fig : numex ] . under these circumstances",
    "duopt algorithm is run and final schedule is calculated as drawn in fig .",
    "[ fig : numex ]",
    "with the new advances in energy harvesting technologies , optimization of communication systems that depend on renewable energy resources has emerged as an important problem .",
    "a large body of recent research effort in the field has focused on transmission scheduling policies  @xcite .",
    "this paper continued the work on to the solution of the previous formulation of the problem stated in  @xcite and  @xcite .",
    "in particular , it aimed to find the power and rate allocation policy in a broadcast channel with two users , that minimizes the total transmission completion time of data that becomes available at arbitrary points in time , with energy that is harvested at arbitrary points in time .",
    "it should be noted that this line of work relies on offline problem formulations where exact knowledge of data and energy arrival events is assumed .",
    "the approach is useful for obtaining structures and guidelines as well as benchmarks for online problems which may be more applicable in practical transmision scenarios .    in this study ,",
    "structural properties about the solution of the general optimal offline broadcast packet scheduling policy for an energy harvesting broadcast channel have been established .",
    "the uniqueness of the optimal policy under the weak - user - full - buffer condition ( wufbc ) has been shown .",
    "an iterative algorithm , duopt , that returns a feasible schedule which possesses the same structural policies that the optimal was shown to have is devised .",
    "moreover , duopt was shown to obtain the unique optimal policy under wufbc .",
    "proving the uniqueness of the optimal policy and optimality of duopt in general are two goals of ongoing work .",
    "the direction set for future work related to the problem presented in this paper also includes online problems .",
    "the claim is that power is non - decreasing with epoch number @xmath47 .",
    "equivalently power is non - decreasing in time . to show this , we will argue that given a schedule in which power decreases at some time @xmath3 , this schedule can only be improved by equating the power levels before and after @xmath3 . consider a time interval @xmath198 , so that power is constant at @xmath199 during @xmath200 , and at @xmath201 during @xmath202 .",
    "as illustrated in fig  [ fig : closerpowers ] , let @xmath203 , and the lengths of the constant - power slots be @xmath204 and @xmath205 .",
    "denote the rate pairs in the @xmath16 and @xmath18 slots as ( @xmath206 , @xmath207 ) and ( @xmath208 , @xmath209 ) , respectively .",
    "we will show that keeping the total consumed energy constant , and transferring some amount of energy @xmath210 from the first slot to the second such that power levels are reallocated closer to each other , the sender can transmit at least the same number of bits within the same duration .",
    "let us denote the average rate of the weaker user as @xmath211 .",
    "provided @xmath212 , the sender could transfer some energy and some of user 2 s bits from the first epoch to the second while keeping user 1 s rates @xmath213 and @xmath214 constant . as energy and bits",
    "are simply being deferred for later use , this operation does not violate feasibility .",
    "specifically , let @xmath215 such that the new power allocation to the slots is @xmath216 satisfying @xmath217 . with this new allocation ,",
    "the weaker user s rate in the first slot is @xmath218 .",
    "its new new average rate over the duration of @xmath219 is : @xmath220 this is shown by straightforward application of the properties listed in section ii .    in the remaining case which is @xmath221 , we know that @xmath222 must hold ( as @xmath199 . ) in this case , the allocation can similarly be improved by bringing power levels closer and transferring some of the first user s bits to the right , while keeping the rate allocation of the weaker user unchanged .",
    "let @xmath223 be the average rate of the stronger user over the duration @xmath219 .",
    "after the reallocation , the average rate of the stronger user becomes @xmath224      the @xmath16 and @xmath18 order derivatives of @xmath231 with respect to @xmath230 are the following and @xmath232 represent the first and second order partial derivatives of @xmath233 with respect to @xmath19 , respectively . ]",
    "according to the properties listed in section ii ,   always holds if @xmath236 .",
    "hence @xmath231 is concave in @xmath230 , if @xmath221 .",
    "we conclude that a policy that contains a drop in power level is sub - optimal .        to reach contradiction , suppose that power increases at time @xmath3 ( @xmath237 ) .",
    "we will show that if none of the conditions  ,   or   hold , then it is possible to improve the schedule by transferring some energy from the @xmath113 epoch to the @xmath8 . assuming the @xmath8 epoch length is @xmath204 and the @xmath113 is @xmath238 , after bringing power levels closer , @xmath239 observe that if we treat @xmath44 as @xmath240 and @xmath241 as @xmath242 , then   becomes identical with  .",
    "this implies that at least the same number of bits could be transmitted to weaker user , if we can bring power levels closer while keeping the stronger user s rates constant .",
    "in addition to this , the allocation could also be improved by bringing power levels while keeping the weaker user s rates constant , in case @xmath243 .",
    "consequently , equations   and   hold .",
    "it is straightforward that we can not bring power levels any closer when condition   holds , due to the energy causality constraint .",
    "secondly , it also does nt yield a better schedule , if we can not transfer data from the latter epoch to the former(condition  ) .",
    "when it is possible to transfer some positive amount of energy from the @xmath113 epoch to the @xmath8 , as shown in  , we can always improve allocation while keeping the rates of the stronger user the same .",
    "although bringing power levels closer while keeping the rates of the stronger user the same is not feasible in case weaker user s data constraint is active , we may still improve allocation as proved in  . nevertheless , this time we require @xmath243 . as rate of the weaker user can only rise upon a data arrival for the weaker user in case weaker user s data constraint",
    "is active , condition   describes the last case that we may not improve allocation by bringing power levels closer .",
    "we have thus shown that this set of three conditions contains all the cases in which power can rise , if none of these hold , then power can not rise .",
    "it is straightforward to show that this set can not be further reduced by finding counterexamples for the claim that if any one of  ,   or   is satisfied , then power may rise at time @xmath3 .        1 .",
    "suppose that power increases upon a bit arrival for the weaker user occurring at @xmath3 .",
    "as there is no energy constraint at @xmath3 , bringing power levels closer does not contradict with the energy causality in this case .",
    "this implies that conditions   or   stated in lemma  [ lmm : closerpowers ] must hold .",
    "however , we know that there is a data arrival for the weaker user at @xmath3 , so if   were true , then   would be true as well .",
    "therefore , condition   holds in either case",
    ". +    ' '' '' 2 .",
    "suppose that power increases upon a bit arrival for the first user .",
    "with similar reasoning to part-1 , condition   of lemma  [ lmm : closerpowers ] can not hold . as there is also no data arrival for the weaker user , condition   must be satisfied .",
    "+          suppose that @xmath244 .",
    "one can find a better schedule by bringing the rates of the stronger user closer by lemma 6 of  @xcite .",
    "therefore , the stronger user s rate can not decrease .",
    "however , the stronger user s rate may increase because it may be against to either bit or energy causality to transfer some stronger user bits from epoch @xmath59 to @xmath47 .",
    "firstly , it is against _ bit causality _ to transfer some stronger user bits from epoch @xmath59 to epoch @xmath47 , if the first condition holds .",
    "secondly , if the second condition is satisfied we can not bring stronger users rates closer to each other as it would violate _ energy causality_.          consider the local optimization problem given in fig .",
    "[ fig : local_constraints ] , where @xmath245 is the data arrival for the @xmath8 user , @xmath246 is the energy harvest at the beginning of @xmath46 epoch for @xmath247 .",
    "@xmath248 is the length of the first epoch and @xmath249 is the transmit duration in the second epoch .",
    "let @xmath250 and @xmath251 be the power and rate assigned to the @xmath8 user during @xmath46 epoch after optimization .",
    "the energy and data causality constraints for the local optimization problem are as follows : @xmath252    the structure of the solution changes if either one of the constraints satisfied with equality .",
    "since there are @xmath253 different constraints , after optimization one will encounter one of the @xmath254 results . we have studied all @xmath255 cases and derived solutions to each one of them for both energy minimization and time minimization functions . in each case , the solution can be calculated analytically for energy minimization or it can be found iteratively for time minimization functions . before starting the optimization , if one already knows which constraints should be satisfied with equality , then the result could be obtained solving just that case .",
    "otherwise , one should compute the results for each case and then select the best one that respects energy and bit causalities .",
    "next , we will analyze one of the cases and present the algorithms for both energy and time minimization functions .",
    "the analyzes of the remaining cases can be done in a similar fashion  @xcite .",
    "[ [ local - optimization - when - only - stronger - user - data - constraint - is - active ] ] local optimization when only stronger user data constraint is active + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + +    one of the possible structures of the local optimal solution is when only the stronger user data constraint is active . in this case ,",
    "total transmit power level in local optimal solution should be constant ( see lemma  [ lmm : closerpowers ] ) . under this condition , a possible illustration of optimal power allocation is depicted in fig .  [",
    "fig : localopt_b1 ] .",
    "since the total power should stay constant during transmission , we should have @xmath256 .",
    "moreover , we should have @xmath257 since only the stronger user bit causality is met .",
    "for a given transmission completion time @xmath258 , the optimum schedule that minimize energy consumption can be found as follows : @xmath259 from   and   we derive @xmath260.\\ ] ] then , total energy consumed in two epochs is calculated by @xmath261            as shown in  ( [ b2_derivative2 ] ) , second derivative of @xmath266 is always negative for @xmath268 , which implies that @xmath266 is a strictly concave function of @xmath249 .",
    "as @xmath249 goes to infinity , @xmath266 is as follows ,      since @xmath266 is a strictly concave function of @xmath249 and goes to a finite number as @xmath249 goes to infinity , @xmath266 is an increasing strictly concave function of @xmath249 and there is a unique @xmath266 for each value of @xmath249 .    in time",
    "minimization we have @xmath270 , @xmath271 , @xmath248 , @xmath263 , @xmath272 , @xmath273 ; @xmath274 and @xmath275 are constant terms and @xmath249 is transmission time within the second epoch which is to be minimized . since @xmath266 is an increasing concave function of @xmath249 , we iteratively find @xmath249 that sends exactly @xmath266 bits to weaker user by using bisection method .",
    "minimum time to transmit @xmath262 and @xmath266 bits to the users in these two epochs can be calculated by @xmath276 .",
    "algorithm  [ alg : tmin_b1 ] presents a pseudo - code of time minimization algorithm for the case that only the stronger user bit causality event occurs .",
    "+      10 f. m. ozcelik , h. erkal and e. uysal - biyikoglu , `` optimal offline packet scheduling on an energy harvesting broadcast link , '' _ 2011 ieee int .",
    "symposium on information theory _",
    ", pp.2886 - 2890 , saint- petersburg , russia , aug . 2011 .",
    "e. uysal - biyikoglu and a. el gamal , `` energy - efficient packet transmission over a multi - access channel , '' _ proc .",
    "ieee intl .",
    "symposium on information theory _ ,",
    "p.153 , july 2002 .",
    "r. a. berry and r. g. gallager , `` communication over fading channels with delay constraints , '' _ ieee transactions on information theory _ , vol.48 , pp.1135 - 1149 , may 2002 .",
    "p. nuggehalli , v. srinivashan , and r. r. rao , `` delay constrained energy efficient transmission strategies for wireless devices , '' _ in proc.ieee infocom _ , vol.3 , pp.1765 - 1772 , new york , june 2002 . m. a. zafer and e. modiano , `` a calculus approach to energy - efficient data transmission with quality of service constraints , '' _ ieee / acm transactions on networking _ ,",
    "vol.17 , pp.898 - 911 , june 2009 . j. yang and s. ulukus , `` optimal packet scheduling in an energy harvesting communication system , '' arxiv:1010.1295v1 , 2010 .",
    "k. tutuncuoglu and a. yener , `` optimum transmission policies for battery limited energy harvesting nodes , '' arxiv:1010.6280 ] , 2010 .",
    "o. ozel , k. tutuncuoglu , j. yang , s. ulukus and a. yener , `` transmission with energy harvesting nodes in fading wireless channels : optimal policies , '' _ selected areas in communications , ieee journal on _ , vol.29 , no.8 ,",
    "pp.1732 - 1743 , september 2011 m. a. antepli , e. uysal - biyikoglu , and h. erkal , `` optimal packet scheduling on an energy harvesting broadcast link , '' _ selected areas in communications , ieee journal on _ , vol.29 , no.8 , pp.1721 - 1731 , september 2011 .",
    "j. yang , o. ozel and s. ulukus , `` broadcasting with an energy harvesting rechargeable transmitter , '' arxiv:1010.2993v1 , 2010 .",
    "o. ozel , j. yang and s. ulukus , `` broadcasting with a battery limited energy harvesting rechargeable transmitter , '' _ modeling and optimization in mobile , ad hoc and wireless networks ( wiopt ) , 2011 international symposium on _ , pp.205 - 212 ,",
    "princeton , nj , may 2011 .",
    "s. chen , p. sinha , n. b. shroff and c. joo , `` finite - horizon energy allocation and routing scheme in rechargeable sensor networks , '' _",
    "ieee infocom11 _ , shanghai china , april 2011",
    ". m. gatzianas , l. georgiadis and l. tassiulas ,  control of wireless networks with rechargeable batteries , \" in _ trans . on wireless communications _ ,",
    "vol . 9 , pp .",
    "581 - 593 , february 2010 .",
    "f. m. ozcelik , h. erkal and e. uysal - biyikoglu , `` optimal offline packet scheduling on an energy harvesting broadcast link , '' _ ieee international symposium on information theory ( isit ) _",
    ", pp.2886 - 2890 , st .",
    "petersburg , russia , july 2011 .",
    "e. uysal - biyikoglu and a. el gamal , `` on adaptive transmission for energy efficiency in wireless data networks , '' _ ieee transsactions on information theory _ ,",
    "vol.50 , pp.3081 - 3094 , dec 2004 .",
    "e. uysal - biyikoglu , b. prabhakar , and a. el gamal , `` energy - efficient packet transmission over a wireless link , '' in _",
    "ieee / acm trans . networking _ ,",
    "vol.10 , pp.487 - 499 , aug",
    "zangwill , _ nonlinear programming _ , prentice - hall , engelwood cliffs , new jersey , prentice - hall , 1969 .",
    "h. erkal , f. m. ozcelik and e. uysal - biyikoglu , _ optimal offline broadcasting with an energy harvesting capable transmitter _",
    ", technical report , metu , ankara , turkey , available at http://www.eee.metu.edu.tr/@xmath282cng ."
  ],
  "abstract_text": [
    "<S> we consider an energy harvesting transmitter broadcasting data to two receivers . </S>",
    "<S> energy and data arrivals are assumed to occur at arbitrary but known instants . </S>",
    "<S> the goal is to minimize the total transmission time of the packets arriving within a certain time window , using the energy that becomes available during this time . </S>",
    "<S> an achievable rate region with structural properties satisfied by the two - user awgn bc capacity region is assumed . </S>",
    "<S> structural properties of power and rate allocation in an optimal policy are established , as well as the uniqueness of the optimal policy under the condition that all the data of the  weaker \" user are available at the beginning . </S>",
    "<S> an iterative algorithm , duopt , based on block coordinate descent that achieves the same structural properties as the optimal is described . </S>",
    "<S> investigating the ways to have the optimal schedule of two consecutive epochs in terms of energy efficiency and minimum transmission duration , it has been shown that duopt achieves best performance under the same special condition of uniqueness .    </S>",
    "<S> packet scheduling , energy harvesting , awgn broadcast channel , energy - efficient scheduling . </S>"
  ]
}