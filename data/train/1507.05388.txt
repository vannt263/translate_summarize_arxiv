{
  "article_text": [
    "disjunctive answer set programming ( asp )  @xcite is a vibrant area of ai providing a declarative formalism for solving hard computational problems .",
    "thanks to the power of modern asp technology  @xcite , asp was successfully used in many application areas , including product configuration  @xcite , decision support for space shuttle flight controllers  @xcite , team scheduling  @xcite , and bio - informatics  @xcite .    with its main decision problems located at the second level of the polynomial hierarchy , full disjunctive asp is necessarily computationally involved .",
    "but some fragments of asp have lower complexity .",
    "two prominent examples are the class of _ normal _ programs and the class of _ head - cycle free _ ( hcf ) programs  @xcite . in each case",
    ", the problem of the existence of an answer set is -complete .",
    "identifying and understanding such fragments is of theoretical importance and can also help to make asp solvers more efficient .",
    "a solver can detect whether a program is from an easier class ( e.g. , is normal or head - cycle free ) and , if so , use a dedicated more lightweight machinery to process it .",
    "hcf programs are defined by a _",
    "condition taking into account all rules in a program . on the other hand , interesting classes of programs can also be obtained by imposing conditions on _ individual _ rules .",
    "examples include the classes of horn , normal , negation - free , and purely negative programs .",
    "for instance , horn programs consist of rules with at most one atom in the head and no negated atoms in the body , and purely negative programs consist of rules with no atoms in the positive body . a general schema to define classes of programs in terms of the numbers of atoms in the head and in the positive and negative bodies of their rules was proposed by  @xcite  . in the resulting space of classes of programs , the complexity of the _ consistency _ problem ( that is , the problem of the existence of an answer set ) ranges from p  to -complete to @xmath0-complete .",
    "the three main classes of programs in that space that fall into the -complete category are the classes of normal and negation - free programs ( possibly with constraints ) , mentioned above , and the class of programs whose non - constraint rules have at most one positive atom in the body  @xcite .",
    "while the former two classes have been thoroughly investigated , the third class has received little attention so far . in particular",
    ", the paper by @xcite   only identified the class and established the complexity of the main reasoning tasks ( deciding the consistency , and skeptical and credulous reasoning ) .    in this paper , we study this `` forgotten '' class in more detail .",
    "we call its programs _ dual - normal _ , since the reducts of their non - constraint part are _ dual_-horn .",
    "in fact , this is the reason why for dual - normal programs the consistency problem is in .",
    "lower complexity is not the only reason why dual - normal programs are of interest .",
    "let us consider a slight modification of the celebrated translation of a @xmath1-qbf @xmath2 into a disjunctive program @xmath3 $ ] devised by  @xcite  .",
    "the translation assumes that @xmath4 is a 3-dnf formula , say @xmath5 , where @xmath6 s are literals over @xmath7 . to define @xmath3 $ ]",
    "we introduce mutually distinct fresh atoms @xmath8 , @xmath9 , for @xmath10 , @xmath11 , for @xmath12 , and set @xmath13 = & \\ { x \\vee \\overline{x } { \\leftarrow}{\\;{|}\\;}x\\in x\\ } \\cup \\ { y \\vee               \\overline{y } { \\leftarrow}{;\\;}y { \\leftarrow}w{;\\;}\\overline{y } { \\leftarrow}w               { \\;{|}\\;}y \\in y\\ } \\cup \\\\             & \\ { w { \\leftarrow}l^*_{i,1},l^*_{i,2},l^*_{i,3}{\\;{|}\\;}1\\leq i \\leq               n\\ } \\cup \\ { \\bot { \\leftarrow}{\\ensuremath{\\neg}}\\ w\\}\\end{aligned}\\ ] ] where @xmath14 if @xmath15 , @xmath16 if @xmath17 , @xmath18 for @xmath19 , @xmath20 for @xmath21 .",
    "it can be shown that @xmath22 $ ] has at least one answer set if and only if @xmath23 is true .",
    "let us consider the subclass of @xmath1-qbfs where each term  @xmath24 in @xmath23 contains at most one universally quantified atom from  @xmath25 .",
    "this restriction makes the @xmath26-complete problem of the validity of a @xmath1-qbf @xmath27-complete , only .",
    "moreover , it is easy to check that under that restriction , @xmath22 $ ] is a dual - normal program . since , the consistency problem for dual - normal programs is @xmath27-complete  @xcite as well , dual - normal programs thus allow here for a straightforward _ complexity - sensitive _ reduction with respect to the subclass of the @xmath1-qbf problem mentioned above .",
    "@xcite   proposed another translation of qbfs into programs that , with slight modifications , is similarly complexity - sensitive .",
    "[ [ main - contributions ] ] main contributions + + + + + + + + + + + + + + + + + +    our first group of results concerns connections between dual - normal programs , propositional theories and normal programs .",
    "they are motivated by practical considerations of processing dual - normal programs .",
    "first , we give an efficient translation from dual - normal programs to satsuch that the models of the resulting formula encode the answer sets of the original program . while similar in spirit to translations to satdeveloped for other classes of programs , our translation requires additional techniques to correctly deal with the dual nature of the programs under consideration .",
    "second , in order to stay within the asp framework we give a novel translation capable to express dual - normal programs as normal ones , _ and _ also vice versa , in each case producing polynomial - size encodings .",
    "in addition , this translation allows us to properly extend the class of dual - normal programs to the novel class of _ body - cycle free _ programs , a class for which the consistency problem is still located in .    in the next group of results ,",
    "we investigate dual - normal programs from a different angle : their ability to express concepts modeled by classes of se- and ue - models  @xcite and , in particular , to express programs under the notions of equivalence defined in terms of se- and ue - models  @xcite . among others ,",
    "we show that the classes of normal and dual - normal programs are incomparable with respect to se - models , and that dual - normal programs are strictly less expressive than normal ones with respect to ue - models .",
    "we also present results concerning the complexity of deciding strong and uniform equivalence between dual - normal programs .",
    "a _ rule _  @xmath28 is an expression  @xmath29 , where @xmath30 , @xmath31 , @xmath32 , @xmath33 , @xmath34 and @xmath35 are non - negative integers , and @xmath36 , @xmath37 , are propositional atoms .",
    "we omit the braces in @xmath38 , @xmath39 , and @xmath40 if the set is a singleton .",
    "we occasionally write @xmath41 if @xmath42 .",
    "we also use the traditional representation of a rule as an expression @xmath43 we call @xmath44 the _ head _ of @xmath28 and @xmath45 @xmath46 the _ body _ of @xmath28 . a rule",
    "@xmath28 is _ normal _ if @xmath47 , @xmath28 is _ horn _ if it is normal and @xmath48 , @xmath28 is _ dual - horn _ if @xmath49 and @xmath48 , @xmath28 is an _ ( integrity ) constraint _",
    "if @xmath42 , @xmath28 is _ positive _ if @xmath48 , and @xmath28 is _ definite _ if @xmath50 . if @xmath51 , we simply write @xmath38 instead of @xmath52 .    a _ disjunctive logic program _ ( or simply a _ program _ ) is a finite set of rules .",
    "we denote the set of atoms occurring in a program  @xmath53 by @xmath54 .",
    "we often lift terminology from rules to programs .",
    "for instance , a program is _ normal _ if all its rules are normal .",
    "we also identify the parts of a program @xmath53 consisting of proper rules as @xmath55 and constraints as @xmath56 . in this paper",
    "we are particularly interested in the following class .",
    "[ def : dnorm ] a program  @xmath53 is called _ dual - normal _ if each rule  @xmath28 of @xmath53 is either a constraint or @xmath49 .",
    "programs that are both normal and dual - normal are called _",
    "singular_.    note that dual - horn programs may contain positive constraints with a single body atom but arbitrary constraints are forbidden in contrast to dual - normal programs .",
    "let @xmath53 be a program and @xmath57 a fresh atom .",
    "we define @xmath58 = &             \\{h(r)\\leftarrow t,\\neg b^{-}(r){\\;{|}\\;}r\\in p , b^+(r)=\\emptyset \\ } \\cup              \\",
    "{ r\\ { \\;{|}\\;}r\\in p , b^+(r)\\neq\\emptyset \\}.\\end{aligned}\\ ] ] this transformation ensures non - empty positive bodies in rules and turns out to be useful in analyzing the semantics of dual - normal programs .",
    "an _ interpretation _ is a set  @xmath59 of atoms .",
    "an interpretation  @xmath59 is a _ model _ of a program  @xmath53 , written @xmath60 , if @xmath59 _ satisfies _ each rule @xmath61 , written @xmath62 , that is , if @xmath63 or @xmath64 .    in the following when we say",
    "that a set  @xmath65 is maximal ( minimal ) we refer to inclusion - maximality ( inclusion - minimality ) .",
    "a horn program either has no models or has a unique least model .",
    "dual - horn programs have a dual property .    [ prop:3 ]",
    "let @xmath53 be dual - horn .",
    "then @xmath53 has no models or has a unique maximal model .",
    "we will now describe a construction that implies this result and is also of use in arguments later in the paper .",
    "let us define @xmath66 and , for @xmath67 , @xmath68 , \\",
    "h\\subseteq e_{i-1}\\}.    \\end{aligned}\\ ] ] intuitively , the sets  @xmath69 consist of atoms that _ must not _ be in any model of @xmath70 $ ] ( must be eliminated ) .",
    "the construction is dual to that for horn programs .",
    "more precisely , the sets  @xmath69 can be alternatively defined as the results of recursively applying to @xmath66 the one - step provability operator for the _ definite horn _",
    "program  @xmath71= \\{b { \\leftarrow}h{\\;{|}\\;}h{\\leftarrow}b \\in p[t]\\}$ ] .",
    "the following result summarizes properties of the program  @xmath70 $ ] and sets  @xmath69 .",
    "[ prop:4 ] let @xmath53 be dual - horn .",
    "then ,    1",
    ".   @xmath72 ; 2 .",
    "@xmath73 is a maximal model ( over @xmath74 ) of @xmath70 $ ] ; 3 .",
    "for every set  @xmath65 of atoms , @xmath65 is a model of @xmath53 if and only if @xmath75 is a model of @xmath70 $ ] ; and 4 .",
    "@xmath53 has a model if and only if @xmath57 belongs to the maximal model ( over @xmath74 ) of @xmath70 $ ] + ( or , equivalently , @xmath76 ) .",
    "properties  ( 3 ) and  ( 4 ) imply proposition  [ prop:3 ] .",
    "the construction can be implemented to run in linear time by means of the algorithm by  @xcite   for computing the least model of a horn program .",
    "the _ gelfond - lifschitz reduct",
    "_  @xmath77 of a program  @xmath53 _ relative to _ an interpretation  @xmath59 is defined as @xmath78 .",
    "observe that for a dual - normal program  @xmath53 any reduct of  @xmath79 is dual - horn .",
    "an interpretation  @xmath59 is an _ answer set _ of a program  @xmath53 if @xmath59 is a minimal model of @xmath77  @xcite .",
    "the set of all answer sets of a program @xmath53 is denoted by @xmath80 .",
    "the following well - known characterization of answer sets is often invoked when considering the complexity of deciding the existence of answer sets .",
    "[ prop:1 ] the following statements are equivalent for any program @xmath53 and any set @xmath65 of atoms :    1 .",
    "@xmath81 , 2 .",
    "@xmath65 is a model of @xmath53 and a minimal model of @xmath82 , and 3 .",
    "@xmath65 is a model of  @xmath83 and @xmath84 .",
    "this result identifies testing whether an interpretation  @xmath65 is a minimal model of @xmath82 as the key task in deciding whether @xmath65 is an answer set of @xmath53 . for normal programs checking that @xmath65 is a minimal model of @xmath82 is easy .",
    "one just needs to compute the least model of the horn program  @xmath82 and check whether it matches @xmath65 .",
    "the general case requires more work .",
    "a possible approach is to reduce the task to that of deciding whether certain programs derived from @xmath82 have models .",
    "specifically , define for a program  @xmath53 and an atom @xmath85 @xmath86 with this notation , we can restate condition  ( 2 ) in proposition  [ prop:1 ] .",
    "[ prop:2 ] an interpretation  @xmath65 is an answer set of a program  @xmath53 if and only if @xmath65 is a model of @xmath53 and for each  @xmath87 , the program  @xmath88 has no models .",
    "clearly , if a program @xmath53 is dual - normal , the programs @xmath88 all are dual - horn . combining propositions  [ prop:4 ] and [ prop:2 ] yields the following corollary , as well as an efficient algorithm for checking whether @xmath65 is an answer set of @xmath53 .",
    "[ cor:1 ] let @xmath53 be a dual - normal program .",
    "an interpretation @xmath65 is an answer set of @xmath53 if and only if @xmath65 is a model of @xmath53 and for every @xmath87 , @xmath89 , where @xmath69 are the sets computed based on @xmath90 $ ] .",
    "in this section , we encode dual - normal programs as propositional formulas so that the models of the resulting formulas encode the answer sets of the original programs . the main idea is to non - deterministically check for every interpretation whether it is an answer set of  @xmath53 . in other words ,",
    "we encode into our formula a guess of an interpretation and the efficient algorithm described above to check whether it has models ( cf .",
    "corollary  [ cor:1 ] ) .",
    "note that the latter part is dual to the horn encoding by  @xcite  .",
    "let @xmath53 be a program and @xmath91 .",
    "the propositional variables in our encodings are given by all atoms  @xmath92 , a fresh variable  @xmath57 , and fresh variables  @xmath93 , for @xmath94 , @xmath95 , and @xmath96 .",
    "we use the variables  @xmath93 and @xmath97 to simulate the computation of @xmath98 based on the program @xmath90 $ ] , when testing minimality of an interpretation  @xmath65 by trying to exclude @xmath34 ( cf .",
    "corollary  [ cor:1 ] ) .",
    "the superscript  @xmath99 generates copies of atoms that represent the set  @xmath69 .",
    "moreover , we write @xmath100 as a shorthand for @xmath101 and we write @xmath102 to indicate that a set  @xmath69 is considered with respect to @xmath90 $ ] instead of @xmath103 $ ] .    the following auxiliary formulas simulate , according to corollary  [ cor:1 ] , an inductive top - down computation of the maximal models of  @xmath90 $ ] , where @xmath65 is an interpretation and @xmath104 . since @xmath90 $ ] is dual - horn",
    "the main part of our first auxiliary formulas is the encoding of the set  @xmath105 where @xmath104 and @xmath96 ( cf .",
    "proposition  [ prop:4 ] properties  ( 1 ) and ( 2 ) ) .    for the initial level  0 , the following formula  @xmath106 encodes @xmath107 .",
    "that is , it ensures that @xmath34 does not belong to a model of @xmath106 and all other variables belong to a model of @xmath106 if and only if they do for the current interpretation over  @xmath54 : @xmath108    the next formula encodes the set  @xmath109 . in other words , we ensure that an atom  @xmath110 does not belong to the model if and only if there is a rule  @xmath111 $ ] where already all atoms in the head do not belong to the model ( according to the previous step ) , and analogously for @xmath97 : @xmath112 @xmath113 note that in @xmath114 the heads are evaluated with respect to the previous level while the negative bodies are evaluated with respect to the current model candidate , thus simulating the concept of reduct inherent in @xmath90 $ ] .",
    "finally , the following auxiliary formula encodes the condition that an interpretation satisfies each rule  @xmath115 : @xmath116 we now put these formulas together to obtain a formula  @xmath117 expressing that some interpretation @xmath118 is a model of @xmath53 and for every atom @xmath119 , atom  @xmath120 does not belong to the maximal model of  @xmath121 $ ] : @xmath122.\\end{aligned}\\ ] ] it is easy to see that the formula  @xmath117 is of size  @xmath123 , where @xmath124 stands for the size of @xmath53 , and obviously we can construct it in polynomial time from @xmath53 . the correctness of the translation is formally stated in the following result .",
    "let @xmath53 be a dual - normal program .",
    "then , @xmath125 , where @xmath126 denotes the set of all models of @xmath23 .",
    "our encoding can be improved by means of an explicit encoding of the induction levels using counters ( see  e.g. ,  @xcite ) .",
    "this allows to reduce the size of the encoding to @xmath127 .",
    "we now provide a polynomial - time translation from programs to programs that allows us to swap heads with positive bodies .",
    "it serves several purposes .",
    "( 1 )  the translation delivers a normal program when the input program is dual - normal , and it delivers a dual - normal program when the input is normal .",
    "given the complexity results by  @xcite  , the existence of such translations is not surprising .",
    "however , the fact that there exists a _",
    "single _ bidirectional translation , not tailored to any specific program class , is interesting .",
    "( 2 )  when applied to head - cycle free programs  @xcite , the translation results in programs that we call _ body - cycle _ free .",
    "body - cycle free programs are in many respects dual to head - cycle free ones .",
    "to proceed , we need one more technical result which provides yet another characterization of answer sets of programs .",
    "it is closely related to the one given by corollary  [ cor:1 ] but more convenient to use when analyzing the translation we give below .",
    "let @xmath53 be a program and @xmath57 a fresh atom .",
    "for every pair of atoms  @xmath128 , where @xmath129 and @xmath130 we introduce a fresh atom  @xmath131 , as an auxiliary atom representing a copy of  @xmath132 in @xmath53 with respect to @xmath133 ; we clarify the role of these atoms below after the proof of proposition [ prop:5 ] .    moreover , for every set  @xmath134 , let @xmath135 . with this notation in hand , we define @xmath136\\},\\end{aligned}\\ ] ] and we write @xmath137 for @xmath138 and @xmath139 for @xmath140 .",
    "[ prop:5 ] let @xmath53 be a program .",
    "an interpretation  @xmath118 is an answer set of @xmath53 if and only if @xmath65 is a model of @xmath53 , and for every  @xmath141 , @xmath142 belongs to every minimal model of @xmath143 .",
    "( @xmath144 ) since @xmath65 is a model of @xmath53 , @xmath65 is a model of @xmath145 .",
    "thus , @xmath65 is a model of @xmath82 . by proposition [ prop:1 ]",
    ", it suffices to show that @xmath65 is a minimal model of @xmath82 .",
    "let us assume that for some  @xmath146 , @xmath147 .",
    "let @xmath148 .",
    "finally , let us set @xmath149 .",
    "we will show that @xmath150 is a model of @xmath151 . to this end , let us consider a rule  @xmath152 in @xmath151 such that @xmath153 , and assume that @xmath154 .",
    "it follows that @xmath155 .",
    "since the rule  @xmath156 belongs to @xmath82 , @xmath157 , and @xmath158 , we have @xmath159 .",
    "thus , @xmath160 and so , @xmath161 .",
    "hence , @xmath162 .",
    "next , let us consider a rule  @xmath163 in @xmath151 .",
    "since @xmath164 is a rule in @xmath82 and @xmath147 , we have @xmath165 .",
    "thus , @xmath166 and so , @xmath167 .",
    "consequently , @xmath168 .",
    "since @xmath169 , it follows that @xmath170 . since @xmath171 , @xmath172 .",
    "thus , there is a minimal model of @xmath143 that does not contain @xmath142 , a contradiction ( each minimal model of @xmath173 contained in @xmath150 has this property ) .",
    "( @xmath174 ) since @xmath175 , @xmath65 is a model of @xmath53 .",
    "let us assume that for some  @xmath141 and for some minimal model  @xmath150 of @xmath176 , @xmath172 .",
    "let us define @xmath177 .",
    "since @xmath178 , @xmath179 is a subset of @xmath180 .",
    "reasoning similarly as before , we can show that @xmath179 is a model of @xmath82 .",
    "this is a contradiction , as @xmath65 is minimal model of @xmath82 .",
    "thus , the assertion follows by proposition [ prop:1 ] .    by proposition  [ prop:5 ] checking whether @xmath65 is an answer set of @xmath53 requires to verify a certain condition for every @xmath181 .",
    "that condition could be formulated in terms of atoms in @xmath182 ( by dropping the subscripts @xmath133 in the atoms of the program @xmath183 and in the condition ) . however",
    ", if a single normal program is to represent the condition for all @xmath141 together , we have to combine the programs @xmath183 . to avoid unwanted interactions",
    ", we first have to standardize the programs apart .",
    "this is the reason why we introduce atoms @xmath131 and use them to define copies of @xmath183 customized to individual @xmath133 s .",
    "given a program  @xmath53 and the customized programs @xmath183 , we now describe the promised translation . to this end , for every atom  @xmath129 , we introduce a fresh atom  @xmath184 .",
    "we set :    @xmath185\\\\    { \\ensuremath{p_{\\text{aux } } } } = & \\{x_x { \\leftarrow}\\neg{\\overline{x } } { ; \\;}y_x { \\leftarrow}\\neg{\\overline{x } } , \\neg y { \\;{|}\\;}x , y\\in { \\text{\\normalfont at}}(p)\\}\\displaybreak[1]\\\\    { \\ensuremath{p_{\\text{diag } } } } = &   { \\ensuremath{p_{\\text{xor}}}}\\cup { \\ensuremath{p_{\\text{aux } } } } \\nonumber\\cup\\bigcup_{x\\in { \\text{\\normalfont at}}(p ) }                   p_x\\displaybreak[1]\\\\    { \\ensuremath{p_{\\text{mod } } } } = & \\{\\bot { \\leftarrow}{\\ensuremath{\\neg}}{h } , b^+,{\\ensuremath{\\neg}}b^-{\\;{|}\\;}h{\\leftarrow}b^+,{\\ensuremath{\\neg}}b^-\\in p\\}\\\\    { \\ensuremath{p_{\\text{true } } } } = & \\{\\bot { \\leftarrow}x , { \\ensuremath{\\neg}}t_x{\\;{|}\\;}x\\in { \\text{\\normalfont at}}(p)\\}\\displaybreak[1]\\\\    { \\ensuremath{p_{\\mathrm{trans } } } } = & { \\ensuremath{p_{\\text{diag}}}}\\nonumber\\cup { \\ensuremath{p_{\\text{mod } } } } \\cup { \\ensuremath{p_{\\text{true}}}}\\end{aligned}\\ ] ]    the following observations are immediate and central :    1 .   for a dual - normal program  @xmath53",
    ", @xmath186 is normal .",
    "2 .   for a normal program  @xmath53",
    ", @xmath186 is dual - normal .",
    "hence , the following result not only establishes the connection between the answer sets of @xmath53 and @xmath186 but also proves that the transformation encodes dual - normal as normal programs , as desired , and at the same time , encodes normal programs as dual - normal ones .",
    "moreover , the transformation can be implemented to run in polynomial time and so , produces polynomial - size programs .",
    "[ thm : trans2 ] let @xmath53 be a program , @xmath187 , @xmath188 and @xmath189",
    ". then @xmath175 if and only if for every minimal model  @xmath179 of @xmath190 , @xmath191 . moreover , every answer set of @xmath186 is of the form @xmath192 for @xmath118 and a minimal model  @xmath179 of @xmath190 .",
    "( @xmath174 ) let @xmath65 be an answer set of @xmath53 and let @xmath179 be any minimal model of  @xmath190 . since @xmath65 is a model of @xmath53 by proposition  [ prop:1 ] , @xmath192 satisfies all constraints in  @xmath193 .",
    "proposition  [ prop:5 ] implies that for every  @xmath181 , @xmath194 .",
    "thus , @xmath192 also satisfies all constraints in  @xmath195 . to prove that @xmath191 it remains to show that @xmath196 ( cf .",
    "proposition  [ prop:1 ] ) . to this end",
    ", we observe that , for each @xmath197 , @xmath198 and thus @xmath199 .",
    "since all rules in @xmath200 have a nonempty body that is disjoint with @xmath192 , and since @xmath179 is a model of @xmath201 , @xmath192 is a model of @xmath202 . since @xmath179 is a minimal model of  @xmath190",
    ", @xmath192 is a minimal model of @xmath202 .",
    "( @xmath144 ) let @xmath179 be a minimal model of  @xmath190 and @xmath192 an answer set of @xmath186 .",
    "clearly , @xmath192 satisfies the constraints in  @xmath193 and so , @xmath65 is a model of @xmath53 .",
    "let @xmath141 .",
    "since @xmath192 satisfies all constraints in  @xmath195 , @xmath203 . thus , @xmath194 . by proposition  [ prop:5 ]",
    ", @xmath65 is an answer set of @xmath53 .    to prove the second part of the assertion ,",
    "let us consider an answer set  @xmath204 of @xmath186 .",
    "let us define @xmath205 .",
    "because of the rules in  @xmath206 , @xmath207 for some set  @xmath208 . by proposition  [ prop:1 ] , @xmath204 is an answer set of @xmath209 that is , @xmath204 is a minimal model of @xmath210 . as above , we have @xmath211 and conclude that @xmath179 is a minimal model of  @xmath190 .",
    "our translation allows us to extend the class of dual - normal programs so that the problem to decide the existence of answer sets remains within the first level of the polynomial hierarchy .",
    "we recall that a program  @xmath53 is _ head - cycle free @xmath212hcf@xmath213 _",
    "@xcite if the positive dependency digraph of @xmath53 has no directed cycle that contains two atoms belonging to the head of a rule in  @xmath53 .",
    "the _ positive dependency digraph _ of @xmath53 has as vertices the atoms  @xmath54 and a directed edge  @xmath214 between any two atoms  @xmath215 for which there is a rule  @xmath61 with @xmath216 and @xmath217 .",
    "it is well known that it is -complete to decide whether a head - cycle free program has an answer set .",
    "the class of hcf programs arguably is the most natural class of programs that contains all normal programs and for which deciding the existence of answer sets is -complete .",
    "we now define a program  @xmath53 to be _ body - cycle free @xmath212bcf@xmath213 _ if the positive dependency graph of @xmath53 , has no directed cycle that contains two atoms belonging to the _ positive body _ of a rule in @xmath53 .",
    "in analogy to hcf programs , bcf programs trivially contain the class of dual - normal programs .",
    "inspecting our translation , yields the following observations :    1 .   for a hcf program  @xmath53 , @xmath186 is bcf .",
    "2 .   for a bcf program  @xmath53 , @xmath186 is hcf .",
    "since @xmath186 is efficiently obtained from  @xmath53 , the following result is a direct consequence of theorem  [ thm : trans2 ] and the fact that the consistency problem for hcf programs is -complete .",
    "[ thm : bcf ] the problem to decide whether a bcf program  @xmath53 has an answer set is -complete .",
    "the translation @xmath186 preserves the cycle - freeness of the positive dependency graph ( the positive dependency graph of @xmath53 is cycle - free if and only if the positive dependency graph of @xmath186 is cycle - free ) . that is essential for our derivation of theorem  [ thm : bcf ]",
    "however , in general , there is no one - to - one correspondence between answer sets of @xmath53 and answer sets of @xmath186 .",
    "thus , as a final result in this section , we provide a slight adaption of the translation  @xmath186 in which the answer sets of programs  @xmath53 and @xmath186 are in a _",
    "one - to - one correspondence_. to this end define , @xmath218 .",
    "note that @xmath219 still turns dual - normal programs to normal programs and vice versa , but we lose the property that cycle - freeness is preserved ( the new rules may introduce additional cycles in the positive dependency graph ) .",
    "thus , both theorem  [ thm : trans2 ] and theorem  [ thm : trans3 ] are of interest .",
    "[ thm : trans3 ] let @xmath53 be a program , @xmath118 and @xmath220 as in theorem  [ thm : trans2 ] . then , @xmath175 if and only if @xmath221 .",
    "moreover , every answer set of @xmath222 is of the form  @xmath223 for some  @xmath118 .",
    "se - models , originating from the work by  @xcite  , and ue - models , proposed by  @xcite  , characterize strong and uniform equivalence of programs , respectively .",
    "more recently , they turned out to be useful also for comparing program classes with respect to their expressivity ( see e.g. , work by  @xcite  ) . in",
    "what follows , we first recall the main results from the literature , focusing on disjunctive and normal programs . then , we complement these results by characterizations of collections of se- and ue - models of dual - normal programs . finally , we strengthen existing complexity results .      an _ se - interpretation _ is a pair  @xmath224 of sets of atoms such that @xmath225 .",
    "we denote by  @xmath226 the class  @xmath227 of all se - interpretations over  @xmath228 .",
    "an se - interpretation  @xmath224 is an _ se - model _ of a program  @xmath53 , written @xmath229 , if @xmath230 and @xmath231 .",
    "se - models of a program @xmath53 contain , in particular , all information needed to identify the answer sets of @xmath53 .",
    "specifically , @xmath25 is an answer set of @xmath53 if and only if @xmath232 is an se - model of @xmath53 and for every @xmath233 , @xmath234 is not .",
    "an se - model  @xmath224 of a program  @xmath53 is a _ ue - model _ of @xmath53 if for every se - model  @xmath235 of @xmath53 such that @xmath236 , @xmath237 holds .",
    "we write @xmath238 ( @xmath239 ) for all se - interpretations that are se - models ( ue - models ) of a program  @xmath53 .",
    "programs  @xmath53 and @xmath240 are _ equivalent _ , denoted by  @xmath241 , if @xmath53 and @xmath240 have the same answer sets .",
    "they are _ strongly equivalent _ , denoted by  @xmath242 , if for every program  @xmath243 , @xmath244 ; and _ uniformly equivalent _ , denoted @xmath245 , if for every set  @xmath23 of normal facts , @xmath246 .",
    "the main results concerning these notions are ( 1 )  @xmath242 if and only if @xmath247  @xcite and ( 2 )  @xmath245 if and only if @xmath248  @xcite .",
    "we now recall definitions of useful properties of sets of se - interpretations  @xcite .",
    "a set  @xmath249 of se - interpretations is _ complete _ if    1 .",
    "@xmath250 implies @xmath251 ; and 2 .",
    "@xmath224 , @xmath252 and @xmath253 imply @xmath254 .",
    "next , @xmath249 is _ closed under here - intersection _ if for all  @xmath255 we have @xmath256 . finally , @xmath249 is _ ue - complete _ if    1 .",
    "@xmath257 implies @xmath258 ; 2 .",
    "@xmath259 and @xmath260 imply that there is @xmath261 such that @xmath262 and @xmath263 ; and 3 .",
    "@xmath264 and @xmath236 imply @xmath237 .",
    "the following results are due to  @xcite  .",
    "for each program  @xmath53 , @xmath238 is complete .",
    "conversely , for every complete set  @xmath265 there is a program  @xmath53 with @xmath266 and @xmath267 . for each normal program  @xmath53 , @xmath238 is complete and closed under here - intersection .",
    "conversely , for every set  @xmath249 of se - interpretations over  @xmath204 that is complete and closed under here - intersection there is a normal program  @xmath53 with @xmath268 and @xmath267 .",
    "next , for every program  @xmath53 , @xmath239 is ue - complete .",
    "conversely , for every ue - complete set  @xmath269 of se - interpretations over  @xmath204 there is a normal program  @xmath53 such that @xmath270 and @xmath271 .",
    "hence , for every disjunctive program  @xmath53 there exists a normal program  @xmath190 with @xmath272 ( however , such @xmath190 can be exponentially larger than @xmath53  @xcite ) . finally , we make use of the following technical result .    [",
    "lem : se ] for every se - interpretation  @xmath224 , @xmath273 if and only if at least one of the following conditions holds :    1 .",
    "[ lem : se : a ] @xmath274 ; 2 .",
    "[ lem : se : b ] @xmath275 ; 3 .",
    "[ lem : se : c ] @xmath276 ; 4 .",
    "[ lem : se : d ] @xmath277 and @xmath278 .",
    "[ [ properties - of - dual - normal - programs . ] ] properties of dual - normal programs .",
    "+ + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + +    our results rely on some new classes of sets of se - interpretations .",
    "first , we introduce sets of se - interpretations that are closed under here - union .",
    "this is the dual concept to sets closed under here - intersection .",
    "we will use it to characterize the se - models of dual - normal programs . to characterize the ue models of dual - normal programs we need an additional , quite involved , concept of a splittable set .",
    "a set  @xmath249 of se - interpretations is called    1 .",
    "_ closed under here - union _ if for any  @xmath257 and @xmath279 , also @xmath280 ; 2 .   _",
    "splittable _ if for every  @xmath228 such that @xmath281 and every  @xmath282 such that @xmath283 ( @xmath284 ) , @xmath285 or @xmath286 for some  @xmath287 , such that @xmath288 .",
    "neither property implies the other in general .",
    "however , for ue - complete sets of se - interpretations , splittability implies closure under here - union .",
    "[ prop:6 ] if a ue - complete collection  @xmath249 of se - interpretations is splittable , it is closed under here - union .",
    "let @xmath289 . by ue - completeness , @xmath281 .",
    "thus , if @xmath290 then @xmath291 . otherwise , by splittability , @xmath292 for some @xmath287 such that @xmath293 and @xmath286 . since @xmath294 and @xmath295 , @xmath296 ( by condition  ( 3 ) of ue - completeness ) .",
    "consequently , @xmath297 and so , @xmath298 in this case , too .",
    "the converse does not hold , that is , for ue - complete sets , splittability is a strictly stronger concept than closure under here - union . as an example consider the set  @xmath299 that is ue - complete and closed under here - union .",
    "this set is _ not _ splittable .",
    "indeed , @xmath300 , yet there is no @xmath287 such that @xmath301 and @xmath302 .    as announced above , closure under here - union",
    "is an essential property of sets of se - models of dual - normal programs .",
    "[ thm : se:1 ] for every dual - normal program  @xmath53 , @xmath238 is complete and closed under here - union .",
    "@xmath238 is complete for every program  @xmath53 .",
    "let @xmath303 .",
    "we need to show that for every rule  @xmath304 in @xmath53 , @xmath305 . to this end , let us assume that none of conditions  ( [ lem : se : a ] ) , ( [ lem : se : b ] ) , and ( [ lem : se : c ] ) of lemma  [ lem : se ] holds for @xmath306 and @xmath28 . since @xmath307 and @xmath308 , none of conditions  ( [ lem : se",
    ": a ] ) , ( [ lem : se : b ] ) , and ( [ lem : se : c ] ) holds for @xmath224 and @xmath28 either . since @xmath309 ,",
    "condition  ( [ lem : se : d ] ) must hold , that is , we have @xmath277 and @xmath310 .",
    "the same argument applied to @xmath235 implies that also @xmath311 . since @xmath53 is dual - normal , @xmath312 and @xmath313 .",
    "thus , @xmath314 and so , condition  ( [ lem : se : d ] ) of lemma  [ lem : se ] holds for @xmath306 and @xmath28 .",
    "consequently , @xmath305 .",
    "the conditions of theorem  [ thm : se:1 ] are not only necessary but also sufficient .",
    "[ thm : dnse ] for every set  @xmath315 of se - interpretations that is complete and closed under here - union , there exists a dual - normal program  @xmath53 with @xmath266 and @xmath267 .",
    "let @xmath228 be a set of atoms , @xmath316 a set of se - interpretations that is complete and closed under here - union , and @xmath317 .",
    "consider @xmath318 such that @xmath319 . since @xmath249 is complete , for every @xmath320 , @xmath258 .",
    "thus , for every  @xmath320 , @xmath321 .",
    "we define @xmath322    clearly , @xmath323 and @xmath324 . for each  @xmath325 , we select an element  @xmath326 ( it is possible , as @xmath327 ) .",
    "similarly , for each  @xmath328 , we select an element  @xmath329 .",
    "we set @xmath330 and @xmath331 , and we define @xmath332    we note that for every  @xmath333 , @xmath334 .",
    "indeed , if @xmath325 , then @xmath335 and so , condition  ( [ lem : se : b ] ) of lemma  [ lem : se ] holds .",
    "otherwise , @xmath328 and @xmath336 .",
    "thus , condition  ( [ lem : se : a ] ) of that lemma holds . on the other hand , @xmath337 .",
    "indeed , @xmath338 and @xmath339 , so neither condition  ( [ lem : se : a ] ) nor condition  ( [ lem : se : b ] ) holds .",
    "moreover , neither condition  ( [ lem : se : c ] ) nor condition  ( [ lem : se : d ] ) holds , as @xmath340 is a constraint .",
    "next , let us consider @xmath341 , where @xmath342 , and let us define @xmath343 .",
    "we set @xmath344    if @xmath345 , let @xmath346 .",
    "since @xmath249 is closed under here - union , @xmath347 is a _ proper _ subset of @xmath348 .",
    "we select an arbitrary element  @xmath349 and define @xmath312 . otherwise , we define @xmath350 .    if @xmath351 , for each  @xmath352 , we select  @xmath353 , and we define @xmath354 . otherwise , we select any element  @xmath355 and define @xmath356 .",
    "we note that by construction , @xmath357 .",
    "next , we define @xmath358    for each  @xmath359 , we select  @xmath360 and set  @xmath361 .    finally , we define a rule  @xmath362 as @xmath363    it is easy to see that @xmath364 . indeed , by construction , @xmath365 , @xmath366 , and @xmath367 .",
    "the second condition implies that @xmath368 and @xmath369 .",
    "thus , none of the conditions  ( 1)(4 ) of lemma  [ lem : se ] holds .    we will show that for every  @xmath257 , @xmath370 .",
    "first , assume that @xmath371 .",
    "it follows that @xmath372 and so , @xmath373 .",
    "thus , @xmath370 by condition  ( [ lem : se : a ] ) .",
    "assume that @xmath374 .",
    "since @xmath250 and @xmath375 , @xmath376 .",
    "thus , @xmath377 . if @xmath378 , then @xmath379 and so , @xmath276 .",
    "consequently , @xmath370 by condition  ( [ lem : se : c ] ) . otherwise , @xmath380 and @xmath312 , for some  @xmath381 .",
    "in particular , @xmath310 . since @xmath250 , @xmath382 and so , @xmath383 . consequently",
    ", @xmath384 .",
    "if @xmath385 , then @xmath386 and @xmath370 by condition  ( [ lem : se : d ] ) . if @xmath387 , then @xmath388 and so , @xmath275",
    "thus , @xmath370 by condition  ( [ lem : se : b ] ) .",
    "let @xmath53 consist of all rules  @xmath340 , where @xmath318 and @xmath389 and of all rules  @xmath362 such that @xmath390 , @xmath391 and @xmath341 . clearly , @xmath392 .",
    "let @xmath341 .",
    "if @xmath393 , then @xmath337 .",
    "thus , @xmath394 .",
    "if @xmath342 , then @xmath364 .",
    "thus , @xmath394 .",
    "it follows that @xmath267 .",
    "thus the two theorems together provide a complete characterization of collections of se - interpretations that can arise as collections of se - models of dual - normal programs .",
    "we now turn to the corresponding results for sets of ue - models of dual - normal programs .",
    "the key role here is played by the notion of splittability .",
    "[ thm : ue:1 ] for every dual - normal program  @xmath53 , @xmath239 is ue - complete and splittable .",
    "the set  @xmath239 is ue - complete for every program  @xmath53 .",
    "thus , we only need to show splittability . toward this end ,",
    "let @xmath395 , where @xmath283 , for every @xmath396 .",
    "since,@xmath397 , it follows that @xmath398 ( by the second condition of completeness ) . since @xmath238 is closed under here - union , @xmath399 . if @xmath400 we are done .",
    "otherwise , @xmath401 ( since @xmath402 ) and , by the definition of ue - models and finiteness of @xmath53 , there is @xmath287 such that @xmath403 such that @xmath404 .    as before ,",
    "the conditions are also sufficient .",
    "[ thm : dnue ] for every set @xmath405 of se - interpretations that is ue - complete and splittable , there is a dual - normal program  @xmath53 with @xmath266 such that @xmath406 .    for every  @xmath228 such that @xmath407",
    ", we define @xmath408 and we denote by @xmath409 the closure of @xmath410 under union . finally , we define the _ se - closure _ @xmath411 of @xmath412 by setting @xmath413    we note that if @xmath414 , then @xmath415 . thus , @xmath410 is defined , that is , @xmath407 .",
    "consequently , @xmath416 and @xmath417 .",
    "next , assume that @xmath418 , @xmath417 , and @xmath260 .",
    "it follows that @xmath419 .",
    "thus , there are sets  @xmath420 such that @xmath421 and @xmath422 , for every @xmath284 .",
    "let us consider any such set  @xmath423 . by definition",
    ", there is a set  @xmath261 such that @xmath424 and @xmath425 . since @xmath253 , @xmath426 .",
    "it follows that @xmath427 .",
    "thus , @xmath428 .",
    "consequently , @xmath415 and @xmath429 .",
    "thus , @xmath411 is complete and , by the construction , closed under here - unions .",
    "it follows that there is a dual - normal program  @xmath53 such that @xmath430 .",
    "we will show that @xmath406 .",
    "first , let @xmath431 .",
    "it follows that @xmath432 .",
    "thus , @xmath419 and @xmath433 .",
    "consequently , @xmath434 .",
    "let us assume that for some @xmath435 , @xmath436 .",
    "since @xmath437 , @xmath438 and so , @xmath439 .",
    "thus , @xmath440 , where @xmath441 or , equivalently , @xmath442 . since @xmath443 , it follows by splittability that there is @xmath444 such that @xmath445 and @xmath446 . since @xmath447 and @xmath448",
    ", it follows that @xmath449 .",
    "consequently , @xmath450 .",
    "thus , @xmath451 , a contradiction .",
    "it follows that @xmath452 .",
    "conversely , let @xmath452 .",
    "it follows that @xmath434 and , since @xmath430 , @xmath418 . by the definition ,",
    "since @xmath453 is defined , @xmath454 .",
    "thus , if @xmath455 , the assertion follows . otherwise , @xmath233 . in this case",
    ", we reason as follows . since @xmath419 , as before we have @xmath456 , for some sets  @xmath423 , @xmath457 , such that @xmath458 . by splittability",
    ", there is @xmath261 such that @xmath446 , @xmath445 and @xmath444 .",
    "again as before , we obtain that @xmath459 and so , @xmath460 .",
    "thus , @xmath461 .",
    "we briefly discuss some implications of our results .",
    "let @xmath462 then @xmath463 and it is neither closed under here - union nor under here - intersection .",
    "thus , for @xmath53 there are no strongly equivalent programs in the classes of normal and dual - normal programs .",
    "moreover , @xmath239 is not closed under here - union and so , not splittable ( proposition  [ prop:6 ] ) .",
    "therefore there is no dual - normal program  @xmath190 such that @xmath464 ( such a normal @xmath190 exists , however ) .",
    "now let us consider the normal program @xmath465 .",
    "we have @xmath466 .",
    "since @xmath467 is not closed under here - union , there is no dual - normal program strongly equivalent to @xmath240 . finally , consider the dual - normal program @xmath468 .",
    "we have @xmath469 .",
    "since @xmath470 is not closed under here - intersection , there is no normal program strongly equivalent to @xmath243 .",
    "we complement the following known results  @xcite : checking strong equivalence between programs is @xmath471-complete ; tractability is only known for the case when both programs are horn .",
    "checking uniform equivalence between programs is @xmath472-complete . if one of the programs is normal , then the problem is @xmath471-complete .",
    "[ the : comp - strong ] checking strong equivalence between singular programs remains @xmath471-hard .",
    "take the standard reduction from unsat(as e.g.  used by  @xcite  ) and let @xmath473 .",
    "define the singular program @xmath474 = & \\ { v{\\leftarrow}{\\ensuremath{\\neg}}\\bar{v}{;\\;}\\bar{v}{\\leftarrow}{\\ensuremath{\\neg}}v{;\\;}{\\leftarrow}v,{\\ensuremath{\\neg}}{v } { \\;{|}\\;}v\\in { \\text{\\normalfont at}}(f)\\ } \\cup           \\ { { \\leftarrow}{\\ensuremath{\\neg}}l^*_{i1 } , { \\ensuremath{\\neg}}l^*_{i2 } , { \\ensuremath{\\neg}}l^*_{i3 } { \\;{|}\\;}1\\leq i \\leq n              \\ }    \\end{aligned}\\ ] ] where @xmath475 for positive literals and @xmath476 for negative ones . one can show that @xmath23 is a positive instance of unsatif and only if @xmath3{\\equiv_{s}}\\{a { \\leftarrow}{;\\;}{\\leftarrow}a\\}$ ] . since the reduction works in polynomial time , @xmath471-hardness follows .",
    "checking uniform equivalence between dual - normal programs is @xmath471-complete .",
    "hardness holds even in the case the programs are singular .    for membership , consider the following algorithm for the complementary problem . we guess @xmath224 and check whether @xmath477 or @xmath478 .",
    "checking whether @xmath452 can be done efficiently : first check @xmath479 which reduces to classical model checking .",
    "if the test fails or @xmath455 we are done .",
    "otherwise , we compute for each  @xmath480 the maximal models of the dual - horn theories @xmath481 this can be done in polynomial time , too .",
    "if all maximal models are equal to @xmath348 , we return true ; otherwise false . for hardness",
    ", one can employ the reduction used in the proof of theorem  6.6 in  @xcite .",
    "we studied properties of dual - normal programs , the `` forgotten '' class of disjunctive programs , for which deciding the existence of answer sets remains -complete .",
    "we provided translations of dual - normal programs to propositional theories and to normal programs , and characterizations of sets of se - interpretations that arise as sets of se- and ue - models of dual - normal programs .",
    "we also established the -completeness of deciding strong and uniform equivalence between dual - normal programs , showing hardness even under additional syntactic restrictions .",
    "our paper raises several interesting issues for future work .",
    "first , the bcf programs that we introduced as a generalization of dual - normal programs deserve further study because of their duality to hcf programs , and good computational properties ( -completeness of deciding existence of answer sets ) .",
    "we believe that bcf programs provide a promising class to encode certain problems , since they also allow certain conjunctions in the positive body .",
    "recall that the operation of _ shifting _ transforms hcf programs into normal ones while preserving the answer sets  @xcite .",
    "an analog of shifting for bcf programs would introduce negations in the heads of the rules .",
    "thus , we plan to explore shifting within the broader setting of lifschitz - woo programs  @xcite . on the other hand , singular programs , another class of programs we introduced , deserve attention due to their simplicity",
    " they are both normal and dual - normal . as concerns dual - normal programs themselves , the key question is to establish whether more concise translations to satand normal programs are possible , as such translations may lead to effective ways of computing answer sets .",
    "thomas eiter and michael fink .",
    "uniform equivalence of logic programs under the stable model semantics . in _",
    "proceedings 19th international conference on logic programming ( iclp 2003 ) _ , volume 2916 of _ lncs _ , pages 224238 .",
    "springer , 2003 .",
    "thomas eiter , michael fink , hans tompits , and stefan woltran . on eliminating disjunctions in stable logic programming .",
    "in _ proceedings of the 9th international conference on principles of knowledge representation and reasoning ( kr 2004 ) _ , pages 447458 . the aaai press , 2004 .",
    "johannes  klaus fichte and stefan szeider .",
    "backdoors to normality for disjunctive logic programs . in _ proceedings of the 27th aaai conference on artificial intelligence ( aaai 2013 ) _ , pages 320327 . the aaai press , 2013 .",
    "carito guziolowski , santiago videla , federica eduati , sven thiele , thomas cokelaer , anne siegel , and julio saez - rodriguez .",
    "exhaustively characterizing feasible logic models of a signaling network using answer set programming .",
    ", 29(18):23202326 , 2013 .",
    "erratum see bioinformatics 30 , 13 , 1942 .",
    "vladimir lifschitz and thomas  y.c . woo .",
    "answer sets in general nonmonotonic reasoning . in _ proceedings of the 3rd international conference on principles of knowledge representation and reasoning ( kr 1992 ) _ , pages 603614 .",
    "morgan kaufmann , 1992 .",
    "monica nogueira , marcello balduccini , michael gelfond , richard watson , and matthew barry .",
    "an a - prolog decision support system for the space shuttle . in",
    "_ proceedings of the 3rd international symposium on practical aspects of declarative language ( padl 2001 ) _ , volume 1990 of _ lncs _ , pages 169183 .",
    "springer , 2001 .",
    "timo soininen and ilkka niemel .",
    "developing a declarative rule language for applications in product configuration . in _ proceedings of the 1st international workshop on practical aspects of declarative languages (",
    "padl 1999 ) _ , volume 1551 of _ lncs _ , pages 305319 .",
    "springer , 1998 .",
    "hudson turner .",
    "strong equivalence for logic programs and default theories ( made easy ) . in thomas eiter , wolfgang faber , and miroslaw truszczyski , editors , _ proceedings of the 6th international conference on logic programming and nonmotonic reasoning ( lpnmr 2001 ) _ ,",
    "volume 2173 of _ lncs _ , pages 8192 , vienna , austria , september 2001 ."
  ],
  "abstract_text": [
    "<S> disjunctive answer set programming is a powerful declarative programming paradigm with complexity beyond . identifying classes of programs for which the consistency problem is in is of interest from the theoretical standpoint and can potentially lead to improvements in the design of answer set programming solvers . </S>",
    "<S> one of such classes consists of _ dual - normal programs _ </S>",
    "<S> , where the number of positive body atoms in proper rules is at most one . unlike other classes of programs , </S>",
    "<S> dual - normal programs have received little attention so far . in this paper </S>",
    "<S> we study this class . </S>",
    "<S> we relate dual - normal programs to propositional theories and to normal programs by presenting several inter - translations . with the translation from dual - normal to normal programs at hand </S>",
    "<S> , we introduce the novel class of _ body - cycle _ free programs , which are in many respects dual to head - cycle free programs . </S>",
    "<S> we establish the expressive power of dual - normal programs in terms of se- and ue - models , and compare them to normal programs . </S>",
    "<S> we also discuss the complexity of deciding whether dual - normal programs are strongly and uniformly equivalent . </S>"
  ]
}