{
  "article_text": [
    "spherical harmonics are the eigenfunctions of the laplace operator on the 2-sphere .",
    "they form a basis and are useful and convenient to describe data on a sphere in a consistent way in spectral space .",
    "spherical harmonic transforms ( sht ) are the spherical counterpart of the fourier transform , casting spatial data to the spectral domain and vice versa .",
    "they are commonly used in various pseudo - spectral direct numerical simulations in spherical geometry , for simulating the sun or the liquid core of the earth among others @xcite .",
    "all numerical simulations that take advantage of spherical harmonics use the classical gauss - legendre algorithm ( see section [ sec : sht ] ) with complexity @xmath0 for a truncation at spherical harmonic degree @xmath1 . as a consequence of this high computational cost when @xmath1 increases , high resolution spherical codes currently spend most of their time performing sht .",
    "a few years ago , state of the art numerical simulations used @xmath3 @xcite .",
    "however , there exist several asymptotically fast algorithms @xcite , but the overhead for these fast algorithms is such that they do not claim to be effectively faster for @xmath4 .",
    "in addition , some of them lack stability ( the error becomes too large even for moderate @xmath1 ) and flexibility ( e.g. @xmath5 must be a power of 2 ) .    among the asymptotically fast algorithms ,",
    "only two have open - source implementations , and the only one which seems to perform reasonably well is ` spharmonickit ` , based on the algorithms described by @xcite .",
    "its main drawback is the need of a latitudinal grid of size @xmath6 while the gauss - legendre quadrature allows the use of only @xmath5 collocation points .",
    "thus , even if it were as fast as the gauss - legendre approach for the same truncation @xmath1 , the overall numerical simulation would be slower because it would operate on twice as many points .",
    "these facts explain why the gauss - legendre algorithm is still the most efficient solution for numerical simulations .    a recent paper @xcite reports that carefully tuned software could finally run 9 times faster on the same cpu than the initial non - optimized version , and insists on the importance of vectorization and careful optimization of the code . as the goal of this work is to speed - up numerical simulations",
    ", we have written a highly optimized and explicitly vectorized version of the gauss - legendre sht algorithm .",
    "the next section recalls the basics of spherical harmonic transforms .",
    "we then describe the optimizations we use and we compare the performance of our transform to other sht implementations .",
    "we conclude this paper by a short summary and perspectives for future developments .",
    "the orthonormalized spherical harmonics of degree @xmath7 and order @xmath8 are functions defined on the sphere as : @xmath9 where @xmath10 is the colatitude , @xmath11 is the longitude and @xmath12 are the associated legendre polynomials normalized for spherical harmonics @xmath13 which involve derivatives of legendre polynomials @xmath14 defined by the following recurrence : @xmath15    the spherical harmonics @xmath16 form an orthonormal basis for functions defined on the sphere : @xmath17 with @xmath18 the kronecker symbol . by construction",
    ", they are eigenfunctions of the laplace operator on the unit sphere : @xmath19 this property is very appealing for solving many physical problems in spherical geometry involving the laplace operator .",
    "the spherical harmonic synthesis is the evaluation of the sum @xmath20 up to degree @xmath21 , given the complex coefficients @xmath22 . if @xmath23 is a real - valued function , @xmath24 , where @xmath25 stands for the complex conjugate of @xmath26 .",
    "the sums can be exchanged , and using the expression of @xmath27 we can write @xmath28 from this last expression , it appears that the summation over @xmath29 is a regular fourier transform .",
    "hence the remaining task is to evaluate @xmath30 or its discrete version at given collocation points @xmath31 .",
    "the analysis step of the sht consists in computing the coefficients @xmath32 the integral over @xmath11 is obtained using the fourier transform : @xmath33 so the remaining legendre transform reads @xmath34 the discrete problem reduces to the appropriate quadrature rule to evaluate the integral ( [ eq : analysis ] ) knowing only the values @xmath35 . in particular , the use of the gauss - legendre quadrature replaces the integral of expression [ eq : analysis ] by the sum @xmath36 where @xmath31 and @xmath37 are respectively the gauss nodes and weights @xcite .",
    "note that the sum equals the integral if @xmath38 is a polynomial in @xmath39 of order @xmath40 or less .",
    "if @xmath41 is given by expression [ eq : synth_direct ] , then @xmath38 is always a polynomial in @xmath39 , of degree at most @xmath42 .",
    "hence the gauss - legendre quadrature is exact for @xmath43 .",
    "a discrete spherical harmonic transform using gauss nodes as latitudinal grid points and a gauss - legendre quadrature for the analysis step is referred to as a gauss - legendre algorithm .",
    "let us first recall some standard optimizations found in almost every serious implementation of the gauss - legendre algorithm .",
    "all the following optimizations are used in the ` shtns ` library .    [",
    "[ use - the - fast - fourier - transform ] ] use the fast - fourier transform + + + + + + + + + + + + + + + + + + + + + + + + + + + + + +    the expressions of section [ sec : sht ] show that part of the sht is in fact a fourier transform .",
    "the fast fourier transform ( fft ) should be used for this part , as it improves accuracy and speed . `",
    "shtns ` uses the ` fftw ` library@xcite , a portable , flexible and highly efficient fft implementation .",
    "[ [ take - advantage - of - hermitian - symmetry - for - real - data ] ] take advantage of hermitian symmetry for real data + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + +    when dealing with real - valued data , the spectral coefficients fulfill @xmath44 , so we only need to store them for @xmath45 .",
    "this also allows the use of faster real - valued ffts .    [",
    "[ take - advantage - of - mirror - symmetry ] ] take advantage of mirror symmetry + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + +    due to the defined symmetry of spherical harmonics with respect to a reflection about the equator @xmath46 one can reduce by a factor of 2 the operation count of both forward and inverse transforms .     and",
    "order @xmath47 ( blue ) and @xmath48 ( red ) , showing the localization near the equator.,scaledwidth=70.0% ]    [ [ precompute - values - of - p_nm ] ] precompute values of @xmath12 + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + +    the coefficients @xmath49 appear in both synthesis and analysis expressions ( [ eq : synth_direct ] and [ eq : analysis ] ) , and can be precomputed and stored for all ( @xmath7,@xmath29,@xmath50 ) .",
    "when performing multiple transforms , it avoids computing the legendre polynomial recursion at every transform and saves some computing power , at the expense of memory bandwidth .",
    "this may or may not be efficient , as we will discuss later .",
    "[ [ polar - optimization ] ] polar optimization + + + + + + + + + + + + + + + + + +    high order spherical harmonics have their magnitude decrease exponentially when approaching the poles as shown in figure [ fig : polar ] .",
    "hence , the integral of expression [ eq : analysis ] can be reduced to @xmath51 where @xmath52 is a threshold below which @xmath12 is considered to be zero .",
    "similarly , the synthesis of @xmath41 ( eq . [ eq : synth_direct ] ) is only needed for @xmath53 . `",
    "shtns ` uses a threshold @xmath54 that does not depend on @xmath7 , which leads to around 5% to 20% speed increase , depending on the desired accuracy and the truncation @xmath1 .",
    "it can be shown that @xmath55 can be computed recursively by @xmath56 with @xmath57 the coefficients @xmath58 and @xmath59 do not depend on @xmath60 , and can be easily precomputed and stored into an array of @xmath61 values .",
    "this has to be compared to the order @xmath62 values of @xmath63 , which are usually precomputed and stored in the spherical harmonic transforms implemented in numerical simulations .",
    "the amount of memory required to store all @xmath63 in double - precision is at least @xmath64 bytes , which gives 2 gb for @xmath2 .",
    "our on - the - fly algorithm only needs about @xmath65 bytes of storage ( same size as a spectral representation @xmath22 ) , that is 8 mb for @xmath2 .",
    "when @xmath1 becomes very large , it is no longer possible to store @xmath63 in memory ( for @xmath66 nowadays ) and on - the - fly algorithms ( which recompute @xmath63 from the recurrence relation when needed ) are then the only possibility .",
    "we would like to stress that even far from that storage limit , on - the - fly algorithm can be significantly faster thanks to vector capabilities of modern processors .",
    "most desktop and laptop computers , as well as many high performance computing clusters , have support for single - instruction - multiple - data ( simd ) operations in double precision .",
    "the sse2 instruction set is available since year 2000 and currently supported by almost every pc , allowing to perform the same double precision arithmetic operations on a vector of 2 double precision numbers , effectively doubling the computing power .",
    "the recently introduced avx instruction set increases the vector size to 4 double precision numbers .",
    "this means that @xmath55 can be computed from the recursion relation [ eq : rec ] ( which requires 3 multiplications and 1 addition ) for 2 or 4 values of @xmath60 simultaneously , which may be faster than loading pre - computed values from memory . hence , as already pointed out by @xcite , it is therefore very important to use the vector capabilities of modern processors to address their full computing power .",
    "furthermore , when running multiple transforms on the different cores of a computer , the performance of on - the - fly transforms ( which use less memory bandwidth ) scales much better than algorithms with precomputed matrices , because the memory bandwidth is shared between cores .",
    "superscalar architectures that do not have double - precision simd instructions but have many computation units per core ( like the power7 or sparc64 ) could also benefit from on - the - fly transforms by saturating the many computation units with independent computations ( at different @xmath60 ) .        figure [ fig : avx ] shows the benefit of explicit vectorization of on - the - fly algorithms on an intel xeon e5 - 2680 ( _ sandy bridge _ architecture with avx instruction set running at 2.7ghz ) and compares on - the - fly algorithms with algorithms based on precomputed matrices . with the 4-vectors of avx ,",
    "the fastest algorithm is always on - the - fly , while for 2-vectors , the fastest algorithm uses precomputed matrices for @xmath67 . in the forthcoming years",
    ", wider vector architecture are expected to become widely available , and the benefits of on - the - fly vectorized transforms will become even more important .    [ [ runtime - tuning ] ] runtime tuning + + + + + + + + + + + + + +    we have now two different available algorithms : one uses precomputed values for @xmath55 and the other one computes them on - the - fly at each transform .",
    "the ` shtns ` library compares the time taken by those algorithms ( and variants ) at startup and chooses the fastest , similarly to what the ` fftw ` library@xcite does .",
    "the time overhead required by runtime tuning can be several order of magnitude larger than that of a single transform .",
    "the observed performance gain varies between 10 and 30% .",
    "this is significant for numerical simulations , but runtime tuning can be entirely skipped for applications performing only a few transforms , in which case there is no noticeable overhead .",
    "modern computers have several computing cores .",
    "we use openmp to implement a multi - threaded algorithm for the legendre transform including the above optimizations and the _ on - the - fly _ approach . the lower memory bandwidth requirements for the _ on - the - fly _ approach is an asset for a multi - threaded transform because if each thread would read a different portion of a large matrix , it can saturate the memory bus very quickly .",
    "the multi - threaded fourier transform is left to the fftw library .",
    "we need to decide how to share the work between different threads . because we compute the @xmath12 on the fly using the recurrence relation [ eq : rec ] , we are left with each thread computing different @xmath10 , or different @xmath29 . as the analysis step",
    "involve a sum over @xmath10 , we choose the latter option .    from equation [ eq : synth_direct ]",
    ", we see that the number of terms involved in the sum depends on @xmath29 , so that the computing cost will also depend on @xmath29 . in order to achieve the best workload balance between a team of @xmath68 threads ,",
    "the thread number @xmath69 ( @xmath70 ) handles @xmath71 , with integer @xmath72 from @xmath73 to @xmath74 .    for different thread number @xmath75",
    ", we have measured the time @xmath76 and @xmath77 needed for a scalar spherical harmonic synthesis and analysis respectively ( including the fft ) .",
    "figure [ fig : avx_omp ] shows the speedup @xmath78 , where @xmath79 is the largest of @xmath76 and @xmath77 , and @xmath80 is the time of the fastest single threaded tranform .",
    "it shows that there is no point in doing a parallel transform with @xmath1 below 128 .",
    "the speedup is good for @xmath3 or above , and excellent up to 8 threads for @xmath81 or up to 16 threads for very large transform ( @xmath82 ) .",
    "table [ tab : speed ] reports the timing measurements of two sht libraries , compared to the optimized gauss - legendre implementation found in the ` shtns ` library ( this work ) .",
    "we compare with the gauss - legendre implementation of ` libpsht ` @xcite , a parallel spherical harmonic transform library targeting very large @xmath1 , and with ` spharmonickit ` 2.7 ( dh ) which implements one of the driscoll - healy fast algorithms @xcite .",
    "all the timings are for a complete sht , which includes the fast fourier transform .",
    "note that the gauss - legendre algorithm is by far ( a factor of order 2 ) the fastest algorithm of the ` libpsht ` library .",
    "note also that ` spharmonickit ` is limited to @xmath5 being a power of two , requires @xmath6 latitudinal colocation points , and crashed for @xmath83 . the software library implementing the fast legendre transform described by @xcite , ` libftsh ` , has also been tested , and found to be of comparable performance to that of ` spharmonickit ` , although the comparison is not straightforward because ` libftsh ` did not include the fourier transform . again , that fast library could not operate at @xmath83 because of memory limitations .",
    "note finally that these measurements were performed on a machine that did not support the new avx instruction set .    [ cols=\"^,^,^,^,^,^,^,^\",options=\"header \" , ]      of the implementations from table [ tab : speed ] , where @xmath84 is the execution time and @xmath85 the frequency of the xeon x5650 cpu ( 2.67ghz ) with 12 cores.,scaledwidth=65.0% ]    in order to ease the comparison , we define the efficiency of the sht by @xmath86 , where @xmath84 is the execution time ( reported in table [ tab : speed ] ) and @xmath85 the frequency of the cpu .",
    "note that @xmath87 reflects the number of computation elements of a gauss - legendre algorithm ( the number of modes @xmath88 times the number of latitudinal points @xmath5 ) .",
    "an efficiency that does not depend on @xmath1 corresponds to an algorithm with an execution time proportional to @xmath62 .",
    "the efficiency of the tested algorithms are displayed in figure [ fig : speed ] .",
    "not surprisingly , the driscoll - healy implementation has the largest slope , which means that its efficiency grows fastest with @xmath1 , as expected for a fast algorithm .",
    "it also performs slightly better than ` libpsht ` for @xmath89 .",
    "however , even for @xmath2 ( the largest size that it can compute ) , it is still 2.8 times slower than the gauss - legendre algorithm implemented in ` shtns ` .",
    "it is remarkable that ` shtns ` achieves an efficiency very close to 1 , meaning that almost one element per clock cycle is computed for @xmath90 .",
    "overall , ` shtns ` is between two and ten times faster than the best alternative .",
    "one can not write about an sht implementation without addressing its accuracy .",
    "the gauss - legendre quadrature ensures very good accuracy , at least on par with other high quality implementations .",
    "the recurrence relation we use ( see  [ sec : fly ] ) is numerically stable , but for @xmath91 , the value @xmath92 can become so small that it can not be represented by a double precision number anymore .",
    "to avoid this underflow problem , the code dynamically rescales the values of @xmath55 during the recursion , when they reach a given threshold .",
    "the number of rescalings is stored in an integer , which acts as an enhanced exponent .",
    "our implementation of the rescaling does not impact performance negatively , as it is compensated by dynamic polar optimization : these very small values are treated as zero in the transform ( eq . [ eq : synth_direct ] and [ eq : gauss ] ) , but not in the recurrence .",
    "this technique ensures good accuracy up to @xmath93 at least , but partial transforms have been performed successfully up to @xmath94 .        to quantify the error we start with random spherical harmonic coefficients @xmath95 with each real part and imaginary part between @xmath96 and @xmath97 . after a backward and forward transform ( with orthonormal spherical harmonics ) , we compare the resulting coefficients @xmath98 with the originals @xmath95 .",
    "we use two different error measurements : the maximum error is defined as @xmath99 while the root mean square ( rms ) error is defined as @xmath100 the error measurements for our on - the - fly gauss - legendre implementation with the default polar optimization and for various truncation degrees @xmath1 are shown in figure [ fig : accuracy ] .",
    "the errors steadily increase with @xmath1 and are comparable to other implementations .",
    "for @xmath101 we have @xmath102 , which is negligible compared to other sources of errors in most numerical simulations .",
    "despite the many fast spherical harmonic transform algorithms published , the few with a publicly available implementation are far from the performance of a carefully written gauss - legendre algorithm , as implemented in the ` shtns ` library , even for quite large truncation ( @xmath2 ) .",
    "explicitly vectorized on - the - fly algorithms seem to be able to unleash the computing power of nowadays and future computers , without suffering too much of memory bandwidth limitations , which is an asset for multi - threaded transforms .",
    "the ` shtns ` library has already been used in various demanding computations ( eg . * ? ? ? * ; * ? ? ? * ; * ? ? ? * ) .",
    "the versatile truncation , the various normalization conventions supported , as well as the scalar and vector transform routines available for c / c++ , fortran or python , should suit most of the current and future needs in high performance computing involving partial differential equations in spherical geometry .",
    "thanks to the significant performance gain , as well as the much lower memory requirement of vectorized on - the - fly implementations , we should be able to run spectral geodynamo simulations at @xmath2 in the next few years .",
    "such high resolution simulations will operate in a regime much closer to the dynamics of the earth s core .",
    "the author thanks alexandre fournier and daniel lemire for their comments that helped to improve the paper .",
    "some computations have been carried out at the service commun de calcul intensif de lobservatoire de grenoble ( scci ) and other were run on the prace research infrastructure _ curie _ at the tgcc ( grant pa1039 ) .",
    "augier , p. , lindborg , e. , nov .",
    "2013 . a new formulation of the spectral energy budget of the atmosphere , with application to two high - resolution general circulation models .",
    "submitted to j. atmos .",
    "http://arxiv.org/abs/1211.0607      christensen , u.  r. , aubert , j. , cardin , p. , dormy , e. , gibbons , s. , glatzmaier , g.  a. , grote , e. , honkura , y. , jones , c. , kono , m. , matsushima , m. , sakuraba , a. , takahashi , f. , tilgner , a. , wicht , j. , zhang , k. , dec .",
    "a numerical dynamo benchmark .",
    "physics of the earth and planetary interiors 128  ( 1 - 4 ) , 2534 .",
    "http://dx.doi.org/10.1016/s0031-9201(01)00275-8    dickson , n.  g. , karimi , k. , hamze , f. , jun .",
    "importance of explicit vectorization for cpu and gpu software performance .",
    "journal of computational physics 230  ( 13 ) , 53835398 .",
    "figueroa , a. , schaeffer , n. , nataf , h.  c. , schmitt , d. , jan . 2013 .",
    "modes and instabilities in magnetized spherical couette flow .",
    "journal of fluid mechanics 716 , 445469 .",
    "http://dx.doi.org/10.1017/jfm.2012.551      glatzmaier , g.  a. , sep . 1984 .",
    "numerical simulations of stellar convective dynamos . i. the model and method .",
    "journal of computational physics 55  ( 3 ) , 461484 .",
    "http://dx.doi.org/10.1016/0021-9991(84)90033-0    healy , d.  m. , rockmore , d.  n. , kostelec , p.  j. , moore , s. , july 2003 .",
    "ffts for the 2-sphere - improvements and variations",
    ". journal of fourier analysis and applications 9  ( 4 ) , 341385 . http://dx.doi.org/10.1007/s00041-003-0018-9          sakuraba , a. , feb .",
    "effect of the inner core on the numerical solution of the magnetohydrodynamic dynamo .",
    "physics of the earth and planetary interiors 111  ( 1 - 2 ) , 105121 .",
    "http://dx.doi.org/10.1016/s0031-9201(98)00150-2      schaeffer , n. , jault , d. , cardin , p. , drouard , m. , 2012 . on the reflection of alfvn waves and its implication for earth s core modelling .",
    "geophysical journal international 191  ( 2 ) , 508516 ."
  ],
  "abstract_text": [
    "<S> in this paper , we report on very efficient algorithms for the spherical harmonic transform ( sht ) . </S>",
    "<S> explicitly vectorized variations of the algorithm based on the gauss - legendre quadrature are discussed and implemented in the ` shtns ` library which includes scalar and vector transforms . </S>",
    "<S> the main breakthrough is to achieve very efficient on - the - fly computations of the legendre associated functions , even for very high resolutions , by taking advantage of the specific properties of the sht and the advanced capabilities of current and future computers . </S>",
    "<S> this allows us to simultaneously and significantly reduce memory usage and computation time of the sht . </S>",
    "<S> we measure the performance and accuracy of our algorithms . even though the complexity of the algorithms implemented in ` shtns ` are in @xmath0 ( where @xmath1 is the maximum harmonic degree of the transform ) , they perform much better than any third party implementation , including lower complexity algorithms , even for truncations as high as @xmath2 . ` </S>",
    "<S> shtns ` is available at https://bitbucket.org/nschaeff/shtns as open source software . </S>"
  ]
}