{
  "article_text": [
    "recently , quantum image processing has attracted a lot of attention . in general",
    ", it has three steps as fig .",
    "1 shows : 1 ) store the image into a quantum system , which is also known as preparation ; 2 ) process the quantum image ; and 3 ) obtain the result by measurement . in this paper , we will focus on quantum image preparation and focus on increasing preparation efficiency .",
    "quantum preparation is related to how an image is stored in a quantum system , which is known as quantum representation .",
    "different quantum image representations may have different preparation methods .",
    "researchers have proposed a number of quantum image representation schemes , such as qubit lattice [ 1 ] , real ket [ 2 ] , entangled image [ 3 ] , frqi ( the flexible representation of quantum images ) [ 4 ] , mcqi ( the rgb multi - channel representation for quantum images ) [ 5 ] , neqr ( the novel enhanced quantum representation of digital images ) [ 6 ] , qualpi ( the quantum representation for log - polar images ) [ 7 ] , qsmc@xmath0qsnc ( quantum states for @xmath1 colors and quantum states for @xmath2 coordinates ) [ 8 ] , naqss ( the normal arbitrary quantum superposition state ) [ 9 ] , ineqr ( the improved neqr ) [ 10 ] , gqir ( the generalized quantum image representation)[11 ] , and _ etc_. a number of papers have summarized and compared them [ 11 - 12 ] .    in this paper , we discuss gqir s compression .",
    "gqir is developed from frqi .",
    "frqi , neqr , ineqr and gqir belong to one class .",
    "they are approbated and used more commonly .",
    "their feature is that they use two entangled state sequences to represent color information and location information respectively .",
    "2 gives the development and the inheritance of this class of representation .",
    "gqir uses @xmath3 qubits for @xmath4-coordinate and @xmath5 qubits for @xmath6-coordinate to represent a @xmath7 image .",
    "both the location information and the color information are captured into normalized quantum states : @xmath8 and @xmath9 .",
    "hence , an gqir image can be written as    @xmath10    where , @xmath11 is the color depth , and @xmath12 @xmath13 @xmath14 is the location information and @xmath15 is the color information .",
    "it needs @xmath16 qubits to represent a @xmath17 image with gray range @xmath18 .",
    "note that gqir can represent not only gray scale images but also color images because the color depth @xmath11 is a variable . in most cases ,",
    "when @xmath19 , it is a binary image ; when @xmath20 , it is a gray scale image ; and when @xmath21 , it is a color image .",
    "we choose gqir procedure because :    1 .",
    "it fully exploits the physical properties of qubits ( entanglement and superposition ) and reduces the number of qubits used to store an image .",
    "2 .   it resolves the real - time computation problem of image processing and provides a flexible method to process any part of a quantum image by using controlled quantum logic gates .",
    "it can represent a quantum image with any size .",
    "it is close to the classical image representation .",
    "hence , it is easier for researchers to understand and to transplant classical image processing algorithm into quantum system .",
    "there are also some researchers believe that measurement is a fatal shortcoming of gqir because measuring the quantum image one time , only one pixel is retrieved and the qubits collapse to the pixel , i.e. , other pixels are disappeared .",
    "if a user want to retrieve the whole image , one must prepare , process and measure the image many , many times .",
    "however , we believe this is due to the wrong use , rather than gqir itself .",
    "it is suitable to solve the problems with small amount output and can not be solved efficiently in classical computers . in ref .",
    "[ 13 - 14 ] , we have given a more detailed exposition and two example algorithms about this issue .",
    "quantum image compression is the procedure that reduces the quantum resources used to prepare quantum images [ 4 ] .",
    "the main resource in quantum preparation is the number of quantum gates instead of the number of qubits , because as stated previously , the number of qubits used in quantum images ( i.e. , @xmath16 ) has been very fewer than the number of bits used in classical images ( i.e. , @xmath22 ) . furthermore , the number of quantum gates can be used to indicate the network time complexity because in quantum network , each quantum gate is an operation which needs a certain amount of time to do it .",
    "hence , in this paper , we only study network time complexity and simply refer to as network complexity , or complexity in the following .",
    "therefore , the main task of quantum image compression is to reduce the number of gates used during quantum image preparation .    in ref .",
    "[ 4 ] and [ 6 ] , the minimization of boolean expressions is used to compress the image preparation .",
    "we call it boolean expression compression ( bec ) method and will introduce it in detail in section 2.1 .",
    "however , bec has some defects that prompt us to give a new compression scheme : 1 ) it needs a time - consuming preprocessing ; and 2 ) the compression ratio is unstable .    hence , this paper gives a new compression scheme .",
    "the new one is based on jpeg which is the most widely used method for still image compression in classical computers .",
    "we call the new one as quantum image jpeg compression , or the jpeg scheme .",
    "it inputs the quantized jpeg coefficients into qubits and then convert them into pixel values .",
    "since the data amount of the jpeg coefficients are significantly less than that of the pixel values , the jpeg scheme can compress an image .",
    "theoretical analysis and experimental results show that the compression ratio of our scheme is obviously higher than that of bec .",
    "the rest of the paper is organized as follows .",
    "2 presents related works about bec , jpeg and two quantum modules used in our scheme .",
    "our scheme is discussed in sect .",
    "3 including the basic ideas and the scheme steps . sect .",
    "4 gives the theoretical analysis and experimental results .",
    "5 gives the conclusion .",
    "a gqir s preparation is composed of @xmath23 hadamard gates and some ( @xmath23)-cnot gates ( cnot gates with ( @xmath23 ) control qubits ) . @xmath23",
    "hadamard gates are used to let state @xmath8 and state @xmath9 appear with equal probability in @xmath14 , and ( @xmath23)-cnot gates are used to set the color information and entangle the color information and location information .    in fig .",
    "3 ( a)-(c ) , an image with 4 pixels is given as an example to explain gqir representation and preparation . in ( a ) , one square indicates one pixel and the number in each square is the decimal pixel value . in ( b ) , the number in @xmath24 before each @xmath25 is the binary pixel value and the number in @xmath24 after each @xmath25 is the binary location information .",
    "there are 4 such formulas superposed because the image has 4 pixels . in ( c )",
    ", 2 hadamard gates generate the 4 location information @xmath26 and 10 2-cnot gates are used to set the color information . since all of the color qubits initial state is @xmath8 , the number of cnot gates is equal to the number of `` 1 '' in the color information .",
    "bec method has been used to compress gqir , which is based on the minimization of boolean expressions .",
    "if @xmath27 is a boolean variable and the value of it is 1 then the lateral @xmath27 is used in the minterm , otherwise the lateral @xmath28 is used . then , for example , a boolean expression @xmath29 is minimized as @xmath30 that is to say , if two cnot gates operate the same color qubit and only one of their control qubits is different , the two cnot gates can be combined into one gate . for example , in fig .",
    "3(b ) , the subspace @xmath31 in the first line , @xmath32 has three @xmath9 , i.e. , three cnot gates are needed ; in the second line , because the last two items are combined , @xmath32 has two @xmath9 and only two cnot gates are needed .",
    "3(d ) compresses the whole example image .",
    "it can be seen that bec drops the number of cnot gates from 10 to 6 .        however , the bec method has some defects :    1 .",
    "in fact , bec has two steps : 1 ) preprocess : determining which cnot gates can be combined ; and 2 ) input : using hadamard gates and cnot gates to input the image into quantum system .",
    "the time complexity of bec is @xmath33 where @xmath34 is the complexity of preprocessing and @xmath35 is the complexity of inputting .",
    "the preprocessing is time consuming because we have to look over all the cnot gates @xmath36 before compression one pair by one pair .",
    "the looking over algorithm is shown below .",
    "+ combine the two cnot gate @xmath37 and @xmath38 to one ; ; ; ; ; + hence , the complexity of the looking over algorithm is @xmath39 .",
    "+ moreover , looking over one round is not enough because two combined gates may be combined further . combining two cnot gate one time",
    ", the number of control qubits will reduce one . hence , the looking over process should be executed @xmath40 round .",
    "therefore , to a @xmath41 image , the complexity of preprocessing is @xmath42 it is a very high complexity , and in most application scenarios , it is intolerable .",
    "moreover , it is even much higher than the complexity before compression : @xmath43",
    ". hence , even assuming that @xmath35 is 0 , bec method increases the complexity instead of playing the role of compression .",
    "the compression ratio of this method is influenced by the bit planes .",
    "it is difficult to give an equation to calculate the compression ratio .",
    "sometimes , the compression ratio is high ( for an extreme example , all the pixels have the same color ) ; and sometimes , maybe , no one cnot gate can be compressed . that is to say , @xmath35 has no exact value .    for more information about gqir",
    ", please refer ref . [",
    "11 ] .",
    "jpeg is a commonly used method of lossy compression for digital still images .",
    "the degree of compression can be adjusted , allowing a selectable tradeoff between storage size and image quality .",
    "the typically compression ratio is 10:1 with little perceptible loss in image quality .",
    "the term `` jpeg '' is an acronym for the joint photographic experts group , which created the standard .",
    "the jpeg encoding process consists of the following steps ( taking a gray scale image as an example ) :    1 .",
    "discrete cosine transform + the image is split into blocks of @xmath44 pixels , and each block ( denoted as @xmath45 , @xmath46 , @xmath47 ) undergoes the discrete cosine transform ( dct ) to get frequency spectrum @xmath48 .",
    "@xmath49\\cos\\left[\\frac{(j+0.5)\\pi}{8}v\\right]\\right\\}\\ ] ] where @xmath50 , @xmath51 , and @xmath52 @xmath53 is the direct - current coefficient , and the bigger @xmath54 and @xmath55 , the higher frequency components @xmath48 .",
    "2 .   quantization + the human eye is good at seeing small differences in brightness over a relatively large area , but not so good at distinguishing the exact strength of a high frequency brightness variation .",
    "this allows one to greatly reduce the amount of information in the high frequency components .",
    "this is done by simply dividing each component in the frequency domain by a constant for that component , and then rounding to the nearest integer .",
    "this rounding operation is the only lossy operation in the whole process if the dct computation is performed with sufficiently high precision . as a result of this , it is typically the case that many of the higher frequency components are rounded to zero , and many of the rest become small positive or negative numbers , which take many fewer bits to represent . the elements in the quantization matrix control the compression ratio , with larger values producing greater compression .",
    "a typical quantization matrix is as follows : @xmath56\\ ] ] + the quantized dct coefficients are computed with @xmath57 3 .",
    "zigzag + because so many coefficients in the dct image are truncated to zero values during the coefficient quantization stage , the zeros are handled differently than non - zero coefficients .",
    "they are coded using a run - length encoding ( rle ) algorithm .",
    "rle gives a count of consecutive zero values in the image , and the longer the runs of zeros , the greater the compression .",
    "one way to increase the length of runs is to reorder the coefficients in the zigzag sequence shown in fig .",
    "4 . this way , coefficients 0 are omitted and a terminator `` eof '' is used .",
    "+      if we want to resume the pixel values , for example if we want to display the image on the screen , the inverse process is executed :    1 .",
    "rearrange the compressed data to @xmath44 blocks",
    "multiply each @xmath44 block with the quantization matrix @xmath58 .",
    "@xmath59 3 .",
    "do inverse dct ( idct ) to each @xmath44 block to get the recovered pixel value @xmath60 : @xmath61\\cos\\left[\\frac{(j+0.5)\\pi}{8}v\\right]\\right\\}\\ ] ] where @xmath46 , @xmath47 , and @xmath52    fig .",
    "5 shows the jpeg compression of two blocks and the jpeg decompression of one block in image `` lena '' .",
    "5 tells us that the recovered block is not the same as the original block .",
    "hence , jpeg compression is a kind of lossy compression .",
    "section 2.2 tells us that two operations : multiplication and addition are used in jpeg compression and decompression .",
    "hence , we use the quantum multiplier [ 17 ] and the quantum adder [ 18 ] to realize them respectively .    the quantum multiplier and the quantum adder are both quantum networks , which can calculate the product or the sum of two numbers which are stored in two @xmath62-qubit quantum registers @xmath63 and @xmath64 , where @xmath65 and @xmath66 .",
    "the quantum multiplication operation @xmath1 is @xmath67 and the quantum addition operation @xmath68 is @xmath69 where , @xmath70 is a @xmath40-qubit quantum register and @xmath71 is a @xmath72-qubit quantum register .    in the following , we use `` muler '' and `` adder '' to represent the quantum multiplier and the quantum adder",
    "respectively as shown in fig .",
    "6 .    according to ref .",
    "[ 17 ] and [ 18 ] , the complexity of muler is @xmath73 the complexity of adder is @xmath74    note that    1 .   in fig .",
    "6(b ) , there has a thick black bar on the right - hand side of the quantum adder .",
    "a network with a bar on the left side represents the reversed sequence of elementary gates embedded in the same network with the bar on the right side .",
    "if the action of the quantum adder is reversed with the input @xmath75 , the output will output @xmath76 when @xmath77 .",
    "when @xmath78 , the output is @xmath79 .",
    "2 .   ref .",
    "[ 17 ] said that stage @xmath80 had @xmath81 ripple quantum adders with size @xmath82 in parallel .",
    "since the @xmath81 ripple quantum adders work at the same time , the time required to run all the @xmath81 ripple quantum adders is equal to the run time of one ripple quantum adder . that is to say the time complexity of state @xmath80 is equal to one ripple quantum adder .",
    "the ripple quantum adder is different from the quantum adder given in ref .",
    "the time complexity of a ripple quantum adder with size @xmath62 is @xmath83 .",
    "hence , the complexity of a ripple quantum adder with size @xmath82 is @xmath84 .",
    "4 .   due to the length limitation of this paper , to get more details about muler and adder , please refer to ref . [",
    "17 ] and [ 18 ] .",
    "unlike the existed schemes that store pixel values in quantum computers directly , the basic idea of our scheme is to store quantized dct coefficients into qubits and then transform them into pixel values . due to",
    "the volume of dct coefficients is obviously smaller than the volume of pixel values , the complexity of preparation is decreased , i.e. , the quantum image is compressed .",
    "7 gives a schematic diagram to contrast our scheme with traditional schemes .",
    "note that the zigzag step is no longer needed in our scheme because the quantized coefficients are input into quantum computers in the form of @xmath44 blocks directly .",
    "section 2.2.2 tells us that when transform the quantized dct coefficients into pixel values , it needs two steps : multiply each @xmath44 block with the quantization matrix @xmath58 ( inverse quantization ) , and do inverse dct ( idct ) to each @xmath44 block to get the recovered pixel value @xmath60 .",
    "based on the unitarity of quantum algorithms , quantum idct can be realized by simply reverse the order of logic gates in quantum dct algorithms .",
    "however the existed quantum dct algorithms [ 19 - 20 ] is not suitable to our scheme because their data storage format is different from ours :    1 .   ref .",
    "[ 19 - 20 ] use @xmath85 to do quantum dct , where @xmath86^{\\text{t}}$ ] is the space domain data ( i.e. , the original pixel values ) , @xmath87^{\\text{t}}$ ] is the frequency domain data ( i.e. , the dct coefficients ) , and @xmath88 is the quantum dct transformation .",
    "hence , the pixels and the coefficients are stored as the probability of basic states .",
    "our scheme converts the pixel values and the coefficients to binary strings and use the corresponding basic states to represent them .",
    "the probabilities of all the corresponding basic states are the same .",
    "hence , the quantum dct and idct method proposed in ref .",
    "[ 19 - 20 ] can not be utilized in this paper .",
    "we will give a new way to realize quantum idct and describe it in the next subsection .",
    "for the sake of simplicity , we assume that the size of the image is @xmath41 .    1 .",
    "dct and quantize .",
    "it is a preprocessing step done in classical computers as described in step 1 and 2 of section 2.2.1 .    1 .",
    "store the quantized dct coefficients into quantum systems .",
    "it is similar to the gqir preparation stated in section 2.1 .",
    "initially , @xmath89 qubits are prepared and set to @xmath8",
    ". the initial state can be expressed as in @xmath90    then , @xmath11 identity gates and @xmath40 hadamard gates are used to construct a @xmath41 blank image . the identity matrix and the hadamard matrix",
    "are shown below .",
    "@xmath91   \\ \\ \\ \\",
    "h=\\frac{1}{\\sqrt2 } \\left [   \\begin{array}{cc }   1 & 1 \\\\   1 & -1   \\end{array }   \\right]\\ ] ]    the whole quantum operation in this step can be expressed as @xmath92 : @xmath93 @xmath92 transforms the initial state @xmath94 to the state @xmath95 .",
    "@xmath96    in simple terms , the effect of identity gate is maintaining the qubit s original state unchanged and the effect of hadamard gate is letting state @xmath97 and state @xmath98 appear with equal probability . note that because identity gates @xmath99 remain qubit s state unchanged , they can be omitted .",
    "after @xmath92 , the blank @xmath41 image is gained .",
    "next , store the quantized dct coefficients .",
    "it is divided into @xmath100 sub - operations and each sub - operation stores one quantized dct coefficient , where @xmath101 is the number of @xmath44 blocks and 64 indicates that there are 64 coefficients to be stored in each block .",
    "we still use @xmath6 and @xmath4 to distinguish sub - operations . for the @xmath102th sub - operation in block @xmath103",
    ", we have @xmath104    in general , in each block , @xmath105 is the biggest coefficient of all @xmath106 , @xmath107 , @xmath108 . due to @xmath109 and @xmath45",
    "does not exceed @xmath110 , @xmath111 note that there is a special item .",
    "when all @xmath112 , @xmath113 however , jpeg compression defines that the quantization result of the special item is @xmath114 .",
    "hence , @xmath115 qubits are enough to store @xmath106 .",
    "however , sometimes , @xmath106 may be a negative number .",
    "the most significant qubit is used as the sign position : if @xmath106 is a negative number , the most significant qubit is set to state @xmath9 ; and if @xmath106 is a positive number , the most significant qubit remains state @xmath8 .",
    "the quantum sub - operation @xmath116 is shown below .",
    "@xmath117 where @xmath118 is the quantum operation to transform the value of pixel @xmath119 from @xmath120 to the desired quantized dct coefficient as shown in eq .",
    "hence , the function of @xmath116 is change pixel @xmath119 and others remain unchanged .",
    "@xmath121 the function of @xmath122 is setting the value of the @xmath123th qubit of pixel @xmath119 s quantized dct coefficient . @xmath124 where @xmath125 is the xor operation .",
    "if @xmath126 , @xmath127 is a @xmath40-cnot gate ( a cnot gate with @xmath40 control qubits ) . otherwise , @xmath128 is a quantum identity gate which will do nothing on the quantum state .",
    "hence , @xmath129 act @xmath116 on @xmath95 @xmath130    @xmath116 only sets the quantized dct coefficient of its corresponding pixel . in order to set all the @xmath41 pixels , a quantum operation @xmath131 is defined below .",
    "@xmath132 act @xmath131 to @xmath95 @xmath133    in simple terms , the effect of step 2 is using @xmath40 hadamard gates and @xmath40-cnot gates to store the quantized dct coefficients to a quantum system .",
    "the number of @xmath40-cnot gates is equal to the number of `` 1 '' in binary coefficients plus the number of negative coefficients .    1 .   store the quantization matrix .",
    "this step uses the similar method as the previous step to store the quantization matrix @xmath58 ( shown in eq .",
    "( 5 ) ) into qubits : 1 ) @xmath134 qubits are prepared and set to @xmath8 .",
    "2 ) 6 hadamard gates are used to construct a @xmath44 blank matrix .",
    "3 ) some 6-cnot gates are used to set the value of @xmath58 .    due to",
    "@xmath58 is a @xmath44 matrix , the cnot gates used in this step have 6 control qubits .",
    "after step 3 , the quantum quantization matrix is : @xmath135 where , in the second to fourth line , @xmath136 is given in decimal and @xmath137 is given in binary .    1 .",
    "inverse quantization .",
    "we use muler to multiply each @xmath44 block with the quantization matrix @xmath138 as eq .",
    "( 7 ) shows .",
    "the multiplication is element - by - element : only when @xmath139 , muler is used to multiply the coefficient block and the quantization matrix , where @xmath137 is the location information of the quantization matrix and @xmath140 is part of the location information of the dct coefficient .",
    "that is to say , each element in the quantization matrix is multiplied with the corresponding dct coefficients in each @xmath44 block .",
    "step 4 can be broken down into the following steps .",
    "1 .   judge whether @xmath139 .",
    "+ define @xmath141 where @xmath142 , @xmath143 .",
    "that is to say , @xmath144 is a cnot gate : if @xmath145 , @xmath146 is changed to 0 ; otherwise , @xmath146 is changed to 1 .",
    "hence , by acting @xmath147 to state @xmath148 , we can align @xmath44 blocks with @xmath138 , i.e. , if all the @xmath149 is equal to @xmath8 , each element in the quantization matrix finds its corresponding dct coefficients in each @xmath44 block . for the sake of simplicity , when no ambiguity is possible , we still use @xmath150 to substitute @xmath149 .",
    "if the condition is satisfied ( i.e. , all the @xmath150 is equal to @xmath8 ) , change the state of a auxiliary qubit @xmath151 with initial state @xmath8 to @xmath9 .",
    "+ a transform @xmath152 is defined .",
    "@xmath153 where , @xmath152 is a 6-cnot gate .",
    "3 .   if @xmath154 , multiply .",
    "+ @xmath151 is the deliverable of step 4.1 and 4.2 .",
    "hence , @xmath155 has no use in the following and @xmath151 substitutes them . if @xmath154 , we use muler to multiply each @xmath44 block with the quantization matrix @xmath138 as eq .",
    "( 7 ) shows .",
    "we use @xmath156 to denote the operation . @xmath157 + since",
    "the quantization matrix and the dct coefficients are stored superposedly , one muler is enough to multiply them parallel .",
    "transform the sign position .",
    "+ define @xmath158 hence , @xmath159 is a 2-cnot gate : if @xmath160 and @xmath161 , the sign position @xmath162 in @xmath163 is changed to @xmath9 .",
    "8 gives the circuit of step 4 .",
    "when @xmath160 , the subspace @xmath164 stores the recovered dct coefficients .        1",
    "inverse dct .    in eq .",
    "( 8) , @xmath165 , @xmath166 , @xmath167 $ ] and @xmath168 $ ] are independent from image . we see them as a whole .",
    "hence , eq . ( 8) can be changed into @xmath169\\cos\\left[\\frac{(j+0.5)\\pi}{8}v\\right]\\right\\}\\\\ = & \\sum_{u=0}^{7}\\sum_{v=0}^{7}\\left\\{f'(u , v)\\times c_{ij}(u , v)\\right\\ } \\end{split}\\ ] ] where @xmath170\\cos\\left[\\frac{(j+0.5)\\pi}{8}v\\right]$ ] .",
    "therefore , this step is divided into two main parts : multiply @xmath171 with @xmath172 and add all the 64 products up .",
    "1 .   store @xmath172 . +",
    "this step uses the similar method as step 2 to store @xmath173 into qubits : 1 ) @xmath174 qubits are prepared and set to @xmath8 .",
    "2 ) 6 hadamard gates are used to construct @xmath123 and @xmath175 .",
    "3 ) some 6-cnot gates are used to set the value of @xmath173 .",
    "+ although @xmath176 use @xmath177 qubits to represent the value of dct coefficients , only @xmath178 qubits works . that is because in a @xmath44 block",
    ", the max value of @xmath171 is @xmath179 , and @xmath180 therefore we only take the first @xmath181 qubits ( @xmath182 ) to participate in the following steps .",
    "@xmath183 still is the sign . in order to multiply @xmath184 with @xmath173 using muler",
    ", we also use @xmath181 qubits to store the value of @xmath172 and @xmath185 is the sign position .",
    "+ @xmath172 has up to @xmath186 values because @xmath187 . by calculating all of them",
    ", we find that @xmath188 hence , except the sign qubit @xmath185 , other @xmath181 qubits store the fractional part of the absolute value .",
    "+ that is to say , each @xmath172 uses @xmath178 qubits to store .",
    "however , because @xmath189 , @xmath190 qubits are needed to store all @xmath172 .",
    "2 .   multiply the absolute value of @xmath171 with @xmath172 .",
    "+ define @xmath191 it is a quantum multiplier muler with 6 control qubits : @xmath192 and @xmath193 are the control qubits , and if the binary values @xmath194 and @xmath195 , muler works . due to the absolute values of @xmath171 and @xmath172",
    "both occupy @xmath181 qubits , the result occupies @xmath196 qubits .",
    "+ use 64 mulers @xmath197 to multiply all @xmath171 with @xmath172 . + symbol @xmath198 is used to denote the product of @xmath171 and @xmath172 .",
    "since @xmath171 is a @xmath199-qubit integer and @xmath172 is a @xmath199-qubit pure decimal , the higher @xmath181 qubits of @xmath198 are the integer part and the lower @xmath181 qubits are the fractional part .",
    "3 .   set the sign position .",
    "+ define @xmath200 it is a 8-cnot gate : if the sign position of @xmath171 is different with the sign position of @xmath201 , and @xmath194 and @xmath195 , change the new sign position @xmath202 from @xmath8 to @xmath9 . + define @xmath203 to set all the 64 sign positions .",
    "add the 64 @xmath204 .",
    "+ according to eq .",
    "( 31 ) , all the 64 @xmath204 should be added together .",
    "we use 64 adder to realize it .",
    "firstly , @xmath205 and @xmath206 are added .",
    "then , @xmath207 and the sum of the previous addition are added .",
    "+ however , there is a sign position @xmath202",
    ". if it is @xmath8 , @xmath208 @xmath209 should be added ; if it is @xmath9 , @xmath207 should be subtracted .",
    "hence , @xmath202 is used as a control qubit : when @xmath210 , the thick black bar is on the right - hand hand of adder ; otherwise , the thick black bar is on the left - hand hand of adder . + the output of the last adder is the regained color information .",
    "it is denoted as @xmath211 and the higher @xmath181 qubits are the integer part and the lower @xmath181 qubits are the fractional part .",
    "however , gqir only uses @xmath11 qubits to represent color .",
    "hence , only the lower @xmath11 qubits of the integer part is useful .",
    "it is @xmath212 .",
    "9 gives the circuit of step 5 .",
    "the useful output of step 5 is @xmath213 @xmath214 and it is the gqir image .",
    "@xmath215 is the color information and @xmath216 is the location information .",
    "in this section , we will compare our scheme with gqir preparation and bec method to highlight the advantages of our scheme .",
    "however , our scheme and bec have a preprocessing step done in classical computers . as we all know , classical computers and quantum computers have different physical principles .",
    "hence , we will compare the quantum part and the classical part separately .",
    "the network complexity depends very much on what is considered to be an elementary gate .",
    "this is a problem about gate granularity .",
    "for example , one toffoli gate ( a not gate with 2 control qubits ) can be simulated by six control - not gates ( a not gate with 1 control qubits ) [ 18 ] .",
    "however , in this paper , we take one gate can be drawn in a quantum circuit as an elementary gate , no matter how many control qubits it has and what function it finishes .",
    "the gqir preparation is done in quantum computers . from section 2.1 , we know that the complexity of the gqir preparation is equal to the number of bit 1 in all the pixels . by assuming that every bit has equal probability to be 0 or 1 , then the gqir preparation complexity before compression is @xmath217 we will give our scheme s complexity based on @xmath173 .    to our scheme , only step 2 - 5 are analyzed because the scope of section 4.1 is quantum part .",
    "the complexity of step 2 ( the number of gates used in step 2 ) in our scheme is equal to the number of bit 1 plus the number of negatives in all the coefficients . we define it as @xmath218 where , @xmath219 is called jpeg compression ratio .",
    "we use statistical method to gain @xmath220 .",
    "800 images obtained from washington university [ 21 ] , university of south california [ 22 ] and pixabay [ 23 ] are used , including people , animals , streetscape , buildings , natural beauty , remote sensing , texture , man - made pattern , and so on .",
    "these images almost cover all common image types .",
    "10 gives some samples .",
    "we calculate each image s compression ratio @xmath220 and show it in fig .",
    "the maximum value is 0.2364 , the minimum value is 0.0148 , the average value is 0.0934 , and the variance is only 0.0014 .",
    "hence , in the following , we set @xmath221 and the complexity of step 2 is @xmath222        step 3 is used to store the quantization matrix . since the quantization matrix is fixed as eq .",
    "( 5 ) shows , the complexity of step 3 ( the number of gates used in step 3 ) is also fixed .",
    "it is equal to the number of bit 1 in all the quantization values .",
    "hence , @xmath223    the complexity of step 4 ( the number of gates used in step 4 ) is also fixed .",
    "@xmath224    the complexity of step 5 ( the number of gates used in step 5 ) is @xmath225 + 128 + 128(8(2q+6)-2)\\\\ = & 64q^{2}+2720q+7232 + 64(4q+4 + 2\\log_{2}(q+3))\\log_{2}(q+3 ) \\end{split}\\ ] ]    note that the first item in the third line in eq .",
    "( 44 ) is @xmath226 .",
    "that is because : 1 ) @xmath227 have 64 components ; 2 ) each @xmath172 is composed by @xmath178 qubits ; and 3 ) each qubit has equal probability to be 0 and 1 .",
    "hence , the complexity of compressed preparation is @xmath228    if our scheme compresses the image preparation , @xmath229 i.e. , @xmath230 hence , when @xmath231 where @xmath232 and @xmath233 , our scheme can compress the quantum image preparation .",
    "assume that @xmath234 is a function of @xmath11 .",
    "the function image is shown in fig .",
    "12 , in which @xmath11 is ranged from 4 to 40 to cover almost all the color depth used in jpeg compression .     and the @xmath235 .",
    "because @xmath62 is a positive integer , we also round @xmath235 to the nearest integer greater than or equal to @xmath235 .",
    "that is to say , the line with small circles gives the lowest value of @xmath62.,width=377 ]    fig .",
    "12 tells us that as long as the image size is bigger than @xmath236 , our scheme can compress the image .",
    "it is a easy to achieve requirement because most of the common image sizes are bigger than @xmath237 .",
    "quantum image compression ratio @xmath238    due to @xmath239 the compression ratio of our scheme is @xmath240    fig .",
    "13 gives the @xmath241 changed with @xmath62 and @xmath11 .",
    "it tells us that :    1 .",
    "no matter how much the value of @xmath11 , when @xmath242 , i.e. , the image size is equal to or bigger than @xmath243 , @xmath241 is approximately 0.9 .",
    "that is to say , the jpeg complexity is only @xmath244 of the original complexity .",
    "2 .   the bigger the @xmath62 , the higher the compression ratio @xmath241 .",
    "the reason to these two items is that @xmath245 and @xmath246 , @xmath247 and @xmath248 are independent of @xmath62 , hence as @xmath62 increases , @xmath241 increases rapidly and the limit is 0.9 .",
    "is changed with the image size @xmath62 and color depth @xmath11.,width=377 ]    we also compare the compression ratio of our scheme with bec in table 1 . however , as stated in section 2.1 , if the preprocessing is taken into account , bec s complexity is too high to bear .",
    "hence , we only test 3 @xmath249 images with @xmath20 .",
    "it can be seen that our scheme s compression ratio is higher than that of bec scheme .     &",
    ".the compression ratio ( not include preprocessing ) .",
    "[ cols=\"^ \" , ]     from fig . 14 and",
    "table 3 , we can see that our scheme does not affect the images visual effect , and the psnr is acceptable .",
    "this paper focuses on quantum image preparation and gives a new quantum image compression scheme based on jpeg to prepare a gqir image . compared with bec",
    ", our scheme has the following advantages :    1 .",
    "its preprocessing ( dct and quantization ) is simple and fast .",
    "2 .   as long as eq .",
    "( 46 ) is satisfied , its compression ratio is higher than that of bec .",
    "moreover , eq . ( 46 ) is a loose condition because it requires that the size of the image is only bigger than or equal to @xmath237 .",
    "venegas - andraca s.e . ,",
    "bose , s. storing , processing and retrieving an image using quantum mechanics .",
    "proceedings of the spie conference on quantum information and computation , pp .",
    "137 - 147 ( 2003 ) latorre , j.i .",
    ": image compression and entanglement .",
    "arxiv : quant - ph/0510031 ( 2005 ) venegas - andraca s.e . , ball j.l . : processing images in entangled quantum systems .",
    "quantum information processing 9(1 ) , 1 - 11 ( 2010 ) le , p.q . , dong , f.y . ,",
    "hirota , k. : a flexible representation of quantum images for polynomial preparation , image compression and processing operations .",
    "inf . process .",
    "10(1 ) , 63 - 84 ( 2011 ) sun , b. , iliyasu , a.m. , yan , f. , dong , f.y .",
    ", hirota , k. : an rgb multi - channel representation for images on quantum computers . journal of advanced computational intelligence and intelligent informatics .",
    "17(3 ) , 404 - 417 ( 2013 ) zhang , y. , lu , k. , gao , y.h . , wang , m. : neqr : a novel enhanced quantum representation of digital images . quantum inf . process .",
    "12(12 ) , 2833 - 2860 ( 2013 ) zhang , y. , lu , k. , gao , y.h .",
    ", xu , k. : a novel quantum representation for log - polar images .",
    "quantum inf . process .",
    "12(9 ) , 3103 - 3126 ( 2013 ) li , h.s . , zhu , q.x . , lan , s. , shen , c.y . , zhou , r.g .",
    ", mo , j. : image storage , retrieval , compression and segmentation in a quantum system . quantum inf . process , 12(6 ) , 2269 - 2290 ( 2013 ) li , h.s . , zhu , q.x . , zhou , r.g . ,",
    "lan , s. , yang , x.j .",
    ": multi - dimensional color image storage and retrieval for a normal arbitrary quantum superposition state .",
    "quantum inf .",
    "13(4 ) , 991 - 1011 ( 2014 ) jiang , n. , wang , l. : quantum image scaling using nearest neighbor interpolation . quantum inf .",
    "14(5 ) , 1559 - 1571 ( 2015 ) jiang , n. , wang , j. , mu , y. : quantum image scaling up based on nearest - neighbor interpolation with integer scaling ratio",
    ". quantum inf .",
    "14(11 ) , 4001 - 4026 ( 2015 ) yan , f. , iliyasu , a.m. , venegas - andraca s.e . : a survey of quantum image representations . quantum inf .",
    "15(1 ) , 1 - 35 ( 2016 ) jiang , n. , dang , y.j . ,",
    "wang , j. : quantum image matching .",
    "quantum inf .",
    "15(9 ) , 3543 - 3572 ( 2016 ) jiang , n. , dang , y.j . ,",
    "zhao , n. : quantum image location .",
    "international journal of theoretical physics , 55(10 ) , 4501 - 4512 ( 2016 ) gonzalez , r.,woods , r. : digital image processing .",
    "pearson / prentice hall , upper saddle river ( 2008 ) https://cs.stanford.edu/people/eroberts/courses/soco/projects/data-compression/lossy/jpeg/lossless.htm saurabh kotiyal , himanshu thapliyal , nagarajan ranganathan .",
    "circuit for reversible quantum multiplier based on binary tree optimizing ancilla and garbage bits .",
    "27th international conference on vlsi design and 13th international conference on embedded systems : 545 - 550 ( 2014 ) vlatko , v. , adriano , b. , artur , e. : quantum networks for elementary arithmetic operations .",
    "phys . rev .",
    "a 54(1 ) , 147 - 153 ( 1996 ) klappenecker , a. , roetteler , m. discrete cosine transforms on quantum computers .",
    "proceedings of the 2nd international symposium on image and signal processing and analysis , 464 - 468 ( 2001 ) tseng , c. , hwang , t. quantum circuit design of @xmath44 discrete cosine transform using its fast computation flow graph .",
    "ieee international symposium on circuits and systems , 1 : 828 - 831 ( 2005 ) http://imagedatabase.cs.washington.edu/ ( 2016 ) http://sipi.usc.edu/services/database/index.html ( 2016 ) https://pixabay.com ( 2016 ) ephraim feig , shmuel winograd .",
    "fast algorithms for the discrete cosine transform .",
    "ieee transactions on signal processing , 40(9 ) : 2174 - 2193 ( 1992 )"
  ],
  "abstract_text": [
    "<S> quantum image processing has been a hot topic . </S>",
    "<S> the first step of it is to store an image into qubits , which is called quantum image preparation . </S>",
    "<S> different quantum image representations may have different preparation methods . in this paper </S>",
    "<S> , we use gqir ( the generalized quantum image representation ) to represent an image , and try to decrease the operations used in preparation , which is also known as quantum image compression . </S>",
    "<S> our compression scheme is based on jpeg ( named from its inventor : the joint photographic experts group )  the most widely used method for still image compression in classical computers . </S>",
    "<S> we input the quantized jpeg coefficients into qubits and then convert them into pixel values . </S>",
    "<S> theoretical analysis and experimental results show that the compression ratio of our scheme is obviously higher than that of the previous compression method .    </S>",
    "<S> example.eps gsave newpath 20 20 moveto 20 220 lineto 220 220 lineto 220 20 lineto closepath 2 setlinewidth gsave .4 setgray fill grestore stroke grestore </S>"
  ]
}