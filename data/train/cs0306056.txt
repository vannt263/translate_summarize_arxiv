{
  "article_text": [
    "the cms experiment @xcite is one of the two multipurpose experiments being under construction to operate at the future large hadron collider ( lhc ) at cern .",
    "a particularly important aspect of the cms core software is the database system that will be used to handle the petabytes of data that the experiment will produce .",
    "the experiment has recently decided to move away from its objectivity based system in favor of an hybrid solution based on root i / o @xcite .",
    "this paper describes the work done in this context so to evaluate the performances of using the very specific root classes ( especially ttree and tclonesarray ) for the data storage . in the meantime , cms also started a more direct replacement of the existing objectivity implementation @xcite .",
    "we did not choose to explore the many use - cases of cms , but rather focused on a single representative one and studied the many ways to implement it with root i / o .",
    "the selected use - case is the last step of the simulation chain @xcite : starting from the events produced by the detector simulation , we simulate the raw data produced by the detector . due to the high luminosity of the lhc machine ,",
    "this involves firstly the superimposition to the signal event of a number of pileup events .",
    "the resulting crossing is then digitized , that is the effect of the front end electronics is simulated so to produced a digitised crossing or raw data . from the applications currently developped by cms , this step is the most critical from the i / o point of view : for the simulation of each raw data event of @xmath0 size , one must load in memory about one hundred and fifty minimum bias events of @xmath1 size .",
    "this requires huge memory and is an intensive data reading process .",
    "moreover , this is an unusual use of root i / o on several aspects :    * the cms code contains c++ templates , stl containers and it uses external packages whose classes can not be instrumented for root .",
    "the root support for templates , standard containers and external classes is quite new and still not fully mature . *",
    "the pileup events , stored in root files , are not read sequentially . ideally , such events should be taken from a large enough statistic , so to produce uncorrelated sequences of pileup to be added on each signal event .",
    "since we have only a finite statistic of pileup events , we chose to select them in a random fashion so to limit the possible effect of correlation between different sequences . nevertheless , the selection method is not fully random ( real randomness would imply a change of file for each new pileup event and would have a strong impact on performances ) . * the events are not processed one by one in memory , such as in standard analysis jobs as described in the root documentation .",
    "as explained before , we rather have at the same time in memory all the hits from the signal and from the many minimum bias events that we want to pile up .    in this context",
    ", we have compared the performance of four kinds of containers ( section [ sec : crossing - model ] ) , combined with three different ways ( section [ sec : managers ] ) to store them in root files .",
    "this leads to the twelve strategies advertized in the title .",
    "also worth to be mentionned , we really focused on the huge event data to be transfered : we did not store neither meta - data nor the links or pointers between the elements of the events .",
    "surely , the latter should be integrated in a later version of the testbed .",
    "the section [ sec : testbed ] gives a more detailed description of the testbed , what we have tested and on which platform .",
    "then , the section [ sec : results ] presents the most interesting results .",
    "the testbed is basically able to build crossings , as described in figure [ f1 ] . as input",
    ", we have a file of five hundred signal events , and one hundred files of five hundred minimum bias events ( actually , for the testbed , one hundred times the same original file ) .",
    "a typical job is the production of five hundred crossings . building a crossing and digitizing it consists of the following steps :    1 .   a persistency manager loads in memory the next signal event from the signal file 2 .",
    "another persistent manager loads 153 minimum bias events from the minimum bias files ( this number corresponds to the luminosity of @xmath2 ) .",
    "these events are selected pseudo - randomly : we take x consecutive events , then we do a random jump between 0 and y , etc .",
    "x is called `` burst '' and y is called `` jump '' .",
    "their typical values in cms applications are 3 and 10 . also , when loading an event , we select randomly which rank it will have in the collection in memory .",
    "the digitizer collects all the hits from the signal and minimum bias events in memory , then simulates the detector front end electronics and produces the correspondant digis .",
    "4 .   a third persistent manager takes the digis and stores them as the next digitized crossing in the digis output file .",
    "the expected bottleneck and area of interest is the loading of the minimum bias events .",
    "below follows the mean number of objects and their size for such events :    * 351 instances of rtbgenparticle ( whose raw size is 46 bytes ) . * 584 instances of rtbsimvertex ( whose raw size is 34 bytes ) . * 169 instances of rtbsimtrack ( whose raw size is 38 bytes ) .",
    "* 3282 instances of rtbcalohit ( whose raw size is 20 bytes ) . * 1871 instances of rtbtrackhit ( whose raw size ist 56 bytes ) .",
    "this leads to an event size of 208 kbytes , if we just consider the pure data , without any adjunction for the support of persistency .",
    "as one can see , the size is mainly dominated by the detector simulated hits .",
    "we also computed that the mean event size would be 392 kbytes if each numerical attribute would be of type double ( this information will prove useful in section [ sec : matrix ] ) .    in the results section",
    ", we will especially study the size of the minimum bias files , and the time necessary to load 153 pseudo - random events from them .",
    "we chose to put all our persistent data in the shared hierarchy of folders proposed by root ( tree of instances of tfolder ) .",
    "this permits to decouple completely the persistency mechanism from the digitizing code .    the folder called //root",
    "/ crossing / digis is the output `` event '' of the current crossing : it contains a container of instances of rtbcalodigis and a container of instances of rtbtrackdigis .",
    "the 153 folders which we have called //root / crossing / minbias * , plus the single one called //root / crossing / signal represent the input events composing the current crossing .",
    "each of these folders contains a container for each kind of input event objects : rtbtrackhit , rtbcalohit , rtbsimtrack , rtbsimvertex and rtbgenparticle .",
    "each time we run the testbed , we chose a given kind of container which is used for all the input and output data .",
    "all those containers inherit from a common abstract class :    ....    template < class t >    class rtbvtarray < t >     {      public :      // write interface      virtual void clear ( ) = 0 ;      virtual void add ( const t & ) = 0 ;      // read interface      virtual uint_t size ( ) const = 0 ;      virtual const t & operator [ ]       ( uint_t i ) const = 0 ;     } ; ....    this ( simplified ) class header shows that we rely on size ( ) and operator [ ] to read the objects of a collection . on the other side , when creating a collection , we do not pre - allocate the size of the container to be filled : in the cms code we have imported in the testbed , the size of the created collections is rarely known in advance .",
    "this write interface is not the most efficient , but it fits the user needs and what matters most for this testbed is the read efficiency .",
    "four kinds of concrete containers have been implemented , which are described below .      the class rtbstlarray < t > wraps a standard std::vector <",
    "t>. the support of this kind of container is quite recent within root .",
    "the main benefit of this container is that any kind of t can be collected ( it is not needed that t inherits from tobject ) .",
    "the associated disadvantage is that root does not apply any of its optimizations when storing / retrieving the objects , expecially its attribute - wise serialization .",
    "the class rtbcarray < t > contains a simple c array dynamicaly allocated .",
    "each time the array is full , the size is multiplied by two and the array reallocated .",
    "the objects which are collected in the c array must be instrumented with classdef , otherwise root i / o will not be able to save them . since we do not want to impose that t is instrumented for root , we wrote a template class rtbclassdef < t > , which inherits from t and is instrumented with classdef .",
    "each time we want to add an instance of t into the c array , we first change its type from t to rtbclassdef < t>.",
    "so to evaluate the eventual cost of this process , we also kept the possibility to compile the testbed with event data classes directly instrumented with classdef ( this is done by unsetting the macro rtb_foreign ) .",
    "the class rtbcarray < t > should not be seen as a container to be used in a real application .",
    "it is rather a toy container , just written for comparison and to evaluate the performance of a good old simplistic c array .",
    "the class rtbobjarray < t > wraps a tobjarray .    as for any root collection",
    ", we can not add an object to the tobjarray when its class does not inherit from tobject .",
    "again , we do not want to impose that t is instrumented for root , so we wrote a template class rtbobj < t > which inherits both from tobject and t. each time we want to add an object into the collection , we first transform it into an instance of rtbobj <",
    "t>. so to evaluate the eventual cost of this process , we also kept the possibility to compile the testbed with top event data classes directly inheriting from tobject ( this is done by setting the macro rtb_tobjects ) .",
    "as for rtbcarray < t > , rtbobjarray < t > should not be seen as a container usable in a real application .",
    "it is here for comparison , and should have the worst performances of all the containers , because it is handling the objects by pointers ( and not by value ) .",
    "the class rtbclonesarray < t > wraps a tclonesarray . as for rtbobjarray",
    "< t > , the instances of t must be transformed into instances of rtbobj < t > before they are added to the collection .",
    "the class rtbclonesarray < t > is the real alternative to rtbstlarray < t>. since it is based on tclonesarray , which is the official optimized container of root , it should show the best perfomance .",
    "the counterpart is that it is harder to use and the collected objects must be kind of tobject .",
    "the task of a persistency manager is to transfer an event from memory ( a tfolder and its contents ) to disk ( an entry in a tfile ) and vice - versa .",
    "three flavors have been implemented , which are described below .",
    "this persistency manager implements the simplest approach , which only uses the base root i / o level and the class tkeys : one directly writes the tfolder to the tfile , each time with a different meaningful name : the name of the original folder plus an incrementing rank .",
    "for example , in our main use - case , the output of the first digitized crossing will be saved as digis0 , the second one as digis1 , etc .",
    "the central idea of the second manager is to avoid the use of root instrumentation and dictionaries : this is achieved by transfering the data of each container into an instance of tmatrixd and storing the matrix instead of the container .",
    "more precisely , each row of the matrix is the copy of one object from the original container , and each column corresponds to a given attribute of the class of the objects .    in this manager , we also chose to use a ttree .",
    "each entry of the tree is an event .",
    "each branch is dedicated to one kind of event objects , and attached to the corresponding matrix .    in this approach",
    ", we do not take profit of the root persistency features , such as the generated streamers , and we must write by ourselves the code which transfers the data between the containers and the matrices ( for each persistent class ) . also ,",
    "since any number is transformed into a double_t , we expect files to be twice bigger than their normal size .",
    "on the other hand , we do not suffer from the root parser limitations and bugs .",
    "we are quite confident here in the data retrieved from the files , and this manager is primarily used in the testbed so to check that the others managers are also correctly retrieving the data .      this third kind of manager is the root recommended approach . each file contains a single ttree whose entries are the events . similarly to the previous manager , there is one top level branch for each kind of event object , but this branch is directly attached to the corresponding container in memory .",
    "the level of split is a parameter of the testbed , but we generally use the recommended default of 99 . concerning the size of buffers , we rather tend to reduce them to 8000 kbytes ( empirical best value ) .",
    "once a persistent manager is built , and before writing or reading an event from a file , one must connect the manager to a given folder in memory and to a given file .    as one can see in the main use - case ( see figure [ f1 ] ) , there is a manager for the signal events , and another one for the digis , because they are always connected to the same files and folders .    with regards to the minimum bias events",
    ", we were not able to build a manager for each of the 153 events in memory ( each manager has some internal buffers and this would require a large amount of memory space ) .",
    "thus , we use a single manager , which must be reconnected to a new memory folder and eventually to a new file after reading each event .",
    "this connexion time is also something we have closely looked at during the analysis of the results .",
    "provided one uses the option -p of rootcint , root has very greatly improved its support of foreign classes , templates and std containers .",
    "it is now also possible to enforce the respect of ansi c++ when compiling .",
    "however , there are still some issues with the use of root that we discuss below .",
    "we really lack a central place where would be documented which subset of c++ is supported in the interpreter , which subset can be made persistent , which one can be used within a ttree , and which one can be used with a tclonesarray within a ttree . since the root team consider as a bug whatever is not supported , they try to fix any such case rather than report it . as a result , each user must rediscover by himself the unsupported cases , when they do not do invisible damage .",
    "it has proved painful to write the configuration files for the generation of dictionaries .",
    "one must explicit all the classes which must be parsed , and in the right order .",
    "even with only seven top classes to be made persistent , we felt the need to write a perl script for the generation of the linkdef file .",
    "a key cause is that when one parses a given class , one must have parsed before all the classes of all the attributes , including each instanciated template .",
    "we wonder if one could not find a way to automatize this within rootcint .",
    "since we handle a very large number of minimum bias files with the same internal tree , it was rather logical to use an instance of tchain .",
    "actually , the fact that tchain inherits from ttree is misleading .",
    "in particular , if you get the branches and customize them , all your changes will disappear when the chain move internally to a new file .",
    "thus , you must detect yourself any change of file and do again the branch customizations . in our use - case of random events and detailed branch tuning ,",
    "tchain has finally not proved helpful .",
    "when one attaches a branch to a given variable , it does not give the address of a variable , but the adress of a pointer to a variable .",
    "this will let any c++ programmer think that he can change later the pointer value , so to fill another variable .",
    "this is not true !",
    "we can not imagine any technical reason for this , but if such an obstacle exists , the signature of the attachment method should be changed for the address of a variable .",
    "this class has really turned out to be hard to understand , with a least six size - like methods .",
    "we can understand that this comes from backward compatibility constraints , but still it is a problem as this class is the central piece of the persistency service .",
    "our proposal to have a new root collection class for the persistency ( without gaps ! ) has not been supported by the root team .",
    "actually , much work is currently done for the efficient support of std::vector < t > , and we guess that this class could become what we would like to see .      a few options can be set before compiling , thanks to macros in the central header file .",
    "they have been kept as compilation option because it was hard to make them runtime options , and not necessarily useful . here",
    "they are :    * rtb_foreign : if set ( the default ) , the persistent classes are not instrumented with the macro classdef , and they will be considered as foreign classes by root . * rtb_tobjects : if set ( not the default ) , the top persistent classes inherit from tobject and are instrumented with classdef ( whatever the value of rtb_foreign ) .",
    "if not set , it implies the use of the rtbobj < t > when appending the objects to root containers and the use of rtbclassdef < t > when putting them into a dynamic c array . *",
    "rtb_reset : if set ( not the default ) , the empty constructors of the persistent classes set all their attributes to 0 ( we were expecting an eventual impact on the compression performance ) .    at runtime , one must choose within four kinds of containers and three kinds of persistent managers .",
    "this leads to twelves base strategies .",
    "all the testbed results will be displayed as an array of twelve cells corresponding to these strategies ( see table [ t1 ] ) .",
    "[ cols=\"^,^,^,^,^\",options=\"header \" , ]     [ t5 ]    on top of that , if we reduce by a factor of ten the number of elements we have in the events ( table [ t5 ] ) , the effect on the specialized root classes is even worse : the strategy tree / clones becomes the worst strategy ( apart from tree / c and * /objarray ) !",
    "the lesson is quite clear : in our specific cms use - case , the use of ttree and tclonesarray is by far the most efficient strategy , but this can not be generalized .",
    "it highly depends on the volume of data and the amount of randomness .",
    "resetting the attributes to 0 in the empty constructors of the event data does not appear to help compression .",
    "so after trying it , we went back to an implementation where the empty contructors let undefined values in the attributes .",
    "unsetting rtb_foreign or setting rtb_tobjects has not greatly improved the performance of the root collections , so we turned back to the use of our templated wrappers rtbclassdef < t > and rtbobj < t>.    for what concerns the write cpu time of the different strategies , the twelve strategies compares almost similarly : only the tree/ * strategies are found slightly slower .    at last , we must confess we did not systematically build the whole set of 500 crossings that is specified by the use - case .",
    "when we did , we always noticed that the overall performance was slightly better .",
    "we have succeeded to read pseudo - random entries from a tchain and to dispatch them to a few hundred tfolders ( despite the fact thar the tuning of the tchain branches has not been straightforward ) .",
    "support for foreign classes , templates and c++ standard library has greatly improved in the recent releases of root .",
    "the magic couple ttree / tclonesarray has proved very efficient for our use - case , yet it requires top level tobjects and the benefits can become losses with smaller data volume or random access pattern .",
    "one can simply use stl vectors and store them directly into root files .",
    "their integration in a ttree is not yet as good as a tclonesarray , but this could change in a future release of root .    if this testbed were to be improved , one major step would be to add real pointers or trefs between the objects ( instead of the current indexes ) and measure the impact on performance .",
    "you can obtain the testbed source code ( for linux with gmake and gcc ) by contacting the authors .",
    "9 `` cms technical proposal '' , cern / lhcc 94 - 38 , lhcc / p1 , dec 15 , 1994 .",
    "b. tanenbaum , `` implementation of persistency in the cms framework '' , chep , san diego , 2003 .",
    "`` the spring 2002 daq tdr production '' , cms note-2002/034 ."
  ],
  "abstract_text": [
    "<S> the simulation of cms raw data requires the random selection of one hundred and fifty pileup events from a very large set of files , to be superimposed in memory to the signal event . </S>",
    "<S> the use of root i / o for that purpose is quite unusual : the events are not read sequentially but pseudo - randomly , they are not processed one by one in memory but by bunches , and they do not contain orthodox root objects but many foreign objects and templates . in this context , we have compared the performance of root containers versus the stl vectors , and the use of trees versus a direct storage of containers . </S>",
    "<S> the strategy with best performances is by far the one using clones within trees , but it stays hard to tune and very dependant on the exact use - case . </S>",
    "<S> the use of stl vectors could bring more easily similar performances in a future root release . </S>"
  ]
}