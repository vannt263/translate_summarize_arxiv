{
  "article_text": [
    "freshml and the language systems that it has inspired provide some user - friendly facilities within the context of strongly typed functional programming for computing with syntactical data structures involving names and name binding .",
    "the underlying theory was presented in  @xcite and has been realised in the fresh patch of objective caml  @xcite .",
    "freshml has also inspired pottier s c@xmath0ml tool  @xcite for objective caml and cheney s freshlib library  @xcite for haskell .",
    "the approach taken to binding in all these works is `` nominal '' in that the user is given access to the names of bound entities and can write syntax manipulating programs that follow the informal practice of referring to @xmath0-equivalence classes of terms via representatives .",
    "however , in freshml the means of access to bound names is carefully controlled by the type system .",
    "it has been shown  @xcite that its static and dynamic properties combine to guarantee a certain `` correctness of representation '' property : data structures representing @xmath0-equivalent syntactical terms ( that is , ones differing only in the names of bound entities ) always behave the same in any program .",
    "so even though programs can name names , as it were , @xmath0-equivalence of name bindings is taken care of automatically by the programming language design .",
    "@xmath1    of course such a correctness of representation property depends rather delicately upon which operations on bound names are allowed . at the heart of this approach to binding is an operation that we call _ generative unbinding_. to explain what it involves , consider a simplified version of fresh objective caml with a single type @xmath2 of bindable names and a parametric family of types @xmath3 classifying abstractions of single names over values of type @xmath4 .",
    "to explain : both @xmath2 and @xmath3 are abstract types that come with the signature of operations shown in figure  [ fig : signb ] .",
    "the closed values of type @xmath2 are drawn from a countably infinite set @xmath5 of symbols that we call _",
    "atoms_. programs only get access to atoms by evaluating the expression @xmath6 to get a fresh one ; and hence program execution depends upon a state recording the atoms that have been created so far . given a type @xmath7 , closed values of type @xmath8 are called _ atom bindings _ and are given by pairs @xmath9 consisting of an atom @xmath10 and a closed value @xmath11 .",
    "atom bindings are constructed by evaluating @xmath12 .",
    "fresh objective caml provides a very convenient form of generative pattern - matching for deconstructing atom bindings . to keep things simple , here",
    "we will avoid the use of pattern - matching and consider an equivalent mechanism for deconstructing atom binding via an @xmath13 function carrying out generative unbinding : @xmath14 evaluates by first evaluating @xmath6 to obtain a fresh atom @xmath15 and then returning the pair @xmath16 , where in general @xmath17 denotes the value obtained from @xmath18 by renaming all occurrences of @xmath19 to be @xmath15 .",
    "the instance of renaming that arises when evaluating @xmath14 is special : the fresh atom @xmath15 does not occur in @xmath18 and so @xmath17 is equivalent to the result of applying to @xmath18 the semantically better behaved operation of _ swapping _ @xmath19 and @xmath15 .",
    "although implementing such an atom swapping operation on all types of values is the main extension that the fresh patch makes to objective caml , we have not included a @xmath20 operation in the signature of figure  [ fig : signb ] .",
    "this is because it is possible for users to define atom swapping themselves for specific types on a case - by - case basis .",
    "although this approach has some limitations , is enough for our purposes here .",
    "( the approach is more useful in the presence of haskell - style type classes ",
    "see  @xcite . )    the type @xmath3 is used in data type declarations in the argument type of value constructors representing binders . to take a familiar example",
    ", the terms of the untyped @xmath21-calculus ( all terms , whether open or closed , with variables given by atoms @xmath22 ) @xmath23 can be represented by closed values of the type @xmath24 given by the declaration @xmath25{rcl }      { { \\mathsf{term } } } & { \\mathbin{{\\mathsf{= } } } } & { { \\mathsf{v } } } { \\mathbin{{\\mathsf{of}}}}{{\\mathsf{atm}}}\\\\      & { \\mathrel{{\\mathsf{| } } } } & { { \\mathsf{l } } } { \\mathbin{{\\mathsf{of}}}}{{\\mathsf{term}}}\\,{{\\mathsf{bnd}}}\\\\      & { \\mathrel{{\\mathsf{| } } } } & { { \\mathsf{a } } } { \\mathbin{{\\mathsf{of}}}}{{\\mathsf{term}}}{\\mathbin{{\\mathsf{*}}}}{{\\mathsf{term}}}\\;.    \\end{array}\\ ] ] the value @xmath26 representing a @xmath21-term @xmath27 is defined by @xmath28{rcl }      { \\ulcorner{a}\\urcorner } & { \\triangleq } & { { \\mathsf{v}}}\\,{a}\\\\      { \\ulcorner\\lambda{a}.t\\urcorner } & { \\triangleq } & { { \\mathsf{l}}}\\,{\\mathopen{\\text{\\normalfont\\guillemotleft}}{a}\\mathclose{\\text{\\normalfont\\guillemotright}}{\\ulcornert\\urcorner}}\\\\      { \\ulcornert_1\\,t_2\\urcorner } & { \\triangleq } & { { \\mathsf{a}}}{{\\mathopen{{\\mathsf{(}}}}{\\ulcornert_1\\urcorner}\\mathbin{{\\mathsf{,}}}{\\ulcornert_2\\urcorner}{\\mathclose{{\\mathsf { ) } } } } }    \\end{array}\\ ] ] and satisfies :    _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ * correctness of representation * : _ two @xmath21-terms are @xmath0-equivalent , @xmath29 , iff @xmath30 and @xmath31 are contextually equivalent closed values of type @xmath24 , i.e.  can be used interchangeably in any well - typed fresh objective caml program without affecting the observable results of program execution . _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _    since it is also the case that every closed value of type @xmath24 is of the form @xmath32 for some @xmath21-term @xmath27 , it follows that there is a bijection between @xmath0-equivalence classes of @xmath21-terms and contextual equivalence classes of closed values of type @xmath24 .",
    "the correctness of representation property is not easy to prove because of the nature of contextual equivalence , with its quantification over all possible program contexts .",
    "it was established in  @xcite using denotational methods that take permutations of atoms into account .",
    "the same methods can be used to generalise from the example of @xmath21-terms to terms over any _ nominal signature _ in the sense of  @xcite .      for the signature in figure  [ fig : signb ] ,",
    "the only operation on atoms apart from @xmath33 is a test for equality : @xmath34 evaluates to @xmath35 if @xmath19 and @xmath15 are the same atom and to @xmath36 otherwise . adding extra operations and relations for",
    "atoms may well change which program phrases are contextually equivalent .",
    "is it possible to have some relations or operations on atoms in addition to equality without invalidating the above correctness of representation property ?",
    "for example it would be very useful to have a linear order @xmath37 , so that values of type @xmath2 could be used as keys in efficient data structures for finite maps and the like .",
    "we show that this is possible , and more .",
    "this is a rather unexpected result , for the following reason .",
    "the proof of the correctness of representation property given in  @xcite relies upon _ equivariant _ properties of the semantics , in other words ones whose truth is invariant under permuting atoms .",
    "atom equality is equivariant : since a permutation is in particular bijective , it preserves and reflects the value of @xmath34 . at first",
    "it seems that a linear order on atoms can not be equivariant , since if @xmath38 is true , then applying the permutation swapping @xmath19 and @xmath15 we get @xmath39 , which is false . however , equivariance is a global property : when considering invariance of the truth of a property under permutations , it is crucial to take into account all the parameters upon which the property depends .",
    "here there is a hidden parameter : _ the current state of dynamically created atoms_. so we should permute the atoms in this state as well as the arguments of the relation .",
    "we shall see that it is perfectly possible to have a state - dependent equivariant ordering for the type @xmath2 without invalidating the correctness of representation property .",
    "indeed we prove that _ one can add any @xmath40-ary function from @xmath2 to numbers _ ( or to booleans , for that matter ) _ whose semantics is reasonable _ ( we explain what is reasonable in section  [ sec : observations - atoms ] ) _ , without invalidating the correctness of representation property for any nominal signature . _    we have to work quite hard to get this result , which generalises the one announced in @xcite ( with a flawed proof sketch ) and finally proved in  @xcite ; but whereas those works uses denotational techniques , here we use an arguably more direct approach based on the operational semantics of the language .",
    "we obtain the correctness result ( theorem  [ thm : corr ] ) as a corollary of more general result ( propositions  [ prop : ext - bind-1 ] and [ prop : ext - bind-2 ] ) showing that , up to contextual equivalence , the type @xmath8 behaves like the atom - abstraction construct of  ( * ? ? ?",
    "* sect .  5 ) .",
    "along the way to these results we prove a mason - talcott - style `` ciu ''  @xcite characterisation of contextual equivalence for our language ( theorem  [ thm : ciu ] ) .",
    "this is proved using howe s method  @xcite applied to a formulation of the operational semantics with felleisen - style evaluation contexts  @xcite , via an abstract machine with frame stacks  @xcite . the proof technique underlying",
    "our work is rule - based induction , but with the novel twist that we exploit semantic properties of freshness of names that are based on the use of name permutations and that were introduced in @xcite and developed in  @xcite .",
    "we use a version of freshml that provides the signature in figure  [ fig : signb ] in the presence of higher order recursively defined functions on user declared data structures .",
    "its syntax is given in figure  [ fig : lans ] .",
    "@xmath41      \\text{\\emph{values } }       & { v}\\in{\\mathit{val}}&\\!\\!\\!\\!::=\\\\      & \\makebox[0pt][r]{variable } & { x}\\\\      & \\makebox[0pt][r]{unit } & { { \\mathopen{{\\mathsf{(}}}}{\\mathclose{{\\mathsf{)}}}}}\\\\      & \\makebox[0pt][r]{pair } & { { \\mathopen{{\\mathsf{(}}}}{v}\\mathbin{{\\mathsf{,}}}{v}{\\mathclose{{\\mathsf{)}}}}}\\\\      & \\makebox[0pt][r]{recursive function } & { { \\mathsf{fun}}}({f}\\,{x}{\\mathbin{{\\mathsf{=}}}}{e})\\\\      & \\makebox[0pt][r]{data construction } & { { \\mathsf{c}}}\\,{v}\\\\      & \\makebox[0pt][r]{atom } & { a}\\\\      & \\makebox[0pt][r]{atom binding } & { \\mathopen{\\text{\\normalfont\\guillemotleft}}{v}\\mathclose{\\text{\\normalfont\\guillemotright}}{v}}\\\\[\\jot ]      \\text{\\emph{expressions } }      & { e}\\in{\\mathit{exp}}&\\!\\!\\!\\!::=\\\\      & \\makebox[0pt][r]{value } & { v}\\\\      & \\makebox[0pt][r]{sequencing } & { \\mathop{{\\mathsf{let}}}}{{x}{\\mathbin{{\\mathsf{=}}}}{e } } { \\mathrel{{\\mathsf{in}}}}{e}\\\\      & \\makebox[0pt][r]{first projection } & { { \\mathsf{fst}}}\\,{v}\\\\      & \\makebox[0pt][r]{second projection } & { { \\mathsf{snd}}}\\,{v}\\\\      & \\makebox[0pt][r]{function application } & { v}\\,{v}\\\\      & \\makebox[0pt][r]{data deconstruction }       & { { \\mathsf{match}}}\\   { v}{\\mathbin{{\\mathsf{with}}}}({{{\\mathsf{c}}}\\,{x}{\\mathbin{\\rightarrow}}{e}}{\\mathrel{{\\mathsf{|}}}}\\cdots)\\\\      & \\makebox[0pt][r]{fresh atom } & { { \\mathsf{fresh}}}{{\\mathopen{{\\mathsf{(}}}}{\\mathclose{{\\mathsf{)}}}}}\\\\      & \\makebox[0pt][r]{generative unbinding } & { { \\mathsf{unbind}}}\\,{v}\\\\      & \\makebox[0pt][r]{atom observation } & { { \\mathsf{obs}}}\\,{v}\\cdots{v}\\\\[\\jot ]      \\text{\\emph{frame stacks } }       & { s}\\in{\\mathit{stk}}&\\!\\!\\!\\!::=\\\\      & \\makebox[0pt][r]{empty } & { \\mathit{id}}\\\\      & \\makebox[0pt][r]{non - empty } & { s}{\\circ}({x}.{e})\\\\      \\text{\\emph{states } }      & { \\vec{a}}\\in{\\mathit{state}}&\\!\\!\\!\\!{\\triangleq}\\text{finite lists of distinct atoms}\\\\      \\makebox[0pt][l]{\\text{\\emph{machine configurations } } }      & & { \\langle{\\vec{a } } , { s } , { e}\\rangle}\\\\[\\jot ]      \\text{\\emph{types } }       & { \\tau}\\in{\\mathit{typ}}&\\!\\!\\!\\!::=\\\\      & \\makebox[0pt][r]{unit } & { { \\mathsf{unit}}}\\\\      & \\makebox[0pt][r]{pairs } & { \\tau}{\\mathbin{{\\mathsf{*}}}}{\\tau}\\\\      & \\makebox[0pt][r]{functions } & { \\tau}{\\mathbin{\\rightarrow}}{\\tau}\\\\      & \\makebox[0pt][r]{data type } & { \\delta}\\\\      & \\makebox[0pt][r]{atoms } & { { \\mathsf{atm}}}\\\\      & \\makebox[0pt][r]{atom bindings } & { \\tau}\\,{{\\mathsf{bnd}}}\\\\      \\makebox[0pt][l]{\\text{\\emph{typing environments } } }      & \\gamma & \\!\\!\\!\\!\\!\\in { \\mathbb{v}}{\\stackrel{\\mathrm{fin}}{\\rightarrow}}{\\mathit{typ}}\\\\      \\makebox[0pt][l]{\\text{\\emph{typing judgements } } } & & \\\\      & \\makebox[0pt][r]{expressions \\ & values }      & \\gamma{\\vdash}{e}{:}{\\tau}\\\\      & \\makebox[0pt][r]{frame stacks }      & \\gamma{\\vdash}{s}{:}{\\tau}{\\mathbin{\\rightarrow}}{\\tau}'\\\\[\\jot ]      \\text{\\emph{initial basis } } & & \\\\      & \\makebox[0pt][r]{natural numbers } & { { \\mathsf{nat}}}\\in{\\mathcal{d}}\\\\      & \\makebox[0pt][r]{zero } & ( { { \\mathsf{zero}}}{\\mathrel{{\\mathsf{:}}}}{{\\mathsf{unit}}}{\\mathbin{\\rightarrow}}{{\\mathsf{nat } } } ) \\in{\\mathcal{c}}\\\\      & \\makebox[0pt][r]{successor } & ( { { \\mathsf{succ}}}{\\mathrel{{\\mathsf{:}}}}{{\\mathsf{nat}}}{\\mathbin{\\rightarrow}}{{\\mathsf{nat } } } ) \\in{\\mathcal{c}}\\\\      & \\makebox[0pt][r]{atom equality } & { { \\mathsf{eq } } } \\in{\\mathcal{o}}\\quad ( { \\mathit{arity}}=2 )    \\end{array}\\ ] ]      the syntax of expressions and frame stacks in figure  [ fig : lans ] involves some variable - binding constructs . specifically :    * free occurrences of @xmath42 and @xmath43 in @xmath44 are bound in @xmath45 ; * free occurrences of @xmath43 in @xmath44 are bound in @xmath46 ; * for @xmath47 , free occurrences of @xmath48 in @xmath49 are bound in @xmath50 ; * free occurrences of @xmath43 in @xmath44 are bound in @xmath51 .    as usual ,",
    "_ we identify expressions and frame stacks up to renaming of bound variables_. we write @xmath52 for the finite set of free variables of an expression @xmath44 ( and similarly for frame stacks ) ; and we write @xmath53}}\\ ] ] for the simultaneous , capture avoiding substitution of values @xmath54 for all free occurrences of the corresponding variables @xmath55 in the expression @xmath44 ( well - defined up to @xmath0-equivalence of bound variables ) .",
    "@xmath56{@{}l }        { { \\mathsf{match}}}\\ { e}{\\mathbin{{\\mathsf{with}}}}{}\\\\        \\quad ( { { \\mathsf{zero}}}(){\\mathbin{\\rightarrow}}{e } ' { \\mathrel{{\\mathsf{|}}}}{{\\mathsf{succ}}}\\,{x}{\\mathbin{\\rightarrow}}{e } '' )      \\end{array }      & & ( { x}\\notin{\\mathit{fv}}({e}'')\\\\      { { \\mathsf{fresh}}}\\ { x}{\\mathrel{{\\mathsf{in}}}}{e}&{\\triangleq}{\\mathop{{\\mathsf{let}}}}{x}{\\mathbin{{\\mathsf{=}}}}{{\\mathsf{fresh}}}(){\\mathrel{{\\mathsf{in}}}}{e}\\\\      { \\mathop{{\\mathsf{let}}}}{{\\mathopen{\\text{\\normalfont\\guillemotleft}}{x}_1    \\mathclose{\\text{\\normalfont\\guillemotright}}{x}_2}{\\mathbin{{\\mathsf{=}}}}{e } } { \\mathrel{{\\mathsf{in}}}}{e } ' & { \\triangleq}\\begin{array}[t]{@{}l }        { \\mathop{{\\mathsf{let}}}}{x}{\\mathbin{{\\mathsf{=}}}}{e}{\\mathrel{{\\mathsf{in}}}}\\\\        { \\mathop{{\\mathsf{let}}}}{x}'{\\mathbin{{\\mathsf{=}}}}{{\\mathsf{unbind}}}\\,{x}{\\mathrel{{\\mathsf{in}}}}\\\\        { \\mathop{{\\mathsf{let}}}}{x}_1{\\mathbin{{\\mathsf{=}}}}{{\\mathsf{fst}}}\\,{x}'{\\mathrel{{\\mathsf{in}}}}\\\\        { \\mathop{{\\mathsf{let}}}}{x}_2{\\mathbin{{\\mathsf{=}}}}{{\\mathsf{snd}}}\\,{x}'{\\mathrel{{\\mathsf{in}}}}{e } '      \\end{array }      & &      ( \\begin{array}[t]{@{}l }        { x},{x}'\\notin{\\mathit{fv}}({e}')\\\\        { x}'\\not={x } , { x}_1\\not={x}_2 )      \\end{array}\\\\       { { \\mathsf{obs}}}\\,{e}_1\\cdots{e}_n & { \\triangleq}\\begin{array}[t]{@{}l }        { \\mathop{{\\mathsf{let}}}}{x}_1{\\mathbin{{\\mathsf{=}}}}{e}_1{\\mathrel{{\\mathsf{in}}}}\\\\        \\cdots\\\\        { \\mathop{{\\mathsf{let}}}}{x}_n{\\mathbin{{\\mathsf{=}}}}{e}_n{\\mathrel{{\\mathsf{in}}}}{{\\mathsf{obs}}}\\,{x}_1\\cdots{x}_n      \\end{array }      & &      ( \\begin{array}[t]{@{}l }        { x}_1,\\ldots,{x}_n\\notin{\\mathit{fv}}({e}_1,\\ldots,{e}_n)\\\\        { x}_1,\\ldots,{x}_n\\ \\text{distinct } ) .",
    "\\end{array }    \\end{aligned}\\ ] ]      the expressions in figure  [ fig : lans ] are given in a `` reduced '' form ( also called `` a - normal '' form  @xcite ) , in which the order of evaluation is made explicit through @xmath57-expressions .",
    "this is not essential : the use of reduced form makes the development of properties of the language s dynamics more succinct and that is mostly what we are concerned with here .",
    "however , when giving example expressions it is convenient to use the `` unreduced '' forms given in figure  [ fig : unrfe ] .",
    "[ rem : objlb ] as well as variables ( standing for unknown values ) , the language s expressions and frame stacks may contain _ atoms _ drawn from a fixed , countably infinite set @xmath5 .",
    "as discussed in the introduction , atoms are used to represent names in the object - level languages that are being represented as data in this programming meta - language . in particular a value of the form @xmath9",
    "is used to represent the object - level binding of a name @xmath19 in the value @xmath18 .",
    "however , note that there are no atom - binding constructs at the programming meta - level .",
    "the reader ( especially one used to using lambda - abstraction to represent all forms of statically - scoped binding ) may well ask why ? why can not we factor out by @xmath58-bound atoms and thereby trivialise ( one half of ) the correctness of representation result referred to in the introduction ?",
    "the reason is that it does not make semantic sense to try to regard @xmath59 as a form of meta - level binding and identify all expressions up to an @xmath0-equivalence involving renaming @xmath58-bound atoms .",
    "for example , if @xmath19 and @xmath15 are two different atoms , such an @xmath0-equivalence would identify @xmath60 with @xmath61 .",
    "however , these are two semantically different values : they are not contextually equivalent in the sense discussed in section  [ sec : cont - equiv ] . for example , the operational semantics described below gives observably different results ( @xmath62 and @xmath63 respectively ) when we place the two expressions in the context @xmath64\\,{a } } { \\mathrel{{\\mathsf{in}}}}{{\\mathsf{eq}}}\\,{x}_1\\,{x}_2\\ ] ] ( where @xmath65 is the observation for atom - equality that we always assume is present  see remark  [ sec : observations - atoms ] ) .",
    "the reason for this behaviour is that variables in freshml - like languages stand for unknown values that may well involve atoms free at the object level .",
    "we may get capture of such atoms within the scope of an atom - binding @xmath59 during evaluation . in the example",
    ", we replaced the hole in @xmath66\\,{a}$ ] with @xmath60 and @xmath61 respectively , yielding expressions that evaluate to @xmath67 and @xmath68the first involving capture and the second not ; and such capturing substitution does not respect naive @xmath0-equivalence .",
    "so the relation of contextual equivalence that we define in section  [ sec : cont - equiv ] does not contain this naive @xmath0-equivalence that identifies all ( open or closed ) expressions up to renaming of @xmath58-bound atoms .. there are also less naive versions of object - level @xmath0-equivalence that respect possibly - capturing substitution , such as the one developed in @xcite involving hypothetical judgements about freshness of atoms for variables ; contextual equivalence and `` contextual freshness '' should form a model of this notion , but we do not pursue this here .",
    "] however , we will show ( theorem  [ thm : corr ] ) that when we restrict to closed expressions representing object - level languages , then contextual equivalence does contain ( indeed , coincides with ) this form of @xmath0-equivalence : this is the correctness of representation result referred to in the introduction .",
    "+    notation :    * @xmath69 indicates the typing environment obtained by extending the finite partial function @xmath70 by mapping a variable @xmath43 to the type @xmath7 ( we always assume that @xmath71 ) . * in the typing rule for @xmath72-expressions , the hypothesis `` @xmath73 '' refers to the top - level data type declaration  ; in other words , the only constructors whose result type is @xmath74 are @xmath75 and @xmath76 is the argument type of @xmath77 ( for @xmath47 ) .",
    "the language defined in figure  [ fig : signb ] is parameterised by the choice of a finite set @xmath78 of function symbols that we call _ observations on atoms _ and whose role is discussed in section  [ sec : observations - atoms ] , by a finite set @xmath79 of _ data type _ symbols , and by a finite set @xmath80 of _ constructor _ symbols .",
    "each constructor @xmath81 is assumed to come with a type , @xmath82 , where @xmath83 and @xmath84 .",
    "the choice of @xmath79 , @xmath80 and this typing information constitutes an ml - style top - level declaration of some ( possibly mutually recursive ) data types : @xmath85 here @xmath86 ( for @xmath87 ) are the distinct elements of the set @xmath79 of data type symbols and @xmath88 ( for @xmath87 and @xmath89 ) are the distinct elements of the set @xmath80 of constructor symbols .",
    "the above declaration just records the typing information @xmath90 that comes with each constructor , grouped by result types : @xmath86 appears as the result type of precisely the constructors @xmath91 and their argument types are @xmath92 . for the moment",
    "we place no restriction on these types @xmath93 : they can be any element of the set @xmath94 whose grammar is given in figure  [ fig : lans ] .",
    "however , when we consider representation of object - level languages up to @xmath0-equivalence in section  [ sec : corr - repr ] , we will restrict attention to top - level data type declarations where the types @xmath93 do not involve function types .",
    "we consider observations on atoms that return natural numbers .",
    "( the effect of admitting some other types of operation on atoms is discussed in section  [ sec : atoa ] . )",
    "so we assume @xmath79 always contains a distinguished data type @xmath95 for the type of natural numbers and that correspondingly @xmath80 contains constructors @xmath96 and @xmath97 for zero and successor .",
    "each @xmath98 denotes a numerical function on atoms .",
    "we assume it comes with an _ arity _ , specifying the number of arguments it takes : so if @xmath99 and @xmath100 is a @xmath101-tuple of values of type @xmath2 , then @xmath102 is an expression of type @xmath95 .",
    "the typing of the language s values , expressions and frame stacks takes place in the presence of typing environments , @xmath70 , each assigning types to finitely many variables .",
    "the rules in figure  [ fig : typr ] for the inductively defined typing relation are entirely standard , given that we are following the signature in fig  [ fig : signb ] .    as well as an arity",
    ", we assume that each @xmath98 comes with a specified interpretation : the form this takes is discussed in section  [ sec : observations - atoms ] .",
    "[ exa : swa ] examples of programming in freshml using its characteristic feature of generatively unbinding atom - binding values may be found in @xcite .",
    "another feature of freshml , the operation of swapping atoms , has been left out of the grammar in figure  [ fig : lans ] . however , as we mentioned in the introduction , there is a type - directed definition of swapping , @xmath103 , for this language .",
    "for example , when @xmath7 is the type @xmath2 of atoms we can make use of the observation @xmath65 for atom - equality that we always assume is present ( see remark  [ sec : observations - atoms ] ) together with the abbreviations in figure  [ fig : unrfe ] and define @xmath104 at unit , product , function and atom - binding types we can make use of standard definitions of permutation action for these types of data ( see  ( * ? ? ?",
    "* section  3 ) , for example ) : @xmath105 at data types we have to make recursive definitions corresponding to the inductive nature of the data types .",
    "for example , if we assume that in addition to the data type @xmath95 for natural numbers we just have a data type @xmath24 as in , then we can define @xmath106{@{}l@{}l }        ( & { { \\mathsf{v}}}\\,{z}_1 { \\mathbin{\\rightarrow}}{{\\mathsf{v}}}(\\mathit{swap}_{{{\\mathsf{atm}}}}{x}\\,{y}\\,{z}_1)\\\\        { \\mathrel{{\\mathsf{| } } } } & { { \\mathsf{l}}}\\,{z}_1 { \\mathbin{\\rightarrow}}\\begin{array}[t]{@{}l }          { \\mathop{{\\mathsf{let}}}}{{\\mathopen{\\text{\\normalfont\\guillemotleft}}{z}_2    \\mathclose{\\text{\\normalfont\\guillemotright}}{z}_3}{\\mathbin{{\\mathsf{=}}}}{z}_1 } { \\mathrel{{\\mathsf{in}}}}\\\\          \\quad { { \\mathsf{l}}}({\\mathopen{\\text{\\normalfont\\guillemotleft}}\\mathit{swap}_{{{\\mathsf{atm}}}}{x}\\,{y}\\,{z}_2    \\mathclose{\\text{\\normalfont\\guillemotright}}(f\\,{z}_3 ) } )        \\end{array}\\\\        { \\mathrel{{\\mathsf{| } } } } & { { \\mathsf{a}}}\\,{z}_1 { \\mathbin{\\rightarrow}}{{\\mathsf{a}}}(f({{\\mathsf{fst}}}\\,{z}_1 ) , f({{\\mathsf{snd}}}\\,{z}_1))\\ , ) ) .",
    "\\end{array }    \\end{aligned}\\ ] ] ( the fact that values of type @xmath95 do not involve atoms means that the above systematic definition of @xmath107 is in fact contextually equivalent to @xmath108 . )    [ cols=\"^\",options=\"header \" , ]     1 .",
    "[ item:1 ] @xmath109}}\\rangle}$ ] 2 .",
    "[ item:2 ] @xmath110 3 .",
    "[ item:3 ] @xmath111}}\\rangle}$ ] 4 .",
    "[ item:4 ] @xmath112 5 .",
    "[ item:5 ] @xmath113 6 .",
    "[ item:6 ] @xmath114}}\\rangle}$ ] if @xmath115 7 .",
    "[ item:7 ] @xmath116 if @xmath117 8 .",
    "[ item:8 ] @xmath118 if @xmath117 9 .   [ item:9 ]",
    "@xmath119 if @xmath99 , @xmath120 and @xmath121    notation :    * @xmath17 is the result of replacing all occurrences of an atom @xmath19 by an atom @xmath15 in the value @xmath18 ; * @xmath122 is the finite set of all atoms occurring in @xmath123 ; * @xmath124 is the state obtained by appending an atom @xmath15 not in @xmath125 to the right of the finite list of distinct atoms @xmath126 ; * @xmath127 is the the closed value of type @xmath95 corresponding to @xmath128 : @xmath129 and @xmath130 ; * @xmath131 is the meaning of @xmath132 : see section  [ sec : observations - atoms ] .",
    "the abstract machine that we use to define the language s dynamics has configurations of the form @xmath133 . here",
    "@xmath44 is the expression to be evaluated , @xmath134 is a stack of evaluation frames and @xmath126 is a finite list of distinct atoms that have been allocated so far .",
    "figure  [ fig : trar ] defines the transition relation between configurations that we use to give the language s operational semantics .",
    "the first six types of transition are all quite standard .",
    "transition  [ item:7 ] defines the dynamic allocation of a fresh atom and transition  [ item:8 ] defines generative unbinding using a freshly created atom ; we discuss transition  [ item:9 ] for observations on atoms in the next section . for the atom @xmath15 in  [ item:7 ] to really be fresh , we need to know that it does not occur in @xmath134 ; similarly , in  [ item:8 ] we need to know that @xmath15 does not occur in @xmath135 . these requirements are met if configurations @xmath133 satisfy that all the atoms occurring in the frame stack @xmath134 or the expression @xmath44 occur in the list @xmath126 . using the notation @xmath136 mentioned in figure  [ fig : trar ] , we write this condition as @xmath137 theorem  [ thm : typs ] shows that this property of configurations is invariant under transitions , as is well - typedness . before stating this theorem we introduce some useful terminology .    a ( _ possible _ ) _ world _",
    "@xmath138 is just a finite subset of the the fixed set @xmath5 of atoms .",
    "we write @xmath139 for the set of all worlds .    in what follows",
    "we will index various relations associated with the language we are considering by worlds @xmath140 that make explicit the atoms involved in the relation .",
    "sometimes ( as in the following theorem ) this is merely a matter of notational convenience ; world - indexing will be more crucial when we consider program equivalence : see remark  [ rem : posw ] below .",
    "[ thm : typs ] write @xmath141 to mean that @xmath142 and that there is some type @xmath143 with @xmath144 and @xmath145 .",
    "the type system has the following properties .",
    "preservation : :    if    @xmath141    and    @xmath146 ,    with @xmath147 say , then    @xmath148 and    @xmath149 .",
    "progress : :    if    @xmath141 ,    then either @xmath150 and    @xmath151 , or    @xmath146    holds for some @xmath152 , @xmath153 and    @xmath154",
    ".    the proof of these properties is routine and is omitted .",
    "[ rem : altos ] it is worth remarking that there are alternative approaches to representing object - level binding of a name @xmath19 in a value @xmath18 in freshml - like languages . in the original paper on freshml  @xcite ,",
    "the authors make a distinction between non - canonical expressions @xmath155 for atom - binding and the `` semantic values '' @xmath156 to which they evaluate . that paper gives an operational semantics in the style of the definition of standard ml  @xcite in which programming language expressions are separate from semantic values .",
    "it is possible to identify such semantic values up to @xmath0-equivalence of @xmath157-bound atoms without the kind of inconsistency illustrated in remark  [ rem : objlb ] .",
    "( such semantic values in which @xmath158 is a binder are used by pottier  @xcite , albeit for first - order values . )",
    "however , this does not help to simplify the type of correctness of representation result in which we are interested here , because programs are written using expressions , not semantic values .",
    "for example , identifying semantic values in this way , @xmath159 and @xmath160 are identical and hence trivially contextually equivalent ; however the expressions @xmath161 and @xmath162 ( that here we write as @xmath67 and @xmath163 ) are not equal and there is something to be done to prove that they are contextually equivalent . in the operational semantics of  @xcite these expressions",
    "evaluate to the same semantic value up to @xmath0-equivalence ; so one would need to prove that contextual equivalence for that language contains `` kleene equivalence''for example by proving a `` ciu '' theorem like our theorem  [ thm : ciu ] below .",
    "so it is probably possible to develop the results of this paper using this slightly more abstract style of operational semantics with semantic values identified up to @xmath0-equivalence of bound atoms .",
    "however our experience is that the style of operational semantics we use here , in which semantic values are identified with certain canonical expressions ( but necessarily not identified up @xmath0-equivalence of bound atoms , for the reasons discussed in remark  [ rem : objlb ] ) leads to a simpler technical development overall .",
    "@xmath164 &    @xmath165 +    the language we are considering is parameterised by a choice of a finite set @xmath78 of numerical functions on atoms .",
    "we assume that each @xmath98 comes with a specified meaning @xmath131 . as mentioned in the introduction",
    ", we should allow these meanings to be dependent on the current state ( the list of distinct atoms that have been created so far ) .",
    "so if @xmath99 , for each @xmath166 we assume given a function @xmath167 mapping @xmath101-tuples of atoms occurring in the state @xmath126 to natural numbers .",
    "these functions are used in the transitions of type [ item:9 ] in figure  [ fig : trar ] .",
    "not every such family @xmath168 of functions is acceptable as an observation on atoms : we require that the family be _",
    "equivariant_. to explain what this means we need the following definition .",
    "[ def : perms ] a finite _ permutation _ of atoms is a bijection @xmath169 from the set @xmath5 of atoms onto itself such that @xmath170 is a finite set .",
    "we write @xmath171 for the set of all such permutations . if @xmath172 and @xmath166 , then @xmath173 denotes the finite list of distinct atoms obtained by mapping @xmath169 over the list @xmath126 ; if @xmath44 is an expression , then @xmath174 denotes the expression obtained from it by applying @xmath169 to the atoms in @xmath44 ; and similarly for other syntactical structures involving finitely many atoms , such as values and frame stacks .",
    "we require the functions @xmath168 associated with each @xmath98 to satisfy an _ equivariance _ property : for all @xmath172 , @xmath166 and @xmath175 ( where @xmath101 is the arity of @xmath132 ) @xmath176 we impose condition   for the following reason . in figure",
    "[ fig : trar ] , the side conditions on transitions of types [ item:7 ] and [ item:8 ] do not specify which of the infinitely many atoms in @xmath177 should be chosen as the fresh atom @xmath15 .",
    "any particular implementation of the language will make such choices in some specific way , for example by implementing atoms as numbers and incrementing a global counter to get the next fresh atom .",
    "we wish to work at a level of abstraction that is independent of such implementation details .",
    "we can do so by ensuring that we only use properties of machine configurations @xmath133 that depend on the relative positions of atoms in the list @xmath126 , rather than upon their identities .",
    "so properties of configurations should be equivariant : if @xmath133 has the property , then so should @xmath178 for any @xmath172 .",
    "the main property of configurations we need is _ termination _ , defined in figure  [ fig : terr ] , since as we see in the next section this determines contextual equivalence of expressions . with condition",
    "we have :    [ lem : ter - equivar ] if @xmath164 , then @xmath179 for any @xmath172 .    in view of the definition of termination in figure  [ fig : terr ]",
    ", it suffices to show that the transition relation is equivariant : @xmath180 this can be proved by cases from the definition of @xmath181 in fig  [ fig : trar ] .",
    "cases [ item:1][item:8 ] follow from general properties of the action of permutations on syntactical structures ( such as the fact that @xmath182}})$ ] equals @xmath183}}$ ] ) ; case [ item:9 ] uses property .    as a corollary",
    "we find that termination is indeed independent of the choice of fresh atom in transitions of the form [ item:7 ] or [ item:8 ] .",
    "[ cor : some - any ] if @xmath184 with @xmath185 , then for all @xmath117 , it is the case that @xmath186 . similarly , if @xmath187 with @xmath188 , then for all @xmath117 , it is the case that @xmath189 .    there are observations on atoms that are not equivariant , that is , whose value on some atoms in a particular state does not depend just upon the relative position of those atoms in the state . for example , if we fix some enumeration of the set of atoms , @xmath190 , it is easy to see that the unary observation given by @xmath191 fails to satisfy",
    ". nevertheless , there is a wide range of functions that do have this property .",
    "figure  [ fig : exaoa ] gives some examples .",
    "@xmath192    [ rem : atoet ] the first observation on atoms given in figure  [ fig : exaoa ] , @xmath193 , combined with the usual arithmetic operations for @xmath95 that are already definable in the language , gives us the effect of the function @xmath194 from the signature in figure  [ fig : signb ] ; so _ we assume that the set @xmath78 of observations on atoms always contains @xmath193 .",
    "_    [ rem : freal ] note that in the operational semantics of figure  [ fig : trar ] we have chosen to make `` fresh atoms largest '' , in the sense that the fresh atom @xmath15 in transitions [ item:7 ] and [ item:8 ] is added to the right - hand end of the list @xmath126 representing the current state . in the presence of observations on atoms other than equality , such a choice may well affect the properties of the notion of program equivalence that we explore in the next section .",
    "other choices are possible , but to insist that program equivalence is independent of any such choice would rule out many useful observations on atoms ( such as @xmath195 or @xmath196 in figure  [ fig : exaoa ] ) .",
    "we wish to prove that the language we have described satisfies correctness of representation properties of the kind mentioned in the introduction .",
    "to do so , we first have to be more precise about what it means for two expressions to be _ contextually equivalent _ , that is , to be interchangeable in any program without affecting the observable results of executing that program . what is a program , what does it mean to execute it , and what results of execution do we observe ?",
    "the answers we take to these questions are : programs are closed well - typed expressions ; execution means carrying out a sequence of transitions of the abstract machine from an initial machine configuration consisting of a state ( that is , a list of atoms containing those mentioned in the program ) , the empty frame stack and the program ; and we observe whether execution reaches a terminal configuration , that is , one of the form @xmath197 .",
    "we need only observe termination because of the language s strict evaluation strategy : observing any ( reasonable ) properties of the final value @xmath18 results in the same notion of contextual equivalence .",
    "also , it is technically convenient to be a bit more liberal about what constitutes an initial configuration by allowing the starting frame stack to be non - empty : this does not change the notion of contextual equivalence because of the correspondence between frame stacks and `` evaluation '' contexts  see the remarks after definition  [ def : cone ] below .",
    "so we can say that @xmath44 and @xmath154 are contextually equivalent if for all program contexts @xmath198 $ ] , the programs @xmath199 $ ] and @xmath200 $ ] are _ operationally equivalent _ in the following sense .",
    "[ def : opee ] @xmath201 is defined to hold if    * @xmath202 ; * @xmath203 and @xmath204 ; and * for all @xmath126 , @xmath134 and @xmath143 with @xmath205 and @xmath206 , it is the case that @xmath207 .",
    "however , for the reasons given in ( * ? ? ?",
    "* section  7.5 ) , we prefer not to phrase the formal definition of contextual equivalence in terms of the inconveniently concrete operation of possibly capturing substitution of open expressions for the hole `` @xmath208 '' in program contexts @xmath198 $ ] . instead we take the more abstract relational approach originally advocated by gordon @xcite and lassen  @xcite that focuses upon the key features of contextual equivalence , namely that it is _ the largest congruence relation for well - typed expressions that contains the relation of operational equivalence of definition  [ def : opee ] . _ a congruence relation is an expression relation that is an equivalence , compatible and substitutive , in the following sense .",
    "+    [ def : expr ] an _ expression relation _",
    "@xmath209 is a set of tuples @xmath210 ( made up of a typing context , a world , two expressions and a type ) satisfying @xmath211 , @xmath212 and @xmath213 .",
    "we write @xmath214 to indicate that @xmath210 is a member of @xmath209 .",
    "we use the following terminology in connection with expression relations .",
    "* @xmath209 is an _ equivalence _ if it is reflexive ( @xmath215 ) , symmetric ( @xmath216 ) and transitive ( @xmath217 ) .",
    "* @xmath209 is _ compatible _ if @xmath218 , where @xmath219 is the _ compatible refinement _ of @xmath209 , defined in figure  [ fig : comr ] .",
    "* @xmath209 is _ substitutive _ if @xmath220}}{\\mathrel{\\mathcal{e}}}{e}'{{[{v}'/{x}]}}{:}{\\tau}'$ ] .",
    "* @xmath209 is _ equivariant _ if @xmath221 .",
    "* @xmath209 is _ adequate _ if @xmath222 .",
    "we extend operational equivalence ( definition  [ def : opee ] ) to an expression relation , @xmath223 , by instantiating free variables with closed values :    [ def : opeqo ] supposing @xmath224 , we define @xmath223 to hold if    * @xmath202 ; * @xmath212 and @xmath213 ; and * for all @xmath225 and all closed values @xmath226 with @xmath227 and @xmath228 ( for @xmath47 ) , it is the case that @xmath229 } } { \\cong}{e}'{{[\\vec{{v}}/\\vec{{x } } ] } } { : } { \\tau}$ ] .",
    "note that for closed expressions , that is , in the case that @xmath230 , the relation @xmath231 agrees with @xmath232 : @xmath233    [ thm : ciu ] operational equivalence of possibly open expressions , @xmath231 , is a compatible , substitutive and adequate equivalence .",
    "it is the largest such expression relation .",
    "it is also equivariant .",
    "the fact that @xmath231 is equivariant follows from lemma  [ lem : ter - equivar ] .",
    "the fact that it is an equivalence and adequate is immediate from its definition ; as is the fact that it contains any expression relation that is adequate , substitutive and reflexive .",
    "so the main difficulty is to show that it is compatible and substitutive .",
    "one can do this by adapting a construction due to howe  @xcite ; see appendix  [ app : proof - ciu - theorem ] .",
    "[ def : cone ] in view of the discussion at the beginning of this section , theorem  [ thm : ciu ] tells us that @xmath231 coincides with a conventional notion of contextual equivalence defined using program contexts : so from now on we refer to @xmath231 as _ contextual equivalence_.    [ rem : ciu ] we labelled the above theorem `` ciu '' because it is analogous to a theorem of that name due to mason and talcott  @xcite .",
    "ciu , after permutation , stands for `` uses of closed instantiations '' ; and the theorem tells us that to test open expressions for contextual equivalence it suffices to first close them by substituting closed values for free variables and then test the resulting closed expressions for termination when they are used in any _ evaluation context _  @xcite .",
    "this follows from the definition of @xmath231 and the fact that termination in evaluation contexts corresponds to termination of machine configurations via the easily verified property @xmath234}\\rangle}{{\\downarrow_{}}}\\ ] ] where the expression @xmath235}$ ] is defined by recursion on the length of the stack @xmath134 by : @xmath236{rcl }        { \\mathit{id}}[{e } ] & { \\triangleq } & { e}\\\\        { s}{\\circ}({x}.{e}')[{e } ] & { \\triangleq } & { s}{[{\\mathop{{\\mathsf{let}}}}{{x}{\\mathbin{{\\mathsf{=}}}}{e } } { \\mathrel{{\\mathsf{in}}}}{e}']}\\;.      \\end{array}\\ ] ]    theorem  [ thm : ciu ] serves to establish some basic properties of contextual equivalence , such as the fact that the state - independent transitions in figure  [ fig : trar ] ( types [ item:1][item:6 ] and [ item:9 ] ) give rise to contextual equivalences .",
    "for example , @xmath237 } } { : } { \\tau}'$ ] holds if @xmath238 and @xmath239 .",
    "however , we have to work a bit harder to understand the consequences of transitions of types [ item:7 ] and [ item:8 ] for contextual equivalence at atom binding types , @xmath8 .",
    "we address this in the next section .",
    "[ rem : posw ] it is immediate from the definition of @xmath231 that it satisfies a weakening property : @xmath240 if it also satisfied a strengthening property @xmath241 then we could make the indexing of contextual equivalence by `` possible worlds '' @xmath138 implicit by taking @xmath242 .",
    "when @xmath78 just contains @xmath193 , property does hold ; this is why there is no need for indexing by possible worlds in  @xcite . however , it is not hard to see that the presence of some observations on atoms , such as the function @xmath243 in figure  [ fig : exaoa ] , can cause to fail .",
    "it is for this reason that we have built indexing by possible worlds into expression relations ( definition  [ def : expr ] ) .",
    "recall from section  [ sec : generative - unbinding ] that the language we are considering is parameterised by a top - level declaration of some ( possibly mutually recursive ) data types : @xmath244 if we restrict attention to declarations in which the argument types @xmath93 of the constructors @xmath88 are just finite products of the declared data types @xmath245 , then the above declaration corresponds to a _ many - sorted algebraic signature _ ; furthermore , in this case the language s values at each data type are just the abstract syntax trees of terms of the corresponding sort in the signature . by allowing atoms and atom bindings in addition to products in the argument types @xmath93 ,",
    "one arrives at the notion of `` nominal signature '' , introduced in  @xcite and more fully developed in  @xcite .",
    "it extends the notion of many - sorted algebraic signature with names ( of possibly many kinds ) and information about name binding in constructors . here , for simplicity , we are restricting to a single kind of name , represented by the type @xmath2 of atoms ; but our results extend easily to the case of many kinds of name .    [",
    "def : noms ] the subset @xmath246 is given by the grammar @xmath247 where @xmath74 ranges over the finite set @xmath79 of data type symbols .",
    "( in other words @xmath248 consists of those types of our language that do not involve any use of the function type construction , @xmath249 . )",
    "the elements of the set @xmath248 are called _ nominal arities_. ( the notation @xmath250 is used in @xcite for what we here write as @xmath251 . )",
    "a _ nominal signature _ with a single sort of atoms , @xmath2 , is specified by a data type declaration   in which the argument types @xmath93 of the constructors @xmath88 are all nominal arities .",
    "the occurrences of @xmath251 in a nominal signature   indicate arguments with bound atoms .",
    "in particular , we can associate with each such signature a notion of _ @xmath0-equivalence _ , @xmath252 , that identifies closed values of nominal arity up to renaming bound atoms .",
    "the inductive definition of @xmath252 is given in figure  [ fig : alpe ] .",
    "it generalises to an arbitrary nominal signature the syntax - directed characterisation of @xmath0-equivalence of @xmath21-terms given in @xcite .",
    "the definition in figure  [ fig : alpe ] is essentially that given in @xcite , except that we have included an indexing by possible worlds @xmath138 , to chime with our form of judgement for contextual equivalence ; without that indexing , the condition `` @xmath253 '' in the rule for @xmath0-equivalence of values of atom binding type would be replaced by `` @xmath254 '' .",
    "[ rem : clov ] for each @xmath255 , the _ closed _ values ( that is , ones with no free variables ) of that type , @xmath256 , correspond precisely to the ground terms ( with arity @xmath257 and atoms in @xmath138 ) over the given nominal signature , as defined in @xcite .",
    "for example , the declaration   corresponds to the nominal signature for @xmath21-calculus ; and closed values of type @xmath24 correspond as in to the abstract syntax trees for @xmath21-terms  open or closed ones , with @xmath21-calculus variables represented by atoms . for other examples of nominal signatures , with more complicated patterns of binding ,",
    "see  ( * ? ? ?",
    "* section  2.2 ) .",
    "note that the definition of @xmath252 in figure  [ fig : alpe ] can not be extended naively to _ open _ values with free variables , for the reasons discussed in remark  [ rem : objlb ] .",
    "free variables stand for unknown values that may well involve atoms that get captured by @xmath58-binders upon substitution .",
    "so as we saw in that remark , it does not make semantic sense to say , for example , that @xmath258 and @xmath258 are @xmath0-equivalent without putting some restrictions on the kind of value @xmath43 stands for . in @xcite ,",
    "et al _ consider such restrictions consisting of assumptions about the freshness of atoms for variables ; they generalise figure  [ fig : alpe ] to a hypothetical notion of @xmath0-equivalence between open values , with hypotheses consisting of such freshness assumptions",
    ". it may be possible to relate the validity of this general form of @xmath0-equivalence to contextual equivalence , but here we content ourselves with the following result about the straightforward notion of @xmath0-equivalence on closed values given by figure  [ fig : alpe ] .",
    "[ thm : corr ] suppose that all the observations on atoms @xmath132 in @xmath78 satisfy the equivariance property .",
    "for each nominal signature , two closed values @xmath259 of the same nominal arity @xmath257 ( with atoms contained in the finite set @xmath138 , say ) are @xmath0-equivalent if and only if they are contextually equivalent : @xmath260    the rest of this section is devoted to the proof of the bi - implication in . before commencing the proof we make some remarks about the relative difficulty of each half of the bi - implication and about alternative approaches to the proof than the one we take .    at first sight",
    "it might seem that this implication is trivial : since we identify expressions up to @xmath0-equivalence of bound variables , contextual equivalence automatically contains that notion of equivalence .",
    "however , @xmath252 is not that meta - level @xmath0-equivalence , it is @xmath0-equivalence at the object - level for @xmath58-bound atoms . as we noted in remark  [ rem : objlb ] , identifying all ( open or closed ) expressions up to renaming @xmath58-bound atoms is incompatible with contextual equivalence : so we can not trivialise the left - to - right implication in by factoring out in this way .",
    "note that the restriction to nominal arities in figure  [ fig : alpe ] means that we do not have to consider @xmath252 for values of the form @xmath45 and hence for open expressions @xmath44 where the naive definition of @xmath252 would encounter the semantic problems discussed in remarks  [ rem : objlb ] and  [ rem : clov ] .",
    "so there really is something to do to establish the left - to - right implication in .",
    "however , we will see that we have already done most of the heavy lifting for this half of the theorem by establishing the ciu theorem  [ thm : ciu ] .",
    "this is equivalent to showing that if two closed values @xmath18 and @xmath261 of nominal arity @xmath257 are not @xmath0-equivalent , then they are not contextually equivalent . proving contextual inequivalence is much easier than proving contextual equivalence , since one just has to construct a context in which the two values have different operational behaviour . in this case",
    "it would suffice to exhibit a closed expression @xmath262 correctly implementing @xmath252 , in the sense that for all @xmath18 and @xmath261    @xmath263    it is indeed possible to construct such an expression @xmath264 by induction on the structure of @xmath257 , by a definition that mimics the rules in figure  [ fig : alpe ] , using the definition of atom - swapping from example  [ exa : swa ] in the case of an atom - binding arity and using recursively defined functions at data types .",
    "the proof of the above properties of @xmath264 is relatively straightforward if tedious ; one first has to prove suitable correctness properties for the swapping expressions @xmath265 from example  [ exa : swa ] .",
    "this is not the route to the right - to - left implication in that we take .",
    "instead we deduce it from a general `` extensionality '' property of atom - binding types @xmath266 that holds for all types @xmath7 , including ones that are not nominal arities , that is , ones involving function types .",
    "this property ( propositions  [ prop : ext - bind-1 ] and [ prop : ext - bind-2 ] ) shows that , up to contextual equivalence , the type @xmath8 behaves like the atom - abstraction construct of  ( * ? ? ?",
    "* sect .  5 ) .",
    "it seems interesting in its own right .",
    "we are able to prove this property of general atom - binding types @xmath266 only under a restriction on observations on atoms over and above the equivariance property   that we always assume they possess .",
    "this is the `` affineness '' property given in definition  [ def : affo ] below .",
    "the equality test @xmath193 ( figure  [ fig : exaoa ] ) is affine and we will see that this fact is enough to prove theorem  [ thm : corr ] as stated , that is , without any restriction on the observations present other than equivariance .",
    "we now begin the proof of theorem  [ thm : corr ] .",
    "[ prop : ext ]    * @xmath267 . * for all types @xmath268 , @xmath269 iff @xmath270 and @xmath271 . * for each data type @xmath86 in the declaration , @xmath272 iff @xmath273 and @xmath274 . * @xmath275 iff @xmath276 .",
    "part ( i ) and the `` if '' directions of ( ii)(iv ) are consequences of the fact ( theorem  [ thm : ciu ] ) that @xmath231 is a compatible equivalence . for the `` only if '' directions of ( ii ) and ( iii ) we apply suitably chosen destructors .",
    "thus for part ( ii ) we use the operational equivalences @xmath277 and @xmath278 that are consequences of the definitions of @xmath232 and the termination relation . similarly , part ( iii )",
    "follows from the easily established operational ( in)equivalences @xmath279 which make use of the following expressions @xmath280 finally , for the `` only if '' direction of part ( iv ) we make use of the fact that @xmath78 always contains the atom equality function @xmath193 from figure  [ fig : exaoa ] : see lemma  [ lem : howe-4](i ) in appendix  [ app : proof - ciu - theorem ] .",
    "this proposition tells us that @xmath232 has properties mirroring those of @xmath0-equivalence given by the first four rules in figure  [ fig : alpe ] . to complete the proof of the correctness theorem",
    ", we need to prove a property of @xmath232 at atom binding arities @xmath251 that mirrors the fifth rule in that figure .",
    "we split this into two parts , propositions  [ prop : ext - bind-1 ] and [ prop : ext - bind-2 ] .",
    "[ prop : ext - bind-1 ] for any type @xmath83 , suppose we are given closed , well - typed atom binding values @xmath281 and @xmath282 .",
    "if for some atom @xmath283 we have @xmath284 then @xmath285    unlike the previous proposition , this result is not just a simple consequence of the congruence properties of operational equivalence . it can be proved via an induction over the rules defining termination : see appendix  [ app : proof - ext - bind-1-proposition ] .",
    "next we need to prove the converse of the above proposition , namely that implies for any @xmath283 .",
    "the difficulty is that in verifying we have to consider the termination behaviour of @xmath286 and @xmath287 in all states @xmath126 with @xmath288 .",
    "the atom @xmath289 may occur at _ any _ position in @xmath126 and not necessarily at its right - hand end ; whereas in assuming , all we appear to know about the termination behaviour of @xmath286 and @xmath287 is what happens when a fresh atom @xmath289 is placed at the end of the state via generative unbinding ( cf .",
    "remark  [ rem : freal ] ) .",
    "in fact we are able to combine @xmath33 and @xmath13 operations to rearrange atoms sufficiently to prove the result we want , but only in the presence of observations on atoms that are insensitive to atoms being added at the left - hand ( that is , least ) end of the state .",
    "the following definition makes this property of observations precise .",
    "it uses the notation @xmath290 for the state obtained from @xmath166 by appending an atom @xmath15 not in @xmath125 to the _ left _ of the finite list of distinct atoms @xmath126 ( cf .",
    "@xmath124 defined in figure  [ fig : trar ] ) .",
    "[ def : affo ] an observation on atoms , @xmath98 , is _ affine _ if it is equivariant   and satisfies : for all @xmath166 , all @xmath117 and all @xmath175 ( where @xmath101 is the arity of @xmath132 ) @xmath291 for example , of the observations defined in figure  [ fig : exaoa ] , @xmath193 and @xmath195 are affine , whereas @xmath196 and @xmath243 are not .    the following property of termination follows from its definition in figures  [ fig : trar ] and [ fig : terr ] , using corollary  [ cor : some - any ] .",
    "[ lem : affo ] given a frame stack @xmath134 and an expression @xmath44 , suppose that only affine observations on atoms occur in them .",
    "then for all @xmath126 with @xmath292 and all @xmath117 , @xmath293 .",
    "we now give a converse of proposition  [ prop : ext - bind-1 ] , under the assumption that only affine observations are used .",
    "the proof is the technically most involved result in the paper .",
    "[ prop : ext - bind-2 ] suppose that @xmath78 only contains affine observations .",
    "for any type @xmath83 , suppose we are given closed , well - typed atom binding values @xmath281 and @xmath282 .",
    "then for all atoms @xmath283 we have @xmath294 implies @xmath295    suppose holds and that @xmath283 .",
    "to prove we have to show for any @xmath296 , @xmath166 and @xmath297 with @xmath298 and @xmath299 that @xmath300 since @xmath301 , we have @xmath302 for some state @xmath152 and atoms @xmath303 ( @xmath304 ) .",
    "choose distinct atoms @xmath305 not occurring in @xmath306 and consider the frame stack @xmath307 )      \\end{array}\\ ] ] where @xmath308 are distinct variables not occurring in @xmath134 .",
    "here we have used the notation `` @xmath309 '' from figure  [ fig : unrfe ] , the notation `` @xmath235}$ ] '' from and the operation @xmath310 of replacing an atom @xmath19 by a variable @xmath43 .",
    "since @xmath311 , by definition of @xmath153 and from we have @xmath312 where @xmath313",
    "let @xmath172 be the permutation swapping each @xmath314 with @xmath315 ( for @xmath316 ) .",
    "since @xmath317 , by definition of @xmath318 we have @xmath319 .",
    "therefore the configuration @xmath320 satisfies the well - formedness condition needed to apply corollary  [ cor : some - any ] . noting that @xmath321 and that @xmath322 , from that corollary , property and the definition of @xmath153 we get : @xmath323 note that by definition of @xmath169 @xmath324 and @xmath325 by and .",
    "so altogether we have @xmath326 a similar argument gives @xmath327 we noted in theorem  [ thm : ciu ] that operational equivalence is equivariant .",
    "so from we have @xmath328 .",
    "since @xmath329 , this operational equivalence gives @xmath330 combining this with and yields @xmath331 since @xmath332 and @xmath78 only contains affine observations , we can now apply lemma  [ lem : affo ] to to get , as required .",
    "[ exa : conjecture ] we conjecture that proposition  [ prop : ext - bind-2 ] fails to hold if we drop the requirement that observations are affine ( but still require them to be equivariant ) . for example consider the equivariant but non - affine observation @xmath196 in figure  [ fig : exaoa ] and the values @xmath333 where @xmath19 is some atom .",
    "we claim that @xmath334 the operational inequivalence is witnessed by the state @xmath335 $ ] and the frame stack @xmath336 , for which one has @xmath337 , but not @xmath338 . at the moment we lack a formal proof of the operational equivalence , but",
    "the intuitive justification for it is as follows . for any state @xmath126 containing @xmath19 and any frame stack @xmath134",
    ", we claim that in any sequence of transitions from @xmath339 the occurrence of @xmath340 in @xmath261 can only be renamed to @xmath341 for atoms @xmath15 at positions strictly greater than @xmath62 in the current state ; and hence @xmath339 has the same termination properties as @xmath342 .",
    "one proves that @xmath343 implies @xmath344 by induction on the the rules defining @xmath0-equivalence in figure  [ fig : alpe ] , using propositions  [ prop : ext ] and [ prop : ext - bind-1 ] .    to prove the converse implication",
    ", first note that if @xmath345 , then @xmath18 contains no instances of observations @xmath98 .",
    "the proof of this is by induction on the structure of the nominal arity @xmath257 ; the only way observations on atoms can appear in values of the language is via function values , @xmath45 , and the definition of `` nominal arity '' excludes function types .",
    "it follows from the definition of operational equivalence in definition  [ def : opee ] that if @xmath344 holds for a language with observation set @xmath78 , it also holds for the sub - language with minimal observation set @xmath346 .",
    "thus it suffices to prove the implication @xmath347 for this minimal sub - language ; and this can be done by induction on the structure of @xmath257 using propositions  [ prop : ext ] and [ prop : ext - bind-2 ] ( the latter applies because @xmath193 is affine ) .",
    "it is instructive to compare the correctness of representation property of freshml ( theorem  [ thm : corr ] ) with _ adequacy _ results for type - theoretic logical frameworks  @xcite . both",
    "are concerned with the representation of expressions of some object - language in a meta - language . for logical frameworks",
    "the main issue is surjectivity : one wants every expression at the meta - level to be convertible to a normal form and for every normal form at certain types to be the representation of some object - level expression .",
    "the fact that @xmath0-equivalence of object - level expressions is preserved and reflected by the representation is a simple matter , because equivalence in the logical framework is taken to be @xmath348-conversion , which specialises on normal forms to just @xmath0-equivalence .",
    "contrast this with the situation for freshml where surjectivity of the representation is straightforward , because values of the relevant freshml data types _ are _ just first order abstract syntax trees ; whereas the fact that @xmath0-equivalence of object - level expressions is preserved and reflected by the representation in freshml is a non - trivial property .",
    "this is because we take equivalence of freshml expressions to be contextual equivalence .",
    "this is the natural notion of equivalence from a programming point of view , but its properties are hard won .",
    "one aspect of adequacy results for logical frameworks highlighted in @xcite is _ compositionality _ of representations . although important , this issue is somewhat orthogonal to our concerns here .",
    "it refers to the question of whether substitution of expressions for variables at the object - level is represented by @xmath349-conversion at the meta - level . from the point of view of nominal signatures  @xcite ,",
    "variables are just one kind of name .",
    "properties of @xmath0-conversion of all kinds of names are treated by the theory ; but if one wants notions of substitution and @xmath349-conversion for a particular kind of name , one has to give a definition ( an `` @xmath0-structural '' recursive definition  @xcite ) .",
    "for example in freshml , using the data type for @xmath21-terms one can give an appealingly simple declaration for a function @xmath350 for capture - avoiding substitution ; see  @xcite .",
    "compositionality of the representation @xmath351 given in the introduction then becomes the contextual equivalence @xmath352}}\\urcorner } { \\cong}{\\mathsf{subst}}\\,{\\ulcornert_2\\urcorner}\\,{a}\\,{\\ulcornert_1\\urcorner } { : } { { \\mathsf{term}}}$ ] .",
    "the ciu theorem ( theorem  [ thm : ciu ] ) provides the basis for proving such contextual equivalences .",
    "( we believe this particular equivalence is valid when @xmath353 , but not when @xmath354 ; see section  [ sec : conclusion ] . )",
    "we have explored some of the consequences of adding integer - valued `` observations on atoms '' to freshml over and above the usual test for equality .",
    "such functions allow more efficient data structures to be used for algorithms involving atoms as keys .",
    "for example , binary search trees making use of the comparison function @xmath195 from figure  [ fig : exaoa ] could be used instead of association lists .    what about adding functions from numbers to atoms ?",
    "an implementation of the language may well represent atoms by numbers , via some fixed enumeration of the set of atoms , @xmath190 .",
    "can we give the programmer access to this bijection ?",
    "less radically , can we allow operations on atoms that make use of arithmetic properties of the underlying representation ?",
    "not without breaking the invariant @xmath292 of configurations @xmath133the property of our operational semantics that ensures that an atom s freshness with respect to the current state really does mean that it is different from all other atoms in the current context .",
    "for example , suppose we add to the language an operation @xmath355 whose meaning is `` successor function on atoms '' , with transitions @xmath356 whenever @xmath357 and @xmath358 for some @xmath359",
    ". then it may well be the case that @xmath117 even though @xmath360 .",
    "so exposing the numerical representation of atoms involves giving up the invariant properties of the abstract semantics we have used here .",
    "perhaps a more interesting alternative to actually exposing numerical representations of atoms would be to prove contextual equivalence of efficient and naive implementations of the abstract semantics extended with types of finite maps on atoms .",
    "such abstract types form an addition to the signature in figure  [ fig : signb ] different from the kind we have considered here , but certainly one worthy of investigation .",
    "the techniques we used here to prove the correctness of representation property are operationally based , in contrast to the denotational techniques used in  @xcite .",
    "the advantage of working directly with the syntax and operational semantics of the language is that there are lower mathematical `` overheads''various kinds of induction being the main techniques involved .",
    "the disadvantage is that to deploy such inductive techniques often involves great ingenuity choosing inductive hypotheses and much error prone tedium checking induction steps .",
    "furthermore , with these methods it seems harder to predict the effect that a slight change in language or formalisation may have on a proof .",
    "although ingenuity in choosing inductive hypotheses may always be the preserve of humans , machine assistance of the kind envisaged by the `` poplmark challenge ''  @xcite seems a very good idea for the other aspects of the operationally based approach .",
    "the main results presented here are still a challenging target for fully formalised and machine checked proofs .",
    "we have taken some care with the formalisation ( using a `` relational '' approach to contextual equivalence , for example ) ; but results concerning coinductive equivalences , like the ciu theorem ( theorem  [ thm : ciu ] ) , are quite complex logically speaking , compared with the kind of type safety results ( like theorem  [ thm : typs ] ) that poplmark has focused on so far .",
    "systems like isabelle / hol  @xcite that develop proofs in full classical higher order logic seem appropriate to the task , in principle .",
    "but there is a gap between what is possible in principle for an expert of any particular system and what is currently practicable for a casual user .",
    "urban and berghofer  @xcite are developing a _ nominal data type package _ for isabelle / hol that may be very useful for narrowing this gap .",
    "the fact that freshml and the urban - berghofer package both have to do with the same mathematical universe of `` nominal sets ''  @xcite is perhaps slightly confusing : their nominal data type package is useful for fully formalising proofs about names and name - binding in operational semantics whether or not those proofs have to do with the particular mechanism of generative unbinding that is the focus of this paper .",
    "the freshml  @xcite approach to functional programming with binders combines abstract types for names and name binding with an unbinding operation that involves generation of fresh names . in this paper",
    "we have studied some theoretical properties of this design to do with data correctness .",
    "we showed that the addition of integer valued observations on names does not break freshml s fundamental correctness of representation property that @xmath0-equivalence classes of abstract syntax trees ( for any nominal signature ) coincide with contextual equivalence classes of user declared data values .",
    "in particular , it is possible to give programmers access to a linear order on names without breaking the `` up to @xmath0-equivalence '' representation of syntax .",
    "the simple insight behind this possibly surprising result has to do with the fact that freshml is impure  program execution mutates the state of dynamically created names . if the state is taken into account when giving the meaning of observations on names , then the permutation invariance properties that underly the correctness property can be retained .",
    "the original version of freshml  @xcite was pure by dint of the `` freshness inference '' included in its type system .",
    "subsequent experience with the language showed that the form of freshness inference that was used there was overly restrictive from a programming point of view .",
    "so freshness inference was dropped in @xcite .",
    "however , pottier  @xcite has recently regained purity in a freshml - like language through the use of user - provided assertions .",
    "we have not investigated whether results like those presented in this paper also apply to pottier s language",
    ".    this paper has been concerned with data correctness , but what about general results on _ program correctness _ ?",
    "the only restriction we placed on observations on atoms is that , as functions of both the state and the names they operate upon , they should be invariant under permuting names .",
    "we have seen that the correctness of representation property ( theorem  [ thm : corr ] ) remains valid in the presence of any such observation .",
    "however , we are certainly not advocating that arbitrary equivariant observations be added to freshml .",
    "this is because some forms of observation may radically affect the general programming laws that contextual equivalence satisfies .",
    "we saw one example of this here : only for `` affine '' observations ( which are insensitive to how many names have been created before the arguments to which they are applied ) were we able to combine propositions  [ prop : ext - bind-1 ] and  [ prop : ext - bind-2 ] to get an `` extensionality '' result explaining contextual equivalence at type @xmath8 in terms of contextual equivalence at @xmath7 , for arbitrary higher types @xmath7 .    more investigation of program correctness properties in the presence of particular observations on atoms is needed before one can advocate adding them to the freshml design .",
    "the techniques we used in this paper could form the basis for such an investigation .",
    "they combine the usual engine of structural operational semantics ",
    "namely syntax - directed , rule based induction  with the approach to freshness of names based on name permutations that was introduced in @xcite and developed in  @xcite .",
    "the authors are grateful for the suggestions for improvement made by the anonymous referees .    mthm97    b.  e. aydemir , a.  bohannon , m.  fairbairn , j.  n. foster , b.  c. pierce , p.  sewell , d.  vytiniotis , g.  washburn , s.  weirich , and s.  zdancewic . mechanised metatheory for the masses : the poplmark challenge . in j.",
    "hurd and t.  melham , editors , _ 18th international conference on theorem proving in higher order logics : tphols 2005 _ , volume 3603 of _ lecture notes in computer science _ , pages 5065 .",
    "springer - verlag , 2005 . ` www.cis.upenn.edu/group/proj/plclub/mmm/ ` .",
    "n. benton and x.  leroy , editors . , electronic notes in theoretical computer science .",
    "elsevier , september 2005 .",
    "j.  cheney .",
    "scrap your nameplate ( functional pearl ) . in _",
    "tenth acm sigplan international conference on functional programming ( icfp05 ) , tallinn , estonia _ , pages 180191 .",
    "acm press , september 2005 .",
    "m.  felleisen and r.  hieb .",
    "the revised report on the syntactic theories of sequential control and state .",
    ", 103:235271 , 1992 .    c.  flanagan , a.  sabry , b.  f. duba , and m.  felleisen . the essence of compiling with continuations . in",
    "proceedings acm sigplan conference on programming language design and implementation , pldi93 , albuquerque , nm , usa _ , pages 237247 .",
    "acm press , june 1993 .",
    "a.  d. gordon .",
    "operational equivalences for untyped and polymorphic object calculi . in gordon and pitts @xcite , pages 954 .",
    "a.  d. gordon and a.  m. pitts , editors . .",
    "publications of the newton institute .",
    "cambridge university press , 1998 .",
    "m.  j. gabbay and a.  m. pitts . a new approach to abstract syntax with variable binding .",
    ", 13:341363 , 2001 .",
    "c.  a. gunter . .",
    "foundations of computing . mit press , 1992 .    d.  j. howe .",
    "proving congruence of bisimulation in functional programming languages .",
    ", 124(2):103112 , 1996 .",
    "s.  b. lassen .",
    "relational reasoning about contexts . in gordon and pitts @xcite ,",
    "pages 91135 .",
    "i.  a. mason and c.  l. talcott .",
    "equivalence in functional languages with effects .",
    ", 1:287327 , 1991 .",
    "r.  milner , m.  tofte , r.  harper , and d.  macqueen . .",
    "mit press , 1997 .",
    "t.  nipkow , l.  c. paulson , and m.  wenzel . ,",
    "volume 2283 of _ lecture notes in computer science_. springer - verlag , 2002 .",
    "f.  pfenning .",
    "logical frameworks . in a.",
    "robinson and a.  voronkov , editors , _ handbook of automated reasoning _",
    ", chapter  17 , pages 10631147 .",
    "elsevier science and mit press , 2001 .",
    "a.  m. pitts and m.  j. gabbay .",
    "a metalanguage for programming with bound names modulo renaming . in r.",
    "backhouse and j.  n. oliveira , editors , _ mathematics of program construction .",
    "5th international conference , mpc2000 , ponte de lima , portugal , july 2000 . proceedings _ , volume 1837 of _ lecture notes in computer science _ , pages 230255 .",
    "springer - verlag , heidelberg , 2000 .    a.  m. pitts .",
    "operational semantics and program equivalence . in g.",
    "barthe , p.  dybjer , and j.  saraiva , editors , _ applied semantics , advanced lectures _ , volume 2395 of _ lecture notes in computer science , tutorial _ , pages 378412 .",
    "springer - verlag , 2002 .",
    "international summer school , appsem 2000 , caminha , portugal , september 915 , 2000 .",
    "a.  m. pitts .",
    "nominal logic , a first order theory of names and binding .",
    ", 186:165193 , 2003 .",
    "a.  m. pitts .",
    "typed operational reasoning . in b.",
    "c. pierce , editor , _ advanced topics in types and programming languages _ , chapter  7 , pages 245289 . the mit press , 2005 .",
    "a.  m. pitts .",
    "alpha - structural recursion and induction . , 53(3):459506 , 2006 .",
    "f.  pottier .",
    "an overview of c@xmath0ml . in benton and leroy @xcite , pages 2752 .",
    "f.  pottier .",
    "static name control for freshml . in _",
    "twenty - second annual ieee symposium on logic in computer science ( lics07 ) _ , pages 356365 , wroclaw , poland , july 2007 .",
    "ieee computer society press .",
    "a.  m. pitts and m.  r. shinwell .",
    "generative unbinding of names . in _",
    "34th annual acm sigplan - sigact symposium on principles of programming languages ( popl 2007 ) , nice , france _ , pages 8595 .",
    "acm press , january 2007 .",
    "m.  r. shinwell . .",
    "phd thesis , university of cambridge computer laboratory , 2005 .",
    "available as university of cambridge computer laboratory technical report ucam - cl - tr-618 .",
    "m.  r. shinwell .",
    ": nominal abstract syntax for the masses . in benton and leroy @xcite ,",
    "pages 5376 .",
    "m.  r. shinwell and a.  m. pitts .",
    "resh objective caml user manual .",
    "technical report ucam - cl - tr-621 , university of cambridge computer laboratory , february 2005 .",
    "m.  r. shinwell and a.  m. pitts . on a monadic semantics for freshness .",
    ", 342:2855 , 2005 .    m.  r. shinwell , a.  m. pitts , and m.  j. gabbay .",
    "freshml : programming with binders made simple . in _",
    "eighth acm sigplan international conference on functional programming ( icfp 2003 ) , uppsala , sweden _ , pages 263274 .",
    "acm press , august 2003 .",
    "c.  urban and s.  berghofer . a recursion combinator for nominal datatypes implemented in isabelle / hol . in",
    "3rd international joint conference on automated reasoning ( ijcar 2006 ) , seattle , usa _ ,",
    "volume 4130 of _ lecture notes in computer science _ , pages 498512 .",
    "springer - verlag , 2006 .    c.  urban and m.  norrish . a formal treatment of the barendregt variable convention in rule inductions . in _ proceedings of the 3rd acm sigplan workshop on mechanized reasoning about languages with variable binding ( merlin 05 ) , tallinn , estonia",
    "_ , pages 2532 .",
    "acm press , 2005 .",
    "c.  urban , a.  m. pitts , and m.  j. gabbay . nominal unification . ,",
    "323:473497 , 2004 .",
    "we wish to show that the expression relation @xmath231 of definition  [ def : opeqo ] is compatible and substitutive ( see definition  [ def : expr ] ) .",
    "we use an adaptation of `` howe s method ''  @xcite to do so .",
    "let the expression relation @xmath361 be inductively defined from @xmath231 by the rule @xmath362 in making this inductive definition , we are implicitly relying upon the easily proved fact that compatible refinement , @xmath363 , is a monotone operation on expression relations , that is , @xmath364 .",
    "[ lem : howe-1 ]    * @xmath365 .",
    "* @xmath361 is compatible and substitutive .",
    "* @xmath366 .",
    "* @xmath367 .",
    "* @xmath368 .",
    "these properties of @xmath361 are simple consequences of its definition and the definition of the extension of compatible refinement to a relation between frame stacks given by the last two rules in figure  [ fig : comr ] .",
    "[ lem : howe-2 ]    * @xmath361 is equivariant . *",
    "@xmath369 . * @xmath370 .    part ( i ) follows from the fact that @xmath231 is equivariant , which in turn is a consequence of lemma  [ lem : ter - equivar ] . parts ( ii ) and ( iii ) are consequences of the fact that world weakening is built into the definition of operational equivalence in definition  [ def : opee ] .",
    "[ lem : howe-3 ] @xmath371 .",
    "if @xmath223 , then in particular @xmath372 and @xmath212 , so that by lemma  [ lem : howe-1](iii ) we have @xmath373 ; so from part ( i ) of that lemma we get @xmath374 .",
    "we wish to show that @xmath361 coincides with @xmath231 . in view of the previous lemma",
    ", it just remains to show that @xmath375 .",
    "lemma  [ lem : howe - key ] provides the key to this . before stating that lemma we give some simple properties of @xmath232 that are needed to prove it .",
    "[ lem : howe-4 ]    * @xmath376 .",
    "* @xmath377 . * if @xmath378 , then for any world @xmath225 and value @xmath379 with @xmath380 and @xmath381 , it is the case that @xmath382",
    ".    for part ( i ) we make use of the fact that @xmath78 always contains the atom equality function @xmath193 from figure  [ fig : exaoa ] .",
    "consider the frame stack @xmath383{@{}l@ { } }      { \\mathop{{\\mathsf{let}}}}{{y}{\\mathbin{{\\mathsf{=}}}}{{\\mathsf{eq}}}\\,{x}\\,{a } } { \\mathrel{{\\mathsf{in}}}}\\\\      { { \\mathsf{match}}}\\ { y } { \\mathbin{{\\mathsf{with}}}}({{\\mathsf{zero}}}{\\mathbin{\\rightarrow}}{{\\mathopen{{\\mathsf{(}}}}{\\mathclose{{\\mathsf{)}}}}}{\\mathrel{{\\mathsf{|}}}}{{\\mathsf{succ}}}\\,{z}{\\mathbin{\\rightarrow}}{{\\mathsf{diverge}}}))\\;.    \\end{array}\\ ] ] if @xmath384 are distinct elements of @xmath138 , then choosing some @xmath166 with @xmath385 , it is not hard to see that @xmath386 holds whereas @xmath387 does not hold .",
    "so if @xmath275 it can not be the case that @xmath388 .    for part ( ii ) , given any @xmath126 , @xmath134 and @xmath143 with @xmath205 and @xmath206 , then @xmath389 and thus @xmath390 .",
    "the proof of part ( iii ) is similar to that for ( ii ) , using the frame @xmath391 in place of @xmath392 .",
    "[ lem : howe - key ] for all @xmath393 and all @xmath394 @xmath395    the lemma is proved by induction on @xmath40 . the base case @xmath396 follows from the definition of @xmath397 ( which implies that @xmath398 can only hold when @xmath399 ) , combined with lemma  [ lem : howe-1](v ) and the definition of @xmath231 . for the induction step , assume holds and that @xmath400 we have to prove @xmath401 and do so by an analysis of against the possible cases [ item:1][item:9 ] in the definition of the transition relation in figure  [ fig : trar ] .      in this case",
    "@xmath402 , @xmath403 , @xmath404 , and @xmath405}}$ ] , for some @xmath406 and @xmath18 . for to hold , by definition of @xmath407 it must be the case that @xmath408 for some @xmath409 and @xmath410 with @xmath411 for some type @xmath412 . since @xmath413 is a value , applying lemma  [ lem : howe-1](v ) to we get @xmath414 for some @xmath415 . since @xmath361 is substitutive ( lemma  [ lem : howe-1](ii ) ) , from and we get @xmath416 } } { \\cong}^ *       { e}_2'{{[{v}'/{x}]}}{:}{\\tau}_2\\;.\\ ] ] applying the induction hypothesis to , , and to , we get @xmath417}}\\rangle}{{\\downarrow_{}}}$ ] ; hence @xmath418 , that is , @xmath419 ; and therefore by we also have @xmath401 , as required .",
    "in this case we have @xmath420 , @xmath404 and @xmath421 for some @xmath406 .",
    "since holds , by definition of @xmath361 , there must exist some @xmath422 , @xmath410 and @xmath423 with @xmath424 the induction hypothesis applied to , and gives @xmath425 and hence @xmath426 .",
    "this and then give @xmath401 , as required .",
    "this follows from the definition of @xmath361 using its substitutivity property , much as for case  [ item:1 ] .      in this case",
    "@xmath427 , @xmath428 , @xmath404 and @xmath429 , for some @xmath268 and @xmath430 . by definition of @xmath407 , for to hold it must be the case that @xmath431 for some @xmath432 and @xmath433 . by the induction hypothesis applied to , , and , we get @xmath434 and hence also @xmath435 .",
    "hence by we have @xmath401 , as required .",
    "this is similar to the previous case .",
    "in this case @xmath436 , @xmath404 , @xmath437 and @xmath438}}$ ] for some @xmath439 and @xmath440 .",
    "since holds , by definition of @xmath361 together with lemma  [ lem : howe-4](iii ) , there must exist some @xmath410 , @xmath433 and @xmath423 with @xmath441 since @xmath361 is compatible ( lemma  [ lem : howe-1](ii ) ) , from we get @xmath442 ; and since @xmath361 is also substitutive , this together with and gives @xmath443 } } { \\cong}^ *    { e}_2'{{[{{\\mathsf{fun}}}({f}\\,{x}{\\mathbin{{\\mathsf{=}}}}{e}_2 ' ) , { v}_2'/{f},{x } ] } }    { : } { \\tau}$ ] .",
    "therefore by the induction hypothesis applied to , this , and , we get @xmath444}}\\rangle}{{\\downarrow_{}}}$ ] . hence @xmath445 and thus by , @xmath401 as required .      in this case",
    "@xmath446 , @xmath447 , @xmath448 , @xmath437 and @xmath449 , for some @xmath450 .",
    "since holds , by definition of @xmath361 we have @xmath451 by lemma  [ lem : howe-2](iii ) applied to , we have @xmath452 ; and by lemma  [ lem : howe-1](iii ) we also have @xmath453 .",
    "so by the induction hypothesis applied to these , @xmath454 and , we get @xmath455 .",
    "hence @xmath456 and hence from we also have @xmath457 , as required .",
    "in this case @xmath458 , @xmath459 , @xmath460 , @xmath437 , and @xmath461 , for some @xmath423 , @xmath19 , @xmath18 and @xmath462 with @xmath463 .",
    "since holds , by definition of @xmath361 together with parts ( i ) and ( ii ) of lemma  [ lem : howe-4 ] , there must exist some @xmath261 with @xmath464 we now appeal to the easily verified fact that since @xmath465 , the renamed values @xmath466 and @xmath467 are respectively equal to the permuted values @xmath468 and @xmath469 ( where @xmath470 denotes the permutation swapping @xmath19 and @xmath15 ) . therefore by parts ( i ) and ( ii ) of lemma  [ lem : howe-2 ] applied to and by parts ( ii ) and ( iii ) of lemma  [ lem : howe-1 ]",
    ", we have @xmath471 by applying lemma  [ lem : howe-2](iii ) to we also have @xmath472 then applying the induction hypothesis to this , , @xmath473 and yields @xmath474",
    ". therefore @xmath475 ; and hence by , we also have @xmath457 , as required .      in this case",
    "@xmath476 , @xmath477 for some @xmath478 , @xmath404 , @xmath437 , and @xmath479 where @xmath480 .",
    "since holds , by definition of @xmath361 together with lemma  [ lem : howe-4](i ) , we must have @xmath481 note that by lemma  [ lem : howe-1](iii ) we also have @xmath482 .",
    "so by the induction hypothesis applied to this , , and we get @xmath483 . since @xmath480 , this implies that @xmath484 ; and hence from we have that @xmath401 holds , as required .",
    "this completes the proof of lemma  [ lem : howe - key ] .",
    "[ lem : howe-5 ] let @xmath485 denote the transitive closure of @xmath361",
    ". then @xmath486    this can be proved by induction on the derivation of @xmath487 from the rule in and the rules for compatible refinement in figure  [ fig : comr ] , using the fact that @xmath231 is symmetric and using lemmas  [ lem : howe-3 ] and [ lem : howe-1](iii ) .",
    "we can now complete the proof of theorem  [ thm : ciu ] by showing that @xmath231 is compatible and substitutive ( definition  [ def : expr ] ) . since @xmath361 has those properties by lemma  [ lem : howe-1](ii )",
    ", it suffices to show that @xmath231 coincides with @xmath361 .",
    "we already noted in lemma  [ lem : howe-3 ] that @xmath231 is contained in @xmath361 .",
    "for the reverse inclusion , since @xmath361 is substitutive and reflexive ( lemma  [ lem : howe-1 ] ) , it is closed under substituting values for variables ; so by definition  [ def : opeqo ] , it suffices to show that @xmath488 to see this , note that by lemma  [ lem : howe - key ] ( together with lemmas  [ lem : howe-1](iv ) and [ lem : howe-2](ii ) ) we have : @xmath489 since the right - hand side of the implication in is a transitive relation between expressions @xmath490 , we also have @xmath491 and therefore lemma  [ lem : howe-5 ] gives @xmath492 combining and gives .",
    "let @xmath493 be the closure under compatible refinement ( figure  [ fig : comr ] ) of the pairs of closed atom binding values that we wish to show are operationally equivalent .",
    "in other words @xmath209 is the expression relation inductively defined by the following two rules .",
    "these properties of @xmath209 are simple consequences of its definition in , the definition of compatible refinement in figure  [ fig : comr ] , and the definition of its extension to a relation between frame stacks given by the last two rules in that figure .",
    "the lemma is proved by induction on @xmath40 . the base case @xmath396 follows directly from lemma  [ lem : ext - bind-1](iii ) and the definition of @xmath219 ( which implies that @xmath501 can only hold when @xmath399 ) . for the induction step ,",
    "assume holds and that @xmath502 we have to prove @xmath401 and do so by an analysis of against the possible cases [ item:1][item:9 ] in the definition of the transition relation in figure  [ fig : trar ] . cases  [ item:1 ] , [ item:3 ] and [ item:6 ] follow from the definition of @xmath209 and its substitutivity property ; we give the details for the first one and omit the other two .",
    "cases [ item:4 ] , [ item:5 ] and [ item:9 ] also follow easily from the definition of @xmath209 ( using lemma  [ lem : ext - bind-1](ii ) in the third case ) .",
    "so we give the proofs just for cases [ item:1 ] , [ item:2 ] , [ item:7 ] and [ item:8 ] .      in this case",
    "@xmath402 , @xmath403 , @xmath404 , and @xmath405}}$ ] , for some @xmath406 and @xmath18 . for to hold , by definition of @xmath219 it must be the case that @xmath408 for some @xmath409 and @xmath410 with @xmath503 for some type @xmath412 . since @xmath413 is a value , applying lemma  [ lem : ext - bind-1](iv ) to we get @xmath504 for some @xmath415 .",
    "so since @xmath219 is substitutive ( lemma  [ lem : ext - bind-1](i ) ) , from and we get @xmath505 } } { \\mathrel{\\mathcal{e}}}{e}_2'{{[{v}'/{x}]}}{:}{\\tau}_2\\;.\\ ] ] applying the induction hypothesis to , , and to , we get @xmath417}}\\rangle}{{\\downarrow_{}}}$ ] ; hence @xmath418 , that is , @xmath401 , as required .      in this case",
    "@xmath506 , @xmath404 and @xmath421 for some @xmath406 . for to hold , by definition of @xmath219 it must be the case that @xmath507 for some @xmath508 and @xmath423 with @xmath509 from and we get @xmath510 ; and the induction hypothesis applied to this , , and gives @xmath425 .",
    "hence @xmath426 , that is , @xmath401 , as required .",
    "in this case @xmath446 , @xmath447 , @xmath448 , @xmath437 and @xmath449 , for some atom @xmath511 . for to hold , by definition of @xmath493 it must be the case that @xmath512",
    ". now lemma  [ lem : ext - bind-2](iii ) applied to gives @xmath513 ; and lemma  [ lem : ext - bind-1](ii ) gives @xmath514 . applying the induction hypothesis to these two facts , @xmath515 and gives @xmath516 .",
    "hence @xmath517 , that is , @xmath401 , as required .",
    "in this case @xmath458 , @xmath459 , @xmath518 , @xmath437 , and @xmath461 , for some @xmath423 , @xmath19 , @xmath18 and @xmath462 with @xmath519 . for to hold , by definition of @xmath209 it must be the case that @xmath520 with @xmath521    if ( a ) holds , then as in the proof of lemma  [ lem : howe - key ] we now appeal to the easily verified fact that since @xmath465 , the renamed values @xmath466 and @xmath467 are respectively equal to the permuted values @xmath468 and @xmath469 ( where @xmath470 denotes the permutation swapping @xmath19 and @xmath15 ) .",
    "therefore from the fact that @xmath522 holds , from parts ( i ) and ( ii ) of lemma  [ lem : ext - bind-2 ] we get @xmath523 .",
    "then since @xmath524 , by lemma  [ lem : ext - bind-1](ii ) we have @xmath525 . applying the induction hypothesis to this , ( weakened using lemma  [ lem : ext - bind-2](iii ) ) , @xmath473 and yields @xmath474 with @xmath526 . therefore by definition of @xmath527 , we also have @xmath528 .",
    "if ( b ) holds , then by theorem  [ thm : ciu ] , so does @xmath529 lemma  [ lem : ter - equivar ] applied to with @xmath530 gives @xmath531 . combining this with ( weakened using lemma  [ lem : ext - bind-2](iii ) ) , @xmath532 ( by lemma  [ lem : ext - bind-1](ii ) ) , @xmath533 and the induction hypothesis , we get @xmath534 . then by definition of @xmath232 , from this and we get @xmath535 with @xmath536 . therefore as before , by definition of @xmath527 , we also have @xmath528 .",
    "we can now complete the proof of proposition  [ prop : ext - bind-1 ] .",
    "for any type @xmath83 , suppose we are given closed , well - typed atom binding values @xmath538 and @xmath539 with @xmath540 and satisfying @xmath541 for some atom @xmath283 .",
    "by definition of @xmath209 this implies @xmath542 for any @xmath306 , @xmath126 , @xmath134 , and @xmath143 with @xmath543 and @xmath206 , we have @xmath544 by lemma  [ lem : ext - bind-1](iii ) and @xmath545 by lemma  [ lem : ext - bind-2](ii ) applied to .",
    "so lemma  [ lem : ext - bind-3 ] applied to , and @xmath546 , we have @xmath547 since @xmath232 is symmetric , the same argument shows that implies @xmath548 thus implies that @xmath9 and @xmath549 are operationally equivalent , as required ."
  ],
  "abstract_text": [
    "<S> this paper is concerned with the form of typed name binding used by the freshml family of languages . </S>",
    "<S> its characteristic feature is that a name binding is represented by an abstract ( name , value)-pair that may only be deconstructed via the generation of fresh bound names . </S>",
    "<S> the paper proves a new result about what operations on names can co - exist with this construct . in freshml </S>",
    "<S> the only observation one can make of names is to test whether or not they are equal . this restricted amount of observation was thought necessary to ensure that there is no observable difference between alpha - equivalent name binders . yet from an algorithmic point of view it would be desirable to allow other operations and relations on names , such as a total ordering . </S>",
    "<S> this paper shows that , contrary to expectations , one may add not just ordering , but almost any relation or numerical function on names without disturbing the fundamental correctness result about this form of typed name binding ( that object - level alpha - equivalence precisely corresponds to contextual equivalence at the programming meta - level ) , so long as one takes the state of dynamically created names into account . </S>"
  ]
}