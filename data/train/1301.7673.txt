{
  "article_text": [
    "the classic 4-peg tower of hanoi problem is posed as follows :    given : four pegs , and _",
    "n _ disks of differing sizes stacked in increasing size order on one of the pegs , with the smallest disk on top .",
    "goal : stack the _",
    "n _ disks on a different one of the four pegs , using the following rules :    1",
    ".   only one disk can be moved at a time .",
    "2 .   only the top disk on any peg can be moved .",
    "larger disks can not be stacked above smaller disks @xcite .",
    "a number of authors have created algorithms to try to solve both this puzzle and the related puzzle involving an arbitrary number of _ k _ pegs .",
    "frame and stewart provided the first documented algorithms for the _ k_-peg problem @xcite @xcite .",
    "their algorithms involved partitioning the disks into intermediate sub - towers . since the time that frame and stewart published their results , others have analyzed algorithms in order to either attempt to solve the 4-peg and _ k_-peg tower of hanoi puzzles using a minimal number of moves , or to try to prove the optimality of the number of moves generated by frame s and stewart s algorithms .",
    "section [ sec : fs ] discusses the frame - stewart algorithm .",
    "the goal of this paper is to make steps toward an efficient dynamic programming solution for the 4-peg tower of hanoi puzzle .",
    "the solution is presented using the b - prolog programming language @xcite , and uses tabling , a technique similar to pattern databases @xcite , in order to decrease the number of necessary computations .",
    "the program will be _ non - deterministic _ , in order to extend the frame - stewart algorithm to variants of the 4-peg problem that involve disk configurations . in order to reduce the non - determinism",
    ", this paper examines different partition locations for the intermediate sub - towers , in order to find the most efficient one to use for the configuration problem .",
    "although there is no guarantee that the 4-peg frame - stewart algorithm is optimal @xcite , the dynamic programming solution utilizes this algorithm , as it has been proven to generate the optimal solution for up to 30 disks @xcite .    in sect .",
    "[ sec : asp ] , the configuration problem is examined , as posed by the 2011 asp competition @xcite .",
    "the focus is team bpsolver s program @xcite , which uses prolog together with tabling @xcite .",
    "bpsolver s results are compared with those of the other teams : team fast downward , which used pddl , and teams ezcsp , idp , potassco , and aclasp , which used sat solvers and grounders .",
    "the comparison will concentrate on potassco s program , which had the second - best performance for the hanoi benchmarks .",
    "[ sec : partitions ] compares dynamic programming approaches for splitting the problem into sub - problems , finding one that seems optimal .",
    "section [ sec : conf ] studies the seemingly optimal solution when applied to random configurations that do not extend from frame s and stewart s algorithms .",
    "then , in sect .",
    "[ sec : classic ] , the dynamic programming approaches are applied to the classic problem for up to 30 disks , getting a different result than sect . [",
    "sec : partitions ] . finally , sect .",
    "[ sec : alter ] describes alternative approaches to solving the 4-peg and _ k_-peg problems .",
    "when the _ k_-peg hanoi problem was posed in 1941 , two authors provided solutions . one algorithm , provided by j. s. frame , is iterative . the other , written by b. m. stewart , the proposer , is recursive .",
    "both authors claim that their algorithms generate the minimum number of moves , while frame admits that other methods might also be able to provide the same minimum number .",
    "following is stewart s algorithm for the 4-peg problem :    1 .",
    "move the @xmath0 topmost disks to another , intermediate , peg ( which is not the destination peg ) , using all 4 pegs .",
    "2 .   move the @xmath1 remaining disks to the destination peg using the 3 remaining pegs .",
    "3 .   move the @xmath0 disks from their current peg to the destination peg , using all 4 pegs @xcite .",
    "frame s algorithm is similar to stewart s . according to frame , for the _ k_-peg problem",
    ", a series of towers needs to be created .",
    "the smallest tower will consist of the largest disks , and the largest tower will consist of the smallest disks .",
    "only the largest disk remains on the start peg .",
    "once the towers are created , the largest disk is moved directly from the start peg to the destination peg .",
    "then , the tower of the next - largest disks can be moved to the destination peg using three pegs .",
    "each intermediate tower is then moved to the destination peg using one more empty peg than the previous tower @xcite .",
    "if the goal is to minimize the number of disk movements , then this algorithm presents two problems .",
    "one problem is to find the optimal number of disks , @xmath0 , to place on the intermediate peg .",
    "this paper examines the partitioning issue in sect .",
    "[ sec : partitions ] , using stewart s recursive algorithm .",
    "the other issue is that frame and stewart do not provide evidence that an optimal aglorithm involves the creation of intermediate sub - towers @xcite .",
    "however , as mentioned above , since korf has verified the optimality of this algorithm for 4 pegs and up to 30 disks @xcite , the frame - stewart algorithm is a good estimate .",
    "one of the asp competition s problems modifies the 4-peg puzzle to include configurations .",
    "this problem follows the same rules as the classic problem , but differs in regard to how the puzzle is initially arranged , and regarding the goal of the puzzle .",
    "instead of all the disks beginning and ending on the same peg , this problem provides two _ configurations_. the first configuration is the _",
    "start state _",
    ", a distribution of the disks over any combination of all four pegs .",
    "the second configuration is the _ goal state _ , a different distribution of the disks over the four pegs .",
    "these configurations were created based on the moves that the frame - stewart algorithm would perform .",
    "the problem is to generate the disk moves needed to get the disks from the first configuration to the second .",
    "in addition , there is a bound on the number of moves that could be generated @xcite .",
    "the bpsolver team used b - prolog to generate solutions for the given configurations .",
    "the following is the relevant code :    ....    : -table plan4(+,+,+,-,min ) .",
    "plan4(n,_cstate,_gstate , plan , len):-n=:=0,!,plan=[],len=0 .",
    "plan4(n , cstate , gstate , plan , len):-       remove_largest_disk_if_in_place (               n , cstate , gstate , cstate1,gstate1 ) , ! ,       n1 is n-1 ,       plan4(n1,cstate1,gstate1,plan , len ) .",
    "plan4(n , cstate , gstate , plan , len):-       % split disks into two groups       partition_disks(n , cstate , gstate , itstate , mid , peg ) ,       % sub - problem1       remove_larger_disks(cstate , mid , cstate1 ) ,       plan4(mid , cstate1,itstate , plan1,len1 ) ,       % sub - problem2       remove_smaller_or_equal_disks(cstate , mid , cstate2 ) ,       remove_smaller_or_equal_disks(gstate , mid , gstate2 ) ,       n1 is n - mid ,       plan3(n1,cstate2,gstate2,peg , plan2,len2 ) ,       % sub - problem3       remove_larger_disks(gstate , mid , gstate1 ) ,       plan4(mid , itstate , gstate1,plan3,len3 ) ,       %       append(plan1,plan2,plan3,plan ) ,       len is len1+len2+len3 . ....    instead of focusing on the given upper - bound of moves , this program attempts to find the _",
    "smallest _ number of moves required to get from the start configuration to the goal configuration .",
    "each configuration is represented by a single state , consisting of four lists .",
    "each list represents a single peg , and stores the disks that are currently located on the peg .",
    "this is an improvement on the bpsolver team s prior attempts to represent configurations using boolean expressions .",
    "prolog lends itself to list operations , and the number of disks on a peg is simply the length of the list .    the predicate plan4 is defined with three clauses .",
    "the first clause is the termination condition . when the number of disks to be removed is zero ,",
    "the problem has been solved .",
    "the second clause determines whether the current largest disk is currently in place .",
    "if so , it simplifies the problem by logically removing the disk .",
    "the third clause uses a modified form of stewart s approach to solve the configuration problem .",
    "the disks are split into two sub - groups , one of which is placed in an intermediate tower .",
    "the problem is separated into three sub - problems :    1 .",
    "the smallest mid disks are placed on an intermediate peg , peg , by calling plan4 recursively .",
    "the larger disks are moved from their current pegs to their destination positions by using the deterministic 3-peg algorithm on all of the pegs except for peg moves for _ n _ disks @xcite . ] .",
    "the small disks in the sub - tower are moved from the intermediate peg to their destination positions by calling the plan4 predicate recursively @xcite .",
    "another important line of code is : -table plan4(+,+,+,-,min ) .",
    "this uses _ tabling _ to store information about each state in memory . the purpose of tabling is to store answers to sub - goals , and to utilize the answers for future variant sub - goals",
    "this is a useful tool for dynamic programming , which reuses solutions to overlapping sub - problems .",
    "b - prolog uses linear tabling , lets variant sub - goals share answers , and uses the local , or lazy , strategy to return answers @xcite . the most recent version of b - prolog replies on hash - consing to let tabled subgoals and answers share ground structed terms @xcite .",
    "there are two benefits to using tabling .",
    "the first benefit is that tabling prevents infinite loops .",
    "once a state is visited , it should not be revisited .",
    "if states are visited more than once , the program could be stuck cycling between multiple states , possibly by just repeatedly moving a single disk between two pegs . by storing states in memory ,",
    "the program can check the table to see if a state has already been encountered .",
    "the other benefit of using tabling is that it reduces the number of calculations .",
    "once the program knows how to move _ p _ disks between two pegs , it can check the table to determine how to move any other set of _ p _ disks between any two pegs .",
    "sub - problems are represented in such a way that the same problem has the same representation and can share answers through tabling . it does not matter what the sizes of the _ p _ disks are , nor does it matter which pegs are being used as the current start and destination pegs , assuming the intermediate and destination pegs are logically empty , meaning that they do not contain disks smaller than the largest one being moved .",
    "this decreases the number of operations used during the recursive calls , and is helpful when backtracking to test a different solution .",
    "the line : -table plan4(+,+,+,-,min ) goes together with the line defining the predicate plan4(n , cstate , gstate , plan , len ) . a plus - sign ( + )",
    "indicates that the corresponding arguments ( n - the number of disks , cstate - the current state , and gstate - the goal state ) are input .",
    "a minus - sign ( - ) indicates that the corresponding arguments ( plan - the sequence of disk moves ) are output .",
    "the last part , min indicates that len , the length of the plan of disk moves , should be minimized . by minimizing the plan length",
    ", the number of moves will clearly be within the bounds provided in the given problems ; otherwise , the problems would be unsolvable .",
    "since the predicate plan4 is non - deterministic , it presents a few interesting issues . like the classic algorithm",
    ", this program must determine optimal sizes of the disk sub - towers .",
    "a new problem that arises is that the program must determine which peg to use to store each sub - tower . in the classic 4-peg problem ,",
    "there is one peg that never has to be used to store a sub - tower @xcite @xcite .",
    "however , the same is not true for the configuration problem .",
    "the start and destination pegs can change for each disk , meaning that any peg might need to be used to store a sub - tower . for further discussion of these issues , see sect .",
    "[ sec : partitions ] .",
    "tabling is also used for plan3 , defined below for the 3-peg problem .    ....    : -table plan3(+,+,+,+,-,min ) .",
    "plan3(0,_cstate,_gstate,_unusedpeg , plan , len):-!,plan=[],len=0 .",
    "plan3(n , cstate , gstate , unusedpeg , plan , len):-       remove_largest_disk_if_in_place(n , cstate ,                           gstate , cstate1,gstate1 ) , ! ,       n1 is n-1 ,       plan3(n1,cstate1,gstate1,unusedpeg , plan , len ) .",
    "plan3(1,cstate , gstate,_unusedpeg , plan , len):- !",
    ",       plan=[(peg1,peg2)],len=1 ,       btm_disk_on_peg(1,cstate , peg1 ) ,       btm_disk_on_peg(1,gstate , peg2 ) .",
    "plan3(n , cstate , gstate , unusedpeg , plan , len):-       btm_disk_on_peg(n , cstate , peg1 ) ,       btm_disk_on_peg(n , gstate , peg2 ) ,       other_two_pegs(peg1,peg2,peg3,peg4 ) ,       ( unusedpeg==peg3->tmppeg = peg4;tmppeg = peg3 ) ,       n1 is n-1 ,       remove_bottom_disk(cstate , peg1,cstate1 ) ,       itstate = s ( _ , _ , _ , _ ) ,       tower @= [ i : i in n1 .. (-1) .. 1 ] ,       foreach(i in 1 .. 4 ,                ( i==tmppeg->arg(i , itstate , tower ) ;                arg(i , itstate , [ ] )               )       ) ,       plan3(n1,cstate1,itstate , unusedpeg , plan1,len1 ) ,       remove_bottom_disk(gstate , peg2,gstate1 ) ,       plan3(n1,itstate , gstate1,unusedpeg , plan2,len2 ) ,       append(plan1,[(peg1,peg2)|plan2],plan ) ,       len is len1+len2 + 1 . ....    like plan4",
    ", the predicate plan3 has a clause for the termination condition and a clause for reducing the problem when the latest disk is in place .",
    "when the number of disks to be moved is one , it takes one step to solve it .",
    "otherwise , the problem is divided into three sub - tasks : the first sub - task is to move n-1 disks except for the largest one from the current peg to a temporary peg ; the second sub - task is to move the largest disk to the destination peg ; the third task is to move the n-1 disks from the temporary peg to the destination peg . unlike plan4 , plan3 is deterministic .",
    "the asp competition had six participants , including bpsolver .",
    "fastdownward used planning domain definition language to represent the problems , and utilized a * search with the selective - max and landmark - cut heuristics , using the input to bound the maximum solution length , in order to solve the hanoi problem .",
    "the idp team described the problems by using first order logic with inductive definitions , translated the problems into extended conjunctive normal form by using the gidl grounder , and solved the problems with the minisat(id ) solver .",
    "the remaining three teams solved the hanoi problem by using the grounder gringo , which translates input programs into equivalent , variable - free programs , and the solver clasp , which focuses on answer set programming together with nogood learning , checking for violated constraints .",
    "while ezcsp ran clasp on its default settings , aclasp utilized a modified restart strategy , which , as described by the team , `` depends on the average decision - level on which conflicts occurred . '' in order to solve the hanoi problem , the final team , potassco , specified that clasp should use the variable state independent decaying sum decision heuristic , and limited the amount of preprocessing and the initial database size .",
    "the asp competition programs were graded based on two criteria : the correctness of the solution and the amount of time that it took for each program to find the solution .",
    "the competition organizers had sixty instances that could have been used to test the hanoi solvers . only fifteen of those instances were actually used to grade the solvers . based on those fifteen instances , the bpsolver team scored highest , followed by potassco , aclasp , and idp .",
    "ezcsp and fast downward tied for the lowest score .",
    "bpsolver s program was the only one that actively used the frame - stewart algorithm to limit the size of the search space .",
    "every other program defined legal moves for the tower of hanoi problem , and used the definition as input to their solvers .",
    "therefore , the other teams scores were a result of the solvers they used and the heuristics that the solvers employed to trim the search space .",
    "the active use of the frame - stewart algorithm contributed to the speed of bpsolver s program .",
    "although some of the other teams used heuristics , and added rules in order to improve the search , such as ezcsp specifying that no disk should be moved twice in a row , they still had a larger search space .",
    "as will be shown in sect .",
    "[ sec : partitions ] , bpsolver used a mathematical function to partition the disks , which limited the possible moves at any given time .",
    "in addition , tabling reduced the number of repeated calculations , causing bpsolver s program to run faster than all the other programs .    in the competition ,",
    "bpsolver s hanoi program scored 94 , while potassco s scored 81 .",
    "however , an analysis of their performances on all 60 instances , summarized in table [ tab : comp ] , shows that the margin would not be as large .",
    "bpsolver still scores higher than potassco , but that is primarily due to the speed of b - prolog , as opposed to the correctness of the program .",
    "bpsolver s program printed a result of `` unknown '' for 6 of the instances , while potassco s was able to solve all instances .",
    "four of those six instances are a result of an error , in which the program printed `` unknown '' after finding a solution",
    ". only one of these instances was run during the competition .",
    "the remaining two unsolved instances , which are illustrated in fig .",
    "[ fig : unsolved_conf ] , and which were not run during the competition , are indicative of a larger problem .",
    "team bpsolver mistakenly believed that there was a known optimal guide for partitioning the disks when creating intermediate sub - towers @xcite .",
    "the b - prolog program s partitioning guide was not always able to find an optimal solution .",
    "instances 17 and 22 , the unsolved instances , title=\"fig : \" ] instances 17 and 22 , the unsolved instances , title=\"fig : \" ]      there have been a number of different estimates for determining the optimal size of the intermediate sub - tower when given _",
    "n _ disks .    for the asp competition , bpsolver used the following code to determine the optimal partition location :    ....    partition_disks(n , cstate , gstate , itstate , mid , peg ) : -       btm_disk_on_peg(n , cstate , peg1 ) ,       btm_disk_on_peg(n , gstate , peg2 ) ,       other_two_pegs(peg1,peg2,peg3,peg4 )",
    ",       ( peg = peg3;peg = peg4 ) ,       arg(peg , cstate , cdisks ) ,       arg(peg , gstate , gdisks ) ,       pn is n - integer(sqrt(2*n)+0.5 ) ,       low is max(pn-2,1 ) ,       up is min(pn+2,n-1 ) ,       between(low , up , mid ) ,       ( cdisks=[cbdisk|_],cbdisk=<mid ; cdisks= [ ] ) ,       ( gdisks=[gbdisk|_],gbdisk=<mid ; gdisks= [ ] ) ,       tower @= [ i : i in mid .. (-1) .. 1 ] ,       itstate = s ( _ , _ , _ , _ ) ,       foreach(i in 1 .. 4 ,               ( i==peg->arg(i , itstate , tower ) ;                arg(i , itstate , [ ] )               )       ) . ....",
    "the arguments are similar to the ones in the plan4 predicate , except itstate defines the intermediate state with the sub - tower , and peg is the peg on which the sub - tower will be placed .",
    "as mentioned above , there is an additional issue about where to place the sub - tower , based on the configurations .",
    "the program solves it in one of two ways .",
    "if the current configuration has a pre - existing sub - tower , a new one does not need to be created . otherwise , the program non - deterministically tests both of the pegs that are currently serving as intermediate pegs for the optimal sub - tower location .    given _",
    "n _ disks , the program uses rand s estimate of @xmath2 for the sub - tower size . as discovered after the asp competition",
    ", this does not always generate the optimal solution .",
    "therefore , the program was tested using different partition estimates .",
    "table [ tab : part ] shows the results .    for table [ tab : part",
    "] , two types of estimates were used .",
    "one type is a formula stated in terms of the number of disks .",
    "the other type relates the 4-peg hanoi problem to the _ triangular numbers _ , which are of the form @xmath3 @xcite , by finding the triangular number that is closest to the number of disks .",
    "the estimates of the first type explicitly state the relation between the number of disks and the triangular numbers found by the second type @xcite . in the final row of table [",
    "tab : part ] , the program was not given a guide for where to partition the disks .",
    "instead , it tested every number between 1 and @xmath4 , where _",
    "n _ is the number of disks .",
    "there are a number of other guides for partitioning the disks @xcite @xcite @xcite @xcite , but these were not tested",
    ". some , such as @xcite , are too closely related to specific algorithms .",
    "others , like @xcite , are too mathematically complex to test in terms of this program .",
    "some of the remaining , like @xcite , are for specific cases .",
    "some alternative partitions are clearly incorrect , as shown by stockmeyer @xcite . instead of including frame s and stewart s estimates ,",
    "this study incorpates stockmeyer s estimate , which is based on those of frame and stewart @xcite .",
    "the b - prolog program allows for an error in the number , @xmath5 , returned by the estimates .",
    "it checks all values between @xmath6 and @xmath7 for an optimal partition number . if this error bound is removed , and the program uses the exact number that is found , or if the error bound is decreased to @xmath8 and @xmath9 , then none of the functions in table [ tab : part ] solve all of the instances .",
    "it should be noted that three of the estimates in table [ tab : part ] fail for two of the instances , 17 and 22 , even when the error is allowed .",
    "the different approximations were tested for time and the amount of table memory that they used . on average ,",
    "the explicit functions almost always used less memory than the partitions that calculated each triangular number until a certain condition was met .",
    "the maximum memory used was always smaller for the explicit functions than for the repeated calculations .",
    "one reason for this is that tabling was incorporated into the calculations of the triangular numbers in order to reduce the number of required calculations .",
    "as shown in table [ tab : part ] , if the program tests every possible partition number , then it is guaranteed to find the optimal solution .",
    "however , the time and memory costs are much higher than they are if the program is given a partitioning guide .",
    "table [ tab : part ] indicates that the best guide to use for the competition is the one originally provided by rohl and gedeon ( as shown in row 3 ) .",
    "it should be noted that , if floor and ceiling operations are removed , liefvoort s solution ( row 2 ) is mathematically equivalent to theirs . since rohl and gedeon use the floor operation , while liefvoort uses the ceiling operation , their solutions differ .",
    "after the original program s error was removed , and the partitioning estimate was changed to that of rohl and gedeon , bpsolver s modified program was run on all 60 instances .",
    "table [ tab : new_comp ] shows the results of these tests , as compared to potassco s results .",
    "the results show that rohl s and gedeon s numbers are better than rand s , because bpsolver now scores 100 , instead of 94 .",
    "each of the sixty instances generated for the 2011 asp competition consisted of configurations that would be created during the execution of the frame - stewart algorithm on the classic 4-peg problem .",
    "the configurations included pre - created sub - towers that the frame - stewart algorithm would have generated .",
    "this section will show that , although a certain partition number is shown to work on the asp configurations , it is not guaranteed to solve every possible random configuration .",
    "bpsolver s modified program was tested in two additional ways .",
    "it was run on randomly generated configurations , some of which might not be created during the execution of the frame - stewart algorithm , and it was run on the classic 4-peg problem .      the first test was running the bpsolver program on randomly generated configurations .",
    "they were generated to match the asp competition s input files , which consisted of five sets of predicates @xcite .",
    "the bpsolver program was tested on twenty random configurations .",
    "since the configurations were random , some appeared to contain pre - existing intermediate sub - towers , while others did not .",
    "two versions of bpsolver s program were tested .",
    "one version created the sub - towers using the formula originally posed by rohl and gedeon @xcite with an error bound of two , and the other did not use any guide for where to partition the disks .",
    "these tests had varied results .",
    "only twelve of the twenty instances were solved by both programs .",
    "these instances had between 18 and 20 disks , while their solutions required between 120 and 257 steps .",
    "another five instances were only solved by the program that did not use a partitioning guide .",
    "these instances had between 21 and 23 disks , and required between 387 and 408 steps .",
    "one instance , with 25 disks , was solved in 533 steps by the program that used a formula , while the program that did not use a guide ran out of memory .",
    "the remaining two instances , which had 24 and 25 disks , were solved by neither program .",
    "the results appear to indicate that the 4-peg problem with random configurations requires a different approach than that of the frame - stewart algorithm . due to the varying sizes of the disks on any peg in the starting configuration",
    ", it might not be easy to derive a mathematical formula for the creation of an intermediate sub - tower .",
    "if a guide is not used , it can be too computationally complex to test every possible set of moves .",
    "disks may need to be repeatedly moved between the four pegs before a condition arises in which it is possible to create an intermediate sub - tower .",
    "configurations such as those found in fig .",
    "[ fig : rand_conf ] might not be encountered during the regular execution of the frame - stewart algorithm . therefore ,",
    "unless modifications are introduced to the algorithm , the frame - stewart algorithm might not be the best to solve random configurations .",
    "start and end configurations of an unsolved random instance ]      the classic 4-peg problem was used to test the same two programs that were tested on the random configurations . for this problem ,",
    "the programs were tested using an input of 30 disks .",
    "the program that used a formula was able to solve the problem using the optimum possible number of moves , 1025 @xcite .",
    "the one that had no guide ran out of memory .    since the program that used rohl s and gedeon s guide was able to solve the 30-disk problem , it was tested on the classic problem using every number of disks between one and thirty .",
    "when these tests were run , the partitioning error bounds of + 2 and -2 were removed . for each of the thirty instances ,",
    "the program was able to solve the problem using the optimum possible number of moves , as proven by @xcite and @xcite .",
    "after these tests were performed , the classic 4-peg problem was used to test the same six partition estimates that were examined using the asp problem in table [ tab : part ] .",
    "each estimate was tested on every number of disks between one and thirty . as opposed to the prior tests",
    ", these tests did not allow any error bound when calculating the partition number .",
    "although three of the estimates failed to solve every single asp competition configuration , all six estimates generated optimal solutions for every instance of the classic problem .",
    "korf has verified the minimum possible number of moves for any algorithm using inputs of up to 30 disks . by using the frame - stewart algorithm with any of the six partition estimates on the regular 4-peg hanoi problem",
    ", a solution is obtained that is the optimal solution of any possible algorithm .",
    "tabling and testing every partition number can be too computationally complex , but rohl s and gedeon s formula provides a good guide .",
    "many authors have tried to solve the 4-peg and _ k_-peg problems using their own algorithms . although most of the approaches are not used in this paper , it is important to note their contributions .",
    "following is a subset of the algorithms :      rohl and gedeon created recursive algorithms for both the 4-peg and the _ k_-peg problems , using a form of stewart s algorithm .",
    "this paper will focus on the algorithm for four pegs , wherein each recursive call builds a single sub - tower .",
    "if the current ordering of the pegs is ( 1 , 2 , 3 , 4 ) , the 4-peg algorithm is called to create a sub - tower with ordering ( 1 , 4 , 3 , 2 ) , the 3-peg algorithm is called on ( 1 , 2 , 3 ) to move the remaining pegs , and the 4-peg algorithm is called on ( 4 , 3 , 2 , 1 ) to move the sub - tower to the destination peg @xcite .",
    "this algorithm provided the partitioning guide utilized by bpsolver s modified program .",
    "lu produced an iterative approach for the 4-peg problem .",
    "lu s algorithm shows a correlation between the disk moves and binary numbers .",
    "it inserts a number of logical fake disks at pre - determined locations in order to map the disk moves to the binary numbers @xcite .",
    "sarkar used a recursive algorithm for the _ k_-peg problem that is similar to frame s algorithm .",
    "the algorithm deterministically decides how to distribute the topmost disks over intermediate pegs , using summation functions , before distributing any disks .",
    "it then recursively calls itself to distribute the disks .",
    "sarkar posed the _ serialization conjecture _ , stating that an optimal algorithm will distribute disks onto pegs such that disks on each peg have consecutive sizes , and the size of the top disk on a peg is consecutive with the size of the bottom disk on the next peg .",
    "if this conjecture is valid , then sarkar s algorithm is optimal @xcite .",
    "although this distribution method is efficient , this paper does not use it , because it does not easily extend to the configuration problem .",
    "another iterative algorithm for the 4-peg puzzle involves arranging the disk numbers into an upper - triangular array . based on this array",
    ", there is a `` cross - correlation '' between the solution of the problem represented by location ( _ i _ , _ j _ ) and the problems represented by locations ( _ i _ , _ j+1 _ ) , and ( _ i+1 _ , _ j+1 _ ) .",
    "this correlation decreases the number of necessary calculations @xcite .",
    "this is another efficient algorithm , although there is no clear way to extend it to the configuration problem .",
    "for configurations directly based on the frame - stewart algorithm , rohl s and gedeon s partitioning estimate of @xmath10 appears to be an optimal guide , even if it requires error bounds . although all of the estimates in table [ tab : part ] generate optimal solutions for the regular 4-peg puzzle for up to 30 disks without using error bounds , their correctness does not seem to extend to the configuration problem .",
    "perhaps the nature of the configuration problem changes the optimal partition location .",
    "testing bpsolver s program on random configurations further clarifies the issue .",
    "it appears that there are some configurations for which creating intermediate sub - towers may not be optimal . unlike the problem",
    "as studied by frame and stewart , it is not clear where to place the intermediate sub - towers .",
    "the non - determinism involved can cause the computation problem to be too computationally complex .",
    "however , bpsolver s program with rohl s and gedeon s estimates runs quickly , and uses tabling to reduce the number of calculations .",
    "therefore , it is a good guide for a dynamic programming solution for modified forms of the 4-peg tower of hanoi problem where non - determinism is required .",
    "the b - prolog program demonstrates the importance of tabling for declarative description of dynamic programming solutions . like use of pattern databases in state - space search and",
    "conflict - driven clause learning and memoization in sat solvers , tabling is a great technique for avoiding repeated exploration of the same states during search .",
    "this research was supported in part by nsf ( no.1018006 )              kaykobad , m , rahman , s. t .- u . , bakhtiar , r .- a . , and a. a. k. majumdar . a recursive algorithm for the multi - peg tower of hanoi problem . _",
    "international journal of computer mathematics _ vol .",
    "57 , no . 1 - 2 ( 1995 ) , 67 - 73 .",
    "korf , richard e. , and ariel felner .",
    "recent progress in heuristic search : a case study of the four - peg towers of hanoi problem .",
    "_ proceedings of the 20th international joint conference on artificial intelligence _ ( 2007 ) , 2324 - 2329 .",
    "stockmeyer , paul k. variations on the four - post tower of hanoi puzzle .",
    "_ proceedings of the 25th southeastern international conference on combinatorics , graph theory , and computing_. _ congressus numerantium _ vol .",
    "102 ( 1994 ) , 3 - 12 .",
    "truszczynski , miroslaw , smith , shaden , and alex westlund .",
    "tower of hanoi : problem description .",
    "asp competition 2011 .",
    "available via https://www.mat.unical.it/aspcomp2011/finalproblemdescriptions/hanoitower .",
    "wang , jun , liu , junpeng , yue , guoying , shao , liangshan , and sukui lu . a non - recursive algorithm for 4-peg hanoi tower . _ 2007 international conference on intelligent systems and knowledge engineering _ ( 2007 ) .",
    "zhou , neng - fa , dovier , agostino , and yuanlin zhang .",
    "bpsolver s solutions to the third asp competition problems .",
    "_ alp newsletter _ ( june 2011 ) .",
    "available via http://www.cs.nmsu.edu/alp/wp-content/uploads/2011/06/bprolog.pdf ."
  ],
  "abstract_text": [
    "<S> the frame - stewart algorithm for the 4-peg variant of the tower of hanoi , introduced in 1941 , partitions disks into intermediate towers before moving the remaining disks to their destination . </S>",
    "<S> algorithms that partition the disks have not been proven to be optimal , although they have been verified for up to 30 disks . </S>",
    "<S> this paper presents a dynamic programming approach to this algorithm , using tabling in b - prolog . </S>",
    "<S> this study uses a variation of the problem , involving configurations of disks , in order to contrast the tabling approach with the approaches utilized by other solvers . </S>",
    "<S> a comparison of different partitioning locations for the frame - stewart algorithm indicates that , although certain partitions are optimal for the classic problem , they need to be modified for certain configurations , and that random configurations might require an entirely new algorithm . </S>"
  ]
}