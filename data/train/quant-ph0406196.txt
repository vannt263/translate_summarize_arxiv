{
  "article_text": [
    "among the many difficulties that quantum computer architects face , one of them is almost intrinsic to the task at hand : how do you design and debug circuits that you ca nt even simulate efficiently with existing tools ?  obviously , if a quantum computer output the factors of a @xmath4-digit number , then you would nt need to simulate it to verify its correctness , since multiplying is easier than factoring .",
    "but what if the quantum computer _ did nt _",
    "ordinarily architects might debug a computer by adding test conditions , monitoring registers , halting at intermediate steps , and so on .",
    "but for a quantum computer , all of these standard techniques would probably entail measurements that destroy coherence .",
    "besides , it would be nice to design and debug a quantum computer using classical cad tools , _ before _ trying to implement it !",
    "quantum architecture is one motivation for studying classical algorithms to simulate and manipulate quantum circuits , but it is not the only motivation .",
    "chemists and physicists have long needed to simulate quantum systems , and they have not had the patience to wait for a quantum computer to be built .  instead , they have developed limited techniques such as quantum monte - carlo ( qmc ) @xcite for computing properties of certain ground states .",
    "more recently , several general - purpose quantum computer simulators have appeared , including oemer s quantum programming language qcl @xcite , the quidd ( quantum information decision diagrams ) package of viamontes et al .",
    "@xcite , and the parallel quantum computer simulator of obenland and despain @xcite .",
    "the drawback of such simulators , of course , is that their running time grows exponentially in the number of qubits .",
    "this is true not only in the worst case but in practice .",
    "for example , even though it uses a variant of binary decision diagrams to avoid storing an entire amplitude vector for some states , viamontes et al .",
    "@xcite  report that  the quidd package took more than 22 hours to simulate grover s algorithm on 40 qubits .  with a general - purpose package ,",
    "then , simulating hundreds or thousands of qubits is out of the question .",
    "a different direction of research has sought to find nontrivial classes of quantum circuits that _ can _ be simulated efficiently on a classical computer .",
    "for example , vidal @xcite  showed that , so long as a quantum computer s state at every time step has polynomially - bounded entanglement under a measure related to schmidt rank , the computer can be simulated classically in polynomial time .",
    "notably , in a follow - up paper @xcite ,  vidal actually implemented his algorithm and used it to simulate @xmath5-dimensional quantum spin chains consisting of hundreds of spins .",
    "a second example is a result of valiant @xcite , which reduces the problem of simulating a restricted class of quantum computers to that of computing the pfaffian of a matrix .",
    "the latter is known to be solvable in classical polynomial time .",
    "terhal and divincenzo @xcite have shown that valiant s class corresponds to a model of noninteracting fermions .",
    "there is one class of quantum circuits that is known to be simulable in classical polynomial time , that does not impose any limit on entanglement , and that arises naturally in several applications .",
    "this is the class of _ stabilizer circuits",
    "_  introduced to analyze quantum error - correcting codes @xcite .",
    "a stabilizer circuit is simply a quantum circuit in which every gate is a controlled - not , hadamard , phase , or @xmath5-qubit measurement gate .",
    "we call a stabilizer circuit _ unitary _ if it does not contain measurement gates .",
    "unitary stabilizer circuits are also known as clifford group circuits .",
    "[ ptb ]    gates.eps    stabilizer circuits can be used to perform the encoding and decoding steps for a quantum error - correcting code , and they play an important role in fault - tolerant circuits .",
    "however , the _ stabilizer formalism _ used to describe these circuits has many other applications .",
    "this formalism is rich enough to encompass most of the paradoxes  of quantum mechanics , including the ghz ( greenberger - horne - zeilinger ) experiment @xcite , dense quantum coding @xcite , and quantum teleportation @xcite .  on the other hand ,",
    "it is not _",
    "so _ rich as to preclude efficient simulation by a classical computer .",
    "that conclusion , sometimes known as the _ gottesman - knill theorem _ , is the starting point for the contributions of this paper .",
    "our results are as follows .  in section [ sim ]",
    "we give a new _ tableau algorithm _ for simulating stabilizer circuits that is faster than the algorithm directly implied by the gottesman - knill theorem .  by removing the need for gaussian elimination",
    ", this algorithm enables measurements to be simulated in @xmath6  steps instead of @xmath7  ( where @xmath2 is the number of qubits ) , at a cost of a factor-@xmath0 increase in the number of bits needed to represent a quantum state .",
    "section [ implem ] describes chp , a high - performance stabilizer circuit simulator that implements our tableau algorithm .",
    "we present the results of an experiment designed to test how chp s performance is affected by properties of the stabilizer circuit being simulated .",
    "chp has already found application in simulations of quantum fault - tolerance circuits @xcite .",
    "section [ parityl ]  proves that the problem of simulating stabilizer circuits is complete for the classical complexity class @xmath1 .",
    "informally , this means that any stabilizer circuit can be simulated using cnot gates alone ; the availability of hadamard and phase gates provides at most a polynomial advantage .",
    "this result removes some of the mystery about the gottesman - knill theorem by showing that stabilizer circuits are unlikely to be capable even of universal _ classical _ computation .    in section",
    "[ canonical ]  we prove a _ canonical form theorem _ that we expect will have many applications to the study of stabilizer circuits .",
    "the theorem says that given any stabilizer circuit , there exists an equivalent stabilizer circuit that applies a round of hadamard gates , followed by a round of phase gates , followed by a round of cnot gates , and so on in the sequence h - c - p - c - p - c - h - p - c - p - c ( where h , c , p stand for hadamard , cnot , phase respectively ) .  one immediate corollary , building on a result by patel , markov , and hayes @xcite and improving one by dehaene and de moor @xcite , is that any stabilizer circuit on @xmath2 qubits has an equivalent circuit with only @xmath3  gates .",
    "finally , section [ beyond ] extends our simulation algorithm to situations beyond the usual one considered in the gottesman - knill theorem .",
    "for example , we show how to handle mixed states , _ without _ keeping track of pure states from which the mixed states are obtainable by discarding qubits .",
    "we also show how to simulate circuits involving a small number of non - stabilizer gates ; or involving arbitrary tensor - product initial states , but only a small number of measurements .  both of these latter two simulations take time that is polynomial in the number of qubits , but exponential in the number of non - stabilizer gates or measurements .",
    "presumably this exponential dependence is necessary , since otherwise we could simulate arbitrary quantum computations in classical subexponential time .",
    "we conclude in section [ open ]  with some directions for further research .",
    "we assume familiarity with quantum computing .  this section provides a crash course on the stabilizer formalism , confining attention to those aspects we will need .",
    "see section 10.5.1 of nielsen and chuang @xcite for more details .    throughout this paper",
    "we will use the following four pauli matrices:@xmath8{ll}% i=\\left ( \\begin{array } [ c]{cc}% 1 & 0\\\\ 0 & 1 \\end{array } \\right )   & x=\\left ( \\begin{array } [ c]{cc}% 0 & 1\\\\ 1 & 0 \\end{array } \\right ) \\\\ y=\\left ( \\begin{array } [ c]{cc}% 0 & -i\\\\ i & 0 \\end{array } \\right )   & z=\\left ( \\begin{array } [ c]{cc}% 1 & 0\\\\ 0 & -1 \\end{array } \\right ) \\end{array}\\ ] ] these matrices satisfy the following identities:@xmath9{ccc}% xy = iz & yz = ix & zx = iy\\\\ yx =- iz & zy =- ix & xz =- iy \\end{array}\\end{aligned}\\ ] ] in particular , every two pauli matrices either commute or anticommute .  the rule for whether to include a minus sign is the same as that for quaternions , if we replace @xmath10 by @xmath11 .",
    "we define the group @xmath12  of @xmath2-qubit _ pauli operators _ to consist of all tensor products of @xmath2 pauli  matrices , together with a multiplicative factor of @xmath13 or @xmath14  ( so the total number of operators is @xmath15 ) .",
    "we omit tensor product signs for brevity ; thus @xmath16  should be read @xmath17 ( we will use @xmath18  to represent the pauli group operation )",
    ".  given two pauli operators @xmath19  and @xmath20 , it is immediate that @xmath21 commutes with @xmath22 if and only if the number of indices @xmath23  such that @xmath24  anticommutes with @xmath25 is even ; otherwise @xmath21 anticommutes with @xmath22 .",
    "also , for all @xmath26 , if @xmath21 has a phase of @xmath13  then @xmath27 , whereas if @xmath21 has a phase of @xmath14  then @xmath28",
    ".    given a pure quantum state @xmath29 ,  we say a unitary matrix @xmath30 _ stabilizes _",
    "@xmath29  if @xmath31  is an eigenvector of @xmath30  with eigenvalue @xmath5 , or equivalently if@xmath32 where we do not ignore global phase .",
    "to illustrate , the following table lists the pauli matrices and their opposites , together with the unique @xmath5-qubit states that they stabilize:@xmath8{lllll}% x : & \\left|   0\\right\\rangle + \\left|   1\\right\\rangle   & \\,\\,\\ , & -x : & \\left| 0\\right\\rangle -\\left|   1\\right\\rangle \\\\ y : & \\left|   0\\right\\rangle + i\\left|   1\\right\\rangle   & \\,\\,\\ , & -y : & \\left| 0\\right\\rangle -i\\left|   1\\right\\rangle \\\\ z : & \\left|   0\\right\\rangle   & \\,\\,\\ , & -z : & \\left|   1\\right\\rangle \\end{array}\\ ] ] the identity matrix @xmath33 stabilizes all states , whereas @xmath34  stabilizes no states .",
    "the key idea of the stabilizer formalism is to represent a quantum state @xmath35 , not by a vector of amplitudes , but by a _ stabilizer group _ , consisting of unitary matrices that stabilize @xmath35 .",
    "notice that if @xmath30 and @xmath36 both stabilize @xmath35 then so do @xmath37 and @xmath38 , and thus the set @xmath39  of stabilizers of @xmath35  is a group .  also , it is not hard to show that if @xmath40  then @xmath41 .",
    "but why does this strange representation buy us anything ?  to write down generators for @xmath42  ( even approximately ) still takes exponentially many bits in general by an information - theoretic argument .",
    "indeed stabilizers seem _ worse _ than amplitude vectors , since they require about @xmath43  parameters to specify instead of about @xmath44 !    remarkably , though , a large and interesting class of quantum states can be specified uniquely by much smaller stabilizer groups  specifically , the intersection of @xmath45 with the pauli group @xcite .",
    "this class of states , which arises in quantum error correction and many other settings , is characterized by the following theorem .",
    "[ gk]given an @xmath2-qubit state @xmath29 , the following are equivalent :    1 .",
    "@xmath29 can be obtained from @xmath46  by cnot , hadamard , and phase gates only",
    "@xmath29 can be obtained from @xmath46  by cnot , hadamard , phase , and measurement gates only .",
    "@xmath29 is stabilized by exactly @xmath47  pauli operators .",
    "@xmath29 is uniquely determined by @xmath48 , or the group of pauli operators that stabilize @xmath29 .    because of theorem [ gk ] , we call any circuit consisting entirely of cnot , hadamard , phase , and measurement gates a _ stabilizer circuit _ , and any state obtainable by applying a stabilizer circuit to @xmath49  a _ stabilizer state_.  as a warmup to our later results , the following proposition counts the number of stabilizer states .",
    "[ count]let @xmath50 be the number of pure stabilizer states on @xmath2 qubits .",
    "then@xmath51    we have @xmath52 , where @xmath53 is the total number of generating sets and @xmath54 is the number of equivalent generating sets for a given stabilizer @xmath55 .  to find @xmath53 , note that there are @xmath56 choices for the first generator @xmath57 ( ignoring overall sign ) , because it can be anything but the identity .",
    "the second generator must commute with @xmath57 and can not be @xmath33 or @xmath57 , so there are @xmath58 choices for @xmath59 .",
    "similarly , @xmath60 must commute with @xmath57 and @xmath59 , but can not be in the group generated by them , so there are @xmath61 choices for it , and so on .",
    "hence , including overall signs,@xmath62 similarly , to find @xmath54 , note that given @xmath55 , there are @xmath63 choices for @xmath57 , @xmath64 choices for @xmath59 , @xmath65 choices for @xmath60 , and so on .",
    "thus @xmath66 therefore @xmath67",
    "theorem [ gk ]  immediately suggests a way to simulate stabilizer circuits efficiently on a classical computer .",
    "a well - known fact from group theory says that any finite group @xmath53 has a generating set of size at most @xmath68 .",
    "so if @xmath35  is a stabilizer state on @xmath2 qubits , then the group  @xmath69  of pauli operators that stabilize @xmath70 has a generating set of size @xmath71 .",
    "each generator takes @xmath72  bits to specify : @xmath0  bits for each of the @xmath2 pauli matrices , and @xmath5 bit for the phase .",
    ", then @xmath21 can only have a phase of @xmath13 , not @xmath14 : for in the latter case @xmath73  would be in @xmath74 ,  but we saw that @xmath34  does not stabilize anything . ]  so the total number of bits needed to specify @xmath35  is @xmath75 .",
    "what gottesman and knill showed , furthermore , is that these bits can be _ updated _ in polynomial time after a cnot , hadamard , phase , or measurement gate is applied to @xmath35 .",
    "the updates corresponding to unitary gates are very efficient , requiring only @xmath76  time for each gate .    however , the updates corresponding to measurements are not so efficient",
    ".  we can decide in @xmath76  time whether a measurement of qubit @xmath77 will yield a deterministic or random outcome .",
    "if the outcome is random , then updating the state after the measurement takes @xmath78  time , but if the outcome is deterministic , then deciding whether the outcome is @xmath79 or @xmath80 seems to require inverting an @xmath81  matrix , which takes @xmath82  time in theory @xcite  but order @xmath83  time in practice .",
    "what that @xmath83  complexity means is that simulations of , say , @xmath84-qubit  systems would already be prohibitive on a desktop pc , given that measurements are frequent .",
    "this section describes a new simulation algorithm , by which both deterministic and random measurements can be performed in @xmath6 time .",
    "the cost is a factor-@xmath0 increase in the number of bits needed to specify a state .  for in addition to the @xmath2 stabilizer generators , we now store @xmath2  destabilizer  generators , which are pauli operators that together with the stabilizer generators generate the full pauli group @xmath12 .",
    "so the number of bits needed is @xmath85 .",
    "the algorithm represents a state by a _ tableau _  consisting of binary variables @xmath86 for all @xmath87 , @xmath23 , and @xmath88  for all @xmath89 :  time.]@xmath90{ccc|ccc|c}% $ x_{11}$ & $ \\cdots$ & $ x_{1n}$ & $ z_{11}$ & $ \\cdots$ & $ z_{1n}$ & $ r_{1}$\\\\ $ \\vdots$ & $ \\ddots$ & $ \\vdots$ & $ \\vdots$ & $ \\ddots$ & $ \\vdots$ & $ \\vdots$\\\\ $ x_{n1}$ & $ \\cdots$ & $ x_{nn}$ & $ z_{n1}$ & $ \\cdots$ & $ z_{nn}$ &",
    "$ r_{n}% $ \\\\\\hline $ x_{\\left (   n+1\\right )   1}$ & $ \\cdots$ & $ x_{\\left (   n+1\\right )   n}$ & $ z_{\\left (   n+1\\right )   1}$ & $ \\cdots$ & $ z_{\\left (   n+1\\right )   n}$ & $ r_{n+1}$\\\\ $ \\vdots$ & $ \\ddots$ & $ \\vdots$ & $ \\vdots$ & $ \\ddots$ & $ \\vdots$ & $ \\vdots$\\\\ $ x_{\\left (   2n\\right )   1}$ & $ \\cdots$ & $ x_{\\left (   2n\\right )   n}$ & $ z_{\\left (   2n\\right )   1}$ & $ \\cdots$ & $ z_{\\left (   2n\\right )   n}$ & $ r_{2n}$% \\end{tabular } \\ \\ \\ \\ \\right)\\ ] ] rows @xmath5 to @xmath2 of the tableau represent the destabilizer generators @xmath91 , and rows @xmath92  to @xmath93 represent the stabilizer generators @xmath94 .",
    "if @xmath95 , then bits @xmath86  determine the  @xmath96  pauli matrix @xmath24 : @xmath97 means @xmath33 , @xmath98 means @xmath99 , @xmath100 means @xmath101 , and @xmath102 means @xmath103 .",
    "finally , @xmath88  is @xmath5 if @xmath104  has negative phase and @xmath105 if @xmath88  has positive phase .  as an example , the @xmath0-qubit state @xmath106  is stabilized by the pauli operators @xmath107  and @xmath108 , so a possible tableau for @xmath109  is@xmath90{cc|cc|c}% $ ~1~$ & $ ~0~$ & $ ~0~$ & $ ~0~$ & $ ~0~$\\\\ $ ~0~$ & $ ~1~$ & $ ~0~$ & $ ~0~$ & $ ~0~$\\\\\\hline $ ~0~$ & $ ~0~$ & $ ~1~$ & $ ~0~$ & $ ~0~$\\\\ $ ~0~$ & $ ~0~$ & $ ~0~$ & $ ~1~$ & $ ~0~$% \\end{tabular } \\right)\\ ] ] indeed , we will take the obvious generalization of the above identity matrix  to be the standard initial tableau .",
    "the algorithm uses a subroutine called @xmath110 , which sets generator @xmath111 equal to @xmath112 .",
    "its purpose is to keep track , in particular , of the phase bit @xmath113 , including all the factors of @xmath114 that appear when multiplying pauli matrices .",
    "the subroutine is implemented as follows .    * * rowsum**@xmath115 : let @xmath116  be a function that takes @xmath117 bits as input , and that returns the exponent to which @xmath114 is raised ( either @xmath105 , @xmath5 , or @xmath118 ) when the pauli matrices represented by @xmath119  and @xmath120  are multiplied .  more explicitly , if @xmath121  then @xmath122 ; if @xmath123  then @xmath124 ; if @xmath125  and",
    "@xmath126  then @xmath127 ; and if @xmath128  and @xmath129  then @xmath130 .",
    "then set @xmath131  if@xmath132 and set @xmath133  if the sum is congruent to @xmath0  mod @xmath117 ( it will never be congruent to @xmath5 or @xmath134 ) .",
    "next , for all @xmath135 ,  set @xmath136 and set @xmath137 ( here and throughout , @xmath138  denotes exclusive - or ) .",
    "we now give the algorithm .",
    "it will be convenient to add an additional @xmath139  row for scratch space .",
    "the initial state @xmath140  has @xmath141  for all @xmath142 , and @xmath143  and @xmath144  for all @xmath142 and  @xmath135 , where @xmath145 is @xmath5  if @xmath146  and @xmath105 otherwise .",
    "the algorithm proceeds through the gates in order ; for each one it does one of the following depending on the gate type .",
    "* cnot from control * @xmath77 * to target * @xmath147**. * *  for all @xmath87 , set @xmath148 , @xmath149 , and @xmath150 .",
    "* hadamard on qubit * @xmath77**. * *  for all @xmath89 , set @xmath151  and swap @xmath152  with @xmath153 .",
    "* phase on qubit * @xmath77**. * *  for all @xmath89 , set @xmath151 and then set @xmath154 .",
    "* measurement of qubit * @xmath77 * in standard basis . *  first check whether there exists a @xmath155  such that @xmath156 .    * case i : * such a @xmath157 exists ( if more than one exists , then let @xmath157 be the smallest ) .  in this case",
    "the measurement outcome is random , so the state needs to be updated .",
    "this is done as follows .",
    "first call @xmath158  for all @xmath89  such that @xmath159  and @xmath160 .",
    "second , set entire the @xmath161  row equal to the @xmath162  row .",
    "third , set the @xmath162  row to be identically @xmath105 , except  that @xmath163  is @xmath105 or @xmath5 with equal probability , and @xmath164 .",
    "finally , return @xmath165  as the measurement outcome .",
    "* case ii : * such an @xmath157 does not exist .  in this case",
    "the outcome is determinate , so measuring the state will not change it ; the only task is to determine whether @xmath105 or @xmath5 is observed .",
    "this is done as follows .",
    "first set the @xmath139  row to be identically @xmath105 .",
    "second , call @xmath166  for all @xmath167  such that @xmath160 .",
    "finally return @xmath168  as the measurement outcome .",
    "once we interpret the @xmath169 , @xmath170 , and @xmath88  bits for @xmath171 as representing generators of @xmath172 , and @xmath173  as representing the group operation in @xmath12 , the correctness of the cnot , hadamard , phase , and random measurement procedures follows immediately from previous analyses by gottesman @xcite .",
    "it remains only to explain why the determinate measurement procedure is correct .",
    "observe that @xmath174  commutes with @xmath104  if the _",
    "_ symplectic inner product__@xmath175 equals @xmath105 , and anticommutes with @xmath104  if @xmath176 .  using that fact it is not hard to show the following .",
    "[ invariant]the following are invariants of the tableau algorithm :    * @xmath94 generate @xmath177 , and @xmath178  generate @xmath12 . *",
    "@xmath91 commute .",
    "* for all @xmath179 , @xmath180  anticommutes with @xmath181 .",
    "* for all @xmath182 such that @xmath183 , @xmath104  commutes with @xmath181 .",
    "now suppose that a measurement of qubit @xmath77 yields a determinate outcome .",
    "then the @xmath184  operator must commute with all elements of the stabilizer , so@xmath185 for a unique choice of @xmath186 .",
    "our goal is to determine the @xmath187 s , since then by summing the appropriate @xmath181 s we can learn whether the phase representing the outcome is positive or negative .",
    "notice that for all @xmath188,@xmath189 by proposition [ invariant ] .  therefore by checking whether @xmath190  anticommutes with @xmath184which it does if and only if @xmath160we learn whether @xmath191 and thus whether @xmath192  needs to be called .",
    "we end this section by explaining how to compute the _ inner product _ between two stabilizer states @xmath35  and @xmath193 , given their full tableaus .",
    "the inner product is @xmath105 if the stabilizers contain the same pauli operator with opposite signs .",
    "otherwise it equals @xmath194 , where @xmath195 is the minimum , over all sets of generators @xmath196  for  @xmath197  and @xmath198  for  @xmath199 , of the number of @xmath114 for which @xmath200 .  for example , @xmath201 and @xmath202 have inner product @xmath203 , since @xmath204 .",
    "the proof is easy : it suffices to observe that neither the inner product nor @xmath195 is affected if we transform @xmath35  and @xmath205  to @xmath206  and @xmath207 respectively , for some unitary @xmath30 such that @xmath208  has the trivial stabilizer .",
    "this same observation yields an algorithm to compute the inner product : first transform the tableau of @xmath209 to that of @xmath210  using theorem [ canonical ] ; then perform gaussian elimination on the tableau of @xmath211 to obtain @xmath195 .",
    "unfortunately , this algorithm takes order @xmath83  steps .",
    "we have implemented the tableau algorithm of section [ sim ]  in a c program called chp ( cnot - hadamard - phase ) , which is available for download .",
    "chp takes as input a program in a simple quantum assembly language ,  consisting of four instructions : ` c ` @xmath77 @xmath147  ( apply cnot from control @xmath77 to target @xmath147 ) , ` h ` @xmath77  ( apply hadamard  to @xmath77 ) , ` p ` @xmath77  ( apply phase gate to @xmath77 ) , and ` m ` @xmath77  ( measure @xmath77 in the standard basis , output the result , and update the state accordingly ) .",
    "here @xmath77  and @xmath147 are nonnegative integers indexing qubits ; the maximum @xmath77 or @xmath147 that occurs in any instruction is assumed to be @xmath212 , where @xmath2 is the number of qubits .  as an example , the following program demonstrates the famous quantum teleportation protocol of bennett et al .",
    "@xcite :    @xmath213{l}% \\texttt{h 1}\\\\ \\texttt{c 1 2}% \\end{tabular } \\right\\ }   $ ]    [ c]lepr pair is prepared ( qubit @xmath5 is + alice s half ; qubit @xmath0 is bob s half )    @xmath213{l}% \\texttt{c 0 1}\\\\ \\texttt{h 0}\\\\ \\texttt{m 0}\\\\",
    "\\texttt{m 1}% \\end{tabular } \\right\\ }   $ ]    [ c]lalice interacts qubit @xmath105 ( the state to + be teleported ) with her half of the + epr pair    @xmath213{l}% \\texttt{c 0 3}\\\\ \\texttt{c 1 4}% \\end{tabular } \\right\\ }   $ ]    [ c]lalice sends @xmath0 classical bits to bob    @xmath213{l}% \\texttt{c 4 2}\\\\ \\texttt{h 2}\\\\ \\texttt{c 3 2}\\\\ \\texttt{h 2}% \\end{tabular } \\",
    "\\right\\ }   $ ]    [ c]lbob uses the bits from alice to + recover the teleported state    we also have available chp programs that demonstrate the bennett - wiesner dense quantum coding protocol @xcite , the ghz ( greenberger - horne - zeilinger ) experiment @xcite , simon s algorithm @xcite , and the shor @xmath214-qubit quantum error - correcting code @xcite .    our main design goal for chp was high performance with a large number of qubits and frequent measurements .",
    "the only reason to use chp instead of a general - purpose quantum computer simulator such as quidd @xcite  or qcl @xcite is performance , so we wanted to leverage that advantage and make thousands of qubits easily simulable rather than just hundreds .",
    "also , the results of section [ parityl ]  suggest that classical postprocessing is unavoidable for stabilizer circuits , since stabilizer circuits are not even universal for classical computation .",
    "so if we want to simulate ( for example ) simon s algorithm , then one measurement is needed for each bit of the first register .",
    "chp s execution time will be dominated by these measurements , since as discussed in section [ sim ] , each unitary gate takes only @xmath215  time to simulate .",
    "our experimental results , summarized in figure [ fig : chart ] , show that chp makes practical the simulation of arbitrary stabilizer circuits on up to about @xmath4 qubits .",
    "since the number of bits needed to represent @xmath2 qubits grows quadratically in @xmath2 , the main limitation is available memory .  on a machine with 256 mb of ram",
    ", chp can handle up to about @xmath216  qubits before virtual memory is needed , in which case thrashing makes its performance intolerable .  the original version of chp required @xmath217 bits for memory ; we were able to reduce this to @xmath218  bits , enabling a 41% increase in the number of qubits for a fixed memory size .",
    "more trivially , we obtained an eightfold improvement in memory by storing @xmath219 bits to each byte instead of @xmath5 .",
    "not only did that change increase the number of storable qubits by 183% , but it also made chp about 50% faster  presumably because ( 1 ) the @xmath173  subroutine now needed to exclusive - or only @xmath220  as many bytes , and ( 2 ) the memory penalty was reduced .  storing the bits in @xmath221-bit words yielded a further 10% performance gain , presumably because of ( 1 ) rather than ( 2 ) ( since even with byte - addressing , a whole memory line is loaded into the cache on a cache miss ) .",
    "as expected , the experimentally measured execution time per unitary gate  grows linearly in @xmath2 , whereas the time per measurement grows somewhere between linearly and quadratically , depending on the states being measured .",
    "thus the time needed for measurements generally dominates execution time .",
    "so the key question is this : what properties of a circuit determine whether the time per measurement is linear , quadratic , or somewhere in between ?  to investigate this question we performed the following experiment .",
    "we randomly generated stabilizer circuits on @xmath2 qubits , for @xmath2 ranging from @xmath222 to @xmath223 in increments of @xmath222 .",
    "for each @xmath2 , we used the following distribution over circuits : _ fix a parameter _ @xmath224 _ _ ; then choose _ _ @xmath225 _ random unitary gates : a cnot from control _",
    "@xmath77 _ to target _",
    "@xmath147 _ _ , a hadamard on qubit _ _ @xmath77 _ _ , or a phase gate on qubit _",
    "_ @xmath77 _ _ , each with probability _ _ @xmath226 _ _ , where _ _ @xmath77 _ and _ @xmath147 _ are drawn uniformly at random from _",
    "@xmath227 _ _  subject to _ _",
    "@xmath228__.  then measure qubit _ _ @xmath77",
    "_ for each _",
    "@xmath229 _ in sequence . _",
    "we simulated the resulting circuits in chp .",
    "for each circuit , we counted the number of seconds needed for all @xmath2 measurement steps ( ignoring the time for unitary gates ) , then divided by @xmath2  to obtain the number of seconds per measurement .",
    "we repeated the whole procedure for @xmath230 ranging from @xmath231  to @xmath232  in increments of @xmath233 .",
    "there were several reasons for placing measurements at the end of a circuit rather than interspersing them with unitary gates .",
    "first , doing so models how many quantum algorithms actually work ( apply unitary gates , then measure , then perform classical postprocessing ) ; second , it allowed us to ignore the effect of measurements on subsequent computation ; third , it ` standardized ' the measurement stage , making comparisons between different circuits more meaningful ; and fourth , it made simulation harder by increasing the propensity for the measurements to be nontrivially correlated .    the decision to make the number of unitary gates  proportional to @xmath234",
    "was based on the following heuristic argument .",
    "the time needed to simulate a measurement is determined by how many times the @xmath173  procedure is called , which in turn is determined by how many @xmath114 s there are such that @xmath160  ( where @xmath77 is the qubit being measured ) .",
    "initially @xmath160  if and only if @xmath235 , so a measurement takes @xmath76  time .  for a random state , by contrast , the expected number of @xmath114 s such that @xmath160  is @xmath2 by symmetry , so a measurement takes order @xmath236  time .  in general , the more @xmath5 s there are in the tableau , the longer measurements take .",
    "but where does the transition from linear to quadratic time occur , and how sharp is it ?",
    "consider @xmath2 people , each of whom initially knows one secret ( with no two people knowing the same secret ) .",
    "each day , two people chosen uniformly at random meet and exchange all the secrets they know .",
    "what is the expected number of days until everyone knows everyone else s secrets ?",
    "intuitively , the answer is @xmath237 , because any given person has to wait @xmath238 days between meetings , and at each meeting , the number of secrets he knows approximately doubles ( or towards the end , the number of secrets he _ does nt _ know is approximately halved ) .  replacing people by qubits and meetings by cnot gates ,",
    "one can see why a ` phase transition ' from a sparse to a dense tableau might occur after @xmath237  random unitary gates are applied .",
    "however , this argument does not pin down the proportionality constant @xmath230 , so that is what we varied in the experiment .",
    "the results of the experiment are presented in figure [ fig : chart ] .",
    "when @xmath239 , the time per measurement appears to grow roughly linearly in @xmath2 , whereas when @xmath240 ( meaning that the number of unitary gates has only doubled ) , the time per measurement appears to grow roughly quadratically , so that running the simulations took @xmath117 hours of computing time .",
    ",  the time per measurement grows as @xmath241  for some @xmath242 .",
    "however , we do not have enough data to confirm or refute this conjecture ]  thus , figure [ fig : chart ] gives striking evidence for a phase transition  in simulation time , as increasing the number of unitary gates by only a constant factor shifts us from a regime of simple states that are easy to measure , to a regime of complicated states that are hard to measure .",
    "this result demonstrates that chp s performance depends strongly on the circuit being simulated .  without knowing what sort of tableaus a circuit will produce ,",
    "all we can say is that the time per measurement will be somewhere between linear and quadratic in @xmath2 .",
    "[ ptb ]    chart.eps",
    "the gottesman - knill theorem shows that stabilizer circuits are not universal for quantum computation , unless quantum computers can be simulated efficiently by classical ones .  to a computer scientist",
    ", this theorem immediately raises a question : where _ do _ stabilizer circuits sit in the hierarchy of computational complexity theory ?  in this section",
    "we resolve that question , by proving that the problem of simulating stabilizer circuits is complete for a classical complexity class known as @xmath1  ( pronounced parity - l ) .",
    "and several hundred other complexity classes ]  the usual definition of @xmath243  is as the class of all problems that are solvable by a nondeterministic logarithmic - space turing machine , that accepts if and only if the total number of accepting paths is odd .",
    "but there is an alternate definition that is probably more intuitive to non - computer - scientists .",
    "this is that @xmath1  is the class of problems that reduce to simulating a polynomial - size _ cnot circuit _ ,",
    "i.e. a circuit composed entirely of not and cnot gates , acting on the initial state @xmath244 .",
    "( it is easy to show that the two definitions  are equivalent , but this would require us first to explain what the usual definition _ means _ ! )    from the second definition , it is clear that @xmath245 ; in other words , any problem reducible to simulating cnot circuits is also solvable in polynomial time on a classical computer .  but this raises a question : what do we mean by reducible ?",
    "problem @xmath54 is reducible to problem @xmath246 if any instance of problem @xmath54 can be transformed into an instance of problem @xmath246 ; this means that problem @xmath246 is harder  than problem @xmath54 in the sense that the ability to answer an arbitrary instance of problem @xmath246 implies the ability to answer an arbitrary instance of problem @xmath54 ( but not necessarily vice - versa ) .",
    "we must , however , insist that the reduction transforming instances of problem @xmath54 into instances of problem @xmath246 not be too difficult to perform .  otherwise , we could reduce hard problems to easy ones by doing all the difficult work in the reduction itself .  in the case of @xmath1 ,",
    "we _ can not _",
    "mean reducible in polynomial time ,  which is a common restriction , since then the reduction would be at least as powerful as the problem it reduces to !",
    "instead we require the reduction to be performed in the complexity class @xmath247 , or _",
    "logarithmic space_that is , by a turing machine @xmath248 that is given a read - only input of size @xmath2 , and a write - only output tape , but only @xmath249  bits of read / write memory .",
    "the reduction works as follows : first @xmath248 specifies a cnot circuit on its output tape ; then an oracle  tells @xmath248 the circuit s output ( which we can take to be , say , the value of the first qubit after the circuit is applied ) , then @xmath248 specifies another cnot circuit on its output tape , and so on .",
    "a useful result of hertrampf , reith , and vollmer @xcite says that this seemingly powerful kind of reduction , in which @xmath248 can make multiple calls to the cnot oracle , is actually no more powerful than the kind with only one oracle call .",
    "( in complexity language , what @xcite  showed is that @xmath250 : any problem in @xmath247  with @xmath1  oracle is also in @xmath1  itself . )",
    "it is conjectured that @xmath251 ; in other words , that an oracle for simulating cnot circuits would let an @xmath247 machine compute more functions than it could otherwise .  intuitively , this is because writing down the intermediate states of such a circuit requires more than a logarithmic number of read / write bits .",
    "indeed , @xmath1  contains some surprisingly hard  problems , such as inverting matrices over @xmath252  @xcite .",
    "on the other hand , it is also conjectured that @xmath253 , meaning that even with an oracle for simulating cnot circuits , an @xmath247  machine could not simulate more general circuits with and and or gates .  as usual in complexity theory ,",
    "neither conjecture has been proved .",
    "now define the gottesman - knill  problem as follows .",
    "we are given a stabilizer circuit @xmath254  as a sequence of gates of the form @xmath255",
    "@xmath256 , @xmath257  @xmath77 , @xmath258  @xmath77 , or @xmath259 @xmath77 , where @xmath260  are indices of qubits .",
    "the problem is to decide whether qubit @xmath5 will be @xmath80  with certainty after @xmath254  is applied to the initial state @xmath49 .",
    "( if not , then qubit @xmath5 will be @xmath261  with probability either @xmath262 or @xmath105 . )    since stabilizer circuits  are a generalization of cnot circuits , it is obvious that gottesman - knill  is @xmath1-hard  ( i.e. any @xmath1 problem can be reduced to it ) .",
    "our result says that gottesman - knill  is _ in _ @xmath1 .",
    "intuitively , this means that any stabilizer circuit can be simulated efficiently using cnot gates alone  the additional availability of hadamard and phase gates gives stabilizer circuits at most a polynomial advantage .  in our view ,",
    "this surprising fact helps to explain the gottesman - knill theorem , by providing strong evidence that stabilizer circuits are not even universal for _ classical _ computation ( assuming , of course , that classical postprocessing is forbidden ) .",
    "[ parityl]gottesman - knill is in @xmath1 .",
    "we will show how to solve gottesman - knill  using a logarithmic - space machine @xmath248 with an oracle for simulating cnot circuits .  by the result of hertrampf , reith , and",
    "vollmer @xcite described above , this will suffice to prove the theorem .    by the principle of deferred measurement",
    ", we can assume that the stabilizer circuit @xmath254 has only a single measurement gate at the end ( say of qubit @xmath5 ) , with all other measurements replaced by cnot s into ancilla qubits .",
    "in the tableau algorithm of section [ sim ] , let @xmath263 be the values of the variables @xmath264  after @xmath265 gates of @xmath254  have been applied .",
    "then  @xmath248 will simulate @xmath254 by computing these values .",
    "the first task of @xmath248 is to decide whether the measurement has a determinate outcome  or equivalently , whether @xmath266  for every @xmath267 , where @xmath268 is the number of unitary gates .",
    "observe that in the cnot , hadamard , and phase procedures , every update to an @xmath169  or @xmath170  variable replaces it by the sum modulo @xmath0 of one or two other @xmath169  or @xmath170  variables .",
    "also , iterating over all @xmath269 and @xmath87  takes only @xmath249  bits of memory .  therefore , despite its memory restriction , @xmath248  can easily write on its output tape a description of a cnot circuit that simulates the tableau algorithm using @xmath218 bits ( the @xmath270 s being omitted ) , and that returns @xmath271 for any desired @xmath114 .  then to decide whether the measurement outcome is determinate",
    ", @xmath248 simply iterates over all @xmath114 from @xmath92  to @xmath93 .",
    "the hard part is to decide whether @xmath79  or @xmath80  is measured in case the measurement outcome _ is _ determinate , for this problem involves the @xmath88  variables , which do not evolve in a linear way as the @xmath169 s and @xmath170 s do .",
    "even worse , it involves the complicated - looking and nonlinear @xmath173  procedure .",
    "fortunately , though , it turns out that the measurement outcome @xmath272 can be computed by keeping track of a single complex number @xmath273 .",
    "this @xmath273  is a product of phases of the form @xmath13 or @xmath14 , and therefore takes only @xmath0 bits to specify .",
    "furthermore , although the obvious  ways to compute @xmath273 use more than @xmath274  bits of memory , @xmath248 can get around that by making liberal use of the oracle .",
    "first @xmath248 computes what @xmath272  _ would _ be  if the cnot , hadamard , and phase procedures did not modify the @xmath88 s .",
    "let @xmath21 be a pauli matrix with a phase of @xmath13 or @xmath14 , which therefore takes @xmath117 bits to specify .",
    "also , let @xmath275  be the pauli matrix represented by the bits @xmath276 in the usual way : @xmath277 , @xmath278 , @xmath279 , @xmath280 .",
    "then the procedure is as follows .",
    "@xmath281    for @xmath282  to @xmath2    @xmath283    @xmath284for @xmath285  to @xmath93 @xmath286ask oracle for @xmath287    @xmath286if @xmath288 then @xmath289    @xmath284next @xmath114    @xmath284multiply @xmath273  by the phase of @xmath21 ( @xmath13 or @xmath14 )    next @xmath290    the answer  is @xmath5  if @xmath291  and @xmath105  if @xmath292 ( note that @xmath273 will never be @xmath14 at the end ) .  however , @xmath248 also needs to account for the @xmath88 s , as follows .    for @xmath285  to @xmath93    @xmath284ask oracle for @xmath293    @xmath284if",
    "@xmath288    @xmath286for @xmath294  to @xmath295    @xmath296if @xmath297  gate is a hadamard or phase on @xmath77    @xmath298ask oracle for @xmath299    @xmath298if @xmath300  then @xmath301    @xmath296end if    @xmath296if @xmath297  gate is a cnot from @xmath77 to @xmath147    @xmath298ask oracle for @xmath302    @xmath298if @xmath303  then @xmath301    @xmath296end if    @xmath286next @xmath265    @xmath284end if    next @xmath304    the measurement outcome , @xmath272 , is then @xmath5  if @xmath291  and @xmath105  if @xmath292 .",
    "as described above , the machine @xmath248 needs only @xmath249  bits to keep track of the loop indices @xmath305 , and @xmath306  additional bits to keep track of other variables .",
    "its correctness follows straightforwardly from the correctness of the tableau algorithm .    for a problem to be @xmath1-complete",
    "simply means that it is @xmath1-hard  _ and _  in @xmath1 .",
    "thus , a corollary of theorem [ parityl ]  is that gottesman - knill is @xmath1-complete .",
    "having studied the simulation of stabilizer circuits , in this section we turn our attention to _ manipulating _ those circuits .",
    "this task is of direct relevance to quantum computer architecture : because the effects of decoherence build up over time , it is imperative ( even more so than for classical circuits ) to minimize the number of gates as well as wires and other resources .  even if fault - tolerant techniques will eventually be used to tame decoherence",
    ", there remains the bootstrapping problem of building the fault - tolerance hardware !  in that regard we should point out that fault - tolerance hardware is likely to consist mainly of cnot , hadamard , and phase gates , since the known fault - tolerant constructions ( for example , that of aharonov and ben - or @xcite ) are based on stabilizer codes .",
    "although there has been some previous work on synthesizing cnot circuits @xcite  and general classical reversible circuits @xcite , to our knowledge there has not been work on synthesizing stabilizer circuits .  in this section",
    "we prove a _ canonical form theorem _ that is extremely useful for stabilizer circuit synthesis .",
    "the theorem says that given _ any _ circuit consisting of cnot , hadamard , and phase gates , there exists an equivalent circuit that applies a round of hadamard gates only , then a round of cnot gates only , and so on in the sequence h - c - p - c - p - c - h - p - c - p - c .",
    "one easy corollary of the theorem is that any tableau satisfying the commutativity conditions of proposition [ invariant ] can be generated by some stabilizer circuit .",
    "another corollary is that any unitary stabilizer circuit has an equivalent circuit with only @xmath3  gates .    given two @xmath2-qubit unitary stabilizer circuits @xmath307 , we say that @xmath308 and @xmath309  are _ equivalent _  if @xmath310  for all stabilizer states @xmath35 , where @xmath311  is the final state when @xmath312  is applied to @xmath35 .",
    "by linearity , it is easy to see that equivalent stabilizer circuits will behave identically on _ all _ states , not just stabilizer states .  furthermore , there exists a one - to - one correspondence between circuits and tableaus :    [ equiv]let @xmath313  be unitary stabilizer circuits , and let @xmath314  be their respective final tableaus when we run them on the standard initial tableau .  then @xmath308  and @xmath309  are equivalent if and only if @xmath315 .",
    "clearly @xmath315  if @xmath308  and @xmath309  are equivalent .  for the other direction",
    ", it suffices to observe that a unitary stabilizer circuit acts linearly on pauli operators ( that is , rows of the tableau ) : if it maps @xmath316  to @xmath317  and @xmath318  to @xmath319 ,  then it maps @xmath320  to @xmath321 .  since the rows of the standard initial tableau form a basis for @xmath12 , the lemma follows .",
    "our proof of the canonical form theorem will use the following two lemmas .",
    "[ nonzero]given an @xmath2-qubit stabilizer state , it is always possible to apply hadamard gates to a subset of the qubits so as to make the @xmath99 matrix have full rank ( or equivalently , make all @xmath44  basis states have nonzero amplitude )",
    ".    we can always perform row additions on the @xmath322  stabilizer matrix without changing the state that it represents .",
    "suppose the @xmath99 matrix has rank @xmath323 ; then by gaussian elimination , we can put the stabilizer matrix in the form@xmath90{l|l}% $ \\,\\,\\,\\,\\,\\,\\,a\\,\\,\\,\\,\\,\\,\\,$ & $ \\,\\,\\,\\,\\,\\,\\,b\\,\\,\\,\\,\\,\\,\\,$\\\\ $ \\,\\,\\,\\,\\,\\,\\,0\\,\\,\\,\\,\\,\\,\\,$ & $ \\,\\,\\,\\,\\,\\,\\,c\\,\\,\\,\\,\\,\\,\\,$% \\end{tabular } \\right)\\ ] ] where @xmath54 is @xmath324  and has rank @xmath325 .",
    "then since the rows are linearly independent , @xmath326 must have rank @xmath327 ; therefore it has an @xmath328  submatrix @xmath329  of full rank .",
    "let us permute the columns of the @xmath99 and @xmath103 matrices simultaneously to obtain@xmath90{cc|cc}% $ a_{1}$ & $ a_{2}$ & $ b_{1}$ & $ b_{2}$\\\\ $ 0 $ & $ 0 $ & $ c_{1}$ & $ c_{2}$% \\end{tabular } \\right )   , \\ ] ] and then perform gaussian elimination on the bottom @xmath327  rows to obtain@xmath90{cc|cc}% $ a_{1}$ & $ a_{2}$ & $ b_{1}$ & $ b_{2}$\\\\ $ 0 $ & $ 0 $ & $ d$ & $ i$% \\end{tabular } \\right )   .\\ ] ] now commutativity relations imply@xmath330{cc}% a_{1 } & a_{2}% \\end{array } \\right )   \\left ( \\begin{array } [ c]{c}% d^{t}\\\\ i \\end{array } \\right )   = 0\\ ] ] and therefore @xmath331 .",
    "notice that this implies that the @xmath332  matrix @xmath333  has full rank , since otherwise the @xmath99 matrix would have column rank less than @xmath325 .",
    "so performing hadamards on the rightmost @xmath327  qubits yields a state@xmath90{cc|cc}% $ a_{1}$ & $ b_{2}$ & $ b_{1}$ & $ a_{2}$\\\\ $ 0 $ & $ i$ & $ d$ & $ 0$% \\end{tabular } \\right)\\ ] ] whose @xmath99 matrix has full rank .",
    "[ gaussian]for any symmetric matrix @xmath334 , there exists a diagonal matrix @xmath335  such that @xmath336 , with @xmath248 some invertible binary matrix",
    ".    we will let @xmath248 be a lower - triangular matrix with @xmath5s all along the diagonal : @xmath337 such an @xmath248 is always invertible .",
    "then there exists a diagonal @xmath335 such that @xmath336 if and only if @xmath338 for all pairs @xmath339 with @xmath340 .",
    "( we pick @xmath335 appropriately to satisfy the equations for @xmath341 automatically , and both sides of the equation are symmetric , covering the cases with @xmath342 . )    we will perform induction on @xmath114 and @xmath343 to solve for the undetermined elements of @xmath248 . for the base case , we know that @xmath344 .",
    "we will determine @xmath345 for @xmath340 by supposing we have already determined @xmath346 for either @xmath347 , @xmath348 or @xmath349 , @xmath350 .",
    "we consider equation  ( [ meqs ] ) for @xmath351 and note that @xmath352 unless @xmath353 .",
    "then @xmath354 by the induction hypothesis , we have already determined in the sum both @xmath355 ( since @xmath356 ) and @xmath357 ( since @xmath358 and @xmath356 ) , so this equation uniquely determines @xmath345 . we can thus find a unique @xmath248 that satisfies ( [ meqs ] ) for all @xmath340 .",
    "say a unitary stabilizer circuit is in _ canonical form _ if it consists of @xmath100 rounds in the sequence h - c - p - c - p - c - h - p - c - p - c .",
    "[ canonical]any unitary stabilizer circuit has an equivalent circuit in canonical form .",
    "divide a @xmath359  tableau into four @xmath81  matrices @xmath360 , @xmath361 , @xmath362 , and @xmath363 , containing the destabilizer @xmath169 bits , destabilizer @xmath170  bits , stabilizer @xmath169  bits , and stabilizer @xmath170  bits  respectively:@xmath90{l|l}% $ a$ & $ b$\\\\\\hline $ c$ & $ d$% \\end{tabular } \\right)\\ ] ] ( we can ignore the phase bits @xmath88 . )  since unitary circuits are reversible , by lemma [ equiv ] it suffices to show how to obtain the standard initial tableau starting from an arbitrary @xmath364 by applying cnot , hadamard , and phase gates .",
    "we _ can not _ use row additions , since although they leave states invariant they do not in general leave circuits invariant .",
    "the procedure is as follows .    * ( 1 ) * use hadamards to make @xmath326 have full rank ( this is possible by lemma [ nonzero ] ) .",
    "* ( 2 ) * use cnot s to perform gaussian elimination on @xmath326 , producing@xmath90{l|l}% $ a$ & $ b$\\\\\\hline $ i$ & $ d$% \\end{tabular } \\right )   .\\ ] ]    * ( 3 ) * commutativity of the stabilizer implies that @xmath365  is symmetric , therefore @xmath366 is symmetric , and we can apply phase gates to add a diagonal matrix to @xmath366 and use lemma  [ gaussian ] to convert @xmath366 to the form @xmath367  for some invertible @xmath248 .    *",
    "( 4 ) * use cnot s to produce@xmath90{l|l}% $ a$ & $ b$\\\\\\hline $ m$ & $ m$% \\end{tabular } \\right )   .\\ ] ] note that when we map @xmath33  to @xmath368 , we also map @xmath366  to @xmath369 .    * ( 5 ) * apply phases to all @xmath2 qubits to obtain@xmath90{l|l}% $ a$ & $ b$\\\\\\hline $ m$ & $ 0$% \\end{tabular } \\right )   .\\ ] ] since @xmath248 is full rank , there exists some subset @xmath55  of qubits such that applying two phases in succession to every @xmath370 will preserve the above tableau , but set @xmath371 .",
    "apply two phases to every @xmath372 .    *",
    "( 6 ) * use cnot s to perform gaussian elimination on @xmath248 , producing@xmath90{l|l}% $ a$ & $ b$\\\\\\hline $ i$ & $ 0$% \\end{tabular } \\right )   .\\ ] ] by commutativity relations , @xmath373 , therefore @xmath374 .    *",
    "( 7 ) * use hadamards to produce@xmath90{l|l}% $ i$ & $ a$\\\\\\hline $ 0 $ & $ i$% \\end{tabular } \\right )   .\\ ] ]    * ( 8) * now commutativity of the destabilizer implies that @xmath54 is symmetric , therefore we can again use phase gates and lemma  [ gaussian ] to make @xmath375  for some invertible @xmath50 .    *",
    "( 9 ) * use cnot s to produce@xmath90{l|l}% $ n$ & $ n$\\\\\\hline $ 0 $ & $ c$% \\end{tabular } \\right )   .\\ ] ]    * ( 10 ) * use phases to produce@xmath90{l|l}% $ n$ & $ 0$\\\\\\hline $ 0 $ & $ c$% \\end{tabular } \\right )   ; \\ ] ] then by commutativity relations , @xmath376 .",
    "next apply two phases each to some subset of qubits in order to preserve the above tableau , but set @xmath377 .    *",
    "( 11 ) * use cnot s to produce@xmath90{l|l}% $ i$ & $ 0$\\\\\\hline $ 0 $ & $ i$% \\end{tabular } \\right )   .\\ ] ]    since theorem [ canonical ]  relied only on a tableau satisfying the commutativity conditions , not on its being generated by some stabilizer circuit , an immediate corollary is that any tableau satisfying the conditions _ is _ generated by some stabilizer circuit .",
    "we can also use theorem [ canonical ] to answer the following question : how many gates are needed for an @xmath2-qubit stabilizer circuit in the worst case ?  cleve and gottesman @xcite showed that @xmath6  gates suffice for the special case of state preparation , and gottesman @xcite and dehaene and de moor @xcite  showed that @xmath6  gates suffice for stabilizer circuits more generally ; even these results were not obvious _ a priori_.  however , with the help of our canonical form theorem we can show a stronger upper bound .",
    "[ overlog]any unitary stabilizer circuit has an equivalent circuit with only @xmath3  gates .",
    "patel , markov , and hayes @xcite  showed that any cnot circuit has an equivalent cnot circuit with only @xmath3  gates .",
    "so given a stabilizer circuit @xmath254 , first put @xmath254 into canonical form , then minimize the cnot segments .",
    "clearly the hadamard and phase segments require only @xmath76  gates each .",
    "corollary [ overlog ]  is easily seen to be optimal by a shannon counting argument : there are @xmath378  distinct stabilizer circuits on @xmath2 qubits , but at most @xmath379 with @xmath268 gates .    a final remark : as noted by moore and nilsson @xcite , any cnot circuit has an equivalent cnot circuit with @xmath6 gates and parallel depth @xmath249 .  thus , using the same idea as in corollary [ overlog ] , we obtain that any unitary stabilizer circuit has an equivalent stabilizer circuit with @xmath6  gates and parallel depth @xmath249 .",
    "( moore and nilsson showed this for the special case of stabilizer circuits composed of cnot and hadamard gates only . )",
    "in this section , we discuss generalizations of stabilizer circuits that are still efficiently simulable .",
    "the first ( easy ) generalization , in section [ mixed ] , is to allow the quantum computer to be in a mixed rather than a pure state .",
    "mixed states could be simulated by simply purifying the state , and then simulating the purification , but we present an alternative and slightly more efficient strategy .",
    "the second generalization , in section [ initial ] , is to initial states other than the computational basis state .  taken to an extreme , one could even have noncomputable initial states .  when combined with arbitrary quantum circuits ,",
    "such quantum advice is very powerful , although its exact power ( relative to classical advice ) is unknown @xcite .",
    "we consider a more modest situation , in which the initial state may include specific ancilla states , consisting of at most @xmath147 qubits each .",
    "the initial state is therefore a tensor product of blocks of @xmath147 qubits .",
    "given an initial state of this form and general stabilizer circuits , including measurements and classical feedback based on measurement outcomes , universal quantum computation is again possible @xcite .",
    "however , we show that an efficient classical simulation exists , _ provided _ only a few measurements are allowed .",
    "the final generalization , in section [ gates ] , is to circuits containing a few non - stabilizer gates .",
    "the qualifier few  is essential here , since it is known that unitary stabilizer circuits plus any additional gate yields a universal set of quantum gates @xcite .",
    "the running time of our simulation procedure is polynomial in @xmath2 , the number of qubits , but is exponential in the @xmath380 , the number of non - stabilizer gates .",
    "we first present the simulation for mixed states .",
    "we allow only _ stabilizer mixed states_that is , states that are uniform distributions over all states in a subspace ( or equivalently , all stabilizer states in the subspace ) with a given stabilizer of @xmath381 generators .",
    "such mixed states can always be written as the partial trace of a pure stabilizer state , which immediately provides one way of simulating them .",
    "it will be useful to see how to write the density matrix of the mixed state in terms of the stabilizer .  the operator @xmath382 , when @xmath248 is a pauli operator , is a projection onto the @xmath383 eigenspace of @xmath248 .",
    "therefore , if the stabilizer of a pure state has generators @xmath384 , then the density matrix for that state is @xmath385 the density matrix for a stabilizer mixed state with stabilizer generated by @xmath386 is @xmath387    to perform our simulation , we find a collection of @xmath388 operators @xmath389 and @xmath390 that commute with both the stabilizer and the destabilizer .",
    "we can choose them so that @xmath391   = \\left [   \\overline{z}_{i}% , \\overline{z}_{j}\\right ]   = \\left [   \\overline{x}_{i},\\overline{z}_{j}\\right ] = 0 $ ] for @xmath392 , but @xmath393 .  this can be done by solving a set of linear equations , which in practice takes time @xmath7 .",
    "if we start with an initial mixed state , we will assume it is of the form @xmath394 ( so @xmath105 on the first @xmath395 qubits and the completely mixed state on the last @xmath396 qubits ) .  in that case",
    ", we choose @xmath397 and @xmath398 .",
    "we could purify this state by adding @xmath399 and @xmath400 to the stabilizer and @xmath401 and @xmath402 to the destabilizer for @xmath403 .",
    "then we could simulate the system by just simulating the evolution of this pure state through the circuit ; the extra @xmath396 qubits are never altered .",
    "a more economical simulation is possible , however , by just keeping track of the original @xmath396-generator stabilizer and destabilizer , plus the @xmath404 operators @xmath389 and @xmath390 .",
    "formally , this allows us to maintain a complete tableau and generalize the @xmath405 tableau algorithm from section  [ sim ] .",
    "we place the @xmath396 generators of the stabilizer as rows @xmath406 of the tableau , and the corresponding elements of the destabilizer as rows @xmath407 .",
    "the new operators @xmath389 and @xmath390 ( @xmath408 ) become rows @xmath409 and @xmath410 , respectively",
    ".  let @xmath411 if @xmath412 and @xmath413 if @xmath171 .",
    "then we have that rows @xmath104 and @xmath414 commute unless @xmath415 , in which case @xmath104 and @xmath414 anticommute .",
    "we can keep track of this new kind of tableau in much the same way as the old kind .",
    "unitary operations transform the new rows the same way as rows of the stabilizer or destabilizer .",
    "for example , to perform a cnot from control qubit @xmath77 to target qubit @xmath147 , set @xmath416 and @xmath150 , for all @xmath87 .",
    "measurement of qubit @xmath77 is slightly more complex than before .",
    "there are now three cases :    * case i : * @xmath156 for some @xmath417 .  in this case",
    "@xmath184 anticommutes with an element of the stabilizer , and the measurement outcome is random .",
    "we update as before , for all rows of the tableau .",
    "* case ii : * @xmath418for all @xmath419 .  in this case@xmath420",
    "is in the stabilizer .  the measurement outcome is determinate , and we can predict the result as before , by calling @xmath173 to add up rows @xmath421 for those @xmath114 with @xmath160 .    *",
    "case iii : * @xmath418for all @xmath417 , but @xmath422for some @xmath423 or @xmath424 . * * in this case @xmath184 commutes with all elements of the stabilizer but is not itself in the stabilizer .",
    "we get a random measurement result , but a slightly different transformation of the stabilizer than in case i.  observe that row @xmath425 anticommutes with @xmath184 .",
    "this row takes the role of row @xmath157 from case i , and the row @xmath426 takes the role of row @xmath427 .",
    "update as before with this modification .",
    "then swap rows @xmath428 and @xmath429 and rows @xmath430 and @xmath431 .  finally , increase @xmath396 to @xmath430 : the stabilizer has gained a new generator .",
    "another operation that we might want to apply is discarding the qubit @xmath77 , which has the effect of performing a partial trace over that qubit in the density matrix .",
    "again , this can be done by simply keeping the qubit in our simulation and not using it in future operations .",
    "here is an alternative : put the stabilizer in a form such that there is at most one generator with an @xmath99 on qubit @xmath77 , and at most one with a @xmath103 on qubit @xmath77 . then drop those two generators ( or one , if there is only one total ) .",
    "the remaining generators describe the stabilizer of the reduced mixed state .",
    "we also must put the @xmath389 and @xmath390 operators in a form where they have no entries in the discarded location , while preserving the structure of the tableau ( namely , the commutation relations of proposition  [ invariant ] ) .",
    "this can also be done in time @xmath432 , but we omit the details , as they are rather involved .",
    "we now show how to simulate a stabilizer circuit where the initial state is more general , involving non - stabilizer initial states .",
    "we allow any number of ancillas in arbitrary states , but the overall ancilla state must be a tensor product of blocks of at most @xmath147 qubits each .",
    "an arbitrary stabilizer circuit is then applied to this state .",
    "we allow measurements , but only @xmath380 of them in total throughout the computation .",
    "we do allow classical operations conditioned on the outcomes of measurements , so we also allow polynomial - time classical computation during the circuit .",
    "let the initial state have density matrix @xmath433 : a tensor product of @xmath429 blocks of at most @xmath147 qubits each .  without loss of generality , we first apply the unitary stabilizer circuit @xmath434 , followed by the measurement @xmath435 ( that is , a measurement of the first qubit in the standard basis ) .",
    "we then apply the stabilizer circuit @xmath436 , followed by measurement @xmath437 on the second qubit , and so on up to @xmath438 .",
    "we can calculate the probability @xmath439 of obtaining outcome @xmath105 for the first measurement @xmath435 as follows : @xmath440   /2\\\\ &   = \\operatorname*{tr}\\left [   \\left (   i+u_{1}^{\\dagger}z_{1}u_{1}\\right ) \\rho\\right ]   /2\\\\ &   = 1/2+\\operatorname*{tr}\\left [   \\left (   u_{1}^{\\dagger}z_{1}u_{1}\\right ) \\rho\\right ]   /2.\\end{aligned}\\ ] ] but @xmath434 is a stabilizer operation , so @xmath441 is a pauli matrix , and is therefore a tensor product operation .",
    "we also know @xmath433 is a tensor product of blocks of at most @xmath147 qubits , and the trace of a tensor product is the product of the traces .",
    "let @xmath442 and @xmath443 where @xmath343 ranges over the blocks .  then",
    "@xmath444 since @xmath24 and @xmath445 are both @xmath446-dimensional matrices , each @xmath447 can be computed in time @xmath448 .    by flipping an appropriately biased coin",
    ", alice can generate an outcome of the first measurement according to the correct probabilities .",
    "conditioned on this outcome ( say of @xmath105 ) , the state of the system is @xmath449 after the next stabilizer circuit @xmath436 , the state is @xmath450 the probability of obtaining outcome @xmath105 for the second measurement , conditioned on the outcome of the first measurement being @xmath105 , is then @xmath451   } { 8p\\left (   0\\right )   } .\\ ] ] by expanding out the @xmath219 terms , and then commuting @xmath434 and @xmath436 past @xmath435  and @xmath437 , we can write this as@xmath452 each @xmath453 term can again be computed in time @xmath448 .",
    "similarly , the probability of any particular sequence of measurement outcomes @xmath454 can be written as a sum @xmath455 where each trace can be computed in time @xmath448 .",
    "it follows that the probabilities of the two outcomes of the @xmath456  measurement can be computed in time @xmath457 .",
    "the last case that we consider is that of a circuit containing @xmath380 non - stabilizer gates , each of which acts on at most @xmath147 qubits .",
    "we allow an unlimited number of pauli measurements and unitary stabilizer gates , but the initial state is required to be a stabilizer state  for concreteness , @xmath458 .",
    "to analyze this case , we examine the density matrix @xmath459 at the @xmath460 step of the computation .",
    "initially , @xmath461 is a stabilizer state whose stabilizer is generated by some @xmath462 , so we can write it as @xmath463 if we perform a stabilizer operation , the @xmath464 s become a different set of pauli operators , but keeping track of them requires at most @xmath465 bits at any given time ( or @xmath466 if we include the destabilizer ) .  if we perform a measurement , the @xmath464 s change in a more complicated way , but remain pauli group elements .",
    "now consider a single non - stabilizer gate @xmath30 .",
    "expanding @xmath30 in terms of pauli operations @xmath467,@xmath468 here @xmath469 is the symplectic inner product between the corresponding vectors , which is @xmath105 whenever @xmath470 and @xmath471 commute and @xmath5 when they anticommute .  in what follows ,",
    "let @xmath472  and @xmath473 .",
    "then we can write the density matrix after @xmath30 as a sum of terms , each described by a pauli matrix @xmath474 and a vector of eigenvalues for the stabilizer .",
    "since @xmath30 and @xmath475 each act on at most @xmath147 qubits , there are at most @xmath476 terms in this sum .",
    "if we apply a stabilizer gate to this state , all of the pauli matrices in the decomposition are transformed to other pauli matrices , according to the usual rules .",
    "if we perform another non - stabilizer gate , we can again expand it in terms of pauli matrices , and put it in the same form .",
    "the new gate can act on @xmath147 new qubits , however , giving us more terms in the sum .",
    "after @xmath380 such operations , we thus need to keep track of at most @xmath477 complex numbers ( the coefficients @xmath478 ) , @xmath479 strings each of @xmath93  bits ( the pauli matrices @xmath474 ) , and @xmath479 strings each of @xmath2 bits  ( the inner products @xmath469 ) .",
    "we also need to keep track of the stabilizer generators @xmath462 , and it will be helpful to also keep track of the destabilizer , for a total of an additional @xmath466 bits .",
    "the above allows us to describe the evolution when there are no measurements .",
    "what happens when we perform a measurement ?",
    "consider the unnormalized density matrix corresponding to outcome @xmath105 for measurement of the pauli operator @xmath22 : @xmath480 where here and throughout we let @xmath481 and @xmath482 .  as usual",
    ", either @xmath22 commutes with everything in the stabilizer , or @xmath22 anticommutes with some element of the stabilizer .",
    "( however , the measurement outcome can be indeterminate in both cases , and may have a non - uniform distribution . )  in the first case , we can rewrite the density matrix as @xmath483 but @xmath484 if @xmath474 and @xmath22 commute , and @xmath485 if @xmath474 and @xmath22 anticommute .  furthermore , as usual , as @xmath22 commutes with everything in the stabilizer , @xmath22 is actually in the stabilizer , so projecting on @xmath486 either is redundant ( if @xmath22 has eigenvalue @xmath383 ) or annihilates the state ( if @xmath22 has eigenvalue @xmath118 ) .",
    "therefore , we can see that @xmath487 has the same form as before : @xmath488 where now the sum over @xmath114 is only over those @xmath474 s that commute with @xmath22 , and the sum over @xmath325 is only over those @xmath471 s that give eigenvalue @xmath383 for @xmath22 .",
    "when @xmath22 anticommutes with an element of the stabilizer , we can change our choice of generators so that @xmath22 commutes with all of the generators except for @xmath57 .",
    "then we write @xmath487 as : @xmath489   \\lambda_{k}%\\end{aligned}\\ ] ] where@xmath490 if @xmath474 and @xmath22 commute , then we keep only the first term @xmath486 in the square brackets .",
    "if @xmath474 and @xmath22 anticommute , we keep only the second term @xmath491 in the square brackets .  in either case , we can rewrite the density matrix in the same kind of decomposition : @xmath492 where @xmath22 has replaced @xmath57 in the stabilizer , and any @xmath474 that anticommutes with @xmath22 has been replaced by @xmath493 , its corresponding @xmath478 replaced by @xmath494 .    therefore , we can always write the density matrix after the measurement in the same kind of sum decomposition as before , with no more terms than there were before the measurement .",
    "the density matrices are unnormalized , so we need to calculate @xmath495 to determine the probability of obtaining outcome @xmath105 .",
    "computing the trace of a single term is straightforward : it is @xmath105 if @xmath474 is not in the stabilizer and @xmath496 if @xmath474 is in the stabilizer ( with @xmath18 or @xmath497 determined by the eigenvalue of @xmath474 ) .  to calculate @xmath498",
    ", we just need to sum the traces of the @xmath477 individual terms .",
    "we then choose a random number to determine the actual outcome .",
    "thereafter , we only need to keep track of @xmath487 or @xmath499 , which we can easily renormalize to have unit trace .",
    "overall , this simulation therefore takes time and space @xmath500 .",
    "* ( 1 ) * iwama , kambayashi , and yamashita @xcite  gave a set of _ local transformation rules _ by which any cnot circuit ( that is , a circuit consisting solely of cnot gates ) can be transformed into any equivalent cnot circuit .",
    "for example , a cnot from @xmath77 to @xmath147 followed by another cnot from @xmath77 to @xmath147 can be replaced by the identity , and a cnot from @xmath77 to @xmath147 followed by a cnot from @xmath501 to @xmath380 can be replaced by a cnot from @xmath501 to @xmath380 followed by a cnot from @xmath77 to @xmath147 , provided that @xmath502  and @xmath503 .  using theorem [ canonical ]",
    ", can we similarly give a set of local transformation rules by which any unitary stabilizer circuit can be transformed into any equivalent unitary stabilizer circuit ?",
    "such a rule set could form the basis of an efficient heuristic algorithm for minimizing stabilizer circuits .    *",
    "( 2 ) * can the tableau algorithm be modified to compute measurement outcomes in only @xmath76  time ?",
    "( in case the measurement yields a random outcome , updating the state might still take order @xmath236  time . )    * ( 3 ) * in theorem [ canonical ] , is the @xmath100-round sequence h - c - p - c - p - c - h - p - c - p - c really necessary , or is there a canonical form that uses fewer rounds ?  note that if we are only concerned with state preparation , and not with how a circuit behaves on any initial state other than the standard one , then the @xmath504-round sequence h - p - c - p - h is sufficient .    *",
    "( 4 ) * is there a set of quantum gates that is neither universal for quantum computation , _ nor _ classically simulable in polynomial time ?",
    "shi @xcite  has shown that if we generalize stabilizer circuits by adding _ any _ @xmath5- or @xmath0-qubit gate not generated by cnot , hadamard , and phase , then we immediately obtain a universal set .    * ( 5 ) * what is the computational power of stabilizer circuits with arbitrary tensor product initial states , but measurements delayed until the end of the computation ?",
    "it is known that , if we allow classical postprocessing and control of future quantum operations conditioned on measurement results , then universal quantum computation is possible @xcite .  however , if all measurements are delayed until the end of the computation , then  the quantum part of such a circuit ( though not the classical postprocessing ) can be compressed to constant depth .",
    "on the other hand , terhal and divincenzo @xcite have given evidence that even constant - depth quantum circuits might be difficult to simulate classically .",
    "* ( 6 ) * is there an efficient algorithm that , given a cnot or stabilizer circuit , produces an equivalent circuit of ( approximately ) minimum size ?  would the existence of such an algorithm have unlikely complexity consequences ?  this might be related to the hard problem of proving superlinear lower bounds on cnot or stabilizer circuit size for explicit functions .",
    "we thank john kubiatowicz , michael nielsen , isaac chuang , cris moore , and george viamontes for helpful discussions , andrew cross for fixing an error in the manuscript and software , and martin laforest for pointing out an error in the proof of theorem  [ canonical ] .",
    "sa was supported by an nsf graduate fellowship and by darpa .",
    "dg is supported by funds from nserc of canada ,  and by the ciar in the quantum information processing program ."
  ],
  "abstract_text": [
    "<S> the gottesman - knill theorem says that a stabilizer circuit  that is , a quantum circuit consisting solely of cnot , hadamard , and phase gates  can be simulated efficiently on a classical computer .  </S>",
    "<S> this paper improves that theorem in several directions .  </S>",
    "<S> first , by removing the need for gaussian elimination , we make the simulation algorithm much faster at the cost of a factor-@xmath0 increase in the number of bits needed to represent a state . </S>",
    "<S> we have implemented the improved algorithm in a freely - available program called chp ( cnot - hadamard - phase ) , which can handle thousands of qubits easily .  </S>",
    "<S> second , we show that the problem of simulating stabilizer circuits is complete for the classical complexity class @xmath1 , which means that stabilizer circuits are probably not even universal for _ classical _ computation .  </S>",
    "<S> third , we give efficient algorithms for computing the inner product between two stabilizer states , putting any @xmath2-qubit stabilizer circuit into a canonical form  that requires at most @xmath3 gates , and other useful tasks .  </S>",
    "<S> fourth , we extend our simulation algorithm to circuits acting on mixed states , circuits containing a limited number of non - stabilizer gates , and circuits acting on general tensor - product initial states but containing only a limited number of measurements . </S>"
  ]
}