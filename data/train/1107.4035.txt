{
  "article_text": [
    "the problem of lifted probabilistic inference in its general form was first explicitly proposed by @xcite , who formulated the problem in terms of parametrized random variables , introduced the use of splitting to complement unification , the parfactor representation of intermediate results , and an algorithm for multiplying factors in a lifted manner .",
    "de salvo braz et al .",
    "[ @xcite ] invented counting elimination for some cases where grounding would create a factor with size exponential in the number of individuals , but lifted inference can be done by counting the number of individuals with each assignment of values .",
    "@xcite proposed counting formulae as a representation of the intermediate result of counting , which allowed for more cases where counting was applicable .",
    "however , this body of research has not fulfilled the promise of lifted inference , as the algorithms still need to ground in some cases .",
    "the main problem is that the proposals are based on variable elimination @xcite .",
    "this is a dynamic programming approach which requires a representation of the intermediate results , and the current representations for such results are not closed under all of the operations used for inference .",
    "we sought to investigate whether there were fundamental reasons why we need to ground in some cases .",
    "an alternative to variable elimination is to used search - based methods based on conditioning such as recursive conditioning @xcite and other methods ( see e.g. , * ? ? ?",
    "the advantage of these methods is that conditioning simplifies the representations , rather than complicating them .",
    "the use of lifted search - based inference was proposed by @xcite , however to be both correct and able to do inference without grounding requires more attention to detail than given in that paper .",
    "this paper answer different questions than @xcite .    note that this paper is about exact inference .",
    "lifted algorithms based on belief propagation ( e.g. by @xcite and @xcite ) explicitly ignore the interdependence amongst the instances that exact inference needs to take into account .    in deriving an algorithm that never needs to ground ,",
    "it is often the examples that demonstrate why simpler methods do not work that are most insightful .",
    "we have thus chosen to write this paper by presenting examples that exemplify the cases that need to be considered .",
    "the problem of lifted inference arises in relational probabilistic models where there are probability distributions over random variables that represent relations which depend on individuals .",
    "@xcite gives an example where the probability that a person fitting a description committed a crime depends on the population size , as this determines how many other people fit the description .",
    "we do nt want to reason about the other individuals separately .",
    "rather , we would like to reason about them as a block considering only the number of such individuals .",
    "a * population * is a set of * individuals*. a population corresponds to a domain in logic .",
    "the * population size * is the cardinality of the population which can be a finite number . for any @xmath0 .",
    "so the infinite case allows for more pruning . ] for the examples below , where there is a single population , we write the population as @xmath1 , where @xmath2 is the population size .    a * parameter * , which corresponds to a logical variable , is written in lower case .",
    "parameters are typed with a population ; if @xmath3 is a parameter of type @xmath4 , @xmath5 is the population associated with @xmath3 and @xmath6 .",
    "we assume that the populations are disjoint ( and so the types are mutually exclusive ) .",
    "constants are written starting with an upper case letter .",
    "a * parametrized random variable ( prv ) * is of the form @xmath7 where @xmath8 is a k - ary functor ( a function symbol or a predicate ) and each @xmath9 is a parameter or a constant .",
    "each functor has a range , which is @xmath10 for predicate symbols .",
    "a parametrized random variable represents a set of random variables , one for each assignment of an individual to a parameter .",
    "the range of the functor becomes the domain of the random variables .",
    "a * substitution * is of the form @xmath11 where @xmath12 are distinct parameters and @xmath9 are constants or parameters , such that @xmath12 and @xmath9 are of the same type . given a prv @xmath13 and a substitution @xmath14 , the application of @xmath15 on @xmath13 , written @xmath16 is the prv with each @xmath12 replaced by @xmath9 .",
    "a substitution @xmath17 * grounds * parameters @xmath18 if @xmath19 are constants .",
    "a * grounding substitution * of @xmath13 is a substitution that grounds all of the parameters of @xmath13 .",
    "probabilistic inference relies on knowing whether two random variables are the same . with parametrized random variables ,",
    "we unify them to make them identical , but instead of just applying a substitution ( as in regular theorem proving ) , @xcite proposed to split parametrized random variables , forming the unifier and residual prvs .    applying substitution @xmath20 to prv @xmath21 results in prv that is the direct application , @xmath22 , and two `` residual '' prvs , @xmath21 with the constraint @xmath23 and @xmath24 with the constraint @xmath25",
    "; these three parametrized random variables , with their associated constraints , represent the same set of random variables as @xmath21 .",
    "a parametrized graphical model ( bayesian network or markov network ) is a network with parametrized random variables as nodes , and the instances of these share potentials .",
    "we need to be explicit about which instances share potentials .    the parametrized graphical model of figure [ examplerq ] ( a ) ,",
    "is shown using parametrized random variables and plates ( where the parameters correspond to plates ) .",
    "the plate representation represents @xmath2 instances of @xmath26 and @xmath27 instances of @xmath28 in the grounding , shown in figure [ examplerq ] ( b ) .",
    "we assume the input to our algorithm is in the form of parfactors",
    ". a * parametric factor * or * parfactor * @xcite is a triple @xmath29 where @xmath30 is a set of inequality constraints on parameters , @xmath31 is a set of parametrized random variables and @xmath32 is a factor , which is a function from assignments of values to @xmath31 to the non - negative reals .",
    "@xmath32 is used as the potential for all instances of the parfactor that are consistent with the constraints . ''",
    "is used between a ( parametrized ) random variable and its value , whereas `` @xmath33 '' and `` @xmath34 '' are used for parameters ( logical variables ) . ]",
    "@xcite also explicitly include a set of parameters in their parfactors , but we do not .",
    "a parfactor means its grounding ; the set of factors on @xmath35 ( all with table @xmath32 ) for each grounding substitution @xmath15 of @xmath31 that obeys the constraints in @xmath30",
    ".      lifted variable elimination , such as in c - fove @xcite , allows for inference to work at the lifted level ( doing unification and splitting at runtime or as a preprocessing step ) like normal variable elimination , until we remove a prv that contains the only instance of a free parameter or is linked to a prv with a different set of parameters . at this stage , we need to take into account that the prv represents a set of random variables .",
    "suppose we have a factor on @xmath36 , @xmath28 and @xmath26 , as in figure [ examplerq ] ( a ) .",
    "we can sum out all instances of @xmath36 , as all of the factors are the same , and get a new factor on @xmath28 ; this does @xmath27 ( identical ) operations on the grounding in a single step .",
    "if we then remove @xmath37 , we are multiplying a set of identical factors , and so can take their value to the power of the population size @xcite .",
    "suppose , instead , we were to first sum out @xmath26 . in the grounding , for each individual @xmath38 , the random variables @xmath39 are interdependent and so eliminating @xmath40 results in a factor on @xmath39 .",
    "the size of this factor is exponential in @xmath2 .    realized that the identity of the individuals is not important ; only the number of individuals having each value of @xmath37 .",
    "they introduced counting to solve cases such as removing @xmath26 first in polynomial time rather than the exponential time ( and space ) used for the ground case .",
    "they , however , do the counting and summing in one step , which limits its applicability .",
    "@xcite defined counting formulae that give a representation for the resulting lifted formula and can then be combined with other factors .",
    "this expanded the applicability of lifted inference , but it still requires grounding in some cases .      an alternative to lifting variable elimination is to lift a search - based method .    (",
    "\\{_case 0_})@xmath41 ( \\{_case 1_})@xmath42 such that @xmath43 ( \\{_case 2_})@xmath44 @xmath45 ( \\{_case 3_})factor graph @xmath46 is disconnected @xmath47 ( \\{_case 4 _ } ) select variable @xmath48 @xmath49 @xmath50    the classic search - based algorithm is recursive conditioning @xcite , a version of which is presented in algorithm [ rc - algo ] .",
    "this algorithm is presented in this non - traditional way , to emphasize the cases that need to be implemented for lifting .",
    "in particular , decoupling branching and the evaluation of factors is useful for developing its lifted counterpart .",
    "the correctness does not depend on the order of the cases ( although efficiency does ) . in this algorithm",
    "@xmath51 is a context , a set of @xmath52 assignments , and @xmath53 is a set of input factors ( this algorithm never creates or modifies factors ; it only evaluate them when all of their variables are assigned ) .",
    "we separate the context from the factors ; typically these are combined to give what could be called partially - assigned factors .. it also makes it conceptually clearer that the factors share the same context . ]    in case 0 , if there are variables that appear in @xmath51 that do not appear in @xmath53 , these are removed from @xmath51 .",
    "this is called `` forgetting '' in the description below ; we forget the context that is not relevant for the rest of the factors .",
    "@xmath54 is the set of variables that appear in @xmath55 .    in case 1",
    ", the cache contains a set of previously computed values .",
    "if a value has already been computed it can be recalled .",
    "initially the cache is @xmath56 .    for case 2 ,",
    "if all of the variables that appear in a factor @xmath57 are assigned in @xmath51 , @xmath58 returns the number that is the value of @xmath8 for the assignment @xmath51 .",
    "these numbers are multiplied .    for case 3 ,",
    "a * * factor graph * * on @xmath46 is a graph where the nodes are factors in @xmath53 , and there is an arc between factors that share a random variable that is nt assigned in @xmath51 .",
    "the connected components refer to the nodes that are connected in this graph .",
    "the connected components can be solved separately , and their return values multiplied .",
    "case 4 * branches * on a variable @xmath3 that is nt assigned . the efficiency , but",
    "not the correctness , of the algorithm depends on which variable @xmath3 is selected to be branched on .",
    "to compute @xmath59 , for each value @xmath60 of @xmath3 , call @xmath61 where @xmath53 is the set of all factors of the model , and normalize the results .",
    "an aspect that is important for lifted inference is that when values are assigned , the factors are simplified as they are now functions of fewer variables .",
    "this should be contrasted to variable elimination that constructs more complicated factors .",
    "in this section , we develop a lifted search - based algorithm .",
    "we show its correctness with respect to a parallel ground algorithm that uses the same order for splitting .",
    "note that , because the lifted algorithm removes multiple variables at once , this restricts the order the variables are split in the ground algorithm . a legal ordering for",
    "the lifted inference branches on all instances of a prv at once , whereas the corresponding ground algorithm branches on all instances sequentially .",
    "we show how the complexity ( as a function of the population size ) of the lifted algorithm is reduced compared to the corresponding ground algorithm .",
    "because we want our algorithm to be correct for all legal branching orderings , we ignore the selection of which variable to branch on ; this can be optimized for efficiency .",
    "we assume that we can count the number of solutions to a csp with inequality constraints in time that is at most logarithmic in the domain size of the variables ( e.g. , by adapting the # ve algorithm of @xcite to not enumerate the undistinguished variables ) .",
    "the lifted analogy of a context in algorithm [ rc - algo ] is a counting context which represents counts of assignments to parametrized random variables .",
    "a * counting context * on @xmath31 is a pair @xmath62 , where @xmath31 is a set of prvs ( all taking a single argument of the same type ) , all parametrized by the same parameter , and @xmath63 is a table mapping assignments of prvs in @xmath31 into non - negative integers .",
    "a counting context represents a context in the grounding . for each individual of the type ,",
    "the table @xmath63 specifies how many of the individuals take on that tuple of values .",
    "we can also treat a counting context in terms of @xmath63 as a set of pairs of the assignment of values to @xmath31 and the corresponding count .    a counting context for @xmath64 , and @xmath65 represents the assignment of values to @xmath37 and @xmath66 for @xmath67 ( @xmath68 ) individuals . 20 of these have both @xmath69 and @xmath70 true",
    ", 40 have @xmath69 true and @xmath70 false , etc .",
    "there is a separate counting context for each type .",
    "a * current context * is a set of pairs either of the form @xmath71 where @xmath72 is a prv that has no parameters , or of the form @xmath73 where @xmath4 is a type and @xmath74 is a counting context where the parameter of each of the prvs in @xmath74 is of type @xmath4 .",
    "a current context can have at most one pair for each type .",
    "a prv @xmath75 is * assigned * in a current context @xmath51 if it has no parameters and @xmath76 , or if it is parametrized by a variable of type @xmath4 and if @xmath77 and @xmath75 unifies with an element of @xmath31 .",
    "a * parfactor graph * on @xmath78 where @xmath51 is a current context and @xmath79 is a set of parfactors , has the elements of @xmath79 as nodes , and there is an arc between parfactors @xmath80 and @xmath81 if there is an element of @xmath82 that is nt assigned in @xmath51 that unifies with an element of @xmath83 such that the unifier does not violate any of the constraints in either parfactor .",
    "the * grounding * of a parfactor graph on @xmath78 is a factor graph on @xmath84 , where for every counting parfactor @xmath85 in @xmath79 , and for every grounding substitution @xmath86 of all of the free parameters that does not violate @xmath55 , @xmath87 is in @xmath88 with table @xmath15 .",
    "@xmath89 represents all of the ground instances that are assigned in @xmath51 , with the corresponding counts given by the table in @xmath51 .",
    "the grounding of a parfactor graph defines its semantics .",
    "we carry out lifted operations so that the lifted operations have the same result as carrying out recursive conditioning on the grounding of the parfactor graph for the same elimination ordering .",
    "the reason we can do lifted inference is because of symmetries .",
    "having a symmetry between the unnamed individuals means that a derivation about some of the individuals can be equally applied to any of the other individuals .",
    "we say that a set of individuals are * exchangeable * in a parfactor graph if the grounding of the parfactor graph with one consistent assignment of individuals to variables is isomorphic to the grounding of the graph with another assignment .",
    "graph isomorphism means there is a 1 - 1 and onto mapping between the nodes where the factors are identical .",
    "exchangeability means that reasoning with some of the individuals can be applied to the other individuals .      in order to determine which instances of parametrized random variables are the same random variables ,",
    "@xcite used unification and splitting on logical variables , which guarantees that the instances are identical or are disjoint . proposed to do all of the splitting up - front in an operation called shattering ( see @xcite for analysis of splitting , shattering and related operations ) .",
    "shattering is a local operation and does not imply graphs constructed by substitutions are isomorphic as in the following example :    consider the network of figure [ shattering - counter - fig ] ( a ) .",
    "although it is shattered , the instances with @xmath90 have a different grounding from the instances where @xmath91 .",
    "this graph can be split , on @xmath90 in the right - hand parfactors , giving the network shown in figure [ shattering - counter - fig ] ( b ) .",
    "an alternative to the local shattering is to carry out a more global preemptive shattering .",
    "a set of parfactors * preemptive shattered * if    * for every type , and every constant @xmath30 of the type that is explicitly mentioned , every parfactor that contains a variable @xmath3 of the type includes the constraint @xmath92 .",
    "* if variables @xmath3 and @xmath93 of the same type are in a parfactor , the parfactor contains the constraint @xmath91 .    given a set of parfactors , to construct an equivalent set of preemptively shattered set of parfactors , all logical variables in a parfactor are split with respect to all explicitly given constants , and any pairs of logical variables in a parfactor are split with respect to each other .",
    "preemptive shattering gives more splits than shattering , and sometimes more than needed , but it allows our proofs to work and does not prevent the asymptotic complexity results we seek . with preemptive shattering , counting the number of instances represented by a parfactor is straightforward ; there are no complex interactions . for the rest of this paper , we assume that all parfactors are preemptively shattered .",
    "note that , as can be seen in the parfactor graph of figure [ shattering - counter - fig ] ( b ) , even after preemptive shattering , we can not always globally rename variables so that the unifying variables are identical .",
    "when the graph is disconnected , algorithm [ rc - algo ] considers the connected components separately , and multiplies them . in this section , we cover all of the cases where the grounding is disconnected , and show how it corresponds to operations in the lifted case .",
    "if the lifted network is disconnected , the ground counterpart is disconnected , and so these disconnected components can be solved separately and multiplied .    if the lifted network is connected , this does not imply that its grounding is connected .",
    "for example , the parfactor graph of figure [ examplerq ] ( c ) is connected yet its grounding is not connected",
    ".    intuitively , if there is a logical variable that is in all of the counting parfactors , the instances for one individual are disconnected from the instances for another individual .",
    "thus , we can the solve the problem for one of the individuals , and the value for the lifted case is that value to the power of the number of individuals .",
    "this intuition needs to be refined because logical variables are local to a parfactor ; renaming the variables gives exactly the same grounding .",
    "there are cases where chains of unifications cause connectedness :    the parfactor graph        does not have disconnected ground instances , even though @xmath3 is in every prv . for three individuals , @xmath94 , in the grounding @xmath95",
    "is connected to @xmath96 through @xmath97 in the grounding of the bottom parfactor , thus @xmath98 is connected to @xmath99 for any different @xmath100 and @xmath101 , using the top parfactor .",
    "this reasoning can be applied generally :    suppose @xmath3 is a logical variable in parfactor @xmath29 that appears in parfactor graph @xmath79 .",
    "@xmath102 means the instances of @xmath3 in parfactor @xmath29 are connected to each other in the grounding of @xmath78 .",
    "@xmath103 can be defined recursively as follows .",
    "@xmath102 is true if and only if :    * @xmath3 appears in @xmath31 , is not assigned in @xmath51 and there is a prv in @xmath31 that is not assigned in @xmath51 and not parametrized by @xmath3 or * there is a parfactor @xmath104 in @xmath79 , such that an element of @xmath31 unifies with an element of @xmath105 ( in a manner consistent with @xmath30 and @xmath106 , and that are not assigned in @xmath51 ) and @xmath3 is unified with a variable @xmath107 such that @xmath108 is true .",
    "the definition of @xmath103 is sound : if @xmath102 is true , the instances of @xmath3 are connected in the grounding .",
    "the proof for the soundness is a straightforward induction proof ; essentially the algorithm is a constructive proof .",
    "however , the definition is not complete : there can be instances that are connected even though @xmath103 is false .",
    "it is instructive to see what a proof for completeness would look like . to prove completeness",
    ", we would prove that all instances of @xmath3 are disconnected if the above construction fails to derive they are connected .",
    "suppose there are two constants @xmath30 and @xmath106 , we need to show that the graph with @xmath3 replaced by @xmath30 is disconnected with the graph with @xmath3 replaced by @xmath106 .",
    "the graph with @xmath3 replaced by @xmath30 has @xmath30 in every prv ( by construction ) and the graph with @xmath3 replaced by @xmath106 has @xmath106 in every prv .",
    "however , this does not imply that the graphs are disconnected as there could be a prv that contains both @xmath30 and @xmath106 , as in the following example :    [ connected - eg ] consider the parfactor graph :        in the grounding , for all individuals @xmath109 , the random variable @xmath110 is connected to @xmath111 .",
    "however , it is disconnected from other instances of @xmath36 .",
    "we use the definition of @xmath103 to detect potentially disconnected components , and we can explicitly check for which instances are connected . in this way , we can ensure that the lifted algorithm detects disconnectedness whenever the ground algorithm would .",
    "the only counterexamples to the completeness of @xmath103 are when there is a set of variables , all with the same domain , and all of them appear in all prvs in the parfactor graph ( possibly renamed ) , and there is an inequality constraint between them .",
    "suppose there are @xmath112 such variables , @xmath113 , in a parfactor .",
    "we choose @xmath112 constants , @xmath114 , and apply the substitution @xmath115 to that parfactor , and then proceed to ground out all the corresponding variables in the other factors by unifying with the factors in all ways , forming a generic connected component .",
    "we then need to count the number of copies of each prv instance in the connected component ; suppose this is @xmath116 . for a population size of @xmath2",
    ", there are @xmath117 instances of the prv , and there are @xmath116 elements in each connected component , therefore there are @xmath118 disconnected components .",
    "if we compute @xmath119 as the probability of the generic connected component , we need to take @xmath119 to the power @xmath120 to compute the probability of the lifted network .    in the above analysis , @xmath2 is the population size and @xmath112 and @xmath116 depend only on the structure of the graph , and not on the population size .",
    "as we assume that we can count the population size in time logarithmic in the population size , the above procedure is polynomial in the log of the population size , whereas grounding is polynomial in the population size . as we see below ,",
    "this is the only case where the grounding is polynomial in the population size .",
    "in example [ connected - eg ] , @xmath121 and @xmath122 , and so the power is @xmath123 . in an example with @xmath124 , it is possible that @xmath116 could be 1,2,3 or 6 .",
    "algorithm [ lrc - algo3 ] gives the lifted variant of case 3 of algorithm [ rc - algo ] .",
    "the main loop is the same as algorithm [ rc - algo ] , with the recursive call @xmath125 where @xmath51 is a current context and @xmath53 is a set of counting parfactors .",
    "( \\{_case 3a_})@xmath53 is disconnected @xmath126 ( \\{_case 3b_})@xmath127 for @xmath128 select one @xmath3",
    "such that @xmath129 let @xmath4 be the type of @xmath3 let @xmath130 let @xmath131 replace @xmath132 with @xmath114 in @xmath8 unify @xmath8 with all other factors in @xmath53 let @xmath133instances of @xmath8 in @xmath134 let @xmath135      once we have a single connected component ( and there is no logical variable for which its instances are connected ) , we select a prv to branch on . in describing this , as in algorithm [ rc - algo ]",
    ", we decouple branching on a variable , and evaluating parfactors .",
    "typically a prv is associated with many parfactors , and when we branch on a prv we need to count the number of instances with various values for the prv . we need to make sure that we branch in a way that enables us to evaluate the relavant parfactors .    for the simplest case ,",
    "assume we want to sum out a boolean prv @xmath136 that has one free logical variable , @xmath3 , with domain @xmath137 .",
    "the idea behind counting @xcite is that only the number of exchangeable individuals that have a prv having a particular value matters , not their identity .",
    "we present counting first considering this simple case , then more complex cases .    in *",
    "counting branching * , for each @xmath138 , such that @xmath139 , the algorithm generate the branch where there are @xmath138 instances of @xmath8 true , and so @xmath140 instances of @xmath8 false .",
    "this branch represents @xmath141 paths in the grounding , as there are this many renamings of constants that would result in the same assignment .",
    "thus it can multiply the result of evaluating this branch by @xmath141 .",
    "note that the counting branching involves generating @xmath142 branches , whereas in the grounding there are @xmath143 assignments of values after the equivalent ground branching .",
    "the resulting counting context records the number of instances of @xmath8 that are true and number that are false .",
    "we now show how to evaluate various cases of parfactors that can include @xmath8 .",
    "the general case is a combination of these specific cases .",
    "for all of the example below , assume they are part of a larger parametrized graphical model .",
    "in particular , assume that the instances are connected , so that the case described in the previous section does not apply .",
    "[ fxe - ex ] consider the parfactor @xmath144 suppose @xmath145 .",
    "this parfactor represents @xmath2 factors .",
    "suppose @xmath146 is : @xmath147 suppose we have split on @xmath148 and assigned it the value @xmath149,and then we split on @xmath136 and are in the branch with @xmath150 for @xmath138 cases and @xmath151 for @xmath140 cases .",
    "this is represented by the current context : @xmath152 the contribution of this parfactor in this current context is @xmath153 .",
    "[ xydifftypeseg ] consider the parfactor @xmath154 suppose @xmath3 and @xmath93 are of different types , where @xmath145 , @xmath155 .",
    "@xmath156 is : @xmath157 this parfactor represents @xmath158 factors ; for each combination of assignments of values to the instances of @xmath8 and @xmath79 , there is a factor . in a current context with @xmath138 @xmath8 s true and @xmath159 @xmath79 s true",
    ", this parfactor has a contribution : @xmath160    [ fxgx - ex ] consider the parfactor @xmath161 suppose @xmath145 .",
    "this parfactor represents @xmath2 factors . unlike the previous cases ,",
    "counting branching is not adequate ; we need to consider which @xmath8-assignments go with which @xmath79-assignments .",
    "we can do a counting branch on @xmath8 first : for each @xmath162 $ ] , consider the case where @xmath8 is true for @xmath138 individuals , and is false for @xmath140 individuals .",
    "this case represents @xmath141 branches in the grounding . to split on @xmath79",
    "we can do a dependent branch : consider the @xmath138 individuals for which @xmath8 is true , and the @xmath140 individuals for which @xmath8 is false separately .",
    "for each @xmath163 $ ] , we consider the branch where @xmath79 is true for @xmath164 individuals and false for @xmath165 individuals all with @xmath150 ; this branch corresponds to @xmath166 ground branches . for each @xmath167 $ ]",
    "we construct the branch where @xmath79 is true for @xmath112 individuals and is false for @xmath168 individuals with @xmath151 .",
    "this represents @xmath169 ground cases .",
    "this branch is represented by the counting context : @xmath170 the contribution of the parfactor in this branch is : @xmath171    [ xneyfgex ] consider the parfactor @xmath172 suppose @xmath3 and @xmath93 are of the same type , where @xmath173 .",
    "this parfactor represents @xmath174 factors .",
    "this can be solved by a mix of the previous two examples .",
    "if we were to do the same as example [ xydifftypeseg ] , we would also include the cases where @xmath90 , which are explicitly excluded ; but these are the cases in example [ fxgx - ex ] .",
    "so the contribution of this factor can be computed by dividing the result of example [ xydifftypeseg ] by the result of example [ fxgx - ex ] , or equivalently subtracting the exponents . as in example",
    "[ fxgx - ex ] , we consider the case where @xmath8 is true for @xmath138 individuals , and for these individuals @xmath79 is true for @xmath164 of them , and out of the individuals where @xmath8 is false , @xmath79 is true for @xmath112 of them .",
    "taking the difference between the exponents example [ xydifftypeseg ] and [ fxgx - ex ] , and noticing that @xmath159 in example [ xydifftypeseg ] corresponds to @xmath175 in example [ fxgx - ex ] , the contribution of these factors is : @xmath176    [ fghex ] consider a mix between the previous examples .",
    "suppose we have the parfactors : @xmath177 @xmath178 where all of the variables are of the same type with @xmath2 individuals .",
    "suppose the branching order is to branch on @xmath179 , then @xmath8 , then @xmath79 .",
    "the split on @xmath79 needs to depend on both @xmath179 and @xmath8 .",
    "this can be done if the splits on @xmath179 and @xmath8 are dependent ; that is , we do a separate count on @xmath8 for the individuals for which @xmath179 are true and the individuals for which @xmath179 are false .",
    "then we do a separate countnote that if we had projected the counts onto the separate factors , we would have lost the interdependence between @xmath8 and @xmath179 , which is needed as the count for @xmath79 depends on both . ] on @xmath79 for the set of individuals for each combination of values to @xmath179 and @xmath8 .    counting branching needs to be expanded to cascaded counting branching .",
    "* dependent counting branching * on a prv @xmath180 that is parametrized by a parameter of type @xmath4 , works as follows .",
    "first , we find the corresponding counting context @xmath62 for @xmath4 .",
    "dependent counting branching replaces this with a counting context on @xmath181 as follows . for each assignment",
    "@xmath182 in the table @xmath63 ( @xmath138 is the count for assignment @xmath183 ) , for each @xmath164 in @xmath184 $ ] , we create the table @xmath185 that maps @xmath186 to @xmath138 and @xmath187 to @xmath165 .",
    "this assignment corresponds to @xmath166 , different grounding assignments , so the grounding needs to be multiplied by @xmath166 .",
    "this is recursively carried out for each tuple .",
    "starting from the current context of example [ fxe - ex ] , dependent counting branching on @xmath188 produces the counting context of example [ fxgx - ex ] .",
    "this context corresponds to @xmath189 contexts in the grounding .",
    "note that there are @xmath190 leaves that are decedents of the current context created in example [ fxe - ex ] , whereas in the grounding there are @xmath143 leaves that are descendants of each corresponding ground context .",
    "branching is shown as case 4 in algorithm [ lifted - rc - algo ] . in this algorithm",
    "@xmath51 is a current context and @xmath53 is a set of input parfactors .",
    "case 4a is the same as case 4 in algorithm [ rc - algo ] ( but for boolean variables ) .",
    "case 4b is for branching on a prv with a single parameter , and sets up dependent counting branching that is presented in algorithm [ branch - algo ] .",
    "note that this treats a counting context as a set of pairs of an assignment of values to a set of prvs and a count ( as described in section [ intrepsec ] ) .",
    "the branching factor depends on the population , but the depth of the recursive calls depends on the structure of the counting context , and not on the population size .",
    "the depth of the recursive calls provides the power of the polynomial . if we use a sparse representation of current contexts with zeros suppressed , this is never worse than grounding .",
    "[ however , whether we use a sparse or dense representation is something that can be optimized for . ]",
    "( \\{_case 0_})@xmath191 ( \\{_case 1_})@xmath42 such that @xmath43 ( \\{_case 2_})@xmath44 ( \\{_case 3_})see algorithm [ lrc - algo3 ] ( \\{_case 4 _ } ) select prv @xmath192 ( \\{_case 4a_})@xmath180 contains no parameters @xmath193 ( \\{_case 4b _ } ) suppose the parameter of @xmath180 is of type @xmath4 @xmath50    @xmath194 suppose @xmath4 is the type of the parameter in @xmath31    the main remaining part of the lifted algorithm is to evaluate a parfactor @xmath29 in a counting context @xmath195 , where all of the variables in @xmath31 are assigned in @xmath105 .",
    "there are three cases : shared parameters , different parameters of the same type and parameters of different types .",
    "one parfactor can contain all of these .    for shared parameters , as in example [ fxgx - ex ] ,",
    "the parfactor provides the base , and there is a unique counting context that provides the powers .",
    "first we group all of these together and raise them to the appropriate powers , and then treat them as a block .    for parameters of different types , as in example",
    "[ xydifftypeseg ] , we need to multiply the powers",
    ". we can treat the shared parameters as a block .    for different parameters of the same type , as in example [ xneyfgex ]",
    ", we can use the other two cases : first we treat them as different types ( which over - counts because it includes the equality cases ) , and then divide by the case when they are equal",
    ". we also have to readjust for double counting , which can be done using the coefficient of @xmath196 where @xmath112 is the number of such cases .",
    "for example , when @xmath124 , this is @xmath197 .",
    "the first of these corresponds to all parameters being different , the second to all pairs of parameters equal , and the third to all parameter the same .",
    "algorithm [ evalpf - algo ] shows how to evaluate a parfactor in a current context .",
    "it omits the last case , as it is computed from the other two cases .",
    "suppose @xmath198 is @xmath29 suppose @xmath51 is @xmath195 @xmath199 @xmath200 @xmath201    [ [ example - fghex - cont . ] ] example [ fghex ] ( cont . ) + + + + + + + + + + + + + + + + + + + + + + +    consider the branch where @xmath179 is true for @xmath138 individuals and false for @xmath140 individuals .",
    "suppose we then branch on @xmath8 .",
    "we then consider the branch with @xmath8 true for @xmath202 of the cases where @xmath179 is false and @xmath203 cases where @xmath179 is true .",
    "we thus have : @xmath203 individuals for which @xmath8 and @xmath179 are true ; @xmath204 individuals which have @xmath179 true and @xmath8 false ; @xmath202 individuals that have @xmath179 false and @xmath8 true ; and @xmath205 individuals what have both @xmath179 and @xmath8 false .",
    "we can then branch on @xmath79 , for each of the four sets of individuals .",
    "we thus know the counts of each case ; algorithm [ evalpf - algo ] computes the contribution of each factor .",
    "the final two cases of the algorithm are caching ( case 1 of algorithm [ rc - algo ] ) and forgetting ( case 0 of algorithm [ rc - algo ] ) .",
    "caching can remain the same , we just have to ensure that the cache can find elements that are the same up to renaming of variables , which can be done easily as the current context does not depend on the name and the variable and can be stored in a canonical way ( e.g. , alphabetically ) .",
    "forgetting is the inverse of splitting .",
    "a variable in a counting context that does nt appear in the parfactors can be summed out of the counting context ( which is the same operation as summing out a variable in variable elimination ) .",
    "@xmath206 in algorithm [ lifted - rc - algo ] means to sum out @xmath180 from the counting context it appears in or to remove it if it is not a parametrized variable .",
    "this description assumed binary - valued variables , and only functors with 0 or 1 arguments .",
    "the first of these is straightforward to generalize , and the second is not .",
    "consider what happens when @xmath8 can have more than two values .",
    "suppose @xmath8 is a unary @xmath207-valued prv with range @xmath208 .",
    "that is , @xmath209 is a random variable with domain @xmath208 .",
    "the assignments we need to consider are when there are non - negative integers @xmath210 where @xmath211 represents the number of individuals that have value @xmath138 . thus for each assignment to @xmath210 , where @xmath212 for each @xmath164 and @xmath213 , we consider the assignment",
    "@xmath214 it is a straightforward combinatorial exercise to include this in the algorithm ( but complicates the description ) .",
    "lifted probabilistic reasoning has proved to be challenging .",
    "there have been many proposals to lift various algorithms , however all of the exact algorithms needed to ground out a population in some cases ( and it is often difficult to tell for which cases they need to ground a population ) .",
    "we set out to determine if there was some fundamental reason why we would need to ground out the representation , or whether there was some case where we needed to effectively ground out .",
    "we believe that we have answered this for two cases :    * when lifted inference is polynomial in a population , which occurs when ve does not create a factor that is parametrized by a population or search can be disconnected for a population , we can solve it in time polynomial in the logarithm of the population .",
    "* for parametrized random variables with zero or a single argument , and search - based inference ( and so also variable elimination , due to their equivalent complexity ) is exponential when grounding , we answer arbitrary conditional queries in time polynomial in the population .",
    "the question of whether we can _ always _ do lifted inference in polynomial time in each population size when there are prvs with more than one argument , is still an open problem . while we can use the algorithm in this paper for many of these cases , there are some very tricky cases",
    ". hopefully the results in this paper will provide tools to fully solve this problem .",
    "we have chosen to not give empirical comparisons of our results .",
    "these are much more comparisons of the low - level engineering than of the lifted algorithm .",
    "there are no published algorithms that can correctly solve all of the examples in this paper in a fully lifted form .              ,",
    "r. , amir , e. , and roth , d. ( 2007 ) . lifted first - order probabilistic inference . in l.",
    "getoor and b.  taskar ( eds . ) , _ introduction to statistical relational learning_. m.i.t . press .",
    "http://www.cs.uiuc.edu/~eyal/papers/brazrothamir_srl07.pdf .",
    "frey , b.j .",
    "( 2003 ) . extending factor graphs",
    "so as to unify directed and undirected graphical models . in _ proceedings of the 19th conference on uncertainty in artificial intelligence _ , pp .",
    "morgan kaufmann .",
    "http://www.psi.toronto.edu/publications/2003/dfg-uai03.pdf .",
    "gogate , v. and domingos , p. ( 2010 ) . exploiting logical structure in lifted probabilistic inference . in",
    "_ aaai 2010 workshop on statististical and relational artificial intelligence ( star - ai)_. http://aaai.org/ocs/index.php/ws/aaaiw10/paper/view/2049 .",
    "jha , a. , gogate , v. , meliou , a. , and suciu , d. ( 2010 ) .",
    "lifted inference from the other side : the tractable features . in _ twenty - fourth annual conference on neural information processing systems ( nips)_.    kersting , k. , ahmadi , b. , and natarajan , s. ( 2009 ) .",
    "counting belief propagation . in j.b .",
    "a.  ng ( ed . ) , _ proceedings of the 25th conference on uncertainty in artificial intelligence ( uai09)_. montreal , canada .",
    "kisynski , j. and poole , d. ( 2009 ) .",
    "constraint processing in lifted probabilistic inference . in _ proc .",
    "25th conference on uncertainty in ai , ( uai-2009 ) _ , pp .",
    "montreal , quebec .",
    "http://www.cs.ubc.ca/~poole/papers/kisynskiuai2009.pdf .",
    "milch , b. , zettlemoyer , l.s .",
    ", kersting , k. , haimes , m. , and kaelbling , l.p .",
    ". lifted probabilistic inference with counting formulas . in _ proceedings of the twenty third conference on artificial intelligence ( aaai)_. http://people.csail.mit.edu/lpk/papers/mzkhk-aaai08.pdf"
  ],
  "abstract_text": [
    "<S> the promise of lifted probabilistic inference is to carry out probabilistic inference in a relational probabilistic model without needing to reason about each individual separately ( grounding out the representation ) by treating the undistinguished individuals as a block . </S>",
    "<S> current exact methods still need to ground out in some cases , typically because the representation of the intermediate results is not closed under the lifted operations . </S>",
    "<S> we set out to answer the question as to whether there is some fundamental reason why lifted algorithms would need to ground out undifferentiated individuals . </S>",
    "<S> we have two main results : ( 1 ) we completely characterize the cases where grounding is polynomial in a population size , and show how we can do lifted inference in time polynomial in the logarithm of the population size for these cases . </S>",
    "<S> ( 2 ) for the case of no - argument and single - argument parametrized random variables where the grounding is not polynomial in a population size , we present lifted inference which is polynomial in the population size whereas grounding is exponential . </S>",
    "<S> neither of these cases requires reasoning separately about the individuals that are not explicitly mentioned . </S>"
  ]
}