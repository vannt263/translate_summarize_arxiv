{
  "article_text": [
    "assume that we are given a population of elements @xmath4 , @xmath5 ( at least at first , the problem of infinite populations will be elaborated on later ) , along with a sequence of probabilities of each element of @xmath6 , denoted @xmath7 , such that @xmath8 , and a single number @xmath0 , the sample size , which might be greater or lower than @xmath1 .",
    "the task is to compute a random sample of size @xmath0 from the population @xmath6 , such that each element @xmath9 from the sample is one of the elements of @xmath6 , each with its corresponding probability .",
    "note that without loss of generality we can ( and will ) assume that @xmath10    the algorithm assumes a non - naive ( constant - time ) implementation of procedures for sampling single random numbers from the beta ( in the easy case , where @xmath11 and @xmath12 parameters are integer and @xmath13 ) , and binomial distributions , as well as lack of numerical errors .",
    "some consideration to mitigating the effects of numerical inaccuracies will be given in later sections .",
    "the algorithm is best presented ( as the author feels ) by starting from the naive algorithm , and iteratively refining it , until the desired time and memory complexity are reached .",
    "the naive algorithm ( which , despite its non - optimal costs , in practice is reasonably efficient , and is used , in its second variant , for example by the _ numpy _ numeric library for python ) is based on a cruicial idea , which will be used also in the novel version presented here .",
    "the idea is based on a geomertical intuition : if an interval @xmath14 $ ] is divided into parts with lengths @xmath15 , then sampling a random number @xmath16 from the uniform distribution @xmath17 and picking the subinterval of @xmath14 $ ] into which it falls ( and the corresponding element of @xmath6 ) results in a choice of a single element of @xmath6 with the desired probability distribution .",
    "efficient finding of the selected subinterval is faciliated by precomputing an array of cumulative sums of probabilities , then performing a binary search on it .",
    "compute array @xmath18 @xmath19 new empty multiset (  @xmath0 times ) randomize @xmath20 find greatest @xmath21 s.t . @xmath22",
    "< x$ ] using binary search add @xmath21 to @xmath23 @xmath23 contains the result    the algorithm consumes @xmath24 time for initialization ( lines 1 and 2 ) , then @xmath25 time for the actual sampling , and @xmath24 memory space for additional data structures ( not counting the @xmath26 for the result ) .",
    "the first modification of the algorithm makes it possible to skip the necessity to precompute the array of cumulative sums in line one .",
    "instead it samples all the necessary random numbers @xmath27 , sorts the @xmath16 array , and then processes the @xmath15 sequence at the same time as @xmath16 , in fasion similar to the merge step of the mergesort algorithm .",
    "@xmath19 new empty multiset @xmath28 @xmath29 randomize @xmath30 sort @xmath16 in ascending order @xmath23 contains the result    the algorithm runs in @xmath31 time , ( which is not an improvement over the previous version ) : lines 4 and 5 take a total of @xmath32 , the outer loop runs @xmath0 times , while the inner loop runs a total of @xmath1 times ( as the variable @xmath33 is bounded by @xmath1 ) .",
    "the algorithm uses @xmath26 memory .",
    "the algorithm might be further improved if the table @xmath16 could be generated in an already sorted order .",
    "this is , in fact , possible : it is a well - known fact that if @xmath34 , then @xmath35 , and is the first element of the sought table  @xcite .",
    "since the variables are independent , then , after sampling the minumum using this method , it is easy to see that the remaining variables ( under condition that they have to be not less than the minimum ) are distributed according to @xmath36 , where @xmath37 is the minimum . the second - lowest variable",
    "might be sampled with the same method after rescaling @xmath36 to @xmath38 , and so on .",
    "in fact , this allows us to drop the step of precomputing the table @xmath16 altogether , and to just compute the consecutive variables `` on the go '' , making the algorithm capable of online operation , as well as improving the runtime .",
    "@xmath19 new empty multiset @xmath28 @xmath29 @xmath39 @xmath23 contains the result    the algorithm runs in @xmath40 time , and requires constant additional memory if working online : in that case , every intermediate result is immediately provided to the calling procedure for consumption ( and possibly , immediately discarded ) , instead of being explicitly stored in @xmath23 .",
    "the practical speed of the above algorithm is constrained by the speed of the sampling from the beta distribution , the remaining operations being trivial in comparison .",
    "this provides an opportunity for optimization : if the population in small with respect to the numer of samples required , then the algorithm will have to sample from the beta distribution many times for any population member .",
    "this can be avoided by changing the reasoning : insead of asking `` where will the next @xmath9 be ? ''",
    "we can ask `` how many @xmath41 we will encounter while going through the current @xmath15 ? '' . the answer to that , for @xmath42",
    "is the binomial distribution : @xmath43 .",
    "for further @xmath44 the answer is the same distribution , only conditioned on the number of @xmath41 and the population probability already consumed : @xmath45.this is in fact a standard algorithm for sampling from multinomial distribution ( which is exactly the same problem as random sample with replacement : only the former terminology is most often used in contexts where @xmath3 , and the latter otherwise ) .",
    "@xmath19 new empty multiset @xmath28 @xmath29 @xmath23 contains the result    the provided algorithm runs in @xmath24 time ( assuming that @xmath23 behaves like a counter , and increasing the count of a given item is done in constant time ) , and in constant memory .",
    "it is capable of working online .",
    "it should be noted , that although it achieves the optimal theoretical asymptotic runtime , its practical implementation will be very inefficient when @xmath46 : even if a sample consisting only of one element is desired , it will perform @xmath1 expensive operations of sampling from binomial distribution .",
    "the previous two algorithms are opposites in terms of their practical pessimistic case : the one using beta distribution has to randomize once per each requested sample member , and so , runs fast if @xmath46 , and slowly if @xmath47 , while the one using the binomial distibution has to randomize once for every member of the population , and as such is efficient in practice only for large values of @xmath0 and small @xmath1 .",
    "it turns out that it is actually possible to create a hybrid algorithm which combines the strengths of both of them .",
    "what s more , the algorithm does nt work by first examining the data , and then choosing one of the previous versions and runnig it , instead it adapts `` on the fly '' , is capable of switching back and forth between modes during runtime as needed , and does not need to examine the data in advance , which keeps it compatible with online operation .",
    "recall the metaphor of a segment divided into fragments corresponding to the population members , with lengths equal to their probabilities .",
    "the algorithm may be imagined as if walking along the segment , picking its sample along the way .",
    "it can make two kinds of steps : first is the `` beta '' step , with constant average length , which may pass over multiple small population elements , and results in adding to the sample the population member in which it ends ( with multiplicity of one ) .",
    "the disadvantage is that if a large population member is encountered then it may take multiple beta steps to pass it .",
    "the other kind of step , the binomial step immediately travels forward to the end of the current population member , adding it to the sample with multiplicity according to the result of randomization .",
    "obviously it makes sense to use this type of step while traversing population members with large probabilities .",
    "this is achieved through the condition in line 7 : the expected number of samples randomized from the current member of the population is compared to a constant ( 1.0 here ) .",
    "the result of this comparison is used to determine whether to proceed in beta or in binomial mode .",
    "any positive constant here is good enough to achieve the theoretical bounds , however , in practice it is best to choose it based on the relative costs of sampling from beta and from binomial distributions .",
    "the algorithm is still online ( although presented in non - online form for readability ) , works in constant memory if online ( results are immediately consumed by caller , instead of being stored in @xmath23 ) .",
    "a careful reader might notice that the algoritm as presented runs in pessimistic @xmath40 time .",
    "the pessimistic time is achieved if the algorithm encounters an element of the population with probability small enough that it decides to use the beta mode , but , due to bad luck , proceeds to draw @xmath26 infinitesimal samples from the beta distribution before leaving the element and proceeding forward",
    ". this may be easily avoided by adding a hard condition that would force a binomial mode after a constant number of consecutive beta samples .",
    "this was omitted from the main code presented here for readability , and also because it is not a concern for any practical application . however , with the hard limit , the algorithm can perform at most @xmath1 binomial samples ( as each binomial sample increases the @xmath33 variable - which is bounded by @xmath1 - and with the hard limit it is possible to perform at most @xmath24 beta samples ) - therefore its runtime is bounded by @xmath24 .",
    "@xmath19 new empty multiset @xmath28 @xmath29 @xmath48 @xmath23 contains the result",
    "the algorithms presented here depend heavily on good implementations of functions for sampling from binomial and from beta distribution .    in particular , anyone undertaking the implementation of the algorithm is advised to write a custom version of function for sampling from @xmath49 distribution : the algorithm always samples with @xmath50 , and in this case , the distribution has an explicit , invertible cdf - and so , a custom sampler using the inverse cdf method will always be faster than a sampler from any scientific library which has to handle the general case .    regarding the binomial distribution , the c++11 function for sampling as implemented by the gnu project s libstdc++ ( standard c++ library on most unix systems ) is inadequate for the task as it seems to have non - constant complexity with regard to its parameters . in any tests performed",
    "i have used the function as implemented by the boost library which seems to work not only faster than libstdc++ s , but also runs in constant time .",
    "regarding the numerical stability of the algorithm , the algorithm computes a cumulative sum of all encountered probabilities , which is of course tricky .",
    "if precise numerical correctness is required , then the summation should be done using kahan s  @xcite or even shewchuk s  @xcite summation algorithms . however , for most if not all practical purposes imaginable , this is not necessary .",
    "special care must be taken , however , as sometimes , due to numerical errors , the last sampling from binomial distribution might be performed with probability of success slightly greater than 1 - the programmer must ensure that the sampling function just assumes 1 instead of crashing .    as a side note",
    ": the algorithm does benefit slightly from having its input data sorted ( in either ascending or descending order , does nt matter ) : it casues the algorithm to perform less switches between beta and binomial mode , and so , it minimises the number of elements which are partially dealt with in binomial mode , and partially in beta mode .",
    "the very slight speed benefit does not justify spending the computational time ( and especially the loss of asymptotic optimality and the ability to work online ) needed to sort the data .",
    "however , this means that in order to avoid any bias in runtime tests described further , the input data for all tests was randomly shuffled .",
    ".a comparison of properties of sampling algorithms [ cols= \" < , > , > , > , > \" , ]     [ tbl - the ]    comparison of runtimes      +   &   +   +   &   +   +   &   +    the algorithms presented in this paper have been implemented in c++11 programming language for purposes of testing and speed comparison .",
    "these are compared with the implementation of standard walker s alias method  @xcite as implemented by the r programming language ( later referred to under name `` walker - r '' ) , the full implementation of r s sampling function ( which examines the data , heuristically chooses between walker s algorithm or a naive algorithm , and the runs it ) , referred to as `` full - r '' , an alternative , standalone implementation of walker s algorithm in c by ransampl library , and with numpy s implementation which follows algorithm  [ alg : one ] .",
    "the novel algorithm proposed in this work ( algorithm  [ alg : five ] ) has been tested in two versions , one which produces an array of size @xmath0 ( the sample with repetitions ) , referred to as the `` alg5-array '' algorithm , and one which produces the multiset ( with integer counts instead of the repetitions ) .",
    "the multiset was implemented either as a hashtable ( using standard c++ _ unordered_map _ data structure ) or trivially as an array of size @xmath1 .",
    "the implementation using the former is referred to as `` alg5-ht '' in plots , the one using the latter as `` alg5-pop '' .",
    "similarly , algorithm  [ alg : four ] has been implemented and tested both outputting an array with repetitions and multiset ( based on an array , hashtable implementation was produced but skipped in effort to avoid complicating the plots further ) .",
    "a summary of theoretical properties of each of the algorithms is presented in table  [ tbl - the ]    the r functions are written in c code , and the code for these functions is reused , slightly modified to remove dependencies on r s internals .",
    "numpy , although written in python , is compiled to native code using cython , and as such , should run at near - native speeds , like the rest of the tested algorithms , without suffering overhead due to python being an interpreted , high - level language .",
    "the algorithms have been tested on three different random populations , one drawn from uniform distribution @xmath51)^n$ ] , representing population with mostly equal probabilities , one drawn from a geometric sequence starting with @xmath52 and ending at @xmath53 , representing a population with skewed probabilities .",
    "the third type of population is generated by applying a gaussian pdf function to @xmath1 points evenly spaced between @xmath54 and 10 times the stdev of the gaussian function .",
    "this is meant to simulate the usual application of sampling function in modelling in population genetics ( which in fact was the inspiration for this research ) : in population genetics models , selection and reproduction of modelled organisms is often done precisely by randomly sampling with replacement of @xmath1 organisms ( that reproduce and pass their offspring to a next generation ) from a population of @xmath1 .",
    "the probability of a given organism being chosen to reproduce is proportional to its _ fitness function _ - which is often gaussian .",
    "each population type ( uniform , geometric and gaussian ) is rescaled so that it sums to @xmath52 , and randomly shuffled .",
    "the results of the tests are presented on figure  [ fig - res ] .",
    "it is evident from the results of the tests that not only is the proposed algorithm asymptotically optimal , but , unlike algorithm 4 it is also efficient in practice , outperforming the competing methods in most scenarios , by as much as several orders of magnitude in some cases . in the single pessimistic case ,",
    "where the distribution of probabilities in the population is close to uniform and @xmath55 , although it runs slightly slower , it still remains competetive , moreover , the difference in runtime grows smaller as @xmath56 , and it overtakes the walker s method at @xmath57 ( data not shown ) .    the algorithm is able to adapt to the input data and use any skew from uniform distribution to its advantage , to increase its runtime , as evidenced by the tests on gaussian and especially geometric populations . unlike the popular algorithms it works in constant additional memory , and is capable of online operation .",
    "an implementation of this algorithm in a few programming languages may be downloaded from http://bioputer.mimuw.edu.pl/~mist/stats",
    "as the proposed algorithm is online , it may accept an infinite sequence of states as its population , and can still be expected to produce a sample in finite time , without exhausting the whole sequence . as such , one application is immediately obvoius : mass sampling of iid variates from any discrete distribution .",
    "all one needs ito do is to exhaustively walk through the configuration space of the distribution , preferably ( though not necessarily ) in order of decreasing probability mass function ( pmf ) , and feed the resulting sequence into the proposed algorithm .",
    "the result is a sample from the input distribution of any desired size .",
    "the advantage of the proposed solution is that the input distribution does not need to have an easily invertible cdf , only a computable pmf .",
    "the runtime is usually sublinear , wrt . to the sample size , but that depends on the exact properties of the distribution being sampled , distributions with light tails being faster to sample from than heavy - tailed ones . as an example : generating a sample of size @xmath58 from poisson distribution with @xmath59 using r programming language s _ rpois _ function takes about 90 seconds , while using the scheme proposed above elapses 0.7 seconds .",
    "such an algorithm itself consumes constant memory plus any memory needed for datastructures needed to walk through the configuration space ( trivially constant in case of distributions with integer support , at worst a linear `` visited '' hashtable plus a linear priority queue when the configuration space is complicated , and needs to be traversed in a dijkstra - like fashion  @xcite ) .",
    "the algorithm works online , in the meaning that the generated part of the sample is immediately available for consumption , before computations proceed to generate the rest of it .",
    "this could be used to provide an alternative implementation of sampling functions in many programming languages , most of which accept an argument denoting sample size , but then proceed to generate even a large sample in naive , iterative fashion .",
    "one point worth noting , however , is that the algorithm , as presented , returns the sample sorted in the order in which the configuration space was traversed .",
    "if this is undesirable , a fisher - yates shuffle  @xcite may be performed on the resulting stream , at the cost of loss of online property .",
    "i would like to thank prof .",
    "anna gambin , baej miasojedow phd , and mateusz cki msc for their helpful comments .",
    "this research was funded by grant no .",
    "2012/06/m / st6/00438 by polish national science centre , and grant polonium , , matematyczne i obliczeniowe modelowanie ewolucji ruchomych elementw genetycznych  ."
  ],
  "abstract_text": [
    "<S> this paper presents a novel algorithm solving the classic problem of generating a random sample of size @xmath0 from population of size @xmath1 with non - uniform probabilities . </S>",
    "<S> the sampling is done with replacement . </S>",
    "<S> the algorithm requires constant additional memory , and works in @xmath2 time ( even when @xmath3 , in which case the algorithm produces a list containing , for every population member , the number of times it has been selected for sample ) . </S>",
    "<S> the algorithm works online , and as such is well - suited to processing streams . </S>",
    "<S> in addition , a novel method of mass - sampling from any discrete distribution using the algorithm is presented .    </S>",
    "<S> = 1 </S>"
  ]
}