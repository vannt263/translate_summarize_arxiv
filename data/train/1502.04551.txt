{
  "article_text": [
    "comparator networks are probably the simplest data - oblivious model for sorting - related algorithms .",
    "the most popular construction is due to batcher @xcite and it s called _ odd - even _ sorting network . for all practical values , this is the best known sorting network .",
    "however , in 1992 parberry @xcite introduced the serious competitor to batcher s construction , called _ pairwise _ sorting network . in context of sorting , pairwise network is not better than odd - even network , in fact it has been proven that they have exactly the same size and depth . as parberry said himself : _  it is the first sorting network to be competitive with the odd - even sort for all values of n_. there is a more sophisticated relation between both types of network and their close resemblance . for overview of sorting networks , see knuth @xcite or parberry @xcite .    in recent years new applications for sorting networks have been found , for example in encoding of _ pseudo boolean constraints _ and _ cardinality constraints _ for sat - solvers .",
    "cardinality constraints take the form @xmath2 , where @xmath3 are boolean variables , @xmath1 is a natural number , and @xmath4 is a relation from the set @xmath5 .",
    "cardinality constraints are used in many applications , the significant one worth mentioning arise in sat - solvers . using cardinality constraints with cooperation of sat - solvers we can handle many practical problems that are proven to be hard .",
    "works of asn _ et al . _",
    "@xcite describe how to use odd - even sorting network to encode cardinality constraints into boolean formulas . in @xcite authors",
    "do the same with pseudo boolean constraints .",
    "it has already been observed that using selection networks instead of sorting networks is more efficient for the encoding of cardinality constraints .",
    "codish and zazon - ivry @xcite introduced pairwise cardinality networks , which are networks derived from pairwise sorting networks that express cardinality constraints .",
    "two years later , same authors @xcite reformulated the definition of pairwise selection networks and proved that their sizes are never worse than the sizes of corresponding odd - even selection networks . to show the difference they plotted it for selected values of @xmath0 and @xmath1 .    in this paper",
    "we give a new construction of smaller selection networks that are based on the pairwise selection ones and we prove that the construction is correct .",
    "we estimate also the size of our networks and compute the difference in sizes between our selection networks and the corresponding pairwise ones",
    ". the difference can be as big as @xmath6 for @xmath7 .",
    "finally , we analyze the standard 3(6)-clause encoding of a comparator and prove that such cnf encoding of any selection network preserves arc - consistency with respect to a corresponding cardinality constraint .    the rest of the paper is organized in the following way : in section 2 we give definitions and notations used in this paper . in section 3",
    "we recall the definition of pairwise selection networks and define auxiliary bitonic selection networks that we will use to estimate the sizes of our networks . in section 4",
    "we present the construction of our selection networks and prove its correctness . in section 5",
    "we analyze the sizes of the networks and , finally , in section 6 we examine the arc - consistency of selection networks .",
    "in this section we will introduce definitions and notations used in the rest of the paper .",
    "input sequence of length @xmath0 is a sequence of natural numbers @xmath8 , where @xmath9 ( for all @xmath10 ) .",
    "we say that @xmath11 is sorted if @xmath12 ( for each @xmath13 ) . given @xmath8 , @xmath14",
    "we define concatenation as @xmath15 .",
    "we will use the following functions from @xmath16 to @xmath17 :    @xmath18    let @xmath19 .",
    "we define a relation @xmath20 on @xmath21 .",
    "let @xmath8 and @xmath22 , then :    @xmath23    let @xmath11 and let @xmath24 , where @xmath25 .",
    "a comparator is a function @xmath26 defined as :    @xmath27    we say that @xmath28 is a comparator network of order @xmath0 , if it can be represented as the composition of finite number of comparators , namely , @xmath29 .",
    "the size of comparator network ( number of comparators ) is denoted by @xmath30 .",
    "comparator network of size 0 is denoted by @xmath31 .",
    "r0.25     traditionally comparator networks are presented as circuits that receives @xmath0 inputs and permutate them using comparators connected by `` wires '' .",
    "each comparator has two inputs and two outputs .",
    "the `` upper '' output is the maximum of inputs , and `` lower '' one is minimum . as an example",
    "look at figure [ fig : maximum ] , where we present a comparator network of order 4 , @xmath32 , that outputs maximum from 4 inputs on its first output , namely , @xmath33 .",
    "it is well known that @xmath34 .",
    "we will often omit explicit declaration of order of comparator network when it is not ambiguous .",
    "a sequence @xmath11 is a bitonic sequence if @xmath35 for some @xmath36 , where @xmath37 , or a circular shift of such sequence .",
    "we distinguish a special case of a bitonic sequence :    * _ v - shaped _",
    ", if @xmath38    and among v - shaped sequences there are two special cases :    * _ nondecreasing _ , if @xmath39 , * _ nonincreasing _ , if @xmath40 .",
    "[ def : bit ]    a comparator network @xmath41 is a _ sorting network _ , if for each @xmath11 , @xmath42 is sorted .",
    "two types of sorting networks are of interest to us : _ odd - even _ and _ pairwise_. based on their ideas , knuth @xcite ( for odd - even network ) and codish and zazon - ivry @xcite ( for pairwise network ) showed how to transform them into selection networks ( we name them @xmath43 and @xmath44 respectively ) .",
    "a sequence @xmath11 is top @xmath1 sorted , with @xmath45 , if @xmath46 is sorted and @xmath47 .",
    "a comparator network @xmath48 ( where @xmath45 ) is a _ selection network _ , if for each @xmath11 , @xmath49 is top @xmath1 sorted .    to simplify the presentation",
    "we assume that @xmath0 and @xmath1 are powers of 2 .",
    "a clause is a disjunction of literals ( boolean variables @xmath50 or their negation @xmath51 ) .",
    "a cnf formula is a conjunction of one or more clauses .",
    "a unit propagation ( up ) is a process , that for given cnf formula , clauses are sought in which all literals but one are false ( say @xmath52 ) and @xmath52 is undefined ( initially only clauses of size one satisfy this condition ) .",
    "this literal @xmath52 is set to true and the process is iterated until reaching a fix point .",
    "cardinality constraints are of the form @xmath53 , where @xmath54 and @xmath4 belongs to @xmath55 .",
    "we will focus on cardinality constraints with less - than relation , i.e. @xmath56 .",
    "an encoding ( a cnf formula ) of such constraint preserves arc - consistency , if as soon as @xmath57 variables among the @xmath58 s become true , the unit propagation sets all other @xmath58 s to false .    in @xcite authors are using sorting networks for an encoding of cardinality constraints , where inputs and outputs of a comparator are boolean variables and comparators are encoded as a cnf formula .",
    "in addition , the @xmath1-th greatest output variable @xmath59 of the network is forced to be 0 by adding @xmath60 as a clause to the formula that encodes @xmath56 .",
    "they showed that the encoding preserves arc - consistency .",
    "a single comparator can be translated to a cnf formula in the following way : let @xmath61 and @xmath62 be variables denoting upper and lower inputs of the comparator , and @xmath63 and @xmath64 be variables denoting upper and lower outputs of a comparator , then :    @xmath65    is the _ full encoding _ of a comparator .",
    "notice that it consists of 6 clauses .",
    "let @xmath66 be a comparator network .",
    "full encoding @xmath67 of @xmath66 is a conjunction of full encoding of every comparator of @xmath66 .",
    "in @xcite authors observe that in case of @xmath4 being @xmath68 or @xmath69 , it is sufficient to use only 3 clauses for a single comparator , namely :    @xmath70    we call it : _ half encoding_. in @xcite it is used to translate odd - even sorting network to encoding that preserves arc - consistency .",
    "we show a more general result ( with respect to both @xcite and @xcite ) , that half encoding of any selection network preserves arc - consistency for the `` @xmath68 '' and `` @xmath69 '' relations .",
    "similar results can be proved for the `` @xmath71 '' relation using the full encoding of comparators and for the `` @xmath72 '' or `` @xmath73 '' relations using an encoding symmetric to @xmath74 , namely : @xmath75 .",
    "now we present two constructions for selection networks .",
    "first , we recall the definition of pairwise selection networks by codish and zazon - ivry @xcite .",
    "secondly , we give the auxiliary construction of a _ bitonic _ selection network @xmath76 , that we will use to estimate the sizes of our improved pairwise selection network in section 5 .",
    "@xmath11 dominates @xmath77 if @xmath78 ( for @xmath10 ) .",
    "a comparator network @xmath41 is a _ splitter _ if for any sequence @xmath79 , if @xmath80 , then @xmath81 dominates @xmath82 .",
    "we can construct splitter @xmath83 by joining inputs @xmath84 , for @xmath85 , with a comparator .",
    "size of a splitter is @xmath86 .    if @xmath87 is bitonic and @xmath88 , then @xmath81 and @xmath82 are bitonic and @xmath89 .",
    "[ lma : split_bit ]    see appendix b of @xcite .",
    "input : any @xmath11 .    1 .",
    "if @xmath90 , return @xmath91 .",
    "2 .   if @xmath92 , return @xmath93 .",
    "3 .   compute @xmath94 .",
    "4 .   compute @xmath95 and @xmath96 .",
    "5 .   compute @xmath97 .",
    "[ net : pw ]    notice that since we introduced a splitter as the third step , in the recursive calls we need to select @xmath1 top elements from the first half of @xmath98 , but only @xmath99 elements from the second half .",
    "the reason : @xmath100 can not be one of the first @xmath1 largest elements of @xmath101 .",
    "first , @xmath100 is smaller than any one of @xmath102 ( by the definition of top @xmath1 sorted sequence ) , and second , @xmath103 dominates @xmath102 , so @xmath100 is smaller than any one of @xmath103 . from this argument",
    "we make the following observation :    if @xmath104 is top @xmath1 sorted , @xmath105 is top @xmath99 sorted and @xmath103 dominates @xmath102 , then @xmath1 largest elements of @xmath101 are in @xmath106 .",
    "[ obs : second_step ]    the last step of network [ net : pw ] merges @xmath1 top elements from @xmath107 and @xmath99 top elements from @xmath108 with so called _ pairwise merger_. we will omit the construction of this merger , because it is not relevant to our work .",
    "we would only like to note , that its size is : @xmath109 .",
    "construction of the merger as well as the detailed proof of correctness of network @xmath44 can be found in section 6 of @xcite .    a comparator network @xmath41 is a bitonic splitter if for any two sorted sequences @xmath110 , if @xmath111 , then ( 1 ) @xmath112 and ( 2 ) @xmath113 and @xmath114 are bitonic .",
    "[ def : bitonic_splitter ]    we can construct bitonic splitter @xmath115 by joining inputs @xmath116 , for @xmath85 , with a comparator .",
    "size of a bitonic splitter is @xmath117 .",
    "we now present the procedure for construction of the bitonic selection network .",
    "we use the odd - even sorting network @xmath118 and the network @xmath119 ( also by batcher @xcite ) for sorting bitonic sequences as black - boxes . as a reminder : @xmath120 consists of two steps , first we use @xmath121 , then recursively compute @xmath122 for @xmath81 and @xmath82 ( base case , @xmath123 , consists of a single comparator ) .",
    "size of this network is : @xmath124 .",
    "bitonic selection network @xmath76 is constructed by the following procedure .",
    "input : any @xmath11 .    1 .",
    "let @xmath125 .",
    "partition input @xmath126 into @xmath52 consecutive blocks , each of size @xmath1 , then sort each block with @xmath127 , obtaining @xmath128 .",
    "2 .   while @xmath129 , do the following : 1 .   collect blocks into pairs @xmath130 .",
    "2 .   compute @xmath131 for each @xmath132 .",
    "3 .   compute @xmath133 for each result of previous step .",
    "4 .   let @xmath134 .",
    "relabel @xmath135 to @xmath136 , for @xmath137 .",
    "[ net : bit ]    a comparator network @xmath76 constructed by the procedure network [ net : bit ] is a selection network .",
    "let @xmath11 be the input to @xmath76 .",
    "after step one we get sorted sequences @xmath128 , where @xmath125 .",
    "let @xmath138 be the value of @xmath52 after @xmath139 iterations .",
    "let @xmath140 be the blocks after @xmath139 iterations .",
    "we will prove by induction that :    _ @xmath141 : if @xmath142 are sorted and are containing @xmath1 largest elements of @xmath126 , then after @xmath139-th iteration of the second step : @xmath143 , @xmath140 are sorted and are containing @xmath1 largest elements of @xmath126 .",
    "_    if @xmath144 , then @xmath145 , so @xmath141 holds .",
    "we show that @xmath146 @xmath147 .",
    "consider @xmath148-th iteration of step two . by the induction hypothesis @xmath143 , @xmath140",
    "are sorted and are containing @xmath1 largest elements of @xmath126 .",
    "we will show that @xmath148-th iteration does not remove any element from @xmath1 largest elements of @xmath126 . to see this , notice that if @xmath149 ( for @xmath150 ) , then @xmath151 and that @xmath152 is bitonic ( by definition [ def : bitonic_splitter ] ) .",
    "because of those two facts , @xmath153 is discarded and @xmath152 is sorted using @xmath154 . after this , @xmath155 and blocks @xmath156 are sorted .",
    "thus @xmath157 is true .    since @xmath125 ,",
    "then by @xmath141 we see that the second step will terminate after @xmath158 iterations and that @xmath159 is sorted and contains @xmath1 largest elements of @xmath126 .",
    "schema of construction of bitonic selection network is shown in figure [ fig : bit - sel ] .",
    "the size of bitonic selection network is :    @xmath160    in figure [ fig : bit - vs - pw ] we present bitonic and pairwise selection networks for @xmath161 and @xmath162 .",
    "as mentioned in the previous section , only the first @xmath99 elements from the second half of the input are relevant when we get to the merging step in @xmath44 .",
    "we will exploit this fact to create a new , smaller merger .",
    "we will use the concept of bitonic sequences , therefore the new merger will be called @xmath163 and the new selection network : @xmath164 .",
    "the network @xmath164 is generated by substituting the last step of @xmath44 with @xmath163 .",
    "the new merger consists of two steps :    input : @xmath101 , where @xmath104 is top @xmath1 sorted and @xmath105 is top @xmath99 sorted and @xmath103 dominates @xmath102 .    1 .",
    "compute @xmath165 , let @xmath166 .",
    "2 .   compute @xmath167 .",
    "[ net : pw_merge ]    the output of network [ net : pw_merge ] consists of sorted @xmath1 largest elements from input @xmath101 , assuming that @xmath104 is top @xmath1 sorted and @xmath105 is top @xmath99 sorted and @xmath103 dominates @xmath102 .",
    "[ thm : pw_merge ]    we have to prove two things : ( 1 ) @xmath168 is bitonic and ( 2 ) @xmath168 consists of @xmath1 largest elements from @xmath101 .",
    "\\(1 ) let @xmath169 be the last index in the sequence @xmath170 , for which @xmath171 .",
    "if such @xmath169 does not exist , then @xmath172 is nondecreasing , hence @xmath168 is bitonic ( nondecreasing ) .",
    "assume that @xmath169 exists , then @xmath173 is nondecreasing and @xmath174 is nonincreasing . adding the fact that @xmath175 proves , that @xmath168 is bitonic ( v - shaped ) .",
    "\\(2 ) by observation [ obs : second_step ] , it is sufficient to prove that @xmath176 . since @xmath177 @xmath178 , then @xmath179 and by definition [ def : bitonic_splitter ] : @xmath180 .",
    "therefore @xmath168 consists of @xmath1 largest elements from @xmath101 .",
    "the bitonic merger in step 2 receives a bitonic sequence , so it outputs a sorted sequence , which completes the proof .",
    "the first step of improved pairwise merger is illustrated in figure [ fig : pw_bit ] .",
    "we use @xmath99 comparators in the first step and @xmath181 comparators in the second step .",
    "we get a merger of size @xmath182 , which is better than the previous approach . in the following it",
    "is shown that we can do even better and eliminate @xmath99 term .    .",
    "]    the main observation is that the result of the first step of @xmath183 operation : @xmath184 is not only bitonic , but what we call _ v - shape s - dominating_.    a sequence @xmath185 is s - dominating if @xmath186 @xmath187 .",
    "[ def : sd ]    if @xmath185 is v - shaped and s - dominating , then @xmath168 is nonincreasing or @xmath188 .",
    "[ lma : sd ]    assume that @xmath168 is not nonincreasing .",
    "then @xmath189 .",
    "assume that @xmath190 .",
    "since @xmath168 is v - shaped , @xmath191 must be in nondecreasing part of @xmath168 . if follows that @xmath192 .",
    "that means that @xmath193 . on the other hand",
    ", @xmath168 is s - dominating , thus @xmath187  a contradiction .",
    "we will say that a sequence @xmath168 is _ v - shape s - dominating at point @xmath36 _ if @xmath36 is the smallest index greater than @xmath99 such that @xmath194 or @xmath195 for a nonincreasing sequence .",
    "let @xmath196 be v - shape s - dominating at point @xmath36 , then @xmath197 .",
    "[ lma : transit ]    if @xmath168 is nonincreasing , then the lemma holds . from lemma [ lma : sd ] : @xmath198 . if @xmath199 , then by definition [ def : bit ] : @xmath200 , so lemma holds .",
    "if @xmath201 , then by definition [ def : bit ] : @xmath202 , so @xmath203 .",
    "since @xmath204 , it suffices to prove that @xmath205 . by definition [ def : sd ] and [ def :",
    "bit ] : @xmath206 .",
    "a _ half splitter _ is a comparator network constructed by comparing inputs @xmath207 ( normal splitter with first @xmath208 comparators removed )",
    ". we will call it @xmath209 .",
    "[ def : hs ]    if @xmath168 is v - shape s - dominating , then @xmath210 .",
    "[ lma : hs_s ]    directly from lemma [ lma : transit ] .",
    "let @xmath168 be v - shape s - dominating .",
    "following statements are true : ( 1 ) @xmath211 is v - shape s - dominating ; ( 2 ) @xmath212 is bitonic ; ( 3 ) @xmath213 .",
    "[ lma : dom ]    \\(1 ) let @xmath214 .",
    "first we show that @xmath98 is v - shaped .",
    "if @xmath98 is nonincreasing , then it is v - shaped .",
    "otherwise , let @xmath169 be the first index from the range @xmath215 , where @xmath216 .",
    "since @xmath217 and @xmath218 , thus @xmath219 .",
    "since @xmath168 is v - shaped , element @xmath220 must be in nondecreasing part of @xmath168 .",
    "it follows that @xmath221 and @xmath222 . from this",
    "we can see that @xmath223 @xmath224 , so @xmath225 . therefore @xmath98 is v - shaped .",
    "next we show that @xmath98 is s - dominating .",
    "consider any @xmath169 , where @xmath226 . by definition [ def : bit ] and",
    "[ def : sd ] : @xmath227 and @xmath187 , therefore @xmath228 , thus proving that @xmath98 is s - dominating . concluding : @xmath98 is v - shape s - dominating .",
    "\\(2 ) let @xmath229 .",
    "by lemma [ lma : hs_s ] : @xmath230 .",
    "we know that @xmath168 is a special case of bitonic sequence , therefore using lemma [ lma : split_bit ] we get that @xmath231 is bitonic .",
    "\\(3 ) let @xmath232 .",
    "by lemma [ lma : hs_s ] : @xmath233 .",
    "we know that @xmath168 is a special case of bitonic sequence , therefore using lemma [ lma : split_bit ] we get @xmath234 .    using @xmath235 and batcher s @xmath119 and successively applying lemma [ lma : dom ] to the resulting v - shape s - dominating half of the output , we have all the tools needed to construct the improved pairwise merger using half splitters :    input : @xmath101 , where @xmath104 is top @xmath1 sorted and @xmath105 is top @xmath99 sorted and @xmath103 dominates @xmath102 .    1 .",
    "compute @xmath165 , let @xmath166 .",
    "2 .   compute @xmath236 : 1 .   if @xmath162 , return .",
    "2 .   let @xmath237 .",
    "recursively compute @xmath238 .",
    "4 .   compute @xmath239 .",
    "5 .   return @xmath240 .",
    "[ net : pw_merge2 ]    the following theorem states that the construction of @xmath241 is correct .",
    "the output of network [ net : pw_merge2 ] consists of sorted @xmath1 largest elements from input @xmath101 , assuming that @xmath104 is top @xmath1 sorted and @xmath105 is top @xmath99 sorted and @xmath103 dominates @xmath102 .",
    "also @xmath242 .",
    "[ thm : pw_bit_merge ]    since step 1 in network [ net : pw_merge2 ] is the same as in network [ net : pw_merge ] , we can reuse the proof of theorem [ thm : pw_merge ] to deduce , that @xmath168 is v - shaped and is containing @xmath1 largest elements from @xmath101 .",
    "also , since @xmath186 @xmath243 and @xmath244 , then @xmath245 , so @xmath168 is s - dominating .",
    "we prove by the induction on @xmath1 , that if @xmath168 is v - shape s - dominating , then the sequence @xmath236 is sorted . for the base case ,",
    "consider @xmath162 and a v - shape s - dominating sequence @xmath246 . by definition [ def : sd ] this sequence",
    "is already sorted and we are done . for the induction step ,",
    "consider @xmath247 . by lemma [ lma : dom ]",
    "we get that @xmath248 is v - shape s - dominating and @xmath249 is bitonic . using the induction hypothesis we sort @xmath248 and using bitonic merger we sort @xmath249 . by lemma",
    "[ lma : dom ] : @xmath250 , which completes the proof of correctness .",
    "as mentioned in definition [ def : hs ] : @xmath209 is just @xmath251 with the first @xmath208 comparators removed .",
    "so @xmath252 is just @xmath154 with some of the comparators removed .",
    "let s count them : in each level of recursion step we take half of comparators from @xmath251 and additional one comparator from the base case ( @xmath162 ) .",
    "we sum them together to get :    @xmath253    therefore we have :    @xmath254    the only difference between @xmath255 and our @xmath256 is the use of improved merger @xmath257 rather than @xmath258 . by theorem [ thm : pw_bit_merge ] , we conclude that @xmath259 , so it follows that :    @xmath260",
    "in this section we estimate the size of @xmath261 . to this end",
    "we show that the size of @xmath261 is upper - bounded by the size of @xmath76 and use this fact in our estimation .",
    "we also compute the exact difference between sizes of @xmath44 and @xmath261 and show that it can be as big as @xmath262 .",
    "finally we show graphically how much smaller is our selection network on practical values of @xmath0 and @xmath1 .",
    "we have the recursive formula for the number of comparators of @xmath261 :    @xmath263    @xmath264 .",
    "[ lma : xyz ]    let @xmath265 be the comparator network that is generated by substituting recursive calls in @xmath261 by calls to @xmath76 .",
    "size of this network ( for @xmath266 ) is :    @xmath267    lemma [ lma : xyz ] follows from lemma [ lma : main1 ] and lemma [ lma : main2 ] below , where we show that :    @xmath268    for @xmath269 ( both powers of 2 ) , @xmath270 .",
    "[ lma : main1 ]    we compute both values from equations [ eq : bit ] and [ eq : aux ] :    @xmath271    we simplify both sides to get the following inequality :    @xmath272    which can be easily proved by induction .    for @xmath273 ( both powers of 2 ) ,",
    "[ lma : main2 ]    by induction . for the base case ,",
    "consider @xmath275 .",
    "if follows by definitions that @xmath276 . for the induction step assume that for each @xmath277 ( in lexicographical order ) the lemma holds , we get :    @xmath278    let @xmath279 and @xmath280",
    "we will compute upper bound for @xmath281 using @xmath282 .",
    "let :    @xmath283    then @xmath284 @xmath285 .",
    "[ lma : unfold ]    the lemma can be easily proved by induction on @xmath139 .",
    "[ lma : bigineq ]    first inequality below is a consequence of lemma [ lma : unfold ] and [ lma : xyz ] .",
    "we also use the following equations : @xmath287 , @xmath288 , @xmath289 .    @xmath290    @xmath291    @xmath292    @xmath293    @xmath294    for @xmath295 , @xmath296 @xmath297 .",
    "[ thm : upper - bound ]    directly from lemmas [ lma : unfold ] and [ lma : bigineq ] .",
    "we will now present the _ size difference _",
    "@xmath298 between pairwise selection network and our network .",
    "merging step in @xmath299 costs @xmath300 and in @xmath301 : @xmath302 , so the difference is given by the following equation :    @xmath303    let @xmath304 .",
    "then :    @xmath305    by straightforward calculation one can verify that @xmath306 , @xmath307 and @xmath308 .",
    "it follows that the theorem is true for @xmath309 and @xmath310 .",
    "we prove the theorem by induction on pairs @xmath311 .",
    "take any @xmath311 , @xmath312 , and assume that theorem holds for every @xmath313 ( in lexicographical order ) .",
    "then we have :    @xmath314    @xmath315 , for @xmath279 .",
    "plots in figure [ fig : prd ] show how much @xmath255 and the upper bound from theorem [ thm : upper - bound ] are worse than @xmath256 .",
    "lines labeled _ codish _ are plotted from @xmath316 and the ones labeled _ upper _ are plotted from the formula @xmath317 , where @xmath318 is the upper bound from theorem [ thm : upper - bound ] .",
    "both @xmath319 and @xmath320 were computed directly from recursive formulas .",
    "we can see that we save the most number of comparators when @xmath1 is larger than @xmath321 , nevertheless for small values of @xmath0 superiority of our network is apparent for any @xmath1 . as for the upper bound , it gives a good approximation of @xmath320 when @xmath0 is small , but for larger values of @xmath0 it becomes less satisfactory .",
    "in this section we prove that half encoding of any selection network preserves arc - consistency with respect to `` less - than '' cardinality constraints .",
    "the proof can be generalized to other types of cardinality constraints .",
    "we introduce the convention , that @xmath322 will denote the input and @xmath323 will denote the output of some order @xmath0 comparator network .",
    "we would also like to view them as sequences of boolean variables , that can be set to either true ( @xmath324 ) , false ( @xmath325 ) or undefined ( @xmath326 ) .    from now on",
    "we assume that every network @xmath66 is half encoded and when we say `` comparator '' or `` network '' , we view it in terms of cnf formulas .",
    "we denote @xmath327 $ ] to be the set of variables in encoding @xmath328 .    a single comparator @xmath74 has the following _ propagation properties _ :",
    "1 .   if @xmath329 or @xmath330 , then up sets @xmath331 ( by @xmath332 or @xmath333 ) .",
    "2 .   if @xmath334 , then up sets @xmath335 ( by @xmath332 and @xmath336 ) .",
    "3 .   if @xmath337 , then up sets @xmath338 ( by @xmath332 and @xmath333 ) .",
    "4 .   if @xmath330 and @xmath339 , then up sets @xmath340 ( by @xmath336 ) . 5 .   if @xmath329 and @xmath339 , then up sets @xmath341 ( by @xmath336 ) .",
    "[ obs : pprop ]    let @xmath48 be a selection network .",
    "assume that @xmath57 inputs are set to @xmath324 , and rest of the variables are undefined .",
    "unit propagation will set variables @xmath342 to @xmath324 .",
    "[ lma : fprop ]    from propagation properties of @xmath74 we can see that if comparator receives two @xmath324s , then it outputs two @xmath324s , when it receives @xmath324 on one input and @xmath326 on the other , then it outputs @xmath324 on the upper output and @xmath326 on the lower output . from this",
    "we conclude that a single comparator will sort its inputs , as long as one of the inputs is set to @xmath324 .",
    "no @xmath324 is lost , so they must all reach the outputs . because the comparators comprise a selection network , the @xmath324s will appear at outputs @xmath342 .",
    "the process of propagating @xmath324s we call a _ forward propagation_. for the remainder of this section assume that : @xmath48 is a selection network ; @xmath57 inputs are set to @xmath324 , and the rest of the variables are undefined ; forward propagation has been performed resulting in @xmath342 to be set to @xmath324 .    a _ path _ is a sequence of boolean variables @xmath343 such that @xmath344 $ ] and for all @xmath345 there exists a comparator @xmath74 in @xmath346 for which @xmath347 and @xmath348 .",
    "let @xmath50 be an undefined input variable .",
    "a path @xmath349 @xmath350 is a _ propagation path _ , if @xmath351 and @xmath352 is the sequence of variables that would be set to @xmath324 by up , if we would set @xmath353 .    if @xmath354 is a propagation path for an undefined variable @xmath50 , then @xmath355 .",
    "[ lma : prpp ]    remember that all @xmath342 are set to @xmath324 .",
    "setting any undefined input variable @xmath50 to @xmath324 will result in up to set @xmath59 to @xmath324 .",
    "otherwise @xmath48 would not be a selection network .",
    "the following lemma shows that propagation paths are deterministic .",
    "let @xmath354 be a propagation path .",
    "for each @xmath356 and @xmath357 , if @xmath358 is a path that would be set to @xmath324 by up if we would set @xmath359 , then @xmath360 .",
    "[ lma : hier ]    by induction on @xmath361 . if @xmath362 , then @xmath363 ( by lemma [ lma : prpp ] ) , so the lemma holds .",
    "let @xmath364 and assume that the lemma is true for @xmath365 .",
    "consider @xmath366 .",
    "set @xmath367 and use up to set @xmath368 .",
    "notice that @xmath369 , otherwise there would exist a comparator @xmath74 , for which @xmath370 is equivalent to either @xmath61 or @xmath62 and @xmath371 and @xmath372 ( or vice versa ) .",
    "that would mean that a single @xmath324 on the input produces two @xmath324s on the outputs .",
    "this contradicts our reasoning in the proof of lemma [ lma : fprop ] . by the induction hypothesis @xmath373 , so @xmath374 .    for each undefined input variable @xmath50 and propagation path @xmath354",
    "we define a directed graph @xmath375 .",
    "let @xmath376 ( @xmath377 ) be the set of undefined input variables .",
    "then @xmath378 is the tree rooted at @xmath59 .    by induction on @xmath379 .",
    "if @xmath380 , then @xmath381 and by lemma [ lma : prpp ] , @xmath382 ends in @xmath59 , so the lemma holds .",
    "let @xmath377 and assume that the lemma is true for @xmath379 .",
    "we will show that it is true for @xmath383 .",
    "consider @xmath384 . by the induction hypothesis @xmath385",
    "is a tree rooted at @xmath59 . by lemma [ lma : prpp ] , @xmath386 .",
    "let @xmath387 be the first variable , such that @xmath388 .",
    "since @xmath388 , there exists @xmath169 ( @xmath389 ) such that @xmath390 . by lemma [ lma : hier ] , starting from variable @xmath391 , paths @xmath392 and @xmath393 are identical .",
    "graph @xmath394 from the above lemma will be called a _ propagation tree_.",
    "if we set @xmath395 , then unit propagation will set all undefined input variables to @xmath325 .",
    "let @xmath394 be the propagation tree rooted at @xmath59 .",
    "we prove by induction on the height @xmath396 of @xmath394 , that ( * ) if we set root of @xmath394 to @xmath325 , then all nodes of the tree will be set to @xmath325 , thus all undefined input variables will also be set to @xmath325 . if @xmath397 , then @xmath398 , so ( * ) is trivially true .",
    "let @xmath399 and assume that ( * ) holds .",
    "we will show that ( * ) holds for height @xmath400 .",
    "let @xmath401 be the propagation tree of height @xmath400 and let @xmath402 be the root .",
    "consider children of @xmath403 in @xmath401 and a comparator @xmath74 for which @xmath404 :    case 1 : @xmath403 has two children .",
    "the only case is when @xmath405 .",
    "unit propagation sets @xmath338 .",
    "nodes @xmath61 and @xmath62 are roots of propagation trees of height @xmath396 and are set to @xmath325 , therefore by the induction hypothesis all nodes in @xmath401 will be set to @xmath325 .",
    "case 2 : @xmath403 has one child . consider two cases : ( i )",
    "if @xmath405 and either @xmath61 or @xmath62 is the child of @xmath403 , then up sets @xmath338 and either @xmath61 or @xmath62 is the root of propagation tree of height @xmath396 and is set to @xmath325 , therefore by the induction hypothesis all nodes in @xmath401 will be set to @xmath325 , ( ii ) @xmath406 and either @xmath407 and @xmath62 is the child of @xmath403 or @xmath408 and @xmath61 is the child of @xmath403 . both of them will be set to @xmath325 by up and again we get the root of propagation tree of height @xmath396 that is set to @xmath325 , therefore by the induction hypothesis all nodes in @xmath401 will be set to @xmath325 .",
    "we have constructed a new family of selection networks , which are based on the pairwise selection ones , but require less comparators to merge subsequences .",
    "the difference in sizes grows with @xmath1 and is equal to @xmath409 for @xmath7 .",
    "in addition , we have shown that any selection network encoded in a standard way to a cnf formula preserves arc - consistency with respect to a corresponding cardinality constraint .",
    "this property is important , as many sat - solvers take advantage of arc - consistency , making the computation significantly faster .",
    "it s also worth noting that using encodings based on selection networks give an extra edge in solving optimization problems for which we need to solve a sequence of problems that differ only in the decreasing bound of a cardinality constraint . in this",
    "setting we only need to add one more clause @xmath410 for a new value of @xmath1 , and the search can be resumed keeping all previous clauses as it is .",
    "this works because if a comparator network is a @xmath1-selection network , then it is also a @xmath411-selection network for any @xmath412 .",
    "this property is called _ incremental strengthening _ and",
    "most state - of - the - art sat - solvers provide a user interface for doing this ."
  ],
  "abstract_text": [
    "<S> selection comparator networks have been studied for many years . recently </S>",
    "<S> , they have been successfully applied to encode cardinality constraints for sat - solvers . to decrease the size of generated formula </S>",
    "<S> there is a need for constructions of selection networks that can be efficiently generated and produce networks of small sizes for the practical range of their two parameters : @xmath0  the number of inputs ( boolean variables ) and @xmath1  the number of selected items ( a cardinality bound ) . in this paper </S>",
    "<S> we give and analyze a new construction of smaller selection networks that are based on the pairwise selection networks introduced by codish and zanon - ivry . </S>",
    "<S> we prove also that standard encodings of cardinality constraints with selection networks preserve arc - consistency . </S>"
  ]
}