{
  "article_text": [
    "business transactions involve multiple partners coordinating and interacting with each other .",
    "these transactions have hierarchies of activities that need to be orchestrated .",
    "business transactions also need to deal with faults that can arise at any stage of the transactions .",
    "compensation mechanisms  @xcite are very important for handling faults for transactions that require a long period of time ( also called _ long running transaction _ , lrt ) .",
    "process calculi are models or languages for concurrent and distributed interactive systems . based on the framework of hoare s csp process algebra  @xcite , butler  _ et al _",
    "@xcite introduced compensating csp , a language to model long running transactions .",
    "the language introduces a method to declare a transaction as a process and it has constructs for orchestration of compensations .    a formal semantics offers a complete , rigorous definition of a language and provides a foundation for mathematical proofs about programs",
    "we have defined both traces  @xcite and operational semantics  @xcite of the language .",
    "having two semantic models of a language , it is natural to verify the consistency between them and check how they are related .",
    "we have defined a relationship between the semantic models in  @xcite by following a systematic approach .",
    "synchronization is an important and well understood feature for concurrent and distributed processes .",
    "however , synchronization was not included in our work . in this paper",
    ", we extend the ccsp semantic models to define the semantics for synchronous processes , where processes synchronize over a set of synchronizing events , and non - synchronizing processes interleave with each other .",
    "we also show that the same relationship that was defined for asynchronous processes also hold for synchronous processes .",
    "we take our work one step further by mechanical verifying the relationship by using the theorem prover pvs  @xcite .",
    "mechanical verification overcomes the problem in hand proofs , also identifies potential flaws in the semantic definitions .",
    "the rest of the paper is organized as follows .",
    "a brief overview of ccsp language is given in ",
    "[ sec : ccsp ] .",
    "we then describe how the language terms are extended to define synchronization of processes in   [ sec : synch ] .",
    "we also give an example of a web service specified by using ccsp and using the extended feature of synchronization . in the following two sections ,",
    "we define how the trace and the operational semantics are extended to synchronization .",
    "  [ sec : relation ] defines a relationship between the semantic models and sketches the proof steps .",
    "we describe the pvs embedding of ccsp syntax and semantics in   [ sec : mechanize ] .",
    "these embeddings are then used to establish the relationship between the synchronous semantic models .",
    "we outline some complimentary work in the following section .",
    "finally , we draw our conclusions in   [ sec : conclusion ] .",
    "processes in ccsp are modelled in terms of the atomic events they can engage in .",
    "the language provides operators that support sequencing , choice , parallel composition of processes . in order to support",
    "failed transaction , compensation operators are introduced .",
    "the processes are categorized into _ standard _ , and _",
    "compensable _ processes .",
    "compensation is part of a compensable process that is used to compensate a failed transaction .",
    "we use notations , such as , @xmath0 to identify standard processes , and @xmath1 to identify compensable processes .",
    "the asynchronous subset of ccsp syntax is summarized in fig .",
    "[ fig : syntax ] .",
    "the basic unit of the standard processes is an atomic event ( @xmath2 ) .",
    "the other operators are the sequential  ( @xmath3 ) , and the parallel composition ( @xmath4 ) , the choice operator ( @xmath5 ) , the interrupt handler ( @xmath6 ) , the empty process @xmath7 , raising an interrupt @xmath8 , and yielding to an interrupt @xmath9 . a process that is ready to terminate is also willing to yield to an interrupt .",
    "in a parallel composition , throwing an interrupt by one process synchronizes with yielding in another process . the basic way of constructing a compensable process is through a compensation pair ( @xmath10 ) , which is constructed from two standard processes , where @xmath11 is called the _ forward _ behaviour that executes during normal execution , and @xmath12 is the associated compensation that is designed to compensate the effect of @xmath11 when needed .",
    "the sequential composition of compensable processes is defined in such a way that the compensations of the completed tasks will be accumulated in reverse to the order of their original composition , whereas compensations from the compensable parallel processes will be placed in parallel . by enclosing a compensable process @xmath13 inside a transaction block @xmath14}$ ]",
    ", we get a complete transaction and the transaction block itself is a standard process .",
    "successful completion of @xmath13 represents successful completion of the block .",
    "but , when the forward behaviour of @xmath13 throws an interrupt , the compensations are executed inside the block , and the interrupt is not observable from outside of the block .",
    "@xmath15 , and @xmath16 are the compensable counterpart of the corresponding standard processes and they are defined by pairing an empty compensation with them , e.g. , @xmath17 .",
    "we define a parallel operator synchronizing over observable events ] extending our earlier definition , where processes interleave over observable events and synchronize only over terminal events ] .",
    "we assume a set of events @xmath18 over which processes will synchronize .",
    "the process @xmath19 represents the parallel composition of processes @xmath11 and @xmath12 , synchronizing over the set of events @xmath18 .",
    "operationally , @xmath11 and @xmath12 interact by synchronizing over the events from @xmath18 , while events not in @xmath18 can occur independently .",
    "an event where both processes synchronize becomes a single event in ( @xmath20 ) , by a synchronizing operator which will be defined later . in the following example",
    "a business transaction is modelled by ccsp constructs added with synchronization :    * example : _ ( car broker web services ) _ *   we model a car broker web service * broker * which provides online support to customers to negotiate car purchases and arranges loans for these",
    ". the architectural view of the web service is given in fig .",
    "[ fig : carbroker ] .        in ccsp , a process is described in terms of its interactions with its environment or with other processes by using atomic actions .",
    "the communications are defined via channels as in standard csp .",
    "a communication is an event described by the pair @xmath21 , where @xmath22 is the channel name and @xmath23 is the value of the message .",
    "input / output are defined using same construct as in csp .",
    "concurrent processes communicate via channels .",
    "we also use i / o parameters for compensation pair : @xmath24    the first step of the transaction is a compensation pair , where the primary action is to receive an order from the buyer and the compensation is to cancel the order .",
    "@xmath25 is used to represent the finite set of car models ranged over by @xmath26 .",
    "the * broker * requests the * supplier * for available quotes ( _ rfq _ ) and then selects a quote from the received quotes ( _ quote _ ) .",
    "the * broker * arranges a loan for the quoted car by requesting a loan from * loanstar*. the loan amount ( @xmath27 ) of loan to be requested is decided from the selected quote and passed to the process * loan*. it requests loan from * loanstar * which is either accepted or rejected . if the loan can not be provided then an interrupt is thrown to cancel the actions that have already taken place .",
    "a compensation is added to _ reqloan _ ( _ cancelloan _ ) so that in the case of failure in a later stage the compensation can be invoked to cancel the event .",
    "the quote is also sent to the buyer ( * sendquote * ) .",
    "an interrupt can be raised either by the * buyer * by rejecting the quote or by the * loanstar * by rejecting the requested loan . in either case , the * supplier * will terminate yielding an interrupt thrown by the * broker * and compensations from both * broker * and * supplier * will run in parallel .",
    "the behaviour of the car broker web service is defined by combining the behaviour of * broker , buyer , supplier * , and * loanstar * , where the processes synchronize over the sets @xmath28 and @xmath29 .",
    "@xmath30\\\\   & &    \\parallel_{c } { \\bf loanstar}\\end{aligned}\\ ] ] @xmath31    the example illustrates the synchronization of processes within a transaction block , @xmath32}$ ] and between transaction blocks ( * buyer * and * loanstar * are transaction blocks ) .",
    "it also outlines how compensations are handled in each case .",
    "a trace records the behaviour of a process up to some moment in time .",
    "the traces of composite processes are defined in terms of their constituent processes .",
    "processes are assumed to have an alphabet of actions @xmath33 which does not include the terminal events @xmath34 .",
    "terminal symbols indicate the way how a process terminates .",
    "standard processes are defined as non - empty set of traces of the form @xmath35 where @xmath36 and @xmath37 . for traces @xmath38 and @xmath39 , we write @xmath40 as their concatenation .",
    "operators are first defined on traces and then lifted to set of traces to define processes .",
    "the traces of a standard process @xmath11 is denoted as @xmath41 .",
    "compensable processes consist of a set of pair of traces of the form @xmath42 , where @xmath43 represents the forward behaviour and @xmath44 represents the compensation .",
    "@xmath45 denotes the trace of a compensable process @xmath13 .",
    "parallel processes synchronize over synchronizing events and interleave over other events . when processes fail to synchronize , the execution blocks and we get a partial behaviour from the composition .",
    "to denote partial behaviour , we assume a special terminal symbol @xmath46 which indicates partial trace .",
    "partial traces are analogous to trace prefixes in standard csp . with the definition of partial behaviour , traces from standard processes satisfy the following properties :    * @xmath47 * @xmath48  ( @xmath49 )    we assume @xmath50 acts as a cut for trace concatenation : @xmath51 . with the introduction of the new terminal event ( @xmath50 ) , we extend the original trace definitions .",
    "the extended trace definitions for sequential operators are defined in fig .",
    "[ fig : trace ] .",
    "we define a synchronization operator on events writing @xmath52 for the synchronization of events @xmath2 and @xmath53 .",
    "consider two processes synchronizing over events @xmath54 and @xmath55 , the synchronization is defined as : @xmath56 , and @xmath57 when @xmath58 and do not synchronize with each other .",
    "we define a synchronization operator over terminal events from the set @xmath59 .",
    "table  [ tab : synch ] enumerates the evaluation of this operator .",
    "we also define the synchronization operator to be commutative . from table  [",
    "tab : synch ] it can be seen that the operator is well - defined for all the operands in the set @xmath59 .",
    "case analysis shows that the synchronization operator is associative .",
    "@xmath60    assuming @xmath61 and @xmath62 , the parallel composition of traces from standard processes are defined as follows : @xmath63      \\trace{b}p   \\parallel_{x } \\trace{\\omega } & ~~=~~ &          \\set{~\\trace{b}r ~|~ r\\in ( p\\parallel_{x } \\trace{\\omega})~ }          \\\\      \\trace{b}p    \\parallel_{x } \\trace{a}q   & ~~=~~ &           \\set{~\\trace{b}r ~|~ r \\in ( p \\parallel_{x } \\trace{a}q)~ }           \\\\      \\trace{b}p   \\parallel_{x } \\trace{b'}q   & ~~=~~ &           \\set{~\\trace{b}r ~|~ r \\in ( p \\parallel_{x } \\trace{b'}q)~ }           \\\\     & &   \\cup~ \\set{~\\trace{b'}r ~|~ r \\in ( \\trace{b}p \\parallel_{x } q)~ } \\end{array}\\end{aligned}\\ ] ] the parallel and synchronization operators are symmetric . for brevity we omit the symmetric cases . the parallel composition of standard processes is defined as follows : @xmath64    with the definition of partial behaviour ( @xmath50 ) , a pair of traces ( @xmath65 ) of a compensable process satisfies the following properties : for @xmath49 ,    * @xmath66 * @xmath67 * @xmath68    the trace semantics for compensable parallel processes is defined as follows : + @xmath69 + @xmath70{r } \\set{(r , r')|r\\in ( p\\parallel_x q )     \\land r'\\in(p'\\parallel_x q')\\land last(r)\\neq\\bot}\\\\[.5ex ]     \\cup\\ ; \\{(r,\\trace{\\bot})| r\\in ( p\\parallel_x q)\\land     last(r)= \\bot\\ }     \\end{array}$ ] @xmath71 @xmath72 returns the terminal symbol from a trace @xmath39 .",
    "the operational semantics are defined by using labelled transition systems  @xcite .",
    "inference rules are used to define the transitions that a process may perform , which for composite processes are given in terms of the possible transition of the constituents ( see  @xcite for detail ) .",
    "two types of transition rules are defined : normal and terminal .",
    "normal transition is caused by a normal event resulting in a transition of a process term from one state to another .",
    "terminal transition is caused by a terminal event where standard process terms terminate to a null process and the forward behaviour of compensable process terms terminate leaving the attached compensation for future reference .",
    "note that the language terms are extended to define the null ( 0 ) process that can not perform any action . for standard and compensable process terms @xmath11 and @xmath13 ( where @xmath73 ) , the normal and terminal transitions are defined as followed :    @xmath74    we extend the transition rules by defining the transitions by a @xmath50 where both standard and compensable processes terminate to a null process . for any process terms @xmath11 and @xmath13 ( where @xmath73 ) , the transitions by a @xmath50 are defined as follows : @xmath75    the transition rules defined in equation  ( [ eqn : bot ] ) cover the transitions for both standard and compensable process terms by the @xmath50 .",
    "hence we do not need to define additional transition rules by a @xmath50 .",
    "the transition rules for sequential standard and compensable processes are defined in fig .",
    "[ fig : os - std ] and fig .",
    "[ fig : os - comp ] respectively .    as @xmath50 is introduced during process synchronization and @xmath50 is a useful semantic device that helps us deriving semantic correspondence , we define the extended transition rules for parallel processes and define those transitions that introduce a @xmath50 . for a compensable process the transition by a @xmath50 lead to a null process and according to our definition no compensations are stored ( being partial behaviour ) .",
    "the transition rules for standard and compensable parallel processes are shown in fig .",
    "[ fig : synch - op ] and fig .",
    "[ fig : csyn - op ] respectively .",
    "over the years , several techniques have been used to establish relationship between different semantic models .",
    "widely used techniques are deriving one semantics from another ( e.g.@xcite ) , extracting the behaviour from one semantic model and showing its relation with another ( e.g.@xcite ) etc .",
    "roscoe  @xcite outlines how to define the semantic relationship for csp . in our earlier work",
    "@xcite , we have adopted a systematic approach showing a relationship between the semantic models .",
    "traces are extracted from the transition rules of the operational semantics and show that the extracted traces correspond to the original traces for each term of the language and finally , prove the correspondence by structural induction over the process terms .",
    "the steps are depicted in fig .",
    "[ fig : proof - steps ] .    in this paper , we extend our earlier approach to define and prove the relationship between the synchronous semantic models . due to the introduction of partial behaviour , proving",
    "the correspondence for synchronous semantic modes becomes critical .",
    "we briefly describe the steps shown in fig .",
    "[ fig : proof - steps ] for asynchronous processes and extend those steps for synchronous processes .",
    "the operational semantics leads to lifted transition relations labelled by sequences of events .",
    "this is defined recursively . for a standard process",
    "@xmath11 : @xmath76      p{\\stackrel{\\trace{a}t}{\\longrightarrow}}q & ~=~ & \\exists p'\\cdot      p{\\stackrel{a}{\\longrightarrow}}p'~\\land~p'{\\stackrel{t}{\\longrightarrow}}q\\end{aligned}\\ ] ] for a standard process @xmath11 , the derived trace @xmath77 is defined as follows :    [ def1 ] for a trace @xmath39 , @xmath78    for compensable processes , it is required to extract traces from both forward and compensation behaviour .",
    "first , we define the lifted forward behaviour and then add the behaviour of compensation by reusing the above definition . for a compensable process",
    "@xmath13 , we get the following definition :    [ def2 ] for traces @xmath39 and @xmath79 , @xmath80    finally , the semantic relationship is defined as follows :    [ th1 ] for a standard process term @xmath11 ( @xmath81 ) , @xmath82 for a compensable process terms @xmath13 , where @xmath83 @xmath84    the theorem is proved by showing that @xmath85 we apply induction over process terms and define supporting lemmas for the structural cases .",
    "traces are extracted for each term of the language and show their correspondence with the original trace semantics . for standard processes , @xmath11 and @xmath12 ,",
    "for all the operators , we show that , @xmath86 for each such operator @xmath87 , the proof is performed by induction over traces assuming @xmath88 , and @xmath89 . for compensable processes , @xmath13 and @xmath90 , we show , @xmath91    consider the sequential composition of processes @xmath11 and @xmath12 . by using  ( [ eq1 ] ) ,",
    "the semantic relationship is shown by , @xmath92 from def .",
    "[ def1 ] , we get the following equation , @xmath93 we also expand the definition of trace semantics as follows : @xmath94 finally , from the above definitions of traces , the following lemma is formulated for the sequential composition of standard processes :    [ lem : stseq ]   + @xmath95    the lemma is proved by applying induction over the trace @xmath39 , where @xmath96 is the base case , and @xmath97 is the inductive case .",
    "similarly , the supporting lemmas for all the other terms of the language are defined and proved .    for synchronous processes , we follow the same approach added with the newly defined @xmath50 event . with the introduction of partial behaviour ,",
    "the definition of derived traces remains the same except for the compensable processes . for a pair of traces ( @xmath39 and @xmath79 ) , the derived traces of synchrnous compensable processes is defined as follows : @xmath98    considering theorem  [ th1 ] , for synchronous processes we prove the following lemma :    for standard process terms @xmath11 and @xmath12 , @xmath99 for compensable process terms @xmath13 and @xmath90 , @xmath100    by following the approach shown earlier we formulate the following lemma for standard processes :    [ lema : synstd ] @xmath70{rl } ( p~\\parallel_{x}~q){\\stackrel{t}{\\longrightarrow}}0 ~= &        \\exists p , q\\cdot t\\in(p~\\parallel_{x}~q)\\\\        & \\land p{\\stackrel{p}{\\longrightarrow}}0~\\land~q{\\stackrel{q}{\\longrightarrow}}0        \\end{array}$ ]    based on the scenario when synchronizing processes fail to synchronize and return partial behaviour , we state two separate lemmas .",
    "first , we assume that there is no failure during the synchronization of processes :    [ lem : nondead ] @xmath70{l }   ( pp\\parallel_x qq){\\stackrel{t}{\\longrightarrow}}r ~=~\\\\[.5ex ]    \\exists p , q , p , q \\cdot t\\in ( p\\parallel_x q ) \\land last(t)\\neq \\bot\\\\[.5ex ]      \\land   pp{\\stackrel{p}{\\longrightarrow}}p\\land qq{\\stackrel{q}{\\longrightarrow}}q \\land r~=~(p\\parallel_x q ) \\end{array}$ ]    the following lemma is defined for the cases when the synchronizing processes fail to synchronize :    [ lem : dead ]   + @xmath101      & \\land   p\\in",
    "t(pp ) \\land q\\in t(qq )      \\end{array}$ ]    in earlier work  @xcite , we have shown how to mechanically proof the relationship between the asynchronous semantic models by embedding the ccsp syntax and semantic models into the theorem prover pvs , where the mechanical proofs have followed the similar proof steps as in hand proofs shown in  @xcite .",
    "after extending the semantic models to synchronization , instead of proving the relationship by hand , we directly prove them by using pvs .",
    "in the following section , we describe how we define and prove the semantic relationship for synchronous models by extending the asynchronous embeddings in pvs .",
    "an embedding is a semantic encoding of one specification language into another , especially , to reuse the existing tools of the target language",
    ". mechanization steps of synchronous processes are outlined in this paper .",
    "detail mechanization steps are described in  @xcite .",
    "pvs mechanization steps are sketched in fig .",
    "[ fig : pvs - steps ] .",
    "first , we define the ccsp syntax .",
    "separate notation is used to define the standard and compensable processes . as pvs supports overloading ,",
    "same notations can be used for the operational and the trace semantics .",
    "[ fig : syntax - pvs ] summarizes the pvs definition of asynchronous subset of ccsp syntax .",
    "the syntax is then extended to define the terms for synchronization . to denote the trace semantics , we write ` full_parallel(x)(p , q ) ` ( @xmath102 ) for standard processes and ` cfull_parallel(x)(pp , qq ) ` ( @xmath103 ) for compensable processes .",
    "proofs about properties of a process algebra often use induction on the structure of the algebra .",
    "pvs has a mechanism called abstract datatype  @xcite , for which pvs generated an induction scheme , and it is convenient to model process algebra terms as an abstract datatype .",
    "ccsp has standard , and compensable process terms and importantly , these process terms are mutually dependant on each other .",
    "mutually recursive datatype is not directly admissible by pvs .",
    "however , pvs has an extended support of _ sub - datatype _",
    "@xcite , where it is possible to define two mutually recursive datatypes as a single datatype .",
    "a sub - datatype collects together groups of constructors of a datatype that form one part of a mutually recursive datatype definition . by using this facility",
    "we define ccsp process algebra terms as follows :    pa_terms : datatype with subtypes stand , comp begin skip : skip ? : stand choice(p : stand , q : stand ) : choice ? : stand seq(p : stand , q : stand ) : seq ? : stand |>(p : stand , q : stand ) : inthnd ? : stand cseq(pp : comp , qq : comp ) : c_seq ? : comp cchoice(pp : comp , qq : comp ) : c_choice ? : comp cpair(p : stand , q : stand ) : cpair ? : comp blk(pp : comp ) : blk ? : stand synpara(x : setof[normal],p : stand , q : stand ) : synpara ? : stand csynpara(x : setof[normal],pp : comp , qq : comp ) : csynpara ? : comp ... end pa_terms    ` synpara ` and ` csynpara ` are the extended definitions for the synchronous process terms .",
    "we define a single datatype ` pa_terms ` that consists of two sub - datatypes : `` stand ` ' for standard processes , and `` comp ` ' for compensable processes .",
    "we can now define processes of types `` stand ` ' and `` comp ` ' .",
    "the trace semantics are defined in pvs in the same way as they are originally defined .",
    "operators are first defined at the trace level , and then lift to the sets of traces to define the processes . the same approach is taken for both standard , and compensable processes . for synchronous processes ,",
    "we first define the synchronization of terminal evens shown in table  [ tab : synch ] by extending the asynchronous definition ( ` parallel ` ) .",
    "syn_parallel(w3:terminal)(w1,w2:terminal):bool= if w3 = bottom then w1 = bottom or w2 = bottom else parallel(w3)(w1,w2 ) endif    the trace semantics for synchronous processes are then defined by following the definitions shown in sec .",
    "[ sec : trace ] .",
    "first we define operators over traces then lift it over set of traces to define processes .",
    "the trace semantics of both standard and compensable processes are defined in pvs as follows :    full_parallel(x)((s1,w1))((s2,w2))((s3,w3)):recursive bool= cases s3 of null : null?(s1 ) and null?(s2 ) and syn_parallel(w3)(w1,w2 ) or cons?(s1 ) and x(car(s1 ) ) and null?(s2 ) and w3 = bottom or cons?(s2 ) and x(car(s2 ) ) and null?(s1 ) and w3 = bottom or cons?(s1 ) and x(car(s1 ) ) and cons?(s2 ) and x(car(s2 ) ) and car(s1 ) /=",
    "car(s2 ) and w3 = bottom , cons(a , tail ) : if x(a ) then cons?(s1 ) and cons?(s2 ) and car(s1 ) = a and car(s2 ) = a and full_parallel(x)((cdr(s1),w1))((cdr(s2),w2))((tail , w3 ) ) else cons?(s1 ) and car(s1 ) = a and full_parallel(x)((cdr(s1),w1))((s2,w2))((tail , w3 ) ) or cons?(s2 ) and car(s2 ) = a and full_parallel(x)((s1,w1))((cdr(s2),w2))((tail , w3 ) ) endif endcases measure length(s3 ) full_parallel(x)(p , q : process ) : process = t : trace    and t = ( s3,w3 ) and full_parallel(x)((s1,w1))((s2,w2))((s3,w3 ) )    cfull_parallel(x)((p , p1))((q , q1))((r , r1 ) ) : bool = ( full_parallel(x)(p)(q)(r ) and full_parallel(x)(p1)(q1)(r1 ) and r2 /= bottom ) or full_parallel(x)(p)(q)(r ) and r2 = bottom and null?(r11 ) and r12 = bottom cfull_parallel(x)(pp , qq : comp_process):comp_process= tt : comp_trace | exists ( pp:(pp),qq:(qq ) ) : cfull_parallel(x)(pp)(qq)(tt )    we represent traces as a pair : ` ( s , w ) ` , where ` s ` is the sequence of normal events and ` w ` is the terminal event .",
    "the operational semantics is defined by using labelled transition systems of the form @xmath104 , where the event @xmath105 makes the transition of the process term from state @xmath11 to @xmath106 .",
    "two types of transitions are defined : normal , and terminal .",
    "both transition rules are defined by using a recursive boolean definition that determines whether there is a transition from one state to another state .",
    "the definitions are given by using equations derived from the transition rules .",
    "the transition rules of some process terms depend on the transition rules of both standard and compensable processes . to define these rules",
    ", we need to combine the transition rules for both standard and compensable processes .",
    "the terminal transition for the process terms are defines as ` wtrans ` and the normal transitions are defined as ` ntrans ` ( see  @xcite,@xcite for details ) .",
    "we then define the transition rules for synchronous processes by following the definitions given in fig .",
    "[ fig : synch - op ] and [ fig : csyn - op ] .    in a normal transition , processes either synchronize or interleave . by extending the transition rules of asynchronous processes we defne the transition rules for synchronous processes as follows :    synpara(x , q , r ) : if x(a ) then exists q1,r1 : ntrans(a)(q , q1 ) and ntrans(a)(r , r1 ) and pa1 = synpara(x , q1,r1 ) else exists q1 : ntrans(a)(q , q1 ) and pa1 = synpara(x , q1,r ) or exists r1 : ntrans(a)(r , r1 ) and pa1 = synpara(x , q , r1 ) endif csynpara(x , qq , rr ) : if x(a ) then exists qq1,rr1:ntrans(a)(qq , qq1 ) and ntrans(a)(rr , rr1 ) and pa1 = csynpara(x , qq1,rr1 ) else exists qq1:ntrans(a)(qq , qq1 ) and pa1 = csynpara(x , qq1,rr ) or exists rr1:ntrans(a)(rr , rr1 ) and pa1= csynpara(x , qq , rr1 )    the terminal transitions are defined as follows :    synpara(x , q , r ) : exists w1,w2 :",
    "syn_wtrans(w1)(q , nul ) and syn_wtrans(w2)(r , nul ) and syn_parallel(w)(w1,w2 ) and p1 = nul or exists ( a : normal , w1,q1 ) : x(a ) and ntrans(a)(q , q1 ) and syn_wtrans(w1)(r , nul ) and w = bottom and p1 = nul or exists ( a : normal , w1,r1 ) : x(a ) and ntrans(a)(r , r1 ) and syn_wtrans(w1)(q , nul ) and w = bottom and p1 = nul or exists ( a1,a2:normal , q1,r1 ) : x(a1 ) and x(a2 ) and a1 /= a2 and ntrans(a1)(q , q1 ) and ntrans(a2)(r , r1 ) and w = bottom and p1 = nul , csynpara(x , qq , rr ) : exists q1,r1,w1,w2 : syn_wtrans(w1)(qq , q1 ) and syn_wtrans(w2)(rr , r1 ) and syn_parallel(w)(w1,w2 ) and w /= bottom and p1 = synpara(x , q1,r1 ) or exists ( a : normal , w1,qq1,r1 ) : x(a ) and ntrans(a)(qq , qq1 ) and syn_wtrans(w1)(rr , r1 ) and w = bottom and p1= nul or exists ( a : normal , w1,q1,rr1 ) : x(a ) and syn_wtrans(w1)(qq , q1 ) and ntrans(a)(rr , rr1 ) and w = bottom and p1 = nul or exists ( a1,a2:normal , qq1,rr1 ) : x(a1 ) and x(a2 ) and a1 /= a2 and ntrans(a1)(qq , qq1 ) and ntrans(a2)(rr , rr1 ) and w = bottom and p1 = nul      by following def",
    ".  [ def1 ] , the derived traces for standard processes are defined as `` trans_trace ` ' .",
    "it defines the transition of a process by a trace consisting of a transition by a sequence of normal events followed by transition by a terminal event .",
    "consider a trace @xmath39 , where @xmath107 .",
    "@xmath108    we then define lemma  [ lema : synstd ] by using the definition of both derived traces and trace rules as follows :    .... synpara_lemma : lemma    trans_trace((s , w))(synpara(x , p , q),nul ) =     exists ( s1,w1,s2,w2 ) :      full_parallel(x)((s1,w1))((s2,w2))((s , w ) ) and      trans_trace((s1,w1))(p , nul )                and      trans_trace((s2,w2))(q , nul ) ....    for compensable processes , we only need to prove that the lifted forward behaviour corresponds to the original traces and reuse the proofs of standard processes for compensations . the definition of derived traces shown in def .  [ def2 ]",
    "consists of the derived trace of both forward and compensation behaviour . to prove our lemmas ( lemma  [ lem : nondead ] and [ lem : dead ] ) we only need to define the forward behaviour and it is defined as ` ftrans_trace ` ( @xmath109 ) .",
    "first , we define the lemma considering the processes will not fail to synchronize and hence , there is no bottom event in the derived traces :    .... csynpara_lemma : lemma   ftrans_trace((s , w))(csynpara(x , pp , qq),r ) =     exists ( s1,w1,s2,w2,p , q ) : w /= bottom and     full_parallel(x)((s1,w1))((s2,w2))((s , w ) ) and     ftrans_trace((s1,w1))(pp , p ) and     ftrans_trace((s2,w2))(qq , q ) and     r = synpara(x , p , q ) ....    next , we define the lemma where compensable processes fail to synchronize during their synchronization .",
    "the main difference is that the derived trace now ends with a @xmath50 representing the partial behaviour , and compensations are not accumulated after termination .    ....",
    "lema_bot : lemma   ftrans_trace((s , w))(csynpara(x , pp , qq),nul ) =    exists ( s1,w1,s2,w2,p , q ) :   w = bottom and     full_parallel(x)((s1,w1))((s2,w2))((s , w ) ) and     ftrans_trace((s1,w1))(pp , p )                and     ftrans_trace((s2,w2))(qq , q ) ....    all these lemmas are proved interactively by applying induction over traces ( ` ( s , w ) ` ) .",
    "pvs has a strong support for induction scheme which facilities proving such lemmas .",
    "one of the contributions most related to our work is by basten and hooman in  @xcite , where the focus is on the use of a general purpose proof checker , e.g. , tool support for the proof of theoretical properties of an acp - style process algebra  @xcite .",
    "the idea is to apply equational reasoning .",
    "mechanical support for both verification of concrete applications and proving theoretical properties of the process algebra are investigated .",
    "pvs has been used in  @xcite to mechanize the trace semantics of csp .",
    "their goal is to verify an authentication protocol specified in csp to overcome errors in the manual verification as well as improve the scalability of the approach .",
    "the mechanization is based on a semantic embedding of csp .",
    "the traces are defined by using a list of events and processes are defined by prefix - closed sets of traces .",
    "the important distinction with the present work is that ccsp traces are non - empty and completed and processes are defined accordingly .",
    "camilleri @xcite showed how to mechanize a subset of the csp operators by using the theorem prover hol @xcite .",
    "the trace model for a subset of the csp operators was mechanized in hol .",
    "initially , events , alphabets and traces are defined and then csp operators are defined in terms of their trace semantic models . and later laws related to the operators are proved from the sematic definition .",
    "in contrast to our approach no syntax is defined at this stage and operators are defined directly in hol .",
    "syntax is defined later and the semantics of the language is shown based on the already defined semantics .",
    "a similar work for the @xmath110-calculus can be found in  @xcite .",
    "one of our main goals is to explore the ways of incorporating process algebra in a general purpose theorem prover . in that respect , a closely related research on the tool support for a process algebra shown in @xcite , where a csp - like algebra , called di - algebra @xcite is formalized in hol .",
    "the algebra is used to reason about synchronous circuits .",
    "process syntax and algebraic laws are defined , but no semantics are defined .",
    "we have extended ccsp language to define synchronization .",
    "we introduced the notion of partial behaviour which allows to model the behaviour of synchronous processes that fail to synchronize .",
    "the formal foundation of the language is strengthen by establishing a relationship between the semantic models by showing that traces extracted from the operational semantics correspond to the original trace semantics . demonstrating the relationship between these two semantics of the ensures the consistency of the semantic description of the language .",
    "we have started mechanizing the semantic models and their relationship in order to investigate the feasibility of the mechanization process .",
    "we have achieved our goal by successfully proving the semantic relationship for the synchronous processes .",
    "defining process algebras in pvs is not new a new idea .",
    "the novelty of this experiment is that , we have not only defined the ccsp process algebra , and the two semantic models , but we have also mechanically proved a relationship between these semantic models .    in the hand proofs",
    ", it is easy to be imprecise about recursion , and typing of the rules .",
    "the mechanization forces to be strict about datatypes , and recursion .",
    "this helped us to define the theorems , and the lemmas in a systematic way , and to prove all the lemmas by following a similar fashion .",
    "the mechanization also helped us identifying some lemmas which were not explored earlier .",
    "the mechanization of the semantic models and their relationships also deepen our understanding of the semantic models for both standard and compensable processes .    having a firm grasp of the semantic models , we are now in a better position to extend the language by defining some important operators for the process algebra , such as event hiding , recursion , distinction between external and internal choice in combination with compensations . in standard csp ,",
    "the distinction between the two choice operators is achieved by using the failure / divergences model which can serve as the basis for our work on ccsp .",
    "our future plan also includes developing a tool support for ccsp which will allow model check as well as animate the specifications .",
    "the research has been carried out at the university of southampton , as a part of the first author s phd project .",
    "m.  butler , t.  hoare , and c.  ferreira , `` a trace semactics for long - running transaction , '' in _ proceedings of 25 years of csp _ , ser .",
    "lncs , a.  abdallah , c.  jones , and j.  sanders , eds .",
    "3525.1em plus 0.5em minus 0.4emlondon : springer - verlag , 2004 .",
    "m.  butler and s.  ripon , `` executable semantics for compensating csp , '' in _ ws - fm 2005 _ , ser .",
    "lncs , m.  bravetti , l.  kloul , and g.  zavattaro , eds .",
    ", vol . 3670.1em plus 0.5em minus 0.4emspringer - verlag , september 1 - 3 2005 , pp .",
    "243256 .",
    "s.  owre , j.  rushby , and n.  shankar , `` pvs : a prototype verification system , '' in _ 11th international conference on automated deduction ( cade ) _ , ser .",
    "lecture notes in artificial intelligence , d.  kapur , ed . , vol .",
    "607.1em plus 0.5em minus 0.4emspringer - verlag , june 1992 , pp . 748752 .",
    "n.  shankar and s.  owre , `` principles and pragmatics of subtyping in pvs . '' in _ recent trends in algebraic development techniques , 14th international workshop , wadt 99 _ , ser .",
    "lncs , d.  bert , c.  choppy , and p.  d. mosses , eds .",
    "1827.1em plus 0.5em minus 0.4emspringer - verlag , september 15 - 18 1999 , pp . 3752 .",
    "b.  dutertre and s.  schneider , `` using a pvs embedding of csp to verify authentication protocols , '' in _ theorem proving in higher order logics , 10th international conference , tphols97 _ , ser .",
    "lncs , e.  l. gunter and a.  p. felty , eds . ,",
    "1275.1em plus 0.5em minus 0.4em springer - verlag , 1997 , pp .",
    "121136 .",
    "r.  groenboom , c.  hendriks , i.  polak , j.  terlouw , and j.  t. udding , `` algebraic proof assistants in hol , '' in _",
    "mpc 95 : mathematics of program construction _ ,",
    "lncs , vol .",
    "947.1em plus 0.5em minus 0.4em springer - verlag , 1995 , pp . 304321 .    m.  b. josephs and j.  t. udding , `` an overview of di algebra . '' in _",
    "26th hawaii int .",
    "conference on system science ( hicss 1993 ) _ , t.  n. mudge , v.  milutinovic , and l.  hunter , eds .",
    "i.1em plus 0.5em minus 0.4emieee computer society press , 1993 , pp ."
  ],
  "abstract_text": [
    "<S> _ compensating csp _ ( ccsp ) is a language defined to model long running business transactions within the framework of standard csp process algebra . in earlier work , we have defined both traces and operational semantics of the language . </S>",
    "<S> we have shown the consistency between the two semantic models by defining a relationship between them . </S>",
    "<S> synchronization was missing from the earlier semantic definitions which is an important feature for any process algebra . in this paper </S>",
    "<S> , we address this issue by extending the syntax and semantics to support synchronization and define a relationship between the semantic models . </S>",
    "<S> moreover , we improve the scalability of our proof technique by mechanically verifying the semantic relationship using theorem prover pvs . we show how to embed process algebra terms and semantics into pvs and to use these embeddings to prove the semantic relationship . </S>",
    "<S> + _ keywords : _ compensating csp , synchronization , semantics , theorem proving , pvs . </S>"
  ]
}