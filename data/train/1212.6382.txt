{
  "article_text": [
    "a graph @xmath4 is outerplanar , if it has a planar embedding with all its vertices lying on the outer face . computing planar straight line drawings of planar graphs , with their vertices placed on a two dimensional grid , is a well known problem in graph drawing .",
    "the height of a grid is defined as the smaller of the two dimensions of the grid .",
    "if @xmath0 has a planar straight line drawing , with its vertices placed on a two dimensional grid of height @xmath5 , then we call it a planar drawing of @xmath0 of height @xmath5",
    ". it is known that any planar graph on @xmath6 vertices can be drawn on an @xmath7 sized grid @xcite .",
    "a well studied optimization problem in this context is to minimize the height of the planar drawing .",
    "pathwidth is a structural parameter of graphs , which is widely used in graph drawing and layout problems @xcite .",
    "we use @xmath8 to denote the pathwidth of a graph @xmath0 .",
    "the study of pathwidth , in the context of graph drawings , was initiated by dujmovic et al .",
    "it is known that any planar graph that has a planar drawing of height @xmath5 has pathwidth at most @xmath5 @xcite .",
    "however , there exist planar graphs of constant pathwidth but requiring @xmath9 height in any planar drawing @xcite . in the special case of trees , suderman @xcite showed that any tree @xmath10 has a planar drawing of height at most @xmath11 .",
    "biedl @xcite considered the same problem for the bigger class of outerplanar graphs . for any @xmath2-vertex - connected outerplanar graph @xmath0",
    ", biedl @xcite obtained an algorithm to compute a planar drawing of @xmath0 of height at most @xmath12 .",
    "since it is known that pathwidth is a lower bound for the height of the drawing @xcite , the algorithm given by biedl @xcite is a @xmath13-factor approximation algorithm for the problem , for any @xmath2-vertex - connected outerplanar graph .",
    "the method in biedl @xcite is to add edges to the @xmath2-vertex - connected outerplanar graph @xmath0 to make it a maximal outerplanar graph @xmath14 and then draw @xmath14 on a grid of height @xmath12 .",
    "the same method would give a constant factor approximation algorithm for arbitrary outerplanar graphs , if it is possible to add edges to an arbitrary connected outerplanar graph @xmath0 to obtain a @xmath2-vertex - connected outerplanar graph @xmath15 such that @xmath16 .",
    "this was an open problem in biedl @xcite .    in this paper",
    ", we settle this problem by giving an algorithm to augment a connected outerplanar graph @xmath0 of pathwidth @xmath1 by adding edges so that the resultant graph is a @xmath2-vertex - connected outerplanar graph of pathwidth @xmath3 .",
    "notice that , the non - triviality lies in the fact that @xmath15 has to be maintained outerplanar .",
    "( if we relax this condition , the problem becomes very easy .",
    "it is easy to verify that the supergraph @xmath15 of @xmath0 , obtained by making two arbitrarily chosen vertices of @xmath0 adjacent to each other and to every other vertex in the graph , is @xmath2-vertex - connected and has pathwidth at most @xmath17 .",
    ") similar problems of augmenting outerplanar graphs to make them @xmath2-vertex - connected , while maintaining the outerplanarity and optimizing some other properties , like number of edges added @xcite , have also been investigated previously .",
    "a _ tree decomposition _ of a graph @xmath4 @xcite is a pair @xmath18 , where @xmath10 is a tree and @xmath19 is a family of subsets of @xmath20 , such that :    1 .   @xmath21 .",
    "2 .   for every edge @xmath22 of @xmath0",
    "there exists @xmath23 such that @xmath22 has both its end points in @xmath24 .",
    "3 .   for every vertex @xmath25 , the induced subgraph of @xmath10 on the vertex set @xmath26 is connected .",
    "the width of the tree decomposition is @xmath27 .",
    "each @xmath28 is referred to as a bag in the tree decomposition . a graph @xmath0 has _ treewidth _",
    "@xmath29 if @xmath29 is the minimum integer such that @xmath0 has a tree decomposition of width @xmath29 .    a _ path decomposition _",
    "@xmath30 of a graph @xmath0 is a tree decomposition of @xmath0 with the additional property that the tree @xmath31 is a path .",
    "the width of the path decomposition is @xmath32 . a graph @xmath0 has _ pathwidth _",
    "@xmath29 if @xmath29 is the minimum integer such that @xmath0 has a path decomposition of width @xmath29 .    without loss of generality we can assume that , in any path decomposition @xmath33 of @xmath0 , the vertices of the path @xmath34 are labeled as @xmath35 , in the order in which they appear in @xmath34 .",
    "accordingly , the bags in @xmath36 also get indexed as @xmath35 . for each vertex @xmath37 , define @xmath38 contains @xmath39 , @xmath40 contains @xmath39 and @xmath41 $ ] . by the definition of a path decomposition , if @xmath42 , then @xmath43 . if @xmath44 and @xmath45 are two distinct vertices , define @xmath46 as follows :    * if @xmath47 , then @xmath48 . * if @xmath49 @xmath50 @xmath51 , then + @xmath52 $ ] . * if @xmath53 @xmath50 @xmath54 , then + @xmath55 $ ] .",
    "the motivation for this definition is the following .",
    "suppose @xmath33 is a path decomposition of a graph @xmath0 and @xmath44 and @xmath45 are two non - adjacent vertices of @xmath0 . if we add a new edge between @xmath44 and @xmath45 , a natural way to modify the path decomposition to reflect this edge addition is the following .",
    "if @xmath48 , there is already an @xmath28 , which contains @xmath44 and @xmath45 together and hence , we need not modify the path decomposition . if @xmath49 @xmath50 @xmath51 , we insert @xmath44 into all @xmath28 , such that @xmath56 . on the other hand , if @xmath53 @xmath50 @xmath54 , we insert @xmath45 to all @xmath28 , such that @xmath56 .",
    "it is clear from the definition of @xmath46 that this procedure gives a path decomposition of the new graph .",
    "whenever we add an edge @xmath57 , we stick to this procedure to update the path decomposition .",
    "a _ block _ of a connected graph @xmath0 is a maximal connected subgraph of @xmath0 without a cut vertex .",
    "every block of a connected graph @xmath0 is thus either a single edge which is a bridge in @xmath0 , or a maximal @xmath2-vertex - connected subgraph of @xmath0 .",
    "if a block of @xmath0 is not a single edge , we call it a non - trivial block of @xmath0 . given a connected outerplanar graph @xmath0 , we define a rooted tree @xmath10 ( hereafter referred to as the _ rooted block tree _ of @xmath0 ) as follows .",
    "the vertices of @xmath10 are the blocks of @xmath0 and the root of @xmath10 is an arbitrary block of @xmath0 which contains at least one non - cut vertex ( it is easy to see that such a block always exists ) . two vertices @xmath58 and @xmath59 of @xmath10 are adjacent if the blocks @xmath58 and @xmath59 share a cut vertex in @xmath0 .",
    "it is easy to see that @xmath10 , as defined above , is a tree . in our discussions , we restrict ourselves to a fixed rooted block tree of @xmath0 and all the definitions hereafter will be with respect to this chosen tree . if block @xmath58 is a child block of block @xmath59 in the rooted block tree of @xmath0 , and they share a cut vertex @xmath60 , we say that @xmath58 is a child block of @xmath59 at @xmath60 .",
    "it is known that every @xmath2-vertex - connected outerplanar graph has a unique hamiltonian cycle @xcite .",
    "though the hamiltonian cycle of a @xmath2-vertex - connected block of @xmath0 can be traversed either clockwise or anticlockwise , let us fix one of these orderings , so that the * successor * and * predecessor * of each vertex in the hamiltonian cycle in a block is fixed .",
    "we call this order the clockwise order . consider a non - root block @xmath58 of @xmath0 such that @xmath58 is a child block of its parent , at the cut vertex @xmath60 .",
    "if @xmath58 is a non - trivial block and @xmath61 and @xmath62 respectively are the predecessor and successor of @xmath60 in the hamiltonian cycle of @xmath58 , then we call @xmath61 the last vertex of @xmath58 and @xmath62 the first vertex of @xmath58 .",
    "if @xmath58 is a trivial block , the sole neighbor of @xmath60 in @xmath58 is regarded as both the first vertex and the last vertex of @xmath58 . by the term * path * , we always mean a simple path , i.e. , a path in which no vertex repeats .",
    "given a connected outerplanar graph @xmath4 of pathwidth @xmath1 , our algorithm will produce a @xmath2-vertex - connected outerplanar graph @xmath63 of pathwidth @xmath3 , where @xmath64 .",
    "our algorithm proceeds in three stages .",
    "\\(1 ) we use a modified version of the algorithm proposed by govindan et al . @xcite to obtain a _ nice tree decomposition _",
    "( defined in section [ stage1 ] ) of @xmath0 .",
    "using this nice tree decomposition of @xmath0 , we construct a special path decomposition of @xmath0 of width at most @xmath65 .",
    "\\(2 ) for each cut vertex @xmath60 of @xmath0 , we define an ordering among the child blocks attached through @xmath60 to their parent block . to define this ordering",
    ", we use the special path decomposition constructed in the first stage .",
    "this ordering helps us in constructing an outerplanar supergraph @xmath66 of @xmath0 , whose pathwidth is at most @xmath67 , such that for every cut vertex @xmath60 in @xmath15 , @xmath68 has exactly two components .",
    "the properties of the special path decomposition of @xmath0 obtained in the first stage is crucially used in our argument to bound the width of the path decomposition of @xmath15 , produced in the second stage .",
    "\\(3 ) we @xmath2-vertex - connect @xmath15 to construct @xmath63 , using a straightforward algorithm . as a by - product , this algorithm also gives us a surjective mapping from the cut vertices of @xmath15 to the edges in @xmath69 .",
    "we give a counting argument based on this mapping and some basic properties of path decompositions to show that the width of the path decomposition of @xmath70 produced in the third stage is at most @xmath71 .",
    "in this section , we construct a _ nice tree decomposition _ of the connected outerplanar graph @xmath0 and then use it to construct a _ nice path decomposition _ of @xmath0 .",
    "we begin by giving the definition of a nice tree decomposition .    given an outerplanar graph @xmath0 , govindan et al .",
    "* section 2 ) gave a linear time algorithm to construct a width @xmath2 tree decomposition @xmath72 of @xmath0 where @xmath73 , with the following special properties :    1 .",
    "there is a bijective mapping @xmath74 from @xmath20 to @xmath75 such that , for each @xmath76 , @xmath77 is present in the bag @xmath78 .",
    "if @xmath58 is a child block of @xmath59 at a cut vertex @xmath60 , the vertex set @xmath79 induces a subtree @xmath80 of @xmath10 such that , if @xmath81 is an edge in @xmath80 , then @xmath82 - this means that the subgraph @xmath83 of @xmath0 has a spanning tree , which is a copy of @xmath80 on the corresponding vertices .",
    "moreover , @xmath84 , with @xmath85 gives a tree decomposition of @xmath58 .",
    "3 .   @xmath0 has a spanning tree , which is a copy of @xmath10 on the corresponding vertices ; i.e. if @xmath81 is an edge in @xmath10 , then @xmath82 .    a tree decomposition @xmath72 of @xmath0 , where @xmath73 having properties 1 , 2 and 3 above , together with the following additional property , is called a nice tree decomposition of @xmath0 .    1 .",
    "if @xmath61 and @xmath62 are respectively the last and first vertices of a non - root , non - trivial block @xmath58 , then the bag @xmath86 contains both @xmath61 and @xmath62 .    in the discussion that follows",
    ", we will show that any outerplanar graph @xmath0 has a nice tree decomposition @xmath72 of width at most @xmath87 .",
    "initialize @xmath72 to be the tree decomposition of @xmath0 , constructed using the method proposed by govindan et al .",
    "@xcite , satisfying properties 1 , 2 and 3 of nice tree decompositions .",
    "we need to modify @xmath72 in such a way that , it satisfies property 4 as well .    for every non - root , non - trivial block @xmath58 of @xmath0 , do the following . if @xmath61 and @xmath62 are respectively the last and first vertices of @xmath58 , then , for each @xmath88 , we insert @xmath62 to @xmath89 , if it is not already present in @xmath89 and we call @xmath62 as a _ propagated _ vertex . note that , after this modification @xmath90 contains both @xmath61 and @xmath62 .",
    "[ claim1 ] after the modification , @xmath72 remains a tree decomposition of @xmath0 .",
    "clearly , we only need to verify that the third property in the definition of a tree decomposition holds , for all the propagated vertices .",
    "let @xmath62 be a propagated vertex , which got inserted to the bags corresponding to vertices of @xmath83 , during the modification .",
    "let @xmath91 , before the modification@xmath92 and let @xmath93 , after the modification@xmath92 . then , clearly , @xmath94 .    clearly , the induced subgraph of @xmath10 on the vertex set @xmath95 is connected , since we had a tree decomposition of @xmath0 before the modification . by property 2 of nice decompositions , the induced subgraph of @xmath10 on the vertex set @xmath79",
    "is also connected . moreover , by property 1 of nice decompositions , @xmath96 and hence , @xmath97 .",
    "this implies that the induced subgraph of @xmath10 on the vertex set @xmath98 is connected .",
    "[ claim2 ] after the modification , @xmath72 becomes a nice tree decomposition of @xmath0 of width at most @xmath87 .",
    "it is easy to verify that all the four properties required by nice decompositions are satisfied , after the modification .",
    "moreover , for any block @xmath58 , attached to its parent at the cut vertex @xmath60 , at most one ( propagated ) vertex is getting newly inserted into the bags corresponding to vertices of @xmath99 . since the size of any bag in @xmath100 was at most two initially and it got increased by at most one , the new decomposition has width at most three .",
    "from the claims above , we can conclude the following .",
    "[ nicetree ] every outerplanar graph @xmath0 has a nice tree decomposition @xmath72 of width @xmath87 , constructible in polynomial time .    let @xmath33 be a path decomposition of an outerplanar graph @xmath0 . if , for every non - root non - trivial block @xmath58 , there is a bag @xmath28 containing both the first and last vertices of @xmath58 together , then @xmath33 is called a nice path decomposition of @xmath0 .",
    "[ nicepath ] let @xmath0 be an outerplanar graph with @xmath101 .",
    "a nice path decomposition @xmath33 of @xmath0 , of width at most @xmath65 , is constructible in polynomial time .",
    "let @xmath72 , with @xmath102 be a nice tree decomposition of @xmath0 of width @xmath87 , obtained using lemma [ nicetree ] . obtain an optimal path decomposition @xmath103 of the tree @xmath10 in polynomial time , using a standard algorithm ( for example , the algorithm from @xcite ) .",
    "since @xmath10 is a spanning tree of @xmath0 , the pathwidth of @xmath10 is at most that of @xmath0 .",
    "therefore , the width of the path decomposition @xmath103 is at most @xmath1 ; i.e. there are at most @xmath104 vertices of @xmath10 in each bag @xmath105 .",
    "let @xmath106 and for each @xmath105 , we define @xmath107 .",
    "it is not difficult to show that @xmath33 , with @xmath108 , is a path decomposition of @xmath0 ( see @xcite ) .",
    "the width of this path decomposition is at most @xmath109 , since @xmath110 , for each bag @xmath111 and @xmath112 , for each bag @xmath113 .",
    "let @xmath58 be a non - root , non - trivial block in @xmath0 and @xmath61 and @xmath62 respectively be the first and last vertices of @xmath58 . since @xmath114 is a vertex of the tree @xmath10 , there is some bag @xmath115 , containing @xmath114 .",
    "the bag @xmath116 contains both @xmath61 and @xmath62 , since @xmath72 is a nice tree decomposition of @xmath0 .",
    "it follows from the definition of @xmath117 that @xmath118 contains both @xmath61 and @xmath62 .",
    "therefore , @xmath33 is a nice path decomposition of @xmath0 .",
    "in this section , we prove some technical lemmas which will be later used to prove that the intermediate graph @xmath15 obtained in stage 2 and the @xmath2-vertex - connected graph @xmath70 obtained in stage 3 are outerplanar .",
    "to get an intuitive understanding of these lemmas , the reader may refer to fig [ fig1 ] .",
    "recall that , when we use the term _ path _ , it always refers to a simple path .",
    "[ extensionlemma ] let @xmath4 be a connected outerplanar graph .",
    "let @xmath119 and @xmath77 be two distinct non - adjacent vertices in @xmath0 and let @xmath120 where @xmath121 be a path in @xmath0 such that :    ( i ) : :    @xmath31 shares at most one edge with any block of    @xmath0 . ( ii ) : :    for @xmath122 , if the block containing the edge    @xmath123 is non - trivial , then    @xmath124 is the successor of @xmath125 in the    hamiltonian cycle of that block .    then the graph @xmath66 , where @xmath126 , is outerplanar .     and",
    "@xmath77 and the path between @xmath127 and @xmath128 ( shown in thick edges ) satisfy the conditions stated in lemma [ extensionlemma ] . according to lemma [ extensionlemma ] , on adding any one of the dotted edges @xmath129 or @xmath130 ,",
    "the resultant graph is outerplanar .",
    "( b ) an outerplanar drawing of the resultant graph , after adding the edge @xmath129 . in this graph",
    ", @xmath131 is the hamiltonian cycle of the new block formed . ]",
    "it is well known that a graph @xmath0 is outerplanar if and only if it contains no subgraph that is a subdivision of @xmath132 or @xmath133 @xcite .",
    "consider a path @xmath31 between @xmath119 and @xmath77 as stated in the lemma .",
    "[ mustappear ] in every path in @xmath0 from @xmath119 to @xmath77 , vertices @xmath134 should appear and for @xmath122 , @xmath125 should appear before @xmath124 in any such path .    for any @xmath135 ,",
    "the two consecutive edges @xmath136 and @xmath137 of the path @xmath31 belong to two different blocks of @xmath0 , by assumption .",
    "therefore , each internal vertex @xmath125 , @xmath135 , is a cut vertex in @xmath0 . as a result , in every path in @xmath0 between @xmath119 and @xmath77 ,",
    "vertices @xmath134 should appear and for @xmath122 , @xmath125 should appear before @xmath124 in any such path .",
    "[ propdisjoint ] for any @xmath122 , there are at most two internally vertex disjoint paths in @xmath0 between @xmath125 and @xmath124 .",
    "any path from @xmath125 to @xmath124 lies fully inside the block @xmath58 that contains the edge @xmath123 .",
    "if @xmath58 is trivial , the only path from @xmath125 to @xmath124 is the direct edge between them . if this is not the case , @xmath58 is @xmath2-vertex - connected .",
    "it is a property of @xmath2-vertex - connected outerplanar graphs that , the number of internally vertex disjoint paths between any two consecutive vertices of the hamiltonian cycle of the graph , is exactly two ( see appendix ) . by the assumption of lemma [ extensionlemma ] ,",
    "if @xmath58 is non - trivial , then @xmath124 is the successor of @xmath125 in the hamiltonian cycle of @xmath58 .",
    "hence , the property follows .",
    "we will show that if @xmath15 is not outerplanar , then @xmath0 also was not outerplanar , which is a contradiction .",
    "assume that @xmath15 is not outerplanar .",
    "this implies that there is a subgraph @xmath138 of @xmath15 that is a subdivision of @xmath132 or @xmath133 .",
    "since @xmath0 does not have a subgraph that is a subdivision of @xmath132 or @xmath133 , @xmath138 can not be a subgraph of @xmath0 .",
    "hence , the new edge @xmath129 should be an edge in @xmath138 and all other edges of @xmath138 are edges of @xmath0.case 1 .",
    "@xmath138 is a subdivision of @xmath132 .",
    "let @xmath139 and @xmath140 denote the four vertices of @xmath138 that correspond to the vertices of @xmath132 .",
    "we call them as branch vertices of @xmath138 . for @xmath141 , @xmath142 ,",
    "let @xmath143 denote the path in @xmath138 from the branch vertex @xmath144 to the branch vertex @xmath145 , such that each intermediate vertex of the path is a degree two vertex in @xmath138 .",
    "without loss of generality , assume that the edge @xmath129 is part of the path @xmath146 of @xmath138 .",
    "all of the vertices @xmath134 appear in @xmath146 .",
    "the order @xmath50 in which the vertices @xmath119 , @xmath77 , @xmath134 appear in @xmath146 should be one of the following three : ( without loss of generality , assuming @xmath147 ) : ( 1 ) @xmath148 + ( 2 ) @xmath149 ( 3 ) @xmath150 for some @xmath151 .",
    "suppose @xmath125 , @xmath135 , does not belong to the path @xmath146 .",
    "then , there is a path in @xmath152 between vertices @xmath119 and @xmath77 , avoiding the vertex @xmath125 , since @xmath138 is a subdivision of @xmath132 .",
    "since @xmath152 is a subgraph of @xmath0 , this implies that there is a path in @xmath0 , between @xmath119 and @xmath77 that avoids @xmath125 .",
    "this is a contradiction to property [ mustappear ] .",
    "therefore , @xmath153 .",
    "notice that there is a path in @xmath152 , and hence in @xmath0 , between @xmath119 and @xmath77 that goes through the vertex @xmath154 . to satisfy property [ mustappear ]",
    ", @xmath125 should appear before @xmath124 , for @xmath122 , in this path .",
    "hence , one of the orderings mentioned in the claim should happen in @xmath146 .",
    "let us denote the first vertex in the ordering @xmath50 by @xmath155 and the last vertex in the ordering @xmath50 by @xmath156 .",
    "( in the first case , @xmath157 and @xmath158 . in the second case , @xmath159 and @xmath160 . in the third case , @xmath161 and @xmath162 . ) in all the three cases of the ordering , there is a direct edge in @xmath0 , between @xmath155 and @xmath156 .",
    "notice that in any of these three possible orderings , we do not have @xmath163 and @xmath160 simultaneously . since @xmath164 , by deleting the intermediate vertices between @xmath155 and @xmath156 from the path @xmath146 and including the direct edge between @xmath155 and @xmath156 , we get a path @xmath165 between @xmath166 and @xmath167 in @xmath0 .",
    "all vertices in @xmath165 are from the vertex set of @xmath146 .",
    "therefore , by replacing the path @xmath146 in @xmath138 by @xmath165 , we get a subgraph @xmath14 of @xmath0 that is a subdivision of @xmath132 .",
    "this means that @xmath0 is not outerplanar , which is a contradiction .",
    "therefore , @xmath138 can not be a subdivision of @xmath132 .",
    "@xmath138 is a subdivision of @xmath133 .",
    "as earlier , let @xmath168 and @xmath169 denote the branch vertices of @xmath138 that correspond to the vertices of @xmath170 .",
    "let @xmath171 be the degree @xmath2 branch vertices in @xmath138 and @xmath172 be the degree @xmath87 branch vertices of @xmath138 .",
    "for @xmath173 and @xmath174 , let @xmath143 denote the path in @xmath138 from vertex @xmath144 to vertex @xmath145 , such that each intermediate vertex of the path is a degree two vertex in @xmath138 . also , for @xmath173 and @xmath174 let @xmath175 denote the path from @xmath176 to @xmath177 in which the vertices in @xmath175 appear in the reverse order compared to @xmath143",
    ". without loss of generality , assume that the edge @xmath129 is part of the path @xmath146 of @xmath138 .",
    "let @xmath178 denote the path in @xmath138 between vertices @xmath140 and @xmath167 , obtained by concatenating the paths @xmath179 and @xmath146 .",
    "all of the vertices @xmath134 appear in @xmath178 .",
    "the order @xmath50 in which the vertices @xmath119 , @xmath77 , @xmath134 appear in @xmath178 should be one of the following three ( without loss of generality , assuming @xmath180 ) : ( 1 ) @xmath148 + ( 2 ) @xmath149 ( 3 ) @xmath150 for some @xmath151 .",
    "this can be proved in a similar way as in case 1 . the remaining part of the proof is also similar .",
    "let us denote the first vertex in the ordering @xmath50 by @xmath155 and the last vertex in the ordering @xmath50 by @xmath156 . repeating similar arguments as in case 1 , we can prove that by deleting the intermediate vertices between @xmath155 and @xmath156 from the path @xmath178 and including the direct edge between @xmath155 and @xmath156 , we get a path @xmath181 between @xmath140 and @xmath167 in @xmath0 .",
    "all vertices in @xmath181 are from the vertex set of @xmath178 .",
    "therefore , by replacing the path @xmath178 in @xmath138 by @xmath181 , we get a subgraph @xmath14 of @xmath0 .",
    "if @xmath181 has at least one intermediate vertex , the subgraph @xmath14 of @xmath0 , obtained by replacing the path @xmath178 in @xmath138 by @xmath181 , is a subdivision of @xmath170 , where an intermediate vertex of @xmath181 takes the role of the branch vertex @xmath166 .",
    "this contradicts the assumption that @xmath0 is outerplanar .",
    "therefore , assume that @xmath181 has no intermediate vertices , i. e. , @xmath182 and @xmath183 . in the first case of ordering @xmath50 mentioned in the claim above",
    ", we have @xmath184 and @xmath185 . in the second case , @xmath186 and @xmath187 . in the third case , @xmath188 and @xmath189 . in each of these cases , by property [ propdisjoint ] , there can be at most two vertex disjoint paths in @xmath0 between @xmath155 and @xmath156 .",
    "but , in all these cases , there is a direct edge between @xmath190 and @xmath191 in @xmath0 . since @xmath138 is a subdivision of @xmath170 , other than this direct edge , in @xmath152 there are two other paths from @xmath190 to @xmath191 that are internally vertex disjoint and containing at least one intermediate vertex",
    "this will mean that there are at least three internally vertex disjoint paths from @xmath182 to @xmath183 in @xmath0 , which is a contradiction .",
    "therefore , @xmath138 can not be a subdivision of @xmath170 .    since",
    ", @xmath15 does not contain a subgraph @xmath138 that is a subdivision of @xmath132 or @xmath133 , @xmath15 is outerplanar .",
    "the following lemma explains the effect of the addition of an edge @xmath129 as mentioned in lemma [ extensionlemma ] , to the block structure and the hamiltonian cycle of each block .",
    "assume that for @xmath192 , the edge @xmath123 belongs to the block @xmath58 .",
    "[ hamiltonianunchanged ]    1 .",
    "other than the blocks @xmath193 to @xmath194 of @xmath0 merging together to form a new block @xmath195 of @xmath15 ,",
    "blocks in @xmath0 and @xmath15 are the same .",
    "2 .   vertices in blocks @xmath193 to @xmath194 , except @xmath125 , @xmath196 , retains their successor and predecessor in the hamiltonian cycle of @xmath195 same as it was in its respective block s hamiltonian cycle in @xmath0 .",
    "each @xmath125 , @xmath122 , retains its hamiltonian cycle predecessor in @xmath195 same as it was in the block @xmath58 of @xmath0 and each @xmath125 , @xmath197 , retains its hamiltonian cycle successor in @xmath195 same as in the block @xmath198 of @xmath0 .",
    "when the edge @xmath129 is added , it creates a cycle containing the vertices @xmath199 .",
    "hence , the blocks @xmath193 to @xmath194 of @xmath0 merge together to form a single block @xmath195 in @xmath15 .",
    "it is obvious that other blocks are unaffected by this edge addition .    for simplicity ,",
    "if @xmath58 is a trivial block containing the edge @xmath123 , we say that @xmath125 and @xmath124 are neighbors of each other in the hamiltonian cycle of @xmath58 . for each @xmath58 , @xmath122 , let @xmath200 be the hamiltonian cycle of @xmath58 in @xmath0 . for @xmath122 , let us denote the path @xmath201 by @xmath202 .",
    "then , the hamiltonian cycle of @xmath195 is @xmath203 , where @xmath204 denotes the concatenation of the paths .",
    "( for example , in fig",
    ". [ fig1 ] , @xmath131 is the hamiltonian cycle of the new block formed , when the edge @xmath129 is added . ) from this , we can conclude that the second and third parts of the lemma holds .",
    "the organization of this sections is as follows : for each cut vertex @xmath60 of @xmath0 , we define an ordering among the child blocks attached through @xmath60 to their parent block , based on the nice path decomposition @xmath33 of @xmath0 obtained using lemma [ nicepath ] .",
    "this ordering is then used in defining a supergraph @xmath66 of @xmath0 such that for every cut vertex @xmath60 in @xmath15 , @xmath68 has exactly two components . using repeated applications of lemma [ extensionlemma ] ,",
    "we then show that @xmath15 is outerplanar .",
    "we extend the path decomposition @xmath33 of @xmath0 to a path decomposition @xmath205 of @xmath15 , as described in section [ background ] . by a counting argument using the properties of the nice path decomposition @xmath33",
    ", we show that the width of the path decomposition @xmath205 is at most @xmath206 , where @xmath207 is the width of @xmath33 .",
    "if @xmath33 is a nice path decomposition of @xmath0 , then , for each non - root block @xmath208 of @xmath0 , at least one bag in @xmath36 contains both the first and last vertices of @xmath208 together .",
    "let @xmath33 be the nice path decomposition of @xmath0 obtained using lemma [ nicepath ] .",
    "for each non - root block @xmath208 of @xmath0 , we define the sequence number of @xmath208 as @xmath209 simultaneously contains both the first and last vertices of @xmath210 .    for each cut vertex @xmath60",
    ", there is a unique block @xmath211 such that @xmath211 and its child blocks are intersecting at @xmath60 . for each cut vertex @xmath60",
    ", we define an ordering among the child blocks attached at @xmath60 , as follows . if @xmath212 are the child blocks attached at @xmath60 , we order them in the increasing order of their sequence numbers in @xmath33 .",
    "if @xmath58 and @xmath59 are two child blocks with the same sequence number , their relative ordering is arbitrary .    from the ordering",
    "defined , we can make some observations about the appearance of the first and last vertices of a block @xmath58 in the path decomposition .",
    "these observations are crucially used for bounding the width of the path decomposition @xmath205 of @xmath15 .",
    "let @xmath213 be the child blocks attached at a cut vertex @xmath60 , occurring in that order according to the ordering we defined above .",
    "for @xmath135 , let @xmath61 and @xmath62 respectively be the last and first vertices of @xmath58 .",
    "[ prop1 ] for any @xmath214 , if @xmath215 , then + @xmath216 $ ] and @xmath217 for all @xmath218 .",
    "if @xmath215 , either @xmath219 or @xmath220 . the latter case will imply that , sequence number of @xmath221 sequence number of @xmath58 , which is a contradiction .",
    "therefore , @xmath219 and hence @xmath216 $ ] .",
    "since @xmath60 is adjacent to @xmath62 and @xmath222 , we get @xmath223 and @xmath224 + @xmath225",
    ". we can conclude that @xmath226 $ ] and the property follows .",
    "[ prop2 ] for any @xmath227 , @xmath228 .",
    "we can assume that @xmath215 and @xmath229 , since the property holds trivially otherwise . by property [ prop1 ] ,",
    "we get , @xmath216 $ ] and @xmath230 + @xmath231 $ ] . since @xmath232 , by the property of the ordering of blocks , we know that sequence number of @xmath233 sequence number of @xmath59 . from the definitions",
    ", we have , @xmath234 sequence number of @xmath235sequence number of @xmath236 and the property follows .",
    "we use algorithm [ algmulticut ] to construct @xmath66 and a path decomposition @xmath205 of @xmath15 .",
    "the processing of each cut vertex is done in lines [ loop1 ] to [ modify ] of algorithm [ algmulticut ] .",
    "while processing a cut vertex @xmath60 , the algorithm adds the edges @xmath237 @xmath238 ( as defined in the algorithm ) and modifies the path decomposition , to reflect each edge addition .",
    "@xmath239 , @xmath240    [ outerplanarfirst ] @xmath15 is outerplanar and for each cut vertex @xmath60 of @xmath15 , @xmath241 has exactly two components .    we know",
    "that @xmath0 is outerplanar to begin with . at a certain stage ,",
    "let @xmath60 be the cut vertex taken up by the algorithm for processing ( in line [ loop1 ] ) .",
    "assume that the graph at this stage , denoted by @xmath242 , is outerplanar and each cut vertex @xmath243 whose processing is completed , satisfies the condition that all the child blocks attached at @xmath243 have merged together to form a single child block attached at @xmath243 .",
    "it is clear that the child blocks attached at a vertex @xmath60 remain unchanged until @xmath60 is picked up by the algorithm for processing .",
    "let @xmath244 , in that order , be the child blocks attached at @xmath60 , according to the ordering defined in section [ ordering ] .",
    "let @xmath211 be the parent block of @xmath244 , in the current graph @xmath242 . for each @xmath245",
    ", let @xmath62 and @xmath61 respectively be the first and last vertices of @xmath58 . for @xmath246 ,",
    "let @xmath247 be the graph obtained , when the algorithm has added the edges up to @xmath248 .",
    "we will prove that the algorithm maintains the following invariants , while processing the cut vertex @xmath60 , for each @xmath249 :    _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ the graph @xmath247 is outerplanar . in @xmath247 , the blocks @xmath250 of @xmath251 have merged together and formed a child block @xmath195 of @xmath211 .",
    "the vertex @xmath252 is the first vertex of @xmath195 .",
    "if @xmath253 , blocks @xmath254 remain the same in @xmath255 , as in @xmath0 .",
    "_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _    by our assumption , the invariants hold for @xmath242 .",
    "we need to show that if the invariants hold for @xmath251 , they hold for @xmath247 as well .",
    "assume that the invariants hold for @xmath251 and let @xmath195 be the child block of @xmath211 in @xmath251 that is formed by merging together the blocks @xmath256 of @xmath257 , as stated in the invariant .",
    "since the invariants hold for @xmath251 by our assumption , @xmath258 is the first vertex of @xmath195 and @xmath222 is the last vertex in @xmath259 . in other words",
    ", @xmath258 is the successor of @xmath60 in @xmath195 and @xmath222 is the predecessor of @xmath60 in @xmath259 and the edges @xmath260 and @xmath261 of the path @xmath262 belong to two different blocks of @xmath251 .",
    "hence , by lemma [ extensionlemma ] , after adding the edge @xmath263 , the resultant intermediate graph @xmath255 is outerplanar . by lemma [ hamiltonianunchanged ] , the blocks @xmath195 and @xmath259 merges together to form a child block @xmath264 of @xmath211 in @xmath255 .",
    "further , the vertex @xmath252 will be the successor of @xmath60 in the hamiltonian cycle of @xmath264 i.e , the first of the block @xmath264 .",
    "remaining blocks of @xmath255 are the same as in @xmath251 .",
    "thus , all the invariants hold for @xmath255 . it follows that the graph @xmath265 is outerplanar and the blocks @xmath244 have merged together in @xmath265 to form a single child block of @xmath211 at @xmath60 .",
    "when this processing is repeated at all cut vertices , it is clear that @xmath15 is outerplanar and for each cut vertex @xmath60 of @xmath15 , @xmath241 has exactly two components .",
    "@xmath205 is a path decomposition of @xmath15 of width at most @xmath67 .",
    "algorithm [ algmulticut ] initialized @xmath205 to @xmath33 and modified it in line [ modify ] , following each edge addition . by property [ prop1 ] , we have @xmath216 $ ] .",
    "hence , by the modification done in line [ modify ] while adding a new edge @xmath248 , @xmath205 becomes a path decomposition of the graph containing the edge @xmath248 , as explained in section [ background ] .",
    "it follows that , when the algorithm terminates @xmath205 is a path decomposition of @xmath15 .",
    "consider any @xmath266 . while processing the cut vertex @xmath60 , if algorithm [ algmulticut ] inserts a new vertex @xmath62 to @xmath267 , to reflect the addition of a new edge @xmath248 then , @xmath218 .",
    "suppose @xmath248 and @xmath268 are two new edges added while processing the cut vertex @xmath60 , where , @xmath269 . by property [ prop2 ] , we know that if @xmath218 , then , @xmath270 .",
    "therefore , when the algorithm processes a cut vertex @xmath60 in lines [ loop1 ] to [ modify ] , at most one vertex is newly inserted to the bag @xmath267 . moreover ,",
    "if @xmath218 then , the cut vertex @xmath217 , by property [ prop1 ] .    that means , a vertex not present in the bag @xmath24 can be added to @xmath267 only when a cut vertex @xmath60 that is already present in the bag @xmath24 is being processed . moreover ,",
    "when a cut vertex @xmath60 that is present in @xmath24 is processed , at most one new vertex can be added to @xmath267 .",
    "it follows that @xmath271number of cut vertices present in @xmath272 .",
    "therefore , the width of the path decomposition @xmath205 is at most @xmath67 .",
    "in this section , we give an algorithm to add some more edges to @xmath66 so that the resultant graph @xmath63 is @xmath2-vertex - connected .",
    "the algorithm also extend the path decomposition @xmath205 of @xmath15 to a path decomposition @xmath273 of @xmath70 .",
    "the analysis of the algorithm shows the existence of a surjective mapping from the cut vertices of @xmath15 to the edges in @xmath69 . a counting argument based on this surjective",
    "mapping shows that the width of the path decomposition @xmath273 is at most @xmath71 . for making our presentation",
    "simpler , if a block @xmath58 is just an edge @xmath274 , we abuse the definition of a hamiltonian cycle and say that @xmath119 and @xmath77 are clockwise neighbors of each other in the hamiltonian cycle of @xmath58 .",
    "recall that for every cut vertex @xmath60 of @xmath15 , @xmath241 has exactly two components . since any cut vertex belongs to exactly two blocks of @xmath0 , based on the rooted block tree structure of @xmath0 , we call them the parent block containing @xmath60 and the child block containing @xmath60",
    ". we use @xmath275 to denote the unique child block of the block @xmath208 at the cut vertex @xmath60 and @xmath276 to denote the parent block of the block @xmath208 . for a block @xmath208",
    ", @xmath277 denotes the successor of the vertex @xmath77 in the hamiltonian cycle of @xmath208 .",
    "we say that a vertex @xmath119 is _ encountered by the algorithm _",
    ", when @xmath119 gets assigned to the variable @xmath128 , during the execution of the algorithm .",
    "the block referred to by the variable @xmath208 represents the _ current block _ being traversed .    to get a high level picture of our algorithm ,",
    "the reader may consider it as a traversal of vertices of @xmath15 , starting from a non - cut vertex in the root block of @xmath15 and proceeding to the successor of @xmath77 on reaching a non - cut vertex @xmath77 . on reaching a cut vertex @xmath60 , the algorithm bypasses @xmath60 and recursively traverses the child block containing @xmath60 and its descendant blocks , starting from the successor of @xmath60 in child block containing @xmath60 .",
    "after this , the algorithm comes back to @xmath60 to visit it , and continues the traversal of the remaining graph , by moving to the successor of @xmath60 in the parent block containing @xmath60 . before starting the recursive traversal of the child block containing @xmath60 and its descendant blocks , the algorithm sets @xmath278 .",
    "( note that , since there is only one child block attached to any cut vertex , each cut vertex is bypassed only once . ) in this way , when a sequence of one or more cut vertices is bypassed , an edge is added from the vertex visited just before bypassing the first cut vertex in the sequence to the vertex visited just after bypassing the last cut vertex in the sequence .",
    "the path decomposition is also modified , to reflect this edge addition . the detailed algorithm to @xmath2-vertex - connect @xmath15",
    "is given in algorithm [ algbiconnect ] .",
    "@xmath279 , @xmath273 = @xmath205 @xmath208 = rootblock [ rootbline ] choose @xmath128 to be some non - cut vertex of the rootblock [ initialvertexline ] @xmath280true , @xmath281 [ completeline1 ] @xmath282 [ reassignline1 ]    if @xmath15 has only a single vertex , then it is easy to see that the algorithm does not modify the graph . for the rest of this section ,",
    "we assume that this is not the case .",
    "the following recursive definition is made in order to make the description of the algorithm easier .",
    "let @xmath0 be a connected outerplanar graph with at least two vertices such that @xmath283 has exactly two connected components for every cut vertex @xmath60 and @xmath77 be a non - cut vertex in the root block of @xmath0 .",
    "for any cut vertex @xmath60 of @xmath0 , let @xmath284 denote the subgraph of @xmath0 induced on the vertices belonging to the unique child block attached at @xmath60 and all its descendant blocks .",
    "if the root - bock of @xmath0 is a non - trivial block , let @xmath285 be the hamiltonian cycle of the root - block of @xmath0 , starting at @xmath77 .",
    "then , @xmath286    the following lemma gives a precise description of the order in which the algorithm encounters vertices of @xmath15 .",
    "[ orderencounter ] let @xmath15 be a connected outerplanar graph with at least two vertices , such that for every cut vertex @xmath60 of @xmath15 , @xmath241 has exactly two connected components .",
    "if @xmath15 is given as the input graph to algorithm [ algbiconnect ] and @xmath287 is the non - cut vertex in the root block of @xmath15 from which the algorithm starts the traversal , then @xmath288 is the order in which algorithm [ algbiconnect ] encounters the vertices of @xmath15 .",
    "since the proof of this lemma is easy but is lengthy and detailed , in order to make the reading easier we have moved the proof to the appendix .",
    "now we will use lemma [ orderencounter ] and derive some properties maintained by algorithm [ algbiconnect ] .",
    "[ completionproperty ]    1 .",
    "every non - cut vertex of @xmath15 is encountered exactly once .",
    "every cut vertex of @xmath15 is encountered exactly twice .",
    "a non - cut vertex is completed when it is encountered for the first time .",
    "a cut vertex is bypassed when it is encountered for the first time and is completed when it is encountered for the second time .",
    "each cut vertex is bypassed exactly once .",
    "every vertex is completed exactly once and a vertex that is declared completed is never encountered again .",
    "the first part of the property follows directly from lemma [ orderencounter ] .    to prove the second part , observe that a vertex @xmath119 is encountered only in lines [ initialvertexline ] , [ reassignv ] or [ childblockline ] .",
    "if @xmath289 is a non - cut vertex , the inner while - loop will not be entered .",
    "the vertex @xmath119 is completed in line [ completeline1 ] or line [ completeline2 ] before another vertex is encountered by executing line [ reassignv ] again .    for any cut vertex @xmath60 , @xmath290 false initially",
    "and it is changed only after @xmath60 is encountered and the algorithm enters the inner while - loop with @xmath291 .",
    "when @xmath60 is first encountered , @xmath292 is false and the algorithm gets into the inner while - loop and inside this loop @xmath292 is set to true .",
    "after this , @xmath292 is never set to false .",
    "therefore , when @xmath60 is encountered for the second time , the inner while - loop is not entered and before @xmath128 gets reassigned , @xmath60 is completed in line [ completeline2 ] .",
    "the third part of the property follows from the first two parts and lemma [ orderencounter ] .",
    "[ surjectionlemma ] each cut vertex of @xmath15 is bypassed exactly once by the algorithm and is associated with a unique edge in @xmath293 .",
    "every edge @xmath294 has a non - empty sequence of bypassed cut vertices associated with it , given by @xmath295 .",
    "hence , the function @xmath296 cut vertices of @xmath297 , defined as @xmath298 is a surjective map .    from property [ completionproperty ] , each cut vertex @xmath60 of @xmath15 is bypassed exactly once by the algorithm .",
    "note that when @xmath60 is bypassed in line [ bypassline ] , @xmath60 is appended to the string @xmath299 and the variable @xmath300 was set to true in the previous line . on exiting the inner while - loop , since @xmath300=true",
    ", an edge is added in line [ edgeline ] . before adding the new edge @xmath22 , in the previous line the algorithm set @xmath295 to be the sequence of cut vertices accumulated in the variable @xmath299 . as we have seen , @xmath60 is present in the string @xmath299 and it is clear from the algorithm that @xmath299 was not reset to emptystring before assigning it to @xmath295 .",
    "therefore , @xmath60 is present in @xmath295 . in the next iteration of the outer while - loop ,",
    "@xmath299 is reset to emptystring .",
    "since @xmath60 is bypassed only once , it will not be added to the string @xmath299 again nor it will be part of @xmath301 for any other edge @xmath302 .",
    "an edge @xmath22 gets added in line [ edgeline ] only if @xmath300 is true , while executing line [ checklooptaken ] . however , the variable @xmath300 is set to false in the outer while - loop every time just before entering the inner while - loop and is set to true only inside the inner while - loop , where at least one cut vertex is bypassed in line [ bypassline ] and is added to @xmath299 .",
    "until the algorithm exits from the inner while - loop , and the next edge @xmath22 is added , @xmath300 is maintained to be true .",
    "this ensures that @xmath295 is a non - empty string for each edge @xmath294 .",
    "[ pathbetweenpairs ]",
    "let @xmath303 be an edge such that , at the time of adding the edge @xmath22 in line [ edgeline ] of algorithm [ algbiconnect ] , the variable @xmath77 contained the value @xmath304 and the variable @xmath128 contained the value @xmath305 .",
    "* the vertex @xmath306 is already completed at this time and the vertex @xmath305 is completed subsequently .",
    "* cut vertices that belong to @xmath295 are precisely the vertices bypassed during the period from the execution of line [ reassignv ] just before adding the edge @xmath22 in line [ edgeline ] to the time when @xmath22 is added in line [ edgeline ] .",
    "these vertices were bypassed in the order in which they appear in @xmath295 . *",
    "each cut vertex bypassed before bypassing the first cut vertex that belong to @xmath295 belongs to the bypass sequence of one of the edges in @xmath69 which was added before @xmath22 . *",
    "if @xmath307 , then @xmath308 is a path in @xmath15 such that * * for each @xmath135 , @xmath309 is the successor of @xmath310 in the hamiltonian cycle of the parent block in @xmath15 , at the cut vertex @xmath125 . *",
    "* @xmath311 is the successor of @xmath312 in the hamiltonian cycle of the child block in @xmath15 , at the cut vertex @xmath313 .",
    "+ since each bypassed vertex is a cut vertex in @xmath15 , it is easy to see that @xmath303 was not already an edge in @xmath15 .",
    "suppose that at the time of adding the edge @xmath22 in line [ edgeline ] of algorithm [ algbiconnect ] , the variable @xmath77 contained the value @xmath304 and the variable @xmath128 contained the value @xmath305 .",
    "observe that the variable @xmath77 always gets its value from the variable @xmath128 in lines [ reassignline1 ] and [ reassignline ] and just before this , in lines [ completeline1 ] and [ completeline2 ] @xmath128 was declared completed .",
    "therefore the vertex assigned to @xmath77 is always a completed vertex .",
    "therefore , at the time of adding the edge @xmath22 in line [ edgeline ] , the vertex @xmath306 is already completed .",
    "after the edge is added in line [ edgeline ] , in line [ completeline2 ] the vertex assigned to @xmath314 is completed . since by property [ completionproperty ] a vertex is completed only once , this is the only time at which @xmath305 is completed .",
    "since each cut vertex is bypassed only once , and is added to the bypass sequence of the next edge added ( see the proof of lemma [ surjectionlemma ] ) , it is clear that if a cut vertex is bypassed before @xmath315 , it should belong to the bypass sequence of an edge in @xmath293 added before @xmath22 .",
    "the remaining parts of the property are easy to deduce from lines [ innerwhile ] - [ childblockline ] and line [ seqline ] of the algorithm .",
    "[ biconnect ] @xmath70 is @xmath2-vertex - connected .    we show that @xmath70 does not have any cut vertices . since @xmath70 is a supergraph of @xmath15 , if a vertex @xmath60 is not a cut vertex in @xmath15 , it will not be a cut vertex in @xmath70 .",
    "we need to show that the cut vertices in @xmath15 become non - cut vertices in @xmath70 .",
    "consider a newly added edge @xmath129 of @xmath70 . without loss of generality , assume that @xmath119 was completed before @xmath77 in the traversal and for @xmath316 , @xmath317 . by property [ pathbetweenpairs",
    "] , @xmath318 is a path in @xmath15 .",
    "when our algorithm adds the edge @xmath129 , it creates the cycle @xmath319 in the resultant graph .",
    "recall that , for each @xmath135 , @xmath320 had exactly two components ; one containing @xmath310 and the other containing @xmath124 . after the addition of the edge @xmath129 , vertices @xmath310 , @xmath125 and @xmath124 lie on a common cycle .",
    "hence , after the edge @xmath129 is added , for @xmath135 , @xmath125 is no longer a cut vertex . since by lemma [ surjectionlemma ] every cut vertex in @xmath15 was part of the bypass sequence associated with some edge in @xmath69 ,",
    "all of them become non - cut vertices in @xmath70 .    to prove that @xmath70 is outerplanar",
    ", we can imagine the edges in @xmath69 being added to @xmath15 one at a time .",
    "our method is to repeatedly use lemma [ extensionlemma ] and show that after each edge addition , the resultant graph remains outerplanar .",
    "we will first note down some properties maintained by algorithm [ algbiconnect ] .",
    "let @xmath321 be the set of edges added by algorithm [ algbiconnect ] .",
    "assume that , for each @xmath322 , @xmath323 was added before @xmath324 and at the time of adding the edge @xmath325 in line [ edgeline ] of algorithm [ algbiconnect ] , the variable @xmath77 contained the value @xmath304 and the variable @xmath128 contained the value @xmath305 . by property [ pathbetweenpairs ] , @xmath304 is completed before @xmath305 .",
    "let @xmath326 , where @xmath327 , and @xmath328 be the associated path in @xmath15 ( property [ pathbetweenpairs ] ) .",
    "let @xmath329 denote the block containing the edge @xmath330 in @xmath15 .",
    "clearly , @xmath331 is the root block of @xmath15 .",
    "the following statement is an immediate corollary of property [ pathbetweenpairs ] , with the definitions above .",
    "[ prop3 ] for each @xmath332 , the vertex @xmath333 is the successor of the vertex @xmath334 in the hamiltonian cycle of the block @xmath335 .",
    "the path @xmath336 shares only one edge with any block of @xmath15 .",
    "[ initialvertex ] if @xmath337 , then @xmath338 .    by our assumption , at the time of adding the edge @xmath323 , we had @xmath306 and @xmath314 . by property [ pathbetweenpairs ] ,",
    "the vertex @xmath306 was already completed at this time . after adding the edge @xmath339",
    ", the algorithm reassigns @xmath340 in line [ reassignline ] . by property [ completionproperty ]",
    ", the algorithm will never encounter the completed vertex @xmath304 again , and this means that @xmath128 is never set to @xmath304 in future .",
    "this also implies that @xmath77 is never set to @xmath304 in future , since @xmath77 gets reassigned later only in line [ reassignline ] , where it gets its value from the variable @xmath128 . since @xmath341",
    "when the edge @xmath342 is added , we have @xmath338 .    at a stage of algorithm [ algbiconnect ] , we say that a non - root block @xmath208 is * touched * , if at that stage algorithm [ algbiconnect ] has already bypassed the cut vertex @xmath343 such that @xmath208 is the child block containing @xmath343 . at any stage of algorithm [ algbiconnect ] ,",
    "we consider the root block of @xmath15 to be touched .    [ touchedblocks ] when algorithm [ algbiconnect ] has just finished adding the edge @xmath323 , the touched blocks are precisely @xmath344 .",
    "this implies that if @xmath345 , the blocks @xmath346 remain untouched when the algorithm has just finished adding the edge @xmath347 .",
    "the root block @xmath331 is always a touched block by definition and the other touched blocks when algorithm [ algbiconnect ] has just finished adding the edge @xmath323 are the child blocks attached to cut vertices bypassed so far .",
    "however , by property [ pathbetweenpairs ] , when algorithm [ algbiconnect ] has just finished adding the edge @xmath323 , a cut vertex @xmath60 is already bypassed if and only if @xmath60 belongs to @xmath348 for some @xmath349 . for @xmath349 , we had @xmath350 and for @xmath351 , @xmath352 is the child block attached at @xmath353 by the last part of property [ pathbetweenpairs ] .",
    "hence , the initial part of the property holds . from this , the latter part of the property follows , by lemma [ surjectionlemma ] .",
    "[ blocksconnected ] for each @xmath354 , when the algorithm has just finished adding the edge @xmath355 , the block @xmath356 is a touched block .",
    "if @xmath356 is the root block , the property is trivially true .",
    "assume that this is not the case .",
    "consider the situation when the algorithm has just finished adding the edge @xmath355 in line [ edgeline ] . by property [ pathbetweenpairs ] ,",
    "the next cut vertex to be bypassed is @xmath357 , which is the first vertex appearing in @xmath358 , and @xmath356 is the parent block attached at @xmath357 .",
    "let @xmath343 be the cut vertex such that @xmath356 is the child block at @xmath343 .",
    "if @xmath343 has been encountered by now , @xmath343 would have been bypassed ( lemma [ completionproperty ] ) , making @xmath356 a touched block .",
    "since a cut vertex is bypassed when it is encountered for the first time ( lemma [ completionproperty ] ) and @xmath343 is the first vertex the algorithm encounters among the vertices in the block @xmath356 ( lemma [ orderencounter ] ) , if @xmath343 is not yet encountered , it will contradict the fact that @xmath357 is the next cut vertex to be bypassed , because @xmath357 is a vertex in @xmath356 .",
    "therefore @xmath343 should have been encountered earlier and therefore , @xmath356 is a touched block .",
    "@xmath70 is outerplanar .",
    "let @xmath359 and for each @xmath360 , let @xmath361 be the graph obtained by assigning @xmath362 .",
    "let @xmath363 denote the root block of @xmath15 .",
    "we will prove that algorithm [ algbiconnect ] maintains the following invariants for each @xmath364 :    * the graph @xmath365 is outerplanar .",
    "* when the algorithm has just finished adding the edge @xmath323 , the set of touched blocks , @xmath366 , have merged together and formed a single block , which we call as the * merged block * @xmath367 in @xmath365 .",
    "@xmath367 will be taken as the root block of @xmath365 .",
    "the other blocks of @xmath15 remain the same in @xmath368 . *",
    "if @xmath369 , @xmath370 is the successor of @xmath371 in the hamiltonian cycle of the block @xmath367 .    by lemma [ outerplanarfirst ] , @xmath359 is outerplanar and it is clear that the above invariants hold for @xmath372 .",
    "assume that the invariants hold for each @xmath177 , where @xmath373 .",
    "consider the case when @xmath374 .",
    "since the invariants hold for @xmath375 , @xmath376 is the successor of @xmath377 in the hamiltonian cycle of the block @xmath378 . by property [ touchedblocks ] ,",
    "the blocks @xmath379 are untouched when the algorithm has just added the edge @xmath380 . since the invariants hold for @xmath375 , these blocks remain the same in @xmath381 as in @xmath15",
    ". therefore , the path @xmath382 continues to satisfy the pre - conditions of lemma [ extensionlemma ] in @xmath381 ( property [ prop3 ] ) .",
    "on addition of the edge @xmath383 to @xmath381 , the resultant graph @xmath384 is outerplanar , by lemma [ extensionlemma ] .    by property [ touchedblocks ] ,",
    "the blocks @xmath385 are precisely the blocks that were not touched at the time when @xmath386 was just added but became touched by the time when @xmath387 is just added .",
    "however , by lemma [ hamiltonianunchanged ] , the blocks @xmath385 merges with @xmath378 and forms the block @xmath388 of @xmath389 and other blocks of @xmath389 are same as those of @xmath381 ( and hence of @xmath15 ) when the edge @xmath387 is added .",
    "thus , all touched blocks have merged together to form the block @xmath388 in @xmath390 and the other blocks of @xmath15 remain the same in @xmath390 .    finally , we have to prove that the successor of @xmath391 in the hamiltonian cycle of the block @xmath388 is @xmath392 , which is the same as the successor @xmath391 in the hamiltonian cycle of the block @xmath393 in @xmath15 . to see this , note",
    "that , by lemma [ hamiltonianunchanged ] , if @xmath128 is the successor of @xmath77 in the block containing the edge @xmath394 before an edge @xmath342 is added , it remains so after adding this edge , unless @xmath395 . by property [ initialvertex ] , @xmath396 for any @xmath397 and",
    "hence it follows that @xmath392 remains the successor @xmath391 in the block containing the edge @xmath398 in @xmath389 .",
    "hence , in order to prove that @xmath392 is the successor of @xmath391 in the hamiltonian cycle of the block @xmath388 , it suffices to prove that the edge @xmath398 belongs to the block @xmath388 in @xmath389 . in the previous paragraph we saw that , at the time of adding the edge @xmath383 , all the touched blocks so far have merged together to form the the block @xmath388 of @xmath384 .",
    "since the edge @xmath398 is in the block @xmath393 in @xmath15 , which is a touched block by property [ blocksconnected ] when the algorithm has just finished adding the edge @xmath383 , the block @xmath393 has also been merged into @xmath388 and hence , the edge @xmath398 is in the block @xmath388 in @xmath389 .",
    "thus , all the invariants hold for @xmath374 and hence for each @xmath360 . since @xmath399 by definition , @xmath70 is outerplanar .",
    "@xmath273 is a path decomposition of @xmath70 of width at most @xmath71 .",
    "it is clear that @xmath273 is a path decomposition of @xmath70 , since we constructed it using the method explained in section [ background ] .    for each @xmath400 ,",
    "let @xmath401 and let @xmath402 denote the set of cut vertices that belong to @xmath358 . by property [ pathbetweenpairs ]",
    ", @xmath403 is a path in @xmath15 .",
    "we will show that , if @xmath404 , then , @xmath405 . without loss of generality , assume that @xmath406 . since @xmath304 is adjacent to @xmath357 , both of them are together present in some bag @xmath266 , with @xmath407 .",
    "similarly , since @xmath305 is adjacent to @xmath408 , they both are together present in some bag @xmath266 , with @xmath409 .",
    "suppose some bag @xmath266 with @xmath404 does not contain any element of @xmath402 .",
    "let @xmath410 belongs to @xmath411 for some @xmath412 and @xmath413 belongs to @xmath411 for some @xmath414 . from the definitions , @xmath415 and @xmath416 .",
    "if @xmath417 , the vertices belonging to @xmath418 will be present in @xmath267 as well , which is a contradiction .",
    "therefore , @xmath419 is a partitioning of @xmath402 .",
    "let @xmath420 be the maximum such that @xmath421 . clearly , @xmath422 .",
    "since @xmath423 is an edge in @xmath15 , both @xmath424 and @xmath425 should be simultaneously present in some bag in @xmath426 .",
    "but this can not happen because @xmath421 and @xmath427 .",
    "this is a contradiction and therefore , if @xmath404 , then , @xmath405 .    by the modification done to the path decomposition to reflect the addition of an edge @xmath325",
    ", a vertex was inserted into @xmath428 only if @xmath404 and for each @xmath428 such that @xmath404 , exactly one vertex ( @xmath304 or @xmath305 ) was inserted into @xmath429 while adding @xmath325 . moreover , when this happens , @xmath405 .",
    "therefore , for any @xmath430 in the index set , @xmath431 .",
    "but , @xmath432 , because @xmath433 , for @xmath434 , by lemma [ surjectionlemma ] .",
    "therefore , for any @xmath430 , @xmath435 .",
    "therefore , width of the path decomposition @xmath273 is at most @xmath71 .",
    "for our preprocessing , we need to compute a rooted block tree of the given outerplanar graph @xmath0 and compute the hamiltonian cycles of each non - trivial block . these can be done in linear time @xcite .",
    "the special tree decomposition construction in govindan et al.@xcite is also doable in linear time . using the hamiltonian cycle of each non - trivial block , we do only a linear time modification in section [ stage1 ] , to produce the nice tree decomposition @xmath72 of @xmath0 of width @xmath87 .",
    "an optimal path decomposition of the tree @xmath10 , can be computed in @xmath436 time @xcite . for computing the nice path decomposition @xmath33 of @xmath0 in section [ stage1 ] ,",
    "the time spent is linear in the size of the path decomposition obtained for @xmath10 , which is @xmath437 @xcite , and the size of @xmath33 is @xmath436 .",
    "computing the firstindex , lastindex and range of vertices and the sequence number of blocks can be done in time linear in the size of the path decomposition .",
    "since the resultant graph is outerplanar , algorithm [ algmulticut ] and algorithm [ algbiconnect ] adds only a linear number of new edges .",
    "since the size of each bag in the path decompositions @xmath205 of @xmath15 and @xmath273 of @xmath70 are only a constant times the size of the corresponding bag in @xmath33 , the time taken for modifying @xmath33 to obtain @xmath205 and later modifying it to @xmath273 takes only time linear in size of @xmath33 ; i.e. , @xmath436 time .",
    "hence , the time spent in constructing @xmath70 and its path decomposition of width @xmath438 is @xmath436 .",
    "in this paper , we have described a @xmath436 time algorithm to add edges to a given connected outerplanar graph @xmath0 of pathwidth @xmath1 to get a @xmath2-vertex - connected outerplanar graph @xmath70 of pathwidth at most @xmath71 .",
    "we also get the corresponding path decomposition of @xmath70 in @xmath436 time .",
    "our technique is to produce a nice path decomposition of @xmath0 and make use of the properties of this decomposition , while adding the new edges .",
    "biedl @xcite obtained an algorithm for computing planar straight line drawings of a @xmath2-vertex - connected outerplanar graph @xmath0 on a grid of height @xmath3 . in conjunction with our algorithm",
    ", biedl s algorithm will work for any outer planar graph @xmath0 . as explained by biedl @xcite",
    ", this gives a constant factor approximation algorithm to get a planar drawing of @xmath0 of minimum height .",
    "10 url # 1`#1`urlprefixhref # 1#2#2 # 1#1    t.  biedl , a 4-approximation for the height of 2-connected outer - planar graph drawings , waoa 2012 , 2012 .",
    "w.  schnyder , embedding planar graphs on the grid , in : proceedings of the first annual acm - siam symposium on discrete algorithms , soda 90 , 1990 , pp .",
    "138148 .",
    "v.  dujmovic , p.  morin , d.  r. wood , path - width and three - dimensional straight - line grid drawings of graphs , in : revised papers from the 10th international symposium on graph drawing , gd 02 , springer - verlag , london , uk , 2002 , pp . 4253 .",
    "m.  suderman , pathwidth and layered drawings of trees , int .",
    "j. comput .",
    "geometry appl .",
    "14  ( 3 ) ( 2004 ) 203225 .",
    "t.  biedl , small drawings of outerplanar graphs , series - parallel graphs , and other planar graphs , discrete comput .",
    "45  ( 1 ) ( 2011 ) 141160 .",
    "a.  garca , f.  hurtado , m.  noy , j.  tejel , augmenting the connectivity of outerplanar graphs , algorithmica 56  ( 2 ) ( 2010 ) 160179 .",
    "g.  kant , augmenting outerplanar graphs , journal of algorithms 21  ( 1 ) ( 1996 ) 125 .",
    "n.  robertson , p.  d. seymour , graph minors .",
    "planar tree - width , j. comb .",
    "theory , ser .",
    "b 36  ( 1 ) ( 1984 ) 4964 .",
    "m.  m. syslo , characterizations of outerplanar graphs , discrete mathematics 26  ( 1 ) ( 1979 ) 4753 .",
    "r.  govindan , m.  a. langston , x.  yan , approximating the pathwidth of outerplanar graphs , inf . process .",
    "lett . 68  ( 1 ) ( 1998 ) 1723 .",
    "k.  skodinis , construction of linear tree - layouts which are optimal with respect to vertex separation in linear time , j. algorithms 47  ( 1 ) ( 2003 ) 4059 .",
    "g.  chartrand , f.  harary , planar permutation graphs , annales de linstitut henri poincar ( b ) probabilits et statistiques 3 ( 1967 ) 433438 .",
    "j.  hopcroft , r.  tarjan , algorithm 447 : efficient algorithms for graph manipulation , commun .",
    "acm 16  ( 6 ) ( 1973 ) 372378 .",
    "let @xmath0 be a @xmath2-vertex - connected outerplanar graph . then , the number of internally vertex disjoint paths between any two consecutive vertices in the hamiltonian cycle of @xmath0 is exactly two .",
    "since @xmath0 is a @xmath2-vertex - connected outerplanar graph , it can be embedded in the plane , so that its exterior cycle @xmath439 is the unique hamiltonian cycle of @xmath0 @xcite .",
    "consider such an embedding of @xmath0 and let @xmath440 @xmath441 , where the vertices of the cycle @xmath439 are given in the clockwise order of the cycle .",
    "consider any pair of of consecutive vertices in @xmath439 . without loss of generality ,",
    "let @xmath57 be this pair .",
    "the paths @xmath442 and @xmath443 are obviously two internally vertex disjoint paths in @xmath0 , between @xmath44 and @xmath45 .",
    "since the path @xmath442 is internally vertex disjoint from any other path in @xmath0 between @xmath44 and @xmath45 , it is enough to show that , there can not be two internally vertex disjoint paths @xmath202 and @xmath444 between @xmath44 and @xmath45 without using the edge @xmath57 . for contradiction , assume that @xmath202 and @xmath444 are two internally vertex disjoint paths between @xmath44 and @xmath45 without using the edge @xmath57 . let @xmath445 be the first edge of @xmath202 and @xmath446 be the first edge of @xmath444",
    ". without loss of generality , assume that @xmath447 .",
    "this implies that the edge @xmath445 is not an edge of the exterior cycle @xmath439 and hence , the ( curve corresponding to the ) edge @xmath445 splits the region bounded by @xmath439 into two parts .",
    "let the closed region bounded by the path @xmath448 and the edge @xmath445 be denoted by @xmath449 and the closed region bounded by by the path @xmath450 and the edge @xmath445 be denoted by @xmath451 .",
    "let the subpath of @xmath444 from @xmath452 to @xmath45 be denoted by @xmath453 . since @xmath452 is in @xmath454 and @xmath45 is in @xmath455 , the path @xmath453 has to cross from @xmath449 to @xmath451 at least once .",
    "since @xmath444 is vertex disjoint from @xmath202 , the path @xmath453 can not cross from @xmath449 to @xmath451 at @xmath305 . since the path @xmath444 is simple , @xmath453 can not cross from @xmath449 to @xmath451 at @xmath44 also .",
    "this implies that there is an edge @xmath129 in @xmath453 with @xmath119 belonging to @xmath454 and @xmath77 belonging to @xmath455 .",
    "this would mean that the curve corresponding to the edge @xmath129 will cross the curve corresponding to the edge @xmath445 , which is a contradiction , because by our assumption , our embedding is an outerplanar embedding .",
    "therefore , there can not be two internally vertex disjoint paths @xmath202 and @xmath444 between @xmath44 and @xmath45 without using the edge @xmath57 .",
    "thus , the number of internally vertex disjoint paths between any two consecutive vertices in the hamiltonian cycle of @xmath0 is exactly two .",
    "for any cut vertex @xmath343 of @xmath15 , let @xmath456 denote the hamiltonian cycle successor of @xmath343 in the ( unique ) child block at @xmath343 and let @xmath457 denote the subgraph of @xmath15 induced on the vertices belonging to the child block attached at @xmath343 and its descendant blocks .",
    "we call the variables @xmath458 @xmath459 , bypass[$ ] @xmath459 , completedcount$ ] the variables relevant for the traversal .",
    "first we prove two basic lemmas which makes the proof of lemma [ orderencounter ] easier .",
    "[ easyprop ] at any point of execution , if a non - cut vertex @xmath119 is encountered , i.e. , @xmath128 is set to @xmath119 , until a cut vertex is encountered in line [ reassignv ] or @xmath460 , from each vertex the algorithm proceed to encounter its hamiltonian successor in the current block , completing it and incrementing the @xmath461 by one each time .    if @xmath119 is encountered in line [ initialvertexline ] ,",
    "the next vertex is encountered in line [ reassignv ] , inside the outer while - loop .",
    "when @xmath128 is a non - cut vertex encountered in line [ reassignv ] or line [ childblockline ] , the inner while - loop condition and the condition in line [ checkline ] will be evaluated to false until a cut vertex is encountered in line [ reassignv ] .",
    "therefore , the variables relevant for the traversal can get updated in lines [ completeline2]-[reassignline ] and lines [ reassignv]-[initialseq ] only , until @xmath128 gets assigned to refer to a cut vertex . from this , the property follows .",
    "[ recursivetraversal ] suppose at a certain time @xmath462 of execution , algorithm [ algbiconnect ] has just executed line [ innerwhile ] and the variable @xmath128 is referring to a cut vertex @xmath60 in @xmath15 and the following conditions are also true :    * the current block being traversed , i.e. the block referred to by the variable @xmath208 , is the parent block at @xmath60 .",
    "* @xmath290false and for each cut vertex @xmath343 of @xmath463 , @xmath464false .",
    "* for each vertex @xmath343 of @xmath463 , @xmath465 false and @xmath466 , where @xmath467    then , the algorithm will again come to line [ innerwhile ] with the variable @xmath128 referring to the same cut vertex @xmath60 .",
    "let @xmath468 be the next time after @xmath462 when this happens . at time @xmath468",
    ", the following conditions will be true :    * [ e1 ] the current block being traversed is the child block at @xmath60 and during the time between @xmath462 and @xmath468 the algorithm never sets the variable @xmath208 to a block other than the child block at @xmath60 or its descendant blocks . * [ e2 ] @xmath290true and for each cut vertex @xmath343 of @xmath463 , @xmath464true . *",
    "[ e3 ] @xmath469false and for each vertex @xmath343 of @xmath463 other than @xmath60 , @xmath465true and @xmath470 . * [ e4 ] the order in which the algorithm encounters vertices during the period from the time @xmath60 was encountered just before @xmath462 and till the time @xmath468 is @xmath471 .",
    "we give a detailed proof of this lemma below , which is in principle just a description of the execution of the algorithm . instead of going through the proof",
    ", the reader may verify the correctness of the lemma directly from the algorithm .",
    "we prove this lemma using an induction on @xmath472 , the number of blocks in @xmath463 . for the base case ,",
    "assume that @xmath473 ; i.e. , @xmath463 is a leaf block of @xmath15 .",
    "suppose the assumptions in the statement of the lemma hold at time @xmath462 . by this assumption",
    ", the condition of the inner while - loop in line [ innerwhile ] has been evaluated to true at time @xmath462 and after executing line [ bypassline ] @xmath292 will be set to true .",
    "similarly , it follows from the assumptions that after executing line [ childblockline ] the current block is set as the child block at @xmath60 and the algorithm sets @xmath474 , the successor of @xmath60 in the child block at @xmath60 . since the child block at @xmath60 is a leaf block , @xmath474 is not a cut vertex . by lemma [ easyprop ] , until @xmath128 gets assigned to refer to a cut vertex , from each vertex the algorithm proceed to encounter its hamiltonian successor in the current block , completing it and incrementing the @xmath461 by one each time . note",
    "that @xmath475 all this time , because at time @xmath462 , we had @xmath467 and the number of times @xmath461 was incremented since time @xmath462 is less than @xmath476 .",
    "since the only cut vertex in the current block is @xmath60 itself , this goes on until @xmath60 is encountered in line [ reassignv ] and then it reaches line [ innerwhile ] at time @xmath468 . from this",
    ", it follows that the order in which vertices were encountered during the period from the time @xmath60 was encountered just before @xmath462 and till the time @xmath468 is the hamiltonian cycle order of the child block at @xmath60 , starting and ending at @xmath60 .",
    "this is precisely @xmath471 .",
    "it is evident that conditions @xmath477 - @xmath478 are also true at time @xmath468 .",
    "now , we will assume that the lemma holds for all cut vertices @xmath343 such that @xmath479 . in order to prove the lemma ,",
    "it is enough to prove that the lemma holds for @xmath60 as well .",
    "let @xmath480 be the hamiltonian cycle of the child block at @xmath60 .",
    "suppose the assumptions in the statement of the lemma hold at time @xmath462 when the algorithm [ algbiconnect ] has just executed line [ innerwhile ] and @xmath291 .",
    "as in the base case , @xmath292 will be set to true and in line [ childblockline ] the current block is set as the child block at @xmath60 and the algorithm sets @xmath481 .",
    "if the set @xmath482 does not contain any cut vertices , we are in the base case and we are done .",
    "otherwise , let @xmath483 be the minimum index in @xmath484 such that @xmath485 is a cut vertex .",
    "by lemma [ easyprop ] , from each vertex the algorithm proceed to encounter its hamiltonian successor in the current block , completing it and incrementing the @xmath461 each time until @xmath486 .",
    "notice that @xmath487 , when @xmath485 is encountered in line [ reassignv ] .",
    "after this , the algorithm reaches line [ innerwhile ] and executes it with @xmath486 at time @xmath488 .",
    "at this time , the block being traversed is the parent block at @xmath485 . since @xmath485 or any other vertex in @xmath489",
    "were not encountered till now after @xmath462 , and by the assumptions of the lemma about the state of the traversal related variables at time @xmath462 , we know that at time @xmath488 , @xmath490false and for each cut vertex @xmath491 of @xmath489 , @xmath492false .",
    "similarly , for each vertex @xmath343 of @xmath489 , @xmath465 false .",
    "thus , the pre - conditions of the lemma are satisfied for the vertex @xmath485 and @xmath493 at time @xmath488 .",
    "the order in which the vertices are encountered during the period from the time @xmath60 was encountered just before @xmath462 and till the time @xmath488 is @xmath494 . since @xmath485 is a cut vertex in the child block at @xmath60 , @xmath495 .",
    "therefore , by induction hypothesis , the algorithm will again come to line [ innerwhile ] with the variable @xmath486 and if @xmath496 is the next time this happens after @xmath497 , the conditions @xmath477 - @xmath498 will be satisfied with @xmath485 replacing @xmath60 , @xmath488 and @xmath496 replacing @xmath462 and @xmath468 respectively and @xmath499 replacing @xmath500 .    at time",
    "@xmath496 , when the algorithm is back at line [ innerwhile ] and executes the line with @xmath486 and @xmath490true , the while - loop condition will evaluate to false and so , the loop will not be entered .",
    "when the algorithm reaches line [ checkline ] , the condition will evaluate to true and therefore , in line [ parentblockline ] , the variable @xmath208 will be updated to its parent block . since @xmath208 is the child block at @xmath485 before this , @xmath208 will be updated to the parent block at @xmath485 , which is the same as the child block at @xmath60 . in line [ completeline2 ] , @xmath501 is set to true and @xmath461 becomes @xmath502 and therefore , in line [ outerwhile ] , the outer while - loop condition evaluates to true .",
    "since @xmath486 now , the algorithm executes line [ reassignv ] , and @xmath128 will be updated to @xmath503 , the successor of @xmath485 in @xmath208 . from the time",
    "@xmath60 was encountered just before @xmath462 , the order in which the algorithm has encountered vertices is @xmath504 .    by repeating similar arguments as above",
    ", we can reach the following conclusion .",
    "if @xmath177 is the maximum index in @xmath484 such that @xmath305 is a cut vertex , the algorithm will come to line [ innerwhile ] with the variable @xmath314 at time @xmath505 such that the conditions below will be true at time @xmath505 .    *",
    "the current block being traversed is the child block at @xmath305 . during the time between @xmath462 and @xmath505 the algorithm never sets the variable @xmath208 to a block other than the child block at @xmath60 or its descendant blocks .",
    "* for each cut vertex @xmath343 of @xmath463 , @xmath464true .",
    "* for @xmath506 , @xmath507false and for each vertex @xmath343 of @xmath463 outside this set , + @xmath465true .",
    "moreover , @xmath508 * the order in which the algorithm encounters vertices during the period from the time @xmath60 was encountered just before @xmath462 and till the time @xmath505 is given by @xmath509 , where for @xmath510 , @xmath511 if @xmath452 is not a cut vertex in @xmath15 and @xmath512 otherwise .    by similar arguments as at time @xmath496",
    ", we can show that , at the time @xmath505 , the inner while - loop condition is false , because @xmath513true and in line [ parentblockline ] the variable @xmath208 will be updated to the child block at @xmath60 . in line [ completeline2 ]",
    ", @xmath514 is set to true and @xmath461 becomes @xmath515 . since this value is less than @xmath516 , in line [ outerwhile ] the outer while - loop condition evaluates to true .",
    "since @xmath314 now , the algorithm executes line [ reassignv ] , and @xmath128 will be updated to the successor of @xmath305 in @xmath208 .    if @xmath517 , then at this stage , @xmath291 and when the algorithm reaches line [ innerwhile ] , that is the time @xmath468 mentioned in the lemma and the order in which the algorithm has encountered vertices is @xmath518 , where for @xmath519 , @xmath511 if @xmath452 is not a cut vertex in @xmath15 and @xmath512 otherwise . if @xmath520 , by the maximality of @xmath177 and using lemma [ easyprop ] , until @xmath128 gets assigned the value @xmath60 in line [ reassignv ] , from each vertex the algorithm proceed to encounter its hamiltonian successor in the current block , completing it and incrementing the @xmath461 each time",
    "we have @xmath475 all this time , because at time @xmath462 we had @xmath466 and afterwards @xmath461 was incremented once for each vertex @xmath343 in @xmath463 for which @xmath521 but @xmath469false still .",
    "when @xmath60 is encountered in line [ reassignv ] and then the algorithm reaches line [ innerwhile ] , that is the time @xmath468 mentioned in the lemma . from the time when @xmath60 was encountered just before @xmath462 , the order in which the algorithm has encountered vertices is @xmath518 , where for @xmath510 , @xmath511 if @xmath452 is not a cut vertex in @xmath15 and @xmath512 otherwise .",
    "thus , in both cases , at time @xmath468 the order in which the algorithm has encountered vertices from the time when @xmath60 was encountered just before @xmath462 is given by @xmath522 .",
    "notice also that the conditions @xmath477-@xmath478 also hold at time @xmath468 and hence the lemma is proved .",
    "* lemma [ orderencounter ] . *",
    "if @xmath15 is given as the input graph to algorithm [ algbiconnect ] , where @xmath15 is a connected outerplanar graph with at least two vertices , such that for every cut vertex @xmath60 of @xmath15 , @xmath241 has exactly two connected components , and if @xmath287 is the non - cut vertex in the root block of @xmath15 from which the algorithm starts the traversal , then @xmath288 is the order in which algorithm [ algbiconnect ] encounters the vertices of @xmath15 .",
    "suppose @xmath523 is the hamiltonian cycle of the root block of @xmath15 .",
    "our method is to use lemma [ recursivetraversal ] at each cut vertex in the root block of @xmath15 and lemma [ easyprop ] at each non - cut vertex in the root block of @xmath15 , until @xmath524 .",
    "we will see that this will go on until @xmath525 is completed .    after the initializations done in lines [ forloop ] - [ completeline1 ] , for every cut vertex @xmath343 in @xmath15 , @xmath464false , current block",
    "@xmath208 is the root block of @xmath15 , @xmath526 , @xmath527 , @xmath528=true and for every other vertex @xmath343 in @xmath15 , @xmath529=false .",
    "since the outer while - loop condition is true , the algorithm enters the loop and in line [ reassignv ] , @xmath44 is encountered .",
    "let us call this instant as time @xmath462 .",
    "if the set @xmath530 contains a cut vertex , let @xmath483 be the minimum index in @xmath484 such that @xmath485 is a cut vertex .",
    "otherwise , let @xmath531 .",
    "by lemma [ easyprop ] , until @xmath128 gets assigned the value @xmath485 in line [ reassignv ] , from each vertex the algorithm proceed to encounter its hamiltonian successor in the current block ( i.e the root block ) , completing it and incrementing the @xmath461 each time , making @xmath532 when @xmath485 is encountered in line [ reassignv ] .",
    "the algorithm then reaches line [ innerwhile ] and executes it with @xmath486 .",
    "let us call this instant as time @xmath488 .",
    "the order in which the vertices are encountered from the beginning of execution of the algorithm is @xmath533 .",
    "if @xmath534 and @xmath485 is not a cut vertex , that means the graph @xmath15 does not have a cut vertex and @xmath535 . in this case",
    ", the inner while - loop condition evaluates to false .",
    "similarly , the condition in line [ checkline ] also evaluates to false . in line [ completeline2 ] ,",
    "the algorithm sets @xmath536true and increments @xmath461 , making @xmath537 .",
    "when the algorithm executes line [ outerwhile ] , the outer while - loop condition evaluates to false and the algorithm terminates .",
    "the order in which the vertices were encountered from the beginning of execution of the algorithm is @xmath538 .",
    "the other case is when @xmath485 is a cut vertex at time @xmath488 . at this time ,",
    "@xmath539 and by similar arguments as in the proof of lemma [ recursivetraversal ] , the pre - conditions of the lemma are satisfied for the vertex @xmath485 and @xmath493 at time @xmath488 .",
    "therefore , by lemma [ recursivetraversal ] applied to the vertex @xmath485 and @xmath493 , the algorithm will again come to line [ innerwhile ] with the variable @xmath486 . if @xmath496 is the next time this happens after @xmath488 , we can see that the state of the traversal related variables at time @xmath496 is similar to those we obtained in the proof of lemma [ recursivetraversal ] , except that @xmath540 .",
    "following similar arguments as in the proof of lemma [ recursivetraversal ] , we can show that when the algorithm executes line [ parentblockline ] the next time after @xmath496 , the variable @xmath208 will be updated to the parent block at @xmath485 , which is the same as the root block . in line [ completeline2 ] ,",
    "@xmath501 is set to true and @xmath461 becomes @xmath541 .    by repeating similar arguments as in the proof of lemma [ recursivetraversal ]",
    ", we can reach the following conclusion .",
    "if @xmath177 is the maximum index in @xmath484 such that @xmath305 is a cut vertex , the algorithm will come to line [ innerwhile ] with the variable @xmath314 at time @xmath505 such that the conditions below will be true at time @xmath505 .    *",
    "the current block being traversed is the child block at @xmath305 .",
    "* for each cut vertex @xmath343 of @xmath15 , @xmath464true .",
    "* for @xmath542 , @xmath507false and for each vertex @xmath343 of @xmath15 outside this set , + @xmath465true .",
    "moreover , @xmath543 * the order in which the algorithm encounters vertices from the beginning of execution of the algorithm till the time @xmath505 is given by @xmath544 , where for @xmath510 , @xmath511 if @xmath452 is not a cut vertex in @xmath15 and @xmath512 otherwise .    by similar arguments as earlier ,",
    "when the algorithm executes line [ parentblockline ] the next time after @xmath505 , the variable @xmath208 will be updated to the parent block at @xmath305 , which is the same as the root block . in line",
    "[ completeline2 ] , @xmath514 is set to true and @xmath461 becomes @xmath545 .    if the above sum is equal to @xmath516 , that means @xmath517 .",
    "when the algorithm executes line [ outerwhile ] , the outer while - loop condition evaluates to false and the algorithm terminates .",
    "the order in which the vertices were encountered from the beginning of execution of the algorithm is @xmath546 , where for @xmath519 , @xmath511 if @xmath452 is not a cut vertex in @xmath15 and @xmath512 otherwise .",
    "this is the same as @xmath288 .    instead , if the sum is less than @xmath516 , then @xmath520 .",
    "in line [ outerwhile ] the outer while - loop condition evaluates to true .",
    "since @xmath314 and @xmath208 is the root block , when the algorithm executes line [ reassignv ] , @xmath128 will be updated to @xmath547 , the successor of @xmath305 in the root block . by the maximality of @xmath177 and using similar arguments as earlier , we can show that until @xmath128 gets assigned the value @xmath525 in line [ reassignv ] , from each vertex the algorithm proceed to encounter its hamiltonian successor in the current block .",
    "when @xmath525 is encountered in line [ reassignv ] and then reach line [ innerwhile ] , the condition of the inner while - loop will evaluate to false because @xmath525 is not a cut vertex .",
    "similarly , the condition in line [ checkline ] will also evaluate to false . in line [ completeline2 ] , @xmath548 is set to true and @xmath461 becomes @xmath549 , which is equal to @xmath516 .",
    "when the algorithm executes line [ outerwhile ] , the outer while - loop condition evaluates to false and the algorithm terminates . from the beginning of execution , the order in which the algorithm has encountered vertices is @xmath546 , where for @xmath510 , @xmath511 if @xmath452 is not a cut vertex in @xmath15 and @xmath512 otherwise .",
    "this order is the same as @xmath288 ."
  ],
  "abstract_text": [
    "<S> given a connected outerplanar graph @xmath0 of pathwidth @xmath1 , we give an algorithm to add edges to @xmath0 to get a supergraph of @xmath0 , which is @xmath2-vertex - connected , outerplanar and of pathwidth @xmath3 . </S>",
    "<S> this settles an open problem raised by biedl @xcite , in the context of computing minimum height planar straight line drawings of outerplanar graphs , with their vertices placed on a two dimensional grid . in conjunction with the result of this paper , the constant factor approximation algorithm for this problem obtained by biedl @xcite for @xmath2-vertex - connected outerplanar graphs will work for all outer planar graphs .    </S>",
    "<S> pathwidth , outerplanar graph,@xmath2-vertex - connected </S>"
  ]
}