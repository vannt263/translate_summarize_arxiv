{
  "article_text": [
    "geometry images ( gims ) are a completely regular remeshing method , which represents a three - dimensional mesh using an image - like structure , with the connectivity information encoded in the image space @xcite .",
    "the main procedure of gims includes three steps : mesh parametrization , sampling and scaling .",
    "a three - dimensional mesh is first mapped onto a square or spherical parametric domain , and a three - dimensional matrix is then obtained by sampling coordinates of points over the parametrized domain , and the matrix is finally transformed into an image array with a proper scaling . to rebuild the mesh ,",
    "the vertices are obtained by transforming the rgb values of the image into cartesian coordinates , and the edges are obtained by connecting all the pairwise vertices which are adjacent in the array .",
    "the reconstruction error arising from gims includes two parts : the _ sampling error _ produced in the sampling step , depending on the parametrization methods , the sampling methods , gim resolutions and interpolating functions , and the _ round - off error _ produced trivially in the scaling step , depending on the scaling between the coordinate values of vertices and rgb values of gims .    to effectively decrease reconstruction errors ,",
    "a solution is to adopt a mesh parametrization minimizing the geometric stretch in gims , where the stretch metric is derived from a taylor expansion of geometric errors .",
    "although such a parametrization is directly derived from the reconstruction error , it is difficult to achieve the global minimizer of the metric because of the multivariate nonconvex optimization problem .",
    "an alternative is to first map the whole mesh piecewise onto several charts , each of which has small distortion and hence is effectively sampled , and then pack them together into a gim .",
    "such methods , referred to as multi - chart gims @xcite , not only solve the large distortion problem but also handle genus - nonzero meshes .",
    "however , multi - chart gims have low efficiency in packing irregular charts , as the graph cut has to be performed to fit both decreasing geometric stretch over a mesh and fewer cutting nodes and branches .",
    "this paper proposes _ connectivity - preserving geometry images _ ( cgims ) , which map a three - dimensional triangular mesh onto an image array which intrinsically preserves the vertex - set and the connectivity of the original mesh .",
    "the motivation comes from the observation that the connectivity of the mesh be preserved by allowing each vertex to appear repeatedly in an image array ( the second column of fig .",
    "[ fig - igim1 ] ) .",
    "such a structure of cgims treats every vertex evenly which preserves details of meshes well .",
    "compared with traditional gims , cgims produce larger resolutions for representing meshes and spend more time for encoding cgim arrays and reconstruction from compressed cgim arrays .",
    "however , experimental results of lossy compression show that by using the multi - stage base color and index map ( mbcim ) scheme as image codec , cgims give promising results in both detail preservations and the peak signal - to - noise ratio ( psnr ) curves .",
    "the paper is organized as follows .",
    "we introduce related work regarding gims in section  [ sec-2 ] .",
    "we give an overview of cgims in section  [ sec-3 ] .",
    "we show the main results of this paper in section  [ sec-4 ] , where we give the main idea of all the phases of cgims , a cgim property and a complete cgim algorithm .",
    "we give other cgim algorithms in section  [ sec-5 ] , including cgims with smaller resolutions and mesh reconstruction from compressed cgims .",
    "we apply cgims to lossy compression of meshes in section  [ sec-6 ] by using jpeg2000 and the mbcim scheme .",
    "we conclude this paper in section  [ sec-7 ] with limitations of cgims and future work .",
    "_ _ single - chart gims__the pioneering work of gims performs a graph - cut over closed meshes , maps them onto a square domain by using a minimizing - geometric - stretch parametrization , and imposes a regular sampling for surface geometry @xcite .",
    "zhou et al .",
    "present gims using adaptive sampling , and employs the jpeg2000 codec for mesh compression @xcite .",
    "praun and hoppe use spherical parametrization to map a genus - zero surface onto a spherical domain @xcite . gauthier and poulin",
    "propose another spherical gim to treat arbitrary genus surfaces , with the holes explicitly represented using genus reduction @xcite .",
    "meng et al .",
    "integrate differential coordinates into traditional gims for geometric morphing @xcite .",
    "_ _ multi - chart gims__as mapping an entire surface to a single chart may produce large distortion , multi - chart gims are developed .",
    "sander et al .",
    "map the mesh piecewise onto several charts and pack them together into a gim @xcite .",
    "carr et al .",
    "partition a mesh into quasi - rectangular clusters which map to rectangular charts in parameter space @xcite . yao and lee decompose a mesh into square gim charts with different resolutions , each of which is adaptively determined by a local reconstruction error @xcite .",
    "feng et al .",
    "generate triangular patches for input meshes using a curvilinear feature that preserves salient features and supports gpu - based lod representation of meshes @xcite .",
    "_ _ applications of gims__research work on applications of gims includes mesh compression @xcite , smooth surface representation @xcite , face recognition @xcite , texture synthesis @xcite , and facial expression modeling @xcite .",
    "we do not list detailed work in order to focus in priority on our work .",
    "the main idea of cgims is to arrange all the vertices of a mesh into a _ v - matrix _",
    "( i.e. a matrix whose elements uniquely correspond to vertices of the mesh ) by inserting them repeatedly , such that the vertex - set and the edge - set generated by the v - matrix are equal to the vertex - set and the connectivity of the original mesh respectively .",
    "then a cgim array is obtained by transforming the cartesian coordinates of all elements of the v - matrix to pixel values . to reconstruct a mesh from the cgim array",
    ", we obtain the vertex - set by collecting elements with different encoding coordinates , and obtain the edge - set by collecting pairwise elements of the array with different encoding connectivity .",
    "accordingly , a cgim algorithm contains three phases : , and , where the first phase gives a v - matrix , the second one transforms the v - matrix into a cgim array , and the last one reconstructs a mesh from the cgim array . among the three phases , is key for cgims , whose algorithm is accordingly tricky and complicated .",
    "before we detail its algorithm in the next section , we shall give a simple understanding of the main idea of .",
    "the phase includes the following three sub - phases .",
    "the first phase partitions the vertex - set of the mesh into several ordered subsets called _ levels _ , the second phase adds repeated elements within those levels so that each pair of neighboring levels preserves an associated edge - set , and the last phase adds repeated elements within the levels again to maintain them in an image - like structure .",
    "the rule for adding repeated elements is based on the edge - set induced by each pair of neighboring levels .        in the following introduction of three sub - phases ,",
    "we define a _ level _ of length @xmath0 to be an @xmath0-tuple @xmath1 $ ] whose elements are vertices of the mesh , and call each @xmath2 to be an _ element _ of the level .    *",
    "* the phase gives a sequence of levels of the mesh ( each level contains no repeated elements but different levels may share common elements and may have different lengths ) such that the union of all elements of all the levels is equal to the vertex - set of the mesh . obtaining such a level sequence",
    "is a fundamental work for the phase , and has to satisfy several properties described in lemma  1 , section  a of the supplementary material .",
    "basically such properties guarantee that each edge of the mesh be characterized either by pairwise neighboring elements of a level ( such an edge is referred to as an _ intra - level edge _ ) , or by pairwise elements from two neighboring levels ( such an edge is referred to as an _ inter - level edge _ ) . can be described by using two strips : @xmath3 , with @xmath4 corresponding to the face set generated by the first and second output levels , and @xmath5 corresponding to the face set generated by the second and third output levels ( the red triangles of the last column ) .",
    "similarly , the second example of fig .  [ fig - igim1 ] can be described by using three strips : @xmath6 , with @xmath7 corresponding to the face set generated by the first and second output levels , and @xmath8 corresponding to the face set generated by the second and third output levels , and @xmath9 corresponding to the face set generated by the third and fourth output levels .",
    "while triangle strips propose an efficient storage of triangular meshes , such a method can not generate an image - like array of vertices and hence no image codec can be imposed . ]    * * the phase transforms each level obtained in previous phase to two levels , one of which coincides with the former level and the other of which coincides with the latter level , by inserting repeated elements within each level .",
    "this work guarantees that the lengths of two neighboring levels be the same and the end - vertices of each inter - level edge appear in correct locations .    * * although the inter - level edges are preserved in pairwise levels and the intra - level edges are preserved in neighboring elements of each level , we can not obtain a v - matrix preserving the vertex - set and the edge - set of the mesh unless all the levels obtained from previous phase have the same length .",
    "the phase accomplishes this work by adding repeated elements within each level such that the pairwise levels obtained from previous phase are exactly the same .",
    "this section gives details of all phases of cgims .",
    "we first introduce some definitions and notations .",
    "let @xmath10 be a triangular mesh in @xmath11 .",
    "we denote @xmath12 if the vertices",
    "@xmath13 , @xmath14 are adjacent in @xmath10 , otherwise we denote @xmath15 ; we denote @xmath16 if the vertices @xmath13 , @xmath14 are the same vertex in @xmath10 , otherwise we denote @xmath17 .",
    "we denote @xmath18 , @xmath19 , @xmath20 to be the vertex - set , the edge - set , the collection of all boundary vertices of @xmath10 respectively , and denote @xmath21 to be the collection of all the vertices adjacent to @xmath13 in @xmath10 .",
    "a _ v - matrix _ with respect to @xmath10 is defined to be a two - dimensional array whose elements are vertices of @xmath10 ; a _ level _ of @xmath10 is defined to be an @xmath0-tuple @xmath1 $ ] whose elements are vertices of @xmath10 , where @xmath0 is called the length of the level .",
    "we denote @xmath22 to be the @xmath23-th element of a level @xmath24 , and we call @xmath23 to be the _ index _ of @xmath13 in @xmath24 if @xmath25 , @xmath26 . we denote @xmath27 to be the last element of @xmath24 , and denote @xmath28 $ ] if @xmath29 ; otherwise , we denote @xmath30 .",
    "we denote @xmath31 to be the number of all elements of a set @xmath32 or the length of a level @xmath32 , and denote @xmath33 to be the number of all @xmath13 s of a level @xmath24 .",
    "we adopt the convention that when we perform set operations ( e.g. @xmath34 ) on a level @xmath24 , then @xmath24 represents the collection of all different elements of the level @xmath24 .",
    "let @xmath35 be vertices and let @xmath36 be levels .",
    "then @xmath13 is called an adjacent element of @xmath37 in @xmath24 if @xmath38 ; moreover , @xmath13 is called an adjacent element of @xmath39 in @xmath24 if there exists @xmath40 such that @xmath38 .",
    "let @xmath41 be two levels of @xmath10 with the same length .",
    "the _ edge - set induced by _",
    "@xmath41 , denoted by @xmath42 , is defined to be the collection of pairwise vertices obtained by connecting each pair of distinct neighboring elements ( the horizontal , vertical and slash directions ) of @xmath41 , i.e.    @xmath43 each element of which has distinct end - vertices , with the index @xmath23 taking all available values .",
    "let @xmath44 be a level sequence of the mesh , @xmath45 .",
    "the * concatenate * operator @xmath46 which maps the level sequence to a novel level is deductively defined by @xmath47 ,   \\\\ & \\langle \\mathcal{l}_1,\\mathcal{l}_2,\\ldots,\\mathcal{l}_n \\rangle : = \\langle ~ \\langle \\mathcal{l}_1,\\mathcal{l}_2,\\ldots,\\mathcal{l}_{n-1}\\rangle , ~ \\mathcal{l}_n \\rangle . \\end{aligned}\\ ] ]    the following definitions are given for partitioning the vertex - set into several levels of the mesh ; such partition is non - trivial as we can see the difference from two examples of fig .",
    "[ fig - igim1 ] ( in the first example the vertices are ",
    "well organized \" so that the partitioned levels share no common vertices ; however in the second example , the partitioned levels share some vertices in order to preserve the connectivity of the mesh ) .",
    "the * irregular pair * in the following definition is an important tool to check whether the vertices are  well organized \" .",
    "[ def - component ] let @xmath48 $ ] be a level of a mesh .",
    "a * sublevel * @xmath49 $ ] , @xmath50 of @xmath51 is defined to be a level consisting of elements of @xmath51 obeying the same relationship of indices of @xmath51 , i.e. @xmath52 . a * component * @xmath53 $ ] of @xmath51 is defined to be a sublevel of @xmath51 such that @xmath54 with @xmath55 , where the first ( the last , respectively ) relationship is valid when the subscript of @xmath56 arrives to 0 ( @xmath57 , respectively ) . a set of single vertex @xmath58 is defined to be a component of @xmath51 if @xmath59 and @xmath60 .",
    "[ def - irre ] let @xmath61 $ ] be a component of a level , @xmath45 .",
    "an * irregular pair * of @xmath62 is defined to be pairwise integers @xmath63 such that @xmath64 where @xmath65 degenerates into @xmath66 ( @xmath67 , respectively ) when one of the subscripts of @xmath56 in @xmath65 is @xmath68 ( @xmath57 , respectively ) .",
    "the vertices @xmath69 are called the end - vertices of the irregular pair @xmath70 .",
    "[ def - proper ] let @xmath51 be a level of a mesh and let @xmath71 be a sublevel of @xmath51 .",
    "then @xmath71 is called a * proper * sublevel of @xmath51 if each component of @xmath71 contains no end - vertices of irregular pairs satisfying equation  ( [ eq - irre1 ] ) and if each component of @xmath71 contains at most an end - vertex of irregular pairs satisfying equation  ( [ eq - irre2 ] ) .",
    "$ ] be a level which is also a component of itself . then @xmath72 are irregular pairs of @xmath51 , and @xmath73 $ ] , @xmath74 $ ] are both proper sublevels of @xmath51 , but @xmath75 $ ] , @xmath76 $ ] are not proper sublevels of @xmath51 because @xmath77 is an irregular pair and because the vertex @xmath78 is an end - vertex of an irregular pair satisfying equation  ( [ eq - irre1 ] ) , respectively.,scaledwidth=30.0% ]    we show an example of proper sublevels in fig .",
    "[ fig - proper ] .",
    "now we give an intuitive explanation to help readers understand the above definitions .",
    "the proper sublevel is used for determining the level sequence in the phase .",
    "suppose that @xmath79 are given .",
    "we shall choose the elements from the adjacent elements of @xmath80 . if the adjacent elements of @xmath80 are  well organized \" ( i.e. they can be arranged to be adjacent one by one , such as the first example of fig .  [ fig - exam2 ] ) , then @xmath81 is simply chosen to be all these elements .",
    "however there exist cases in which all these elements are not  well organized \" .",
    "see the second example of fig .",
    "[ fig - exam2 ] : whatever combination you choose ( e.g. @xmath82 or others ) , the vertices @xmath83 have no adjacent elements in the forthcoming level as they are isolated by edges within @xmath80 and @xmath84 .",
    "in order to guarantee that no incorrect connectivity be produced in such a case , we can only choose a subset of all these elements together with some elements from @xmath80 to form @xmath84 . as we notice that such  isolated \" vertices appear only when irregular pairs exist ( e.g. @xmath85 are irregular pairs of the candidate level @xmath86 $ ] ) , we must choose the subset containing no irregular pairs , which make the proper sublevels a good option .",
    "[ def - align1](the function for the * slash*-direction connection )   let @xmath87 $ ] , @xmath88 $ ] be two levels of a mesh , @xmath89 .",
    "the function @xmath90 returns the following pairwise levels @xmath91 \\\\",
    "\\mathcal{l}'_2 = [ \\underbrace{w_1,\\ldots , w_1}_{\\max(1,d'_{1 } ) } , \\underbrace{w_2,\\ldots , w_2}_{\\max(1,d'_{2 } ) } , \\cdots , ~\\underbrace{w_n,\\ldots , w_n}_{\\max(1,d'_{n } ) } ] \\end{array}\\ ] ] where @xmath92          a rough procedure for the phase for open genus - zero triangular meshes is described in fig .",
    "[ fig - flowchart ] , where the phase recursively determines the level @xmath81 by using @xmath80 and its neighboring elements , until all vertices are traversed . before going to the detailed algorithm of section  [ sec-45 ]",
    ", we illustrate the main idea using two examples of fig .",
    "[ fig - exam2 ] .",
    "when the neighboring elements of @xmath80 contain no irregular pairs ( see the first example , where the vertices of the component @xmath93 $ ] are simply connected one by one ) , then @xmath84 is simply chosen to be @xmath93 $ ] ; otherwise ( see the second example , where @xmath94 occurs while @xmath95 are located in nonadjacent positions within @xmath96 $ ] ) , we choose @xmath84 to be the union of a few vertices of @xmath97 together with some vertices of @xmath80 .",
    "we briefly outline the three sub - phases : , , as follows , and give the detailed algorithm in the next section .    * * the purpose of this phase is to obtain a level sequence @xmath84 , @xmath98 .",
    "we first parametrize an open genus - zero mesh @xmath10 onto the planar domain @xmath99\\times[0,1]$ ] by using tutte s parametrization @xcite , and choose all the vertices whose ordinate is one to be the initial level @xmath100 . for @xmath101",
    ", we recursively determine the level @xmath81 in two steps : ( i ) obtain a candidate level @xmath51 by ordering each @xmath102 in counterclockwise direction with respect to @xmath103 , and removing repeated elements within adjacent locations of @xmath51 ; ( ii ) if @xmath51 contains no irregular pairs , then we obtain @xmath81 by _ combining _",
    "@xmath51 _ with _ @xmath80 ( see the figure on the left ) ; otherwise , we obtain @xmath81 by _ combining _ a proper sublevel of @xmath51 _ with _ @xmath80 .",
    "the whole loop ends when @xmath104 holds .",
    "* * the purpose of this phase is to obtain a level sequence @xmath105 such that : @xmath106 , and all the edge - sets induced by @xmath107 are equal to the edge - set of @xmath10 .",
    "we do it in this way : for each distinct element @xmath108 , we check the number of its neighbors in @xmath109 , and add @xmath13 in @xmath81 repeatedly to maintain the connectivity , then we repeat the same step by adding @xmath13 in @xmath109 for @xmath110 .    *",
    "* * * so far , we obtain a level sequence @xmath105 such that @xmath111 , where @xmath112 contain the same elements with different numbers in them . we denote @xmath113 to be all different elements of @xmath114 in turn .",
    "the purpose of this phase is to obtain another level sequence @xmath115 such that all the levels @xmath116 have the same length , and the edge - set induced by @xmath107 equals to the edge - set induced by @xmath117 .",
    "we do it in this way : first for @xmath118 , we add repeated elements in @xmath119 such that @xmath120 , and we simultaneously add repeated elements in @xmath121 to maintain the same length of @xmath107 and the same edge - set induced by @xmath107 ; then for @xmath122 , we add repeated elements in @xmath121 such that @xmath123 .",
    "that makes @xmath124 become exactly the same set , and consequently gives the level @xmath116 .",
    "finally , we obtain a v - matrix @xmath125 with respect to @xmath10 by setting @xmath116 as its @xmath126-th row vector : obtained in the phase .",
    "the phase accordingly transforms the cgim array to a vertex - set and an edge - set of the reconstructive mesh .",
    "such two phases are trivial hence we omit the details . ]",
    "@xmath127      let @xmath125 be a v - matrix with respect to a mesh @xmath10 with @xmath128 rows and @xmath0 columns .",
    "we denote @xmath129 to be the element in the @xmath126-th row , @xmath23-th column of @xmath125 , and denote @xmath130 to be the level consisting of the @xmath126-th row of @xmath125 , @xmath131 , @xmath132 .",
    "then @xmath125 is said to be _ connectivity - preserving _ to @xmath10 , if the vertex - set @xmath133 induced by @xmath125 equals to the vertex - set of @xmath10 , and if the edge - set @xmath134 induced by @xmath125 equals to the edge - set of @xmath10 .",
    "we can check that the v - matrix in the second column of both examples of fig .",
    "[ fig - igim1 ] is connectivity - preserving to the original mesh respectively . the following property shows estimates of reconstruction errors of cgims .",
    "* property  * let @xmath125 be a v - matrix with respect to @xmath10 and let @xmath135 be the reconstructed mesh generated from @xmath125 by using a @xmath136-bit cgim .",
    "suppose that @xmath125 is connectivity - preserving to @xmath10 .",
    "then the max hausdorff distance and the root - mean - square hausdorff distance between @xmath135 and @xmath10 are both bounded by @xmath137      this section gives a complete algorithm for the phase which produces a v - matrix preserving the connectivity of the original mesh .",
    "such a property is proved in section  a of the supplementary material .",
    "with respect to an open genus - zero triangular mesh @xmath10.,scaledwidth=35.0% ]    1 .   * input * : an open genus - zero triangular mesh @xmath10 .",
    "* output * : the _ row resolution _",
    "@xmath138 , the _ column resolution _",
    "@xmath139 , a level sequence @xmath140 , @xmath98 and a v - matrix @xmath125 .",
    "[ step - para ] parametrize @xmath10 onto the planar domain @xmath99\\times[0,1]$ ] using tutte s parametrization @xcite .",
    "[ step - l1 ] set @xmath141 , and choose the initial level @xmath100 to be all vertices whose ordinate is one over the parametrized domain , such that @xmath142 where @xmath143 denotes the abscissa of a vertex in @xmath144 .",
    "[ step - order ] for @xmath145 , order @xmath146 by @xmath147 where @xmath148 , @xmath149 , and @xmath150 denotes the angle from a planar vector @xmath151 to another planar vector @xmath152 in counterclockwise direction",
    ". 6 .   [ step - setq1 ] set @xmath153 , and remove @xmath154 which satisfies @xmath155 , @xmath156 .",
    "[ step - component1 ] compute all the components @xmath157 of @xmath51 .",
    "[ step - proper ] for each component @xmath158 with irregular pairs , compute a proper sublevel @xmath71 of @xmath158 , @xmath159 , and set @xmath160 .",
    "[ step - setq2 ] @xmath161 .",
    "[ step - component2 ] compute all the components @xmath157 of @xmath51",
    "[ step - computkj ] for each component @xmath158 of @xmath51 , compute the smallest index of @xmath162 s adjacent elements in @xmath80 and the greatest index of @xmath163 s adjacent elements in @xmath80 , i.e. @xmath164 12 .",
    "[ step - deterli ] determine the level @xmath81 : @xmath165 13 .",
    "[ step - align1 ] by using definition  [ def - align1 ] , compute @xmath166 14 .",
    "[ step - deterli+ ] determine the levels @xmath167 , @xmath168 : @xmath169 15 .",
    "[ step - deterli2 ] if @xmath170 , @xmath171 , then remove the first term @xmath172 from @xmath81 , @xmath167 and @xmath168 . if @xmath173 , @xmath174 , then remove the last term @xmath175 from @xmath81 , @xmath167 and @xmath168 . )",
    "is that if @xmath176 , @xmath171 , then @xmath177 is capable of being the first element of @xmath81 and hence the level @xmath178 is unnecessary for being a sublevel of @xmath81 , @xmath167 , @xmath168 ; the reason is similar for @xmath179 . ]",
    "[ step - endloop ] if @xmath180 holds , then set @xmath181 and goto step  ( [ step - fori2 ] ) ; otherwise , @xmath182 , and goto step  ( [ step - order ] ) .",
    "[ step - fori2 ] for @xmath183 , @xmath184",
    "[ step - computr2 ] @xmath185 ,   @xmath186 ,  @xmath187",
    "[ step - forir1 ] for @xmath188 ,  @xmath189 , where the first output variable is denoted by @xmath190 as it is not used . 20 .",
    "[ step - endvmatrix ] obtain a v - matrix @xmath125 using equation  ( [ eq - isomatrix ] ) .",
    "denote @xmath191 to be all different elements of @xmath100 in turn , where @xmath192 is the number of different elements in @xmath100    [ rem - igim1 ] such a cgim algorithm is parametrization - free .",
    "this is because the following inequality @xmath193 holds for any two distinct adjacent vertices @xmath56 , @xmath194 of @xmath195 , @xmath196 , and such an inequality depends not on the parametrization but on the connectivity of @xmath10 .",
    "[ rem - igim3 ] in algorithm  [ alg - align2 ] line  [ alg - insert1 ] , we insert all @xmath2 s into @xmath197 so that all @xmath2 s are in adjacent locations in the new @xmath197 ; so do the @xmath198 s in line  [ alg - insert2 ] .",
    "this is guaranteed because all @xmath2 s are in adjacent locations of @xmath199 , as well as in adjacent locations of @xmath200 , according to lemma  4 of section  a of the supplementary material .",
    "this section gives algorithms for cgims of smaller resolutions in section  [ sec-51 ] , and for reconstructing meshes from compressed cgims in section  [ sec-52 ] .",
    "we introduce the idea of cgims for treating closed genus - zero meshes in section  b of the supplementary material .      compared with traditional gims ,",
    "the greatest disadvantage of cgims is that they have blow - up resolutions in order to entirely preserve the connectivity of a mesh .",
    "such a disadvantage decreases the efficiency of mesh compression using cgims .",
    "we shall propose a modified phase for cgims of smaller resolutions ( algorithm  [ alg - modifyiso ] ) . compared with the phase in section  [ sec-45 ] , the modification consists of two aspects .",
    "one aspect comes from the observation that the column resolution of cgims is much greater than the row resolution ( varying from one and a half times to two and a half times in our experiments ) , which drives us adjust the phase to re - group the vertex - set in order to produce a smaller column resolution ; the other is to check each row and each column of the v - matrix @xmath125 to see whether any row or any column of @xmath125 is removable ( algorithm  [ alg - modifyiso ] , lines  [ alg - removrow]-[alg - removcol ] ) , i.e. whether @xmath236 hold for some @xmath237 respectively , where @xmath238 denote the level consisting of the @xmath126-th row , the @xmath23-th column of @xmath125 respectively , and where the set on the left - hand - side represents the edge - set induced by the v - matrix removing the @xmath126-th row , or removing the @xmath23-th column of @xmath125 respectively .",
    "let us explain the first aspect of the modification using fig .",
    "[ fig - columnreso ] . in the first example",
    ", the cgim algorithm gives @xmath239 $ ] , @xmath240 $ ] , @xmath241 $ ] , and gives a v - matrix of resolutions @xmath242 in the right hand side ( option  1 ) .",
    "the column resolution of the v - matrix is large because vertex f has five neighbors in @xmath81 .",
    "however if we choose @xmath243 $ ] , @xmath244 $ ] , @xmath245 $ ] , then we give a v - matrix of smaller size @xmath246 ( option  2 ) . in the second example ,",
    "option  1 gives @xmath247 $ ] , @xmath248 $ ] , @xmath249 $ ] , and gives a v - matrix of resolutions @xmath242 , while option  2 gives @xmath247 $ ] , @xmath248 $ ] , @xmath250 $ ] , @xmath251 $ ] , and gives a v - matrix of smaller size @xmath252 . the trick is to combine fewer vertices in the next level when the next level or current level contains vertices with too many neighbors in other levels , so that the column resolution of the v - matrix decreases .",
    "parametrize @xmath10 onto the planar domain @xmath99\\times[0,1]$ ] choose the initial level @xmath100 using step  ( [ step - l1 ] )    @xmath185 ,   @xmath186 obtain the v - matrix @xmath125 using equation  ( [ eq - isomatrix ] )    based on this observation , we modify the phase by selecting a smaller number of vertices to combine with the last level for obtaining @xmath51 in steps  ( [ step - proper ] ) , ( [ step - setq2 ] ) , which increases the row resolution and decreases the column resolution .",
    "such an operation is given in lines  [ alg - foreach]-[alg - foreachend ] of algorithm  [ alg - modifyiso ] , where @xmath253 is the threshold for controlling the extent for the novel grouping , i.e. when @xmath253 is small , fewer new vertices are added in the next level ( which increases the row resolution @xmath138 and accordingly decreases the column resolution @xmath139 ) , and vice versa .",
    "cgims consist of pixels , many of which share the same rgb values in order to maintain the connectivity of the mesh , whereas compressed cgims do not have such a property because of quantization errors over each pixel during lossy compression .",
    "thus , to reconstruct meshes from compressed cgims , we add a phase so that the pixels with similar values are re - evaluated with a common value , chosen to be the average of values of those pixels which are clustered in the same category .",
    "let @xmath254 be a compressed cgim array .",
    "we record @xmath255 as the number of different elements in the @xmath126-th row , the @xmath23-th column of the v - matrix respectively ( such numbers are the additional information we record during cgim - based lossy compression of meshes ) , @xmath256 . then we compute the color distance metrics @xmath257 between pixels @xmath70 and @xmath258 , @xmath98 , @xmath259 , and the color distance metrics @xmath260 between pixels @xmath70 and @xmath261 , @xmath262 . for each @xmath263",
    ", we put all the pixels of the @xmath126-th row into the category sequence @xmath264 , @xmath265 as follows : @xmath266 where @xmath267 are chosen to be the indices such that @xmath268 , @xmath269 are no smaller than other @xmath257 , @xmath259 . in order to put pixels in different rows together ,",
    "we need to _ combine _ each category of the @xmath270-th row _ with _ a suitable category of the @xmath126-th row , _ with _ a category @xmath271 \" is referred to as setting @xmath272 and @xmath273 . ] @xmath274 . to do this , for each @xmath275",
    ", we define another category sequence @xmath276 , @xmath277 as follows : @xmath278 where @xmath279 are chosen to be the indices such that @xmath280 , @xmath269 are no smaller than other @xmath260 , @xmath281 .",
    "next we shall determine which category of @xmath282 be the category @xmath283 combined with .",
    "we define a category distance metric between @xmath264 and @xmath283 by @xmath284 where    condition 1 : : :    @xmath285 such that    @xmath286 condition 2 : : :    @xmath287 such that @xmath288 ,    @xmath289 ,    @xmath290    and where @xmath291 condition 1 indicates that two categories @xmath264 , @xmath283 share no common column index ; condition 2 indicates that @xmath264 , @xmath283 share common column indices but those indices are located on the boundary between two groups of similar - value pixels in columns . if @xmath264 , @xmath283 satisfy either of two conditions for all @xmath292 , then @xmath283 is not combined with any categories ; otherwise , we set @xmath293 and combine @xmath283 with @xmath294 , where @xmath295 is given by the average of all color distance metrics in @xmath23-th column direction such that @xmath70 , @xmath261 belong to a common category @xmath296 .",
    "we illustrate the phase in fig .",
    "[ fig - cluster ] and we give details in section  c of the supplementary material .",
    "m8.5mm|m6mm|m6.5mm|m4mm!width1.0pt m14mm|m3mm|m5.5mm|m8.5mm|m7mm|m7 mm !",
    "width1.0pt m14mm|m3mm|m3mm|m7mm|m7 mm & & & & & + & & & & & & & @xmath297 & @xmath298 & @xmath299 & & & & @xmath298 & @xmath299 + & & & & & & & @xmath300 & @xmath301 & @xmath301 & & & & @xmath301 & @xmath301 + @xmath302 & 1663 & 3299 & 0.10 & @xmath303 & @xmath304 & 20 & 69 & 4 & 87 & @xmath305 & @xmath306 & 56 & 20 & 20 + @xmath307 & 1198 & 2369 & 0.07 & @xmath308 & @xmath309 & 10 & 35 & 2 & 23 & @xmath305 & @xmath306 & 34 & 20 & 20 + @xmath310 & @xmath311 & @xmath312 & 0.66 & @xmath313 & @xmath314 & 667 & 1351 & 31 & 690 & @xmath305 & @xmath306 & @xmath315 & 21 & 21 + @xmath316 & @xmath317 & @xmath318 & 0.75 & @xmath319 & @xmath320 & 758 & 1716 & 32 & 905 & @xmath305 & @xmath306 & @xmath321 & 21 & 21 + @xmath322 & @xmath323 & @xmath324 & 2.74 & @xmath325 & @xmath326 & 902 & 2294 & 67 & 1638 & @xmath327 & @xmath328 & @xmath329 & 83 & 83 + @xmath330 & @xmath331 & @xmath332 & 1.69 & @xmath333 & @xmath334 & @xmath335 & @xmath336 & 96 & 3259 & @xmath327 & @xmath328 & @xmath337 & 84 & 83 + @xmath338 & @xmath339 & @xmath340 & 1.53 & @xmath341 & @xmath342 & @xmath343 & @xmath344 & 203 & 5491 & @xmath327&@xmath328 & @xmath345 & 83 & 83 + @xmath346 & @xmath347 & @xmath348 & 3.71 & @xmath349 & @xmath350 & @xmath351 & @xmath352 & 338 & @xmath353 & @xmath327 & @xmath328 & @xmath354 & 84 & 83 +    this section gives experimental results of cgim algorithms and results of cgim - based mesh compression .",
    "we run all experiments on an i7 - 2600 3.4ghz machine with 16 gb ram using matlab r2013a , and we use algorithm  [ alg - modifyiso ] for the phase , where the threshold parameters are taken as @xmath355 .",
    "we show the cgims , cnims ( connectivity - preserving normal images , each pixel of which corresponds to the normal of an element in the v - matrix ) and traditional gims , nims for a number of mesh models in fig .",
    "[ fig - igim2 ] , including four open genus - zero meshes ( @xmath356 , @xmath307 , @xmath322 , @xmath338 ) and two closed genus - zero meshes ( @xmath357 , @xmath358 ) .",
    "we show the comparisons of resolutions , file sizes and running time of cgims with respect to traditional gims in table  [ tab - igim ] . as we see , the file sizes of cgims of @xmath359 are greater , and the sizes of cgims of @xmath360 are relatively small compared with the sizes of original models .",
    "the reason is that those models contain toes , fingers or other details and hence have large geometric distortions , while @xmath361 both have lower distortions .",
    "moreover , table  [ tab - igim ] shows that cgims have a much longer running time compared with traditional gims , especially for models with large sizes .",
    "this is because cgims spend much time on obtaining the v - matrix connectivity - preserving to the mesh ( algorithm  [ alg - modifyiso ] ) and reconstructing meshes ( the phase ) .",
    "we admit the less efficiency of cgims as such two phases of cgims are unavoidable .",
    "we implement the lossy compression by using cgims and traditional gims for six models : @xmath356 , @xmath307 , @xmath338 , @xmath322 , @xmath357 , @xmath358 .",
    ", @xmath358 are @xmath362 , @xmath363 respectively . ] for traditional gims , we choose two resolutions ( @xmath364 , @xmath305 for @xmath356 and @xmath307 as they have relatively smaller sizes ; @xmath305 , @xmath365 for the other four models ) of 8-bit images with jpeg2000 as image codec , where the wavelet kernel is w9x7 and the wavelet transform level is five ; for cgims , we choose jpeg2000 as image codec ( with the same wavelet kernel and transform level ) and the mbcim as image codec , respectively .",
    "the mbcim scheme was proposed for compressing compound images , many pixels of which share common values , which are close to cgim arrays .",
    "the mbcim scheme is introduced briefly in section  d of the supplementary material .    * * qualitative results**we show mesh reconstructions from lossy compressed cgims in fig .",
    "[ fig - igim3 ] .",
    "cgims recover the thumb part of the @xmath307 model better than gims do ; this is mainly because the parametrization puts the original vertices of the thumb into a smaller region and imposes an inadequate sampling over that region .",
    "reconstructed meshes for gims look smooth in general , but fail in representing some details ( e.g. , @xmath356 s top and @xmath338 s eyes ) ; nevertheless , reconstructed meshes for cgims look coarse in lower target rates ( e.g. , @xmath357 s ears ) .    * * quantitative results**we show the psnr curves in fig .",
    "[ fig - psnr ] , where the @xmath366-axis represents file sizes given by setting different target rates ( in jpeg2000 ) or different quantization parameters ( in mbcim ) , and the @xmath367-axis represents the psnr values . for @xmath356 , @xmath322 , @xmath307 , cgims achieve better than gims in the whole part of curve , which is mainly because those three models have small resolutions with respect to the original size of the mesh .",
    "in particular , @xmath307 has a bad parametrization on its thumb part , leading to an insufficient sampling over that part and hence a bad reconstruction using gims . on the other hand , gims with resolutions @xmath365 achieve better results for @xmath338 , @xmath357 , @xmath358 in the most part of curves , while cgims achieve better results when the compression rate tends to be lower .",
    "moreover we see that cgims with mbcim coding achieve better rate distortions than cgims with jpeg2000 . also , the rate distortions strongly depend on the resolutions of cgims : the smaller the resolutions are , the better rate distortions cgims achieve .",
    "therefore , reconstruction errors of cgims for lossy compression depends on the quantization errors of coordinates of vertices , incorrect cluster algorithms during reconstructions and the incorrect connectivity incurred by quantization errors and incorrect cluster algorithms ; moreover , the psnr depends on the three ingredients given above , as well as the cgim resolutions .    * * discussion**fig .",
    "[ fig - igim3 ] implies that cgims have promising advantages in preserving details compared with traditional gims .",
    "the reason is that gims treat a mesh with a regular sampling over parametrized domain and hence incur a loss in high distortion parts ( e.g. , @xmath338 s eyes ) , whereas cgims treat details and non - details of a mesh evenly as the elements of the v - matrix . although the magnified details show that gims produce more compact grids in @xmath338 s eyebrows than cgims do , what cgims show is close to the faithful geometry of the model .",
    "moreover , with the same codec jpeg2000 , cgims do not perform better psnrs than gims , but cgims with mbcim codec perform better psnrs than cgims with jpeg2000 .",
    "this is mainly because cgims usually have large resolutions compared with gims as we mentioned before , which increases the compressed file size for the same target rate during encoding . for large distortion models ( @xmath338 , @xmath357 , @xmath358 ) , cgims do not have better psnrs for small target rates , as the quantization error produces incorrect connectivity in the algorithm .",
    "such an error decreases and accordingly the psnr increases when the target rate is larger . also , mbcim is more suitable than jpeg2000 for cgim compression according to the experimental results .",
    "yet , cgims give bad psnrs for meshes with much larger distortion ( see fig .  [ fig - failure ] , a failure example of @xmath346 ) , as those meshes have large resolutions of cgims and consequently the compressed file size is large for a given compression rate .",
    "* * advantages**this paper proposes cgims , which represent genus - zero triangular meshes by embedding a mesh onto a rectangular array which preserves the connectivity of vertices with round - off errors on coordinates of vertices .",
    "compared with traditional gims , the advantages of cgims mainly include :            \\(i ) the greatest disadvantage of cgims is that cgims have much redundancy especially for meshes with large distortion , which makes cgims need higher compression rate than traditional gims under the same limit of data size .",
    "this can be seen from fig .",
    "[ fig - igim3 ] where cgims show less smoothness on the models @xmath368 .",
    "\\(iii ) unlike gims , traditional image codecs are not suitable for cgims because most pixels of cgims share the same value and such a structure brings much trouble during the reconstruction of lossy compression . to overcome this shortcoming , other image codec for cgims must be developed .",
    "\\(iv ) under high compression rate , the phase may result in incorrect connectivity of vertices or orientation of faces ( see the dark face at the bottom of @xmath356 in row one , column two of fig .",
    "[ fig - igim3 ] ) , which destroys the connectivity - preserving property and limits the applications of cgims to lossy compression .",
    "\\(i ) developing multi - chart cgims with smaller resolutions .",
    "we shall consider first partitioning it into a collection of submeshes , each of which is represented by a cgim with small resolutions , and then packing all sub - cgims into a single cgim .",
    "\\(iii ) applying cgims to hierarchical mesh compression .",
    "we shall consider gims which preserve details , features or region of interest of meshes by using cgim patches , and impose roi codings on such gims .",
    "feng , w. , kim , b. , yu , y. , peng , l. , hart , j. : feature - preserving triangular geometry images for level - of - detail representation of static and skinned meshes .",
    "acm trans . graph . * 29*(2 ) , article 11 ( 2010 )"
  ],
  "abstract_text": [
    "<S> we propose _ connectivity - preserving geometry images _ ( cgims ) , which map a triangular mesh onto a rectangular regular array of an image , such that the reconstructed mesh produces no sampling errors , but merely round - off errors over the coordinates of vertices . by using permutation techniques on vertices , </S>",
    "<S> cgims first obtain a _ </S>",
    "<S> v - matrix _ whose elements are vertices of the original mesh , which intrinsically preserves the vertex - set and connectivity of the original mesh , and then generate a cgim array by transforming the cartesian coordinates of corresponding vertices of the v - matrix into rgb values . compared with traditional geometry images ( gims ) , </S>",
    "<S> cgims achieve the minimum reconstruction error with a parametrization - free algorithm . </S>",
    "<S> we apply cgims to lossy compression of meshes . </S>",
    "<S> experimental results show that while cgims produce a lower efficiency in both encoding and decoding time and larger resolutions than traditional gims , cgims perform better peak signal - to - noise ratios and preserve details better than gims especially with the multi - stage base color and index map scheme , because cgims treat details and non - details of meshes evenly as all elements of the v - matrix .    </S>",
    "<S> example.pdf gsave newpath 20 20 moveto 20 220 lineto 220 220 lineto 220 20 lineto closepath 2 setlinewidth gsave .4 setgray fill grestore stroke grestore </S>"
  ]
}