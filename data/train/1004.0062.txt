{
  "article_text": [
    "we consider programs containing high security inputs and low security outputs . informally , the quantitative information flow problem concerns the amount of information that an attacker can learn about the high security input by executing the program and observing the low security output .",
    "the problem is motivated by applications in information security .",
    "we refer to the classic by denning  @xcite for an overview .",
    "in essence , quantitative information flow measures _ how _ secure , or insecure , a program is .",
    "thus , unlike non - interference  @xcite , that only tells whether a program is completely secure or not completely secure , a definition of quantitative information flow must be able to distinguish two programs that are both interferent but have different degrees of `` secureness . ''",
    "for example , consider the following two programs : @xmath0 in both programs , @xmath1 is a high security input and @xmath2 is a low security output .",
    "viewing @xmath1 as a password , @xmath3 is a prototypical login program that checks if the guess @xmath4 matches the password .",
    "is a program constant .",
    "see section  [ sec : prelim ] for modeling attacker / user ( i.e. , low security ) inputs . ] by executing @xmath3 , an attacker only learns whether @xmath1 is equal to @xmath4 , whereas she would be able to learn the entire content of @xmath1 by executing @xmath5 .",
    "hence , a reasonable definition of quantitative information flow should assign a higher quantity to @xmath5 than to @xmath3 , whereas non - interference would merely say that @xmath3 and @xmath5 are both interferent , assuming that there are more than one possible value of @xmath1 .",
    "researchers have attempted to formalize the definition of quantitative information flow by appealing to information theory .",
    "this has resulted in definitions based on the shannon entropy  @xcite , the min entropy  @xcite , the guessing entropy  @xcite , and channel capacity  @xcite .",
    "much of the previous research has focused on information theoretic properties of the definitions and approximate ( i.e. , incomplete and/or unsound ) algorithms for checking and inferring quantitative information flow according to such definitions .    in this paper",
    ", we give a verification theoretic and complexity theoretic analysis of quantitative information flow and investigate precise methods for checking quantitative information flow . in particular , we study the following _ comparison problem _ : given two programs @xmath3 and @xmath5 , decide if @xmath6 . here",
    "@xmath7 denotes the information flow quantity of the program @xmath8 according to the quantitative information flow definition @xmath9 where @xmath9 is either @xmath10 $ ] ( shannon - entropy based with distribution @xmath11 ) , @xmath12 $ ] ( min - entropy based with distribution @xmath11 ) , @xmath13 $ ] ( guessing - entropy based with distribution @xmath11 ) , or @xmath14 ( channel - capacity based ) .",
    "note that , obviously , the comparison problem is no harder than actually computing the quantitative information flow as we can compare the two numbers once we have computed @xmath15 and @xmath16 .    concretely , we show the following negative results , where @xmath9 is @xmath17 , @xmath18 $ ] , @xmath19 $ ] , or @xmath13 $ ] with @xmath11 uniform .    *",
    "checking if @xmath20 is not a @xmath21-safety property  @xcite for any @xmath21 .",
    "* restricted to loop - free boolean programs , checking if @xmath20 is # p - hard .",
    "the results are in stark contrast to non - interference which is known to be a @xmath22-safety property in general  @xcite ( technically , for the termination - insensitive case ) and can be shown to be conp - complete for loop - free boolean programs ( proved in section  [ sec : complex ] ) . ( # p is known to be as hard as the entire polynomial hierarchy  @xcite . )",
    "the results suggest that precisely inferring ( i.e. , computing ) quantitative information flow according to these definitions would be harder than checking non - interference and may require a very different approach ( i.e. , not self composition  @xcite ) .",
    "we also give the following positive results which show checking if the quantitative information flow of one program is larger than the other for all distributions according to the entropy - based definitions is easier .",
    "below , @xmath23 is @xmath24 , @xmath25 , or @xmath26 .    *",
    "checking if @xmath27(m_1 ) \\leq",
    "\\mathcal{y}[\\mu](m_2)$ ] is a @xmath22-safety property .",
    "* restricted to loop - free boolean programs , checking if @xmath27(m_1 ) \\leq \\mathcal{y}[\\mu](m_2)$ ] is conp - complete .",
    "these results are proven by showing that the problems @xmath28(m_1 ) \\leq { \\it se}[\\mu](m_2)$ ] , @xmath29(m_1 ) \\leq { \\it me}[\\mu](m_2)$ ] , and @xmath30(m_1 ) \\leq { \\it ge}[\\mu](m_2)$ ] are all actually equivalent to a simple @xmath22-safety relation @xmath31 .",
    "we also show that this relation refines the channel - capacity based quantitative information flow , that is , if @xmath31 then @xmath32 .",
    "the fact that @xmath31 is a @xmath22-safety property implies that it can be reduced to a safety problem via self composition .",
    "this leads to a new approach to precisely checking quantitative information flow that leverages recent advances in automated software verification  @xcite .",
    "briefly , given @xmath3 and @xmath5 , @xmath31 means that @xmath3 is at least as secure as @xmath5 for all distributions while @xmath33 means that there must be a distribution in which @xmath3 is less secure than @xmath5 , according to the entropy - based definitions of quantitative information flow .",
    "therefore , by deciding @xmath31 , we can measure the security of the program @xmath3 relative to another _ specification _ program @xmath5 .",
    "note that this is useful even when @xmath3 and @xmath5 are `` incomparable '' by @xmath34 , that is , when @xmath35 and @xmath36 .",
    "see section  [ sec : qbysc ] for the details .",
    "the rest of the paper is organized as follows .",
    "section  [ sec : prelim ] reviews the existing information - theoretic definitions of quantitative information flow .",
    "section  [ sec : qifnksafe ] proves the hardness of their comparison problems and thus shows the hardness of precisely inferring quantitative information flow according to these definitions .",
    "section  [ sec : qshan ] introduces the relation @xmath34 and proves it equivalent to the comparison problems for the entropy - based definitions with their distributions universally quantified .",
    "the section also shows that this is a @xmath22-safety property and is easier to decide than the non - universally - quantified comparison problems , and suggests a self - composition based method for precisely checking quantitative information flow .",
    "section  [ sec : related ] discusses related work , and section  [ sec : concl ] concludes .",
    "appendix  [ sec : lemdefs ] contains the supporting lemmas and definitions for the proofs appearing in the main text .",
    "the omitted proofs appear in appendix  [ sec : proofs ] .",
    "we introduce the information theoretic definitions of quantitative information flow that have been proposed in literature .",
    "first , we review the notion of the _ shannon entropy _  @xcite , @xmath37(x)$ ] , which is the average of the information content , and intuitively , denotes the uncertainty of the random variable @xmath38 .",
    "let @xmath38 be a random variable with sample space @xmath39 and @xmath11 be a probability distribution associated with @xmath38 ( we write @xmath11 explicitly for clarity ) .",
    "the shannon entropy of @xmath38 is defined as @xmath40(x)=\\sum_{x\\in\\mathbb{x } } \\mu(x = x)\\log\\frac{1}{\\mu(x = x)}\\ ] ] ( the logarithm is in base 2 . )    next , we define _",
    "conditional entropy_. informally , the conditional entropy of @xmath38 given @xmath41 denotes the uncertainty of @xmath38 after knowing @xmath41 .",
    "let @xmath38 and @xmath41 be random variables with sample spaces @xmath39 and @xmath42 , respectively , and @xmath11 be a probability distribution associated with @xmath38 and @xmath41 .",
    "then , the conditional entropy of @xmath38 given @xmath41 , written @xmath37(x|y)$ ] is defined as @xmath40(x|y)=\\sum_{y\\in\\mathbb y } \\mu(y = y ) \\mathcal{h}[\\mu](x|y = y)\\ ] ] where @xmath43(x|y = y ) \\\\ \\hspace{2em}=\\sum_{x\\in\\mathbb x } \\mu(x = x|y = y)\\log\\frac{1}{\\mu(x = x|y = y ) } \\\\",
    "\\mu(x = x|y = y)=\\frac{\\mu(x = x , y = y)}{\\mu(y = y ) } \\end{array}\\ ] ]    next , we define ( conditional ) mutual information . intuitively , the conditional mutual information of @xmath38 and @xmath41 given @xmath44 represents the mutual dependence of @xmath38 and @xmath41 after knowing @xmath44 .",
    "let @xmath45 and @xmath44 be random variables and @xmath11 be an associated probability distribution .",
    "then , the conditional mutual information of @xmath38 and @xmath41 given @xmath44 is defined as @xmath46(x;y|z)&=&\\mathcal{h}[\\mu](x|z)-\\mathcal{h}[\\mu](x|y , z)\\\\ & = & \\mathcal{h}[\\mu](y|z)-\\mathcal{h}[\\mu](y|x , z ) \\end{array}\\ ] ]    let @xmath8 be a program that takes a high security input @xmath1 and a low security input @xmath47 , and gives the low security output @xmath2 . for simplicity , we restrict to programs with just one variable of each kind , but it is trivial to extend the formalism to multiple variables ( e.g. , by letting the variables range over tuples ) .",
    "also , for the purpose of the paper , unobservable ( i.e. , high security ) outputs are irrelevant , and so we assume that the only program output is the low security output .",
    "let @xmath11 be a probability distribution over the values of @xmath1 and @xmath47 .",
    "then , the semantics of @xmath8 can be defined by the following probability equation .",
    "( we restrict to terminating deterministic programs in this paper . )",
    "@xmath48 note that we write @xmath49 to denote the low security output of the program @xmath8 given inputs @xmath50 and @xmath51 .",
    "now , we are ready to introduce the shannon - entropy based definition of quantitative information flow ( qif )  @xcite .",
    "[ def : se ] let @xmath8 be a program with high security input @xmath1 , low security input @xmath47 , and low security output @xmath2 .",
    "let @xmath11 be a distribution over @xmath1 and @xmath47 .",
    "then , the shannon - entropy - based quantitative information flow is defined @xmath52(m ) & = & \\mathcal{i}[\\mu](o;h|l ) \\\\   & = & \\mathcal{h}[\\mu](h|l)-\\mathcal{h}[\\mu](h|o , l ) \\end{array}\\ ] ]    intuitively , @xmath37(h|l)$ ] denotes the initial uncertainty knowing the low security input and @xmath37(h|o , l)$ ] denotes the remaining uncertainty after knowing the low security output .    as an example , consider the programs @xmath3 and @xmath5 from section  [ sec : introduction ] .",
    "for concreteness , assume that @xmath4 is the value @xmath53 and @xmath1 ranges over the space @xmath54 .",
    "let @xmath55 be the uniform distribution over @xmath54 , that is , @xmath56 for all @xmath57 .",
    "the results are as follows .",
    "@xmath58(m_1)&=\\mathcal{h}[u](h)-\\mathcal{h}[u](h|o)\\\\ & = \\log 4-\\frac{3}{4}\\log{3}\\\\ & \\approx .81128\\\\&\\\\    { \\it se}[u](m_2)&=\\mathcal{h}[u](h)-\\mathcal{h}[u](h|o)\\\\ & = \\log 4-\\log 1\\\\ & = 2 \\end{array}\\ ] ] consequently , we have that @xmath59(m_1 ) \\leq { \\it se}[u](m_2)$ ] , but @xmath59(m_2 ) \\not\\leq { \\it se}[u](m_1)$ ] .",
    "that is , @xmath3 is more secure than @xmath5 ( according to the shannon - entropy based definition with uniformly distributed inputs ) , which agrees with our intuition .",
    "let us recall the notion of non - interference  @xcite .",
    "a program @xmath8 is said to be non - interferent iff for any @xmath60 and @xmath61 , @xmath62 .",
    "it is worth noting that non - interference can be formalized as a special case of the shannon - entropy based quantitative information flow where the flow quantity is zero .",
    "[ thm : reqni ] let @xmath8 be a program that takes high - security input @xmath1 , low - security input @xmath47 , and returns low - security output @xmath2 . then , @xmath8 is non - interferent if and only if @xmath63(m)=0 $ ] .",
    "the above theorem is complementary to the one proven by clark et al .",
    "@xcite which states that for any @xmath11 such that @xmath64 for all @xmath65 and @xmath66 , @xmath18(m)=0 $ ] iff @xmath8 is non - interferent .",
    "next , we introduce the _ min entropy _ , which smith  @xcite recently suggested as an alternative measure for quantitative information flow .",
    "let @xmath38 and @xmath41 be random variables , and @xmath11 be an associated probability distribution .",
    "then , the min entropy of @xmath38 is defined @xmath67(x)=\\log\\frac{1}{\\mathcal{v}[\\mu](x)}\\ ] ] and the conditional min entropy of @xmath38 given @xmath41 is defined @xmath67(x|y)=\\log\\frac{1}{\\mathcal{v}[\\mu](x|y)}\\ ] ] where @xmath68(x)&=\\max_{x\\in\\mathbb x } \\mu(x = x)\\\\ \\mathcal{v}[\\mu](x|y = y)&=\\max_{x\\in\\mathbb x } \\mu(x = x|y = y)\\\\ \\mathcal{v}[\\mu](x|y)&=\\sum_{y\\in\\mathbb y } \\mu(y = y ) \\mathcal{v}[\\mu](x|y = y ) \\end{array}\\ ] ]    intuitively , @xmath69(x)$ ] represents the highest probability that an attacker guesses @xmath38 in a single try .",
    "we now define the min - entropy - based definition of quantitative information flow .",
    "[ def : me ] let @xmath8 be a program with high security input @xmath1 , low security input @xmath47 , and low security output @xmath2 .",
    "let @xmath11 be a distribution over @xmath1 and @xmath47 .",
    "then , the min - entropy - based quantitative information flow is defined @xmath70(m)=\\mathcal{h}_\\infty[\\mu](h|l)-\\mathcal{h}_\\infty[\\mu](h|o , l)\\ ] ]    whereas smith  @xcite focused on programs lacking low security inputs , we extend the definition to programs with low security inputs in the definition above .",
    "it is easy to see that our definition coincides with smith s for programs without low security inputs .",
    "also , the extension is arguably natural in the sense that we simply take the conditional entropy with respect to the distribution over the low security inputs .",
    "computing the min - entropy based quantitative information flow for our running example programs @xmath3 and @xmath5 from section  [ sec : introduction ] with the uniform distribution , we obtain , @xmath71(m_1)&=\\mathcal{h}_\\infty[u](h)-\\mathcal{h}_\\infty[u](h|o)\\\\ & = \\log 4-\\log 2\\\\ & = 1\\\\&\\\\ { \\it me}[u](m_2)&=\\mathcal{h}_\\infty[u](h)-\\mathcal{h}_\\infty[u](h|o)\\\\ & = \\log 4 -\\log 1\\\\ & = 2 \\end{array}\\ ] ] again , we have that @xmath72(m_1 ) \\leq { \\it me}[u](m_2)$ ] and @xmath73(m_2 ) \\not\\leq { \\it me}[u](m_1)$ ] , and so @xmath5 is deemed less secure than @xmath3 .",
    "the third definition of quantitative information flow treated in this paper is the one based on the guessing entropy  @xcite , that is also recently proposed in literature  @xcite .",
    "let @xmath38 and @xmath41 be random variables , and @xmath11 be an associated probability distribution .",
    "then , the guessing entropy of @xmath38 is defined @xmath74(x)=\\sum_{1\\le i\\le m}i\\times\\mu(x = x_i)\\ ] ] where @xmath75 and @xmath76 .",
    "the conditional guessing entropy of @xmath38 given @xmath41 is defined @xmath74(x|y)=\\sum_{y\\in{\\mathbb y}}\\mu(y = y)\\sum_{1\\le i\\le m}i\\times\\mu(x = x_i|y = y)\\ ] ] where @xmath75 and @xmath77 .",
    "intuitively , @xmath78(x)$ ] represents the average number of times required for the attacker to guess the value of @xmath38 .",
    "we now define the guessing - entropy - based quantitative information flow .",
    "[ def : ge ]",
    "let @xmath8 be a program with high security input @xmath1 , low security input @xmath47 , and low security output @xmath2 .",
    "let @xmath11 be a distribution over @xmath1 and @xmath47 .",
    "then , the guessing - entropy - based quantitative information flow is defined @xmath79(m)=\\mathcal{g}[\\mu](h|l)-\\mathcal{g}[\\mu](h|o , l)\\ ] ]    like with the min - entropy - based definition , the previous research on guessing - entropy - based quantitative information flow only considered programs without low security inputs  @xcite .",
    "but , it is easy to see that our definition with low security inputs coincides with the previous definitions for programs without low security inputs .",
    "also , as with the extension for the min - entropy - based definition , it simply takes the conditional entropy over the low security inputs .",
    "we test _ ge _ on the running example from section  [ sec : introduction ] by calculating the quantities for the programs @xmath3 and @xmath5 with the uniform distribution .",
    "@xmath80(m_1 ) & = \\mathcal{g}[u](h)-\\mathcal{g}[u](h|o)\\\\ & = \\frac{5}{2 } - \\frac{7}{4}\\\\ & = 0.75\\\\\\\\ { \\it ge}[u](m_2 ) & = \\mathcal{g}[u](h)-\\mathcal{g}[u](h|o)\\\\ & = \\frac{5}{2 } - 1\\\\ & = 1.5 \\end{array}\\ ] ] therefore , we again have that @xmath81(m_1 ) \\leq { \\it ge}[u](m_2)$ ] and @xmath81(m_2 ) \\not\\leq { \\it ge}[u](m_1)$ ] , and so @xmath5 is considered less secure than @xmath3 , even with the guessing - entropy based definition with the uniform distribution .",
    "the fourth and the final existing definition of quantitative information flow that we introduce in this paper is the one based on _ channel capacity _  @xcite , which is simply defined to be the maximum of the shannon - entropy based quantitative information flow over the distribution .    let @xmath8 be a program with high security input @xmath1 , low security input @xmath47 , and low security output @xmath2 .",
    "then , the channel - capacity - based quantitative information flow is defined @xmath82(o;h|l)\\ ] ]    unlike the shannon - entropy based , the min - entropy based , and the guessing - entropy based definitions , the channel - capacity based definition of quantitative information flow is not parameterized by a distribution over the inputs . as with the other definitions ,",
    "let us test the definition on the running example from section  [ sec : introduction ] by calculating the quantities for the programs @xmath3 and @xmath5 : @xmath83(o;h)\\\\ & = 1\\\\&\\\\ { \\it cc}(m_2)&=\\max_\\mu\\mathcal{i}[\\mu](o;h)\\\\ & = 2 \\end{array}\\ ] ] as with the entropy - based definitions ( with the uniform distribution ) , we have that @xmath84 and @xmath85 , that is , the channel - capacity based quantitative information flow also says that @xmath5 is less secure than @xmath3 .",
    "we investigate the hardness of deciding the following _ comparison problem _",
    "@xmath86 $ ] : given programs @xmath3 and @xmath5 having the same input domain , decide if @xmath18(m_1 ) \\leq { \\it    se}[\\mu](m_2)$ ] . because we are interested in hardness , we focus on the case where @xmath11 is the uniform distribution @xmath55 . that is , the results we prove for the specific case applies to the general case .",
    "also note that the comparison problem is no harder than actually computing the quantitative information flow because we can compare @xmath18(m_1)$ ] and @xmath18(m_2)$ ] if we know their actual values .",
    "likewise , we study the hardness of the comparison problem @xmath87 $ ] , defined to be the problem @xmath19(m_1 ) \\leq { \\it    me}[\\mu](m_2)$ ] , @xmath88 $ ] , defined to be the problem @xmath13(m_1 ) \\leq { \\it ge}[\\mu](m_2)$ ] , and @xmath89 , defined to be the problem @xmath84 . as with @xmath90",
    "$ ] , we require the two programs to share the same input domain for these problems .    we show that none of these comparison problems are @xmath21-safety problems for any @xmath21 .",
    "informally , a program property is said to be a _",
    "property  @xcite if it can be refuted by observing @xmath21 number of ( finite ) execution traces .",
    "a @xmath21-safety problem is the problem of checking a @xmath21-safety property .",
    "note that the standard safety property is a @xmath91-safety property .",
    "an important property of a @xmath21-safety problem is that it can be reduced to a standard safety ( i.e. , @xmath91-safety ) problem , such as the unreachability problem , via a simple program transformation called _ self composition _  @xcite .",
    "it is well - known that non - interference is a @xmath22-safety property ,- safety property  @xcite . ] and this has enabled its precise checking via a reduction to a safety problem via self composition and piggybacking on advances in automated safety verification methods  @xcite .",
    "unfortunately , the results in this section imply that quantitative information flow inference problem is unlikely to receive the same benefits .    because we are concerned with properties about pairs of programs ( i.e. , comparison problems ) ,",
    "we extend the notion of @xmath21-safety to properties refutable by observing @xmath21 traces from each of the two programs .",
    "more formally , we say that the comparison problem @xmath92 is a @xmath21-safety property if @xmath93 implies that there exists @xmath94\\hspace*{-1.2pt}]}$ ] and @xmath95\\hspace*{-1.2pt}]}$ ] such that    * @xmath96 * @xmath97 * @xmath98\\hspace*{-1.2pt } ] } \\wedge t_2 \\subseteq { [ \\hspace*{-1.2pt}[m_2']\\hspace*{-1.2pt } ] } \\rightarrow   ( m_1 ' , m_2 ' ) \\not\\in c$ ]    in the above , @xmath99\\hspace*{-1.2pt}]}$ ] denotes the semantics ( i.e. , traces ) of @xmath8 , represented by the set of input / output pairs @xmath100 .",
    "we now state the main results of the section .",
    "( recall that @xmath55 denotes the uniform distribution . )",
    "we sketch the main idea of the proofs .",
    "all proofs are by contradiction .",
    "let @xmath92 be the comparison problem in the statement and suppose @xmath92 is @xmath21-safety .",
    "let @xmath101 .",
    "then , we have @xmath94\\hspace*{-1.2pt}]}$ ] and @xmath102\\hspace*{-1.2pt}]}$ ] satisfying the properties ( 1 ) , ( 2 ) , and ( 3 ) above . from this , we construct @xmath103 and @xmath104 such that @xmath105\\hspace*{-1.2pt}]}$ ] and @xmath106\\hspace*{-1.2pt}]}$ ] and @xmath107 to obtain the contradiction .    @xmath108 $ ] is not a @xmath21-safety property for any @xmath109 .",
    "[ thm : seks ]    @xmath110 $ ] is not a @xmath21-safety property for any @xmath109 .",
    "[ thm : meks ]    @xmath111 $ ] is not a @xmath21-safety property for any @xmath112 .",
    "[ thm : geks ]    @xmath89 is not a @xmath21-safety property for any @xmath109 .",
    "[ thm : ccks ]      the notion of @xmath21-safety property , like the notion of safety property from where it extends , is defined over all programs regardless of their size .",
    "( for example , non - interference is a @xmath22-safety property for all programs and unreachability is a safety property for all programs . ) but , it is easy to show that the comparison problems would become `` @xmath21-safety '' properties if we constrained and bounded the input domains because then the size of the semantics ( i.e. , the input / output pairs ) of such programs would be bounded by @xmath113 . in this case , the problems are at most @xmath113-safety .",
    "however , these bounds are high for all but very small domains , and are unlikely to lead to a practical verification method .",
    "we discuss the details of the proof of theorem  [ thm : seks ] .",
    "the proofs of theorems  [ thm : meks ] , [ thm : geks ] , [ thm : ccks ] are deferred to appendix  [ sec : proofs ] .    for contradiction",
    ", suppose @xmath108 $ ] is a @xmath21-safety property .",
    "let @xmath8 and @xmath114 be programs having the same input domain such that @xmath115 $ ] .",
    "then , it must be the case that there exist @xmath116\\hspace*{-1.2pt}]}$ ] and @xmath117\\hspace*{-1.2pt}]}$ ] such that @xmath118 , @xmath119 , and @xmath120\\hspace*{-1.2pt}]}\\wedge t ' \\subseteq { [ \\hspace*{-1.2pt}[m_c']\\hspace*{-1.2pt } ] } \\rightarrow ( m_c , m_c ' )",
    "\\not\\in c_{\\it se}[u]$ ] .",
    "let @xmath121 where @xmath122 .",
    "now , we construct new programs @xmath123 and @xmath124 as follows .",
    "@xmath125 where    * @xmath126 , * @xmath127 , * @xmath128 , @xmath129 , @xmath130 , @xmath131 , and @xmath132 are distinct , * @xmath133 , * @xmath134 , and * @xmath135 .    then ,",
    "comparing the shannon - entropy - based quantitative information flow of @xmath123 and @xmath124 , we have , @xmath136(\\bar{m'})-{\\it se}[u](\\bar{m})\\\\    \\hspace{2em}=\\sum_{o_x'\\in{\\{{o_1',\\dots , o_i'}\\}}}u(o_x')\\log\\frac{1}{u(o_x')}\\\\    \\hspace{3em}+u(o')\\log\\frac{1}{u(o')}+u(o_r')\\log\\frac{1}{u(o_r')}\\\\    \\hspace{4em}-(\\sum_{o_x\\in{\\{{o_1,\\dots , o_j}\\}}}u(o_x)\\log\\frac{1}{u(o_x)}\\\\    \\hspace{5em}+\\sum_{o_y\\in{\\{{o_{j+1},\\dots , o_{j+i}}\\}}}u(o_y)\\log\\frac{1}{u(o_y)}\\\\    \\hspace{6em}+u(o_r)\\log\\frac{1}{u(o_r)})\\\\ \\end{array}\\ ] ] ( note the abbreviations from appendix  [ sec : lemdefs ] . ) by lemma  [ lem : a7 ] , we have @xmath137 and @xmath138 trivially , we have @xmath139 as a result , we have @xmath140(\\bar{m'})-{\\it se}[u](\\bar{m})\\ge 0\\ ] ] note that @xmath123 and @xmath124 have the same counterexamples @xmath141 and @xmath142 , that is , @xmath143\\hspace*{-1.2pt}]}$ ] and @xmath144\\hspace*{-1.2pt}]}$ ] . however , we have @xmath145 $ ] .",
    "this leads to a contradiction .",
    "@xmath146    @xmath147\\\\ { \\textit{wp}({{\\sf if}\\;\\psi\\;{\\sf then}\\;m_0\\;{\\sf else}\\;m_1 } , { \\phi})}\\\\ \\qquad=(\\psi\\rightarrow { \\textit{wp}({m_0 } , { \\phi})})\\wedge(\\neg \\psi\\rightarrow { \\textit{wp}({m_1 } , { \\phi})})\\\\ { \\textit{wp}({m_0;m_1 } , { \\phi})}={\\textit{wp}({m_0 } , { { \\textit{wp}({m_1 } , { \\phi } ) } } ) } \\end{array}\\ ] ]    the purpose of this section is to show a complexity theoretic gap between non - interference and quantitative information flow .",
    "the results strengthen the hypothesis that quantitative information flow is quite hard to compute precisely , and also suggest an interesting connection to counting problems .",
    "we focus on loop - free boolean programs whose syntax is given in figure  [ syntax ] .",
    "we assume the usual derived formulas @xmath148 , @xmath149 , @xmath150 , and @xmath151 . we give the usual weakest precondition semantics in figure  [ wpsemantics ] .",
    "to adapt the information flow framework to boolean programs , we make each information flow variable @xmath1 , @xmath47 , and @xmath2 range over functions mapping boolean variables of its kind to boolean values .",
    "so , for example , if @xmath152 and @xmath153 are low security boolean variables and @xmath154 is a high security boolean variable , then @xmath47 ranges over the functions @xmath155 , and @xmath1 and @xmath2 range over @xmath156 .",
    "( every boolean variable is either a low security boolean variable or a high security boolean variable . )",
    "we write @xmath157 for an input @xmath158 and an output @xmath159 if @xmath160 for a boolean formula @xmath161 such that @xmath162 and @xmath163 for all output @xmath164 . here",
    ", @xmath165 is the usual logical satisfaction relation , using @xmath166 , etc .  to look up the values of the boolean variables .",
    "( note that this incurs two levels of lookup . )    as an example , consider the following program .",
    "@xmath167 let @xmath152 , @xmath153 and @xmath168 be high security variables and @xmath154 be a low security variable . then , @xmath169(m ) & = & 1.5\\\\    { \\it me}[u](m ) & = & \\log 3\\\\ & \\approx & 1.5849625\\\\ { \\it ge}[u](m)&= & 1.25\\\\ { \\it cc}(m ) & = & \\log 3\\\\ & \\approx & 1.5849625 \\\\ \\end{array}\\ ] ]    we prove the following hardness results .",
    "these results are proven by a reduction from # sat , which is the problem of counting the number of solutions to a quantifier - free boolean formula .",
    "# sat is known to be # p - complete . because # sat is a function problem and the comparison problems are decision problems , a step in the proofs makes binary search queries to the comparison problem oracle a polynomial number of times .",
    "( recall that the notation @xmath170 means the complexity class of function problems solvable in polynomial time with an oracle for the problem @xmath171 . )",
    "[ thm : secomp ] @xmath172}$ ]    [ thm : mecomp ] @xmath173}$ ]    [ thm : gecomp ] @xmath174}$ ]    [ thm : cccomp ]",
    "@xmath175    we remind that the above results apply ( even ) when the comparison problems @xmath108 $ ] , @xmath110 $ ] , @xmath111 $ ] , and @xmath89 are restricted to loop - free boolean programs .    in summary , each comparison problem @xmath108 $ ] , @xmath110 $ ] , @xmath111 $ ] , and @xmath89 can be used a polynomial number of times to solve a # p - complete problem . because toda s theorem  @xcite implies that the entire polynomial hierarchy can be solved by using a # p - complete oracle a polynomial number of times ,",
    "our results show that the comparison problems for quantitative information flow can also be used a polynomial number of times to solve the entire polynomial hierarchy , for the case of loop - free boolean programs .",
    "as shown below , this presents a gap from non - interference , which is only conp - complete for loop - free boolean programs .",
    "[ thm : nicomp ] checking non - interference is conp - complete for loop - free boolean programs .",
    "the above is an instance of the general observation that , by solving quantitative information flow problems , one is able to solve the class of problems known as _ counting problems _ , which coincides with # sat for the case of loop - free boolean programs .",
    "we discuss the details of the proof of theorem  [ thm : secomp ] .",
    "the proofs of theorems  [ thm : mecomp ] , [ thm : gecomp ] , [ thm : cccomp ] are deferred to appendix  [ sec : proofs ] .",
    "first , we prove the following lemma which states that we can compare the number of solutions to boolean formulas by computing @xmath59 $ ] .",
    "( for convenience , we use large letters @xmath1 , @xmath47 , @xmath2 , etc .  to range over boolean variables as well as generic random variables . )",
    "[ lem : a3 ] let @xmath176 and @xmath177 be distinct boolean random variables .",
    "let @xmath178 and @xmath179 be any non - negative integers such that @xmath180 and @xmath181 .",
    "let @xmath182 ( resp .",
    "@xmath183 ) be a formula over @xmath176 having @xmath178 ( resp .",
    "@xmath179 ) assignments",
    ". then , @xmath184 iff @xmath59(m_j)\\le{\\it se}[u](m_i)$ ] where @xmath185 and @xmath186 .",
    "let @xmath187 and @xmath188 .",
    "we have @xmath189(m_j ) & = \\frac{j}{2^{|h|+1}}\\log\\frac{2^{|h|+1}}{j } + \\frac{2^{|h|+1}-j}{2^{|h|+1}}\\log\\frac{2^{|h|+1}}{2^{|h|+1}-j}\\\\ \\hspace{5.3em } & = p\\log p + ( 1-p)\\log \\frac{1}{1-p}\\\\    { \\it se}[u](m_i ) & = \\frac{i}{2^{|h|+1}}\\log\\frac{2^{|h|+1}}{i } + \\frac{2^{|h|+1}-i}{2^{|h|+1}}\\log\\frac{2^{|h|+1}}{2^{|h|+1}-i}\\\\ \\hspace{5.3em } & = q\\log q + ( 1-q)\\log \\frac{1}{1-q } \\end{array}\\ ] ]    * * only if * + suppose @xmath184 . then",
    ", @xmath136(m_i)-{\\it se}[u](m_j ) \\\\ \\hspace{3em } = p\\log\\frac{1}{p }",
    "+ ( 1-p)\\log\\frac{1}{1-p}\\\\   \\hspace{4em } - q\\log\\frac{1}{q } - ( 1-q)\\log\\frac{1}{1-q}\\\\ \\hspace{3em } = \\log(\\frac{1-p}{p})^p \\frac{1-q}{1-p } ( \\frac{q}{1-q})^q \\end{array}\\ ] ] then , from @xmath190 and @xmath191 , we have @xmath58(m_i)-{\\it se}[u](m_j ) & \\geq \\log(\\frac{1-p}{p})^p ( \\frac{q}{1-q})^q\\\\ & \\ge\\log(\\frac{1-p}{p})^q ( \\frac{q}{1-q})^q\\\\ & = \\log(\\frac{(1-p)q}{p(1-q)})^q\\\\ & = \\log(\\frac{q - pq}{p - pq})^q\\\\ & = \\log(\\frac{pq - q}{pq - p})^q\\\\ & = \\log(\\frac{1-\\frac{1}{p}}{1-\\frac{1}{q}})^q\\\\ & \\geq 0 \\end{array}\\ ] ] the last line follows from @xmath192 . * * if * + we prove the contraposition .",
    "suppose @xmath193 . then , @xmath194(m_j ) - { \\it",
    "se}[u](m_i ) \\\\ \\qquad = q\\log\\frac{1}{q } + ( 1-q)\\log\\frac{1}{1-q } \\\\ \\qquad\\qquad- p\\log\\frac{1}{p } - ( 1-p)\\log\\frac{1}{1-p } \\\\ \\qquad > 0 \\end{array}\\ ] ]",
    "the last line follows from the fact that @xmath195 .",
    "therefore , @xmath59(m_j ) \\not\\leq { \\it se}[u](m_i)$ ] .    then , using lemma  [ lem : a3 ] , we prove the following lemma which is crucial to proving theorem  [ thm : secomp ] .    [",
    "lem : a4 ] let @xmath176 be distinct variables and @xmath161 be a boolean formula over @xmath176 . then , the number of assignments for @xmath161 can be computed by executing an oracle that decides whether programs are in @xmath108 $ ] at most @xmath196 times .",
    "first , we define a procedure that returns the number of solutions of @xmath161 .",
    "let @xmath197 where @xmath198 is a formula over @xmath176 having @xmath179 assignments and @xmath177 be a boolean variable such that @xmath199 .",
    "note that , by lemma  [ lem : a2 ] , such @xmath198 can be generated in linear time .",
    "then , we invoke the following procedure where @xmath200 .",
    "@xmath201(f(n),m ' ) \\vee \\neg c_{\\it se}[u](m',f(n))\\\\    \\qquad{\\sf if}\\;c_{\\it se}[u](f(n),m')\\\\    \\qquad\\qquad{\\sf then}\\;\\{\\ell = n;n=(\\ell+r)/2;\\}\\\\    \\qquad\\qquad{\\sf else}\\;\\{r = n;n=(\\ell+r)/2;\\}\\\\    { \\sf return}\\;n \\end{array}\\ ] ]    note that when the procedure terminates , we have @xmath59(f(n ) ) = { \\it se}[u](m')$ ] , and so by lemma  [ lem : a3 ] , @xmath202 is the number of satisfying assignments to @xmath161 .",
    "we show that the procedure iterates at most @xmath203 times . to see this , every iteration in the procedure",
    "narrows the range between @xmath204 and @xmath51 by one half .",
    "because @xmath205 is bounded by @xmath206 , it follows that the procedure iterates at most @xmath203 times .",
    "hence , the oracle @xmath108 $ ] is accessed @xmath196 times , and this proves the lemma .",
    "finally , theorem  [ thm : secomp ] follows from lemma  [ lem : a4 ] and the fact that # sat , the problem of counting the number of solutions to a boolean formula , is # p - complete .",
    "as proved in section  [ sec : qifnksafe ] , precisely computing quantitative information flow is quite difficult . indeed",
    ", we have shown that even just comparing two programs on which has the larger flow is difficult ( i.e. , @xmath207 , @xmath208 , @xmath209 , and @xmath89 ) .    in this section ,",
    "we show that universally quantifying the shannon - entropy based comparison problem @xmath86 $ ] , the min - entropy based problem @xmath210 $ ] , or the guessing - entropy based problem @xmath88 $ ] over the distribution @xmath11 is equivalent to a simple relation @xmath34 enjoying the following properties .",
    "* @xmath34 is a @xmath22-safety property .",
    "* @xmath34 is conp - complete for loop - free boolean programs .",
    "note that ( 1 ) implies that we can actually check if @xmath211 $ ] for all @xmath11 via self composition ( and likewise for @xmath210 $ ] and @xmath88 $ ] ) .",
    "we actually show in section  [ sec : qbysc ] that we can even use the security - type - based approach suggested by terauchi and aiken  @xcite to minimize code duplication during self composition ( i.e. , do _ interleaved _ self composition ) .    we remind that except for the conp - completeness result ( theorem  [ thm : rcomp ] ) , the results in this section apply to any ( deterministic and terminating ) programs and not just to loop - free boolean programs .",
    "[ def : r ] we define @xmath34 to be the relation such that @xmath212 iff for all",
    "@xmath66 and @xmath213 , if @xmath214 then @xmath215 .",
    "note that @xmath31 essentially says that if an attacker can distinguish a pair of high security inputs by executing @xmath3 , then she could do the same by executing @xmath5 .",
    "hence , @xmath34 naturally expresses that @xmath3 is at least as secure as @xmath5 .",
    "have appeared in literature ( often in somewhat different representations )  @xcite . in particular ,",
    "clark et al .",
    "@xcite have shown a result analogous to the @xmath216 direction of theorem  [ thm : reqse ] below .",
    "but , @xmath34 s properties have not been fully investigated . ]",
    "it may be somewhat surprising that this simple relation is actually equivalent to the rather complex entropy - based quantitative information flow definitions when they are cast as comparison problems and the distributions are universally quantified , as stated in the following theorems .",
    "first , we show that @xmath34 coincides exactly with @xmath207 with its distribution universally quantified .",
    "[ thm : reqse ] @xmath217(m_1,m_2)}\\}}$ ]    the proof is detailed in section  [ sec : reqseproof ] .",
    "the next two theorems show that @xmath34 also coincides with @xmath208 and @xmath218 with their distribution universally quantified .",
    "[ thm : reqme ] @xmath219(m_1,m_2)}\\}}$ ]    [ thm : reqge ] @xmath220(m_1,m_2)}\\}}$ ]    the first half of the @xmath216 direction of the proofs for the theorems above is much like the that of theorem  [ thm : reqse ] , that is , it makes the observation that @xmath5 disambiguates the high security inputs at least as fine as does @xmath3 .",
    "then , the proof concludes by utilizing the particular mathematical properties relevant to the respective definitions .",
    "the proof for the @xmath221 direction is also similar to the argument used in theorem  [ thm : reqse ] .",
    "the details of the proofs appear in appendix  [ sec : proofs ] .",
    "next , we show that @xmath34 refines @xmath89 in the sense that if @xmath212 then @xmath222 .",
    "[ thm : rimpcc ] @xmath223    note that , the other direction , @xmath224 , does not hold as @xmath34 is not always a total order , whereas @xmath89 is .",
    "we also show that @xmath34 is compatible with the notion of non - interference .",
    "[ thm : rni ] let @xmath5 be a non - interferent program . then",
    ", @xmath212 iff @xmath3 is also non - interferent and @xmath3 has the same input domain as @xmath5 .",
    "next , we show that @xmath34 is easier to decide than the non - universally - quantified versions of the comparison problems .",
    "first , it is trivial to see from definition  [ def : r ] that @xmath34 is a @xmath22-safety property .",
    "[ thm : r2safe ] @xmath34 is a @xmath22-safety property .",
    "it can be shown that , restricted to loop - free boolean programs , @xmath34 is conp - complete .",
    "this follows directly from the observation that we can decide @xmath34 by self composition thanks to its @xmath22-safety property and the fact that , for loop - free boolean programs , self composition reduces the problem to an unsat instance .. ]    [ thm : rcomp ] restricted to loop - free boolean programs , @xmath34 is conp - complete .",
    "we discuss the details of the proof of theorem  [ thm : reqse ] .",
    "the proofs of theorems  [ thm : reqme ] , [ thm : reqge ] , [ thm : rimpcc ] are deferred to appendix  [ sec : proofs ] .",
    "first , we prove the following lemma which says that , if @xmath225 then @xmath59(m')$ ] is at least as large as @xmath59(m)$ ] per each low security input @xmath66 .",
    "[ lem : a8 ] suppose @xmath225 , that is , for all @xmath226 , @xmath227 in @xmath228 and @xmath51 in @xmath229 , @xmath230 .",
    "let @xmath231 be the set of the outputs of @xmath8 , and @xmath232 be the set of the outputs of @xmath114 . then , for any @xmath51 , we have @xmath233 .",
    "( recall the notational convention from definition  [ def : distabrv ] . )",
    "first , we prove for any output @xmath159 of @xmath8 , there exist corresponding outputs @xmath234 of @xmath114 such that @xmath235 let @xmath236 be the set such that @xmath237 .",
    "let @xmath238 .",
    "let @xmath239,  and , @xmath240 .",
    "for any @xmath241 such that @xmath242 and @xmath243 , we have @xmath244 since @xmath225 .",
    "then , we have @xmath245 . by lemma  [ lem : a7 ]",
    ", we have @xmath246 now to prove the lemma , it suffices to show that each @xmath247 constructed above are disjoint .",
    "that is , for @xmath248 and @xmath249 outputs of @xmath8 such that @xmath250 , @xmath251 . for contradiction ,",
    "suppose @xmath252 .",
    "then , there exist @xmath226 and @xmath227 such that @xmath253 , @xmath254 , @xmath255 , and @xmath256 . since @xmath225",
    ", we have @xmath257 , and it leads to a contradiction .",
    "hence , we have @xmath258    we now prove theorem  [ thm : reqse ] .    *",
    "@xmath216 + suppose @xmath259 . by lemma  [ lem : detse ] , @xmath260(m)&=\\mathcal h[\\mu](o|l)\\\\    & = \\sum_\\ell\\sum_o \\mu(o,\\ell)\\log\\frac{\\mu(\\ell)}{\\mu(o,\\ell)}\\\\ \\end{array}\\ ] ] and @xmath260(m')&=\\mathcal h[\\mu](o'|l)\\\\    &",
    "= \\sum_\\ell\\sum_{o ' } \\mu(o',\\ell)\\log\\frac{\\mu(\\ell)}{\\mu(o',\\ell)}\\\\ \\end{array}\\ ] ] by lemma  [ lem : a8 ] and the fact that @xmath259 , we obtain for any @xmath51 @xmath261 hence , @xmath262 * @xmath221 + we prove the contraposition .",
    "suppose @xmath263 .",
    "then , there exist @xmath264 such that @xmath265 and @xmath266 .",
    "pick a probability function @xmath11 such that @xmath267 .",
    "+ then , we have @xmath268(o'|l)&=\\sum_\\ell\\sum_o \\mu(o,\\ell)\\log\\frac{\\mu(\\ell)}{\\mu(o,\\ell)}\\\\ & = \\mu(o',\\ell')\\log\\frac{\\mu(\\ell')}{\\mu(o',\\ell')}\\\\ & = 1\\log\\frac{1}{1}\\\\ & = 0 \\end{array}\\ ] ] let @xmath269 and @xmath248 be output variables such that @xmath270 , @xmath271 , and @xmath272 .",
    "@xmath273(o|l)&=\\sum_{o\\in{\\{{o_0,o_1}\\ } } } \\mu(o,\\ell')\\log\\frac{\\mu(\\ell')}{\\mu(o,\\ell')}\\\\ & = \\frac{1}{2}\\log\\frac{1}{\\frac{1}{2}}+\\frac{1}{2}\\log\\frac{1}{\\frac{1}{2}}\\\\ & = 1\\\\ \\end{array}\\ ] ] therefore , @xmath18(m)\\not\\le{\\it se}[\\mu](m')$ ] , that is , @xmath274}\\}}$ ] .",
    "theorems  [ thm : reqse ] , [ thm : reqme ] , [ thm : reqge ] , and [ thm : r2safe ] imply that we can check if the entropy - based quantitative information flow of a program ( i.e. , _ se _ , _ me _ , and _ ge _ ) is bounded by that of another for all distributions via self composition  @xcite .",
    "this suggests a novel approach to precisely checking quantitative information flow .",
    "that is , given a _",
    "program @xmath3 , the user would construct a _ specification _",
    "program @xmath5 with the same input domain as @xmath3 having the desired level of security .",
    "then , she would check @xmath212 via self composition .",
    "if so , then @xmath3 is guaranteed to be at least as secure as @xmath5 according to the shannon - entropy based , the min - entropy based , and the guessing - entropy based definition of quantitative information flow for all distributions ( and also channel - capacity based definition ) , and otherwise , there must be a distribution in which @xmath3 is less secure than @xmath5 according to the entropy - based definitions .",
    "note that deciding @xmath31 is useful even when @xmath3 and @xmath5 are @xmath34-incomparable , that is , when neither @xmath212 nor @xmath275 .",
    "this is because @xmath276 implies that @xmath3 is less secure than @xmath5 on some distribution .",
    "for example , suppose @xmath3 is some complex login program with the high security input @xmath1 and the low security input @xmath47 .",
    "and we would like to verify that @xmath3 is at least as secure as the prototypical login program @xmath5 below .",
    "@xmath277 then , using this framework , it suffices to just query if @xmath212 is true .",
    "( note that the output domains of @xmath3 and @xmath5 need not to match . )",
    "we now describe how to actually check @xmath212 via self composition . from @xmath3 and @xmath5",
    ", we construct the self - composed program @xmath114 shown below .",
    "@xmath278 note that @xmath212 is true iff @xmath114 does not cause an assertion failure .",
    "the latter can be checked via a software safety verifier such as slam and blast  @xcite . as an aside",
    ", we note that this kind of construction could be easily generalized to reduce any @xmath21-safety problem ( cf . section  [ sec : qifnksafe ] ) to a safety problem , as shown by clarkson and schneider  @xcite .",
    "note that the line @xmath279 ( resp .",
    "@xmath280 ) of the pseudo code above is @xmath3 ( resp .",
    "@xmath5 ) sequentially composed with a copy of itself , which is from where the name `` self composition '' comes .",
    "therefore , technically , @xmath114 is a composition of two self compositions .",
    "@xmath279 ( and @xmath280 ) are actually exactly the original self composition proposed for non - interference  @xcite .",
    "terauchi and aiken  @xcite noted that only the parts of @xmath3 ( and @xmath5 ) that depend on the high security inputs @xmath1 and @xmath177 need to be duplicated and self composed , with the rest of the program left intact and `` interleaved '' with the self - composed parts .",
    "the resulting program tends to be verified easier than the naive self composition by modern software safety verifiers .",
    "they proposed a set of transformation rules that translates a while program annotated with security types  @xcite ( or dependency analysis results ) to an interleaved self - composed program .",
    "this was subsequently improved by a number of researchers to support a richer set of language features and transformation patterns  @xcite .",
    "these transformation methods can be used in place of the naive self compositions at @xmath281 and @xmath280 in building @xmath114 .",
    "that is , we apply a security type inference ( or a dependency analysis ) to @xmath3 and @xmath5 to infer program parts that depend on the high security inputs @xmath1 and @xmath177 so as to only duplicate and self compose those parts of @xmath3 and @xmath5 .",
    "we recall the ideal login program below . @xmath282",
    "we check the following four programs using the above as the specification .",
    "@xmath283 here , @xmath1 and @xmath47 are 64-bit values , @xmath284 is the bit - wise and operator , and @xmath285 is the left shift operator . @xmath3 leaks the entire password .",
    "@xmath5 checks the password against the user guess but then leaks the first bit when the check fails .",
    "@xmath286 only checks the first 32 bits of the password . and , @xmath287 implements password checking correctly via a while loop .",
    "we verify that only @xmath287 satisfies the specification , that is , @xmath288 . to see that @xmath289 , note that for any @xmath290 such that @xmath291 , @xmath292 and @xmath293 , we have that @xmath294 but @xmath295 . to see that @xmath296 , note that for @xmath290 such that @xmath297 , @xmath292 , @xmath298 and @xmath299 , we have that @xmath300 but @xmath295 .",
    "to see that @xmath301 , let @xmath290 be such that @xmath302 , @xmath303 , and @xmath291 , then , @xmath304 but @xmath305 . and",
    "@xmath306 , that is , @xmath5 and @xmath286 are @xmath34-incomparable with @xmath307 . ]",
    "( here , @xmath308 denotes @xmath309 , i.e. , the first 32 bits of @xmath152 . )",
    "the results imply that for @xmath3 , @xmath5 , and @xmath286 , there must be a distribution where the program is less secure than @xmath307 according to each of the entropy - based definition of quantitative information flow .",
    "for instance , for the shannon - entropy based definition , we have for the uniform distribution @xmath55 , @xmath58(m_{\\it spec})&=\\frac{1}{2^{58 } } + \\frac{2^{64}-1}{2^{64}}\\log\\frac{2^{64}}{2^{64}-1}\\\\ & \\approx 3.46944695 \\times 10^{-18}\\\\ { \\it se}[u](m_1)&=64\\\\ { \\it se}[u](m_2)&= \\frac{1}{2 } + \\frac{1 + 2^{63}}{2^{65}}\\log\\frac{2^{64}}{1 + 2^{63}}+\\frac{2^{63}-1}{2^{65}}\\log\\frac{2^{64}}{2^{63}-1}\\\\ & \\approx 1.0\\\\ { \\it se}[u](m_3)&=\\frac{1}{2^{27}}+\\frac{2^{64}-2^{32}}{2^{64}}\\log\\frac{2^{64}}{2^{64}-2^{32}}\\\\ & \\approx 7.78648\\times10^{-9}\\\\ \\end{array}\\ ] ] that is , @xmath59(m_1 ) \\not\\leq { \\it se}[u](m_{\\it spec})$ ] , @xmath310(m_2 ) \\not\\leq { \\it se}[u](m_{\\it spec})$ ] , and @xmath310(m_3 ) \\not\\leq { \\it se}[u](m_{\\it spec})$ ] .",
    "finally , we have that @xmath288 , and so @xmath287 is at least as secure as @xmath307 according to all of the definitions of quantitative information flow considered in this paper .",
    "in fact , it can be also shown that @xmath311 .",
    "( however , note that @xmath287 and @xmath307 are not semantically equivalent , i.e. , their outputs are reversed . )",
    "this work builds on previous work that proposed information theoretic notions of quantitative information flow  @xcite .",
    "the previous research has mostly focused on information theoretic properties of the definitions and proposed approximate ( i.e. , incomplete and/or unsound ) methods for checking and inferring them . in contrast , this paper investigates the verification theoretic and complexity theoretic hardness of precisely inferring quantitative information flow according to the definitions and also proposes a precise method for checking quantitative information flow .",
    "our method checks the quantitative information flow of a program against that of a specification program having the desired level of security via self composition for all distributions according to the entropy - based definitions .",
    "it is quite interesting that the relation @xmath34 unifies the different proposals for the definition of quantitative information flow when they are cast as comparison problems and their distributions are universally quantified . as remarked in section  [ sec : qshan ] , @xmath34 naturally expresses the fact that one program is more secure than the other , and it could be argued that it is the essence of quantitative information flow .",
    "researchers have also proposed definitions of quantitative information flow that do not fit the models studied in this paper .",
    "these include the definition based on the notion of _ belief _  @xcite , and the ones that take the maximum over the low security inputs  @xcite .",
    "refines these notions in the same sense as theorem  [ thm : rimpcc ] , but the other direction is not guaranteed to hold . ]    despite the staggering complexity made apparent in this paper , recent attempts have been made to ( more ) precisely infer quantitative information flow ( without universally quantifying over the distribution as in our approach ) .",
    "these methods are based on the idea of _ counting_. as remarked in section  [ sec : complex ] , quantitative information flow is closely related to counting problems , and several attempts have been made to reduce quantitative information flow problems to them .",
    "for instance , newsome et al .",
    "@xcite reduce the inference problem to the # sat problem and apply off - the - shelf # sat solvers . to achieve scalability , they sacrifice both soundness and completeness by only computing information flow from one execution path .",
    "backes et al .",
    "@xcite also propose a counting - based approach that involves self composition .",
    "however , unlike our method , they use self composition repeatedly to find a new solution ( i.e. , more than a bounded number of times ) , and so their results do not contradict the negative results of this paper .",
    "we have investigated the hardness and possibilities of precisely checking and inferring quantitative information flow according to the various definitions proposed in literature .",
    "specifically , we have considered the definitions based on the shannon entropy , the min entropy , the guessing entropy , and channel capacity .",
    "we have shown that comparing two programs on which has the larger flow according to these definitions is not a @xmath21-safety problem for any @xmath21 , and therefore that it is not possible to reduce the problem to a safety problem via self composition .",
    "the result is in contrast to non - interference which is a @xmath22-safety problem .",
    "we have also shown a complexity theoretic gap with non - interference by proving the # p - hardness of the comparison problems and conp - completeness of non - interference , when restricted to loop - free boolean programs .",
    "we have also shown a positive result that checking if the entropy - based quantitative information flow of one program is larger than that of another for all distributions is a @xmath22-safety problem , and that it is also conp - complete when restricted to loop - free boolean programs .",
    "we have done this by proving a surprising result that universally quantifying the distribution in the comparison problem for the entropy - based definitions is equivalent to a simple @xmath22-safety relation .",
    "motivated by the result , we have proposed a novel approach to precisely checking quantitative information flow that reduces the problem to a safety problem via self composition .",
    "our method checks the quantitative information flow of a program for all distributions against that of a specification program having the desired level of security .",
    "we would like to thank takeshi tsukada for important insights and useful discussions that motivated this work .",
    "we also thank the anonymous reviewers for their useful comments .",
    "this work was supported by mext kakenhi 20700019 and 20240001 , and global coe program `` ceries . ''",
    "10    m.  backes , b.  kpf , and a.  rybalchenko . automatic discovery and quantification of information leaks . in _",
    "ieee symposium on security and privacy _ , pages 141153 .",
    "ieee computer society , 2009 .",
    "t.  ball and s.  k. rajamani .",
    "the slam project : debugging system software via static analysis . in _ popl _ , pages 13 , 2002 .",
    "g.  barthe , p.  r. dargenio , and t.  rezk .",
    "secure information flow by self - composition . in _ csfw _ , pages 100114 .",
    "ieee computer society , 2004 .",
    "d.  beyer , t.  a. henzinger , r.  jhala , and r.  majumdar .",
    "the software model checker blast .",
    ", 9(5 - 6):505525 , 2007 .",
    "d.  clark , s.  hunt , and p.  malacaria .",
    "quantified interference for a while language .",
    ", 112:149166 , 2005 .",
    "d.  clark , s.  hunt , and p.  malacaria .",
    "quantitative information flow , relations and polymorphic types .",
    ", 15(2):181199 , 2005 .",
    "d.  clark , s.  hunt , and p.  malacaria . a static analysis for quantifying information flow in a simple imperative language .",
    ", 15(3):321371 , 2007 .",
    "m.  r. clarkson , a.  c. myers , and f.  b. schneider .",
    "belief in information flow . in _",
    "pages 3145 .",
    "ieee computer society , 2005 .",
    "m.  r. clarkson and f.  b. schneider",
    ". hyperproperties . in _ csf _",
    ", pages 5165 .",
    "ieee computer society , 2008 .",
    "e.  s. cohen .",
    "information transmission in computational systems . in _",
    "sosp _ , pages 133139 , 1977 .    .",
    "darvas , r.  hhnle , and d.  sands . a theorem proving approach to analysis of secure information flow . in d.",
    "hutter and m.  ullmann , editors , _ spc _ , volume 3450 of _ lecture notes in computer science _ , pages 193209 .",
    "springer , 2005 .",
    "d.  e.  r. denning . .",
    "addison - wesley longman publishing co. , inc . ,",
    "boston , ma , usa , 1982 .",
    "c.  flanagan and j.  b. saxe . avoiding exponential explosion : generating compact verification conditions . in _",
    "pages 193205 , 2001 .",
    "j.  a. goguen and j.  meseguer .",
    "security policies and security models . in _ ieee symposium on security and privacy _ , pages 1120 , 1982 .",
    "t.  a. henzinger , r.  jhala , r.  majumdar , and g.  sutre .",
    "lazy abstraction . in _ popl _ , pages 5870 , 2002 .",
    "b.  kpf and d.  basin . an information - theoretic model for adaptive side - channel attacks . in _",
    "ccs 07 : proceedings of the 14th acm conference on computer and communications security _ , pages 286296 , new york , ny , usa , 2007 .",
    "k.  r.  m. leino .",
    "efficient weakest preconditions . , 93(6):281288 , 2005 .",
    "p.  li and s.  zdancewic .",
    "downgrading policies and relaxed noninterference . in j.",
    "palsberg and m.  abadi , editors , _ popl _ , pages 158170 .",
    "acm , 2005 .",
    "p.  malacaria .",
    "assessing security threats of looping constructs . in m.",
    "hofmann and m.  felleisen , editors , _ popl _ , pages 225235 .",
    "acm , 2007 .",
    "p.  malacaria and h.  chen .",
    "lagrange multipliers and maximum information leakage in different observational models . in _",
    "plas 08 : proceedings of the third acm sigplan workshop on programming languages and analysis for security _ , pages 135146 , new york , ny , usa , 2008 .",
    "j.  l. massey .",
    "guessing and entropy . in _",
    "isit 94 : proceedings of the 1994 ieee international symposium on information theory _",
    ", page 204 , 1994 .",
    "s.  mccamant and m.  d. ernst .",
    "quantitative information flow as network flow capacity . in r.",
    "gupta and s.  p. amarasinghe , editors , _ pldi _ , pages 193205 .",
    "acm , 2008 .",
    "j.  mclean . a general theory of composition for trace sets closed under selective interleaving functions . in _",
    "sp 94 : proceedings of the 1994 ieee symposium on security and privacy _",
    ", page  79 , washington , dc , usa , 1994 .",
    "ieee computer society .",
    "k.  l. mcmillan .",
    "lazy abstraction with interpolants . in t.  ball and r.  b. jones , editors , _ cav _ , volume 4144 of _ lecture notes in computer science _ , pages 123136 .",
    "springer , 2006 .",
    "d.  a. naumann . from coupling relations to mated invariants for checking information flow . in _",
    "computer security - esorics 2006 , 11th european symposium on research in computer security , proceedings _",
    ", pages 279296 , hamburg , germany , sept . 2006 .",
    "j.  newsome , s.  mccamant , and d.  song .",
    "measuring channel capacity to distinguish undue influence . in _ proceedings of the fourth acm sigplan workshop on programming languages and analysis for security ( plas ) _ , dublin , ireland ,",
    "june 2009 .",
    "a.  sabelfeld and a.  c. myers . a model for delimited information release .",
    "in k.  futatsugi , f.  mizoguchi , and n.  yonezaki , editors , _ isss _ , volume 3233 of _ lecture notes in computer science _ , pages 174191 .",
    "springer , 2003 .",
    "c.  shannon . a mathematical theory of communication .",
    ", 27:379423 , 623656 , 1948 .",
    "g.  smith .",
    "on the foundations of quantitative information flow . in _",
    "fossacs 09 : proceedings of the 12th international conference on foundations of software science and computational structures _ ,",
    "pages 288302 , berlin , heidelberg , 2009 .",
    "springer - verlag .",
    "t.  terauchi and a.  aiken .",
    "secure information flow as a safety problem . in c.",
    "hankin and i.  siveroni , editors , _ sas _ , volume 3672 of _ lecture notes in computer science _ , pages 352367 .",
    "springer , 2005 .",
    "s.  toda .",
    "is as hard as the polynomial - time hierarchy .",
    ", 20(5):865877 , 1991 .",
    "h.  unno , n.  kobayashi , and a.  yonezawa .",
    "combining type - based analysis and model checking for finding counterexamples against non - interference . in v.  c. sreedhar and s.  zdancewic , editors , _ plas _ , pages 1726 .",
    "acm , 2006 .",
    "d.  volpano , g.  smith , and c.  irvine . a sound type system for secure flow analysis .",
    ", 4(3):167187 , 1996 .",
    "we define some abbreviations .    [ def : distabrv ]",
    "@xmath312    we use this notation whenever the correspondences between random variables and their values are clear .    for convenience , we sometimes use large letters @xmath1 , @xmath47 , @xmath2 , etc .  to range over boolean variables as well as generic random variables .    for simplicity",
    ", we often compute the shannon - entropy based quantitative information flow for programs that do not have low security inputs . for such programs ,",
    "the equation _ se _ from definition  [ def : se ] can be simplified as follows",
    ".    @xmath313(m)&=\\mathcal{i}[\\mu](o;h)\\\\    & = \\mathcal{h}[\\mu](o ) \\end{array}\\ ] ]    we note the following property of deterministic programs  @xcite .",
    "[ lem : detse ] for @xmath8 deterministic , @xmath314(m)=\\mathcal{i}[\\mu](o;h|l ) = \\mathcal{h}[\\mu](o|l)\\ ] ]    the following lemma is used to show that we can generate a boolean formula that has exactly the desired number of solutions in polynomial ( actually , linear ) time .    [",
    "lem : a2 ] let @xmath21 be an integer such that @xmath315 .",
    "then , a boolean formula that has exactly @xmath21 assignments over the variables @xmath316 can be computed in time linear in @xmath317 .",
    "we define a procedure that returns the boolean formula .",
    "below , @xmath318 , i.e. , @xmath319 is the @xmath178th variable .",
    "@xmath320 here , @xmath321 is an empty string .",
    "let @xmath322 be a @xmath317-bit binary representation of @xmath21 .",
    "we prove that @xmath323 returns a boolean formula that has exactly k assignments by induction on the number of variables , that is , @xmath317 .",
    "* @xmath324 * * @xmath325 + @xmath326 returns @xmath327 , that is , @xmath328 .",
    "@xmath151 has no satisfying assignment .",
    "* * @xmath329 + @xmath330 returns @xmath331 , that is , @xmath332 .",
    "@xmath332 has only one satisfying assignment . *",
    "@xmath333 * * @xmath334 + let @xmath335 be a binary representation of @xmath21 . @xmath336",
    "returns @xmath337 . by induction hypothesis , @xmath338 has @xmath21 satisfying assignments for @xmath316 .",
    "it follows that @xmath337 has just @xmath21 satisfying assignments , because @xmath339 has no assignment and @xmath340 has just @xmath21 assignments . *",
    "* @xmath341 + let @xmath342 be a binary representation of @xmath21 .",
    "@xmath343 returns @xmath344 .",
    "@xmath51 is a binary representation of @xmath345 . by induction hypothesis",
    ", @xmath338 has @xmath345 satisfying assignments for @xmath316 .",
    "it follows that @xmath344 has just @xmath21 satisfying assignments , because @xmath346 has just @xmath345 assignments and when @xmath347 , @xmath344 has just @xmath348 assignments .",
    "we frequent the following property of logarithmic arithmetic when proving statements concerning the shannon entropy .",
    "[ lem : a7 ] let @xmath349 and @xmath350 be numbers such that @xmath351 $ ] .",
    "then , we have @xmath352 .    because @xmath353 and @xmath354 , it follows that , @xmath355",
    "[ thm : reqni ] let @xmath8 be a program that takes high - security input @xmath1 , low - security input @xmath47 , and returns low - security output @xmath2 .",
    "then , @xmath8 is non - interferent if and only if @xmath356(m)=0 $ ] .      * ( @xmath358 ) suppose that @xmath8 is non - interferent .",
    "then , by lemma  [ lem : detse ] , @xmath52(m)&=&\\mathcal{i}[\\mu](o;h|l)\\\\ & = & \\mathcal{h}[\\mu](o|l)\\\\ & = & \\sum_{o}\\sum_{\\ell}\\mu(o,\\ell)\\log\\frac{\\mu(\\ell)}{\\mu(o,\\ell)}\\\\ & = & \\sum_{o}\\sum_{\\ell}\\mu(o,\\ell)\\log\\frac{\\mu(\\ell)}{\\mu(\\ell)}\\\\ & = & 0 \\end{array}\\ ] ] the last step follows from the fact that non - interference implies @xmath359 . *",
    "( @xmath360 ) suppose that @xmath8 is interferent .",
    "then , there must be @xmath361 and @xmath226 such that @xmath362 , @xmath363 , and @xmath272 .",
    "pick a probability function @xmath11 such that @xmath267 . then , by lemma  [ lem : detse ] , @xmath52(m)&=&\\mathcal{i}[\\mu](o;h|l)\\\\ & = & \\mathcal{h}[\\mu](o|l)\\\\ & = & \\sum_{o}\\sum_{\\ell}\\mu(o,\\ell)\\log\\frac{\\mu(\\ell)}{\\mu(o,\\ell)}\\\\ & = & \\mu(o_0,\\ell')\\log\\frac{\\mu(\\ell')}{\\mu(o_0,\\ell')}\\\\ & & \\qquad+\\mu(o_1,\\ell')\\log\\frac{\\mu(\\ell')}{\\mu(o_1,\\ell')}\\\\ & = & \\frac{1}{2}\\log 2 + \\frac{1}{2}\\log 2\\\\ & = & 1 \\end{array}\\ ] ] therefore , there exists @xmath11 such that @xmath18(m ) \\neq 0 $ ] , and we have the conclusion .",
    "for contradiction , suppose @xmath110 $ ] is a @xmath21-safety property .",
    "let @xmath8 and @xmath114 be programs having same input domain such that @xmath364 $ ] .",
    "then , it must be the case that there exist @xmath365\\hspace*{-1.2pt}]}$ ] and @xmath366\\hspace*{-1.2pt}]}$ ] such that @xmath118 , @xmath119 , and @xmath367\\hspace*{-1.2pt } ] } \\wedge t ' \\subseteq { [ \\hspace*{-1.2pt}[m_c']\\hspace*{-1.2pt } ] } \\rightarrow ( m_c ,    m_c ' )",
    "\\not\\in c_{\\it me}[u]$ ] .        the number of outputs of the program @xmath124 is greater than or equal to the number of the outputs of the program @xmath123 .",
    "hence , by lemma  [ lem : melog ] , we have @xmath371 $ ] .",
    "but , @xmath143\\hspace*{-1.2pt}]}$ ] and @xmath144\\hspace*{-1.2pt}]}$ ] .",
    "this leads to a contradiction .                    for contradiction ,",
    "suppose @xmath111 $ ] is a @xmath21-safety property .",
    "let @xmath8 and @xmath114 be programs having the same input domain such that @xmath385 $ ] .",
    "then , it must be the case that there exist @xmath365\\hspace*{-1.2pt}]}$ ] and @xmath366\\hspace*{-1.2pt}]}$ ] such that @xmath118 , @xmath119 , and @xmath367\\hspace*{-1.2pt } ] } \\wedge t ' \\subseteq { [ \\hspace*{-1.2pt}[m_c']\\hspace*{-1.2pt } ] } \\rightarrow ( m_c ,    m_c ' )",
    "\\not\\in c_{\\it ge}[u]$ ] .",
    "we compare the guessing - entropy - based quantitative information flow of the two programs .",
    "@xmath386(\\bar{m'})-{\\it ge}[u](\\bar{m})\\\\    \\quad=\\frac{|\\mathbb{h}|}{2}-\\frac{1}{2|\\mathbb{h}|}\\sum_{o'\\in m'(\\mathbb{h})}|m'^{-1}(o')|^2\\\\    \\qquad-\\frac{|\\mathbb{h}|}{2}+\\frac{1}{2|\\mathbb{h}|}\\sum_{o\\in m(\\mathbb{h})}|m^{-1}(o)|^2\\\\    \\quad=\\frac{1}{2|\\mathbb{h}|}\\sum_{o\\in m(\\mathbb{h})}|m^{-1}(o)|^2\\\\ \\qquad-\\frac{1}{2|\\mathbb{h}|}\\sum_{o'\\in m'(\\mathbb{h})}|m'^{-1}(o')|^2\\\\    \\quad=\\frac{1}{2|\\mathbb{h}|}(\\sum_{o_x\\in{\\{{o_1,\\dots , o_i}\\}}}|m^{-1}(o_x)|^2\\\\ \\qquad\\qquad+|m^{-1}(o)|^2+|m^{-1}(o_r)|^2)\\\\    \\qquad-\\frac{1}{2|\\mathbb{h}|}(\\sum_{o_x'\\in{\\{{o_1',\\dots , o_j'}\\}}}|m'^{-1}(o_x')|^2\\\\    \\qquad\\qquad+\\sum_{o_y'\\in{\\{{o_{j+1}',\\dots , o_{j+i}'}\\}}}|m'^{-1}(o_y')|^2\\\\ \\qquad\\qquad+|m'^{-1}(o_r')|^2)\\\\ \\end{array}\\ ] ] by lemma  [ lem : gelem ] , we have @xmath387 trivially , we have @xmath388 as a result , we have @xmath389(\\bar{m'})-{\\it ge}[u](\\bar{m})\\ge 0\\ ] ] recall that @xmath123 and @xmath124 have the same counterexamples @xmath141 and @xmath142 , that is , @xmath143\\hspace*{-1.2pt}]}$ ] and @xmath144\\hspace*{-1.2pt}]}$ ] .",
    "however , we have @xmath390 $ ] .",
    "this leads to a contradiction .",
    "[ lem : a5 ] let @xmath176 be distinct boolean variables , @xmath161 be a boolean formula over @xmath176 , and @xmath202 be the number of satisfying assignments for @xmath161 . if @xmath202 is less than @xmath394 , then the number of the outputs of the boolean program @xmath395 defined in figure  [ boolenc ] is equal to @xmath396 .",
    "[ lem : a6 ] let @xmath176 be distinct variables and @xmath161 be a boolean formula over @xmath176 .",
    "then , the number of assignments for @xmath161 can be computed by executing an oracle that decides whether programs are in @xmath110 $ ] at most @xmath196 times .",
    "let @xmath397 where @xmath198 is a formula over @xmath176 having @xmath179 assignments and @xmath177 is a boolean variable such that @xmath398 .",
    "note that by lemma  [ lem : a2 ] , such @xmath198 can be generated in linear time .",
    "then , we invoke the following procedure where @xmath141 is defined in figure  [ boolenc ] .",
    "@xmath399}\\\\ \\qquad\\qquad{\\sf and}\\;(t(b(n)),t(\\phi\\wedge h'))\\in",
    "c_{\\it me}[u])\\\\ \\qquad{\\sf if}\\;(t(\\phi\\wedge h'),t(b(n)))\\in c_{\\it me}[u]\\\\    \\qquad\\qquad{\\sf then}\\;\\{\\ell = n;n=(\\ell+r)/2;\\}\\\\    \\qquad\\qquad{\\sf else}\\;\\{r = n;n=(\\ell+r)/2;\\}\\\\    { \\sf return}\\;n \\end{array}\\ ] ]    note that when the procedure terminates , we have @xmath400(t(b(n))={\\it me}[u](t(\\phi\\wedge h'))$ ] , and so by lemma  [ lem : melog ] and lemma  [ lem : a5 ] , @xmath202 is the number of satisfying assignments to @xmath161 .    we show that the procedure iterates at most @xmath203 times . to see this , note that every iteration in the procedure narrows the range between @xmath204 and @xmath51 by one half .",
    "because @xmath205 is bounded by @xmath206 , it follows that the procedure iterates at most @xmath203 times .",
    "hence , the oracle @xmath110 $ ] is accessed @xmath196 times , and this proves the lemma .",
    "[ lem : gemono ] let @xmath176 and @xmath177 be distinct variables and @xmath161 and @xmath401 be boolean formulas over @xmath176 .",
    "let @xmath402 and @xmath403 .",
    "then , we have @xmath404 iff @xmath81(m)\\le{\\it      ge}[u](m')$ ] .    by the definition , @xmath405(m)&=\\mathcal{g}(h)-\\mathcal{g}(h|o)\\\\    & = \\frac{1}{2}(|{\\overrightarrow{{h}}}|)+\\frac{1}{2}-\\sum_o\\sum_{1\\le i\\le |{\\overrightarrow{{h}}}|}i u(h_i , o)\\\\    & = \\frac{|{\\overrightarrow{{h}}}|}{2}\\\\ & \\quad -\\frac{1}{2|{\\overrightarrow{{h}}}|}(|m^{-1}({\\sf true})|^2+|m^{-1}({\\sf      false})|^2 )",
    "\\end{array}\\ ] ] therefore , @xmath389(m ) \\leq { \\it ge}[u](m')\\ ] ] iff @xmath406 but , trivially , the latter holds iff @xmath407    [ lem : gecomp ] let @xmath176 and @xmath177 be distinct variables and @xmath161 be a boolean formula over @xmath176 . then , the number of assignments for @xmath161 can be computed by executing an oracle that decides whether programs are in @xmath111 $ ] at most @xmath196 times .",
    "let @xmath397 where @xmath198 is a formula over @xmath176 having @xmath179 assignments and @xmath177 is a boolean variable such that @xmath398 .",
    "note that by lemma  [ lem : a2 ] , such @xmath198 can be generated in linear time .",
    "@xmath408}\\\\ \\qquad\\qquad{\\sf and}\\;(o:=b(n),o:=\\phi\\wedge h')\\in",
    "c_{\\it ge}[u])\\\\ \\qquad{\\sf if}\\;(o:=\\phi\\wedge h',o:=b(n))\\in c_{\\it ge}[u]\\\\    \\qquad\\qquad{\\sf then}\\;\\{\\ell = n;n=(\\ell+r)/2;\\}\\\\    \\qquad\\qquad{\\sf else}\\;\\{r = n;n=(\\ell+r)/2;\\}\\\\ { \\sf return}\\;n \\end{array}\\ ] ]      we show that the procedure iterates at most @xmath203 times . to see this , every iteration in the procedure narrows the range between @xmath204 and @xmath51 by one half . because @xmath205 is bounded by @xmath206 , it follows that the procedure iterates at most @xmath203 times .",
    "hence , the oracle @xmath111 $ ] is accessed @xmath196 times , and this proves the lemma .",
    "* @xmath411 + we reduce via self composition  @xcite .",
    "let @xmath8 be a boolean program that we want to know if it is non - interferent .",
    "first , we make a copy of @xmath8 , with each variable @xmath152 in @xmath8 replaced by a fresh ( primed ) variable @xmath412 .",
    "call this copy @xmath114 .",
    "let @xmath413 , where @xmath414 is the boolean formula encoding the conjunction of equalities @xmath415 , @xmath416 ,  , @xmath417 , where @xmath418 are the low security output variables of @xmath8 .",
    "note that @xmath161 can be obtained in time polynomial in the size of @xmath8 . here , instead of the rules in figure  [ wpsemantics ] , we use the optimized weakest precondition generation technique  @xcite that generates a formula quadratic in the size of @xmath419 . then",
    ", @xmath8 is non - interferent if and only if @xmath161 is valid , that is , if and only if @xmath420 is unsatisfiable .",
    "* @xmath421 + let @xmath161 be a formula that we want to know if it is unsatisfiable .",
    "we prove that the following programs is non - interferent iff @xmath161 is unsatisfiable . here , all variables that appear in @xmath161 are high security input variables and @xmath1 is a high security input variable that is distinct from variables appearing in @xmath161 , and @xmath2 is the low security output variable .",
    "@xmath422 trivially , if @xmath161 is unsatisfiable , then this program returns only @xmath151 , that is , this program is non - interferent .",
    "if this program is non - interferent , then this program returns only @xmath423 for any input , or returns only @xmath151 for any input .",
    "however , this program can not return only @xmath424 , because if @xmath425 then @xmath426 .",
    "therefore , this program only returns @xmath151 , when this program is non - interferent .",
    "that means @xmath161 is unsatisfiable when the program is non - interferent .",
    "[ lem : a10 ] let @xmath430 be a set , and @xmath8 and @xmath114 be functions whose domains contain @xmath430 .",
    "suppose that we have @xmath431 , for all @xmath432 in @xmath430 .",
    "then , for all @xmath433 , we have @xmath434 .",
    "[ lem : a12 ] let @xmath1 , @xmath2 , @xmath435 , and @xmath47 be distinct random variables .",
    "let @xmath8 and @xmath114 be programs .",
    "we have @xmath259 iff for any distribution @xmath11 , @xmath436(h|o',l)\\le \\mathcal{h}_\\infty[\\mu](h|o , l)$ ] where @xmath437 and @xmath438 .    * ( @xmath358 ) + suppose @xmath225 .",
    "we have @xmath439(h|o',l)\\le \\mathcal{h}_\\infty[\\mu](h|o , l)\\\\    \\qquad\\textrm { iff } \\mathcal{v}[\\mu](h|o , l)\\le \\mathcal{v}[\\mu](h|o',l ) \\end{array}\\ ] ] by the definition of min entropy , and + @xmath440(h|o , l)\\\\ \\quad=\\sum_{o\\in{\\mathbb o},\\ell\\in{\\mathbb l } } \\mu(o,\\ell)\\max_{h\\in\\mathbb h } \\mu(h|o,\\ell)\\\\ \\quad   = \\sum_{o\\in{\\mathbb o},\\ell\\in{\\mathbb l } } \\mu(o,\\ell ) \\max_{h\\in\\mathbb h } \\frac{\\mu(h , o,\\ell)}{\\mu(o,\\ell)}\\\\ \\quad   = \\sum_{o\\in{\\mathbb o},\\ell\\in{\\mathbb l } } \\max_{h\\in\\mathbb h } \\mu(o,\\ell)\\frac{\\mu(h , o,\\ell)}{\\mu(o,\\ell)}\\\\ \\quad   = \\sum_{o\\in{\\mathbb o},\\ell\\in{\\mathbb l}}\\max_{h\\in\\mathbb h } \\mu(h , o,\\ell)\\\\ \\quad   = \\sum_{o\\in{\\mathbb o},\\ell\\in{\\mathbb l}}\\max_{h\\in { \\{{h'\\mid o = m(h',\\ell)}\\ } } } \\mu(h,\\ell)\\\\ \\end{array}\\ ] ] where @xmath441 $ ] , and @xmath442 and @xmath443 are sample spaces of low - security input and high - security input , respectively .",
    "therefore , it suffices to show that @xmath440(h|o',l)-\\mathcal{v}[\\mu](h|o , l)\\\\    \\quad=\\sum_{o'\\in{\\mathbb o'},\\ell\\in{\\mathbb l}}\\max_{h\\in{\\{{h'\\mid o'=m'(h',\\ell)}\\ } } } \\mu(h,\\ell)\\\\    \\qquad-\\sum_{o\\in\\mathbb o,\\ell\\in{\\mathbb l}}\\max_{h\\in{\\{{h'\\mid o = m(h',\\ell)}\\ } } } \\mu(h,\\ell)\\\\    \\quad\\ge 0 \\end{array}\\ ] ] where @xmath444 $ ] .",
    "+ for any @xmath445 and @xmath66 , there exists @xmath446 such that @xmath447 . because @xmath225 , by lemma  [ lem : a10 ] , we have @xmath448 + therefore , @xmath449 for some @xmath450 . hence , each summand in @xmath451 also appears in @xmath452 . and",
    ", we have the above proposition .",
    "* ( @xmath360 ) + we prove the contraposition .",
    ". then , there exist @xmath453 such that @xmath454 , @xmath455 , @xmath253 , and @xmath272 .",
    "pick a probability distribution @xmath11 such that @xmath456 . then",
    ", we have @xmath440(h|o',l)\\\\ \\quad = \\sum_{o'\\in{\\mathbb o'},\\ell\\in{\\mathbb        l}}\\max_{h\\in{\\{{h'\\mid o'=m(h',\\ell)}\\ } } } \\mu(h,\\ell)\\\\    \\quad= \\frac{1}{2 } \\end{array}\\ ] ] and @xmath440(h|o , l)\\\\ \\quad=\\sum_{o\\in{\\mathbb o},\\ell\\in{\\mathbb        l}}\\max_{h\\in{\\{{h'\\mid o = m(h',\\ell)}\\ } } } \\mu(h,\\ell)\\\\    \\quad=   \\frac{1}{2}+\\frac{1}{2}\\\\    \\quad= 1 \\end{array}\\ ] ] therefore , @xmath436(h|o',l)\\not\\le \\mathcal{h}_\\infty[\\mu](h|o , l)$ ] .",
    "straightforward from lemma  [ lem : a12 ] and the fact that @xmath436(h|l)-\\mathcal{h}_\\infty[\\mu](h|o , l)\\le    \\mathcal{h}_\\infty[\\mu](h|l)-\\mathcal{h}_\\infty[\\mu](h|o',l)$ ] iff @xmath436(h|o , l)\\ge\\mathcal{h}_\\infty[\\mu](h|o',l)$ ] .      * @xmath216 + suppose @xmath458 . by the definition ,",
    "@xmath459(m)=\\\\ \\sum_{\\ell\\in \\mathbb{l},h\\in\\mathbb{h}}in(\\lambda h'.\\mu(h',\\ell),{\\mathbb h},h)\\mu(h,\\ell)\\\\ -\\sum_{o\\in\\mathbb{o},\\ell\\in\\mathbb{l},h\\in\\mathbb{h } } in(\\lambda h'.\\mu(h',o,\\ell),\\mathbb{h},h)\\mu(h , o,\\ell ) \\end{array}\\ ] ] and @xmath460(m')=\\\\ \\sum_{\\ell\\in \\mathbb{l},h\\in\\mathbb{h}}in(\\lambda",
    "h'.\\mu(h',\\ell),{\\mathbb h},h)\\mu(h,\\ell)\\\\ -\\sum_{o'\\in\\mathbb{o'},\\ell\\in\\mathbb{l},h\\in\\mathbb{h } } in(\\lambda h'.\\mu(h',o',\\ell),\\mathbb{h},h)\\mu(h , o',\\ell ) \\end{array}\\ ] ] where @xmath461 $ ] and @xmath462 $ ] .",
    "+ it suffices to show that @xmath463 + let @xmath464 and @xmath66 .",
    "let @xmath465 , and let @xmath466 . because @xmath225 , for any @xmath241 such that @xmath467 , we have @xmath468",
    ". then , by lemma  [ lem : gelem ] , we have @xmath469 where @xmath470 + now we prove each @xmath247 constructed above are disjoint .",
    "that is , for @xmath248 and @xmath249 outputs of @xmath8 such that @xmath250 , @xmath471 . for a contradiction , suppose @xmath252",
    "then , there exist @xmath226 and @xmath227 such that @xmath253 , @xmath254 , @xmath255 , and @xmath256 . since @xmath225 , we have @xmath257 , and it leads to a contradiction .",
    "hence , we have for any @xmath61 , @xmath472 + therefore , it follows that @xmath463 * @xmath221 + we prove the contraposition .",
    ". then , there exist @xmath473 such that * * @xmath474 , @xmath475 , and @xmath476 * * @xmath477 + then , we can pick @xmath11 such that @xmath478 .",
    "we have @xmath79(m)=1.5 - 1=0.5\\ ] ] and @xmath79(m')=1.5 - 1.5=0\\ ] ] therefore ,",
    "we have @xmath479 $ ] .        by theorem  [ thm : reqse ]",
    ", we have @xmath481(m)\\le{\\it se}[\\mu](m')\\ ] ] now , there exists @xmath482 such that @xmath483(m)\\ ] ] therefore , @xmath484(m)\\le{\\it se}[\\mu'](m')\\ ] ] trivially , @xmath484(m')\\le { \\it cc}(m')\\ ] ] therefore , we have the conclusion .",
    "* @xmath485 + we prove by reducing @xmath34 to unsat , which is conp - complete .",
    "we reduce via self composition  @xcite .",
    "let @xmath8 and @xmath114 be boolean programs that we want to know if they are in @xmath34 .",
    "first , we make copies of @xmath8 and @xmath114 , with all variables in @xmath8 and @xmath114 replaced by fresh ( primed ) variables .",
    "call these copies @xmath486 and @xmath487 .",
    "let @xmath488 where @xmath393,@xmath489,@xmath490 , and @xmath491 are the low security outputs of @xmath8,@xmath486,@xmath114 , and @xmath487 , respectively .",
    "note that @xmath161 can be obtained in time polynomial in the size of @xmath8 and @xmath114 . here , like in theorem  [ thm : nicomp ] , we use the optimized weakest precondition generation technique  @xcite to generate a formula quadratic in the size of @xmath492 . then , @xmath259 if and only if @xmath161 is valid , that is , if and only if @xmath420 is unsatisfiable . * @xmath493 + we prove by reducing ni to @xmath34 , because ni is conp - complete by theorem  [ thm : nicomp ] .",
    "we can check the non - interference of @xmath8 by solving @xmath225 where @xmath114 is non - interferent and have the same input domain as @xmath8 by theorem  [ thm : rni ] . note that such @xmath114 can be constructed in polynomial time .",
    "therefore , we have @xmath493 ."
  ],
  "abstract_text": [
    "<S> researchers have proposed formal definitions of quantitative information flow based on information theoretic notions such as the shannon entropy , the min entropy , the guessing entropy , and channel capacity . </S>",
    "<S> this paper investigates the hardness and possibilities of precisely checking and inferring quantitative information flow according to such definitions .    </S>",
    "<S> we prove that , even for just comparing two programs on which has the larger flow , none of the definitions is a k - safety property for any k , and therefore is not amenable to the self - composition technique that has been successfully applied to precisely checking non - interference . </S>",
    "<S> we also show a complexity theoretic gap with non - interference by proving that , for loop - free boolean programs whose non - interference is conp - complete , the comparison problem is # p - hard for all of the definitions .    for positive results , we show that universally quantifying the distribution in the comparison problem , that is , comparing two programs according to the entropy based definitions on which has the larger flow for all distributions , is a 2-safety problem in general and is conp - complete when restricted for loop - free boolean programs . </S>",
    "<S> we prove this by showing that the problem is equivalent to a simple relation naturally expressing the fact that one program is more secure than the other . </S>",
    "<S> we prove that the relation also refines the channel - capacity based definition , and that it can be precisely checked via the self - composition as well as the `` interleaved '' self - composition technique . </S>"
  ]
}