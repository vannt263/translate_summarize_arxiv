{
  "article_text": [
    "it has long been the goal of mathematicians to minimize the set of assumptions and axioms in their systems .",
    "implementers of theorem provers use this principle : they use a logic with as few inference rules as possible , and prove lemmas outside the core logic in preference to adding new inference rules . in applications of logic to computer security  such as _ proof - carrying code _",
    "@xcite and distributed authentication frameworks @xcite  the implementation of the core logic is inside the trusted code base ( tcb ) , while proofs need not be in the tcb because they can be checked .",
    "two aspects of the core logic are in the tcb : a set of logical connectives and inference rules , and a program in some underlying programming language that implements proof checking  that is , interpreting the inference rules and matching them against a theorem and its proof .",
    "definitions and lemmas are essential in constructing proofs of reasonable size and clarity .",
    "a proof system should have machinery for checking lemmas , and applying lemmas and definitions , in the checking of proofs .",
    "this machinery also is within the tcb ; see figure  [ lemmamach ] .",
    "[ lemmamach ]    many theorem provers support definitions and lemmas and provide a variety of advanced features designed to help with tasks such as organizing definitions and lemmas into libraries , keeping track of dependencies , and providing modularization ; in our work we are particularly concerned with separating that part of the machinery necessary for proof checking ( i.e. , in the tcb ) from the programming - environment support that is used in proof development .",
    "this separation was particularly important for a proof - carrying code system we built initially in @xmath0prolog  @xcite . in this paper",
    "we will demonstrate a definition / lemma implementation that is about three dozen lines of code .",
    "the @xmath0prolog language @xcite has several features that allow concise and clean implementation of logics , proof checkers , and theorem provers @xcite . in a previous paper  @xcite",
    ", we presented a lemma and definition mechanism implemented in @xmath0prolog . in this paper , we extend that work and describe it more fully .",
    "we present the lemma mechanism and a generalization of our definition mechanism , again implemented in @xmath0prolog .",
    "since we now have more experience using the twelf system  @xcite , we include a detailed comparison of the twelf and @xmath0prolog  versions of the encoding of our logic , lemmas , and definitions .",
    "an important purpose of this paper is to show which language features allow a small tcb and efficient representation of proofs . we also give a comparison of programming issues that are important to our proof - carrying code application .",
    "although the lemma and definition mechanism is general , we illustrate it using an implementation of higher - order logic .",
    "we call this logic the _ object logic _ to distinguish it from the _ metalogic _ implemented by @xmath0prolog or twelf .",
    "our object logic is not polymorphic , but our lemma and definition mechanisms are polymorphic in the sense that they can express properties that hold at any type of the object logic .",
    "the symmetry of equality , for example , is one such lemma we will encounter .",
    "the @xmath0prolog version of the clauses we present use the syntax of the terzo implementation  @xcite .",
    "we also discuss the teyjus implementation  @xcite and compare the two for our purposes .",
    "terzo is interpreted and provides more flexibility , but teyjus has a compiler in which our code runs much more efficiently .",
    "@xmath0prolog  is a higher - order logic programming language which extends prolog in essentially two ways .",
    "first , it replaces first - order terms with the more expressive simply - typed @xmath0-terms ; @xmath0prologimplementations generally extend simple types to include ml - style prenex polymorphism @xcite .",
    "second , it permits implication and universal quantification ( over objects of any type ) in goal formulas .",
    "we introduce types and constants using ` kind ` and ` type ` declarations , respectively .",
    "for example , a new primitive type @xmath1 and a new constant @xmath2 of type @xmath3 are declared as follows .",
    ".... kind    t        type .",
    "type    f        t - > t - > t. ....    capital letters in type declarations denote type variables and are used in polymorphic types . in program goals and clauses , @xmath0-abstraction is written using backslash 134 as an infix operator .",
    "capitalized tokens not bound by @xmath0-abstraction denote free variables .",
    "all other unbound tokens denote constants .",
    "universal quantification is written using the constant pi in conjunction with a @xmath0-abstraction ( e.g. , ` pi x134 ` represents universal quantification over variable x ) .",
    "the symbols _ comma _ and = > represent conjunction and implication .",
    "the symbol : - denotes the converse of = > and is used to write the top - level implication in clauses .",
    "the type ` o ` is the type of clauses and goals of @xmath0prolog . we usually omit universal quantifiers at the top level in definite clauses , and assume implicit quantification over all free variables .",
    "we will encode a natural deduction proof system for our higher - order object logic .",
    "( in our earlier work  @xcite , we implemented a sequent calculus version . )",
    "we implement a proof checker for this logic that is similar to the one described by felty  @xcite .",
    "program  [ core - types ] contains the type declarations used in our encoding .    ....",
    "kind   tp               type .",
    "kind   tm               type .",
    "kind   pf               type .",
    "type   form             tp .",
    "type   intty            tp .",
    "type   arrow            tp - > tp - > tp .",
    "infixr   arrow    8 .",
    "type   pair             tp - > tp - > tp .",
    "type   eq               tp - > tm - > tm - > tm .",
    "type   imp",
    "tm - > tm - > tm .",
    "infixr   imp      7 .",
    "type   forall           tp - > ( tm - > tm ) -",
    "> tm . type   false            tm .",
    "type   lam              ( tm - > tm ) -",
    "> tm . type   app              tp - > tm - > tm - > tm .",
    "type   mkpair           tm - > tm - > tm .",
    "type   fst              tp - > tm - > tm .",
    "type   snd              tp - > tm - > tm .",
    "type   hastype          tm - > tp - > o. type   proves           pf - > tm - > o. type   assump           o - > o.    type   refl             pf .",
    "type   beta             pf .",
    "type   fstpair          pf .",
    "type   sndpair          pf .",
    "type   surjpair         pf .",
    "type   congr            tp - > tm - > tm - > ( tm - > tm ) - > pf - > pf - > pf .",
    "type   imp_i            ( pf - > pf ) - > pf .",
    "type   imp_e            tm - > pf - > pf - > pf .",
    "type   forall_i         ( tm - > pf ) - > pf .",
    "type   forall_e         tp - > ( tm - > tm ) - > pf - > tm - > pf . ....    [ core - types ]    we introduce three primitive types : ` tp ` for object - level types , ` tm ` for object - level terms ( including formulas ) and ` pf ` for proofs in the object logic .",
    "we introduce constants for the object - level type constructors .",
    "the main type constructor for our object language is the ` arrow ` constructor taking two types as arguments .",
    "we also include objects of type ` tp ` to represent base types , such as ` form ` and ` intty ` .",
    "to represent formulas , we introduce constants such as ` imp ` to represent implication in the object logic , and ` eq ` which takes two terms and a type and is used to represent equality at any type .",
    "we use infix notation for the type arrow and binary logical connectives .",
    "the binding strength of each infix operator is declared using an ` infix ` declaration .",
    "the constant ` forall ` represents universal quantification .",
    "it takes a type representing the type of the bound variable and a functional argument , which allows object - level binding of variables by quantifiers to be defined in terms of meta - level @xmath0-abstraction .",
    "an example of its use is the following formula , which expresses the commutativity of equality for integers :    .... forall intty ( x\\ forall intty ( y\\ ( eq intty x y ) imp ( eq intty y x ) ) ) .",
    "....    the parser uses the usual rule for the syntactic extent of a lambda , so this expression is equivalent to    .... forall intty x\\ forall intty y\\ eq intty x y imp eq intty y x. ....",
    "this use of higher - order data structures is called _ higher - order abstract syntax _  @xcite ; with it , we do nt need to describe the mechanics of substitution explicitly in the object logic @xcite .    to represent terms",
    ", we introduce the ` app ` and ` lam ` constants for application and abstraction , as well as constants for pairing and projections .",
    "the ` app ` constructor takes three arguments .",
    "the second argument is a term of functional type and the third argument is the term it is applied to .",
    "the first argument is the type of the argument to the function .",
    "the ` lam ` constant has a type , which like ` forall ` , uses meta - level abstraction to represent object - level binding .",
    "the constants at the end of program  [ core - types ] are used to build terms representing proofs .",
    "we call these constants as well as any other terms whose type ends in `` ` - > pf ` '' _ proof constructors_.    programs  [ core - types ] and  [ core - rules ] together implement a full proof checker for our object logic",
    ".    .... hastype ( eq t x y ) form : - hastype x t , hastype y t. hastype ( a imp b ) form : - hastype a form , hastype b form .",
    "hastype ( forall t a ) form : - pi x\\ ( hastype x t = > hastype ( a x ) form ) .",
    "hastype false form .",
    "hastype ( lam f ) ( t1 arrow t2 ) : - pi x\\ ( hastype x t1 = > hastype ( f x ) t2 ) . hastype ( app t1 f x ) t2 : - hastype f ( t1 arrow t2 ) , hastype x t1 .",
    "hastype ( mkpair x y ) ( pair t1 t2 ) : - hastype x t1 , hastype y t2 .",
    "hastype ( fst t2 x ) t1 : - hastype x ( pair t1 t2 ) .",
    "hastype ( snd t1 x ) t2 : - hastype x ( pair t1 t2 )",
    ".    proves q a : - assump ( proves q a ) .",
    "proves refl ( eq t x x ) . proves beta ( eq t2 ( app t1 ( lam f ) x ) ( f x ) ) .",
    "proves fstpair ( eq t1 ( fst t2 ( mkpair x y ) ) x ) .",
    "proves sndpair ( eq t2 ( snd t1 ( mkpair x y ) ) y ) . proves surjpair ( eq ( pair t1 t2 ) ( mkpair ( fst t2 z ) ( snd t1 z ) ) z ) . proves ( congr t x z h p1",
    "p2 ) ( h x ) : -     hastype",
    "x t , hastype z t ,    proves p1 ( eq t x z ) , proves p2 ( h z ) .",
    "proves ( imp_i q ) ( a imp b ) : -    pi p\\ ( assump ( proves p a ) = > proves ( q p ) b )",
    ". proves ( imp_e a q1 q2 ) b : -    hastype a form , proves q1 ( a imp b ) , proves q2 a. proves ( forall_i q ) ( forall t a ) : -    pi y\\ ( hastype y t = > proves ( q y ) ( a y ) )",
    ". proves ( forall_e t a q x ) ( a x ) : -     pi x\\ ( hastype x t = > hastype ( a x ) form ) ,    hastype x t ,    proves q ( forall t a ) . ....",
    "[ core - rules ]    program  [ core - rules ] implements both typechecking and inference rules .",
    "the last four clauses of program  [ core - rules ] implement the introduction and elimination rules for implication and universal quantification , which are given in figure  [ core - inf ] .",
    "[ core - inf ]    we do not include inference rules for the other logical connectives . instead , we define them in terms of existing connectives using our definition mechanism described later .",
    "the remaining clauses for the ` proves ` predicate implement inference rules for equality .",
    "typechecking for terms is implemented by the ` hastype ` clauses .",
    "proof checking is implemented by the ` proves ` clauses .",
    "a goal of the form ` ( proves p a ) ` should be run only after ` a ` is typechecked , i.e. , a proper check has the form ` ( hastype a form , proves p a ) ` .    to implement the discharge of assumptions in the implication introduction rule , we use implication and universal quantification in @xmath0prolog goals .",
    "the goal ` ( d = > g ) ` adds clause ` d ` to the @xmath0prolog clause database , attempts to solve ` g ` , and then ( upon either the success or failure of ` g ` ) removes ` d ` from the clause database .",
    "the goal ` ( pi y134(g y ) ) ` introduces a new constant ` c ` with the same type as ` y ` , replaces ` y ` with ` c ` , and attempts to solve the goal ` ( g c ) ` .",
    "for example , consider the goal    .... proves ( imp_i q\\q ) ( a imp a ) ....    where ` a ` is a propositional constant ( a constant of type ` form ` ) ; then @xmath0prolog will execute the ( instantiated ) body of the ` imp_i ` clause    .... pi p\\ ( assump ( proves p a ) = > proves ( ( q\\q ) p ) a ) ....    this generates a new constant ` c ` , and adds ` ( assump ( proves c a ) ` to the database ; then the subgoal ` ( proves ( ( q134q ) c ) a ) ` , which is @xmath4-equivalent to ` ( proves c a ) ` , matches the first clause for the ` proves ` predicate .",
    "the subgoal ` ( assump ( proves c a ) ) ` is generated and this goal matches our dynamically added clause .",
    "we have chosen to use the ` assump ` predicate for adding atomic clauses to the program .",
    "this is not necessary , but we find it useful to distinguish between adding atomic clauses and adding non - atomic clauses , which we will see later .",
    "note that the typechecking clauses for ` forall ` and ` lam ` use meta - level implication and universal quantification in a manner similar to the ` proves ` clause for the @xmath5-i rule .",
    "it is important to show that our encoding of higher - order logic in @xmath0prolog  is _",
    "adequate_. to do so , we must show that a formula has a natural deduction proof if and only if its representation as a term has an associated proof term that can be checked using the inference rules of program  [ core - rules ] .",
    "the encoding we use is similar to the encoding of higher - order logic in the logical framework  @xcite and the proof of adequacy of our encoding is similar to the one discussed there .",
    "the main difference between the two encodings is the types of the logical connectives .",
    "for example , in their encoding , ` imp ` is given type ` tm ` and the fact that it is a connective which takes two formulas as arguments is expressed using object level types ; the ` hastype ` clause is    .... hastype imp ( form arrow form arrow form ) .",
    "....    an implication must then be expressed using the ` app ` constructor , e.g. , ` ( app ( app imp a ) b ) ` .",
    "we found that this encoding of the connectives quickly became cumbersome and our encoding was more readable . on the other hand ,",
    "our encoding is not as economical as the one we used previously  @xcite .",
    "there we represented object - level types as meta - level types , which allowed us to eliminate all the ` hastype ` clauses and subgoals .",
    "the types of our object logic , however , did not match up well with the types of @xmath0prolog , which forced certain limitations in the implementation of our proof - carrying code system .",
    "( see appel and felty  @xcite for further analysis . )",
    "the encoding in the current paper seems to be the best compromise .",
    "in mathematics the use of lemmas can make a proof more readable by structuring the proof , especially when the lemma corresponds to some intuitive property . for automated proof checking ( in contrast to automated or traditional theorem proving )",
    "this use of lemmas is not essential , because the computer does nt need to understand the proof in order to check it . but",
    "lemmas can also reduce the _",
    "size _ of a proof ( and therefore the time required for proof checking ) : when a lemma is used multiple times it acts as a kind of `` subroutine . ''",
    "this is particularly important in applications like proof - carrying code where proofs are transmitted over networks to clients who check them .",
    "we first present an example which we use to illustrate our lemma mechanism in @xmath0prolog  ( section  [ lemmasexample ] ) , and then present this mechanism as we d implement it in terzo ( section  [ lemmasterzo ] ) .",
    "we then explain the modifications required to meet the extra restrictions imposed by teyjus ( section  [ lemmasteyjus ] ) .",
    "we end this section with some optimizations that are important for keeping proofs that use lemmas as small as possible ( section  [ lemmasopt ] ) and then with some more examples ( section  [ lemmasmore ] ) .      theorem  [ thm : simple ] shows the use of our core logic to express a simple proof checking goal .",
    ".... proves    ( forall_i i\\ ( forall_i j\\ ( imp_i q\\      ( congr intty i j ( eq intty j ) q refl ) ) ) )    ( forall intty i\\ forall intty j\\ ( eq intty",
    "i j imp eq intty j i ) )",
    ". ....    [ thm : simple ]    the proof of this lemma uses the @xmath6-i rule as well as congruence and reflexivity of equality .",
    "its proof can be checked as a successful @xmath0prolog query to our core logic in programs  [ core - types ] and [ core - rules ] .",
    "alternatively , we may want to prove it using the following general lemma about symmetry of equality at any type .",
    "@xmath7 the proof of this lemma can be checked as the following @xmath0prolog query .    ....",
    "pi t\\ pi a\\ pi b\\ pi p\\    ( hastype a t , hastype b t , proves p ( eq t b a ) ) = >       proves ( congr t b a ( eq t a ) p refl ) ( eq t a b ) . ....",
    "this query introduces an arbitrary ` p ` , adds the typing clauses ` ( hastype a t ) ` and ` ( hastype b t ) ` , and the assumption ` ( proves p ( eq t b a ) ) ` to the set of clauses , then checks the proof of congruence using these facts .",
    "the syntax @xmath8 ` = > ` @xmath9 means exactly the same as @xmath9 ` : - ` @xmath8 , so we could just as well write this query as    .... pi t\\ pi a\\",
    "pi b\\ pi p\\    ( proves ( congr t b a ( eq t a ) p refl ) ( eq t a b ) : -       hastype a t , hastype b t , proves p ( eq t b a ) ) . ....    now , suppose we abstract the proof ( roughly , ` congr t b a ( eq t a ) p refl ` ) from this query .    ....",
    "( inference = ( pcon\\ pi t\\ pi a\\ pi b\\ pi p\\                  proves ( pcon t a b p ) ( eq t a b ) : -                   hastype a t , hastype b t , proves p ( eq t b a ) ) ,   proof = ( t\\a\\b\\p\\ congr t b a ( eq t a ) p refl ) ,   query = ( inference proof ) ,   query ) . ....",
    "the solution of this query proceeds in four steps : the variable ` inference ` is unified with a @xmath0-term ; ` proof ` is unified with a @xmath0-term ; ` query ` is unified with the application of ` inference ` to ` proof ` ( which is a term @xmath4-equivalent to the query of the previous paragraph ) , and finally ` query ` is solved as a goal ( checking the proof of the lemma ) .",
    "once we know that the lemma is valid , we can make a new @xmath0prolog atom ` symm ` to stand for its proof , and we can prove some other theorem in a context where the clause ` ( inference symm ) ` is in the clause database ; remember that ` ( inference symm ) ` is @xmath4-equivalent to    .... pi t\\ pi a\\ pi",
    "b\\ pi p\\   ( proves ( symm t a b p ) ( eq t a b ) : -     hastype a t , hastype b t , proves p ( eq t b a ) ) . ....    this series of transformations starting with a proof checking subgoal has led us to a clause that looks remarkably like an inference rule . with this clause in the database , we can use the new proof constructor ` symm ` just as if it were primitive . instead of adding new clauses like this to our proof checker , which would increase the size of our tcb ,",
    "we show how to put such lemmas inside proofs .      in the example in the previous section , `",
    "symm ` is a new constant , but when lemmas are proved and put inside proofs dynamically , we can instead `` make a new atom '' by simply ` pi`-binding it .",
    "this leads to the recipe for lemmas shown in program  [ lemmafig ] , which is the heart of our lemma mechanism .    ....",
    "type   lemma_pf   ( a - > o ) - > a - > ( a - > pf ) - > pf .",
    "proves ( lemma_pf inference lemmaproof restproof ) c : -   inference lemmaproof ,   pi name\\ ( ( inference name ) = > ( proves ( restproof name ) c ) ) .",
    "....    [ lemmafig ]    ( we will improve it slightly in the next section . ) this program introduces a constructor ` lemma_pf ` for storing lemmas in proofs .",
    "this constructor takes three arguments : ( 1 ) a derived inference rule ` inference ` ( of type ` a - > o ` ) parameterized by a proof constructor ( of type ` a ` ) , ( 2 ) a term ` lemmaproof ` of type ` a ` representing a proof of the lemma built from core - logic proof constructors ( or using other lemmas ) , and ( 3 ) a proof of the main theorem ` restproof ` that is parameterized by a proof constructor ( of type ` a ` ) .",
    "operationally , this clause first executes ` ( inference lemmaproof ) ` as a query , to check the proof of the lemma itself ; then it ` pi`-binds ` name ` in the lemma , adds it as a new clause , and runs ` restproof ` ( which is parameterized on the lemma proof constructor ) applied to ` name ` .",
    "the terms ` inference ` and ` proof ` from the example in section  [ lemmasexample ] illustrate the form of the terms which will appear as the first two arguments to ` lemma_pf ` .",
    "theorem  [ thm : symm ] illustrates the use of ` lemma_pf ` in an example ; this theorem is a modification of theorem  [ thm : simple ] that uses the ` symm ` lemma .",
    ".... proves ( lemma_pf    ( symm\\ pi t\\ pi a\\ pi b\\ pi p\\      proves ( symm t a b p ) ( eq t a b ) : -          hastype a t , hastype b t , proves p ( eq t b a ) )    ( t\\a\\b\\p\\ ( congr t b a ( eq t a ) p refl ) )    ( symm\\ ( forall_i i\\ ( forall_i j\\ ( imp_i q\\ ( symm intty j i q ) ) ) ) ) ) ( forall intty i\\ forall intty j\\ ( eq intty i j imp eq intty j i ) ) . ....    [ thm : symm ]      if we restrict ourselves to the terzo implementation of @xmath0prolog , then meta - level formulas can occur inside proofs using any of the @xmath0prolog connectives .",
    "but if we want to be able to use teyjus as well , we must make one more change .",
    "the teyjus system does not allow ` = > ` or ` : - ` to appear in arguments of predicates .",
    "thus the term    ....    ( symm\\ pi t\\ pi a\\ pi b\\ pi p\\      proves ( symm t a b p ) ( eq t a b ) : -          hastype a t , hastype b t , proves p ( eq t b a ) ) ....    occurring in the ` symm ` lemma in theorem  [ thm : symm ] can not appear directly as the first argument to ` lemma_pf ` .",
    "teyjus also does not allow variables to appear at the head of the left of an implication .",
    "these restrictions come from the theory underlying @xmath0prolog  @xcite ; without the latter one , a runtime check is needed to insure that every dynamically created goal is an acceptable one .",
    "we can avoid putting ` : - ` inside arguments of predicates by writing the above term as    ....    ( symm\\ pi t\\ pi a\\ pi b\\ pi p\\      proves ( symm t a b p ) ( eq t a b )",
    "< < = =          hastype a t , hastype b t , proves p ( eq t b a ) ) ....    where ` < < = = ` is a new infix operator of type ` o - > o ` .",
    "but this , in turn , means that the subgoal ` ( inference lemmaproof ) ` of the ` lemma_pf ` clause in program  [ lemmafig ] will no longer check the lemma , since ` <",
    "< = = ` has no operational meaning .",
    "to handle such goals , we add the three constants declared at the beginning of program  [ cinterp ] , which introduce both forward and backward implication arrows , and a new atomic predicate ` cl ` of type ` o - > o ` , and we introduce the two clauses that follow these declarations to interpret our new arrows as @xmath0prolog implication .",
    ".... type   = = > >             o - > o - > o.               infixr   = = > >",
    "type   < < = =             o - > o - > o.               infixl   < < = =     0 .",
    "type   cl               o - > o.    ( d = = > > g ) : - ( cl d ) = > g. ( g < < = = d ) : - ( cl d ) = > g.    type   backchain     o - > o - > o.    proves p a : - cl cl , backchain ( proves p a ) cl .",
    "hastype x t : - cl cl , backchain ( hastype x t ) cl .",
    "assump g : - cl cl , backchain ( assump g ) cl .",
    "backchain g g. backchain g ( pi d ) : - backchain g ( d x ) .",
    "( a , b ) : -   backchain g a ; backchain g b. backchain g ( h < < = = g1 ) : -   backchain g h , g1 .",
    "backchain g ( g1 = = > >",
    "h ) : -   backchain g h , g1 .",
    "....    [ cinterp ]    note that although it would have been more direct , we did not add :    .... ( d = = > > g ) : - d = > g. ....    because of the teyjus restriction mentioned above that variables can not appear at the head of the left of an implication .",
    "the use of the ` cl ` `` wrapper '' solves the problem created by this restriction , but requires us to implement an interpreter to handle clauses of the form ` ( cl a ) ` .",
    "the remaining clauses in program  [ cinterp ] implement this interpreter .    since the type of ` ( inference proof ) ` is ` o ` , the term ` inference ` might conceivably contain subterms which are @xmath0prologclauses . of course , in teyjus these clauses will not contain ` : - ` or ` = > ` , but they may contain ` < < = = ` and ` = = > > ` , which get interpreted via the clauses of program  [ cinterp ] .",
    "they could also , for example , contain any other @xmath0prolog  code including input / output operations . executing ` ( inference proof ) ` can not lead to unsoundness  if the resulting proof checks , it is still valid .",
    "but there are some contexts where we wish to restrict the kind of program that can occur inside a proof and be run when the proof is checked . for example , in a proof - carrying - code system , the code consumer might not want proof checking to cause @xmath0prolog to execute code that accesses private local resources .    to limit the kind and amount of execution possible in the executable part of a lemma , we introduce the ` valid_clause ` predicate of type ` o - > o ` ( program  [ validclause ] ) .",
    ".... valid_clause ( pi c ) : -      pi x\\ valid_clause ( c x ) .",
    "valid_clause ( a , b ) : -       valid_clause a , valid_clause b. valid_clause ( a < < = = b ) : - valid_clause a , valid_clause b. valid_clause ( a = = > > b ) : - valid_clause a , valid_clause b. valid_clause ( proves q a ) .",
    "valid_clause ( hastype x t ) .",
    "valid_clause ( assump ( proves q a ) ) .",
    "....    [ validclause ]    a clause is valid if it contains ` pi ` , _ comma _ , `",
    "< < = = ` , ` = = > > ` , ` proves ` , ` hastype ` , ` assump ` , and nothing else .",
    "of course , a ` proves ` or ` assump ` clause contains subexpressions of type ` pf ` and ` tm ` , and a ` hastype ` clause has subexpressions of type ` tm ` and ` tp ` , so all the constants in proofs , terms , and types of our object logic are also permitted .",
    "absent from this list are @xmath0prolog input / output ( such as ` print ` ) and the semicolon ( backtracking search ) .",
    "the ` valid_clause ` restriction is the reason that we only need new clauses for the ` proves ` , ` hastype ` , and ` assump ` predicates in program  [ cinterp ] .",
    "we must add at least these three because they are used for checking nodes in a proof that require using the clauses added dynamically via the ` cl ` predicate . including no other predicates in the ` valid_clause ` definition guarantees that we need no other new clauses with ` cl ` subgoals .",
    "because of the introduction of `",
    "< < = = ` , ` = = > > ` , and ` valid_clause ` , we modify the clause in program  [ lemmafig ] for checking lemmas . the new clause is shown in program  [ teyjuslemmafig ] .",
    ".... proves ( lemma_pf inference lemmaproof restproof ) c : -   pi name\\ ( valid_clause ( inference name ) ) ,   inference lemmaproof ,   pi name\\ ( cl ( inference name ) = > ( proves ( restproof name ) c ) ) . ....",
    "[ teyjuslemmafig ]    the first subgoal is new ; it ` pi`-binds ` name ` and checks to see if the new lemma applied to ` name ` is valid .",
    "the only other modification is in the last subgoal , which adds the lemma as a new clause via the ` cl ` predicate . since all lemmas will be added via ` cl ` , the only way to use them is via the ` proves ` clause in program  [ cinterp ] . using that clause , the ` ( cl cl ) ` subgoal looks up the lemmas that have been added , one at a time , and tries them out via the ` backchain ` predicate .",
    "this predicate processes the clauses in a manner similar to the @xmath0prolog language itself . in terzo , using this interpreter is less efficient than the direct implementation in program  [ lemmafig ] . in teyjus , the interpreter is required , but when compiled , the code runs faster than either terzo version .    in summary , our technique allows lemmas to be contained _ within _ the proof . we do not need to install new `` global '' lemmas into the proof checker .",
    "the dynamic scoping also means that the lemmas of one proof can not interfere with the lemmas of another , even if they have the same names .",
    "this machinery uses several interesting features of @xmath0prolog :    [ [ polymorphism . ] ] polymorphism .",
    "+ + + + + + + + + + + + +    the type of the ` lemma_pf ` constructor uses polymorphism to indicate that proof constructors introduced for lemmas can have different types .    [",
    "[ meta - level - formulas - as - terms . ] ] meta - level formulas as terms .",
    "+ + + + + + + + + + + + + + + + + + + + + + + + + + + + +    lemmas such as symmetry of equality occur inside proofs as an argument to the ` lemma_pf ` constructor in the following form .    ....",
    "( symm\\ pi t\\ pi a\\ pi b\\ pi p\\      proves ( symm t a b p ) ( eq t a b ) < < = =          hastype a t , hastype b t , proves p ( eq t b a ) ) ....    it is just a data structure ( parameterized by ` symm ` ) ; it does not `` execute '' anything , in spite of the fact that it contains the @xmath0prolog quantifier ` pi ` and our new connective ` < < = = ` .",
    "this gives us the freedom to write lemmas using syntax very similar to that used for writing primitive inference rules .",
    "handling the new constants for `",
    "< < = = ` and ` = = > > ` is easy enough operationally .",
    "however , it is an inconvenience for the user , who must use different syntax in lemmas than in inference rules .",
    "this inconvenience is avoided in terzo .",
    "[ [ dynamically - constructed - goals . ] ] dynamically constructed goals .",
    "+ + + + + + + + + + + + + + + + + + + + + + + + + + + + + +    when the clause from program  [ teyjuslemmafig ] for the ` lemma_pf ` proof constructor checks the proof of a lemma by executing the goal ` ( inference lemmaproof ) ` , we are executing a goal that is built from a run - time - constructed data structure . `",
    "inference ` will be instantiated with terms such as the one above representing the symmetry lemma .",
    "it is only when such a term is applied to its proof and thus appears in `` goal position '' that it becomes the current subgoal on the execution stack .",
    "[ [ dynamically - constructed - clauses . ] ] dynamically constructed clauses .",
    "+ + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + +    when , having successfully checked the proof of a lemma , the ` lemma_pf ` clause executes    .... cl ( inference name ) = > ( proves ( restproof name ) c ) ....    it is adding a dynamically constructed clause to the @xmath0prolog database .",
    "although it is not the case for terzo or teyjus , if a metalanguage were to prohibit all terms having ` o ` in their types as arguments to a predicate , it would still be possible to implement lemmas using our approach .",
    "appendix  [ dynamic ] illustrates by showing an interpreter which extends program  [ cinterp ] to handle this extra restriction .",
    "new constants must be introduced not only for implication but also for every meta - level connective .",
    "note that when meta - level formulas are not allowed , there is no possibility for dynamically created goals or clauses .",
    "twelf for example , does not allow meta - level formulas as terms and is also not polymorphic , and thus the approach described in this section can not be used , but the approach of appendix  [ dynamic ] could . instead , as we will see in section  [ sec",
    ": twelf ] , twelf provides alternative features which we can use to implement lemmas .",
    "the ` symm ` proof constructor in theorem  [ thm : symm ] is a bit unwieldy , since it requires ` t ` , ` a ` , and ` b ` as arguments .",
    "we can imagine writing a primitive inference rule    .... proves ( symm p ) ( eq t a b ) : -    hastype a t , hastype b t , p proves ( eq t b a ) .",
    "....    using the principle that the proof checker does nt need to be told ` t ` , ` a ` , and ` b ` inside the proof term , since they can be found in the formula to be checked .",
    "then , in theorem  [ thm : symm ] , ` ( symm intty j i q ) ` would be ` ( symm q ) ` .    therefore we add three new proof constructors`elam ` , ` extract ` , and ` extractgoal`as shown in program  [ elam ] .",
    ".... type   elam             ( a - > pf ) - > pf .",
    "type   extract          tm - > pf - > pf .",
    "type   extractgoal      o - > pf - > pf .",
    "proves ( elam q ) a : - proves ( q b ) a. proves ( extract a p ) a : - proves p a. proves ( extractgoal g p ) a : - valid_clause g , g , proves p a. ....    [ elam ]    these can be used in the following stereotyped way to extract components of the formula to be proved .",
    "first bind variables with ` elam ` , then match the target formula with ` extract ` .",
    "theorem  [ thm : symma ] is a modification of theorem  [ thm : symm ] that makes use of these constructors .    .... proves ( lemma_pf    ( symm\\ pi t\\ pi a\\ pi b\\ pi p\\      proves ( symm p )",
    "( eq t a b )",
    "< < = =           hastype a t , hastype b t , proves p ( eq t b a ) )    ( p\\ elam t\\ elam a\\ elam b\\      ( extract ( eq t a b ) ( congr t b a ( eq t a ) p refl ) ) )    ( symm\\ ( forall_i i\\ ( forall_i j\\ ( imp_i q\\ ( symm q ) ) ) ) ) ) ( forall intty i\\ forall intty j\\ ( eq intty i j imp eq intty j i ) ) .",
    "....    [ thm : symma ]    note that we could eliminate the ` hastype ` subgoals from our new version of the ` symm ` lemma because we know them to be redundant as long as ` ( eq t a b ) ` was already typechecked .",
    "the reason for keeping them is that the second subgoal of the clause in program  [ teyjuslemmafig ] would fail without them ; the proof checking of the lemma requires these ` hastype ` assumptions . in encoding our core logic ,",
    "it was possible to eliminate all such redundant subgoals .",
    "the fact that such a shortcut is not possible in lemmas causes a tradeoff ; by keeping such lemmas out of the tcb and putting them in proofs , we are forcing the proof checker to do more work .",
    "there seems to be no easy way to avoid this redundant work , though some ad - hoc optimizations to proof checking might be possible .",
    "the ` extractgoal ` proof constructor asks the checker to run @xmath0prolog code to help construct the proof .",
    "its implementation uses ` valid_clause ` to restrict what kinds of @xmath0prolog code can be run .",
    "note , however , that ` valid_clause ` does not always eliminate code that loops and so its current implementation can not guarantee termination .",
    "a stricter ` valid_clause ` would be necessary to achieve this .",
    "the ` extractgoal ` proof constructor was useful for handling assumptions in the sequent calculus version of our object logic  @xcite ; for natural deduction , the same need does not arise in the implementation of our core logic , but ` extractgoal ` is useful for implementing more complex lemmas .",
    "although we have not done so , it would be interesting to further explore the possibility of creating more compact proofs by leaving out information that can be computed easily via code given as arguments to ` extractgoal ` .      as another example of the use of lemmas , we can of course use one lemma in the proof of another , as shown by theorem  [ thm : symmtrans ] .",
    ".... proves ( lemma_pf    ( symm\\ pi t\\ pi a\\ pi b\\ pi p\\      proves ( symm p ) ( eq t a b ) < < = =           hastype a t , hastype b t , proves p ( eq t b a ) )    ( p\\ elam t\\ elam a\\ elam b\\      ( extract ( eq t a b ) ( congr t b a ( eq t a ) p refl ) ) )    ( symm\\ ( lemma_pf    ( trans\\ pi t\\ pi a\\ pi b\\ pi c\\ pi q1\\ pi q2\\      proves ( trans c q1 q2 ) ( eq t a b ) < < = =          hastype a t , hastype b t , hastype c t ,          proves q1 ( eq t a c ) , proves q2 ( eq t c b ) )    ( c\\q1\\q2\\ elam a\\ elam b\\ elam t\\      ( extract ( eq t a b ) ( congr t b c ( eq t a ) ( symm q2 ) q1 ) ) )    ( trans\\ ( forall_i i\\ forall_i j\\ forall_i k\\              ( imp_i q1\\ ( imp_i q2\\ ( trans j ( symm q1 ) q2 ) ) ) ) ) ) ) ) ( forall intty i\\ forall intty j\\ forall intty k\\    ( eq intty j i imp eq intty j k imp eq intty i k ) ) ) . ....    [ thm : symmtrans ]    the proof of the ` trans ` lemma expressing transitivity of equality uses the ` symm ` lemma .",
    "the ` symm ` lemma is naturally polymorphic : it can express the idea that @xmath10 just as well as @xmath11 .",
    "theorem  [ thm : compose ] illustrates part of a proof which contains two lemmas whose proofs use ` symm ` at different types .    ....",
    "( lemma_pf    ( symm\\ pi t\\ pi a\\ pi b\\ pi p\\      proves ( symm p ) ( eq t a b )",
    "< < = =           hastype a t , hastype b t , proves p ( eq t b a ) )    ( p\\ elam t\\ elam a\\ elam b\\      ( extract ( eq t a b ) ( congr t b a ( eq t a ) p refl ) ) )    ( symm\\ ( lemma_pf    ( poly1\\ proves poly1      ( forall ( intty arrow intty ) f\\ forall ( intty arrow intty ) g\\       ( eq ( intty arrow intty ) f g ) imp ( eq ( intty arrow intty ) g f ) ) )    ( forall_i f\\ ( forall_i g\\ ( imp_i q\\ ( symm q ) ) ) )    ( poly1\\ ( lemma_pf    ( poly2\\ proves poly2       ( forall ( intty arrow intty ) f\\ forall intty x\\        ( eq intty ( app intty f x ) x ) imp ( eq intty x ( app intty f x ) ) ) )    ( forall_i f\\ ( forall_i x\\ ( imp_i q\\ ( symm q ) ) ) )    ( poly2\\ ... ) ) ) ) ) ) ....    [ thm : compose ]    in our previous work  @xcite , because we represented object - level types as meta - level types , we were unable to allow polymorphism in lemmas at all . to do so",
    "would have required a metalanguage with more general non - prenex polymorphism . to handle theorem  [ thm : compose ] required two copies of the ` symm ` lemma , one at each type .    in principle , we do not need lemmas at all .",
    "instead , we can replace each subproof of the form ` ( lemma_pf i l r ) ` with the term ` ( r l ) ` , which replaces each use of a lemma with its proof .",
    "this approach , however , adds undesirable complexity to proofs .",
    "but , using this fact it should be straightforward to prove the correspondence between proofs with the ` lemma_pf ` constructor and proofs without , which would directly extend soundness and adequacy results to our system with lemmas .",
    "definitions are another important mechanism for structuring proofs to increase clarity and reduce size .",
    "if some property ( of a base - type object , or of a higher - order object such as a predicate ) can be expressed as a logical formula , then we allow the introduction of an abbreviation to stand for that formula .",
    "we start by presenting a motivating example ( section  [ defsexample ] ) , which leads us to our definition mechanism in @xmath0prolog  ( section  [ defsteyjus ] ) .",
    "we also discuss two simpler versions of our definition mechanism ( sections  [ defssimple ] and  [ defsatomic ] ) , which allow us to have a smaller tcb , but which require more work to use .",
    "we can express the fact that @xmath2 is an associative function by the formula @xmath12 this will only be a valid expression if @xmath2 has type @xmath13 . putting this formula in @xmath0prolog notation and expressing the type constraint on @xmath2 , we get the following provable @xmath0prolog typechecking goal .    .... pi f\\ pi t\\   ( pi x\\ pi y\\ hastype",
    "x t = > hastype y t = > hastype",
    "( f x y ) t ) = >   hastype ( forall t x\\ forall t y\\ forall t z\\            eq t ( f x ( f y z ) ) ( f ( f x y ) z ) ) form . ....    to make this into a definition , the first step is to associate some name , say ` assoc ` , with the definition body ( which is the first argument of the last ` hastype ` above ) .",
    "we associate a name to a body of a definition in the same way we associated a new proof constructor with the proof it stood for . if we follow exactly the pattern of the ` symm ` lemma introduced at the beginning of section  [ lemmas ] , we abstract out the body of the definition and obtain the following query .    ....",
    "( typeinf = ( assoc\\ pi f\\ pi t\\              hastype ( assoc f t ) form",
    "< < = =              pi x\\ pi y\\ ( hastype x t = = > >                 hastype y t = = > > hastype ( f x y ) t ) ) , def = ( f\\t\\ ( forall t x\\ forall t y\\ forall t z\\          ( eq t ( f x ( f y z ) ) ( f ( f x y ) z ) ) ) ) , query = ( typeinf def ) , query ) ....    ` typeinf ` is the typechecking query above with ` = > ` replaced by ` = = > > ` or ` < < = = ` , and the abstraction ` assoc ` replacing the body of the definition . ` def ` contains the body abstracted with respect to the function ` f ` and type ` t ` and ` ( typeinf def ) ` is exactly the typechecking subgoal above ( except for the use of ` = = > > ` and ` < < = = ` ) . if all we wanted was a typechecking lemma to typecheck expressions of the form given by ` def ` , then we could use our lemma mechanism directly .    ....",
    "( lemma_pf    ( assoc\\ pi f\\ pi t\\      hastype ( assoc f t ) form < < = =      pi x\\ pi y\\ ( hastype x t = = > > hastype y t = = > > hastype ( f x y ) t ) )    ( f\\t\\ ( forall t x\\ forall t y\\ forall t z\\     ( eq t ( f x ( f y z ) ) ( f ( f x y ) z ) ) ) )    ( assoc\\ ... ....    this example shows that we can have typechecking lemmas in addition to proof checking lemmas .",
    "it also motivates our definition mechanism shown next , which we obtain by adding the ability to replace a name with the expression it represents and vice versa .",
    "we introduce a new proof constructor ` def_pf ` and a new proof term ` def ` to represent equality between a name and its definition .",
    "this definition mechanism is implemented by the clauses in program  [ definition - fig ] .",
    ".... type   def_pf           tp - > ( a - > o ) - > a - > ( a - > pf ) - > pf .",
    "type   def              pf .",
    "type   def_to_eqclause tp - > a - > a - > o - > o.    def_to_eqclause t dname def ( pi clause ) : -    pi x\\ ( def_to_eqclause t ( dname x ) ( def x ) ( clause x ) ) .",
    "def_to_eqclause t dname def ( proves def ( eq t dname def ) ) .",
    "proves ( def_pf t typeinf term restproof ) c : -    pi name\\     ( valid_clause ( typeinf name ) ,      typeinf term ,      def_to_eqclause t name term ( eqclause name ) ,      cl ( typeinf name ) = > cl ( eqclause name ) = > ( proves ( restproof name ) c ) ) .",
    "....    [ definition - fig ]    the arguments to ` def_pf ` are similar to the arguments to ` lemma_pf ` , but also include one more for the type of the body of the definition ( after it is applied to all its arguments ) . in the clause for proof checking ` def_pf ` nodes , the first two subgoals are similar to ` lemma_pf ` nodes . here",
    ", they check that the typechecking clause is valid and that ` term ` ( the body of the definition ) is correctly typed .",
    "the third clause computes the clause for expressing definitional equality using the ` def_to_eqclause ` program .",
    "the fourth subgoal for proof checking definitions adds both the typechecking clause and the equality clause before checking the rest of the proof .    like ml , @xmath0prolog has parametric polymorphism ( in the syntactic sense ) .",
    "but unlike ml , @xmath0prolog does not have the parametricity property .",
    "a polymorphic function can examine the structure of its argument .",
    "we illustrate with a simple example : a function that tells the arity ( number of function arguments ) of an arbitrary value .",
    ".... type     arity            a - > int - > o. arity f n : - arity ( f x ) n1 , n is n1 + 1 .",
    "arity x 0 . ....    the first clause can only be used when ` f ` is a function ; the second clause matches any value .",
    "the ` def_to_eqclause ` clauses uses this exact feature of @xmath0prolog s polymorphism .",
    "it first uses the meta - level type of ` def ` to apply ` def ` to as many arguments as possible .",
    "the first clause introduces new variables to serve as these arguments . once it is applied to all of its arguments , the second clause forms the equality clause using the type , the name , and the body of the definition . for our example , the computed clause is    .... eqclause = ( assoc\\ ( pi f\\ pi t\\               proves def ( eq form ( assoc f t )                 ( forall t x\\ forall t y\\ forall t z\\                   ( eq t ( f x ( f y z ) ) ( f ( f x y ) z ) ) ) ) ) ) . ....    to ensure that there is only one solution to the ` arity ` predicate above and likewise the ` def_to_eqclause ` predicate in program  [ definition - fig ] , we could have used the logic programming cut ( ` ! ` ) operator at the end of the first clause for each predicate .",
    "we have omitted it here because ` def_to_eqclause ` is only be used in our proof checker , which is written to avoid the need for backtracking .    to use definitions in proofs",
    "we introduce two new lemmas : ` def_i ` to replace a formula with the definition that stands for it ( or viewed in terms of backward proof , to replace a defined name with the term it stands for ) , and ` def_e ` to expand a definition in the forward direction during proof construction .",
    "their proofs are shown in program  [ defs - fig ] .    ....",
    "( lemma_pf    ( def_i\\ pi t\\ pi name\\ pi b\\ pi p\\ pi q1\\ pi q2\\      proves ( def_i t name b p q1 q2 ) ( p name )",
    "< < = =       proves q1 ( eq t name b ) ,       hastype name t , hastype b t ,       proves q2 ( p b ) )    ( t\\name\\b\\p\\q1\\q2\\ ( congr t name b p q1 q2 ) )    ( def_i\\ ( lemma_pf    ( def_e\\ pi t\\ pi name\\ pi b\\ pi p\\ pi q1\\ pi q2\\      proves ( def_e t name b p q1 q2 ) ( p b ) <",
    "< = =       proves q1 ( eq t name b ) ,       hastype name t , hastype b t ,       proves q2 ( p name ) )    ( t\\name\\b\\p\\q1\\q2\\ ( congr t b name p     ( congr t name b ( eq t b ) q1 refl ) q2 ) )    ( def_e\\ ... ....    [ defs - fig ]    theorem  [ thm : def ] shows a proof using definitions . in this proof , ` f ` is a function symbol and ` t ` is a type , and the theorem is represented as a @xmath0prolog subgoal with a top - level implication , where the right hand side is a ` proves ` subgoal and the left hand side specifies the typing information about ` f ` which must hold in order for the proof in the ` proves ` subgoal to be valid .    .... pi f\\ pi t\\    ( pi x\\ pi y\\ hastype",
    "x t = > hastype y t = > hastype ( f x y ) t ) = > ( proves   ( lemma_pf ... symm\\   ( lemma_pf ... trans\\   ( lemma_pf ... def_i\\   ( lemma_pf ...",
    "def_e\\    ( def_pf form      ( assoc\\ pi f\\ pi t\\        hastype ( assoc f t ) form < < = =        pi x\\ pi y\\         ( hastype x t = = > > hastype y t = = > > hastype",
    "( f x y ) t ) )      ( f\\t\\ ( forall t x\\ forall t y\\ forall t z\\       ( eq t ( f x ( f y z ) ) ( f ( f x y ) z ) ) ) )      ( assoc\\   ( lemma_pf     ( assoc_inst\\ pi f\\ pi t\\ pi a\\ pi b\\ pi c\\ pi q\\       proves ( assoc_inst f q ) ( eq t ( f a ( f b c ) ) ( f ( f a b ) c ) ) < < = =         hastype a t , hastype b t , hastype c t ,         pi x\\ pi y\\ ( hastype x t = = > > hastype y t = = > > hastype ( f x y ) t ) ,         proves q ( assoc f t ) )     ( f\\q\\       ( elam t\\ elam a\\ elam b\\ elam c\\       ( extract ( eq t ( f a ( f b c ) ) ( f ( f a b ) c ) )        ( forall_e t ( z\\ ( eq t",
    "( f a ( f b z ) ) ( f ( f a b ) z ) ) )         ( forall_e t ( y\\ ( forall t z\\ ( eq t ( f a ( f y z ) ) ( f ( f a y ) z ) ) ) )          ( forall_e t ( x\\ ( forall t y\\ ( forall t z\\                       ( eq t ( f x ( f y z ) ) ( f ( f x y ) z ) ) ) ) )           ( def_e form ( assoc f t )             ( forall t x\\ forall t y\\ forall t z\\             ( eq t ( f x ( f y z ) ) ( f ( f x y ) z ) ) ) ( x\\x ) def",
    "q ) a ) b ) c ) ) ) )     ( assoc_inst\\   ( imp_i q1\\ ( forall_i a\\ ( imp_e ( assoc f t )    ( imp_i q2\\ ( trans ( f ( f a a ) ( f a a ) )                ( assoc_inst f q2 ) ( assoc_inst f q2 ) ) )    ( def_i form ( assoc f t )     ( forall t a\\ forall t b\\ forall t c\\          ( eq t ( f a ( f b c ) ) ( f ( f a b ) c ) ) ) ( x\\x ) def q1 ) ) ) ) ) ) ) ) ) ) ) )   ( ( forall t a\\ forall t b\\ forall t c\\     eq t ( f a ( f b c ) ) ( f ( f a b ) c ) ) imp    ( forall t a\\ eq t",
    "( f a ( f a ( f a a ) ) ) ( f ( f ( f a a ) a ) a ) ) ) ) ....    [ thm : def ]    the proof ( the first argument to the ` proves ` predicate ) contains a series of four lemmas which we have already seen , followed by the definition of associativity , followed by a fifth lemma about associativity ( ` assoc_inst ` ) , followed by the main body of the proof .",
    "the ` def_i ` lemma is used in the main body of the proof . in general ,",
    "proof checking using the ` def_i ` lemma means that the proof being checked must match the term ` ( def_i t name b p q1 q2 ) ` , which is the first argument ( the proof term ) of the head of the ` proves ` clause implementing the ` def_i ` lemma in program  [ defs - fig ] .",
    "this match determines the terms matching ` p ` and ` name ` .",
    "the formula being proved must be a formula that matches the term ` ( p name ) ` , which is the second argument of the head of the ` proves ` clause implementing the ` def_i ` lemma in program  [ defs - fig ] . here",
    "` name ` is not always simply a variable name , but is actually the definition name applied to all of its arguments to form a term of type ` tm ` . in our example , ` assoc ` has type    .... ( tm - > tm - > tm ) - > tp - > tm . ....    at the point that proof checking of the body of the proof uses the ` def_i ` lemma",
    ", the formula to be checked is ` ( assoc f t ) ` .",
    "the term that corresponds to ` ( p name ) ` in this example is ` ( x\\x)(assoc f t ) ` , which matches this formula .",
    "proof checking proceeds by finding a proof of the goal of the form    .... ( proves q1 ( eq form ( assoc f t ) b ) ) ....    which is proved simply by matching with the @xmath0prolog equality assumption added when the ` assoc ` definition was processed by the ` proves ` clause for ` def_pf ` .",
    "next , the two typechecking subgoals of the ` def_i ` clause are solved . solving the first , ` ( hastype ( assoc f t ) form ) ` , requires using the @xmath0prolog type inference assumption which was also added when the ` assoc ` definition was processed by the ` proves ` clause for ` def_pf ` .",
    "finally , the rest of the proof , is checked via the subgoal of the form ` ( proves q2 ( p b ) ) ` , where the formula to be checked has the definition name replaced by its body .",
    "the ` def_e ` lemma is used in the proof of the ` assoc_inst ` lemma .",
    "its use in proof checking is similar to ` def_i ` .",
    "the main difference is that the formula to be checked must match the term ` ( p b ) ` , i.e. , the formula contains an instance or instances of the body of the definition , and in the subgoal to be checked , the body of the definition is replaced with the name of the definition .    as another example of definitions , program  [ def : and ] shows the definition of logical conjunction for the object logic using the ` def_pf ` proof constructor .    ....",
    "( def_pf form      ( and\\ pi a\\ pi b\\        hastype ( and a b ) form",
    "< < = =        hastype a form , hastype b form )      ( a\\b\\ ( forall form c\\ ( ( a imp b imp c ) imp c ) ) )      ( and\\ ... ....    [ def : and ]    other connectives such as disjunction , negation , and existential quantification can also be defined , and the rules for introduction and elimination of these connectives can be proved as lemmas .      the new primitives and clauses in program  [ definition - fig ] provide a convenient way of incorporating definitions , but actually are not needed at all . instead , for each new definition , it is possible to introduce a special lemma to handle that definition .",
    "these special lemmas are quite complex and we do not want to require the user to come up with them",
    ". for illustration , theorem  [ thm : altdef ] shows the part of the proof that replaces the ` def_pf ` node in theorem  [ thm : def ] .    .... ...   ( lemma_pf ... def_e\\    ( lemma_pf     ( define_assoc\\ pi q\\ pi b\\       proves ( define_assoc q ) b < < = =         pi d\\ pi q\\             ( pi f\\ pi t\\                 ( proves q ( eq form ( d f t )                                ( forall t x\\ forall t y\\ forall t z\\                                 ( eq t ( f x ( f y z ) ) ( f ( f x y ) z ) ) ) ) ) )             = = > >             ( pi f\\ pi t\\ hastype ( d f t ) form",
    "< < = =                  pi x\\ pi y\\ hastype x t = = > > hastype y",
    "t = = > >                                 hastype ( f x y ) t )             = = > > proves ( q d q ) b )     ( q\\ ( q ( f\\t\\ ( forall t x\\ forall t y\\ forall t z\\                  ( eq t ( f x ( f y z ) ) ( f ( f x y ) z ) ) ) ) refl ) )     ( define_assoc\\   ( define_assoc     ( assoc\\q\\   ( lemma_pf     ( assoc_inst\\ ... ....    [ thm : altdef ]    this part of the proof includes the specialized lemma , called ` define_assoc ` , and shows that it is used immediately after it is defined .",
    "the bound variable ` assoc ` represents the name for the new definition , and the bound variable ` q ` represents a proof of equality between the definition name and its body .",
    "the new proof contains no use of the ` def_pf ` or ` def ` proof constructors .",
    "occurrences of ` def ` in theorem  [ thm : def ] are replaced with ` q ` .",
    "this change , although not shown in theorem  [ thm : altdef ] , is the only other change required to obtain the complete alternate proof .",
    "we omit a detailed explanation of the ` define_assoc ` lemma and simply note that it is fairly complex and increases the size of this example proof .",
    "also , this lemma is similar in structure to the simpler ` define ` lemma described below in section  [ defsatomic ]    additional programming can make this alternative way of incorporating definitions easier to use .",
    "in particular , it is possible to write a program to transform proofs that use ` def_pf ` and ` def ` to proofs that use only specialized lemmas such as the one in theorem  [ thm : altdef ] .",
    "such a program would allow us to remove program  [ definition - fig ] from the tcb .",
    "for the special class of defined terms that have meta - level type ` tm ` , which we call _ atomic _ definitions , it is easy to eliminate the need for ` def_pf ` and ` def ` because it is possible to include one new general lemma that replaces them .",
    "for example , we can express associativity of integers as the following term    .... lam f\\ forall intty x\\ forall intty y\\ forall intty z\\     eq intty ( app intty ( app intty f x ) ( app intty ( app intty f y ) z ) )          ( app intty ( app f intty ( app intty ( app intty f x ) y ) ) z ) ) ) ....    where ` f ` has meta - type ` tm ` and object type ` ( intty arrow intty arrow intty ) ` , and the ` app ` constructor is used to apply ` f ` to its arguments . if we specialize theorem  [ thm : def ] to integers , theorem  [ thm : newdef ] shows the part of the proof of this new theorem that replaces what is shown in theorem  [ thm : altdef ] .    .... ...   ( lemma_pf ... def_e\\    ( lemma_pf     ( define\\ pi t\\ pi f\\ pi q\\ pi b\\       proves ( define t f q ) b < < = =        hastype f t ,        pi d\\ pi q\\",
    "( hastype d t = = > >                      proves q ( eq t d f ) = = > > proves ( q d q ) b ) )     ( t\\f\\p\\ ( p f refl ) )     ( define\\   ( define ( ( intty arrow intty arrow intty ) arrow form )     ( lam f\\ forall intty x\\ forall intty y\\ forall intty",
    "z\\         eq intty ( app intty ( app intty f x ) ( app intty ( app intty f y ) z ) )              ( app intty ( app intty f ( app intty ( app intty f x ) y ) ) z ) ) )     ( assoc\\q\\   ( lemma_pf     ( assoc_inst\\ ... ....    [ thm : newdef ]    the parts of the proof not shown are similar to theorems  [ thm : def ] and  [ thm : altdef ] , but modified to use the new type of the bound variable ` f ` , which has the same type as the bound ` f ` in the definition .    in general , to check a proof using the ` define ` lemma , which has the following form    .... ( define t term ( name\\ eqproof\\ ( restproof name eqproof ) ) ) ....    the system interprets the `` ` pi d ` '' within the ` define ` lemma to create a new atom ` d ` to stand for the ` name ` .",
    "the new atom ` q ` is also introduced to stand for a proof that the name is equal to the body of the definition , and ` ( proves q ( eq t d term ) ) ` is added to the clause database .",
    "finally , @xmath4-conversion substitutes ` d ` for ` name ` and ` q ` for ` eqproof ` within ` restproof ` and the resulting proof is checked .    in proof checking the new proof , instead of subproofs of the form    .... ( proves def ( eq form ( assoc f t ) b ) )",
    "....    that would be generated by proof checking thereom  [ thm : def ] , or subproofs of the form    .... ( proves q ( eq form ( assoc f t ) b ) ) ....    that would be generated by proof checking thereom  [ thm : altdef ] , in theorem  [ thm : newdef ] we have subproofs of the form    .... ( proves q ( eq ( ( intty arrow intty arrow intty ) arrow form ) assoc b ) ) ....    where ` q ` here is the name of the proof term introduced inside the ` define ` proof node .    in general , having a single ` define ` lemma that can be used by all atomic definitions is simpler , but the atomic forms of definitions are larger and harder to read . in the case of ` assoc ` , the atomic version is three lines , while the original version is one line long . in our previous work",
    "@xcite , having to choose between the version of ` assoc ` that used ` app ` and the one that did nt was not an issue , since there were no ` app ` and ` lam ` constructors . instead application and abstraction were encoded directly using application and abstraction at the meta - level .",
    "also , there was no reason to include a separate ` def_pf ` proof constructor ; the ` define ` lemma was sufficient for introducing all definitions .",
    "although this allowed a simpler version of definitions , we were unable to allow polymorphism in definitions , which is desirable in definitions for the same reason it is desirable in lemmas .",
    "our previous encoding also did not allow definitions for object - level types .",
    "for example , in the domain of proof - carrying code , we have declarations like this one    .... hastype has_mltype          ( ( exp arrow form ) arrow ( exp arrow exp ) arrow exp arrow           ( ( exp arrow form ) arrow ( exp arrow exp ) arrow exp arrow            form ) arrow form .",
    "....    types like this arise because we encode types of the programming language we are reasoning about ( in this case ml ) as predicates which themselves take predicates as arguments . in our new version",
    ", it is possible to handle definitions at meta - type ` tp ` ; we would need a new proof constructor and a new proof checking clause similar to the one for the ` def_pf ` proof constructor in program  [ definition - fig ] .",
    "adding type definitions would also require adding reasoning about equality of types into our typechecking clauses .",
    "the lemma and definition mechanisms provide ways to store lemmas and definitions inside proofs .",
    "packaging proofs in this way makes it straightforward to communicate proofs , and keeps the proof checking machinery ( the tcb ) simple , which is important for our proof - carrying code application .",
    "thus far , all the @xmath0prolog code in programs  [ core - types ] , [ core - rules ] , [ lemmafig ] , [ cinterp ] , [ validclause ] , [ teyjuslemmafig ] , [ elam ] , and [ definition - fig ] is inside the tcb . a good environment for building proofs is also essential , and this part of the code can be outside the tcb .",
    "we do nt have to be as careful because we know that any proofs we build in our theorem proving environment have to be checkable by the proof checking code presented so far .    as we build a library of lemmas and definitions , we clearly do nt want to store every lemma and definition inside every proof that uses them .",
    "instead , for lemmas that have general applicability like ` symm ` , we would like to store them each once and allow them to be used in other proofs as needed . to do so",
    ", we provide predicates for stating each definition and lemma . to use these predicates ,",
    "we must introduce new constants for definition and lemma names .",
    "program  [ prog : store ] contains the declarations of these new predicates , and two examples which use them .    ....",
    "type   def_lemma        a - > ( a - > o ) - > a - > o. type   def_definition   tp - > a - > ( a - > o ) - > a - > o.    type symm              pf - > pf .",
    "def_lemma symm    ( symm\\ pi t\\ pi a\\ pi b\\ pi p\\      proves ( symm p ) ( eq t a b )",
    "< < = =           hastype a t , hastype b t , proves p ( eq t b a ) )    ( p\\ elam a\\ elam b\\ elam t\\      ( extract ( eq t a b ) ( congr t b a ( eq t a ) p refl ) ) ) .",
    "type   assoc            ( tm - > tm - > tm ) - > tp - > tm .",
    "def_definition form assoc    ( assoc\\ pi f\\ pi t\\      hastype ( assoc f t ) form < < = =      pi x\\ pi y\\       ( hastype x t = = > > hastype y t = = > > hastype ( f x y ) t ) )    ( f\\t\\ ( forall t x\\ forall t y\\ forall t z\\     ( eq t ( f x ( f y z ) ) ( f ( f x y ) z ) ) ) ) . ....    [ prog : store ]    @xmath0prolog s polymorphism is used in these predicates . the first argument to ` def_lemma ` is the lemma name , and the next two arguments correspond to the ` inference ` and ` lemmaproof ` arguments to the ` lemma_pf ` constructor .",
    "the arguments to ` def_definition ` are the definition name ( the second argument ) and arguments that correspond to the first three arguments of the ` def_pf ` constructor ( arguments 1 , 3 , and 4 here )",
    ".    then we can write programs to manipulate these lemmas and definitions in various ways .",
    "for example , if we want to package a proof as a single term with all the definitions and lemmas it depends on inside it , we must write a program to do so .",
    "the resulting proof should not contain any constants like ` symm ` and ` assoc ` ; instead lemma and definition names must be bound variables inside occurrences of the ` lemma_pf ` and ` def_pf ` proof constructors .",
    "we do not present the `` packaging '' program here , but instead present a simpler program that illustrates some of the programming techniques required for manipulating lemmas and definitions stored in this way .",
    "program  [ prog : check ] contains a program for checking a proof .",
    "it does nt check the lemmas that the proof depends on , but could be easily modified to do so .",
    ".... type   done_def         a - > o. type   done_lemma       a - > o. type   check_lem        a - > o. type   check_lem_aux    b - > a - > ( a - > o ) - > a - > o.    check_lem name : -    def_definition t dname inference def ,    not ( done_def dname ) , ! ,    def_to_eqclause t dname def eqclause ,    done_def dname = > cl ( inference dname ) = > cl eqclause = > check_lem name .",
    "check_lem name : -    def_lemma lname inference lemmaproof ,    check_lem_aux name lname inference lemmaproof .",
    "check_lem_aux name name inference lemmaproof : - ! ,    pi name\\ ( valid_clause ( inference name ) ) ,    ( inference lemmaproof ) .",
    "check_lem_aux name lname inference lemmaproof : - ! ,    not ( done_lemma lname ) , !",
    ",    done_lemma lname = > cl ( inference lname ) = > check_lem name . ....    [ prog : check ]    the trick of using prolog cut ( ` ! ` ) along with the predicates ` done_def ` and ` done_lemma ` allows us to process a list of clauses in the order they appear in the database . the first clause for ` check_lem ` looks for the next definition and each time it finds a new one , it adds the corresponding typechecking clause and equality clause . the second ` check_lem ` clause is used once all definitions have been added .",
    "it finds the next lemma and uses ` check_lem_aux ` to see if the next lemma is the one that should be checked .",
    "if so , the proof is checked ; if not , the proof checking clause for the lemma is added to the database and ` check_lem ` is called to process the next lemma .",
    "the _ logical framework _",
    "( lf )  @xcite is another example of a metalanguage in which it is possible to encode a wide variety of logics .",
    "the twelf system  @xcite is an implementation of lf which provides logic programming capabilities , many of which are similar to @xmath0prolog . in this section ,",
    "we compare the encoding of our core logic in @xmath0prolog to a corresponding encoding in twelf , discuss lemmas and definitions in twelf , and compare the programming environments of these two languages .",
    "lf is a @xmath0-calculus with dependent types .",
    "a dependent type in lf has the structure @xmath14 where @xmath15 and @xmath16 are types and @xmath17 is a variable of type @xmath15 bound in this expression .",
    "the type @xmath16 may contain occurrences of @xmath17 .",
    "this structure represents a `` functional type . ''",
    "if @xmath2 is a function of this type , and @xmath18 is a term of type @xmath15 , then @xmath19 ( @xmath2 applied to @xmath18 ) has the type @xmath20b$ ] , which represents the type @xmath16 where all occurrences of @xmath17 are replaced by @xmath18 .",
    "thus the argument type is @xmath15 and the result type _ depends _ on the value input to the function . if @xmath17 does nt occur in @xmath16 , this type is often abbreviated using the usual type arrow : @xmath21 .",
    "the extra expressiveness of dependent types allows object - level types to be expressed more directly , eliminating the need for any typechecking clauses like the ` hastype ` clauses of program  [ core - rules ] .",
    "the twelf constructor declarations in program  [ core - twelf ] illustrate the use of dependent types for encoding our object logic .",
    ".... tp      : type .",
    "tm      : tp - > type .",
    "form    : tp .",
    "pf      : tm form - > type .",
    "intty   : tp .",
    "arrow   : tp - > tp - > tp .",
    "% infix right 14 arrow .",
    "pair    : tp - > tp - > tp .",
    "eq      : tm t - > tm t - > tm form .",
    "imp     : tm form - > tm form - > tm form .",
    "% infix right 10 imp .",
    "forall : ( tm t - > tm form ) - > tm form .",
    "false   : tm form .",
    "lam     : ( tm t1 - > tm t2 ) - > tm ( t1 arrow t2 ) .",
    "app     : tm ( t1 arrow t2 ) - > tm t1 - > tm t2 .",
    "mkpair : tm t1 - > tm t2 - > tm ( pair t1 t2 ) .",
    "fst     : tm ( pair t1 t2 ) - > tm t1 .",
    "snd     : tm ( pair t1 t2 ) - > tm t2 .",
    "refl      : pf ( eq x x ) .",
    "beta      : pf ( eq ( app ( lam f ) x ) ( f x ) ) .",
    "fstpair   : pf ( eq ( fst ( mkpair x y ) ) x ) .",
    "sndpair   : pf ( eq ( snd ( mkpair x y ) ) y ) .",
    "surjpair : pf ( eq ( mkpair ( fst z ) ( snd z ) ) z ) . congr     : { h : tm t - > tm form }               pf ( eq x z ) - > pf ( h z ) - > pf ( h x ) . imp_i     : ( pf a - > pf b ) - > pf ( a imp b ) . imp_e     : pf ( a imp b ) - > pf a - > pf b. forall_i : ( { y : tm t}pf ( a y ) ) - > pf ( forall a ) .",
    "forall_e : pf ( forall a ) - > { y : tm t}pf ( a y ) . ....",
    "[ core - twelf ]    felty and miller  @xcite show how to transform an lf object logic into an encoding in a higher - order logic which is a sublogic of the one implemented by @xmath0prolog .",
    "the discussion in this section is informal , but in appendix  [ app : compare ] , we use this transformation to provide a formal basis for comparing our two encodings .    although typechecking clauses are not needed here , the proof checking operation is more complicated in twelf since it requires type reconstruction for dependent types .",
    "twelf has its own built - in definition mechanism , which can be used for both lemmas and definitions in the object logic .",
    "program  [ twelf - def ] contains a twelf version of the definition of ` assoc ` and the ` symm ` lemma .",
    ".... % abbrev assoc : ( tm t - > tm t - > tm t ) - > tm form =    [ f:(tm t - > tm t - > tm t ) ]     ( forall [ a : tm t ] forall [ b : tm t ] forall [ c : tm t ]      ( eq ( f a ( f b c ) ) ( f ( f a b )",
    "c ) ) ) .",
    "symm : pf ( eq x y ) - > pf ( eq y x ) =   [ q : pf ( eq x y ) ] ( congr ( [ z : tm t ] ( eq y z ) ) q refl ) . ....    [ twelf - def ]    the ` abbrev ` directive is required in some definitions for technical reasons , which we do not describe here .",
    "there are three parts to a definition : a constant naming the definition , its type , and its body ( an lf term ) .",
    "a lemma is similar and contains its name , the formula representing the statement of the lemma ( which is a type in lf ) , and the proof ( an lf term ) .    in twelf ,",
    "a proof is simply a series of declarations and definitions , where the last one is the statement and proof of the main theorem .",
    "this proof possibly depends on the lemmas and definitions that come before it .",
    "each definition in the sequence has the form mentioned above : a name , a type , and the term which the name abbreviates when it appears in subsequent declarations .",
    "the declarations defining the logical constants and primitive inference rules shown in program  [ core - twelf ] ( which each have a type but no defining term ) are at the beginning of the sequence . in twelf , we can not package up a lemma and its proof , or a definition and its body , along with the rest of the proof , in the same way we did in @xmath0prolog .",
    "the reason for this is that we can not introduce a ` lemma_pf ` or ` def_pf ` constructor because they require polymorphism at the meta - level , which twelf does not have .    in our @xmath0prolog version",
    ", we discussed naming each lemma and definition , including one copy of each in a library , and using it whenever needed .",
    "we then presented a program which was able to check the proof of a theorem , assuming that lemmas and definitions were organized in this way . in twelf",
    ", we do nt need a special program for checking proofs of lemmas .",
    "one of the central meta - operations of twelf is to read in a series of declarations and definitions , and check each one as it is encountered .",
    "proofs are fully checked by this operation .    in twelf ,",
    "other kinds of operations on proofs are limited .",
    "many proof transformations that we can implement in @xmath0prolog are not programmable in twelf either because they require polymorphism or because they require manipulation of meta - level formulas .",
    "manipulation of meta - level formulas is not possible in twelf because it requires quantification over such formulas ( i.e. , quantification over types containing ` type ` ) , which is not allowed .",
    "although we have focussed on the lemma and definition mechanisms in @xmath0prolog and twelf , other aspects of the metalanguage are also relevant to our needs for proof generation and checking .      for our application , proof - carrying code ,",
    "we wish to prove theorems about machine instructions that add , subtract , and multiply ; and about load / store instructions that add offsets to registers .",
    "therefore we require some rudimentary integer arithmetic in our logic .",
    "some logical frameworks have powerful arithmetic primitives , such as the ability to solve linear programs @xcite or to handle general arithmetic constraints @xcite .",
    "for example , twelf provides a complete theory of the rationals , implemented using linear programming @xcite . on the one hand ,",
    "linear programming is a powerful and general proof technique , although it can increase the complexity of the tcb . on the other hand ,",
    "synthesizing arithmetic from scratch is not easy .",
    "we have also experimented with arithmetic in @xmath0prolog where we use the ` is ` predicate to provide some automatic simplifications .",
    "parameterizable data structures with higher - order unification modulo @xmath4-equivalence provide an expressive way of representing formulas , predicates , and proofs .",
    "we make heavy use of higher - order data structures with both direct sharing and sharing modulo @xmath4-reduction",
    ". the implementation of the metalanguage must preserve this sharing ; otherwise our proof terms will blow up in size .",
    "any logic programming system is likely to implement sharing of terms obtained by copying multiple pointers to the same subterm . in terzo , this can be seen as the implementation of a reduction algorithm described by wadsworth @xcite .",
    "but we require even more sharing .",
    "the similar terms obtained by applying a @xmath0-term to different arguments should retain as much sharing as possible .",
    "therefore some intelligent implementation of higher - order terms within the metalanguage  such as teyjus s use of explicit substitutions  @xcite  seems essential .      in this paper , we have concentrated on an encoding of the logic used for proof checking , and discussed some operations on proofs .",
    "but of course , we will also need to construct proofs .",
    "for the proof - carrying code application , we need an automatic theorem prover to prove the safety of programs . for implementing this prover",
    ", we have found that the prolog - style control primitives ( such as the cut ( ` ! ` ) operator and the ` is ` predicate ) , which are also available in @xmath0prolog , are quite important .",
    "@xmath0prolog also provides an environment for implementing tactic - style interactive provers @xcite .",
    "this kind of prover is useful for proving the lemmas that are used by the automatic prover .",
    "twelf does not have many control primitives ; in fact , implementation of control primitives does not fit well into the twelf system design .",
    "we have begun to experiment with an operator in twelf similar to prolog cut , to see if it will allow us to implement the automatic prover in the same way as in @xmath0prolog .",
    "there is also no support for building interactive provers in twelf , so proofs of lemmas used by the automatic prover must be constructed by hand .",
    "the logical frameworks discussed in this paper are promising vehicles for proof - carrying code , or in general where it is desired to keep the proof checker as small and simple as possible .",
    "we have proposed a representation for lemmas and definitions that should help keep proofs small and well - structured , and each of these frameworks has features that are useful in implementing , or implementing efficiently , our machinery .",
    "we have found the conciseness of the encoding in twelf to be particularly convenient , and because of that , we have used twelf for extensive proof development in our proof - carrying code application . as",
    "programming with proofs becomes more important in the next phases of our system , @xmath0prolog will have more advantages .",
    "we are currently investigating ways to combine the use of the two metalanguages .",
    "the translation discussed in appendix  [ app : compare ] will serve as the foundation for this combination .",
    "to write a full interpreter , we extend program  [ cinterp ] in section  [ lemmasteyjus ] by introducing a new type ` goal ` and connectives which build terms of this type . in particular , we now give ` < < = = ` and ` = = > > ` the type ` goal - > goal - > goal ` . we also introduce a new constant ` ^^ ` for conjunction having the same type as the implication constructors .",
    "finally , we introduce ` all ` for universal quantification having type ` ( a - > goal ) - > goal ` . in addition",
    ", we change the type of ` backchain ` to ` goal - > goal - > o ` , and modify the clauses for the _ comma _ and ` pi ` to use the new constants . in the ` backchain ` clauses for `",
    "< < = = ` and ` = = > > ` in program  [ cinterp ] , the goal ` g1 ` which appears as an argument inside the head of the clause also appears as a goal in the body of the clause . in the full interpreter",
    ", we can not do this . `",
    "g1 ` no longer has type ` o ` ; it has type ` goal ` and is constructed using the new connectives . instead , we replace ` g1 ` with ` ( solveg g1 ) ` and implement the ` solveg ` predicate to handle the solving of goals . the new code for ` solveg ` and the modified code for ` backchain ` is in program  [ interp ]",
    ".    .... kind   goal             type .",
    "type   = = > >             goal - > goal - > goal .",
    "infixr   = = > >",
    "type   < < = =             goal - > goal - > goal .",
    "infixl   < < = =     0 .",
    "type   ^^               goal - > goal - > goal .",
    "infixl   ^^       3 .",
    "type   all              ( a - > goal ) - > goal .",
    "type   cl               goal - > o. type   backchain        goal - > goal - > o. type   solveg           goal - > o.    type   proves           pf - > form - > goal .",
    "type   assume           form - > goal .",
    "type   valid_clause     goal - > goal .",
    "solveg ( all g ) : - pi x\\ ( solveg ( g x ) ) .",
    "solveg ( g1 ^^ g2 ) : - solveg g1 , solveg g2 .",
    "solveg ( d = = > > g ) : - ( cl d ) = > solveg g. solveg ( g < < = = d ) : - ( cl d ) = > solveg g. solveg g : - cl d , backchain g d.    backchain g g. backchain g ( all d ) : - backchain g ( d x ) . backchain g ( a ^^ b ) : - backchain g a ; backchain g b. backchain g ( h < < = = g1 ) : - backchain g h , solveg g1 .",
    "backchain g ( g1 = = > >",
    "h ) : - backchain g h , solveg g1 . ....    [ interp ]    in order to use this interpreter to solve goals of the form ` ( proves p a ) ` , the ` proves ` predicate must be a constructor for terms of type ` goal ` , and the meta - level goal presented to @xmath0prolog must have the form ` ( solveg ( proves p a ) ) ` . similarly , inference rules must also be represented as objects of type ` goal ` and wrapped inside ` cl ` to form @xmath0prolog clauses .",
    "several examples of clauses for inference rules are given in program  [ inf - interp ] to illustrate .    .... cl ( proves q a < < = = assump ( proves q a ) ) .",
    "cl ( proves ( imp_i q ) ( a imp b ) < < = =        all p\\ ( assump ( proves p a ) = = > > proves ( q p ) b ) ) .",
    "cl ( proves ( forall_i q ) ( forall t a ) < < = =        all y\\ ( hastype y t = = > > proves ( q y ) ( a y ) ) ) .",
    "cl ( proves ( lemma_pf inference lemmaproof restproof ) c <",
    "< = =    all name\\      ( valid_clause ( inference name ) ^^      inference lemmaproof ^^      ( inference name ) = = > > ( proves ( restproof name ) c ) ) ) . ....    [ inf - interp ]    the last clause is the new clause for handling lemmas in this setting . note that in this version , ` valid_clause ` constructs objects of type ` goal ` ; thus all the clauses for ` valid_clause ` must also be wrapped in ` cl ` .",
    "as stated , the transformation in felty and miller  @xcite can provide a formal basis for comparing our two encodings . in order to perform this transformation , we must consider a `` full '' lf encoding , which does not take advantage of the abbreviations that twelf allows .",
    "just as the full lf encoding can be improved by using twelf s abbreviations , the @xmath0prolog program that results from the transformation can be improved by making several optimizations .",
    "we discuss how the encoding presented in programs  [ core - types ] and  [ core - rules ] can be viewed as the application of the transformation , followed by performing several such optimizations .    in both @xmath0prolog and twelf ,",
    "all tokens in a clause or declaration beginning with uppercase letters are implicitly bound by universal quantifiers at the outermost level . in twelf , this implicit quantification is important for providing an encoding of the object logic that is readable and usable . to see why , consider the ` surjpair ` rule , which uses the ` mkpair ` , ` fst ` , and ` snd ` constants .",
    "we can make the outermost quantification explicit in twelf , resulting in the declarations :    .... mkpair : { t1:tp}{t2:tp}tm t1 - > tm t2 - > tm ( pair t1 t2 ) .",
    "fst     : { t1:tp}{t2:tp}tm ( pair t1 t2 ) - > tm t1 .",
    "snd     : { t1:tp}{t2:tp}tm ( pair t1 t2 ) - > tm t2 .",
    "surjpair :   { t1:tp}{t2:tp}{z : tm ( pair t1 t2 ) }   pf ( eq ( pair t1 t2 ) ( mkpair t1 t2 ( fst t1 t2 z ) ( snd t1 t2 z ) ) z ) . ....    this version of ` surjpair ` is quite a bit bigger than the one in program  [ core - twelf ] .",
    "explicitly including ` t1 ` and ` t2 ` means that ` mkpair ` , ` fst ` , and ` snd ` each take two extra type arguments , while ` surjpair ` takes three .",
    "terms containing these constants must then take extra arguments which in this example causes redundancy in the type of ` surjpair ` because the same types appear many times .",
    "implicit quantifiers make the encoding easier to read and work with .",
    "in fact , in the version we used in our experiments , the fact that ` app ` could be represented as a binary constructor without loss of information allowed us to replace the ` app ` constant with an infix symbol , resulting in encoded terms that were syntactically even closer to the terms they represented .",
    "we can not make ` app ` in the @xmath0prolog encoding infix because it takes three arguments .",
    "( we discuss why it must take three arguments below . )",
    "the explicit quantifiers that we have left out in program  [ core - twelf ] are those that twelf can easily reconstruct . because of this reconstruction , however , a twelf typechecker ( proof checker ) has to work harder than it would if we used an explicit version .",
    "these encodings illustrate a tradeoff we encounter in proof and term size versus complexity of the proof checker . reducing the proof size forces the checker ( the tcb ) to become more complex .",
    "when considering the formal transformation , we start from a modified version of program  [ core - twelf ] that makes all quantifiers explicit . to illustrate",
    ", we apply the transformation to all of the declarations in the twelf encoding except for the constants and inference rules for pairing . applying the transformation to these declarations , we get the @xmath0prolog type declarations and clauses in programs  [ trans - types ] and  [ trans - rules ] .",
    "type   lam              ltm - > ltm - > ( ltm - > ltm ) - > ltm .",
    "type   app              ltm - > ltm - > ltm - > ltm - > ltm .",
    "type   eq               ltm - > ltm - > ltm - > ltm .",
    "type   imp              ltm - > ltm - > ltm .",
    "infixr   imp      7 .",
    "type   forall           ltm - > ( ltm - > ltm ) - > ltm .",
    "type   false            ltm .",
    "type   refl             ltm - > ltm - > ltm .",
    "type   beta             ltm - > ltm - > ( ltm - > ltm ) - > ltm - > ltm .",
    "type   congr            ltm - > ltm - > ltm - > ( ltm - > ltm ) - >                           ltm - > ltm - > ltm .",
    "type   imp_i            ltm - > ltm - > ( ltm - > ltm ) - > ltm .",
    "type   imp_e            ltm - > ltm - > ltm - > ltm - > ltm .",
    "type   forall_i         ltm - > ( ltm - > ltm ) - > ( ltm - > ltm ) - > ltm .",
    "type   forall_e         ltm - > ( ltm - > ltm ) - > ltm - > ltm - > ltm .",
    "....            hasltype ( lam t1 t2 f ) ( tm ( t1 arrow t2 ) ) : - hasltype t1 tp , hasltype t2 tp ,    pi x\\ ( hasltype x ( tm t1 ) = > hasltype ( f x ) ( tm t2 ) ) .",
    "hasltype ( app t1 t2 f x ) ( tm t2 ) : - hasltype t1 tp , hasltype t2 tp ,    hasltype f ( tm ( t1 arrow t2 ) ) , hasltype x ( tm t1 ) . hasltype ( eq t x y ) ( tm form ) : -    hasltype t tp , hasltype x ( tm t ) , hasltype y ( tm t ) .",
    "hasltype ( a imp b ) ( tm form ) : - hasltype a ( tm form ) , hasltype b ( tm form ) . hasltype ( forall t a ) ( tm form ) : - hasltype t tp ,    pi x\\ ( hasltype x ( tm t ) = > hasltype ( a x ) ( tm form ) ) .",
    "hasltype false ( tm form ) .",
    "hasltype ( refl t x ) ( pf ( eq t x x ) ) : - hasltype t tp , hasltype x ( tm t ) . hasltype ( beta t1 t2 f x ) ( pf ( eq t2 ( app t1 t2 ( lam t1 t2 f ) x ) ( f x ) ) ) : -    hasltype t1 tp , hasltype t2 tp ,    pi x\\ ( hasltype x ( tm t1 ) = > hasltype ( f x ) ( tm t2 ) ) .",
    "hasltype ( congr t x z h p1",
    "p2 ) ( pf ( h x ) ) : -    hasltype t tp , hasltype x ( tm t ) , hasltype z ( tm t ) ,    pi x\\ ( hasltype x ( tm t ) = > hasltype ( h x ) ( tm form ) ) ,    hasltype p1 ( pf ( eq t x z ) ) , hasltype p2 ( pf ( h z ) ) .",
    "hasltype ( imp_i a b q ) ( pf ( a imp b ) ) : -    hasltype a ( tm form ) , hasltype b ( tm form ) .    pi p\\ ( hasltype p ( pf a ) = > hasltype ( q p ) ( pf b ) )",
    ". hasltype ( imp_e a b q1 q2 ) ( pf b ) : -     hasltype a ( tm form ) , hasltype b ( tm form ) ,    hasltype q1 ( pf ( a imp b ) ) , hasltype q2 ( pf a ) .",
    "hasltype ( forall_i t a q ) ( pf ( forall t a ) ) : - hasltype t tp ,    pi y\\ ( hasltype y ( tm t ) = > hasltype ( a y ) ( tm form ) ) ,    pi y\\ ( hasltype y ( tm t ) = > hasltype ( q y ) ( pf ( a y ) ) ) .",
    "hasltype ( forall_e t a q y ) ( pf ( a y ) ) : - hasltype t tp ,    pi y\\ ( hasltype y ( tm t ) = > hasltype ( a y ) ( tm form ) ) ,    hasltype q ( pf ( forall t a ) ) , hasltype y ( tm t ) . ....      before discussing the details , it is already possible to see some of the similarities between the twelf and @xmath0prolog  encodings , and between the @xmath0prolog  encoding resulting from the transformation and the one in programs  [ core - types ] and  [ core - rules ] .",
    "for example , in twelf the full version of the ` congr ` rule is      the ` congr ` proof constructor takes 6 arguments ( ` t ` , ` x ` , ` z ` , ` h ` , and two subproofs ) . in the @xmath0prolog  version of ` congr ` in programs  [ trans - types ] and  [ trans - rules ] , ` congr ` also takes 6 arguments ( 4 terms and 2 subproofs ) though their types are different from the lf version .",
    "also , in our original @xmath0prolog  encoding ( program  [ core - rules ] ) , the ` congr ` clause has 4 subgoals , while in the new one ( program  [ trans - rules ] ) there are 6 ; it is easy to see the correspondence between 4 of them in the two encodings . note that in the version in program  [ core - rules ] , two of them are typechecking subgoals and two are proof checking subgoals . in twelf , typechecking and proof checking",
    "are unified , so all subgoals in the twelf version are twelf typechecking goals ; in our example some of them check terms whose types have the form ` ( tm a ) ` , while others check terms whose types have the form ` ( pf a ) ` .    in lf , there are several kinds of assertions .",
    "the two that are important for the formal transformation are : `` @xmath15 is a type '' and `` term @xmath22 has type @xmath15 '' .",
    "two @xmath0prolog types ` ltp ` and ` ltm ` introduced in program  [ trans - types ] are used to encode lf types and terms .",
    "the @xmath0prolog predicates ` ltype ` and ` hasltype ` are introduced to express the two assertions , respectively .",
    "the first assertion is important for transforming the three declarations in program  [ core - twelf ] that end in `` ` type . ` '' they declare constants that are used to create lf types , which correspond to @xmath0prolog  formulas ( terms of type ` o ` ) .",
    "the second assertion is used for the rest . in order for an assertion of the second kind to hold",
    ", it must also be the case that @xmath15 is a type .",
    "for this reason , the @xmath0prolog predicate ` well_typed ` is included ( program  [ trans - types ] ) and has one clause ( program  [ trans - rules ] ) .",
    "the declarations and clause discussed so far are necessary no matter what twelf encoding we begin with .",
    "the remaining declarations and clauses in programs  [ trans - types ] and  [ trans - rules ] are specific to our particular object logic . for each twelf declaration in program  [ core - twelf ] that we consider , there is one type declaration in program  [ trans - types ] and one clause in program  [ trans - rules ] .",
    "the first change we make to the @xmath0prolog code in programs  [ trans - types ] and  [ trans - rules ] to get closer to an optimized version involves the ` well_typed ` clause .",
    "consider the first subgoal of this clause , an ` ltype ` subgoal .",
    "note that for our particular encoding , there are three clauses for the ` ltype ` predicate .",
    "they correspond to the three kinds of objects in the encoding of the object logic : types , terms , and proofs . in solving an ` ltype ` subgoal , at most one clause will ever apply at any point depending on which of three forms the argument has .",
    "this observation permits us to replace ` well_typed ` with the following three clauses which cover every case .      in the first clause",
    ", we can eliminate the ` ltype ` subgoal because it is always provable . in the second and third clauses",
    ", we can replace the ` ltype ` subgoal with the corresponding subgoal from the body of the only ` ltype ` clause that applies , to obtain the clauses below .",
    "although ` hasltype ` is sufficient for representing any lf assertion of the form `` term @xmath22 has type @xmath15 , '' in our encoding it is useful to distinguish three ways in which it is used .",
    "this fact leads to our second modification of programs  [ trans - types ] and  [ trans - rules ] .",
    "the second argument to ` hasltype ` always has one of the following forms : ` tp ` , ` ( tm t ) ` , or ` ( pf a ) ` . using this fact",
    ", we replace ` hasltype ` with three predicates : ` istype ` , ` hastype ` , and ` proves ` .",
    "since the second argument to ` istype ` always is ` tp ` , we can eliminate this argument altogether so that ` istype ` has type ` ltm - > o ` .",
    "program  [ trans - mod1 ] illustrates the modifications discussed so far on a subset of the ` hasltype ` clauses in program  [ trans - rules ] , which include only those for ` arrow ` , ` forall ` , and ` forall_i ` .                      looking back at program  [ core - twelf ] ,",
    "note the types of the four constants that are used to construct terms of type ` tp ` .",
    "there are no dependent types here ; they are all simple types , which could be transformed directly to @xmath0prolog types .",
    "this fact leads to our third modification .",
    "instead of transforming all twelf terms and types to @xmath0prolog terms as is done by the transformation , we transform types with no dependencies directly to @xmath0prolog types , thus allowing the @xmath0prolog typechecker to do more typechecking work automatically .",
    "this direct transformation gives us the @xmath0prolog declarations      this change forces several other changes .",
    "the type of ` tm ` must be changed to ` tp - > ltp ` .",
    "the ` well_typed ` clause for ` tp ` is no longer necessary .",
    "the ` istype ` predicate and all of the clauses for it can be removed ; all ` istype ` subgoals in other clauses can be eliminated .",
    "the ` well_typed ` clause for ` tm ` can also be eliminated since checking for well - typedness amounts to simply using the ` hastype ` predicate . in the types of all of the constants , wherever there appears a term ` t ` of type ` ltm ` such that ` t ` represents an object - logic type , the type of ` t ` must be changed to ` tp ` .",
    "program  [ trans - mod2 ] illustrates these changes on the subset of declarations and clauses from program  [ trans - mod1 ] .",
    "note that the types of ` forall ` and ` forall_i ` are changed to reflect the fact that the first argument ` t ` has type ` tp ` .",
    "our fourth modification to the @xmath0prolog code allows the @xmath0prolog type system to make further useful distinctions for our particular object logic .",
    "we introduced the ` hastype ` and ` proves ` predicate for the cases when the second argument to our old ` hasltype ` had the forms ` ( tm t ) ` and form ` ( pf a ) ` , respectively .",
    "we can further simplify these clauses by eliminating the ` tm ` and ` pf ` constants . simply eliminating them",
    "means we must change the types of the second argument to these predicates appropriately ,      but we can go a step further than that .",
    "notice that after removing ` tm ` and ` pf ` , terms appear as the first argument to ` hastype ` and types as the second , and that proofs appear as the first argument to the ` proves ` predicate and formulas , which are a subset of the terms , appear as the second . to make these distinctions in the program ,",
    "we reintroduce the constants ` tm ` and ` pf ` , but this time as @xmath0prolog types which replace ` ltm ` .      after making all the changes discussed so far to the types and clauses in programs  [ trans - types ] and  [ trans - rules ] , we obtain the somewhat simpler versions in programs  [ trans - types - a ] and  [ trans - rules - a ] .          type   lam              tp - > tp - > ( tm - > tm ) - > tm . type   app              tp - > tp - > tm - > tm - > tm .",
    "type   eq               tp - > tm - > tm - > tm .",
    "type   imp              tm - > tm - > tm .",
    "infixr   imp      7 .",
    "type   forall           tp - > ( tm - > tm ) -",
    "> tm . type   false            tm .",
    "type   refl             tp - > tm - > pf .",
    "type   beta             tp - > tp - > ( tm - > tm ) -",
    "> tm - > pf . type   congr            tp - > tm - > tm - > ( tm - > tm ) - > pf - > pf - > pf .",
    "type   imp_i            tm - > tm - > ( pf - > pf ) - > pf . type   imp_e            tm - > tm - > pf - > pf - > pf .",
    "type   forall_i         tp - > ( tm - > tm ) - > ( tm - > pf ) - > pf .",
    "type   forall_e         tp - > ( tm - > tm ) - > pf - > tm - > pf . ....        hastype ( lam t1 t2 f ) ( t1 arrow t2 ) : -    pi x\\ ( hastype x t1 = > hastype ( f x ) t2 ) .",
    "hastype ( app t1 t2 f x ) t2 : - hastype f ( t1 arrow t2 ) , hastype x t1 . hastype ( eq t x y ) form : - hastype x t , hastype y t. hastype ( a imp b ) form : - hastype a form , hastype b form .",
    "hastype ( forall t a ) form : - pi x\\ ( hastype x t = > hastype ( a x ) form ) .",
    "hastype false form .",
    "proves ( refl t x ) ( eq t x x ) : - hastype x t. proves ( beta t1 t2 f x ) ( eq t2 ( app t1 t2 ( lam t1 t2 f ) x ) ( f x ) ) : -    pi x\\ ( hastype x t1 = > hastype ( f x ) t2 ) . proves",
    "( congr t x z h p1",
    "p2 ) ( h x ) : -    hastype x t ,",
    "hastype z t , pi x\\ ( hastype x t = > hastype ( h x ) form ) ,    proves p1 ( eq t x z ) , proves p2 ( h z ) . proves ( imp_i a b q ) ( a imp b ) : - hastype a form , hastype b form .",
    "pi p\\ ( proves p a = > proves ( q p ) b ) . proves ( imp_e a b q1 q2 )",
    "b : - hastype a form , hastype b form ,    proves q1 ( a imp b ) , proves q2 a. proves ( forall_i t a q ) ( forall t a ) : -    pi y\\ ( hastype y t = > hastype ( a y ) form ) .",
    "pi y\\ ( hastype y t = > proves ( q y ) ( a y ) ) . proves ( forall_e t a q y ) ( a y ) : -    pi y\\ ( hastype y t = > hastype ( a y ) form ) ,    proves q ( forall t a ) , hastype y t. ....      note that ` tm ` and ` pf ` no longer appear in clauses ( program  [ trans - rules - a ] ) , and instead appear in types ( program  [ trans - types - a ] ) . also note the new type and clause for ` well_typed ` as compared to what they were in program  [ trans - mod2 ] .    the types and clauses in programs  [ trans - types - a ] and  [ trans - rules - a ] are now quite close to those of programs  [ core - types ] and  [ core - rules ] in section  [ core ] .",
    "the remaining changes are optimizations that can be best illustrated if we view the @xmath0prolog code as a proof checker .",
    "in particular , for any subgoal of the form ` ( proves p a ) ` , we assume the proof and the formula are given at the outset ( no logical variables ) and that the subgoal ` ( hastype a form ) ` will be asked first ( e.g. , via the ` well_typed ` predicate ) .",
    "with this in mind , by looking at some of the clauses for the ` proves ` predicate , we find two kinds of redundancy .",
    "consider , for example , the clause for ` refl ` .",
    "the arguments ` t ` and ` x ` appear in both the proof and the formula . assuming that a formula and proof are always paired together , any arguments that appear in the formula do not have to be repeated in the proof .",
    "thus we can remove both arguments to ` refl ` .",
    "also , since we assume that the formula has already been typechecked , the ` hastype ` subgoal is redundant and can be eliminated .",
    "thus we achieve the simple form for the ` refl ` rule as it appears in program  [ core - rules ] .",
    "next consider the clause for ` imp_e ` . since ` b ` is the formula whose proof is to be checked",
    ", we do nt need an extra copy among the arguments to ` imp_e ` .",
    "we also do nt need to typecheck ` b ` since this has been done via the initial call to ` well_typed ` .",
    "if we are to guarantee correct typing of the formula in _ any _ ` proves ` subgoal generated during proof checking , then we need to keep ` hastype ` subgoals for any formula that does not appear as a subformula of the formula in the head of the clause . in the ` imp_e ` clause ,",
    "the goal ` ( hastype a form ) ` is asked before ` ( proves q2 a ) ` and this ` hastype ` subgoal can not be removed .",
    "these changes lead to the ` imp_e ` clause in program  [ core - rules ] .",
    "analogously , we can examine the ` hastype ` clauses and remove redundant arguments from terms .",
    "for example , in the case of ` app ` , the type ` t2 ` can be removed because it appears as the second argument to ` hastype ` .",
    "we must keep ` t1 ` if we want to preserve the property that proof checking will not introduce logic variables .",
    "note that when comparing program  [ trans - rules - a ] to program  [ core - rules ] , in the ` proves ` clause for ` congr ` , no arguments are removed from the proof term in either case , even though ` h ` and ` x ` appear in the second argument to ` proves ` .",
    "the reason is that backchaining on this clause requires higher - order matching , for which there can be more than one solution .",
    "one further criteria that we place on our proof checker is that it can not backtrack .",
    "thus we must include ` h ` and ` x ` explicitly in the proof term to prevent the possibility that when backchaining on this clause , a backtrack point is created by unification .",
    "we can , however , eliminate the typechecking subgoal for ` h ` because its well - typedness follows from the fact that ` ( h x ) ` has type ` form ` and ` x ` has type ` t ` .",
    "eliminating this subgoal from the clause in program  [ trans - rules - a ] gives us the clause in program  [ core - rules ] .",
    "after making analogous changes to all of the clauses in program  [ trans - rules - a ] , the only remaining difference in program  [ core - rules ] is the use of ` assump ` to identify assumptions added during proof checking , which as stated earlier , is not necessary , but is useful for various programming tasks in our proof - carrying code system .",
    "note that in making changes to the @xmath0prolog code , we have been careful not to complicate proof checking by requiring any more power from @xmath0prolog than was needed to execute the code obtained directly from the transformation .",
    "the same is not true for the twelf code . as stated earlier , the version that used abbreviations ( program  [ core - twelf ] ) needs more type reconstruction power than the version with all arguments explicitly included .    in summary",
    ", using the formal correspondence has provided a principled way to arrive at the versions of the encodings of the object logic in twelf ( program  [ core - twelf ] ) and @xmath0prolog(program  [ core - rules ] ) that we have compared .",
    "the main differences are ( 1 ) the twelf encoding is more concise because dependent types eliminate the need for explicit typechecking subgoals , and ( 2 ) in @xmath0prolog , unlike twelf , proof checking of the optimized version of the encoding is no more complex than proof checking the original .",
    "andrew  w. appel and amy  p. felty . a semantic model of types and machine instructions for proof - carrying code .",
    "in _ the 27th annual acm sigplan - sigact symposium on principles of programming languages _ , pages 243253 , 2000 .",
    "gopalan nadathur and dale miller .",
    "an overview of @xmath0prolog . in robert",
    "a. kowalski and kenneth  a. bowen , editors , _ fifth international conference and symposium on logic programming _ , pages 810827 . mit press , 1988 .",
    "gopalan nadathur and dustin .",
    "j. mitchell .",
    "system description : teyjus  a compiler and abstract machine based implementation of @xmath0prolog . in _ the 16th international conference on automated deduction _ ,",
    "pages 287291 .",
    "springer - verlag , july 1999 .",
    "gopalan nadathur and debra  sue wilson . a representation of lambda terms suitable for operations on their intensions . in _ proceedings of the 1990 acm conference on lisp and functional programming _ , pages 341348 , 1990 .",
    "frank pfenning and carsten schrmann .",
    "system description : twelf  a meta - logical framework for deductive systems . in _ the 16th international conference on automated deduction _ ,",
    "pages 202206 .",
    "springer - verlag , july 1999 ."
  ],
  "abstract_text": [
    "<S> @xmath0prolog  is known to be well - suited for expressing and implementing logics and inference systems . </S>",
    "<S> we show that lemmas and definitions in such logics can be implemented with a great economy of expression . </S>",
    "<S> we encode a higher - order logic using an encoding that maps both terms and types of the object logic ( higher - order logic ) to terms of the metalanguage ( @xmath0prolog ) . </S>",
    "<S> we discuss both the terzo and teyjus implementations of @xmath0prolog . </S>",
    "<S> we also encode the same logic in twelf and compare the features of these two metalanguages for our purposes . </S>"
  ]
}