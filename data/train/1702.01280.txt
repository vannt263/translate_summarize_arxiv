{
  "article_text": [
    "since its introduction at the 2009 prague stringology conference  @xcite , the problem of indexed binary jumbled pattern matching has been discussed in many top conferences and journals .",
    "it asks us to preprocess a binary string such that later , given a number of 0s and a number of 1s , we can quickly report whether there exists a substring with those numbers of 0s and 1s and , optionally , return the position of one such substring or possibly even all of them .",
    "the nave preprocessing algorithm takes quadratic time but researchers have reduced that bound to @xmath6  @xcite , @xmath7  @xcite , @xmath8  @xcite and finally @xmath9 with randomization or @xmath10 without  @xcite .",
    "researchers have also looked at indexing for approximate matching  @xcite , indexed jumbled pattern matching over larger alphabets  @xcite , indexing labelled trees and other structures  @xcite , and how to index faster when the ( binary ) input string is compressible .",
    "gagie et al .",
    "@xcite gave an algorithm that runs in @xmath11 when the input is represented as a straight - line program with @xmath12 rules , and badkobeh et al .",
    "@xcite gave one that runs in @xmath0 time when the input consists of @xmath2 runs , i.e. , maximal unary substrings ( we will denote later as @xmath2 the number of maximal substrings of 1s , for convenience ) . giaquinta and grabowski",
    "@xcite gave two algorithms : one runs in @xmath13 time , where @xmath14 is a parameter , and produces an index that uses @xmath15 extra space and answers queries in @xmath16 time ; the other runs in @xmath17 time , where @xmath18 is the size of a machine word .",
    "amir et al .",
    "@xcite gave an algorithm that runs in @xmath19 time when the input is a run - length encoded binary string , or @xmath0 time when it is a plain binary string ; it builds an index that takes @xmath20 words and answers queries in @xmath21 time , however .",
    "very recently , sugimoto et al .",
    "@xcite considered the related problems of finding abelian squares , abelian periods and longest common abelian factors , also on run - length encoded strings .",
    "we first review some preliminary notions in section  [ sec : pre ] .",
    "we present our main result in section  [ sec : alg ] : a new and very simple indexing algorithm that runs in @xmath3 time , which matches giaquinta and grabowski s algorithm with the parameter @xmath22 and is thus tied as the fastest known when @xmath23 and the smallest straight - line program for the input has @xmath24 rules . for an input string of up to ten million bits , for example , if the average run - length is three or more then @xmath25 .",
    "our algorithm takes only 17 lines of pseudocode , making it a promising starting point for investigating other possible algorithmic features . in section  [ sec : witness ] , for example , we show how to extend our algorithm to store information that lets us report the position of a match ( if there is one )",
    ". finally , in section  [ sec : workspace ] , we show how we can alternatively adapt it to use only @xmath5 bits of space .",
    "consider a string @xmath26 .",
    "we denote by @xmath27 $ ] the substring of @xmath28 consisting of the @xmath29th through @xmath30th characters , for @xmath31 ; if @xmath32 , we can also write simply @xmath33 $ ] .",
    "cicalese et al .",
    "@xcite observed that , if we slide a window of length @xmath14 over @xmath28 , the number of 1s in the window can change by at most 1 at each step .",
    "it follows that if @xmath34 $ ] contains @xmath35 copies of 1 and @xmath36 $ ] contains @xmath37 copies of 1 with @xmath38 then , for @xmath39 between @xmath35 and @xmath37 ( notice @xmath35 could be smaller than , larger than , or equal to @xmath37 ) , there is a substring of length @xmath14 in @xmath40 $ ] with exactly @xmath39 copies of 1 .",
    "this immediately implies the following theorem :    [ thm : table ] let @xmath35 and @xmath37 be the minimum and maximum numbers of 1s in any substring of length @xmath14 .",
    "there is a substring of length @xmath14 with @xmath39 copies of 1 if and only if @xmath41 .    by theorem  [ thm : table ] ,",
    "if we compute and store , for @xmath42 , the minimum and maximum numbers of 1s in a substring of @xmath28 of length @xmath14 then later , given a number of 0s and a number of 1s , we can report in constant time whether there exists a substring with that many 0s and 1s . for example , if @xmath43 then , as @xmath14 goes from 1 to @xmath44 , the minimum and maximum numbers of 1s are @xmath45 and @xmath46 , respectively . since the fifth numbers in these lists are 2 and 4 , we know , there are substrings of length 5 with exactly 2 , 3 and 4 copies of 1 , but none with 0 , 1 or 5 ( or more than 5 , obviously ) .",
    "cicalese et al .",
    "@xcite noted that , if we also store the positions of the substrings with the minimum and maximum numbers of 1s and a bitvector for @xmath28 that supports constant time rank queries , then via binary search in @xmath47 time we can find an example of a substring with any desired numbers of 0s and 1s , called a _ witness _ if such a substring exists .",
    "( the query @xmath48 returns the number of 1s in @xmath49 $ ] ; see , e.g. ,  @xcite for more details of rank queries on bitvectors . ) for example , suppose we want to find a substring of length 5 with exactly 3 copies of 1 in our example string @xmath28 .",
    "we have stored that there are substrings of length 5 with 2 and 4 copies of 1 starting at positions 1 and 4 , respectively , so we know there is a substring of length 5 with exactly 3 copies of 1 starting in @xmath50 $ ] .",
    "we choose @xmath51 and check how many 1s there are in @xmath52 $ ] via two rank queries . in this case",
    ", the answer is 3 , so we have found a witness in one step ; otherwise , we would know there is a witness starting in @xmath53 $ ] and we would recurse on that interval .",
    "the same authors noted that in each step , the lists of minimum and maximum numbers can only stay the same or increment , so we can represent each list as a bitvector of length @xmath1 and support access to it using rank queries .",
    "for example , the bitvector for the list of minimum numbers in our example is @xmath54 , so @xmath48 returns the @xmath29th number in the list .",
    "since an @xmath1-bit bitvector takes @xmath5 bits of space , it follows that we can store our index in @xmath5 bits and still support constant - time queries , if we do not want a witness .",
    "we note , however , that even though the input @xmath28 takes @xmath1 bits and the resulting index takes @xmath5 bits , all previous constructions have used @xmath55 _ words _ in the worst case .",
    "a _ run _ in @xmath28 is a maximal unary substring and the run - length encoding @xmath56 is obtained by replacing each run by a copy of the character it contains and its length . although @xmath2 is usually used to denote the number of runs , for convenience , we use it to denote only the number of runs of 1s  about half its normal value for binary strings  and consider @xmath28 to begin and end with ( possibly empty ) runs of 0s .",
    "for example , for our example string the run - length encoding is @xmath57 and @xmath58 ( instead of 9 ) .",
    "we denote the lengths of the runs of zeroes and 1s as @xmath59 , \\ldots , z [ \\rho]$ ] and @xmath60 , \\ldots , o [ \\rho]$ ] , respectively .",
    "since finding substrings with the minimum numbers of 1s is symmetric to finding substrings with the maximum numbers of 1s ( e.g. , by taking the complement of the string ) , we describe how , given a binary run - length encoded string @xmath61 $ ] , we can build a table @xmath62 $ ] such that @xmath63 = f ( k)$ ] , where @xmath64 denotes the maximum number of 1s in a substring of @xmath28 of length @xmath14 .    the complete pseudo - code of our algorithm  only 17 lines  is shown as algorithm  [ alg : index ] .",
    "the starting point of our explanation and proof of correctness is the observation that , if the bit immediately to the left of a substring is a 1 , we can shift the substring one bit left without decreasing the number of 1s ; if the first bit of the substring is a 0 , then we can shift the substring one bit right ( shortening it on the right if necessary ) without decreasing the number of 1s .",
    "it follows that , for @xmath42 , there is a substring of length at most @xmath14 containing @xmath64 copies of 1 and starting at the beginning of a run of 1s .",
    "since we can remove any trailing 0s from such a substring also without changing the number of 1s , there is such a substring that also ends in a run of 1s .",
    "therefore we have the following lemma :    [ lem : starting ] for @xmath42 , there is a substring of length at most @xmath14 containing @xmath64 copies of 1 , starting at the beginning of a run of 1s and ending in a run of 1s .",
    "applying lemma  [ lem : starting ] immediately yields an @xmath65-time algorithm : set @xmath62 $ ] to all 0s ; for each position @xmath29 at the beginning of a run of 1s and each position @xmath30 in a run of 1s , set @xmath66 = \\max ( t [ j - 1 + 1 ] , s [ i ] + \\cdots + s [ j])$ ] ; finally , because @xmath67 is non - decreasing , make a pass over @xmath68 from @xmath69 $ ] to @xmath70 $ ] setting each @xmath71 = \\max ( t [ i ] , t [ i - 1])$ ] . computing the number @xmath33 + \\cdots + s [ j]$ ] of 1s in a substring @xmath72 $ ] starting at the beginning of a run of 1s and ending in a run of 1s is easy to do from the run - length encoding in amortized constant time .    to speed this preliminary algorithm up to run in @xmath3 time , we first observe that , if @xmath73 is the length of a substring starting at the beginning of a run of 1s , ending in a run of 1s and containing @xmath74 copies of 1 , and @xmath75 is the length of a substring starting at the beginning of a run of 1s and ending at the end of a run of 1s , then @xmath76 .",
    "( in fact this is true for any @xmath73 and @xmath77 , simply because @xmath78 for all @xmath35 . )",
    "we then observe that , for some such @xmath79 , we have @xmath80 . to see why , consider any substring @xmath27 $ ] of length @xmath73 starting at the beginning of a run of 1s , ending within a run of 1s and containing @xmath74 copies of 1 :",
    "let @xmath79 be the length of the substring starting at @xmath33 $ ] and ending at the end of the run of 1s containing @xmath81 $ ] , so @xmath80 .",
    "[ lem : ending ] if @xmath73 is the length of a substring starting at the beginning of a run of 1s , ending in a run of 1s and containing @xmath74 copies of 1 , and @xmath75 is the length of a substring starting at the beginning of a run of 1s and ending at the end of a run of 1s , then @xmath76 .",
    "furthermore , for some such @xmath79 , we have @xmath80 .    with lemma  [ lem : ending ]",
    ", we can compute the number @xmath82 + \\cdots + s[j]$ ] of 1s in each substring @xmath72 $ ] starting at the beginning of a run of 1s and ending in a run of 1s , in a total of @xmath3 time : again , set @xmath62 $ ] to all 0s ; for each position @xmath29 at the beginning of a run of 1s and each position @xmath30 at the end of a run of 1s , set @xmath66 = \\max ( t [ j - 1 + 1 ] , s [ i ] + \\cdots + s [ j])$ ] ; make a pass over @xmath68 from @xmath83 $ ] to @xmath84 $ ] setting each @xmath71 = \\max ( t [ i ] , t [ i + 1 ] - 1)$ ] . computing the number @xmath33 + \\cdots + s [ j]$ ] of 1s in a substring",
    "@xmath27 $ ] starting at the beginning of a run of 1s and ending at the end of a run of 1s is again easy to do from the run - length encoding in amortized constant time .    combining lemmas  [ lem : starting ] and  [ lem : ending ] , we have a complete algorithm for computing @xmath68 in @xmath3 time : set @xmath62 $ ] to all 0s ; for each position @xmath29 at the beginning of a run of 1s and each position @xmath30 at the end of a run of 1s , set @xmath66 = \\max ( t [ j - 1 + 1 ] , s [ i ] + \\cdots + s [ j])$ ] ; make a pass over @xmath68 from @xmath83 $ ] to @xmath84 $ ] setting each @xmath71 = \\max ( t [ i ] , t [ i + 1 ] - 1)$ ] ( which sets @xmath85 $ ] correctly for every length @xmath73 of a substring starting at the beginning of a run of 1s , ending in a run of 1s and containing @xmath74 copies of 1 ) ; and make a pass over @xmath68 from @xmath69 $ ] to @xmath70 $ ] setting each @xmath71 = \\max ( t [ i ] , t [ i - 1])$ ] ( which sets every entry in @xmath68 correctly ) .",
    "once we have @xmath68 , we can convert it into a bitvector in @xmath5 time .",
    "summarizing our results so far , we have the following theorem , which we adapt in later sections :    [ thm : main ] given a binary string @xmath28 of length @xmath1 containing @xmath2 runs of 1s , we can build an @xmath5-bit index for constant - time jumbled pattern matching in @xmath3 time .",
    "now we examine how our algorithm works on our example @xmath43 .",
    "first we set all entries of @xmath68 to 0 , then we loop through the runs of 1s and , for each , loop through the runs of 1s not earlier , computing distance from the start of the first to the end of the second and the number of 1s between those positions . while doing this , we set @xmath84 = 1 $ ] , the number of 1s from the start to the end of the first run of 1s ; @xmath86 = 2 $ ] , the number of 1s from the start of the first run of 1s to the end of the second run of 1s ; @xmath87 = 5 $ ] , the number of 1s from the start of the first run of 1s to the end of the third run of 1s ; @xmath88 = 7 $ ] , the number of 1s from the start of the first run of 1s to the end of the fourth run of 1s ; @xmath89 = 4 $ ] , the number of 1s from the start of the second run of 1s to the end of the third run ; etc . when we have finished this stage , @xmath90 $ ] .",
    "we then make a pass over @xmath68 from right to left , setting each @xmath71 = \\max ( t [ i ] , t [ i + 1 ] - 1)$ ] . after this stage , @xmath91 $ ] .",
    "finally , we make a pass over @xmath68 from left to right , setting each @xmath71 = \\max ( t [ i ] , t [ i - 1])$ ] .",
    "this fills in @xmath92 $ ] and leaves @xmath68 correctly computed as @xmath93 $ ] .",
    "as described in section  [ sec : pre ] , if together with computing the minimum and maximum number of 1s in a substring of length @xmath14 for @xmath42 , we also store the positions of substrings of length  @xmath14 with those numbers of 1s , and a single bitvector for @xmath28 , then , together with confirming that @xmath28 contains a substring with a given number of 0s and 1s ( if it does ) , we can give the starting position of such a substring , still in constant time .    in this section ,",
    "we show how to modify our algorithm from section  [ sec : alg ] to build also a table @xmath94 $ ] such that @xmath95 $ ] is the starting position of a substring of length @xmath14 containing @xmath64 copies of 1s .",
    "computing and storing the starting position of a substring of length @xmath14 with the minimum number of 1s is symmetric .",
    "first , notice that during the first stage of algorithm  [ alg : index ] , whenever we set @xmath63 = f ( k)$ ] , we have found a substring of length @xmath14 containing @xmath64 copies of 1 , so we can set @xmath95 $ ] at the same time .",
    "now consider the second stage of the algorithm , in which we make a right - to - left pass over @xmath68 setting @xmath71 = \\max ( t [ i ] , t [ i + 1 ] - 1)$ ] for @xmath96 .",
    "when we start this stage , for every positive entry in @xmath68 we have set the corresponding entry in @xmath97 .",
    "therefore , by induction , whenever we set @xmath71 = t [ i + 1 ] - 1 $ ] , we have @xmath98 $ ] set to the starting position of a substring of length @xmath99 containing @xmath100 $ ] copies of 1 .",
    "the substring of length @xmath29 starting at @xmath98 $ ] contains at least @xmath100 - 1 $ ] copies of 1 , so we can set @xmath101 = p [ i + 1]$ ] . in the last stage of the algorithm ,",
    "in which we make a left - to - right pass over @xmath68 , we can almost use the same kind of argument and simply copy @xmath97 values when we copy @xmath68 values , except that we must ensure the starting positions we copy are far enough to the left of the end of the string ( i.e. , that the substrings have the correct lengths ) .",
    "our modified algorithm is shown as algorithm  [ alg : witness ]  still only 25 lines  and we now have the following theorem :    [ thm : witness ] given a binary string @xmath28 of length @xmath1 containing @xmath2 runs of 1s , we can build an @xmath5-word index for constant - time jumbled pattern matching _ with witnessing _ in @xmath3 time .    running our modified algorithm on our example @xmath43 , in the first stage we set @xmath90 $ ] and , simultaneously , @xmath102 $ ] , where 0 indicates an unset value in @xmath97 . in the second stage",
    ", we set @xmath91 $ ] and @xmath103 $ ] .",
    "finally , in the third stage , we fill in @xmath92 = t [ 11]$ ] , but we can not just set @xmath104 = p [ 11 ] = 2 $ ] because @xmath105 $ ] has length only 11 , so we set @xmath104 = 1 $ ]",
    ".    @xmath106 $ ]",
    "it is frustrating that both @xmath28 and the index described in theorem  [ thm : main ] take @xmath5 bits , but we use @xmath5 words to build the index . in this section ,",
    "we show how to reduce this workspace to @xmath5 bits also , without increasing the time bound for construction by more than a constant factor .",
    "suppose we divide @xmath68 into blocks of size @xmath107 and modify our algorithm such that , whenever we set a value @xmath71 $ ] , we ensure that each value @xmath108 $ ] in the same block with @xmath109 is at least @xmath71 - i + j$ ] and each value @xmath108 $ ] in the same block with @xmath110 is at least @xmath71 $ ] .",
    "since we would eventually set each such @xmath108 $ ] to a value at least as great during the normal execution of the algorithm , this does not change its correctness , apart from perhaps slowing it down by an @xmath47 factor .",
    "for any two consecutive values @xmath71 $ ] and @xmath100 $ ] in the same block now , however , we have @xmath71 \\leq t [ i + 1 ] \\leq t [ i ] + 1 $ ] . we can thus store each block by storing its first value and a binary string of length @xmath107 whose bits indicate where the values in the block increase .",
    "therefore , we need a total of only @xmath5 bits to store all the blocks .",
    "notice that , if we increase a value @xmath71 $ ] by more than @xmath107 , we reset the first value @xmath111 $ ] of the block to be @xmath71 - i + h$ ] , set the leading bits of the block to 1s to indicate that the values increase until reaching @xmath71 $ ] , and set the later bits of the block to 0s to indicate that the values remain equal to @xmath71 $ ] until the end of the block .",
    "therefore , we can speed the algorithm up to run in @xmath3 time again , by using a universal table of size @xmath112 to decide how to update blocks when we set values in them .",
    "[ thm : workspace ] given a binary string @xmath28 of length @xmath1 containing @xmath2 runs of 1s , we can build an @xmath5-bit index for constant - time jumbled pattern matching in @xmath3 time using @xmath5 bits of workspace .",
    "in fact , it seems possible to make the algorithm run in @xmath3 time and @xmath5 bits of space even without a universal table , using ac0 operations on words that are available on standard architectures .",
    "this workspace reduction makes little sense for a string as small as our example @xmath43 but , for the sake of argument , suppose we partition our array @xmath68 for it into three blocks of length 4 each .",
    "we keep @xmath84 $ ] , @xmath89 $ ] and @xmath113 $ ] stored explicitly and represent the other entries of @xmath68 implicitly with three 3-bit binary strings @xmath114 , @xmath115 and @xmath116 .",
    "initially we set @xmath84 = t [ 5 ] = t [ 9 ] = 0 $ ] and @xmath117 .",
    "recall from section  [ sec : alg ] that we first set @xmath84 = 1 $ ] , the number of 1s from the start to the end of the first run of 1s . at this point , we do not need to change @xmath114 .",
    "we then set @xmath86 = 2 $ ]  the number of 1s from the start of the first run of 1s to the end of the second run of 1s  by setting @xmath118 : starting from @xmath84 = 1 $ ] , this encodes @xmath69 = t [ 1 ] + 0 = 1 $ ] , @xmath86 = t [ 1 ] + 0 + 1 = 2 $ ] and @xmath119 = t [ 1 ] + 0 + 1 + 0 = 2 $ ] .",
    "next we set @xmath87 = 5 $ ]  the number of 1s from the start of the first run of 1s to the end of the third run of 1s  by setting @xmath89 = 3 $ ] and @xmath120 : starting from @xmath89 = 3 $ ] , this encodes @xmath121 = t [ 5 ] + 1 = 4 $ ] , @xmath87 = t [ 5 ] + 1 + 1 = 5 $ ] and @xmath122 = t [ 5 ] + 1 + 1 + 0 = 5 $ ] .",
    "continuing like this , we set @xmath88 = 7 $ ] by setting @xmath113 = 5 $ ] and @xmath123 ; set @xmath89 = 4 $ ] and @xmath124 ; etc .",
    "when we are finished this stage , @xmath84 = 1 $ ] , @xmath89 = 4 $ ] and @xmath113 = 6 $ ] , and @xmath125 , @xmath124 and @xmath126 , encoding @xmath93 $ ] . in this case",
    "the final right - to - left and left - to - right passes have no effect , but there are cases ( e.g. , when we do not set any values in a certain block ) when they are still necessary .",
    "amihood amir , alberto apostolico , tirza hirst , gad  m landau , noa lewenstein , and liat rozenberg .",
    "algorithms for jumbled indexing , jumbled border and jumbled square on run - length encoded strings . , 656:146159 , 2016 .",
    "amihood amir , timothy  m chan , moshe lewenstein , and noa lewenstein . on hardness of jumbled indexing . in _ proceedings of the international colloquium on automata , languages , and programming ( icalp ) _ ,",
    "pages 114125 .",
    "springer , 2014 .",
    "david bremner , timothy  m chan , erik  d demaine , jeff erickson , ferran hurtado , john iacono , stefan langerman , mihai ptracu , and perouz taslakian .",
    "necklaces , convolutions , and x+ y. , 69(2):294314 , 2014 .",
    "pter burcsi , ferdinando cicalese , gabriele fici , and zsuzsanna liptk . on table arrangements , scrabble freaks , and jumbled pattern matching .",
    "in _ proceedings of the international conference on fun with algorithms ( fun ) _ , pages 89101 .",
    "springer , 2010 .",
    "timothy  m chan and moshe lewenstein .",
    "clustered integer 3sum via additive combinatorics . in",
    "_ proceedings of the forty - seventh annual acm on symposium on theory of computing ( stoc ) _ , pages 3140 .",
    "acm , 2015 .",
    "ferdinando cicalese , travis gagie , emanuele giaquinta , eduardo  sany laber , zsuzsanna liptk , romeo rizzi , and alexandru  i tomescu .",
    "indexes for jumbled pattern matching in strings , trees and graphs . in _ proceedings of the international symposium on string processing and information retrieval ( spire ) _ , pages 5663 .",
    "springer , 2013 .",
    "ferdinando cicalese , eduardo laber , oren weimann , and raphael yuster .",
    "near linear time construction of an approximate index for all maximum consecutive sub - sums of a sequence . in _ proceedings of the annual symposium on combinatorial",
    "pattern matching ( cpm ) _ , pages 149158 .",
    "springer , 2012 .",
    "stephane durocher , robert fraser , travis gagie , debajyoti mondal , matthew skala , and sharma  v thankachan .",
    "indexed geometric jumbled pattern matching . in _ proceedings of the annual symposium on combinatorial pattern matching ( cpm ) _ ,",
    "pages 110119 .",
    "springer , 2014 .",
    "tomasz kociumaka , jakub radoszewski , and wojciech rytter .",
    "efficient indexes for jumbled pattern matching with constant - sized alphabet . in",
    "_ proceedings of the european symposium on algorithms ( esa ) _ , pages 625636 .",
    "springer , 2013 ."
  ],
  "abstract_text": [
    "<S> important papers have appeared recently on the problem of indexing binary strings for jumbled pattern matching , and further lowering the time bounds in terms of the input size would now be a breakthrough with broad implications . </S>",
    "<S> we can still make progress on the problem , however , by considering other natural parameters . </S>",
    "<S> badkobeh et al .  </S>",
    "<S> ( ipl , 2013 ) and amir et al .  ( tcs , 2016 ) gave algorithms that index a binary string in @xmath0 time , where @xmath1 is the length and @xmath2 is the number of runs , and giaquinta and grabowski ( ipl , 2013 ) gave one that runs in @xmath3 time . </S>",
    "<S> in this paper we propose a new and very simple algorithm that also runs in @xmath4 time and can be extended either so that the index returns the position of a match ( if there is one ) , or so that the algorithm uses only @xmath5 bits of space . </S>"
  ]
}