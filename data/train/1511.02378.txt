{
  "article_text": [
    "distributed storage is a popular method to store files securely without requiring data encryption . instead of storing a file and its replications in multiple servers",
    ", we can break the file into components and store the components into multiple servers . in this way , both the reliability and the security of the file can be increased .",
    "a typical approach is to encode the file using an @xmath1 reed - solomon ( rs ) code and distribute the encoded file into @xmath2 servers .",
    "when we need to recover the file , we only need to collect the encoded parts from @xmath3 servers , which achieves a trade - off between reliability and efficiency .",
    "however , when repairing or regenerating the contents of a failed node , the whole file has to be recovered first , which is a waste of bandwidth .",
    "the concept of regenerating code was introduced in  @xcite , where a replacement node is allowed to connect to some individual nodes directly and regenerate a substitute of the failed node , instead of first recovering the original data then regenerating the failed component . compared to the rs code",
    ", regenerating code achieves an optimal tradeoff between bandwidth and storage within the minimum storage regeneration ( msr ) and the minimum bandwidth regeneration ( mbr ) points .",
    "however , when malicious behaviors exist in the network , both the regeneration of the failed node or the reconstruction of the original file will fail .",
    "the error resilience of the reed - solomen code based regenerating code in the network with errors and erasures was analyzed in  @xcite . in our previous work ,",
    "a hermitian code based regenerating code was proposed to provide better error correction capability compared to the reed - solomen code based approach .    inspired by the nice performance of hermitian code based regenerating codes , in this paper we step forward to further construct optimal regenerating codes which have similar layered structure like hermitian code in distributed storage .",
    "the main contributions of this paper are :    * we propose an optimal construction of 2-layer rate - matched regenerating code .",
    "both theoretical analysis and performance evaluation show that this code can achieve storage efficiency higher than the universally resilient regenerating code proposed in  @xcite .",
    "* we propose an optimal construction of @xmath0-layer rate - matched regenerating code .",
    "the @xmath0-layer code can achieve higher error correction efficiency than the code proposed in  @xcite and the hermitian code based regenerating code proposed in  @xcite .",
    "furthermore , the @xmath0-layered code is easier to understand and has more flexibility than the hermitian based code .    here",
    "we will focus on error correction and malicious node locating in data regeneration and reconstruction in distributed storage .",
    "when no error occurs or no malicious node exists , the data regeneration and reconstruction can be processed the same as the existing works .",
    "it it worth to note that although there are two types of regenerating codes : msr code and mbr code on the msr point and mbr point respectively , in this paper we will only focus on the optimization of the msr code for the following two reasons :    1 .",
    "the processes and results of the optimization for these two codes are similar .",
    "the optimization for the msr code can be directly applied to the mbr code with similar optimization results .",
    "the differences between the constructions of msr code and mbr code have little impact on the optimization proposed in this paper .",
    "the rest of this paper is organized as follows : in section  [ sec : related ] we introduce the related work . in section  [ sec : preliminary ] , the preliminary of this paper is presented . in section  [ sec",
    ": rate - matched - msr ] , we propose two component codes for the rate - matched regenerating codes .",
    "we propose and analyze the 2-layer rate - matched regenerating code in section  [ sec:2-layer ] . then we propose and analyze the @xmath0-layer rate - matched regenerating code in section  [ sec : m_layer_msr ] .",
    "the paper is concluded in section  [ sec : conclusion ] .",
    "when a storage node in the distributed storage network that employing the conventional @xmath1 rs code ( such as oceanstore  @xcite and total recall  @xcite ) fails , the replacement node connects to @xmath3 nodes and downloads the whole file to recover the symbols stored in the failed node .",
    "this approach is a waste of bandwidth because the whole file has to be downloaded to recover a fraction of it . to overcome this drawback , dimakis _",
    "et al_.  @xcite introduced the conception of @xmath4 regenerating code based on the network coding . in the context of regenerating code , the contents stored in a failed node can be regenerated by the replacement node through downloading @xmath5 help symbols from @xmath6 helper nodes .",
    "the bandwidth consumption for the failed node regeneration could be far less than the whole file .",
    "a data collector  ( dc ) can reconstruct the original file stored in the network by downloading @xmath7 symbols from each of the @xmath3 storage nodes . in  @xcite",
    ", the authors proved that there is a tradeoff between bandwidth @xmath5 and per node storage @xmath7 .",
    "they found two optimal points : minimum storage regeneration ( msr ) and minimum bandwidth regeneration ( mbr ) points .",
    "currently there are many literatures focusing on the optimal regenerating codes design : @xcite . in  @xcite the implementation of the regenerating code were studied .",
    "the regenerating code can be divided into functional regeneration and exact regeneration . in the functional regeneration ,",
    "the replacement node regenerates a new component that can functionally replace the failed component instead of being the same as the original stored component .",
    "@xcite formulated the data regeneration as a multicast network coding problem and constructed functional regenerating codes .",
    "@xcite implemented a random linear regenerating codes for distributed storage systems .",
    "@xcite proved that by allowing data exchange among the replacement nodes , a better tradeoff between repair bandwidth @xmath5 and per node storage @xmath7 can be achieved . in the exact regeneration",
    ", the replacement node regenerates the exact symbols of a failed node .",
    "@xcite proposed to reduce the regeneration bandwidth through algebraic alignment .",
    "@xcite provided a code structure for exact regeneration using interference alignment technique .",
    "@xcite presented optimal exact constructions of mbr codes and msr codes under product - matrix framework .",
    "this is the first work that allows independent selection of the nodes number @xmath2 in the network .    none of these works above considered code regeneration under node corruption or adversarial manipulation attacks in hostile networks .",
    "in fact , all these schemes will fail in both regeneration and reconstruction if there are nodes in the storage cloud sending out incorrect responses to the regeneration and reconstruction requests .    in  @xcite ,",
    "the byzantine fault tolerance of regenerating codes were studied . in  @xcite ,",
    "the authors discussed the amount of information that can be safely stored against passive eavesdropping and active adversarial attacks based on the regeneration structure . in  @xcite , the authors proposed to add crc codes in the regenerating code to check the integrity of the data in hostile networks .",
    "unfortunately , the crc checks can also be manipulated by the malicious nodes , resulting in the failure of the regeneration and reconstruction . in  @xcite ,",
    "the authors proposed to add data integrity protection in distributed storage . in  @xcite , the authors proposed an erasure - coded distributed storage based on threshold cryptography . in  @xcite , the authors analyzed the verification cost for both the client read and write operation in workloads with idle periods . in  @xcite",
    ", the authors analyzed the error resilience of the rs code based regenerating code in the network with errors and erasures .",
    "they provided the theoretical error correction capability . in @xcite",
    "the authors proposed a hermitian code based regenerating code , which could provide better error correction capability . in  @xcite",
    "the authors proposed the universally secure regenerating code to achieve information theoretic data confidentiality .",
    "but the extra computational cost and bandwidth have to be considered for this code . in @xcite",
    "the authors proposed to apply linear feedback shift register ( lfsr ) to protect the data confidentiality .",
    "[ sec : preliminary ]      regenerating code introduced in  @xcite is a linear code over finite filed @xmath8 with a set of parameters @xmath4 . a file of size @xmath9 is stored in @xmath2 storage nodes , each of which stores @xmath7 symbols .",
    "a replacement node can regenerate the contents of a failed node by downloading @xmath10 symbols from each of @xmath6 randomly selected storage nodes .",
    "so the total bandwidth needed to regenerate a failed node is @xmath11 .",
    "the data collector ( dc ) can reconstruct the whole file by downloading @xmath7 symbols from each of @xmath12 randomly selected storage nodes . in  @xcite , the following theoretical bound was derived : @xmath13 from equation  ( [ eq : min_cut ] ) , a trade - off between the regeneration bandwidth @xmath5 and the storage requirement @xmath7 was derived . @xmath5 and @xmath7 can not be decreased at the same time .",
    "there are two special cases : minimum storage regeneration ( msr ) point in which the storage parameter @xmath7 is minimized ; @xmath14 and minimum bandwidth regeneration ( mbr ) point in which the bandwidth @xmath5 is minimized : @xmath15      in this paper , we assume there is a secure server that is responsible for encoding and distributing the data to storage nodes .",
    "replacement nodes will also be initialized by the secure server .",
    "dc and the secure server can be implemented in the same computer and can never be compromised .",
    "we use the notation @xmath16/@xmath17 to refer to either the full rate / fractional rate msr code or a codeword of the full rate / fractional rate msr code .",
    "the exact meaning can be discriminated clearly according to the context .",
    "we assume some network nodes may be corrupted due to hardware failure or communication errors , and/or be compromised by malicious users . as a result , upon request , these nodes may send out incorrect responses to disrupt the data regeneration and reconstruction .",
    "the adversary model is the same as  @xcite , we assume that the malicious users can take full control of @xmath18 ( @xmath19 and corresponds to @xmath20 in  @xcite ) storage nodes and collude to perform attacks",
    ".    we will refer these symbols as _ bogus _ symbols without making distinction between the corrupted symbols and compromised symbols .",
    "we will also use corrupted nodes , malicious nodes and compromised nodes interchangeably without making any distinction .",
    "in this section , we will introduce two different component codes for rate - matched msr code on the msr point with @xmath21 .",
    "the code based on the msr point with @xmath22 can be derived the same way through truncating operations . in the rate - matched msr code",
    ", there are two types of msr codes with different code rates : full rate code and fractional rate code .",
    "the full rate code is encoded based on the product - matrix code framework in  @xcite . according to equation  ( [ eq : msr_tradeoff ] )",
    ", we have @xmath23 , @xmath24 for one block of data with the size @xmath25 .",
    "the data will be arranged into two @xmath26 symmetric matrices @xmath27 , each of which will contain @xmath28 data .",
    "the codeword @xmath16 is defined as @xmath29 \\begin{bmatrix } s_1 \\\\",
    "s_2 \\end{bmatrix } = \\psi m_h=\\begin{bmatrix}\\ch_1\\\\ \\vdots\\\\ \\ch_n\\end{bmatrix},\\ ] ] where @xmath30 is a vandermonde matrix and @xmath31 $ ] such that @xmath32 and @xmath33 for @xmath34 , @xmath35 is a primitive element in @xmath8 , and any @xmath6 rows of @xmath36 are linearly independent .",
    "then each row @xmath37 ( @xmath38 ) of the codeword matrix @xmath16 will be stored in storage node @xmath39 , where the encoding vector @xmath40 is the @xmath41 row of @xmath36 .",
    "suppose node @xmath42 fails , the replacement node @xmath43 will send regeneration requests to the rest of @xmath44 helper nodes . upon receiving the regeneration request ,",
    "helper node @xmath39 will calculate and send out the help symbol @xmath45 , where @xmath46 is the @xmath47 row of @xmath48 .",
    "@xmath43 will perform algorithm  [ alg : reg_h ] to regenerate the contents of the failed node @xmath42 . for convenience , we define @xmath49 where @xmath50 is the @xmath51 row of @xmath36 @xmath52 and @xmath53 is the vector containing the first @xmath54 symbols of @xmath55 .",
    "suppose @xmath56 is the response from the @xmath41 helper node .",
    "if @xmath57 has been modified by the malicious node @xmath39 , we have @xmath58 .",
    "we can successfully regenerate the symbols in node @xmath42 when the number of errors in the received help symbols @xmath59 from @xmath44 helper nodes is less than @xmath60 , where @xmath61 is the floor operation . without loss of generality , we assume @xmath62 .",
    "@xmath43 regenerates symbols of the failed node @xmath42 [ alg : reg_h ]    * step n : *    decode @xmath63 to @xmath64 , where @xmath65^t$ ] can be viewed as an mds code with parameters @xmath66 since @xmath67 .",
    "solve @xmath68 and compute @xmath69 as described in  @xcite .    for regeneration , the full rate code can correct errors from @xmath70 malicious nodes , where @xmath61 is the floor operation .",
    "when the dc needs to reconstruct the original file , it will send reconstruction requests to @xmath2 storage nodes . upon receiving the request",
    ", node @xmath39 will send out the symbol vector @xmath71 to the dc .",
    "suppose @xmath72 is the response from the @xmath41 storage node . if @xmath71 has been modified by the malicious node @xmath39 , we have @xmath73 .",
    "the dc will reconstruct the file as follows : let @xmath74^t$ ] , we have @xmath75   \\begin{bmatrix } s'_1\\\\ s'_2 \\end{bmatrix }   = r',\\ ] ] @xmath76    let @xmath77 , @xmath78 , and @xmath79 , then @xmath80 since @xmath81 are both symmetric , we can solve the non - diagonal elements of @xmath81 as follows : @xmath82 because matrices @xmath83 and @xmath84 have the same structure , here we only focus on @xmath83 ( corresponding to @xmath85 ) .",
    "it is straightforward to see that if node @xmath39 is malicious and there are errors in the @xmath41 row of @xmath86 , there will be errors in the @xmath41 row of @xmath87 .",
    "furthermore , there will be errors in the @xmath41 row and @xmath41 column of @xmath83 .",
    "define @xmath88 , we have @xmath89 . here",
    "we can view each column of @xmath83 as an @xmath90 mds code because @xmath48 is a vandermonde matrix .",
    "the length of the code is @xmath91 since the diagonal elements of @xmath83 is unknown .",
    "suppose node @xmath54 is a legitimate node , we can decode the mds code to recover the @xmath92 column of @xmath83 and locate the malicious nodes",
    ". eventually @xmath83 can be recovered .",
    "so the dc can reconstructs @xmath93 using the method similar to  @xcite , for @xmath94 , the recovering process is similar .    for reconstruction , the full rate code can correct errors from @xmath95 malicious nodes .        for the fractional rate code",
    ", we also have @xmath96 , @xmath97 for one block of data with the size @xmath98\\\\   & \\!\\alpha(\\alpha \\ ! \\!+ \\!\\!1)/2\\ ! + \\!\\ !",
    "( x \\!-\\!0.5)d(1\\!\\!+\\!\\!(x\\!-\\!0.5)d)/2 , & x \\in\\!\\ !",
    "( 0.5,\\!1 ] \\end{matrix}\\right.,\\ ] ] where @xmath99 is the match factor of the rate - matched msr code .",
    "it is easy to see that the fractional rate code will become the full rate code with @xmath100 .",
    "the data @xmath101 \\in(\\mathbb{f}_q)^{b_l}$ ] will be processed as follows :    when @xmath102 , the data will be arranged into a symmetric matrix @xmath93 of the size @xmath26 : @xmath103 the codeword @xmath17 is defined as @xmath104 \\begin{bmatrix } s_1 \\\\ \\mathbf{0 } \\end{bmatrix } = \\psi m_l,\\ ] ] where @xmath105 is the @xmath26 zero matrix and @xmath106 are the same as the full rate code .    when @xmath107 , the first @xmath108 data will be arranged into an @xmath26 symmetric matrix @xmath93 .",
    "the rest of the data @xmath109 will be arranged into another @xmath26 symmetric matrix @xmath94 : @xmath110 the codeword @xmath17 is defined the same as equation  ( [ eq : encoding_msr_h ] ) with the same parameters @xmath111 and @xmath36 .",
    "then each row @xmath112 ( @xmath38 ) of the codeword matrix @xmath17 will be stored in storage node @xmath39 respectively , in which the encoding vector @xmath40 is the @xmath41 row of @xmath36 .",
    "the fractional rate code can achieve the msr point in equation  ( [ eq : msr_tradeoff ] ) since it it encoded under the product - matrix msr code framework in  @xcite .",
    "the regeneration for the fractional rate code is the same as the regeneration for the full rate code described in section  [ sec : reg_high_rate ] with only a minor difference .",
    "if we define @xmath53 as the vector containing the first @xmath54 symbols of @xmath113 , there will be only @xmath114 nonzero elements in the vector . according to @xmath115 ,",
    "the received symbol vector @xmath63 for the fractional rate code in * step 1 * of algorithm  [ alg : reg_h ] can be viewed as an @xmath116 mds code . since @xmath117",
    ", we can detect and correct more errors in data regeneration using the fractional rate code than using the full rate code .    for regeneration , the fractional rate code can correct errors from @xmath118 malicious nodes .",
    "the reconstruction for the fractional rate code is similar to that for the full rate code described in section  [ sec : rec_high_rate ] .",
    "let @xmath119^t$ ] .    when the match factor @xmath107 , reconstruction for the fractional rate code is the same to that for the full rate code .    when @xmath120 , equation  ( [ eq : rec_eqn ] ) can be written as : @xmath121 so we can view each column of @xmath86 as an @xmath122 mds code .",
    "after decoding @xmath86 to @xmath123 , we can recover the data matrix @xmath93 by solving the equation @xmath124 meanwhile , if the @xmath41 rows of @xmath86 and @xmath123 are different , we can mark node @xmath39 as corrupted .    for reconstruction ,",
    "when the match factor @xmath107 , the fractional rate code can correct errors from @xmath95 malicious nodes . when the match factor @xmath102 , the fractional rate code can correct errors from @xmath125 malicious nodes .",
    "in this section , we will show our first optimization of the rate - matched msr code : 2-layer rate - matched msr code . in the code design",
    ", we utilize two layers of the msr code : the fractional rate code for one layer and the full rate code for the other .",
    "the purpose of the fractional rate code is to correct the erroneous symbols sent by malicious nodes and locate the corresponding malicious nodes .",
    "then we can treat the errors in the received symbols as erasures when regenerating with the full rate code .",
    "however , the rates of the two codes must match to achieve an optimal performance .",
    "here we mainly focus on the rate - matching for data regeneration .",
    "we can see in the later analysis that the performance of data reconstruction can also be improved with this design criterion .",
    "we will first fix the error correction capabilities of the full rate code and the fractional rate code .",
    "then we will derive the optimal rate matching criteria to optimize the data storage efficiency under the fixed error correction capability .      from the analysis above ,",
    "we know that during regeneration , the fractional rate code can correct up to @xmath126 errors , which are more than @xmath127 errors that the full rate code can correct . in the 2-layer rate - matched msr code design ,",
    "our goal is to match the fractional rate code with the full rate code .",
    "the main task for the fractional rate code is to detect and correct errors , while the main task for the full rate code is to maintain the storage efficiency .",
    "so if the fractional rate code can locate all the malicious nodes , the full rate code can simply treat the symbols received from these malicious nodes as erasures , which requires the minimum redundancy for the full rate code .",
    "the full rate code can correct up to @xmath128 erasures .",
    "thus we have the following optimal rate - matching equation : @xmath129 from which we can derive the match factor @xmath99 .      to encode a file with size @xmath130 using the 2-layer rate - matched msr code , the file",
    "will first be divided into @xmath131 blocks of data with the size @xmath132 and @xmath133 blocks of data with the size @xmath134 , where the parameters should satisfy @xmath135 then the @xmath131 blocks of data will be encoded into code matrices @xmath136 using the full rate code and the @xmath133 blocks of data will be encoded into code matrices @xmath137 using the fractional rate code . to prevent the malicious nodes from corrupting the fractional rate code only",
    ", the secure server will randomly concatenate all the matrices together to form the final @xmath138 codeword matrix : @xmath139,\\ ] ] where @xmath140 is the random matrices permutation operation .",
    "the secure sever will also record the order of the permutation for future code regeneration and reconstruction .",
    "then each row @xmath141 $ ] ( @xmath142 ) of the codeword matrix @xmath143 will be stored in storage node @xmath39 , where @xmath144 is the @xmath41 row of @xmath145 ( @xmath146 ) , and @xmath147 is the @xmath41 row of @xmath148 ( @xmath149 ) .",
    "the encoding vector @xmath40 for storage node @xmath39 is the @xmath41 row of @xmath36 in equation  ( [ eq : encoding_msr_h ] ) .",
    "therefore , we have the following theorem .",
    "the encoding of 2-layer rate - matched msr code can achieve the msr point in equation  ( [ eq : msr_tradeoff ] ) since both the full rate code and the fractional code are msr codes .",
    "suppose node @xmath42 fails , the security server will initialize a replacement node @xmath43 with the order information of the fractional rate code and the full rate code in the 2-layer rate - matched msr code .",
    "then the replacement node @xmath43 will send regeneration requests to the rest of @xmath44 helper nodes . upon receiving the regeneration request ,",
    "helper node @xmath39 will calculate and send out the help symbol @xmath150 .",
    "@xmath43 will perform algorithm  [ alg : reg_rate_matched ] to regenerate the contents of the failed node @xmath42 . after the regeneration is finished",
    ", @xmath43 will erase the order information .",
    "so even if @xmath43 was compromised later , the adversary would not get the permutation order of the fractional rate code and the full rate code .",
    "@xmath43 regenerates symbols of the failed node @xmath42 for the 2-layer rate - matched msr code [ alg : reg_rate_matched ]    * step",
    "n : *    according to the order information , regenerate all the symbols related to the @xmath133 data blocks encoded by the fractional rate code , using algorithm  [ alg : reg_h ] . if errors are detected in the symbols sent by node @xmath39 , it will be marked as a malicious node .",
    "regenerate all the symbols related to the @xmath131 data blocks encoded by the full rate code , using algorithm  [ alg : reg_h ] . during the regeneration ,",
    "all the symbols sent from nodes marked as malicious nodes will be replaced by erasures @xmath151 .",
    "it is easy to see that algorithm  [ alg : reg_rate_matched ] can correct errors and locate malicious node using the fractional rate code while achieve high storage efficiency using the full rate code .",
    "we summarize the result as the following theorem .    for regeneration , the 2-layer rate - matched msr code can correct errors from @xmath118 malicious nodes .",
    "we have the following design requirements for a given distributed storage system applying the 2-layer rate - matched msr code :    * the maximum number of malicious nodes @xmath152 that the system can detect and locate using the fractional rate code .",
    "we have @xmath153 * the probability @xmath154 that the system can detect all the malicious nodes .",
    "the detection will be successful if each malicious node modifies at least one help symbol corresponding to the fractional rate code and sends it to the replacement node .",
    "suppose the malicious nodes modify each help symbol to be sent to the replacement node with probability @xmath155 , we have @xmath156    so there is a trade - off between @xmath133 and @xmath131 : the number of data blocks encoded by the fractional rate code and the number of data blocks encoded by the full rate code .",
    "if we encode using too much full rate code , we may not meet the detection probability @xmath154 requirement .",
    "if too much fractional rate code is used , the redundancy may be too high .",
    "the storage efficiency is defined as the ratio between the actual size of data to be stored and the total storage space needed by the encoded data : @xmath157 thus we can calculate the optimized parameters @xmath99 , @xmath6 , @xmath131 , @xmath133 by maximizing equation  ( [ eq : efficiency ] ) under the constraints defined by equations  ( [ eq : rate - match ] ) , ( [ eq : size_equation ] ) , ( [ eq : error_correction ] ) , ( [ eq : det_suc ] ) .    @xmath6 and @xmath99 can be determined by equation ( [ eq : rate - match ] ) and ( [ eq : error_correction ] ) : @xmath158 since @xmath130 is constant , to maximize @xmath159 is equal to minimize @xmath160 .",
    "so we can rewrite the optimization problem as follows : @xmath161 this is a simple linear programming problem . here",
    "we will show the optimization results directly : @xmath162 in this paper we assume that we are storing large files , which means @xmath163 .",
    "so an optimal solution for the 2-layer rate - matched msr code can always be found .",
    "we have the following theorem :    when the number of blocks of the fractional rate code @xmath133 equals to @xmath164 and the number of blocks of the full rate code @xmath131 equals to @xmath165 , the 2-layer rate - matched msr code can achieve the optimal storage efficiency",
    ".      when dc needs to reconstruct the original file , it will send reconstruction requests to @xmath2 storage nodes . upon receiving the request",
    ", node @xmath39 will send out the symbol vector @xmath71 .",
    "suppose @xmath72 is the response from the @xmath41 storage node .",
    "if @xmath71 has been modified by the malicious node @xmath39 , we have @xmath166 . since dc has the permutation information of the fractional rate code and the full rate code , similar to the regeneration of the 2-layer rate - matched msr code , dc will perform the reconstruction using algorithm  [ alg : rec_rate_matched ] .",
    "dc reconstructs the original file for the 2-layer rate - matched msr code [ alg : rec_rate_matched ]    * step n : *    according to the order information , reconstruct each of the @xmath133 data blocks encoded by the fractional rate code and locate the malicious nodes .",
    "reconstruct each of the data blocks encoded by the full rate code . during the reconstruction ,",
    "all the symbols sent from malicious nodes will be replaced by erasures @xmath151 .    in section  [ sec : para_opt_reg ] , we optimized the parameters for the data regeneration , considering the trade - off between the successful malicious node detection probability and the storage efficiency .",
    "for data reconstruction , we have the following theorem :    when the number of blocks of the fractional rate code @xmath133 equals to @xmath167 and the number of blocks of the full rate code @xmath131 equals to @xmath165 , the 2-layer rate - matched msr code can guarantee that the same constraints for data regeneration ( equation  ( [ eq : error_correction ] ) ,  ( [ eq : det_suc ] ) ) be satisfied for the data reconstruction .",
    "the maximum number of malicious nodes can be detected for the data reconstruction is no smaller than @xmath152 : if @xmath107 , the number is @xmath168 .",
    "we have @xmath169 . if @xmath120 , the number is @xmath170 .",
    "we have @xmath171 .    the successful malicious node detection probability for the data reconstruction is larger than @xmath154 : the probability is @xmath172 , so we have @xmath173 .",
    "although the rate - matching equation  ( [ eq : rate - match ] ) does not apply to the data reconstruction , the reconstruction strategy in algorithm  [ alg : rec_rate_matched ] can still benefit from the different rates of the two codes .",
    "when @xmath120 , the fractional rate code can detect and correct @xmath174 malicious nodes , which are more than @xmath175 malicious nodes that the full rate code can detect .",
    "when @xmath107 , the full rate code and the fractional rate code can detect and correct the same number of malicious nodes : @xmath168 .    from the analysis above we",
    "can see that the same optimized parameters , which are obtained for the data regeneration , can maintain the optimized trade - off between the malicious node detection and storage efficiency for the data reconstruction .      from the analysis above ,",
    "we know that for a distributed storage system with @xmath2 storage nodes out of which at most @xmath152 nodes are malicious , the 2-layer rate - matched msr code can guarantee detection and correction of the malicious nodes during the data regeneration and reconstruction with the probability at least @xmath154 .",
    "for a distributed storage system with @xmath176 , @xmath177 and @xmath178 , suppose we have a file with the size @xmath179 symbols to be stored in the system .",
    "the number of the fractional rate code blocks @xmath133 and the number of the full rate code blocks @xmath131 for different detection probabilities @xmath154 are shown in fig .",
    "[ fig : number_of_blocks ] . from the figure",
    "we can see that the number of fractional rate code blocks will increase when the detection probability becomes larger .",
    "accordingly , the number of full rate code blocks will decrease .    ]    for the universally resilient msr code constructed in  @xcite , the efficiency of the code with the same regeneration performance as the 2-layer rate - matched msr code is defined as @xmath180 in fig .",
    "[ fig : efficiency_comp ] we will show the efficiency ratios @xmath181 between the 2-layer rate - matched msr code and the universally resilient msr code under different detection probabilities @xmath154 . from the figure we can see that the 2-layer rate - matched msr code has higher efficiency than the universally resilient msr code .",
    "when the successful malicious nodes detection probability is @xmath182 , the efficiency of the 2-layer rate - matched msr code is about @xmath183 higher .    ]",
    "in this section , we will show our second optimization of the rate - matched msr code : @xmath0-layer rate - matched msr code . in the code design ,",
    "we extend the design concept of the 2-layer rate - matched msr code . instead of encoding",
    "the data using two msr codes with different match factors , we utilize @xmath0 layers of the full rate msr codes with different parameter @xmath6 , written as @xmath184 for layer @xmath185 , @xmath186 , which satisfy @xmath187 the data will be divided into @xmath0 parts and each part will be encoded by a distinct full rate msr code . according to the analysis above",
    ", the code with a lower code rate has better error correction capability .",
    "the codewords will be decoded layer by layer in the order from layer @xmath188 to layer @xmath189 .",
    "that is , the codewords encoded by the full rate msr code with a lower @xmath6 will be decoded prior to those encoded by the full rate msr code with a higher @xmath6 .",
    "if errors were found by the full rate msr code with a lower @xmath6 , the corresponding nodes would be marked as malicious .",
    "the symbols sent from these nodes would be treated as erasures in the subsequent decoding of the full rate msr codes with higher @xmath6 s .",
    "the purpose of this arrangement is to try to correct as many as erroneous symbols sent by malicious nodes and locate the corresponding malicious nodes using the full rate msr code with a lower rate .",
    "however , the rates of the @xmath0 full rate msr codes must match to achieve an optimal performance .",
    "here we mainly focus on the rate - matching for data regeneration .",
    "we can see in the later analysis that the performance of data reconstruction can also be improved with this design criterion .",
    "the main idea of this optimization is to optimize the overall error correction capability by matching the code rates of different full rate msr codes .      according to section  [ sec : reg_high_rate ] ,",
    "the full rate msr code @xmath190 for layer @xmath185 can be viewed as an @xmath191 mds code for @xmath186 . during the optimization",
    ", we set the summation of the @xmath6 s of all the layers to a constant @xmath192 : @xmath193 here we will show the optimization through an illustrative example first . then we will present the general result .",
    "there are three layers of full rate msr codes for @xmath194 : @xmath195 , @xmath196 and @xmath197",
    ".    the first layer code @xmath195 can correct @xmath198 errors : @xmath199 where @xmath200 or @xmath201 depending on whether @xmath202 is even or odd .    by regarding the symbols from the @xmath198 nodes where",
    "errors are found by @xmath195 as erasures , the second layer code @xmath196 can correct @xmath203 errors : @xmath204 where @xmath205 or @xmath201 , with the restriction that @xmath206 , which can be written as : @xmath207    the third layer code @xmath197 also treat the symbols from the @xmath203 nodes as erasures .",
    "@xmath197 can correct @xmath208 errors : @xmath209 where @xmath210 or @xmath201 , with the restriction that @xmath211 , which can be written as : @xmath212    according to the analysis above , the @xmath6 s of the three layers satisfy : @xmath213 and we can rewrite equation  ( [ eqn : sumd ] ) as : @xmath214    to maximize the error correction capability of the @xmath0-layer rate - matched msr code for @xmath194 , we have to maximize @xmath208 , the number of errors that the third layer code @xmath197 can correct , since @xmath208 has included all the malicious nodes from which errors are found by the codes of first two layers .",
    "with all the constraints listed above , the optimization problem can written as :    @xmath215    now we have changed this optimization problem into a typical linear programming problem .",
    "this linear programming problem has a feasible solution .",
    "we solve it using the simplex algorithm  @xcite . when @xmath216 , the @xmath0-layer rate - matched msr code can correct errors from at most @xmath217 malicious nodes , where round(@xmath218 ) is the rounding operation .",
    "similar to the storage efficiency @xmath159 defined in section  [ sec:2-layer ] , here we can define the error correction efficiency @xmath219 of the @xmath0-layer rate - matched msr code as the ratio between the maximum number of malicious nodes that can be found and the total number of storage nodes in the network : @xmath220 the universally resilient msr code with the same code rate can be viewed as an @xmath221 mds code which can correct errors from at most @xmath222 malicious nodes ( best case ) .",
    "so the error correction efficiency @xmath223 is @xmath224 the comparison of the error correction capability between @xmath0-layer rate - matched msr code for @xmath194 and universally resilient msr code is shown in fig .",
    "[ fig : delta_c_3 ] . in this comparison , we set the number of storage nodes in the network @xmath176 . from the figure",
    "we can see that the @xmath0-layer rate - matched msr code for @xmath194 improves the error correction efficiency more than @xmath225 .",
    "-layer rate - matched msr code for @xmath194 and universally resilient msr code ]      for the general @xmath0-layer rate - matched msr code , the optimization process is similar .",
    "the first layer code @xmath195 can correct @xmath198 errors as in equation  ( [ eqn:3_t1 ] ) . by regarding the symbols from the @xmath226 nodes where",
    "errors are found by @xmath227 as erasures , the @xmath41 layer code can correct @xmath228 errors for @xmath229 : @xmath230 where @xmath231 or @xmath201 , with the restriction that @xmath232 , which can be written as : @xmath233    similarly , the parameter @xmath6 of the @xmath41 layer for @xmath234 must satisfy @xmath235 and equation  ( [ eqn : sumd ] ) can be written as : @xmath236    we can maximize the error correction capability of the @xmath0-layer rate - matched msr code by maximizing @xmath237 . with all the constrains listed above , the optimization problem can be written as : @xmath238    after verifying that this linear programming problem has a feasible solution , we can use the simplex algorithm to solve it .",
    "the optimization result can be summarized as follows :    [ thm : m - layer - reg ] for the regeneration of @xmath0-layer rate - matched msr code , when @xmath239 it can correct errors from at most @xmath240 malicious nodes .",
    "the error correction efficiency for the @xmath0-layer rate - matched msr code is @xmath241 this is a monotonically increasing function for @xmath0 , so we have :    [ cor : monoincrease ] the error correction efficiency of the @xmath0-layer rate - matched msr code increases with m , which is the number of layers .    during the optimization",
    ", we set the code rate of the rate - matched msr code to a constant value and maximize the error correction capability .",
    "to optimizing the rate - matched msr code , we can also set the error correction capability @xmath228 for @xmath242 in  ( [ eqn : opt_n_ti ] ) to a constant value @xmath243 and maximize the code rate .",
    "the problem can be written as : @xmath244 the optimization result is the same as that of  ( [ eqn : opt_original ] ) : when all the @xmath245 for @xmath186 are the same , the code rate is maximized .",
    "@xmath184 , @xmath246 , satisfies the following equation : @xmath247      although at the beginning of this section we propose to decode the code with a lower rate first in the @xmath0-layer rate - matched msr code , equation  ( [ eqn : opt_result_d ] ) shows that we can get the optimized error correction capability when all the rates of the codes in the @xmath0-layer code are equal .",
    "however , this result is not in conflict with our assumption in equation  ( [ eqn : m_layer_assump ] ) .    [ [ comparison - with - the - hermitian - code - based - msr - code - in ] ] comparison with the hermitian code based msr code in  @xcite + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + +    the hermitian code based msr code ( h - msr code ) in  @xcite has better error correction capability than the universally resilient msr code .",
    "however , because the structure of the underlying hermitian code is predetermined , the error correction capability might not be optimal . in figure",
    "[ fig : comp_h ] , the maximum number of malicious nodes from which the errors can be corrected by the h - msr code is shown . here",
    "we set the parameter @xmath248 of the hermitian code  @xcite from 4 to 16 with a step of 2 . in the figure",
    ", we also plot the performance of the @xmath0-layer rate - matched msr code with the same code rates as the h - msr code .",
    "the comparison result demonstrates that the rate - matched msr code has better error correction capability than the h - msr code .",
    "moreover , the rate - matched code is easier to understand and has more flexibility than the h - msr code .",
    "-layer rate matched msr code and the h - msr code ]    [ [ number - of - layers - and - error - correction - efficiency ] ] number of layers and error correction efficiency + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + +    since we have seen the advantage of the rate - matched msr code over the universally resilient msr code in section  [ sec : eva_3 ] , here we will mainly discuss how the number of layers can affect the error correction efficiency . the error correction efficiency of the @xmath0-layer rate - matched msr code is shown is fig .  [",
    "fig : delta_c_n ] , where we set @xmath176 and @xmath249 .",
    "we also plot the error correction efficiency @xmath250 of the universally resilient msr code with same code rates for comparison . from the figure we can see that when @xmath2 and @xmath192 are fixed , the optimal error correction efficiency will increase with the number of layers @xmath0 as in corollary  [ cor : monoincrease ] .",
    "-layer rate - matched msr code under different m for @xmath251    [ [ optimized - storage - capacity ] ] optimized storage capacity + + + + + + + + + + + + + + + + + + + + + + + + + +    moreover , the optimization condition in equation  ( [ eqn : opt_result_d ] ) also leads to maximum storage capacity besides the optimal error correction capability .",
    "we have the following theorem :    the @xmath0-layer rate - matched msr code can achieve the maximum storage capacity if the parameter @xmath6 s of all the layers are the same , under the constraint in equation  ( [ eqn : sumd ] ) .",
    "the code of the @xmath41 layer can store one block of data with the size @xmath252 .",
    "so the @xmath0-layer code can store data with the size @xmath253 .",
    "our goal here is to maximize @xmath9 under the constraint in equation  ( [ eqn : sumd ] ) .",
    "we can use lagrange multipliers to find the point of maximum @xmath9 .",
    "let @xmath254 we can find the maximum value of @xmath9 by setting the partial derivatives of this equation to zero : @xmath255 here we can see that when all the parameter @xmath6 s of all the layers are the same , we can get the maximum storage capacity @xmath9 .",
    "this maximization condition coincides with the optimization condition for achieving the goal of this section : optimizing the overall error correction capability of the rate - matched msr code .",
    "so far , we implicitly presume that there is only one data block of the size @xmath256 for each layer @xmath39 . in practical distributed storage ,",
    "it is the parameter @xmath184 that is fixed instead of @xmath192 , the summation of @xmath184 .",
    "however , as long as we use @xmath0 layers of msr codes with the same parameter @xmath257 , we will still get the optimal solution for @xmath258 .",
    "in fact , the @xmath0-layer rate - matched msr code here becomes a single full rate msr code with parameter @xmath257 and @xmath0 data blocks . and based on the dependent decoding idea we describe at the beginning of section  [ sec : m_layer_msr ] , we can achieve the optimal performance .",
    "so when the file size @xmath130 is larger than one data block size @xmath259 of the single full rate msr code with parameter @xmath257 , we will divide the file into @xmath260 data blocks and encode them separately .",
    "if we decode these data blocks dependently , we can get the optimal error correction efficiency .      in the practical case , @xmath261 in equation  ( [ eqn : efficiency_m_layer ] )",
    "so here we will study the relationship between the number of dependently decoding data blocks @xmath0 and the error correction efficiency @xmath219 , which is shown in fig .",
    "[ fig : delta_c_practical ] .",
    "we set @xmath176 and @xmath262 . from the figure",
    "we can see that although @xmath219 will become higher with the increasing of dependently decoding data blocks @xmath0 , the efficiency improvement will be negligible for @xmath263 . actually when @xmath264 the efficiency has already become @xmath265 of the upper bound of @xmath219 .    ]    on the other hand , there exist parallel algorithms for fast mds code decoding  @xcite .",
    "we can decode blocks of mds codewords parallel in a pipeline fashion to accelerate the overall decoding speed .",
    "the more blocks of codewords we decode parallel , the faster we will finish the whole decoding process . for large files that could be divided into a large amount of data blocks ( @xmath266 blocks )",
    ", we can get a trade - off between the optimal error correction efficiency and the decoding speed by setting the number of dependently decoding data blocks @xmath0 and the number of parallel decoding data blocks @xmath267 under the constraint @xmath268 .      from the analysis above we know that to encode a file with size @xmath130 using the optimal @xmath0-layer rate - matched msr code is to encode the file using a full rate msr code with predetermined parameter @xmath269 .",
    "first the file will be divided into @xmath266 blocks of data with size @xmath259 , where @xmath270 .",
    "then the @xmath266 blocks of data will be encoded into code matrices @xmath271 and form the final @xmath272 codeword matrix : @xmath273 $ ] .",
    "each row @xmath274 $ ] , @xmath142 , of the codeword matrix @xmath275 will be stored in storage node @xmath39 , where @xmath144 is the @xmath41 row of @xmath145 , @xmath276 .",
    "the encoding vector @xmath40 for storage node @xmath39 is the @xmath41 row of @xmath36 in equation  ( [ eq : encoding_msr_h ] ) .",
    "the encoding of m - layer rate - matched msr code can achieve the msr point in equation  ( [ eq : msr_tradeoff ] ) since both the full rate code and the fractional code are msr codes .",
    "suppose node @xmath42 fails , the replacement node @xmath43 will send regeneration requests to the rest of @xmath44 helper nodes . upon receiving the regeneration request , helper node @xmath39 will calculate and send out the help symbol @xmath150 .",
    "as we discuss above , combining both dependent decoding and parallel decoding can achieve the trade - off between optimal error correction efficiency and decoding speed .",
    "although all @xmath266 blocks of data are encoded with the same msr code , @xmath43 will place the received help symbols into a 2-dimension lattice with size @xmath277 as shown in fig .",
    "[ fig : lattice_arrange ] . in each grid of the lattice",
    "there are @xmath44 help symbols corresponding to one data block , received from @xmath44 helper nodes .",
    "we can view each row of the lattice as related to a layer of an @xmath0-layer rate - matched msr code with @xmath267 blocks of data , which will be decoded parallel .",
    "we also view each column of the lattice as related to @xmath0 layers of an @xmath0-layer rate - matched msr code with one block of data each layer , which will be decoded dependently .",
    "@xmath43 will perform algorithm  [ alg : reg_m_layer ] to regenerate the contents of the failed node @xmath42 .",
    "arrange the received help symbols according to fig .",
    "[ fig : lattice_arrange ] . repeat the following steps from layer @xmath201 to layer @xmath0 :    @xmath43 regenerates symbols of the failed node @xmath42 for the @xmath0-layer rate - matched msr code [ alg : reg_m_layer ]    * step n : *    for a certain grid ,",
    "if errors are detected in the symbols sent by node @xmath39 in previous layers of the same column , replace the symbol sent from node @xmath39 by an erasure @xmath151 .",
    "parallel regenerate all the symbols related to @xmath267 data blocks using the algorithm similar to algorithm  [ alg : reg_h ] with only one difference : parallel decode all the @xmath267 mds codes in * step 1 * of algorithm  [ alg : reg_h ] .",
    "the error correction capability of the regeneration is described in theorem  [ thm : m - layer - reg ] .",
    "when dc needs to reconstruct the original file , it will send reconstruction requests to @xmath2 storage nodes . upon receiving the request ,",
    "node @xmath39 will send out the symbol vector @xmath71 .",
    "suppose @xmath72 is the response from the @xmath41 storage node .",
    "if @xmath71 has been modified by the malicious node @xmath39 , we have @xmath278 .",
    "the strategy of combining dependent decoding and parallel decoding for reconstruction is similar to that for regeneration .",
    "@xmath279 will place the received symbols into a 2-dimension lattice with size @xmath277 .",
    "the only difference is that in a grid of the lattice there are @xmath2 symbol vectors @xmath280 corresponding to data block @xmath54 , received from @xmath2 storage nodes .",
    "dc will perform the reconstruction using algorithm  [ alg : rec_rate_matched_m_rec ] .",
    "arrange the received symbols similar to fig .",
    "[ fig : lattice_arrange ] . here",
    "we place received codeword matrix @xmath281 into grid @xmath54 instead of help symbols received from n-1 help nodes .",
    "repeat the following steps from layer @xmath201 to layer @xmath0 :    dc reconstructs the original file for the @xmath0-layer rate - matched msr code [ alg : rec_rate_matched_m_rec ]    * step n : *    for a certain grid , if errors are detected in the symbols sent by node @xmath39 in previous layers of the same column , replace symbols sent from node @xmath39 by erasures @xmath151 .",
    "parallel reconstruct all the symbols of the @xmath267 data blocks using the algorithm similar to section  [ sec : rec_high_rate ] with only one difference : parallel decode all the mds codes in section  [ sec : rec_high_rate ] .    for data reconstruction",
    ", we have the following theorem :    for the reconstruction of @xmath0-layer rate - matched msr code , when @xmath239 the number of malicious nodes from which the errors can be corrected is maximized .    from section  [ sec : rate_matching_m ] we know that for regeneration of an optimal @xmath0-layer rate - matched msr code , the parameter @xmath6 s of all the layers are the same , which implies the parameter @xmath7 s of all layers are also the same .",
    "since the optimization of regeneration is derived based on the decoding of @xmath66 mds codes and in reconstruction we have to decode @xmath282 mds codes , if the parameter @xmath7 s of all the layers are the same , we can achieve the same optimization results for reconstruction .",
    "in this paper , we develop two rate - matched regenerating codes for malicious nodes detection and correction in hostile networks : 2-layer rate - matched regenerating code and @xmath0-layer rate - matched regenerating code .",
    "we propose the encoding , regeneration and reconstruction algorithms for both codes . for the 2-layer rate - matched code",
    ", we optimize the parameters for the data regeneration , considering the trade - off between the malicious nodes detection probability and the storage efficiency .",
    "theoretical analysis shows that the code can successfully detect and correct malicious nodes using the optimized parameters .",
    "our analysis also shows that the code has higher storage efficiency compared to the universally resilient regenerating code ( @xmath183 higher for the detection probability @xmath182 ) .",
    "then we extend the 2-layer code to @xmath0-layer code and optimize the overall error correction efficiency by matching the code rate of each layer s regenerating code .",
    "theoretical analysis shows that the optimized parameter could also achieve the maximum storage capacity under the same constraint .",
    "furthermore , analysis shows that compared to the universally resilient regenerating code , our code can improve the error correction efficiency more than @xmath225 .",
    "k.  rashmi , n.  shah , k.  ramchandran , and p.  kumar , `` regenerating codes for errors and erasures in distributed storage , '' in _ international symposium on information theory ( isit ) 2012 _ , pp .  12021206 , 2012 .",
    "r.  bhagwan , k.  tati , y .- c .",
    "cheng , s.  savage , and g.  m. voelker , `` total recall : system support for automated availability management , '' in _ roc .",
    "design implementation _ , pp .  337350 , 2004 .",
    "c.  suh and k.  ramchandran , `` exact - repair mds codes for distributed storage using interference alignment , '' in _ 2010 ieee international symposium on information theory proceedings ( isit ) _ , pp .  161165 , 2010 .",
    "s.  el  rouayheb and k.  ramchandran , `` fractional repetition codes for repair in distributed storage systems , '' in _ 2010 48th annual allerton conference on communication , control , and computing ( allerton ) _ , pp .  15101517 , 2010 .",
    "n.  shah , k.  v. rashmi , and p.  kumar , `` a flexible class of regenerating codes for distributed storage , '' in _ 2010 ieee international symposium on information theory proceedings ( isit ) _ , pp .  19431947 , 2010 .",
    "h.  hou , k.  w. shum , m.  chen , and h.  li , `` basic regenerating code : binary addition and shift for exact repair , '' in _ 2013 ieee international symposium on information theory proceedings ( isit ) _ , pp .  16211625 , 2013 .",
    "chen , g .-",
    "li , c .- t .",
    "tsai , s .-",
    "yuan , and h .-",
    "chiao , `` regenerating code based p2p storage scheme with caching , '' in _",
    "iccit 09 .",
    "fourth international conference on computer sciences and convergence information technology , 2009 _ , pp .  927932 , 2009 .",
    "a.  duminuco and e.  biersack , `` a practical study of regenerating codes for peer - to - peer backup systems , '' in",
    "_ icdcs 09 .",
    "29th ieee international conference on distributed computing systems , 2009 _ , pp .",
    "376  384 , june 2009 .      y.  wu and a.  g. dimakis , `` reducing repair traffic for erasure coding - based storage via interference alignment , '' in _ ieee international symposium on information theory , 2009 .",
    "isit 2009 .",
    "_ , pp .  22762280 , 2009 .",
    "n.  shah , k.  rashmi , p.  kumar , and k.  ramchandran , `` interference alignment in regenerating codes for distributed storage : necessity and code constructions , '' _ ieee transactions on information theory _",
    "58 , pp .",
    "2134  2158 , 2012 .",
    "k.  rashmi , n.  shah , and p.  kumar , `` optimal exact - regenerating codes for distributed storage at the msr and mbr points via a product - matrix construction , '' _ ieee transactions on information theory _ ,",
    "57 , pp .  52275239 , 2011 .",
    "s.  pawar , s.  el  rouayheb , and k.  ramchandran , `` securing dynamic distributed storage systems against eavesdropping and adversarial attacks , '' _ ieee transactions on information theory _",
    "57 , pp .",
    "6734  6753 , 2011 .",
    "m.  abd - el - malek , g.  ganger , g.  goodson , m.  reiter , and j.  wylie , `` lazy verification in fault - tolerant distributed storage systems , '' in _ srds 2005 .",
    "24th ieee symposium on reliable distributed systems , 2005 _ , pp .",
    "179190 , 2005 ."
  ],
  "abstract_text": [
    "<S> regenerating code is a class of code very suitable for distributed storage systems , which can maintain optimal bandwidth and storage space </S>",
    "<S> . two types of important regenerating code have been constructed : the minimum storage regeneration ( msr ) code and the minimum bandwidth regeneration ( mbr ) code . however , in hostile networks where adversaries can compromise storage nodes , the storage capacity of the network can be significantly affected . in this paper , we propose two optimal constructions of regenerating codes through rate - matching that can combat against this kind of adversaries in hostile networks : 2-layer rate - matched regenerating code and @xmath0-layer rate - matched regenerating code . for the 2-layer code , we can achieve the optimal storage efficiency for given system requirements . </S>",
    "<S> our comprehensive analysis shows that our code can detect and correct malicious nodes with higher storage efficiency compared to the universally resilient regenerating code which is a straightforward extension of regenerating code with error detection and correction capability . </S>",
    "<S> then we propose the @xmath0-layer code by extending the 2-layer code and achieve the optimal error correction efficiency by matching the code rate of each layer s regenerating code . </S>",
    "<S> we also demonstrate that the optimized parameter can achieve the maximum storage capacity under the same constraint . </S>",
    "<S> compared to the universally resilient regenerating code , our code can achieve much higher error correction efficiency .    </S>",
    "<S> optimal regenerating code , mds code , error - correction , adversary . </S>"
  ]
}