{
  "article_text": [
    "the design of complex systems such as unmanned air vehicles ( uavs ) can be greatly improved through the use of advanced system and software architecting tools . in previous work , we have successfully used model checking to verify software components that have been created using model - based development ( mbd ) tools such as simulink @xcite .",
    "an objective of our current research is to build on this success and extend the reach of model checking and other formal methods to system design models .",
    "the architecture analysis and design language ( aadl ) @xcite is targeted for capturing the important design concepts in real - time distributed embedded systems .",
    "the aadl language can capture both the hardware and software architecture in a hierarchical format .",
    "it provides hardware component models including processors , buses , memories , and i / o devices , and software component models including threads , processes , and subprograms .",
    "interfaces for these components and data flows between components can also be defined .",
    "the language offers a high degree of flexibility in terms of architecture and component detail .",
    "this supports incremental development where the architecture is refined to increasing levels of detail and where components can be refined with additional details over time .",
    "one of our core innovations is to structure the formalizations and proofs by following the aadl descriptions of the system . in other work , we did this through the use of formal assume - guarantee contracts that correspond to the component requirements for each component @xcite .",
    "our current work on darpa s high assurance cyber military systems ( hacms ) program is focused on security properties of uavs @xcite .",
    "we have found that in assuring the cyber - security properties of aircraft designs we need to integrate a variety of evidence with varying levels of formality .",
    "this has been our motivation to explore assurance case approaches .    in this paper",
    "we report on _ resolute _ , a new assurance case language and tool which is based on architectural models . in developing resolute",
    ", we have followed the same approach of embedding the proof in the architectural model for the vehicle , tightly coupling terms in the assurance case with evidence derived directly from the system design artifacts .",
    "this ensures that we maintain consistency between the system design and its associated assurance case(s ) .",
    "design changes that might invalidate some aspect of an assurance case can be immediately flagged by our tool for correction .",
    "using resolute , the goal is to construct an _ assurance case _",
    "@xcite about a system specified in aadl . from  @xcite",
    ", an assurance case is defined as :    _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ a reasoned and compelling argument , supported by a body of evidence , that a system , service or organization will operate as intended for a defined application in a defined environment . _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _    assurances cases are constructed to show that one or more _ claims _ about the system are acceptable ; usually the claims are defined for an aspect of the system such as safety ( _ safety cases _ ) or security ( _ security cases _ ) . for complex systems , these structured arguments are often large and complicated . in order to construct ,",
    "present , discuss , and review these arguments , it is necessary that they are clearly documented .",
    "several notations have been proposed to properly document assurance cases .",
    "the most popular notation is currently the goal structuring notation ( gsn )  @xcite , which is used in several assurance - case tool suites .",
    "an example of the gsn notation is shown in figure  [ fig : gsn ] . in gsn",
    ", we have _ goals _ ( g1 .. g6 in figure  [ fig : gsn ] ) that represent claims about the system .",
    "when a claim is established through reasoning about subclaims , a _ strategy _ ( s1 , s2 in figure  [ fig : gsn ] ) is used to describe the nature of how the subclaims establish the claim .",
    "furthermore , strategies often rely on _ assumptions _ in order for the strategy to be reasonably applied . in the figure",
    ", we make an argument that the system is acceptably secure by enumerating the hazards that prevent it from being secure and demonstrating that these hazards are mitigated .",
    "an assumption of this strategy ( a1 in figure  [ fig : gsn ] ) is that we have enumerated all reasonable security hazards .",
    "also , it is often necessary to provide the _ context _ in which a strategy or goal occurs : in the case of the enumeration strategy , the context is the list of identified hazards .",
    "we terminate the argument either in goals that have no further decomposition , graphically notated by a diamond ( shown in the figure by goals g4 and g6 ) , or in _ solutions _",
    "( sln1 , sln2 in figure  [ fig : gsn ] ) that describe evidence for the goal .",
    "gsn arguments form directed acyclic graphs ; it is possible to use the same subclaim or evidence as part of the justification of a larger claim , but it is not well - formed to have a cyclic chain of reasoning within a gsn graph .    to be compelling , the argument must provide sufficient assurance in the claims made about the system .",
    "constructing such arguments is quite difficult , even given appropriate notations .",
    "first , proper claims must be identified to define the objectives of the assurance case .",
    "then appropriate argumentation must be constructed : such argumentation must often take into account the environment in which the system is used , the artifacts that are constructed during system design , implementation , and test , and the processes followed during the development and implementation cycle . there is a rich body of literature that describes proper processes and patterns for constructing assurance cases , _",
    "e.g. _  @xcite .",
    "our domain of interest is distributed real - time embedded systems ( including both hardware and software ) , such as comprise the critical functionality in commercial and military aircraft .",
    "many aerospace companies have adopted mbd processes for production of software components , and we have successfully applied formal analysis at this level to verify component requirements . however , the system design process is often less rigorous : system - level descriptions of the interactions of distributed components , resource allocation decisions , and communication mechanisms between components are typically ad hoc and not based on analyzable models .",
    "application of formal analysis methods at the system level requires 1 ) an abstraction that defines how components will be represented in the system model , and 2 ) selection of an appropriate formal modeling language .    in this approach ,",
    "the architectural model includes interface , interconnections , and specifications for components but not their implementations .",
    "it describes the interactions between components and their arrangement in the system , but the components themselves are black boxes .",
    "the component implementations are described separately by the existing mbd environment and artifacts ( or by traditional programming languages , where applicable ) .",
    "they are represented in the system model by the subset of their specifications that is necessary to describe their system - level interactions .",
    "this distinction between system architecture and component implementation is important to ensure the scalability of the analyses that we wish to perform .",
    "we have selected aadl as a system modeling language for our work .",
    "aadl is described in sae standard as5506b and has a sufficiently precise definition to support formalization of its semantics @xcite .",
    "it provides syntax for describing both hardware and software aspects of the system so that requirements related to resource allocation , scheduling , and communication between distributed elements can be addressed .",
    "textual and graphical versions of the language are available with tool support for each @xcite .",
    "an important feature of the language is its extensibility via the annex mechanism .",
    "language developers can embed new syntax into an aadl model to provide new features or to support additional analyses .",
    "annex expressions have full access to the rest of the model providing the ability to refer to components and properties described in the base aadl language .",
    "we have used this annex mechanism to add behavioral contracts and assurance case rules to our system architecture models .",
    "figure  [ fig : aadl ] shows an example aadl system model ( using the graphical syntax ) that we have developed for the hacms program .",
    "the model describes a uav that includes a simplified version of the system software along with the processing hardware ( px4fmu ) and an i / o board for motors and radios ( px4ioar ) .",
    "the actual flight software model is over 7,000 lines of aadl and includes 35 computing threads , with a c implementation of over 50k lines of code .    in the hacms project",
    "we are concerned primarily with cyber - security of uavs .",
    "we are developing analysis tools based on the aadl language that allow us to verify important security and information flow properties for this kind of system .",
    "we are also developing synthesis tools that allow us to generate glue code and system configuration data for the system .",
    "this data , along with the component implementations , provide everything needed to build the final flight binaries from the aadl model . to show that our results scale to real military systems",
    ", we are also transitioning these technologies for demonstration on boeing s unmanned little bird helicopter @xcite .",
    "resolute is a language and tool for constructing assurance cases based on aadl models .",
    "users formulate claims and rules for justifying those claims , which resolute uses to construct assurance cases . both the claims and rules are parameterized by variable inputs which are instantiated using elements from the models .",
    "this creates a dependence of the assurance case on the aadl model and means that changes to the aadl model can result in changes to the assurance case .",
    "this also means that a small set of rules can result in a large assurance case since each rule may be applied multiple times to different parts of the architecture model .",
    "resolute is designed primarily to show the structure of an argument ; in the gsn notation , it would define how a claim is provable from subclaims . in some ways , resolute is richer than gsn ; as shown below , it supports parametric goals and arbitrary boolean relations between claims and subclaims rather than simple conjunctions or @xmath0-of-@xmath1 relations . on the other hand",
    ", it does not currently provide specific placeholders for _ context _ and _ assumption _ information . in gsn ,",
    "this information is explicit , but informal : it is documented to aid the readers and writers of the assurance case .",
    "resolute currently does not have a placeholder for this information , but this could easily be remedied by adding string properties to document contextual aspects of claim / subclaim relationships . to define context and assumption ideas",
    "more formally is more challenging and something that we are considering for future work .      in resolute , each claim corresponds to a first - order predicate .",
    "for example , a user might represent a claim such as `` the memory of process p is protected from alteration by other processes '' using the predicate memory_protected(p : process ) .",
    "the user specifies rules for memory_protected which provide possible ways to justify the underlying claim . logically , these rules correspond to global assumptions which have the form of an implication with the predicate of interest as the conclusion .",
    "for example , an operating system such as nicta s secure microkernel sel4which we are using in hacms  might enforce memory protection on its own @xcite :    ....    memory_protected(p : process ) < =      ( property_lookup(p , os ) = \" sel4 \" ) ....    here we query the architectural model to determine the operating system for the given process . another way to satisfy memory protection may be to examine all the other processes which share the same underlying memory component .",
    "note that in aadl a `` process '' represents a logical memory space while a `` memory '' represents a physical memory space .    ....",
    "memory_protected(p : process ) < =      forall ( mem : memory ) .",
    "bound(p , mem ) = >        forall ( q : process ) .",
    "bound(q , mem ) = >",
    "memory_safe_process(q ) ....    in the above rule , we are querying the architectural model via the universal quantification over memory and process components . note that quantification is always finite since we only quantify over architectural components and other finite sets .",
    "the built - in bound predicate determines how software maps to hardware .",
    "in addition , we call another user defined predicate memory_safe_process to determine if a process is memory safe . in the resulting assurance case , the claim that a process p is memory protected will be supported by subclaims that all processes in its memory space are memory safe",
    ". thus there will be one supporting subclaim for each process in the memory space .",
    "the above rules for memory protection illustrate a couple of ways to justify the desired claim , but they do not constitute a complete description of memory protection nor a complete listing of sufficient evidence .",
    "this is a critical point in resolute : rules are sufficient , but not complete .",
    "the negation of a claim can never be used in an argument ( _ i.e. _ , in logic programming parlance , we do not make a closed world assumption ) .",
    "this is a manifestation of the traditional phrase `` absence of evidence is not evidence of absence . '' instead , if the user truly wants to use a claim in a negative context , that notion must be formalized as a separate positive claim with its own rules for what constitutes sufficient evidence .",
    "for example , one may be interested in a claim such as memory_violated which has rules which succeed only when a concrete memory violation is detected .",
    "separate from claims , resolute has a notion of _ computations _ which are complete and can thus be used in both positive and negative contexts .",
    "usually these computations are based on querying the model .",
    "for example , the bound predicate above is a built - in computation which returns a boolean value and is used in a negative context in the rule for memory_protected .",
    "users may also introduce their own functions which are defined via a single equation such as    ....",
    "message_delay(p : process ) =      sum({thread_message_delay(t )             for ( t : thread ) if bound(t , p ) } ) ....    here sum is a built - in function and thread_message_delay is another user - defined function .    computations may contribute to an assurance case , but they do not appear in it independently since they do not make any explicit claim . instead , a user may wrap claims around computations as needed , for instance a claim such as `` message delay time for p is within acceptable bounds '' using the message_delay function .",
    "since claims can not be used negatively while computations can , claims may not appear within computations .",
    "this creates two separate levels in resolute : the logical level on top and the computation level beneath it .",
    "the logical level determines the claims , rules , and evidence used in the assurance case argument , while the computation level helps determine which claims are relevant in a particular context and may directly satisfy some claims by performing computations over the model .",
    "external analyses are incorporated in resolute as computations .",
    "an external analysis is run each time the corresponding computation is invoked .",
    "this is useful for deploying existing tools for analyzing properties such as schedulability or resource allocation .",
    ".... only_receive_decrypt(x : component ) < =    * * \" the component \" x \" only receives messages that pass decrypt \" * *    forall ( c : connection ) .",
    "( parent(destination(c ) ) = x ) = >        is_sensor_data(c ) or only_receive_decrypt_connection(c )    only_receive_decrypt_connection(c : connection ) < =    * * \" the connection \" c \" only carries messages that pass decrypt \" * *    let src : component = parent(source(c ) ) ;    unalterable_connection(c ) and ( is_decrypt(src ) or only_receive_decrypt(src ) ) ....    .... bound(logical : component , physical : component ) : bool =    memory_bound(logical , physical ) or    connection_bound(logical , physical ) or    processor_bound(logical , physical )    memory_bound(logical : component , physical : component ) : bool =    has_property(logical , deployment_properties::actual_memory_binding ) and    member(physical , property(logical , deployment_properties::actual_memory_binding ) )    connection_bound(logical : component , physical : component ) : bool =    has_property(logical , deployment_properties::actual_connection_binding ) and    member(physical , property(logical , deployment_properties::actual_connection_binding ) )    processor_bound(logical : component , physical : component ) : bool =    has_property(logical , deployment_properties::actual_processor_binding ) and    member(physical , property(logical , deployment_properties::actual_processor_binding ) ) ....    we have implemented resolute as an aadl annex using the open source aadl tool environment ( osate ) @xcite plug - in for the eclipse ide .",
    "resolute itself is open source under a bsd license and available online @xcite .",
    "using osate , users are able to interact with resolute in the same environment in which they develop their aadl models . in addition",
    ", the resulting framework provides on - the - fly syntactic and semantic validation .",
    "for example , references to aadl model elements in the resolute annex are linked to the actual aadl objects in the same project so that undefined references and type errors are detected instantly .",
    "the syntax of resolute is inspired by logic programming .",
    "each rule defines the meaning and evidence for a claim .",
    "the meaning of a claim is given by a text string in the rule which is parameterized by the arguments of the claim .",
    "the body of the rule consists of an expression which describes sufficient evidence to satisfy that claim .",
    "claims may be parameterized by aadl types ( e.g. , threads , systems , memories , connections , etc . ) , integers , strings , booleans , or sets .    figure  [ fig : ex - rules ] shows an example of two resolute rules .",
    "the meaning of the claim is given by the associated text , for example only_receive_decrypt(x ) means : `` the component x only receives commands that pass decrypt . ''",
    "an instantiated version of this string is what will appear in the corresponding assurance case .",
    "the built - in functions like destination and source return the feature to which a connection is attached , and the built - in parent then gives the component which holds that feature .",
    "these rules also make use of other user - defined claims such as is_sensor_data and unalterable_connection which talk about the content and integrity of connections .",
    "note that the two claims shown in the figure are mutually recursive .",
    "together , these claims walk over a model cataloging the data - flow and constructing a corresponding assurance case .",
    "many claims , rules , and functions will appear within a resolute annex library which is typically a top - level file in an aadl project .",
    "these libraries define the rules for all claims in resolute , but do not make any assertions about what arguments the claims should hold on .",
    "in addition , resolute comes with a standard library of predefined functions for common operations .",
    "for instance , the bound predicate for determining if a logical component is bound to a specific physical component is part of the standard library and defined as in figure  [ fig : bound ] .",
    "an assurance case is initiated in resolute by adding a _ prove _ statement to the resolute annex for an aadl component .",
    "a prove statement consists of a claim applied to some concrete arguments .",
    "an example prove statement is shown in figure  [ fig : prove ] where the claim only_receive_ground_station is associated with the motor controller thread . when a resolute analysis is run on an aadl system instance , an assurance case is generated for every prove statement that appears in any component within that instance .",
    ".... process implementation main_loop.impl    subcomponents      mc : thread motor_control      ...      annex resolute { * *      prove only_receive_ground_station(mc )    * * } end main_loop.impl ; ....            figure  [ fig : ex - success ] shows a portion of a successful assurance case generated by resolute on our simplified uav model .",
    "each claim is shown on a single line .",
    "supporting claims are shown indented one level beneath the claim they support .",
    "a check next to a claim indicates that it is proven .",
    "figure  [ fig : ex - failure ] shows a portion of a failed assurance case .",
    "an exclamation point indicates that a claim has failed . in this case , the aadl model includes a safety controller which is allowed to bypass the decrypt component and directly send messages to the uav .",
    "this bypass is detected resolute .",
    "in fact , the only difference between figures  [ fig : ex - success ] and [ fig : ex - failure ] is the aadl model .",
    "the claims and rules are identical in both .",
    "the assurance case shown in figure  [ fig : ex - success ] is constructed over our simplified uav model .",
    "we ported this assurance case to the true uav model once the latter was available .",
    "although the true uav model contained seven times as many software components as the simplified model , very few of the resolute rules needed to be changed .",
    "the most significant change was that the true uav model has data - flow cycles , and therefore the simple recursive rules used in figure  [ fig : ex - rules ] are insufficient .",
    "instead , we created more sophisticated rules which recursively computed the set of components which were reachable prior to passing through the decrypt component , and then we justified the claim that the given set was complete and did not have access to the motor control component .",
    "assurance cases as shown in figures  [ fig : ex - success ] and [ fig : ex - failure ] are interactive in the resolute user interface .",
    "the user can navigate through the assurance case and select a claim to navigate to locations in the model relevant to the claim .",
    "for example , the user can navigate to any of the aadl components referenced as input parameters to the claim or can navigate to the rule that defines the claim .",
    "this makes it much easier to figure out why an assurance case is failing or why a particular part of the assurance case has a given structure .",
    "an assurance case generated by resolute is also a stand - alone object . after construction",
    ", it no longer depends on resolute or even the aadl model , though it of course still refers to elements of the model .",
    "this means the assurance case can be used as an independent certification artifact .",
    "in addition , resolute allows assurance cases to be exported to other formats and assurance case tools such as certware @xcite .",
    "@xmath2        { \\gamma \\vdash g_1 \\land g_2 }        { \\gamma \\vdash g_1 & \\gamma \\vdash g_2 } & & \\infer[\\lor\\mathcal{r}_{i=1,2 } ]        { \\gamma \\vdash g_1 \\lor g_2 }        { \\gamma \\vdash g_i } & & \\infer[\\rightarrow\\mathcal{r } ]        { \\gamma \\vdash g_1 \\rightarrow g_2 }        { \\gamma , g_1 \\vdash g_2}\\end{aligned}\\ ] ]    @xmath3        { \\gamma \\vdash \\forall x\\ ! : \\",
    "! \\alpha.~ g(x ) }        { \\gamma \\vdash g(t_1 ) & \\cdots & \\gamma \\vdash g(t_n ) } & & \\infer[\\exists\\mathcal{r}_{i=1\\ldots n } ]        { \\gamma \\vdash \\exists x\\ ! : \\",
    "! \\alpha.~ g(x ) }        { \\gamma \\vdash g(t_i)}\\end{aligned}\\ ] ]    where @xmath4    @xmath5        { \\gamma \\vdash a(\\bar{t } ) }        { \\gamma \\vdash g(\\bar{t})}\\end{aligned}\\ ] ]    where @xmath6 .",
    "@xmath7        { \\gamma , \\langle e \\rangle \\vdash g }        { e \\downarrow \\mbox{false } } & & \\infer[\\mbox{eval-}\\mathcal{r } ]        { \\gamma \\vdash \\langle e \\rangle }        { e \\downarrow \\mbox{true}}\\end{aligned}\\ ] ]    the resolute language consists of both a logic and a computational sublanguage .",
    "the logic of resolute is an intuitionistic logic similar to pure prolog , but augmented with explicit quantification .",
    "the logic is parameterized by the computational sublanguage , and requires only that the sublanguage is deterministic .",
    "this allows the computational sublanguage to be customized to any domain ( e.g. aadl in our context ) and to be expanded and refined , without worrying about the logical consequences .",
    "in fact , we do not even require termination for the computational sublanguage , though in practice a non - terminating computation will lead to non - terminating proof search .",
    "let the type of formulas be @xmath8 .",
    "we assume the usual logical constants of @xmath9 and @xmath10 for every type @xmath11 not containing @xmath8 .",
    "let the type of booleans be @xmath12 with constants @xmath13 and @xmath14 .",
    "we use the constant @xmath15 to inject booleans into formulas .",
    "we assume a notion of evaluation @xmath16 read `` @xmath17 evaluates to @xmath18 '' .",
    "we assume evaluation is deterministic .",
    "the full set of types and terms is left unspecified , but would typically be determined by the computational sublanguage .",
    "we define a judgment @xmath19 where @xmath20 is a set of formulas called assumptions and @xmath21 is a formula called the goal .",
    "this judgment holds when the goal @xmath21 is a consequence of assumptions @xmath20 in the resolute logic .",
    "the rules for this judgment are presented in figure  [ fig : logic - rules ] .    the rules for @xmath22 , @xmath23 , and @xmath24 are standard .",
    "the quantification rules apply only to types with finitely many inhabitants since the rules work via explicit enumeration .",
    "this simplistic treatment of quantification means that proof search only needs to consider ground terms . moreover , finiteness is appropriate for our domain where we want to quantify over types such as all threads in a model or all processes within a particular system .",
    "the rule for backchain allows the assumptions in @xmath20 to be used in constructing a proof of an atomic goal .",
    "note that in the backchain rule , @xmath25 stands for an atomic formula , _",
    "i.e. _ , a predicate applied to arguments . finally , the rules for evaluation allow a proof to be finished by finding an assumption which evaluates to @xmath14 or a conclusion that evaluates to @xmath13 .",
    "user specified claims in resolute are treated as predicates in the logic , and the rules for claims are treated as initial assumptions .",
    "each prove statement in the aadl model is translated to a goal @xmath21 while all the resolute rules are translated into the initial context @xmath20 .",
    "then proof search is performed on @xmath19 .",
    "if a proof is found , that proof is transformed into an assurance case by replacing each intermediate sequent of the form @xmath26 by the instantiated version of the claim text for the claim @xmath27 .",
    "thus , for us , an assurance case is a proof in the resolute logic , and browsing the assurance case means traversing the proof tree .",
    "the resolute logic we use in our implementation is a customization of the general resolute logic . in particular , we allow quantification over all aadl model types ( threads , process , etc ) and over all user computed sets . our computational sublanguage is based on the requirements enforcement analysis language @xcite .",
    "our sublanguage includes all the aadl model types and more traditional types of integers , reals , strings , ranges , and sets .",
    "there are pre - defined functions for common operations ( e.g. sum , union , member ) or queries against the aadl model properties and components .",
    "users may also define their own functions even using recursion , and thus our computational sublanguage is turing complete .",
    "moreover , our sublanguage allows calls out to external tools for richer analyses such as scheduling or model checking .",
    "users may specify any rules or meanings for claims , and thus resolute can make no judgment about how valid the resulting argument is . resolute only ensures that the constructed assurance cases are valid with respect to the user specified claims and rules .",
    "ultimately , the acceptability of an assurance case generated by resolute must depend on traditional assurance case techniques such as expert review .",
    "resolute provides a way of keeping an assurance case synchronized with an architecture model , but the quality of that assurance case is still dependent on the user .",
    "as discussed in section  [ sec : assurance ] , assurance cases have a large and well - developed literature . patterns for assurance case argumentation have been considered in  @xcite , and common fallacies in assurance cases are considered in  @xcite .",
    "an approach to apply and evolve assurance cases as part of system design is found in  @xcite , which is similar to the process we have used in applying the resolute tools . a comparison of assurance cases to prescriptive standards such as do178b / c is provided by @xcite .",
    "recent work on _ confidence cases _ as a means of assessing assurance case arguments is found in  @xcite .",
    "several commercial and research tools support the development of assurance cases .",
    "asce  @xcite from adelard is currently the most widely used commercial tool for constructing assurance cases .",
    "asce supports integration with commercial requirements management tools such as doors , constructing confidence cases with assurance cases , and integration with a variety of tools through its plug - in architecture .",
    "other assurance case tools include advocate  @xcite from nasa ames , certware  @xcite from nasa langley , d - case  @xcite , and nor - sta  @xcite .",
    "these tools provide structured editing , visualization , metrics , and reasoning tools for safety arguments but are not tied into a system architectural model .    in  @xcite ,",
    "a safety case in asce involving a combination of mechanized proof , testing , and hand - proofs is used to argue that the maximum error introduced in the computation of a monotonic function is within some tolerance of the actual value of the function .",
    "this is similar to how we use resolute in the example in section  [ sec : tools ] ; we assemble disparate evidence from different verification techniques towards an argument . unlike our work ,",
    "the asce safety case is not directly integrated into the software / system architecture .",
    "similar work in  @xcite describes patterns for using proofs within a safety case and automation for generating portions of the proof as a part of the safety case .",
    "the evidential tool bus ( etb )  @xcite is very similar in syntax and semantics to resolute .",
    "it is supported by a datalog - style logic and is designed to combine evidence from a variety of sources . however , the focus of the etb is on distribution and on _ provenance_that is , to log the sequence of tool invocations that were performed to solve the query .",
    "it uses timestamps to determine which analyses are out of date with respect to the current development artifacts and to only re - run those analyses that are not synchronized with the current development artifacts .",
    "in addition , it is designed to perform distributed execution of analyses .",
    "analysis tool plug - ins are used to execute the analysis tools within etb .",
    "etb is designed to be tool and model agnostic , and is therefore not integrated with a model of the system architecture .    the work in @xcite ties together",
    "an assurance case with a model - based notation ( simulink ) for the purpose of demonstrating that the simulink - generated code meets its requirements .",
    "this work has many similarities to ours , in that the assurance case is closely tied to the hierarchical structure of the model .",
    "it is more rigorous ( in that the assurance case is derived from a formal proof ) but also much more narrow , corresponding to a component in the system assurance cases that we create .",
    "the two approaches could perhaps be integrated to provide more rigorous safety cases for a wider class of software developed in a model - based environment .",
    "we have generated a number of assurance cases with resolute for the design of a uav in the hacms project .",
    "specifically , we have generated assurance cases that reason about the flow of information through the vehicle and the availability of resources under different operating modes .",
    "the tool has been useful for modeling requirements of the architecture at early phases of the design , and verifying that they still hold in later phases . in future work",
    "we plan to make the assurance cases generated by resolute exportable to more assurance case tools . in order to support this , we may extend resolute with a more complete set of standard assurance case constructs .",
    "for example , we may introduce strategies as first - class constructs by augmenting resolute rules with explicit textual descriptions that would then appear in the assurance case .",
    "we also plan to improve the grammar to support more features of aadl .",
    "the work presented here was sponsored by darpa as part of the hacms program under contract fa8750 - 12 - 9 - 0179 .",
    "n.  basir , e.  denney , and b.  fischer .",
    "deriving safety cases for hierarchical structure in model - based development .",
    "in e.  schoitsch , editor , _ proceedings of the 2010 international conference on computer safety , reliability , and security ( safecomp ) _ , volume 6351 of _ lecture notes in computer science _ , pages 6881 .",
    "springer , 2010 .",
    "d.  d. cofer , a.  gacek , s.  p. miller , m.  w. whalen , b.  lavalley , and l.  sha . compositional verification of architectural models . in a.",
    "e. goodloe and s.  person , editors , _ proceedings of the 4th nasa formal methods symposium ( nfm 2012 ) _ , volume 7226 , pages 126140 , berlin , heidelberg , april 2012 .",
    "springer - verlag .",
    "s.  cruanes , g.  hamon , s.  owre , and n.  shankar .",
    "tool integration with the evidential tool bus . in r.",
    "giacobazzi , j.  berdine , and i.  mastroeni , editors , _ verification , model checking , and abstract interpretation _ ,",
    "volume 7737 of _ lecture notes in computer science _ ,",
    "pages 275294 .",
    "springer berlin heidelberg , 2013 .",
    "l.  cyra and j.  grski .",
    "supporting compliance with security standards by trust case templates . in _",
    "2007 international conference on dependability of computer systems ( depcos - relcomex 2007 ) , june 14 - 16 , 2007 , szklarska poreba , poland _ , pages 9198 .",
    "ieee computer society , 2007 .",
    "e.  denney , g.  pai , and j.  pohl .",
    ": an assurance case automation toolset . in _ proceedings of the 2012 international conference on computer safety , reliability , and security ( safecomp ) _ ,",
    "pages 821 , berlin , heidelberg , 2012 .",
    "springer - verlag .",
    "j.  goodenough , c.  weinstock , and a.  klein . toward a theory of assurance case confidence .",
    "technical report cmu / sei-2012-tr-002 , software engineering institute , carnegie mellon university , september 2012 .",
    "r.  hawkins , k.  clegg , r.  alexander , and t.  kelly . using a software safety argument pattern catalogue : two case studies . in _ proceedings of the 2011 international conference on computer safety , reliability and security ( safecomp ) _ ,",
    "september 2011 .",
    "g.  klein , k.  elphinstone , g.  heiser , j.  andronick , d.  cock , p.  derrin , d.  elkaduwe , k.  engelhardt , r.  kolanski , m.  norrish , t.  sewell , h.  tuch , and s.  winwood . : formal verification of an os kernel . in _ proceedings of the acm",
    "sigops 22nd symposium on operating systems principles _ , sosp 09 , pages 207220 , new york , ny , usa , 2009 ."
  ],
  "abstract_text": [
    "<S> arguments about the safety , security , and correctness of a complex system are often made in the form of an assurance case . </S>",
    "<S> an assurance case is a structured argument , often represented with a graphical interface , that presents and supports claims about a system s behavior . </S>",
    "<S> the argument may combine different kinds of evidence to justify its top level claim . </S>",
    "<S> while assurance cases deliver some level of guarantee of a system s correctness , they lack the rigor that proofs from formal methods typically provide . </S>",
    "<S> furthermore , changes in the structure of a model during development may result in inconsistencies between a design and its assurance case . </S>",
    "<S> our solution is a framework for automatically generating assurance cases based on 1 ) a system model specified in an architectural design language , 2 ) a set of logical rules expressed in a domain specific language that we have developed , and 3 ) the results of other formal analyses that have been run on the model . </S>",
    "<S> we argue that the rigor of these automatically generated assurance cases exceeds those of traditional assurance case arguments because of their more formal logical foundation and direct connection to the architectural model . </S>"
  ]
}