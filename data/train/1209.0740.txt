{
  "article_text": [
    "errors exist in many storage devices @xcite . in optical disks , read only memories and quantum memories , the error probability from @xmath3 to @xmath2 is significantly higher than the error probability from @xmath2 to @xmath3 , which is modeled by z - channels where the transmitted sequences only suffer one type of errors , say @xmath1 . in some other devices , like flash memories and phase change memories ,",
    "although the error probability from @xmath2 to @xmath3 is still smaller than that from @xmath3 to @xmath2 , it is not ignorable .",
    "that means both types of errors , say @xmath1 and @xmath4 are possible , modeled by binary asymmetric channels .",
    "in contrast to symmetric errors , where the error probability of a codeword is context independent ( since the error probability for 1s and 0s is identical ) , asymmetric errors are context dependent .",
    "for example , the all-1 codeword is prone to have more errors than the all-0 codeword in both z - channels and binary asymmetric channels .",
    "the construction of asymmetric error correcting codes is a topic that was studied extensively . in @xcite ,",
    "klve summarized and presented several such codes .",
    "in addition , a large amount of efforts are contributed to the design of systematic codes @xcite , constructing single or multiple error - correcting codes @xcite , increasing the lower bounds @xcite and applying ldpc codes in the context of asymmetric channels @xcite .",
    "however , the existing approach for code construction is similar to the approach taken in the construction of symmetric error - correcting codes , namely , it assumes that every codeword could tolerate @xmath0 asymmetric errors ( or generally @xmath5 @xmath1 errors and @xmath6 @xmath4 errors ) . as a result",
    ", different codewords might have different reliability . to see this ,",
    "let s consider errors to be i.i.d .",
    ", where every bit that is a 1 can change to a 0 by an asymmetric error with crossover probability @xmath7 and each bit that is a @xmath2 keeps unchanged . for a codeword @xmath8 , let @xmath9 denote the hamming weight of @xmath10 .",
    "then the probability for @xmath10 to have at most @xmath0 asymmetric errors is @xmath11 since @xmath10 can correct @xmath0 errors , @xmath12 is the probability of correctly decoding @xmath10 ( assuming codewords with more than @xmath0 errors are uncorrectable ) .",
    "it can be readily observed that the reliability of codewords decreases when their hamming weights increase , for example , see fig .",
    "[ fig_errorprobability ] .    while asymmetric errors are content dependent , in most applications of data storage the reliability of each codeword should be content independent .",
    "namely , unaware of data importance , no matter what content is stored , it should be retrieved with very high probability .",
    "the reason is that once a block can not be correctly decoded , the content of the block , which might be very important , will be lost forever .",
    "so we are interested in the worst - case performance rather than the average performance that is commonly considered in telecommunication , and we want to construct error - correcting codes that can guarantee the reliability of every codeword . in this case , it is not desired to let all the codewords tolerate the same number of asymmetric errors , since the codeword with the highest hamming weight will become a ` bottleneck ' and limit the code rate .",
    "we call the existing codes _ uniform codes _ while we focus on the notion of _ nonuniform codes _ , namely , codes whose codewords can tolerate different numbers of asymmetric errors depending on their hamming weights .",
    "the goal of introducing nonuniform codes is to maximize the code size while guaranteeing the reliability of each codeword for combating asymmetric errors .",
    "and @xmath13 when @xmath14 and @xmath15.,width=288 ]    in a nonuniform code , given a codeword @xmath16 of weight @xmath17 , we let @xmath18 denote the number of @xmath1 errors that @xmath10 has to tolerate , and we let @xmath19 denote the number of @xmath4 errors that @xmath10 has to tolerate . both @xmath20 and @xmath21 are step functions on @xmath22 that can be predetermined by the channel , the types of errors and the required reliability . in this paper , we consider @xmath20 a nondecreasing function and @xmath21 a nonincreasing function of codeword weight . as a result ,",
    "we call such a code as a nonuniform code correcting @xmath23 $ ] errors . in particular , for z - channels",
    "where @xmath24 for all @xmath25 , we call it a nonuniform code correcting @xmath20 asymmetric errors .",
    "surprisingly , while nonuniform codes seem to be a natural idea ( especially in data storage applications ) , they were not studied in the literature .    in z - channels , let @xmath26 be the crossover probability of each bit from @xmath3 to @xmath2 and let @xmath27 be maximal tolerated error probability for each codeword . if we consider the errors to be i.i.d .",
    ", then we can get @xmath28 for @xmath25 . in this case , every erroneous codeword can be corrected with probability at least @xmath29 .",
    "the following notations will be used throughout of this paper : @xmath30    in this paper , we introduce the concept of nonuniform codes and study their basic properties , upper bounds on the rate , asymptotic performance , and code constructions .",
    "we first focus on z - channels and study nonuniform codes correcting @xmath20 asymmetric errors .",
    "the paper is organized as follows : in section  [ section_properties ] , we provide some basic properties of nonuniform codes . in section  [ section_upper ]",
    ", we give an almost explicit upper bound for the size of nonuniform codes .",
    "section  [ section_asymptotic ] studies and compares the asymptotic performances of nonuniform codes and uniform codes .",
    "two general constructions , based on multiple layers or bit flips , are proposed in section  [ section_construction1 ] and section  [ section_construction2 ] .",
    "finally , we extend our discussions and results from z - channels to general binary asymmetric channels in section  [ section_general ] , where we study nonuniform codes correcting @xmath31 $ ] errors , namely , @xmath20 @xmath1 errors and @xmath21 @xmath32 errors . concluding remarks are presented in section  [ section_conclusion ] .",
    "storage devices such as optical disks , read - only memories and quantum atomic memories can be modeled by z - channels , in which the information can suffer a single type of error , namely @xmath1 . in this section ,",
    "we study some properties of nonuniform codes for z - channels , namely , codes that only correct @xmath20 asymmetric errors .",
    "typically , @xmath18 is a nondecreasing function in @xmath17 , the weight of the codeword .",
    "we prove it in the following lemma for the case of i.i.d . errors .",
    "[ lemma_sec1_1 ] assume the errors in a z - channel are i.i.d .",
    ", then given any @xmath33 , the function @xmath20 defined in ( [ equ_property_1 ] ) satisfies @xmath34 for all @xmath35 .",
    "let us define @xmath36 then @xmath37 which leads us to @xmath38 .",
    "\\label{equation_1_1}\\end{aligned}\\ ] ]    first , let us prove that @xmath39 .",
    "since @xmath40 we have @xmath41 .    we know that @xmath42 , so @xmath43 according to definition of @xmath18 , we can conclude that @xmath39 .",
    "second , let us prove that @xmath44 . based on equation ( [ equation_1_1 ] )",
    ", we have @xmath45.\\end{aligned}\\ ] ] so @xmath46 .    we know that @xmath47 , therefore @xmath48 according to the definition of @xmath49 , we have @xmath50 .",
    "this completes the proof",
    ".    given two binary vectors @xmath51 and @xmath52 , we say @xmath53 if and only if @xmath54 for all @xmath55 .",
    "let @xmath56 be the ( asymmetric ) ` ball ' centered at @xmath10 , namely , it consists of all the vectors obtained by changing at most @xmath57 @xmath3s in @xmath10 into @xmath2s , i.e. , @xmath58 where @xmath13 is the weight of @xmath10 and @xmath59    we have the following properties of nonuniform codes as the generalizations of those for uniform codes studied in @xcite .",
    "[ lemma_sec1_2 ] code @xmath60 is a nonuniform code correcting @xmath20 asymmetric errors if and only if @xmath61 for all @xmath62 with @xmath63 .    according to the definition of nonuniform codes",
    ", all the vectors in @xmath56 can be decoded as @xmath10 , and all the vectors in @xmath64 can be decoded as @xmath65 .",
    "hence , @xmath61 for all @xmath62 .",
    "[ lemma_sec1_4 ] there always exists a nonuniform code of the maximum size that corrects @xmath20 asymmetric errors and contains the all - zero codeword .",
    "let @xmath60 be a nonuniform code correcting @xmath20 asymmetric errors , and assume that @xmath66 .",
    "if there exists a codeword @xmath67 such that @xmath68 , then we can get a new nonuniform code @xmath69 of the same size by replacing @xmath10 with @xmath70 in @xmath60 .",
    "if there does not exist a codeword @xmath67 such that @xmath68 , then we can get a larger nonuniform code @xmath69 by adding @xmath70 to @xmath60",
    ".    given a nonuniform code @xmath60 , let @xmath71 denote the number of codewords with hamming weight @xmath72 in @xmath60 , i.e. , @xmath73    given a nondecreasing function @xmath20 , let @xmath74 denote a set of weights that can reach weight @xmath72 with at most @xmath20 asymmetric errors , namely , @xmath75    [ lemma_sec1_5 ] let @xmath60 be a nonuniform code correcting @xmath20 asymmetric errors . for @xmath76 , we have @xmath77    let @xmath78 be the set consisting of all the vectors of length @xmath79 and weight @xmath72 .",
    "if @xmath67 with @xmath80 , according to the properties of @xmath20 , @xmath56 contains @xmath81 vectors of weight @xmath72 , namely @xmath82 according to lemma  [ lemma_sec1_2 ] , we know that @xmath83 is a disjoint union , in which the number of vectors is @xmath84 since @xmath85 and there are at most @xmath86 vectors in @xmath87 , the lemma follows .",
    "let @xmath88 denote the maximum size of a uniform code correcting @xmath0 asymmetric errors , and let @xmath89 denote the maximum size of a nonuniform code correcting @xmath20 asymmetric errors , where @xmath0 is a constant and @xmath20 is a nondecreasing function of codeword weight . in this section , we first present some existing results on the upper bounds of @xmath88 for uniform codes .",
    "then we derive an almost explicit upper bound of @xmath89 for nonuniform codes .      an explicit upper bound to @xmath88",
    "was given by varshamov @xcite .",
    "in @xcite , borden showed that @xmath88 is upper bounded by @xmath90 where @xmath91 is the maximal number of vectors in @xmath92 with hamming distance at least @xmath93 .",
    "goldbaum @xcite pointed out that the upper bounds can be obtained using integer programming . by adding more constrains to the integer programming",
    ", the upper bounds were later improved by delsarte and piret @xcite and weber et al .",
    "klve generalized the bounds of delsarte and piret , and gave an almost explicit upper bound which is very easy to compute by relaxing some of the constrains@xcite , in the following way .    _",
    "@xcite _ for @xmath94 , let @xmath95 be defined by @xmath96 , \\forall 1\\leq r\\leq \\frac{n}{2}-t,\\\\    4 ) & \\hspace{0.05in}y_{n - r } = y_r , \\quad \\forall 0\\leq r < \\frac{n}{2}.\\end{aligned}\\ ] ] then @xmath97.[theorem_sec2_1 ]    this method obtains a good upper bound to @xmath88 ( although it is not the best known one ) .",
    "since it is easy to compute , when @xmath79 and @xmath0 are large , it is every useful for analyzing the sizes of uniform codes .",
    "we now derive an almost explicit upper bound for the size of nonuniform codes correcting @xmath20 asymmetric errors , followed the idea of klve @xcite for uniform codes . according to the lemmas in the previous section",
    ", we can get an upper bound of @xmath89 , denoted by @xmath98 , such that @xmath99 where the maximum is taken over the following constraints : @xmath100 here , condition @xmath101 is given by lemma  [ lemma_sec1_4 ] , and condition @xmath102 is given by lemma  [ lemma_sec1_5 ] .",
    "our goal is to find an almost explicit way to calculate @xmath103 .",
    "[ lemma_sec2_1 ] assume @xmath104 is maximized over @xmath105 in the problem above .",
    "if @xmath106 for some integer @xmath107 with @xmath108 , then @xmath109    .,width=192 ]    suppose that @xmath110 for some @xmath72 that satisfies the above condition .",
    "let @xmath111 and @xmath112 , as indicated in figure [ fig_upper ] , where a triangular denote the ball centered at the top vertex .",
    "furthermore , we let @xmath113 .",
    "note that in this case @xmath114 and @xmath115 .",
    "we first prove that for all @xmath116 , @xmath117 . in order to prove this , we let @xmath118",
    ", then we get @xmath119    it is easy to obtain that @xmath120    so @xmath121    now , we construct a new group of real numbers @xmath122 such that @xmath123 with @xmath124 @xmath125    for such @xmath126 , it is not hard to prove that @xmath127 for @xmath76 . on the other hand ,",
    "@xmath128 which contradicts our assumption that @xmath104 is maximized over the constrains .",
    "so the lemma is true .",
    "[ lemma_sec2_2 ] assume @xmath104 is maximized over @xmath105 in the problem above . if @xmath106 for some integer @xmath107 with @xmath108 , then @xmath129 where @xmath130    _ sketch of proof : _ let @xmath131 . if @xmath132 , then the lemma is true .",
    "so we only need to prove it for the case that @xmath133 .",
    "similar to lemma  [ lemma_sec2_1 ] , we assume @xmath110 , to get the contradiction , we can construct a new group of real numbers @xmath134 such that @xmath135.\\end{aligned}\\ ] ] with @xmath136    for this @xmath134 , they satisfy all the constrains and @xmath137 at the same time , it can be proved that @xmath138 which contradicts with our assumption that @xmath104 is maximized over the constrains .",
    "this completes the proof .",
    "now let @xmath95 be a group of optimal solutions to @xmath139 that maximize @xmath140 .",
    "then @xmath95 satisfy the condition in lemma  [ lemma_sec2_2 ] .",
    "we see that @xmath141 . then based on lemma  [ lemma_sec2_2 ]",
    ", we can get @xmath142 uniquely by iteration .",
    "hence , we have the following theorem for calculating the upper bound @xmath103 .",
    "let @xmath95 be defined by @xmath143,\\\\       & \\hspace{0.05in}\\forall 1\\leq r\\leq n.\\end{aligned}\\ ] ] then @xmath144.[theorem_sec2_2 ]    this theorem provides an almost explicit expression for the upper bound @xmath98 , which is much easier to calculate than the equivalent expression defined at the beginning of this subsection .",
    "note that in the theorem , we do not have a constrain like the one ( constraint 4 ) in theorem  [ theorem_sec2_1 ] .",
    "it is because that the optimal nonuniform codes do not have symmetric weight distributions due to the fact that @xmath18 monotonically increases with @xmath17 .",
    "here we focus on i.i.d",
    ". errors , i.e. , given the crossover probability @xmath26 from @xmath2 to @xmath3 and the maximal tolerated error probability @xmath145 , the function @xmath20 is defined in equation ( [ equ_property_1 ] ) . in this case , we can write the maximum size of a uniform code as @xmath146 , and write the maximum size of a nonuniform code as @xmath147 .    .,width=345 ]    now we let @xmath148 denote the maximal code rate defined by @xmath149 similar , we let @xmath150 denote the maximal code rate defined by @xmath151 by the definition of uniform and nonuniform codes , it is simple to see that @xmath152 .    figure [ fig_upbound2 ] depicts the upper bounds of @xmath148 and @xmath150 for different values of @xmath26 when @xmath153 and @xmath154 .",
    "the upper bound of @xmath148 is obtained based on the almost explicit upper bound given by klve , and the upper bound of @xmath150 is obtained based on the almost explicit method proposed in this section .",
    "it demonstrates that given the same parameters , the upper bound for nonuniform codes is substantially greater than that for uniform codes .",
    "in this section , we study and compare the asymptotic rates of uniform codes and nonuniform codes .",
    "note that the performance of nonuniform codes strongly depends on the selection of the function @xmath20 . here , we focus on i.i.d",
    ". errors , so given @xmath33 , we study the asymptotic behavior of @xmath155 and @xmath156 as @xmath157 . by the definition of nonuniform and uniform codes ,",
    "the ` balls ' containing up to @xmath158 ( or @xmath159 ) errors that are centered at codewords @xmath10 need to be disjoint .    before giving the asymptotic rates , we first present the following known result : for any @xmath160 , when @xmath79 is large enough , we have @xmath161 where @xmath162 is the entropy function with @xmath163 and @xmath164    let @xmath165 be the maximum size of a constant - weight binary code of codeword length @xmath79 , whose hamming weight is @xmath17 and minimum distance is @xmath93 .",
    "let @xmath166 be the maximum size of a binary code with hamming weight @xmath17 and codeword length @xmath79 where every codeword can correct @xmath0 asymmetric errors .",
    "then @xmath167    let @xmath60 be a code of length @xmath79 , constant weight @xmath17 and size @xmath166 that corrects @xmath0 asymmetric errors .",
    "for all @xmath16 , let s define @xmath168 be the set consisting of all the vectors obtained by changing at most @xmath0 @xmath3s in @xmath10 into @xmath2s , i.e. , @xmath169 then @xmath170 , we know that @xmath171 .",
    "let @xmath172 be a vector such that @xmath173 for @xmath55",
    ". then @xmath174 and @xmath175 .",
    "w.l.o.g , suppose that @xmath176",
    ". then @xmath177 , and the hamming distance between @xmath10 and @xmath65 is @xmath178 so the minimum distance of @xmath60 is at least @xmath179 . as a result , @xmath180 .",
    "on the other hand , if a constant - weight code has minimum distance at least @xmath179 , it can correct @xmath0 asymmetric errors . as a result , @xmath181 .",
    "let us first give the lower bound of @xmath182 and then provide the upper bound .",
    "[ theorem_asym1 ] given @xmath183 , if @xmath184 , we have @xmath185    we consider uniform codes that correct @xmath0 asymmetric errors , where @xmath186    according to hoeffding s inequality , for any @xmath160 , as @xmath79 becomes large enough , we have @xmath187 . if we write @xmath188 , then @xmath189 for @xmath79 large enough .    since each codeword tolerates @xmath0 asymmetric errors , we have @xmath190 for every @xmath17 with @xmath25 .",
    "the gilbert bound gives that ( see graham and sloane@xcite ) @xmath191    hence @xmath192 } { { w \\choose i } } { { n - w \\choose i}}}\\\\    & \\geq & \\max_{w : \\frac{w(n - w)}{n}>t } \\frac { { { n \\choose w}}}{n\\max_{i\\in [ 0,t ] } { { w \\choose i } } { { n - w \\choose",
    "i}}}\\\\    & \\geq & \\max_{w : \\frac{w(n - w)}{n}>t } \\frac { { { n \\choose w}}}{n { { w \\choose t } } { { n - w \\choose t}}}.\\end{aligned}\\ ] ]    for a binomial term @xmath193 and @xmath160 , when @xmath79 is large enough , @xmath194    let @xmath195 and @xmath188 with @xmath196 , as @xmath79 becomes large enough , we have @xmath197    from @xmath198 , we get @xmath199 ; then @xmath200 is a continuous function of @xmath201 . as @xmath79 becomes large ,",
    "we have @xmath202 , so we can approximate @xmath200 with @xmath203 .",
    "similarly , we can approximate @xmath204 with @xmath205 .",
    "then we can get as @xmath206 , @xmath207    if @xmath208 , the maximum value can be achieve at @xmath209 .",
    "hence we have @xmath185    this completes the proof .",
    "[ theorem_asym2 ] given @xmath210 , we have @xmath211.\\ ] ]    for a uniform code correcting @xmath0 asymmetric errors , we have the following observations :    1 .",
    "there is at most one codeword with hamming weight at most @xmath0 ; 2 .   for @xmath212 ,",
    "the number of codewords with hamming weight @xmath17 is at most @xmath213 .",
    "consequently , the total number of codewords is @xmath214    so as @xmath206 , we have @xmath215\\\\ & \\leq &   \\frac{1}{n}\\log \\frac{2^{(1+\\gamma)n}}{2^{h(\\frac{\\gamma}{1+\\gamma})(1+\\gamma)n}}\\\\ & = & ( 1+\\gamma)-h(\\frac{\\gamma}{1+\\gamma})(1+\\gamma)\\\\ & = & ( 1+p)[1-h(\\frac{p}{1+p})],\\end{aligned}\\ ] ] where the last step is due to the continuousness of @xmath216 over @xmath201 .",
    "this completes the proof .",
    "we see that when @xmath157 , @xmath155 does not depends on @xmath145 as long as @xmath183 .",
    "it is because that when @xmath206 , we have @xmath217 , which does not depend on @xmath145",
    ". this property is also hold by @xmath156 when @xmath157 .      in this subsection",
    ", we study the bounds of the asymptotic rates of nonuniform codes . here",
    ", we use the same idea as that for uniform codes , besides that we need also prove that the ` edge effect ' can be ignored , i.e. , the number of codewords with hamming weight @xmath219 does not dominate the final result .",
    "[ theorem_asym3 ] given @xmath210 , we have @xmath220    we consider nonuniform codes that corrects @xmath20 asymmetric errors , where @xmath221 for all @xmath25 .",
    "based on hoeffding s inequality , for any @xmath160 , as @xmath17 becomes large enough , we have @xmath222 . in another word , for any @xmath223 , when @xmath79 is large enough and @xmath224 , we have @xmath222 .",
    "let @xmath195 and @xmath225 , then when @xmath79 is large enough , if @xmath226 , we have @xmath227 if @xmath228 , we call it the ` edge ' effect . in this case @xmath229 .    since each codeword with hamming weight @xmath17 can tolerate @xmath18 errors , @xmath230 for every @xmath17 with @xmath25 .    applying the gilbert bound , we have @xmath231    then @xmath232}n { { w \\choose i } } { { n - w \\choose",
    "i}}}\\\\    & \\geq & \\max_{w : \\frac{w(n - w)}{n}\\geq t_{\\downarrow}(w ) } \\frac { { { n \\choose w}}}{n { { w \\choose t_{\\downarrow}(w ) } } { { n - w \\choose   t_{\\downarrow}(w)}}}.\\end{aligned}\\ ] ]    when @xmath157 , we have @xmath233    note that when @xmath228 for small @xmath234 , we have @xmath235 so we can ignore this edge effect .",
    "that implies that we can write @xmath236 for any @xmath237 with @xmath238 .",
    "since @xmath239 , for any fixed @xmath237 , @xmath240 is a continuous function of @xmath201 . as @xmath206 , we have @xmath241    this completes the proof .        ' '' ''    & lower bound & upper bound +    ' '' ''    @xmath242 & @xmath243i_{0\\leq p\\leq \\frac{1}{4}}$ ] & @xmath244 $ ] +    ' '' ''    @xmath245 & @xmath246 & @xmath247 +    [ nonuniform_table1 ]        [ theorem_asym4 ] given @xmath210 , we have @xmath248 with @xmath249 .    here",
    "we use the same notations as above .",
    "similar as the proof in theorem  [ theorem_asym2 ] , given @xmath250 , the maximal number of codewords is @xmath251    as @xmath206 , we have @xmath252    note that when @xmath228 for small @xmath234 , we have @xmath253 so we can ignore the edge effect .",
    "that implies that we can write @xmath236 for any @xmath237 with @xmath238 .",
    "since for any fixed @xmath237 with @xmath254 , @xmath255 is a continuous function of @xmath201 . when @xmath157 , we have @xmath256 which equals to @xmath257 with @xmath249 .",
    "this completes the proof .",
    "table [ nonuniform_table1 ] summarizes the analytic upper bounds and lower bounds of @xmath242 and @xmath245 obtained in this section . for the convenience of comparison",
    ", we plot them in figure  [ fig_asymp ] .",
    "the dashed curves represent the lower and upper bounds to @xmath182 , and the solid curves represent the lower and upper bounds to @xmath218 .",
    "the gap between the bounds for the two codes indicate the potential improvement in efficiency ( code rate ) by using the nonuniform codes ( compared to using uniform codes ) when the codeword length is large .",
    "we see that the upper bound in theorem [ theorem_asym4 ] is also the capacity of the z - channel , derived in @xcite .",
    "it means that nonuniform codes may be able to achieve the z - channel capacity as @xmath79 becomes large , while uniform codes can not ( here we assume that they have codewords of high weights and worst - case performance is considered , so the constructions of uniform codes can not achieve the capacity of z - channel ) .",
    "in @xcite , klve summarized some constructions of uniform codes for correcting asymmetric errors .",
    "the code of kim and freiman was the first one constructed for correcting multiple asymmetric errors .",
    "varshamov @xcite and constrain and rao @xcite presented some constructions based group theory .",
    "later , delsarte and piret @xcite proposed a construction based on ` expurgating / puncturing ' with some improvements given by weber et al.@xcite .",
    "it is natural for us to ask whether it is possible to construct nonuniform codes based on existing constructions of uniform codes . in this section ,",
    "we propose a general construction of nonuniform codes based on multiple layers .",
    "it shows that the sizes of the codes can be significantly increased by equalizing the reliability of all the codewords .",
    "let us start from a simple example : assume we want to construct a nonuniform code with codeword length @xmath258 and @xmath259 in this case , how can we construct a nonuniform code efficiently ?",
    "intuitively , we can divide all the codewords into two layers such that each layer corresponds to an individual uniform code , namely , we get a nonuniform code @xmath260 where @xmath261 is a uniform code correcting @xmath3 asymmetric error and @xmath262 is a uniform code correcting @xmath263 asymmetric errors .",
    "so we can obtain a nonuniform code by combining multiple uniform codes , each of which corrects a number of asymmetric errors .",
    "we call nonuniform codes constructed in this way as _ layered codes_. however , the simple construction above has a problem  due to the interference of neighbor layers , the codewords at the bottom of the higher layer may violate our requirement of reliability , namely , they can not correct sufficient asymmetric errors . to solve this problem , we can construct a layered code in the following way : let us first construct a uniform code correcting @xmath263 asymmetric errors .",
    "then we add more codewords into the code such that    1 .",
    "the weights of these additional codewords are less than @xmath264 .",
    "this condition can guarantee that in the resulting nonuniform code all the codewords with weights at least @xmath265 can tolerate @xmath263 errors .",
    "these additional codewords are selected such that the codewords with weights at most @xmath266 can tolerate @xmath3 error .      generally , given a nondecreasing function @xmath20",
    ", we can get a nonuniform code with @xmath159 layers by iterating the process above .",
    "based on this idea , given @xmath267 , we construct layered codes as follows .",
    "let @xmath268 and let @xmath269 be @xmath270 binary codes of codeword length @xmath79 , where @xmath271 and for @xmath272 , the code @xmath273 can correct @xmath0 asymmetric errors . given @xmath20",
    ", we can construct a layered code @xmath60 such that @xmath274 where @xmath275     and @xmath276 .",
    ", width=345 ]    we see that there is a shift of the layers ( corresponding to the function @xmath277 and the function @xmath20 ) , see figure [ fig_layer ] as a demonstration .",
    "the following theorem shows that the construction above satisfies our requirements of nonuniform codes , i.e. , it corrects @xmath278 asymmetric errors .",
    "let @xmath60 be a layered code based on the above construction , then for all @xmath279 , @xmath10 can tolerate @xmath57 asymmetric errors .",
    "we prove that for all @xmath280 with @xmath63 , @xmath281 .",
    "w.l.o.g . , we assume @xmath282 .    if @xmath283 , the conclusion is true .",
    "if @xmath284 and @xmath282 , then @xmath285 .",
    "that means there does not exist a word @xmath286 such that @xmath287 and @xmath288 and @xmath289 .",
    "since @xmath284 , according to the definition of @xmath277 , it is easy to get @xmath290 .",
    "so there does not exist a word @xmath286 such that @xmath287 and @xmath291 and @xmath292 , namely , @xmath281 .",
    "this completes the proof .",
    "we see that the constructions of layered codes are based on the provided group of codes @xmath293 such that @xmath294 and for @xmath272 , and the code @xmath273 corrects @xmath0 asymmetric errors .",
    "examples of such codes include varshamov codes @xcite , bch codes , etc .",
    "the construction of varshamov codes can be described as follows : let @xmath295 be distinct nonzero elements of @xmath296 , and let @xmath297 . for @xmath298 , let @xmath299 .",
    "for @xmath300 and @xmath301 , let @xmath302 where the elementary symmetric function @xmath303 for @xmath304 are defined by @xmath305 then @xmath273 can correct @xmath0 asymmetric errors ( for @xmath306 ) , and @xmath307 .",
    "such a group of codes can also be constructed by bch codes : let @xmath308 be @xmath79 distinct nonzero elements of @xmath309 with @xmath310 . for @xmath301 , let @xmath311      assume @xmath10 is a codeword in @xmath273 and @xmath312 is a received erroneous word with error vector @xmath313 , then there is an efficient algorithm to decode @xmath65 into a codeword , which is denoted by @xmath314 . if @xmath65 has at most @xmath0 asymmetric errors , then @xmath315 .",
    "we show that the layered codes proposed above also have an efficient decoding algorithm if @xmath316 ( for @xmath317 ) are provided and efficient .",
    "let @xmath60 be a layered code based on the above construction , and let @xmath312 be a received word such that @xmath67 and @xmath318 .",
    "to recover @xmath10 from @xmath65 , we enumerate the integers in @xmath319 $ ] .",
    "if we can find an integer @xmath0 such that @xmath320 and @xmath321 , then @xmath315 .    if we let @xmath322 , then we can get that @xmath0 satisfies the conditions and @xmath315 .",
    "so such @xmath0 exists .",
    "now we only need to prove that once there exists @xmath0 satisfying the conditions in the theorem , we have @xmath315 . we prove this by contradiction .",
    "assume there exists @xmath0 satisfying the conditions but @xmath323",
    ". then @xmath324 . since we also have @xmath325 , @xmath326 , which contradicts the property of the layered codes .",
    "this completes the proof .    in the above method , to decode an erroneous word @xmath65 , we can check all the integers between @xmath327 and @xmath328 to find the value of @xmath0 .",
    "once we find the integer @xmath0 satisfying the conditions in the theorem , we can decode @xmath65 into @xmath314 directly .",
    "( note that the length of the interval for @xmath0 , namely @xmath329 , is normally much smaller than @xmath330 .",
    "it is approximately @xmath331 for i.i.d .",
    "errors when @xmath330 is large . )",
    "we see that this decoding process is efficient if @xmath332 is efficient for @xmath301 .",
    "typically , nonlinear codes , like varshamov codes are superior to bch codes . but it is still not well - known how to estimate the sizes of varshamov codes and their weight distributions . to compare uniform constructions and nonuniform constructions for correcting asymmetric errors , we focus on bch codes , namely , we compare normal bch codes with layered bch codes . here ,",
    "we consider i.i.d . errors , and we assume that the codeword length is @xmath153 , the crossover probability is @xmath26 and the maximal tolerated error probability is @xmath145 .",
    ".bch codes with codeword length @xmath333 @xcite [ cols=\"<,<,<,<,<,<,<\",options=\"header \" , ]     [ nonuniform_table2 ]    table [ nonuniform_table2 ] shows the relations between the dimension @xmath270 and the number of errors @xmath0 that can be corrected in bch codes when @xmath153 . according to @xcite ,",
    "many bch codes have approximated binomial weight distribution .",
    "so given an @xmath334 bch code , the number of codewords of weight @xmath335 is approximately @xmath336    for a normal bch code , it has to correct @xmath0 errors with @xmath337 then it has @xmath338 codewords where @xmath270 can be obtained from table [ nonuniform_table2 ] based on the value of @xmath0",
    ".    for a layered bch code , the codewords with hamming weight @xmath17 have to correct @xmath18 asymmetric errors such that @xmath339 for all @xmath25 .",
    "based on the approximated weight distribution of bch codes , the number of codewords in a layered bch codes can be estimated by summing up the numbers of codewords with different weights .    .",
    ", width=345 ]    figure [ fig_bchrate ] plots the estimated rates of bch codes and layered bch codes for different @xmath26 when @xmath153 and @xmath154 . here , for a code @xmath60",
    ", let @xmath340 be the number of codewords , then the rate of @xmath60 is defined as @xmath341 . from this figure , we see that under the same parameters @xmath250 , the rates of layered bch codes are much higher than those of bch codes . by constructing nonuniform codes instead of uniform codes ,",
    "the code rate can be significantly increased . comparing figure [ fig_bchrate ] with figure [ fig_upbound2 ]",
    ", it can be seen that the rates of layered bch codes are very close to the upper bounds of uniform codes .",
    "it implies that we can gain more by considering nonuniform codes rather than nonlinear uniform codes .",
    "many nonlinear codes designed to correct asymmetric errors like varshamov codes are superior to linear codes . however , they do not yet have efficient encoding algorithms , namely , it is not easy to find an efficient encoding function @xmath342 with @xmath343 . in this section ,",
    "we focus on the approach of designing nonuniform codes for asymmetric errors with efficient encoding schemes , by utilizing the well - studied linear codes .",
    "a simple method is that we can use a linear code to correct @xmath159 asymmetric errors directly , but this method is inefficient not only because the decoding sphere for symmetric errors is greater than the sphere for asymmetric errors ( and therefore an overkill ) , but also because for low - weight codewords , the number of asymmetric errors they need to correct can be much smaller than @xmath159 .",
    "our idea is to build a _ flipping code _ that uses only low - weight codewords ( specifically , codewords of hamming weight no more than @xmath344 ) , because they need to correct fewer asymmetric errors and therefore can increase the code s rate . in the rest of this section , we present two different constructions .",
    "first , we construct a linear code @xmath60 ( like bch codes ) of length @xmath79 with generator matrix @xmath345 that corrects @xmath346 symmetric errors .",
    "assume the dimension of the code is @xmath270 .",
    "for any binary message @xmath347 , we can map it to a codeword @xmath10 in @xmath60 such that @xmath348 . next , let @xmath349 denote a word obtained by flipping all the bits in @xmath10 such that if @xmath350 then @xmath351 and if @xmath352 then @xmath353 ; and let @xmath65 denote the final codeword corresponding to @xmath354 . we check whether @xmath355 and construct @xmath65 in the following way : @xmath356 here , the auxiliary bits ( @xmath2s or @xmath3s ) are added to distinguish that whether @xmath10 has been flipped or not , and they form a repetition code to tolerate errors .",
    "the corresponding decoding process is straightforward : assume we received a word @xmath357 . if there is at least one @xmath3 in the auxiliary bits , then we `` flip '' the word by changing all @xmath2s to @xmath3s and all @xmath3s to @xmath2s ; otherwise , we keep the word unchanged .",
    "then we apply the decoding scheme of the code @xmath60 to the first @xmath79 bits of the word .",
    "finally , the message @xmath354 can be successfully decoded if @xmath357 has at most @xmath346 errors in the first @xmath79 bits .      in the previous construction ,",
    "several auxiliary bits are needed to protect one bit of information , which is not very efficient . here",
    "we try to move this bit into the information part of the codewords in @xmath60 .",
    "this motivates us to give the following construction .",
    "let @xmath60 be a systematic linear code with length @xmath79 that corrects @xmath358 symmetric errors ( we will specify @xmath358 later ) .",
    "assume the dimension of the code is @xmath270 .",
    "now , for any binary message @xmath359 of length @xmath360 , we get @xmath361 by adding one bit @xmath2 in front of @xmath354",
    ". then we can map @xmath362 to a codeword @xmath10 in @xmath60 such that @xmath363 where @xmath345 is the generator matrix of @xmath60 in systematic form and the length of @xmath364 is @xmath365 .",
    "let @xmath366 be a codeword in @xmath60 such that the first bit @xmath367 and its weight is the maximal one among all the codeword in @xmath60 , i.e. , @xmath368 generally , @xmath369 is very close to @xmath79 .",
    "for example , in any primite bch code of length @xmath333 , @xmath366 is the all - one vector ; also we can construct ldpc codes that include the all - one vector as long as their parity - check matrices have even number of ones in each column . in order to reduce the weights of the codewords , we use the following operations : calculate the relative weight @xmath370 then we get the final codeword @xmath371 where @xmath372 is the binary sum , so @xmath373 is to flip the bits in @xmath10 corresponding the ones in @xmath366 .",
    "so far , we see that the maximal weight for @xmath65 is @xmath374 .",
    "that means we need to select @xmath358 such that @xmath375 for many linear codes , @xmath376 is the all - one vector , so @xmath377    in the above encoding process , for different binary messages , they have different codewords . and for any codeword @xmath65 , we have @xmath378 .",
    "that is because either @xmath379 or @xmath380 , where both @xmath10 and @xmath366 are codewords in @xmath60 and @xmath60 is a linear code .",
    "so the resulting flipping code is a subset of code @xmath60 .",
    "the decoding process is very simple : given the received word @xmath381 , we can always get @xmath65 by applying the decoding scheme of the linear code @xmath60 if @xmath382 .",
    "if @xmath383 , that means @xmath10 has been flipped based on @xmath366 , so we have @xmath384 ; otherwise , @xmath385 . then the initial message @xmath386 .",
    "we see that the second construction is a little more efficient than the first one , by moving the bit that indicates flips from the outside of a codeword ( of an error - correcting code ) to the inside .",
    "here is an example of the second construction : let @xmath60 be the @xmath387 hamming code , which is able to correct single - bit errors .",
    "the generating matrix of the @xmath387 hamming code is @xmath388 here we have @xmath389 and @xmath390",
    ". assume the binary message is @xmath391 , then we have @xmath392 .",
    "it is easy to see that @xmath366 is the all - one codeword , i.e. , @xmath393 . in this case , @xmath394 , so the final codeword @xmath395 .",
    "assume the binary message is @xmath396 , then we have @xmath397 . in this case , @xmath398 , so the final codeword @xmath399 .",
    "assume the received word is @xmath400 . by applying the decoding algorithm of hamming codes",
    ", we get @xmath401 .",
    "since @xmath383 , we have @xmath384 , and as a result , @xmath396 .",
    "when @xmath79 is sufficiently large , the flipping codes above become nearly as efficient ( in terms of code rate ) as a linear codes correcting @xmath346 symmetric errors .",
    "it is much more efficient than designing a linear code correcting @xmath159 symmetric errors .",
    "note that when @xmath79 is large and @xmath26 is small , these codes can have very good performance on code rate .",
    "that is because when @xmath79 is sufficiently large , the rate of an optimal nonuniform code is dominated by the codewords with the same hamming weight @xmath402 ( @xmath403 ) , and @xmath402 approaches @xmath404 as @xmath26 gets close to @xmath2 .",
    "we can intuitively understand it based on two facts when @xmath79 is sufficiently large : ( 1 ) there are at most @xmath405 codewords in this optimal nonuniform code .",
    "( 2 ) when @xmath26 becomes small , we can get a nonuniform code with at least @xmath406 codewords .",
    "so when @xmath79 is sufficiently large and @xmath26 is small , we have @xmath407 .",
    "hence , an optimal nonuniform code has almost the same asymptotic performance with an optimal weight - bounded code ( hamming weight is at most n/2 ) that corrects @xmath408 asymmetric errors .",
    "let us consider a flipping bch code based on the second construction .",
    "similar as the previous section , we assume that the codeword length is @xmath153 and the number of codewords with weight @xmath335 can be approximated by @xmath409 where @xmath270 is the dimension of the code .",
    "figure [ fig_flippingrate ] compares the estimated rates of flipping bch codes and those of layered bch codes when @xmath153 and @xmath154 .",
    "surprisingly , the flipping bch codes achieves almost the same rates as layered bch codes .",
    "note that , for the layered codes , we are able to further improve the efficiency ( rates ) by replacing bch codes with varshamov codes , i.e. , based on layered varshamov codes .    . ,",
    "in the previous sections , we have introduced and studied nonuniform codes for z - channels . the concept of nonuniform codes can be extended from z - channels to general binary asymmetric channels , where the error probability from @xmath2 to @xmath3 is smaller than the error probability from @xmath3 to @xmath2 but it may not be ignorable . in this case , we are able to construct nonuniform codes correcting a big number of @xmath1 errors and a small number of @xmath4 errors .",
    "such codes can be used in flash memories or phase change memories , where the change in data has an asymmetric property .",
    "for example , the stored data in flash memories is represented by the voltage levels of transistors , which drift in one direction because of charge leakage . in phase change memories , another class of nonvolatile memories , the stored data is determined by the electrical resistance of the cells , which also drifts due to thermally activated crystallization of the amorphous material . this asymmetric property will introduce more @xmath1 errors than @xmath4 errors after a long duration .    in this section ,",
    "we first investigate binary asymmetric channels where the probability from @xmath2 to @xmath3 is much smaller than that from @xmath3 to @xmath2 , namely , @xmath410 , but @xmath411 is not ignorable . in this case , we can let @xmath21 be a constant function .",
    "later , we consider general binary asymmetric channels , where @xmath21 can be an arbitrary nonincreasing step function .",
    "we show that if @xmath21 is a constant function , then correcting @xmath23 $ ] errors is equivalent to correcting @xmath412 asymmetric errors , where @xmath20 can be an arbitrary step functions on @xmath22 .",
    "[ theorem_asymmetric1 ] let @xmath21 be a constant function , a code @xmath60 is a nonuniform code correcting @xmath23 $ ] errors if and only if it is a nonuniform code correcting @xmath412 asymmetric errors .",
    "\\1 ) we first show that if @xmath60 is a nonuniform code correcting @xmath23 $ ] errors where @xmath21 is a constant function , then it can correct @xmath412 asymmetric errors .",
    "we need to prove that there does not exists a pair of codewords @xmath280 such that @xmath413 @xmath414 where @xmath59    .,width=307 ]    let us prove it by contradiction .",
    "assume that their exists a pair of codewords @xmath415 that satisfy the inequalities above . by adding at most @xmath21 @xmath4 errors , we get a vector @xmath416 from @xmath10 such that the hamming distance between @xmath416 and @xmath65 is minimized ;",
    "also we get a vector @xmath357 from @xmath65 such that the hamming distance between @xmath357 and @xmath10 is minimized . in this case , we only need to show that @xmath417 which contradicts with our assumption that @xmath60 can correct @xmath23 $ ] errors . the intuitive way of understanding @xmath418 is shown in figure [ fig_general1 ] . in the figure , we present each vector as a line , in which the solid part is for @xmath3s and the dashed part is for @xmath2s .    if @xmath419 and @xmath420 , then @xmath421 so @xmath422 .",
    "the statement is true .    if @xmath419 and @xmath423 , then @xmath424 . in this case",
    ", @xmath425 we get the statement .    similarly ,",
    "if @xmath420 and @xmath426 , we have @xmath427 and @xmath428    if @xmath429 and @xmath423 , we can get @xmath430 @xmath428    based on the discussions above , we can conclude that if @xmath60 is a nonuniform code correcting @xmath23 $ ] errors where @xmath21 is a constant function , then it is also a nonuniform code correcting @xmath412 asymmetric errors .",
    "\\2 ) we show that if @xmath60 is a nonuniform codes correcting @xmath412 asymmetric errors where @xmath21 is a constant function , then it is also a nonuniform code correcting @xmath31 $ ] errors .",
    "that means for any @xmath280 , there does not exist a vector @xmath364 such that @xmath431 @xmath432    let us prove this by contradiction .",
    "we assume there exists a vector @xmath364 satisfies the above conditions .",
    "now , we define a few vectors @xmath433 such that @xmath434 @xmath435 @xmath436 the intuitive way of understanding these vectors is shown in figure [ fig_general2 ] . in the figure , we present each vector as a line , in which the solid part is for @xmath3s and the dashed part is for @xmath2s .",
    ".,width=307 ]    then @xmath437 @xmath438    now we want to show that @xmath439    since @xmath440 we only to show that @xmath441    according to the definition of @xmath354 , it is easy to get",
    "that @xmath442 so @xmath443 , which leads us to @xmath439    similarly , we can also get @xmath444 in this case , @xmath60 is not a nonuniform codes correcting @xmath412 asymmetric errors , which contradicts with our assumption .",
    "based on the discussions above , we can get the conclusion in the theorem .    according to the above theorem , all our results for z - channels , like upper bounds and constructions of nonuniform codes , can apply to nonuniform codes correcting @xmath23 $ ] errors if @xmath21 is a constant function .",
    "another case of binary asymmetric channel is that @xmath445 but @xmath411 is not much smaller than @xmath446 . in this case , it is not efficient to write @xmath21 as a constant function . instead",
    ", we consider it as a nonincreasing step function .",
    "let @xmath20 be a nondecreasing function and @xmath21 be a nonincreasing function .",
    "a code @xmath60 is a nonuniform code correcting @xmath23 $ ] errors if it is a nonuniform code correcting @xmath447 asymmetric errors . here , for all @xmath25 , @xmath448    let @xmath60 be a nonuniform code correcting @xmath447 errors . for any @xmath280 , w.l.o.g , we assume @xmath449 .",
    "if @xmath450 , then there does not exist a vector @xmath364 such that @xmath431 @xmath432    if @xmath451 , according to the proof in theorem  [ theorem_asymmetric1 ] , we can get that there does not exist a vector @xmath364 such that @xmath452 @xmath453 @xmath454 @xmath455    since @xmath456 @xmath457 @xmath458 we can get that there does not exist a vector @xmath364 such that @xmath431 @xmath432    finally , we conclude that @xmath60 is a nonuniform code correcting @xmath31 $ ] errors .    according to the above theorem , we can convert the problem of constructing a nonuniform codes for an arbitrary binary asymmetric channel to the problem of constructing a nonuniform correcting only @xmath1 errors .",
    "note that this conversion results in a little loss of code efficiency , but typically it is very small . both layered codes and flipping codes can be applied for correcting errors in binary asymmetric channels .",
    "a little point to notice is that @xmath447 might not be a strict nondecreasing function of codeword weight . in this case",
    ", we can find a nondecreasing function @xmath459 which is slightly larger than @xmath447 , and construct a nonuniform code correcting @xmath460 asymmetric errors .",
    "when we apply flipping codes for correcting errors in binary asymmetric channels , we do not have to specify @xmath20 and @xmath21 separately .",
    "for example , assume that i.i.d .",
    "errors are considered .",
    "if the maximal tolerated error probability is @xmath145 , then given a codeword of weight @xmath17 , it has to tolerate total @xmath461 errors . for @xmath25 ,",
    "@xmath462 can be obtained by calculating the minimal integer @xmath0 such that @xmath463 @xmath464 to construct a flipping code , we only need to find a linear code such that it corrects @xmath465 symmetric errors , where @xmath376 is the codeword with the maximum weight in the linear code .",
    "let @xmath20 be a nondecreasing function and @xmath21 be a nonincreasing function .",
    "if a code @xmath60 is a nonuniform code correcting @xmath31 $ ] errors , then it corrects @xmath466 asymmetric errors . here , @xmath467",
    "the proof of this theorem is very similar as the proof for the previous theorem .",
    "it follows the conclusion in theorem  [ theorem_asymmetric1 ] .    according to the theorem above , to calculate the upper bound of nonuniform codes correcting @xmath23 $ ] errors",
    ", we can first calculate the upper bound of nonuniform codes correcting @xmath466 asymmetric errors",
    ". generally speaking , nonuniform codes correcting @xmath23 $ ] errors ( considering the optimal case ) are more efficient than nonuniform codes correcting @xmath447 asymmetric errors , but less efficient than those correcting @xmath466 asymmetric errors . according to the definitions of @xmath468 and @xmath469 , it is easy to get that @xmath470 for @xmath25 .",
    "typically , if @xmath471 , then @xmath472 .",
    "it implies that nonuniform codes correcting @xmath31 $ ] errors are roughly as efficient as those correcting @xmath412 asymmetric errors . if we consider i.i.d .",
    "errors and long codewords , it is equally difficult to correct errors introduced by a binary asymmetric channel with crossover probabilities @xmath446 and @xmath411 or a z - channel with a crossover probability @xmath473 .",
    "in storage systems with asymmetric errors , it is desirable to design error - correcting codes such that the reliability of each codeword is guaranteed in the worst case , and the size of the code is maximized .",
    "this motivated us to propose the concept of nonuniform codes , whose codewords can tolerate a number of asymmetric errors that depends on their hamming weights .",
    "we derived an almost explicit upper bound on the size of nonuniform codes and compared the asymptotic performances of nonuniform codes and uniform codes - it is evident that there is a potential performance gain by using nonuniform codes .",
    "in addition , we presented two general constructions of nonuniform codes , including _ layered codes _ and _ flipping codes_. open problems include efficient encoding for _ layered codes _ and the construction of _ flipping codes _ when @xmath26 is not small . in general ,",
    "the construction of simple and efficient nonuniform codes is still an open problem .",
    "y.  cassuto , m.  schwartz , v.  bohossian , and j.  bruck , ",
    "codes for asymmetric limited - magnitude errors with application to multilevel flash memories , \" _ ieee trans .",
    "inform . theory _",
    "4 , pp . 15821595 , 2010 .",
    "r. r.  varshamov ,  some features of linear codes that correct asymmetric errors \" ( in russian ) , _ doklady akad .",
    "sssr _ , vol .",
    "3 , pp . 546548 , 1964 .",
    "( trans : _",
    "soviet physics - doklady 9 _ , pp . 538540 , 1965 .",
    ")            j. h. weber , c. de vroedt , and d. e. boekee ,  bounds and constructions for binary codes of length less than 24 and asymmetric distance less than 6 , \" _ ieee trans .",
    "inform . theory _",
    "13211331 , 1988 ."
  ],
  "abstract_text": [
    "<S> the construction of asymmetric error correcting codes is a topic that was studied extensively , however , the existing approach for code construction assumes that every codeword should tolerate @xmath0 asymmetric errors . </S>",
    "<S> our main observation is that in contrast to symmetric errors , asymmetric errors are content dependent . </S>",
    "<S> for example , in z - channels , the all-1 codeword is prone to have more errors than the all-0 codeword . </S>",
    "<S> this motivates us to develop nonuniform codes whose codewords can tolerate different numbers of asymmetric errors depending on their hamming weights . </S>",
    "<S> the idea in a nonuniform codes construction is to augment the redundancy in a content - dependent way and guarantee the worst case reliability while maximizing the code size . in this paper , we first study nonuniform codes for z - channels , namely , they only suffer one type of errors , say @xmath1 . specifically , we derive their upper bounds , analyze their asymptotic performances , and introduce two general constructions . </S>",
    "<S> then we extend the concept and results of nonuniform codes to general binary asymmetric channels , where the error probability for each bit from @xmath2 to @xmath3 is smaller than that from @xmath3 to @xmath2 .    </S>",
    "<S> nonuniform codes , asymmetric errors , coding for data storage , bounds and constructions . </S>"
  ]
}