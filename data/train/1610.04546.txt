{
  "article_text": [
    "many researchers have found out the hard way that there s a world of difference between `` works for me on my machine '' and `` works for other people on theirs '' .",
    "many common challenges can be avoided by following a few simple rules ; doing so not only accelerates research , but also improves reproducibility .",
    "scientific software is typically developed and used by a single person , usually a graduate student or postdoc  @xcite .",
    "it may produce the intended results in their hands , but what happens when someone else wants to run it ?",
    "everyone with a few years of experience feels a bit nervous when told to use another person s code to analyze their data : it will often be undocumented , work in unexpected ways ( if it works at all ) , rely on nonexistent paths or resources , be tuned for a single dataset , or simply be an older version than was used in published papers .",
    "the potential new user is then faced with two unpalatable options : hack the existing code to make it work , or start over .",
    "being unable to replicate results is so common that one publication refers to it as `` a rite of passage ''  @xcite .",
    "the root cause of this problem is that most research software is nt _",
    "robust_. the difference between running and being robust is the difference between `` works for me on my machine '' and `` works for other people on a cluster i ve never used '' .",
    "the lack of robustness also leads to many duplicated efforts , which slows the pace of research  @xcite .",
    "bioinformatics software repositories @xcite catalogue dozens to hundreds of tools to perform the same task : for example , in 2016 the bioinformatics links directory included 84 different multiple sequence aligners , 141 tools to analyze transcript expression , and 182 pathway and interaction resources .",
    "some of these tools are legitimate efforts to improve the state - of - the - art , but often they are difficult to install and run  @xcite , and are effectively abandoned after publication  @xcite .",
    "this problem is not unique to bioinformatics , or even to computing  @xcite .",
    "best practices in software engineering specifically aim to increase software robustness . however , most bioinformaticians learn what they know about software development on the job or otherwise informally  @xcite .",
    "existing training programs and initiatives rarely have the time to cover software engineering in depth , especially since the field is so broad and developing so rapidly  @xcite .",
    "in addition , making software robust is not directly rewarded in science , and funding is difficult to come by  @xcite .",
    "some proposed solutions to this problem include restructuring educational programs , hiring dedicated software engineers  @xcite , partnering with private sector or grassroots organizations  @xcite , or using specific technical tools like containerization or cloud computing  @xcite .",
    "each of these requires time and , in some cases , institutional change .",
    "the good news is , you do nt need to be a professionally - trained programmer to write robust software .",
    "in fact , some of the best , most reliable pieces of software in many scientific communities are written by researchers  @xcite who have adopted strong software engineering approaches , have high standards of reproducibility , use good testing practices , and foster inter - institutional collaborations that grow into strong user bases . in the bioinformatics community ,",
    "bioconductor and galaxy follow this path  @xcite .",
    "so what _ is _ `` robust '' software ?",
    "in brief , it :    * works for users other than the original author ; * is kept under version control ; * can be installed on more than one computer or account with relative ease ; * has well - defined input and output formats ; * has documentation that describes what its dependencies are , how to install it , and what the options are ; and * comes with enough tests to show that it actually runs .",
    "these simple rules do nt just ensure that the software will run for other people ; they are also necessary steps toward creating a reusable library that can be shared and reused through a site like cpan or cran .",
    "they are generic and can be applied to all languages , libraries , packages , documentation styles , and operating systems for both closed - source and open - source software .",
    "whether the aim is as simple as sharing the code with collaborators or as complex as using the software in a production analysis environment , increasing the robustness of your software decreases headaches all around .",
    "the readme is the first stop for most new users . at a minimum",
    ", it needs to get a new user started and point them towards more help , if they need it .",
    "numerous guidelines exist on how to write good readmes@xcite ; their key common features are listed below .    *",
    "explain what the software does : * at the beginning of the readme , explain what the software does in one or two sentences .",
    "there s nothing more frustrating than downloading and installing something only to find out that it does nt do what you thought it did .",
    "* list required dependencies : * often , software depends on specific versions of libraries , modules , or operating systems .",
    "this is entirely reasonable as long as it is properly documented .",
    "include the name and version number for each dependency .",
    "several methods exist for acquiring required packages : either provide the commands necessary to download the dependencies ; link to the software homepage ; or ( our preference ) use a dependency manager .",
    "we address dependencies in more detail in rule 5 .",
    "* provide compilation / installation instructions : * if the software needs to be compiled or installed , list those instructions in the readme . also mention if you recommend they use a pre - compiled binary instead through a system such as pip , yum , or apt .",
    "* list input and output files * : all possible input and output files should be listed in this section .",
    "do the files use a particular standard , an extension of an existing format , or your own format ?",
    "if they use a standard format , link to the specification and version .",
    "if you extend the standard or have your own format , define it explicitly , listing all the required fields and acceptable values .",
    "( you get bonus points if you include a script to convert between a standard format and your file format ) .",
    "if there is no rigorous format ( which is common with log files ) , show at least a few lines from an example file and explain what the sections mean .",
    "input files and their formats are included in most documentation , but intermediate , auxiliary , and log files are often missing . _",
    "all _ files should be listed in the readme , even those considered self - explanatory .",
    "log files are often full of valuable information that can be mined for the user s specific purpose . if your users might need to know , `` does this program report the percentage of reads trimmed to remove adapter sequences ? '' they should be able to check the readme and confidently say , `` yes , it is in the log file '' .",
    "* state attributions and licensing : * attributions are how you credit your main contributors ; licenses are how others may use and credit your work .",
    "these files should be available _ before _ the software is installed ( or even downloaded ) . leave no question in anyone s mind about whether your software can be used commercially , how much modification is permitted , and how other software needs to credit you . if your software is not open source , state that clearly .",
    "attributions can also contain a list of `` expert '' users that can be contacted if new users have problems with the software .",
    "the readme file for khmer is a good model : it explains the software s purpose , tells readers where to get help , and includes links to a citation file ( explaining how to cite the project ) and the license file .",
    "usage information provides the first line of help for both first - time and experienced users of command - line applications . ideally , usage is a terse , informative command - line help message that guides the user in the correct use of the software .",
    "terseness is important : usage that extends for multiple screens is a nuisance , especially when printed to standard error instead of standard output ( where it can easily be paged ) .",
    "long output is also much less likely to be read ",
    "usage should provide all of the information necessary to run the software .",
    "it is invoked either by running the software without any arguments , running it with incorrect arguments , or by explicitly choosing a help or usage option .",
    "more standard command - line behaviours are detailed in @xcite .",
    "almost all command - line applications use a combination of posix  @xcite and gnu  @xcite standards for usage .",
    "an example of good usage is gnu s ` mkdir ` command , which makes new directories :    .... $ mkdir --help usage : mkdir [ option ] ... directory ... create the directory(ies ) , if they do not already exist .",
    "mandatory arguments to long options are mandatory for short options too .",
    "-m , --mode = mode    set file mode ( as in chmod ) , not a = rwx - umask    -p , --parents      no error if existing , make parent directories as needed    -v , --verbose      print a message for each created directory    -z , --context = ctx   set the selinux security context of each created                        directory to ctx        --help      display this help and exit        --version   output version information and exit    report mkdir bugs to bug-coreutils@gnu.org gnu coreutils home page : <",
    "http://www.gnu.org/software/coreutils/ > general help using gnu software : < http://www.gnu.org/gethelp/ > for complete documentation , run : info coreutils ' mkdir invocation ' ....    * the syntax for running the program * : this includes the name of the program and defines the relative location of optional and required flags , arguments and values for execution . arguments in [ square brackets ] are usually optional .",
    "an ellipsis (  e.g .",
    "`` [ option ]  '' ) indicates that more than one value can be provided .    *",
    "description * : similar to the readme , the description reminds users of the software s primary function .",
    "* most commonly used arguments , a description of each , and the default values * : not all arguments need to appear in the usage , but those most commonly used should be listed .",
    "users will rely on this for quick reference when working with the software .    *",
    "where to find more information * : whether it s an email address , web site , or manual page , there should be an indication where the user can go to find out more about the software .",
    "* printed to standard output * : usage should be displayed on standard output so that it can be piped into ` less ` , searched with ` grep ` , or compared to the previous version with ` diff ` .",
    "* exit with an appropriate exit code * : when usage is invoked by providing incorrect arguments , the program should exit with a non - zero code to indicate an error . however , when help is explicitly requested , the software should not exit with an error .",
    "software evolves over time , with developers adding or removing features as need dictates . making official releases",
    "stamps a particular set of features with a project - specific identifier so that version can be retrieved for later use . for example , if a paper is published , the software should be released at the same time so that the results can be reproduced .",
    "most software has a version number composed of a decimal number that increments as new versions are released .",
    "there are many different ways to construct and interpret this number , but most importantly for us , a particular software version run with the same parameters should give identical results no matter when it s run .",
    "results include both correct output as well as any errors . * increment your version number every time you release your software to other people*.    semantic versioning is one of the most common types of versioning for open - source software .",
    "version numbers take the form of _",
    "major.minor[.patch]_ , e.g. , 0.2.6 .",
    "changes in the major version number herald significant changes in the software that are not backwards compatible , such as changing or removing features or altering the primary functions of the software .",
    "increasing the minor version represents incremental improvements in the software , like adding new features . following",
    "the minor version number can be an arbitrary number of project - specific identifiers , including patches , builds and qualifiers .",
    "common qualifiers include ` alpha ` , ` beta ` , and ` snapshot ` , for applications that are not yet stable or released , and ` -rc ` for release candidates prior to an official release .",
    "* the version of your software should be easily available by supplying ` --version ` or ` -v ` on the command line*. this command should print the software name and version number , and it should also be * included in all of the program s output * , particularly debugging traces . if someone needs help , it s important that they be able to tell whoever s helping them which version of the software they re using .    while new releases may make a program better in general",
    ", they can simultaneously create work for someone who integrated the old version into their own workflow a year or two ago , and wo nt see any benefits from upgrading .",
    "a program s authors should therefore * ensure that old released versions continue to be available . * a number of mechanisms exist for controlled release that range from as simple as adding an appropriate commit message or tag to version control , to official releases alongside code on bitbucket or github , to depositing into a repository like apt , yum , homebrew , cpan , etc .",
    "choose the method that best suits the number and expertise of users you anticipate .",
    "in the spirit of code reuse and interoperability , developers often want to reuse software written by others . with a few lines ,",
    "a call is made out to the other program and the results are incorporated into the primary script . using popular projects reduces the amount of code that needs to be maintained and leverages the work done by the other software .",
    "unfortunately , reusing software introduces dependencies , which can bring their own special pain .",
    "the interface between two software packages can also be a source of considerable frustration : all too often , support requests descend into debugging errors produced by the other project . in addition , every package someone has to install before being able to use yours is a possible ( some would say `` likely '' ) source of frustration for some potential user .",
    "the way the second program is invoked can throw up errors .",
    "the program may not be in the user s path , or it may be an older or newer version and produce results different than expected .",
    "windows users will be frustrated if you invoke ` bash ` or ` sh ` explicitly or use shell - specific conventions like ` * ' expansion .",
    "even linux - standard functions available vary slightly between installs . for example , gnu ` sort ` is available on almost every * nix distribution , but sorts differently depending on locale .    despite these problems , software developers in research should re - use existing software provided three guidelines",
    "are adhered to .",
    "first , * make sure that you really need the auxiliary program*. if you are executing gnu sort instead of figuring out how to sort lists in python , it may not be worth the pain of integration .",
    "second , * ensure the appropriate software and version is available*. early in execution , check whether the dependency is executable and whether the version is compatible . either allow the user to configure the exact path to the package , distribute the program with the dependent software , or download it during installation using a dependency management system ( see rule 5 ) .",
    "finally , to ensure support on as many different operating systems as possible , * use native functions for starting other processes * , such as java s ` runtime.exec ` call , python s ` subprocess ` module , and perl s ` system ` command , and be sure to capture and report the output of the subprocess s standard error to facilitate debugging .",
    "in all but the simplest of scripts , * use a build automation utility to compile code and/or manage your software workflow*. the benefits of using tools like make , rake , maven , ant or ms build vastly outweigh the their learning curves .",
    "most importantly , a build system lets someone else build your software the same way you would .",
    "most build utilities can also be configured to run tests during every build and re - generate documentation , and can be hooked into continuous integration , cutting releases , and deploying the software to other environments .",
    "build utilities rely on any dependencies being present in the environment for a successful build , and so developers should * document _ all _ dependencies , preferably in a machine - readable form*. package managers like apt and yum are available on most unix - like systems , and application package managers exist for specific languages like python ( pip ) , java ( maven / gradle ) , and ruby ( rubygems ) .",
    "these package managers can be used together with the build utility to ensure that dependencies are available at compile / run time .",
    "for example , it is common for python projects to include a file called ` requirements.txt ` that lists the names of required libraries , along with version ranges :    .... requests>=2.0 pygithub>=1.26,<=1.27 python - social - auth>=0.2.19,<0.3 ....    this file can be read by the pip package manager , which can check that the required software is available and install it if it is not .",
    "whatever is used , we recommend that developers should _ always _ install dependencies using their dependency description , especially on their personal machines , so that they re sure it works .",
    "conversely , developers should * avoid depending on scripts and tools which are not available as packages*. in many cases , a program s author may not realize that some tool was built locally , and does nt exist elsewhere . at present , the only sure way to discover such unknown dependencies is to install on a system administered by someone else and see what breaks . as",
    "use of virtualization containers becomes more widespread , software installation can also be tested on a virtual machine or container system like docker .",
    "root ( also known as `` superuser '' or `` admin '' ) is a special account on a computer that has ( among other things ) the power to modify or delete system files and user accounts .",
    "conversely , files and directories owned by root usually can not be modifed by normal users .",
    "installing or running a program with root privileges is often convenient , since doing so automatically bypasses all those pesky safety checks that might otherwise get in the user s way .",
    "however , those checks are there for a reason : scientific software packages may not intentionally be malware , but one small bug or over - eager file - matching expression can certainly make them behave as if they were .",
    "outside of very unusual circumstances , * packages should not require root privileges to set up or use*.    another reason for this rule is that users may want to try out a new package before installing it system - wide on a cluster .",
    "requiring root privileges will frustrate such efforts , and thereby reduce uptake of the package . requiring ,",
    "as apache tomcat does , that software be installed under its own user account  i.e .",
    ", that ` packagename ` be made a user , and all of the package s software be installed in that pseudo - user s space  is similarly limiting , and makes side - by - side installation of multiple versions of the package more difficult .",
    "developers should therefore * allow packages to be installed in an arbitrary location * , e.g. , under a user s home directory in ` ~/packagename ` , or in directories with standard names like ` bin ` , ` lib ` , and ` man ` under a chosen directory . if the first option is chosen , the user may need to modify her search path to include the package s executables and libraries , but this can ( more or less ) be automated , and is much less risky than setting things up as root .",
    "testing the ability to install software has traditionally been regarded as difficult , since it necessarily alters the machine on which the test is conducted .",
    "lightweight virtualization containers like docker make this much easier as well , or simply * ask another person to try and build your software*.",
    "it s easy to write software that reads input from a file called ` mydata.csv ` , but also very limiting .",
    "if a colleague asks you to process her data , you must either overwrite your data file ( which is risky ) or edit your code to read ` otherdata.csv ` ( which is also risky , because there s every likelihood you ll forget to change the filename back , or will change three uses of the filename but not a fourth ) .",
    "hard - coding file paths in a program also makes the software harder to run in other environments .",
    "if your package is installed on a cluster , for example , the user s data will almost certainly _ not _ be in the same directory as the software , and the folder ` c:\\users\\yourname\\ ` will probably not even exist .    for these reasons , users should be able to * set the names and locations of input and output files as command - line parameters*. this rule applies to reference data sets as well as the user s own data : if a user wants to try a new gene identification algorithm using a different set of genes as a training set , she should not have to edit the software to do so . a corollary to this rule",
    "is * do not require users to navigate to a particular directory to do their work * , since `` where i have to be '' is just another hard - coded path .    in order to save typing ,",
    "it is often convenient to allow users to specify an input or output _ directory _ , and then require that there be files with particular names in that directory .",
    "this practice , which is sometimes called `` convention over configuration '' , is used by many software frameworks , such as wordpress and ruby on rails , and often strikes a good balance between adaptability and consistency .",
    "useful parameters are those values that a user will need to modify to suit their computer , dataset or application .",
    "the full list of useful parameters is software - specific and so can not be detailed here , but a short list includes providing input and reference files and directories , output files and directories , filtering , tuning , random number generation seeds , and alternatives such as compressing results , use a variant algorithm , or verbose output .",
    "providing parameters on the command line increases the flexibility and usability of the program .",
    "you may have determined early in development that 0.58 is an optimal cluster threshold for your original dataset , but that does nt mean it is best for every case .",
    "being able to change parameters on the fly to determine if and how they change the results is important as your software gains more users , as it facilitates exploratory analysis and parameter sweeping . *",
    "choose reasonable defaults where they exist * , and * set no defaults at all when there are nt any reasonable ones*.    you can set reasonable default values as long as any command line arguments override those values .",
    "configuration files should be used in preference to hard - coding the defaults directly .",
    "configuration files can be in a standard location , e.g. ` .packagerc ` in the user s home directory or provided on the command line as an additional argument .",
    "only values that are unlikely to change between runs belong in the config file , such as dependencies , servers , version numbers , network drives , and any other defaults for your lab or institution .",
    "use a default configuration file and specify all other parameters on the command line .",
    "when the software starts , it should * echo all parameters and software versions to standard out or a log file alongside the results*. this feature supports greater reproducibility because any result can be replicated with only the previous output files as reference .",
    "finally , if the software is configurable in any way , it should * check that all input values are in a reasonable range at startup*. few things are as annoying as having a program announce after running for two hours that it is nt going to save its results because the requested directory does nt exist .",
    "every package should come with a small test script for users to run after installation .",
    "its purpose is not only to check that the software is working correctly ( although that is extremely helpful ) , but also to ensure that it works at all .",
    "this test script can also serve as a working example of how to run the software .    in order to be useful ,",
    "* make the test script easy to find and run*. many build systems will also run unit tests if provided them at compile time . if the build system is not amenable to testing , a single file in the project s root directory named ` runtests.sh ` or something equally obvious is a much better solution than documenting test cases and requiring people to copy and paste them .",
    "equally , * make the test script s output easy to interpret*. screens full of correlation coefficients do not qualify : instead , the script s output should be simple to understand for non - experts , such as one line per test , with the test s name and its pass / fail status , followed by a single summary line saying how many tests were run and how many passed or failed . if many or all tests fail because of missing dependencies , that fact should be displayed once , clearly , rather than once per test , so that users have a clear idea of what they need to fix and how much work it s likely to take .",
    "research has shown that the ease with which people can start making contributions is a strong predictor of whether they will or not  @xcite . by making it simpler for outsiders to contribute",
    ", a test suite of any kind also makes it more likely that they will , and software with collaborators stands a better chance of surviving in the busy field of scientific software .",
    "given a set of parameters and a dataset , * a particular version of a program should produce the same results every time it is run * to aid testing , debugging , and reproducibility .",
    "even minor changes to code can cause minor changes in output because of floating - point issues , which means that getting exactly the same output for the same input and parameters probably wo nt work during development , but it should still be a goal for people who have deployed a specific version .",
    "many applications rely on randomized algorithms to improve performance or runtimes . as a consequence , results can change between runs , even when provided with the same data and parameters . by its nature , this randomness renders strict reproducibility and therefore debugging more difficult . if even the small test set ( # 9 ) produces different results for each run , new users may not be able to tell whether the software is working properly .",
    "when comparing results between versions or after changing parameters , even small differences can confuse or muddy the comparison . and especially when producing results for publications , grants or diagnoses , any analysis should be absolutely reproducible .    given the size of biological data , it is unreasonable to suggest that random algorithms be removed .",
    "however , most programs use a pseudo - random number generator , which uses a starting seed and an equation to approximate random numbers . setting the seed to a consistent value can remove randomness between runs .",
    "* allow the user to optionally provide the random seed as an input parameter * , thus rendering the program deterministic for those cases where it matters . if the seed is set internally ( e.g. , using clock time ) , echo it to the output for re - use later .",
    "if setting the seed is not possible , * make sure the acceptable tolerance is known and detailed in documentation and in the tests*.",
    "any short list of rules for developing robust software will necessarily be incomplete .",
    "our more significant omissions include :    * documentation * : :    we think it is very important for developers to document their work ,    but our experience is that people are unlikely do it during normal    development , and we do nt want to recommend practices that people    wo nt actually adopt . however , it is worth noting that software that    is widely used and contributed to has and enforces the need for good    documentation  @xcite .",
    "numerous resources exist for writing high    quality documentation  @xcite and so we do not cover it here .",
    "* services * : :    the rules we present above are necessary , but not sufficient , for    software that needs to interact with services such as database and web    servers .",
    "such software is often stopped and started under automatic    control , may need to authenticate , etc .",
    ", all of which are out of scope    of this paper .",
    "there has been extended discussion over the past few years of the sustainability of research software , but this question is meaningless in isolation : any piece of software can be sustained if its users are willing to put in enough effort .",
    "the real equation is the ratio between the skill and effort available , and the ease with which software can be installed , understood , used , maintained , and extended .",
    "following the ten rules we outline here reduce the denominator , and thereby enable researchers to build on each other s work more easily .",
    "that said , not _ every _ coding effort needs to be engineered to last .",
    "code that is used once to answer a specific question related to a specific dataset does nt require comprehensive documentation or flexible configuration , and the only sensible way to test it may well be to run it on the dataset in question .",
    "exploratory analysis is an iterative process that is developed quick and revised often  @xcite .",
    "however , if a script is dusted off and run three or four times for slightly different purposes , is crucial to a publication or a lab , or being passed on to someone else , it may be time to make your software more robust .",
    "ison j , rapacki k , mnager h , kala m , rydza e , chmura p , et  al .",
    "tools and data services registry : a community effort to document bioinformatics resources .",
    "nucleic acids research .",
    "doi:10.1093/nar / gkv1116 .",
    "atwood tk , bongcam - rudloff e , brazas me , corpas m , gaudet p , lewitter f , et  al .",
    "goblet : the global organisation for bioinformatics learning , education and training .",
    "plos computational biology .",
    "2015;doi:10.1371/journal.pcbi.1004143 .",
    "afgan e , baker d , van  den beek m , blankenberg d , bouvier d , ech m , et  al .",
    "the galaxy platform for accessible , reproducible and collaborative biomedical analyses : 2016 update .",
    "nucleic acids research",
    ". 2016;44(w1):w3w10 .",
    "doi:10.1093/nar / gkw343 .",
    "gentleman rc , carey vj , bates dm , bolstad b , dettling m , dudoit s , et  al .",
    "bioconductor : open software development for computational biology and bioinformatics . genome biology .",
    "doi:10.1186/gb-2004 - 5 - 10-r80 .",
    "steinmacher i , silva mag , gerosa ma , redmiles df . a systematic literature review on the barriers faced by newcomers to open source software projects . information and software technology .",
    "2015;59:67  85 .",
    "doi : http://dx.doi.org/10.1016/j.infsof.2014.11.001 ."
  ],
  "abstract_text": [
    "<S> software produced for research , published and otherwise , suffers from a number of common problems that make it difficult or impossible to run outside the original institution , or even off the primary developer s computer . </S>",
    "<S> we present ten simple rules to make such software robust enough to run anywhere , and inspire confidence in your reproducibility , and thereby delight your users and collaborators . </S>"
  ]
}