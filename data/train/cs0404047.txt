{
  "article_text": [
    "industrial and power burners have some particular requirements , as a customized study of the geometry for combustion head and combustion chamber for an optimal shape of the flame . rapid prototyping for an accurate design of the correct geometry involves a numerical simulation of the gas or oil flows in the burner s components ( see fig .",
    "1 ) .        the necessity of an high graphic resolution require a large amount of particles paths for tracing the streamlines of flow .",
    "hence the numerical computation is memory and cpu very expensive for the used hardware environment . in a tipical simulation",
    "the number of paths to compute is some thousands , and the number of geometrical points to interpolate for each path is some thousands too . for the treatment of this large amount of data",
    "a parallel environment can be very useful .",
    "we suppose to have a dataset output from pre - processing and processing phases of a simulation , for example from numerical resolution of navier - stokes equations or from cellular automaton models [ 1 ] . we would a fast and flexible method to obtain from those data an accurate paths tracking of fluid particles with a smooth 3d visualization of trajectories , possibly with continuous slope and curvature .",
    "our experience shows that computational fluid dynamics packages have some limits in this post - processing phase , principally due to a rigid resolution of the initial mesh and to a small degree of parallelism .",
    "let * s * the number of 3d points for each trajectory and * m * the total number of trajectories from simulation dataset .",
    "we have tested that usual interpolation methods are have some disadvantages for our aims : for example bezier - like is not realistic in case of twisting or diverging speed - fields ; chebychev or least - squares - like are too rigid for a customized application ; polynomial fitting is simple but often shows spurious effects as runge - gibbs phenomenon [ 2 ] .",
    "we have elaborated a _",
    "spline_-based technique .",
    "we suppose * s * = 4x*n*. for every group of four points , the interpolation is obtained by three cubic polynomials imposing four analytical conditions : passage at * p*@xmath0 point , @xmath1 ; passage at * p*@xmath2 point ; continuous slope at * p*@xmath0 point ; continuous curvature at * p*@xmath0 point . for smooth rendering and for avoiding excessive twisting of trajectories , the cubics * u*@xmath0 are added to the bezier curve * b * associated to the four points : * v*@xmath0 = @xmath3*b * + @xmath4*u*@xmath0 , @xmath5 ( see fig .",
    "2 ) .        in our simulations",
    "we have chosen @xmath3 = @xmath4 = 0.5 .",
    "let * b * = @xmath6 , @xmath7 , the bezier curve of control points * p*@xmath8 , ... , * p*@xmath9 , and let * u*@xmath0 = @xmath10 , @xmath11 , the spline between two points .",
    "one can see that the coefficients of this spline can be computed by a matrix - vector product * coeff * = * t***p * where * coeff * = ( @xmath12 , @xmath13 , @xmath14 , @xmath15 ) , * p * = ( * p*@xmath2 , * p*@xmath0 , @xmath16 , @xmath17 , 1 ) and * t * is a 4 x 5 numerical matrix , constant for every groups of points and for every trajectory .",
    "if we define the 4*m*x5*m * _ global matrix _",
    "@xmath18 where * 0 * is a 4x5 zero - matrix , and define the vector * s * = ( * p*@xmath2 , * p*@xmath0 , @xmath19 , @xmath20 , 1 , ... , * p*@xmath2 , * p*@xmath0 , @xmath21 , @xmath22 , 1 ) , one can compute for every two - points group the coefficients of cubic splines for all the * m * trajectories with the matrix - vector product * c * = * g***s*. the matrix * g * is _ sparse _ with density equal at most to 1/*m * ; if * m * = 1000 , the density of 0.001 is a very good value for obtain the benefits of sparsity methods , mainly in computational total time and memory allocation [ 3 ] .",
    "for computing the coefficients of all the splines involved in the simulation , the complexity analysis shows a total number of operations of order * m***n*. using * p * computational processes on a multiprocessor environment , a useful method is the distribution of * m*/*p * trajectories to every process . in this way every process receives * m*/*p * rows of the matrix * g * for computing splines by matrix - vector multiply . in a first experiment ( fall 2003 ) , we have used the linux cluster at cineca , bologna ( italy ) , equipped with pentium iii 1.133 ghz processors , and a software environment constituted by c programs and mpi libraries [ 4 ] .",
    "the use of such parallel routines has been useful only for startup of multi- processes and data distribution .",
    "tests have shown a quasi - linear _ speedup _ , in the sense of parallelism , for all the values of * m * and * n * respect to the number * p * of used processes ( see e.g. fig .",
    "3 ) .        in a second experiment ( winter 2003 )",
    ", we have used a multinode windows 2000 cluster of our company , equipped with a total of 4 intel xeon 3.2 ghz processors and 4 gb ram , and a parallel environment using matlab 6.5 scripts on distributed package s sessions on nodes .",
    "tests have shown very high performances for splines computation using the internal algorithms of sparse matrix - vector multiply for the matrix * g * ( see e.g. fig .",
    "after the computation of splines , we have focused on their valuations on a suitable set of parameter s values .",
    "this set can be chosen large enough to obtain a fine sampling for an high graphic resolution .",
    "consequently the amount of computation can be very huge , so that it is necessary an adequate method to valuate all the splines for all the trajectories .",
    "let * v*+1 the number of ticks for each spline valuation with a uniform sampling ; then the ticks are ( 0 , 1/*v * , 2/*v * , . . .",
    ", ( * v*-1)/*v * , 1 ) .",
    "the values of splines parameter _",
    "t _ are ( 0 , 1 , 2 , 3)-th degree powers of this array .",
    "the value of a cubic at _ t_@xmath23 can be view as a dot product :    @xmath24    this fact permits to consider the constant 4x(*v*+1 ) matrix    @xmath25    we consider the * m*x4 matrix    @xmath26 where each row contains the coefficients of a spline interpolating two points in a single trajectory .",
    "then the * m*x(*v*+1 ) matrix product * e * = * c***t * contains in each row the values of a cubic between two data points , for all the * m * trajectories ( _ eulerian view _ ) . in a similar way on can consider a _",
    "lagrangian view _ for computing the values of all the cubics in a single trajectory .",
    "it can be easily shown that the total number of operations for computing all the values along each trajectory is of order * n*x*m*x(*v*+1 ) .",
    "for the computation of the values we have used the cluster of our company with multisessions of matlab package as parallel environment .",
    "it is fundamental for this step the improvement of performances due to the usage of lapack level 3 blas routines incorporated in matlab [ 5 ] .",
    "another feature of this method is the fact that the matrix * t * is constant , hence it is computed only once , requires a small memory allocation so its values can be stored permanently in the cache . with * p * , number of processes , divisor of 3*n * , total number of two - points groups , the method used has been the distribution of 3*n*/*p * matrices * c * to every process .",
    "the performances of multiprocess products show a quite linear speedup respect the * p * variable and a total computation time of order * n*x*m * ; increasing the value of * m * or * n * for a better resolution , the time spent on computation does nt change if the value of processes is increased ( _ gustafson law _ [ 6 ] ) ( see fig . 5 ) .",
    "these techniques have supplied good results for improving performances of post - processing phase in cfd simulations .",
    "further work is planned for implementing a _ global matrix _ product for the splines evaluation , with the purpose of using the sparse matrices benefits to reduce total execution time and memory allocation .",
    "matlab incorporates lapack . increasing the speed and capabilities of matrix computation .",
    ", winter 2000 , www.mathworks.com/company/newsletters/news_notes/clevescorner/ winter2000.cleve.html ."
  ],
  "abstract_text": [
    "<S> in this work i present a technique of construction and fast evaluation of a family of cubic polynomials for analytic smoothing and graphical rendering of particles trajectories for flows in a generic geometry . </S>",
    "<S> the principal result of the work was implementation and test of a method for interpolating 3d points by regular parametric curves and their fast and efficient evaluation for a good resolution of rendering . for the purpose </S>",
    "<S> i have used a parallel environment using a multiprocessor cluster architecture . </S>",
    "<S> the efficiency of the used method is good , mainly reducing the number of floating - points computations by caching the numerical values of some line - parameter s powers , and reducing the necessity of communication among processes . </S>",
    "<S> this work has been developed for the research & development department of my company for planning advanced customized models of industrial burners . </S>"
  ]
}