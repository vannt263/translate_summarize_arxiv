{
  "article_text": [
    "matching problems have received a lot of attention in different areas .",
    "dynamic load balancing and job scheduling in parallel and distributed networks can be solved by algorithms using a matching set of communication links  @xcite . moreover ,",
    "the matching problem has been recently studied in the algorithmic game theory . indeed , the seminal problem relative to matching introduced by knuth",
    "is the stable marriage problem @xcite .",
    "this problem can be modeled as a game with economic interactions such as two - sided markets @xcite or as a game with preference relations in a social network @xcite .",
    "but , all distributed algorithms proposed in the game theory domain use identities while we are interested in anonymous networks , _",
    "i.e. _ without identity .    in graph theory , a _ matching _",
    "@xmath1 in a graph is a set of edges without common vertices .",
    "a matching is _ maximal _ if no proper superset of @xmath1 is also a matching .",
    "maximum _ matching is a maximal matching with the highest cardinality among all possible maximal matchings . in this paper , we present a self - stabilizing algorithm for finding a maximal matching .",
    "self - stabilizing algorithms @xcite , are distributed algorithms that recover after any transient failure without external intervention _",
    "i.e. _ starting from any arbitrary initial state , the system eventually converges to a correct behavior .",
    "the environment of self - stabilizing algorithms is modeled by the notion of _ daemon_. a daemon allows to capture the different behaviors of such algorithms accordingly to the execution environment .",
    "two major types of daemons exist : the _ sequential _ and the _ distributed _ ones .",
    "the sequential daemon means that exactly one eligible process is scheduled for execution at a time .",
    "the distributed daemon means that any subset of eligible processes is scheduled for execution at a time . in an orthogonal way ,",
    "a daemon can be _ fair _ ( meaning that every eligible process is eventually scheduled for execution ) or _ adversarial _ ( meaning that the daemon only guarantees global progress , _",
    "i.e. _ at any time , at least one eligible process is scheduled for execution ) .    in this paper",
    "we provide two self - stabilizing algorithms .",
    "the first one , called the _ matching algorithm _ , is a randomized algorithm for finding a maximal matching in an anonymous network .",
    "we show the algorithm stabilizes in expected @xmath0 moves under the adversarial distributed daemon .",
    "this is the first algorithm solving this problem assuming at the same time an anonymous network and an adversarial distributed daemon . in this algorithm",
    ", nodes have pointers and a node can determine whether its neighbor points to it or to another node , leading to a contradiction with the anonymous assumption . indeed , to know which node a neighbor is pointing to , the usual way is to use identities . to solve this problem , and",
    "this is the first paper giving a solution , we provide a self - stabilizing algorithm where we assume the classical link - register model , _",
    "i.e. _ a node communicates with a neighbor through a register associated to the link from the node to this neighbor .",
    "this algorithm , called the _ link - name algorithm _ , gives names to communication links such that ( i ) both nodes at the extremity of a link @xmath2 know the name of @xmath2 and ( ii ) a node can not have two distinct incident links with the same name . at the end of this paper",
    ", we will see how to rewrite the matching algorithm using output of the link - name algorithm , allowing then a process to know if one of its neighbors points to it without using identity .",
    "several self - stabilizing algorithms have been proposed to compute maximal matching in unweighted or weighted general graphs . for an unweighted graph , hsu and",
    "huang @xcite gave the first algorithm and proved a bound of @xmath0 on the number of moves under a sequential adversarial daemon .",
    "the complexity analysis is completed by hedetniemi et al .",
    "@xcite to @xmath3 moves .",
    "manne et al .",
    "@xcite presented a self - stabilizing algorithm for finding a @xmath4-approximation of a maximum matching .",
    "the complexity of this algorithm is proved to be @xmath5 moves under a distributed adversarial daemon . in a weighted graph , manne and mjelde @xcite presented the first self - stabilizing algorithm for computing a weighted matching of a graph with an @xmath6-approximation to the optimal solution .",
    "they that established their algorithm stabilizes after at most exponential number of moves under any adversarial daemon ( _ i.e. _ sequential or distributed ) .",
    "turau and hauck @xcite gave a modified version of the previous algorithm that stabilizes after @xmath7 moves under any adversarial daemon .",
    "all algorithms presented above , but the hsu and huang @xcite , assume nodes have unique identity .",
    "the hsu and huang s algorithm is the first one working in an anonymous network .",
    "this algorithm operates under any sequential daemon ( fair or adversarial ) in order to achieve symmetry breaking .",
    "indeed , manne et al .",
    "@xcite proved that in some anonymous networks there exists no deterministic self - stabilizing solution to the maximal matching problem under a synchronous daemon .",
    "this is a general result that holds under either the fair or the adversarial distributed daemon .",
    "this also holds whatever the communication and atomicity model ( the state model with guarded rule atomicity or the link - register model with read / write atomicity ) .",
    "goddard et al .",
    "@xcite proposed a generalized scheme that can convert any anonymous and deterministic algorithm that stabilizes under an adversarial sequential daemon into a randomized one that stabilizes under a distributed daemon , using only constant extra space and without identity .",
    "the expected slowdown is bounded by @xmath0 moves .",
    "the composition of these two algorithms can compute a maximal matching in @xmath8 moves in an anonymous network under a distributed daemon .    in anonymous networks , gradinariu and",
    "johnen @xcite proposed a self - stabilizing probabilistic algorithm to give processes a local identity that is unique within distance @xmath9 .",
    "they used this algorithm to run the hsu and huang s algorithm under an adversarial distributed daemon .",
    "however , only a finite stabilization time was proved .",
    "chattopadhyay et al .",
    "@xcite improved this result by giving a maximal matching algorithm with @xmath10 expected rounds complexity under the fair distributed daemon .",
    "note that a _ round _ is a minimal sequence of moves where each node makes at least one move .",
    "it is straightforward to show that this algorithm stabilizes in @xmath11 moves , but chattopadhyay et al",
    ". do not give any upper bound on the move complexity .    the previous algorithm as well as the maximal matching algorithm presented in this work both assume an anonymous network and a distributed daemon .",
    "however the first algorithm assumes the fair daemon while the second one does not make any fairness assumption .",
    "moreover , no move complexity is given for the first algorithm while we will prove the second one converges in expected @xmath0 moves .",
    "the following table compares features of the aforementioned algorithms and ours . among all adversarial distributed daemons and with the anonymous assumption , our algorithm provides the best complexity .    [ cols=\"^,^,^,^,^,^ \" , ]     when dealing with matching under anonymous networks , we have to overcome the difficulty that a process has to know if one of its neighbors points to it . in hsu and huang s paper @xcite ,",
    "this difficulty is not even mentioned and the assumption a node can know if one of its neighbors points to it is implicitly made . however , this difficulty is mentioned in the goddard et al .",
    "paper @xcite , where authors present an anonymous self - stabilizing algorithm for finding a @xmath12-maximal matching in trees and rings . to overcome this difficulty",
    ", authors assume that every two adjacent nodes share a private register containing an incorruptible link s number .",
    "note that this problem does not appear for the vertex cover problem @xcite or the independent set problem @xcite even in anonymous networks ( see @xcite for a survey ) .",
    "indeed , in these kind of problems , we do not try to build a set of edges , but a set of nodes .",
    "so , a node does not point to anybody and it simply has to know whether or not one of its neighbors belongs to the set . in this paper , we propose a self - stabilizing solution for this problem without assuming any incorruptible memory .",
    "a system consists of a set of processes where two adjacent processes can communicate with each other .",
    "the communication relation is typically represented by a graph g = ( v , e ) where @xmath13 and @xmath14 .",
    "each process corresponds to a node in @xmath15 and two processes @xmath16 and @xmath17 are adjacent if and only if @xmath18 . the set of neighbors of a process @xmath16 is denoted by @xmath19 and is the set of all processes adjacent to @xmath16 .",
    "we assume an _ anonymous _ system meaning that processes have no identifiers .",
    "thus , two different processes having the same number of neighbors are undistinguishable .",
    "we distinguish two communication models : the _ state model _ and the _ link - register model_. we are going to define the state model , then we will define the link - register model by pointing out the differences with the state model .    in the _ state model _ , each process maintains a set of _ local variables _ that makes up the _ local state _ of the process .",
    "a process can read its local variables and the local variables of its neighbors , but it can write only in its own local variables . a _ configuration _",
    "@xmath20 is a set of the local states of all processes in the system .",
    "each process executes the same algorithm that consists of a set of _",
    "rules_. each rule is of the form of @xmath21 .",
    "the _ guard _ is a boolean function over the variables of both the process and its neighbors .",
    "the _ command _ is a sequence of actions assigning new values to the local variables of the process .",
    "a rule is _ enabled _ in a configuration @xmath20 if the guard is true in @xmath20 .",
    "a process is _ activable _ in a configuration @xmath20 if at least one of its rules is enabled .",
    "execution _ is an alternate sequence of configurations and transitions @xmath22 , such that @xmath23 , @xmath24 is obtained by executing the command of at least one rule that is enabled in @xmath25 ( a process that executes such a rule makes a _ move _ ) .",
    "more precisely , @xmath26 is the non empty set of enabled rules in @xmath25 that has been executed to reach @xmath24 such that each process has at most one of its rules in @xmath26 .",
    "an _ atomic operation _ is such that no change can takes place during its run , we usually assume an atomic operation is instantaneous . in the case of the state model , such an operation corresponds to a rule .",
    "we use the following notation : @xmath27 .",
    "an execution is _ maximal _ if it is infinite , or it is finite and no process is activable in the last configuration .",
    "all algorithm executions considered in this paper are assumed to be maximal .",
    "a _ daemon _ is a predicate on the executions .",
    "we consider only the most powerful one : the _ distributed daemon _ that allows all executions described in the previous paragraph .",
    "an algorithm is _ self - stabilizing _ for a given specification , if there exists a sub - set @xmath28 of the set of all configurations such that : every execution starting from a configuration of @xmath28 verifies the specification ( _ correctness _ ) and starting from any configuration , every execution reaches a configuration of @xmath28 ( _ convergence _ ) .",
    "@xmath28 is called the set of _ legitimate configurations_. a _",
    "probabilistic self - stabilizing _ algorithm ensures ( deterministic ) correctness , but only ensures probabilistic convergence .",
    "a configuration is _ stable _ if no process is activable in the configuration . both algorithms presented here , are _ silent _ , meaning that once the algorithm stabilized , no process is activable . in other words ,",
    "all executions of a silent algorithm are finite and end in a stable configuration .",
    "note the difference with a non silent self - stabilizing algorithm that has at least one infinite execution with a suffix only containing legitimate configurations , but not stable ones .    in the _ link - register model _",
    "@xcite , each process maintains a set of _ registers _ associated to each of its communication links .",
    "a process can read and write in its own registers , but it can only read the registers of its neighbors that are associated to one of its links . more formally ,",
    "if @xmath16 is a process , @xmath29 , @xmath16 maintains a set of registers @xmath30 .",
    "these registers belong to @xmath16 and are associated to the link @xmath31 , thus @xmath16 can read and write in these registers and @xmath17 can read them .",
    "the set of all registers of a process is the _ local state _ of the process . in this paper",
    ", we use the link - register model . in this model , we assume local unique name on edges / ports , classically named the _ port numbering model _ in message - passing systems , as a syntactic tool to designate a specific register as well as its counterpart on the other side of the communication link .    the configuration and rule definitions remain the same , but the difference is in the execution definition . in the link - register model ,",
    "usually , the minimal atomicity is not the rule , but the action ( remember that a command is a set of actions ) .",
    "this atomicity is called the _ read / write atomicity_. we define two types of actions : ( i ) the _ internal action _ that is an action over internal variables , such that ` i++ ` , and ( ii ) the _ communication action _ that is an action of reading or writing in a register",
    ". an _ atomic action _ here is the execution of a finite sequence of internal actions ended by one communication action .",
    "then , a transition in an execution is a non - empty set of atomic actions such that each process has at most one of its atomic actions in the transition .",
    "the _ matching algorithm _",
    "@xmath32 presented in this section uses the state model given in the previous section and is based on the maximal matching algorithm given by manne et al .",
    "@xcite . in algorithm @xmath32 , every node @xmath16 has one local variable @xmath33 representing the node @xmath16 is matched with . if @xmath16 is not matched , then @xmath33 is equal to @xmath34",
    ". algorithm @xmath32 ensures that a maximal matching is eventually built .",
    "formally , we require the following specification @xmath35 for @xmath32 :    for a graph @xmath36 , the set @xmath37 is a maximal matching of @xmath38 , _",
    "i.e. _ @xmath35 = @xmath39 holds :    * @xmath40 :   @xmath41 ( consistency )   * @xmath42 :   @xmath43 ( matching condition )   * @xmath44 :   @xmath45 ( maximality )     for the sake of simplicity , we assume that if any node @xmath16 having the value @xmath17 in its @xmath33 variable such that @xmath46 or @xmath47 then @xmath16 understands this value as null ( @xmath34 ) .",
    "algorithm @xmath48 has the three rules described in the following .",
    "if a node @xmath16 points to null , while one of its neighbors points to @xmath16 , then @xmath16 accepts the proposition , meaning @xmath16 points back to this neighbor ( _ marriage _ rule ) .",
    "if a node @xmath16 points to one of its neighbors while this neighbor is pointing to a third node , then @xmath16 abandons , meaning @xmath16 resets its pointer to null ( _ abandonment _ rule ) .",
    "if a node @xmath16 points to null , while none of its neighbors points to @xmath16 , then @xmath16 searches for a neighbor pointing to null .",
    "if such a neighbor @xmath17 exists , then @xmath16 points to it ( _ seduction _ rule ) .",
    "this seduction can lead to either a marriage between @xmath16 and @xmath17 , if @xmath17 chooses to point back to @xmath16 ( @xmath17 will then execute the _ marriage _ rule ) , or to an abandonment if @xmath17 finally decides to get married to another node than @xmath16 ( @xmath16 will then execute the _ abandonment _ rule ) .",
    "we define the probabilistic function @xmath49 that uniformly chooses an element in a finite set @xmath50 .",
    "the process @xmath16 makes a move according to one of the following rules :    * * ( marriage ) * @xmath51 * * ( abandonment ) * @xmath52 * * ( seduction ) * @xmath53 + @xmath54    the node that @xmath16 chooses to get married with in the marriage rule is not specified , since this choice has no bearing upon the correctness nor the complexity of the algorithm .",
    "the proof of this algorithm is based on a potential function . to define this function , we first need to define notions of a _ single node _ , a _ good edge _ and an _ almost good edge_.    let @xmath55 be the set of all possible configurations of the algorithm .",
    "let @xmath56 be a configuration . a process pointing to null and having no neighbor pointing to it",
    "is called a _ single node_.",
    "then we define the predicate : _",
    "single(u ) _ @xmath57 $ ] .",
    "moreover , we define the set @xmath58 as the set of single nodes in @xmath20 .",
    "note that if a single node is activable then at least one of its neighbors points to null .",
    "we define the two following families of edges :    * a _ good edge _ is an edge @xmath31 where @xmath59 and @xmath60 * an _ almost good edge _ is an edge @xmath31 where @xmath59 and @xmath61 .",
    "such a node @xmath17 is called an _ indecisive _ process .",
    "[ fig_good_almost ]    a process in a good edge can not ever be activable . since every process has only one pointer , two good edges can not be adjacent .",
    "therefore , there can not be more than @xmath62 good edges .",
    "the activation of an indecisive process necessarily produces a good edge .",
    "an indecisive process can belong to many almost good edges .",
    "so there can not be more than @xmath63 almost good edge .",
    "we define the potential function @xmath64 by @xmath65 where @xmath66 is the number of good edges in @xmath20 and @xmath67 the number of almost good edges in @xmath20 .",
    "we recall the lexicographic order on @xmath68 : @xmath69 if one of the following conditions holds : + ( 1 ) @xmath70 ( 2 ) @xmath71 and @xmath72    [ lem:1 ] let @xmath73 be an execution of @xmath74 .",
    "we have : +    @xmath75    this establishes that @xmath76 is a potential function .",
    "[ lem : proba ] let @xmath73 be an execution of @xmath74 . for all @xmath77 , if @xmath26 contains a move of a node that is single in @xmath25 , then @xmath78 with probability greater than @xmath79 .",
    "more formally : @xmath80\\geq \\frac{1}{4}$ ]    this means that if the daemon activates a process of @xmath58 then with probability at least @xmath81 , the potential function @xmath76 strictly increases .",
    "[ lem : moves ] in any execution containing @xmath82 moves , at least one indecisive or single node is activated .",
    "this establishes a upper bound of the number of moves between two activations of indecisive or single nodes . from the combination of lemmas [ lem:1 ] ,  [ lem : proba ] and  [ lem : moves ] , we obtain theorem  [ algomatching ] .    [ algomatching ] under the adversarial distributed daemon and with the guarded - rule atomicity ,",
    "the matching algorithm @xmath74 is self - stabilizing and silent for the specification @xmath35 and it reaches a stable configuration in @xmath0 expected moves .",
    "we just give an expected upper bound on the convergence time . in the following , we give an upper bound that hold with high probability .",
    "[ th : main ] let @xmath83 , and take @xmath84 .",
    "then , after @xmath85 moves , the algorithm has converged with probability greater than @xmath86 .",
    "first , we recall hoeffding s inequality applied to the identically independent distributed bernoulli random variables @xmath87 , @xmath88 ,  @xmath89 which take value @xmath12 with success probability @xmath81 .",
    "let @xmath90 be the random variable such that @xmath91 ( corresponding to the number of success during @xmath2 trials ) . from hoeffding s inequality , we have , for some @xmath92 , @xmath93",
    "\\leq \\exp({-2 \\varepsilon^2\\ell})\\ ] ]    second , we prove the probability not to reach a stable configuration in at most @xmath85 moves .",
    "let @xmath94 be the event _ `` the algorithm has converged in @xmath85 moves''_. let @xmath95 be a random variable of the number of times the potential function @xmath76 has increased during the first @xmath85 moves of the execution .",
    "note that @xmath96 means that the algorithm has converged in at most @xmath85 moves .",
    "we focus on computing an upper bound of the probability of @xmath97 . since @xmath76 starts from @xmath98 in the worst case and is incremented with probability @xmath99 every @xmath82 moves : @xmath100 & \\leq & pr \\left (",
    "f_k   < \\frac{n^2}2 \\right )   \\end{aligned}\\ ] ]    from lemma  [ lem : moves ] , in any execution containing @xmath82 moves , at least one indecisive or single node is activated .",
    "so the number of times that one indecisive or single node is activated is at least @xmath101 . from lemma [ lem : proba ] , when a single or an indecisive node is actived , @xmath76 strictly increases with probability greater than @xmath81 .",
    "so , this activation can be viewed as a bernoulli distribution which takes value @xmath12 with success probability at most @xmath81 .",
    "let @xmath102 be a random variable of the number of times the potential function @xmath76 has increased after @xmath103 activations of single or indecisive nodes .",
    "so equation   can be rewritten as : @xmath104 & \\leq & pr \\left ( y_\\ell",
    "< \\frac{n^2}2 \\right )   \\text { with   }    \\ell=\\left \\lfloor \\frac{k}{n+1}\\right \\rfloor \\label{eq : proof:1}\\\\          & \\leq & \\sum_{i=0}^{\\frac{n^2}2 - 1 } { \\ell \\choose i } \\left(\\frac14\\right)^i\\left(\\frac34\\right)^{\\ell - i}\\end{aligned}\\ ] ]    this value is the probability that less than @xmath105 independent bernouilli variables with parameter @xmath99 yield a positive result in @xmath2 trials .",
    "equation can be rewritten as : @xmath104 & \\leq & pr \\left ( s_\\ell < \\frac{n^2}2 \\right ) \\label{eq : proof:2}\\end{aligned}\\ ] ] thus we can apply the hoeffding s inequality , with @xmath106 : @xmath107 @xmath108   \\leq \\exp ( -a)\\label{eq : proof:4 } \\end{aligned}\\ ] ]    thus , a sufficient condition for the algorithm to have converged after @xmath85 moves with probability greater than @xmath86 is that : @xmath109 \\geq 1- \\varepsilon '   ~\\leftrightarrow~ pr[\\neg c_k ] \\leq \\varepsilon'$ ] @xmath110@xmath111 \\leq    \\varepsilon'\\end{aligned}\\ ] ]    we choose the value @xmath85 such that @xmath112 .",
    "we set @xmath113 , with @xmath114 .",
    "@xmath115 \\leq    \\varepsilon'\\end{aligned}\\ ] ]    thus , for @xmath116 , we have convergence with probability greater than @xmath86 .",
    "finally , since @xmath113 , for @xmath84 , the algorithm has converged after @xmath85 steps with probability greater than @xmath86 .",
    "[ cor : end ] for @xmath117 , the algorithm converges after @xmath0 moves with probability greater than @xmath118 .",
    "when dealing with matching under anonymous networks , we have to overcome the difficulty that a process has to know if one of its neighbors points to it . in the marriage rule for example ,",
    "a node @xmath16 tests if there exists one of its neighbors @xmath17 such that @xmath119 .",
    "thus @xmath16 has to know that the @xmath16 s value appearing in the equality is himself while @xmath16 has no identity .",
    "this is a fundamental difficulty that is inherently associated to the specification problem and the matching problem can not even be specified without additional assumptions . in this paper ,",
    "the solution consists by adopting the _ link - register _ model .",
    "moreover , in this model , we assume local unique names on edges / ports ( classically named the _ port numbering model _ in message - passing systems ) as a syntactic tool to designate a specific register as well as its counterpart on the other side of the communication link .",
    "in this section , we present a self - stabilizing algorithm that gives names to communication links such that ( i ) a _ link - name _ is shared by each extremity of the link and ( ii ) a node can not have two distinct incident links with the same _ link - name_. at the end of the section , we will see how this algorithm is used to overcome the anonymous difficulty previously presented .",
    "* the port numbering function : * a process @xmath120 is linked to some other processes , its neighbors , through some edges . since the network is anonymous , @xmath16 can not distinguish these neighbors using identifiers .",
    "however , @xmath16 only knows a _ port _ associated to each of them .",
    "we introduce then the @xmath121 set being a set of ports , and the function @xmath122 associating a port to each incident edge of a node .",
    "this formalizes as : @xmath123 + the function @xmath122 only makes sense when applied on a process and one of its incident edges . to simplify notations ,",
    "when @xmath122 is applied in other cases it returns @xmath124 .",
    "+    @xmath125     + this leads to model the network as a graph @xmath126 .",
    "for instance , in the graph of figure [ fig_local_view ] , we have : @xmath127 .",
    "note that @xmath128 and @xmath129 denote the same edge and so @xmath130    in this model , all ports for a given process are distinct : +    @xmath131     + thus , in figure [ fig_local_view ] , @xmath132 but @xmath133 can be equal to @xmath67 , @xmath134 or @xmath135 . +",
    "* the _ port _ and _ proc _ functions : * in order to access the necessary information to communicate through the registers , a node needs to know the set of ports of its own incident edges , let @xmath136 be this set : +    @xmath137     + for instance , in figure [ fig_local_view ] , @xmath138 .",
    "we define two functions : @xmath139 and @xmath140 .",
    "the function @xmath139 associates to a node @xmath16 and one of its ports @xmath67 , the node @xmath17 reached by @xmath16 through the port @xmath67 .",
    "more formally , we have : @xmath141 for instance , in figure [ fig_local_view ] , @xmath142 and @xmath143",
    ".    the function @xmath140 is defined accordingly to the function @xmath139 : given a node @xmath16 and one of its ports @xmath67 , if @xmath17 is the node @xmath16 can reach through port @xmath67 ( @xmath144 ) , then @xmath17 reached @xmath16 through @xmath145 .",
    "more formally , we have : @xmath146 for instance , in figure [ fig_local_view ] , @xmath147 , @xmath148 and @xmath149 .    note that the function @xmath139 is not used to obtain a node _ value _ or _ identity _ but a node _",
    "entity_. the function @xmath139 is a tool of representation of existing links , allowing a node to denote the node at the other end of one of its communication links . in the same way , the function @xmath140 is used to obtain the port _ entity _ and not the port _ value_. as a result , we can not compose or compare results returned by @xmath139 or @xmath140 or do any arithmetic operations on them , this would violate the anonymous assumption .      the _ link - name algorithm _",
    "@xmath150 presented in this section uses the link - register model given in a previous section , with read / write atomicity .    in algorithm @xmath32 , we wrote `` @xmath151 '' to specify that a node @xmath17 is pointing to @xmath16 .",
    "the anonymous assumption makes this test impossible ; the link - name algorithm will make it possible .    in algorithm @xmath150 ,",
    "every node @xmath16 contains two registers per port @xmath67 ( see figure [ fig_registers ] ) : @xmath152 and @xmath153 .",
    "register @xmath153 is the name @xmath16 gives to its port @xmath67 . from @xmath16 s point of view",
    ", @xmath153 is the name used by @xmath16 to designate the node @xmath154 .",
    "register @xmath152 is the name used by @xmath154 to designate @xmath16 . once again , from @xmath16 s point of view , @xmath155 is designated as @xmath156 ( see * ( @xmath157 ) * rule below ) .",
    "the algorithm ensures that eventually every two different processes @xmath16 and @xmath17 will agree on names they use to call each other .",
    "more formally , we require the following specification @xmath158 for @xmath150 :    for a graph @xmath126 we have , @xmath159 with :    * @xmath160 : @xmath161 * @xmath162 : @xmath163    in algorithm @xmath150 , a process @xmath16 checks whether every port has a unique name taken between 1 and @xmath164 . if not , @xmath16 renames them all ( rule @xmath165 ) .",
    "per port @xmath67 , process @xmath16 checks whether the name used by @xmath154 to designate @xmath16 is equal to @xmath152 ( rule @xmath157 ) .",
    "the link - name algorithm @xmath150 for node @xmath16 :    ( @xmath165 ) : :    @xmath166 for every @xmath167 : : :       +    * @xmath168    algorithm @xmath150 satisfies the following theorem :    [ th:2 ] under the adversarial distributed daemon and with the read / write atomicity , the link - name algorithm @xmath150 is self - stabilizing and silent for the specification @xmath158 , and it reaches a stable configuration in @xmath169 moves .",
    "the link - register model allows to locally distinguish the links incident to a node . despite of this link naming , the impossibility result proved by manne et al . [ 19 ]",
    "still holds . in other words ,",
    "there exists no deterministic self - stabilizing algorithm to build the maximum matching under the synchronous daemon even with a link - register model .",
    "so the link - register model allows to overcome the anonymous difficulty that is a node can not know if one of its neighbors points to itself .",
    "however it does not overcome the impossibility in an anonymous network to find some _",
    "solution for the maximal matching problem .",
    "in particular , the manne _",
    "_ algorithm @xcite does not solve the anonymous maximal matching problem even if we assume an underlying link - register model .      in this section ,",
    "we give a systematic way to rewrite the matching algorithm @xmath32 using registers of @xmath170 in order to avoid @xmath48 s instructions that violate the anonymous assumption .",
    "algorithm @xmath48 has two kinds of such instructions : the one that writes a non null value in a variable @xmath171 ( _ e.g. _ @xmath172 ) and the other that searches for a specific non null value in a variable @xmath171 ( _ e.g. _ @xmath173 ) .",
    "for example we would like to see the marriage rule @xmath174 rewritten as : @xmath175    we give above the generic rules that permit such a rewriting .",
    "note that these generic rules are purely syntactical , _",
    "i.e. _ we replace some character sequences by some other . in the following",
    ", @xmath16 denotes the node executing the algorithm and @xmath17 another node ( @xmath176 ) .    * the set of neighbor s identifiers @xmath19 is rewritten as the set of ports @xmath136 . *",
    "if @xmath17 appears 1 .   in a quantifier , then @xmath16 manipulates the port @xmath67 that links it to @xmath17 .",
    "so the expression `` @xmath177 '' is replaced by `` @xmath178 '' and the expression `` @xmath29 '' is replaced by `` @xmath179 '' ; 2 .   as a subscript of a variable ( as in @xmath180 ) ,",
    "then @xmath17 is replaced by @xmath154 since in this case @xmath17 indicates the _ owner of the variable _ ; 3 .",
    "otherwise ( as in @xmath59 ) , @xmath17 is replaced by @xmath153 since in this case @xmath17 indicates _ the node itself _ and so the name used by @xmath16 to designate node @xmath17 is needed . + _ applying the two previous rules ( 2 . and 3 . )",
    ", we obtain : + `` @xmath181 '' is rewritten as `` @xmath182 '' and @xmath183 is rewritten as `` @xmath184 '' _ * if @xmath16 ( the node executing the algorithm ) appears 1 .   as a subscript of a variable ( as in @xmath185 ) then no rewriting is needed , 2 .",
    "otherwise ( as in @xmath60 ) , @xmath16 is replaced by @xmath152 since in this case @xmath16 indicates _ the node itself _ appearing in the variable of the @xmath16 s neighbor @xmath186 .",
    "3 .   _ applying the previous rule ,",
    "we obtain : `` @xmath187 '' is rewritten as `` @xmath188 ''  _    we give above the algorithm @xmath32 fully rewritten using these rules :       * * ( marriage ) * @xmath189 * * ( abandonment ) * @xmath190 * * ( seduction ) * @xmath191 + @xmath192 + @xmath193    in the following , we will denote by @xmath194 , the algorithm @xmath32 rewritten with the rules above .",
    "having defined algorithms @xmath194 and @xmath150 , we would like to compose them to give a unified self - stabilizing algorithm . however , this is not doable in a straightforward way .",
    "indeed , the two algorithms use different communication and atomicity models : algorithm @xmath194 assumes the state model with the guarded rule atomicity , while @xmath150 assumes the link - register model with the read / write atomicity . for this composition , we keep both models . so @xmath194 and @xmath150 are executed in the same execution , under these two different models .",
    "we can not directly apply the composition result of dolev et al .",
    "@xcite since authors assume the same model for their composition .",
    "however , we can use similar arguments :    1 .",
    "@xmath150 neither reads nor writes in variables of @xmath194 while @xmath194 only reads in registers of  @xmath150 .",
    "2 .   @xmath150 stabilizes independently of @xmath194 .    concerning @xmath194 ,",
    "@xmath194 has been proved under the state communication model while it uses _ registers _ from @xmath150 .",
    "however we can notice that @xmath150 is silent thus the value of these registers will eventually not change .",
    "furthermore , a node does not read registers of its neighbors but only its own registers .",
    "thus they can be viewed as internal variables ( since they are not used to communicate between neighbors ) .",
    "thus @xmath194 only uses local and internal variables so the proof that has been done for @xmath32 is still valid for @xmath194 .",
    "thus once @xmath150 is stabilized and reaches a stable configuration , @xmath194 eventually stabilizes under the state model and the guarded rule atomicity .",
    "we presented a self - stabilizing algorithm for the construction of a maximal matching .",
    "this algorithm assumes the state model and runs in a anonymous network and under the adversarial distributed daemon .",
    "it is a probabilistic algorithm that converges in @xmath0 moves with high probability .",
    "we then present the _ pointing impossibility _ that is the impossibility for a node , in an anonymous network assuming the state model , to know whether or not one of its neighbors points to it .",
    "we overcome this by using the link - register model .",
    "so , we first give a detailed formalization of this model .",
    "second , we gave the _ link - name _ algorithm , that allow two nodes sharing an edge to keep each other updated about the name they chose for the shared edge .",
    "we finally saw that in an anonymous network , assuming the link - register model the pointing impossibility result does not hold anymore . as a perspective , we would like to analyze the maximal matching algorithm under the link - register model with the read / write atomicity instead of the state model .    10    heiner ackermann , paul  w. goldberg , vahab  s. mirrokni , heiko rglin , and berthold vcking .",
    "uncoordinated two - sided matching markets . , 40(1):92106 , 2011 .",
    "petra berenbrink , tom friedetzky , and russell  a. martin . on the stability of dynamic diffusion load balancing . , 50(3):329350 , 2008 .",
    "subhendu chattopadhyay , lisa higham , and karen seyffarth .",
    "dynamic and self - stabilizing distributed matching . in _ proceedings of the twenty - first annual acm symposium on principles of distributed computing ( podc ) _ , pages 290297 .",
    "acm , 2002 .",
    "edsger  w. dijkstra .",
    "self - stabilizing systems in spite of distributed control . , 17(11):643644 , 1974 .",
    "shlomi dolev . .",
    "mit press , 2000 .",
    "shlomi dolev , amos israeli , and shlomo moran .",
    "self - stabilization of dynamic systems . in _ proceedings of the mcc workshop on self - stabilizing systems _ , 1989 .",
    "shlomi dolev , amos israeli , and shlomo moran .",
    "self - stabilization of dynamic systems assuming only read / write atomicity . , 7(1):316 , 1993 .",
    "bhaskar ghosh and s.  muthukrishnan .",
    "dynamic load balancing by random matchings .",
    ", 53(3):357370 , 1996 .",
    "wayne goddard , stephen  t. hedetniemi , david  pokrass jacobs , and pradip  k. srimani .",
    "anonymous daemon conversion in self - stabilizing algorithms by randomization in constant space . in",
    "_ 9th int . conf . in distributed computing and networking ( icdcn )",
    "_ , volume 4904 of _ lncs _ , pages 182190 .",
    "springer , 2008 .",
    "wayne goddard , stephen  t. hedetniemi , and zhengnan shi .",
    "an anonymous self - stabilizing algorithm for 1-maximal matching in trees . in _ proceedings of the int",
    ". conf . on parallel and distributed processing techniques and applications ( pdpta ) _ , pages 797803 , 2006 .",
    "maria gradinariu and colette johnen . self - stabilizing neighborhood unique naming under unfair scheduler . in",
    "euro - par conference _ ,",
    "volume 2150 , pages 458465 , 2001 .",
    "nabil guellati and hamamache kheddouci .",
    "a survey on self - stabilizing algorithms for independence , domination , coloring , and matching in graphs .",
    ", 70(4):406415 , 2010 .",
    "stephen  t. hedetniemi , david  pokrass jacobs , and pradip  k. srimani .",
    "maximal matching stabilizes in time o(m ) .",
    ", 80(5):221223 , 2001 .",
    "martin hoefer .",
    "local matching dynamics in social networks .",
    "pages 2035 , 2013 .",
    "su - chu hsu and shing - tsaan huang .",
    "a self - stabilizing algorithm for maximal matching .",
    ", 43(2):7781 , 1992 .",
    "donald knuth . .",
    "les presses de luniversit de montral , 1976 .",
    "fredrik manne and morten mjelde . a self - stabilizing weighted matching algorithm . in _",
    "symposium stabilization , safety , and security of distributed systems ( sss ) _ , lecture notes in computer science , pages 383393 .",
    "springer , 2007 .",
    "fredrik manne , morten mjelde , laurence pilard , and sbastien tixeuil . a new self - stabilizing maximal matching algorithm .",
    ", 2009 .",
    "fredrik manne , morten mjelde , laurence pilard , and sbastien tixeuil .",
    "a self - stabilizing 2/3-approximation algorithm for the maximum matching problem .",
    ", 412(40):55155526 , 2011 .",
    "zhengnan shi , wayne goddard , and stephen  t. hedetniemi .",
    "an anonymous self - stabilizing algorithm for 1-maximal independent set in trees .",
    ", 91(2):7783 , 2004 .",
    "volker turau and bernd hauck .",
    "a fault - containing self - stabilizing ( 3 - 2/(delta+1))-approximation algorithm for vertex cover in anonymous networks .",
    ", 412(33):43614371 , 2011 .",
    "volker turau and bernd hauck . a new analysis of a self - stabilizing maximum weight matching algorithm with approximation ratio 2 .",
    ", 412(40):55275540 , 2011 .",
    "* proof of lemma [ lem:1 ] : * a process that belongs to a good edge will never be activable , thus a good edge can not be destroyed .    the only way to reduce the number of almost good edges is to apply the marriage rule on the indecisive process .",
    "indeed , let @xmath195 be an almost good edge , where @xmath17 is the indecisive process of @xmath196 . in edge @xmath196 ,",
    "the only activable process is @xmath17 and this node can only execute a marriage move .",
    "note that @xmath17 can belong to several almost good edges .",
    "thus the execution of the marriage rule by @xmath17 destroys all the almost good edges incident to @xmath17 and creates one new good edge . to conclude , in every case @xmath76",
    "can not decrease .",
    "+   + * proof of lemma [ lem : proba ] : * let @xmath16 be a single node that is activated in @xmath25 .",
    "let @xmath198 and @xmath133 be its cardinality . since @xmath16 is activated in @xmath25 , @xmath199 is not an empty set and @xmath200 .",
    "let @xmath201 .",
    "note that @xmath16 seduces a neighbor @xmath17 with a probability @xmath202 . indeed , process @xmath16 seduces one of its neighbors with probability @xmath203 .",
    "moreover , if @xmath16 decides to seduce ( _ i.e. _ to change its local variable @xmath185 ) , then it seduces @xmath17 with probability @xmath204 .",
    "let us assume that @xmath16 seduces @xmath17 , then there are three cases ( see figure  [ fig_proba_calcul ] ) :    case 1 ) @xmath205 and @xmath17 is activated in @xmath25 : : :    ( @xmath206 in fig . [ fig_proba_calcul ] ) in    this case , there is a process @xmath207 such that    @xmath208 and @xmath17 has to apply the    marriage rule .",
    "this action creates a new good edge containing    @xmath17 .",
    "case 2 ) @xmath209 and @xmath17 is activated in @xmath25 : : :    ( @xmath210 and    @xmath211 in fig .",
    "[ fig_proba_calcul ] ) in this    case , process @xmath17 applies the seduction rule and still    points to null with probability @xmath203 .",
    "thus , edge    @xmath31 becomes an almost good edge with    probability  @xmath203 .",
    "case 3 ) @xmath17 is not activated in @xmath25 : : :    in this case @xmath17 still points to null with probability 1 .",
    "thus , edge @xmath31 becomes an almost good edge .",
    "let @xmath212 be the probability to create :    * a new almost good edge between @xmath16 and @xmath17 such that @xmath17 is the indecisive process of edge @xmath31 ( we will call this an _ almostgood - creation _ ) , * or a new good edge containing @xmath17 ( we will call this a _ good - creation _ ) ,    during @xmath27 given that @xmath16 is a single node that is activated in @xmath25 and @xmath201 and @xmath213 .",
    "+ from the previous case study , we can deduce that in case 1 , a _ good - creation _ occurs with probability @xmath214 , in case 2 , an _ almostgood - creation _ occurs with probability @xmath215 and in case 3 , an _ almostgood - creation _ occurs with probability @xmath214 .",
    "thus @xmath216 .",
    "+ moreover , we define @xmath217 as the probability for @xmath16 to create :    * a new almost good edge between @xmath16 and one of its neighbors @xmath17 such that @xmath17 is the indecisive process of edge @xmath31 * or a new good edge containing one of its neighbor ,    during @xmath27 given that @xmath16 is a single node that is activated in @xmath25 .",
    "+ we have : @xmath218    thus : @xmath219\\geq \\frac{1}{4}$ ]    @xmath197 +   + * proof of lemma [ lem : moves ] : * we are going to exhibit an as long as possible execution @xmath220 without activating any indecisive or single node .",
    "note that the seduction rule can only be executed by single nodes and that the marriage rule can only be executed by indecisive nodes .",
    "thus , the only possible rule in @xmath220 is the abandonment rule .",
    "if this rule is executed by some process @xmath16 , then @xmath16 becomes single and all indecisive , respectively single , neighbors of @xmath16 will remain so .",
    "thus , we can apply this rule at most @xmath221 times . @xmath197",
    "+   + * proof of theorem [ algomatching ] : * first , we prove that a stable configuration satisfies the specification @xmath35 . in a stable configuration @xmath20",
    ", we can apply neither the abandonment nor the marriage rules .",
    "then for all node @xmath16 in @xmath15 we have one of the two following conditions : @xmath222 or @xmath223 .",
    "note that in condition 2 , @xmath180 can not be @xmath34 otherwise condition 1 does not hold for @xmath17 .",
    "thus the set @xmath224 is such that @xmath18 and so @xmath40 holds .",
    "let us prove that in a stable coation , @xmath1 is a maximal matching .",
    "since every process has only one pointer , two good edges can not be adjacent .",
    "thus @xmath42 holds and @xmath1 is a matching . since we can not apply the seduction rule , for every node @xmath16 such that @xmath225 , every neighbor @xmath17 of @xmath16 is such that @xmath226 and thus @xmath17 belongs to an edge in @xmath1 .",
    "thus @xmath44 holds and @xmath1 is maximal .",
    "now , let us prove that we reach a stable configuration in @xmath0 expected moves .",
    "let @xmath50 be a random variable of the number of moves needed to increase function @xmath76 . according to lemma [ lem : moves",
    "] , each sequence of @xmath82 moves , contains at least one move from an indecisive or single node .",
    "let @xmath227 be such a move .",
    "if @xmath227 is a move of an indecisive node , then @xmath227 is the execution of the marriage rule , and thus @xmath76 increases by one during this move .",
    "if @xmath227 is a move of a single node , then according to lemma [ lem : proba ] , @xmath76 strictly increases with probability greater than @xmath81 during this move .",
    "thus in both cases , @xmath76 strictly increases with probability greater than @xmath81 during @xmath227 .",
    "if it fails , then there can have at most @xmath221 additional moves before the activation of an indecisive or single node .",
    "and there can be at most @xmath63 simultaneous moves when an indecisive or single node is actived .",
    "we have a sequence of bernoulli trials , each with a probability greater than @xmath81 of success .",
    "so , we have @xmath228 \\leq 4\\cdot 2\\cdot   n$ ] . by definition ,",
    "function @xmath76 has @xmath229 possible values . therefore ,",
    "the expected time for @xmath76 to reach its maximal possible value is @xmath0 . in conclusion ,",
    "algorithm @xmath74 reaches a stable configuration in @xmath0 expected moves .",
    "@xmath197 +   + * proof of equation  :* let @xmath113 , with @xmath230 , and so @xmath231 .",
    "we can get : @xmath232 @xmath233 @xmath234 @xmath235 @xmath236 @xmath237 \\leq    \\varepsilon'\\ ] ] @xmath197 +   + * proof of corollary [ cor : end ] : * first , we notice that the function @xmath238 is an increasing function for @xmath239 .",
    "in fact @xmath240 and @xmath241 has positive values for @xmath242 .",
    "this implies that when @xmath242 , we have @xmath243    second , we focus on @xmath117 .",
    "let @xmath244 be a real such that @xmath245 . from theorem",
    "[ th : main ] , the algorithm has converged after @xmath85 moves with probability greater than @xmath86 where @xmath84 . since @xmath117 , we obtain that @xmath246 .",
    "so , the algorithm has converged after @xmath247 moves with probability greater than @xmath248 .",
    "[ lemma1 naming ] under the adversarial distributed daemon and with the read / write atomicity , any execution of the link - name algorithm @xmath249 reaches a stable configuration in at most @xmath250 moves .",
    "we start by giving the complexity of algorithm @xmath150 in term of moves .",
    "first , we focus on rule @xmath165 for each node @xmath16 .",
    "node @xmath16 executes rule @xmath165 at most once . during this execution , for every port @xmath67",
    ", @xmath16 makes at most @xmath9 moves : one reading - move to check whether @xmath251 and at most one writing - move to rename @xmath153 .",
    "therefore , the total number of moves for @xmath165 executed by any node in the network is : @xmath252    second , we count the move complexity for rule @xmath157 given a node @xmath16 and a port @xmath67 .",
    "@xmath157 is executed by @xmath16 at most twice , since @xmath156 changes its value at most once ( due to the rule @xmath165 ) . in every execution of rule @xmath157",
    ", @xmath16 makes at most @xmath253 moves : 2 moves to compare the two registers @xmath254 and , if the condition holds , 2 moves to assign @xmath156 to @xmath152 .",
    "therefore , the total number of moves for @xmath157 executed by any node in the network , and for all @xmath67 is : @xmath255          in a stable configuration , the guard of rule @xmath165 is false for every node . thus @xmath256 holds . for",
    "every edge @xmath257 in the network , neither @xmath16 nor @xmath17 can apply their rule associated to edge @xmath196 : @xmath258 and @xmath259 .",
    "this implies that @xmath260 and @xmath261 , where @xmath262 and @xmath263 .",
    "thus @xmath160 holds ."
  ],
  "abstract_text": [
    "<S> we propose a self - stabilizing algorithm for computing a maximal matching in an anonymous network . </S>",
    "<S> the complexity is @xmath0 moves with high probability , under the adversarial distributed daemon . in this algorithm </S>",
    "<S> , each node can determine whether one of its neighbors points to it or to another node , leading to a contradiction with the anonymous assumption . to solve this problem , we provide under the classical link - register model , a self - stabilizing algorithm that gives a unique name to a link such that this name is shared by both extremities of the link .    </S>",
    "<S> [ [ keywords ] ] keywords : + + + + + + + + +    randomized algorithm , self - stabilization , maximal matching , anonymous network . </S>"
  ]
}