{
  "article_text": [
    "we tackle the problem of _ loop closure _ in vision - based navigation .",
    "this is a particular classification task whereby a training set of images is indexed by location , and given a test image one wants to query the database to decide whether the former is present in the latter , and if so return the indexed location .",
    "this is closely related to _ scene recognition _ , where the focus is on a particular instance , as opposed to an object class ( we want to determine whether we are at particular intersection in a given city , not whether we are at _ some _ intersection of _ some _ urban area ) . as such , test images are only subject to _ nuisance variability _",
    "due to viewpoint , illumination and partial occlusion from moving objects , but otherwise there is no _ intrinsic _ ( intra - class ) variability .",
    "the state - of - the - art for image retrieval is based on convolutional neural network ( cnn ) architectures , trained to marginalize nuisance and intrinsic variability . while some of this variability is managed by design , for instance through the use of linear convolutions and pooling ,",
    "the rest is _ learned away _ by means of large annotated datasets .",
    "unfortunately , existing convolutional architectures are not well matched to the loop closure problem : in a discriminatively trained network , the compositionality property afforded by linear convolutions , while critical to model intra - class variability , is detrimental to loop closure , as there is no intrinsic variability .",
    "at the same time , a cnn does not respect the topology of data space at higher levels of the hierarchy , since filters at any given layer are supported on the entire feature map of the previous layer . in loop closure ,",
    "locality is key , and while one could retrieve from the feature map the locations that correspond to active units , this requires some effort @xcite . in this sense ,",
    "cnns are too much and too little for loop closure as they are not designed to specifically tackle the problem .",
    "it is not a coincidence that the state - of - the - art in loop closure consists of variants of bag - of - words ( bows ) and inverted indices @xcite that were ubiquitous in image retrieval before the advent of cnns , which are powerful for object identification , not for applications like slam which we focus on in this paper . unlike generic retrieval",
    ", however , bows have remained the most popular .    given the critical importance of loop closure in location services ranging from smartphones to autonomous vehicles ,",
    "we focus on its peculiarities , and attempt to harvest some of the components of neural networks to improve the state - of - the - art . stripped of the linear convolutions ( we do not need to model intrinsic variability ) and relu ( occlusions can be modeled as a subset selection , rather than a marginalization as suggested in @xcite ) , what we have left is a _ hierarchical spatially pooled data structure built upon local photometric descriptors @xcite .",
    "_ there are no filters , and no learning other than the trivial pooling of local descriptors .",
    "motivated by this intuition , we propose a new hierarchical representation for loop closure , detailed in sec .",
    "[ sect - derivation ] .",
    "loop closure is also closely related to location , or `` place , '' recognition  @xcite and large - scale visual search  @xcite , but with some important restrictions .",
    "first , both previous data ( training images ) and current ( test , or query ) data are usually available as time - indexed sequences , even if they are captured by different agents , and training images may be aggregated into a `` map ''  @xcite or reduced to a collection of `` keyframes ''  @xcite .",
    "second , as a binary classification task ( at each instant of time , a loop closure is either detected or not ) , the cost of missed detections and false alarms are highly asymmetric : we pay a high price for declaring a loop closure that is nt , but there is minor harm in missing one , as temporal continuity affords many second chances in subsequent images .",
    "this is unlike large - scale image retrieval , where we wish to find what we are looking for ( few missed detections , or high recall ) even if we have to wade through some irrelevant hits ( many false alarms , or low precision ) .    like image retrieval , however ,",
    "the challenge with loop closure is scaling .",
    "in navigation applications , it may be hours before we return to a previously seen portion of the scene .",
    "therefore , we have to store , and search through , hundreds of thousands to millions of images .",
    "our goal in this paper is to _ design a hierarchical data structure that helps speed up matching by leveraging on the two domain - specific constraints above : _ temporal adjacency , and high precision .",
    "assuming continuous trajectories , the first translates to proximity in pose space @xmath2 ( position and orientation ) . for the second , the best trade - off with missed detections",
    "can be achieved by testing every datum in the training set via _ linear search accelerated via an inverse index_. our goal is to achieve similar performance at a fraction of the cost compared to inverse index search .",
    "this can not be achieved in a worst - case setting .",
    "what matters instead is _ average performance _",
    "trading off precision with computational cost .",
    "we evaluate such average performance empirically on public benchmarks such as the _ kitti _ dataset  @xcite , the _ city centre _ , and _ new college _",
    "datasets  @xcite , as well as demonstrating extensions to general image retrieval on _ ukbench _",
    "@xcite and _ inria holidays dataset _  @xcite .",
    "we propose a simple data structure based on hierarchical pooling of location likelihoods  in the form of sample distributions of visual descriptors  with respect to the topology of pose space . in practice",
    ", this means simply constructing bag - of - words of visual descriptors , that represent the likelihood of the locations that generated them , and pooling them temporally in a fine - to - coarse fashion , either by averaging , summing , or taking the index - wise maximum .    while averaging likelihoods may seem counter - productive , in sec .",
    "[ sect - derivation ] we show it makes sense in the context of the classical theories of sampling and anti - aliasing . in sec .",
    "[ sect - expm ] we show that , despite its simplicity , it works as well as sophisticated agglomerative schemes at a fraction of the effort . while it may seem that something this simple that works must have been done before , we could not find trace of it in the literature , reviewed in sec .",
    "[ sect - related ] , perhaps owing to the counter - intuitive nature of building hierarchies of pooled likelihoods .",
    "loop closure is a key component in robotic mapping ( slam )  @xcite , autonomous driving , location services on hand - held devices , and for wearables such as virtual reality displays .",
    "appearance - only methods  @xcite are essentially large - scale retrieval algorithms , heavily influenced by  @xcite and more in general the literature of bag - of - word object recognition and categorization  @xcite .    for scalability",
    ", the most common choice is to combine quantized local descriptors into a bag - of - words and then use an inverted index .",
    "fab - map  @xcite extends the basic setup by learning a generative model of the visual words using a chow - liu tree to model the probability of co - occurrence of visual words .",
    "fab - map 2.0",
    "@xcite scales further by exploiting sparsity to make the inverted index retrieval architecture more efficient .",
    "angeli  @xcite adopt recursive bayesian filtering with a simple voting scheme based on term frequency - inverted document frequency ( tf - idf )  @xcite .",
    "starting from  @xcite , sift or surf descriptors were replaced by more efficient binary descriptors such as brief  @xcite and orb  @xcite to achieve comparable precision and recall to fab - map 2.0 with an order of magnitude speed increase .",
    "several recent mapping and localization systems adopt it as a module , including  @xcite and orb - slam  @xcite .",
    "in addition to the specific loop closure literature , general ideas from spatial data structures and agglomerative clustering  @xcite are also relevant to this work , including the kd - tree  @xcite , dual trees and decision trees  @xcite , as well as data structures used for retrieval such as pyramid matching  @xcite and its spatial version  @xcite . in more general terms , this work also relates to visual navigation and mapping , structure - from - motion , and location recognition , including the use of global descriptors  @xcite .",
    "our method can be considered appearance - only , but it is loosely informed by geometry , in the sense that the scene domain ( pose space ) provides the topology with respect to which we pool descriptors . also closely related to our approach are @xcite , which present techniques for merging only pairs of bows .",
    "to the best of our knowledge , our work is the first to pool them hierarchically and specifically target search time in loop closure .",
    "since our focus is on a spatial structure that facilitates loop closure query , we adopt components from recent state - of - the - art methods as a baseline , and compare such a baseline against the same components integrated within our data structure .",
    "specifically , we adopt  @xcite as a baseline , consisting of a bag - of - words where each word is an element of a dictionary of descriptors obtained off - line by hierarchical k - means clustering , with each word weighted by its inverse document frequency . fast detectors  @xcite and brief descriptors  @xcite are employed , and tf - idf  @xcite is used to classify the bow relative to the inverse index .",
    "this standard pipeline , with different clustering procedures to generate the dictionary and different features , comprises most basic large - scale retrieval systems , including appearance - only loop closure .",
    "however , the number of false alarms in large - scale settings is crippling , so temporal consistency and geometric verification are typically used as correction mechanisms . in a topological loop closure setting , matches against different images that are adjacent in time are lumped together as a single match , and highest - scoring matches are checked for temporal consistency with previous time series data .",
    "our data structure can be interpreted as a hierarchical version of tf - idf . to illustrate the method",
    ", we first assume that every frame is a `` keyframe '' and therefore we have a time - series of bows , obtained as described above , and organized into a linear structure or _ un - oriented list _ , as we wish to retrieve regardless of the direction of traversal .",
    "each node is associated with a histogram , in the form of a bow , representing the likelihood of a pose @xmath3 ( position @xmath4 and orientation @xmath5 ) given the data ( the image at time @xmath6 , @xmath7 ) : @xmath8 , where the equivalence is up to normalization , and the density function is approximated with a histogram with @xmath9 bins , equal to the size of the dictionary .",
    "we now construct a second level , or `` layer '' , of the data structure , simply by pooling adjacent histograms ( fig .",
    "[ fig - tree ] ) .",
    "this is repeated for higher layers until either a maximum depth is reached , or until a single root node is left .",
    "similarities between pooled and query histograms are computed using the _ intersection kernel _",
    "@xcite , that is the area of the intersection of the two histograms .",
    "thus , if @xmath10 ( a query histogram ) has bin values @xmath11 , and similarly for @xmath12 , we have that @xmath13 the intersection kernel is related to many divergence functions  @xcite as well as to metrics used in optimal transport problems .",
    "several standard choices for the pooling operation are available which we show trade off between precision and cost ( sec .",
    "[ sect - expm ] ) .",
    "suppose @xmath12 is the parent histogram which has child histograms @xmath14 . both @xmath12 and @xmath15 .",
    "mean- or average - pooling refers to @xmath16 , sum - pooling refers to @xmath17 , and max - pooling refers to @xmath18 , where @xmath19 .",
    "the latter two pooling operators have an upper bound property when using the intersection kernel which makes the hierarchical test _ have the same precision - recall behavior as standard inverse index search but also reasonable speedup _ , though not as much speedup as the average operator .",
    "it is well known that for a query @xmath10 , @xmath20 when sum / max operators are used and thus if @xmath21 , @xmath22 must hold .",
    "the downside of using sum / max - pooling is that without normalization , the pooled histograms may score high very quickly and trigger detections everywhere in the tree , which limits maximum speedup attainable .",
    "different trees with different depths and different branching factors can be constructed , trading off expected risk and computation time , characterized empirically in sec .",
    "[ sect - expm ] .",
    "in addition to a fixed depth ( the data structure is then applied to the time series on a sliding window - based ) and branching factor , one could devise more clever schemes to determine the topology of the tree , discussed in sec .",
    "[ sect - fancy ] .",
    "however , we find that the benefit is limited compared to the straightforward fixed - topology architecture .",
    "suppose in our tree structure , a sliding window of @xmath23 histograms @xmath24 are pooled into a parent node @xmath12 , then @xmath12 is an approximation of these histograms under one of the pooling operations .",
    "based on the assumption that the child histograms are locally similar , the pooled histogram should be a good approximation to them . since our goal is to search for the closest match , or at least for all matches that exceed a threshold @xmath25 ( we seek large values of @xmath26 ) , if @xmath27 , the chance of any of @xmath12 s descendants exceeding the threshold is rare ( or impossible , in the case of max- or sum - pooling ) , therefore we stop searching the sub - tree rooted at @xmath12 .",
    "therefore , search in a hierarchical tf - idf setting simply boils down to _ greedy breadth - first search , while maintaining an inverted index for each layer .",
    "_ if only one layer is used , this reduces to standard linear search using an inverted index .",
    "so far we have assumed that the time - series of data @xmath28 is sampled regularly ( at constant time - intervals , or constant space - intervals ) , but it can also be sampled adaptively , by exploiting statistics of the data stream to decide which samples , or _",
    "keyframes _ , to use .",
    "the data structure above does not change , since all that is required is a topology or adjacency structure to construct the tree . in sec .",
    "[ sect - fancy ] we explore more sophisticated heuristics to this end .",
    "adaptive ( sub)-sampling can be done in a number of ways .",
    "the most popular involve a combination of heuristics that includes the average number of tracked features and their overlap ( new keyframes are spawned when the overlap of tracks with neighboring frames drop below a threshold ) , as well as hard gates on minimum and maximum time intervals , minimum and maximum distance in space or pose , between keyframes , including keyframes already existing in the map ( but not temporally adjacent ) .    while there is significant performance or computational cost modulation",
    "to be had , our goal here is not to determine the best method for selecting keyframes .",
    "instead , we focus on the data structure regardless of the sub - sampling mechanism . consequently",
    ", we limit ourselves to constructing it either on the raw time series , or on any subsampling of it , as generated by any keyframe selection method .",
    "it should be noted that mean - pooling , as described in the previous section , appears to be counter - productive since our goal is to maintain high precision . just like selecting keyframes , building",
    "the hierarchy can be understood as a form of ( sub)-sampling .",
    "regardless of whether subsampling is regular ( as in building the tree above ) or adaptive ( as in selecting keyframes ) , classical sampling theory  @xcite suggests that what should be stored at the samples is _ not _ the value of the function , but the local average relative to the topology of the domain where the data are defined ( _ anti - aliasing _ ) .    in our case ,",
    "the domain is time , or the order of keyframes , as a proxy of location in @xmath2 .",
    "the range of the data is the space of likelihood functions , approximated by the bow histograms @xmath29 .",
    "therefore , anti - aliasing simply reduces to averaging neighboring bows .",
    "the study of the optimal averaging , both in terms of support and weights , is beyond our scope here , where for mean - pooling we simply average nearest neighbors in the tree topology relative to a uniform prior .",
    "we do not delve into considering more sophisticated anti - aliasing schemes , since we have found that simple topologies yield attractive precision - computational cost tradeoff , which is unlikely to be significantly disrupted by fine - tuning the weights .",
    "the practice of averaging likelihood functions as a way of anti - aliasing descriptors has also been recently shown by  @xcite in the context of pooling local descriptors for correspondences in wide - baseline matching .",
    "our method can be considered an extension ( or special case ) where the correspondence and pooling are performed in time , and the descriptors are histograms of visual words , a mid - level representation , rather than histograms of gradient orientation , the result of low - level processing .    while our method is agnostic to the choice of heuristic to select keyframes , and in sec .",
    "[ sect - expm ] we report results both with and without keyframes , it should be mentioned that even in the case of regular sampling , often for computational reasons datasets come down - sampled to the point where there is little to no overlap of descriptors or tracks between adjacent frames , that can therefore be safely considered all keyframes .",
    "one example ( oxford ) will be illustrated in sec .",
    "[ sect - expm ] , where frames are so distant that tracking is not possible , and therefore wide - baseline correspondence must be employed for data association .      while the choice of heuristics for keyframe selection has no effect on our method , which can be applied to the raw time series or to the sequence of keyframes , the same ( adaptive sampling ) heuristics used to ( down)-sample keyframes from the regularly sampled images could be used to aggregate nodes at one level into parents one level above .",
    "this would give rise to trees having different levels of connectivity at different layers , and indeed potentially at each node .",
    "we have found that , in practice , these heuristics fail to yield significant performance improvements when compared to trees with fixed topology having constant splitting factors that match the average of their adaptive counter - part .",
    "representative experiments are shown in sec .",
    "[ sect - expm ] , with more details in the supplemental material .",
    "although our approach is geared towards the loop closure scenario , its usage is not be restricted to it .",
    "a hierarchical structure of this form could be built on top of any histogram - based representation of images where some proxy of topology is available . in more general settings",
    "when a temporal stream of images is unavailable , extra labeling information , such as geotags , class labels , or textual annotations could be used .",
    "a hierarchy can be constructed using affinity between these alternate forms of metadata , provided that affinity implies proximity in the solution space . in sec .",
    "[ sect - retrieval ] , we demonstrate our data structure on two typical image retrieval benchmarks .",
    "a common loop closure benchmark is the _ kitti _ odometry dataset , consisting of 22 sequences of stereo pairs captured from a car driving through urban scenes  @xcite .",
    "we also test our scheme on the _ oxford city centre _ and _ oxford new college _ datasets , captured by a hand - held camera  @xcite .",
    "these two datasets are challenging due to the ubiquity of repetitive structures such as brick walls and long corridors .",
    "the datasets have different temporal sampling , finer in _ kitti _ and coarser in _",
    "oxford_. on the latter , each frame is considered a keyframe since the diversity between frames is such that each passes all the thresholds imposed by the most common keyframe selection heuristics .",
    "we use components of the recent orb - slam  @xcite , made available by the authors , as the baseline for our experiments .",
    "orb - slam incorporates some recent techniques from binary feature descriptors and graph optimization .",
    "modules in orb - slam include fast keypoint detection  @xcite , orb descriptors  @xcite and conversion to a bag - of - words . in loop detection ,",
    "to quickly retrieve bag - of - words of previously visited places , an inverted index structure is maintained .",
    "orb - slam also provides a heuristic to select keyframes , which we also use in our keyframe based experiments .      missed detection and false alarms are traded off by an arbitrary choice of threshold , as in any detection algorithm .",
    "since the threshold affects the average query time ( we can make that quite short by choosing a threshold that yields no false alarms while rejecting every hypothesis ) we must come to a reasonable choice .",
    "we adopt the following policy : we generate precision - recall curves for all possible values of the threshold on _ kitti _ 00 .",
    "then , we select the smallest threshold that yields zero false alarms ( of course , that will still generally yield a non - zero false alarm rate in datasets that are not used in setting the threshold ) and use it on other sequences .",
    "we stress our focus on minimizing search - time of the query , and the data structure that enables it , rather than detection performance which is fixed by the choice of algorithm . choosing sample images as queries ensures that the chosen algorithm will positively detect ( at least ) a loop closure when one is there .",
    "however , to avoid criticalities in the evaluation , we remove the query image from the dataset , but assume that there is a true match with neighboring images or keyframes . in some cases , the neighboring keyframes may be sufficiently different to fail the test , hence introducing spurious errors in the evaluation as these should be considered loop closures .",
    "this occurs , for instance , when the dataset is severely temporally down - sampled , as in the oxford set .",
    "however , this handicap is shared by all methods , thus making our evaluation of the relative improvement due to the adoption of our data structure , fair .",
    "we show that our algorithm can be up to one order of magnitude faster than the baseline algorithm while still maintaining comparable performance in terms of precision and recall .",
    "the datasets we use are the left stereo images from _ kitti _ sequences 00 and 02 , which include 6-dof ground truth poses and many loop closures .",
    "the evaluation protocol is as follows : traverse the sequence and insert bow of images into database incrementally , while using each image to query the database .",
    "two images are regarded as a correct match if they were taken within 15 meters of each other . to avoid trivial matches , we prevent the query from matching temporally adjacent images including the query itself . fig .",
    "[ fig - prcurve00 ] and fig .",
    "[ fig - prcurve02 ] show precision - recall curves of baseline algorithm and our hierarchical search with different topologies .",
    "[ fig - timings ] show timings of the baseline and our algorithm with different topologies and pooling schemes at the same threshold , chosen to achieve high precision and recall .",
    "only time to query the database is counted , time for feature extraction and conversion to bow are excluded .",
    "we use @xmath30  -x to denote a hierarchy with @xmath31 layers , a branching factor of @xmath32 and pooling strategy @xmath33 .",
    "note that for baseline and our proposed algorithm with configuration @xmath34  -mean , @xmath35  -mean , the precision - recall curves are almost identical , while our approach is 2 - 5 times faster . for configuration @xmath36  -mean , while its performance is slightly worse , it achieves an order of magnitude speedup relative to the baseline . as mentioned in sec .",
    "[ sect - testing ] , sum / max - pooling have the same precision - recall behavior as the baseline .",
    "in these two datasets , sum- and max - pooling are slightly slower than inverted index search .",
    "since both of these operations rapidly reduce sparsity in the histograms , we expect slower performance relative to mean - pooling .",
    "however , experiments in sec .  [ sect - synthex ] and sec .  [ sect - retrieval ] show that sum / max - poolings do still speedup search in general .    _",
    ", title=\"fig : \" ] _ , title=\"fig : \" ]      in addition to the baseline algorithm , we generate a second baseline by applying the same algorithm to keyframes , rather than to all stored images . in principle",
    ", the heuristics involved in the selection of keyframes could be propagated to all nodes of the data structure , as discussed in sec .",
    "[ sect - fancy ] .",
    "however , our experiments indicate that this yields minor benefits compared to simple averaging .",
    "the second row of table  [ tab - kittikeyframe ] shows average time - cost rate   for searching via an inverted index among keyframes , which is worse than searching in a simple hierarchy built on raw images , as shown in the second row of table  [ tab - kittioverall ] . besides , a simple regular sampling strategy on top of keyframes can speedup searching by a large margin as shown in table  [ tab - kittikeyframe ] . instead of a fixed topology of the data structure , corresponding to regular grouping",
    ", we can consider adaptive grouping based on a variety of criteria .",
    "adaptive sampling , or grouping , based on _ geometry _ includes performing spectral clustering in @xmath2 .",
    "curves in fig .",
    "[ fig - timings ] indicate that adaptive sampling achieves marginal improvements compared to regular sampling at a constant rate equal to the average of the adaptive sampling rate .",
    "similarly , parallax - based sampling , based on clustering only the translational component of pose , also yields underwhelming improvements .      instead of clustering descriptors based on the domain where they are defined in a loop - closure system , that is pose space and the associated visibility and parallax , we can cluster descriptors based on where they stand in descriptor space .",
    "this is typically done in a discriminative setting using agglomerative information bottleneck ( aib )  @xcite , which can also be used to reduce the complexity of the dictionary we use to compose the bag - of - words  @xcite .",
    "unfortunately , the scale of operations desired prevents straightforward application of agglomerative clustering such as aib , as well as standard data structures such as the kd - tree or decision trees .",
    "also , dimensionality reduction by clustering in descriptor space is counter - productive , because the goal is to discriminate pose , and therefore similar descriptors that refer to distant points in pose space should not be averaged ( think of driving through a countryside where the landscape changes slightly over long stretches of open road ) , whereas different descriptors generated by nearby locations ( think of rotating in place in a cluttered indoor scene ) can be safely aggregated because loop closure can be called so long as any of them triggers a match .",
    "depending on the particular query image , our method could reduce or increase search time .",
    "the former occurs when correspondence fails early allowing us to rule out subsequent tests at finer scales .",
    "however , in the worst - case we may end up performing more comparisons than inverse index search when the test reaches the finest scale too often . in practice , what matters is that our algorithm shortens test time _ on average _ during long sequences .",
    "since most _ kitti _ sequences contain few or no loop closures , we generate synthetic positive and negative queries as follows : for sequences 01 to 21 , we generate positive queries by sampling the right stereo images of each sequence ( slightly different from the left images from which we constructed the database ) , and generate negative queries by sampling images from sequence 00 . for the _ oxford _ datasets , we construct the database using odd - numbered images ,",
    "generate positive queries from the even - numbered images , and negative queries again from _ kitti _ 00 .",
    "overall performance is measured by combining both sets of queries .",
    "of course , even in the negative case our algorithm could find erroneous correspondences , which are then labeled as false alarms .",
    "similarly , we may find no correspondence in the former case ( missed detection ) .",
    "we use average time - cost rate to evaluate how the searching algorithm scales with size of the database .",
    "table  [ tab - kittipositive ] and  [ tab - kittinegative ] show average time - cost rate and speedup over inverse index search on the _ kitti _ dataset for positive / negative queries respectively",
    ". overall performance , combining positive and negative sets , is reported in table  [ tab - kittioverall ] for _ kitti _ and table  [ tab - oxfordregular ] for the _ oxford _ datasets .",
    "also , we repeat the same experimental procedure on a subset of the original database selected using heuristic keyframe selection , instead of using every image of the sequence , in table  [ tab - kittikeyframe ] .      in general , it seems that the domain - specific constraints would favor deep structures with small branching factors for the purpose of accelerating the query .",
    "assuming that loop closures are rare , which is the case in long driving sequences , we can reject queries by just visiting a few top - level nodes of the hierarchy which is cheaper compared to visiting a lot of bottom - level nodes .",
    "however , this only holds for the hierarchy without inverted index . with the inverted index , to retrieve a bag - of - words is just to retrieve sparse common words shared by query and database entries , which makes visiting extra nodes very cheap .",
    "on the other hand visiting an extra layer of the hierarchy always imposes overhead , which might not be negligible depending on the dataset .",
    "therefore , when an inverted index is employed , a shallow structure with suitable branching factor depending on the application is preferred .",
    "furthermore , for short - term loop closure , as employed during tracking and mapping , the priorities are different .",
    "but since in that case scale is not as cogent an issue , we focus on large - scale , rare - loop scenarios . fig .",
    "[ fig - tradeoff ] shows performance of different tree topologies using mean - pooling on _ kitti _ 02 .",
    "all sampled topologies improve the baseline by a considerable margin . depending on the application context and constraints",
    ", one may favor one architecture over another .",
    "this determination has to be made empirically .",
    "here we have focused on benchmark datasets that are commonly employed for navigation , mapping , and loop closure applications .     on _",
    "kitti _ 02 .",
    "baseline : basic inverted index ; @xmath30 : tree structure with depth @xmath31 and branching factor @xmath32 .",
    "mean - pooling is used . _ _ ]      we test our algorithm on two publicly available image retrieval benchmarks : _ ukbench _  @xcite and _ inria holidays dataset _  @xcite .",
    "* ukbench *   consists of 2550 groups of 4 images each ( 10200 total ) .",
    "the 4 images in each group contain the same object or location , but under different viewpoint , rotation , scale and lighting conditions .",
    "we use the same evaluation protocol available on the authors website : count how many of 4 images are top-4 when using a query image from that set of four images .",
    "we use the pre - computed visual words provided by the authors , which are quantized sift descriptors using a 1 m vocabulary .",
    "* inria holidays dataset *   contains 500 image groups ( 1491 total ) , each of which represents a distinct scene or object under different rotations , viewpoint and illumination changes , blurring , etc .",
    "the dataset covers a very large variety of scene types ( natural , man - made , water and fire effects , etc ) .",
    "performance is measured by mean average precision ( map ) averaged over all 500 queries . in our experiments",
    ", we use the 4.5 million sift descriptors and 100k vocabulary provided by the authors to construct a bow for each image .",
    "the baseline remains search using an inverted index system .",
    "our algorithm is facilitated by a three - layer data structure with original histograms at the bottom layer . at the second layer ,",
    "histograms belonging to the same object / scene are pooled ( pooling based on prior information available about the data and problem space ) . at the top layer , we compare two different strategies to build the hierarchy : random grouping and greedy affinity grouping .",
    "random grouping : we randomly group every @xmath9 histograms from the second layer .",
    "greedy affinity grouping : we greedily group every @xmath9 histograms based on their nearest neighbors in affinity ( which is the histogram intersection score ) . in each setup",
    ", we also compare the different choices of pooling operators .",
    "table  [ tab - ukbench ] and table  [ tab - holiday ] show results on the _ ukbench _ and _ holidays _ datasets with @xmath37 , more experiment results with different hierarchical structures can be found in supplemental material .",
    "the search strategy we use in image retrieval is a slightly different from what we use in loop closure . unlike the hierarchical test in loop closure which we search down those nodes which score higher than the threshold , in image retrieval tasks",
    ", we completely discard the threshold and only search down those nodes which have top 10 highest scores .",
    "thus even for sum / max - poolings , the precision - recall behavior should be different from the baseline .",
    "all hierarchical approaches , regardless of pooling operation , are faster than the baseline .",
    "we also notice improved score / map in these two experiments , likely due to the grouping of histograms of the same object / scene at the second layer of our hierarchy and the top-4 scoring mechanism imposed by the benchmark .",
    "we have presented a hierarchical data structure consisting of pooled local descriptors representing the likelihood of locations given the images they generate , while maintaining an inverted index at each level of the data structure .",
    "while mean - pooling of histograms may seem counter - productive , it is a sensible choice when considered an anti - aliasing procedure in the context of classical sampling theory , where the data structure , as well as keyframes , are tasked to _ down - sampling _ the native rate .",
    "we have compared several pooling strategies , and found that mean - pooling provides most speedup at small cost to performance ; sum - pooling has the upper - bound property and accelerates search to a reasonable degree without loss of performance ; and max - pooling shares the same property with sum - pooling but exhibits a larger speedup due better approximating the nodes below it .    for simplicity , we chose a fixed topology ( depth and branching factor ) and studied the resulting performance empirically .",
    "we have found that sophisticated heuristics do not improve performance enough to justify the added complexity .",
    "we have benchmarked our scheme on public datasets , where we have shown that even a shallow tree can significantly cut down on test time with minimal impact to precision , which is the main goal of loop closure ."
  ],
  "abstract_text": [
    "<S> we propose a data structure obtained by hierarchically averaging bag - of - word descriptors during a sequence of views that achieves average speedups in large - scale loop closure applications ranging from @xmath0 to @xmath1 times on benchmark datasets . </S>",
    "<S> although simple , the method works as well as sophisticated agglomerative schemes at a fraction of the cost with minimal loss of performance .    </S>",
    "<S> # 1#1 # 1 </S>"
  ]
}