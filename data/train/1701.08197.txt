{
  "article_text": [
    "radio frequency interference ( rfi ) mitigation is extremely important to take advantage of the vastly improved bandwidth , sensitivity , and field - of - view of exascale telescopes . for current instruments ,",
    "rfi mitigation is typically done offline , and in some cases ( partially ) manually . at the same time",
    ", it is clear that due to the high bandwidth requirements , rfi mitigation will have to be done automatically , and in real - time , for exascale instruments .",
    "in general , real - time rfi mitigation will be less precise than offline approaches . due to memory constraints",
    ", there is much less data to work with , typically only in the order of one second or less , as opposed to the entire observation .",
    "in addition , due to memory limitations and the fact that processing is typically done in a distributed system , we can record only limited statistics of the past . moreover",
    ", we will typically have only few frequency channels locally available at each compute node .",
    "finally , the amount of processing that can be spent on rfi mitigation is extremely limited due to computing constraints and a limited power budget .",
    "many existing algorithms are therefore far too expensive and not applicable .",
    "nevertheless , there are many potential benefits as well , which include the possibility of working on higher time and frequency resolutions , before any integration is done , leading to more accurate results .",
    "most importantly , we can remove rfi before beam forming , which combines data from all receivers . with beam forming , not only the signals , but also the rfi that is present in the data streams from the separate receivers is combined , effectively taking the union of all rfi .",
    "thus , the rfi from any receiver will pollute all beams .",
    "therefore , it is essential to also perform real - time rfi mitigation before the beam former , even though the data rates can be very high at this point .",
    "this is particularly important for pulsar surveys , for instance .",
    "the algorithms we use are based on earlier work by offringa and others  @xcite .",
    "although our techniques are generic , we describe how we implemented real - time rfi mitigation for one of the ska pathfinders : the low frequency array ( lofar )  @xcite .",
    "the modified rfi mitigation algorithms we introduce here are extremely fast , and the computational requirements scale linearly in the number of samples and frequency channels .",
    "we evaluate the quality of the algorithms with lofar pulsar observations . using",
    "the signal - to - noise ratios of the folded pulse profiles , we can qualitatively and quantitatively compare the impact of different real - time rfi mitigation algorithms .",
    "in addition to cpu versions , we have developed a prototype for graphical processing units ( gpus ) .",
    "we present the very promising performance results of performing real - time rfi mitigation on gpus .",
    "finally , we are now working on incorporating our cpu and gpu codes in the ska central signal processor ( csp ) , in the context of the time domain team ( tdt ) pulsar and transient pipeline .",
    "for the offline rfi mitigation for the lofar telescope , we use the aoflagger  @xcite .",
    "this flagger is relatively efficient , and is fast enough to be applied in modern high - resolution observatories .",
    "the aoflagger operates on visibility data , and currently is used only in the imaging mode .",
    "although the aoflagger provides a selection of many different algorithms , for online use , we ported the most important and successful ones to the lofar real - time central processing system , that originally ran on an ibm blue gene / p supercomputer .",
    "we also ported the algorithms to nvidia gpus using cuda , as described in section  [ sec : gpu ] .",
    "we call our implementation of the real - time flagger `` lof '' , short for _ lofar online flagger_.      the most important algorithm we use is sumthreshold  @xcite .",
    "it performs thresholding with an exponentially increasing window size , and an increasingly sharper threshold .",
    "this way , it can detect rfi at different scales . as we will demonstrate in section  [ sec : eval ] , this indeed works well in practice , and effectively removes rfi from microsecond to multiple second scales . with sumthreshold",
    ", we define the threshold for the current window as follows : + @xmath0 + where the factor is : @xmath1 +   + typical values are p = 1.5 , and sensitivity = 1.0 .",
    "all measurements use the defaults , since we empirically found that they provide optimal results .",
    "no tuning is required .",
    "figure  [ fig : sumthreshold ] shows the threshold for different iterations .     for different iterations ;",
    "right graph shows the operation of sumthreshold .",
    "the sliding window doubles every iteration . ]     for different iterations ; right graph shows the operation of sumthreshold .",
    "the sliding window doubles every iteration . ]",
    "figure  [ fig : sumthreshold ] shows the operation of the sumthreshold algorithm . with the default values ,",
    "the algorithm begins the first iteration as a simple thresholder , flagging all single samples that are more than 6  sigma away from the median .",
    "the second iteration doubles the window size to two samples , but lowers the threshold to 4.5  sigma .",
    "we typically run 7 - 10  iterations , depending on the resolution and size of the input .",
    "sumthreshold can be run in a one - dimensional mode , as shown in figure  [ fig : sumthreshold ] .",
    "this can then be done in both time and frequency directions .",
    "alternatively , the algorithm can operate on 2d data in one pass as well ( not shown in figure  [ fig : sumthreshold ] ) . as we will explain in section  [ sec : rt - changes ] , for real - time use ,",
    "we did implement a 2d code , but we will mostly use the one dimensional version of the algorithm for performance reasons .",
    "it is important to note that the computational complexity of the sumthreshold algorithm itself is linear in the number of samples .",
    "therefore , the algorithm is suitable for real - time use , where we are limited by the number of compute cycles we can spend .",
    "the scale - invariant rank operator  @xcite makes sumthreshold more robust , by extending the ranges of flagged samples by a percentage of the size of the flagged range .",
    "a typical percentage we used is 20% .",
    "this means that all ranges of consecutive flagged samples are extended by flagging 20% more samples , before and after the original range .",
    "the algorithm can be run in both the time direction and the frequency direction .",
    "the sir operator helps to remove rfi that slowly rises and decreases in strength , that may be otherwise undetected .",
    "the result of the sir operator is shown in figure  [ fig : sir ] .",
    "we use a version of the sir operator implementation that has a linear computational complexity in the number of samples ( the original implementation in the aoflagger had worse computational complexity ) .",
    "the linear version of the algorithm is described in  @xcite .",
    "since sir operates on the flag masks only , and not on the actual data itself , it is extremely efficient .",
    "figure  [ fig : lofar ] shows a high - level overview of the lofar real - time central signal processing pipeline .",
    "the entire pipeline is implemented in software , and is described in detail in  @xcite , including a detailed performance analysis .",
    "the lofar online flagger components are placed in four different places in the pipeline .",
    "depending on the configuration and the observation type , one or more different flaggers are used .",
    "data arrives in the form of raw voltages at the top left of the figure .",
    "next , a number of steps are executed independently of whether we are in imaging or beam forming mode .",
    "the most important step is a polyphase filter bank that splits the broad input subbands in narrower frequency channels .",
    "typical channel bandwidths are between 0.8  khz and 12  khz , with sample rates between 82  microseconds and 1.3  milliseconds .",
    "when we need extremely high time resolution ( e.g , for millisecond pulsars or for the cosmic ray pipeline ) , we bypass the polyphase filter bank altogether . for this case",
    "we created a special high time resolution flagger .",
    "next , the band pass of the first polyphase filter bank that runs inside the stations on fpgas is corrected .",
    "after this bandpass correction , we inserted our pre - correlation flagger that works on the channelized raw voltage data .",
    "it is important to do this after the band pass correction , as this ensures that the sensitivity is equal across all channels .",
    "the pre - correlation version is the most important real - time flagger , especially for the beam forming modes .",
    "the beam former does a weighted addition of the data streams from the different stations , essentially taking the union of all rfi from all stations .",
    "if rfi is present at a station , this will pollute all output beams .",
    "especially for uncorrelated rfi and long baselines , this is sub optimal .",
    "in addition , we can use our real - time flagger after the correlator , for real - time image - based transient detection , for example .",
    "the drawback of performing rfi mitigation after the correlator is that , depending on the number of baselines and the integration time , data rates can be higher than before the correlator . finally , we have a post beam forming flagger that can potentially benefit from a better interference - to - noise ratio ( inr ) .",
    "moreover , depending on the number of output beams , this typically runs on lower data rates .",
    "to make sure the algorithms used in the aoflagger work in a real - time context , we had to make several changes .",
    "first , depending on the input data type of the flagger , we may have to compute amplitudes first .",
    "this is the case for the high - time resolution flagger , and for the pre - correlation flagger .",
    "the post - correlation flagger runs on visibility data directly , while the post - beam forming flagger runs on stokes  i data .        in pre - correlation mode",
    ", we typically integrate the data .",
    "we found it particularly useful to integrate the time direction fully for frequency flagging , and to integrate the frequency direction fully for time domain flagging .",
    "figure  [ fig : integrate ] shows this .",
    "this approach has two benefits : it improves the inr , while at the same time reducing the computational costs .",
    "we first flag in the frequency direction .",
    "this removes strong narrow - band rfi that would otherwise decrease the quality of the statistics used to compute the thresholds .",
    "we found that this is frequently present in the lofar rfi environment .",
    "this also is the reason we create the narrow approximately 1khz channels .",
    "we have an alternative method that implements 2d  flagging , while partially integrating in one or both dimensions to improve inr and to reduce compute costs .",
    "all flaggers have linear computational complexity in the number of samples , regardless of their place in the real - time pipeline .",
    "for instance , the pre - correlation flagger has a complexity of _",
    "o(nrstations * nrpolarizations * nrchannels * nrtimes ) _ , the post - correlation flagger is _",
    "o(nrbaselines * nrpolarizations * nrchannels ) _ , and the post beam forming flagger is _",
    "o(nrbeams * nrchannels * nrtimes)_.      one of the most difficult problems with real - time rfi mitigation is the very limited window on the observation .",
    "typically , we can only keep one second of data or less ( e.g. , a tenth of a second ) in memory .",
    "similarly , we can only keep a very limited number of frequency channels in memory .",
    "this is due to memory constraints , and partially because we process the data on a distributed system .",
    "we create parallelism by performing domain decomposition .",
    "this typically means that different frequency subbands are processed on different compute nodes .",
    "finally , in some cases , processing a second of input data takes longer than a second . to still meet the real - time requirements , subsequent seconds are processed partially overlapping in time , by different compute nodes .",
    "all these factors severely limit our situational awareness .",
    "our solution for this problem is the introduction of a novel history flagger that performs simple thresholding of the current data chunk , based on statistics of past chunks .",
    "pseudo code for this history flagger is shown below .",
    "+    .... // for all channels , we do the following : // keep a history buffer ( sliding window ) of //",
    "means of unflagged samples of the past seconds    currentvalue = meanofunflaggedsamples ( )    historymean = meanofmeans ( ) historystddev = stddevofmeans ( ) threshold= historymean + sensitivity * historystddev    if(currentvalue < threshold ) {      addtohistory(station , subband , currentvalue ) } else {      addtohistory(station , subband , threshold )      flagthisintegrationtime ( ) } ....        as shown in figure  [ fig : history ] , our flagger uses a history buffer that stores the means of the unflagged samples of the previous seconds of data .",
    "this buffer essentially is a sliding window over the data .",
    "we use the buffer to compute the mean and standard deviation of the previous seconds , to give us a frame of reference for the overall signal strength of the current second .",
    "this is especially important , since a strong broadband rfi event that lasts longer than our integration time can otherwise not be detected .",
    "the quality of the statistics that we compute and keep is important , especially since the window on the data is so small .",
    "we use only very basic statistics , such as ( winsorized ) means , medians , standard deviations , and the mad ( median absolute deviation ) . to compute the medians , which can be expensive",
    ", we use an efficient _ o(n ) _ implementation ( note that sorting the data already is _",
    "o(nlogn ) _ at best .",
    "more complications result from using a distributed platform : statistics are often in the wrong place , at the wrong time .",
    "moreover , we can not compute running statistics , since a second of data takes more than a second to compute .",
    "finally , our real - time pipeline uses complex communication patterns due to scheduling , and asynchronous communication for better performance .",
    "together , this means that even computing basic statistics is quite complex in practice .",
    "an important consideration for the history flagger is presented by the space requirements of the statistics of the past we want to keep in the history buffer .",
    "let us use lofar numbers as an example .",
    "for the pre - correlation flagger , we need @xmath2 = 15.5  mbyte per second .",
    "if we want to keep 5 minutes of history in the buffer , we already need 300  samples , leading to a storage requirement of 4.5  gbytes . after the correlator , requirements are even higher : @xmath3 = 504  mbyte per second , which , even if we want to store only 5 minutes , already leads to 148  gbytes of statistics data .",
    "therefore , in practice , even keeping these very limited statistics of only a few minutes of the past already is extremely difficult , and down - sampling may be needed .",
    "in this section , we will present a qualitative and quantitative evaluation of the real - time flagger , using a lofar pulsar observation .",
    "we use the pulsar pipeline , because it allows for a quantitative comparison : we perform dedispersion and folding to create a folded pulse profile . next , we compute the snr of the pulse profile as a measure of quality .",
    "better rfi mitigation directly leads to a higher snr .",
    "we performed an observation of pulsar b1919 + 21 , which has a period of 1.3373  s , a pulse width 0.04  s , and a dispersion measure ( dm ) of 12.455 .",
    "we observed at 138.0145.2 mhz ( 32 subbands ) with 5  stations : cs005 , cs006 , rs205 , rs406 , and uk608 . we deliberately chose a number of core stations , where rfi is expected to be correlated , a remote station in the netherlands , where the rfi environment is known to be particularly bad , and an international station in the uk , to guarantee we also have uncorrelated rfi .",
    "we used a special lofar mode that allowed us to store the raw udp network packets , before the data even enters the correlator .",
    "this allows us to replay the entire real - time pipeline in an offline mode , enabling comparisons between different flagging algorithms , parameter settings and even observation modes ( e.g. , imaging or beam forming ) . for the beam forming mode that we use for the pulsar pipeline",
    ", we split the frequency subbands into 16  channels ( 12  khz / 82  s ) .",
    "figure  [ fig : waterfall ] shows two waterfall plots .",
    "the left side is the original observation with rfi present ; on the right the improvement of our lof compared to a simple thresholding scheme , where we manually determined the optimal threshold .",
    "there clearly is a lot of residual rfi that is not removed by the thresholder , that is removed by lof .",
    "figure  [ fig : stokesi1 ] shows stokes  i data of an output beam ; figure  [ fig : stokesi2 ] shows the same , but zoomed in .",
    "the top panels are without rfi mitigation , the bottom panels with lof .",
    "almost all rfi is removed .",
    "the data is not de - dispersed , but the pulsar signal is so strong that it is clearly visible in the data . _",
    "note that the pulses are not flagged away by our mitigation algorithms .",
    "_        in figure  [ fig : profiles ] ( left side ) , we show the folded pulse profiles , without rfi mitigation , with a simple thresholder , and with lof . without rfi mitigation ,",
    "the pulsar signal is completely below the noise floor , and can not be detected . with the thresholder , the pulse is visible , but there also are false positives , caused by strong rfi events that were not removed . with lof ,",
    "there is one clear peak with the right shape , with a good snr .",
    "this can be seen better in the right side of figure  [ fig : profiles ] , which shows the same data , but zoomed in , with the non - flagged line removed .",
    "figure  [ fig : snr ] shows that lof flags 2.9% of the data in the observation , significantly more than the simple thresholder that only flags 1.7% . in the bottom",
    "left graph , we show that lof flags away about 15% of the total signal power , only slightly more than the simple thresholder .",
    "the bottom right graph shows the snr of the folded pulse profile .",
    "lof is significantly better than the simple thresholder , and almost as high as performing _",
    "rfi mitigation with presto s rfifind  @xcite .",
    "the lofar online processor needs hundreds of teraflops of computational power .",
    "future instruments such as the square kilometre array ( ska ) will be much more sensitive , and will require orders of magnitude more processing  @xcite . therefore , we were careful to make sure that all algorithms used in our real - time flagger have a linear computational complexity , allowing excellent scaling .",
    "in addition , we investigated the use of modern processing architectures , such as gpus . for lofar , we already switched from an ibm blue gene / p system to a gpu cluster .",
    "for the central signal processor of the ska , a combination of fpgas and gpus are likely . in this section",
    ", we present a prototype gpu version of the lof .          with linus schoemaker  @xcite , we worked on the gpu port of lof .",
    "due to the limited space , we will only describe the most important differences with the normal parallel cpu version here . the normal lof exploits parallelism by scheduling different subbands to different",
    "compute nodes . inside the compute nodes we use c++ and openmp for multi - threading , and asynchronous mpi messages for inter - node communication . to avoid synchronization and parallelization overhead",
    ", we make the parallelism as coarse grained as possible .",
    "this means that each thread handles all data for one subband .",
    "gpus , in contrast , can efficiently exploit extremely fine grained parallelism .",
    "hundreds of thousands of threads can work in parallel on a single gpu , without overhead .",
    "in fact , in our implementation , we create one gpu thread _ per sample_. we exploit data - reuse by using the shared memory that is available inside the gpu s streaming multiprocessors .",
    "the performance results are shown in figure  [ fig : gpu ] .",
    "the top two lines ( red and green ) show the run time without doing any data integration , running sumthreshold on the full input data rate . for the red line , we also run the sir operator ; green is without .",
    "the bottom two lines show performance if we fully integrate and run sumthreshold two times , once in the frequency direction , and once in the time direction , as described in section  [ sec : rt - changes ] . in all cases ,",
    "we achieve linear scalability .",
    "the gpu performs so well , that we can handle all lofar stations on single gpu in real time .",
    "we are currently working on incorporating our cpu and gpu codes in the ska central signal processor ( csp ) , in the context of the time domain team ( tdt ) pulsar and transient pipeline .",
    "the initial stages of the csp , including the beam former , will likely use fpgas .",
    "after the beam former , gpus are the most likely candidate for further processing",
    ". therefore , we will perform post - beamforming flagging using our algorithms on gpus . for an fpga implementation",
    ", more research is needed .",
    "we have demonstrated that our online flagger can achieve much higher quality than simple thresholding , in real time , even on a distributed system .",
    "the sumthreshold algorithm was originally used mostly on visibility data . in this paper",
    ", we demonstrated that the algorithm also works well on raw voltages , pre - correlation data , and post - beam forming data .",
    "therefore , we have one robust algorithm for extremely different scales , from microseconds to multiple seconds . the algorithms are scalable and have linear computational complexity , adding little overhead to existing pipelines .",
    "one complication is that we have an extremely limited view on our data , and therefore need a history flagger . due to the high data rates",
    ", we have to be flexible in storage requirements , even for statistics .",
    "we are currently working on commissioning of the gpu code for lofar .",
    "moreover , we are constructing a performance model that can extrapolate scalability towards ska sizes .",
    "this model includes power dissipation as well , since this will be an important bottleneck for the ska .",
    "we plan to use the dome exabounds tool for this analysis  @xcite .",
    "all code used in this paper is available as open source : + https://github.com/nlesc/eastroviz ."
  ],
  "abstract_text": [
    "<S> we describe the design and implementation of an extremely scalable real - time rfi mitigation method , based on the offline aoflagger . </S>",
    "<S> all algorithms scale linearly in the number of samples . </S>",
    "<S> we describe how we implemented the flagger in the lofar real - time pipeline , on both cpus and gpus . </S>",
    "<S> additionally , we introduce a novel simple history - based flagger that helps reduce the impact of our small window on the data .    by examining an observation of a known pulsar , </S>",
    "<S> we demonstrate that our flagger can achieve much higher quality than a simple thresholder , even when running in real time , on a distributed system . </S>",
    "<S> the flagger works on visibility data , but also on raw voltages , and beam formed data . </S>",
    "<S> the algorithms are scale - invariant , and work on microsecond to second time scales . </S>",
    "<S> we are currently implementing a prototype for the time domain pipeline of the ska central signal processor .    </S>",
    "<S> rfi , real - time , lofar , ska , csp , tdt </S>"
  ]
}