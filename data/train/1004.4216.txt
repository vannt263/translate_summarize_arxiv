{
  "article_text": [
    "the expansion of database systems to encompass the storage of non - alphanumeric datatypes has led to the requirement for index structures by which these datatypes may be queried .",
    "tree - based index structures for traditional datatypes rely heavily on the fact that these datatypes have a strict linear ordering ; this is unsurprising since it is this same property that we use naturally in discussing ordered data , using notions such as ` before ' , ` after ' and ` between ' .",
    "newer datatypes such as images and sounds possess no such natural linear ordering , and in consequence we do not attempt to exploit one , but rather evaluate data in terms of their relative _ similarities _ : one image is ` like ' another image but is ` not like ' another different image . this has led to the notion of _ similarity searching _ for such datatypes , and the definition of queries like _ range _ ( find all objects within a given distance of a query object ) and _ k nearest neighbour _ ( find the _ k _ objects in the database nearest to the query object ) , where _ distance _ is some measure of the dissimilarity between objects .    spatial access methods such as the r - tree @xcite can support similarity queries of this nature by abstracting objects as points in a multidimensional vector space and calculating distance using a euclidean metric .",
    "a more general approach is to abstract objects as points in a metric space , in which a distance function is known , but absolute positions of objects need not be .",
    "this renders consideration of dimensionality unnecessary , and so provides a single method applicable to all dimensionalities , and also to cases where dimensionality is unclear or unknown .",
    "the first metric trees @xcite were essentially static , in - memory structures . however , in 1997 the m - tree @xcite was proposed ; a paged , dynamically balanced structure that adjusts gracefully to insertion of new objects .",
    "the notion of objects _ closeness _ is preserved more perfectly than in earlier structures by associating a _ covering radius _ with pointers above the leaf level in the tree , indicating the furthest distance from the pointer at which an object in its subtree might be found .",
    "this , in combination with the triangle inequality property of the metric space , permits branches to be pruned from the tree when executing a query .    for a query result to be found in a branch rooted on a pointer with reference value @xmath0 , that result must be within a distance @xmath1 ( the _ search radius _ ) of the query object @xmath2 . by definition ,",
    "all objects in the branch rooted on @xmath0 are also within @xmath3 ( the covering radius ) of @xmath0 , so the regions defined by @xmath1 around @xmath2 and @xmath3 around @xmath0 must intersect .",
    "this is a direct statement of the triangle inequality : for an object answering query @xmath2 to be found in the subtree rooted on @xmath0 , it must be true that : @xmath4 so when @xmath0 is encountered in descending the tree , @xmath5 can be calculated in order to decide whether further descent is required or the branch can be pruned from the search .",
    "figure [ fig : prune ] shows a query in 2-dimensional space for which the branch rooted on @xmath0 can be pruned from the search .",
    "figure [ fig : noprune ] gives the opposite case .",
    "although the m - tree grows gracefully under insert , there has to date been no algorithm published for the complementary delete operation .",
    "the authors of @xcite explicitly state in their discussion of the slim - tree , an m - tree structure modified for enhanced performance , that neither their structure nor the original m - tree yet support delete . in this paper",
    "we discuss some reasons for the difficulty in implementing delete , propose a modified tree to overcome these , present an algorithm for delete and discuss some features of our modification .",
    "the insertion of an object @xmath6 into an m - tree proceeds as follows . from the root node , an entry pointing to a child node",
    "is selected as the most appropriate parent for @xmath6 .",
    "the child node is retrieved from disk and the process is repeated recursively until the entry reaches the leaf level in the tree .",
    "a number of suggestions have been made as to how the ` best ' subtree should be chosen for descent .",
    "the original implementation of the m - tree selects , if possible , a subtree for which zero expansion of covering radius is necessary , or , if not , the subtree for which the required expansion of covering radius is least .",
    "a slim - tree offers the same options , a randomly selected subtree , or a choice based on the available physical space to accommodate the new entry in the subtree . in all of these variations however , in the event that the covering radius of the selected node entry @xmath0 must be expanded to accommodate the entry , it is expanded to @xmath7 as @xmath6 passes @xmath0 on its way to the leaf level .",
    "having reached a leaf , @xmath6 is inserted if it fits , otherwise the leaf node is split into two with leaf entries being partitioned into two groups according to some strategy , referred to as the _ splitting policy_. pointers to the two leaves are then promoted to the level above , replacing the pointer to the original child . on promotion ,",
    "the covering radius of each promoted node entry @xmath8 is set to : @xmath9 where @xmath10 is the set of entries in the leaf .",
    "if there is insufficient space in the node to which entries are promoted , it too splits and promotes entries . when promoting from two internal nodes in this way , the covering radius of each promoted node entry",
    "is set to : @xmath11 where @xmath10 is the set of entries in the node .",
    "this applies the limiting case of the triangle inequality property of the metric space to observe that any leaf entry in the new entry s subtree and accessed through a chain of node entries , is at most as far from the new entry as if that chain of node entries were linear .    a critical observation , with respect to the delete problem , is that immediately after a node entry is promoted , its covering radius is dependent solely on its distance from its _ immediate _ children , and the covering radius of those children",
    "this is not always true ; once another object for insertion @xmath12 passes the node entry and expands its covering radius to @xmath13 , the new covering radius depends on the entire contents of the node entry s subtree , and can only be specified exactly as : @xmath14 where @xmath15 is the set of _ all _ leaf entries in the subtree rooted on @xmath0 .",
    "this effect is illustrated in figure [ fig : asymm ] , which shows three levels of an m - tree branch .",
    "figure [ fig : asymm](a ) shows leaf entries * b * and * c * , under a subtree pointer with reference value * b*. this subtree s covering radius is currently contained within that of its own parent , * a*. in figure [ fig : asymm](b ) , insertion of point * d * causes a slight expansion of the radius around * a * , but expands the child s radius _ beyond _ that of its parent .",
    "thus the correct covering radius around * a * is no longer calculable from the distance to , and the radii of , * a * s immediate children .",
    "the decision to expand the covering radius only as far as is immediately necessary and no further therefore introduces asymmetry between the insert and ( unimplemented ) delete operations : insert adds an object and may expand covering radii , but conversely delete can not contract a node entry s covering radius without reference to _ all _ objects at the leaf level in its subtree , thus requiring an expensive subtree walk for correct implementation .",
    "in the sm - tree , on insertion of new objects , we explicitly expand the covering radius of a node entry to the limit specified by the triangle inequality ; _ i.e. _ to maintain all non - leaf entries covering radii at the size they would be were they newly promoted from below in a standard m - tree .",
    "the insert algorithm undergoes a slight modification to achieve this : no longer are covering radii expanded as new objects pass routing node entries , but expanded covering radii are returned upwards as each recursive call terminates .",
    "the modified insert algorithm is given below .",
    "in this and later algorithms we invoke the procedure ` split ` ; this is not defined here but takes a set of entries and partitions them , according to the selected splitting policy , into two sets that each fit into a single node ( disk page ) .",
    "two pointers to those nodes are then returned with their covering radii set appropriately . `",
    "insert ` returns either the two pointers returned by ` split ` , or if no node splitting occurs , returns the ( possibly expanded ) covering radius of the subtree , to update its existing node entry pointer .",
    "insert ( @xmath6:leafentry , @xmath16:node , @xmath17:nodeentry ) + [ 0.25 cm ]    ifffff=    let @xmath10 be the set of entries in @xmath16 ; + if ( @xmath16 is a leaf ) + add @xmath6 to @xmath10 ; + if ( @xmath10 will fit into @xmath16 ) + let @xmath18 ; + return @xmath19 ; + else + split(@xmath10 ) ; + return promoted entries ; + else + choose ` best ' subtree entry @xmath20 from @xmath10 ; + insert(@xmath6 , child(@xmath20 ) , @xmath20 ) ; + if ( entries returned ) //",
    "_ entries promoted from below _",
    "+ let @xmath21 be the set of returned entries ; + remove @xmath20 from @xmath10 ; + if ( @xmath22 will fit into @xmath16 ) + for each entry @xmath23 + let @xmath24 ; + add @xmath8 to @xmath10 ; + return @xmath25 ; + else + split(@xmath22 ) ; + return promoted entries ; + else + let @xmath26 returned covering radius ; + if ( @xmath27 ) + let @xmath28 = @xmath29 ; + return @xmath25 ; +    the choice of @xmath20 is made by finding the node entry closest to the entry being inserted @xmath6 ( _ i.e. _ the entry @xmath30 for which @xmath7 is a minimum ) , rather than by attempting to limit the expansion of existing covering radii , because it is no longer possible while descending the tree to make any assertions about the effect of that choice on @xmath28 .",
    "the choice made in the original m - tree was based on the heuristic that we wish to minimise the overall volume covered by a node @xmath16 . in the sm - tree , unlike the original m - tree , all node entry covering radii entirely contain their subtrees , suggesting that subtrees should be centred as tightly as possible on their root ( within the constraint of minimising overlap between sibling nodes ) to minimise the volume covered by @xmath16 .",
    "the complexity of the insert algorithm , in common with the b - tree and m - tree structures , is @xmath31 , where @xmath32 is the height of the tree .",
    "other m - tree - like structures do not yet support the delete operation ; however the provision of insert / delete symmetry in the sm - tree enables this structure to do so .",
    "it is now true in all cases that the covering radius of a node entry is dependent solely on its separation from its immediate children and their covering radii ; this enables covering radii to be returned by an implementation of the delete operation in the same way that they are by the modified ` insert ` , and permits node entry covering radii to contract as objects are deleted .",
    "furthermore , as a node entry s covering radius is no longer directly dependent on the distance between it and leaf - level entries in its subtree , node entries can be distributed between other nodes , permitting underflown internal nodes to be merged with other nodes at the same level .",
    "the ` delete ` algorithm proceeds in a similar manner to a range query of range zero ( exact match ) , exploiting the triangle inequality for tree pruning , followed by the actions required to delete an object if it is found , and handle underflow if it occurs . `",
    "delete ` returns the ( possibly contracted ) covering radius of the subtree , or when a node underflows returns that node s full set of entries .",
    "delete ( @xmath33:leafentry , @xmath16:node ) + [ 0.25 cm ]    ifffffff=    let @xmath10 be the set of entries in @xmath16 ; + if ( @xmath16 is a leaf ) + if ( @xmath34 ) + remove @xmath33 from @xmath10 ; + if ( @xmath16 is underflown ) + return @xmath10 ; + return @xmath19 ; + else + for each @xmath35 + if ( @xmath36 ) + delete ( @xmath33 , @xmath37 ) ; + if ( entries returned ) // _ child node underflown _ + let @xmath21 be the set of returned entries ; + find node entry @xmath38 for which @xmath39 is a minimum ; + let @xmath40 be the set of entries in @xmath41 ; + if ( @xmath42 ) will fit into @xmath41 + remove @xmath0 from @xmath10 ; + for each @xmath23 + let @xmath43 ; + add @xmath8 to @xmath40 ; + if ( @xmath41 is a leaf ) + let @xmath44 ; + else + let @xmath45 ; + else + remove @xmath0 and @xmath46 from @xmath10 ; + split(@xmath42 ) ; + add new child pointer entries to @xmath10 ; + else + let @xmath26 returned covering radius ; + if ( @xmath47 ) + let @xmath3 = @xmath29 ; + if ( @xmath16 is underflown ) + return @xmath10 ; + else + return @xmath25 ; +    in this implementation of delete , returned entries are merged with those belonging to the child of its parent s nearest neighbour in the node .",
    "it may be that more careful merging policies can be defined to maximise the tree s shrinkage under delete in the same way that intelligent splitting policies minimise the tree s expansion under insert .",
    "as in the b - tree , the delete algorithm s complexity is @xmath31 , where @xmath32 is the height of the tree .",
    "for experimental evaluation , a series of sm - trees and m - trees were constructed on 4 kb pages from a set of 25 000 objects in 2 , 4 , 6 , 8 , 10 , 15 and 20 dimensions .",
    "all trees used the original m - tree s _ minmax _ split policy and the @xmath48 metric for @xmath49 dimensions : @xmath50 for @xmath51 .    in our implementation of the sm - tree",
    ", queries are evaluated in the same way as in the standard m - tree .",
    "branches are pruned from the search when the triangle inequality does not permit results to be found in them .",
    "nearest neighbour searches proceed using the notion of a _ dynamic search radius _ ; a search begins as a range query with infinite range and the search radius is contracted as objects within it are encountered .",
    "data objects were implemented as points in a 20-dimensional vector space , enabling dimensionality of experiments to be varied simply by adjusting the metric function to consider a fewer or greater number of dimensions , while maintaining a constant object size . except where indicated otherwise , experiments were performed using an artifically clustered data set .",
    "clusters were produced by distributing randomly - generated points around other seed points ( also randomly - generated ) .",
    "a trigonometric function based distribution was chosen to produce a higher point density closer to seed points , although each vector component was produced independently , resulting in regions of higher point density parallel to coordinate axes ( see figure [ fig : points ] ; dimensions 1 and 2 of the 20-dimension data set ) .",
    "each tree was required to process a series of range and nearest - neighbour queries . _",
    "k_-nearest - neighbour queries were run for 1 , 10 and 50 nearest neighbours , and for each such query , the distance of the _ _ k__th neighbour from the query object was used to formulate a range query that returned the same set of results .",
    "query performance is measured in terms of page - hits ( ios ) assuming an initially empty , infinite buffer pool , and in all cases is averaged over 100 queries .",
    "figure [ fig : nn1 ] gives the performance of the m - tree and sm - tree in evaluating a one - nearest - neighbour query , clearly showing that the two are comparable , although the sm - tree does pay a performance penalty over the m - tree .",
    "the near - horizontal lines on the plot indicate the number of ios required to read the trees leaf - level pages , _",
    "i.e. _ the number at which it becomes as costly to perform a sequential scan as to use the tree structure . in common with other multidimensional and metric access methods , performance deteriorates with increasing dimensionality .",
    "the 50-nearest - neighbour query given in figure [ fig : nn50 ] illustrates the deterioration in search performance when searching for larger numbers of objects : this is expected given that larger ranges of data must necessarily occupy a larger portion of the search structure .",
    "more interesting however is the comparison between the one - nearest - neighbour ( figure [ fig : nn1 ] ) and zero - radius ( figure [ fig : r0 ] ) queries . for a query object known to be in the database both will return exactly one object",
    ", however the zero - radius query easily outperforms the nearest - neighbour query , we believe as a direct consequence of the fact that all nearest - neighbour queries begin with a search radius of infinity .",
    "this is less striking but equally true in other queries returning greater numbers of results .",
    "the effect of different data distributions on a 1-nearest - neighbour query is illustrated in figure [ fig : datadist ] .",
    "sm - trees and m - trees were produced using the clustered data set used previously , another non - uniformly distributed data set , and a uniform random data set .",
    "non - uniform data points were generated using a polynomial function taking randomly - generated numbers as input and producing as output non - uniformly distributed numbers between 0 and 1 .",
    "a graph of dimensions 1 and 2 of this distribution is given in figure [ fig : non - uniform ] .",
    "both the sm - tree and the m - tree perform better with increasingly non - uniform data .",
    "figure [ fig : msd ] illustrates an interesting behaviour of the sm - tree under delete .",
    "the figure gives the one - nearest - neighbour query results for three trees : the two structures already discussed and a third , a sm - tree containing the same set of 25 000 objects but created by inserting twice that number and deleting half of them .",
    "the curve for the post - delete tree is noticeably higher than the others , however it can also be seen that the efficiency limit for a sequential scan is raised in proportion : the tree is bigger and less heavily occupied .",
    "a separate analysis in this case showed the post - delete tree s nodes to be just over 40% full ( the page underflow limit ) while the other trees nodes were approaching 60% full .",
    "this is exactly analogous to a situation well - known in b - trees .",
    "in the sm - tree we present a structure that modifies the original m - tree in order to obtain and maintain an invariant property of the tree : that a node entry s covering radius is always dependent solely on information available from its immediate children .",
    "this invariant property permits us to observe that the tree is symmetric with respect to the ( modified ) insert and delete operations , for which we provide algorithms .",
    "the performance of the tree is in most cases comparable to that of the m - tree , and where comparison is not possible ( in the post - delete case ) , is analogous with the b - tree .",
    "a performance penalty over the m - tree is introduced by maintaining insert / delete symmetry , however this may be judged to be acceptable in cases where support for object deletion is required .",
    "some directions for further work include the development of split policies specially adapted to the behaviour of the sm - tree .",
    "m - tree heuristics for developing tightly clustered subtrees are reflected in splitting policies designed for that structure , and are likely to be less compatible with the sm - tree s requirement for tightly _ centred _ subtrees , _ i.e. _ the preference for rooting subtrees on pointer values close to that on which the parent is rooted , in order to reduce expansion of covering radii on propagation back up the tree ."
  ],
  "abstract_text": [
    "<S> the m - tree is a paged , dynamically balanced metric access method that responds gracefully to the insertion of new objects . to date </S>",
    "<S> , no algorithm has been published for the corresponding delete operation . </S>",
    "<S> we believe this to be non - trivial because of the design of the m - tree s insert algorithm . </S>",
    "<S> we propose a modification to insert that overcomes this problem and give the corresponding delete algorithm . </S>",
    "<S> the performance of the tree is comparable to the m - tree and offers additional benefits in terms of supported operations , which we briefly discuss .    </S>",
    "<S> * keywords * : metric access methods , similarity queries , dynamic metric trees , triangle inequality </S>"
  ]
}