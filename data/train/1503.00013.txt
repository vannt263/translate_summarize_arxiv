{
  "article_text": [
    "the importance of big data analytics has been widely recognized in recent years , however , efficient large scale distributed data storage systems have to be designed and implemented in order to support the complete pipeline of data collection , processing and archival on a scale never seen before , where advanced coding techniques have been shown to play an important role .    digital contents in large scale",
    "distributed storage systems usually have different reliability requirements .",
    "for example , although it is important to protect recent customer billing records with a very reliable code , it may be acceptable to allow the data loss probability of a 5-year - old office document backup to be higher by using a relatively weak code .",
    "moreover , it was shown recently that erasure codes can also be used to reduce data access latency , whose behavior depends on the coding parameters @xcite .",
    "thus , different levels of latency can also be integrated into the same data storage system by adopting different coding parameters for different contents .",
    "such flexibility can significantly reduce the cost of hardware infrastructure , and there is tremendous interest recently both in industry and in academia to design efficient software defined storage ( sds ) systems utilizing flexible erasure codes .",
    "the theoretical framework of symmetrical multilevel diversity ( mld ) coding @xcite is a natural fit for this scenario , where there are a total of @xmath0 independent messages @xmath1 to be stored , and the overall system consists of @xmath2 storage nodes situated in different network locations , each with @xmath3 units of data .",
    "the messages are coded in such a way that by accessing any @xmath4 of these nodes , the first @xmath5 messages @xmath6 can be completely recovered .",
    "disk or node failures occur regularly in a large scale storage system , and the overall quality of service is heavily affected by the efficiency of the repair process .",
    "@xcite proposed the framework of regenerating codes to address the tradeoff between the storage and repair - bandwidth in @xmath7 erasure - coded distributed storage systems . to repair a node ,",
    "a new node replacing the failed one requests @xmath8 units of data each from any of the @xmath9 remaining nodes , and regenerates the @xmath3 units of content to store on the new node ; this code is referred to as the @xmath10 regenerating code .",
    "there exists a natural tradeoff between the storage @xmath3 and the repair bandwidth @xmath8 : the point corresponding to the minimum amount of the storage is referred to as the minimum storage regenerating ( msr ) point , and the other extreme is referred to as the minimum repair - bandwidth regenerating ( mbr ) point . in @xcite , the content regenerated is allowed to be only functionally equivalent to the content on the failed node , thus the name functional - repair regenerating codes . in practice , requiring the content regenerated to be exactly the same as that on the failed node can simplify the system design significantly , and thus recent research effort has focused on exact - repair regenerating codes @xcite .    in the regenerating code framework , only a single message is allowed , and thus offering only a single level of reliability and access latency ; on the other hand , in the mld coding framework , the data repair process was not considered . in this work ,",
    "we consider repair - efficient codes in systems with heterogeneous reliability and latency requirements , and investigate the optimal storage vs. repair - bandwidth tradeoff . because of the connection to the mld coding problem and the regenerating code problem , we refer to this problem as multilevel diversity coding with regeneration ( mld - r ) in the sequel ; see fig .",
    "[ fig : system ] .",
    "we shall restrict our attention to the case of exact - repair , and furthermore to the case when @xmath11 , because this is the most practically important case .",
    "nevertheless , the framework can be straightforwardly generalized to other relevant settings .",
    "an intuitive and straightforward coding strategy is to use individual regenerating code for each message to satisfy the respective reliability and latency requirement ( _ i.e. , _ separate coding ) , and thus the most important question we must answer first is whether it is even beneficial to consider codes that mix the messages . without the repair consideration , it was shown in @xcite that no mixing is necessary for the symmetrical mld coding problem .",
    "we show that for the minimum storage point on the optimal tradeoff where @xmath3 is minimized ( analogous to the msr point in regenerating codes ) , the aforementioned separate coding is again sufficient . on the other hand ,",
    "we show for @xmath12 , by providing a novel code construction , that mixing can strictly improve upon the performance of the separate coding solution in terms of overall storage - repair - bandwidth tradeoff .",
    "in fact , we completely characterize this tradeoff by establishing its converse .",
    "it is worth noting that when @xmath13 , separate coding is in fact sufficient , thus @xmath12 is the smallest non - trivial case where the benefit of mixing manifests .",
    "one difficulty in establishing these results is in deriving the outer bounds . for the minimum storage point , we utilize a recursive bounding technique which may be of independent interest .",
    "the converse for the tradeoff rate region when @xmath12 is rather difficult to identify and derive manually , and thus we utilize the computational approach developed in @xcite .",
    "this proof is thus presented in tables whose rows are simple known information inequalities , and the summation of the rows are precisely the outer bounds . though this does not conform to the conventional proof approach of using chains of information inequalities in information theory literature , we believe that these tables are in a sense more fundamental .",
    "indeed , we can write down many different versions of chains of inequalities with the help of these tables , by taking different orders when applying these individual inequalities .",
    "the rest of the paper is organized as follows .",
    "a formal problem formulation and some preliminaries are given in section [ sec : problemformulation ] . in section [ sec : main ] , the main results of the paper are presented together with the relevant discussion .",
    "the proofs are given in section [ sec : msp ] and section [ sec : case4 ] .",
    "section [ sec : conclusion ] concludes the paper with a few future research directions .",
    "several technical proofs are given in the appendix .",
    ", width=642 ]",
    "an mld - r code is defined below , where @xmath14 is used to denote the set @xmath15 , and @xmath16 is used to denote the cardinality of a set @xmath17 .",
    "it can be assumed without loss of generality @xmath18 , where @xmath19 is the number of messages .",
    "this is because if @xmath20 , then the messages @xmath21 can be viewed as part of @xmath22 ; on the other hand if @xmath23 , we can simply consider an alternative problem with @xmath24 and define the messages @xmath25 to be degenerate .",
    "recall in this work we assume @xmath11 .    [ def : nkkcode ] an @xmath26 mld - r code consists of @xmath2 encoding functions @xmath27 , @xmath28 decoding functions @xmath29 , @xmath30 repair encoding functions @xmath31 , and @xmath2 repair decoding functions @xmath32 , where @xmath33 each of which maps the message @xmath34 to one piece of coded information , @xmath35 each of which maps coded information stored on a set @xmath17 of nodes to the first @xmath16 messages @xmath36 , @xmath37 each of which maps a piece of coded information at node @xmath38 to an index that is made available to node @xmath39 to reconstruct the coded data at node @xmath39 , and @xmath40 each of which maps @xmath9 such indices from the helper nodes to reconstruct the information stored at the failed node @xmath39 .",
    "the functions must satisfy the data reconstruction conditions @xmath41 and the repair conditions @xmath42    note @xmath43 is the storage node capacity , @xmath44 is the per - helper - node repair bandwidth , and @xmath45 is the rate of the @xmath38-th message ; the base of @xmath46 is arbitrary , and we choose base 2 for convenience . because of the linear scaling relation among them , we can alternatively consider the normalized version as follows .",
    "a normalized storage - repair - bandwidth - message - rate tuple @xmath47 is said to be achievable with @xmath2 nodes where @xmath48 , if there exists an @xmath26 mld - r code such that @xmath49 the convex closure of all the achievable @xmath47 tuples is the achievable storage - repair - bandwidth - message - rate tradeoff region @xmath50 . for a fixed @xmath51 tuple ,",
    "the achievable storage - repair - bandwidth tradeoff region is the collection of all @xmath52 pairs such that @xmath53 , which is denoted as @xmath54 .    the codes and the tradeoff regions do not involve any particular assumption on the distribution of the messages , however , without loss of generality we can assume that the messages @xmath55 are mutually independent and uniformly distributed , since otherwise we can perform a pre - coding to eliminate any dependence and non - uniformity .",
    "sometimes it is convenient to use the accumulative sum rates instead of individual rates , and thus we define @xmath56 the corresponding accumulative message @xmath57 is sometimes also written as @xmath58 .",
    "note that this definition implies @xmath59 , however we often still write @xmath60 for convenience .",
    "the reconstruction condition ( [ eqn : reconstructionzeroerror ] ) requires that there is no decoding error , _",
    "i.e. _ , the zero - error requirement is adopted .",
    "an alternative definition is to require instead the probability of decoding error to be asymptotically zero as @xmath61 .",
    "it will become clear that this does not cause any essential difference , and thus we do not give this alternative definition .",
    "when deriving outer bounds , we use @xmath62 to denote the helper ( random ) information sent from node-@xmath38 to node-@xmath39 , and @xmath63 to denote the coded data stored on node-@xmath38 .",
    "the random variable vector @xmath64 is sometimes written as @xmath65 .",
    "one straightforward coding strategy is to encode each individual message using a regenerating code of the necessary strength .",
    "more precisely , the message @xmath66 is encoded using an @xmath10 regenerating code ( _ i.e. _ , any @xmath5 nodes can recover the message @xmath66 , and any new node obtains information from any @xmath9 nodes for repair ) of rate @xmath67 , and the resultant code thus has storage rate and repair rate : @xmath68    in order to characterize this separate coding tradeoff region , denoted as @xmath69 , tradeoff region characterizations of individual regenerating codes are needed ; _ e.g. , _ for the case of @xmath13 , tradeoff region characterizations for @xmath70 and @xmath71 regenerating codes are needed . however ,",
    "such characterizations for general parameters are still unknown , except for the case of @xmath72 , and the special case @xmath73 only recently established in @xcite .",
    "fortunately , using these existing results , we can provide a characterization of the separate coding tradeoff region for mld - r when @xmath13 , denoted as @xmath74 , and that when @xmath12 , denoted as @xmath75 .",
    "[ prop : case3 ] the storage - repair - bandwidth tradeoff region @xmath74 achievable using separate coding is the set of @xmath52 pairs satisfying the following conditions @xmath76    [ prop : case4 ] the storage - repair - bandwidth tradeoff region @xmath75 achievable using separate coding is the set of @xmath52 pairs satisfying the following conditions @xmath77    the proofs for these propositions are given in the appendix .",
    "our first main result is a characterization of the extreme point in the tradeoff rate region @xmath54 where @xmath78 is minimized , through the following theorem .    [",
    "theorem : msp ] for any @xmath79 , we have @xmath80    it was shown in @xcite that for mld coding without repair considerations , the minimum achievable rate is given as @xmath81 using separate coding .",
    "thus theorem [ theorem : msp ] and the existence of @xmath10 exact - repair regenerating codes at the msr point @xcite imply the following corollary .    for the minimum storage point on the boundary of the tradeoff rate region @xmath79 where @xmath81 the minimum repair bandwidth is given as @xmath82 and it can be achieved by separately coding of each message @xmath66 with an @xmath10 exact - repair msr code .",
    "the next two theorems provide complete characterizations for @xmath83 and @xmath84 .    [",
    "theorem : case3 ] @xmath85 .",
    "the forward direction @xmath86 is straightforward , and the converse direction is proved in the appendix .",
    "this theorem states that for the case of @xmath13 , the strategy of separate coding is optimal , and there is no need to mix the messages .",
    "however , our next result shows that this is in general not true , and mixing the messages is beneficial . for this purpose , we establish theorem [ theorem : mrr4 ] , whose proof is provided in section [ sec : case4 ] .",
    "[ theorem : mrr4 ] the storage - repair - bandwidth tradeoff region @xmath87 is the collection of all @xmath52 pairs that satisfy the following constraints : @xmath88    the regions @xmath89 and @xmath90 are depicted in fig .",
    "[ fig : rateregion ] for the case @xmath91 and @xmath92 .",
    "it can be seen that the inclusion @xmath93 is strict , thus generally , mixing of contents in mld - r can be beneficial .",
    "we formally state it as it a corollary .",
    "@xmath94 .     using separate coding , and the tradeoff rate region @xmath95 .",
    "[ fig : rateregion],width=415 ]",
    "it can be shown that we only need to consider symmetric codes , where permutations of node indices do not change the joint entropy values ; see @xcite for more details about this symmetry . thus without loss of generality , we can restrict the proof to symmetric codes only . before presenting the proof of theorem [ theorem :",
    "msp ] , we first give an auxiliary lemma .",
    "this lemma plays a similar instrumental role in the proof of theorem [ theorem : msp ] as han s inequality in the converse proof of symmetrical mld coding problem given in @xcite .",
    "[ lemma : msp ] for any integer @xmath96 such that @xmath97 and any symmetric mld - r code with a total of @xmath2 nodes @xmath98    let @xmath96 be an integer such that @xmath97 .",
    "we start by writing @xmath99 where we write @xmath100 to denote for the reason of symmetry , the first inequality in the chain is because @xmath101 and the second inequality is by data reconstruction requirement ( [ eqn : reconstructionzeroerror ] ) .",
    "however notice that @xmath102 where in the last step we applied han s inequality , and also used the symmetry property . putting ( [ eqn : lemma1 ] ) and ( [ eqn : lemma2 ] ) together gives @xmath103 which has common terms on both sides that can be eliminated , and this leads to exactly the inequality in the lemma .    in the proof of the lemma above , after several steps of derivation , the same terms in the original quantity reappear , albeit with different coefficients .",
    "the same terms are subtracted on both sides of the inequality , which can be conceptually viewed as recursively applying the same chains of inequalities .",
    "we are now ready to present the proof of theorem [ theorem : msp ] .",
    "the theorem is proved through an induction , where we show that for @xmath104 , @xmath105h(w^m_1|m^m_1)\\nonumber\\\\ & \\qquad\\qquad\\qquad\\qquad\\qquad+\\frac{h(s_{m+1\\rightarrow1},\\ldots , s_{n\\rightarrow1},w^m_1|m^m_1)}{n - m}.\\label{eqn : claim}\\end{aligned}\\ ] ] the theorem is then simply a consequence of this statement when setting @xmath106 and normalizing both sides by @xmath107 , and taking into account of the facts @xmath108=0,\\end{aligned}\\ ] ] and @xmath109    to show ( [ eqn : claim ] ) is true for @xmath110 , we write the following chain of inequalities @xmath111 applying lemma [ lemma : msp ] now with @xmath112 gives @xmath113h(w_1|m_1)\\nonumber\\\\ & \\qquad\\qquad\\qquad+\\frac{b_2}{n-2}+\\frac{h(s_{3\\rightarrow1},\\ldots , s_{n\\rightarrow1},w_1,w_2|m_1,m_2)}{n-2}.\\end{aligned}\\ ] ] thus ( [ eqn : claim ] ) is true for @xmath110 .",
    "next suppose ( [ eqn : claim ] ) is true @xmath114 , and we wish to show it is also true for @xmath115 .",
    "notice that by lemma [ lemma : msp ] with @xmath116 , we have @xmath117 thus @xmath118h(w^{m_0}_1|m^{m_0}_1)\\nonumber\\\\ & \\qquad\\qquad\\qquad\\qquad\\qquad+\\frac{h(s_{m_0 + 1\\rightarrow1},\\ldots , s_{n\\rightarrow1},w^{m_0}_1|m^{m_0}_1)}{n - m_0}\\nonumber\\\\ & \\geq \\sum_{k=1}^{m_0}\\frac{(n-2)(n - k)+1}{k(n - k)}{b}_k+\\left[\\frac{n-2}{m_0}-\\frac{m_0 - 1}{m_0(n - m_0)}-\\frac{n-1}{m_0(n - m_0)(n - m_0 - 1)}\\right]h(w^{m_0}_1|m^{m_0}_1)\\nonumber\\\\ & \\qquad + \\frac{1}{n - m_0 - 1}b_{m_0 + 1}+\\frac{1}{n - m_0 - 1}h(s_{m_0 + 2\\rightarrow1},\\ldots , s_{n\\rightarrow1},w^{m_0 + 1}_1|m^{m_0 + 1}_1)\\nonumber\\\\ & = \\sum_{k=1}^{m_0}\\frac{(n-2)(n - k)+1}{k(n - k)}{b}_k+\\left[\\frac{n-2}{m_0}-\\frac{1}{n - m_0 - 1}\\right]h(w^{m_0}_1|m^{m_0}_1)\\nonumber\\\\ & \\qquad + \\frac{1}{n - m_0 - 1}b_{m_0 + 1}+\\frac{1}{n - m_0 - 1}h(s_{m_0 + 2\\rightarrow1},\\ldots , s_{n\\rightarrow1},w^{m_0 + 1}_1|m^{m_0 + 1}_1)\\nonumber\\\\ & \\geq \\sum_{k=1}^{m_0}\\frac{(n-2)(n - k)+1}{k(n - k)}{b}_k+\\left[\\frac{n-2}{m_0}-\\frac{1}{n - m_0 - 1}\\right]\\frac{m_0}{m_0 + 1}h(w^{m_0 + 1}_1|m^{m_0}_1)\\nonumber\\\\ & \\qquad + \\frac{1}{n - m_0 - 1}b_{m_0 + 1}+\\frac{1}{n - m_0 - 1}h(s_{m_0 + 2\\rightarrow1},\\ldots , s_{n\\rightarrow1},w^{m_0 + 1}_1|m^{m_0 + 1}_1)\\nonumber\\\\ & = \\sum_{k=1}^{m_0}\\frac{(n-2)(n - k)+1}{k(n - k)}{b}_k+\\left[\\frac{n-2}{m_0 + 1}-\\frac{m_0}{(n - m_0 - 1)(m_0 + 1)}+\\frac{1}{n - m_0 - 1}\\right]b_{m_0 + 1}\\nonumber\\\\ & \\qquad+\\left[\\frac{n-2}{m_0 + 1}-\\frac{m_0}{(n - m_0 - 1)(m_0 + 1)}\\right]h(w^{m_0 + 1}_1|m^{m_0 + 1}_1)\\nonumber\\\\ & \\qquad\\qquad+\\frac{1}{n - m_0 - 1}h(s_{m_0 +",
    "2\\rightarrow1},\\ldots , s_{n\\rightarrow1},w^{m_0 + 1}_1|m^{m_0 + 1}_1),\\end{aligned}\\ ] ] which is precisely ( [ eqn : claim ] ) for @xmath115 after some elementary algebra .",
    "this completes the proof of theorem [ theorem : msp ] .",
    "readers familiar with the converse proof for the symmetric mld coding problem may recognize certain similarity between the above proof and that in @xcite .",
    "the key difference is that in the converse proof for mld coding , one only needs to peel off the message rates by combining information in @xmath63 s sequentially . here",
    "the regeneration requirement necessitates a more elaborate peeling process , and lemma [ lemma : msp ] serves a similar role as han s inequality in the proof in @xcite .",
    "in this section the proof of theorem [ theorem : mrr4 ] is presented .",
    "we start by providing a new code construction that achieves a particular operating point , which will play an instrumental role in the proof of theorem [ theorem : mrr4 ] .",
    "[ sec : case4 ]      we first give a proposition , the proof of which requires a new code construction .    [",
    "theorem : case4outside ] the rate pair @xmath119 .",
    "we give a novel code construction where @xmath120 , @xmath121 , @xmath122 , @xmath123 and @xmath124 .",
    "for concreteness , the code symbols and algebraic operations are assumed in gf@xmath125 .",
    "let us denote the information symbols of message @xmath126 as @xmath127 , and the symbols of message @xmath128 as @xmath129 .",
    "* encoding : * first use a @xmath130 mds erasure code ( _ e.g. _ , reed - solomon code ) to encode @xmath127 into ten coded symbols @xmath131 , such that any three symbols can completely recover @xmath127 .",
    "then place linear combinations of @xmath129 and @xmath131 into the nodes as in table [ tab : codesymbols ] , where the addition @xmath132 is also in gf@xmath125 .",
    "* decoding @xmath126 using any two nodes : * to decode @xmath126 , observe that any pair of nodes has two symbols involving the same @xmath133 , in the form of @xmath134 in one node and @xmath133 in the other node .",
    "for example node 2 has symbol @xmath135 and node 3 has @xmath136 .",
    "this implies @xmath137 can be recovered , and together with the first symbols stored in this pair of nodes , we have three distinct symbols in the set @xmath138 .",
    "thus by the property of the mds code , these three symbols can be used to recover @xmath127 and thus the message @xmath126 .",
    "* decoding @xmath126 and @xmath128 using any three nodes : * recall using any two nodes we can recover the message @xmath126 , and thus all the code symbols @xmath131 .",
    "this implies that when three nodes are available , we can eliminate all the @xmath137 symbols first in the linear combinations .",
    "however , it is clear that after this step all the symbols @xmath129 are directly available , and thus the message @xmath128 can be decoded .",
    "* repair using any three nodes : * to regenerate the symbols in one node from the other three , each of the helper nodes sends the first symbol stored on the nodes as the initial step .",
    "denote the @xmath139 symbols on the failed node as @xmath140 , which may be stored in a form also involving @xmath141-symbols .",
    "the helper nodes each find in the symbols stored on it the one involving @xmath142 , @xmath133 and @xmath143 , respectively , and send these symbol combinations as the second step .",
    "the placement of the @xmath139-symbol guarantees that these symbols are stored on the three helper nodes respectively .",
    "recall that from any three @xmath141-symbols available in the initial step , the message @xmath126 can recovered , and thus any of the @xmath141-symbols .",
    "this implies that @xmath140 can be recovered after eliminating the @xmath141 symbols from the received symbol combinations in the second step , and thus all the symbols on the failed node can be successfully regenerated .",
    "each helper node contributes exactly @xmath144 symbols in this process .    .a",
    "code for @xmath12 where @xmath145 and @xmath146 .",
    "[ cols=\"^,^,^,^,^\",options=\"header \" , ]",
    "we considered multilevel diversity coding with regeneration , which addresses the storage vs. repair - bandwidth tradeoff in distributed storage systems with heterogeneous reliability and access latency requirements .",
    "it is shown that for the minimum storage point on the optimal tradeoff , separate coding is sufficient , and there is no need to mix different contents . on the other hand ,",
    "a complete characterization of the tradeoff region is provided for the case of four nodes , which reveals that mixing can strictly improve the general tradeoff . in other words ,",
    "separate coding using individual regenerating code is not optimal , and mixing the contents can strictly improve the efficiency of the codes .",
    "another notable feature of this work is that we further developed the computational approach in @xcite to identify and prove the converse . as a result ,",
    "the converse proof is presented as tabulation , without translating the tables to the conventional form of proofs usually seen in information theory literature .",
    "it is our belief that this computational approach will be able to play an even more significant role in future studies . in order to help future researchers to utilize such data",
    ", we post the result in this paper as part of the online collection of `` solutions of computed information theoretic limits ( scitl ) '' hosted at @xcite , which hopefully in the future can serve as a data depot for information theoretic limits obtained through computational approaches .",
    "there are several immediate research directions to follow .",
    "firstly , the code construction given for @xmath12 can be generalized to other parameters straightforwardly , and we shall address this issue in a later work .",
    "secondly , the mld - r problem can be extended to allow more general values of @xmath9 not equal to @xmath147 .",
    "thirdly , it is important to understand how much improvement over separate coding can be attained by mixing the contents .",
    "lastly , it may also be useful to consider the analogous requirement in the locally repairable code setting @xcite .",
    "it is known that the rate region of @xmath70 regenerating codes ( before normalization ) is @xmath148 and the rate region of @xmath71 regenerating codes is @xmath149 it is straightforward to verify that separate coding indeed leads to the rate region given in proposition [ prop : case3 ] using fourier - motzkin elimination .",
    "it is straightforward to show that the inequalities in proposition [ prop : case4 ] have to hold in this separate coding based achievability scheme , _",
    "e.g. _ , @xmath150 where ( a ) is because of ( [ eqn:413 ] ) , ( b ) because of ( [ eqn:423 ] ) , and ( c ) because of ( [ eqn:433 ] ) .",
    "other inequalities can be shown in a similar manner .",
    "next we show this outer bound is indeed achievable using the separate coding based scheme .",
    "computing the intersections of any two linear bounds in ( [ eqn : case4_1])-([eqn : case4_5 ] ) yields a total of @xmath151 points , which are the possible extremal ( corner ) points of the region .",
    "however , some of them do not satisfy all the inequalities , and after eliminating them , the corner points of the region in proposition [ prop : case4 ] are thus given as ( see also fig .",
    "[ fig : rateregion ] ) @xmath152 next we show that they are indeed achievable using the separate coding based scheme , which implies that the region given in ( [ eqn : case4_1])-([eqn : case4_5 ] ) is achievable by a time - sharing argument .",
    "it is easily seen that the rate pairs in ( [ eqn : point4 ] ) are all simple linear combinations of the corner point rate pairs of the @xmath162 and @xmath159 codes after proper normalization , _",
    "i.e. , _ by dividing @xmath163 , and thus achievable using the separate coding based scheme .",
    "the proof is now complete .",
    "it can be shown that we only need to consider symmetric codes , where permutations of node indices do not change joint entropy values ; see @xcite for more details about this symmetry . thus without loss of generality , we can restrict the proof to symmetric codes only .",
    "denote the information stored at node @xmath38 as @xmath63 , the helper information sent from node @xmath38 to node @xmath39 as @xmath164 , and the message to be decoded using any @xmath39 nodes as @xmath165 .",
    "first write the following inequalities @xmath166\\nonumber\\\\ & \\geq b_1+\\frac{1}{2}h(w_1,w_2|m_1)\\nonumber\\\\ & \\stackrel{(c)}{=}b_1+\\frac{1}{2}h(w_1,w_2,m_2|m_1)\\nonumber\\\\ & \\geq b_1+\\frac{1}{2}h(m_2|m_1)\\geq b_1+\\frac{1}{2}b_2,\\label{eqn : firstinequality}\\end{aligned}\\ ] ] where ( a ) is because @xmath167 can be recovered from @xmath168 alone , and ( s ) implies by the existence of symmetric solutions , ( c ) is because @xmath169 together can recover @xmath126 . dividing both sides of ( [ eqn : firstinequality ] ) by @xmath170 gives the result . from here ,",
    "we use ( s ) to denote by the reason of the symmetry .",
    "next we bound @xmath8 by writing @xmath171\\nonumber\\\\ & \\geq \\frac{1}{2}[h(s_{1\\rightarrow3},s_{2\\rightarrow3})]\\nonumber\\\\ & \\stackrel{(a)}{=}\\frac{1}{2}[h(s_{1\\rightarrow3},s_{2\\rightarrow3},w_3,m_1)]\\nonumber\\\\ & \\geq \\frac{1}{2}b_1+\\frac{1}{2}h(s_{1\\rightarrow3},s_{2\\rightarrow3},w_3|m_1),\\end{aligned}\\ ] ] where ( a ) is because from the helper message @xmath172 and @xmath173 , we can regenerate @xmath174 . to bound the second term above",
    ", we write @xmath175\\nonumber\\\\ & \\stackrel{(a)}{=}h(s_{1\\rightarrow3},s_{2\\rightarrow3},w_3,s_{3\\rightarrow1},s_{3\\rightarrow2}|m_1)\\nonumber\\\\ & \\geq h(s_{1\\rightarrow3},s_{2\\rightarrow3},s_{3\\rightarrow1},s_{3\\rightarrow2}|m_1)\\nonumber\\\\ & \\stackrel{(s)}{=}\\frac{1}{3}[h(s_{1\\rightarrow3},s_{2\\rightarrow3},s_{3\\rightarrow1},s_{3\\rightarrow2}|m_1)\\nonumber\\\\ & \\qquad\\qquad+h(s_{1\\rightarrow2},s_{3\\rightarrow2},s_{2\\rightarrow1},s_{2\\rightarrow3}|m_1)\\nonumber\\\\ & \\qquad\\qquad\\qquad+h(s_{3\\rightarrow1},s_{2\\rightarrow1},s_{1\\rightarrow2},s_{1\\rightarrow3}|m_1)]\\nonumber\\\\ & \\stackrel{(b)}{\\geq } \\frac{1}{3}[h(s_{1\\rightarrow3},s_{2\\rightarrow3},s_{3\\rightarrow1},s_{3\\rightarrow2},s_{1\\rightarrow2},s_{2\\rightarrow1}|m_1)\\nonumber\\\\ & \\qquad+h(s_{3\\rightarrow2},s_{2\\rightarrow3}|m_1)+h(s_{3\\rightarrow1},s_{2\\rightarrow1},s_{1\\rightarrow2},s_{1\\rightarrow3}|m_1)]\\nonumber\\\\ & \\stackrel{(c)}{=}\\frac{1}{3}[b_2+h(s_{3\\rightarrow2},s_{2\\rightarrow3}|m_1)\\nonumber\\\\ & \\qquad\\qquad+h(s_{3\\rightarrow1},s_{2\\rightarrow1},s_{1\\rightarrow2},s_{1\\rightarrow3}|m_1)]\\nonumber\\\\ & \\geq \\frac{1}{3}[b_2+h(s_{3\\rightarrow2},s_{2\\rightarrow3},s_{3\\rightarrow1},s_{2\\rightarrow1},s_{1\\rightarrow2},s_{1\\rightarrow3}|m_1)]\\nonumber\\\\ & \\geq \\frac{1}{3}[b_2+h(m_2|m_1)]\\geq \\frac{2b_2}{3},\\end{aligned}\\ ] ] where ( a ) is because @xmath176 are functions of @xmath174 , ( b ) is because @xmath177 and ( c ) is because from @xmath178 we can regenerate @xmath179 , subsequently decode @xmath126 .",
    "it follows that @xmath180    the remaining inequality in theorem [ theorem : case3 ] can be proved by writing the following : @xmath181\\nonumber\\\\ & = \\frac{3}{2}b_1+h(w_1,s_{1\\rightarrow2},s_{1\\rightarrow3}|m_1)+\\frac{1}{2}h(s_{1\\rightarrow3},s_{2\\rightarrow3},w_3|m_1)\\nonumber\\\\ & = \\frac{3}{2}b_1+\\frac{1}{2}h(w_1,s_{1\\rightarrow2},s_{1\\rightarrow3}|m_1)\\nonumber\\\\ & \\quad+\\frac{1}{2}[h(w_1,s_{1\\rightarrow2},s_{1\\rightarrow3}|m_1)+h(s_{1\\rightarrow3},s_{2\\rightarrow3},w_3|m_1)]\\nonumber\\\\ & \\geq \\frac{3}{2}b_1+\\frac{1}{2}h(w_1,s_{1\\rightarrow2},s_{1\\rightarrow3}|m_1)\\nonumber\\\\ & \\quad+\\frac{1}{2}[h(w_1,w_3,s_{1\\rightarrow2},s_{1\\rightarrow3},s_{2\\rightarrow3}|m_1)+h(s_{1\\rightarrow3}|m_1)]\\nonumber\\\\ & = \\frac{3}{2}b_1+\\frac{1}{2}b_2+\\frac{1}{2}[h(w_1,s_{1\\rightarrow2},s_{1\\rightarrow3}|m_1)+h(s_{1\\rightarrow3}|m_1)]\\nonumber\\\\ & \\stackrel{(s)}{=}\\frac{3}{2}b_1+\\frac{1}{2}b_2+\\frac{1}{2}[h(w_1,s_{1\\rightarrow2},s_{1\\rightarrow3}|m_1)+h(s_{2\\rightarrow3}|m_1)]\\nonumber\\\\ & \\geq\\frac{3}{2}b_1+\\frac{1}{2}b_2+\\frac{1}{2}[h(w_1,s_{1\\rightarrow2},s_{1\\rightarrow3},s_{2\\rightarrow3}|m_1)]\\nonumber\\\\ & \\geq\\frac{3}{2}b_1+b_2.\\end{aligned}\\ ] ] the proof is thus complete .",
    "n. b. shah , k. v. rashmi , p. v. kumar and k. ramchandran , distributed storage codes with repair - by - transfer and non - achievability of interior points on the storage - bandwidth tradeoff , , vol .",
    "1837 - 1852 , mar .",
    "k. v. rashmi , n. b. shah , and p. v. kumar , optimal exact - regenerating codes for distributed storage at the msr and mbr points via a product - matrix construction , , vol .",
    "57 , no . 8 , pp . 52275239 , aug ."
  ],
  "abstract_text": [
    "<S> digital contents in large scale distributed storage systems may have different reliability and access delay requirements , and for this reason , erasure codes with different strengths need to be utilized to achieve the best storage efficiency . at the same time , in such large scale distributed storage systems , nodes fail on a regular basis , and the contents stored on them need to be regenerated and stored on other healthy nodes , the efficiency of which is an important factor affecting the overall quality of service . in this work , </S>",
    "<S> we formulate the problem of multilevel diversity coding with regeneration to address these considerations , for which the storage vs. repair - bandwidth tradeoff is investigated . </S>",
    "<S> we show that the extreme point on this tradeoff corresponding to the minimum possible storage can be achieved by a simple coding scheme , where contents with different reliability requirements are encoded separately with individual regenerating codes without any mixing . on the other hand </S>",
    "<S> , we establish the complete storage - repair - bandwidth tradeoff for the case of four storage nodes , which reveals that codes mixing different contents can strictly improve this tradeoff over the separate coding solution . </S>"
  ]
}