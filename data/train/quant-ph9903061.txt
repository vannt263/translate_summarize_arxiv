{
  "article_text": [
    "richard feynman  @xcite in his talk during the first conference on the physics of computation held at mit in 1981 observed that it appears to be impossible to simulate a general quantum evolution on a classical probabilistic computer in an _ efficient _ way .",
    "he pointed out that any classical simulation of quantum evolution appears to involve an exponential slowdown in time as compared to the natural evolution since the amount of information required to describe the evolving quantum state in classical terms generally grows exponentially in time .",
    "however , instead of viewing this as an obstacle , feynman regarded it as an opportunity .",
    "if it requires so much computation to work out what will happen in a complicated multiparticle interference experiment then , he argued , the very act of setting up such an experiment and measuring the outcome is tantamount to performing a complex computation .",
    "indeed , all quantum multiparticle interferometers _ are _ quantum computers and some interesting computational problems can be based on estimating internal phase shifts in these interferometers .",
    "this approach leads to a unified picture of quantum algorithms and has been recently discussed in detail by cleve _ et al . _",
    "@xcite .",
    "let us start with the textbook example of quantum interference , namely the double - slit experiment , which , in a more modern version , can be rephrased in terms of mach - zehnder interferometry ( see fig .  [ fig - mz ] ) .",
    "( 80,70 ) ( 0,30)(1,0)30 ( 30,27)(5,6)@xmath0 ( 35,30)(1,0)20 ( 10,20)(0,1)35 ( 55,30)(0,1)35 ( 10,55)(1,0)20 ( 30,52)(5,6)@xmath1 ( 35,55)(1,0)30 ( 65,52)(0,1)6 ( 65,55)(6,6)[r ] ( 52,65)(1,0)6 ( 55,65)(6,6)[t ] ( 40,70)(30,6)@xmath2 ( 69,52)(30,6)@xmath3 ( 8,28)(1,1)4 ( 53,53)(1,1)4 ( 8,53)(1,1)4 ( 53,28)(1,1)4 ( 0,31)(5,5)@xmath4 ( 4,20)(5,5)@xmath5 ( 50,30)(5,5)@xmath4 ( 10,50)(5,5)@xmath5    [ fig - mz ]    a particle , say a photon , impinges on a beam - splitter ( bs1 ) , and , with some probability amplitudes , propagates via two different paths to another beam - splitter ( bs2 ) which directs the particle to one of the two detectors . along each path between the two beam - splitters , is a phase shifter ( ps ) .",
    "if the lower path is labelled as state @xmath6 and the upper one as state @xmath7 then the particle , initially in path @xmath6 , undergoes the following sequence of transformations @xmath8 where @xmath0 and @xmath1 are the settings of the two phase shifters and the action of the beam - splitters is defined as @xmath9 ( and extends by linearity to states of the form @xmath10 ) . here , we have ignored the @xmath11 phase shift in the reflected beam , which is irrelevant because the interference pattern depends only on the _ difference _ between the phase shifts in different arms of the interferometer .",
    "the phase shifters in the two paths can be tuned to effect any prescribed relative phase shift @xmath12 and to direct the particle with probabilities @xmath13 and @xmath14 respectively to detectors  0 \" and  1 \" .",
    "the roles of the three key ingredients in this experiment are clear .",
    "the first beam splitter prepares a superposition of possible paths , the phase shifters modify quantum phases in different paths and the second beam - splitter combines all the paths together .",
    "as we shall see in the following sections , quantum algorithms follow this interferometry paradigm : a superposition of computational paths is prepared by the hadamard ( or the fourier ) transform , followed by a quantum function evaluation which effectively introduces phase shifts into different computational paths , followed by the hadamard or the fourier transform which acts somewhat in reverse to the first hadamard / fourier transform and combines the computational paths together . to see this ,",
    "let us start by rephrasing mach - zehnder interferometry in terms of quantum networks .",
    "in order to avoid references to specific technological choices ( hardware ) , let us now describe our mach - zehnder interference experiment in more abstract terms .",
    "it is convenient to view this experiment as a _ quantum network _ with three quantum logic gates ( elementary unitary transformations ) operating on a qubit ( a generic two - state system with a prescribed computational basis @xmath15 ) .",
    "the beam - splitters will be now called the hadamard gates and the phase shifters the phase shift gates ( see  fig .  [ fig - hph ] ) .",
    "( 80,20 ) ( 0,10)(1,0)7 ( 7,7)(6,6)*h * ( 52,7)(6,6)*h * ( 58,10)(1,0)10 ( 13,10)(1,0)9 ( 22,7)(21,6)@xmath16 ( 43,10)(1,0)9    [ fig - hph ]    the hadamard gate is the single qubit gate @xmath17 performing the unitary transformation known as the hadamard transform given by ( eq .  [ tran ] )    @xmath18    the matrix is written in the basis @xmath19 and the diagram on the right provides a schematic representation of the gate * h * acting on a qubit in state @xmath20 , with @xmath21 . using the same notation we define the phase shift gate @xmath22 as a single qubit gate such that @xmath23 and @xmath24 ,    @xmath25    let us explain now how the phase shift @xmath26 can be `` computed '' with the help of an auxiliary qubit ( or a set of qubits ) in a prescribed state @xmath27 and some controlled-@xmath28 transformation where @xmath29 ( see fig .  [ cphase ] ) .    ( 180,50 )    ( 25,10)(0,0)@xmath27 ( 25,40)(0,0)@xmath6    ( 30,40)(1,0)10 ( 50,40)(1,0)40 ( 100,40)(1,0)10 ( 30,10)(1,0)35 ( 75,10)(1,0)35    ( 40,35)(10,10)*h * ( 90,35)(10,10)*h * ( 70,40 ) ( 70,40)(0,-1)25 ( 65,5)(10,10)*u *    ( 115,10)(0,0)@xmath27 ( 125,40)(0,0 )    here the controlled-@xmath28 is a transformation involving two qubits , where the form of @xmath28 applied to the auxiliary or target qubit depends on the logical value of the control qubit . for example , we can apply the identity transformation to the auxiliary qubits ( i.e. do nothing ) when the control qubit is in state @xmath6 and apply a prescribed @xmath28 when the control qubit is in state @xmath7 . in our example",
    "shown in fig .",
    "[ cphase ] , we obtain the following sequence of transformations on the two qubits    @xmath30    we note that the state of the auxiliary register @xmath27 , being an eigenstate of @xmath28 , is not altered along this network , but its eigenvalue @xmath31 is `` kicked back '' in front of the @xmath7 component in the first qubit .",
    "the sequence ( [ sequ ] ) is equivalent to the steps of the mach - zehnder interferometer ( [ mz ] ) and , as was shown in  @xcite , the kernel of most known quantum algorithms .",
    "since quantum phases in interferometers can be introduced by some controlled-@xmath28 operations , it is natural to ask whether effecting these operations can be described as an interesting computational problem .",
    "suppose an experimentalist , alice , who runs the mach - zehnder interferometer delegates the control of the phase shifters to her colleague , bob .",
    "bob is allowed to set up any value @xmath12 and alice s task is to estimate @xmath26 . clearly for general @xmath26",
    "this involves running the device several times until alice accumulates enough data to estimate probabilities @xmath32 and @xmath33 , however , if bob promises to set up @xmath26 either at @xmath34 or at @xmath35 then a single - shot experiment can deliver the conclusive outcome ( click in detector `` 0 '' corresponds to @xmath36 and in detector `` 1 '' corresponds to @xmath37 ) . the first quantum algorithm proposed by david deutsch in 1985  @xcite",
    "is related to this effect .",
    "we have seen in the previous section that a controlled - u transformation can be used to produce a particular phase shift on the control qubit corresponding to its eigenvalue on the auxiliary qubit .",
    "if two eigenvalues of the controlled - u transformation lead to different orthogonal states in the control qubit , a single measurement on this qubit will suffice to distinguish the two cases .",
    "for example consider the boolean functions @xmath38 that map @xmath39 to @xmath39 .",
    "there are exactly four such functions : two constant functions ( @xmath40 and @xmath41 ) and two `` balanced '' functions ( @xmath42 and @xmath43 ) .",
    "it turns out that it is possible to construct a controlled function evaluation such that two possible eigenvalues are produced which may be used to determine whether the function is constant or balanced .",
    "this is done in the following way .",
    "let us formally define the operation of `` evaluating '' @xmath38 in terms of the _ @xmath38-controlled - not _ operation on two bits : the first contains the input value and the second contains the output value .",
    "if the second bit is initialised to @xmath34 , the @xmath38-controlled - not maps @xmath44 to @xmath45 .",
    "this is clearly just a formalization of the operation of computing @xmath38 . in order to make the operation reversible ,",
    "the mapping is defined for _ all _ initial settings of the two bits , taking @xmath46 to @xmath47 , where @xmath48 denotes addition modulo two .",
    "a single evaluation of the @xmath38-controlled - not on quantum superpositions suffices to classify @xmath38 as constant or balanced .",
    "this is the real advantage of the quantum method over the classical .",
    "classically if the @xmath38-controlled - not operation may be performed only once then it is _ impossible _ to distinguish between balanced and constant functions .",
    "whatever the outcome , both possibilities ( balanced and constant ) remain for @xmath38 .",
    "this corresponds to our classical intuition about the problem since it involves determining not particular values of @xmath49 and @xmath50 , but a global property of @xmath38 .",
    "classically to determine this global property of @xmath38 , we have to evaluate both @xmath49 and @xmath50 , which involves evaluating @xmath38 twice .",
    "deutsch s quantum algorithm has the same mathematical structure as the mach - zehnder interferometer , with the two phase settings @xmath51 .",
    "it is best represented as the quantum network shown in fig .",
    "[ deutsch ] , where the middle operation is the @xmath38-controlled - not , which can be defined as :    @xmath52    ( 180,50 )    ( 18,10)(0,0)@xmath53 ( 25,40)(0,0)@xmath6    ( 30,40)(1,0)10 ( 50,40)(1,0)40 ( 100,40)(1,0)10 ( 30,10)(1,0)35 ( 75,10)(1,0)35    ( 40,35)(10,10)*@xmath54 * ( 90,35)(10,10)*@xmath54 * ( 70,40 ) ( 70,40)(0,-1)25 ( 65,5)(10,10)*@xmath55 *    ( 122,10)(0,0)@xmath53 ( 125,40)(0,0 )    the initial state of the qubits in the quantum network is @xmath56 ( apart from a normalization factor , which will be omitted in the following ) . after the first hadamard transform , the state of the two qubits has the form @xmath57 . to determine the effect of the @xmath38-controlled - not on this state , first note that , for each @xmath58 , @xmath59 therefore , the state after the @xmath38-controlled - not is @xmath60 that is , for each @xmath61 , the @xmath20 term acquires a phase factor of @xmath62 , which corresponds to the eigenvalue of the state of the auxiliary qubit under the action of the operator that sends @xmath63 to @xmath64 .",
    "this state can also be written as @xmath65 which , after applying the second hadamard transform to the first qubit , becomes @xmath66 therefore , the first qubit is finally in state @xmath6 if the function @xmath38 is constant and in state @xmath7 if the function is balanced , and a measurement of this qubit distinguishes these cases with certainty .",
    "the mach - zehnder interferometer with phases @xmath0 and @xmath1 each set to either 0 or @xmath35 can be regarded as an implementation of the above algorithm . in this case ,",
    "@xmath0 and @xmath1 respectively encode @xmath49 and @xmath50 ( with @xmath35 representing 1 ) , and a single photon can query both phase shifters ( i.e.  @xmath49 and @xmath50 ) in superposition . more recently ,",
    "this algorithm ( fig .",
    "4 ) has been implemented using a very different quantum physical technology , nuclear magnetic resonance @xcite .",
    "more general algorithms may operate not just on single qubits , as in deutsch s case , but on sets of qubits or ` registers ' .",
    "the second qubit becomes an auxiliary register @xmath27 prepared in a superposition of basis states , each weighted by a different phase factor , @xmath67 in general , the middle gate which produces the phase shift is some controlled function evaluation .",
    "a controlled function evaluation operates on its second input , the ` target ' , according to the state of the first input , the ` control ' .",
    "a controlled function @xmath38 applied to a control state @xmath20 , and a target state @xmath27 gives @xmath68 where the addition is mod @xmath69 .",
    "hence for the register in state  ( [ reg ] ) @xmath70 effectively a phase shift proportional to the value of @xmath71 is produced on the first input .",
    "we will now see how phase estimation on registers may be carried out by networks consisting of only two types of quantum gates : the hadamard gate @xmath17 and the conditional phase shift @xmath72 .",
    "the conditional phase shift is the two - qubit gate @xmath72 defined as @xmath73 the matrix is written in the basis @xmath74 , ( the diagram on the right shows the structure of the gate ) .",
    "for some of the known quantum algorithms , when working with registers , the hadamard transformation , corresponding to the beamsplitters in the interferometer , is generalised to a quantum fourier transform .",
    "the discrete fourier transform is a unitary transformation of a @xmath75dimensional vector @xmath76 defined by : @xmath77 where @xmath71 and @xmath78 are in general complex numbers . in the following ,",
    "we assume that @xmath75 is a power of @xmath79 , i.e. , @xmath80 for some @xmath81 ; this is a natural choice when binary coding is used .",
    "the quantum version of the discrete fourier transform ( qft ) is a unitary transformation which can be written in a chosen computational basis @xmath82 as , @xmath83 more generally , the @xmath84 effects the discrete fourier transform of the input amplitudes . if @xmath85 then the coefficients @xmath86 are the discrete fourier transforms of the @xmath71 s",
    ".    a given phase @xmath87 can be encoded by a qft . in this process",
    "the information about @xmath88 is distributed between states of a register .",
    "let @xmath61 be represented in binary as @xmath89 , where @xmath90 ( and similarly for @xmath91 ) .",
    "an important observation is that the qft of @xmath61 , @xmath92 , is unentangled , and can in fact be factorised as @xmath93 the network for performing the qft is shown in fig .",
    "[ fig - qft ] .",
    "the input qubits are initially in some state @xmath94 where @xmath95 is the binary representation of @xmath61 , that is , @xmath96 .",
    "as the number of qubits becomes large , the rotations @xmath97 will require exponential precision , which is impractical .",
    "fortunately , the algorithm will work even if we omit the small rotations , @xcite .",
    "the general case of @xmath81 qubits requires a simple extension of the network following the same pattern of @xmath98 and @xmath99 gates .",
    "( 210,120)(40,0 )    ( 0,34)(20,12)@xmath100 ( 0,54)(20,12)@xmath101 ( 0,74)(20,12)@xmath102 ( 0,94)(20,12)@xmath103    ( 240,34)(20,12)@xmath104 ( 240,54)(20,12)@xmath105 ( 240,74)(20,12)@xmath106 ( 240,94)(20,12)@xmath107    ( 43,16)@xmath108    ( 20,40)(1,0)170 ( 190,34)(12,12)@xmath54 ( 202,40)(1,0)18 ( 20,60)(1,0)104 ( 124,54)(12,12)@xmath54 ( 136,60)(1,0)84 ( 20,80)(1,0)54 ( 74,74)(12,12)@xmath54 ( 86,80)(1,0)134 ( 20,100)(1,0)14 ( 34,94)(12,12)@xmath54 ( 46,100)(1,0)174    ( 60,100 ) ( 60,100)(0,-1)20 ( 60,80 )    ( 100,100 ) ( 100,60 ) ( 100,60)(0,1)40    ( 110,80 ) ( 110,60 ) ( 110,60)(0,1)20    ( 150,40 ) ( 160,40 ) ( 170,40 ) ( 150,40)(0,1)60 ( 160,40)(0,1)40 ( 170,40)(0,1)20 ( 150,100 ) ( 160,80 ) ( 170,60 )    states of the form  ( [ ft2 ] ) are produced by function evaluation in a quantum computer .",
    "suppose that @xmath28 is any unitary transformation on @xmath109 qubits and @xmath27 is an eigenvector of @xmath28 with eigenvalue @xmath31 .",
    "the scenario is that we do not explicitly know @xmath28 or @xmath27 or @xmath110 , but instead are given devices that perform controlled-@xmath28 , controlled-@xmath111 , controlled-@xmath112 and so on until we reach controlled-@xmath113 .",
    "also , assume that we are given a single preparation of the state @xmath27 .",
    "from this , our goal is to obtain an @xmath81-bit estimator of @xmath26 .    in a quantum algorithm a quantum state of the form @xmath114",
    "is created by applying the network of fig .",
    "[ fs ] .    then , in the special case where @xmath115 , the state @xmath116 ( and hence @xmath26 ) can be obtained by just applying the inverse of the qft ( which is the network of fig .  [ fig - qft ] in the backwards direction and with the qubits in reverse order ) . if @xmath61 is an @xmath81-bit number this will produce the state @xmath117 exactly ( and hence the exact value @xmath26 ) .",
    "however , @xmath26 is not in general a fraction of a power of two ( and may not even be a rational number ) .",
    "for such a @xmath118 , it turns out that applying the inverse of the qft produces the best @xmath81-bit approximation of @xmath119 with probability at least @xmath120  @xcite .",
    "the probability of obtaining the best with significant probability , it is not necessarily the best estimator of @xmath119 , since , for example , we might be able to to obtain as close an estimate with higher probability .",
    "see @xcite for details . ]",
    "estimate can be made @xmath121 for any @xmath122 , @xmath123 , by creating the state in equation ( [ qftphi ] ) but with @xmath124 qubits and rounding the answer off to the nearest @xmath81 bits @xcite .",
    "( 290,180)(105,380 ) ( 160,380)(20,60)@xmath125 ( 220,380)(20,60)@xmath126 ( 285,380)(20,60)@xmath127 ( 110,425 ) ( 1 , 0 ) 50 ( 180,425 ) ( 1 , 0 ) 40 ( 240,425 ) ( 1 , 0 ) 45 ( 305,425 ) ( 1 , 0 ) 80 ( 110,415 ) ( 1 , 0 ) 50 ( 180,415 ) ( 1 , 0 ) 40 ( 240,415 ) ( 1 , 0 ) 45 ( 305,415 ) ( 1 , 0 ) 80 ( 110,405 ) ( 1 , 0 ) 50 ( 180,405 ) ( 1 , 0 ) 40 ( 240,405 ) ( 1 , 0 ) 45 ( 305,405 ) ( 1 , 0 ) 80 ( 110,395 ) ( 1 , 0 ) 50 ( 180,395 ) ( 1 , 0 ) 40 ( 240,395 ) ( 1 , 0 ) 45 ( 305,395 ) ( 1 , 0 ) 80 ( 105,560 ) ( 1 , 0)280 ( 105,525 ) ( 1 , 0)280 ( 105,485 ) ( 1 , 0)280 ( 170,440 ) ( 0 , 1 ) 45 ( 230,440 ) ( 0 , 1 ) 85 ( 295,440 ) ( 0 , 1)120 ( 80,407)@xmath128 ( 397,407)@xmath128 ( 50,485)@xmath129 ( 50,525)@xmath129 ( 50,560)@xmath129 ( 393,485)@xmath130 ( 393,525)@xmath131 ( 393,560)@xmath132 ( 170,485 ) ( 230,525 ) ( 295,560 )",
    "we will now illustrate the general framework described in the preceding section by showing how some of the most important quantum algorithms can be viewed in this light .",
    "we start with shor s quantum algorithm for efficient factorisation ( for a comprehensive discussion of quantum factoring see  @xcite ) .",
    "shor s quantum factoring of an integer @xmath133 is based on calculating the period of the function @xmath134 for a randomly selected integer @xmath135 between @xmath136 and @xmath133 . for any positive integer @xmath91 , we define @xmath137 to be the remainder ( between @xmath34 and @xmath138 ) when we divide @xmath91 by @xmath133 .",
    "more generally , @xmath137 is the unique positive integer @xmath139 between @xmath34 and @xmath138 such that @xmath133 evenly divides @xmath140 .",
    "for example , @xmath141 , @xmath142 , and @xmath143 . we can test if @xmath135 is relatively prime to @xmath133 using the euclidean algorithm .",
    "if it is not , we can compute the greatest common divisor of @xmath135 and @xmath133 using the extended euclidean algorithm . this will factor @xmath133 into two factors @xmath144 and @xmath145 ( this is called _ splitting _ @xmath133 ) .",
    "we can then test if @xmath144 and @xmath145 are powers of primes , and otherwise proceed to split them if they are composite .",
    "we will require at most @xmath146 splittings before we factor @xmath133 into its prime factors .",
    "these techniques are summarised in @xcite .",
    "it turns out that for increasing powers of @xmath135 , the remainders form a repeating sequence with a period @xmath147 .",
    "we can also call @xmath147 the _ order _ of @xmath135 since @xmath148 .",
    "once @xmath147 is known , factors of @xmath133 are obtained by calculating the greatest common divisor of @xmath133 and @xmath149 .",
    "suppose we want to factor @xmath150 using this method .",
    "let @xmath151 . for increasing @xmath61 the function @xmath152 forms a repeating sequence @xmath153 .",
    "the period is @xmath154 , and @xmath155 .",
    "then we take the greatest common divisor of @xmath156 and @xmath150 , and of @xmath157 and @xmath150 , which gives us @xmath158 and @xmath159 , respectively , the two factors of @xmath150 .",
    "classically , calculating @xmath147 is at least as difficult as trying to factor @xmath133 ; the execution time of the best currently - known algorithms grows exponentially with the number of digits in @xmath133 .",
    "quantum computers can find @xmath147 very efficiently .",
    "consider the unitary transformation @xmath160 that maps @xmath20 to @xmath161 .",
    "such a transformation is realised by simply implementing the reversible classical network for multiplication by @xmath135 modulo @xmath133 using quantum gates .",
    "the transformation @xmath160 , like the element @xmath135 , has order @xmath147 , that is , @xmath162 , the identity operator .",
    "such an operator has eigenvalues of the form @xmath163 for @xmath164 . in order to formulate shor s algorithm in terms of phase estimation",
    "let us apply the construction from the last section taking @xmath165    note that @xmath27 is an eigenvector of @xmath160 with eigenvalue @xmath166 . also , for any @xmath167 , it is possible to implement efficiently a controlled-@xmath168 gate by a sequence of squaring ( since @xmath169 ) .",
    "thus , using the state @xmath27 and the implementation of controlled-@xmath168 gates , we can directly apply the method of the last section to efficiently obtain an estimator of @xmath170 .",
    "the problem with the above method is that we are aware of no straightforward efficient method to prepare state @xmath27 , however , let us notice that almost any state @xmath171 of the form @xmath172 where @xmath173 is from @xmath174 would also do the job . for each @xmath175 ,",
    "the eigenvalue of state @xmath171 is @xmath176 .",
    "we can again use the technique from the last section to efficiently determine @xmath177 and if @xmath173 and @xmath147 are coprime then this yields of @xmath178 satisfies @xmath179 then there is a unique rational of the form @xmath180 with @xmath181 satisfying @xmath182 consequently , @xmath183 , and the continued fractions algorithm will find the fraction for us .",
    "we might be unlucky and get a @xmath173 like @xmath34 , but with even @xmath79 repetitions with random @xmath173 we can find @xmath147 with probability at least @xmath184 @xcite . ] @xmath147 .",
    "now the key observation is that @xmath185 and @xmath7 _ is _ an easy state to prepare .",
    "if we substituted @xmath7 in place of @xmath27 in the last section then effectively we would be estimating one of the @xmath147 , randomly chosen , eigenvalues @xmath176 .",
    "this demonstrates that shor s algorithm , in effect , estimates the eigenvalue corresponding to an eigenstate of the operation @xmath160 that maps @xmath20 to @xmath186 . a classical procedure - the continued fractions algorithm - can be employed to estimate @xmath147 from these results . the value of @xmath147 is then used to factorise the integer .",
    "a number of algorithms can be generalised in terms of group theory as examples of finding hidden subgroups . for any @xmath187 ,",
    "the coset @xmath188 , of the subgroup @xmath189 is defined as @xmath190 .",
    "say we have a function @xmath38 which maps a group @xmath191 to a set @xmath192 , and @xmath38 is constant on each coset of the subgroup @xmath189 , and distinct on each coset , as illustrated in figure [ hidden.sub ] .    in other words , @xmath193 if and only if @xmath194 is an element of @xmath189 .    in deutsch s case , @xmath195 with addition mod @xmath79 as the group operation , and @xmath192 is also @xmath39 .",
    "there are two possible subgroups @xmath189 : @xmath6 , and @xmath191 itself .",
    "we are given a black - box @xmath55 for computing @xmath38 @xmath196 there are two cosets of the subgroup @xmath197 : @xmath197 and @xmath198 .",
    "if the function is defined to be constant and distinct on each coset , it must be balanced . on the other hand , there is only one coset of the other subgroup @xmath191 , the group itself . in this case",
    "the function is constant . with our specially chosen eigenvector @xmath199",
    "the algorithm always outputs @xmath6 if @xmath200 ( @xmath38 is constant ) , and @xmath7 if @xmath201 , ( f is balanced ) .",
    "therefore we can view deutsch s algorithm as distinguishing between the ` hidden subgroups ' .",
    "the hidden subgroup problem also encompasses the problem of finding orders of elements in a group , of which the factoring algorithm is a special case . in quantum factoring",
    ", we wish to find the order @xmath147 of the element @xmath135 in some group represented by @xmath192 . here",
    "@xmath191 is the group of integers @xmath202 and @xmath189 is the additive subgroup @xmath203 of integer multiples of @xmath147 , where @xmath147 is the order of @xmath135 , and @xmath135 is from the multiplicative group of integers modulo @xmath133 .",
    "the function @xmath38 maps @xmath61 to @xmath204 mod @xmath133 .",
    "the output @xmath63 in this case estimates an element which is orthogonal is orthogonal to @xmath205 , we mean that @xmath206 for every @xmath207 . this notion of orthogonality generalises to groups with several generators as well . ] to the subgroup @xmath189 .",
    "the output @xmath208 corresponds to the estimate @xmath209 of the eigenvalue @xmath178 of the operator @xmath160 which maps @xmath20 to @xmath210 ( that is , the operator which maps @xmath211 to @xmath212 ) on the eigenvector @xmath213 . in general , for any function @xmath38 mapping a finitely generated abelian group @xmath191 to a finite set @xmath192 , the quantum network shown in figure [ hidden.network ] will output an estimate of a random element orthogonal to the hidden subgroup @xmath189 . with enough such elements , we can easily determine @xmath189 using linear algebra .    by framing algorithms in terms of hidden subgroups",
    ", it may be possible to think of other problems associated with this structure in groups which we can treat with quantum algorithms .",
    "a number of algorithms have already been cast in this language , including deutsch s problem @xcite , simon s problem @xcite , factoring integers @xcite , finding discrete logarithms @xcite , abelian stabilisers @xcite , self - shift - equivalences @xcite , and others @xcite ( see @xcite and @xcite for details ) .      the first quantum algorithm for searching",
    "was constructed by grover  @xcite .",
    "this has led to a large class of searching and counting algorithms .",
    "we again consider a function @xmath38 , this time mapping us from a set @xmath192 to the set @xmath39 .    we might wish to decide if there is a solution to @xmath214 ( the _ decision _ problem ) , or to actually find a solution to @xmath214 ( the _ searching _ problem ) .",
    "we might be more demanding and want to know how many solutions @xmath61 there are to @xmath214 ( _ counting problem _ ) .",
    "small cases of the searching @xcite and counting @xcite algorithms have been implemented using nmr technology .    in this section",
    "we will show how approximate quantum counting can easily be phrased as an instance of phase estimation , and quantum searching as an instance of inducing a desired relative phase between two eigenvectors .    in the following sections analysing quantum counting and searching",
    ", we will be considering the _ grover iterate _",
    "@xmath215    which was defined in @xcite with @xmath216 as the hadamard transform .",
    "it was later generalised in @xcite , @xcite , @xcite and @xcite with @xmath216 being any transformation such that @xmath217 contains a solution to @xmath214 with non - zero amplitude , i.e.@xmath218 for some @xmath61 with @xmath214 .",
    "the operator @xmath55 maps @xmath219 for all @xmath61 satisfying @xmath214 , and the operator @xmath220 maps @xmath221 leaving the remaining basis states alone .",
    "note that this @xmath55 is slightly different than the standard @xmath55 which maps @xmath222 to @xmath223 , but can be easily obtained from it by setting @xmath224 to @xmath199 .",
    "quantum counting was first discussed in @xcite , where it was observed that the grover iterate is almost periodic with a period dependent on the number of solutions . therefore the techniques of period - finding , as in shor s algorithm , were applied @xcite .",
    "it is also possible to think of the problem as a phase estimation ( see @xcite ) .",
    "we simply observe that the eigenvalues has multiplicity @xmath225 , @xmath136 has multiplicity @xmath226 , and @xmath227 and @xmath228 each have multiplicity @xmath136 .",
    "if @xmath229 , then @xmath136 has multiplicity @xmath133 , ( note that @xmath230 ) , if @xmath231 , then @xmath232 has multiplicity @xmath133 , ( @xmath233 ) .",
    "] of @xmath191 are @xmath136 , @xmath232 , @xmath234 , and @xmath235 where @xmath236 has @xmath167 solutions and @xmath237 let @xmath238 denote the set of solutions to @xmath214 , and @xmath239 denote the set of solutions to @xmath240 . estimating @xmath241 ( or @xmath242 ) will give us information about the number of solutions to @xmath236 .",
    "for example , for small @xmath241 , the number of solutions , @xmath167 , is roughly @xmath243 since @xmath244 for small @xmath241 .",
    "we can use the techniques of the previous sections to estimate this phase @xmath241 provided we know how to create a starting state containing the eigenvectors with eigenvalues @xmath234 and @xmath235 . for non - trivial @xmath167 ,",
    "these eigenvectors are given by @xmath245 where @xmath246    fortunately , the starting state @xmath247 is equal to @xmath248 for some real number @xmath249 , which is not important as far as counting is concerned , since all that is required for the phase estimation procedure is any superposition of these two eigenvectors of @xmath191 .    thus using a controlled-@xmath191 , controlled-@xmath250 ,  , and a controlled-@xmath251 ,",
    "( as done with controlled-@xmath28s in figure  [ fs ] ) and applying a quantum fourier transform , we can get an @xmath81-bit estimate of either @xmath241 or @xmath242 .",
    "this gives us an estimate of @xmath167 , the number of solutions .",
    "note that , unlike in the case of finding orders , there are in general no short - cuts for computing higher powers of @xmath191 .",
    "that is , computing @xmath251 requires @xmath252 repetitions of @xmath191 .",
    "quantum algorithms for approximate counting require roughly only square root of the number of calls a classical algorithm would require .",
    "while estimating the number of solutions to @xmath236 is a special case of quantum phase estimation , the algorithm for searching for these solutions can be viewed as a clever use of the phase kick - back technique to induce a desired relative phase between two eigenvectors of @xmath191 .",
    "the state @xmath253 is a superposition of solutions to @xmath214 , so it is itself a solution which it is possible for us to construct .",
    "we note that @xmath254 and our starting state for quantum searching is @xmath255 each iteration of @xmath191 kicks back a phase of @xmath234 in front of @xmath256 and @xmath235 in front of @xmath257 .",
    "so @xmath173 iterations of @xmath191 produces the state @xmath258 since we seek @xmath259 we want to choose the number of iterations @xmath173 so that @xmath260 is as close to an integer as possible .",
    "when @xmath167 is small , this means selecting the number of iterations close to @xmath261    note that any classical algorithm would require @xmath262 evaluations of @xmath38 before finding a solution to @xmath236 with high probability .",
    "multi - particle interferometers can be viewed as quantum computers and any quantum algorithm follows the typical structure of a multi - particle interferometry sequence of operations .",
    "this approach seems to provide an additional insight into the nature of quantum computation and , we believe , will help to unify all quantum algorithms and relate them to different instances of quantum phase estimation .",
    "this work was supported in part by the european tmr research network erp-4061pl95 - 1412 , hewlett - packard and elsag - bailey , the royal society , cesg and the rhodes trust .",
    "is partially supported by canada s nserc .",
    "r. feynman : simulating physics with computers .",
    "* 21 * , 1982 , pp .",
    "467 - 488 .",
    "r. cleve , a. ekert , c. macchiavello , and m. mosca : quantum algorithms revisited , proc .",
    "a * 454 * , 1998 , pp . 339354 .",
    "see also lanl preprint / quant - ph/9708016 .",
    "d. deutsch : quantum - theory , the church - turing principle and the universal quantum computer .",
    "a * 400*,1985 , pp .",
    "j. jones and m. mosca : implementation of a quantum algorithm on a nuclear - magnetic resonance quantum computer .",
    "phys . * 109 * , pp .",
    "1648 - 1653 .",
    "see also lanl preprint quant - ph/9801027 .",
    "i. chuang , l. vandersypen , x. zhou , d. leung and s. lloyd : experimental realisation of a quantum algorithm .",
    "nature , * 393 * , 1998 , pp . 143 - 146 . see also lanl preprint quant - ph/9801037 .",
    "d. coppersmith : an approximate fourier transform useful in quantum factoring , ibm research report no .",
    "rc19642 , 1994 .",
    "a. barenco , a. ekert , k. suominen and p. trma : approximate quantum fourier - transform and decoherence .",
    "a * 54 * , 1996 , pp .",
    "139 - 146 .",
    "see also lanl preprint quant - ph/9601018 .",
    "w. van dam , g. dariano , a. ekert , c. macchiavello and m. mosca : estimating phase rotations on a quantum computer , preprint .",
    "p.shor : algorithms for quantum computation : discrete logarithms and factoring .",
    "35th annual symposium on foundations of computer science , 1994 , pp .",
    "see also lanl preprint quant - ph/9508027 .",
    "a. ekert and r. jozsa : quantum computation and shor s factoring algorithm , rev .",
    "* 68 * , 733 , 1996 , pp .",
    "733 - 753 .",
    "a. menezes , p. van oorschot , and s. vanstone : handbook of applied cryptography , crc press , london , 1996 .",
    "d. simon : on the power of quantum computation .",
    "35th annual symposium on foundations of computer science , 1994 , pp .",
    "116 - 123 .",
    "a. kitaev : quantum measurements and the abelian stabiliser problem .",
    "lanl preprint quant - ph/9511026 , 1995 .",
    "d. grigoriev , : testing the shift - equivalence of polynomials by deterministic , probabilistic and quantum machines .",
    "theoretical computer science , * 180 * , 1997 , pp .",
    "217 - 228 .",
    "d. boneh , and r. lipton : quantum cryptanalysis of hidden linear functions ( extended abstract ) .",
    "lecture notes on computer science , * 963 * , 1995 , pp.424 - 437 . m. mosca and a. ekert : hidden subgroups and estimation of eigenvalues on a quantum computer . to appear in the proc . of the 1st international nasa conference on quantum computing and quantum information processing , lecture notes on computer science , 1998 .",
    "hyer : conjugated operators in quantum algorithms .",
    "preprint , 1997 .",
    "l. grover : a fast quantum mechanical algorithm for database search , proc .",
    "28 annual acm symposium on the theory of computing , acm press new york , 1996 , pp .",
    "212 - 219 . journal version , `` quantum mechanics helps in searching for a needle in a haystack '' , appeared in _ physical review letters _ , * 79 * ( 1997 ) 325 - 328 .",
    "see also lanl preprint quant - ph/9706033 .",
    "n. gershenfeld , i. chuang and m. kubinec : experimental implementation of fast quantum searching .",
    "* 80 * , 1998 , pp .",
    "3408 - 3411 .",
    "j. jones , r. hansen and m. mosca : implementation of a quantum search algorithm on a quantum computer .",
    "nature , * 393 * , 1998 , pp . 344 - 346 . see also lanl preprint quant - ph/9805069 .",
    "j. jones and m. mosca : approximate quantum computing on an nmr ensemble quantum computer . submitted .",
    "see lanl preprint quant - ph / quant - ph/9808056 . g. brassard and p. hyer : an exact quantum polynomial - time algorithm for simon s problem .",
    "proceedings of the fifth israeli symposium on theory of computing and systems , ieee computer society press , 1997 , pp.12 - 23 . see also lanl preprint quant - ph/9704027 .",
    "l. grover : a framework for fast quantum mechanical algorithms .",
    "30th annual acm symposium on the theory of computing , 1998 .",
    "see also lanl preprint quant - ph/9711043 .",
    "g. brassard , p. hyer and a. tapp : quantum counting , proc .",
    "25th international colloquium on automata , languages and programming , lecture notes on computer science , * 1443 * , pp . 820 - 831 , 1998 . see also lanl preprint quant - ph/9805082 .",
    "m. boyer , g. brassard , p. hyer and a. tapp : tight bounds on quantum searching , proceedings of the fourth workshop on physics and computation , 1996 , pp .",
    "forschritte der physik , special issue on quantum computing and quantum cryptography , * 4 * , pp .",
    "493 - 505 , 1998 .",
    "see also lanl preprint quant - ph/9605034 .",
    "m. mosca : quantum searching and counting by eigenvector analysis .",
    "proceedings of randomized algorithms , satellite workshop of mfcs 98 .",
    "available at www.eccc.uni - trier.de / eccc - local / eccc - lecturenotes / randalg/."
  ],
  "abstract_text": [
    "<S> quantum computers use the quantum interference of different computational paths to enhance correct outcomes and suppress erroneous outcomes of computations . in effect , they follow the same logical paradigm as ( multi - particle ) interferometers . </S>",
    "<S> we show how most known quantum algorithms , including quantum algorithms for factorising and counting , may be cast in this manner . </S>",
    "<S> quantum searching is described as inducing a desired relative phase between two eigenvectors to yield constructive interference on the sought elements and destructive interference on the remaining terms .    * on quantum algorithms *    richard cleve , artur ekert , leah henderson , chiara macchiavello and michele mosca    _ centre for quantum computation </S>",
    "<S> _    _ clarendon laboratory , university of oxford , oxford ox1 3pu , u.k . _    _ department of computer science _    </S>",
    "<S> _ university of calgary , calgary , alberta , canada t2n 1n4 _    _ theoretical quantum optics group _    _ dipartimento di fisica `` a. volta '' and i.n.f.m . </S>",
    "<S> - unit di pavia _    _ via bassi 6 , i-27100 pavia , italy _ </S>"
  ]
}