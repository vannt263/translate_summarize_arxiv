{
  "article_text": [
    "originally introduced by alon and others @xcite this problems explores permutation routing on graphs where routing is achieve through a series of matchings called steps .",
    "let @xmath0 be an undirected labeled graph with vertex labeled @xmath10 having a pebble labeled @xmath11 initially .",
    "a permutation @xmath2 gives the destinations of each pebble .",
    "the task is to route each pebble to their destination via a sequence of matchings . given a matching we swap the pebbles on pairs of matched vertices .",
    "the _ routing time _",
    "@xmath3 is defined as the minimum number of steps necessary to route all the pebbles for a given permutation . for given graph @xmath0 , the maximum routing time over all permutations",
    "is called the routing number @xmath12 of @xmath0 . since their inception ,",
    "permutation routing via matching have generated continual interest .",
    "however , prevailing literature focuses on determining the routing numbers of special graphs .",
    "we shall give a very brief survey about them in the next section .",
    "in this paper we shall focus on the computational aspect of the problem .",
    "in particular we show that for a general graph determining whether @xmath3 is @xmath6 is @xmath13 complete for @xmath7 .",
    "however , we show that it is possible to determine if @xmath14 in polynomial time by determining whether a certain graph has a perfect matching .",
    "it remains open whether computing @xmath3 is constant factor @xmath15-@xmath16 .",
    "the routing via matching model has several variants and generalizations @xcite .",
    "for example a popular network routing model is the direct path routing model . in this model",
    "a packet move towards its destination directly and no two packets uses the same links ( edges ) . in one version of the problem a path",
    "may be specified for each vertex .",
    "costas and others @xcite show that this problem and some variants of it to be @xmath13 complete . in this paper",
    "we only consider the classical model as described in the previous section . in the introductory paper alon and others",
    "@xcite show that for any connected graph @xmath0 , @xmath17 .",
    "this was shown by considering a spanning tree of @xmath0 and using only the edges of the spanner to route the permutation in @xmath0 .",
    "note that one can always route a permutation on a tree , by iteratively moving a pebble that belong to some leaf node and ignoring the node afterwards .",
    "the routing scheme is recursive and uses a well known property of trees : a tree has a vertex whose removal results in a forest of trees with size at most @xmath18 . later in @xcite zhang",
    "improve this upper bound @xmath19 .",
    "this was done using a new decomposition called the caterpillar decomposition .",
    "this bound is essentially tight as it takes @xmath20 steps to route a permutation on a star @xmath21 .",
    "there are few known results for routing numbers of graphs besides trees . we know that for the complete graph and the complete bipartite graph the routing number is 2 and 4 respectively@xcite .",
    "later li and others @xcite extends these results to show @xmath22 ( @xmath23 ) . for the @xmath24-cube @xmath25",
    "we know that @xmath26",
    ". the lower bound is quite straightforward .",
    "the upper bound was discovered using the results for determinig the routing number of the cartesian product of two graphs @xcite .",
    "if @xmath27 be the cartesian product of @xmath28 and @xmath29 then : @xmath30 since @xmath31 the result follow was determined to be 4 via a computer search@xcite ] .    here",
    "we take a detour to discuss a related problem of determining the _ acquaintance time _ of a connected graph .",
    "given a connected graph @xmath0 whose vertices contains pebbles , its acquaintance time @xmath32 is defined to be the minimum number of matching necessary for each pebble to be acquainted with each other .",
    "we say two pebbles are acquainted if they happen to be on adjacent vertices .",
    "hence the acquaintance time of a complete graph is 0 .",
    "this notion of acquaintance was introduce by benjamini and others in a recent paper@xcite .",
    "they show that routing number and acquaintance time of a graph are distinct parameters by giving a separation result for the complete bipartite graph .",
    "they show @xmath33 , which stands in contrast to the routing number of 4 for @xmath34 .",
    "we believe that further investigation is necessary to study graphs which have large separation between the two parameters .      in this section",
    "we present a polynomial time deterministic algorithm to determine given a graph if a permutation can be routed in less than two steps . determining whether @xmath35 is trivial hence we consider only the case when @xmath36 . the basic idea centers around whether we can route the individual cycles of the permutation within 2 steps .",
    "let @xmath37 be a permutation with @xmath38 cycles and @xmath39 .",
    "we say a cycle @xmath40 is _ individually routable _ if it can be routed using only edges of the induced subgraph @xmath41 $ ] . a pair of cycles @xmath42 are _ mutually routable _ if all the pebbles withing them can be routed using only the edges between the two subsets @xmath43 and @xmath44 .",
    "the next lemma shows that we can not route a pair of cycles using edges between the components as well as within the components .",
    "if a pair of cycles are mutually routable in 2-steps then they must be of same length .",
    "as the first matched pair , the rest of the matching is forced for both the stages .",
    "the crossed vertices in the figure will not be routed.,width=151 ]    we prove this assuming @xmath0 is a complete graph .",
    "since for any other case the induced subgraph @xmath45 $ ] would have fewer of edges , hence this is a stronger claim .",
    "let @xmath46 .",
    "consider the cycle @xmath47 . at the first step we have only three choices for matching some vertex with @xmath48 .",
    "case 1 : :    _ @xmath48 is not matched_. in this case , in the    next(last ) round @xmath48 must be matched with    @xmath49 .",
    "this implies @xmath50 must    be at @xmath49 after the first round .",
    "this would    force @xmath51 to be matched with    @xmath52 in the first round , otherwise    @xmath51 will not be able to reach    @xmath50 in two rounds .",
    "proceeding in this way we see    that the matching for all the vertices are fixed once we decide not to    match @xmath48 .",
    "this implies @xmath43 and    @xmath44 can not be routed mutually if we choose to omit any    vertex from the matching in @xmath43 in the first round .",
    "case 2 : :    _ @xmath48 is matched with @xmath53_. in this    case also we can show that the entire matching is forced .",
    "case 3 : :    _ @xmath48 is matched with @xmath54_. from    figure 1 we see that unless @xmath55 , the pair    @xmath43 and @xmath44 are not mutually routable in 2    steps .",
    "three or more cycles are not mutually routable in 2 steps .    naively verifying whether a cycle @xmath56 are individually or a pair @xmath57 is mutually routable takes @xmath58 and @xmath59 respectively .",
    "however , we can employ a more sophisticated approach that takes time proportional to the number of edges in the induced subgraphs corresponding to the cycles .",
    "first consider the case of verifying whether a cycle @xmath60 is individually routable .",
    "if @xmath41 $ ] is clique then there are @xmath61 different routing schemes , one for each choices of how we match the @xmath62 vertex in the first round .",
    "for example , if we match @xmath63 ( @xmath64 ) in the first then the routing scheme is the following sequence @xmath65 of matchings ( slightly modified from @xcite ) :    @xmath66    where @xmath67 .",
    "note for every @xmath10 , @xmath68 . also , it follows from lemma 1 that no edge can be in two different routings .",
    "let us label these @xmath69 different routing schemes from 1 to @xmath69 .",
    "next we scan through the edges of @xmath41 $ ] maintaining a array of counters of size @xmath69 whose @xmath62 element counts the number edges we have seen so far that belongs to the @xmath62 routing scheme .",
    "after iterating over all the edges if some counter @xmath10 has a value @xmath69 or @xmath70 depending on whether @xmath69 is even or odd , respectively , then we know @xmath40 can be routed using the @xmath62 routing scheme otherwise @xmath40 is not individually routable .",
    "clearly this takes time linear in the number of edges in @xmath41 $ ] .",
    "so the total time to verify all cycles is @xmath71 .",
    "we can extend this argument to show that we can also verify all pairs of cycles for mutual routability in @xmath71 steps also .",
    "the main observation is that the pairs of cycles partition the routable edges into disjoints sets .",
    "next define a graph @xmath72 whose vertices are the cycles ( @xmath73 ) and two cycle are adjacent iff they are mutually routable in 2-steps . additionally , @xmath74 has loops corresponding to vertices which are individually routable cycles .",
    "we can modify any existing maximum matching algorithm to check whether @xmath74 has a perfect matching ( accounting for the self loops ) with only a linear overhead .",
    "we omit the details .",
    "then the next lemma follows immediately :    @xmath75 iff there is a perfect matching in @xmath74 .",
    "it is apparent from the previous discussion that @xmath74 can be constructed in @xmath71 time .",
    "since we have at most @xmath38 cycles , @xmath74 will have t most @xmath76 vertices and at most @xmath77 edges .",
    "hence we can determine a maximum matching in @xmath74 in @xmath78 time @xcite .",
    "this gives a total runtime of @xmath79 for our algorithm which finds a 2-step routing scheme of a connected graph if one exists .",
    "@xmath80 iff @xmath0 is a clique .",
    "@xmath81 : :    a two step routing scheme for @xmath82 was given in @xcite .",
    "@xmath83 : :    if @xmath0 is not a clique then there is at least a pair of    non - adjacent vertices .",
    "let @xmath63 be a non - edge .",
    "then by    lemma 1 the permutation @xmath84 can not be    routed in two steps .      for @xmath7 computing @xmath3",
    "is @xmath86-complete .",
    "need to swap their pebbles .",
    "the unmarked circles have pebbles that is fixed.,width=377 ]    proving it is in @xmath86 is trivial , we can use a set of matchings as a witness . for the np hardness proof",
    "we first define three _ atomic _ gadgets ( see figure 6 ) which will be use to construct the variable and clause gadgets .",
    "vertices whose pebbles are fixed ( 1 cycles ) are represented as circles .",
    "otherwise they are represented as black discs .",
    "so in the first three sub - figures ( ( a)-(c ) ) the input permutation is @xmath87 . in all our construction",
    "we shall use permutation consisting of only 1 or 2 cycles .",
    "each cycle labeled @xmath10 will be represented as a pair @xmath88 .",
    "if the correspondence between a pair is clear from the figure then we shall omit the subscript .",
    "it is an easy observation that @xmath89 . in the case of the hexagon",
    "@xmath90 we see that in order to route the pebbles within 3 steps we have to use the left or the right path , but we can not use both paths simultaneously ( i.e. , @xmath91 goes through left but @xmath92 goes through the right ) .",
    "figure 6(e ) shows a chain of squares connecting @xmath93 to @xmath94 .",
    "if vertex @xmath93 is used during routing any pebble other than the two pebbles to its right then the chain construction forces @xmath94 to be used in routing the two pebbles to its left .",
    "this chain is called a _",
    "f - chain_. in our construction we use chains of constant length to simplify the presentation of our construction .    .",
    "( a ) is a special case for @xmath95 , ( b ) is the general case.,width=453 ]      say we have clause @xmath96 . in figure 6(d ) we show how to create a clause gadget .",
    "this is referred to as the _ clause graph _",
    "@xmath97 of the clause @xmath40 .",
    "the graph in figure 6(d ) can route @xmath98 in three steps by using one of the three paths between @xmath99 and @xmath100 .",
    "say , @xmath99 is routed to @xmath100 via @xmath101 .",
    "then it must be the case that vertex @xmath101 is not used to route any other pebbles .",
    "we say the vertex @xmath101 is _ owned _ by the clause .",
    "otherwise , it would be not possible to route @xmath99 to @xmath100 in three steps via @xmath101 .",
    "we can interpret this as follows .",
    "a clause has a satisfying assignment iff its clause graph has a owned vertex .",
    "construction of the variable gadgets are little more involved than the clause gadgets . for some @xmath102 ,",
    "let the variable @xmath103 is in @xmath104 clauses .",
    "the variable gadget corresponding to @xmath103 is shown in figure 7(b ) .",
    "vertically aligned hexagons are all in one level .",
    "number of levels is @xmath105 .",
    "the left most hexagon @xmath106 and the rightmost hexagon @xmath107 share a common edge as indicate in the figure making it circularly wrapped .",
    "the permutation we will route on @xmath108 ( the variable graph of @xmath103 ) is @xmath109 . for each variable we shall have a separate graph and a corresponding permutation on its vertices . in the graph @xmath108",
    "there are only two possible ways to route @xmath110 in two steps .",
    "1 ) if we route @xmath111 using the right path in @xmath106 this forces @xmath112 and @xmath113 to be routed using the right paths in their respective hexagons @xmath114 and @xmath115 . continuing in this way",
    "we see that @xmath116 must be routed using the right path of @xmath107 . in during this routing the vertices",
    "@xmath117 are not used and hence are free and can be owned by some clause .",
    "2 ) if we route @xmath111 using the left path of @xmath106 , the opposite happens and @xmath118 will be the free vertices in this case .",
    "this forces variable assignment .",
    "the former and latter case corresponds to true ( right ) and false ( left ) assignment of @xmath103 respectively .      for each clause @xmath40 , if the literal @xmath119 then we connect @xmath120 ( for some @xmath10 ) to the vertex labeled @xmath121 via an _ f - chain_. if @xmath122 then we connect it with @xmath123 via an _ f - chain_. this is our final graph @xmath124 corresponding to an instance of a 3-@xmath125 formula .",
    "the input permutation is @xmath126 , which is the concatenation of all the individual permutation on the variable , clause graphs and @xmath127-_chains_. this completes our construction .",
    "we need to show , @xmath128 iff @xmath129 is satisfiable .",
    "suppose @xmath129 is satisfiable .",
    "then for each variable @xmath103 , if the literal @xmath101 is true then we use left routing in @xmath108 , otherwise we use right routing .",
    "this ensures in each clause graph there will be at least one owned vertex .",
    "now suppose @xmath130 .",
    "then each clause graph has at least one owned vertex .",
    "if @xmath101 is a free vertex in some clause graph then @xmath131 is not a free vertex in any of the other clause graphs , otherwise variable graph @xmath108 will not be able rout its own permutation in 3 steps .",
    "hence the set of free vertices will be a satisfying assignment for @xmath129 .",
    "it is an easy observation that the number of vertices in @xmath132 is polynomially bounded in @xmath133 ; the number of variables and clauses in @xmath129 respectively and that @xmath132 can be explicitly constructed in polynomial time .",
    "in this section we introduce _ sorting numbers _ for graphs in the context of sorting networks .",
    "majority of existing literature on sorting networks focus on optimizing the depth ( number of concurrent stages ) and size ( total number of comparators used ) of such networks . here , we study a slightly different problem .",
    "let the _ sorted order _ of the vertices of a labeled graph @xmath0 be the permutation @xmath2 that assigns a rank @xmath134 to the vertex labeled @xmath10 .",
    "given @xmath0 the task is to design an optimal sorting network ( in terms of depth ) on @xmath0 .",
    "before we make this notion formal we need to define a sorting network .      1 .",
    "@xmath90 is a connected labeled graph having @xmath24 vertices and a sorted ordering @xmath2 on its vertices .",
    "initially each vertices of @xmath90 contains a pebble having some value , that is they act as input terminals of the network .",
    "the ordered set @xmath136 consists of directed matchings in @xmath90 . in a directed matching some edges in the matching have been assigned a direction .",
    "sorting occurs in stages . at stage",
    "@xmath10 we use the matching @xmath137 to exchange pebbles between matched vertices according to their orientation . for an edge @xmath138 ,",
    "when swapped the smaller of the two pebble goes to @xmath93 . if an edge is undirected then both pebbles swap regardless of their order .",
    "after @xmath139 stages the vertex labeled @xmath10 contains the pebble whose rank is @xmath134 in the sorted order of the pebbles .",
    "@xmath139 is called the depth of the network .",
    "additionally , this must hold for all ( @xmath140 ) initial arrangement of the pebbles .",
    "each edge in @xmath90 is in some matching , that is @xmath90 is minimal .",
    "we say @xmath135 is a sorting network on @xmath0 if @xmath90 is a spanning subgraph of @xmath0 .",
    "let @xmath141 be the set of all such sorting networks on @xmath0 over all possible spanning subgraphs and sorted orderings ( non - isomorphic ) .    sorting number @xmath142 of a graph @xmath0",
    "is defined to be minimum depth of any sorting network on @xmath0 .",
    "additionally , @xmath143 is the sorting number of @xmath0 over all possible sorting network on @xmath0 with a fixed sorted order @xmath2 .",
    "the above lemma implies that if we construct a sorting network for some arbitrary sorted order on the vertices then we suffer a penalty of @xmath145 on the depth of our network as compared to the optimal one .",
    "let @xmath146 be an optimal sorting network on @xmath0 . using this network we can create another sorting network @xmath147 whose depth is @xmath145 more than the optimal one .",
    "this can be done in two rounds .",
    "first we use the sorting network @xmath146 to determine after @xmath142 stages the ranks of each pebble in the sorted order .",
    "after this step we will know that the pebble at vertex @xmath10 has a rank @xmath148 .",
    "but @xmath147 sends a pebble with rank @xmath148 to the vertex labeled @xmath149 .",
    "hence we can route the fixed permutation @xmath150 on @xmath0 during the second round to arrive at the desired sorted order @xmath2 .",
    "since we can route a permutation on any graph in @xmath145 steps the lemma follows .",
    "note that if @xmath0 is not connected than @xmath151 .",
    "otherwise , there always exists a spanning tree @xmath152 of @xmath0 and @xmath153 .",
    "the main result of this section will be to obtain both a lower and an upper bounds for @xmath154 .",
    "we start by restating some previous results for sorting networks with restricted topology under this new framework .",
    "the path graph @xmath155 is one of the simplest case .",
    "we know that @xmath156 .",
    "this follows from the fact that the classical odd - even transposition sort takes @xmath157 matching steps and that is optimal .",
    "next we discuss some known bounds for the sorting numbers of some common graphs starting with the complete graph .",
    "these results are summarized in table 1 . for the the complete graph @xmath82 .",
    "ajtai - komlos - szemerdi ( aks ) sorting network directly gives an upper bound of @xmath158 for the sorting number of @xmath82 . in this case",
    "also the bound is tight . for the @xmath24-cube @xmath25 we can use the batcher s bitonic sorting network , which has a depth of @xmath159 @xcite .",
    "this was later improved to @xmath160 by plaxton and suel@xcite .",
    "we also have a lower bound of @xmath161 due to leighton and plaxton . for the square mesh @xmath162 it is known that @xmath163 , which is tight with respect to the constant factor of the largest term .",
    "this follows from results of schnorr & shamir @xcite , where they introduced the @xmath164-sorter for the square mesh",
    ".          given two graphs @xmath166 and @xmath167 their cartesian product is the graph @xmath168 such that @xmath169 and @xmath170 .",
    "the next theorem gives the sorting number of a product graph in terms of sorting numbers of its components .",
    "the network that sorts @xmath172 is constructed via networks for @xmath28 and @xmath29 as follows .",
    "let , @xmath173 and @xmath174 be the vertex set of the graphs @xmath28 and @xmath29 respectively .",
    "the labeling of the vertices are based on the output ranks of the sorted order .",
    "the graph @xmath0 with vertex set @xmath175 can be visualized in a grid of size @xmath176 .",
    "each row consists of a copy of @xmath29 and each column consists of a copy of @xmath28 .",
    "see figure 2 for an illustration .    the sorting network for @xmath0 consists of the following matching scheme .",
    "let @xmath177 and @xmath178 be the respective matching schemes for @xmath28 and @xmath29 . if @xmath179 is a pair of matched vertices in some matching , we assign a direction to the edge @xmath180 according to the comparator attached to the edge @xmath180 .",
    "if smaller of the two pebbles is put in @xmath93 after the exchange then we say the edge is directed from @xmath93 to @xmath94 .",
    "then @xmath93 is called the lower vertex and @xmath94 is called the upper vertex .",
    "a directed matching thus partitions the vertex set into three parts : upper , lower and non - participating vertices .",
    "let , @xmath181 and @xmath182 .",
    "we start by sorting each row of @xmath0 , which have copies of @xmath29 using the sorting network @xmath178 .",
    "however , each row corresponds to a vertex in @xmath28 .",
    "consider the set of upper , lower and non - participating vertices of @xmath28 for the matching @xmath183 .",
    "these vertices partition the rows of @xmath0 into three parts . for each row in @xmath0",
    "if it is associated with a lower vertex in @xmath28 then we call it a lower row .",
    "similarly we define upper rows and non - participating rows . for each lower row then we sort it normally using the sorting network of @xmath29 . if the row is an upper row we sort it using the sorting network of @xmath29 where the direction of the comparators have been reversed .",
    "we leave the non - participating rows unmatched .",
    "next we use the matching @xmath183 to do a compare exchange on the columns of @xmath0 .",
    "these two stages ( sorting on rows ( copies of @xmath29 ) and the application of a matching from @xmath177 ) together constitute a single _ full _ stage in @xmath0 .",
    "the set of matchings without the final compare - exchange on columns constitute a half - stage .",
    "hence a full stage consists of @xmath184 matchings on @xmath0 .",
    "continuing , we invoke a full stage corresponding each successive matching in @xmath177 , hence for @xmath185 full stages . at the end",
    "we need to sort every row of @xmath0 in ascending order .",
    "this last stage is a half stage and adds an additional @xmath186 matchings to the sorting network .",
    "the final sorted order of vertices are @xmath187 .",
    "the correctness of the above procedure can be proven using the 0 - 1 principle .",
    "each half stage in @xmath0 consists of sorting in ascending order or descending order .",
    "this is followed up by a compare exchange between the matched rows .",
    "consider a pair of matched rows @xmath188 and @xmath189 corresponding to vertices @xmath190 and @xmath191 in @xmath28 .",
    "assume @xmath10 precedes @xmath192 in the sorted order in @xmath28 ( @xmath64 ) . since @xmath193 is sorted in ascending order and @xmath194 in descending order , a compare - exchange between the pairs @xmath195 is a merge operation for 0 - 1 input .",
    "hence , after the compare exchange we have @xmath196 for every pair of vertices , where @xmath197 and @xmath198 .",
    "it is known that @xcite if we replace every comparator of a sorting network by a merging subnetwork then the new network correctly sorts every input sequence whose elements are multi - sets instead of single elements . in our case @xmath193",
    "s corresponds to these multi - sets and the sorting operation ( on copies of @xmath29 ) followed by exchange correspond to a single merging operation in the network @xmath28 .",
    "recall the analogous result for the routing number of the product graph @xcite .",
    "we have @xmath199 .",
    "the corresponding bound for the sorting number is much worse . since",
    "a @xmath24-cube @xmath25 can be written as the cartesian product of @xmath200 , from theorem 1 we see that @xmath201 , which is @xmath202 where @xmath203 is the number of vertices in a @xmath24-cube . unfortunately , although non - trivial , the above bound is weak for @xmath24-cubes . however , we believe that for @xmath204 ( product of two stars ) the bound of the theorem may be tight .      here",
    "we informally discuss the lower bound of @xmath154 .",
    "this occurs when the tree is a star . for a star @xmath21",
    "there are only @xmath24 non - isomorphic sorted orders . without loss of generality",
    "we assume in the ordering the center gets the pebble ranked @xmath24 .",
    "let @xmath205 be a sequence of matchings , which are in this case are just singleton edges .",
    "the important observation is this : once a pebble is placed in its final sorted position , it must stay there for the remainder of the matchings for @xmath154 to be minimum .",
    "given @xmath136 , consider the input permutation of pebbles ( given by an adversary ) which makes the first pebble to be put into its correct place be first matched at least after @xmath206 steps .",
    "similarly , the second pebble to be matched at least after an additional @xmath207 steps and so on .",
    "this would ensure that it takes at least @xmath208 steps to obtain the sorted order .",
    "note , if the sorted order had put some other pebble ( @xmath10 ) than the pebble ranked @xmath24 at the center , then it takes at most 1 additional step to put @xmath24 at the center .          in this section",
    "we present an oblivious sorting algorithm for trees .",
    "the algorithm @xmath209 is a natural generalization of the classical odd - even transposition sort algorithm .",
    "first recall the following fact about trees : for any tree @xmath152 with @xmath24 vertices there exists a vertex @xmath210 whose removal produces connected components of size @xmath211 .",
    "we can take this special vertex @xmath210 as the root , which we assume has @xmath212 children , see figure 3 .",
    "let the subtree @xmath213 have @xmath214 nodes and any non - leaf node has at most @xmath215 children .",
    "further , assume the subtrees are arranged in descending order according to their size from left to right ( @xmath216 ) .",
    "the sorted order @xmath217 is defined recursively as follows .",
    "we call this the _ ulti - root re - order _ ( mp ) labeling .",
    "note that the root @xmath218 of @xmath213 may not be the the @xmath190 in figure 3 .",
    "given a tree this ordering can be easily precomputed and it is fixed afterwards .",
    "furthermore once we have our sorting network , using lemma 8 we can easily create another sorting network with a more natural ordering as our sorted order . ] using an additional @xmath145 steps .",
    "the @xmath219 has two main phases : 1 ) in phase-1 we use the subtrees as buckets to partition the pebbles such that @xmath220 gets the first @xmath221 smallest pebbles , @xmath222 the next @xmath223 smallest pebbles and so on . 2 ) next in phase-2 we call @xmath224 recursively for all the subtrees @xmath225 . sorting on these subtrees",
    "happens in parallel .",
    "let as assume the number of matchings needed to partition the pebbles during the first phase is @xmath226 , if the root @xmath210 has degree @xmath212 and the subtree @xmath213 has maximum arity of @xmath215 .",
    "then the total number of stages in @xmath209 is given by the following recurrence :      since any routing between the subtrees must use the root @xmath210 , we route the pebbles between a pair of subtrees at a time .",
    "the procedure @xmath228 takes a pair of consecutive subtrees and sorts the pebbles in such a away that after completion each pebble in @xmath229 is smaller than pebbles in @xmath230 .",
    "we first describe in detail @xmath231 .",
    "figure 4 shows the two subtrees @xmath213 and @xmath232 connected via @xmath210 .",
    "let the height of @xmath213 be @xmath233 and the height of @xmath232 be @xmath234 .",
    "total number of levels in @xmath235 is @xmath236 .",
    "vertices are grouped according to the level they are in starting from the leftmost vertices ( which are at depth @xmath233 in @xmath213 ) which are assigned to group 1 .",
    "based on its group number a vertex is either an odd or an even vertex .",
    "each stage consists of either matchings between odd - even vertices or even - odd vertices . for each non - leaf node",
    "we pick an arbitrary but fixed ordering of its children so that at any odd or even stage they will be chosen sequentially in that order .",
    "this also makes the above scheme oblivious .",
    "all the matched edges are directed from left to right . for each pair of matched vertices we exchange their pebbles if the vertex to the left has a larger pebble to that of the right .",
    "we call an odd followed by an even stage together a cycle",
    ". we shall count the number of cycles to simplify our analysis .",
    "the procedure @xmath231 is oblivious , thus by the 0 - 1 principle @xcite we only need to show it works correctly when the input is restricted to 0 and 1 .",
    "@xmath231 is broken up into two rounds .",
    "in the first round , which happens in parallel on the subtrees @xmath241 and @xmath232 , we move the larger pebbles towards @xmath210 in @xmath241 and we move the smaller pebbles towards @xmath191 in @xmath232 . after completion of this round",
    "every path from @xmath210 to a leaf in @xmath241 is decreasing and for @xmath232 every path from @xmath191 to a leaf is increasing .",
    "to prove this claim consider a path @xmath242 in @xmath152 from @xmath210 to some leaf node @xmath243 of @xmath240 .",
    "let @xmath244 where @xmath245 .",
    "let @xmath246 be the arities of the nodes on this path from @xmath210 to the leaf .",
    "we prove that for this path at most @xmath247 cycles suffice to sort the pebbles on it ( that is all the 1 s that were initially in the path are closer to the root than the 0 s ) . here",
    "we make two important observations that simplifies our analysis : 1 ) no new 0 s are introduced to this path during any stage of the routing .",
    "2 ) if a new 1 enters this path from a child not on this path replacing some 0 , we can essentially ignore it , as this does not hurt the relative ordering of the existing 0 s and 1 s in the path .",
    "so we assume no new 1 is introduced in the path during the routing .",
    "this two assumptions allows us to treat the path @xmath242 in isolation . since @xmath242 was chosen arbitrarily proving the property holds for @xmath242 would suffice .",
    "now , consider the special case when @xmath248 .",
    "then the odd - even matchings in @xmath242 would follow the same pattern as the odd - even transposition sorting network , which takes @xmath249 cycles .",
    "the proof for this special case can be extended relatively easily with some additional bookkeeping .",
    "let as assume that we have @xmath38 1 s initially in @xmath242 .",
    "it is apparent that the worst case happens when all the 1 s are initially at the other end of the root . assuming the root to be the rightmost vertex in @xmath242 .",
    "let the 1 initially at vertex @xmath250 be labeled as @xmath251 .",
    "the timing diagram in figure 5 shows the progression of each 1 towards the root .",
    "the rightmost 1 is at vertex @xmath252 initially . when counting the number of cycles we make the following conservative estimate .",
    "it takes @xmath253 at most @xmath254 cycles to move to @xmath255 .",
    "similarly it takes @xmath256 cycles for @xmath257 to move to @xmath252 . since it can take @xmath253 at most @xmath254 to vacate @xmath252 and at most @xmath258 additional cycles for the edge @xmath259 to be in a matching afterwards . in figure 5 , the crosses represent a jump from child to its parent by a 1 .",
    "the thick lines represent the cycles when the child with a 1 is waiting to be matched with its parent ( which has a 0 ) so that it can move up .",
    "the dotted line between two thick line represents the time spent by the child idling whose parent still has a 1 .",
    "it is clear from the figure 5 that the maximum bottleneck occurs when @xmath260 .",
    "otherwise , if we have @xmath261 for some @xmath10 then the child at @xmath262 have to wait @xmath263 to move to @xmath264 . since , @xmath265 by the time this 1 reaches",
    "@xmath264 the 1 at @xmath266 would have already moved on to @xmath267 . which only helps with the routing .",
    "figure 5 shows the timing diagram for the first three 1 s starting from the right most 1 at @xmath252 .",
    "we see that for @xmath253 it takes at most @xmath268 cycles to reach the root @xmath269 .",
    "similarly for @xmath257 it takes at most @xmath270 cycles to reach @xmath269 . in general for @xmath271 it takes at most @xmath272 cycles . clearly for any path ,",
    "@xmath273 which gives us the first term in the bound of the lemma .",
    "this proves the claim .    in the second round we exchange pebbles between @xmath241 and @xmath232 such that after end of this round at least @xmath241 is all 0 s or @xmath232 is all 1 s .",
    "we show this rounds takes at most @xmath274 cycles .",
    "this can be proven by recycling some of the main ideas from the previous proof .",
    "again we consider a path , but this time not restricted to the subtrees themselves but from one subtree to another .",
    "let this path be @xmath275 .",
    "let the arity sequence be analogously defined ( @xmath276 ) .",
    "note here that , the node @xmath210 links the two trees and contributes an arity of 1 for each side ( figure 4 ) .",
    "let @xmath277 ( where ` @xmath278 ' represents concatenation ) , where @xmath279 and @xmath280 .",
    "we call a @xmath281 with all 0 s or a @xmath282 with all 1 s as _ clean _ , otherwise they are _ dirty_. after the completion of this round we assume without loss of generality that @xmath240 is clean ( all 0 s ) . hence , after completion of this round",
    "every @xmath281 will be pure .",
    "conversely , as long as their is some impure @xmath281 their must also be some impure @xmath282 . hence if @xmath282 becomes pure before @xmath281 we can consider another path @xmath283 where @xmath284 is still impure . since the paths @xmath242 and",
    "@xmath285 have consumed equal number of cycles before @xmath282 became pure , due to symmetry , we can carry our timing diagram ( of pebbles in @xmath281 ) over to @xmath285 and continue extending it . similarly we can extend our timing diagram to other paths @xmath286 etc if necessary .",
    "hence , without loss of generality we assume @xmath282 never becomes pure before @xmath281 .",
    "also note that after crossing @xmath269 , a 1 in this path may choose to move to some other subtree not in the path .",
    "hence , from the perspective of @xmath242",
    "we can imagine that the said 1 just vanishes and is replaced by a 0 .",
    "this however is a desirable situation and only helps with our bound since we want @xmath240 to be clean was clean after this round then we just do the same analysis from the perspective of the 0 s in @xmath232 . ] .",
    "now we look at the routing schedule on @xmath242 . before beginning of this round @xmath250 s have all 1 s starting from @xmath287 up to some @xmath288",
    ". we can carry over most of the observations we made to obtain the timing diagram for the first round .",
    "however , we must take into account one additional bottleneck . during the analysis of the first round we ignored the 1",
    "s coming from other subtrees to our path @xmath242 as they did not hinder the invariant ( all 1 s precedes all 0 s ) .",
    "however , we can not ignore these extraneous 1 s for this round because all the 1 s in @xmath281 must move to @xmath282 before the end of it . at the beginning , the sentinel @xmath289 moves to @xmath269 immediately after 1 cycle",
    ". then it may take it up to @xmath290 cycles to move to @xmath291 .",
    "for @xmath292 it takes at most 2 cycles to move to @xmath287 . actually the timing diagram for this two 1 s will be exactly the same as in the first round because no other 1 from some other subtree can get in front of them .",
    "let @xmath293 and @xmath294 .",
    "for the sentinel it takes at most @xmath295 to reach @xmath296 or finish at somewhere left of @xmath296 .",
    "similarly it takes @xmath292 at most @xmath297 steps to reach its final position .",
    "however things get interesting for @xmath298 .",
    "first it has to wait for its predecessor @xmath292 to vacate @xmath299 .",
    "once @xmath292 has left @xmath299 it may be the case that , an arbitrary number of 1 s from other sibling subtrees may end up beating it to reach @xmath299 .",
    "let us say @xmath300 1 s reach @xmath299 before @xmath298 does",
    ". then it would take @xmath298 at most @xmath301 to reach @xmath302 or end up somewhere left of it .",
    "we note that the second summation dominates the first one the further left we go .",
    "this can be generalized : if @xmath303 1 s have moved into @xmath242 in front of @xmath304 ( these events occur before @xmath304 reaches @xmath299 ) then it takes @xmath304 at most @xmath305 steps to reach its final position in @xmath242 . since @xmath306 and @xmath307 are all @xmath308 we have that after @xmath309 steps @xmath281 would be pure . since , @xmath281 is arbitrary we see that @xmath240 must be all 0 s as well .    the @xmath231 procedure is called for each consecutive pairs of subtrees during one pass .",
    "we call a subtree type-1 if it contains all 1 s .",
    "similarly we define a tree to be type-0 if it contains all 0 s .",
    "next we prove the following assertion : after one pass one of the following is true .",
    "1 ) the rightmost subtree @xmath310 is of type-1 .",
    "2 ) all the subtrees to its left are type-0 .",
    "this can be easily seen from the fact that the trees are arranged from left to right with decreasing size .",
    "after the first swap between @xmath311 and @xmath222 it is obvious that either @xmath311 is of type-0 or @xmath222 is of type-1 .",
    "let the assertion hold after completion of @xmath228 .",
    "hence , either @xmath213 is of type-1 or all the subtrees before @xmath213 are of type-0 . if the former is true then after completion of @xmath228 , @xmath230 would be of type-1 since @xmath312 .",
    "if the latter holds then after the swap all subtrees to the left of @xmath230 will be of type-0 .",
    "this proves the assertion .",
    "hence during the next pass we can ignore @xmath310 . in parallel , however , since we have wait for @xmath311 to start sorting in parallel , this does not improve the number of stages . ] in the above analysis we see that the number of cycles depends on @xmath239 which is a property of the input sequence .",
    "however we can easily make @xmath228 oblivious by observing that @xmath313 , where @xmath314 is the number of pebbles exchanged between @xmath240 and @xmath230 during the @xmath315 pass .",
    "let us consider the swap between @xmath316 and @xmath222 .",
    "during the first pass @xmath317 pebbles are exchanged .",
    "but during the first pass at most @xmath318 pebbles were exchanged between @xmath319 and @xmath320 hence at most this many pebble will be exchanged during the swap operation between @xmath316 and @xmath222 during the second pass .",
    "we see that this argument can be generalized easily .          at this point",
    "we focus on the double sum .",
    "we want to show @xmath324 . here",
    "@xmath8 is the maximum degree of @xmath152 and @xmath325 is some constant .",
    "the total number of pebbles transported to @xmath213 after @xmath326 passes is @xmath327 to the total number of nodes in the trees right of @xmath213 .",
    "hence , @xmath328 .",
    "we have , @xmath329        this shows that @xmath209 requires @xmath334 stages to correctly sort any input with respect to the mp ordering .",
    "we note that for the two extreme cases , 1 ) when @xmath335 and 2 ) @xmath336 the number stages needed by @xmath209 is optimal up to a constant factor .",
    "it remains to be seen if there exists an @xmath337 round sorting network for trees      ajtai , m. , komls , j. , & szemerdi , e. ( 1983 , december ) .",
    "an 0 ( n log n ) sorting network . in proceedings of the fifteenth annual acm symposium on theory of computing ( pp . 1 - 9 ) .",
    "batcher , k. e. ( 1968 , april ) .",
    "sorting networks and their applications . in proceedings of the april 30may 2 , 1968 , spring joint computer conference ( pp .",
    "307 - 314 ) .",
    "komls , j. , ma , y. , & szemerdi , e. ( 1998 ) .",
    "matching nuts and bolts in o ( n log",
    "siam journal on discrete mathematics , 11(3 ) , 347 - 372 .",
    "schnorr , c. p. , & shamir , a. ( 1986 ,",
    "november ) .",
    "an optimal sorting algorithm for mesh connected computers . in proceedings of the eighteenth annual acm symposium on theory of computing ( pp .",
    "255 - 263 ) .",
    "alon , n. , chung , f. r. , & graham , r. l. ( 1994 ) . routing permutations on graphs via matchings .",
    "siam journal on discrete mathematics , 7(3 ) , 513 - 530 .",
    "li , w. t. , lu , l. , & yang , y. ( 2010 ) . routing numbers of cycles , complete bipartite graphs , and hypercubes .",
    "siam journal on discrete mathematics , 24(4 ) , 1482 - 1494 .",
    "zhang , l. ( 1999 ) .",
    "optimal bounds for matching routing on trees .",
    "siam journal on discrete mathematics , 12(1 ) , 64 - 77 .",
    "busch , c. , magdon - ismail , m. , mavronicolas , m. , & spirakis , p. ( 2004 ) .",
    "direct routing : algorithms and complexity . in algorithms ",
    "esa 2004 ( pp .",
    "134 - 145 ) .",
    "springer berlin heidelberg .",
    "benjamini , i. , shinkar , i. , & tsur , g. ( 2014 ) .",
    "acquaintance time of a graph .",
    "siam journal on discrete mathematics , 28(2 ) , 767 - 785 .",
    "micali , s. , & vazirani , v. v. ( 1980 , october ) .",
    "an @xmath338 algoithm for finding maximum matching in general graphs . in foundations of computer science , 1980 . ,",
    "21st annual symposium on ( pp .",
    "17 - 27 ) .",
    "plaxton , c. g. , & suel , t. ( 1994 ) .",
    "a super - logarithmic lower bound for hypercubic sorting networks ( pp .",
    "618 - 629 ) .",
    "springer berlin heidelberg .",
    "knuth , d. e. ( 1998 ) .",
    "the art of computer programming : sorting and searching ( vol .",
    "pearson education .",
    "leighton , t. , & plaxton , c. g. ( 1998 ) .",
    "hypercubic sorting networks .",
    "siam journal on computing , 27(1 ) , 1 - 47 ."
  ],
  "abstract_text": [
    "<S> the paper is divided in to two parts . in the first part we present some new results for the _ routing via matching _ model introduced by alon et al@xcite . </S>",
    "<S> this model can be viewed as a communication scheme on a distributed network . </S>",
    "<S> the nodes in the network can communicate via matchings ( a step ) , where a node exchanges data with its partner . </S>",
    "<S> formally , given a connected graph @xmath0 with vertices labeled from @xmath1 $ ] and a permutation @xmath2 giving the destination of pebbles on the vertices the problem is to find a minimum step routing scheme . </S>",
    "<S> this is denoted as the routing time @xmath3 of @xmath0 given @xmath2 . in this paper </S>",
    "<S> we present the following new results , which answer one of the open problems posed in @xcite : 1 ) determining whether @xmath3 is @xmath4 can be done in @xmath5 deterministic time for any arbitrary connected graph @xmath0 . </S>",
    "<S> 2 ) determining whether @xmath3 is @xmath6 for any @xmath7 is np - complete . in the second part we study a related property of graphs , which measures how easy it is to design sorting networks using only the edges of a given graph . informally , _ sorting number _ of a graph </S>",
    "<S> is the minimum depth sorting network that only uses edges of the graph . </S>",
    "<S> many of the classical results on sorting networks can be represented in this framework . </S>",
    "<S> we show that a tree with maximum degree @xmath8 can accommodate a @xmath9 depth sorting network . </S>",
    "<S> additionally , we give two instance of trees for which this bound is tight .    , np completeness , sorting networks </S>"
  ]
}