{
  "article_text": [
    "reversible circuits are linear , boolean circuits with no loops , whose elementary gates are reversible . in quantum computation ,",
    "reversible circuits are mostly used as oracle : the _ description _ of the problem to solve .",
    "usually , this description is given as a classical , conventional algorithm : the graph to explore  @xcite , the matrix coefficients to process  @xcite , _",
    "etc_. these algorithms use arbitrarily complex structures , and if some are rather simple , for example  @xcite , others are quite complicated and make use of analytic functions  @xcite , memory registers  @xcite ( which thus have to be simulated ) , _ etc_.",
    "this paper is concerned with the design of reversible circuits as _ operational semantics _ of a higher - order purely functional programming language .",
    "the language is expressive enough to encode most algorithms : it features recursion , pairs , booleans and lists , and it can easily be extended with additional structures if needed .",
    "this operational semantics can be understood as the _ compilation _ of a program into a reversible circuit .",
    "compiling a program into a reversible circuit is fundamentally different from compiling on a regular back - end : there is no notion of `` loop '' , no real control flow , and all branches will be explored during the execution .",
    "in essence , a reversible circuit is the _ trace _ of all possible executions of a given program .",
    "constructing a reversible circuit out of the trace of execution of a program is what bennett  @xcite proposed in 1973 , using turing machines . in this paper",
    ", we refer to it as landauer embeddings  @xcite .    in this paper",
    ", we build up on this idea of circuit - as - trace - of - program and formalize it into an operational semantics for our higher - order language .",
    "this semantics is given externally as an abstract machine , and internally , as a _",
    "monadic interpretation_.    the strength of our approach to circuit synthesis is to be able to reason on a regular program independently from the constraints of the circuit construction .",
    "the approach we follow is similar to what is done in geometry of synthesis  @xcite for hardware synthesis , but since the back - end we aim at is way simpler , we can devise a very natural and compact monadic operational semantics .    * contribution . * the main contribution of this paper is a monadic presentation of landauer embeddings  @xcite in the context of higher - order programs .",
    "its main strength is its parametricity : a program really represents a _ family _ of circuits , parametrized on the size of the input .",
    "furthermore , we demonstrate a compositional monadic procedure for generating a reversible circuit out of a regular , purely functional program .",
    "the generated circuit is then provably computing the same thing as the original program .",
    "this can be used to internalize the generation of a reversible circuit out of a functional program .",
    "it has been implemented in quipper  @xcite and used for building complex quantum oracles",
    ".    * related works . * from the description of a conventional function it is always possible to design a reversible circuit computing the function out of its truth table or properties thereof and several methods have been designed to generate compact circuits ( see e.g.  @xcite ) . however , if these techniques allow one to write reversible functions with arbitrary truth tables  @xcite , they do not usually scale well as the size of the input grows .    synthesis of reversible circuits can be seen as a small branch of the vast area of hardware synthesis . in general , hardware synthesis can be structural ( description of the structure of the circuit ) or behavioral ( description of algorithm to encode ) .",
    "functional programming languages have been used for both . on the more structural side",
    "one finds lava  @xcite , bluespec  @xcite , functional netlists  @xcite , _",
    "etc_. on the behavioral side we have the geometry of synthesis  @xcite , esterel  @xcite , forsyde  @xcite , _ etc_. two more recent contributions sitting in between structural and behavioral approaches are worth mentioning .",
    "first , the imperative , _ reversible _ synthesis language syrec  @xcite , specialized for reversible circuits .",
    "then , thomsen s proposal  @xcite , allowing to represent a circuit in a functional manner , highlighting the behavior of the circuit out of its structure .    on the logic side ,",
    "the geometry of interaction  @xcite is a methodology that can be used to turn functional programs into reversible computation  @xcite : it is based on the idea of turning a typing derivation into a reversible automaton",
    ".    there have also been attempts to design reversible abstract machines and to compile regular programs into reversible computation .",
    "for example , a reversible version of the semcd machine has been designed  @xcite .",
    "more recently , the compiler revs  @xcite aims at compiling conventional computation into reversible circuits .",
    "monadic semantics for representing circuits is something relatively common , specially among the dsl community : lava  @xcite , quipper  @xcite , fe - si  @xcite , _",
    "etc_. other approaches use more sophisticated constructions , with type systems based on arrows  @xcite in order to capture reversibility .    in the present work ,",
    "the language is circuit - agnostic , and the interest of the method lies more in the fact that the monadic semantics to build reversible circuits is completely _ implicit _ and only added at circuit - generation time , following the approach in  @xcite , rather than in the choice of the language .",
    "compared to  @xcite , our approach is also parametric in the sense that a program does not describe one fixed - size circuit but a family of circuits , parametrized by the size of the input .",
    "* plan of the paper .",
    "* section  [ sec : reversible - circuits ] presents the definition of reversible circuits and how to perform computation with them .",
    "section  [ sec : progr - revers - circ ] describes a pcf - like lambda - calculus and proposes two operational semantics : one as a simple beta - reduction and one using an abstract machine and a partial evaluation procedure generating a circuit .",
    "section  [ sec : internalizing ] describes the call - by - value reduction strategy and explains how to internalize the abstract - machine within the language using a monad .",
    "section  [ sec : use - cases ] discusses the use of this technique in the context of the generation of quantum oracles , and discusses the question of optimizing the resulting circuits .",
    "finally , section  [ sec : conclusion ] concludes and proposes some future investigations .",
    "r0.3     a reversible boolean circuit consists in a set of _ open wires _ and _ elementary gates _ attached onto the wires .",
    "schematically , a reversible boolean circuit is of the form shown on the right . to each gate",
    "is associated a boolean operation , supposed to be reversible . in this circuit example",
    ", @xmath0 is a one - bit operation ( for example a not - gate , flipping a bit ) while @xmath1 is a two - bit operation . in each wire ,",
    "a bit `` flows '' from left to right .",
    "all the bits go at the same pace .",
    "when a gate is met , the corresponding operation is applied on the wires attached to the gate . since the gates are reversible , the overall circuit is reversible by making the bits flow backward .    [ [ choice - of - elementary - gates . ] ] * choice of elementary gates . * + + + + + + + + + + + + + + + + + + + + + + + + + + + + +    many gates have been considered in the literature  @xcite . in this paper , we will consider multi - controlled - not gates . a not gate , represented by @xmath2 & * { \\oplus } \\ar@{-}[r ] & ~ , } $ ] is flipping the value of the wire on which it is attached . the operator @xmath3 stands for the bit - flip operation . given a gate @xmath1 acting on @xmath4 wires , a controlled - f is a gate acting on @xmath5 wires",
    ". the control can be positive or negative , represented    r0.35    @xmath6 & * { \\bullet } \\ar@{-}[r]\\ar@{-}[d ] & x    \\\\",
    "\\vec{y}\\ar@{=}[r ] & * + [ f]{f } \\ar@{=}[r ] &   } \\quad \\xymatrix@r=.05in@c=.1 in {    x \\ar@{-}[r ] & * { \\circ } \\ar@{-}[r]\\ar@{-}[d ] & x    \\\\",
    "\\vec{y } \\ar@{=}[r ] & * + [ f]{f } \\ar@{=}[r ] & } $ ]    respectively as shown on the right . in both cases ,",
    "the top wire is not modified . on the bottom wires ,",
    "the gate @xmath1 is applied if @xmath7 is true for the positive control , and false for the negative control .",
    "otherwise , no gate is applied : the values @xmath8 flow unchanged through the gate .",
    "a positively - controlled not gate will be denoted cnot .",
    "a reversible circuit runs a computation on some query : some input wires correspond to the query , and some output wires correspond to the answer .",
    "the auxiliary input wires that are not part of the query are initially fed with the boolean `` false '' ( also written @xmath9 ) .",
    "[ [ computing - with - reversible - circuits . ] ] * computing with reversible circuits . * + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + +    as described by landauer@xcite and bennett@xcite , a conventional , classical algorithm that computes a boolean function @xmath10 can be mechanically transformed into a reversible circuit sending the triplet @xmath11 to @xmath12 , as in figure  [ fig : tf ] .",
    "its input wires are not modified by the circuit , and the trace of all intermediate results are kept in garbage wires .",
    "because of their particular structure , two landauer embeddings @xmath13 and @xmath14 can be composed to give a landauer embedding of the composition @xmath15 .",
    "figure  [ fig : tgth ] shows the process : the wires of the output of @xmath13 are fed to the input of @xmath14 , and the output of the global circuit is the one of @xmath14 .",
    "the garbage wires now contain all the ones of @xmath13 and @xmath14 .",
    "note that it is easy to build elementary landauer embeddings for negation and conjunction : the former is a negatively - controlled not while the latter is a positively doubly - controlled not .",
    "any boolean function can then be computed with landauer embeddings .",
    "# 1#2#3#4(#1,#4#2);(#3,#2 ) * * ; ( # 1,#4#2.9999);(#3,#4#2.9999 ) * * ; ( # 1,#4#2.5);(#3,#4#2.5 ) * * ; ( # 1,#4#2.25);(#3,#4#2.25 ) * * ; ( # 1,#4#2.75);(#3,#4#2.75 ) * * ; ( # 1,#4#2.625);(#3,#4#2.625 ) * * ; ( # 1,#4#2.375);(#3,#4#2.375 ) * * ; ( # 1,#4#2.55);(#3,#4#2.55 ) * * ; ( # 1,#4#2.45);(#3,#4#2.45 ) * * ;    .35 @xmath16    .5 @xmath17",
    "in this section , we present an implementation of landauer embeddings to the context of a higher - order functional programming language , and show how it can be understood through an abstract machine .      a reversible circuit has a very simple structure . as a linear sequence of elementary gates",
    ", it can be represented as a simple list of gates .    a _ reversible gate _",
    "@xmath0 is a term @xmath18 where @xmath19 , @xmath20, ",
    ",@xmath21 are natural numbers such that for all @xmath22 , @xmath23 , and where @xmath24,",
    " ,@xmath25 are booleans .",
    "if the list of @xmath26 is empty , we simply write @xmath27 in place of @xmath28 .",
    "the _ wires _ of the gate @xmath29 is the set of natural numbers @xmath30 . the wire @xmath19 is called _ active _ and the @xmath31 s are called the _ control wires_. given a list @xmath32 of gates , the union of the sets of wires of the elements of @xmath32 is written @xmath33 .",
    "finally , the boolean values true and false flowing in the wires are respectively represented with @xmath34 and @xmath35 throughout the paper .    a _ reversible boolean circuit _ is a triplet @xmath36 where @xmath32 is a list of reversible gates and where @xmath37 and @xmath38 are sets of wires .",
    "the list @xmath32 is the _ raw circuit _",
    ", @xmath37 is the set of _ inputs wires _ and @xmath38 the set of _ outputs wires_. we also call @xmath39 the _ auxiliary wires _ and @xmath40 the _ garbage wires_.    executing a reversible circuit on a given tuple of booleans computes as follows .",
    "[ def : exec - circ ] consider a circuit @xmath36 and a family of bits @xmath41 .",
    "valuation _ for the circuit is an indexed family @xmath42 of booleans .",
    "the _ execution of a gate @xmath29 on the valuation @xmath43 _ is the valuation @xmath44 such that for all @xmath45 , @xmath46 and @xmath47 if @xmath48 and @xmath49 otherwise .",
    "the execution of the circuit @xmath36 with input @xmath41 is the succession of the following operations : ( 1 ) initialization of a valuation @xmath43 such that for all @xmath50 , @xmath51 , and for all the other values of @xmath22 , @xmath52 is false .",
    "( 2 ) execution of every gate in @xmath32 on @xmath43 , _ in reverse order_. ( 3 ) the execution of the circuit returns the sub - family @xmath53 .      in this section",
    ", we present the functional language that we use to describe the regular computations that we eventually want to perform with a reversible circuit .",
    "the language is simply - typed and it features booleans , pairs and lists .",
    "@xmath54    a , b & { : } { : } { = } &    { { \\tt bit}}{\\,{|}\\,}a \\oplus b { \\,{|}\\,}a\\times b { \\,{|}\\,}{{\\tt 1}}{\\,{|}\\,}a \\to b { \\,{|}\\,}{{[}{a}{]}}. \\end{array}\\ ] ] the language comes equipped with the typing rules of table  [ tab : typ - rules ] .",
    "there are several things to note .",
    "first , the construct @xmath55 can only output _",
    "first - order types_. a first order type is a type from the grammar @xmath56}}. $ ] despite the fact that one can encode them with the test construct , for convenience we add the basic boolean combinators @xmath3 , @xmath57 and @xmath58 .",
    "there are no constructors for lists , but instead there is a coercion from @xmath59}})$ ] to @xmath60}}$ ] ; the term @xmath61 turns a list - type into a additive type .",
    "there is a special - purpose term @xmath62 that will be used in particular in section  [ sec : op - sem - rev - circ ] as an error - spawning construct .",
    "the boolean values true and false are respectively represented with @xmath34 and @xmath35 .",
    "@xmath63 is the unit term and @xmath64 is used as the destructor of the unit .",
    "finally , @xmath65 is a fixpoint operator . as we shall eventually work with a call - by - value reduction strategy , we only consider fixpoints defining functions .",
    "@xmath66 @xmath67 @xmath68}}\\to{{{\\tt 1}}}\\oplus(a\\times{{[}{a}{]}})}{}\\ ] ] @xmath69 @xmath70 @xmath71 } } } {      \\delta\\vdash m:{{{\\tt 1}}}\\oplus(a\\times{{[}{a } { ] } } )    } \\ ] ] @xmath72    [ notation : syntax ] we write @xmath73 for @xmath74 and @xmath75 in place of @xmath76 .",
    "we also write @xmath77 $ ] for @xmath78 .",
    "we also write general products @xmath79 as @xmath80 .",
    "projections @xmath81 for @xmath82 extends naturally to @xmath4-ary products .",
    "we write @xmath83 for the term @xmath84 .",
    "[ rem : if1storder ] the typing rule of the if - then - else construct imposes a first - order condition on the branches of the test .",
    "this will be clarified in remark  [ rem : if1storderbis ] . for",
    "now , let us just note that this constraint can be lifted with some syntactic sugar : if @xmath85 and @xmath86 are of type @xmath87 , where @xmath88 is first - order , then a `` higher - order '' test @xmath89 can be defined using the native first - order test by an @xmath90-expansion with the lambda - abstraction @xmath91 .",
    "@xmath92 }      &      \\pi_i{{\\langle{m_1,m_2}\\rangle } } & \\to m_i      &      { { { \\mathtt{skip}}}\\mathtt{;}{m } }      & \\to m      \\\\[1ex ]      { { { \\mathtt{if}}~{{\\mathtt{t\\!t}}}~\\mathtt{then}~{m}~\\mathtt{else}~{n } } }      & \\to m      &      { { { \\mathtt{if}}~{{\\mathtt{f\\!f}}}~\\mathtt{then}~{m}~\\mathtt{else}~{n } } }      & \\to n      &      { { \\mathtt{split}^{}}}\\,m & \\to m      \\end{array }      \\\\[2.5ex ]      \\begin{array}{r@{}lr@{}l }      { { { \\mathtt{match}}~{{{\\tt inj}}_i(p)}~{\\mathtt{with}}~({x_1\\,\\mapsto\\,m_1}\\vert{x_2\\,\\mapsto\\,m_2 } ) } }      & \\to      m_i{[}p / x_i { ] }      &      y(m )      & \\to      m(y(m ) )      \\end{array }      \\end{array}\\ ] ]    we equip the language with the smallest rewrite - system closed under subterm reduction , satisfying the rewrite rules of table  [ tab : betared ] , and satisfying the obvious rules regarding @xmath3 , @xmath58 and @xmath93 : for example , @xmath94 and @xmath95 .",
    "note that the term @xmath62 does not reduce .",
    "this is on purpose : it represents an error that one can not catch with the type system ; in particular it will be used in section  [ sec : op - sem - rev - circ ] .",
    "the usual safety properties are satisfied , modulo the error - spawning term @xmath62 .",
    "a value is a term @xmath96 defined by the grammar @xmath97 , where @xmath98 is a constant term : @xmath63 , @xmath34 , @xmath35 .",
    "type preservation and progress are verified : ( 1 ) if @xmath99 , then for all @xmath86 such that @xmath100 we also have @xmath101 .",
    "( 2 ) if @xmath85 is a closed term of type @xmath102 then either @xmath85 is a value , or @xmath85 contains the term @xmath62 , or @xmath85 reduces .    in summary , the language is well - behaved .",
    "it is also reasonably expressive , in the sense that most of the computations that one could want to perform on lists of bits can be described , as shown in example  [ ex : list ] .",
    "when defining a large piece of code , we will be using a haskell - like notation .",
    "so instead of defining a closed function as a lambda - term on a typing judgment , we shall be using the notation    .... function : type_of_the_function function arg1 arg2 ... = body_of_the_function ....    also , we shall use the convenient notation @xmath103 for @xmath104 and the notation @xmath105 for @xmath106 .",
    "similarly , we allow multiple variables for recursive functions , and we use pattern - matching for lists and general products in the same manner .",
    "[ ex : list ] the usual list combinators can be defined . here",
    "we give the definition of foldl : ( a @xmath107 b @xmath107 a ) @xmath107 a @xmath107 [ b ] @xmath107 a. the other ones ( such as map , zip  ) are written similarly .",
    ".... foldl f a l = letrec g z l ' = match ( split l ' ) with                        nil$\\hspace{2.1ex}$ $ \\mapsto$ z                     | $ \\langle$h , t$\\rangle$ $ \\mapsto$ g",
    "( f z h ) t                in g a l ....    [ ex : adder ] one can easily encode a bit - adder : it takes a carry and two bits to add , and it replies with the answer and the carry to forward .    ....",
    "bit_adder : bit $ \\to$ bit $ \\to$ bit $ \\to$ ( bit $ \\times$ bit ) bit_adder carry x y =        let majority a b c = if ( xor a b ) then c else a in        let z = xor ( xor carry x ) y in        let carry ' = majority carry x y in $ \\langle$carry ' , z$\\rangle$ ....    encoding integers as lists of bits , low - bit first , one can use the bit - adder to write a complete adder in a ripple - carry manner , amenable to a simple folding .",
    "we use an implementation similar to the one done in  @xcite .",
    ".... adder_aux : ( bit $ \\times$ [ bit ] ) $ \\to$ ( bit $ \\times$ bit ) $ \\to$ ( bit $ \\times$ [ bit ] ) adder_aux $ \\langle$w , cs$\\rangle$ $ \\langle$a , b$\\rangle$ = let $ \\langle$w ' , c'$\\rangle$ = bit_adder w a b in $ \\langle$w ' , c'::cs$\\rangle$    adder : [ bit ] $ \\to$ [ bit ] $ \\to$ [ bit ] adder x y = $ \\pi#2 $ ( foldl adder_aux $ \\langle\\ffalse$ , nil$\\rangle$ ( zip y x ) ) ....      we consider the language as a _ specification language _ for boolean reversible circuits in the following sense : a term of type @xmath108 computes a boolean function @xmath109 .    in this section , we propose an operational semantics for the language generating landauer embeddings , as described in section  [ sec : reversible - circuits ] . the circuit is produced during the execution of an abstract machine and partial evaluation of terms .",
    "essentially , a term reduces as usual , except for the term constructs handling the type @xmath110 , for which we only record the operations to be performed . formally , the definitions are as follows .",
    "a _ circuit - generating abstract machine _ is a tuple consisting of ( 1 ) a typing judgment @xmath111 ;   ( 2 ) a partial circuit @xmath112 where @xmath32 is a list of gates ;   ( 3 ) a one - to - one linking function mapping the free variables @xmath113 of @xmath85 to the wires @xmath114 .    intuitively , @xmath115 is the set of input wires .",
    "the set of output wires is not yet computed : we only get it when @xmath85 is a value .",
    "if @xmath0 is a gate , we write @xmath116 for the partial circuit @xmath117 . given a judgment @xmath118 , the empty machine is @xmath119 and is denoted with @xmath120 .",
    "the size of the domain of a linking function @xmath121 is written @xmath122 .    by abuse of notation",
    ", we shall write abstract machine with terms , and not typing judgements .",
    "it is assumed that all terms are well - typed according to the definition .",
    "given a linking function @xmath121 , a _ first - order extension of @xmath121 _ consists of a term of shape @xmath123 ,    $ ] where the @xmath113 s are in the domain of @xmath121 .",
    "we say that two first - order extensions of @xmath121 have _ the same shape _ provided that they are both products with the same size or lists with the same size such as their components have pairwise the same shape .",
    "@xmath124 , rc , l ) & { \\mathrel{\\to_{\\it am}}}(c[m{[}n / x { ] } ] , rc , l )          \\\\[.5ex ]          ( c[\\pi_i{{\\langle{m_1,m_2}\\rangle } } ] , rc , l ) & { \\mathrel{\\to_{\\it am}}}(c[m_i ] , rc , l )          \\\\[.5ex ]          ( c[{{{\\mathtt{skip}}}\\mathtt{;}{m } } ] , rc , l )   & { \\mathrel{\\to_{\\it am}}}(c[m ] , rc , l )          \\\\[.5ex ]          ( c[{{\\mathtt{split}^{}}}\\,m ] , rc , l ) & { \\mathrel{\\to_{\\it am}}}(c[m ] , rc , l )          \\\\[.5ex ]          ( c[{{{\\mathtt{match}}~{{{\\tt inj}}_i(p)}~{\\mathtt{with}}~({x_1\\,\\mapsto\\,m_1}\\vert{x_2\\,\\mapsto\\,m_2 } ) } } ] , rc , l )          & { \\mathrel{\\to_{\\it am}}}(c[m_i{[}p / x_i { ] } ] , rc , l )          \\\\[.5ex ]          ( c[y(m ) ] , rc , l )          & { \\mathrel{\\to_{\\it am}}}(c[m(y(m ) ) ] , rc , l )      \\end{array}\\ ] ]    @xmath125,rc , l){\\mathrel{\\to_{\\it am}}}(c[p_{i_0 } ] , rc , l ' )    ~~&~~    ( c[{\\mathtt{t\\!t}}],rc , l){\\mathrel{\\to_{\\it am}}}(c[p_{i_0 } ] , ( { { \\tt n}({i_0})})::rc ,    l ' )    \\\\    ( c[{\\tt not}~p_i],rc , l)&{\\mathrel{\\to_{\\it am}}}(c[p_{i_0}],{{\\tt n}({i_0}\\cdot{{\\mathtt{f\\!f}}^i})}::rc ,    l ' )    \\\\    ( c[{\\tt and}~p_i~p_j],rc , l)&{\\mathrel{\\to_{\\it am}}}(c[p_{i_0 } ] ,    { { \\tt n}({i_0}\\cdot{{\\mathtt{t\\!t}}^i{\\mathtt{t\\!t}}^j } ) } : : rc , l ' )    \\\\    ( c[{\\tt xor}~p_i~p_j],rc , l)&{\\mathrel{\\to_{\\it am}}}(c[p_{i_0}],{{\\tt n}({i_0}\\cdot{(i,{\\mathtt{t\\!t } } ) } ) } : :    { { \\tt n}({i_0}\\cdot{{\\mathtt{t\\!t}}^j})}::rc , l ' )    \\\\    ( c[{{{\\mathtt{if}}~{p_i}~\\mathtt{then}~{v}~\\mathtt{else}~{w } } } ] , rc , l)&{\\mathrel{\\to_{\\it am}}}\\\\       & \\hspace{-10ex }    \\left\\ {      \\begin{array}{l@{\\quad}l }        ( c[u ] , rc',l '' ) & \\textrm{$v$ and $ w$ of the same shape }        \\\\",
    "c[{{\\tt err } } ] & \\textrm{otherwise }      \\end{array}\\right .",
    "\\end{aligned}\\ ] ]    the set of circuit - generating abstract machines is equipped with a rewrite - system @xmath126 defined using a notion of _ beta - context _ @xmath127 $ ] , that is , a term with a hole , as follows .",
    "@xmath128 { \\,{|}\\,}\\lambda x.c[- ] { \\,{|}\\,}(c[-])n { \\,{|}\\,}m(c[- ] ) { \\,{|}\\,}{{\\langle{c[-],n}\\rangle } } { \\,{|}\\,}{{\\langle{m , c[-]}\\rangle } } { \\,{|}\\,}\\\\ \\pi_1(c[- ] ) { \\,{|}\\,}\\pi_2(c[- ] ) { \\,{|}\\,}{{c[-]}\\mathtt{;}{n } } { \\,{|}\\,}{{m}\\mathtt{;}{c[- ] } } { \\,{|}\\,}{{{\\mathtt{if}}~{c[-]}~\\mathtt{then}~{n}~\\mathtt{else}~{p } } } { \\,{|}\\,}\\\\ { { { \\mathtt{if}}~{\\!m\\!}~\\mathtt{then}~{c[\\!-\\!]}~\\mathtt{else}~{\\!p\\ ! } } } { \\,{|}\\,}{{{\\mathtt{if}}~{\\!m\\!}~\\mathtt{then}~{\\!n\\!}~\\mathtt{else}~{c[\\!-\\ ! ] } } } { \\,{|}\\,}{{\\tt inj}}_1(c[\\!-\\ ! ] ) { \\,{|}\\,}{{\\tt inj}}_2(c[\\!-\\ ! ] ) { \\,{|}\\,}\\\\ { { { \\mathtt{match}}~{c[-]}~{\\mathtt{with}}~({x\\,\\mapsto\\,m}\\vert{y\\,\\mapsto\\,n } ) } } { \\,{|}\\,}{{{\\mathtt{match}}~{p}~{\\mathtt{with}}~({x\\,\\mapsto\\,c[-]}\\vert{y\\,\\mapsto\\,n } ) } } { \\,{|}\\,}\\\\ { { { \\mathtt{match}}~{p}~{\\mathtt{with}}~({x\\,\\mapsto\\,m}\\vert{y\\,\\mapsto\\,c[- ] } ) } } { \\,{|}\\,}y(c[- ] ) .",
    "\\end{array}\\ ] ] the constructor @xmath129 $ ] is the _ hole _ of the context . given a context @xmath127 $ ] and a term @xmath85 , we define @xmath130 $ ] as the variable - capturing substitution of the hole @xmath129 $ ] by @xmath85 .",
    "the rewrite rules can then be split in two sets .",
    "the first set concerns all the term constructs unrelated to the type @xmath110 . in these cases ,",
    "the state of the abstract machine is not modified , only the term is rewritten .",
    "the rules , presented in table  [ tab : ambetagen ] , are the same as for the small - step semantics of table  [ tab : betared ] : apart from the two rules concerning @xmath131-@xmath132-@xmath133 , all the others are the same .",
    "the second set of rules concerns the terms dealing with the type @xmath110 , and can be seen as partial - evaluation rules : we only record in the circuit the operations that would need to be done .",
    "the rules are shown in table  [ tab : rw - abm ] .",
    "the linking function @xmath134 is @xmath135 , where @xmath136 is a new wire .",
    "the variable @xmath137 is assumed to be fresh . for the case of the @xmath131-@xmath132-@xmath133 , we assume @xmath96 and @xmath138 are first - order extensions of @xmath121 with the same shape .",
    "the term @xmath139 is a first - order extension of @xmath121 with the same shape as @xmath96 and @xmath138 containing only ( pairwise - distinct ) free variables and mapping to new distinct garbage wires .",
    "@xmath140 is @xmath121 updated with this new data .",
    "suppose that @xmath96 contains the variables @xmath141 , that @xmath138 contains the variables @xmath142 and that @xmath139 contains the variables @xmath143 .",
    "then @xmath144 is @xmath145 with the following additional series of gates : @xmath146 and @xmath147 .",
    "note that the set @xmath37 is never modified by the rules    safety properties hold for this new semantics , in the sense that the only error uncaught by the type system is the term @xmath62 that might be spawned .",
    "if @xmath148 , if @xmath149 is an abstract machine and if @xmath150 , then we have the judgement @xmath151 .",
    "suppose that @xmath148 is valid and that @xmath149 is an abstract machine .",
    "then either @xmath85 is a value , or @xmath85 contains @xmath62 , or @xmath149 reduces through ( @xmath152 ) .      the abstract machine @xmath85 generates a circuit computing the same function as the small - step reduction of @xmath85 in the following sense .",
    "let @xmath153 be an abstract machine .",
    "we write @xmath154 for the circuit defined as @xmath155 .",
    "let @xmath156 be the execution of the circuit @xmath154 on the valuation @xmath157 .",
    "we define @xmath158 as the term @xmath85 where each free variable @xmath7 has been replaced with @xmath159 .",
    "intuitively , if @xmath149 is seen as a term where some boolean operations have been delayed in @xmath145 , then @xmath160 corresponds to the term resulting from the evaluation of the delayed operations .",
    "[ th : sim ] [ th : eq - am - beta ] consider a judgment @xmath108 and suppose that @xmath161 then @xmath162 , and provided that @xmath163 , the term @xmath164 is equal to @xmath165 if and only if the term @xmath166 reduces to @xmath165 .",
    "the proof is done using an invariant on a single step of the rewriting of abstract machines , stated as follows .",
    "[ lem : inv1 ] consider a judgment @xmath108 and suppose that @xmath167 let @xmath168 be a valuation .",
    "then either the term @xmath158 is equal to @xmath169 if the rewrite corresponds to the elimination of a boolean @xmath34 or @xmath35 , or @xmath170 , or @xmath86 contains the error term @xmath62 .",
    "if @xmath171 , then there is a sequence of intermediate rewrite steps where none of the terms involved is the term @xmath62 . from lemma  [ lem : inv1 ] , one concludes that for all valuations @xmath172 on @xmath37 , @xmath173 . choosing @xmath163 , @xmath174 is the term @xmath85 where each free variable @xmath175 has been substituted with its corresponding boolean @xmath176 .",
    "similarly , @xmath177 is equal to the value@xmath178 .",
    "we can conclude the proof by remarking that the term @xmath179 reduces to @xmath85 where each of the free variables @xmath175 have been substituted with @xmath176 , that is , the term @xmath174 .",
    "one would have also hoped to have a simulation result in the other direction , stating that if a ( closed ) term @xmath180 reduces to a tuple of booleans , then @xmath120 generates a circuit computing the same tuple .",
    "unfortunately this is not the case , and the reason is the particular status of the type @xmath110 and the way the if- then - else behaves .",
    "[ rem : if1storderbis ] let us re - visit the first - order constraint of the if- then - else discussed in remark  [ rem : if1storder ] in the light of this operational semantics . here",
    ", this test behaves as a regular boolean operator acting on three arguments : they need to be all reduced to values before continuing .",
    "this test is `` internal '' to the circuit : both branches are evaluated during a run of the program . because it is `` internal '' , the type of the branches have to be `` representable '' : thus the constraint on first - order .",
    "this test does not control the execution of the program : its characteristic only appears at circuit - evaluation time .    with this operational semantics , it is also interesting to note that there are two kinds of booleans : the `` internal '' type @xmath110 , and the `` external '' type defined e.g. as @xmath181 .",
    "if the former does not control the flow , the latter does with the match constructor . and",
    "unlike if- then - else , match does not have type constraints on its branches .",
    "the term @xmath62 can be explained in the light of this discussion .",
    "thanks to the condition on the shape of the output branches of the test , it is used to enforce the fact that @xmath110 can not be coerced to a @xmath182 .",
    "indeed , consider the term @xmath183}}}$ ] : using a match against the result of the test , it would allow one to use the bit @xmath184 for controlling the shape of the rest of the circuit .",
    "as there is not such construct for reversible circuits , it therefore has to be forbidden : it is not possible to control the flow of execution of the program through the type @xmath110 . and the fact that a well - typed term can produce an error is simply saying that the type - system is not `` strong enough '' to capture such a problem .",
    "it is very much related to the fact that the zip operator on lists can not be `` safely '' typed without dependent types .",
    "instead of defining an external operational semantics as we did in section  [ sec : op - sem - rev - circ ] , one can internalize the definition of circuits in the language . given a program ,",
    "provided that one chooses a reduction strategy , one can simulate the abstract - machine semantics inside using a generic _ monadic lifting _",
    ", close to what was proposed in  @xcite .",
    "before going ahead with the full abstract - machine semantics , we present the monadic lifting of for a monadic function - type .",
    "it is the transposition of haskell s monads to our language .",
    "the main characteristic of the reversible abstract - machine is to change the operational behavior of the type @xmath110 : the terms @xmath34 , @xmath35 , the inline @xmath110-combinators and the term construct @xmath55 do not reduce as regular lambda - terms .",
    "instead , they trigger a side - effect , which can be simulated within a monad .",
    "a _ monad _ is a function - type @xmath185 together with two terms @xmath186 and @xmath187 . a _",
    "reversible - circuit monad _ is a monad together with a type @xmath188 and the terms @xmath189 , @xmath190 , and @xmath191 , and finally @xmath192 .",
    "given a reversible - circuit monad @xmath193 , we inductively define the _ @xmath193-monadic lifting of a type @xmath102 _ , written @xmath194 .",
    "we omit the index @xmath193 for legibility .",
    "@xmath195 } } )      & =      { { [ } { { { \\it lift}_{\\mathcal{}}}(a)}{]}}.    \\end{aligned}\\ ] ] the _ @xmath193-monadic lifting of a term @xmath85 _ , denoted with @xmath196 , is defined as follows .",
    "first , we set @xmath197 , @xmath198 , @xmath199 , @xmath200 and @xmath201",
    ". then @xmath202    [ rem : cbv ] note that in this definition of the lifting , we followed a call - by - value approach : the argument @xmath203 of a function @xmath204 is first reduced to a value before being fed to the function .",
    "this will be discussed in section  [ sec : cbv ] .",
    "the fact that a monad is equipped with @xmath205 , @xmath206 , @xmath207 , @xmath208 , @xmath209 and @xmath210 is not a guarantee that the lifting will behave as expected .",
    "one has to choose the right monad for it .",
    "it is the topic of section  [ sec : rev - circ - from - monad ] .",
    "however , in general this monadic - lifting operation preserves types ( proof by induction on the typing derivation ) .    provided that @xmath211 is valid , so is the judgment @xmath212      all the structure of the abstract machine can be encoded in the language .",
    "a wire is a natural number .",
    "a simple way to represent them is with the type @xmath213}}$ ] .",
    "the number @xmath9 is the empty list while the successor of @xmath4 is @xmath214 .",
    "a gate is then @xmath215}}$ ] .",
    "a raw circuit is @xmath216}}$ ] .",
    "we now come to the abstract machine . in the formalization of section  [ sec : op - sem - rev - circ ] , we were using a state with a circuit and a linking function . in this internal representation , the linking function",
    "is not needed anymore : the computation directly acts on wires .",
    "however , the piece of information that is still needed is the next fresh value .",
    "the state is encapsulated in @xmath217}}\\times{{\\tt wire}}$ ] . finally , given a type @xmath102 , we write @xmath218 for the type @xmath219 : this is a computation generating a reversible circuit .    the type operator @xmath220 can be equipped with the structure of a reversible - circuit monad , as follows .",
    "first , it is obviously a state - monad , making the two first constructs automatic : @xmath221 the others are largely relying on the fact that is expressive enough to emulate what was done in section  [ sec : op - sem - rev - circ ] . provided that @xmath222 stands for the successor function , we can @xmath206 as the lambda - term @xmath223 and @xmath205 as the lambda - term @xmath224 .",
    "note how the definition reflects the reduction rules corresponding to @xmath34 and @xmath35 in table  [ tab : rw - abm ] : in the case of @xmath35 , the returned wire is the next fresh one , and the state is updated by increasing the `` next - fresh '' value by one unit . in the case of @xmath34 , on top of this we add a not - gate to the list of gates in order to flip the value of the returned wire .",
    "the definitions of @xmath209 , @xmath208 and @xmath207 are similar . for @xmath210 ,",
    "one capitalizes on the fact that we know the structure of the branches of the test , as they are of first - order types .",
    "one can then define a zip - operator @xmath225 for each first - order type @xmath226 .      as was mentioned in remark  [ rem : cbv ] , the monadic lifting intuitively follows a call - by - value approach .",
    "it can be formalized by developing a call - by - value reduction strategy for circuit - abstract machines . such a definition follows the one of the reduction proposed in section  [ sec : op - sem - rev - circ ] : we first design a notion of _ call - by - value evaluation context _ @xmath227 $ ] characterizing the call - by - value redex that can be reduced .",
    "@xmath228 }      \\begin{array}{r@{}l }      ( e[(\\lambda x.m)v ] , rc , l ) & { \\mathrel{\\to_{\\it cbv}}}(e[m{[}v / x { ] } ] , rc , l )      \\nl      ( e[\\pi_i{{\\langle{v_1,v_2}\\rangle } } ] , rc , l ) & { \\mathrel{\\to_{\\it cbv}}}(e[v_i ] , rc , l )      \\nl      ( e[{{{\\mathtt{skip}}}\\mathtt{;}{m } } ] , rc , l )      & { \\mathrel{\\to_{\\it cbv}}}(e[m ] , rc , l )        \\nl      ( e[{{\\mathtt{split}^{}}}\\,v ] , rc , l ) & { \\mathrel{\\to_{\\it cbv}}}(e[v ] , rc , l )                                  \\nl     ( e[{{{\\mathtt{match}}~{{{\\tt inj}}_i(v)}~{\\mathtt{with}}~({x_1\\,\\mapsto\\,m_1}\\vert{x_2\\,\\mapsto\\,m_2 } ) } } ] , rc , l )      \\hspace{-10ex}\\nl & { \\mathrel{\\to_{\\it cbv}}}(e[m_i{[}v / x_i { ] } ] , rc , l )      \\nl      ( e[y(\\lambda x.m ) ] , rc , l )      & { \\mathrel{\\to_{\\it cbv}}}(e[m[y(\\lambda x.m)/x ] ] , rc , l )      \\end{array}\\ ] ]    @xmath229,rc , l){\\mathrel{\\to_{\\it cbv}}}(e[p_{i_0 } ] , rc , l ' )    ~~&~~    ( e[{\\mathtt{t\\!t}}],rc , l){\\mathrel{\\to_{\\it cbv}}}(e[p_{i_0 } ] , ( { { \\tt n}({i_0})})::rc ,    l ' )    \\\\    ( e[{\\tt not}~p_i],rc , l)&{\\mathrel{\\to_{\\it cbv}}}(e[p_{i_0}],{{\\tt n}({i_0}\\cdot{{\\mathtt{f\\!f}}^i})}::rc ,    l ' )    \\\\    ( e[{\\tt and}~p_i~p_j],rc , l)&{\\mathrel{\\to_{\\it cbv}}}(e[p_{i_0 } ] ,    { { \\tt n}({i_0}\\cdot{{\\mathtt{t\\!t}}^i{\\mathtt{t\\!t}}^j } ) } : : rc , l ' )    \\\\    ( e[{\\tt xor}~p_i~p_j],rc , l)&{\\mathrel{\\to_{\\it cbv}}}(e[p_{i_0}],{{\\tt n}({i_0}\\cdot{(i,{\\mathtt{t\\!t } } ) } ) } : :    { { \\tt n}({i_0}\\cdot{{\\mathtt{t\\!t}}^j})}::rc , l ' )    \\\\    ( e[{{{\\mathtt{if}}~{p_i}~\\mathtt{then}~{v}~\\mathtt{else}~{w } } } ] , rc , l)&{\\mathrel{\\to_{\\it cbv}}}\\\\ & \\hspace{-10ex }    \\left\\ {      \\begin{array}{l@{\\quad}l }        ( e[u ] , rc',l '' ) & \\textrm{$v$ and $ w$ of the same shape }        \\\\        { { \\tt err } } & \\textrm{otherwise }      \\end{array}\\right .    \\end{aligned}\\ ] ]    a _ call - by - value context _ is a beta - context with the following grammar @xmath230 & { : } { : } { = } & [ - ] { \\,{|}\\,}(e[-])n { \\,{|}\\,}v(e[- ] ) { \\,{|}\\,}{{\\langle{e[-],n}\\rangle } } { \\,{|}\\,}{{\\langle{v , e[-]}\\rangle } } { \\,{|}\\,}\\\\ & & \\pi_1(e[- ] ) { \\,{|}\\,}\\pi_2(e[- ] ) { \\,{|}\\,}{{e[-]}\\mathtt{;}{n } } { \\,{|}\\,}{{v}\\mathtt{;}{e[- ] } } { \\,{|}\\,}{{{\\mathtt{if}}~{e[-]}~\\mathtt{then}~{n}~\\mathtt{else}~{p } } } { \\,{|}\\,}\\\\ & & { { { \\mathtt{if}}~{v}~\\mathtt{then}~{e[-]}~\\mathtt{else}~{p } } } { \\,{|}\\,}{{{\\mathtt{if}}~{v}~\\mathtt{then}~{w}~\\mathtt{else}~{e[- ] } } } { \\,{|}\\,}{{\\tt inj}}_1(e[- ] ) { \\,{|}\\,}\\\\ & & { { \\tt inj}}_2(e[- ] ) { \\,{|}\\,}{{{\\mathtt{match}}~{e[-]}~{\\mathtt{with}}~({x\\,\\mapsto\\,m}\\vert{y\\,\\mapsto\\,n } ) } } { \\,{|}\\,}y(e[- ] ) .",
    "\\end{array}\\ ] ] we define the _ call - by - value reduction strategy _ on circuit - generating abstract machines as shown in tables  [ tab : amcbv ] and  [ tab : cbv - abm ] .    essentially , the generic rules of table  [ tab : ambetagen ] are turned into their call - by - value version in the standard way . for example , we require that @xmath231 , rc , l ) { \\mathrel{\\to_{\\it cbv}}}(e[m{[}v / x { ] } ] , rc , l)$ ] happens only when @xmath96 is a value .",
    "similarly , the rules of table  [ tab : rw - abm ] are reflected in table  [ tab : cbv - abm ] , replacing @xmath127 $ ] with @xmath227 $ ] .",
    "remark however that the reduction strategy does not exactly match the rewrite system @xmath126 in one special case : the rewrite rule concerning the fixpoint .",
    "we chose to modify it in order for the fixpoint to behave in a call - by - value manner : we embedded two steps of @xmath126 into one step of the strategy .",
    "one can then show that if @xmath232 then @xmath233 .    in the light of this reduction strategy and of the monadic lifting of the previous section",
    ", one can now formalize what was mentioned in remark  [ rem : cbv ] .",
    "first , one can turn an abstract machine into a lifted term .",
    "[ def : amlift ] let @xmath234 and let @xmath235 be an abstract machine where @xmath236",
    ". then we define @xmath237 as the term @xmath238\\right )      { { \\langle{\\overline{c},{{\\bf s}}\\,\\overline{\\max({\\rm          range}(l))}}\\rangle}},\\ ] ] where @xmath239 is the representation of @xmath32 as a term of type @xmath216}}\\times{{\\tt wire}}$ ] , and where @xmath240 with @xmath4 an integer is the representation of @xmath4 as a term of type @xmath241}}$ ] .",
    "then , provided that @xmath242 stands for the reflexive , symmetric and transitive closure of the beta - reduction on terms and choosing @xmath85 and @xmath235 as in definition  [ def : amlift ] :    suppose that @xmath232 .",
    "then @xmath243 is beta - equivalent to @xmath244 .",
    "provided that the beta - reduction is confluent , this essentially says that the abstract - machine semantics can be simulated with the monadic lifting .",
    "[ cor ] if @xmath245 and @xmath246 then the term @xmath247 is beta - equivalent to @xmath239 , where @xmath239 is the representation of @xmath32 as a term , as described in definition  [ def : amlift ] .",
    "[ sec : reduc - size - circ ]    a rapid explanation is needed here : in quantum computation , one does not deal with classical bits but with the so - called _",
    "quantum bits_. at the logical level , a quantum algorithm consists of one or several _ quantum circuits _ , that is , reversible circuits with quantum bits flowing in the wires .    quantum algorithms",
    "are used to solve classical problems .",
    "for example : factoring an integer  @xcite , finding an element in a unordered list  @xcite , finding the solution of a system of linear equations  @xcite , finding a triangle in a graph  @xcite , _",
    "etc_. in all of these algorithms , the description of the problem is a completely non - reversible function @xmath10 and it has to be encoded as a reversible circuit computing the function @xmath248 sending @xmath249 to @xmath250 , possibly with some auxiliary wires set back to @xmath9 .",
    "r0.4    @xmath251    a canonical way to produce such a circuit is with a _",
    "bennett embedding_. the procedure is shown on the right .",
    "first the landauer embedding @xmath252 of @xmath253 is applied .",
    "then the output of the circuit is xord onto the @xmath254 input wires , and finally the inverse of @xmath252 is applied . in particular , all the auxiliary wires are back to the value @xmath9 at the end of the computation .",
    "the method we propose in this paper offers a procedure for generating the main ingredient of this construction : the landauer embedding .",
    "one just has to encode the problem in the language @xmath255 ( or extension thereof ) , possibly test and verify the program , and generate a corresponding reversible circuit through the monadic lifting",
    ". theorems  [ th : eq - am - beta ] and  [ cor ] guarantee that the monadic lifting of the program will give a circuit computing the same function as the original program .",
    "this algorithm was implemented within the language quipper , and used for non - trivial oracles  @xcite .",
    "note that quipper is not the only possible back - end for this generic monadic lifting : nothing forbids us to write a back - end in , say , lava  @xcite .",
    "[ ex : addercircuit ] the first example of code we saw ( example  [ ex : adder ] ) computes an adder .",
    "one can run this code to generate a reversible adder : figure  [ fig : adder-4-raw ] shows the circuit generated when fed with 4-bits integers .",
    "one can see 4 blocks of pairs of similar shapes .",
    "[ ex : sin ] in the oracle for the qlsa algorithm  @xcite , one has to solve a system of differential equations coming from some physics problem using finite elements method .",
    "the bottom line is that it involves analytic functions such as sine and atan2 .    using fixed - point real numbers on 64 bits",
    ", we wrote a sine function using a taylor expansion approximation . in total , we get a reversible circuit of 7,344,140 multi - controlled gates ( with positive and negative controls ) .",
    "the function atan2 was defined using the cordic method .",
    "the generated circuit contains 34,599,531 multi - controlled gates .",
    "these two functions can be found in quipper s distribution  @xcite .",
    "the monadic lifting proposed in this paper generates circuits that are efficient in the sense that the size of a generated circuit is linear in the number of steps it takes to evaluate the corresponding program .",
    "this means that any program running in polynomial time upon the size of its input generates a polynomial - sized circuit . without any modification or optimization whatsoever",
    ", the technique is therefore able to generate an `` efficient '' circuit for an arbitrary , conventional algorithm .",
    "this is how the circuit for the function sine cited in example  [ ex : sin ] was generated : first , a conventional implementation was written and tested .",
    "when ready the lifting was performed , generating a circuit .",
    "compared to other reversible compilers  @xcite , the approach taken in this paper considers the construction of the circuit as a process that can be completely automatized : the stance is that it should be possible to take a classical , functional program with conventional inductive datatypes and let the compiler turn it into a reversible circuit without having to interfer ( or only marginally ) .",
    "we do not claim to have a final answer : we only aim at proposing a research path towards such a goal .",
    "a first step towards a more complete compiler for would involve optimization passes on the generated circuits .",
    "indeed , as can be inferred from a quick analysis of figure  [ fig : adder-4-raw ] , if monadic lifting generates efficient circuits it does not produces particularly lean circuits .",
    "there is a rich literature on optimization of reversible circuits  @xcite , some also considering positive and negative controls  @xcite .",
    "all of these works are relevant for reducing the size of the circuits we get .",
    "the purpose of this section is not to aggressively optimize the circuits we get from the monadic lifting , but instead to reason on the particular shapes we obtain from this monadic semantics . if the reduction of a lambda - term into a reversible circuit is so verbose , it is partly due to the fact that garbage wires are created for every single intermediate result .",
    "we aim at pointing out the few optimization rules stemming from the circuit generation and reflecting these low - level optimizations to high - level program transformations .",
    "the reversible adder of figure  [ fig : adder-4-raw ] is very verbose . by applying the simple optimization schemes presented in this section ,",
    "one gets the smaller circuit of figure  [ fig : adder-4-optim ] .",
    "one clearly sees the carry - ripple structure , and it is in fact very close to known reversible ripple - carry adders ( see e.g.  @xcite ) . in the following discussion ,",
    "we hint at how program transformations could be applied in order to get a circuit of compactness similar to the one obtained from the low - level circuit rewrites .",
    "* algebraic optimizations . *   let us consider the example of the 1-bit adder of figure  [ fig : optim ] , from the code of example  [ ex : adder ] .",
    "three simple potential optimizations are highlighted .",
    "in general , these optimizations require to have a knowledge of the value of the bits flowing in the wires ( e.g. dashed box 2 ) . since there are input wires , this information needs to be kept in algebraic form , as a function of the input wires .",
    "of course , for non - trivial circuits this means actually computing the circuit .",
    "however , because of the shape of the generated circuit , instead of a complete algebraic form , for the purpose of circuit simplification it is often enough to keep only partial algebraic information about the wires .",
    "to each piece of wire , we essentially keep a limited knowledge of the past operations .    _ dashed box 1 .",
    "_   gates acting on wires of known constant value .",
    "the gate will never fire as the control will always be negative .",
    "the gate can be removed .",
    "from the perspective of the code the circuit comes from , this situation typically occurs when constant booleans are manipulated , for example with the term @xmath256 .",
    "_ dashed box 2 .",
    "_   copy of one wire to another one .",
    "provided that the controlled wire is never controlled later on , one can remove the gate and move all the controls and gates of the bottom wire to the top wire .",
    "the fact that the wire is not used later on means that the particular intermediate result is never used again : from the point of view of the program it means that this particular result is only used _",
    "linearly_. the typical case where this occurs is in a term such as @xmath257 .",
    "a garbage wire is created to hold the result of the @xmath3 , but this is not needed as this intermediate result is not going to be reused .",
    "instead one can directly apply a not - gate on the result of @xmath258 .",
    "_ dashed box 3 . _   here , @xmath259 .",
    "the two cnots can be replaced with only one connecting wires @xmath260 and @xmath184 , and one could have removed wire @xmath98 altogether .",
    "again , some care must be taken : the new active wire should not be controlled later on ( ruling out wire @xmath260 ) , and the controls and actions of wire @xmath98 should be moved to the new active wire .",
    "this situation can also be understood as a linearity constraint on the program side .",
    "* reduction strategies and garbage wires . *   the call - by - value reduction strategy we follow sometimes computes unused intermediate results , therefore generating gates acting on unused wires .",
    "one can safely discard such gates .",
    "note that the abstract machine is agnostic to the choice of reduction strategy .",
    "in general , depending on the chosen reduction path , the generated circuits do not have the same size and shape .",
    "consider the term @xmath261 a call - by - value reduction strategy first evaluate the argument , and then feeds the output    r0.3    value to the and operator .",
    "since having the same variable @xmath254 means that the two controlling wires collapsed , we get the circuit presented on the right : @xmath262 is the output of the circuit , which is the meaning of the lambda - term .    with a call - by - name strategy , the term instead reduces to the following circuit .",
    "the    r0.45    last wire is the output wire , the other wires are garbage wires .",
    "of course , we get the same result : @xmath263 and @xmath262 are indeed the same boolean value .",
    "however , note that the circuit is different than the one generated by a call - by - value strategy . in general , call - by - name tends to generate larger circuits as arguments are duplicated and evaluated several times .",
    "the case where it is not true is when the argument of a function is not used : in call - by - value , the argument would generate a piece of circuit , whereas in call - by - name , since it would not be evaluated , the argument would leave no trace on the circuit .    0.4        0.4     * optimizations by shuffling .",
    "*   a less obvious circuit modification is to send cnot gates as far as possible to the right , by swapping the order of gates .",
    "this is again a side - effect of the particular shape of the generated circuit .",
    "if it does not decrease the size the circuit , it is able to reveal places where algebraic optimizations can be performed .",
    "for example , consider the circuit in figure  [ fig : shuffling-1 ] .",
    "the two first cnots can be moved to the far right - end , becoming a hidden cnot ( as dashed box 2 of figure  [ fig : optim ] ) : they are merged into one single cnot and the first auxiliary wire is removed .",
    "we get the circuit in figure  [ fig : shuffling-2 ] .",
    "the corresponding program transformation modifies the term @xmath264 to @xmath265 as @xmath266 does not use @xmath7 nor @xmath254 , one of the algebraic optimization might apply .        by applying these optimization schemes on the reversible adder of figure  [ fig : adder-4-raw ] ,",
    "one gets the circuit presented in figure  [ fig : adder-4-optim ] .",
    "one can now clearly see the carry - ripple structure , and it is in fact very close to known reversible ripple - carry adders ( see e.g.  @xcite ) .",
    "these optimizations were implemented in quipper : applied on larger circuits such as the ones of example  [ ex : sin ] , we get in general a size reduction by a factor of 10 .",
    "in this paper , we presented a simple and scalable mechanism to turn a higher - order program acting on booleans into into a family of reversible circuits using a monadic semantics .",
    "the main feature of this encoding is that an automatically - generated circuit is guaranteed to perform the same computation as the original program .",
    "the classical description we used is a small pcf - like language , but it is clear from the presentation that another choice of language can be made . in particular ,",
    "an interesting question is whether it is possible to use a language with a stronger type system for proving properties of the encoded functions .",
    "a second avenue of research is the question of the parallelization of the generated circuits .",
    "the circuits we produce are so far completely linear . following the approach in  @xcite , using parallel higher - order language",
    "might allow one to get parallel reversible circuits , therefore generating circuits with smaller depths .",
    "finally , the last avenue for research is the design of generic compiler with a dedicated code optimizations .",
    "indeed , an analysis of the specific optimizations described in section  [ sec : optim ] suggests that these could be designed at the level of code , therefore automatically generating leaner circuits up front .",
    "this opens the door to the design of specific type systems and code manipulations in a future full compiler . and back - end , specific circuit optimizations ."
  ],
  "abstract_text": [
    "<S> boolean reversible circuits are boolean circuits made of reversible elementary gates . despite their constrained form </S>",
    "<S> , they can simulate any boolean function . </S>",
    "<S> the synthesis and validation of a reversible circuit simulating a given function is a difficult problem . in 1973 , </S>",
    "<S> bennett proposed to generate reversible circuits from traces of execution of turing machines . in this paper </S>",
    "<S> , we propose a novel presentation of this approach , adapted to higher - order programs . starting with a pcf - like language </S>",
    "<S> , we use a monadic representation of the trace of execution to turn a regular boolean program into a circuit - generating code . </S>",
    "<S> we show that a circuit traced out of a program computes the same boolean function as the original program . </S>",
    "<S> this technique has been successfully applied to generate large oracles with the quantum programming language quipper . </S>"
  ]
}