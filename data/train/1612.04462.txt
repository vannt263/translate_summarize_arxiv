{
  "article_text": [
    "we investigate the synchronization of finite state automata focussing on the class of deterministic planar automata . a finite state automaton is planar , if and only if , its transition digraph is planar .",
    "planar automata have been previously studied , and it is known that there are regular languages which can not be recognized by deterministic planar automata @xcite .",
    "this last fact indicates that the class of planar automata is not universal with respect to the recognition power of finite automata .",
    "however , we conjecture that this restricted class is universal with respect to the hardness of synchronization .",
    "this conjecture motivates us to study the synchronization of planar automata . to begin with , we study the algorithmic complexity of some synchronization problems for planar and nonplanar automata .",
    "( @xmath12 \\mathbf{:}$ ] optimal synchronization of planar automata )    * input : @xmath13 , where @xmath0 is a synchronizing planar automaton and @xmath14 is a positive integer . *",
    "problem : decide if there exists a synchronizing string for @xmath15 whose length is upperbounded by @xmath16    the problem @xmath12 $ ] is np complete .",
    "eppstein @xcite proved there exists a ptime algorithm , which , on input @xmath17 ( where @xmath18 is a cnf ) computes a pair @xmath19 , such that @xmath20 is a synchronizing automaton satisfying the following two conditions :    1 .",
    "if @xmath18 is satisfiable there exists a reset word for @xmath21 , whose length is upperbounded by @xmath22 2 .",
    "if @xmath18 is not satisfiable the length of the minimal reset words for @xmath20 is equal to @xmath23    one can easily check that for all @xmath24 the automaton @xmath21 is planar .",
    "thus , we have that set of outputs of eppstein s reduction is included in the class of planar synchronizing automata , and it implies that sat is ptime reducible to @xmath25 $ ] .",
    "thus , we have that @xmath25 $ ] is np hard .",
    "it is easy to check that @xmath26 $ ] belongs to np    it was fairly easy to prove that @xmath25 $ ] is np complete , we just noticed that all the gadgets used in eppstein s proof are planar .",
    "a similar fact will happen more than once in this work : we get the hardness result for planar automata by noticing that the proof for general automata works verbatim in the planar framework .",
    "how hard is the problem of approximating the minimal reset length of an automaton ?",
    "first , we observe that eppstein s greedy algorithm @xcite is a ptime approximation algorithm of ratio @xmath27 , and it is clear that it must work as well when one restricts its execution to planar synchronizing automata .",
    "it is natural to ask : which is the best approximation ratio that can be achieved in polynomial time ?    given @xmath28 it is np hard to approximate the minimal reset length of planar automata within the ratio @xmath29    gawrychowski and straszak @xcite proved that for all @xmath28 it is np hard to approximate the minimal reset length of general synchronizing automata within the ratio @xmath30 once again , it is enough to check that the proof of gawrychowski and straszak works for planar automata .",
    "thus , we have that the best approximation ratio that can be achieved in polynomial time is the ratio @xmath31 which is achieved by eppstein algorithm . moreover , the claim is true for planar and general synchronizing automata .",
    "it is worth to remark that the computation of minimal reset lengths is not a typical np computation , given that minimality corresponds to an universal assertion instead of an existential assertion .",
    "then , it can not be said that the np completeness of @xmath32 characterizes the intrinsic hardness of computing minimal reset lengths and minimal synchronizing strings .",
    "this observation motivates the study of a second algorithmic problem , denoted by @xmath33 $ ] and defined by :    ( @xmath34 : $ ] deciding minimal reset length )    * _ input : _",
    "@xmath13 _ _ , where _ _ @xmath35 _ _  is a synchronizing planar automaton and _ _",
    "@xmath14__is a positive integer .",
    "_ _ * _ problem : decide if the minimal reset length of _ @xmath0 _",
    "_  is equal to _ _",
    "@xmath16    let dp be the closure under finite intersections of the class np@xmath36co - np , we prove that @xmath34 $ ] is complete for dp .",
    "olschewski and ummels proved that @xmath34 $ ] is complete for dp ( see reference @xcite ) .",
    "our result is , once again , an easy consequence of the nonplanar result ( with its proof ) , but this time we have to work a little bit .    @xmath34 $ ] is complete for dp .    as remarked before olschewski and ummels proved that @xmath37 is complete for dp@xmath38 to this end , they exhibited a ptime reduction of the problem sat - unsat in the problem @xmath39 recall that sat - unsat is the problem defined by :    * _ input : _",
    "@xmath40 _ _ , where _ _ @xmath17 _ _  and _ _ @xmath41 _ _  are boolean formulas in conjunctive normal form . _",
    "_ * _ problem : decide if _ @xmath18 _ _  is satisfiable and _ _",
    "@xmath42 _ _  is unsatisfiable .",
    "_ _        it is known that the later problem is dp complete , and hence the reduction of olschewski and ummels suffices .",
    "given @xmath43 and @xmath44 , the aforementioned reduction allows one to compute a pair @xmath45 such that :    * if @xmath18 and @xmath41 are satisfiable , then the minimal reset length of @xmath46 is equal to @xmath47 * if @xmath18 is satisfiable and @xmath41 is unsatisfiable , then the minimal reset length of @xmath0 is equal to @xmath48 * if @xmath18 is unsatisfiable , then the minimal reset length of @xmath49 is equal to @xmath50    the automaton @xmath46 is defined as follows :    we suppose , without loss of generality , that @xmath18 and @xmath41 have the same number @xmath51 of clauses , and no propositional variable occurs in both @xmath17 and @xmath41 .",
    "let @xmath52 and @xmath53 the automaton @xmath54 consists of the states @xmath55 and @xmath56 , where @xmath57 and @xmath58 the transitions are depicted in figure 1 .",
    "an edge from @xmath59 to @xmath60 labelled with @xmath61 has the meaning that @xmath62 for all @xmath63 the sets @xmath64 are defined by @xmath65 and @xmath66 and the sets @xmath67 are defined by @xmath68 and @xmath69    it can be observed that @xmath46 is not always a planar automaton .",
    "however , such a construction can be slightly modified in order to obtain a planar automaton @xmath70 satisfying the above three conditions .",
    "a possible modification consists in eliminating the nodes @xmath71 and @xmath72 and replacing them with the set of nodes@xmath73    moreover , for each @xmath74 we set@xmath75    it is easy to check that the automaton so defined , which we denote with symbol @xmath70 , is a planar automaton satisfying the same three conditions satisfied by @xmath76 .",
    "thus , we have a ptime reduction of sat - unsat in the problem @xmath77 , $ ] and hence we can conclude that the later problem is complete for dp .",
    "olschewski and ummels also proved that the problem of computing the minimal reset length of a given synchronizing automaton is complete for the class @xmath78 } $ ] @xcite .",
    "it can be checked that their proof can be used ( verbatim ) to show that computing the minimal reset length of planar automata is complete for the same class of functions .      in this section",
    "we add a further hardness result to the above list .",
    "this time we have to work hard , because we have to prove first the corresponding nonplanar result , which characterizes the parameterized complexity of _ subset synchronization .",
    "we refer the reader to @xcite for a pedagogical introduction to the basics of parameterized complexity .",
    "given an automaton @xmath0 , and given @xmath79 , a synchronizing string for those @xmath14 states , is a string @xmath80 such that for all @xmath81 , the equality @xmath82holds .",
    "in the later case we say that @xmath83 synchronizes the subset @xmath84    we think that subset synchronization is a powerful concept that allows one to model some interesting discrete dynamics .",
    "suppose , for instance , that one has a troop of agents scattered over a territory , and that he wants to broadcast an instruction , the same one for all the agents , which must lead the agents to a common site on the territory .",
    "if the territory is the transition digraph of a synchronizing automaton , and he does not know the initial locations of  the agents , then he must broadcast a reset word for the underlying automaton . on the other hand ,",
    "if he knows the initial locations @xmath85 , then he must broadcast a synchronizing string for these @xmath14 states .",
    "a second dynamics refers a class of games on checkerboards .",
    "suppose one has a set of tokens scattered over checkerboard .",
    "each time he chooses an available action , it determines the way in which he must move each one of his tokens .",
    "tokens that arrive to the same site are stacked .",
    "the goal is to gather all the tokens into a single stack using as few actions as possible .",
    "notice that if the transition digraph defined by the checkerboard together with the set of allowed actions defines the transition digraph of an automaton , say @xmath0 , then the goal of this game corresponds to synchronize the states of @xmath0 that were occupied by tokens at time @xmath86    notice that , in the above two situations , one is interested in computing minimal synchronizing strings for the set of occupied states .",
    "we consider that planar automata are natural scenarios for the most representative instances of those two problems : on one hand , it can be argued that planar digraphs , which are the discrete versions of the surfaces of genus @xmath87 are natural discrete models of territories . and , on the other hand , most checkerboards are planar .",
    "first , we consider the case where the number of states to be synchronized is upperbounded by a fixed constant .",
    "we use the symbol @xmath14**-**@xmath88 to denote the problem .",
    "( @xmath14-@xmath89 synchronization of @xmath14-tuples@xmath90    * _ input : _",
    "_ where  _ _ @xmath0 _ is a synchronizing automaton , _",
    "@xmath92 _ and _ @xmath93 * _ problem : compute a synchronizing string of minimal length for the states _",
    "@xmath94    given @xmath95 it is easy to show that the problem @xmath14-@xmath88 can be solved in polynomial time .",
    "@xmath14-@xmath88 can be solved in time @xmath96    let @xmath97 be an instance of @xmath14-@xmath98 consider the @xmath14__-power automaton _",
    "_ @xmath99 defined by :    * @xmath100 ( the @xmath59@xmath101 are not necessarily pairwise different ) . * given @xmath102 , the equality@xmath103holds@xmath38    computing a minimal synchronizing string for states @xmath104 is the same as computing a minimal path in @xmath105 connecting the state @xmath106 with the set @xmath107 . the later problem can be solved in time @xmath108    notice that , when estimating the running time of the above algorithm , the parameter @xmath14 occurs in the exponent . what does it happens if the parameter @xmath109 is not fixed ?",
    "let @xmath59-@xmath25 $ ] be the parameterized problem defined by :    ( @xmath59-@xmath110 : $ ] parameterized synchronization of planar automata )    * _ input : _",
    "_ where  _ _ @xmath0 _ is a synchronizing planar automaton and _ _ _  _ _ @xmath112_. _ * _ parameter : _",
    "@xmath16 * _ problem : decide if there exists a synchronizing string of length _",
    "@xmath113 _ for the states _",
    "@xmath114    recall that a parameterized problem is fix parameter tractable , if and only if , it can be solved in time @xmath115 , for some function @xmath116 and some constant @xmath117 ( see reference @xcite ) .",
    "is @xmath59-@xmath25 $ ] _ fix parameter tractable _ ?",
    "we prove that the problem @xmath59-@xmath25 $ ] is @xmath118 complete .",
    "the class @xmath118 is supposed to be the parameterized analogue of  pspace @xcite .",
    "this class is located above of the w - hierarchy , and hence our result implies that @xmath59-@xmath119 $ ] is w@xmath120 $ ] hard for all @xmath121 .  the class @xmath118 is defined as the closure under _ fpt - reductions  _ ( see reference @xcite ) of the following problem .",
    "( @xmath59-@xmath122 deciding acceptance of parameterized space bounded computations )    * _ input : _",
    "@xmath123 , _ where @xmath35 is a nondeterministic turing machine , _ @xmath124 _ _  is a positive integer given in unary , and _ _ @xmath125 * _ parameter : _ @xmath16 * _ problem : decides if _",
    "_ accepts the empty input in at most _",
    "@xmath124 _ steps and checking at most _ @xmath14 _",
    "cells_.    given a parameterized problem @xmath126 , if one wants to check that @xmath126 belongs to @xmath118 , it is enough to exhibit a nondeterministic ram accepting the language @xmath127 and such that the number of registers it uses along the computation , on input @xmath128 is bounded above by a quantity that only depends on the parameter of @xmath129 ( see @xcite ) .",
    "we prove that @xmath59-@xmath25 $ ] is @xmath118 hard by exhibiting an fpt turing reduction of _ the parameterized longest common subsequence problem _ in @xmath59-@xmath25 .$ ] the _ _  _ _ parameterized longest common subsequence problem , denoted by @xmath59-@xmath130 , is the parameterized problem defined by :    ( @xmath59-@xmath131 parameterized longest common subsequence )    * _ input : _",
    "_ where  _ _ @xmath133 _ is a finite alphabet _",
    ", @xmath134 _ _  and _ _ @xmath135 _ is a positive integer . _ * _ parameter : _ @xmath14 * _ problem : decide if there exists a string _ @xmath136 , _ such that for all _ @xmath137 _ string _ @xmath83 _ is a substring of _",
    "@xmath138 , _ and such that _",
    "guillemot @xcite proved that @xmath59-@xmath140 is hard for @xmath118 .",
    "[ teo]the problems @xmath59-@xmath25 $ ] and @xmath59-@xmath88 are @xmath118 complete .",
    "first , we check that @xmath59-@xmath88 belongs to @xmath118 . to this end",
    ", we construct a suitable nondeterministic ram accepting the problem @xmath59-@xmath141 the machine works , on input , @xmath142 as follows :    the machine stores in the first @xmath14 registers a tuple of positive integers @xmath143 , such that for all @xmath137 the inequality @xmath144 holds .",
    "it begins with @xmath145 , and then it overwrites @xmath146 .",
    "set @xmath147 for all @xmath148 the machine nondeterministically chooses a tuple @xmath149 , which can ( over)writes on the first @xmath14 registers , if and only if , there exists @xmath74 such that @xmath150 .",
    "the machine accepts if and only if the entries of the last tuple are all equal .",
    "now , we prove the @xmath118 hardness of @xmath59-@xmath25 $ ] and @xmath59-@xmath151 .",
    "first , we prove that @xmath59-@xmath140 is @xmath152 many - one reducible to @xmath59-@xmath151 , and hence we prove that @xmath59-@xmath88 is @xmath152 turing reducible to @xmath59-@xmath25 .$ ] the later reduction is given as the composition of two reductions . the first one is a @xmath152 many - one reduction of the problem @xmath153-@xmath88 in the problem @xmath59-@xmath154 $ ] , which is the restriction of @xmath59-@xmath88 to binary automata ( automata whose input alphabet has size 2)@xmath38 the second one is a @xmath152 many - one reduction of @xmath59-@xmath155 $ ] in @xmath59-@xmath25 .$ ]    * first stage * ( _ reducing _ @xmath59-@xmath140 _ to _ @xmath59-@xmath88)*. *    let @xmath156 be an instance of @xmath59-@xmath140 .",
    "given @xmath157 we use baeza - yates construction(see @xcite ) to compute a dfa , say @xmath158 , that accepts the language constituted by all the subsequences of @xmath159 it is important to remark that the size of @xmath158 is bounded above by @xmath160 .",
    "notice that for all @xmath157 we are using the automaton @xmath158 as a language acceptor , it implies that for all @xmath137 , there exists a marked state ( the initial state of @xmath158 ) which we denote with the symbol @xmath161 moreover , for all @xmath157 there exists a nonempty subset of @xmath162 , denoted with the symbol @xmath163 , and which is equal to the set of accepting states of automaton @xmath158 .",
    "we use the set @xmath164 to define an automaton @xmath165 in the following way :    1 .",
    "@xmath166 , where @xmath167 2 .",
    "@xmath168 , where @xmath169 denotes disjoint union , and given @xmath157 the symbol @xmath162 denotes the set of states of the automaton @xmath170 moreover , we have that @xmath171 .",
    "3 .   the transition function of @xmath0 , which we denote with the symbol @xmath172 is defined as follows@xmath173    let @xmath174 be equal to @xmath175 , we have that @xmath176 it is the output of the first reduction .",
    "it is easy to check that @xmath177-@xmath140 , if and only if , the states @xmath178 can be synchronized in time @xmath179 that is : it can be easily checked that @xmath177-@xmath180 if and only if , @xmath181-@xmath88 .",
    "unfortunately , it happens that baeza - yates construction is nonplanar , and hence if @xmath174 is equal to @xmath182 it could occur that the automaton @xmath0 is a nonplanar one . therefore , we have to proceed with the second reduction . +",
    "* second stage * ( _ reducing _",
    "@xmath59-@xmath88 _ to _",
    "@xmath59-@xmath26 $ ] )    let @xmath59-@xmath154 $ ] be the restriction of @xmath59-@xmath88 to the set of instances@xmath183    the construction used in @xcite yields a @xmath152 many - one reduction of the problem @xmath59-@xmath88 in its restriction @xmath59-@xmath154 $ ] .",
    "now , we will exhibit a @xmath152 turing reduction of the problem @xmath59-@xmath184 $ ] in the problem @xmath59-@xmath25 $ ] .",
    "let @xmath185 be an instance of @xmath59-@xmath154 .$ ] a planar drawing of the automaton @xmath35 is an embedding in @xmath186 of its transition digraph , and which satisfies the following three properties :    * edges are mapped on simple curves . *",
    "no three edges meet at a common crossing . *",
    "two edges meet at most once .",
    "planar drawings can be computed in polynomial time , and if the automaton @xmath35 is a planar one hence its planar drawing can be chosen to be a planar embedding .",
    "suppose that @xmath0 is nonplanar , and let @xmath187 be a planar drawing of @xmath0 .",
    "given @xmath188 an edge ( transition ) of @xmath35 , we use the symbol @xmath189 to denote the number of crossings involving edge @xmath190 notice that for all @xmath187 and for all @xmath188 the inequality @xmath191 holds .    to begin with the reduction we compute a planar drawing of @xmath0 ,",
    "say @xmath187 , and we use @xmath187 to compute a planar automaton @xmath192 .",
    "the computation of @xmath192 goes as follows :    1 .",
    "let @xmath193 be the input alphabet of @xmath0 , the input alphabet of @xmath192 is equal to @xmath194 2 .",
    "let @xmath188 be an edge of @xmath0 , and suppose that @xmath188 is labeled with the letter @xmath195 .",
    "we partition @xmath196 into @xmath197 disjoint segments .",
    "the idea is to built @xmath197  gadgets that are used to eliminate the crossings involving @xmath198 .",
    "the segments can be chosen to be connected , with a nonempty interior , and such that each crossing is an inner point of one of those intervals .",
    "moreover , we can choose the @xmath199 segments in such a way that each one of them contains at most one crossing .",
    "the gadgets are extremely simple : + suppose that @xmath188 is directed from @xmath59 to @xmath200 we observe that each one of the @xmath199 segments has a first point ( the closest to @xmath201)@xmath38 given @xmath202 , we choose four points in the @xmath203th segment@xmath38 let @xmath204 and @xmath205 be those four points , we have that @xmath206 is equal to the first point of the segment , point @xmath207 lies between @xmath206 and @xmath208 , while @xmath209 lies between @xmath207 and @xmath205 .",
    "moreover , the point @xmath205 is different to the first point of the @xmath210th segment . if @xmath211 we have that @xmath212 . if @xmath213 we set @xmath214 .",
    "let @xmath215 , notice that the @xmath203th segment has been divided into four subsegments @xmath216 and @xmath217 .",
    "given @xmath218 , the edge @xmath219 is directed from @xmath220 to @xmath221 , while the edge @xmath222 is directed from @xmath205 to @xmath223 .",
    "moreover , we assign to those four edges the labels @xmath224 and @xmath225 ( respectively ) .",
    "3 .   now suppose that edges @xmath188 and @xmath116 meet at some point @xmath226 .",
    "there exists @xmath227 such that @xmath226 lies on the @xmath203th segment of @xmath228 and it also lies on the @xmath229th segment of @xmath230 we can choose the points @xmath231 and @xmath205 , and the points @xmath232 and @xmath233 in such a way that : * the equalities @xmath234 and @xmath235 hold . *",
    "the point @xmath226 lies between @xmath208 and @xmath205 + notice that the construction is somewhat asymmetrical .",
    "however , it does not matter : given two edges that cross each other at some point @xmath236 it makes not difference which edge plays the role of edge @xmath188 and which one plays the role of edge @xmath230 + suppose that @xmath116 is labeled with the letter @xmath237 , and suppose that @xmath238 , in this case the elimination of the crossing looks as follows + if @xmath239 we merge the two parallel edges going from @xmath208 ( @xmath240 ) to @xmath205 ( @xmath241 ) , and which are labeled with the letter @xmath242 4 .",
    "we are trying to draw a planar automaton @xmath192 . to this end",
    ", we use the set of points@xmath243and the set of edges@xmath244and we add some loops : if @xmath245 , and there is not an outgoing edge labeled with the letter @xmath246 we add a loop with this label attached to this node .",
    "it is easy to check that @xmath192 is a planar synchronizing automaton , which can be computed in polynomial time from automaton @xmath0 .",
    "notice that the construction of @xmath192 does not depend on the pair @xmath247    let @xmath248 and let @xmath59 be an state of @xmath0 , we use the symbol @xmath249 to denote the planar automaton that is obtained from @xmath250 by attaching to node @xmath251 a planar digraph that we call @xmath252 the gadget @xmath253 is computed from @xmath135 and @xmath254 , and it is used as a clock for the synchronization process .",
    "the construction of @xmath253 goes as follows :    we begin with a set @xmath255 which is equal to @xmath256    then , for all @xmath257 we identify the points @xmath258 and @xmath259 given @xmath215 and given @xmath260 we add the edges @xmath261 and @xmath262 and we label them with the letter @xmath263 .",
    "we also add the edges @xmath264 and @xmath265 , and we label them with the letter @xmath266 we set @xmath267 if @xmath268 , we add the edges @xmath269 and we label them with the letter @xmath270 moreover , for all @xmath271 we add an edge @xmath272 labeled with the letter @xmath273 finally , we add the necessary loops in order to get a planar automaton , this planar automaton ( its transition digraph ) is the clock @xmath274 .    given the node @xmath251 , we embed @xmath253 in the plane in such a way that the following two conditions are satisfied :    1 .",
    "@xmath275 2 .",
    "there are not crossings between the edges of @xmath253 and the edges of @xmath192 .",
    "then , we remove the loops that were attached to @xmath276 in order to get a deterministic planar synchronizing automaton that we denote with the symbol @xmath277 .",
    "we observe that if a token is placed on state @xmath278 then one can move this token to the state @xmath251 by using a string of length @xmath279 the quantity @xmath280 is the length of the shortest strings satisfying the equality @xmath281    moreover , if the string @xmath282 satisfies the above equality , there exist @xmath283 such that @xmath284 and for all @xmath285 the factor @xmath286 satisfies the equality@xmath287for some @xmath288 that is , given @xmath289 , the homomorphism defined by@xmath290it happens that @xmath129 is a minimal string satisfying the equality@xmath291if and only if , there exists @xmath292 such that @xmath293 this property of @xmath253 allows us to use it as a clock : if one wants to synchronize the states @xmath294 in less than @xmath295 steps , then he must try to move all those states to @xmath296 , and to this end he has to use a string in the range of the homomorphism @xmath116 .",
    "we use this fact to avoid that some token being synchronized uses the crossing - gadgets to leave an edge of @xmath0 that it has not fully traversed , recall that the edges of @xmath0 were partitioned in many different segments ( subedges ) .    given the automaton @xmath0 and given @xmath297 , we use the symbol @xmath298 to denote the tuple@xmath299    it is easy to check that the set @xmath300 can be synchronized in time @xmath135 , if and only if , there exists @xmath59 such that the states @xmath301 of the automaton @xmath302 can be synchronized in time @xmath303 .",
    "thus , we have the claimed @xmath152 turing reduction of @xmath59-@xmath154 $ ] in @xmath59-@xmath25 , $ ] and hence we have that @xmath59-@xmath25 $ ] is @xmath118 hard .",
    "it is worth to remark that the above reduction shows that @xmath59-@xmath304 $ ] is @xmath118 hard .",
    "we use the symbol @xmath59-@xmath305 $ ] to denote the restriction of @xmath59-@xmath25 $ ] to the class of automata defined over a four letter alphabet .",
    "given @xmath306 $ ] , one of the algorithmic problems studied so far , we use the symbol @xmath126 to denote its unrestricted ( nonplanar ) version , i.e. symbol @xmath126 denotes the algorithmic problem that is obtained from @xmath307 $ ] by flipping the planarity constraint .",
    "let us summarize all the above results with the following table    @xmath308 $ & $ esynch\\left [ p\\right ] $ & approx .",
    "ratio of $ synch% \\left [ p\\right ] $ & $ \\ \\ p$-$synch\\left [ p\\right ] $ \\\\ \\hline np complete & dp complete & \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ $ \\ \\ \\ \\ o\\left ( n\\right )",
    "$ & $ nwl$ complete \\\\ \\hline $ synch$ & $ esynch$ & \\ approx . ratio of $ synch$ & $ \\ \\ \\ \\ p$-$synch$ \\\\",
    "\\hline np complete & dp complete & $ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ o\\left ( n\\right ) $ & $ nwl$ complete \\\\",
    "\\hline \\end{tabular}%\\ ] ]    the above table seems to indicate that the class of planar automata is universal with respect to the algorithmic complexity of synchronization . perhaps , the only issue that remains to be analyzed is the parameterized approximability of subset synchronization .",
    "we say that @xmath59-@xmath88 is _ fpt approximable within the ratio _",
    "@xmath309 if and only if , there exists an @xmath152 algorithm , which , on input @xmath310 , outputs an integer @xmath124 such that if @xmath311 is the minimal reset length of the states @xmath312 then the inequalities@xmath313hold",
    ".    it follows from the work of gerbush and heeringa that @xmath59-@xmath88 is fpt approximable within the ratio @xmath314 ( see @xcite ) .",
    "it is natural to ask : which are the approximation ratios that can achieved in fpt time ? which are the approximation ratios that can achieved in fpt time for planar automata ?",
    "we think that those two questions are the questions that remain to be solved , and that are related to the algorithmic complexity of synchronizing planar and nonplanar automata .",
    "we observe that subset synchronization makes sense for nonsynchronizing automata .",
    "it is easy to check that for all @xmath315 the synchronizing times of the hardest @xmath14-tuples of states is @xmath316 ( see @xcite ) . synchronizing times of order @xmath316 are achieved by sequences of nonsynchronizing automata ( an upper bound @xmath317 holds for synchronizing automata ) .",
    "it is also easy to check that for all @xmath315 there exist sequences of planar automata achieving those worst synchronizing times of order @xmath318 .",
    "thus , we have that the slowest nonsynchronizing automata are planar .",
    "we conjecture that an analogous fact holds for the synchronization of all the states ( whenever it is possible ) : the slowest synchronizing automata are planar automata .",
    "the hardness of a class of synchronizing automata can be measured in many different ways , we propose two different hardness measures :      according to the first measure , the class of planar synchronizing automata is as hard as the class constituted by all the synchronizing automata .",
    "we conjecture that the same is true for the second measure .    _ the weak erny conjecture _",
    "is the conjecture claiming that there exists a quadratic polynomial @xmath319 such that the synchronizing time of any synchronizing automata with @xmath51 states is upperbounded by @xmath320 .",
    "erny s conjecture claims that @xmath321 can be taken equal to @xmath322    [ conjecture - universal]given @xmath323 , if there exists a sequence of synchronizing automata whose synchronizing time is @xmath324 , then there must exist a sequence of planar synchronizing automata whose synchronizing time is @xmath325 .",
    "we notice that our conjecture implies that the weak erny conjecture is true , if and only if , it holds true for planar synchronizing automata . in order to prove the above conjecture one can try a construction similar to the used in the proof of theorem [ teo ] .",
    "let @xmath0 be a given nonplanar automaton , and let @xmath192 be the output of the aforementioned construction .",
    "we have that @xmath326 , where @xmath51 is the size of @xmath0 .",
    "thus , the reset length of @xmath192 is large provided that the reset length of @xmath0 is large .",
    "the problem is that the size of @xmath327 is quadratic with respect to the size of @xmath0 .",
    "our construction does not work because of this quadratic blow - up .",
    "it could work if we could restrict its application to sequences of automata of bounded genus . in this later case",
    "we would have to use smaller clocks , clocks whose sizes are linearly related to the sizes of the automata given as input .",
    "we notice that from a naive point of view our conjecture must be true : planarity is a constraint that makes harder the movement of tokens trough the digraph .",
    "this naive observation was an additional motivation for our conjecture , which asserts that the worst synchronizing times are achieved by planar automata .",
    "we have some further reasons to consider that it is a likely conjecture :    * as remarked before , all the sequences of slowly synchronizing automata registered in the literature are sequences of planar automata .",
    "thus , the slowest synchronizing automata registered in the literature are planar automata . *",
    "as it was remarked at the end of last section , the slowest nonsynchronizing automata are planar ."
  ],
  "abstract_text": [
    "<S> planar automata seems to be representative of the synchronizing behavior of deterministic finite state automata . </S>",
    "<S> we conjecture that erny s conjecture holds true , if and only if , it holds true for planar automata . in this paper </S>",
    "<S> we have gathered some evidence concerning this conjecture . </S>",
    "<S> this evidence  amounts to show that the class of planar automata is representative of the algorithmic hardness of synchronization    this work is related to the synchronization of deterministic finite state automata ( dfas , for short ) .    </S>",
    "<S> let @xmath0 be a dfa , and let @xmath1 be its input alphabet , we use the symbol @xmath2 to denote the set of finite strings over the alphabet @xmath1 . </S>",
    "<S> the function @xmath3 is defined by the equation:@xmath4where @xmath5 is the transition function of @xmath0 .    </S>",
    "<S> a _ synchronizing string _ ( _ reset word _ ) for @xmath0 , is a string @xmath6 such that for all @xmath7 the equality @xmath8holds    we say that automaton @xmath0 is _ synchronizing , _ if and only if , there exists a synchronizing string for @xmath0 . </S>",
    "<S> let @xmath0 be a synchronizing automaton , its _ minimal reset length _ </S>",
    "<S> , denoted by @xmath9 , is the length of its minimal synchronizing strings . </S>",
    "<S> it is easy to prove that @xmath10 erny @xcite conjectured that @xmath11 this conjecture is called _ </S>",
    "<S> erny s conjecture _ , and it is considered the most important open problem in the combinatorial theory of finite state automata .    * the universality conjecture for planar automata . * it is well known that if erny s conjecture holds true for strongly connected automata , then it holds true for all the deterministic finite state automata . </S>",
    "<S> therefore , we say that the class of strongly connected automata is _ </S>",
    "<S> universal_. we conjecture that the same is true of the class of planar automata .    </S>",
    "<S> let us discuss some of the facts that led us to formulate the _ universality conjecture _ for planar automata__. _ _    we are interested in some algorithmic problems related to dfa - synchronization . </S>",
    "<S> it happens that the algorithmic complexity of those problems is well understood , and there are many deep results characterizing their intrinsic hardness @xcite , @xcite , @xcite . </S>",
    "<S> it can be noticed that all those hardness proofs work well for the planar restrictions of the problems . </S>",
    "<S> then , we have that the planar restrictions of those problems are as hard as the unrestricted versions . </S>",
    "<S> it means that the class of planar automata is an _ universal class _ with respect to the algorithmic hardness of synchronization .    </S>",
    "<S> it can be checked that all the sequences of slowly synchronizing automata registered in the literature are sequences of planar automata ( see reference @xcite ) . at his point , it is important to remark that it is fairly easy to transform a planar sequence of slowly synchronizing automata into a nonplanar sequence with the same synchronizing behavior , and then it follows that there exist nonplanar sequences of slowly synchronizing automata . </S>",
    "<S> however , it seems that all the sequences of slowly synchronizing automata can be obtained this way : by locally perturbing a sequence of slowly synchronizing planar automata . notice that if the last assertion is true , all the automata that could refute erny s conjecture are _ essentially planar_.    the above two observations are the origin of the conjecture . by the way we have found some additional evidence in favor of it . </S>",
    "<S> the goal of this work is to discuss  in more detail those old and new facts .    </S>",
    "<S> * organization of the work and contributions . </S>",
    "<S> * this work is organized into two sections , in section 1 we characterize the algorithmic hardness of some synchronization problems related to planar automata and we show that those problems are as hard as the nonplanar versions . those results amount to show that the class of planar automata is universal with respect to the hardness of synchronization . </S>",
    "<S> we finish in section 2 with some concluding remarks . </S>"
  ]
}