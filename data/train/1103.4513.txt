{
  "article_text": [
    "imagine a computing device with very limited powers . what is the simplest computational problem you could ask it to solve ?",
    "it is not the addition of two numbers , nor sorting , nor string matching  it is telling two inputs apart : distinguishing them in some way .",
    "take as our computational model the deterministic finite automaton or dfa . as usual , it consists of a @xmath1-tuple , @xmath2 , where @xmath3 is a finite nonempty set of states , @xmath4 is a nonempty input alphabet , @xmath5 is the transition function ( assumed to be _ complete _ , or defined on all members of its domain ) , @xmath6 is the initial state , and @xmath7 is a set of final states .",
    "we say that a dfa @xmath8 _ separates _",
    "@xmath9 and @xmath10 if @xmath8 accepts one but rejects the other . given two distinct words",
    "@xmath11 we let @xmath12 be the number of states in the smallest dfa accepting @xmath9 and rejecting @xmath10 .",
    "for example , the dfa below separates @xmath13 from @xmath14 .",
    "[ data140 ]    however , by a brief computation , we see that no @xmath15-state dfa can separate these two words .",
    "so @xmath16 .",
    "note that @xmath17 , because the language of a dfa can be complemented by swapping the reject and accept states .",
    "we let @xmath18 .",
    "the _ separating words problem _ is to determine good upper and lower bounds on @xmath19 .",
    "this problem was introduced 25 years ago by goralk and koubek , who proved @xmath20 .",
    "it was later studied by robson @xcite , who obtained the best upper bound so far : @xmath21 .    as an additional motivation",
    ", the separating words problem can be viewed as an inverse of a classical problem from the early days of automata theory : given two dfas accepting different languages , what length of word suffices to distinguish them ?",
    "more precisely , given two dfas @xmath22 and @xmath23 , with @xmath24 and @xmath25 states , respectively , with @xmath26 , what is a good bound on the length of the shortest word accepted by one but not the other ?",
    "the usual cross - product construction quickly gives an upper bound of @xmath27 ( make a dfa for @xmath28 ) .",
    "but the optimal upper bound of @xmath29 follows from the usual algorithm for minimizing automata .",
    "furthermore , this bound is best possible ( * ? ? ?",
    "* thm.3.10.6 ) . for nfas",
    "the bound is exponential in @xmath24 and @xmath25 @xcite .    from the following result , already proved by goralk and koubek , we know that the hard case of word separation comes from words of equal length :    suppose @xmath30 and @xmath31",
    ". then @xmath32 .",
    "furthermore , there is an infinite class of examples where @xmath33 .",
    "[ one ]    we use the following lemma :    if @xmath34 and @xmath35 , then there is a prime @xmath36 such that @xmath37 .",
    "[ pnt ]    ( of proposition [ one ] ) if @xmath31 , then by lemma  [ pnt ] there exists a prime @xmath36 such that @xmath38 .",
    "hence a simple cycle of @xmath39 states serves to distinguish @xmath9 from @xmath10 .    on the other hand",
    ", no dfa with @xmath25 states can distinguish @xmath40 to see this , let @xmath41 for @xmath42 .",
    "then @xmath43 is ultimately periodic with period @xmath0 and preperiod at most @xmath44 .",
    "thus @xmath45 .",
    "since @xmath46 by the prime number theorem , the @xmath47 lower bound follows .    as an example , suppose @xmath48 and @xmath49 .",
    "then @xmath50 and @xmath51 .",
    "so we can accept @xmath9 and reject @xmath10 with a dfa that uses a cycle of size @xmath52 , as follows :    cycle1.pstex_t    [ cycle1 ]    in what follows , then , we only consider the case of equal - length words , and we redefine @xmath53 .",
    "the goal of the paper is to survey what is known and unknown , and to examine some variations on the original problem .",
    "our main new results are theorems  [ hamming ] and [ nondets ] .",
    "as we have defined it , @xmath19 could conceivably depend on the size of the alphabet @xmath4 .",
    "let @xmath54 be the maximum number of states needed to separate two length-@xmath25 words over an alphabet of size @xmath55 .",
    "then we might have a different value @xmath56 depending on @xmath57 .",
    "the following result shows this is not the case for @xmath58 .",
    "this result was stated in without proof ; we supply a proof here .    for all @xmath58 we have @xmath59 .",
    "suppose @xmath60 are distinct length-@xmath25 words over an alphabet @xmath4 of size @xmath61 .",
    "then @xmath10 and @xmath62 must differ in some position , say for @xmath63 , @xmath64 for @xmath65 .",
    "now map @xmath66 to @xmath67 , @xmath68 to @xmath69 and map all other letters of @xmath4 to @xmath67 .",
    "this gives two new distinct binary words @xmath70 and @xmath71 of length @xmath25 .",
    "if @xmath70 and @xmath71 can be separated by an @xmath24-state dfa , then so can @xmath10 and @xmath62 , by renaming transitions of the dfa to be over @xmath72 and @xmath73 instead of @xmath67 and @xmath69 , respectively .",
    "thus @xmath74 . but clearly @xmath75 , since every binary word can be considered as a word over the larger alphabet @xmath4 .",
    "so @xmath76 .",
    "one frustrating aspect of the separating words problem is that nearly all pairs of words can be easily separated .",
    "this means that bad examples can not be easily produced by random search .",
    "consider a pair of words @xmath77 selected uniformly from the set of all pairs of unequal words of length @xmath25 over an alphabet of size @xmath55 .",
    "then the expected number of states needed to separate @xmath9 from @xmath10 is @xmath78 .    with probability @xmath79",
    ", two randomly - chosen words will differ in the first position , which can be detected by an automaton with @xmath80 states .",
    "with probability @xmath81 the words will agree in the first position , but differ in the second , etc .",
    "hence the expected number of states needed to distinguish two randomly - chosen words is bounded by @xmath82 .",
    "first of all , there is a lower bound analogous to that in proposition  [ one ] for words of _ equal _ length . this does not appear to have been known previously .",
    "no dfa of at most @xmath25 states can separate the equal - length binary words @xmath83 and @xmath84 .",
    "[ equal ]    in pictures , we have    [ data135 ]    more formally , let @xmath8 be any dfa with @xmath25 states , let @xmath85 be any state , and let @xmath66 be any letter .",
    "let @xmath86 for @xmath42 .",
    "then @xmath43 is ultimately periodic with period @xmath0 and preperiod ( `` tail '' ) at most @xmath44 .",
    "thus @xmath45 .",
    "it follows that after processing @xmath87 and @xmath88 , @xmath8 must be in the same state .",
    "similarly , after processing @xmath89 and @xmath90 , @xmath8 must be in the same state .",
    "so no @xmath25-state machine can separate @xmath9 from @xmath10 .",
    "we now prove a series of very simple results showing that if @xmath9 and @xmath10 differ in some `` easy - to - detect '' way , then @xmath12 is small .",
    "suppose @xmath9 and @xmath10 are words that differ in some symbol that occurs @xmath91 positions from the start",
    ". then @xmath92 .",
    "let @xmath93 be a prefix of length @xmath91 of @xmath9 .",
    "then @xmath93 is not a prefix of @xmath10 .",
    "we can accept the language @xmath94 using @xmath95 states ; such an automaton accepts @xmath9 and rejects @xmath10 .",
    "for example , to separate @xmath96 from @xmath97 we can build a dfa to recognize words that begin with @xmath98 :    x0101.pstex_t    [ x0101 ]    ( transitions to a dead state are omitted . )",
    "suppose @xmath9 and @xmath10 differ in some symbol that occurs @xmath91 positions from the end .",
    "then @xmath99 .",
    "let the dfa @xmath8 be the usual pattern - recognizing automaton for the length-@xmath91 suffix @xmath100 of @xmath9 , ending in an accepting state if the suffix is recognized .",
    "then @xmath8 accepts @xmath9 but rejects @xmath10 .",
    "states of @xmath8 correspond to prefixes of @xmath100 , and @xmath101 the longest suffix of @xmath102 that is a prefix of @xmath100 .",
    "for example , to separate @xmath103 from @xmath104 we can build a dfa to recognize those words that end in @xmath98 :    suff0101.pstex_t    [ suff0101 ]      define @xmath105 as the number of occurrences of the symbol @xmath66 in the word @xmath9 .    if @xmath30 and @xmath106 for some symbol @xmath66 , then @xmath32 .    by the prime number theorem ,",
    "if @xmath107 , and @xmath9 and @xmath10 have @xmath55 and @xmath24 occurrences of @xmath66 respectively ( @xmath108 ) , then there is a prime @xmath109 such that @xmath110 ( mod @xmath39 ) .",
    "so we can separate @xmath9 from @xmath10 just by counting the number of @xmath66 s , modulo @xmath39 .",
    "analogously , we have the following result .    if there is a pattern of length @xmath91 occurring a differing number of times in @xmath9 and @xmath10 , with @xmath30 , then @xmath111 .",
    "the previous results have shown that if @xmath9 and @xmath10 have differing `` fingerprints '' , then they are easy to separate .",
    "by contrast , the next result shows that if @xmath9 and @xmath10 are very similar , then they are also easy to separate .    the _ hamming distance _ @xmath112 between two equal - length words @xmath9 and @xmath10 is defined to be the number of positions where they differ .",
    "let @xmath9 and @xmath10 be words of length @xmath25 . if @xmath113 , then @xmath111 . [ hamming ]    without loss of generality ,",
    "assume @xmath10 and @xmath62 are binary words , and @xmath10 has a @xmath69 in some position where @xmath62 has a @xmath67 . consider the following picture :    sep1.pstex_t    [ double1 ]    let @xmath114 be the positions where @xmath10 and @xmath62 differ .",
    "now consider @xmath115",
    ". then @xmath116 . by the prime number theorem",
    ", there exists some prime @xmath117 such that @xmath118 is not divisible by @xmath39 .",
    "so @xmath119 for @xmath120 .",
    "define @xmath121 = @xmath122 .",
    "this value can be calculated by a dfa consisting of two connected rings of @xmath39 states each .",
    "we use such a dfa calculating @xmath123 . since @xmath39 is not a factor of @xmath118 , none of the positions @xmath124",
    "are included in the count @xmath123 , and the two words @xmath10 and @xmath62 agree in all other positions .",
    "so @xmath10 contains exactly one more @xmath69 in these positions than @xmath62 does , and hence we can separate the two words using @xmath125 states .",
    "it is natural to think that pairs of words that are related might be easier to separate than arbitrary words ; for example , it might be easy to separate a word from its reversal .",
    "no better upper bound is known for this special case .",
    "however , we still have a lower bound of @xmath47 for this restricted problem :    there exists a class of words @xmath9 for which @xmath126 where @xmath127 .",
    "consider separating @xmath128 from @xmath129 then , as before , no dfa with @xmath130 states can separate @xmath9 from @xmath131 .",
    "must @xmath132 ?",
    "no , for @xmath133 , @xmath134 , we have @xmath135 but @xmath136    is @xmath137 unbounded ?",
    "two words @xmath138 are _ conjugates _ if one is a cyclic shift of the other .",
    "for example , the english words ` enlist ` and ` listen ` are conjugates .",
    "is the separating words problem any easier if restricted to pairs of conjugates ?    there exist a infinite class of pairs of words @xmath11 such that @xmath11 are conjugates , and @xmath139 for @xmath140 .",
    "consider again @xmath141 and @xmath142",
    "we can define @xmath143 in analogy with @xmath144 : the number of states in the smallest nfa accepting @xmath9 but rejecting @xmath10 .",
    "there do not seem to be any published results about this measure .",
    "now there is an asymmetry in the inputs : @xmath143 need not equal @xmath145 .",
    "for example , the following @xmath15-state nfa accepts @xmath146 and rejects @xmath147 , so @xmath148 .",
    "nsep.pstex_t    [ asymm ]    however , an easy computation shows that there is no @xmath15-state nfa accepting @xmath10 and rejecting @xmath9 , so @xmath149 .",
    "is @xmath150 unbounded ?",
    "a natural question is whether nfas give more separation power than dfas .",
    "indeed they do , since @xmath151 but @xmath152 however , a more interesting question is the _ extent _ to which nondeterminism helps with separation  for example , whether it contributes only a constant factor or there is any asymptotic improvement in the number of states required .",
    "the quantity @xmath153 is unbounded .",
    "[ nondets ]    consider once again the words @xmath154 where @xmath155 , @xmath156 .",
    "we know from theorem  [ equal ] that any dfa separating these words must have at least @xmath157 states .",
    "now consider the following nfa @xmath8 :    aut11.pstex_t    [ data136 ]    the language accepted by this nfa is @xmath158 , where @xmath159 is the set of all integers representable by a non - negative integer linear combination of @xmath25 and @xmath44 .",
    "but @xmath160 , as can be seen by computing @xmath161 modulo @xmath44 and modulo @xmath25 .",
    "on the other hand , every integer @xmath162 is in @xmath159 .",
    "hence @xmath163 is accepted by @xmath8 but @xmath164 is not .",
    "now @xmath8 has @xmath165 states , so @xmath166 , which is unbounded .",
    "find better bounds on @xmath153 .",
    "we can also get an @xmath47 lower bound for nondeterministic separation .",
    "no nfa of @xmath25 states can separate @xmath167 from @xmath168    a result of chrobak @xcite , as corrected by to @xcite , states that every unary @xmath25-state nfa is equivalent to one consisting of a `` tail '' of at most @xmath169 states , followed by a single nondeterministic state that leads to a set of cycles , each of which has at most @xmath25 states .",
    "the size of the tail was proved to be at most @xmath170 by geffert @xcite .",
    "now we use the same argument as for dfas above .    find better bounds on @xmath143 for @xmath171 , as a function of @xmath25 .",
    "we have @xmath172 .",
    "let @xmath8 be an nfa with the smallest number of states accepting @xmath9 and rejecting @xmath10 .",
    "now make a new nfa @xmath173 with initial state equal to any one element of @xmath174 and final state @xmath175 , and all other transitions of @xmath8 reversed .",
    "then @xmath173 accepts @xmath131 . but @xmath173 rejects @xmath176 . for",
    "if @xmath173 accepted @xmath176 then @xmath8 would also accept @xmath10 , since the input string and transitions are reversed .",
    "in , the authors showed that words can be separated with small context - free grammars ( and hence small pda s ) . in this section",
    "we observe    two distinct words of length @xmath25 can be separated by a 2dpda of size @xmath177 .",
    "recall that a 2dpda is a deterministic pushdown automaton , with endmarkers surrounding the input , and two - way access to the input tape . given distinct strings @xmath11 of length @xmath25 ,",
    "they must differ in some position @xmath39 with @xmath178 . using @xmath179 states",
    ", we can reach position @xmath39 on the input tape and accept if ( say ) the corresponding character equals @xmath180 $ ] , and reject otherwise .",
    "here is how to access position @xmath39 of the input .",
    "we show how to go from scanning position @xmath181 to position @xmath182 using a constant number of states : we move left on the input , pushing two symbols per move on the stack , until the left endmarker is reached .",
    "now we move right , popping one symbol per move , until the initial stack symbol is reached . using this as a subroutine , and applying it to the binary expansion of @xmath39 , we can , using @xmath179 states ,",
    "reach position @xmath39 of the input .",
    "we conclude by relating the separating words problem to a natural problem of algebra .    instead of arbitrary automata , we could restrict our attention to automata where each letter induces a permutation of the states ( `` permutation automata '' ) , as suggested by robson @xcite .",
    "he obtained an @xmath183 upper bound in this case .",
    "for an @xmath25-state automaton , the action of each letter can be viewed as an element of @xmath184 , the symmetric group on @xmath25 elements .",
    "turning the problem around , then , we could ask : what is the shortest pair of distinct equal - length binary words @xmath11 , such that for all morphisms @xmath185 we have @xmath186 ?",
    "although one might suspect that the answer is @xmath187 , for @xmath188 , there is a shorter pair ( of length 11 ) : @xmath189 and @xmath190 .    now if @xmath186 for all @xmath191 , then ( if we define @xmath192 ) we have that @xmath193 the identity permutation for all @xmath191 .",
    "call any nonempty word @xmath62 over the letters @xmath194 an _ identical relation _ if @xmath195 the identity for all morphisms @xmath191 .",
    "we say @xmath62 is _ nontrivial _ if @xmath62 contains no occurrences of @xmath196 and @xmath197 .    what is the length @xmath198 of the shortest nontrivial identical relation over @xmath184 ?",
    "recently gimadeev and vyalyi proved @xmath199 .",
    "thanks to martin demaine and anna lubiw , who participated in the open problem session at mit where these problems were discussed .            r.  a. gimadeev and m.  n. vyalyi .",
    "identical relations in symmetric groups and separating words with reversible automata . in f.",
    "m. ablayev and e.  w. mayr , editors , _",
    "5th international computer science symposium in russia , csr 2010 _ , volume 6072 of _ lecture notes in computer science _ , pages 144155 .",
    "springer - verlag , 2010 .",
    "p.  goralk and v.  koubek . on discerning words by automata .",
    "in l.  kott , editor , _ proc .",
    "13th intl conf . on automata , languages , and programming ( icalp )",
    "_ , volume 226 of _ lecture notes in computer science _ ,",
    "pages 116122 .",
    "springer - verlag , 1986 ."
  ],
  "abstract_text": [
    "<S> the _ separating words problem _ asks for the size of the smallest dfa needed to distinguish between two words of length @xmath0 ( by accepting one and rejecting the other ) . in this paper </S>",
    "<S> we survey what is known and unknown about the problem , consider some variations , and prove several new results . </S>"
  ]
}