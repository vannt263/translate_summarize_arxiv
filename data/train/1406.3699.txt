{
  "article_text": [
    "modern parallel and distributed storage systems encapsulate the storage layer behind an object abstraction [ 1 ] since this allows to hide the implementation details behind a key - valued interface : having ` get(oid ) ` and ` set(oid , value ) ` functions where ` oid ` is an object identifier . a device / service that exposes such an interface",
    "is known as an object storage device ( osd ) . in this work",
    "we introduce the concept of a versioning osd ( vosd ) : incorporating versioning primitives as part of the osd api . a vosd stores multiple versions of an object , allowing the user to execute time - travel operations and to access an object s lineage .",
    "the vosd interface ( shown below ) requires a ` version_id ` parameter to be passed to any call .",
    "additionally , similar collection - wide operations can be implemented that allow handling versions for a sets of objects ( with a corresponding ` collection_id ` parameter ) .",
    "the regular osd api can be supported by assuming that ` get / set ` operations return / modify the latest version .",
    "clone(v_id , o_id ) get(v_id , o_id ) set(v_id , o_id , value ) diff(v_1 , v_2 , o_id ) parent(v_1 , o_id ) children(v_1 , o_id )    clone(v_id , c_id ) ...",
    "a vosd serves as a powerful building block , as distributed and parallel storage systems can enable new services that leverage multiversioning , allowing a user / application to choose from an spectrum of multiversioning alternatives : distinct consistency needs can be served depending on the use case .",
    "we look at two of these use cases next .",
    "to exemplify the utility of having versioning as a first - class citizen in an osd interface , we look at two use cases : one distributed and another one in a parallel setting .",
    "we focus on the issues at the single osd level since these are independent of scale .      in transactional database systems ,",
    "versioning is usually employed to implement optimistic concurrency control . in this",
    "setting , instead of acquiring locks , every transaction operates over a snapshot of the database in an isolated manner .",
    "when a transaction is ready to be committed , a validation phase checks that it does nt conflict with others , in which case the transaction is aborted and has to be restarted .",
    "implementing multiversion concurrency control ( mvcc ) [ 2 ] requires keeping track of the highest - committed transaction ( hct ) .",
    "access to this record has to be serialized to avoid inconsistencies .",
    "once this hct record is available ( e.g.  as an object itself ) , implementing mvcc on top of a vosd is relatively straight forward . at the beginning of a transaction",
    ", the collection of objects that is being transactionally managed is snapshotted . at the end of the transaction ,",
    "a lock is acquired on the hct record and every object in the isolated snapshot is ` diff`ed against the corresponding hct .",
    "if no conflicts arise , the hct is assigned to point to the new transaction and the lock is released .",
    "hpc applications use checkpointing as their main fault - tolerant technique : periodically dump checkpoints to storage and , in the advent of failures , recover by reading the latest checkpoint .",
    "a recent trend is to provide asynchronous interfaces ( e.g.  see the recent doe fastforward storage and i / o effort [ 3 ] ) to applications .",
    "asynchrony allows an application to request an i / o operation and not have to wait for its completion .",
    "a challenge arises when multiple i / o operations depend on each other , since in order to avoid inconsistencies ( e.g. abort if a dependant request fails ) , the user needs to keep track of these dependencies and add new logic at the application level .",
    "all this extra code introduces overhead and causes waste of computational resources .    by employing versioning ,",
    "an hpc application can tag every i / o operation with its corresponding checkpoint version and let multiple versions co - exist .",
    "an out - of - core process can merge multiple versions or garbage collect unused ones to free - up space .",
    "additionally , similarly to the mvcc case , a record that keeps track of the highest - readable checkpoint ( hrc ) can be used to give analysis and visualization applications access to consistent checkpoints ( an isolation level known as read - atomicity [ 4 ] ) .",
    "there are mainly three alternatives for implementing an osd api : by using an in - memory backend , key - value store or a local posix filesystem . incorporating versioning to each of these",
    "can be done in distinct ways :    * * posix*. if the underlying filesystem supports it , copy - on - write ( cow ) can be used to represent multiple versions of an object . if filesystem lacks support for cow , a vosd can fall - back to having per - version copies . * * in - memory*. copy - on - write memory can be employed .",
    "for complex objects this might carry an extra overhead .",
    "in such cases , alternatives like ropes or interning can be used .",
    "* * key - value store*. the most straight - forward way to implement it is by keeping a copy for each version of an object .",
    "this might be prohibitive for large objects .",
    "we next present preliminary evaluation of implementations for each of the above .",
    "the ceph distributed storage platform [ 5 ] provides an object interface that exposes a ` clone ( ) ` operation , allowing applications to create snapshots of an object .",
    "internally , ceph abstracts storage nodes as osds and currently supports the three backend types mentioned earlier :    * * posix*. a ceph osd can be backed by either xfs , ext4 , zfs or btrfs . in our experiments we use xfs",
    "thus we can not make use of a cow operation . * * in - memory*. ceph osds implement a custom in - memory store ( memstore ) , using cow to back the snapshot operation .",
    "* * key - value store*. the key - value store of a ceph osd is backed by an instance of leveldb , which is what we use . since leveldb",
    "does nt support versioning , cloning an object results in making a full copy of an object .    *",
    "experimental setup*. our experiments were conducted on a machine with two 2.0ghz dual - core opteron 2212 , 8 gb ddr-2 ram , one 250 gb seagate 7200-rpm sata hard drive , running ubuntu 12.04 .",
    "a ceph osd daemon runs on the machine and a local client connects to it to operate on objects stored in it .",
    "we measure two aspects : version creation and retrieval .",
    "we generate a workload consisting of 100 objects and 100 versions .",
    "the size of each object is 4 mb .",
    "we modify a portion of the object for each version ( 64 16 kb chunks modified at random ) .",
    "we measure the time it takes to create this workload for each backend .",
    "table 1 shows the results .    ....",
    "backend        phase         time ( ms )      ---------- --------------   -----------       xfs             f                676                      s                 59                      m              20829      ---------- -------------   ------------       memstore        f                106                      s                 47                      m               9247      ---------- ---------------   ----------       leveldb         f                196                      s                192                      m               9548 ....    we break down the timings into three phases : ` f ` which corresponds to the time it takes to create the first revision . `",
    "s ` denotes the average time that it takes to create a snapshot of the collection . `",
    "m ` corresponds to the average time it takes to modify the 100 objects ( 64 16 kb modifications for each object ) .      for the workload described above",
    ", we read the latest version of an object , as well as a randomly selected version ( in the [ 1,100 ] range ) . the object being read",
    "is randomly chosen .",
    "we execute 100 queries of each type and report the average .",
    "table 2 shows the results .    ....",
    "backend      latest ( ms )    random ( ms )      ----------- ------------- -------------        xfs           11.5           11.7        memstore       3.2            3.1        leveldb        6.4            6.4 ....",
    "as part of our ongoing project , we are defining a generalized distributed multiversioning framework that will be able to support multiple flavors of versioning . as mentioned previously , applications can customize this service to their particular needs and observe distinct consistency guarantees .",
    "we are currently looking at other use cases that fit in this multi - versioned view : distributed softare transactional memory , management of massive datasets , transactional stream processing and programmable filesystems .",
    "[ 1 ] m. mesnier , g. ganger , and e. riedel , `` object - based storage , '' _ ieee communications magazine _ , vol .",
    "2003 , pp . 8490 .",
    "[ 5 ] s.a .",
    "weil , s.a .",
    "brandt , e.l .",
    "miller , d.d.e .",
    "long , and c. maltzahn , `` ceph : a scalable , high - performance distributed file system , '' _ proceedings of the 7th symposium on operating systems design and implementation _ , berkeley , ca , usa : usenix association , 2006 , pp ."
  ],
  "abstract_text": [
    "<S> the ability to store multiple versions of a data item is a powerful primitive that has had a wide variety of uses : relational databases , transactional memory , version control systems , to name a few . </S>",
    "<S> however , each implementation uses a very particular form of versioning that is customized to the domain in question and hidden away from the user . in our going project </S>",
    "<S> , we are reviewing and analyzing multiple uses of versioning in distinct domains , with the goal of identifying the basic components required to provide a generic distributed multiversioning object storage service , and define how these can be customized in order to serve distinct needs . with this primitive , new services can leverage multiversioning to ease development and provide specific consistency guarantees that address particular use cases . </S>",
    "<S> this work presents early results that quantify the trade - offs in implementing versioning at the local storage layer . </S>"
  ]
}