{
  "article_text": [
    "a key issue of distributed systems is the coordination of distributed entities that concurrently run in the system .",
    "very different solutions can be developed to address this problem , but even distributed systems can be very different , hence it is important to carefully choose a solution ( or a set of solutions ) that is appropriate for the specific distributed system under consideration .",
    "a major distinction , indeed , can be made between the systems that adopt the shared memory model and those that rely on message passing .",
    "the first kind of systems is often a natural model for _ data - centric _ applications , that fit a _ centralized control _ of distributed entities that cooperate to fulfill logically centralized algorithms operating on mutable shared data . on the other hand , _ communication - centric _ applications",
    "are usually built on top of concurrent / distributes entities that take their decisions only based upon local information ( _ locality and isolation principles _ ) .",
    "a general approach to structuring distributed systems is _ protocol - oriented programming _ , which endorses thinking ( hence programming ) in terms of communication protocols . in this view , programming a concurrent / distributed system entails the design of a precise communication protocol involving a possibly dynamic set of interacting parties .",
    "however , in order for a paradigm to become an effective programming style , it requires high - level support to _ express coordination protocols _ in the programming language , and , above all , it requires some support to _ check protocol compliance_. finding the correct abstractions to express and enforce coordination protocols is very hard , especially because suitable abstractions should also productively interoperate with the other abstractions provided by the language . for instance , systems with centralized control best fit a top - down implementation of a global coordination protocol , e.g. the multiparty session types s methodology that projects a global protocol into the sub - protocols of local parties  @xcite . on the contrary , distributed systems made of local entities that work with strong isolation and locality principles ,",
    "require support for consistent bottom - up compositions of local behaviors .",
    "furthermore , real systems usually rely on hybrid architectures and logical models , so it is important to remind that there is no single solution and trade - offs are unavoidable .    in this article",
    "we study the application of the typestate - oriented programming discipline to achieve protocol - oriented programming in an actor system .",
    "typestate - oriented programming ( tsop for short )  @xcite is an extension of the oo paradigm where objects are modeled not just in terms of interfaces but in terms of their usage protocols , describing legal sequences of method calls , possibly depending on the object s internal state . in @xcite",
    "we showed how tsop can be statically enforced in the objective join calculus , that is a calculus of concurrent objects equipped with a semantics based on the chemical abstract machine @xcite .",
    "more precisely , we introduced a simple behavioral type theory that allows to describe and enforce structured object protocols consisting of possibilities , prohibitions and obligations . according to the chemical metaphor",
    ", programs are modeled as chemical soups of molecules ( i.e. , multisets of messages sent to objects ) that encode both the current state of the objects and the ( pending ) operations on them . moreover , reaction rules , corresponding to object s method definitions , explicitly specify both the valid combinations of state and operations as well as the state changes engendered by each operation .    in @xcite we put forward a couple of examples written with scala akka actors , showing that the actor programming model  @xcite bears strong similarities with tsop we realized in the objective join calculus , at least at the program level .",
    "the formal development of a behavioral type system for actors along the lines of @xcite is the subject of current work .",
    "instead , in this article we further explore the implementation of tsop in the context of scala akka , and even if a full implementation of the behavioral type discipline of @xcite requires a compiler extension , we demonstrate that exploiting the powerful typing support offered by scala allows us to go a long way into checking protocol compliance solely using off - the - shelf development tools .      the implementation of typestate - oriented actors is entirely illustrated by means of examples .",
    "we start by fully studying an object with a very simple usage protocol , but that is enough to display all the issues of the typestate discipline .",
    "this main running example is presented in stages so to separate the explanation of different ingredients , more precisely :    * in section 2.1 we draw on plain akka actors , that are essentially untyped , thus in order to address protocol violations they have to resort to defensive programming by explicitly dealing with unintended messages ; * in section 2.2 we introduce the use of types to represent actor s interfaces and typed actor references to encapsulate references to stateful actors ; * in section 2.3 we resort to the explicit continuation - passing programming style to keep track of the dynamic change of the actors state ; * in section 2.4 we refactor the code so to just implicitly deal with continuations .",
    "we define a suitable monad that allows ( @xmath0 ) to simplify the code of the user of a stateful actor , bringing better to light its logic , ( @xmath1 ) the compiler to check that a stateful actor will only receive intended messages at the intended state , ( @xmath2 ) and usage protocol to be completely encoded in terms of typed expressions ; * while in sections 2.3 and 2.4 we considered a stateful actor accessed by a single user , in section 2.5 we show that in order to scale the approach to the case of multiple concurrent users it is sufficient for the stateful actor to mix - in ( a trait implementing ) the semantics  la chemical abstract machine .",
    "the final section 3 displays our tsop approach at work on a more complex scenario .",
    "it shows that scala akka actors effectively support the definition of stateful actors that can dynamically change _ both their behavior and their interface_. moreover , the scala type system is expressive enough to let the compiler check that a stateful actor will only receive intended messages at the intended states . besides the absence of wrong messages , a full typing support for protocol - oriented programming would also require to detect violations of protocol obligations , that is to ensure that all the intended messages are eventually sent",
    "this property is captured by the behavioral typing studied in @xcite but the required linear types are beyond the expressive power of the current scala type system .    all the code shown in the article is compatible with scala 2.11.6 and akka 2.3.4 .",
    "in this section we consider as a running example a buffer that can contain at most one value of a generic type ` t ` .",
    "the buffer provides just two operations : ` insert(x : t ) ` and ` remove ( ) ` , however since the buffer can not hold more than a value , no two consecutive ` insert ` operations can be executed , and similarly no two consecutive ` remove ` operations .",
    "such a usage constraint can be rephrased in typestate - oriented terms as the following protocol :    _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ * buffer protocol : * the buffer has two possible _ states _ , `",
    "empty ` and ` full ` .",
    "when in state ` empty ` its _ interface _ only contains the operation ` insert(x : t ) ` , whose execution moves the buffer to state ` full ` .",
    "when the buffer is in state ` full ` its _ interface _ only contains the operation ` remove ( ) ` , whose execution moves it to state ` empty ` .",
    "the initial state of the buffer is ` empty ` .",
    "_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _      moving from the buffer s protocol above to the definition of a ` buffer ` actor is straightforward : simply observe that actors can directly implement finite state machines ( fsm ) and the protocol above can be easily expressed as a fsm with two states ` empty ` and ` full ` and two edges labeled ` insert(x : t ) ` and ` remove ( ) ` connecting one state with the other .",
    "we point out that we are not necessarily advocating the use of fsms to express objects protocols , we use them here just as a mental bridge between protocol declarations and actor implementations .",
    "the following code defines a generic akka actor ` buffer[t ] ` that is intended to handle only the messages ` insert ` and ` remove ` , implemented as case classes .",
    "in particular , the actor defines two possible behaviors that correspond to the two possible buffer s states : ` empty ` and ` full ` .",
    "each behavior is a partial function ( of type ` receive ` as expected for akka actor s behaviors ) that only handles the single message that belongs to the interface of the corresponding state .",
    "moreover , the state change engendered by the operations is obtained by using the actor s ability to change its current behavior by means of the ` become ` method .",
    "finally , the definition of the ` receive ` method corresponds to setting the initial state of the buffer to ` empty ` .",
    "case class insert[t](value : t ) case class remove ( )    class buffer[t ] extends actor def empty : receive = case insert(x : t ) = > context.become(full(x ) ) println(``inserted ' ' + x ) def full(x : t):receive = case remove ( ) = > context.become(empty ) println(``removed ' ' + x ) def receive = empty    even if the code above is typed , there is no type support to guarantee that :    1 .   no messages other than ` insert ` and `",
    "remove ` are sent to the buffer .",
    "the ` insert(v ) ` message is sent only to an ` empty ` buffer and the ` remove ( ) ` message is sent only to a ` full ` buffer . therefore , since each message makes the buffer switch state , ` insert ` and ` remove ` must be alternated .    indeed , the following user code is well - typed even if it violates the intended buffer protocol :    val s = actorsystem ( ) val buffer = s.actorof(props(new buffer[int]),``buff '' ) val user = s.actorof(props(new actor buffer !",
    "insert(4 ) buffer ! remove ( ) buffer !",
    "insert(10 ) buffer !",
    "insert(20 ) // the msg is received and silently discarded buffer !",
    "the msg is received and silently discarded def receive = partialfunction.empty ) )    the ` insert(20 ) ` message is indeed received by a buffer whose current behavior is the ` full(10 ) ` partial function , which is not defined on the ` insert ` case class .",
    "the default akka s policy for actors that receive a message that is not handled by their current behavior is to wrap that message into an ` unhandledmessage ` object and forward it to the actor system s event stream for logging .",
    "therefore the reception of the unintended ( logically wrong ) messages ` insert(20 ) ` and ` 4 ` gets completely unnoticed by the user actor . by adopting a defensive programming strategy",
    ", we could enrich the ` buffer ` class with an overriding of the ` unhandled(msg : any ) ` method inherited from the ` actor ` class so to explicitly manage unintended messages .",
    "however , the aim of the tsop approach is opposite : instead of protecting the buffer , it checks the user code and statically marks the sending of the wrong messages as untyped actions .",
    "the first one of the two guarantees formulated above reminds the basic type safety property of oop : in well - typed programs all the methods invoked on objects belong to the object s interface . in the context of actors",
    "there is no method invocation , but a message is passed as a parameter to the dispatching method , that in akka is the method ` def ! ( msg : any):unit ` of the class ` actorref ` .",
    "however , in this scenario there is no way to link ( and check ) the actor s interface ( i.e. the set of allowed incoming messages ) with the types of the parameters of the dispatching method .",
    "we then resort to the following solution : first of all we use the nominal type system of scala to represent actors interfaces , then we wrap actor references of type ` actorref ` into instances of the ` typedref[t ] ` generic class which provides a typed - version of the dispatching method with signature ` def tytell(msg : t):unit ` . in other terms , a wrapper of type ` typedref[t ] ` encapsulates a reference to a stateful actor _ at state _ ` t ` , and provides a method that allows for the static checking of the correctness of the incoming messages .",
    "observe that the ` typedref[-t ] ` class is contravariant in its type parameter : indeed , let ` s ` be a sub - interface of ` t ` , then an actor of type ` typedref[s ] ` can be safely substituted by an actor of type ` typedref[t ] ` which is able to handle a superset of messages .",
    "the following code applies this approach to the running example : let ` bufferinterf ` , ` produceint ` and ` consumeint ` be a hierarchy of empty traits corresponding to the interfaces assumed by the buffer in different states ; their names remind that when in state ` empty ` , resp . `",
    "full ` , the buffer allows the production , resp .",
    "consumption , of an item .",
    "accordingly , the case classes extend the suitable trait so that ` bufferinterf ` is the ( super-)type of the buffer s messages .",
    "let also ` buffer ` be a reference of type ` typedref[bufferinterf ] ` built around the ` actorref ` spawned by the actor system upon creation of the ` buffer ` actor ( lines 15 - 16 ) .",
    "then the ( typed-)invocation ` buffer tytell(msg ) ` will only compile if ` msg ` is one of the two intended messages ` insert ` or ` remove ` .",
    "trait bufferinterf trait produceint extends bufferinterf trait consumeint extends bufferinterf    case class insert[t](value : t ) extends produceint case class remove ( ) extends consumeint    class typedref[-t](r : actorref ) def tytell(msg : t ) = r ! msg // add a layer of typing over usual send    class buffer[t ] extends actor ... // defined exactly as in section 2.1    val s = actorsystem ( ) val untypedbuffer = s.actorof(props(new buffer[int]),``buff '' ) val buffer = new typedref[bufferinterf](untypedbuffer )    val user = s.actorof(props(new actor    buffer tytell insert(4 ) buffer tytell remove ( ) //buffer tytell 4 does not compile untypedbuffer !",
    "4 // compiles but the msg is silently discarded buffer tytell insert(10 ) buffer tytell insert(20 ) // compiles but the msg is silently discarded    def receive = partialfunction.empty    ) )    in the user code above we see the type checking in action to prevent unintended messages to be sent to a _ typed actor reference _ : line 21 does not compile since the invocation of the ` tytell ` method of the ` typedref[bufferinterf ] ` class does not accept the parameter ` 4 ` which is not of type ` bufferinterf ` .",
    "on the other hand , nothing prevents to send the wrong message ` 4 ` to the buffer actor by using its _ untyped _ reference as in line 22 .",
    "this kind of errors can be avoided by designing a proper encapsulation of the type ` actorref ` so that actor users can only handle typed actor references .",
    "more importantly , line 24 above shows that the second guarantee required by the buffer protocol , that is the alternation of ` insert ` and ` remove ` , eludes the type checking : two consecutive insertions are well typed even if the second one gets silently discarded because it is received by a ` full ` buffer .",
    "this is not surprising since the information encoded in the types just refer to the buffer interfaces , but nothing expresses the state - change ( possibly ) provoked by the reception of a message .",
    "furthermore , the initial ` buffer ` reference in line 16 could be better typed as an empty buffer , i.e. ` typedref[produceint ] ` , since it initially accepts only ` insert ` messages .",
    "however , with such a type , no ` remove ` message can ever be passed to the ` tytell ` method , even after an initial insertion that would have moved the buffer to the correct ` full ` state .",
    "what is really missing here is the buffer reference s ability to _ keep track of the dynamic change of its type / state _ between ` typedref[produceint ] ` and ` typedref[consumeint ] ` .",
    "notice that statically we can only approximate these changes with a common supertype , i.e. ` typedref[bufferinterf ] ` , but we have seen that it is not enough . the alternative is to take a new reference , of the suitable type , each time the state has changed .",
    "this is what we will do in the next subsection resorting to the _ continuation - passing _ programming style .",
    "it is important to observe that the combination of typed actor references and continuation - passing style is exactly ( part of ) the solution adopted by the akka typed @xcite experimental library available in the latest akka release .",
    "further major differences between our approach and that of akka typed will be presented in the next sections .      in order to keep track of the state changes caused by message reception",
    ", we let actors reply by sending to users a _ continuation reference _ , that is a reference to themselves _ typed at the new state _ that can be used to continue the interaction according to the rest ( the continuation ) of the protocol . since in the actor model",
    "the communication is asynchronous , messages are enriched with an additional parameter ` replyto ` referring to the actor that expects the corresponding reply message carrying the continuation .",
    "accordingly , in the code below the ` insert ` and ` remove ` case classes have the additional parameter ` replyto ` of type ` actorref ` corresponding to the ( not necessarily typed ) user actor that is waiting for the continuation . moreover , the additional case classes defined in lines 6 - 7 stand for the reply messages sending back to the user the ( typed ) continuations . more precisely ,",
    "when the buffer receives an ` insert ` message it moves to the state ` full ` , hence its continuation , carried by the message ` insertreply ` , has type ` typedref[consumeint ] ` .",
    "similarly , the reply to a ` remove ` request carries both the removed value and a continuation of type ` typedref[produceint ] ` standing for the buffer that moved to the state ` empty ` .",
    "// parameters replyto correspond to buffer users , it is sufficient // to type them with actorref since we do not model their protocol case class insert[t](value : t , replyto : actorref ) extends produceint case class remove(replyto : actorref ) extends consumeint //",
    "reply messages carry the buffer s continuation in the new state case class insertreply(o : typedref[consumeint ] ) case class removereply[t](v : t , o : typedref[produceint ] )    class buffer[t ] extends actor def empty : receive = case insert(x : t , r ) = > context.become(full(x ) ) r !",
    "insertreply(new typedref[consumeint](self ) ) def full(x : t):receive = case remove(r ) = > context.become(empty ) r !",
    "removereply(x , new typedref[produceint](self ) ) def receive = empty    val s = actorsystem ( ) val untypedbuffer = s.actorof(props(new buffer[int]),``buff '' ) val buffer = new typedref[produceint](untypedbuffer )    val user = s.actorof(props(new actor    buffer tytell insert(4,self )    def run(v : int ) : receive = case insertreply(o ) = > o tytell remove(self ) //o tytell insert(9,self ) does not compile case removereply(x , o ) = > if ( v > 0 ) o tytell insert(v+4,self ) context.become(run(v-1 ) ) else println(``done '' ) def receive = run(4 )    ) )    compared to the previous implementation of the ` buffer ` actor , the new definition takes care of the reply messages ( lines 12 and 16 ) .",
    "the user actor undergoes major changes : the initial ` buffer ` reference has type ` typedref[produceint ] ` ( line 23 ) and represents an initially empty buffer .",
    "this reference is used _ just once _ by the user in line 26 to ask for the insertion of the integer ` 4 ` .",
    "subsequent references to the buffer are those bound by the parameter ` o ` of the reply messages ( lines 29 and 31 ) . therefore , by rebinding the buffer object to new references as a result of sending a message , and by typing such new references with a type that describes the newly reached state , we can control that sequences of message invocations conform to the buffer s usage protocol , provided that each reference is used at most once .    for instance , sending in line 29 an ` insert ` message to the reference ` o ` would not compile since the compiler knows that the type of the variable ` o ` is ` typedref[consumeint ] ` . for the same reason also the expression in line 30 would not compile , even if it follows a ` remove ` request . on the other hand ,",
    "two successive calls ` o tytell remove(self ) ; o tytell remove(self ) ` would be well typed even if they do not respect the buffer protocol , and similarly invoking ` tytell insert(0,self ) ` on the reference ` buffer ` instead of ` o ` in line 29 would not be prevented by the compiler .",
    "the point is that in order to enforce protocol compliance , it is important to ensure that a reference ( to a typestate actor ) is used _ at most once_.    the behavioral type system developed in @xcite statically checks the linear usage of typed object references , however this is beyond the capabilities of the standard scala type system",
    ". therefore , in order to enforce an affine usage of typed references , that is at most one call of the ` tytell ` method , we could enrich the ` typedref ` class with an _ affine flag _ and transform an affinity violation , i.e. , a logical error , into a runtime error . for the sake of completeness we show below the corresponding definition , but we do not assume it in the rest of the paper .",
    "class typedref[-t](r : actorref ) private var used = false def tytell(msg : t ) = if ( !",
    "used ) used = true ; r ! msg else println(``affinity violation '' ) ; throw new exception    we finally comment on the difference between this approach and that of akka typed actors . as we said above",
    ", this module provides both typed actor references ( which are instances of the ` actorref[-t ] ` class ) and a continuation passing programming style .",
    "type safety guarantees  @xcite that in well typed programs an actor of type ` actorref[t ] ` will only receive messages of type ` t ` .",
    "however , a key assumption / constraint of akka typed actors is that they can dynamically change their behavior only as along as the new behavior still handles all the messages handled by the previous one .",
    "for instance , the 1-place buffer should handle both ` insert ` and ` remove ` messages in both states ` empty ` and ` full ` .",
    "in other words , the buffer must be prepared ( i.e. , programmed ) to receive messages that arrive when it is in the wrong state . here",
    "we are instead claiming that it is possible to define typestate - oriented actors whose behaviors are defined only on messages that are meaningful in the corresponding state .",
    "we will further discuss akka typed constraint in later sections ; we conclude observing that even in the akka typed module there is no support to statically check whether the program violates the continuation - passing style by re - using an `` out of date '' reference .",
    "so , like in the code above , it is responsibility of the programmer to use at most once a typed reference that is subject to a state / type change .",
    "adopting the continuation - passing style allows stateful actors to take advantage of type checking , but it entails a more involved user code .",
    "explicit use of reply messages carrying continuations might be useful to correctly combine the protocols of two ( or more ) interacting stateful actors .",
    "however , in simple cases where a stateful actor is accessed by a single user , it would be useful to simplify the user code and bring to light its logic .",
    "indeed , looking at the user code shown in the previous subsection it is not immediate to understand that the actor is alternating ` insert ` and ` remove ` requests .    in this section",
    "we illustrate how to simplify the code accessing a stateful actor by encapsulating continuations into a monad .",
    "we start by showing the refactoring of the code of a user that alternates ` insert ` and ` remove ` requests to a 1-place buffer :    val user = s.actorof(props(new actor    for o < - buffer tytell insert(0 ) o < - buffer.afterinsert(o ) tytell remove ( ) o < - buffer.afterremove(o ) tytell insert(2 ) o < - buffer.afterinsert(o ) tytell remove ( ) o < - buffer.afterremove(o ) tytell insert(4 ) o < - buffer.afterinsert(o ) tytell remove ( ) yield println ( `` end '' )    def receive = partialfunction.empty    ) )    this code is very similar to that in the untyped case , but it heavily builds on typed continuations , which are hidden within the monad but are still enforcing type safety .",
    "messages ` insertreply ` and ` removereply ` are not needed anymore , and the code adopts the for - notation offered by scala to work with monads . the monad we define below makes use of futures so that the code above has the asynchronous and non - blocking semantics that is distinctive of actors , and the code style is reminiscent of scala concurrent programs that use futures .",
    "first of all , observe that by using the same variable ` o ` for each binding in lines 2 - 7 , we reduce the risk ( still not checked by the compiler ) of using an out - of - date reference .",
    "similarly , it is easier to spot whether the reference ` buffer ` is used only once in line 2 . on the other hand , as we will explain below , the user code needs explicit type - enforcements , that have been encapsulated in the methods ` afterinsert ` and ` afterremove ` .",
    "the main ideas of this approach can be summarized as follows :    1 .",
    "we have already observed in section 2.2 that it is essential for types to somehow encode information about the state changes ( possibly ) provoked by the reception of messages . in section 2.3 such information is encoded by the reply messages , e.g. , the definition ` case class insertreply(o : typedref[consumeint ] ) ` links the ` insert ` message with the ` consumeint ` interface assumed by the buffer in the next state ` full ` .",
    "here we get rid of reply messages , and we rather define a _ usage protocol expression _ that directly encodes the state transitions involved by the actor protocol .",
    "more precisely , a protocol expression is a function associating the next state , i.e. the typed continuation , to each message in the actor s interface ( lines 27 - 38 below ) .",
    "2 .   instead of `",
    "typedref[t ] ` we use a richer actor wrapper ` protref[t ] ` , which encapsulates both a reference to a stateful actor _ at state _ `",
    "t ` and the usage protocol expression of such actor .",
    "the actor s protocol is indeed inspected in the new definition of the ` tytell ` method , that now returns an object of type ` continuation ` which encapsulates the next state that will be assumed by the actor upon reception of the message passed as parameter to ` tytell ` ( lines 13 and 15 below ) .",
    "the abstract class ` continuation ` has an abstract type member ` nextstate ` and encapsulates a promise and a paired future holding a value of type ` protref[nextstate ] ` .",
    "the pair ( promise , future ) allows the usual asynchronous and non - blocking semantics : the user of the actor sends a message and immediately obtains a future ( as a continuation reference ) , that will be asynchronously completed by the actor which fulfills the corresponding promise upon handling the received message .",
    "+ more precisely , when the user invokes ` tytell(msg ) ` , the actor protocol is inspected and a pair ( promise , future ) of the suitable `` next type '' is created ( see line 13 and the definition of the ` protocol ` expression in lines 27 - 38 below ) .",
    "then the promise is forwarded to the actor to be completed ( line 14 ) , while the continuation is returned to the caller , that is to the user ( line 15 ) . since the ` continuation ` class is implemented as a monad on top of the ` future[t ] ` monad ( lines 6 - 8 ) , the user can deal with the returned object using the simple for - notation that is common in scala programming with futures .    abstract class continuation    type t //",
    "t stands for the next state val p : promise[protref[t ] ] val f : future[protref[t ] ]    def map[s](fun : protref[t ] = > s ) : future[s ] = f map fun def flatmap[s](fun : protref[t ] = > future[s ] ) : future[s ] = f flatmap fun def filter(pred : protref[t ] = > boolean):future[protref[t ] ] = f filter pred    class protref[-t](r : actorref , protocol : t=>continuation ) def tytell(msg : t ) : continuation = val cont = protocol(msg ) // returns a promise of suitable type r!(msg , cont.p ) //",
    "r will complete the promise p return cont    trait bufferinterf trait produceint extends bufferinterf trait consumeint extends bufferinterf    case class insert(value : int ) extends produceint //",
    "for simplicity just int values case class remove ( ) extends consumeint    object buffer // protocol for a buffer whose user alternates insert and remove def protocol : bufferinterf = > continuation = case insert(v ) = > new continuation type t= consumeint val p = promise[protref[consumeint ] ] val f = p.future case remove ( ) = > new continuation type t = produceint val p = promise[protref[produceint ] ] val f = p.future def afterinsert[u](o : protref[u]):protref[consumeint ] = o.asinstanceof[protref[consumeint ] ] def afterremove[u](o : protref[u]):protref[produceint ] = o.asinstanceof[protref[produceint ] ]    the definition of the buffer actor must then be modified so that instead of sending reply messages the message handler completes a promise .",
    "notice also that , because of the new definition of the ` tytell ` method , the buffer s incoming messages are pairs made of a message tag and the specific promise instance to be completed ( lines 3 and 8 below ) .",
    "the injection of the explicit type of the promise variable ` p ` in lines 3 and 8 is needed to typecheck the promise completion in lines 5 and 10 , on the other hand , a warning is produced by the compiler since the type argument of the generic class ` promise ` gets unchecked because it is eliminated by type erasure .",
    "anyway , the correct type parameter to inject in lines 3 and 8 can be automatically deduced from the buffer s protocol definition , i.e. the ` buffer.protocol ` function defined in the companion object ( lines 27 - 38 of the code above ) .",
    "class buffer extends actor def empty : receive = case ( insert(x),p : promise[protref[consumeint ] ] ) = > context.become(full(x ) ) p success new protref[consumeint](self , buffer.protocol ) def full(x : int ) : receive = case ( remove(),p : promise[protref[produceint ] ] ) = > context.become(empty ) p success new protref[produceint](self , buffer.protocol ) def receive = empty    for the sake of completeness , we show the program code that completes the definition of the user actor shown at the beginning of this section :    val s = actorsystem ( ) val untypedbuffer = s.actorof(props(new buffer),``buff '' ) val buffer = new protref[produceint](untypedbuffer , buffer.protocol ) val user = .... as above ...",
    "[ [ summary - of - the - tsop - guarantees - actually - enforced - by - typing . ] ] summary of the tsop guarantees actually enforced by typing .",
    "+ + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + +    the advantages of the approach we described in this section can be summarized as follows :    * the is truly implemented as a type - stateful object : ( @xmath0 ) each state corresponds to an actor behavior that handles only the messages that belong to the interface assumed in that state , and ( @xmath1 ) state transition is achieved by changing the current behavior ( by means of ` become ` ) and using a typed wrapper corresponding to the interface assumed in the new state ; * the code has a clean logic and its compilation guarantees that the buffer will only receive * the intended messages at the intended state*. for instance , two consecutive ` remove ` requests would result in the ill - typed expression ` buffer.afterremove(o ) tytell remove ( ) ` that is rejected by the compiler .",
    "it is worth observing that the type casts provided by the methods ` buffer.afterinsert ` and ` buffer.afterremove ` are inevitable because the compiler can only statically assume that the continuation returned by an invocation of the ` tytell ` operator has an abstract type , therefore a type - coercion is needed .",
    "the definition of the ` tytell ` method ensures that the actual type of the returned object is correct because it has been deduced from the usage protocol , hence no type - cast error will occur at runtime .",
    "removing these casts requires implementing a specific static analysis ; however our solution keeps the code clean by resorting to so - called phantom types .",
    "* most of the code of the given program can be automatically generated from the specification of the intended buffer . in our code",
    "the protocol is made of ( @xmath0 ) a hierarchy of empty traits that encode interfaces , ( @xmath1 ) a set of case classes defining the messages belonging to these interfaces , and ( @xmath2 ) a function expressing the state transitions entailed by message reception .",
    "ideally , tsop programmers could define object protocols using some other more declarative language , e.g. uml sequence diagrams , fsms or cfsms as in  @xcite or even using a specific type language as in  @xcite , and the translation into typed code analogous to the one above could be automatically generated .",
    "we leave this subject for future developments .",
    "so far we have considered a rather simple scenarion in which a stateful actor is accessed by a single concurrent user . ensuring that a stateful object only receives the intended messages at the intended states is much more difficult when the object is aliased or shared  @xcite .",
    "for instance , if the empty buffer is initially shared by two users and the first user fills it with a value , it causes the buffer to move to the ` full ` state thus disabling the insertion that could have been concurrently requested by the second user .",
    "however , if the first user later on removes the inserted value , the concurrent insertion requested by the second user could be only temporarily disabled , since the buffer eventually gets back to the ` empty ` state .    in other terms , in a concurrent ( and asynchronous ) setting , an actor must be prepared to receive messages that correctly belong to its protocol even if the actor is not in the appropriate state _",
    "yet_. dealing with this scenario is indeed the main reason why the akka typed library allows an actor to dynamically change its behavior as long as the new behavior accepts the same set of messages as the original one . indeed ,",
    "if the buffer in the ` full ` state can somehow handle also the ` insert ` messages , no requests get lost .",
    "anyway , in this way the stateful object essentially can change its behavior but it always keeps the same interface .",
    "we showed in @xcite that we can instead keep the tsop idea of different interfaces in different states even in a concurrent setting by resorting to the chemical semantics .",
    "the chemical model of concurrency , due to berry and boudol in 1992 @xcite , interprets the state of an asynchronous concurrent system as a soup of molecules , corresponding to the messages that have been sent to the concurrent entities .",
    "the behavior of the system is then described by reaction rules , that specify how ( patterns of ) molecules / messages can be consumed so to produce new ones .",
    "this model of concurrency is the foundation of the join calculus  @xcite , a formal language for which there exist a number of both native and library implementations ( e.g. ,  @xcite ) . on the other hand ,",
    "a similar semantic model can be established also in scala akka ( @xmath0 ) by interpreting molecules as messages sent to actors , ( @xmath1 ) by interpreting actor behaviors as reaction rules , and ( @xmath2 ) by modifying the default management of the actor mailbox so to keep a received message / molecule until it triggers a reaction , i.e. until the current behavior / state of the actor is able to handle it .    a precise formal account of the connection between the actor model and the join calculus that allows to scale to actors the type safety properties proved in @xcite is subject of current work .",
    "here we illustrate by means of examples that scala akka actors can support the chemical semantics , and the scala type system can already check typestate - oriented code to some extent .",
    "more precisely , we define a ` chemical ` trait that can be used to optionally provide actors with chemical semantics by means of mix - in composition .",
    "the trait is defined so that it only keeps the messages of ( super)type ` protocolmsg ` , that will eventually be handled since they actually belong to the actor s protocol , while other messages can be immediately discarded as errors .",
    "trait protocolmsg // identifies the type of the messages to keep    trait chemical extends actor    private val soup : arraybuffer[protocolmsg ] = new arraybuffer ( ) private def check ( ) = soup.map(self !",
    "_ ) ; soup.clear private def keep : receive = case msg : protocolmsg = > soup.append(msg )    def chembecome(newstate : receive ) = check ( ) ; context.become(newstate ) def chemreact(behave : receive):receive = behave orelse keep    the ` chemreact ` method extends the actor s behavior so to keep protocol messages ( i.e. messages of type ` protocolmsg ` ) arriving at the wrong time , while ` chembecome ` is used to change the actor s state and re - check saved messages . in this definition saved messages are simply re - sent to the mailbox , we show in the next section a more realistic implementation that relies on the akka s ` stash ` trait  @xcite that allows an actor to temporarily stash away messages and prepend them to the actor s mailbox right before changing the current behavior .    as far as our running example in concerned , we can obtain a 1-place buffer that is robust with respect to multiple concurrent users by mixing - in the ` chemical ` trait to its definition . to illustrate , we consider a buffer that can be accessed by two kinds of user actors : a ` producer ` actor that repeatedly sends ` insert ` messages and a ` consumer ` actor that repeatedly sends ` remove ` messages . in this scenario",
    "the buffer s usage protocol is different from the one we considered in the previous sections : while the buffer still switches between the states ` empty ` and ` full ` , now each user is aware of a single , fixed buffer interface , i.e. , the ` producer ` relies just on the ` produceint ` interface to send ` insert ` messages , while the ` consumer ` is aware just of the ` consumeint ` interface .",
    "accordingly , in the typed encoding of the new buffer s protocol , the type of the continuation references must be adapted : after sending an ` insert ` message a ` producer ` will get a continuation of type ` typedref[produceint ] ` , while the ` consumer ` will obtain a continuation of type ` typedref[consumeint ] ` as a result of a ` remove ` message .",
    "we show below the code corresponding to the explicit passing of continuations ( cf .",
    "section 2.3 ) , while the integration of the chemical semantics with the continuation monad is postponed to the next section .",
    "trait bufferinterf extends protocolmsg //",
    "chemical molecules trait produceint extends bufferinterf trait consumeint extends bufferinterf    case class insert[t](value : t , replyto : actorref ) extends produceint case class remove(replyto : actorref ) extends consumeint case class insertreply(o : typedref[produceint ] ) case class removereply[t](v : t , o : typedref[consumeint ] )    class buffer[t ] extends actor with chemical def empty : receive = chemreact case insert(x : t , r ) = > chembecome(full(x ) ) r !",
    "insertreply(new typedref[produceint](self ) ) def full(x : t):receive = chemreact case remove(r ) = > chembecome(empty ) r !",
    "removereply(x , new typedref[consumeint](self ) ) def receive = empty    class producer(buffer : typedref[produceint ] ) extends actor buffer tytell insert(0 , self ) def sent(v : int ) : receive = case insertreply(o ) = > o tytell insert(v+10,self ) //remove(self ) would not compile context.become(sent(v+10 ) ) def receive = sent(0 )    class consumer(buffer : typedref[consumeint ] ) extends actor buffer tytell remove(self ) def receive : receive = case removereply(x , o)= > o tytell remove(self )    val s = actorsystem ( ) val bufferuntyped = s.actorof(props(new buffer[int]),``buffer '' ) val buffer = new typedref[bufferinterf](bufferuntyped ) //use contravariance of typedref[-t ] val producer1 = s.actorof(props(new producer(buffer ) ) ) val consumer1 = s.actorof(props(new consumer(buffer ) ) ) val consumer2 = s.actorof(props(new consumer(buffer ) ) )    the program above spawns one producer and two consumers accessing the same 1-place buffer . because of",
    "nondeterminism it is unreasonable to expect that the buffer _ receives _ alternated messages ` insert ` and ` remove ` .",
    "thanks to its chemical semantics , however , it is guaranteed that the buffer _ handles _ the messages in the correct sequence .",
    "interestingly , the definition of the new class ` buffer ` is identical to the previous ones but for the usage of ` chemreact ` and ` chembecome ` methods introduced by the ` chemical ` mix - in .",
    "therefore , we have that with a simple mix - in the clean tsop definition mentioning only the intended messages at the intended states is actually robust in a fully concurrent context .",
    "we finally remark that in lines 41 - 43 above we relied on the contravariance of the type parameter of the class ` typedref[-t ] ` : indeed , the ` buffer ` reference , which is of type ` typedref[bufferinterf ] ` , is passed as a parameter to the ` producer ` , resp . `",
    "consumer ` , constructor which instead expects a parameter of super - type ` typedref[produceint ] ` , resp . `",
    "typedref[consumeint ] ` .      for the sake of completeness we rephrase the code above to show the integration of the chemical semantics with the ` continuation ` monad .",
    "in particular , the ` chemical ` trait is implemented by means of the ` stash ` trait and it is modified ( line 5 ) to keep the specific kind of messages that in this scenario will be sent to an ` actor ` , that is pairs ` ( m , p ) ` where ` m ` is the actual message and ` p ` is the promise instance to be filled upon message handling .",
    "the rest of the code is straightforward : the buffer protocol is declared in the companion object and the ` buffer ` class mixes - in the ` chemical ` trait and defines the actor in a typestate - oriented style .",
    "finally , the ` producer ` and ` consumer ` classes define user actors by means of the for - notation .",
    "trait protocolmsg    trait chemical extends actor with stash    private def check ( ) = unstashall ( ) private def keep : receive = case ( m : protocolmsg , p ) = > stash ( )    def chembecome(newstate : receive ) = check ( ) ; context.become(newstate ) def chemreact(behave : receive):receive = behave orelse keep    object buffer // protocol for a buffer with concurrent producers and consumers def protocol : bufferinterf = > continuation = case insert(v ) = > new continuation type t= produceint val p = promise[protref[produceint ] ] val f = p.future case remove ( ) = > new continuation type t = consumeint val p = promise[protref[consumeint ] ] val f = p.future def afterinsert[u](o : protref[u]):protref[produceint ] = o.asinstanceof[protref[produceint ] ] def afterremove[u](o : protref[u]):protref[consumeint ] = o.asinstanceof[protref[consumeint ] ]    class buffer extends actor with chemical def empty : receive = chemreact case ( insert(x),p : promise[protref[produceint ] ] ) = > chembecome(full(x ) ) p success new protref[produceint](self , buffer.protocol ) def full(x : int ) : receive = chemreact case ( remove(),p : promise[protref[consumeint ] ] ) = > chembecome(empty ) p success new protref[consumeint](self , buffer.protocol ) def receive = empty    class producer(buffer : protref[produceint ] ) extends actor    for o < - buffer tytell insert(0 ) o < - buffer.afterinsert(o ) tytell insert(10 ) o < - buffer.afterinsert(o ) tytell insert(20 ) o < - buffer.afterinsert(o ) tytell insert(30 ) o < - buffer.afterinsert(o ) tytell insert(40 ) yield println(``end producer '' )    def receive = partialfunction.empty    class consumer(buffer : protref[consumeint ] ) extends actor    for o < - buffer tytell remove ( ) o < - buffer.afterremove(o ) tytell remove ( ) o < - buffer.afterremove(o ) tytell remove ( ) o < - buffer.afterremove(o ) tytell remove ( ) yield println(``end consumer '' )    def receive = partialfunction.empty    val s = actorsystem ( ) val bufferuntyped = s.actorof(props(new buffer),``buffer '' ) val buffer = new protref[bufferinterf](bufferuntyped , buffer.protocol ) //use contravariance val producer = s.actorof(props(new producer(buffer ) ) ) val consumer = s.actorof(props(new consumer(buffer ) ) )",
    "in this section we address a more complex example , showing that our solution for typestate - oriented actor programming is effective even with more complex protocols .",
    "more precisely , we consider an example coming from the literature about session types , i.e. the bookshop server ( cf .",
    "a client accessing the server initially adds a number of items to the shopping basket , then asks for the checkout and sends information about the credit card and the shipping .",
    "the bookshop protocol is defined by the recursive session type ` shop = & < add:?book.shop , checkout:?card.?address.end > ` , which essentially corresponds to the tsop protocol defined by the following fsm :        in order to define this protocol in terms of scala types , we first choose the names of the five possible states and the corresponding interfaces ( lines 2 - 6 and 8 - 12 ) .",
    "state transitions are then encoded in the ` shop ` companion object ( lines 15 - 41 ) .",
    "since the bookshop can be accessed by multiple concurrent users , we need to decide a serving policy .",
    "initially we let the bookshop completely serve one user at a time , and we rely on the chemical semantics to keep initial requests that may concurrently arrive from a user while serving another one .",
    "therefore , we tag with type ` protocolmsg ` only the initial message ` add ` ( line 8) .",
    "we will later discuss other choices that allow a greater degree of concurrency .",
    "trait shopinterface trait initinterf extends shopinterface // with protocolmsg trait whichinterf extends shopinterface trait cinfointerf extends shopinterface trait addinfointerf extends shopinterface trait endinterf extends shopinterface    case class add(name : string ) extends initinterf with protocolmsg case class checkout(name : string ) extends initinterf case class book(name : string , b : string ) extends whichinterf case class card(name : string , cardnum : string ) extends cinfointerf case class address(name : string , add : string ) extends addinfointerf    object shop def protocol : shopinterface = > continuation = case add(n ) = > new continuation type t = whichinterf val p = promise[protref[whichinterf ] ] val f = p.future case checkout(n ) = > new continuation type t= cinfointerf val p = promise[protref[cinfointerf ] ] val f = p.future case book(n , b ) = > new continuation type t = initinterf val p = promise[protref[initinterf ] ] val f = p.future case card(n , cn ) = > new continuation type t = addinfointerf val p = promise[protref[addinfointerf ] ] val f = p.future case address(n , add ) = > new continuation type t = endinterf val p = promise[protref[endinterf ] ] val f = p.future def afteradd[u](o : protref[u]):protref[whichinterf ] = o.asinstanceof[protref[whichinterf ] ] def afterco[u](o : protref[u]):protref[cinfointerf ] = o.asinstanceof[protref[cinfointerf ] ] def afterbook[u](o : protref[u]):protref[initinterf ] = o.asinstanceof[protref[initinterf ] ] def aftercard[u](o : protref[u]):protref[addinfointerf]=o.asinstanceof[protref[addinfointerf ] ] def afteraddress[u](o : protref[u]):protref[endinterf ] = o.asinstanceof[protref[endinterf ] ]    class shop extends actor with chemical    private val shopbasket : map[string , string ] = map[string , string ] ( )    def init : receive = chemreact    case ( add(n),p : promise[protref[whichinterf ] ] ) = >",
    "println(n+ `` please chose a book '' ) p success new protref[whichinterf](self , shop.protocol ) context.become(which )    case ( checkout(n),p : promise[protref[cinfointerf ] ] ) = > println(``start payment for ' ' + n ) p success new protref[cinfointerf](self , shop.protocol ) context.become(cinfo )    def which : receive = chemreact case ( book(n , b),p : promise[protref[initinterf ] ] ) = > println(b+``put in the basket of ' ' + n ) if(shopbasket.contains(n ) ) shopbasket(n ) + = ( `` ' ' + b ) else shopbasket + = ( n->b ) p success new protref[initinterf](self , shop.protocol ) context.become(init ) //",
    "ensures that the current user // completes the shopping without interleaving other users // or use chembecome(init ) to recheck soup !",
    "def cinfo : receive = chemreact case ( card(n , c),p : promise[protref[addinfointerf ] ] ) = > println(``using card n.''+c+``of ' ' + n ) p success new protref[addinfointerf](self , shop.protocol ) context.become(addinfo )    def addinfo : receive = chemreact case ( address(n , a),p : promise[protref[endinterf]])= > println(``shipping ' ' + shopbasket(n)+ `` to ' ' + n+ `` in ' ' + a ) shopbasket.remove(n ) p success new protref[endinterf](self , shop.protocol ) chembecome(init ) // rechecks the soup searching for //",
    "another client to serve    def receive = init    notice that the ` shop ` actor is defined as a stateful object with four different behaviors , each one handling only the messages expected to be received in the corresponding state .",
    "the additional state ` end ` appearing in the public protocol is only used by the users : indeed , at the end of the interaction , the users receive a continuation of type ` protref[endinterf ] ` ( line 82 ) that ensures that no further message can be sent to the ` shop ` actor since ` endinterf ` corresponds to the shop s empty interface .",
    "every shop s behavior calls the ` chemreact ` method to keep ` add ` messages that might arrive at any moment from a user different form the one that is currently served . on the other hand , the `",
    "chembecome ` method is called only in line 83 at the end of the interaction with the current user .",
    "indeed , while ` context.become ` simply changes the actor s state / behavior , the ` chembecome ` method also re - sends the saved ` add ` messages so that they can be eventually handled .    in order to increase the throughput of the server",
    ", we can let the bookshop interleave the shopping phases and the checkout phases of different users .",
    "more precisely , each time the shop gets back to state ` init ` , it can start serving the shopping or the checkout of another actor . to change the policy in this way it is sufficient to ( @xmath0 ) collect in the chemical soup both",
    "the ` add ` and ` checkout ` messages , that is to tag with type ` protcolmsg ` the entire ` initinterf ` interface ( line 2 ) , and ( @xmath1 ) allows a recheck of the saved messages each time the shop enters the ` init ` state , which means using ` chembecome ` instead of ` context.become ` in line 67 .",
    "we conclude by showing the code of a program that spawns a bookshop and three users that buy a couple of books each :    class user(shop : protref[initinterf ] , name : string , info : map[string , string ] ) extends actor    for o < - shop tytell add(name ) o < - shop.afteradd(o ) tytell book(name , info(``book1 '' ) ) o < - shop.afterbook(o ) tytell add(name ) o < - shop.afteradd(o ) tytell book(name , info(``book2 '' ) ) o < - shop.afterbook(o ) tytell checkout(name ) o < - shop.afterco(o ) tytell card(name , info(``cc '' ) ) //",
    "shop.afterco(o ) tytell address ( ... ) shipping without paying does not compile !",
    "o < - shop.aftercard(o ) tytell address(name , info(``addr '' ) ) yield println(name+ `` ended shopping '' )    def receive = partialfunction.empty    val s = actorsystem ( ) val untypedshop = s.actorof(props(new shop),``shop '' ) val shop = new protref[initinterf](untypedshop , shop.protocol )    val infom1=map(``book1''->``pride and prejudice'',``book2''->``odissea'',``cc '' ->``1234'',``addr''->``padua '' ) val infom2=map(``book1''- > `` ben hur '' , `` book2''->``pinocchio'',``cc '' ->``1212 '' , `` addr '' - > `` venice '' ) val infom3=map ( `` book1''- > `` java8 '' , `` book2''->``scala'',``cc '' ->``8888 '' , `` addr '' - > `` newyork '' ) val user1 = s.actorof(props(new user(shop,``mary'',infom1 ) ) ) val user2 = s.actorof(props(new user(shop,``jane'',infom2 ) ) ) val user3 = s.actorof(props(new user(shop,``alice'',infom3 ) ) )    notice that in this code any attempt at sending an ` address ` message just after the message ` checkout ` without sending the credit card number , results in a type safety error .",
    "indeed , the reference ` shop.afterco(o ) ` in line 8 has type ` protref[cinfointerf ] ` , hence it only accepts ` card ` messages . on the other hand",
    ", this typing can only prevent wrong message sends but can not guarantee that intended messages will be actually sent .",
    "for instance , a user which starts the interaction with the bookshop but never sends the final ` address ` message would satisfy the compiler even if it would leave the shop in an intermediate state .",
    "the full behavioral typing we studied in @xcite captures these issues byt it requires linear types , which are not available in the standard scala compiler .",
    "the aim of the tsop approach is opposite to that of defensive programming : instead of adding code to the stateful object to protect it from wrong accesses , it checks the user code and statically marks the wrong accesses as untyped actions .",
    "we illustrated by means of examples that scala akka effectively supports typestate - oriented actor programming .",
    "an actor can be defined as a stateful object by letting states correspond to actor behaviors that possibly handle different sets of messages .",
    "then , a dynamic change of behavior corresponds to a change of actor s interface .",
    "moreover , by fully encoding stateful protocols into typed expressions , we can let the scala compiler check that the actor will only handle intended messages at the intended times . nevertheless , a fair amount of defensive programming is still needed since static detection of violations of protocol obligations ( e.g. , ensuring that an intended message is eventually sent ) requires the verification of linear properties that are currenlty beyond the expressive power of the scala type system .",
    "moreover , the integration of tsop with the fault tolerance properties required in distributed actor systems is still an open research issue .    we conclude observing that even if tsop enables the coordination of concurrent entities , it certainly does not solve the general problem .",
    "indeed a protocol - oriented programming paradigm requires more than a single conceptual model and suitable abstractions and programming patterns can only emerge as a productive integration of different techniques , both at the high level ( i.e , techniques to express and verify coordination properties ) and at the lower level ( i.e. , language abstractions , performace and scalability issues ) .",
    "we thank the passionate people of scala by the lagoon , the venice area scala user group , for the insightful comments and the stimulating discussions .",
    "jonathan aldrich , joshua sunshine , darpan saini , and zachary sparks .",
    "typestate - oriented programming . in _ proceedings of the 24th acm sigplan conference companion on object - oriented programming , systems , languages , and applications ( oopsla09 ) _ , pages 10151022 .",
    "acm , 2009 .",
    "kevin bierhoff and jonathan aldrich .",
    "modular typestate checking of aliased objects . in _ proceedings of the 22nd annual acm sigplan conference on object - oriented programming systems and applications ( oopsla07 )",
    "_ , pages 301320 .",
    "acm , 2007 .",
    "giulia brusaferro .",
    "un calcolo formale per gli",
    "attori scala akka e i loro tipi .",
    "thesis of the ms degree in computer science under the supervision of s. crafa .",
    "universit di padova , italy .",
    "paduathesis n.52659 .",
    "http://tesi.cab.unipd.it/52659/ , 2016 .",
    "silvia crafa and luca padovani . .",
    "in _ proceedings of the acm international conference on object - oriented programming , systems , languages , and applications ( oopsla15 ) _ , volume  50 of _ acm sigplan notices _ , pages 917934 .",
    "acm , 2015 .",
    "cdric fournet and georges gonthier .",
    "the reflexive cham and the join - calculus .",
    "in _ proceedings of the 23rd acm sigplan - sigact symposium on principles of programming languages ( popl96 ) _ , pages 372385 .",
    "acm , 1996 .",
    "philipp haller and tom  van cutsem . implementing joins using extensible pattern matching . in _ proceedings of the 10th international conference on coordination models and languages ( coordination08 )",
    "_ , lncs 5052 , pages 135152 .",
    "springer , 2008 .",
    "carl hewitt , peter bishop , and richard steiger .",
    "a universal modular actor formalism for artificial intelligence . in _ proceedings of the 3rd international joint conference on artificial intelligence ( ijcai73 )",
    "_ , pages 235245 .",
    "william kaufmann , 1973 .",
    "kohei honda , nobuko yoshida , and marco carbone . multiparty asynchronous session types . in _ proceedings of the 35th acm sigplan - sigact symposium on principles of programming languages ( popl08 ) _ , pages 273284 .",
    "acm , 2008 .",
    "g.  stewart  von itzstein and mark jasiunas . on implementing high level concurrency in java .",
    "in _ proceedings of the 8th asia - pacific conference on advances in computer systems architecture ( acsac03 ) _ , lncs 2823 , pages 151165 .",
    "springer , 2003 .",
    "julien lange , emilio tuosto , and nobuko yoshida . from communicating machines to graphical choreographies . in _ proceedings of the 42nd annual acm sigplan - sigact symposium on principles of programming languages ( popl15 ) _ , pages 221232 .",
    "acm , 2015 .",
    "joshua sunshine , karl naden , sven stork , jonathan aldrich , and ric tanter .",
    "first - class state change in plaid . in _ proceedings of the 26th acm international conference on object - oriented programming systems , languages , and applications ( oopsla11 )",
    "_ , pages 713732 .",
    "acm , 2011 ."
  ],
  "abstract_text": [
    "<S> typestate - oriented programming is an extension of the oo paradigm in which objects are modeled not just in terms of interfaces but also in terms of their usage protocols , describing legal sequences of method calls , possibly depending on the object s internal state . </S>",
    "<S> we argue that the actor model allows typestate - oop in an inherently distributed setting , whereby objects / actors can be accessed concurrently by several processes , and local entities cooperate to carry out a communication protocol . in this article </S>",
    "<S> we illustrate the approach by means of a number of examples written in scala akka . </S>",
    "<S> we show that scala s abstractions support clean and natural typestate - oriented actor programming with the usual asynchronous and non - blocking semantics . </S>",
    "<S> we also show that the standard type system of scala and a typed wrapping of usual ( untyped ) akka s ` actorref ` are enough to provide rich forms of type safety so that well - typed actors respect their intended communication protocols .    </S>",
    "<S> this approach draws on a solid theoretical background , consisting of a sound behavioral type system for the join calculus , that is a foundational calculus of distributed asynchronous processes whose semantics is based on the chemical abstract machine , that unveiled its strong connections with typestate - oriented programming of both concurrent objects and actors . </S>"
  ]
}