{
  "article_text": [
    "precision of floating - point operations is sometimes of serious concern in simulation physics when rounding errors in variables or matrix elements considerably affect numerical results for investigated physical phenomena @xcite .",
    "there are several programming libraries , e.g. , refs .",
    "@xcite , for high - precision computing , which are helpful in this regard . among them , the library named zkcm @xcite , which we have been developing , is a c++ library for multiprecision complex - number matrix computation .",
    "it provides several functionalities including the lu decomposition , the singular value decomposition , the tensor product , and the tracing - out operation and an easy - to - use syntax for basic operations .",
    "it is based on the gnu mp ( gmp ) @xcite and mpfr @xcite libraries , which are commonly included in recent distributions of unix - like systems .",
    "there is an extension library named zkcm_qc .",
    "this library is designed for simulating quantum computing @xcite by the time - dependent matrix - product - state method @xcite [ or , simply referred to as the matrix - product - state ( mps ) method ] .",
    "it uses a matrix product state @xcite to represent a pure quantum state .",
    "the mps method is recently one of the standard methods for simulation - physics software @xcite . as for other methods effective for simulating quantum computing , see , e.g. , refs .  @xcite . with zkcm_qc ,",
    "one may use quantum gates in @xmath3 , @xmath4 , and @xmath5 as elementary gates .",
    "indeed , in general , quantum gates in @xmath6 and @xmath4 are enough for universal quantum computing @xcite , but we regard quantum gates in @xmath5 also as elementary gates so as to reduce computational overheads in circuit constructions .    a simulation of quantum computing with mps is known for its computational efficiency in case the schmidt ranks are kept small during the simulation @xcite . even for the case",
    "slightly large schmidt ranks are involved , it is not as expensive as a simple simulation .",
    "the theory of mps simulation will be briefly explained in sec .",
    "[ sectheory ] .",
    "numerical errors will be phenomenologically discussed in sec .",
    "[ secdj ] , which will give a certain reason why we introduce multiprecision computation for an mps simulation of quantum computing .",
    "this contribution is intended to provide a useful introduction for programming with the libraries .",
    "section  [ seczkcm ] describes two examples of the use of the zkcm library : one for showing the precision dependence of a solution of a simple linear equation ; the other for simulating an nmr spectrum in a simple model .",
    "performance evaluation of the library is made in sec .",
    "[ secpe ] .",
    "section  [ seczkcmqc ] shows an overview of the theory of the mps method and an example of simulating a simple quantum circuit using the zkcm_qc library .",
    "in addition , later in the section numerical errors in an mps simulation of quantum computing are examined using a certain setup of a quantum algorithm .",
    "we discuss on the effectiveness and the performance of our libraries in sec .",
    "[ secdiscussion ] .",
    "section [ secsummary ] summarizes our achievements .",
    "the zkcm library is designed for general - purpose matrix computation .",
    "this section concentrates on its main library .",
    "it has two major c++ classes : `` ` zkcm_class ` '' and `` ` zkcm_matrix ` '' .",
    "the former class is a class of a complex number .",
    "many operators like `` ` + = ` '' and functions like trigonometric functions are defined for the class .",
    "the latter class is a class of a matrix .",
    "standard operations and functions like matrix inversion are defined .",
    "in addition , the singular - value decomposition of a general matrix , the diagonalization of an hermitian matrix , the discrete fourier transform , etc . , are defined for the class .",
    "functoins for the tensor product ( kronecker product ) and the tracing - out operation ( e.g. , one can trace out the subsystem b of system abc ) are also defined . a detailed document is placed in the `` doc '' directory of the package of zkcm .    as for installation of the library , the standard process `` ` ./configure",
    "` @xmath7 ` make ` @xmath7 ` sudo make install ` '' works in most cases ; otherwise the document should be consulted .",
    "we will next look at simple examples to demonstrate the programming style using the library .",
    "( here , the latest stable version , ver .",
    "0.3.2 , is used . )",
    "[ [ example-1 ] ] example 1 + + + + + + + + +    there is a classical example @xcite often mentioned to recall the importance of multiprecision computation .",
    "it clarifies that a sufficiently large precision is required even for a simple linear equation with only two variables .",
    "consider the linear equation @xmath8 with @xmath9 the exact solution is @xmath10 .",
    "one way to numerically find the solution is to compute @xmath11 using the matrix inversion .",
    "another way is to utilize the gaussian elimination ( see , _",
    "e.g. _ , refs .",
    "we used functions `` ` inv ` '' and `` ` gauss ` '' of zkcm for the former and the latter ways , respectively ( as for pivoting , a partial pivoting is used in `` ` gauss ` '' ) .",
    "then , we plotted the computed value of @xmath12 against the precision [ bits ] as shown in fig .",
    "[ figclassical ] .",
    "( here , we refer to the number of bits for a significand of a floating - point number as precision . )",
    "we can see that low - precision computing resulted in a wrong answer while high - precision computing resulted in a correct answer .",
    "it should be emphasized that the double precision ( namely , 53 bits for the mantissa portion of a floating - point number ) is not enough in this example .",
    "plot of the computed values of @xmath12 against the precision ( the bit length of a mantissa ) employed for floating - point numbers . either ( i ) the matrix inversion ( pluses ) or ( ii ) the gaussian elimination ( circles ) was used . for case ( ii ) , there are data points with @xmath12 values @xmath13 for some values of precision @xmath14 ; they are outside the range in the figure.,width=298 ]    the program used for this example is shown in listing  [ codeclassic ] .",
    "it is found as `` samples / classic_example.cpp '' in the package .",
    "it is written to use the matrix inversion . to use the gaussian elimination ,",
    "the line `` ` b = inv(a ) * b ; ` '' should be replaced with `` ` b = gauss(a , b ) ; ` '' .",
    ".... # include \" zkcm.hpp \" # include < fstream > int main ( ) {    std::ofstream ofs(\"classic_example.dat \" ) ;    if ( !",
    "ofs )    {      std::cerr <",
    "< \" could not create the file\\   classic_example.dat \"",
    "< < std::endl ;      return -1 ;    }    ofs < < \" # prec x y \" < < std::endl ;    for ( int prec = 32 ; prec < 257 ; prec++ )    {      zkcm_set_default_prec(prec ) ;      zkcm_matrix a(2 , 2 ) , b(2 , 1 ) ;        a(0 , 0 ) = \" 64919121 \" ;      a(0 , 1 ) = \" -159018721 \" ;      a(1 , 0 ) = \" 41869520.5 \" ;      a(1 , 1 ) = \" -102558961 \" ;        b(0 , 0 ) = 1 ;      b(1 , 0 ) = 0 ;        b = inv(a ) * b ;      //replace the above line with      //b = gauss(a , b ) ;      //to use the gaussian elimination instead .",
    "ofs < < prec < < \" \"          < < b(0 , 0 ) < < \" \"          < < b(1 , 0 ) < < std::endl ;    }    zkcm_quit ( ) ;    return 0 ; } ....    the program is compiled and executed in a standard way .",
    "its output file `` classic_example.dat '' can be visualized by gnuplot @xcite using the file `` classic_example.gnuplot '' found in the `` samples '' directory .    in the program",
    ", one can see typical features of the zkcm library .",
    "the line `` ` zkcm_set_default_prec(prec ) ; ` '' sets the default internal precision ( the default bit length of a significand ) of an object to `` ` prec ` '' .",
    "any object like `` ` a ` '' ( this is a @xmath15 matrix ) constructed without specified precision possesses the default precision .",
    "it is possible to specify a particular precision ( _ i.e. _ , in case of a matrix object , the length of the significand for each part of each element of the matrix ) , say , 512 , by constructing the object as `` ` zkcm_matrix a(2 , 2 , 512 ) ` '' , for instance . for a matrix object , say , `` `",
    "a ` '' , it is convenient to access its @xmath16 element by `` ` a(i , j ) ` '' that is a reference to the element .",
    "the element is an object in the type of `` ` zkcm_class ` '' . to assign a value into a `` ` zkcm_class ` '' object ( a complex number ) `` ` z ` '' , one can write `` ` z= ... ; ` '' where the right - hand side can be a number or a string describing a complex number in the style ` \" _ _ _ + _ _ _ * i \" ` ( pari / gp style @xcite ; here , `` ` i ` '' stands for @xmath17 ) , ` \" _ _",
    "_ + _ _ _ i \" ` , ` \" _ _",
    "_ + _ _ _ j \" ` ( here , `` ` j ` '' stands for @xmath18 ) , etc .",
    "( there are other acceptable styles ) . in the program , by `` ` a(0 , 0 ) = \" 64919121 \" ; ` '' the value @xmath19 is assigned to the @xmath20 element of matrix ` a ` .",
    "other values are assigned to corresponding elements in a similar way .",
    "the solution of the linear equation is obtained by using the function `` ` inv ` '' or `` ` gauss ` '' .",
    "the obtained result is written into the output file stream `` ` ofs ` '' by using the operator `` ` < < ` '' . in the program ,",
    "the elements are individually written out so as to meet the data format of a data - plotting program .",
    "after computation is performed , the program should be terminated . at this stage , it is recommended to write `` ` zkcm_quit ( ) ; ` '' so as to release miscellaneous memories allocated for internal use of background library functions .",
    "[ [ example-2 ] ] example 2 + + + + + + + + +    as the second example , a sample program `` nmr_spectrum_simulation.cpp '' found in the `` samples '' directory of the package of zkcm is explained .",
    "this program generates a simulated free - induction - decay ( fid ) spectrum of liquid - state nmr for the spin system consisting of a proton spin with precession frequency @xmath21  400 mhz ( variable `` ` w1 ` '' in the program ) and a @xmath22 spin with precession frequency @xmath23  125 mhz ( variable `` ` w2 ` '' ) at room temperature ( 300 k ) ( variable `` ` t ` '' ) .",
    "a j coupling constant @xmath24 khz ( variable `` ` j12 ` '' ) is considered for the spins .",
    "the first line of the program is to include a header file of zkcm :    .... # include \" zkcm.hpp \" int main(int argc , char * argv [ ] ) { ....    in the beginning of the `` ` main ` '' function , the default precision is set to 280 bits by    ....    zkcm_set_default_prec(280 ) ; ....    in the subsequent lines , some matrices like pauli matrices @xmath25 and @xmath26 , etc . are generated .",
    "for example , @xmath26 is generated as    ....",
    "zkcm_matrix x = \" [ 0 , 1 ; 1 , 0 ] \" ; ....    using a string representing a matrix in the pari / gp style .",
    "the @xmath27 pulse is generated as    ....",
    "zkcm_matrix yhpi(2,2 ) ;    yhpi(0,0 ) = sqrt(zkcm_class(0.5 ) ) ;    yhpi(0,1 ) = sqrt(zkcm_class(0.5 ) ) ;    yhpi(1,0 ) = -sqrt(zkcm_class(0.5 ) ) ;    yhpi(1,1 ) = sqrt(zkcm_class(0.5 ) ) ;    ....    other matrices are generated by similar lines .",
    "after this , values of constants and parameters are set .",
    "for example , the boltzmann constant @xmath28 [ j / k ] is generated as    ....    zkcm_class kb(\"1.3806504e-23 \" ) ; ....    the hamiltonian @xmath29 of the spin system is generated in the type of `` ` zkcm_matrix ` '' and is specified as    ....    h = w1 * tensorprod(z/2,i ) + w2 * tensorprod(i , z/2 )        + j12 * tensorprod(z/2,z/2 ) ; ....    this is used to generate a thermal state @xmath30 :    ....    zkcm_matrix rho(4,4 ) ;    rho = exp_h((-hplanck / kb / t ) * h ) ;    rho /=",
    "trace(rho ) ; ....    here , `` ` exp_h ` '' is a function to calculate the exponential of an hermitian matrix and `` ` hplanck ` '' is the planck constant ( @xmath31 js ) .",
    "the sampling time interval @xmath32 to record the value of @xmath33 for the proton spin is set to @xmath34 ( any number smaller than @xmath35 might be fine instead of @xmath36 ) by    ....",
    "zkcm_class dt(zkcm_class(\"0.43\")/w1 ) ; ....    the number of data to record is then decided as    ....    int n = unp2(8.0/dt / j12 ) ; ....    here , function `` ` unp2 ` '' returns the integer upper nearest power of 2 for a given number .",
    "now arrays to store data are prepared as row vectors .    ....",
    "zkcm_matrix array(1 , n ) , array2(1 , n ) ; ....    the following lines prepare the @xmath26 and @xmath27-pulse operators acting only on the proton spin .    ....",
    "zkcm_matrix x1(4 , 4 ) , yhpi1(4 , 4 ) ;    x1 = tensorprod(x ,",
    "i ) ;    yhpi1 = tensorprod(yhpi , i ) ; ....    to get an fid data , we firstly tilt the proton spin by the ideal @xmath27 pulse .",
    "....    rho = yhpi1 * rho * adjoint(yhpi1 ) ; ....    now the data of time evolution of @xmath33 of the proton spin under the hamiltonian @xmath29 is recorded for the time duration @xmath37 using    ....    array = rec_evol(rho , h , x1 , dt , n ) ; ....    we now use a zero - padding for this `` ` array ` '' so as to enhance the resolution .",
    "this will extend the array by n zeros .    ....",
    "array2 = zero_padding(array , 2*n ) ; ....    to obtain a spectrum , the discrete fourier transform is applied .    ....",
    "array2 = abs(dft(array2 ) ) ; ....    this `` ` array2 ` '' is output to the file `` example_zp.fid '' as an fid spectrum data with @xmath38 as the frequency interval , in the gnuplot style by    ....",
    "gp_1d_print(array2 , 1.0/dt / zkcm_class(2*n ) ,                1 , \" example_zp.fid \" ) ; ....    at last , the function `` ` main ` '' ends with `` ` zkcm_quit ( ) ; ` '' and `` ` return 0 ; ` '' .",
    "the program is compiled and executed in a standard way .",
    "the result stored in `` example_zp.fid '' is visualized by gnuplot using the file `` example_zp.gnuplot '' placed in the directory `` samples '' , as shown in fig .",
    "[ figzp ] .",
    "plot of the simulation data stored in `` example_zp.fid '' .",
    "see the text for the details of this simulation.,width=298 ]    it should be noted that we have not employed a high - temperature approximation . under a high - temperature approximation ,",
    "the first order deviation @xmath39 of @xmath40 ( here , @xmath41 ) is considered as a deviation density matrix and calculations are performed using the normalized deviation density matrix @xmath42 this approximation is commonly used @xcite but it can not be used for simulations for low temperature .",
    "an advantage of using zkcm for simulating nmr spectra is that the temperature can be chosen .",
    "this is possible because of high accuracy in computing the exponential of a hamiltonian .    as we have seen in this example , zkcm has useful functions to handle matrices , especially those often used in simulations in quantum physics . for the list of available functions ,",
    "see the reference manual found in the package .",
    "we evaluate the performance of zkcm ( version 0.3.2 ) in comparison with pari @xcite ( version 2.5.3 with the gmp kernel ) , a conventional highly - evaluated c library for mathematical computing .      here",
    ", we evaluate the performance of the function `` ` gamma ` '' of zkcm , which calculates @xmath44 for a complex number @xmath45 .",
    "it is implemented on the basis of the expansion using the stirling formula for @xmath46 : @xmath47,\\ ] ] where @xmath48 is the first or the second bernoulli number ( as the absolute value is used , either is fine ) ; @xmath49 is a sufficiently large ( but not very large ) integer to guarantee the accuracy ; @xmath50 is the remainder of the sum ( corresponding to the sum of the terms for @xmath51 ) .",
    "it is known that the expansion is not convergent since @xmath52 grows rapidly for large @xmath53 .",
    "it was , however , proved by spira @xcite that @xmath54 holds when @xmath55 .",
    "thus the expansion is usable for computation with enough accuracy as long as @xmath45 is appropriately scaled to a large value in advance .",
    "we internally scale @xmath45 to satisfy @xmath55 and @xmath56 . in accordance with this scaling , @xmath49 is appropriately chosen so that @xmath50 becomes small enough for required precision . for the scaling ,",
    "the well - known formulae @xmath57 $ ] ( here , @xmath58 is an integer ) and @xmath59 $ ] ( here , @xmath45 is not a pole ) are utilized . to compute bernoulli numbers ,",
    "we utilize the relation @xmath60 and the fact that @xmath61 vanishes for integer @xmath62 .",
    "we keep the computed values of binomial coefficients and bernoulli numbers inside a certain subblock of a function for computing @xmath44 .",
    "therefore , the cost to compute @xmath48 assuming that we have already computed @xmath63 for even number @xmath64 is small : @xmath65 rational - number operations are enough , we can not use this assumption in general . in this case ,",
    "akiyama - tanigawa algorithm @xcite is employed to calculate the bernoulli number .",
    "this takes @xmath66 rational - number operations . ]",
    "( we make use of the c++ class `` ` mpq_class ` '' of gmp for internally handling rational numbers ) .",
    "now , the speed of computing @xmath44 using `` ` gamma ` '' is evaluated for @xmath67 with random @xmath68 $ ] .",
    "it is compared with the function with the same name , `` ` gamma ` '' , of the pari library .",
    "the pari library uses a similar algorithm to compute @xmath44 .",
    "the main difference is that pari can utilize cached values of bernoulli numbers that are once calculated in any function during a process is running .",
    "it can also use precomputed values of typical constants .    as shown in table",
    "[ tablegamma ] , the average computation time of @xmath44 in the zkcm library is on the same order of magnitude as that in the pari library in the absence of cached values of bernoulli numbers .",
    "however , in the presence of cached values of bernoulli numbers , the computation speed of @xmath44 in pari is quite much faster .",
    ".[tablegamma]comparison of the average real time consumption for computing @xmath44 for @xmath67 with random @xmath68 $ ] .",
    "the average was taken over 1,000 trials .",
    "no i / o operation was involved .",
    "time for generating @xmath45 was negligible ( this was no more than @xmath69 seconds ) . the standard deviation ( we employ the sample standard deviation ) for each entry",
    "is shown in parentheses in small fonts under the entry .",
    "`` prec '' stands for the precision ( the bit length of each mantissa ) employed in a program . in a program using pari , function `` nbits2prec '' was used to convert the precision into the number of code words that is defined as the precision for variables in pari .",
    "zkcm version 0.3.2 and pari version 2.5.3 were used .",
    "they were compiled with gcc / g++ with their default optimization flags , while test programs for this performance evaluation were compiled without optimization flags.in this table , the middle and the right columns show the results for pari with and without precomputed values of bernoulli numbers , respectively .",
    "environments : for upper entries ( @xmath70 ) : fedora 15 64-bit operating system on intel core i5 m460 cpu ( 2.53 ghz , max .",
    "2.80ghz ) with 4 gb ram . for lower entries ( @xmath71 ) : fedora 16 64-bit operating system on amd fx-8120 cpu ( 3.10ghz , max .",
    "4.00ghz ) with 16 gb ram . [ cols=\">,<,<,<\",options=\"header \" , ]     for precision less than or equal to 55 bits , some of matrix diagonalization routines failed after the half point of the circuit , which indicates an accumulated error due to precision shortage .",
    "more specifically speaking about this case , a small non - hermitian fraction due to the accumulated error in a reduced density matrix resulted in the convergence error of eigenvectors during an update of tensors .",
    "with the zkcm library , standard tasks in numerical matrix calculations can be completed within the time consumption on the same order of magnitude as that with the pari library as we have seen in the comparison performed in sec .",
    "[ secpe ] .",
    "the comparison also showed that zkcm is slower than pari , even in a simple matrix multiplication , which suggests that basic arithmetic operations make a certain gap in speed of the two libraries .",
    "in fact , zkcm uses mpfr functions while pari uses gmp functions for the basic arithmetic computation .",
    "mpfr is approximately two and a half times as slow as gmp in multiplying floating - point numbers as far as we tested . with @xmath72 for @xmath73 times where the initial value of @xmath12 was set to @xmath74 .",
    "the precision was set to 512 bits .",
    "it took @xmath75 seconds on average ( with standard deviation @xmath76 ) when we used mpfr s `` mpfr_t '' structure for floating point numbers while it took only @xmath77 seconds on average ( with standard deviation @xmath78 ) when we used gmp s `` mpf_t '' structure .",
    "the average was taken over ten trials .",
    "this test was performed on a machine with the fedora 15 64-bit os , intel core i5 m460 cpu , and 4 gb ram .",
    "gmp version 4.3.2 and mpfr version 3.0.0 were used . ]",
    "thus it is reasonable to find a certain gap in computational speed .",
    "we believe the gap is acceptable as long as it does not change the order of magnitude of computation time for basic matrix computation .",
    "it has been probably a historical reason that pari has not used mpfr so far .",
    "we chose mpfr because it has floating - point exceptions and other useful functionalities for real floating - point numbers by default .    the only unexpected result in sec .",
    "[ secpe ] is the one about hermitian matrix diagonalization shown in tables [ tableherm ] and [ tableherm2 ] .",
    "it has been shown that time consumptions of functions `` ` diag_h ` '' of zkcm and `` ` eigen ` '' and `` ` jacobi ` '' of pari are on the same order of magnitude .",
    "this is an unusual result because the jacobi method employed in `` ` jacobi ` '' looks as fast as a variant of the qr method employed in `` ` diag_h ` '' for a @xmath2 matrix .",
    "it is likely that `` ` diag_h ` '' and `` ` jacobi ` '' are used for a similar purpose or under a similar situation , since they both work fine for a matrix with degenerate eigenvalues .",
    "( it is known @xcite that `` ` eigen ` '' almost always fails for a matrix with degenerate eigenvalues . ) in this point of view , too , it is meaningful to compare `` ` diag_h ` '' and `` ` jacobi ` '' .",
    "as mentioned above , function `` ` jacobi ` '' of pari is an implementation of a standard jacobi method .",
    "function `` ` diag_h ` '' of zkcm employs the householder - qr method with the wilkinson shift for computing approximate eigenvalues and uses several sets of inverse iterations to find eigenvectors and at the same time to enhance the accuracy of eigenvalues .",
    "it has been commonly known that the jacobi method is slower than the qr method : `` for matrices of order greater than about 10 , however , the algorithm is slower , by a significant constant factor , than the qr method ... ''|page 571 of ref .  @xcite ; `` ... the jacobi method is several times slower than a reduction to tridiagonal form , followed by francis s algorithm.''|page 488 of ref .  @xcite .",
    "thus , it is unusual that , for a relatively large matrix with the order @xmath79 , there is no significant advantage in using the householder - qr method . in a phenomenological explanation",
    ", this is due to the large cost of inverse iterations . by using the gprof program @xcite ( a monitoring software )",
    ", it turned out that , in `` ` diag_h ` '' , more than 71.1 percent of running time was spent for the inverse iterations in case of a @xmath2 matrix with the precision @xmath80 [ bits ] . in fact",
    "speedup of one or two orders of magnitude was possible by omitting inverse iterations for finding eigenvalues as we have shown in tables [ tableei1 ] and [ tableei2 ] .",
    "it was however impossible to achieve a required precision without inverse iterations as clearly shown in the tables .",
    "thus , it was unexpectedly expensive to achieve a sufficient convergence by inverse iterations .",
    "we , of course , used the lu decomposition to reduce the cost of each inverse iteration .",
    "this , however , did not mitigate the total cost of the inverse iterations sufficiently . as a matter of fact ,",
    "the total number of the inverse iterations had to be increased along with the increase in required precision .",
    "this , at a glance , does not look in accordance with a conventional theory of inverse iteration @xcite suggesting that the machine epsilon does not make a difference in the process of inverse iteration .",
    "the conventional theory , however , considers the process where the inverse iteration is used for computing an eigenvector for a given approximate eigenvalue . in our case , in contrast , we also improve accuracy of the eigenvalue using the computed eigenvector .",
    "a routine of inverse iteration is often called several times in order for achieving sufficient accuracy for each pair of an eigenvalue and the corresponding eigenvector .",
    "furthermore , program routines called by the routine of inverse iteration are not error - free in practice .",
    "thus it was not surprising that the choice of precision considerably affected the cost of inverse iterations ( and hence the time consumption of `` ` diag_h ` '' shown in table [ tableei1 ] ) .",
    "another factor that makes inverse iterations expensive is the cost of basic arithmetic operations in multiprecision computing .",
    "unlike double - precision computing where every basic arithmetic instruction is performed within a few clock cycles , it takes quite many cycles .",
    "takes @xmath81 time with @xmath82 dependent on the chosen algorithm . in real cpu time",
    ", it should scale slightly better in practice because of vectorization of operands .",
    "see the manual of gmp @xcite for the details of algorithms for arithmetic instructions . ]",
    "it is fast in double - precision computing to successively perform arithmetic instructions because this does not involve any conditional branching .",
    "in contrast , it is inevitable to involve several conditional branching instructions in every arithmetic operation in multiprecision computing .",
    "thus , the simple fact that basic arithmetic instructions are not hardware instructions should be a large factor .    in future , we should find a strategy for faster hermitian matrix diagonalization .",
    "as a possible approach , the precision of computation for finding approximate eigenvalues can be internally enlarged so that a relatively small number of subsequent inverse iterations should be enough to achieve a required precision .",
    "table [ tableei1 ] , however , shows that accuracy of approximate eigenvalues is not very much enhanced by simply increasing the preset precision in the householder - qr method .",
    "so far , the author could not find the reason of this tendency .",
    "a detailed theoretical and practical analyses of the present implementation ( and perhaps the method itself ) will be required to overcome this difficulty . for another approach",
    ", there is a possibility that a certain method uncommon under the double - precision environment possesses an advantage under a high - precision environment in a practical sense .",
    "it is of interest to re - investigate practical usefulness of conventional methods @xcite for eigenvalue problems under a high - precision environment .",
    "apart from computational speed , the syntax of a library is also important for usability . as a c++ library",
    ", zkcm provides an easy - to - use syntax for handling matrices by operator overloading .",
    "it also provides various functionalities for matrix computation as member functions of a class as well as as external functions .",
    "thus a program code using the library should look simpler than those written with some other multiprecision libraries for fortran or c languages .",
    "in general , it is relatively easy to write an extension library of a c++ library .",
    "as we have introduced , zkcm has an extension library named zkcm_qc developed for a ( time - dependent ) mps simulation of quantum circuits .",
    "the main library and the extension are under steady development .",
    "latest development versions can be downloaded from the repositories linked from the url  @xcite .      as for the zkcm_qc library",
    ", it is worth mentioning that multiprecision computation is useful in mps simulations of quantum computing as discussed in sec .",
    "[ secdj ] .",
    "indeed , truncation errors are dominant whenever truncations of nonzero schmidt coefficients are employed .",
    "it is however uncommon to employ such truncations in simulating quantum computing since they cause an unacceptably large error as we have discussed . as a consequence ,",
    "the rounding error become the only possible error .",
    "in our example , slightly more than double precision was required for reliable mps simulation .",
    "this is true in a different example to simulate quantum search , which is shown in our related contribution @xcite .",
    "thus , time - dependent mps simulation is fragile not only against accumulating truncation errors @xcite but also against accumulating rounding errors .",
    "high - precision computation is therefore beneficial to the mps method .",
    "apart from the mps method , there have been several simulators of quantum computing which make use of parallel programming techniques @xcite to mitigate the time consumption of the brute - force method .",
    "they use a parallelized exact matrix computation and spend a massive computational resource ( _ e.g. _ , more than one thousand cpu processes and several hundred gigabytes physical memory to handle less than forty qubits @xcite ) .",
    "it seems that an accumulation of rounding errors is not significant for these simulators although they use double precision computation , as this was not reported so far .",
    "in contrast to their approach , use of the mps method is quite economical . as we have shown in sec .",
    "[ secdj ] , we could handle 65 qubits in the mps simulation of the deutsch - jozsa algorithm under a certain setup , which ran as a single cpu process and took only ( approximately ) seven minutes in case of 256-bit floating - point precision .",
    "besides the mps method , viamontes",
    "_ s method @xcite using a compressed graph representation is also quite economical to simulate quantum computation .",
    "according to refs .",
    "@xcite , its compressed data structure is sensitive to rounding errors so that they used multiprecision computation based on the gmp library .",
    "the mps data structure ( [ eq1 ] ) is of course a compressed data structure for which we needed multiprecision computation for stable quantum circuit simulation",
    ". it will be interesting to theoretically investigate if a simulation of quantum computing utilizing a compressed data structure generally has a certain inevitable sensitivity to rounding errors .    finally , we discuss on the computational cost of the mps method , which is known to grow polynomially in the maximum schmidt rank @xmath83 during the simulation @xcite as mentioned in sec .",
    "[ sectheory ] .",
    "it is expected that mps simulation becomes very expensive for quantum circuits of algorithms for hard problems like those for quantum prime factorization @xcite of a large composite number .",
    "it has been discussed @xcite that large entanglement ( this usually leads to a large schmidt rank ) must be involved in quantum prime factorization .",
    "so far , kawaguchi _",
    "_ @xcite found schmidt rank @xmath84 in a modular exponentiation circuit ( this is used in quantum prime factorization ) with @xmath85 qubits in their mps simulation .",
    "nevertheless , it has been neither proved nor numerically verified that @xmath83 grows exponentially in the number @xmath53 of qubits as far as the author knows . although there have been several studies on entanglement during quantum prime factorization @xcite , they have not reached an answer to how entanglement grows in @xmath53 .",
    "it is still an open problem how we rigorously estimate the value of @xmath83 for a given quantum circuit . presently , a known upper bound for @xmath83 is a function exponentially growing in the number of basic quantum gates overlapping to each other ( _ i.e. _ , those stretching across the same bundle of wires ) @xcite ; this is however not practically useful for a user of the mps method to estimate the value of @xmath83 for his / her simulation .",
    "more theoretical and numerical efforts are required to understand the scalability of the method .",
    "we have introduced the zkcm library which is a c++ library developed for multiprecision complex - number matrix computation .",
    "it is especially usable for high - precision numerical simulations in quantum physics ; it has an easy - to - use syntax for matrix manipulations and helpful functionalities like the tensor - product and tracing - out operations , the discrete fourier transform , etc .",
    "an extension library zkcm_qc has also been introduced , which is a library for a multiprecision time - dependent matrix - product - state simulation of quantum computing .",
    "it enables a user - friendly coding for simulating quantum circuits .",
    "the library zkcm_qc uses three - qubit gates as elementary gates in addition to single- and two - qubit gates . as it is not usually explained in detail how a three - qubit gate is simulated in a time - dependent mps simulation ,",
    "a detailed explanation is given here .",
    "as for simulations of single- and two - qubit gates , see refs .",
    "@xcite for detailed explanations .",
    "consider the quantum gate @xmath86 acting on the three qubits @xmath87 , @xmath88 , and @xmath89 . with a focus on the three qubits ,",
    "the mps of @xmath53 qubits can be written as @xmath90 with @xmath91 and @xmath92 , where @xmath93 are the schmidt vectors of the block of qubits @xmath94 for the splitting between @xmath95 and @xmath87 , and @xmath96 are those of the block of qubits @xmath97 for the splitting between @xmath89 and @xmath98 .",
    "what we should do as a simulation of applying the quantum gate @xmath99 to @xmath100 is to update tensors @xmath101 , @xmath102 , @xmath103 , @xmath104 , and @xmath105 to @xmath106 , @xmath107 , @xmath108 , @xmath109 , and @xmath110 , respectively , so that the mps with the updated tensors represents the resultant state @xmath111 .",
    "this process is explained hereafter step by step .",
    "( here is some note on the description : in case @xmath112 , the tensor @xmath113 should be regarded as unity and the parameter @xmath114 should be dropped .",
    "similarly , in case @xmath115 , the tensor @xmath116 should be regarded as unity and the parameter @xmath117 should be dropped . )      first , we are going to compute the tensors @xmath120 and @xmath121 of the resultant state .",
    "the reduced density matrix of qubits @xmath122 calculated from eq .",
    "( [ resultant ] ) is @xmath123 ^ 2\\\\ & \\times\\theta(i_l , i_{l+1},i_{l+2},v_{l-1},v_{l+2 } ) \\theta^*({i'}_l , i_{l+1},i_{l+2},{v'}_{l-1},v_{l+2})\\biggr]\\\\ & \\times|v_{l-1}\\rangle|i_l\\rangle\\langle { v'}_{l-1}|\\langle { i'}_l|\\\\ & = \\sum_{i_l v_{l-1 } { i'}_l { v'}_{l-1}}\\biggl [ \\sum_{i_{l+1}i_{l+2}v_{l+2 } } [ v_{l+2}(v_{l+2})]^2\\\\ & \\times \\theta(i_l , i_{l+1},i_{l+2},v_{l-1},v_{l+2 } ) \\theta^*({i'}_l , i_{l+1},i_{l+2},{v'}_{l-1},v_{l+2})\\\\ & \\times v_{l-1}(v_{l-1})v_{l-1}({v'}_{l-1})\\biggr ]      \\langle \\phi_{{v'}_{l-1}}|\\langle { i'}_l| \\end{split}\\ ] ] with @xmath124 $ ] .",
    "the matrix @xmath125 is a @xmath126 matrix .",
    "this is now diagonalized to achieve the eigenvalues @xmath127 ^ 2 $ ] and the corresponding eigenvectors @xmath128 under the basis @xmath129 .",
    "immediately we find the values of @xmath130 .",
    "we may truncate out negligibly small eigenvalues . ] to reduce @xmath131 ( the updated value of @xmath132 , namely , the number of data in @xmath133 ) .",
    "in addition , we have vector elements @xmath134 of just computed eigenvectors : @xmath135 thus we have obtained @xmath136    second , we are going to compute the tensors @xmath137 and @xmath138 from eq .",
    "( [ resultant ] ) .",
    "the reduced density matrix of qubits @xmath139 is @xmath140 ^ 2\\\\ & \\times\\theta(i_l , i_{l+1},i_{l+2},v_{l-1},v_{l+2 } ) \\theta^*(i_l , i_{l+1},{i'}_{l+2},v_{l-1},{v'}_{l+2 } ) \\biggr]\\\\ & \\times|i_{l+2}\\rangle|v_{l+2}\\rangle\\langle{i'}_{l+2}|\\langle{v'}_{l+2}|\\\\ & = \\sum_{i_{l+2}v_{l+2}{i'}_{l+2}{v'}_{l+2}}\\biggl [ \\sum_{i_li_{l+1}v_{l-1}}[v_{l-1}(v_{l-1})]^2\\\\ & \\times\\theta(i_l , i_{l+1},i_{l+2},v_{l-1},v_{l+2 } ) \\theta^*(i_l , i_{l+1},{i'}_{l+2},v_{l-1},{v'}_{l+2})\\\\ & \\times v_{l+2}(v_{l+2})v_{l+2}({v'}_{l+2})\\biggr ]      \\langle{i'}_{l+2}|\\langle\\phi_{{v'}_{l+2}}| \\end{split}\\ ] ] with @xmath141 $ ] .",
    "the matrix @xmath142 is a @xmath143 matrix .",
    "this is now diagonalized to achieve the eigenvalues @xmath144 ^ 2 $ ] and the corresponding eigenvectors @xmath145 under the basis @xmath146 .",
    "the values of @xmath137 are immediately found .",
    "we may truncate out negligibly small eigenvalues to reduce @xmath147 ( the updated value of @xmath148 ) .",
    "in addition , we have vector elements @xmath149 of just computed eigenvectors : @xmath150 thus we have obtained @xmath151    third , we are going to compute the tensor @xmath152 . by the definition of this tensor",
    ", we have @xmath153 we substitute the equations @xmath154 into the above equation to obtain @xmath155 ^ 2\\widetilde{q_{l}}^*(i_l , v_{l-1},v_l ) \\widetilde{q_{l+2}}^*(i_{l+2},v_{l+1},v_{l+2})\\\\ & \\times [ v_{l+2}(v_{l+2})]^2 \\theta(i_l , i_{l+1},i_{l+2},v_{l-1},v_{l+2 } ) \\biggr\\}. \\end{split}\\ ] ]          here is an example program to use a three - qubit operation .",
    "it simulates the simplest case of grover s quantum search @xcite .",
    "one may also see the simulation performed in sec .",
    "[ secdj ] for another example .    for a brief sketch of the quantum search ,",
    "suppose that there is an oracle function @xmath157 that has @xmath158 solutions @xmath159 ( namely , strings @xmath159 such that @xmath160 ) .",
    "classical search for finding a solution takes @xmath161 queries .",
    "in contrast , the grover search finds a solution in @xmath162 queries .",
    "in particular when @xmath163 and @xmath164 , a single query is enough for the grover search .",
    "for example , consider the parent data set @xmath165 and the solution @xmath166 for a certain oracle with a single oracle bit .",
    "a single grover iteration @xmath167 maps @xmath168 to @xmath169 , where @xmath170 with @xmath171 and @xmath172 acts on the left side qubits ; @xmath173 is a state of the oracle qubit ( the right - most qubit ) .",
    "@xmath174 is a unitary operation corresponding to @xmath175 and @xmath176 is a so - called inversion - about - average operation . to implement @xmath174 and @xmath176",
    ", we utilize the fact that flipping @xmath177 changes the phase factor @xmath178 , following a common implementation @xcite .    here , we consider a very simple oracle structure , namely that , it flips @xmath177 when the left side qubits are in @xmath179 using a very straight - forward circuit interpretation .",
    "note that there is no realistic benefit to perform a search in such a case because we know the solution beforehand .",
    "usually a search is performed because we can not guess the solutions by the circuit appearance ( consider , _",
    "e.g _ , an instance of a satisfiability problem @xcite ) .",
    "the sample program to simulate the grover search for the present simple case is shown in listing  [ codeqsearch ] .",
    ".... # include \" zkcm_qc.hpp \" int main ( ) {    zkcm_set_default_prec(256 ) ;    mps m(3 ) ;    //prepare the state for the parent data set and    //the initial state of the oracle qubit .",
    "m.applyu(tensor2tools::hadamard , 0 ) ;    m.applyu(tensor2tools::hadamard , 1 ) ;    m.applyu(tensor2tools::paulix , 2 ) ;    m.applyu(tensor2tools::hadamard , 2 ) ;        //inversion - about - average operation    zkcm_matrix u_s(8 , 8) ;    u_s.set_to_identity ( ) ;    u_s(0 , 0 ) = u_s(1 , 1 ) = 0 ;    u_s(0 , 1 ) = u_s(1 , 0 ) = 1 ;    zkcm_matrix h = zkcm_matrix(\"[1 , 1 ; 1 , -1 ] \" )                    / sqrt(zkcm_class(2 ) ) ;    zkcm_matrix i = zkcm_matrix(\"[1 , 0 ; 0 , 1 ] \" ) ;    h = tensorprod(tensorprod(h , h ) , i ) ;    u_s = h * u_s * h;//this is 1 - 2|s><s| .      std::cout < < \" initially , prob(01)= \"              < < m.rdo_block(0 , 1).get(1 , 1 )              < < std::endl              < < \" go into grover 's iteration ... \"              < <",
    "std::endl ;    for ( int i = 0 ; i < 8 ; i++ )    {      m.applyu8(u_f , 0 , 1 , 2 ) ;      m.applyu8(u_s , 0 , 1 , 2 ) ;      std::cout < < \" after \" < < i + 1                < < \" times iteration , prob(01)= \"                < < m.rdo_block(0 , 1).get(1 , 1 )                < < std::endl ;    }    zkcm_quit ( ) ;    return 0 ; } ....      .... [ user@localhost foo]$ c++ -o simple_q_search \\",
    "simple_q_search.cpp -lzkcm_qc -lzkcm -lmpfr \\",
    "-lgmp -lgmpxx [ user@localhost foo]$ ./simple_q_search   initially , prob(01)=2.500000000e-01 go into grover 's iteration ... after 1 times iteration , prob(01)=1.000000000e+00 after 2 times iteration , prob(01)=2.500000000e-01 after 3 times iteration , prob(01)=2.500000000e-01 after 4 times iteration , prob(01)=1.000000000e+00 after 5 times iteration , prob(01)=2.500000000e-01 after 6 times iteration , prob(01)=2.500000000e-01 after 7 times iteration , prob(01)=1.000000000e+00 after 8 times iteration , prob(01)=2.500000000e-01 ....    we see that the success probability , _",
    "i.e. _ , the probability to find @xmath166 in the left side qubits if we measure them in the computational basis , is unity after a single @xmath167 is applied . by continuing the iteration , the success probability oscillates .",
    "we have seen a sample program that uses a three - qubit gate by calling the function `` ` applyu8 ` '' .",
    "in addition to this function , there are functions for typical three - qubit gates .",
    "they are briefly mentioned below .",
    "the first typical three - qubit gate is the ccnot gate already introduced in sec .",
    "[ secdj ] , which flips a single target qubit @xmath180 under the condition that two control qubits @xmath181 and @xmath182 are in @xmath183 .",
    "zkcm_qc has a particular member function ( of class `` ` mps ` '' ) for it : `` ` mps & mps::ccnot ( int a , int b , int t ) ; ` '' .",
    "the second typical one is the controlled - swap ( cswap ) gate , which swaps two target qubits @xmath184 and @xmath185 under the condition that the control qubit @xmath186 is in @xmath187 .",
    "the member function corresponding to this gate is `` ` mps & mps::cswap ( int c , int p , int q ) ; ` '' .    in summary of this appendix , the process to simulate a three - qubit gate operation in a time - dependent mps simulation has been theoretically described .",
    "a sample program to simulate a simple quantum search has been provided , which uses one of the three - qubit gate functions of the zkcm_qc library .",
    "bailey , r. barrio , j.m .",
    "borwein , high - precision computation : mathematical physics and dynamics , appl .",
    "comput . 218",
    "( 2012 ) 10106 - 10121 .",
    "smith , multiple precision complex arithmetic and functions , acm trans .",
    "software 24 ( 1998 ) 359 - 367 , .",
    "b. haible , r.b .",
    "kreckel , maintainers , cln - class library for numbers , . d.h .",
    "bailey , y. hida , k. jeyabalan , x.s .",
    "li , b. thompson , arprec , .",
    "fujiwara , exflib - extend precision floating - point arithmetic library , .",
    "m. nakata , the mpack ( mblas / mlapack ) ; a multiple precision arithmetic version of blas and lapack , .",
    "a. saitoh , zkcm and zkcm_qc , + .",
    "the gnu multiple precision arithmetic library , + .",
    "l. fousse , g. hanrot , v. lefvre , p. plissier , p. zimmermann , mpfr : a multiple - precision binary floating - point library with correct rounding , acm trans .",
    "software 33 ( 2007 ) 13 , .",
    "j. gruska , quantum computing , mcgraw - hill , 1999 .",
    "nielsen , i.l .",
    "chuang , quantum computation and quantum information , cambridge university press , 2000 .",
    "g. vidal , efficient classical simulation of slightly entangled quantum computations , phys .",
    "91 ( 2003 ) 147902 .",
    "white , density matrix formulation for quantum renormalization groups , phys .",
    "69 ( 1992 ) 2863 - 2866 .",
    "white , density - matrix algorithms for quantum renormalization groups , phys .",
    "b 48 ( 1993 ) 10345 .",
    "_ , the alps project release 2.0 : open source software for strongly correlated systems , j.  stat .  mech .",
    "2011(05 ) ( 2011 ) p05001 , .",
    "viamontes , m. rajagopalan , i.l .",
    "markov , j.p .",
    "hayes , gate - level simulation of quantum circuits , in : proceedings of the 2003 asia and south pacific design automation conference ( asp - dac 2003 ) , kitakyushu , japan , 21 - 24 jan .",
    "2003 ( acm press , new york , 2003 ) 295 - 301 ; g.f .",
    "viamontes , i.l .",
    "markov , j.p .",
    "hayes , improving gate - level simulation of quantum circuits , quantum inf . process . 2 ( 2003 ) 347 - 380",
    ". s. aaronson , d. gottesman , improved simulation of stabilizer circuits , phys .",
    "rev .  a 70 ( 2004 ) 052328 .",
    "d. deutsch , a. barenco , a. ekert , universality in quantum computation , proc .",
    "r.  soc .",
    "lond .  a 449 ( 1995 ) 669 - 677 .",
    "a. kawaguchi , k. shimizu , y. tokura , n. imoto , classical simulation of quantum algorithms using the tensor product representation , e - print arxiv : quant - ph/0411205 .",
    "kulisch , w.l .",
    "miranker , the arithmetic of the digital computer : a new approach , siam review 28(1 ) ( 1986 ) 1 - 40 .",
    "wilkinson , error analysis of direct methods of matrix inversion , j. acm 8(3 ) ( 1961 ) 281 - 330 .",
    "trefethen , three mysteries of gaussian elimination , acm signum newsletter 20(4 ) ( 1985 ) 2 - 5 .",
    "gnuplot , .",
    "the pari  group , pari / gp , ( bordeaux , 2000 - 2012 ) , .",
    "r. spira , calculation of the gamma function by stirling s formula , math .",
    "25(114 ) ( 1971 ) 317 - 322 .",
    "m. kaneko , the akiyama - tanigawa algorithm for bernoulli numbers , j. integer seq .",
    "3 ( 2000 ) article 00.2.9 .",
    "a. saitoh , m. kitagawa , matrix - product - state simulation of an extended brschweiler bulk - ensemble database search , phys .",
    "a 73 ( 2006 ) 062332 .",
    "smith , t.o .",
    "levante , b.h .",
    "meier , r.r .",
    "ernst , computer simulations in magnetic resonance . an object oriented programming approach , j.  magn .",
    "106a ( 1994 ) 75 - 105 , .",
    "public communications in the bug tracking system of pari / gp , bug report logs - # 1349 , august 2012 .",
    "w.h . press ,",
    "teukolsky , w.t . vetterling , b.p .",
    "flannery , numerical recipes : the art of scientific computing , 3rd edition , cambridge university press , 2007 .",
    "mueller , householder s method for complex matrices and eigensystems of hermitian matrices , numer . math . 8",
    "( 1966 ) 72 - 92 .",
    "d. kressner , numerical methods for general and structured eigenvalue problems , springer - verlag , 2005 .",
    "h. venzl , a.j .",
    "daley , f. mintert , a. buchleitner , statistics of schmidt coefficients and the simulability of complex quantum systems , phys .",
    "e 79 ( 2009 ) 056223 .",
    "bauls , r. ors , j.i .",
    "latorre , a. prez , p. ruiz - femena , simulation of many - qubit quantum computation with matrix product states , phys .",
    "a 73 ( 2006 ) 022344 .",
    "d. gobert , c. kollath , u. schollwck , g. schtz , real - time dynamics in spin-@xmath188 chains with adaptive time - dependent density matrix renormalization group , phys .",
    "e 71 ( 2005 ) 036102 .",
    "garca - ripoll , time evolution of matrix product states , new j. phys .",
    "8 ( 2006 ) 305 .",
    "a. saitoh , a multiprecision c++ library for matrix - product - state simulation of quantum computing : evaluation of numerical errors , e - print arxiv:1211.4086 .",
    "grover , a fast quantum mechanical algorithm for database search , in : proceedings of the 28th annual acm symposium on theory of computing ( stoc 1996 ) , philadelphia , pa , 22 - 24 may 1996 ( acm press , new york , 1996 ) 212 - 219 .",
    "d. deutsch , r. jozsa , rapid solution of problems by quantum computation , proc .",
    "royal soc .",
    "london a 439 ( 1992 ) 553 - 558 .",
    "watkins , fundamentals of matrix computations , 3rd edition , wiley , 2010 .",
    "graham , p.b .",
    "kessler , m.k .",
    "mckusick , gprof : a call graph execution profiler , in : proceedings of the 1982 sigplan symposium on compiler construction , boston , ma , 23 - 25 june 1982 ( acm , new york , 1982 ) , acm sigplan notices 17(6 ) ( 1982 ) 120 - 126 .",
    "ipsen , computing an eigenvector with inverse iteration , siam rev .",
    "39 ( 1997 ) 254 - 291 .",
    "y. saad , numerical methods for large eigenvalue problems , revised edition , siam , 2011 .",
    "j. niwa , k. matsumoto , h. imai , general - purpose parallel simulator for quantum computing , phys .",
    "a 66 ( 2002 ) 062317 . k. de raedt , k. michielsen , h. de raedt , b. trieu , g. arnold , m. richter , th .",
    "lippert , h. watanabe , n. ito , massively parallel quantum computer simulator , comput .",
    "( 2007 ) 121 - 136 .",
    "f. tabakin , b. juli - daz , qcmpi : a parallel environment for quantum computing , comput .",
    "phys . comm . 180",
    "( 2009 ) 948 - 964 .",
    "e. gutirrez , s. romero , m.a .",
    "trenas , e.l .",
    "zapata , quantum computer simulation using the cuda programming model , comput .",
    "( 2010 ) 283 - 300 .",
    "shor , polynomial - time algorithms for prime factorization and discrete logarithms on a quantum computer , siam j. comput . 26",
    "( 1997 ) 1484 - 1509 .",
    "r. jozsa , n. linden , on the role of entanglement in quantum - computational speed - up , proc .",
    "lond . a 459 ( 2003 ) 2011 - 2032 .",
    "a. kawaguchi , k. shimizu , y. tokura , n. imoto , classical simulation of the modular exponentiation using the tensor product decomposition , in : extended abstract booklet of the 11th quantum information technology symposium , kyoto , japan , 6 - 7 december 2004 ( unpublished , in japanese with english abstract ) pp.163 - 166 , technical report no .",
    "qit2004 - 82 .",
    "s. parker , m.b .",
    "plenio , entanglement simulations of shor s algorithm , j. mod .",
    "49 ( 2002 )",
    "1325 - 1353 . y. shimoni , d. shapira , o. biham , entangled quantum states generated by shor s factoring algorithm , phys .",
    "a 72 ( 2005 ) 062308 .",
    "kendon , w.j .",
    "munro , entanglement and its role in shor s algorithm , quantum inf .",
    "( 2006 ) 630 - 640 .",
    "y. most , y. shimoni , o. biham , entanglement of periodic states , the quantum fourier transform , and shor s factoring algorithm , phys .",
    "a 81 ( 2010 ) 052306 .",
    "r. jozsa , on the simulation of quantum circuits , e - print arxiv : quant - ph/0603163 .",
    "viamontes , i.l .",
    "markov , j.p .",
    "hayes , graph - based simulation of quantum computation in the density matrix representation , quantum inf .",
    "5 ( 2005 ) 113 - 130 .",
    "viamontes , efficient quantum circuit simulation , phd thesis , university of michigan , 2007 .",
    "garey , d.s .",
    "johnson , computers and intractability : a guide to the theory of np - completeness , w.h . freeman and co. , 1979 ."
  ],
  "abstract_text": [
    "<S> zkcm is a c++ library developed for the purpose of multiprecision matrix computation , on the basis of the gnu mp and mpfr libraries . </S>",
    "<S> it provides an easy - to - use syntax and convenient functions for matrix manipulations including those often used in numerical simulations in quantum physics . </S>",
    "<S> its extension library , zkcm_qc , is developed for simulating quantum computing using the time - dependent matrix - product - state simulation method . </S>",
    "<S> this paper gives an introduction about the libraries with practical sample programs .    </S>",
    "<S> multiprecision computing ; linear algebra ; time - dependent matrix product state ; quantum information    * program summary *    _ manuscript title : _ zkcm : a c++ library for multiprecision matrix computation with applications in quantum information + _ authors : _ akira saitoh + _ program title : _ zkcm + _ journal reference : _ + _ catalogue identifier : _ + _ licensing provisions : _ gnu lesser general public license ver . 3 + _ programming language : _ c++ + _ </S>",
    "<S> computer : _ general computers + _ operating system : _ unix - like systems , such as linux , free bsd , cygwin on windows os , etc . </S>",
    "<S> + _ ram : _ several mega bytes - several giga bytes , dependent on the problem instance + _ keywords : _ multiprecision computing , linear algebra , time - dependent matrix product state , quantum information + _ classification : _ 4.8 linear equations and matrices , 4.15 quantum computing + _ external routines / libraries : _ gnu mp ( gmp ) @xcite , mpfr @xcite ver . </S>",
    "<S> 3.0.0 or later + _ nature of problem : _ multiprecision computation is helpful to guarantee and/or evaluate the accuracy of simulation results in numerical physics . </S>",
    "<S> there is a potential demand for a programming library focusing on matrix computation usable for this purpose with a user - friendly syntax . </S>",
    "<S> + _ solution method : _ a c++ library zkcm has been developed for multiprecision matrix computation . it provides matrix operations useful for numerical studies of physics , e.g. , the tensor product ( kronecker product ) , the tracing - out operation , the inner product , the lu decomposition , the hermitian - matrix diagonalization , the singular - value decomposition , and the discrete fourier transform . for basic floating - point operations , gmp and mpfr libraries are used . an extension library zkcm_qc </S>",
    "<S> has also been developed , which employs the time - dependent matrix - product - state method to simulate quantum computing . </S>",
    "<S> + _ restrictions : _ multiprecision computation with more than a half thousand bit precision is often a thousand times slower than double - precision computation for any kind of matrix computation . </S>",
    "<S> + _ additional comments : _ a user s manual is placed in the directory `` doc '' of the package . each function is explained in a reference manual found in the directories `` doc / html '' and `` doc / latex '' . </S>",
    "<S> sample programs are placed in the directory `` samples '' . + _ running time : _ it takes less than thirty seconds to obtain a dft spectrum for @xmath0 data points of a time evolution of a quantum system described by a @xmath1 matrix hamiltonian for 256-bit precision when we use recent amd or intel cpu with 2.5 ghz or more cpu frequency . </S>",
    "<S> it takes three to five minutes to diagonalize a @xmath2 hermitian matrix for 512-bit precision using the aforementioned cpu . </S>",
    "<S> +    0 the gnu multiple precision arithmetic library , + . </S>",
    "<S> l. fousse _ </S>",
    "<S> et al . _ , </S>",
    "<S> mpfr : a multiple - precision binary floating - point library with correct rounding , acm trans . </S>",
    "<S> math . </S>",
    "<S> software 33 ( 2007 ) 13 , . </S>"
  ]
}