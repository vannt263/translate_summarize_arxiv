{
  "article_text": [
    "a fundamental issue in distributed computing is fault - tolerance : guaranteeing that work is performed , despite the presence of failures .",
    "for example , in controlling a nuclear reactor it may be crucial for a set of valves to be closed before fuel is added .",
    "thus , the procedure for verifying that the valves are closed must be highly fault - tolerant . if processes never fail then the _ work _ of checking that the valves are closed could be distributed according to some load - balancing technique .",
    "since processes may fail , we would like an algorithm that guarantees that the work will be performed as long as at least one process survives",
    ". such an algorithm could be particularly useful in a local area network , where jobs might be distributed among idle workstations .",
    "( the idea of running computations on idle nodes is an old one , going back at least to @xcite .",
    "see @xcite for one implementation of this approach , and further references . ) in this case a `` failure '' might correspond to a user reclaiming her machine .",
    "the notion of work in this paper is very broad , but is restricted to `` idempotent '' operations , that is , operations that can be repeated without harm .",
    "this is because if a process performs a unit of work and fails before telling a second process of its achievement , then the second process has no choice but to repeat the given unit of work .",
    "examples include verifying a step in a formal proof , evaluating a boolean formula at a particular assignment to the variables , sensing the status of a valve , closing a valve , sending a message , say , to a process outside of the given system , or reading records in a distributed database .",
    "formally , we assume that we have a synchronous system of @xmath0 processes that are subject to crash failures , that want to perform @xmath1 independent units of work .",
    "( for now , we assume that initially there is common knowledge among the @xmath0 processes about the @xmath1 units of work to be performed .",
    "we return to this point later . ) in one time unit a process can compute locally and perform one unit of work and one round of communication ( sending and receiving messages ) . given that performing a unit of work can be repeated without harm , a trivial solution is obtained by having each process perform every unit of work . in our original example , this would mean that every process checks that every valve is closed .",
    "this solution requires no messages , but in the worst case performs @xmath6 units of work and runs in @xmath1 rounds .",
    "( here the worst case is when no process fails . )",
    "another straightforward solution can be obtained by having only one process performing the work at any time , and checkpointing to each process after completing every unit of work . in this solution , at most @xmath7 units of work are ever performed , but the number of messages sent is almost @xmath6 in the worst case .    in both these solutions",
    "the total amount of _ effort _ , defined as work plus messages , is @xmath8 .",
    "if the actual cost of performing a unit of work is comparable to the cost of sending a message , then neither solution is appealing .",
    "in this paper we focus on solutions which are work - optimal , up to a constant factor , while keeping the total effort reasonable .",
    "clearly , since a process can fail immediately after performing a unit of work , before reporting that unit to any other process , a work - optimal solution performs @xmath7 units of work in the worst case .",
    "thus , we are interested in solutions that perform @xmath2 work .",
    "let @xmath9 .",
    "our first result is an algorithm whose total effort is at most @xmath10 .",
    "in fact , in the worst case the amount of work performed is at most @xmath11 and the number of messages is at most @xmath12 , so the form of the bound explains the costs exactly .",
    "we then optimize this algorithm to achieve running time of @xmath2 rounds .",
    "note that any solution requires @xmath1 rounds in the worst case , since if @xmath13 processes are initially faulty then the remaining process must perform all @xmath1 units of work . in this algorithm the synchrony is used only to detect failures , as usual by detecting the absence of an expected message .",
    "thus , it can be easily modified to work in a completely asynchronous system equipped with a failure detection mechanism .",
    "we then prove that the above algorithm is not message - optimal ( among work - optimal algorithms ) , by constructing a technically challenging work - optimal algorithm that requires only @xmath14 messages in the worst case .",
    "since @xmath15 is a lower bound on work , and hence on effort , the @xmath16 effort of this algorithm is nearly optimal .",
    "the improved message complexity is obtained by a more aggressive use of synchrony . in particular , the absence of a message in this algorithm has two possible meanings : either the potential sender failed or it has insufficient `` information '' ( generally about the history of the execution ) , and therefore has chosen not to send a message . due to this use of synchrony , unlike the first algorithm , this low - effort algorithm will not run in the asynchronous model with failure detection .",
    "in addition , the efficiency comes at a price in terms of time : in the worst case , the algorithm requires @xmath5 rounds .",
    "the first two algorithms are very sequential : at all times work is performed by a single active process who uses some checkpointing strategy to inform other processes about the completed work .",
    "this forces the algorithms to take at least @xmath1 steps , even in a failure - free run . to reduce the time we need to increase parallelism",
    "however , intuitively , increasing parallelism while simultaneously minimizing time and remaining work - optimal may increase communication costs , since processes must quickly tell each other about completed work .",
    "the third algorithm does exactly this in a fairly straightforward way , paying a price in messages in order to decrease best - case time .",
    "it is designed to perform time - optimally in the absence of failures , and to have its time complexity degrade gracefully with additional faults . in particular",
    ", it takes @xmath17 rounds in the failure - free case , and its message cost is @xmath18 ; its worst - case message cost is @xmath19 , where @xmath20 is the actual number of failures in the execution .",
    "there are a number of assumptions in our model that are arguably not realistic .",
    "for one , we assume that the @xmath1 units of work are identical , or , at least , that they all take the same amount of time to perform .",
    "in addition , we assume that the total workload is static , and is common knowledge at the beginning of the algorithm .",
    "it is not too hard to modify our last algorithm to deal with a more realistic scenario , where work is continually coming in to different sites of the system , and is not initially common knowledge .",
    "we remark that a patent has been filed by ibm for such a modified algorithm .",
    "one application of our algorithms is to byzantine agreement .",
    "the idea is that the general tries to inform @xmath0 processes , and then each of these @xmath0 processes performs the `` work '' of ensuring that all processes are informed . in particular , our second algorithm , called protocol @xmath21 , gives a byzantine agreement algorithm for the crash fault model that requires @xmath22 messages and @xmath23 time , where @xmath1 is the number of processes in the system and @xmath0 is a bound on the number of failures , while our third algorithm gives a byzantine agreement algorithm that uses @xmath24 messages and exponential time .",
    "the best result prior to ours was a nonconstructive algorithm due to bracha that requires @xmath25 messages @xcite .",
    "galil , mayer , and yung @xcite have recently obtained an algorithm that uses only a linear number of messages .",
    "however , the algorithm is incomparable to the agreement algorithm obtained using protocol  @xmath21 because it requires a superlinear number of rounds . using the observation that our solutions to the work problem yield solutions to byzantine agreement , we can now return to the assumption that initially there is common knowledge about the work to be performed . specifically ,",
    "if even one process knows about this work , then it can act as a general , run byzantine agreement on the pool of work using one of the three algorithms , and then the actual work is performed by running the same algorithm a second time on the real work . if @xmath1 , the amount of actual work , is @xmath26 , then the overall cost at most doubles when the work is not initially common knowledge .",
    "the idea of doing work in the presence of failures , in a different context , has appeared elsewhere .",
    "first , bridgland and watro @xcite considered a system of @xmath0 asynchronous processes that together must perform @xmath1 independent units of work .",
    "the processes may fail by crashing and each process can perform at most one unit of work .",
    "they provide tight bounds on the number of crash failures that can be tolerated by any solution to the problem .",
    "clearly , our problem assumes a very different model than the one of @xcite .",
    "furthermore , they want a protocol that guarantees that the work will be performed in every execution of the protocol , while we want only a protocol that guarantees that the work will be performed in executions in which at least one process survives . consequently , their problem is not always solvable and their focus is on finding conditions under which it is solvable .",
    "our problem is always solvable ; our focus is on finding efficient solutions .",
    "another similar but not identical problem was considered by kanellakis and shvartsman . in a seminal paper",
    "@xcite they consider the _ write - all _ problem , in which @xmath1 processes cooperate to set all @xmath1 entries of an @xmath1-element array to the value  1 .",
    "they provide an efficient solution that tolerates up to @xmath27 faults , and show how to use it to derive robust versions of parallel algorithms for a large class of interesting problems .",
    "their original paper was followed by a number of papers that consider the problem in other shared - memory models ( see @xcite ) .",
    "the write - all problem is , of course , a special case of the type of work we consider .",
    "nevertheless , our framework differs from that of  @xcite in two important respects , so that their results do not apply to our problem ( nor ours to theirs ) .",
    "first , they consider the shared - memory model while we consider the message - passing model .",
    "using the shared - memory model simplifies things considerably for our problem . in this model",
    ", there is a straightforward algorithm ( that uses shared memory to record what work has been done ) with optimal effort @xmath2 ( where effort now counts both reading and writing into shared memory , as well as doing work ) , running in time @xmath28 . while there are well - known emulators that can translate algorithms from the shared - memory model to the message - passing model ( see @xcite ) , these emulators are not applicable for our problem , because the number of failures they tolerate is less than a majority of the total number of processes , while our problem allows up to @xmath13 failures . also , these transformations introduce a multiplicative overhead of message complexity that is polynomial in @xmath0 , while one of our goals here is to minimize this term .. ] second , our complexity measure is inherently different from that of @xcite .",
    "kanellakis and shvartsman s complexity measure is the sum , over the rounds during which the algorithm is running , of the number of processes that are not faulty during each round .",
    "they call their measure the _ available processor steps_. this measure essentially `` charges '' for a nonfaulty process at round  @xmath29 whether or not it is actually doing any work ( say , reading or writing a cell in shared memory ) .",
    "our approach is generally _ not _ to charge a process in round @xmath29 if it is not expending any effort ( sending a message or performing a unit of work ) at that round , since it is free at that round to be working on some other task .",
    "of course , the appropriateness of charging or not charging for process idle time will depend very much on the details of the system and the tasks being performed .",
    "our results have been extended by de prisco , mayer , and yung  @xcite , and by galil , mayer , and yung  @xcite",
    ". de prisco , mayer , and yung  @xcite consider the problem introduced here , but their goal is to optimize the available processor steps defined by @xcite , and then the number of messages .",
    "they present a message - efficient algorithm that achieves optimality in the available processor steps measure .",
    "they also show that when @xmath30 , any algorithm for performing work in the message - passing model requires at least @xmath31 available processor steps . this lower bound can be avoided in shared - memory models that allow concurrent writes ;",
    "for example , an @xmath32 solution is presented in @xcite .",
    "galil , mayer , and yung  @xcite employ the results of @xcite to obtain a byzantine agreement algorithm for the crash fault model that requires only a linear number of messages . roughly speaking ,",
    "the processors are organized into a tree .",
    "the children of the root attempt to solve the problem recursively ; the group membership protocol of  @xcite ( called a _ checkpoint protocol _ , not to be confused with the checkpoints as defined in our paper ) is used to attempt to determine which of the children have failed to complete the recursive step , and the computation is re - organized accordingly .    the galil , mayer , and yung protocol compares to that obtained by using our protocol  @xmath21 as follows : @xcite requires @xmath23 messages , while ours requires @xmath33 ; @xcite requires @xmath34 rounds of communication while ours requires @xmath23 ; finally , @xcite requires messages of length @xmath35 , where @xmath36 is the set of possible agreement values .",
    "this appears to be because the protocol requires knowledge of which processors are alive and which processors occupy which parts of the tree .",
    "in contrast , our messages are of length @xmath37 .",
    "our goal in this section is to present a protocol with effort @xmath38 and running time @xmath15 .",
    "we begin with a protocol that is somewhat simpler to present and analyze , with effort @xmath38 and running time @xmath39 .",
    "this protocol has the additional property of working with minimal change in an asynchronous environment with failure detection .",
    "the main idea of the protocol is to use checkpointing in order to avoid redoing too much work if a process fails .",
    "the most nave approach to checkpointing does not work . to understand why ,",
    "suppose a process does a checkpoint after each @xmath40 units of work .",
    "this means that up to @xmath40 units of work are lost when a process fails . since up to @xmath0 processes may fail",
    ", this means that @xmath41 units of work can be lost ( and thus must be repeated ) , which suggests we should take @xmath42 if we want to do no more than @xmath23 units of work altogether .",
    "however , since each checkpoint involves @xmath0 messages , this means that roughly @xmath43 messages will be sent .",
    "thus , we must have @xmath44 if we are to use fewer than @xmath45 messages . roughly speaking",
    ", this argument shows that doing checkpoints too infrequently means that there might be a great deal of wasted work , while doing them too often means that there will be a great deal of message overhead .",
    "our protocol avoids these problems by doing _",
    "full _ checkpoints to all the processes relatively infrequently ",
    "after @xmath46 units of work  but doing partial checkpoints to only @xmath47 processes after every @xmath48 units of work .",
    "this turns out to be just the right compromise .      for ease of exposition",
    ", we assume that @xmath0 is a perfect square , and that @xmath1 is divisible by @xmath0 ( so that , in particular , @xmath49 ) .",
    "we leave to the reader the easy modifications of the protocol when these assumptions do not hold .",
    "we assume that the processes are numbered 0 through @xmath13 , and that the units of work are numbered 1 through @xmath1 .",
    "we divide the processes into @xmath47 groups of size @xmath47 each , and use the notation @xmath50 to denote process @xmath51 s group .",
    "( note @xmath52 . )",
    "we divide the work into @xmath47 _ chunks _ , each of size @xmath46 , and subdivide the chunks into @xmath47 _ subchunks _ of size @xmath48 .",
    "the protocol guarantees that at each round , at most one process is _",
    "active_. the active process is the only process performing work .",
    "if process @xmath51 is active , then it knows that processes 0 to @xmath53 have crashed or terminated .",
    "initially , process 0 is active .",
    "the algorithm for process 0 is straightforward : process 0 starts out doing the work , a subchunk at a time . after completing a subchunk @xmath54",
    ", it does a checkpoint to the remaining processes in its group @xmath55 ( processes @xmath56 to @xmath57 ) ; that is , it informs its group that the subchunk of work has been completed by broadcasting to the processes in its group a message of the form @xmath58 .",
    "( if process 0 crashes in the middle of a broadcast , we assume only that some subset of the processes receive the message . ) we call this a _ partial checkpoint _ , since the checkpointing is only to the processes in @xmath55 .",
    "( code for this for module and the whole protocol may be found in figure  [ protocol a code ] . ) after completing a whole chunk of work  that is , after completing a subchunk @xmath54 which is a multiple of @xmath47process 0 informs _ all _ the processes that subchunk @xmath54 has been completed , but it informs them one group at a time . after informing a whole group , it checkpoints the fact that a group has been informed to its own group ( i.e. , group 1 ) .",
    "formally , after completing a subchunk @xmath54 that is a multiple of @xmath47 , process 0 does a partial checkpoint to its own group , and then for each group @xmath59 , process 0 broadcasts to the processes in group @xmath60 a message of the form @xmath61 , and then broadcasts to all the processes in its own group a message of the form @xmath61 .",
    "we call this a _ full checkpoint_. note that in a full checkpoint , there is really a double checkpointing process : we checkpoint both the fact that work has been completed , and ( to the processes in @xmath55 ) the fact that all processes have been informed that the work has been completed .",
    "process 0 terminates after sending the message @xmath62 to process @xmath13 , indicating to the last process that the last chunk of work has been completed ( unless it crashes before that round ) .    if process 0 crashes , we want process 1 to become active ; if process 1 crashes , we want process 2 to become active , and so on .",
    "more generally , if process @xmath63 discovers that the first @xmath64 processes have crashed , then it becomes active .",
    "once process @xmath63 becomes active , it continues with essentially the same algorithm as process 0 , except that it does not repeat the work it knows has already been done .",
    "we must ensure that the takeover proceeds in a `` smooth '' manner , so that there is at most one active process at a time .",
    "xx = xxxx = xxxx = xxxx = xxxx = xxxx = xxxx    main protocol +   + 1 .",
    "round number @xmath65 _ and _ not received @xmath66 or @xmath67 + 2 .",
    "+   + dowork +   + 1 .",
    "the last message received was from @xmath68 and had the form @xmath61 + 2 .",
    "@xmath69 + 3 .",
    "partialcheckpoint(@xmath54 ) ;   \\{see code below } + 4 .",
    "broadcast @xmath61 to processes @xmath70 ; + 5 .",
    "fullcheckpoint@xmath71;\\{complete a full checkpoint ; see code below } + 6 .",
    "let ( @xmath54 ) be the last message received ; + 7 .",
    "partialcheckpoint(@xmath54 ) ; + 8 .",
    "@xmath54 is a multiple of @xmath47 + 9 .",
    "fullcheckpoint(@xmath72 ) .",
    "* for * @xmath73 to @xmath0 * do * \\{proceed with performing work } + 11 .",
    "perform subchunk @xmath74 ; + 12 .",
    "partialcheckpoint(@xmath74 ) ; + 13 .",
    "@xmath74 is a multiple of @xmath47 ; + 14 .",
    "fullcheckpoint(@xmath75 ) +   + partialcheckpoint@xmath58 +   + 1 . inform the remainder of group @xmath76 that subchunk @xmath54 has been performed + by broadcasting @xmath58 to processes @xmath77 +   +   + fullcheckpoint@xmath78 +   + 1 .",
    "@xmath79 to @xmath47 * do * + 2 . inform group @xmath60 that subchunk @xmath54 has been performed + by broadcasting @xmath61 to group @xmath60 ; + 3 .",
    "inform the remainder of group @xmath76 that group @xmath60 has been informed + about subchunk @xmath54 by broadcasting @xmath61 to processes @xmath70    process @xmath63 s algorithm is as follows .",
    "if @xmath63 does not know that all the work has already been performed and sufficiently long time has passed from the beginning of the execution , then @xmath63 becomes active .",
    "`` sufficiently long '' means long enough to ensure that processes @xmath80 have crashed or terminated .",
    "as we show below , we can take `` sufficiently long '' to be defined by the function @xmath81 .",
    "( `` dd '' stands for deadline .",
    "we remark that this is not an optimal choice for the deadline ; we return to this issue later . )",
    "thus , if the round number @xmath29 is less than @xmath82 , then @xmath63 does nothing .",
    "otherwise , if @xmath63 does not know that the work is completed , it takes over as the active process at round @xmath82 .",
    "when @xmath63 takes over as the active process , it essentially follows process 0 s algorithm .",
    "suppose the last message @xmath63 received was of the form @xmath61 , and this message was received from a process @xmath68 . by the syntax of the message we have that @xmath54 is a multiple of @xmath47 and that @xmath68 was performing a full checkpoint when it sent the message . if @xmath69 then @xmath83 , since this is the only kind of full checkpoint message that @xmath68 sends to processes outside its group .",
    "thus , @xmath63 must inform the rest of its own group that subchunk @xmath54 was performed , which it does with a partialcheckpoint(@xmath54 ) , and proceeds with the full checkpoint of @xmath54 , beginning with group @xmath84 .",
    "if @xmath85 then @xmath86 ; the meaning of @xmath87 in this case is that @xmath68 has told group @xmath60 that subchunk @xmath54 has been completed , and is telling its own group , @xmath88 ( @xmath89 ) , about this fact . in this case",
    "@xmath63 first ensures that its own group knows that group @xmath60 has been informed about subchunk @xmath54 by broadcasting @xmath61 to the remainder of its group , and then proceeds with the full checkpoint beginning with group @xmath90 .",
    "if the last message received was of the form @xmath58 then this message was part of a partial checkpoint to @xmath76 . in this case process @xmath63",
    "completes the partial checkpoint .    in all three cases",
    ", @xmath63 proceeds with work beginning with subchunk @xmath91 ( if such a subchunk exists ) .    unless it has already crashed",
    ", process @xmath63 terminates before becoming active if it receives @xmath66 ( as part of a partial checkpoint ) or @xmath67 ( as part of a full checkpoint ) .",
    "otherwise , after becoming active at @xmath82 , it terminates as follows .",
    "if @xmath92 then @xmath63 terminates after broadcasting @xmath66 to the remainder of @xmath76 . if @xmath93 then @xmath63 terminates after completing a call of the form fullcheckpoint(@xmath94 )",
    "this completes the description of our first protocol .",
    "we call this protocol  @xmath95 ; the code appears in figure  [ protocol a code ] .",
    "notice that we can easily modify this algorithm to run in a completely asynchronous system equipped with an appropriate _ failure detection mechanism _",
    "@xcite : if a process fails , then the failure detection mechanism must eventually inform all the processes that have not failed of this fact ; moreover , the mechanism must be sound , in that it never says that a nonfaulty process has failed .",
    "the modification is trivial : rather than waiting until round @xmath82 before becoming active , process @xmath63 waits until it has been informed that processes @xmath96 crashed or terminated .",
    "we now give a correctness proof for protocol @xmath97 .",
    "we say a process is _ retired _ if it has either crashed or terminated .",
    "[ facts ] a process performs at most @xmath1 units of work , sends at most @xmath98 messages , and runs for less than @xmath99 rounds from the time it becomes active to the time it retires .",
    "it is easy to see that from the time process @xmath51 becomes active , it performs each unit of work at most once , partial checkpoints each subchunk at most once ( and hence performs at most @xmath0 partial checkpoints ) , and full checkpoints every chunk at most once ( and hence performs at most @xmath47 full checkpoints ) .",
    "each partial checkpoint consists of a broadcast to process @xmath51 s group , and hence involves at most @xmath47 messages and one round .",
    "thus , process @xmath51 spends at most @xmath0 rounds on partial checkpoints , and sends at most @xmath100 messages when performing partial checkpoints . during a full checkpoint ,",
    "process @xmath51 broadcasts once to each group other than its own , and broadcasts at most @xmath47 times to its own group .",
    "each broadcast involves at most @xmath47 messages and one round , and there are @xmath47 groups .",
    "thus , process @xmath51 sends less than @xmath101 messages when performing full checkpoints , and takes less than @xmath102 rounds doing so .",
    "the required bounds immediately follow .",
    "recall that @xmath103 .",
    "the following lemma is now immediate from the definition of dd .",
    "[ ordergroupalemma ] assume process @xmath63 becomes active at round @xmath29 of an execution @xmath104 of protocol @xmath95 .",
    "then all processes @xmath105 have retired before round  @xmath29 .",
    "depth1pt    it is sometimes convenient to view a group @xmath50 as a whole .",
    "therefore we say that a _ group is active _ in the period starting when some process in this group becomes active and ending when the last process of this group retires .",
    "notice that lemma  [ ordergroupalemma ] ensures that when @xmath50 becomes active , all processes in smaller groups have retired .",
    "[ protocolatheorem ] in every execution of protocol @xmath95 ,    * at most @xmath106 units of work are performed in total by the processes , * at most @xmath107 messages are sent , * by round @xmath108 , all processes have retired .",
    "part ( c ) is immediate from lemma  [ facts ] and the definition of @xmath109 .",
    "we prove parts ( a ) and ( b ) simultaneously .",
    "to do so , we need a careful way of counting the total number of messages sent and the total amount of work done . a given unit of work may be performed a number of times .",
    "if it is performed more than once , say by processes @xmath110 , we say that @xmath111 _ redoes _ that unit of work of @xmath112 , @xmath113 redoes the work of @xmath111 , etc .",
    "it is important to note that @xmath113 does not redo the work of @xmath112 in this case ; only that of @xmath111 .",
    "similarly , we can talk about a message sent during a partial checkpoint of a subchunk or a full checkpoint of a chunk done by @xmath112 as being _",
    "resent _ by @xmath111 .",
    "in particular , a message @xmath114 sent by @xmath112 as part of a broadcast is resent by @xmath111 if @xmath111 sends exactly the same message as part of a broadcast ( not necessarily to the same set of recipients ) .",
    "for example , if @xmath112 sends @xmath58 to the remainder of @xmath115 as part of a partial checkpoint , and later @xmath111 sends @xmath58 to the remainder of @xmath116 , then , whether or not @xmath117 , the messages in the second broadcast are considered to be resendings .",
    "since the completion of a chunk is followed by a full checkpoint , it is not hard to show that when a new group becomes active , it will redo at most one chunk of work that was already done by previous active groups .",
    "it will also redo at most one full checkpoint that was done already on the previous chunk , and @xmath47 partial checkpoints ( one for each subchunk of work redone ) . in all , it is easy to see that at most @xmath46 units of work done by previous groups are redone when a new group becomes active , and @xmath118 messages are resent . similarly , since the completion of a subchunk",
    "is followed by a partial checkpoint , it is not hard to show that when a new process , say @xmath51 , in a group that is already active becomes active , and the last message it received was of the form @xmath58 ( i.e. , a partial checkpoint of subchunk @xmath54 ) , it will redo at most one subchunk that was already done by previous active process ( namely , @xmath91 ) , and may possibly resend the messages in two partial checkpoints :  the one sent after subchunk @xmath54 , and the one sent after subchunk @xmath91 ( if the previous process crashed during the checkpointing of @xmath91 without @xmath51 receiving the message ) . if the last message that @xmath51 received was @xmath61 for @xmath119 ( that is , the checkpointing of a checkpoint in the middle of a full checkpoint ) ,",
    "then similar arguments show that it may resend @xmath120 messages :  the checkpoint of @xmath61 to its own group , the checkpoint @xmath71 to group @xmath90 , and the checkpointing of @xmath71 to its own group .",
    "thus , the amount of work done by an active group that is redone when a new process in that group becomes active is at most @xmath48 , and the number of messages resent is at most @xmath120 .",
    "the maximum amount of unnecessary work done is : ( number of groups ) @xmath121 ( amount of work redone when a new group becomes active ) + ( number of processes ) @xmath121 ( amount of work redone when a new process in an already active group becomes active ) @xmath122 .",
    "similarly , the maximum number of unnecessary messages that may be sent is no more than : ( number of groups ) @xmath121 ( number of messages resent when a new group becomes active ) + ( number of processes ) @xmath121 ( number of messages resent when a new process in an already active group becomes active ) @xmath123 .",
    "clearly @xmath1 units of work must be done ; by lemma  [ facts ] , at most @xmath124 messages are necessary .",
    "thus , no more than @xmath106 units of work will be done altogether , and no more than @xmath125 messages will be sent altogether .",
    "as we have observed , the round complexity of protocol @xmath95  is @xmath108 .",
    "we now discuss how the protocol can be modified to give a protocol that has round complexity @xmath15 , while not significantly changing the amount of work done or the number of messages sent .",
    "certainly one obvious hope for improvement is to use a better function than @xmath109 for computing when process @xmath51 should become active .",
    "while some improvement is possible by doing this , we can get a round complexity of no better than @xmath126 if this is all we do , which is still more than we want .",
    "intuitively , the problem is that if process @xmath63 gets a message of the form @xmath61 , then it is possible , as far as @xmath63 is concerned , that some other process @xmath127 may have received a message of the form @xmath128 .",
    "( observe that this situation is possible even if @xmath129 because if the sender of the message @xmath130 crashes at the round it broadcasts this message to @xmath50 , this message may reach an arbitrary subset of the processes in @xmath50 . )",
    "process @xmath63 can not become active before it is sure that @xmath51 has retired . to compute how long it must wait before becoming active",
    ", it thus needs to compute how long @xmath51 would wait before becoming active , given that @xmath51 got a message of the form @xmath128 .",
    "on the other hand , if @xmath51 did get such a message , then as far as @xmath51 is concerned , some process @xmath131 may have received a message of the form @xmath132 .",
    "notice that , in this case , process @xmath63 knows perfectly well that no process received a message of the form @xmath132 ; the problem is that @xmath51 does not know this , and must take into account this possibility when it computes how long to wait before becoming active .",
    "carrying out a computation based on these arguments gives an algorithm which runs in @xmath126 rounds .    on closer inspection",
    ", it turns out that the situation described above really causes difficulties only when all processes involved ( in the example above , this would be the processes @xmath63 , @xmath51 , and @xmath133 ) are in the same group .",
    "thus , in our modified algorithm , called protocol @xmath21 , process @xmath63 computes the time to become active as follows : suppose that the last message received by process @xmath63 before round @xmath29 was received from process @xmath51 in round @xmath134 .",
    "process @xmath63 then computes a function @xmath135 with the property that if @xmath136 , then process @xmath63 knows at round @xmath29 that all processes in groups @xmath137 must have retired .",
    "moreover , if @xmath129 , then @xmath63 knows at round @xmath29 that all processes @xmath138 must have retired .",
    "process @xmath63 then polls all the lower - numbered processes in its own group not known to it as retired , one by one , to see if they are alive ; if not , then @xmath63 becomes active .",
    "if any of them is alive , then the lowest - numbered one that is alive becomes active upon receipt of @xmath63 s message .",
    "once a process becomes active , it proceeds just as in protocol  @xmath95 .",
    "this technique turns out to save a great deal of time , while costing relatively little in the way of messages .",
    "in particular , in protocol @xmath21 , process 0 follows the same algorithm as in protocol @xmath95 .",
    "s algorithm is as follows . here",
    "@xmath63 receives messages either of the form @xmath58 , @xmath61 or of the form .",
    "we call the first two types of messages _ ordinary _ , to distinguish them from the  messages .",
    "suppose that the last ordinary message received by process @xmath63 before round @xmath29 is of the form @xmath58 or @xmath87 , and this message was received from process @xmath51 at round @xmath134 . to avoid dealing separately with the special case in which @xmath63 does not receive any message before it becomes active , we use the convention that process 0 becomes active in round 0 ( just before the execution begins ) and every process receives from it an ordinary message @xmath139 at that round .",
    "( these fictitious messages are used only in the analysis and hence will not be taken into account when computing the message complexity of the protocol .",
    "also , if in the actual execution process 0 crashes before ever becoming active then we say that it crashes just after it finishes broadcasting these fictitious messages . )",
    "there are now two ways for @xmath63 to become active at round @xmath29 .",
    "the first is if @xmath63 receives a  message at round @xmath29 and @xmath140 . in this case",
    "@xmath63 becomes active , proceeding just as in protocol  when it became active at round @xmath82 .",
    "alternatively , if @xmath63 does not receive a message for a sufficiently long time , @xmath63 becomes active .",
    "intuitively , sufficiently long will ensure that all processes smaller than @xmath63 have already retired .    to analyze this more formally , we need some definitions .",
    "let  be @xmath17 .",
    "( `` '' stands for process time out . )",
    "@xmath141 is an upper bound on the number of rounds that can pass before process @xmath63 in group @xmath142 hears from process @xmath51 if @xmath51 is active .",
    "let @xmath143 denote @xmath63 mod @xmath47 .",
    "let @xmath144 be @xmath145 .",
    "( `` '' stands for group time out . )",
    "@xmath146 is an upper bound on the number of rounds that can pass before process @xmath63 in group @xmath147 hears from a process @xmath68 in @xmath50 with @xmath148 if any of these processes is active .",
    "next we define a new deadline function as follows :    @xmath149 we now define `` sufficiently long '' in terms of @xmath150 rather than @xmath109 . again taking @xmath29 to be the current round , @xmath134 to be the last round before @xmath29 in which @xmath63 received a message , and @xmath51 to be the process sending that message",
    ", @xmath63 proceeds as follows : if @xmath151 , then @xmath63 does nothing . if @xmath152 and @xmath153 , @xmath63 becomes _",
    "preactive_. first consider the case where @xmath154 . informally , at this point",
    ", @xmath63 knows that all processes from groups @xmath155 have failed . in this case , it sends a  message to each lower - numbered process in its group , starting with the first process in @xmath76 up to the @xmath156st process in @xmath76 , and waiting @xmath141 rounds between messages to see if it receives a message .",
    "( observe that if the recipient of the  message is alive , the sender receives a message from it within one round after the  mesage was sent ; however , for technical reasons the sender of the  messages waits @xmath141 rounds between two successive  messages . ) if @xmath157 , process @xmath63 proceeds similarly to the case where @xmath158 except that when sending  messages it starts with the @xmath159st process in @xmath76 .",
    "that is , it sends a  message to each lower - numbered process in its group , starting with the @xmath159st process in @xmath76 up to the @xmath156st process in @xmath76 , and waiting @xmath141 rounds between messages to see if it receives a message .",
    "if @xmath63 does not receive any response to its  messages by round @xmath160 if @xmath158 , or by round @xmath161 if @xmath129 , then it becomes active at round @xmath162 ( respectively , @xmath163 ) , proceeding just as it did in protocol @xmath95 at round @xmath164 .",
    "if it does get a message , then @xmath63 becomes passive again .",
    "xx = xxxx = xxxx = xxxx = xxxx = xxxx = xxxx main protocol +   + 1 . just received a  message + 2 .",
    "dowork ;  \\{see figure  [ protocol a code ] for details } + 3 .",
    "round number @xmath165 + last message received was from process @xmath51 at round @xmath134 + 4 .",
    "preactivephase@xmath166 +   +   + preactivephase@xmath166 +   + 1 .",
    "@xmath158 + 2 .",
    "@xmath167 ; + 3 .",
    "@xmath168 ; +   + 4 .",
    "@xmath169 ; + 5 . not received a message _ and _ @xmath170 * do * + 6 . @xmath171 + 7 .",
    "send  message to process @xmath133 ; + 8 .",
    "@xmath172 ; + 9 . just received a  message or @xmath173 + 10 .",
    "dowork    note that the construction of the algorithm guarantees that if @xmath174 , the last ordinary message that @xmath63 receives in execution @xmath175 prior to round @xmath29 was sent by @xmath51 , and @xmath158 , then @xmath63 will become active in @xmath175 at or before round @xmath29 .",
    "( it may become active earlier if it receives a  message . ) similarly , if @xmath176 , the last ordinary message that @xmath63 receives in execution @xmath175 prior to round @xmath29 was sent by @xmath51 , and @xmath157 , then @xmath63 will become active in @xmath175 at or before round @xmath29 .",
    "define @xmath177 ( `` ' ' stands for transition time . ) our observations above show that if @xmath178 and the last ordinary message that @xmath63 receives in execution @xmath175 prior to round @xmath29 was sent by @xmath51 , then @xmath63 will become active in @xmath175 at or before round @xmath29 .    unless it has already crashed",
    ", process @xmath63 terminates before becoming active if it receives @xmath66 ( as part of a partial checkpoint ) or @xmath67 ( as part of a full checkpoint ) .",
    "otherwise , after becoming active it terminates as follows . if @xmath92 then @xmath63 terminates after broadcasting @xmath66 to the remainder of @xmath76 . if @xmath93 then @xmath63 terminates after completing a call of the form fullcheckpoint(@xmath94 )",
    "this completes the description of protocol @xmath21 .",
    "the code for protocol  @xmath21 appears in figure  [ protocol b code ] ; it uses the code for the dowork procedure in figure  [ protocol a code ] .      in this section",
    "we show that the round complexity of protocol @xmath21  is @xmath2 , and that neither the amount of work done nor the number of messages sent in protocol  is significantly larger than in protocol .",
    "suppose for a moment that in every execution of protocol @xmath21  a process becomes active only after all lower numbered processes have retired .",
    "since when a process becomes active in an execution of protocol @xmath21 it performs essentially the same steps as when it becomes active when it follows protocol , a similar proof to the one of theorem  [ protocolatheorem ] will show that the amount of work performed in any execution of protocol @xmath21 is no more than @xmath106 units ( which is roughly the maximum amount of work performed in any execution of protocol ) , and the number of ordinary messages sent is no more than @xmath12 ( which is roughly the maximum number of messages sent in any execution of protocol ) .",
    "since the number of   messages sent in any execution of protocol  is at most @xmath100 ( each process sends at most one  message to every other process in its group ) , it follows immediately that the total amount of effort performed by protocol  is not significantly larger than the one performed by protocol .",
    "therefore , the main property we need to prove is that in every execution of protocol , a process becomes active only after all lower numbered processes have retired .",
    "our analysis uses what we call _ activation chains_. the round @xmath29 _ activation chain _ of process @xmath51 , denoted @xmath179 , is the sequence of processes @xmath180 such that @xmath181 and for all @xmath63 , if @xmath182 received an ordinary message prior to round @xmath29 , then @xmath183 is the sender of the last message received by @xmath184 .",
    "( as we show below , it can not be the case that @xmath182 receives ordinary messages from two distinct processes in the same round .",
    "since we have not yet proved this , for now , if @xmath182 received ordinary messages from more than one process in the last round in which it received an ordinary message , we take @xmath183 to be the lowest - numbered process among them . )",
    "notice that our convention that process 0 sent a round 0 message guarantees that @xmath185 .",
    "in addition , note that the processes in the activation chain appear in increasing order since a process sends messages only to higher numbered processes .",
    "it is sometimes convenient to view @xmath51 s activation chain as a whole and to reason about the effort performed by the chain .",
    "we say that process @xmath68 in @xmath179 is the _ current process _ from the round it becomes active up to ( but not including ) the round at which its successor in the chain becomes active .",
    "note that a process in @xmath179 is current when it first becomes active .",
    "now let @xmath186 be processes in @xmath179 such that @xmath187 immediately succeeds @xmath68 , and assume the last ordinary message @xmath187 receives from @xmath68 before @xmath187 becomes active is sent at round @xmath134 .",
    "clearly , any operation ( sending messages or performing a unit of work ) done by @xmath68 after round @xmath134 is not known by @xmath187 and hence may be repeated by the chain ( that is , may be repeated by some process when it is the current process in the chain ) . on the other hand , any operation done by @xmath68 before round @xmath134 will be known by the processes succeeding it in the chain by the time they become active , and hence will not be repeated by the chain .",
    "the operation done by @xmath68 in round @xmath134 , which is a broadcast to @xmath188 , will be repeated by @xmath187 in the first round in which @xmath187 becomes active .",
    "we say that an operation performed by a process @xmath68 in the chain is _ useful _ if it is performed before the round in which the process immediately succeeding @xmath68 in the chain heard from @xmath68 for the last time before becoming active ( if the process is @xmath51 , then there is no later process in the chain , and hence all operations performed by @xmath51 are useful ) .",
    "when we refer to an _ operation performed by a chain @xmath189 _ , we mean a useful operation performed by some process in that chain .",
    "we say that a round is _ useful _ for the chain @xmath189 if the chain performed a useful operation in that round ; otherwise we say that the round is _",
    "useless_.    the discussion above shows that the operations performed by a chain proceed in a similar order to the operations performed by a single active process .",
    "more precisely , if we consider only useful operations , the processes in the chain perform work units one by one in the natural order and without repetition ; each time a subchunk @xmath54 is completed by the chain , the group of the process that completes this subchunk is informed about this fact exactly once , and if the completed subchunk is a multiple of @xmath47 , then in addition all groups whose numbers are higher than the group of the process that completed this subchunk are informed that the subchunk is completed one by one in the natural order and without repetition ( that is , each such group @xmath60 receives a message @xmath87 exactly once ) ; moreover , each time such a group @xmath60 is informed , this fact is checkpointed to the group of the informer exactly once .",
    "assume process @xmath51 is active at some round @xmath29 with @xmath190 .",
    "then we denote by @xmath191 the number of useful rounds for the chain @xmath179 in interval @xmath192 $ ] ( that is , in the period from round @xmath193 to round @xmath194 ( inclusive ) ) .",
    "the discussion above shows the following :    [ maxlemma ] let @xmath187 be active at some round @xmath29 with @xmath195 .",
    "then    * @xmath196 , * if @xmath197 , then each process @xmath198 must have received a message from ( a process in ) @xmath189 at some round @xmath134 such that @xmath199 .    part ( a ) follows from the fact that in each useful round , the chain either performs work , or checkpoints to some group @xmath60 the fact that a subchunk @xmath54 was performed , or checkpoints the fact that group @xmath60 was informed that chunk @xmath54 was performed .",
    "the discussion above shows that no unit of work is repeated and hence there are at most @xmath1 useful rounds in which the chain performs work .",
    "similarly , each subchunk is partially checkpointed at most once and hence there are at most @xmath0 useful rounds in which the chain performs partial checkpoints of subchunks .",
    "also , the completion of a chunk is checkpointed to each group at most once , yielding at most @xmath0 useful rounds in which such subchunks are checkpointed .",
    "finally , the fact that group @xmath60 was informed about chunk @xmath54 is checkpointed at most once , yielding at most @xmath0 additional useful rounds . summing the above",
    "the claim follows .",
    "part ( b ) follows because , as reasoned above , the useful operations done by the chain follow the same order as if they are done by a single active process , and hence within @xmath200 rounds the chain must complete a chunk and a full checkpoint .",
    "now , as we mentioned above , at the core of our proof of correctness is the fact that when a process becomes active , all lower numbered processes have already retired . to prove this , we first prove a lower bound on the number of useful rounds for a given activation chain in a given period . using this bound",
    ", we can show that if some process @xmath51 receives its last ordinary message before becoming active at round @xmath193 , @xmath51 becomes active at round @xmath194 , and some process @xmath201 has not retired by @xmath194 , then process @xmath51 would have received an ordinary message from some process in @xmath202 between rounds @xmath193 and @xmath194 , contradicting our choice of @xmath193 .",
    "we now proceed with the formal proofs .",
    "we start with a technical lemma .",
    "[ addlemma ] let @xmath203",
    ". then    * @xmath204 , * if @xmath205 , then @xmath206 .",
    "the proof is straightforward .",
    "we start with part ( a ) . in the calculations below",
    ", we use `` ( @xmath157 ) '' to denote the value 1 if @xmath129 and 0 otherwise . similarly",
    ", `` @xmath207 '' denotes 1 if @xmath158 , and 0 otherwise .",
    "recall that @xmath143 denotes @xmath63 mod @xmath47 .",
    "@xmath208(g_j \\neq g_k)\\\\ & \\quad & + [ ( { \\bar{\\mbox{{\\em \\j}}}}-\\overk)\\mdp](g_j = g_k ) \\\\ & \\quad & + [ \\mdg(j)+(g_l - g_j-1)\\mdg(0)+\\overl \\mdp](g_l \\neq g_j)\\\\ & \\quad & + [ ( \\overl-{\\bar{\\mbox{{\\em \\j}}}})\\mdp](g_l = g_j).\\end{aligned}\\ ] ]    if @xmath209 , then @xmath210(g_l \\neq g_k)\\\\ & \\quad & + [ ( \\overl-{\\bar{\\mbox{{\\em \\j}}}})\\mdp](g_l = g_k)\\\\ & = & [ \\mdg(k)+(g_l - g_k-1)\\mdg(0)+\\overl \\mdp](g_l \\neq g_k)\\\\ & \\quad & + [ ( \\overl-\\overk)\\mdp](g_l = g_k)\\\\ & = & \\tr(l , k),\\end{aligned}\\ ] ] and part ( a ) follows .",
    "( in the first equality we replaced @xmath76 by @xmath88 since in this case they are identical , and the second equality follows because @xmath211 . )    if @xmath212 , then @xmath213\\\\ & \\quad & + [ \\mdg(j)+(g_l - g_j-1)\\mdg(0)+\\overl \\mdp](g_l \\neq g_j)\\\\ & \\quad & + [ ( \\overl-{\\bar{\\mbox{{\\em \\j}}}})\\mdp](g_l = g_j)\\\\ & = & [ \\mdg(k)+(g_l - g_k-1)\\mdg(0)+\\overl \\mdp](g_l \\neq g_j)\\\\ & \\quad & + [ \\mdg(k)+(g_j - g_k-1)\\mdg(0)+\\overl \\mdp](g_l = g_j)\\\\ & = & [ \\mdg(k)+(g_l - g_k-1)\\mdg(0)+\\overl \\mdp]\\\\ & = & \\tr(l , k),\\end{aligned}\\ ] ] and again part ( a ) follows .",
    "( the second equality follows by a case analysis on whether or not @xmath214 , using the fact that @xmath215 and the fourth equality follows since @xmath212 and @xmath203 implies @xmath216 . )    the proof of part ( b ) is similar .",
    "observe that here by assumption , @xmath217 and hence also @xmath218 . if @xmath209 , then @xmath219\\\\ & = & [ \\mdg(k)+(g_l - g_k-1)\\mdg(0)]\\\\ & = & \\ddb(l , k),\\end{aligned}\\ ] ] and part ( b ) follows .    if @xmath212 , then @xmath220\\\\ & \\quad & + [ \\mdg(j)+(g_l - g_j-1)\\mdg(0)]\\\\ & = & [ \\mdg(k)+(g_l - g_k-1)\\mdg(0)]\\\\ & = & \\ddb(l , k),\\end{aligned}\\ ] ] and part ( b ) follows .",
    "the next lemma establishes a lower bound on the number of useful rounds for an activation chain in a given interval .",
    "[ minlemma ] assume @xmath187 is active at some round @xmath29 such that @xmath195 .",
    "assume @xmath221 is the current process in @xmath189 at some round @xmath222 .",
    "then @xmath223    we first show that if @xmath63 is in @xmath189 and becomes active at round @xmath134 with @xmath224 , then there are at most @xmath225 useless rounds in @xmath226 $ ] .",
    "we proceed by induction on @xmath134 . if @xmath227 , the result is trivial .",
    "if @xmath228 , then @xmath63 is @xmath51 s successor for some @xmath51 in the activation chain and @xmath63 received its last message from @xmath51 at some round @xmath229 .",
    "( there is such an @xmath51 and such a message since by convention process 0 sent an ordinary message to everybody just before the execution begins . ) by definition , we have @xmath230 .",
    "if @xmath231 , we are done , since no round in @xmath232 $ ] is useless , so there are at most @xmath233 useless rounds in @xmath234 $ ] .",
    "if @xmath235 , then suppose @xmath51 becomes active at @xmath236 . by the inductive hypothesis , there are at most @xmath237 useless rounds in @xmath238 $ ] . all the rounds in",
    "@xmath239 $ ] are useful .",
    "thus , there are at most @xmath240 useless rounds in @xmath226 $ ] . since @xmath241 by lemma  [ addlemma ] , the inductive step follows .",
    "suppose that @xmath187 becomes active at round @xmath242 . by the argument above",
    ", there are at most @xmath243 useless rounds in @xmath244 $ ] .",
    "if @xmath245 , it immediately follows that there are at most @xmath243 useless rounds in @xmath246 $ ] . on the other hand , if @xmath247 , since @xmath187 is still active at @xmath248 , it follows that there are no useless rounds in @xmath249 $ ] .",
    "hence , we again get that there are at most @xmath243 useless rounds in @xmath246 $ ] . the lemma follows .",
    "the next lemma shows that in every execution of protocol , by the time a process becomes active , all lower numbered processes have retired .",
    "[ properorderlemma ] in every execution of protocol @xmath21 ,    * before the round @xmath29 in which process @xmath51 becomes preactive , all processes in groups @xmath250 have retired ; * before the round @xmath29 in which process @xmath51 becomes active , all processes @xmath251 have retired .",
    "fix an execution @xmath252 of protocol @xmath21 .",
    "the proof proceeds by induction on the round @xmath29 .",
    "the base case of @xmath253 holds trivially since only process 0 is active then .",
    "assume the claim for @xmath254 , and we will show it for @xmath29 . if @xmath255 , the claim holds trivially .",
    "thus , we can assume @xmath256 .",
    "suppose that the last ordinary message that @xmath51 received before round @xmath29 came from @xmath68 , and was received at round @xmath193 .",
    "( note that there must have been such an ordinary message , given our assumption that process 0 sent an ordinary message to all the processes before the execution begins . )",
    "we first prove part ( a ) .",
    "assume , by way of contradiction , that some process @xmath187 with @xmath257 does not retire by round @xmath29 . since , by assumption , @xmath193 was the latest round @xmath258 at which @xmath51 received an ordinary message , to complete the proof it is enough to show that if @xmath187 does not retire before round @xmath29 , @xmath51 must have received an ordinary message at some round @xmath229 with @xmath259 .",
    "in fact , we plan to show that @xmath51 must have received a message in the interval @xmath260 from some process in @xmath189 .",
    "to do this , we plan to use lemmas  [ maxlemma ] and  [ minlemma ] .",
    "notice that both of these lemmas require @xmath187 to be active .",
    "in fact , we can assume without loss of generality that @xmath187 is active at some round @xmath261 of @xmath252 , and that @xmath262 . if not , we can just consider the execution @xmath263 which is identical to @xmath252 up to round @xmath29 , after which all processes other than @xmath187 crash .",
    "it is clear that eventually @xmath187 becomes active in @xmath252 , with the same activation chain it has in round @xmath29 .",
    "moreover , if @xmath51 receives an ordinary message in the interval @xmath260 in @xmath263 , then it must also receive the same message in @xmath252 , since the two executions agree up to round @xmath29 .",
    "since @xmath68 becomes active at some round prior to @xmath29 , the inductive hypothesis on part ( b ) of the lemma implies that all processes @xmath264 have retired by round @xmath265 .",
    "thus without loss of generality @xmath266 .",
    "we consider two cases : ( i ) @xmath68 is in @xmath189 ; ( ii ) @xmath68 is not in @xmath189 .    in case ( i ) , since @xmath68 is in @xmath187 s activation chain and is active at round @xmath193 , by the inductive hypothesis , it must be the current process in @xmath189 at round @xmath193 . applying lemma  [ minlemma ] to @xmath267 , we get @xmath268    by definition , @xmath51 becomes preactive in round @xmath269 , and hence @xmath270 . substituting this into the above inequality we get @xmath271    since @xmath272",
    ", lemma  [ addlemma ] implies that @xmath273 , and substituting this fact in the above inequality we get @xmath274    thus part ( b ) of lemma  [ maxlemma ] implies that @xmath51 must have received an ordinary message at some round in the interval @xmath275 , contradicting the assumption that it does not , and the claim follows .    in case ( ii ) , let @xmath276 be the greatest process @xmath277 in @xmath187 s activation chain , and let @xmath63 be the smallest process @xmath278 in @xmath187 s activation chain .",
    "suppose @xmath63 gets its last message before becoming active from @xmath276 at round @xmath279 .",
    "( note that this means that the last message received by @xmath63 before becoming active came at @xmath279 . ) since the inductive hypothesis on part ( b ) implies that @xmath276 must retire before @xmath68 becomes active , and since @xmath68 must become active at least one round before it sent a message to @xmath51 ( since by assumption @xmath280 and process @xmath68 checkpoints to its own group before it sends a message to another group ) , we have @xmath281 . furthermore , since the processes succeeding @xmath276 in @xmath187 s chain are greater than @xmath68 , the same inductive hypothesis implies that these processes can become active only after process @xmath68 retires , and hence after round @xmath193 . since by definition ,",
    "any message received by @xmath51 after round @xmath279 from @xmath187 s chain must be sent by one of the processes succeeding @xmath276 in the chain , it follows that if @xmath51 receives a message from @xmath187 s chain after round @xmath279 , this message is sent after round @xmath193 .    to complete the proof",
    "we show that @xmath51 must have received some message from @xmath187 s chain at some round in the interval @xmath282 , and hence in the interval @xmath275 , contradicting the assumption that it does not .",
    "as argued above , to show this it is enough to show that @xmath283 applying lemma  [ minlemma ] to @xmath187 s activation chain we get @xmath284    to bound @xmath285 , we need to bound @xmath286 . to do this",
    "we will compute two terms : ( a ) @xmath287 ; and ( b ) @xmath288 .",
    "the first term is equal to @xmath289 as argued above . to compute the second term",
    ", we first show : ( 1 ) @xmath290 , and ( 2 ) @xmath291 .    for ( 1 ) , clearly @xmath292 , since @xmath293 .",
    "if @xmath209 , @xmath63 must have received a message from @xmath68 at round @xmath294 before @xmath68 sent a message to @xmath51 ( since by assumption @xmath280 and process @xmath68 checkpoints to its own group just before it sends a message to another group ) .",
    "as we have observed , @xmath295 , so this contradicts the assumption that the last message received by @xmath63 before becoming active came at @xmath279 .",
    "thus @xmath296 .    for ( 2 ) , clearly @xmath297 .",
    "if @xmath298 , this means that @xmath63 did not receive a message from a process in @xmath88 before becoming active ( because if it did , then by the inductive hypothesis on part ( b ) we have that this message arrives after @xmath276 retires and hence after round @xmath279 ) .",
    "but since @xmath299 , and @xmath68 sent a message to @xmath51 at @xmath193 , some process in @xmath88 must have sent a message to @xmath63 before round @xmath193 , and hence before @xmath63 becomes active .",
    "this gives us the desired contradiction .    to complete the proof of case ( ii ) we use the following claim :    [ nolessclaim ] every process @xmath300 with @xmath301 that becomes active",
    "does so no earlier than round @xmath302 .",
    "we proceed by induction .",
    "assume @xmath303 and the claim holds for all @xmath300 with @xmath304 .",
    "we prove it for @xmath305 .",
    "we first show that the last ordinary message that any process @xmath306 in @xmath88 receives from any process @xmath307 with @xmath308 is sent no earlier than round @xmath309 .",
    "observe that since @xmath276 is in @xmath88 , so are @xmath305 and @xmath307 . if @xmath310 , the claim trivially follows since @xmath276 must send a message to its own group at round @xmath311 just before it sends a message to @xmath312 .",
    "otherwise , by the induction hypothesis we have that @xmath307 became active no earlier than round @xmath309 , and the claim again follows .",
    "let @xmath307 be the last process from which @xmath305 receives an ordinary message .",
    "observe that @xmath308 .",
    "( because , as reasoned above , @xmath305 has received a message from @xmath276 , and hence the message sent from @xmath307 was sent at or after the time the message from @xmath276 ; the inductive hypothesis on part ( b ) therefore implies that @xmath313 . )",
    "it follows from the claim above that the message from @xmath307 was sent no earlier than round @xmath309 .",
    "in addition , the inductive hypothesis on part ( b ) implies that @xmath305 becomes active only after @xmath307 retires , and hence only after receiving its message .",
    "now , assume that @xmath305 does not receive a  message .",
    "it then becomes preactive @xmath314 rounds after it receives the last ordinary message from @xmath307 and then @xmath305 starts sending  messages to lower numbered processes in its group . since , by assumption ,",
    "@xmath305 does not receive a message in response , it becomes active @xmath315 rounds after receiving this last message from @xmath307 , and hence no earlier than round @xmath316 .",
    "next assume @xmath305 receives a  message . let @xmath317 be the process sending this message .",
    "let @xmath307 be the last process from which @xmath317 received an ordinary message before sending the  message to @xmath305 .",
    "since @xmath317 sends a  message to @xmath305 , it follows that @xmath318 .",
    "just as above , we can show that @xmath313 , and hence that @xmath317 received the ordinary message from @xmath307 no earlier than round @xmath319 .",
    "clearly , @xmath317 sends the  message to @xmath305 no earlier than @xmath320 rounds after it receives its ordinary message from @xmath307 , and the claim follows as above .",
    "this completes the proof of the inductive step .",
    "now , to compute @xmath321 , observe that @xmath193 , the round in which @xmath68 sends a message to @xmath51 , is at least one round after @xmath68 becomes active ( because @xmath322 and @xmath68 first broadcasts to its own group ) , and hence claim  [ nolessclaim ] immediately implies that @xmath323 .",
    "thus we get that @xmath324 ( the fourth inequality follows because @xmath325 , and the fifth inequality follows because @xmath326 . )    again , lemma  [ addlemma ] implies that @xmath327 , and hence @xmath328 this completes the proof of the inductive step for part ( a ) .    for part ( b ) , suppose by way of contradiction that @xmath51 becomes active at round @xmath29 and process @xmath329 has not retired by round @xmath29 .",
    "first assume @xmath51 does not receive a  message . if @xmath257 , we get an immediate contradiction using the inductive step for part ( a ) , since @xmath51 becomes active at or after it becomes preactive .",
    "otherwise , recall that @xmath68 is the last process from which @xmath51 receives an ordinary message before becoming active , and this message is received at round @xmath193 .",
    "if @xmath330 , then since @xmath68 became active before round @xmath29 , the inductive hypothesis on part ( b ) implies that @xmath187 must have retired before @xmath68 became active and hence before round @xmath29 . if @xmath331 , then @xmath51 becomes preactive only after @xmath332 additional rounds in which it does not hear from @xmath187 .",
    "we claim that @xmath187 must have retired by that time .",
    "because otherwise , in this period @xmath187 would have either performed a subchunk and informed its group , or would have checkpointed a subchunk to a group @xmath333 and informed its group about the checkpoint . since @xmath334 , in both cases ,",
    "@xmath51 must have heard from @xmath187 . finally , if @xmath335 , then before @xmath51 becomes active it sends a  message to @xmath187 and waits for a message from @xmath187 for @xmath141 additional rounds .",
    "exactly as above , it follows again that since @xmath51 does not receive any message from @xmath187 , @xmath187 must have retired .",
    "next assume @xmath51 does get a  message before becoming active .",
    "however , the same reasoning as above shows that by the time a process sends a  message to process @xmath51 , all processes @xmath251 have retired , and we are done .",
    "finally we can show :    [ protocolbtheorem ] in every execution of protocol ,    * at most @xmath106 units of work are performed in total by the processes , * at most @xmath336 messages are sent , * by round @xmath337 all processes have retired .",
    "parts ( a ) and ( b ) were argued in the beginning of section  [ section : bproof ] .",
    "for part ( c ) , let @xmath51 be the last process that is active and consider its activation chain .",
    "we want to find the last round @xmath194 in which @xmath51 is active .",
    "it follows from lemma  [ maxlemma ] that the maximal number of useful rounds performed by any chain is @xmath99 .",
    "therefore , applying lemma  [ minlemma ] with @xmath338 we get that @xmath339 thus @xmath340",
    "in this section we prove that the effort of @xmath38 obtained by the previous protocols is not optimal , even for work - optimal protocols .",
    "we construct another work - optimal algorithm , protocol  @xmath342 , that requires only @xmath16 messages ( and a variant that requires only @xmath343 messages ) , yielding a total effort of @xmath344 .",
    "as is the case with protocols @xmath97  and  @xmath345 , at most one process is active at any given time .",
    "however , in protocol @xmath342 it is not the case that there is a predetermined order in which the processes become active .",
    "rather , when an active process fails , we want the process that is currently _ most knowledgeable _ to become the new active process .",
    "as we shall see , which process is most knowledgeable after an active process @xmath51 fails depends on how many units of work @xmath51 performed before failing . as a consequence , there is no obvious variant of protocol @xmath342 that works in the model with asynchronous processes and a failure - detector . roughly speaking ,",
    "protocol @xmath342 strives to `` spread out '' as uniformly as possible the knowledge of work that has been performed and the processes that have crashed .",
    "thus , each time the active process , say @xmath51 , performs a new unit of work or detects a failure , @xmath51 tells this to the process @xmath63 it currently considers least knowledgeable .",
    "then process @xmath63 becomes as knowledgeable as @xmath51 , so after performing the next unit of work ( or detecting another failure ) , @xmath51 tells the process it now considers least knowledgeable about this new fact .",
    "the most nave implementation of this idea is the following : process 0 begins by performing unit 1 of work and reporting this to process 1 .",
    "it then performs unit 2 and reports units 1 and 2 to process 2 , and so on , telling process @xmath51 mod @xmath0 about units 1 through @xmath51 .",
    "note that at all times , every process knows about all but at most the last @xmath0 units of work to be performed .",
    "if process 0 crashes , we want the most knowledgeable alive process  the one that knows about the most units of work that have been done  to become active .",
    "( if no process alive knows about any work , then we want the highest numbered alive process to become active . )",
    "it can be shown that this can be arranged by setting appropriate deadlines . moreover , the deadlines are chosen so that at most one process is active at a given time .",
    "the most knowledgeable process then continues to perform work , always informing the least knowledgeable process .",
    "the problem with this nave algorithm is that it requires @xmath346 work and @xmath346 messages in the worst case .",
    "for example , suppose that process 0 performs the first @xmath13 units of work , so that the last process to be informed is process @xmath13 , and then crashes . in addition , @xmath347 crash .",
    "eventually process @xmath348 , the most knowledgeable non - retired process , will become active",
    ". however , process @xmath348 has no way of knowing whether process 0 crashed just after informing it about work unit @xmath348 , or process 0 continued to work , informing later processes ( who must have crashed , for otherwise they would have become active before process @xmath348 ) .",
    "thus , process @xmath348 repeats work units @xmath349 , again informing ( retired ) processes @xmath350 .",
    "suppose process @xmath348 crashes after performing work unit @xmath13 and informing process @xmath13 .",
    "then process @xmath351 becomes active , and again repeats this work .",
    "if each process @xmath352 , crashes after repeating work units @xmath353 , then @xmath354 work is done , and @xmath354 messages are sent .",
    "( a slight variant of this example gives a scenario in which @xmath346 work is done , and @xmath346 messages are sent . )    to prevent this situation , a process performs failure detection before proceeding with the work .",
    "the key idea here is that we treat failure detection as another type of work .",
    "this allows us to use our algorithm recursively for failure detection .",
    "specifically , fault - detection is accomplished by polling a process and waiting for a response or a timeout .",
    "the difficulty encountered by our approach is that , in contrast to the real work , the set of faulty processes is dynamic , so it is not obvious how these processes can be detected without sending ( wasteful ) polling messages to _ nonfaulty _ processes .",
    "in fact , in our algorithm we do not attempt to detect all the faulty processes , only enough to ensure that not too much work is wasted by reporting work to faulty processes .",
    "xx = xxxx = xxxx = xxxx = xxxx = xxxx = xxxx + 1 .",
    "@xmath355 ; + 2 .",
    "@xmath356 * do * + 3 .",
    "@xmath357 + 4 .",
    "@xmath358 * do * + 5 .",
    "send `` are you alive ? ''",
    "to @xmath359 $ ] ; + 6 . no response + 7 .",
    "add @xmath359 $ ] to @xmath360 ; + 8 .",
    "@xmath361 + 9 .",
    "send ordinary message to @xmath362 $ ] ; + 10 .",
    "@xmath363 \\gets \\curr$ ] ; + 11 .",
    "@xmath364 \\gets \\succ(\\point_i[g^i_{h+1}])$ ] ; + 12 .",
    "@xmath365 + 13 .",
    "@xmath366 \\gets \\succ(\\point_i[g^i_{h}])$ ] ; + 14 .",
    "@xmath367 ; + 15 .",
    "( _ i.e. _ , response received ) @xmath367 ; + 16 .",
    "@xmath368 ; +   + \\{process level 0 ( real work ) : } + 17 .",
    "@xmath369 \\le n$ ] * do * + 18 .",
    "perform work unit @xmath369 $ ] ; + 19 .",
    "send an ordinary message to @xmath370 $ ] ; + 20 .",
    "@xmath371 \\gets \\curr$ ] ; + 21 .",
    "@xmath370 \\gets \\succ(\\point_i[g^i_1])$ ] ; + 22 .",
    "@xmath369 \\gets \\succ(\\point_i[g_0])$ ]      for ease of exposition we assume @xmath0 is a power of 2 . again , the processes are numbered @xmath372 through @xmath13 , and the units of work are numbered 1 through @xmath1 . although our algorithm is recursive in nature , it can more easily be described when the recursion is unfolded .",
    "processing is divided into @xmath373 levels , numbered 1 to @xmath373 , where level @xmath373 would have been the deepest level of the recursion , had we presented the algorithm recursively . in each level , the processes are partitioned into groups as follows . in level @xmath374 , @xmath375 , there are @xmath376 groups of size @xmath377 .",
    "thus , in level @xmath373 , there are @xmath348 groups of size @xmath378 , in level @xmath379 there are @xmath380 groups of size @xmath381 , and so on , until level 1 , in which there is a single group of size  @xmath0 .",
    "let @xmath382 denote the size of a group at level  @xmath374 .",
    "the first group of level @xmath374 contains processes @xmath383 , the next group contains processes @xmath384 , and so on .",
    "thus each group of level @xmath385 contains two groups of level @xmath386 .",
    "note that each process @xmath51 belongs to @xmath387 groups , exactly one on each level .",
    "we let @xmath388 denote the level  @xmath374 group of process  @xmath51 .",
    "initially process 0 is active .",
    "when process  @xmath51 becomes active , it performs fault - detection in its group at every level , beginning with the highest level and working its way down , leaving level @xmath374 as soon as it finds a non - faulty process in @xmath388 .",
    "once fault - detection has been completed on @xmath389 , the set of all processes , process @xmath51 begins to perform real work .",
    "thus , we sometimes refer to the actual work as @xmath390 , or level 0 , and the fault - detection on level @xmath374 as _ work on level @xmath374_. for each @xmath375 , each time it performs a unit of work on @xmath391 , process  @xmath51 reports that work to some process in @xmath388 .",
    "( observe that the above protocol requires at least @xmath1 messages .",
    "however , it will later become clear that modifying this protocol so that when a process performs work on @xmath390 , it reports only each time it completes @xmath48 units of work , will immediately give a work optimal protocol that requires only @xmath343 messages . )    a _ unit of fault - detection _ is performed by sending a special message `` are you alive ? '' to one process , and waiting for a reply in the following round .",
    "ordinary _ message informs a process at some level @xmath374 , @xmath375 , of a unit of ( real or fault - detection ) work at level @xmath392 .",
    "as we shall see , an ordinary message also carries additional information .",
    "these two are the only types of messages sent by an active process .",
    "as before , a process that has crashed or terminated is said to be _ retired_. an inactive non - retired process only sends responses to `` are you alive ? '' messages .",
    "each process @xmath51 maintains a list @xmath360 of processes known by @xmath51 to be retired .",
    "it also maintains an array of pointers , @xmath393 , indexed by group name .",
    "intuitively , @xmath369 $ ] is the successor of the last unit of work known by @xmath51 to have been performed ( and therefore this is where @xmath51 will start doing work when it becomes active ) .",
    "for @xmath394 , @xmath395 $ ] contains the successor ( according to the cyclic order in @xmath396 , which we define precisely below ) of the last process in @xmath396 known by @xmath51 to have received an ordinary message from a process in @xmath396 that was performing ( real or fault - detection ) work on @xmath397 .",
    "we call @xmath395 $ ] _ process @xmath51 s pointer into @xmath396_. process @xmath51 s moves are governed entirely by the round number , @xmath360 , and pointers into its own groups ( i.e. , pointers into groups @xmath388 ) .",
    "associated with each pointer @xmath398 $ ] is a round number , @xmath399 $ ] , indicating the round at which the last message known to be sent was sent ( or , in the case of @xmath390 , when the last unit of work known to be done was done ) .",
    "initially , @xmath369 = 1 $ ] , @xmath395 $ ] is the lowest - numbered process in @xmath400 , and @xmath401 = \\round_i[g^j_h ] = 0 $ ] .",
    "we occasionally use @xmath399(r)$ ] to denote the value of @xmath399 $ ] at the beginning of round @xmath29 ; we similarly use @xmath402 and @xmath398(r)$ ] .",
    "the triple @xmath403 is the _ view _ of process  @xmath51 .",
    "we also define the _ reduced view _ of process  @xmath51 to be @xmath404 - 1 + |f_i|$ ] ; thus , @xmath51 s reduced view is the sum of the number of units of work known by @xmath51 to be done and the number of processes known by @xmath51 to be faulty .",
    "a process includes its view whenever it sends an ordinary message .",
    "when process @xmath51 receives an ordinary message , it updates its view in light of the new information received .",
    "note that process @xmath51 may receive information about one of its own groups from a process not in that group .",
    "similarly , it may pass to another process information about a group in which the other process is a member but to which @xmath51 does not belong .",
    "let @xmath388 be any group as described above , where the process numbers range from @xmath405 to @xmath406 .",
    "there is a natural fixed cyclic order on the group , which we call the _",
    "cyclic order_. process @xmath51 sends messages to members of @xmath388 in _ increasing order_. by this we mean according to the cyclic order but skipping itself and all processes in @xmath360 .",
    "let @xmath407 be in @xmath388",
    ". then @xmath63 s _ @xmath51-successor in @xmath388 _ , is @xmath63 s nearest successor in the cyclic ordering that is not in @xmath408 .",
    "we omit the @xmath51 in `` @xmath51-successor , '' as well as the name of the group in which the successor is to be determined , when these are clear from the context .    when process @xmath51 first becomes active it searches for other non - retired processes as follows . for each level @xmath374 , starting with @xmath387 and going down to 1 , process @xmath51 polls group @xmath388 , starting with @xmath409 $ ] , by sending an",
    "`` are you alive ? '' message .",
    "if no answer is received , it adds this process to @xmath360 .",
    "if @xmath385 , process @xmath51 sends an ordinary message reporting this newly detected failure to @xmath410 $ ] , sets @xmath410 $ ] to its @xmath51-successor in @xmath411 , and sets @xmath363 $ ] to the current round number .",
    "process @xmath51 repeats these steps until an answer is received or @xmath412 .",
    "it then enters level @xmath392 , and repeats the process . note that if no reply was received , then although the pointer into @xmath388 does not change , the successor in @xmath388 of @xmath409 $ ] does change , because the successor function takes into account @xmath360 , which has changed",
    "level 0 is handled similarly to levels 1 through @xmath379 , but the process performs real work instead of polling , and increases the work pointer after performing each unit of work . if @xmath369",
    "= n+1 $ ] then process @xmath51 halts , since in this case all the work has been completed .",
    "this completes the description of the behavior of an active process .",
    "the code for an active process appears in figure  [ figure : code for an active process ] .    at any time in the execution of the algorithm ,",
    "each inactive non - retired process @xmath51 has a _",
    "deadline_. we define @xmath413 to be the number of rounds that process @xmath51 waits from the round in which it first obtained reduced view @xmath114 until it becomes active : @xmath414 where @xmath415 . as we show below ( lemma  [ upperbound ] )",
    ", @xmath416 is an upper bound on the number of rounds that any process needs to wait before first hearing from the active process .",
    "( more formally , if @xmath63 becomes active at round @xmath29 and is still active @xmath416 rounds later , then by the beginning of round @xmath417 , all processes that are not retired will have received a message from @xmath63 . ) all our arguments below work without change if we replace @xmath416 by any other bound on the number of rounds that a process needs to wait before first hearing from the active process .",
    "this observation will be useful later , when we consider a slight modification of protocol @xmath342 .",
    "if process @xmath51 receives no message by the end of @xmath418 , then it becomes active at the beginning of round @xmath419 .",
    "otherwise , if at round @xmath29 it receives a message based on which it obtains a reduced view of @xmath114 , and if it receives no further messages by the end of round @xmath420 , it becomes active at the beginning of round @xmath421 .",
    "this completes the description of the algorithm .",
    "[ donelemma ] in every execution of protocol @xmath422 in which there are no more than @xmath13 failures , the work is completed .    by assumption ,",
    "one of the processes is correct , say @xmath51 . at some point process  @xmath51",
    "will become active , since once every other process has retired process @xmath51 will not extend its deadline .",
    "it is straightforward from inspection of the algorithm that at any time during the execution of the algorithm @xmath404 = w$ ] if and only if the first @xmath423 units of work have been performed , and that when it becomes active , process  @xmath51 performs all units of work from @xmath369 $ ] through  @xmath1 .",
    "the next lemma shows that our choice of @xmath416 has the properties mentioned above .",
    "[ upperbound ] if @xmath63 is active at round @xmath29 , and is not retired by round @xmath424 , then all processes that are not retired will receive a message from @xmath63 before the beginning of @xmath425 .",
    "it is immediate from the description of the algorithm that all nonretired processes have received a message from @xmath63 by the time it has performed @xmath0 units of work ( at level @xmath390 ) after round @xmath29 .",
    "thus , we compute an upper bound on the time it takes for @xmath63 to perform @xmath0 units of work starting at round @xmath29 . in the worst case , @xmath63 has just become active at the beginning of round @xmath29 , and must do failure detection before reaching level @xmath390 and doing work . while doing this failure detection , @xmath63 sends `` are you alive ?",
    "'' messages to at most @xmath426 processes ( the extra @xmath387 is due to the fact that at each level , it may send one `` are you alive ? ''",
    "message to a process that is alive , but crashes later while @xmath63 is doing failure detection on a larger group ) . after discovering a failure , process @xmath63 sends an ordinary message",
    "; thus , it sends at most @xmath0 ordinary messages .",
    "each message sent takes up one round ; in addition , process @xmath63 waits one round for a response after each `` are you alive ? ''",
    "this means that @xmath63 spends at most @xmath427 rounds in levels @xmath428 .",
    "clearly , @xmath63 spends @xmath429 rounds working at level @xmath390 in the course of doing @xmath0 units of work ( since it sends an ordinary message between each unit of work ) .",
    "the required bound follows .",
    "if @xmath51 received its last ordinary message from @xmath63 at round @xmath29 , we call other processes that received an ordinary message from @xmath63 after @xmath51 did _ first - generation processes _ ( implicitly , with respect to @xmath51 , @xmath63 , and @xmath29 ) . if @xmath51 did not yet receive any ordinary messages , then the first - generation processes ( with respect to @xmath51 and @xmath29 ) are those that received an ordinary message from a process with a number greater than @xmath51 .",
    "we define @xmath68th generation processes inductively .",
    "if we have defined @xmath68th generation , then the @xmath430st generation are those processes that receive an ordinary message from a @xmath68th generation process .",
    "the _ rank _ of a process is the highest generation that it is in .",
    "[ lemma : reduced view m+k ] let @xmath51 receive its last ordinary message from @xmath63 at round  @xmath29 , let @xmath114 be the reduced view of @xmath51 after receiving this message , and let @xmath431 be a @xmath68th rank process with respect to @xmath51 , @xmath63 , and @xmath29 . then",
    ", after @xmath431 receives its last ordinary message , its reduced view is at least @xmath432 .",
    "the proof is an easy induction on @xmath68 , since when a @xmath68th rank process becomes active , it knows about everything its parent knew when it became active , and at least one more piece of work or failure .",
    "we say process @xmath51 _ knows more _ than process @xmath63 at round @xmath29 if @xmath433 and for all groups @xmath434 , @xmath399(r ) \\ge \\round_j[g](r)$ ] .",
    "note that if equality holds everywhere then intuitively the two processes are equally knowledgeable .",
    "we first show that our algorithm has the property that for any two inactive non - retired processes , one of them is more knowledgeable than the other , unless they both know nothing ; that is , the knowledge of two non - retired processes is never incomparable .",
    "this is important so that the `` most knowledgeable '' process is well - defined .",
    "moreover , the knowledge can be quantified by the reduced view .",
    "process @xmath51 knows more than inactive process @xmath63 if and only if the reduced view of @xmath51 is greater than the reduced view of  @xmath63 .",
    "finally , the algorithm also ensures that the active process is at least as knowledgeable as any inactive non - retired process .",
    "[ totalorderlemma ] for every round @xmath29 of the execution the following hold :    * if process @xmath51 received an ordinary message from process  @xmath435 at round @xmath436 , and @xmath51 is inactive and has not retired by the beginning of round  @xmath29 , then at the beginning of round @xmath29 , no processes other than @xmath63 and processes in the @xmath68th generation with respect to @xmath51 , @xmath63 , and @xmath134 , for some @xmath437 , know as much as  @xmath51 . *",
    "suppose process @xmath51 received its last ordinary message at round @xmath134 ( if @xmath51 has received no ordinary messages then @xmath438 ) , and @xmath114 is @xmath51 s reduced view after receiving this message .",
    "if @xmath51 is not retired at the beginning of round @xmath439 , and it receives no further ordinary messages before the beginning of round @xmath29 , then at the beginning of round  @xmath29 no non - retired process knows more than  @xmath51 .",
    "* at the beginning of round  @xmath29 , there is an asymmetric total order ( `` knows more than '' ) on the non - zero knowledge of the non - retired processes that did not become active before round @xmath29 , and the active process knows at least as much as the most knowledgeable among these processes . moreover , for any two non - retired processes @xmath51 and @xmath63 , @xmath51 knows more than @xmath63 if and only if the reduced view of @xmath51 is greater than the reduced view of @xmath63 . * at most one process is active in round  @xmath29 .",
    "the proof is by induction on @xmath29 .",
    "the base case , @xmath440 , is straightforward .",
    "let @xmath441 , and assume that all parts of the lemma hold for smaller values of @xmath29 .",
    "we prove it for  @xmath29 .    for part ( a ) , observe that by the inductive hypothesis , ( a ) holds at the beginning of round @xmath442 . if no process is active in round @xmath442 , then no process knowledge changes , so ( a ) holds at the beginning of round @xmath29 as well .",
    "if process @xmath443 is active in round @xmath442 , then by part ( c ) of the inductive hypothesis , @xmath443 knows at least as much as @xmath51 .",
    "thus , by part ( a ) , it must be the case that @xmath443 is either @xmath63 or some process in the @xmath68th generation with respect to @xmath51 , @xmath63 , and @xmath134 , for some @xmath68 ( since , by assumption , @xmath51 is not active at the beginning of round @xmath29 ) . the only process whose knowledge changes during round @xmath442 is one to which @xmath443 sends an ordinary message .",
    "it is immediate from the definition that this process must be in the @xmath68th generation with respect to @xmath51 , @xmath63 , and @xmath29 , for some @xmath68 .    for part ( b )",
    ", we must consider two cases : @xmath444 and @xmath445 . if @xmath446 , let @xmath63 be the process that wrote to @xmath51 at @xmath134 .",
    "by part  ( a ) we have that only @xmath63 and processes in generation @xmath437 with respect to @xmath51 , @xmath63 , and @xmath134 are as knowledgeable as @xmath51 at any round in the interval @xmath447 . by part  ( c ) , these can be the only processes active in this interval .",
    "thus , it suffices to argue that @xmath63 and all processes of generation @xmath437 with respect to @xmath51 , @xmath63 , and @xmath134 are retired by the beginning of round  @xmath29 .",
    "since a reduced view is at most @xmath7 , the highest rank a process could be in is @xmath7 .",
    "we now argue that by the beginning of round @xmath448 all processes of ranks 1 through @xmath7 have retired .",
    "more generally , we argue by induction on @xmath68 that for every @xmath68 with @xmath449 , by the beginning of round @xmath450 , every process in ranks 1 to @xmath68 has retired .    if @xmath451 , note that since @xmath51 received an ordinary message from  @xmath63 at round  @xmath134 , by lemma  [ upperbound ] , every rank  1 process receives a message from  @xmath63 before round @xmath452 . by lemma  [ lemma",
    ": reduced view m+k ] , the reduced view of any such process is at least @xmath453 .",
    "since @xmath51 receives no message from @xmath63 by round @xmath452 , it must be the case that @xmath63 has retired by round @xmath452 . by definition ,",
    "no rank  1 process can receive any messages at any round in @xmath454 ( otherwise it would have a rank higher than 1 ) .",
    "thus , any rank  1 process @xmath133 became active before @xmath455 , so by definition of @xmath416 and the fact that @xmath456 , @xmath51 would have heard from @xmath133 before @xmath457 .",
    "it is easy to check that @xmath458 .",
    "since @xmath51 did not receive any messages by the beginning of round @xmath29 , @xmath133 must have retired by then .    in general , consider a rank @xmath459 process @xmath133 , and assume inductively that every rank  @xmath68 or lower process has retired by the beginning of round  @xmath29 . by definition of rank",
    ", @xmath133 received an ordinary message from a rank  @xmath68 process , and , since these are all retired by round  @xmath29 , @xmath133 must have received this message before round  @xmath29 . by the inductive hypothesis on @xmath68",
    ", @xmath133 must have received its last ordinary message by the beginning of round @xmath460 ( again using the fact that @xmath461 if @xmath462 ) . by lemma  [ lemma : reduced view m+k ] , the reduced view of @xmath133 when it received its last ordinary message before round  @xmath29 was at least @xmath463 .",
    "thus , it must have become active before round @xmath464 , if it became active at all .",
    "since @xmath51 received no messages from @xmath133 , it follows that @xmath133 must have retired before round @xmath465 .",
    "this completes the induction on  @xmath68 .    if @xmath438 we need the fact that @xmath466 , which follows easily from the definitions .",
    "we claim that , for every @xmath467 , by round @xmath468 , every process in ranks 1 to @xmath68 has retired . to see this , note that a rank  0 process @xmath443 ( one with a higher number than @xmath51 that received no messages ) must have become active at round  @xmath469 , and therefore must have retired by round @xmath470 .",
    "thus a level  1 process received its last message by @xmath471 .",
    "we now proceed as in the case @xmath446 .    to prove part  ( c ) , observe that the result is immediate from the inductive hypothesis applied to @xmath442 if there is no active process at the beginning of round @xmath442 ( for in that case , no process reduced view changes ) .",
    "otherwise , suppose that @xmath63 is active at the beginning of round @xmath442 .",
    "if @xmath63 does not send an ordinary message in round @xmath442 , again the result follows immediately from the inductive hypothesis ( since no process reduced view changes ) .",
    "if @xmath63 does send an ordinary message to , say , process @xmath51 , it is immediate that @xmath51 and @xmath63 know more at the beginning of round @xmath29 than any other non - retired process , and that @xmath51 s reduced view is greater than that of any other non - retired inactive process .    it remains to show part  ( d ) .",
    "observe that the result is immediate if no process becomes active at round @xmath29 .",
    "now suppose that process @xmath51 becomes active at the beginning of round @xmath29 .",
    "we must show that no process that was active prior to round @xmath29 is still active at the beginning of round @xmath29 , and that no process besides @xmath51 becomes active at round @xmath29 .",
    "let @xmath134 be the last round in which @xmath51 received a message ( as usual , if @xmath51 received no messages prior to round @xmath29 , then we take @xmath445 ) , and suppose that @xmath114 was @xmath51 s reduced view at round @xmath134 .",
    "then we must have @xmath472 . from part  ( b )",
    ", it follows that no non - retired process knows more than  @xmath51 at the beginning of round  @xmath29 . from part  ( c )",
    ", it follows that any process that was active in the interval @xmath447 must know more than  @xmath51 .",
    "this shows that all processes that were active before round @xmath29 must have retired by the beginning of round  @xmath29 .",
    "suppose some other process @xmath133 becomes active at round @xmath29 .",
    "we have just shown that @xmath133 does not know more than @xmath51 . from part ( c ) it follows therefore that @xmath133 knows less than @xmath51 . thus part ( b ) provides a contradiction to the assumption that @xmath133 becomes active at round @xmath29 .",
    "[ lemma : run time ] the running time of the algorithm is at most @xmath473 rounds .    if process @xmath51 s reduced",
    "view is @xmath114 and it does not receive a message within @xmath413 steps , then it becomes active .",
    "each message that @xmath51 receives increases its reduced view .",
    "thus , @xmath51 becomes active in at most @xmath474 rounds .",
    "once it becomes active , arguments similar to those used in lemma  [ upperbound ] show that it retires in at most @xmath475 rounds .",
    "thus , the running time of the algorithm is at most @xmath476 rounds .",
    "the next lemma shows that an active process @xmath51 does not send messages to retired processes that , because they were more knowledgeable than @xmath51 , should have become active before @xmath51 did .",
    "these messages are avoided because during fault detection @xmath51 discovers that these processes have retired .",
    "[ monotoniclemma ] if process @xmath133 gets an ordinary message at round @xmath134 from a process operating on group @xmath477 and process @xmath51 is active at the beginning of round @xmath478 then :    * if @xmath479(r ) \\ge r'$ ] , then all processes in the interval @xmath480(r))$ ] in the cyclic order on @xmath481 are either retired by the beginning of round @xmath29 or receive an ordinary message in the interval @xmath482(r)]$ ] from a process operating on @xmath477 .",
    "( if @xmath483(r)$ ] , then all processes in @xmath481 are either retired by the beginning of round @xmath29 or receive a message in the interval @xmath482(r)]$ ] from a process operating on @xmath477 . )",
    "moreover , either @xmath51 s knowledge at the beginning of round @xmath29 is greater than @xmath133 s knowledge at the end of @xmath134 , or @xmath484 . *",
    "if @xmath479(r ) < r'$ ] , then all processes in the interval @xmath485(r ) , i']$ ] in the cyclic order on @xmath481 are either retired by the beginning of round @xmath134 , or receive a message in the interval @xmath486(r ) , r']$ ] from a process operating on @xmath477 . moreover ,",
    "all the processes in this interval are retired by the beginning of round @xmath29 , and if @xmath487 , then all these processes will be in @xmath360 by the time @xmath51 begins to operate on @xmath391 .",
    "we proceed by induction on @xmath29 .",
    "the case @xmath440 is vacuous .",
    "assume that @xmath488 and the result holds for @xmath442 . if @xmath489 , then it must be the case that @xmath133 received its message from @xmath51 , @xmath479(r)= r-1 $ ] , and @xmath490 $ ] is the successor of @xmath133 in the cyclic order on @xmath481 , as computed by @xmath51 in round @xmath442 .",
    "it is easy to see that the result follows immediately in this case , because all processes in the interval @xmath491)$ ] must be retired .",
    "suppose @xmath492 .",
    "if @xmath51 is also active at round @xmath442 , then the result is immediate from the inductive hypothesis unless @xmath493 $ ] changes during round @xmath442 .",
    "the description of the algorithm shows that @xmath493 $ ] changes only if @xmath494 and @xmath51 is operating on group @xmath391 , in which case @xmath493 $ ] is set to @xmath442 at the end of round @xmath442 , and @xmath495(r)$ ] is the successor of @xmath495(r-1)$ ] in the cyclic order on @xmath496 . in this case",
    "it is easy to see that the result follows from the inductive hypothesis ; we leave details to the reader .",
    "thus , we have reduced to the case that @xmath51 becomes active at round @xmath29 .",
    "let @xmath479(r ) = r''$ ] and let @xmath490(r ) = i''$ ] . if @xmath497 , then it must be the case that @xmath51 received a message from @xmath63 at some earlier round @xmath74 such that @xmath498(s ) = \\point_i[g_h^{i'}](r)$ ] and @xmath499(s ) = \\round_i[g_h^{i'}](r)$ ] . since we must have @xmath500(s ) \\le s$ ] , the result now follows from the induction hypothesis ( using @xmath63 and @xmath74 instead of @xmath51 and @xmath29 ) .",
    "it remains only to consider the case @xmath501 .",
    "let @xmath502 be the process that sent the ordinary message to process @xmath133 at round @xmath134 , and suppose that @xmath443 became active at the beginning of round @xmath503 .",
    "we claim that we have the following chain of inequalities : @xmath504(s ' ) < s ' < r ' < r$ ] .",
    "every inequality in this chain is immediate from our assumptions except the first one .",
    "suppose that @xmath505(s ' ) < r''$ ] .",
    "from lemma  [ totalorderlemma ] , it follows that @xmath506(s ' ) < r''$ ] for all processes @xmath68 not retired by round @xmath503 .",
    "this means that no process not retired at @xmath503 knows that a message was sent at round @xmath229 .",
    "but at round @xmath507 , process @xmath51 knows this fact ( since , by assumption @xmath493(r ) = r''$ ] ) .",
    "this is impossible .",
    "thus , we must have @xmath505(s ' ) \\ge r''$ ] .",
    "note that @xmath508(r ' ) = i'$ ] , by assumption .",
    "thus , by the inductive hypothesis , all processes in the cyclic order on @xmath509 in the interval @xmath510 are either retired by the beginning of round @xmath503 or receive an ordinary message in the interval @xmath511(s')]$ ] from a process operating on @xmath477 . since we also know that @xmath133 receives a message at round @xmath134 from a process operating on @xmath477 , this proves the first half of part ( b ) . since , by lemma  [ totalorderlemma ]",
    ", all processes not retired by round @xmath29 must be less knowledgeable than @xmath51 at the beginning of round @xmath29 , it follows from lemma  [ totalorderlemma ] that all the processes in the interval @xmath512 $ ] in the cyclic order have in fact retired by round @xmath29 . from the description of the algorithm , it follows that @xmath51 will detect this fact before it starts operating on @xmath391 .",
    "observe that the algorithm treats ` are you alive ? '",
    "messages as real work .",
    "therefore , we refer to these messages as work unless stated otherwise . on the other hand , the ordinary messages are still referred to as messages .    using lemma  [ monotoniclemma ]",
    ", we can show that indeed effort is not wasted :    [ wastecorollary ] at most @xmath513 units of work are done and reported to @xmath388 by group @xmath388 when operating on group @xmath391 .    given @xmath51 , @xmath374 , and an execution @xmath514 of protocol @xmath342",
    ", we consider the sequence of triples @xmath515 , with one triple in the sequence for every time a process @xmath516 sends an ordinary message reporting a unit of work @xmath517 to a process @xmath518 , listed in the order that the work was performed .",
    "we must show that the length of this sequence is no greater than @xmath519 .",
    "we say that a triple @xmath515 is _ repeated _ in this sequence if there is a triple @xmath520 later in the sequence where the same work unit @xmath521 is performed .",
    "clearly there are at most @xmath522 nonrepeated triples in the sequence , so it suffices to show that there are at most @xmath523 repeated triples . to show this",
    ", it suffices to show that the third components of repeated triples ( denoting which process was informed about the unit of work ) are distinct .",
    "suppose , by way of contradiction , that there are two repeated triples @xmath524 and @xmath525 with the same third component .",
    "suppose that @xmath526 informed @xmath527 about @xmath528 in round @xmath134 , and @xmath529 informed @xmath527 about @xmath530 in round @xmath229 .",
    "without loss of generality , we can assume that @xmath531 . since @xmath524 is a repeated triple , there is a triple @xmath532 after @xmath524 in the sequence .",
    "let @xmath533 be the round in which @xmath534 became active , and let @xmath535 be the round in which @xmath529 became active .",
    "let @xmath536(r_j)$ ] , for @xmath537 . by lemma  [ monotoniclemma ] ,",
    "if @xmath538 , then either @xmath529 s knowledge at the beginning of round @xmath539 is greater than @xmath527 s knowledge at the end of @xmath134 , or @xmath540 , and if @xmath541 , then @xmath542 before @xmath529 starts operating on @xmath543 .",
    "since @xmath529 sends a message to @xmath527 while operating on @xmath543 , it can not be the case that @xmath544 before @xmath529 starts operating on @xmath543 , so it must be the case that @xmath538 and",
    "@xmath529 s knowledge at the beginning of round @xmath535 is greater than @xmath527 s knowledge at the end of round @xmath134 . in particular",
    ", this means that @xmath529 must know that @xmath526 informed @xmath527 about @xmath528 at the beginning of @xmath535 .",
    "we next show that every process @xmath545 that is active at some round @xmath29 between @xmath134 and @xmath535 must know that @xmath526 informed @xmath527 about @xmath528 at the beginning of round @xmath29 . for suppose not .",
    "then , by lemma  [ monotoniclemma ] , @xmath527 must have retired by the beginning of round @xmath29 . since , by lemma",
    "[ totalorderlemma ] , @xmath405 is the most knowledgeable process at the beginning of round @xmath29 , it follows that no process that is not retired knows that @xmath527 was informed about @xmath528 .",
    "thus , there is no way that @xmath529 could find this out by round @xmath535 .",
    "it is easy to see that @xmath534 does not know that @xmath527 was informed about @xmath528 ( for if it did , it would not repeat the unit of work @xmath528 ) . therefore , @xmath532 must come after @xmath525 in the sequence . since @xmath546(r '' )",
    "= z_1 $ ] , and @xmath527 received an ordinary message from @xmath526 while operating on @xmath391 at round @xmath134 , it follows from lemma  [ monotoniclemma ] that between rounds @xmath134 and @xmath229 , every process in @xmath388 that is not retired must receive an ordinary message . in particular",
    ", this means that @xmath534 must receive an ordinary message .",
    "since all active processes between round @xmath134 and @xmath229 know that @xmath527 was informed about @xmath528 , it follows that @xmath534 must know it too by the end of round @xmath229 .",
    "but then @xmath534 would not redo @xmath528 , giving us the desired contradiction .    in every execution of protocol @xmath342 ,    * at most @xmath547 units of real work",
    "are performed , * at most @xmath548 messags are sent , * by round @xmath549 , all processes have retired .",
    "lemma  [ wastecorollary ] implies that the amount of real work units that are performed and reported to @xmath550 is at most @xmath551 .",
    "in addition , each of the @xmath0 processes may perform one unit without reporting it ( because it retired immediately afterwards ) .",
    "summing the two , ( a ) follows .    for part ( b )",
    ", lemma  [ wastecorollary ] implies that each @xmath552 , performs at most @xmath553 reported units of works when operating on @xmath391 .",
    "( here a unit is may be either a real work unit or an ` are you alive ? ' message . )",
    "let @xmath554 .",
    "notice if we consider groups of the form @xmath388 for @xmath555 we count all the groups exactly once .",
    "the argument above tells us that the total number of reported units of work is @xmath556 the reason for the factor of 3 is that if @xmath385 , then @xmath523 occurs three times in the left - hand sum : once when considering the work performed by group @xmath388 operating on @xmath391 , once when considering the work performed by @xmath411 when operating on @xmath388 , and once when considering the work performed by @xmath557 when operating on @xmath388 . clearly , the @xmath558 reported units performed on @xmath390 result in one message each , and the remaining ones result in two messages each ( because then the unit itself is also a message ) .",
    "so the number of messages corresponding to reported units of work is at most @xmath559    in addition , the unreported units may result in messages .",
    "these consist both of ` are you alive ? ' messages sent by a process but not reported by it due to the fact it crashes or terminates immediately afterwards , and of ` are you alive ? '",
    "messages that were not reported because the recipient of the ` are you alive ? ' message responded .",
    "each process in @xmath560 can perform at most one such unreported unit when operating on @xmath391 , and hence each group @xmath560 performs no more than @xmath523 such units .",
    "in addition , we have to sum the answers of alive processes in @xmath561 to ` are you alive ? ' message sent by @xmath388 .",
    "again , there are at most @xmath523 such answers .",
    "finally , each process @xmath51 sends messages to the other process in @xmath562 just before it starts operating , which together with the answers sums up to a total of no more than @xmath102 messages .",
    "therefore , the number of messages corresponding to unreported units of work is at most @xmath563    summing the messages due to the reported units of work and the messages due to the unreported units of work , part ( b ) follows .",
    "part ( c ) is immediate from lemma  [ lemma : run time ] .",
    "we remark that we can improve the message complexity to @xmath14 ( that is , remove the @xmath1 term in ( b ) above ) by informing processes in group @xmath550 after @xmath48 units of work done at level @xmath390 , rather than after every unit of work .",
    "this does not result in a significant increase in total work , but it does increase the time complexity .",
    "the increase in time complexity comes from an increase in @xmath416 ( the upper bound on the number of rounds , from the time the currently active process takes over , that any process needs to wait before first hearing from the active process ) .",
    "formally , we have    [ improving the message complexity ] modifying protocol  by informing processes in group @xmath550 after @xmath48 units of work done at level @xmath390 , rather than after every unit of work , yields a protocol that sends @xmath564 messages , performs @xmath2 work , and terminates within @xmath565 rounds .",
    "all the algorithms we have considered so far are inherently sequential : there is only one process performing work at a time . if processes always have many ( other ) tasks that they can do , then the fact that all but one process is idle at a given time is not a great problem . on the other hand , time is certainly a critical element in many applications . in this section , we present an algorithm that aims to achieve maximum distribution of the work load among the processes .",
    "the algorithm is time - optimal in the typical case where there are no faults , and its performance degrades gracefully in the presence of faults .",
    "the basic ideas of this algorithm have been patented @xcite .",
    "the idea of the algorithm is straightforward . we alternate _ work phases _ and _ agreement phases _ , until all the correct processes are sure that all the work has been done . in the first work phase ,",
    "process  @xmath63 performs units of work @xmath566 ( we again assume for simplicity that @xmath1 is a multiple of @xmath0 ) in the first @xmath48 rounds .",
    "process @xmath63 starts the first agreement phase by broadcasting a message to all the other processes saying that it has done its work . in subsequent rounds ,",
    "process @xmath63 proceeds much as in eventual byzantine agreement @xcite : it broadcasts its current _",
    "view_what work has been done , and which processes were alive at the end of the work phase , from its point of view .",
    "it continues to do so until ( a ) the set of processes that are currently alive , according to @xmath63 s view , is the same in two consecutive rounds , or ( b ) it receives a message from some process @xmath51 saying that @xmath51 is done and containing @xmath51 s view . in case ( a )",
    ", it takes as its _ final view _ its own view , while in case ( b ) , it takes as its final view the view in @xmath51 s message . in all cases",
    ", it then broadcasts a message saying it is done , together with its final view of which processes were alive at the end of the work phase and what work remains to be done , and terminates the phase .    using the by - now standard techniques of @xcite",
    ", we can show that all the correct processes agree on their final view at the time when they terminate the phase , and a correct process is done by round @xmath567 , where @xmath20 is the number of processes that are faulty during the agreement phase . finally , all correct processes terminate at most one round after the first correct process terminates .",
    "we omit details here .    after process @xmath63",
    "terminates the first agreement phase , if , according to its final view , @xmath568 more work still needs to be done ( perhaps because some process crashed before doing its allocated work ) and @xmath569 processes are still correct , then it starts the second work phase .",
    "it performs @xmath570 units of work , with the work being divided among the correct processes according to their i d numbers",
    ". may not be divisible by @xmath571 , a process might have to do @xmath572 work .",
    "we ignore this issue in the discussion , since its impact on complexity is negligible ; however , the code takes it into account . ] after the work phase , there is an agreement phase , which is just like the first agreement phase , with one small change .",
    "whereas in the first agreement phase , if process @xmath63 did not hear from process @xmath51 during some round , then process @xmath63 knew @xmath51 was faulty , in later agreement phases , since @xmath51 may be behind @xmath63 by one step , @xmath63 must allow @xmath51 one round of grace before declaring it faulty . similarly , in order to terminate , a process must have two consecutive rounds _ after the grace round _ where , its view of the set of currently alive processes is the same , or receive a message from another process saying it is done",
    ". we leave it to the reader to check that again , at the end of the phase , all correct processes agree that all the work has been performed , or they agree on their final view , and that every correct process terminates no more than one round after the first correct process terminates .",
    "we continue in this manner , provided no more than half of the processes that were correct at the beginning of a phase fail , until all correct processes are sure that all work has been done .",
    "if at any phase more than half the correct processes fail , we revert to another of our algorithms ( for example , protocol @xmath95 ) .",
    "we call this algorithm protocol ; the code appears in figure  [ protocol d code ] . in the code",
    ", we use the function @xmath573 , where @xmath574 is a set of nonnegative integers ; @xmath575 if there are @xmath68 elements of @xmath574 less than @xmath74 .",
    "xx = xxxx = xxxx = xxxx = xxxx = xxxx = xxxx    main protocol +   + 1 .",
    "@xmath576;\\{@xmath574 is the set of outstanding units of work } + 2 .",
    "@xmath577;\\{@xmath578 is the set of processes known to have been correct + at the end of the previous work phase } + 3 .",
    "@xmath579;\\{@xmath580 keeps track of whether to allow a grace round } + 4 .",
    "@xmath581 * do * + 5 .",
    "@xmath582 ; + 6 .",
    "perform work in @xmath583 ; + 7 .",
    "wait @xmath584 rounds ; \\{to make sure all processes spend equally long in this phase } + 8 .",
    "@xmath585 ; \\{update outstanding units of work } + 9 .",
    "@xmath586 ; + 10 .",
    "agree@xmath587 ; \\{see code below } + 11 .",
    "@xmath588 ( _ i.e. _ more than half the processes alive at the end of the previous + work phase failed by the end of the current work phase ) + 12 . perform work in @xmath574 using protocol @xmath95 ; + 13 .",
    "@xmath589 ; + 14 .",
    "@xmath590 +   + agree@xmath587 +   + 1 .",
    "@xmath591 ; + 2 .",
    "@xmath592 ; \\{@xmath593 keeps track of processes not known by @xmath63 to be faulty } + 3 . @xmath594 ; + 4 .",
    "@xmath595 * do * + 5 .",
    "@xmath596 ; \\{save old value of @xmath593 } + 6 .",
    "broadcast @xmath597 to all processes in @xmath593 ; + 7 .",
    "@xmath598 * do * + 8 .",
    "received @xmath599 _ and _ @xmath600 + 9 .",
    "@xmath601 ; + 10 .",
    "@xmath602 ; + 11 . received @xmath603 _ and _ @xmath604 + 12 .",
    "@xmath605 ; + 13 .",
    "@xmath606 ; + 14 . @xmath607 ; + 15 .",
    "no message received from @xmath51 _ and _ @xmath608 + 16 .",
    "@xmath609 ; + 17 .",
    "@xmath610 and @xmath608 + 18 .",
    "@xmath607 ; + 19 .",
    "@xmath611 ; + 20 .",
    "broadcast @xmath612 to all processes in @xmath593    we now analyze protocol @xmath613 .",
    "the analysis splits into two cases , depending on whether it is the case that for every phase , no more than half the processes that are correct at the beginning of the phase are discovered to have failed during the phase .",
    "a process @xmath614 is _ thought to be correct _ at the beginning of phase @xmath51 if @xmath615 or @xmath616 and @xmath614 is in the final view of some process @xmath617 that decided in the phase  @xmath53 agreement protocol .",
    "note that in the latter case @xmath614 is in the final view of all processes that complete the phase  @xmath53 agreement protocol .",
    "[ protocol d ] in every execution of protocol  in which at most @xmath20 processes fail ,    1 .   if for each phase , no more than half the processes that are thought to be correct at the beginning of the phase are discovered to have failed by the end of that phase , then * at most @xmath618 units of work are performed , * at most @xmath619 messages",
    "are sent , * by round @xmath620 , all processes have retired .",
    "if in some phase more than half the processes that are thought to be correct at the beginning of some phase are discovered to have failed by the end of the phase , then * at most @xmath621 units of work are performed , * at most @xmath622 messages are sent , * by round @xmath623 , all processes have retired .    for part ( 1 ) , an easy induction on @xmath68 shows that by the end of phase @xmath68 , no more than @xmath624 units of work remain to be done , and no more than @xmath625 units of work have been done .",
    "it follows that at most @xmath618 units of work are done altogether .",
    "( we remark that there is nothing special about the factor `` half '' in our requirement that we revert to protocol @xmath95 if more than half the processes that were correct at the beginning of the phase are discovered to have failed during the phase .",
    "we could have chosen any factor @xmath626 ; a similar proof would show that by the end of phase @xmath68 , at most @xmath627 units of work remain to be done , and no more than @xmath628 units of work have been done , so that no more than @xmath629 units of work are done altogether .",
    "however , it follows from results of @xcite that if we allow an arbitrary fraction of the processes to fail at every step , and do not revert to protocol @xmath95 , it is possible to construct an execution where @xmath20 processes fail and @xmath630 units of work are done altogether .",
    "indeed , it follows from the arguments in @xcite that this result is tight ; there is a matching upper bound . ) since each nonfaulty process broadcasts to all the other nonfaulty processes in each round of an agreement phase , at most @xmath631 messages are sent in each such round .",
    "if @xmath632 is the number of failures discovered during the @xmath68th agreement phase , then the first agreement phase lasts at most @xmath633 rounds , while for @xmath634 , the @xmath68th agreement phase lasts at most @xmath635 rounds , because of the grace round .",
    "thus , altogether , the agreement phases last at most @xmath636 rounds , where @xmath637 is the number of agreement phases . since @xmath638 , the agreement phases last at most @xmath639 rounds , and at most @xmath619 messages are sent .",
    "finally , to compute an upper bound on the total number of rounds , it remains only to compute how many rounds are required to do the work ( since we know the agreement phases last altogether at most @xmath639 rounds ) .",
    "recall that at the end of phase @xmath68 , at most @xmath624 units of work need to be done . since no more than half the processes fail during any phase , at least @xmath640 processes are nonfaulty .",
    "thus , at most @xmath641 rounds are spent during each work phase doing work .",
    "since there are at most @xmath642 work phases , this gives the required bound on the total number of rounds .",
    "for part ( 2 ) , first observe that if we revert to protocol @xmath95 at the end of phase @xmath68 , then by our earlier observations it is known to the remaining processes that no more than @xmath643 units of work remain to be done , and no more than @xmath644 units of work have been done .",
    "it is also easy to see that at least @xmath348 processes are discovered as faulty .",
    "moreover , by the bounds in part ( 1 ) , at most @xmath619 messages have been sent and @xmath645 rounds have elapsed . now applying theorem  [ protocolatheorem ] , we see that at most @xmath646 work is performed by protocol  @xmath95 , no more than @xmath647 messages are sent , and @xmath648 rounds are required . by taking @xmath649 ( the worst case ) , we get the bounds claimed in the statement of the theorem .    while the worst - case message complexity of this algorithm is significantly worse than that of our other algorithms , the time complexity is better ( at least , if less than half the correct processes fail in each phase ) .",
    "more importantly , the situation is particularly good if no process fails or one process fails .",
    "if no process fails , then @xmath1 units of work are done , the algorithm takes @xmath17 rounds , and @xmath18 messages are sent .",
    "if one process fails , then we leave it to the reader to check that the algorithm requires at most @xmath650 rounds , has message complexity at most @xmath651 , and at most @xmath652 units of work are done .",
    "as we mentioned in the introduction , it is easy to modify this algorithm to deal with a somewhat more realistic setting , where work is continually coming in to the system . essentially , the idea is to run eventual byzantine agreement periodically ( where the length of the period depends on the size of the work load , and other features of the system ) .",
    "we omit further details here .",
    "we can also cut down the message complexity in the case of no failures to @xmath653 , rather than @xmath18 , while still keeping the same work and time complexity . instead of messages being broadcast during the agreement phase",
    ", they are all sent to a central coordinator , who broadcasts the results .",
    "if there are no failures , the agreement phase lasts 2 rounds , just as before . dealing with failures is somewhat subtle if we do this though , so we do not analyze this approach carefully here .",
    "one application of our algorithms is to byzantine agreement .",
    "a byzantine agreement protocol provides a means for @xmath1 processes , at most @xmath0 of which may be faulty , to agree on a value broadcast by a distinguished process called the _ general _",
    ", in such a way that all nonfaulty processes decide on the same value and , when the general is nonfaulty , they decide on the value the general sent . as in the rest of the paper , we restrict ourselves here to crash failures .",
    "consider the following byzantine agreement algorithm .",
    "the algorithm proceeds in two stages : first , the general broadcasts its value to processes @xmath372 to @xmath0 ; and then , these @xmath654 processes employ one of our sequential algorithms to perform the `` work '' of informing processes @xmath372 to @xmath27 about the general s value .",
    "so , performing one unit of work here means sending a message of the form `` the general s value is @xmath405 . '' to distinguish processes @xmath655 from the others , we refer to them as the _ senders_. a few more details are necessary to complete the description of the algorithm .",
    "first , throughout the algorithm , each process has a value for the general .",
    "initially , the value is 0 .",
    "if a process receives a message informing it about a value for the general different from its current value , it adopts the new value .",
    "second , if the chosen work protocol is @xmath422 , then we modify it slightly so that each of its messages contains , in addition to its usual original contents , the current value the sender has for the general .",
    "finally , at a predetermined time by which the underlying work protocol is guaranteed to have terminated , each process decides on its current value for the general .",
    "observe that processes @xmath656 play two roles in the second stage of the byzantine agreement algorithm : they both report the value of the general ( as they do work ) and are informed of this value ( as work is performed on them by other senders ) .",
    "we now prove the correctness of our byzantine agreement algorithm .",
    "obviously , if the general is correct , all processes will decide on its value .",
    "since at least one of the @xmath654 senders is nonfaulty , it must be the case that a value is reported by a sender to every nonfaulty process . to show agreement , it suffices to show that there is no time at which two nonfaulty processes that have had a value reported to them by a sender have different ( current ) values .",
    "this , in turn , follows from the fact that if an active sender @xmath614 reports a value @xmath657 , and the sender that was active just before @xmath614 reported @xmath658 , then at the time @xmath614 becomes active , no value was reported to any nonfaulty process .",
    "assume otherwise .",
    "let @xmath614 be the first active sender that violates this claim .",
    "then @xmath614 reports @xmath657 for the general and the previous sender reported @xmath658 .",
    "let @xmath659 be the first sender that was active before @xmath614 and reported @xmath658 ; by construction , all senders that were active after @xmath659 but before @xmath614 reported @xmath658 .    by assumption ,",
    "when @xmath659 becomes active , no value was reported to any process that has not yet crashed .",
    "the choice of @xmath659 guarantees that the only value that is reported from the time that @xmath659 becomes active to the time that @xmath614 becomes active is @xmath658 .",
    "it can not be the case that a value was reported to @xmath614 during this time , for then @xmath614 s value when it becomes active would be @xmath658 , not @xmath657 . in the case of protocols",
    "@xmath95 and @xmath21 , since work is done in increasing order of process number , it follows that no value is reported to any process with a higher number than @xmath614 .",
    "( we remark that it is important here that a value is _ not _ included as part of the checkpoint messages in protocols @xmath95 and @xmath21 .",
    "since checkpoint messages are broadcast , if a value were included , it is possible that a process that was active before @xmath614 crashed while checkpointing to @xmath614 ; in this case , @xmath614 may not have heard the value @xmath658 , and some process with a higher number than @xmath614 may have heard it . )",
    "moreover , the proof of correctness of protocols @xmath95 and @xmath21 shows that all processes with a lower number than @xmath614 must have crashed before @xmath614 became active .",
    "thus , it follows that no value was reported to any nonfaulty process at the time @xmath614 became active . in the case of protocol @xmath422 ,",
    "when @xmath614 becomes active it is the most knowledgeable nonretired ( and hence nonfaulty ) process . since for protocol",
    "@xmath422 we assume that the checkpointing messages include the value that was sent , no value can have been sent to any process that has not crashed .    using protocol @xmath422 , we get a byzantine agreement protocol for crash failures that uses @xmath660 messages in the worst case , thus improving over bracha s bound of @xmath661 @xcite . using @xmath95 or @xmath21",
    ", we match bracha s message complexity , but our protocols are constructive , whereas bracha s is not .",
    "in this paper we have formulated the problem of performing work efficiently in the presence of faults .",
    "we presented three work - optimal protocols to solve the problem .",
    "one sends @xmath3 messages and takes @xmath2 time , another requires @xmath4 messages at the cost of significantly greater running time , and the third optimizes on time in the usual case ( where there are few failures ) .",
    "in particular , in the failure - free case , it takes @xmath662 rounds and requires @xmath18 messages .",
    "there are numerous open problems that remain .",
    "for example , it would be interesting to see if message complexity and running time could be simultaneously optimized .",
    "it would also be interesting to prove a nontrivial lower bound on the message complexity of work - optimal protocols .",
    "finally , note that by trying to optimize effort , the sum of work done and messages sent , we implicitly assumed that one unit of work was equal to one message .",
    "in practice , we may want to weight messages and work differently .",
    "as long as the `` weight '' of a message is linearly related to the weight of a unit of work , then , of course , the complexity bounds for our algorithms continue to hold . however , if we weight things a little differently , then a completely different set of algorithms might turn out to be optimal . in general",
    ", it would be interesting to explore message / work / time tradeoffs in this model .",
    "the authors are grateful to vaughan pratt for many helpful conversations , in particular for his help with the proof of protocol @xmath95 . we also thank david greenberg , maurice herlihy , and serge plotkin for their suggestions for improving the presentation of this work .      , _",
    "algorithms for the certified write - all problem _ , siam journal of computing ( to appear ) .",
    "a preliminary version , containing other results , appears in proc .",
    "23rd acm symposium on theory of computing , 1991 , pp .",
    "370 - 380 ( with the title `` wait - free parallel algorithms for the union - find problem '' ) .    , _ sharing memory robustly in message - passing systems _ , journal of the acm ( to appear ) .",
    "a preliminary version appears in proc .",
    "9th acm symposium on principles of distributed computing , 1990 , pp .",
    "363 - 375 .    , _ a partial equivalence between shared - memory and message - passing in an asynchronous fail - stop distributed environment _ , mathematical systems theory , 26 ( 1993 ) , pp . 2139 .",
    ", unpublished manuscript , department of computer science , cornell university , july  1984 .      , _ parallel algorithms with processor failures and delays _ , journal of algorithms , vol .",
    "45 - 86 , january , 1996 . , _ unreliable failure detectors for reliable distributed systems _ , journal of the acm ( to appear )",
    ". a preliminary version appears in proc .",
    "10th acm symposium on distributed computing , 1991 , pp .",
    "325340 .                    ,",
    "_ work optimal asynchronous algorithms for shared memory parallel computers _",
    ", siam journal on computing , 21 ( 1992 ) , pp .",
    "1070 - 1099 .",
    ", _ the worm programs  early experience with a distributed computation _ , communications of the acm , 25 ( 1982 ) , pp",
    ".  95103 ."
  ],
  "abstract_text": [
    "<S> we consider a system of @xmath0 synchronous processes that communicate only by sending messages to one another , and that together must perform @xmath1 independent units of work . </S>",
    "<S> processes may fail by crashing ; we want to guarantee that in every execution of the protocol in which at least one process survives , all @xmath1 units of work will be performed . </S>",
    "<S> we consider three parameters : the number of messages sent , the total number of units of work performed ( including multiplicities ) , and time . </S>",
    "<S> we present three protocols for solving the problem . </S>",
    "<S> all three are work - optimal , doing @xmath2 work . </S>",
    "<S> the first has moderate costs in the remaining two parameters , sending @xmath3 messages , and taking @xmath2 time . </S>",
    "<S> this protocol can be easily modified to run in any completely asynchronous system equipped with a failure detection mechanism . </S>",
    "<S> the second sends only @xmath4 messages , but its running time is large ( @xmath5 ) . </S>",
    "<S> the third is essentially time - optimal in the ( usual ) case in which there are no failures , and its time complexity degrades gracefully as the number of failures increases .    </S>",
    "<S> [ section ]    # 1    fault - tolerance , work , byzantine agreement , load balancing , distributed systems </S>"
  ]
}