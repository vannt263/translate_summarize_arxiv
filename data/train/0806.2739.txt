{
  "article_text": [
    "if the dimensions of a device become smaller than the phase coherence length @xmath0 of charge carriers , classical transport theories are not valid any more . instead , carrier dynamics is now governed by quantum mechanics , and the wave - like nature of particles becomes important .",
    "in general , the conductance / resistance of such a device does not follow ohm s law .    in the regime of coherent quantum transport",
    ", the landauer - bttiker formalism  @xcite relates the conductance @xmath1 of a device to the total transmission probability @xmath2 of charge carriers through the device , @xmath3 where @xmath4 is the transmission amplitude between different states with transverse quantum numbers @xmath5 and @xmath6 in the left and right lead , respectively . a state with a given transverse quantum number @xmath5",
    "is also called _ channel _ @xmath5 .",
    "the problem of calculating the conductance is thus reduced to calculating scattering eigenfunctions @xmath7 for a given energy @xmath8 : @xmath9 where @xmath10 is the hamiltonian of the system .",
    "alternatively , the transmission probability can be extracted from the retarded green s function @xmath11 that obeys the equation of motion @xmath12 the fisher - lee relation @xcite then allows to calculate the transmission ( @xmath4 ) and reflection ( @xmath13 ) amplitudes from @xmath14 . in its simplest form ,",
    "the fisher - lee relation reads @xmath15 and @xmath16 where @xmath17 is the velocity of channel @xmath5 and the integration runs over the cross - section @xmath18 ( @xmath19 ) of the left ( right ) lead .",
    "the landauer - bttiker formalism can also deal with multi - terminal systems , but is restricted to linear response , i.e.  small bias voltages . in the general case including external bias , the conductance can be calculated using the non - equilibrium green s function formalism ( see , e.g.  @xcite ) .    except for particularly simple examples , solving eqs .",
    "( [ eq : scattering_eigenstate ] ) and ( [ eq : retarded_greenfunction ] ) exactly is not possible , and therefore a numerical computation is often the method of choice .",
    "instead of solving directly a differential equation with its continuous degrees of freedom , such as the schrdinger equation , numerical computations are usually only attempted within a discrete basis set .",
    "the differential equation is then replaced by a set of linear equations , and the hamiltonian @xmath10 can be written as a matrix . very often , only few of the matrix elements @xmath20 are nonzero .",
    "such _ tight - binding _ representations of the hamiltonian are ubiquitous in quantum transport calculations and can arise from finite differences  @xcite , from the finite element method  @xcite , from atomic orbitals in empirical tight - binding  @xcite or kohn - sham orbitals within density functional theory  @xcite .",
    "when describing transport , the systems under consideration are open and thus extend to infinity . as a consequence ,",
    "the tight - binding matrix @xmath10 is infinite - dimensional .",
    "however , the conductance calculation can be reduced to a finite problem by partitioning the system into a finite scattering region attached to leads that extend to infinity , as schematically depicted in fig .",
    "[ fig : grids](a ) . for the case of two - terminals ,",
    "the matrix @xmath10 can be written as @xmath21 where @xmath22 is the ( infinite ) hamiltonian of the left ( right ) lead , @xmath23 is the hamiltonian of the scattering region and of finite size . the matrices @xmath24 and @xmath25 represent the coupling between the scattering region and the left and right lead , respectively .    in order to reduce the problem size , it is useful to introduce the retarded self - energy @xmath26 , where @xmath27 is the surface green s function of the left ( right ) lead , i.e.  the value of the green s function at the interface of the lead disconnected from the scattering region",
    ". then , the green s function @xmath28 of the scattering region can be calculated as @xcite @xmath29 reminiscent of eq .",
    "( [ eq : retarded_greenfunction ] ) but with an effective hamiltonian @xmath30 of finite size .",
    "this treatment is easily extended to multi - terminal systems .",
    "note that it suffices to know the surface green s function of the ( semi-)infinite leads , as in a tight - binding hamiltonian the matrices @xmath31 and @xmath32 have only few nonzero entries . for simple systems , the surface green s function can be calculated analytically @xcite , whereas in more complex situations it must be computed numerically , either by iteration @xcite , or by semi - analytical formulas @xcite .",
    "the original infinite - dimensional problem has thus been reduced to a finite size matrix problem that can , in principle , be solved straight - forwardly on a computer . however , for any but rather small problems , the computational task of the direct inversion in eq .",
    "( [ directinversion ] ) is prohibitive .",
    "therefore , for two - terminal transport , many algorithms make use of the _ sparsity _ of the hamiltonian matrix in tight - binding representation - in particular that this matrix can be written in block - tridiagonal form : @xmath33 where the index @xmath34 ( @xmath35 ) denotes the blocks in the left ( right ) lead , @xmath36 the blocks within the scattering region , and @xmath37 ( @xmath38 ) the first block in the left ( right ) lead . such a form arises , for example , naturally in the method of finite differences , when grid points are grouped into vertical slices according to their @xmath39-coordinates , as shown in fig .",
    "[ fig : grids](b ) , but also applies to any other sparse tight - binding hamiltonian .",
    "the block - tridiagonal form of the hamiltonian is the foundation of several quantum transport algorithms for two - terminal systems .",
    "the transfer matrix approach applies naturally to block - tridiagonal hamiltonians , but becomes unstable for larger systems .",
    "however , a stabilized version has been developed by usuki _",
    "et al . _",
    "@xcite . in the decimation technique",
    "@xcite , the hamiltonian of the scattering region is replaced by an effective hamiltonian between the two leads by eliminating internal degrees of freedom .",
    "the contact block reduction method  @xcite calculates the full green s function of the system using a limited set of eigenstates .",
    "the recursive green s function ( rgf ) technique  @xcite uses dyson s equation to build up the system s green s function block by block .",
    "it has also been adapted to hall geometries with four terminals  @xcite and to calculate non - equilibrium densities  @xcite .",
    "furthermore , the rgf algorithm has been formulated to be suitable for parallel computing  @xcite .     contains all blocks @xmath40 .",
    "( b ) the green s function @xmath41 is obtained by adding another matrix block . ]",
    "of course , there are also other transport techniques not directly based on the block - tridiagonal form of the hamiltonian matrix , such as extracting the green s function from wave packet dynamics @xcite .",
    "still , such algorithms are not as widely used as the large class of algorithms , that are directly based on the block - tridiagonal form of the hamiltonian . in order to illustrate the typical computational tasks of this class of algorithms , we briefly explain , as a representative example , the rgf algorithm .",
    "the rgf technique is based on dyson s equation @xmath42 ( see , e.g  @xcite ) , where @xmath14 denotes the green s function of the perturbed system , @xmath43 that of the unperturbed system and @xmath44 the perturbation . using this equation , the system is built up block by block , as depicted in fig .",
    "[ fig : rgf ] .",
    "let @xmath45 denote the green s function for the system containing all blocks @xmath40 .",
    "then , at energy @xmath8 , the green s function @xmath41 is related to @xmath45 by @xmath46 and @xmath47 starting from @xmath48 , the surface green s function of the right lead , @xmath49 slices are added recursively , until @xmath50 has been calculated .",
    "the blocks of the green s function of the full system necessary for transport are then given by @xmath51 and @xmath52 where @xmath53 is the surface green s function of the left lead .",
    "@xmath54 and @xmath55 are sufficient to calculate transmission and reflection probabilities via the fisher - lee relation , eqs .   and .",
    "each step of the algorithm performs inversions and matrix multiplications with matrices of size @xmath56 . since the computational complexity of matrix inversion and multiplications scales as @xmath57 , the complexity of the rgf algorithm is @xmath58 .",
    "thus , it scales linearly with the `` length '' n , and cubically with the `` width '' @xmath56 of the system .",
    "this scaling also applies to most of the other transport algorithms mentioned above .    while for particular cases",
    "general transport algorithms , such as the rgf algorithm , can not compete with more specialized algorithms , such as the modular recursive green s function technique  @xcite that is optimized for special geometries , they are very versatile and easily adapted to two - terminal geometries  provided that the leads are arranged collinearly . amongst other things , this restriction will be lifted by the approach presented in this work .",
    "although the block - tridiagonal structure of @xmath10 , eq .  ( [ eq : blocktridiagonal ] ) , that arises naturally in many problems appears to have a small `` width '' and thus seems to be quite suitable for transport algorithms , optimizing the block - tridiagonal structure by reordering the matrix @xmath10 may lead to a significant speed - up in the conventional two - terminal algorithms , as we show below .",
    "furthermore , such a reordering allows for the application of the established two - terminal algorithms to more complex geometries , such as non - collinear leads or multi - terminal structures , that would otherwise need the development of specialized algorithms .",
    "below , we develop a matrix reordering algorithm based on graph partitioning techniques that brings an arbitrary matrix @xmath10 into a block - tridiagonal form optimized for transport calculations . to this end",
    ", the paper is organized as follows . in section  [ section : algorithm ] we formulate the matrix reordering problem in the language of graph theory and develop the reordering algorithm . in section [ section : examples ] we apply this algorithm to various examples and investigate its performance and the performance of the rgf algorithm for the reordered hamiltonian @xmath10 .",
    "we conclude in section  [ section : conclusions ] .",
    "as shown in the introduction , the typical runtime of transport algorithms , is proportional to @xmath59 , does depend on the particular block - tridiagonal structure of @xmath10 .",
    "therefore , the runtime of these algorithms can be improved in principle by conveniently reordering @xmath10 with a permutation @xmath60 , @xmath61    in order to quantify how a typical transport algorithm performs for a given matrix structure , we define a weight @xmath62 associated with a matrix @xmath10 as @xmath63 where @xmath56 is the size of block @xmath64 .",
    "optimizing the matrix for transport algorithms is then equivalent to minimizing the weight @xmath62 . since @xmath65 , where @xmath66 is the total number of grid points , @xmath62 is minimal , if all @xmath56 are equal , @xmath67",
    "therefore , a matrix tends to have small weight , if the number @xmath49 of blocks is large , and all blocks are equally sized .",
    "the reordering problem of the matrix @xmath10 is thus summarized as follows :    [ matrix_reordering_problem ] * matrix reordering problem : * find a reordered matrix @xmath68 such , that    1 .",
    "@xmath69 and @xmath70 are blocks given by the left and right leads ( as required by transport algorithms ) 2 .",
    "@xmath68 is block - tridiagonal ( @xmath71 , iff @xmath72 ) , 3 .",
    "the number @xmath49 of blocks is as large as possible , and all blocks are equally sized .    in principle , this constrained optimization problem could be solved by generic optimization algorithms , such as _ simulated annealing_. however , for larger problems the optimization could take much more time than the actual transport calculation , rendering the optimization process useless .",
    "it is therefore necessary to use heuristics especially designed for the problem at hand . to this end",
    ", we formulate the matrix reordering problem in the language of graph theory .",
    "a _ graph _ @xmath73 is an ordered pair @xmath74 , where @xmath75 is a set of _ vertices _ @xmath76 and @xmath77 a set of ordered pairs of vertices @xmath78 .",
    "such a pair is called an _ edge_. a graph is called _ undirected _ , if for every edge @xmath79 also @xmath80 .",
    "two vertices @xmath81 and @xmath82 are called _ adjacent _ , if @xmath79 . in order to simplify the notation",
    ", we will also consider a vertex @xmath76 to be adjacent to itself .",
    "there is a natural one - to - one correspondence between graphs and the structure of sparse matrices . for a given @xmath83 matrix @xmath10",
    ", we define a graph @xmath84 with @xmath85 and @xmath86 iff the entry @xmath87 . a graph thus stores information about the _ structure _ of a matrix ,",
    "i.e.  which entries are nonzero .",
    "it does not contain any information about the values of the respective entries , although these may be stored easily along with the graph .",
    "however , for the formulation of the quantum transport algorithms , only the block - tridiagonal form , i.e.  the structure of the matrix , is relevant .",
    "hermitian matrices , that are considered in quantum transport , have a symmetric structure of zero and nonzero entries , and therefore the corresponding graphs are undirected",
    ".        a graph can be depicted by drawing dots for each vertex @xmath76 , and lines connecting these dots for every edge @xmath88 , as shown in fig .",
    "[ fig : graphs](a ) .",
    "it should be noted that a graphical representation of a tight - binding grid , such as shown in fig .",
    "[ fig : graphs](b ) , can be directly interpreted as a representation of a graph and the corresponding matrix structure .    in terms of graph theory",
    ", matrix reordering corresponds to renumbering the vertices of a graph .",
    "since we are only interested in reordering the matrix in terms of matrix blocks ( the order within a block should not matter too much ) , we define a _ partitioning _ of @xmath73 as a set @xmath89 of disjoint subsets @xmath90 such that @xmath91 and @xmath92 for @xmath93 . using these concepts",
    ", we can now reformulate the original matrix reordering problem into a graph partitioning problem :    [ graph_part_problem ] * graph partitioning problem : * find a partitioning @xmath94 of @xmath73 such that :    1 .",
    "[ req1 ] @xmath95 and @xmath96 contain the vertices belonging to left and right leads , 2 .",
    "[ req2 ] 1 .",
    "vertices in @xmath95 and @xmath96 are only connected to vertices in @xmath97 and @xmath98 , respectively , 2 .   for @xmath99 , there are edges between @xmath100 and @xmath101 iff @xmath72 , 3 .",
    "[ req3 ] the number @xmath102 of sets @xmath100 is as large as possible , and all sets @xmath100 have the same cardinality @xmath103 . a partitioning with all @xmath103 equally sized",
    "is called _",
    "balanced_.    a partitioning obeying requirement [ graph_part_problem].[req2 ] is called a _ level set _ with _ levels _ @xmath100  @xcite .",
    "level sets appear commonly as an intermediate step in algorithms for bandwidth reduction of matrices  @xcite .",
    "these algorithms seek to find a level set of minimal width , i.  e. @xmath104 as small as possible which is equivalent to requirement [ graph_part_problem].[req3 ] .",
    "the main difference between our graph partitioning problem and the bandwidth reduction problem is requirement [ graph_part_problem].[req1 ] : in the graph partitioning problem , @xmath95 and @xmath98 are determined by the problem at hand , while in the bandwidth reduction problem these can be chosen freely .",
    "due to this difference , bandwidth reduction algorithms can be applied successfully to our graph partitioning problem only for special cases , as we show below .",
    "the term _ graph partitioning _ usually refers to the general problem of finding a balanced partitioning @xmath89 of a graph and has many applications in various fields such as very - large - scale integration ( vlsi ) design @xcite , sparse matrix reorderings for lu or cholesky decompositions @xcite , or block ordering of sparse matrices for parallel computation @xcite .",
    "in particular , the latter examples also include block - tridiagonal orderings @xcite .",
    "however , as these reorderings are geared towards parallel computation , they obtain a fixed number @xmath49 of sets @xmath100 given by the number of processors of a parallel computer , whereas in our block - tridiagonal reordering the number @xmath49 should be as large as possible .",
    "in addition to that , the constraints on the blocks @xmath95 and @xmath96 ( requirement [ graph_part_problem].[req1 ] ) are again not present there .    as we can not directly employ existing techniques to solve the graph partitioning problem , we will develop an algorithm combining ideas from both bandwidth reduction and graph partitioning techniques in the subsequent sections : concepts from bandwidth reduction are employed to construct a level set which is then balanced using concepts from graph partitioning .",
    "a breadth - first - search ( bfs ) @xcite on a graph immediately yields a level set @xcite . in our particular example , the level set is constructed as follows :    [ bfsalgo ] level set construction by breadth - first - search .    1 .",
    "start from @xmath105 .",
    "then , @xmath106 , as the first level is given by the constraints of requirement ( [ req1 ] ) .",
    "2 .   if there is a vertex in @xmath100 that is adjacent to a vertex in @xmath96 , assign all the remaining unassigned vertices into @xmath100 and end the algorithm .",
    "all vertices adjacent to @xmath100 that are not contained in the previous levels @xmath107 are assigned to @xmath108 .",
    "4 .   continue at step b with @xmath109 .",
    "note that the sets @xmath89 form a level set by construction  a set @xmath100 may only have vertices adjacent to @xmath110 and @xmath108 .",
    "the construction by bfs not only obtains the number of levels @xmath102 for a particular realization , but yields a more general information :    the number of levels @xmath102 in the level set constructed by algorithm [ bfsalgo ] is the maximum number of levels compatible with the constraints on the initial and final level @xmath95 and @xmath96 for a graph @xmath73 .",
    "this can be seen from the fact that a bfs finds the shortest path in the graph between the initial sets @xmath95 and @xmath96 , @xmath111 where @xmath112 and @xmath113 .",
    "any vertex on this shortest path can be uniquely assigned to a single level @xmath100 and it would not be compatible with a larger number of levels than @xmath102 .",
    "algorithm [ bfsalgo ] not only yields the maximum number of levels : all vertices contained in the first @xmath5 levels of the bfs must be contained in the first @xmath5 levels of _ any _ other level set .",
    "[ lemma_minimal_set ] let @xmath114 be a level set constructed by algorithm [ bfsalgo ] , and @xmath115 another level set consistent with the requirements of problem [ graph_part_problem ] with @xmath116 .",
    "then @xmath117 for @xmath118 .",
    "the statement is proved by induction .",
    "it is true trivially for @xmath119 ( because of requirement [ req1 ] in problem [ graph_part_problem ] ) and for @xmath120 ( then the levels cover the whole graph ) .",
    "suppose now that the statement holds for @xmath121 .",
    "note that for the proof it suffices to show that @xmath122 .",
    "consider now the set of all vertices adjacent to @xmath123 , @xmath124 . by construction , @xmath125 .",
    "since @xmath126 and @xmath127 is a level set , all vertices adjacent to @xmath123 must be contained in the set of vertices including the next level , i.e.  @xmath128 .",
    "but then also @xmath122 , which concludes the proof .    .",
    "different levels are shown in alternating shades of grey . ]",
    "thus , the vertices contained in the first @xmath5 levels of the bfs form a minimal set of vertices needed to construct @xmath5 levels .",
    "however , this also implies that the last level which then covers the remaining vertices of the graph , may contain many more vertices than the average , leading to an unbalanced level set .",
    "this is not surprising , since the algorithm does not explicitly consider balancing and only local information is used , i.e.  whether a vertex is adjacent to a level or not .",
    "an example for this imbalance is shown in fig .",
    "[ example_bfs ] , the bfs construction yields a very large last level .    note that throughout the manuscript we visualize the graph theoretical concepts using examples of graphs obtained from discretizing a two - dimensional structure .",
    "however , the ideas and algorithms presented here apply to any graph and are not limited to graphs with coordinate information .",
    "two - dimensional graphs have the advantage of being visualized easily .",
    "in particular , the bfs search has an intuitive physical analog : wave front propagation of elementary waves emanating from the vertices of the initial level @xmath95 .",
    "the problem that a bfs does not yield a balanced partitioning was also noted in the theory of bandwidth reduction .",
    "the gibbs - poole - stockmeyer ( gps ) algorithm tries to overcome this deficiency by constructing a level set through the combination of two bfs searches starting from the initial and the final levels .",
    "however there the initial and final levels are sought to be furthest apart , contrary to our problem . in general",
    ", the gps construction only yields a balanced level set if the initial and final level are close to furthest apart , as we will show in sec .",
    "[ section : examples ] .      in order to obtain a balanced partitioning , graph partitioning",
    "algorithms commonly perform a recursive bisection , i.e.  successively bisect the graph and the resulting parts until the desired number of parts is obtained @xcite .",
    "this approach has the advantage of reducing the partitioning problem to a simpler one , i.e.  bisection .",
    "furthermore , if the resulting parts of every bisection are equally sized , the overall partitioning will be balanced .",
    "in addition , bisection is inherently a global approach , as the whole graph must be considered for splitting the system into two equally sized parts .",
    "thus , it can be expected to yield better results than a local approach , such as bfs .",
    "we intent to construct a level set with @xmath102 levels , where @xmath102 is the maximum number of levels as determined by algorithm [ bfsalgo ] . to this end",
    "we start from an initial partitioning @xmath129 , where @xmath95 and @xmath96 contain the vertices of the leads ( requirement [ graph_part_problem].[req1 ] ) , and @xmath97 all other vertices .",
    "the level set is then obtained by applying the bisection algorithm recursively to @xmath97 and the resulting subsets , until @xmath49 levels are obtained , as shown schematically in fig .",
    "[ fig : recursive_bisection_example ] . here",
    "bisection means splitting a set @xmath100 into two sets , @xmath130 and @xmath131 , such that @xmath132 and @xmath133 . in oder",
    "to be applicable to the graph partitioning problem [ graph_part_problem ] , the bisection must comply with certain requirements :    [ bisection_prob ] the bisection algorithm must be    1 .   [ bisect_req1 ] compatible with a level set with @xmath102 levels .",
    "[ bisect_req2 ] balanced .",
    "[ bisect_req3 ] performed such that subsequent bisections may lead to a balanced level set .",
    "requirement [ bisection_prob].[bisect_req3 ] is formulated rather vaguely : usually there are many different choices how to perform a bisection .",
    "a particular choice will influence the subsequent bisections ( for a similar problem in graph partitioning see @xcite ) , and thus the bisection algorithm must in principle take all following bisection steps into account . since an exact solution to that problem seems computationally intractable , we will resort to heuristics there .",
    "we start explaining how to comply with requirements [ bisection_prob].[bisect_req1 ] and [ bisection_prob].[bisect_req2 ] . in the following",
    "we assume that @xmath134 , as @xmath135 are trivial cases .",
    "then the initial partitioning @xmath129 forms a level set , and so will the final result of the recursive bisection , if the result of every intermediate bisection yields a level set . for this , consider a set @xmath100 with vertices adjacent to the sets @xmath136 and @xmath137 , where `` left''(``right '' ) is defined as being closer to @xmath95 ( @xmath96 ) .",
    "then the sets resulting from the bisection , @xmath130 and @xmath131 may only have vertices adjacent to @xmath136,@xmath131 and @xmath130,@xmath137 , respectively .",
    "apart from the condition of forming a level set , requirement [ bisection_prob].[bisect_req1 ] also dictates the total number of levels . due to the nature of the recursive bisection ,",
    "the number of final levels contained in an intermediate step is always well - defined .",
    "if a set @xmath100 contains @xmath138 levels , then @xmath130 and @xmath131 must contain @xmath139 and @xmath140 levels , respectively .",
    "here , @xmath141 denotes rounding off to the next smallest integer .",
    "the bisection is thus balanced , if @xmath142 note that @xmath138 can take any value , and usually is not a power of two .    from lemma [ lemma_minimal_set ] we know that the minimum set of vertices necessary to form @xmath5 levels is given by a bfs up to level @xmath5",
    ". let @xmath143 ( @xmath144 ) denote the set of vertices found by a bfs starting from @xmath136 ( @xmath137 ) up to level @xmath145 ( @xmath146 ) .",
    "then , for any bisection complying with requirement [ bisection_prob].[bisect_req1 ] , @xmath147 and @xmath148 .",
    "these vertices are uniquely assigned to @xmath130 and @xmath131 and are consequently marked as _ locked _ , i.e.  later operations may not change this assignment .",
    "an example for the vertices found in a bfs is shown in fig .",
    "[ fig : bisection_explanation](a ) .",
    "note that in the initial bisection , @xmath149 , @xmath150 , @xmath151 , and @xmath152 .",
    "( black ) and @xmath144 ( dark grey ) that must be contained in @xmath130 and @xmath131 , respectively . the remaining vertices ( light grey ) can be assigned to either set .",
    "( b ) and ( c ) : examples illustrating the difference between cut edges and cut nets .",
    "the number of cut edges is 5 in both ( b ) and ( c ) , while the number of cut nets ( boundary vertices ) is 10 in ( b ) and 9 in ( c ) . ]",
    "the remaining unassigned vertices can be assigned to either set , and the bisection will still be compatible with a level set containing @xmath102 vertices .",
    "thus for complying with requirement [ bisection_prob].[bisect_req2 ] , any prescription obeying the balancing criterion may be used .",
    "we choose to distribute the remaining vertices by continuing the bfs from @xmath136 and @xmath137 and assigning vertices to @xmath130 and @xmath131 depending on their distance to the left or right neighboring set , while additionally obeying the balancing criterion .",
    "this approach  assigning vertices to levels according to their distance from the initial and final set  is rather intuitive and probably the procedure that would be used if the level set were to be constructed `` by hand '' .",
    "this procedure may lead to reasonable level sets , however in general , additional optimization on the sets @xmath130 and @xmath131 is needed , as discussed below .",
    "if this optimization is used , it can also be useful to distribute the unassigned vertices randomly , as this may help avoiding local minima .",
    "as mentioned above , there is a lot of arbitrariness in distributing the unassigned vertices into @xmath130 and @xmath131 .",
    "however , the particular choice of the bisection will influence whether a later bisection is balanced or not : if @xmath153 contains more vertices than the balance criterion , the bisection _ can not _ be balanced .",
    "obviously , the bfs that constructs @xmath153 depends on the details of the set @xmath100 and thus on the details of the previous bisection step .",
    "in order to formulate a criterion that may resolve the above mentioned arbitrariness and help to find a balanced level set , it is useful to consider the matrix representation of the graph @xmath73 . bisecting a graph means ordering the corresponding matrix into two blocks that are connected by an off - diagonal matrix @xmath154 : @xmath155 this off - diagonal matrix will be unchanged by further bisections and thus determines the minimum level width that can be achieved . therefore , the size of the off - diagonal matrix @xmath154 should be minimized .    in a bisection , an edge @xmath156 is said to be _ cut _ , if @xmath81 and @xmath82 belong to different sets , i.e.  @xmath157 and @xmath158 or vice versa .",
    "the entries of @xmath154 correspond to edges cut by the bisection , and minimizing the number of entries in @xmath154 corresponds to minimizing the number of edges cut by the bisection ( _ min - cut criterion _ ) .",
    "this criterion is often used in reordering matrices for parallel processing , where the off - diagonal matrix size determines the amount of communication between processors .",
    "however , the number of entries in @xmath154 is not directly related to the size of the matrix , as has been noted in the graph partitioning problem for parallel computing @xcite .",
    "instead , the size of the off - diagonal matrix is given by the number of _ surface _ vertices , i.e.  the number of vertices that have cut edges .",
    "for this , we define a _ net _ of a vertex @xmath76 in a graph @xmath84 as @xcite @xmath159 note that @xmath160 , as @xmath76 is adjacent to itself .",
    "a net is said to be cut by a bisection , if any two vertices @xmath161 are contained in different sets @xmath130 and @xmath131 .",
    "then , the number of surface vertices and thus the size of the off - diagonal matrix @xmath154 is given by the number of cut nets .",
    "thus , minimizing the number of cut nets ( _ min - net - cut criterion _ ) corresponds to minimizing the the number of surface vertices , and thus to minimizing the size of the off - diagonal matrix @xmath154 .",
    "furthermore , since the vertices in @xmath162 are determined by a bfs emanating from the surface vertices , minimizing the number of cut nets will usually also lead to a smaller number of vertices in @xmath162 , leaving more freedom towards achieving a balanced bisection . figs .",
    "[ fig : bisection_explanation](b ) and ( c ) show a comparison of the min - cut and min - net - cut criterion for simple examples . in practice ,",
    "when minimizing the number of cut nets , we also use the min - cut criterion to break ties between different bisections with the same number of cut nets ( _ min - net - cut - min - cut criterion _ ) in order to avoid wide local minima , that occur frequently in the min - net - cut problem .    both the min - cut and min - net - cut bisection problem",
    "have been shown to be @xmath163-hard @xcite .",
    "therefore , only heuristics are available to solve them .",
    "these heuristics start from an initial ( balanced ) bisection , such as constructed by the steps outlined above , and improve upon this initial bisection . here",
    ", we choose to use the fiduccia - mattheyses ( fm ) algorithm @xcite , as it is readily available for min - cut and min - net - cut bisection .",
    "in fact , min - net - cut bisection is a _",
    "hypergraph _ partitioning problem , and the fm algorithm was originally designed for hypergraph partitioning .",
    "furthermore , the fm algorithm can naturally deal with locked vertices that may not be moved between sets , is reasonable fast and its underlying concepts are easy to understand .",
    "the fm heuristic is a _ pass - based _ technique , i.e.  it is applied repeatedly to the problem ( several _ passes _ are performed ) , iteratively improving the bisection .",
    "more detailed information about the fundamentals of the fiduccia - mattheyses algorithm are given in appendix [ sec : fm_explanation ] .",
    "we now summarize the steps outlined above and formulate an algorithm for bisection :    [ bisection_algo ] bisection of set @xmath100 containing @xmath138 levels , with left ( right ) neighboring set @xmath136 ( @xmath137 ) .    1 .",
    "stop , if @xmath164 .",
    "2 .   do a bfs starting from @xmath136 up to level @xmath139 and a bfs starting from @xmath137 up to level @xmath165 .",
    "the vertices found by the bfs are assigned to @xmath130 and @xmath131 , respectively , and are marked as locked .",
    "3 .   distribute the remaining unassigned vertices taking into account the balance criterion .",
    "the vertices may be assigned according to either one of the following prescriptions : 1 .",
    "continue the bfss from step b and assign vertices to @xmath130 , if they are first reached by the bfs from @xmath136 , and to @xmath131 , if they are first reached by the bfs from @xmath137 .",
    "if a set has reached the size given by the balance criterion , assign all remaining vertices to the other set .",
    "2 .   distribute the unassigned vertices randomly to @xmath130 and @xmath131 .",
    "if a set has reached the size given by the balance criterion , assign all remaining vertices to the other set .",
    "4 .   optimize the sets @xmath130 and @xmath131 by changing the assignment of unlocked vertices according to some minimization criterion .",
    "in particular , the following optimizations may be performed : 1 .",
    "no optimization .",
    "min - cut optimization using the fm algorithm .",
    "min - net - cut optimization using the fm algorithm .",
    "min - net - cut - min - cut optimization using the fm algorithm .",
    "recursive application of the bisection algorithm [ bisection_algo ] then leads to an algorithm for constructing a level set complying with the requirements of the graph partitioning problem [ graph_part_problem ] , and thus an algorithm for block - tridiagonalizing a matrix .",
    "[ graph_part_algo ] block - tridiagonalization of matrix @xmath10    1 .",
    "construct the graph @xmath84 corresponding to the matrix @xmath10 , and the sets @xmath95 and @xmath96 corresponding to the leads .",
    "2 .   use algorithm [ bfsalgo ] to determine the maximum number of levels @xmath102 .",
    "if @xmath166 , stop .",
    "3 .   construct @xmath167 , containing @xmath49 levels .",
    "4 .   apply the bisection algorithm [ bisection_algo ] to @xmath97 and then recursively on the resulting subsets .",
    "do not further apply if a set only contains one level .",
    "it should be emphasized , that the block - tridiagonalization does not require any other input than the graph structure . in principle , the number of fm passes may affect the result .",
    "however , from experience , this number can be chosen as a fixed value , e.g.  10 fm passes , for all situations @xcite .",
    "thus , the block - tridiagonalization algorithm can serve as a black box .    ) , and application of the block - tridiagonalization algorithm [ graph_part_algo ] with distribution of vertices by bfs ( algorithm [ bisection_algo ] , step c.(a ) ) ( b ) without further optimization , ( c ) with min - cut optimization , ( d ) with min - net - cut optimization . ]    in fig .  [",
    "fig : algo_application ] we show for examples of level sets arising from the natural ordering of grid points ( fig .  [ fig : algo_application](a ) , _ natural level set _ ) and from the block - tridiagonalization algorithm developed in this work ( fig .",
    "[ fig : algo_application](b)(d ) ) for the case of a disk - type geometry .",
    "the level set in fig .",
    "[ fig : algo_application](b ) arises from recursive bisection , where the vertices were distributed according to a bfs without any optimization .",
    "the resulting level set strongly resembles the natural level set .",
    "this is due to the highly symmetric structure and the fact that vertices are assigned to levels according to their distance from the leads  only small deviations are present due to the balance criterion .",
    "when the bisection is optimized according to the min - cut criterion , fig .",
    "[ fig : algo_application](c ) , the resulting level set changes little , as the min - cut criterion favors horizontal and vertical cuts for a square lattice , as presented in the example . in contrast , min - net - cut optimization ( fig .  [ fig : algo_application](d ) ) yields a new , non - trivial level set that has less symmetry than the underlying structure . note that the minimization of surface vertices leads to levels in the form of `` droplets '' , analogous to surface tension in liquids .    in fact",
    ", we will show in sec .",
    "[ section : examples ] that min - net - cut optimization usually leads to level sets and thus block - tridiagonal orderings that are superior to those arising from other methods .",
    "in particular , they are better than the natural level sets , leading to a significant speed - up of transport algorithms , as demonstrated in sec .",
    "[ sec : examples_mesoscopics ] .",
    "in addition to that , the reordering algorithms allow one to use conventional two - terminal transport algorithms also for more complicated , even multi - terminal structures ( see secs .",
    "[ sec : examples_mesoscopics ] and [ sec : examples_multiterminal ] ) .",
    "we conclude the theoretical considerations with an analysis of the computational complexity of algorithms [ bisection_algo ] and [ graph_part_algo ] .",
    "the bisection algorithm involves a bfs search on @xmath100 , which scales linearly with the number of edges within @xmath100 , and thus has complexity @xmath168 , where @xmath169 is the set of edges within @xmath100 .",
    "in addition to that , a single optimization pass of the fm algorithm scales also as @xmath168 @xcite .",
    "usually , a constant number of passes independent of the size of the graph is enough to obtain converged results , and therefore the optimization process of several fm passes is also considered to scale as @xmath168 .",
    "thus , the full bisection algorithm also has complexity @xmath168 .",
    "usually , the number of edges per vertex is approximately homogeneous throughout the graph .",
    "since the recursive bisection is a divide - and - conquer approach , the computational complexity of the full block - tridiagonalization algorithm is then @xmath170 @xcite . in typical graphs arising from physics problems ,",
    "the number of edges per vertex is a constant , the computational complexity can also be written as @xmath171 , where @xmath172 is the number of vertices in @xmath44 , or the size of the matrix @xmath10 .",
    "in contrast , many quantum transport algorithms , such as the recursive green s function technique , scale as @xmath173 in the optimal case of @xmath49 equally sized matrix blocks ( levels ) of size @xmath174 . often , the number of blocks ( levels ) @xmath175 . typically , to name a few examples , @xmath176 in one - dimensional chains , @xmath177 in two dimensions , and the transport calculation scales as @xmath178 .",
    "thus , except for the case of a linear chain , where @xmath179 and matrix reordering is pointless anyways , the block - tridiagonalization algorithm always scales more favorably than the quantum transport algorithms .",
    "this scaling implies that the overhead of the matrix reordering in the transport calculation will become more negligible , the larger the system size .",
    "we now evaluate the performance of the block - tridiagonalization algorithm using representative examples from mesoscopic physics . the schrdinger equation for the two - dimensional electron gas ( 2deg )",
    "is usually transformed into a tight - binding problem by the method of finite differences @xcite , where the continuous differential equation is replaced by a set of linear equations involving only the values of the wave function on discrete grid points .",
    "commonly , these points are arranged in a regular , square grid .",
    "this grid , together with the shape of the particular structure under consideration then defines the structure of the hamilton matrix and the corresponding graph .     denotes a length characterizing the extent for the different structures . ]",
    "the representative examples considered here are shown in fig .",
    "[ fig : examples_2deg ] : the circle ( fig .",
    "[ fig : examples_2deg](a ) ) and the asymmetric sinai billiard ( fig .  [ fig : examples_2deg](b ) ) that are examples of integrable and chaotic billiards in quantum chaos , the ring ( fig .",
    "[ fig : examples_2deg](c ) ) that may exhibit various interference physics , and the circular cavity with leads that are not parallel ( fig .",
    "[ fig : examples_2deg](d ) ) as an example of a structure that does not have an intuitive , natural block - tridiagonal ordering . for all these structures ,",
    "we introduce a length scale @xmath180 , given by the outer radius of the circular structures and the side length of the square structure , characterizing the maximum extent .",
    "the fineness of the grid , and thus the size of the corresponding graph will be measured in number of grid points per length @xmath180 .",
    "we now apply the block - tridiagonalization algorithm using the various optimization criteria discussed in the previous section , and compare the resulting orderings with the natural ordering and the ordering generated by the gps algorithm . the weights @xmath62 , eq .  , of the different orderings",
    "are given in table [ tab : weights ] .",
    "> m0.22||>m0.16|>m0.16|>m0.16|>m0.16 & circular billiard&asymmetric sinai billiard&ring&cavity with perp . leads + natural block- + tridiagonal ordering & @xmath181&@xmath182&@xmath183&@xmath184 + gibbs - poole - stockmeyer&@xmath185&@xmath186&@xmath187&@xmath188 + distribution by bfs , no optimization&@xmath189&@xmath190&@xmath191&@xmath192 + distribution by bfs , min - cut&@xmath189&@xmath193&@xmath191&@xmath194 + random distribution , min - cut&@xmath195&@xmath196&@xmath191&@xmath197 + distribution by bfs , min - net - cut&@xmath189&@xmath198&@xmath191&@xmath199 + random distribution , min - net - cut&@xmath200&@xmath201&@xmath202&@xmath199 + distribution by bfs , min - net - cut - min - cut&@xmath203&@xmath204&@xmath205&@xmath206 + random distribution , min - net - cut - min - cut&@xmath207&@xmath208&@xmath202&@xmath209 +    the initial distributions for the bisection algorithm are done in two different ways : the vertices are distributed both in an ordered way  by bfs  and randomly .",
    "the outcome after the optimization however is always similar for both types of initial distributions which indicates that the resulting weights are close to the global minimum and not stuck in a local minimum .",
    "note that we use twice as many fm passes for a random initial distribution than for an initial distribution by bfs , as convergence is usually slower for a random initial distribution .    in all examples , the min - net - cut criterion yields orderings with the best weights , as expected from the considerations of the previous section .",
    "based on the weight , orderings according to this criterion are expected to give the best performance in transport calculations such as the rgf algorithm . note that the min - net - cut - min - cut ordering is on average closest to the best ordering .",
    "the min - net - cut ordering sometimes suffers from slow convergence , when the algorithm must traverse a wide local minimum .",
    "the additional min - cut criterion helps to break ties and thus avoids these wide local minima .",
    "except for the ring , where all algorithms perform well , the gps algorithm yields weights that are even larger than the weight of the natural ordering . as discussed above , the gps algorithms performs well , if both leads are furthest apart in terms of the graph . in the case of the ring , this is approximately fulfilled . in the general case , when the leads are at arbitrary positions , the gps algorithm usually produces some very large levels . as the level size enters cubically in the @xmath62 ,",
    "this results in a prohibitively large weight .",
    "the gps algorithm thus can not be used as a generic reordering algorithm for quantum transport according to problem [ graph_part_problem ] .    in summary , the block - tridiagonalization algorithm [ graph_part_algo ] in the combination of initial distribution by bfs and min - net - cut - min - cut optimization yields the best reorderings with respect to the weight @xmath62 .",
    "experience shows that usually 10 fm passes are enough for optimizing a bisection . as a consequence",
    ", we will use this combination exclusively in the rest of this work .     as a function of the level ( matrix block ) index @xmath210 for the natural level set ( dashed line ) and the min - net - cut - min - cut reordering ( solid line ) , shown for ( a ) the circle billiard , ( b ) the asymmetric sinai billiard , ( c ) the ring , and ( d ) the circular cavity with perpendicular leads . note that for ( d )",
    ", there is no natural ordering . in all examples , there were 400 grid points per length @xmath211 . ]    the weight @xmath62 of a matrix is a global measure of the quality of a ordering .",
    "additional insight can be gained from the distribution of the sizes @xmath56 of the matrix blocks / levels . in fig .",
    "[ fig : blocksizes ] we show this distribution before and after reordering . for the natural ordering of the finite difference grids ,",
    "the number of matrix blocks is determined by the number of lattice points along the @xmath39-coordinate direction ( see fig .  [",
    "fig : grids](b ) ) .",
    "in contrast , the number of matrix blocks after reordering is given by the length of the shortest path between the two leads , in terms of the corresponding graph .",
    "in the case of the circle billiard , fig .",
    "[ fig : blocksizes](a ) , the number of matrix blocks is the same for the natural ordering and the reordered matrix , as the shortest path between the leads is simply a straight line along the @xmath39-coordinate direction .",
    "the improvements in the weight originate only from balancing the matrix block sizes : while the matrix block sizes vary for the natural ordering ",
    "the lateral size changes along the @xmath39-direction  the reordered matrix has equally sized matrix blocks . for this particular example , the result of the block - tridiagonalization algorithm is optimal , as it yields the best solution with respect to the requirements set forth in problems [ matrix_reordering_problem ] and [ graph_part_problem ] .",
    "note that in general it is not always possible to find a perfectly balanced partitioning , but the circle billiard is such an example .",
    "in contrast , in the case of the asymmetric sinai billiard and the ring the number of matrix blocks generated by the block - tridiagonalization algorithm is larger than in the natural ordering ( see figs .  [",
    "fig : blocksizes](b ) and ( c ) , respectively ) . in both cases ,",
    "the obstacle within the scattering region increases the length of the shortest path connecting the two leads . in both examples ,",
    "this increase in the number of matrix blocks leads to a significantly decreased weight @xmath62 with respect to the natural ordering , although the partitioning is only approximately balanced . for instance , in the particular case of the ring , the number of matrix blocks after reordering is approximately given by the number of lattice points around half of the circumference .",
    "the reordered ring thus has a weight very similar to a straight wire with a width twice as large as the width of one arm of the ring , and a length given by half of the ring circumference .    for the cavity with perpendicular leads",
    ", there is no natural ordering , and a specialized transport algorithm would be required .",
    "the reordering creates a matrix with approximately balanced block sizes , and allows the direct application of conventional algorithms .",
    "the weight @xmath62 was introduced as a theoretical concept in order to simulate the computational complexity of a transport calculation . after discussing the influence of the reordering on this theoretical concept ,",
    "we now demonstrate how the reordering increases the performance of an actual quantum transport calculation .    to this end",
    "we use a straight - forward implementation of the well - established recursive green s function algorithm for two terminals , as described in ref .",
    "the necessary linear algebra operations are performed using the atlas implementation of lapack and blas @xcite , optimized for specific processors .",
    "it should be emphasized that the code that does the actual transport calculation  such as calculation of the green s function and evaluation of the fisher - lee relation  is the same for all examples considered here , including the non - trivial cavity with perpendicular leads .",
    "the abstraction necessary for the reordering , i.e.  the graph structure and the corresponding level set , allows for a generic computational code applicable to any tight - binding model .",
    ", eq .  , through the reordering as a function of the grid size for the circular billiard , the asymmetric sinai billiard , and the ring , respectively .",
    "@xmath212 is shown excluding ( @xmath213 ) and including ( @xmath214 ) the overhead of matrix reordering .",
    "the estimate for @xmath212 from the weights @xmath62 of the different orderings is shown as a dashed line .",
    "( d ) : fraction of time @xmath215 , eq .",
    ", used for reordering the matrix as a function of the grid size .",
    "data is shown for the circular billiard ( @xmath213 ) , the asymmetric sinai billiard ( @xmath214 ) , the ring ( @xmath216 ) , and the circular cavity with perpendicular leads ( @xmath217 ) .",
    "the benchmarks were run on pentium 4 processor with 2.8 ghz and 2 gbs of memory . ]",
    "we measure the performance gain through matrix reordering as @xmath218 note that during a real calculation , the conductance is usually not only calculated once , but repeatedly as a function of some parameters , such as fermi energy or magnetic field .",
    "thus , the respective quantum transport algorithm is executed repeatedly , too .",
    "in contrast , the block - tridiagonalization has to be carried out again _ only _ when the structure of the matrix and thus the corresponding graph changes .",
    "for the examples considered here this would correspond to changing the grid spacing or the shape of the structure .",
    "in such a case , the overhead of matrix reordering must be taken into account for @xmath212 .",
    "this overhead can be quantified as @xmath219 in a typical calculation however , the matrix structure given by the underlying tight - binding grid does not change , and the matrix reordering must be carried out only once . in this common situation ,",
    "the overhead of matrix reordering is negligible .",
    "for example , any change of physical parameters such as fermi energy , magnetic field or disorder averages does not change the matrix structure .    in fig .",
    "[ fig : reordering_speedup ] we show the performance gain through matrix reordering , @xmath212 , as a function of grid size for the circle billiard , the asymmetric sinai billiard , and the ring ( figs .",
    "[ fig : reordering_speedup](a)(c ) , respectively ) .",
    "we include both measurements excluding and including the overhead of matrix reordering , as discussed above .",
    "remember that in the case of the cavity with perpendicular leads , fig .",
    "[ fig : examples_2deg](d ) , there is no natural ordering and thus a performance comparison is not possible .",
    "in fact for this system , only matrix reordering makes a transport calculation possible in the first place .",
    "we find that block - tridiagonalization always increases the algorithmic performance in the typical situation , when the overhead of matrix reordering can be neglected .",
    "however , even if the reordering overhead is taken into account , we see a significant performance gain except for small systems  but there the total computing time is very short anyway .",
    "in fact , as the system sizes increases , the overhead of reordering becomes negligible , as predicted from the analysis of the computational complexity , and the performance gains including and excluding the reordering overhead converge .",
    "this can also be seen in fig .",
    "[ fig : reordering_speedup](d ) , where we show the reordering overhead @xmath215 as a function of system size .",
    "especially for large systems , the total computing time can become very long , and any performance gain is beneficial .",
    "reordering leads to significant performance gains up to a factor of 3 in the case of the ring .",
    "the performance gain @xmath212 can also be estimated from the weights @xmath62 of the original matrix ( the natural ordering ) and the reordered matrix , shown as the dashed line in figs .",
    "[ fig : reordering_speedup](a)(c ) .",
    "the actual , measured performance gain approaches this theoretical value , as the system size increases .",
    "note that we do not fully reach the theoretically predicted performance gain in the case of the ring . on modern computer architectures , computing time does not only depend on the number of arithmetic operations @xcite , and",
    "thus the weight @xmath62 overestimates the performance gain , though the performance still improves significantly .",
    ", for the circular billiard ( @xmath213 ) , the asymmetric sinai billiard ( @xmath214 ) , the ring ( @xmath216 ) , and the circular cavity with perpendicular leads ( @xmath217 ) .",
    "the solid line is a fit to the predicted scaling of the computational complexity , @xmath220 . ]    finally , we demonstrate the @xmath171 scaling of the reordering algorithm .",
    "[ fig : reordering_scaling ] shows the computing times of the block - tridiagonalization algorithm as a function of matrix / graph size @xmath49 for the geometries considered in this section .",
    "for all systems , the computing times scale according to the prediction from the complexity analysis in sec .",
    "[ sec : complexity_analysis ] , as apparent from the fit @xmath221 .",
    "note that for large @xmath172 , @xmath171 scaling is practically indistinguishable from @xmath222 , as can also be seen in fig .",
    "[ fig : reordering_scaling ] .    in the examples of this section",
    ", we considered the pedagogic case of charge transport on a square , finite difference grid .",
    "the approach presented here can however immediately applied to more complex situations , such as spin transport , as reviewed in ref .",
    "in addition , extending the transport calculation to a different grid is straightforward , as any tight - binding grid can be encoded into a graph , and the block - tridiagonalization algorithm has already been applied to the case of the hexagonal grid of graphene @xcite ( for a review on graphene see @xcite ) .",
    "a further example of this versatility is shown in the next section , where we apply the block - tridiagonalization algorithm to solve multi - terminal structures involving different tight - binding models .      in the previous section",
    ", we demonstrated that matrix reordering increases the performance of quantum transport algorithms for two - terminal structures and additionally makes it possible to apply these conventional algorithms to non - trivial structures . whereas there is a great variety of quantum transport algorithms for systems with two leads",
    ", there are only few algorithms that are suitable for multi - terminal structures , and most of these are restricted to rather specific geometries ( e.g.  ref .",
    "only recently algorithms have been developed that claim to be applicable to any multi - terminal structure .",
    "the _ knitting algorithm _ of ref .",
    "@xcite is a variant of the rgf algorithm where the system is built up adding every lattice point individually , instead of adding whole blocks of lattice points at a time .",
    "therefore , instead of a matrix multiplication , the central computational step is an exterior product of vectors .",
    "unfortunately , this implies that the knitting algorithm can not use highly optimized matrix multiplication routines ( level 3 blas operations ) , that are usually much more efficient than their vector counterparts ( level 2 blas operations ) , as discussed in ref .",
    "another multi - terminal transport algorithm presented recently @xcite , is based on the transfer matrix approach .",
    "however , it requires the hamiltonian to be in a specific block - tridiagonal form , and the corresponding level set is set up manually .",
    "here we show how to employ the block - tridiagonalization algorithm in order to apply the well - established two - terminal quantum transport algorithms to an arbitrary multi - terminal system .",
    "the basic idea is sketched in fig .",
    "[ fig : multiterminal_virtualleads](a ) : combining several ( real ) leads into only two virtual leads the multi - terminal problem is reduced to an equivalent two - terminal problem . after reordering , the resulting problem can then be solved by conventional two - terminal algorithms .",
    "note that in this approach the number of matrix blocks is given by the shortest path between leads in two different virtual leads .",
    "if all leads are very close together , this may lead to only few , large blocks in the reordered matrix and respectively levels in the graph partitioning , leading to a very large weight @xmath62 .",
    "in such a case it is advisable to collect all leads into a single virtual lead . the second virtual lead is then formed by a vertex in the graph , that is furthest away from all leads as depicted in fig .",
    "[ fig : multiterminal_virtualleads](b ) .",
    "such a vertex can be found by a bfs search originating from all leads .",
    "thereby the number of matrix blocks / levels is maximized .",
    "in fact , this approach yields a block - tridiagonal matrix structure as required by the algorithm of ref .",
    "@xcite .",
    "is shown as a function of @xmath223 , where @xmath224 is the width of the hall bar and @xmath225 the cyclotron radius in a magnetic field @xmath226 .",
    "note that @xmath227 .",
    "the dotted lines indicate the quantized values of the hall resistance , @xmath228 , where @xmath5 is a positive integer . ]",
    "we now demonstrate these strategies on the example of the quantum hall effect ( qhe ) in a 2deg formed in a semiconductor heterostructure @xcite and in graphene @xcite . for this",
    "we use a four - terminal hall bar geometry as sketched in fig .",
    "[ fig : multiterminal_virtualleads](a ) , on top of a square lattice ( finite difference approximation to 2deg ) and a hexagonal lattice .",
    "again , it should be emphasized that the code of the actual transport calculation is the same as employed in the two - terminal examples of the previous section .",
    "the results of the calculation are shown in fig .",
    "[ fig : example_halleffect ] , where the integer qhe of the 2deg and the odd - integer qhe of graphene are clearly visible .",
    "the methods outlined above make it possible to calculate quantum transport in _ any _ system described by a tight - binding hamiltonian .",
    "this generality is one of the main advantages gained by using the matrix reordering .",
    "however , generality also implies that it is difficult to make use of properties of specific systems , such as symmetries , in order to speed up calculations .",
    "special algorithms developed specifically for a certain system however can , and will usually be faster than a generic approach  at the cost of additional development time .    in the case of the hall geometry in a 2deg",
    ", such a special algorithm was presented by baranger et al .",
    "@xcite , and we have implemented a variant of it . comparing the computing times for the hall bar geometry in a 2deg , we find that the special algorithm is only a factor of @xmath229 faster than our generic approach .",
    "although such a performance comparison may depend crucially on the details of the system under consideration , experience shows that the use of the generic approach often does not come with a big performance penalty .",
    "we have developed a block - tridiagonalization algorithm based on graph partitioning techniques that can serve as a preconditioning step for a wide class of quantum transport algorithms .",
    "the algorithm can be applied to any hamilton matrix originating from an arbitrary tight - binding formulation and brings this matrix into a form that is more suitable for many two - terminal quantum transport algorithms , such as the widely used recursive green s function algorithm .",
    "the advantages of this reordering are twofold : first , the reordering can speed up the transport calculation significantly .",
    "second , it allows for applying conventional two - terminal algorithms to non - trivial geometries including non - collinear leads and multi - terminal systems .",
    "the block - tridiagonalization algorithm scales as @xmath171 , where @xmath172 is the size of the hamilton matrix , and thus induces only little additional overhead .",
    "we have demonstrated the performance of the matrix reordering on representative examples , including transport in 2degs and graphene .    the block - tridiagonalization algorithm can operate as a black box and serve as the foundation of a generic transport code that can be applied to arbitrary tight - binding systems .",
    "such a generic transport code is desirable , as it minimizes development time and increases code quality , as only few basic transport routines are necessary , that can be tested thoroughly .",
    "we acknowledge financial support from dfg within grk638 and sfb689 .",
    "the fiduccia - mattheyses algorithm was originally developed for hypergraph partitioning @xcite .",
    "a hypergraph @xmath230 is an ordered pair @xmath231 , where @xmath75 is a set of vertices , and @xmath232 a set of _ nets _ @xmath233 ( also called",
    "_ hyperedges _ ) between them .",
    "a net @xmath233 is a set of vertices , i.e.  @xmath234 .",
    "an undirected graph is a special realization of a hypergraph , where every net contains exactly two vertices .",
    "thus , any algorithm for hypergraph partitioning can also be applied to an undirected graph .      during the fm bisection",
    ", we have to consider the graph structure arising from the hamiltonian matrix in order to minimize the number of cut edges ( min - cut ) , whereas for minimizing the number of surface vertices , i.e.  the number of cut nets ( min - net - cut ) , the hypergraph structure arising from all nets @xmath235 as defined in eq .",
    ", @xmath236 , is essential . for min - net - cut - min - cut optimization",
    ", we have to consider both structures simultaneously . a schematic representation of a graph and the corresponding hypergraph structure is shown in fig .  [ fig : example_graph_hypergraph ] .",
    "the fm algorithm is based on the concept of _ gain_. the gain of a vertex in an existing bisection is defined as the change in weight , i.e.  the number of cut edges or nets , that occurs when this vertex is move to the other part .",
    "this gain can also be negative , if such a move increases the number of cut edges or nets .",
    "the basic idea of the fm algorithm is to swap vertices with the highest gain between parts , while obeying some balance criterion .",
    "the fact that the highest gain can be negative , helps the fm algorithm to escape local minima . after moving ,",
    "the respective vertex is locked in order to avoid an infinite loop , where a single vertex might be swapped back and forth repeatedly .",
    "the fm pass ends , when all ( free ) vertices have been moved , and the best bisection encountered during the pass is returned as result .",
    "further passes can then successively improve on this bisection .",
    "p.  havu , v.  havu , m.  j. puska , r.  m. nieminen , nonequilibrium electron transport in two - dimensional nanostructures modeled using green s functions and the finite - element method , phys . rev .",
    "b 69  ( 11 ) ( 2004 ) 115325 .",
    "s.  sanvito , c.  j. lambert , j.  h. jefferson , a.  m. bratkovsky , general green39s - function formalism for transport calculations with @xmath237 hamiltonians and giant magnetoresistance in co- and ni - based magnetic multilayers , phys .",
    "b 59  ( 18 ) ( 1999 ) 1193611948 .",
    "m.  luisier , a.  schenk , w.  fichtner , g.  klimeck , atomistic simulation of nanowires in the @xmath238 tight - binding formalism : from boundary conditions to strain calculations , phys . rev .",
    "b 74  ( 20 ) ( 2006 ) 205323 .",
    "a.  di  carlo , a.  pecchia , l.  latessa , t.  frauenheim , g.  seifert , tight - binding dft for molecular electronics ( gdftb ) , in : g.  cuniberti , g.  fagas , k.  richter ( eds . ) , introducing molecular electronics , springer , berlin , heidelberg , 2006 , pp .",
    "153184 .",
    "t.  usuki , m.  saito , m.  takatsu , r.  a. kiehl , n.  yokoyama , numerical analysis of ballistic - electron transport in magnetic fields by using a quantum point contact and a quantum wire , phys . rev .",
    "b 52  ( 11 ) ( 1995 ) 82448255 .                                        c.  m. fiduccia , r.  m. mattheyses , a linear - time heuristic for improving network partitions , in : dac 82 : proceedings of the 19th conference on design automation , ieee press , piscataway , nj , usa , 1982 , pp . 175181 .",
    "m.  wimmer , m.  scheid , k.  richter , spin - polarized quantum transport in mesoscopic conductors : computational concepts and physical phenomena , to appear in the encyclopedia of complexity and system science , arxiv:0803.3705v1 ( 2008 ) .              k.  s. novoselov , a.  k. geim , s.  v. morozov , d.  jiang , m.  i. katsnelson , i.  v. grigorieva , s.  v. dubonos , a.  a. firsov , two - dimensional gas of massless dirac fermions in graphene , nature 438  ( 7065 ) ( 2005 ) 197200 ."
  ],
  "abstract_text": [
    "<S> numerical quantum transport calculations are commonly based on a tight - binding formulation . </S>",
    "<S> a wide class of quantum transport algorithms requires the tight - binding hamiltonian to be in the form of a block - tridiagonal matrix . here </S>",
    "<S> , we develop a matrix reordering algorithm based on graph partitioning techniques that yields the optimal block - tridiagonal form for quantum transport . </S>",
    "<S> the reordered hamiltonian can lead to significant performance gains in transport calculations , and allows to apply conventional two - terminal algorithms to arbitrary complex geometries , including multi - terminal structures . </S>",
    "<S> the block - tridiagonalization algorithm can thus be the foundation for a generic quantum transport code , applicable to arbitrary tight - binding systems . </S>",
    "<S> we demonstrate the power of this approach by applying the block - tridiagonalization algorithm together with the recursive green s function algorithm to various examples of mesoscopic transport in two - dimensional electron gases in semiconductors and graphene .    ,    coherent quantum transport , recursive green s function technique , block - tridiagonal matrices , matrix reordering , graph partitioning 72.10.bg , 02.70.-c , 02.10.ox 05c50 , 05c78 </S>"
  ]
}