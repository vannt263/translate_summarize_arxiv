{
  "article_text": [
    "we assume familiarity with basic notions of combinatorial semigroup theory , including free semigroups and monoids , and semigroup and monoid presentations . in all but",
    "section  [ sec_uniform ] of the paper , which is devoted to uniform decision problems , we assume we have a fixed finite presentatation for a monoid ( or semigroup  we shall see shortly that the difference is unimportant ) .",
    "words are assumed to be drawn from the free monoid on the generating alphabet unless otherwise stated .",
    "we write @xmath1 to indicate that two words are equal in the free monoid , and @xmath2 to indicate that they represent the same element of the semigroup presented .",
    "we say that a word @xmath3 is a _",
    "possible prefix _ of @xmath4 if there exists a ( possibly empty ) word @xmath5 with @xmath6 , that is , if the element represented by @xmath4 lies in the right ideal generated by the element represented by @xmath3 .",
    "the empty word is denoted @xmath7 .",
    "a _ relation word _ is a word which occurs as one side of a relation in the presentation .",
    "piece _ is a word in the generators which occurs as a factor in sides of two different relations , or as a factor of both sides of a relation , or in two different ( possibly overlapping ) places within one side of a relation . to ensure a uniform treatment for free semigroups and monoids",
    ", we make the convention that the empty word @xmath7 is always a piece , even if the presentation has no relations .",
    "the presentation is said to _ satisfy the condition @xmath8 _ , where @xmath9 is a positive integer , if no relation word can be written as the product of * strictly fewer than * @xmath9 pieces .",
    "thus for each @xmath9 , @xmath10 is a strictly stronger condition than @xmath8 .",
    "we briefly mention another related condition .",
    "the presentation _ satisfies the condition ol(@xmath11 ) _ , where @xmath12 if whenever a piece @xmath3 occurs as a factor of a relation word @xmath13 we have @xmath14 . notice",
    "that if @xmath9 is a positive integer , then a semigroup satisfying ol(@xmath15 ) will certainly satisfy @xmath10 .",
    "the weakest meaningful small overlap condition , @xmath16 , says that no relation word is a product of zero pieces , that is , that @xmath7 is not a relation word . from this",
    "we see that in a small overlap monoid presentation , no non - empty word can be equivalent to the empty word , that is , no non - empty word can represent the identity .",
    "it follows that every small overlap monoid presentation is also interpretable as a semigroup presentation , and that the monoid presented is isomorphic to the semigroup presented with an adjoined identity element . for simplicity in",
    "what follows we shall focus upon small overlap monoids , but from each of our results one can immediately deduce a corresponding result for small overlap semigroups .    for each relation word @xmath13 ,",
    "let @xmath17 and @xmath18 denote respectively the longest prefix of @xmath13 which is a piece , and the longest suffix of @xmath13 which is a piece .",
    "if the presentation satisfies @xmath19 then @xmath13 can not be written as a product of two pieces , so this prefix and suffix can not meet ; thus , @xmath13 admits a factorisation @xmath20 for some non - empty word @xmath21 .",
    "if moreover the presentation satisfies the stronger condition @xmath0 then @xmath13 can not be written as a product of three pieces , so @xmath21 is not a piece .",
    "the converse also holds : a @xmath19 presentation such that no @xmath21 is a piece is a @xmath0 presentation .",
    "we call @xmath17 , @xmath21 and @xmath18 the _ maximal piece prefix _ , the _ middle word _ and the _ maximal piece suffix _ respectively of @xmath13 .    assuming now that the presentation satisfies at least the condition @xmath19 , we shall use the letters @xmath22 , @xmath23 and @xmath24 ( sometimes with adornments or subscripts ) exclusively to represent maximal piece prefixes , middle words and maximal piece suffixes respectively of relation words ; two such letters with the same subscript or adornment ( or with none ) will be assumed to stand for the appropriate factors of the same relation word .    if @xmath13 is a relation word we write @xmath25 for the ( necessarily unique , as a result of the small overlap condition ) word such that @xmath26 or @xmath27 is a relation in the presentation .",
    "we write @xmath28 , @xmath29 and @xmath30 for @xmath31 , @xmath32 and @xmath33 respectively .",
    "( this is an abuse of notation since , for example , the word @xmath17 may be a maximal piece prefix of two distinct relation words , but we shall be careful to ensure that the meaning is clear from the context . )",
    "to perform efficient computations with words , it is very helpful to be able to process them in a sequential , left - right manner . to facilitate this in the case of the word problem for small overlap monoids",
    ", we need to know what can be deduced about the equivalence ( or non - equivalence ) of two words from prefixes of those words .",
    "this section develops a theory with this end in mind , including a number of results which can be viewed as weak cancellativity conditions satisfied by small overlap monoids .",
    "we assume throughout a fixed monoid presentation satisfying the small overlap condition @xmath0 .",
    "we first introduce some terminology .",
    "a _ relation prefix _ of a word is a prefix which admits a ( necessarily unique , as a consequence of the small overlap condition ) factorisation of the form @xmath34 where @xmath22 and @xmath23 are the maximal piece prefix and middle word respectively of some relation word @xmath35",
    ". an _ overlap prefix ( of length @xmath9 ) _ of a word @xmath4 is a relation prefix which admits an ( again necessarily unique ) factorisation of the form @xmath36 where    * @xmath37 ; * no factor of the form @xmath38 begins before the end of the prefix @xmath39 ; * for each @xmath40 , @xmath41 is a relation word with @xmath42 and @xmath43 the maximal piece prefix and suffix respectively ; and * for each @xmath44 , @xmath45 is a proper , non - empty prefix of @xmath46 .",
    "notice that if a word has a relation prefix , then the shortest such must be an overlap prefix .",
    "a relation prefix @xmath34 of a word @xmath4 is called _ clean _",
    "if @xmath4 does * not * have a prefix @xmath47 where @xmath48 and @xmath49 are the maximal piece prefix and middle word respectively of some relation word , and @xmath50 is a proper , non - empty prefix of @xmath23 .",
    "clean overlap prefixes , in particular , will play a crucial role in what follows .",
    "[ prop_overlapprefixnorel ] let @xmath51 be an overlap prefix of some word .",
    "then this prefix contains no relation word as a factor ( except possibly @xmath52 in the case that @xmath53 ) .",
    "suppose that the given overlap prefix contains a relation word @xmath13 as a factor . by the definition of an overlap prefix ,",
    "no occurrence of @xmath13 can begin before the end of the prefix @xmath39 , so we may assume that @xmath13 is a factor of @xmath54 .",
    "it follows that either @xmath13 contains @xmath55 as a factor for some @xmath56 , or else @xmath13 is a factor of @xmath57 for some @xmath56 ( where @xmath58 if @xmath59 ) and we may assume without loss of generality that the occurrence of @xmath13 overlaps non - trivially with the prefix @xmath55 .    in the former case , since @xmath42 is a maximal piece prefix of @xmath60 and @xmath45 is non - empty , @xmath55 can not be a piece ; it follows then that we must have @xmath61 with the occurrence in the obvious place . in the latter case",
    ", @xmath13 is the product of a non - empty factor of @xmath60 with a factor of the @xmath62 ; but by the small overlap assumption , @xmath13 can not be written as a product of two pieces , so it must again be that @xmath61 with the occurrence in the obvious place .    now if @xmath63 then , since @xmath13 is a factor of the given relation prefix , we must clearly have @xmath64 so that @xmath65 . on the other hand , if @xmath66 then either @xmath60 contains @xmath67 as a factor , which contradicts the fact that @xmath68 is a maximal piece prefix of @xmath60 , or else ( recalling that @xmath45 is a proper prefix of @xmath46 ) we see that @xmath67 contains a non - empty suffix of @xmath46 followed by @xmath43 , which contradicts the fact that @xmath43 is a maximal piece suffix of @xmath60 .",
    "[ prop_opgivesmop ] let @xmath4 be a word .",
    "every overlap prefix of @xmath4 is contained in a clean overlap prefix of @xmath4 .",
    "we fix @xmath4 and prove by induction on the difference between the length of @xmath4 and the length of the given overlap prefix , that is , on the length of that part of @xmath4 not contained in the given overlap prefix . for the base case , observe that an overlap prefix constituting the whole of @xmath4 is necessarily clean . now suppose @xmath69 is an overlap prefix , and that the result holds for longer overlap prefixes of @xmath4 .",
    "if the given prefix is clean then there is nothing to prove .",
    "otherwise , by the definition of a clean overlap prefix , there exist words @xmath22 and @xmath23 , being the maximal piece prefix and the middle word respectively of some relation word , and a proper non - empty prefix @xmath70 of @xmath71 such that @xmath72 is a prefix of @xmath4 .",
    "clearly this is an overlap prefix of @xmath4 which is strictly longer than the original one , and so by induction is contained in a clean overlap prefix of @xmath4 .",
    "but now the original overlap prefix of is contained in a clean overlap prefix , as required .",
    "[ cor_nomopnorel ] if a word @xmath4 has no clean overlap prefix , then it contains no relation word as a factor , and so if @xmath2 then @xmath1 .",
    "suppose @xmath4 has no clean overlap prefix .",
    "if @xmath4 contained a relation word as a factor then clearly it would have a relation prefix , that is , a prefix of the form @xmath73 for some relation word @xmath13 .",
    "but by our observations above , the shortest relation prefix of @xmath4 would be an overlap prefix , and so by proposition  [ prop_opgivesmop ] , is contained in a clean overlap prefix of @xmath4 .",
    "thus , @xmath4 contains no relation word as a factor .",
    "it follows easily that no relations can be applied to @xmath4 , so the only word equivalent to @xmath4 is @xmath4 itself .",
    "[ lemma_staysclean ] if @xmath74 with @xmath75 a clean overlap prefix then @xmath76 is a clean overlap prefix of @xmath77 .",
    "let @xmath78 be the factorisation given by the definition of a clean overlap prefix .",
    "then @xmath77 has a prefix @xmath79 if @xmath37 it is immediate from the factorisation given by that @xmath76 is an overlap prefix of @xmath77 . in the case",
    "@xmath80 , however , we must consider the possibility that the prefix @xmath81 contains a factor of the form @xmath82 overlapping the final initial segment @xmath39 .",
    "suppose it does .",
    "then recalling that @xmath83 is not a piece , and so can not be a factor of @xmath84 , we see that @xmath85 admits a factorisation @xmath86 for some non - empty prefix @xmath87 or @xmath83 .",
    "moreover , @xmath87 must be a proper prefix of @xmath83 , or else @xmath39 would have a factor @xmath82 , contradicting the fact that @xmath75 was a clean overlap prefix of @xmath4 .",
    "this shows that @xmath88 is an overlap prefix of @xmath77 .",
    "it remains to show that the given overlap prefix is clean .",
    "suppose for a contradiction that it is not .",
    "then by definition , there is a factor of the form @xmath89 overlapping the end of the prefix @xmath85 ; but this factor is either by contained in @xmath90 ( contradicting the supposition that @xmath91 is a maximal piece prefix of a relation word @xmath92 ) or contains a non - empty suffix of @xmath93 followed by @xmath94 ( contradicting the assumption that @xmath94 is a maximal piece suffix of @xmath95 ) .",
    "the following lemma is fundamental to our approach to @xmath0 monoids . with careful application",
    "it seems to permit a comparable understanding to that resulting from remmers geometric theory , but in a purely combinatorial ( and hence more computationally orientated ) way .",
    "[ lemma_overlap ] suppose a word @xmath4 has clean overlap prefix @xmath96 . if @xmath2 then @xmath97 has overlap prefix either @xmath96 or @xmath98 , and no relation word occurring as a factor of @xmath97 overlaps this prefix , unless it is @xmath99 or @xmath95 as appropriate .    since @xmath96 is an overlap prefix of @xmath4 , it has by definition a factorisation @xmath100 for some @xmath101 .",
    "we use this fact to prove the claim by induction on the length @xmath102 of a rewrite sequence ( using the defining relations ) from @xmath4 to @xmath97 .    in the case",
    "@xmath103 , we have @xmath1 , so @xmath97 certainly has ( clean ) overlap prefix @xmath104 . by proposition  [ prop_overlapprefixnorel",
    "] , no relation word factor can occur entirely within this prefix ( unless it is @xmath105 and @xmath106 ) .",
    "if a relation word factor of @xmath97 overlaps the end of the given overlap prefix and entirely contains @xmath107 then , since @xmath107 is not a piece , that relation word must clearly be @xmath35 .",
    "finally , a relation word can not overlap the end of the given overlap prefix but not contain the suffix @xmath107 , since this would clearly contradicts the fact that the given overlap prefix is clean .",
    "suppose now for induction that the lemma holds for all values less than @xmath102 , and that there is a rewrite sequence from @xmath4 to @xmath97 of length @xmath102 .",
    "let @xmath108 be the second term in the sequence , so that @xmath108 is obtained from @xmath4 by a single rewrite using the defining relations , and @xmath97 from @xmath108 by @xmath109 rewrites .",
    "consider the relation word in @xmath4 which is to be rewritten in order to obtain @xmath108 , and in particular its position in @xmath4 . by proposition  [ prop_overlapprefixnorel",
    "] , this relation word can not be contained in the clean overlap prefix @xmath75 , unless it is @xmath105 where @xmath106 .",
    "suppose first that the relation word to be rewritten contains the final factor @xmath23 of the given clean overlap prefix .",
    "( note that this covers in particular the case that the relation word is @xmath107 and @xmath106 . ) from the @xmath0 assumption we know that @xmath23 is not a piece , so we may deduce that the relation word is @xmath99 contained in the obvious place . in this case , applying the rewrite clearly leaves @xmath108 with a prefix @xmath76 , and by lemma  [ lemma_staysclean ] , this is a clean overlap prefix .",
    "now @xmath97 can be obtained from @xmath108 by @xmath109 rewrite steps , so it follows from the inductive hypothesis that @xmath97 has overlap prefix either @xmath76 or @xmath110 , and that no relation word occurring as a factor of @xmath97 overlaps this prefix , unless it is @xmath99 or @xmath95 as appropriate ; this completes the proof in this case .",
    "next , we consider the case in which the relation word factor in @xmath4 to be rewritten does not contain the final factor @xmath71 of the clean overlap prefix , but does overlap with the end of the clean overlap prefix . then @xmath4 has a factor of the form @xmath105 , where @xmath22 is the maximal piece prefix and @xmath23 the middle word of a relation word , which overlaps @xmath52 , beginning after the start of @xmath71 .",
    "this clearly contradicts the assumption that the overlap prefix is clean .",
    "finally , we consider the case in which the relation word factor in @xmath4 which is to be rewritten does not overlap the given clean overlap prefix at all .",
    "then obviously , the given clean overlap prefix of @xmath4 remains an overlap prefix of @xmath108 .",
    "if this overlap prefix is clean , then a simple application of the inductive hypothesis again suffices to prove that @xmath97 has the required property",
    ".    there remains , then , only the case in which the given overlap prefix is no longer clean in @xmath108 .",
    "then by definition there exist words @xmath22 and @xmath23 , being a maximal piece prefix and middle word respectively of some relation word , such that @xmath108 has the prefix @xmath111 for some proper , non - empty prefix @xmath70 of @xmath71 . now certainly this is not a prefix of @xmath4 , since this would contradict the assumption that @xmath69 is a clean overlap prefix of @xmath4 .",
    "so we deduce that @xmath108 must contain a relation word overlapping the final @xmath107 .",
    "this relation word can not contain the final factor @xmath107 , since this would again contradict the assumption that @xmath69 is a clean overlap prefix of @xmath4 .",
    "nor can the relation word contain the final factor @xmath23 , since @xmath23 is not a piece .",
    "hence , @xmath108 must have a prefix @xmath112 for some relation word and proper , non - empty prefix @xmath50 of @xmath23 and some relation word @xmath13 .",
    "suppose @xmath113 where @xmath17 and @xmath18 are the maximal piece prefix and suffix respectively .",
    "then it is readily verified that @xmath114 is a clean overlap prefix of @xmath108 .",
    "but now by the inductive hypothesis , @xmath97 has prefix either @xmath115 or @xmath116 and so in particular it certainly has prefix @xmath117 which in turn is easily seen to have prefix @xmath118 moreover , by proposition  [ prop_overlapprefixnorel ] , the prefix or of @xmath97 contains no relation word as a factor ( unless it is the final factor @xmath119 and @xmath120 ) and it follows easily that no relation word factor overlaps the prefix of @xmath97 .",
    "the lemma has the following easy corollary .",
    "[ cor_noncleanprefix ] suppose a word @xmath4 has ( not necessarily clean ) overlap prefix @xmath75 . if @xmath2 then @xmath97 has a prefix @xmath5 and contains no relation word overlapping this prefix .    by proposition  [ prop_opgivesmop ]",
    "the overlap prefix @xmath121 of @xmath4 is contained in a clean overlap prefix @xmath122 of @xmath4 .",
    "now by lemma  [ lemma_overlap ] , @xmath97 has a prefix @xmath123 and contains no relation word overlapping this prefix .",
    "but it is easily seen that @xmath123 must be at least as long as @xmath5 , so that @xmath97 has a prefix @xmath5 and contains no relation word overlapping this prefix , as required .",
    "the following proposition describes a very weak left cancellation property of small overlap monoids ; it will allow us to restrict attention to words with a prefix of the form @xmath105 where @xmath22 and @xmath23 are the maximal piece prefix and middle word respectively of some relation word .",
    "[ prop_dumpprefix ] suppose a word @xmath4 has an overlap prefix @xmath34 and that @xmath124 .",
    "then @xmath2 if and only if @xmath125 where @xmath126 .",
    "clearly if @xmath127 with @xmath128 then it is immediate that @xmath129 .",
    "conversely , suppose @xmath2 .",
    "since @xmath34 is an overlap prefix , by proposition  [ prop_overlapprefixnorel ] it can not contain a relation word starting before the end of @xmath39 . by corollary  [ cor_noncleanprefix ] , @xmath97 has prefix @xmath39 , say @xmath125 . now consider a rewrite sequence , using the defining relations , from @xmath4 to @xmath97 .",
    "again using corollary  [ cor_noncleanprefix ] , every term in this sequence will have prefix @xmath39 , and contain no relation word overlapping this prefix .",
    "it follows that the same sequence of rewrites can be applied to take @xmath130 to @xmath131 , so that @xmath128 as required .",
    "we now introduce some more terminology .",
    "let @xmath4 be a word with shortest relation prefix @xmath34 , and let @xmath3 be a piece .",
    "we say that @xmath4 is _ @xmath3-inactive _ if @xmath132 has shortest relation prefix @xmath133 and _ @xmath3-active _ otherwise .",
    "the following proposition describes another weak cancellation property of small overlap monoids .",
    "[ prop_inactive ] let @xmath4 be a word and @xmath3 a piece .",
    "if @xmath4 is @xmath3-inactive then @xmath134 if and only if @xmath135 for some @xmath5 with @xmath136 .",
    "suppose @xmath4 has shortest relation prefix @xmath137 , so that @xmath138 has shortest relation prefix @xmath139 .",
    "suppose @xmath140 .",
    "if @xmath141 then by proposition  [ prop_dumpprefix ] ( since the shortest relation prefix is clearly an overlap prefix ) , we have @xmath142 where @xmath143 . now setting @xmath144 we have @xmath145 and @xmath146",
    "the converse implication is obvious .",
    "[ prop_coactive ] let @xmath147 and @xmath148 be maximal piece suffixes of relation words and suppose @xmath4 is @xmath147-active and @xmath148-active .",
    "then @xmath147 and @xmath148 have a common non - empty suffix , and if @xmath149 is the maximal common suffix then    * @xmath4 is @xmath149-active ; * @xmath150 if and only if @xmath151 where @xmath152 and @xmath153 ; and * @xmath154 if and only if @xmath155 where @xmath156 ; and @xmath153 .",
    "let @xmath157 and @xmath158 be the shortest relation prefixes of @xmath159 and @xmath160 respectively . since @xmath4 is @xmath147-active and @xmath148-active , we must have @xmath161 and @xmath162 . moreover , since @xmath147 is a piece and @xmath163 is a maximal piece prefix of the relation word @xmath164 we must have @xmath165 , and similarly @xmath166 .",
    "it follows that @xmath4 has prefixes @xmath167 and @xmath168 where @xmath169 and @xmath170 are proper ( perhaps empty ) suffixes of @xmath163 and @xmath171 respectively .",
    "thus , one of @xmath167 and @xmath168 is a prefix of the other , and so either @xmath172 is a factor of @xmath168 and hence of @xmath173 or @xmath174 is a factor of @xmath167 and hence of @xmath164 .",
    "but by the @xmath0 assumption , neither @xmath172 nor @xmath174 is a piece",
    "so the only possible explanation is that @xmath164 and @xmath173 are the same relation word , and moreover @xmath175 .",
    "now let @xmath3 be such that @xmath176 .",
    "we have already observed that @xmath169 is a proper prefix of @xmath163 , so @xmath3 is non - empty .",
    "now @xmath177 , and also @xmath178",
    "so by symmetry we have @xmath179 .",
    "hence , @xmath3 is a common non - empty suffix of @xmath147 and @xmath148 .",
    "now let @xmath149 be the maximal common suffix of @xmath147 and @xmath148 .",
    "let @xmath180 , @xmath181 and @xmath182 be such that @xmath183 , @xmath184 and @xmath185 .",
    "then clearly @xmath186 and @xmath187 .",
    "now @xmath188 has a relation prefix @xmath189 , from which it is immediate that @xmath4 is @xmath149-active so that ( i ) holds .    to show that ( ii ) holds , let @xmath190 be such that @xmath191 , and suppose @xmath2 .",
    "now @xmath192 where @xmath193 is the shortest relation prefix , and hence is an overlap prefix .",
    "hence , by proposition  [ prop_dumpprefix ] we have @xmath194 where @xmath195 .",
    "but now setting @xmath196 we have @xmath151 , @xmath152 and @xmath197 as required .",
    "conversely , if @xmath151 where @xmath152 and @xmath198 then we have @xmath199 this completes the proof that ( ii ) holds , and an entirely symmetric argument shows that ( iii ) holds .",
    "[ cor_actsame ] let @xmath147 and @xmath148 be maximal piece suffixes of relation words .",
    "suppose @xmath4 is @xmath148-active and @xmath200",
    ". then @xmath201 .",
    "if @xmath4 is @xmath147-inactive then by proposition  [ prop_inactive ] we have @xmath2 , and so certainly @xmath201 .    on the other hand , if @xmath4 is @xmath147-active then let @xmath149 be the maximal common suffix of @xmath147 and @xmath148 and let @xmath181 and @xmath182 be such that @xmath152 and @xmath156 . then by the proposition  [ prop_coactive](ii ) ,",
    "since @xmath200 we have @xmath202 where @xmath198 .",
    "but from @xmath203 we deduce that @xmath204 , so now we have @xmath205    [ cor_eitheror ] let @xmath4 and @xmath97 be words and @xmath147 and @xmath148 be maximal piece suffixes of relation words .",
    "suppose there exist words @xmath206 such that @xmath207 then either @xmath200 or @xmath208 or both .",
    "fix @xmath4 and @xmath97 , and suppose @xmath9 is minimal ( allowing exchanging @xmath147 and @xmath148 if necessary ) such that a sequence of equivalences as above exists .",
    "suppose further for a contradiction that @xmath209 .",
    "if @xmath210 was @xmath147-inactive then by proposition  [ prop_inactive ] we would have @xmath211 so that @xmath212 , contradicting the minimality assumption on @xmath9 .",
    "similarly , if @xmath210 was @xmath148-inactive then we would have @xmath213 so that @xmath214 again contradicting the minimality assumption on @xmath9 .",
    "thus , @xmath210 is both @xmath147-active and @xmath148-active .",
    "but now since @xmath215 , we apply corollary  [ cor_actsame ] to see that @xmath212 , again providing the required contradiction .",
    "in this section we use the theory developed in section  [ sec_weakcan ] to provide a new characterisation of when two words in the generators of a small overlap presentation represent the same element of the monoid presented . in section  [ sec_algorithm ] we shall use this characterisation to develop an efficient algorithm to solve the word problem .",
    "we first present a lemma which gives a set of mutually exclusive combinatorial conditions , the disjunction of which is necessary and sufficient for two words of a certain form to represent the same element .    [ lemma_eq ] suppose @xmath216 where @xmath107 is a clean overlap prefix of @xmath4 . then @xmath2",
    "if and only if one of the following mutually exclusive conditions holds :    * @xmath217 and @xmath218 and either @xmath219 or @xmath220 or both ; * @xmath216 , @xmath221 , and @xmath24 fails to be a prefix of at least one of @xmath190 and @xmath131 , and @xmath222 ; * @xmath223 , @xmath224 and either @xmath219 or @xmath220 or both ; * @xmath216 , @xmath224 but @xmath24 is not a prefix of @xmath190 and @xmath225 ; * @xmath223 , @xmath226 but @xmath94 is not a prefix of @xmath131 and @xmath227 ; * @xmath216 , @xmath226 , @xmath24 is not a prefix of @xmath190 and @xmath94 is not a prefix of @xmath131 , but @xmath228 , @xmath229 , @xmath230 , @xmath231 where @xmath232 and @xmath149 is the maximal common suffix of @xmath24 and @xmath94 , @xmath149 is non - empty , and @xmath149 is a possible prefix of @xmath233 .",
    "first we treat the claim that the conditions ( 1)-(6 ) are mutually exclusive .",
    "since @xmath22 is a maximal piece prefix of @xmath35 and @xmath23 is non - empty , @xmath107 is not a piece .",
    "an entirely similar argument shows that @xmath84 is not a piece .",
    "in particular , neither of @xmath107 and @xmath84 is a prefix of the other , and so @xmath97 can have at most one of them as a prefix .",
    "thus , conditions ( 1)-(2 ) are not consistent with conditions ( 3)-(6 ) . the mutual exclusivity of ( 1 ) and ( 2 ) is self - evident from the definitions , and likewise that of ( 3)-(6 ) .",
    "it is easily verified that each of the conditions ( 1)-(5 ) imply that @xmath2 .",
    "we show next that ( 6 ) implies that @xmath2 . since @xmath149 is a possible prefix of @xmath233 and @xmath232 , we may write @xmath234 for some word @xmath11 .",
    "now we have @xmath235 what remains , which is the main burden of the proof , is to prove that @xmath2 implies that at least one of the conditions ( 1)-(6 ) holds . to this end ,",
    "then , suppose @xmath2 ; then there is a rewriting sequence taking @xmath4 to @xmath97 . by lemma  [ lemma_overlap ] ,",
    "every term in this sequence will have prefix either @xmath107 or @xmath84 and this prefix can only be modified by the application of the relation @xmath236 in the obvious place .",
    "we now prove the claim by case analysis .    by lemma  [ lemma_overlap ] ,",
    "@xmath97 begins either with @xmath107 or with @xmath84 .",
    "consider first the case in which @xmath97 begins with @xmath107 ; we split this into two further cases depending on whether @xmath4 and @xmath97 both begin with the full relation word @xmath35 ; these will correspond respectively to conditions ( 1 ) and ( 2 ) in the statement of the lemma .",
    "* case ( 1 ) .",
    "* suppose @xmath217 and @xmath237 .",
    "then clearly there is a rewriting sequence taking @xmath4 to @xmath97 which by lemma  [ lemma_overlap ] can be broken up as : @xmath238 where none of the steps in the sequences indicated by @xmath239 involves rewriting a relation word overlapping with the prefix @xmath107 or @xmath84 as appropriate .",
    "it follows that there are rewriting sequences .",
    "@xmath240 now by corollary  [ cor_eitheror ] , either @xmath219 or @xmath220 as required to show that condition ( 1 ) holds .",
    "* case ( 2 ) .",
    "* suppose now that @xmath216 , @xmath241 and @xmath24 fails to be a prefix of at least one of @xmath190 and @xmath131 .",
    "we must show that @xmath222 ; suppose for a contradiction that this does not hold .",
    "we consider only the case that @xmath24 is not a prefix of @xmath190 ; the case that @xmath24 is not a prefix of @xmath131 is symmetric .",
    "we consider rewriting sequences from @xmath242 to @xmath241 .",
    "again using lemma  [ lemma_overlap ] , we see that there is either ( i ) such a sequence taking @xmath4 to @xmath97 containing no rewrites of relation words overlapping the prefix @xmath107 , or ( ii ) such a sequence taking @xmath4 to @xmath97 which can be broken up as : @xmath243 where none of the intermediate words in the sequences indicated by @xmath239 contains a relation word overlapping with the prefix @xmath107 or @xmath84 as appropriate . in case ( i )",
    "there is clearly a rewrite sequence taking @xmath190 to @xmath131 so that @xmath222 as required . in case ( ii ) , there are rewriting sequences .",
    "@xmath244 notice that , since @xmath190 does not begin with @xmath24 , we can deduce from proposition  [ prop_inactive ] that @xmath108 is @xmath24-active . by corollary  [ cor_eitheror ] , either @xmath245 or @xmath246 . in the latter case ,",
    "since @xmath108 is @xmath24-active , corollary  [ cor_actsame ] tells us that we also have @xmath245 in any case .",
    "but now @xmath247 so condition ( 2 ) holds and we are done .",
    "we have now shown that if @xmath97 begins with @xmath107 then either condition ( 1 ) or condition ( 2 ) holds .",
    "it remains to consider the case in which @xmath97 begins with @xmath84 , and show that one of conditions ( 1)-(6 ) must be satisfied .",
    "we split the analysis here into four cases depending on whether @xmath4 begins with the full relation word @xmath35 , and whether @xmath97 begins with the full relation word @xmath90 ; these four cases will correspond respectively to conditions ( 3)-(6 ) in the statement of the lemma .",
    "* case ( 3 ) .",
    "* suppose @xmath217 and @xmath248 .",
    "then @xmath249 , so by the same argument as in case ( 1 ) we have either @xmath250 or @xmath220 as required to show that condition ( 3 ) holds",
    ".    * case ( 4 ) .",
    "* suppose @xmath242 and @xmath248 but @xmath24 is not a prefix of @xmath190 . then @xmath251 . now applying the same argument as in case ( 2 ) ( with @xmath252 in place of @xmath97 and setting @xmath253 ) we have @xmath254 so that condition ( 4 ) holds .",
    "* case ( 5 ) . *",
    "suppose @xmath217 , @xmath255 but @xmath94 is not a prefix of @xmath131 .",
    "then we have @xmath256 . now applying the same argument as in case ( 1 ) ( but with @xmath257 in place of @xmath4 and setting @xmath258 ) we obtain @xmath259 so that condition ( 5 ) holds",
    ".    * case ( 6 ) . *",
    "suppose @xmath242 , @xmath255 and that @xmath24 is not a prefix of @xmath190 and @xmath94 is not a prefix of @xmath131 .",
    "it follows this time there is a rewriting sequence taking @xmath4 to @xmath97 of the form @xmath260 where once more none of the intermediate words in the sequences indicated by @xmath239 contains a relation word overlapping with the prefix @xmath107 or @xmath84 as appropriate .",
    "now there are rewriting sequences .",
    "@xmath261 notice that , since @xmath190 does not begin with @xmath24 , we may deduce from proposition  [ prop_inactive ] that @xmath108 is @xmath24-active . by corollary  [ cor_eitheror ] , either @xmath245 or @xmath246 . in the latter case ,",
    "since @xmath108 is @xmath24-active , corollary  [ cor_actsame ] tells us that we also have @xmath245 anyway .",
    "but now @xmath262 where @xmath190 does not begin with @xmath24 , and also @xmath263 were @xmath131 does not begin with @xmath94 . by applying proposition  [ prop_inactive ] twice",
    ", we deduce that @xmath264 is both @xmath24-active and @xmath94-active .",
    "let @xmath149 be the maximal common suffix of @xmath24 and @xmath94 . then applying proposition  [ prop_coactive ] ( with @xmath265 and @xmath266 )",
    ", we see that @xmath149 is non - empty and    * @xmath230 where @xmath228 and @xmath267 ; and * @xmath231 where @xmath229 and @xmath268 .",
    "but then we have @xmath269 and also @xmath149 is a possible prefix of @xmath233 as required to show that condition ( 6 ) holds .",
    "lemma  [ lemma_eq ] gives a first clue as to how one might solve the word problem for a small overlap monoid by analysing words sequentially from left to right .",
    "the natural strategy is as follows .",
    "first , use proposition  [ prop_dumpprefix ] to reduce to the case in which the words both have clean relation prefixes of the form @xmath107 or @xmath84 . now by examining short prefixes , one can clearly always rule out at least five of the six mutually exclusive conditions of the lemma .",
    "the remaining condition will involve equivalence of words derived from suffixes of @xmath4 and @xmath97 , so apply the same approach recursively to test whether this condition is satisfied .",
    "this approach meets with several apparent obstacles .",
    "firstly , it is not clear that the words derived from the suffixes of @xmath4 and @xmath97 , which must be tested for equivalence in the recursive call , are shorter than the original words @xmath4 and @xmath97 ; for example , a relation word @xmath35 may be shorter than the maximal piece suffix @xmath94 of the word on the other side of the relation .",
    "in fact the recursive call will not always involve shorter words , but it will involve words which are simpler in a more subtle sense , so that the algorithm still terminates rapidly .",
    "secondly , some of the conditions involve a disjunction of equivalence of _ two _ pairs of words derived from the suffixes ; testing both would require two recursive calls , potentially leading to exponential time complexity .",
    "it tranpires , though , that the theory of activity and inactivity developed in section  [ sec_weakcan ] means that one recursive call will always suffice .",
    "finally , some of the conditions require us to check the possible prefixes of words derived from suffixes ; this problem is solved by the following development of lemma  [ lemma_eq ] , which gives simultaneous conditions for two words to be equal , and to admit a given piece as a possible prefix .",
    "[ lemma_eqandprefix ] suppose @xmath216 where @xmath107 is a clean overlap prefix , and suppose @xmath3 is a piece .",
    "then @xmath2 and @xmath3 is a possible prefix of @xmath4 if and only if one of the following mutually exclusive conditions holds :    * @xmath217 and @xmath218 , either @xmath219 or @xmath220 , and also @xmath3 is a prefix of either @xmath22 or @xmath270 or both ; * @xmath216 , @xmath221 , and @xmath24 fails to be a prefix of at least one of @xmath190 and @xmath131 , and @xmath222 , and also either * * @xmath3 is a prefix of @xmath22 * * @xmath3 is a prefix of @xmath270 and @xmath24 is a possible prefix of @xmath190 ; + or both ; * @xmath223 , @xmath224 and either @xmath219 or @xmath220 or both , and also @xmath3 is a prefix of @xmath22 or @xmath270 or both ; * @xmath216 , @xmath224 but @xmath24 is not a prefix of @xmath190 and @xmath225 , and also @xmath3 is a prefix of @xmath22 or @xmath270 or both ; * @xmath223 , @xmath226 but @xmath94 is not a prefix of @xmath131 and @xmath227 , and also @xmath3 is a prefix of @xmath22 or @xmath270 or both ; * @xmath216 , @xmath226 , @xmath24 is not a prefix of @xmath190 and @xmath94 is not a prefix of @xmath131 , but @xmath228 , @xmath229 , @xmath230 , @xmath231 where @xmath232 , @xmath149 is the maximal common suffix of @xmath24 and @xmath94 , @xmath149 in non - empty , @xmath149 is a possible prefix of @xmath233 , and also @xmath3 is a prefix of @xmath22 or @xmath270 or both .",
    "mutual exclusivity of the six conditions is proved exactly as for lemma  [ lemma_eq ] .",
    "suppose now that one of the six conditions above applies .",
    "each condition clearly implies the corresponding condition from lemma  [ lemma_eq ] , so we deduce immediately that @xmath2",
    ". we must show , using the fact that @xmath3 is a prefix of @xmath22 or of @xmath270 , that @xmath3 is a possible prefix of @xmath4 , or equivalently of @xmath97 .    in case ( 1 ) , if @xmath3 is a prefix of @xmath22 then it is a prefix of @xmath4 , while if @xmath3 is a prefix of @xmath270 then it is a prefix of @xmath257 which is clearly equivalent to @xmath4 . in case ( 2 ) , if @xmath3 is a prefix of @xmath22 then it is again a prefix of @xmath4 , while if @xmath3 is a prefix of @xmath270 and @xmath24 is a possible prefix of @xmath190 , say @xmath271 , then @xmath272 where the latter has @xmath3 as a prefix . in the remaining cases",
    "@xmath4 begins with @xmath22 and @xmath97 begins with @xmath270 , so @xmath3 is a prefix of either @xmath4 or @xmath97 , and hence a possible prefix of @xmath4 .",
    "conversely , suppose @xmath2 and @xmath3 is a possible prefix of @xmath4",
    ". then exactly one of the six conditions in lemma  [ lemma_eq ] applies . by lemma  [ lemma_overlap ] ,",
    "every word equivalent to @xmath4 begins with either @xmath107 or @xmath84 . since @xmath3 is a piece",
    ", @xmath22 is the maximal piece prefix of @xmath35 , and @xmath270 is the maximal piece prefix of @xmath90 it follows that @xmath3 is a prefix of either @xmath22 or @xmath270 . if any but condition ( 2 ) of lemma  [ lemma_overlap ] is satisfied , this suffices to show that the corresponding condition from the statement of lemma  [ lemma_eqandprefix ] holds .    if condition ( 2 ) from lemma  [ lemma_eq ] applies , we must show additionally that either @xmath3 is a prefix of @xmath22 , or @xmath3 is a prefix of @xmath270 and @xmath24 is a possible prefix of @xmath190 .",
    "suppose @xmath3 is not a prefix of @xmath22 .",
    "then by the above , @xmath3 is a prefix of @xmath270 .",
    "it follows from lemma  [ lemma_overlap ] , that the only way the prefix @xmath107 of the word @xmath4 can be changed using the defining relations is by application of the relation @xmath236 . in order for this to happen",
    ", one must clearly be able to rewrite @xmath273 to a word of the form @xmath274 ; consider the shortest possible rewriting sequence which achieves this . by lemma  [ lemma_overlap ] , no term in the sequence except for the last term will contain a relation word overlapping the initial @xmath107 .",
    "it follows that the same rewriting steps rewrite @xmath190 to @xmath275 , so that @xmath24 is a possible prefix of @xmath190 , as required .",
    "in this section we present an algorithm , for a fixed monoid presentation satisfying @xmath0 , which takes as input arbitrary words @xmath4 and @xmath97 and a piece @xmath3 , and decides whether @xmath2 and @xmath3 is a possible prefix of @xmath4",
    ". it will transpire that this algorithm can be implemented to run time in linear in the shorter of @xmath4 and @xmath97 .",
    "in particular , by setting @xmath276 we obtain an algorithm to solve the word problem in time linear in the smaller of the input words .",
    "the algorithm is shown ( in recursive / functional pseudocode ) in figure  1 .",
    "our first objective is to prove the correctness of the algorithm , that is , that whenever the algorithm terminates , it provides the output it gives is correct .",
    "@xmath277 or @xmath278 [ li_start_a ] @xmath277 and @xmath278 and @xmath276 [ li_allepsilon ] [ li_someepsilon ] [ li_end_a ] @xmath4 does not have the form @xmath279 with @xmath107 a clean overlap prefix @xmath4 and @xmath97 begin with different letters [ li_start_b ] [ li_uvdifferentstart ] @xmath280 and @xmath4 and @xmath3 begin with different letters [ li_updifferentstart ] @xmath281 with first letter deleted @xmath282 with first letter deleted @xmath280 @xmath283 with first letter deleted @xmath284 [ li_rec_nomop ] [ li_end_b ]    @xmath285 be such that @xmath242 [ li_start_c ]    @xmath3 is a prefix of neither @xmath22 nor @xmath270 [ li_pnotprefix ]    @xmath97 does not begin either with @xmath107 or with @xmath84 [ li_vstartswrong ]    @xmath217 and @xmath218 @xmath233 is @xmath94-active @xmath286 [ li_rec_case1a ] @xmath287 [ li_rec_case1b ]    @xmath242 and @xmath241 @xmath3 is a prefix of @xmath22 @xmath288 [ li_rec_case2a ] @xmath289 [ li_rec_case2b ]    @xmath217 and @xmath248 @xmath233 is @xmath94-active @xmath290 [ li_rec_case3a ] @xmath291 [ li_rec_case3b ]    @xmath242 and @xmath248 @xmath292 [ li_rec_case4 ]    @xmath217 and @xmath255 @xmath293 [ li_rec_case5 ]    @xmath242 and @xmath255 @xmath149 be the maximal common suffix of @xmath24 and @xmath94 @xmath181 be such that @xmath228 @xmath182 be such that @xmath229 @xmath190 does not begin with @xmath181 or @xmath131 does not begin with @xmath182 ; [ li_case6no ] @xmath233 be such that @xmath294 @xmath295 be such that @xmath296 ; @xmath297 [ li_rec_case6 ] [ li_end_c ]    [ lemma_correctness ] suppose @xmath4 and @xmath97 are words and @xmath3 a piece . then the algorithm @xmath298    * outputs @xmath299 only if @xmath2 and @xmath3 is a possible prefix of @xmath4 ; and * outputs @xmath300 only if @xmath301 or @xmath3 is not a possible prefix of @xmath4 .",
    "we prove correctness using induction on the number @xmath9 of recursive calls .",
    "consider first the base case @xmath80 , that is , where the algorithm terminates without a recursive call .",
    "suppose @xmath4 , @xmath97 and @xmath3 are such that this happens .",
    "we consider each of the possible lines at which termination may occur , establishing in each case that the output produced is correct .    * if @xmath277 , @xmath278 and @xmath276 then clearly @xmath2 and @xmath3 is a possible prefix of @xmath4 ,",
    "so the output @xmath299 is correct . *",
    "if @xmath277 [ respectively , @xmath278 ] then it follows easily from the small overlap condition @xmath0 that no relations can be applied to @xmath4 [ @xmath97 ] ; indeed a relation which could be applied to @xmath4 [ @xmath97 ] would have to have @xmath7 as one side , but @xmath7 is a piece and hence can not be a relation word .",
    "hence , we can have that @xmath2 and @xmath3 is a possible prefix of @xmath4 only if @xmath304 . in this case",
    ", this condition is not satisfied , so the output @xmath300 is correct . * in this case , @xmath4 does not begin with a clean overlap prefix of the form @xmath107 . so by proposition  [ prop_dumpprefix ] ,",
    "every word equivalent to @xmath4 must begin with the same letter as @xmath4 .",
    "hence , if @xmath4 and @xmath97 do not begin with the same letter then we can not have @xmath2 , so the output @xmath300 is correct .",
    "* again , @xmath4 does not begin with a clean overlap prefix .",
    "if @xmath3 is non - empty and begins with a different letter to @xmath4 , then again by proposition  [ prop_dumpprefix ] , @xmath3 can not be a possible prefix of @xmath4 , so the output @xmath300 is correct .",
    "* we are now in the case that @xmath4 has a clean overlap prefix @xmath107 .",
    "if @xmath3 is not a prefix of @xmath22 or @xmath270 then by lemma  [ lemma_eqandprefix ] we see that @xmath3 is not a possible prefix of @xmath4 , so the output @xmath300 is correct .",
    "* once again , we are in the case that @xmath4 has a clean overlap prefix @xmath107 .",
    "if @xmath97 does not begin with either xy or @xmath84 then by lemma  [ lemma_eq ] we can not have @xmath2 so the output @xmath300 is correct .",
    "* we are now in the case that @xmath273 and @xmath255 where @xmath24 is not a prefix of @xmath190 and @xmath94 is not a prefix of @xmath131 . we know also that @xmath149 is the maximal common suffix of @xmath24 and @xmath94 and @xmath181 and @xmath182 are such that @xmath228 and @xmath229 . by lemma  [ lemma_eqandprefix ]",
    "we can not have @xmath2 unless @xmath190 and @xmath131 have the form @xmath305 and @xmath306 respectively , so if this is not the case , the output @xmath300 is correct .",
    "now let @xmath307 and suppose for induction that the algorithm produces the correct output whenever it terminates after strictly fewer than @xmath9 recursive calls .",
    "let @xmath308 be such that the algorithm terminates after @xmath9 recursive calls .",
    "this time , we consider each of the possible places at which the first recursive call can be made , establishing in each case that the output produced is correct .",
    "* in this case @xmath4 does not begin with a clean overlap prefix of the form @xmath107 and we have @xmath309 .",
    "it follows by proposition  [ prop_dumpprefix ] that every word equivalent to @xmath4 has the form @xmath310 where @xmath311 .",
    "in particular , @xmath312 if and only if @xmath222 , @xmath3 is a possible prefix exactly if either @xmath276 or @xmath313 where @xmath314 is a possible prefix of @xmath190 . by the inductive hypothesis",
    ", the recursive call correctly establishes whether these conditions hold .",
    "* we know that @xmath217 , that @xmath218 and that @xmath3 is a prefix of @xmath22 or @xmath270 . by lemma  [ lemma_eqandprefix ]",
    ", it follows that @xmath2 and @xmath3 is a possible prefix of @xmath4 if and only if @xmath219 or @xmath220 .",
    "we also know that @xmath233 is @xmath94-active , so by corollary  [ cor_actsame ] , this is true if and only if @xmath220 . *",
    "this is the same as the previous case , except that @xmath233 is not @xmath94-active . in this case , by proposition  [ prop_inactive ] we have that @xmath220 implies @xmath232 which in turn implies @xmath219 , so it suffices to test the latter . * here we know that @xmath273 , @xmath315 , that @xmath24 is not a prefix of @xmath190 or @xmath131 and that @xmath3 is a prefix of @xmath22 .",
    "it follows by lemma  [ lemma_eqandprefix ] that @xmath2 and @xmath3 is a possible prefix of @xmath4 if and only if @xmath222 . *",
    "this time we know that @xmath273 , @xmath315 and that @xmath3 is a prefix of @xmath270 but not of @xmath22 .",
    "it follows by lemma  [ lemma_eqandprefix ] that @xmath2 and @xmath3 is a possible prefix of @xmath4 if and only if @xmath222 and @xmath24 is a possible prefix of @xmath190 . *",
    "here we have @xmath217 and @xmath248 , and @xmath3 is a prefix of @xmath22 or @xmath270 .",
    "it follows by lemma  [ lemma_eqandprefix ] that @xmath2 and @xmath3 is a possible prefix of @xmath4 if and only if either @xmath219 or @xmath220 .",
    "we also know that @xmath233 is @xmath94-active , so by corollary  [ cor_actsame ] , this is true if and only if @xmath220 .",
    "* this is the same as the previous case , except that @xmath233 is not @xmath94-active . in this case ,",
    "by proposition  [ prop_inactive ] we have that @xmath220 implies @xmath232 which in turn implies @xmath219 , so it suffices to test the latter . * if we get here , we know that @xmath242 , that @xmath248 , that @xmath24 is not a prefix of @xmath190 and that @xmath3 is a prefix of @xmath22 or @xmath270 ; it follows that @xmath2 and @xmath3 is a possible prefix of @xmath4 if and only if condition ( 4 ) of lemma  [ lemma_eqandprefix ] holds , that is , if and only if @xmath316 . by the inductive hypothesis",
    ", the recursive call will correctly estbalish if this is the case . * the argument here is symmetric to that for termination at line  [ li_rec_case4 ] . *",
    "having got here , we know that @xmath3 is a prefix of @xmath22 or @xmath270 , that @xmath273 and @xmath255 where @xmath24 is not a prefix of @xmath190 and @xmath94 is not a prefix of @xmath131 . we know also that @xmath149 is the maximal common suffix of @xmath24 and @xmath94 and @xmath181 and @xmath182 are such that @xmath228 and @xmath229 . finally , we know that @xmath230 and @xmath231 .",
    "it follows by lemma  [ lemma_eqandprefix ] that @xmath2 and @xmath3 is a possible prefix of @xmath149 if and only if @xmath232 and @xmath149 is a possible prefix of @xmath233 . by the inductive hypothesis",
    ", the recursive call correctly establishes whether this holds .",
    "we have now shown that our algorithm produces the correct output whenever it terminates , but we have not yet shown that it always terminates .",
    "in fact , the following theorem shows that it does so after only a linear number of recursive calls .",
    "[ lemma_recbound ] let @xmath317 be the length of the longest maximal piece suffix of a relation word .",
    "the number of recursive calls during execution of a call to @xmath298 is bounded above by @xmath318 .    for clarity in our analysis ,",
    "we let @xmath319 , @xmath320 and @xmath321 denote the parameters to the @xmath56th recursive call in the execution ( with in particular @xmath322 , @xmath323 and @xmath324 ) .",
    "each call to the function involves executing exactly one of the sections [ li_start_a][li_end_a ] , [ li_start_b][li_end_b ] and [ li_start_c][li_end_c ] ; we call these calls of type a , b and c respectively",
    ". we shall show that the number of calls of each of these types is bounded above by a linear function of @xmath325 so that , the total number of recursive calls is also bounded above by a linear function of @xmath325 .",
    "first , notice that a call of type a can not make a recursive call , so that is only at most one type a call in the execution .",
    "now for a word @xmath11 we let @xmath326 if @xmath11 does not have a clean overlap prefix , and @xmath327 to be the length of the part of @xmath11 which follows the shortest clean overlap prefix , that is , @xmath328 where @xmath329 with @xmath137 the shortest clean overlap prefix , otherwise .",
    "it is readily verified that if the @xmath56th recursive call is of type b and itself makes a recursive call then we have @xmath330 , while if the @xmath56th recursive call is of type c and itself makes a recursive call then we have @xmath331 .",
    "since @xmath332 can never be negative , it follows that the total number of recursive calls of type c is linearly bounded above by @xmath333 , which clearly is no more than @xmath334 .",
    "now note that if the @xmath56th recursive call is of type b and itself makes a recursive call then we have @xmath335 , while if the @xmath56th recursive call is of type c and itself makes a recursive call then we have @xmath336 .",
    "we have seen that the entire execution can not feature more than @xmath334 calls of type c or more than one call of type a. hence , if the execution involves @xmath56 recursive calls , it must include at most @xmath334 calls of type c , and at least @xmath337 calls of type b. it follows that , if execution involves @xmath56 recursive calls , we must have @xmath338 since the length of @xmath319 can not be negative , it follows that execution must terminate after at most @xmath318 calls .",
    "it remains to justify our claim that this algorithm can be implemented in linear time .",
    "since the concept of linear time is highly dependant upon model of computation , it is necessary to be precise upon the model under consideration .",
    "we consider a turing machine with two two - way - infinite read - write storage tapes , using a tape alphabet including the generators for our monoid and a separator symbol @xmath339 .",
    "( recall that a two - way - infinite tape can be simulated using a one - way - infinite tape in linear time ( * ? ? ?",
    "* section  7.5 ) , so the assumption of a two - way - infinite tape is essentially immaterial ) .",
    "if we assume that the input words @xmath4 , @xmath97 and @xmath3 are initially encoded on one of the tapes in the form @xmath340 , then it is easily seen that , with a linear amount of preprocessing , we can store the piece @xmath3 in the finite state control , and arrange for @xmath341 and @xmath342 to be the content of the first and second tape respectively .",
    "it is straightforward to verify that , given a word @xmath4 , one can check whether @xmath4 has a clean overlap prefix of the form @xmath107 , and if so find @xmath22 , @xmath23 and the corresponding @xmath24 , by analysing a prefix of @xmath4 of bounded length .",
    "similarly , for a given maximal piece suffix @xmath24 , we can check whether @xmath4 is @xmath24-active by analysing a prefix of @xmath4 of bounded length .",
    "it follows that each recursive step of our algorithm involves analysing prefixes of @xmath4 and @xmath97 of bounded length , before possibly making a recursive call , with @xmath4 and @xmath97 modified only by changing prefixes of bounded length . clearly",
    "any analysis of a bounded length prefix can be performed in constant time ; moreover , if a recursive call is required then the tape contents can be modified to contain the parameters for that call , again in constant time .",
    "it follows that the algorithm can be implemented with execution time bounded above by a linear function of the number of recursive calls in the execution , which by lemma  [ lemma_recbound ] is bounded above by a linear function of the length of @xmath4 .",
    "moreover , by swapping @xmath4 and @xmath97 at the start of the computation if necessary , we may assume without loss of generality that @xmath4 is shorter than @xmath97 .",
    "thus we obtain the following .    [ thm_lineartime ] for each every monoid presentation satisfying @xmath0 , there exists a two - tape turing machine which solves the corresponding word problem in time linear in the shorter of the input words .",
    "the reader may initially be surprised by the fact that one can test equivalence of two words in time bounded by a function of the _ shorter _ word  indeed , this bound potentially does not even afford time to fully read the longer word !",
    "however , remmers showed that , for a fixed @xmath19 presentation , the length of the longer of two equivalent words is bounded by a linear function of the length of the shorter ( * ? ? ?",
    "* theorem  5.2.14 ) .",
    "thus , if the difference in lengths of two words is too great , one may conclude without further analysis that the words are not equivalent .",
    "in fact remmers result is the only possible explanation for this phenomemon , so the fact that this property holds for @xmath0 presentations can also be deduced from theorem  [ thm_lineartime ] .",
    "in section  [ sec_algorithm ] we developed a linear time algorithm to solve the word problem for a fixed small overlap presentation .",
    "since our method of describing the algorithm was entirely constructive , one might reasonably expect that it also gives rise to a solution for the uniform word problem for @xmath0 presentations , that is the algorithmic problem of , given a @xmath0 presentation and two words , deciding whether the words represent the same element of the monoid presented . in this section",
    ", we shall see that this is indeed the case , and show that the resulting algorithm remains fast .    to avoid unnecessary technicalities ,",
    "we describe and analyse the algorithms using the ram model of computation ; in particular this allows us to assume that elementary operations involving generators from the presentation ( such as comparing two generators ) are single steps performable in constant time .",
    "the exact time complexity of a turing machine implementation would depend upon the number of tapes and the precise encoding of the input , but would certainly remain polynomial of low degree in the input size .",
    "we begin with some simple results describing the complexity of some elementary computations with a finite monoid presentation . if @xmath343 is a finite presentation we denote by @xmath344 the cardinality of the alphabet @xmath345 , and by @xmath346 the sum length of the relation words in @xmath347 .",
    "where the meaning is clear , we shall abuse notation by using @xmath347 also to denote the set of relation words in the presentation .",
    "[ prop_findprefix ] there is a ram algorithm which , given a presentation @xmath343 and a word @xmath5 , computes the maximum piece prefix ( and/or maximum piece suffix ) of @xmath5 in time @xmath348 .",
    "in particular , there is a ram algorithm to decide , given the same inmput , decides whether the word @xmath5 is a piece in time @xmath348 .    for each relation word @xmath349 and position @xmath350 in that word we can compute in time @xmath351 the length @xmath9 of the longest common prefix of @xmath5 and @xmath352 ( where @xmath353 represents the @xmath354th letter of @xmath13 ) .",
    "our machine does this for each relation word and each position in that relation word in turn , recording",
    "as it goes along ( i ) the maximum value of @xmath9 attained so far , and ( ii ) the maximum value of @xmath9 which has been attained or exceeded at least twice . the latter , upon completion , is clearly the length of the longest piece prefix of @xmath5 , and the total time taken for execution is @xmath355 as claimed . an obvious dual algorithm can be used to find the longest piece suffix of @xmath5 .",
    "there is a ram algorithm which , given as input a presentation @xmath343 , decides in time @xmath356 whether the presentation satisfies the condition @xmath0 .",
    "our machine begins by computing the maximum piece prefix @xmath17 and maximum piece suffix @xmath18 for each relation word @xmath349 ; by proposition  [ prop_findprefix ] this can be done in time @xmath357    it then tests , in time @xmath358 , whether for any of the relation words @xmath13 we have @xmath359 . if so then some relation word is a product of two pieces , so the presentation does not even satisfy the weaker condition @xmath19 and we are done .",
    "otherwise , the machine computes , again in time @xmath358 , the middle word @xmath21 of each relation word . by our remarks in section  [ sec_prelim ] , the presentation satisfies @xmath0 if and only if none of the words @xmath21 is a piece . using proposition  [ prop_findprefix ] again , this condition can be tested in time @xmath360    thus , we have described a ram algorithm to test a presentation @xmath343 for the @xmath0 condition in time @xmath356 .",
    "[ thm_ramuniform ] there is a ram algorithm which , given as input a @xmath0 presentation @xmath361 and two words @xmath362 , decides whether @xmath4 and @xmath97 represent the same element of the semigroup presented in time @xmath363    suppose we are given a @xmath0 presentation @xmath361 and two words @xmath364 . just as in the proof of proposition  [ prop_findprefix ] , the machine begins by finding for every relation @xmath13 the maximum piece prefix @xmath17 , the maximum piece suffix @xmath18 and the middle word @xmath21 , in time @xmath356 .",
    "it now has the information required to apply the algorithm given above .",
    "a simple line - by - line analysis shows that each line , and hence each recursive call , can be executed in time @xmath358 . by lemma  [ lemma_recbound ]",
    ", the number of recursive calls is bounded above by @xmath365 where @xmath317 , being the length of the longest maximum piece suffix of a relation word , is less than @xmath346 .",
    "thus , this part of the algorithm terminates in time @xmath366 .    as above we may assume , by exchanging @xmath4 and @xmath97 at the start of the computation if necessary , that @xmath367 so that @xmath368 .",
    "it follows that the uniform word problem can be solved in time @xmath369 as claimed .",
    "this research was supported by an rcuk academic fellowship .",
    "the author is grateful to v.  n.  remeslennikov , whose questions prompted this line of research and who shared many helpful ideas .",
    "he would also like to thank a.  v.  borovik for some helpful conversations , j.  b.  fountain and v.  a.  r.  gould for facilitating access to some of the relevant literature , and kirsty for all her support and encouragement ."
  ],
  "abstract_text": [
    "<S> we develop a combinatorial approach to the study of semigroups and monoids with finite presentations satisfying small overlap conditions . </S>",
    "<S> in contrast to existing geometric methods , our approach facilitates a sequential left - right analysis of words which lends itself to the development of practical , efficient computational algorithms . </S>",
    "<S> in particular , we obtain a highly practical linear time solution to the word problem for monoids and semigroups with finite presentations satisfying the condition @xmath0 , and a polynomial time solution to the uniform word problem for presentations satisfying the same condition .    </S>",
    "<S> mark kambites +    school of mathematics ,  university of manchester , + manchester m13 9pl ,  england .    ` </S>",
    "<S> mark.kambites@manchester.ac.uk ` </S>",
    "<S> +    small overlap conditions are simple and natural combinatorial conditions on semigroup and monoid presentations , which serve to limit the complexity of derivation sequences between equivalent words in the generators . </S>",
    "<S> they form a natural semigroup - theoretic analogue of the _ small cancellation _ </S>",
    "<S> conditions which are extensively used in combinatorial and computational group theory @xcite . </S>",
    "<S> it is well known that every group admitting a finite presentation satisfying suitable small cancellation conditions is _ word hyperbolic _ in the sense of gromov @xcite , and in particular has word problem solvable in linear time .    in the 1970s , remmers </S>",
    "<S> @xcite developed an elegant geometric theory of small overlap semigroups , using the natural semigroup - theoretic analogue of the _ van kampen diagrams _ extensively employed in combinatorial group theory ( see for example @xcite ) . </S>",
    "<S> he applied his methods to show that semigroups satisfying sufficiently small overlap conditions have what would now be called _ linear dehn function _ , that is , that the minimum length of a derivation sequence between any two equivalent words is bounded above by a linear function of the word lengths . in theory , it follows immediately that one can test if two words in the generators for such a semigroup are equivalent , by exhaustively searching the ( finite ) space of all applicable derivation sequences of the given length , to see if any of them transforms one word to the other . however , the number of possible derivation sequences , and hence the time complexity of this algorithm , is exponential in the word length . </S>",
    "<S> more sophisticated techniques ( such as applications of graph reachability algorithms ) are of course applicable , but the problem remains one of searching a space of exponential size , and so we can not really hope that this approach will lead to a tractable solution for the word problem . </S>",
    "<S> the question naturally arises , then , of how hard the word problem really is in these semigroups .    in this paper , we develop a new approach to the study of this important class of semigroups and monoids , along purely combinatorial lines . while our work lacks some of the mathematical elegance of remmers approach  indeed our foundational results are of a rather technical nature and our proofs mainly by case analysis  it has the advantage of permitting a _ sequential _ ( left - right ) analysis of elements , which for computational purposes seems more relevant than a geometric viewpoint . </S>",
    "<S> two computational consequences of the theory we develop are of particular interest . </S>",
    "<S> the first is a linear time ( on a two - tape turing machine ) algorithm to solve the word problem in any semigroup with a presentation satisfying remmers condition @xmath0 . </S>",
    "<S> the second is a polynomial time ( more precisely , in the ram model , quadratic in the presentation length and linear in the word length ) solution to the uniform word problem for presentations satisfying the same condition . </S>",
    "<S> while the proofs of correctness and of the time complexity bounds for these algorithms are rather technical , the algorithms themselves are quite straightforward to describe and eminently suitable for practical implementation ; the author is currently working on an implementation for the gap computer algebra system @xcite .    </S>",
    "<S> in addition to this introduction , this paper comprises five sections . in section  [ sec_prelim ] </S>",
    "<S> we briefly recall the definitions of small overlap semigroups and monoids , together with some of their properties , and introduce some notation and terminology which will be used in the rest of the paper . </S>",
    "<S> section  [ sec_weakcan ] establishes some technical , but nonetheless important , combinatorial properties of small overlap monoids , which are then used in section  [ sec_equality ] to give a sequential characterisation of equivalence for two words in the generators of a @xmath0 presentation . </S>",
    "<S> section  [ sec_algorithm ] shows how this characterisation can be used to develop a linear time algorithm for the solution of the word problem of a fixed small overlap presentation . </S>",
    "<S> finally , in section  [ sec_uniform ] we apply our techniques to the solution of the uniform word problem for @xmath0 presentations ; we also observe that one test efficiently whether an arbitrary presentation satisfies the condition @xmath0 .    </S>",
    "<S> the relationship of this work to the geometric approach developed by remmers @xcite perhaps deserves a further comment . as already mentioned , our approach to small overlap semigroups is entirely combinatorial and , in its finished state , makes no direct use of remmers geometric machinery . </S>",
    "<S> however , the author would most likely never have arrived at this viewpoint without the insight and intuition afforded by remmers approach , and the reader interested in fully understanding the present paper may find it helpful to study also remmers work in parallel . </S>",
    "<S> some of his results have been given a very accessible treatment by higgins @xcite , but unfortunately the only complete source still seems to be his thesis @xcite . </S>"
  ]
}