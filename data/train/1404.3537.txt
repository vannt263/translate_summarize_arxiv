{
  "article_text": [
    "ensuring that distributed embedded systems meet their requirements is an important and well - studied topic in industry and research . with growing system sizes and the combination of independently developed systems into larger systems of systems",
    "the interplay of different subsystems becomes an important aspect of study .",
    "when regarding embedded controllers integrated into other devices such as robots or cars , the software running on these systems does have an impact on the physical environment .",
    "potential hazards resulting from incorrect software can lead to damaged property , injuries or even loss of human lives . when combining systems that have a physical impact on an environment , one may have to study the subsystems together , since one can detect some potential hazards , e.g. , two cars driving in opposite directions , but on a single lane only in the combined system .",
    "different techniques have been introduced for modeling and checking of cyber - physical systems and their properties .",
    "these comprise differential equations , automata and different notions of time such as continuos or discrete time and others .",
    "based on these modeling approaches , tools for checking properties have been developed .",
    "the software engineering community has been studying the design and architecture of component - based systems for decades .",
    "specification formalisms like automata and message sequence charts are frequently used to describe expected behavior of systems .",
    "different means for checking these specifications are available .    in this report",
    ", we present work towards a unified approach to cyber - physical systems and component - based software development .",
    "we motivate a new framework for spatial cyber - physical behavior , communication and interaction between different components .",
    "our framework is especially suited for large - scale widely distributed systems with limited interactions between components but also allows the modeling of the precise geometric behavior of components in space .",
    "several components may be distributed over a large space and have distinct features of communication , spatial and internal behavioral aspects .",
    "we describe a process for checking properties of our models .",
    "in particular , we are focusing on spatial aspects : a component features different dimensions of possible non - deterministically occupied space , e.g. , characterizing its physical dimensions , and the reach of sensors and communication devices .",
    "we study modeling and verification scenarios which are characterized by a discrete notion of time that features _ time points _ and _ time intervals _ between them .",
    "time points are partially ordered .",
    "this allows for the modelling of synchronous and asynchronous systems with distinct synchronisation points between different components .",
    "some preliminary ideas to this report are presented in @xcite .",
    "an application of our framework in an ide for the development of reactive probabilistic systems is featured among other content in @xcite .",
    "[ [ overview ] ] overview + + + + + + + +    section  [ sec : relwork ] discusses related work .",
    "modeling of systems with our framework and examples are presented in section  [ sec : model ] .",
    "section  [ sec : reason ] describes ways to reason about our models and perform verification .",
    "section  [ sec : impl ] discusses our implementation in scala .",
    "conclusion and future work is presented in section  [ sec : concl ] .",
    "work that is relevant to this paper has been done in areas such as formal logic and process algebras , hybrid - systems , robotics and formal methods for component - based software engineering .",
    "[ [ formal - logic - and - process - algebraic - approaches ] ] formal logic and process algebraic approaches + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + +    the handbook of spatial logic @xcite discusses spatial logics , related algebras and applications . the book covers a large spectrum not only limited to computer science .",
    "a process algebra like formalism for describing and reasoning about spatial behavior has been introduced in @xcite and @xcite .",
    "process algebras come with a precise formal semantics definition and are aimed towards the specification of highly parallel systems . here , disjoint logical spaces are represented in terms of expressions by bracketing structures and carry or exchange concurrent process representations .",
    "a model checking tool for process algebra like spatial behavioral specifications is presented in @xcite .",
    "a graph - based technique for the verification of spatial properties of finite @xmath0-calculus fragments is introduced in @xcite",
    ".    for results on spatial interpretations see , e.g. , @xcite .",
    "many aspects of spatial logic are in general undecidable . a quantifier - free rational fragment of ambient logic ( corresponding to regular language constraints ) , however , has been shown to be decidable in @xcite .",
    "special modal logics for spatio - temporal reasoning go back to the seventies .",
    "the region connection calculus ( rcc ) @xcite includes spatial predicates of separation .",
    "for example rcc features predicates indicating that regions do not share points at all , points on the boundary of regions are shared , internal contact where one region is included and touches on the boundary of another from the inside , proper overlap of regions , and proper inclusion .",
    "in addition @xcite features an overview of the relation of these logics to various kripke - style modal logics , reductions of rcc - style fragments to a minimal number of topological predicates , their relationship to interval - temporal logics and decidability .",
    "[ [ hybrid - systems ] ] hybrid - systems + + + + + + + + + + + + + +    the area of hybrid systems has seen the development of different tools for reasoning and verification .",
    "spaceex @xcite allows the modeling of continuos hybrid systems based on hybrid automata .",
    "it can be used for computing overapproximations of the space occupied by an object moving in time and space .",
    "additionally , it is possible to model spatial behavior in more general purpose oriented verification tools in hybrid systems ( e.g. , @xcite ) .    [",
    "[ robotics ] ] robotics + + + + + + + +    related to our work is the work on path planning for robots ( e.g. , @xcite ) . in our work , however , we are concentrating on checking existing properties of systems rather than optimization or discovery of new possible paths .",
    "collision detection for robots in combination with motion planning has been studied for a long time , see , e.g. , @xcite and @xcite . strongly related to motion planning",
    "is the task of efficiently handling geometric reasoning . on this geometric interpretation level ,",
    "techniques have been investigated to structure the tasks of detecting possible inference between geometric objects ( e.g. , @xcite and @xcite ) for efficient analysis .",
    "[ [ data - models - and - gis - like - services ] ] data models and gis like services + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + +    data models for cyberphysical infrastructure in construction , plant automation and transport  domains that we are aiming for in this paper  have been studied in the past . unlike in this paper ,",
    "many of the existing real - world applications are aligned towards a geometric representation of components and are typically based on so - called 2.5 dimensional gis ( geographic information system ) representations where the 3rd dimension @xmath1 is represented as a function @xmath2 of the 2 dimension @xmath3 and @xmath4 coordinates .",
    "this @xcite limits the geometric , topological and information retrieval use of such models .",
    "true three dimensional modeling is far from common practice @xcite .",
    "our approach is not limited to a particular geometric representation , coordinate or dimension system .",
    "future extensions of interest include consideration of standards such as the web 3d services and the sensor web enablement architecture of the open geospatial consortium  , visualisation and decision support @xcite and efficient data structures for fast meta reasoning and presenting subproblems of choice to specialist solvers used in our examples .",
    "[ [ component - based - systems ] ] component - based systems + + + + + + + + + + + + + + + + + + + + + + +    multiple formalisms to describe component behavior can be used as specification basis for our methodology .",
    "for example the uml 2.0 @xcite standard provides message sequence charts and state machines that can be used to describe component behavior and interactions .",
    "these can be used to derive information about shared lifetimes of components and behavior .",
    "the notion of time and component interaction used in this paper is compatible with the petri - nets induced notion .",
    "this is used , e.g. , in the bip framework @xcite for modeling of distributed asynchronous systems .",
    "invariants are used as an intermediate step for verification in the bip context @xcite .",
    "invariants are also used as an intermediate representation of components in this work .",
    "we have been investigating mathematical models of behavior in space in previous work @xcite , which also features a survey on work related to these models .",
    "a prestudy of the work described in this paper is presented in @xcite .",
    "another software architectural model was proposed in @xcite .",
    "specification and reasoning on existing software component systems @xcite in the context of a type system for behavior has also been examined by us and is an important direction of future extensions of this paper . in this work",
    "we aim towards a unified view of component system aspects and verification and the introduction of space as an additional feature .",
    "symbolically reasoning about invariants of asynchronous distributed systems , which is a part of our verification methodology in this paper , has been studied by us in @xcite .",
    "this section presents the ingredients of our modeling framework for spatial behavior and examples .      here",
    ", we present four guiding examples , concurrent window cleaning , moving forklifts , communicating cars on a road network , and rotating robots .    [ [ concurrent - window - cleaning ] ] concurrent window cleaning + + + + + + + + + + + + + + + + + + + + + + + + + +        figure  [ fig : ex1 ] shows a concurrent window cleaning system .",
    "platforms @xmath5 , @xmath6 are attached to a mobile device on a roof .",
    "they can be moved horizontally by moving the mobile device on the roof and vertically through a rope .",
    "attached to each platform is a robot arm : @xmath7 and @xmath8 .",
    "it can have different positions relative to its platform , but only within a limited range .",
    "furthermore , we have some kind of internal state for each platform .",
    "the behavior of each robot is controlled by a program .",
    "this program implies behavior which is potentially non - deterministic and may depend on other robots or external events .",
    "the behavior is characterized by spatial aspects , the movement of the robot , communication aspects ( e.g. , interactions with other robots or some external controlling device ) , and internal state changes .",
    "we are interested in simulating possible window cleaning scenarios .",
    "robots have local states and when they interact with another robot their actions may undergo a synchronization .",
    "this synchronization does not need to be global , i.e. , in case of many robots cleaning a window , the synchronisation does not have to be shared with all robots .",
    "for this reason , we only have a partial order of time .",
    "each element of this partial order is called a time point .",
    "one aspect that we are interested in , is whether a certain system state implies a collision . to do this",
    ", we could examine the position of each platform and each robot arm .",
    "based on this , we could calculate the exact space boundaries that each device uses .",
    "an alternative way is to use an abstraction and use an overapproximation of the space used .",
    "more coarse grained abstractions may only have to take the position of the platforms into account .",
    "[ [ forklifts ] ] forklifts + + + + + + + + +    figure  [ fig : newex ] shows a second example .",
    "suppose that two forklifts want to drive on the pictured network of paths and perform tasks .",
    "the behavior of the two forklifts is written as follows :    * forklift 1 starts at n1 .",
    "it can continue either to n5 or via n4 to n7 in order to exit the system .",
    "this is unknown at the time the system starts . *",
    "forklift 2 starts at n2 and continues to n3 .",
    "if it can detect that n4 is occupied at will continue to n6 and than n7 .",
    "if n4 is unoccupied it will continue to n7 via n4 .",
    "forklift 2 will exit the system via n7 .",
    "further constraints apply :    * in addition to the movement in the paths network , each forklift occupies a certain amount of space and drives at a certain speed . for distinct time",
    "points it is possible to determine an area in which the forklift will reside .",
    "* additionally each forklift has a locally limited ability to detect obstacles and other forklifts .",
    "possible questions apply : 1 ) can collisions occur ?",
    "2 ) are forklifts delayed by other forklifts that can be detected and avoided ?    [ [ driving - cars ] ] driving cars + + + + + + + + + + + +    figure  [ fig : ex2 ] shows two cars @xmath9 and @xmath10 driving on a network of roads .",
    "the road network is formalized as a graph .",
    "cars have a limited ability of locally communicating with each other , iff they are within a certain distance of each other .",
    "this distance is indicated by a circle around the car in the figure .",
    "a car has a local state .",
    "this is defined by the following ingredients :    * the road section it is currently driving on : the edge of the corresponding graph . * the position on the road , e.g. , indicating the progress on the road section and the direction it is facing . * aspects of the internal state that encapsulates the parts of a state that are truly local to the car like the amount of fuel left . * communication aspects of an internal state , e.g. , states that are reached throughout an ongoing communication effort with other cars according to a protocol .",
    "one can see , that spatial , truly internal and communication aspects are encoded in the states .    for calculating the distance between two cars travelling on different roads ,",
    "we need an interpretation .",
    "we take the road edges and the position on the road into account .",
    "the topological graph information needs to be interpreted in a geometrical way .",
    "for example , we can retrieve data from a geographic information system to get the exact location on earth that allows us to compute the distance between the two cars .",
    "alternatively a car may itself keep track of the actual coordinates within its state .",
    "furthermore , we need a shared time points between the two cars so that we have access to their positions at the same time .",
    "the local communication possibilities of the cars may be used for various purposes .",
    "for example , a car might inform another car that a road has been blocked ( indicated by the x in the figure ) .",
    "the road blockage may leave a fuel station inaccessible .",
    "the other car may therefore alter a scheduled fuel stops and use another fuel station .",
    "[ [ rotating - robots ] ] rotating robots + + + + + + + + + + + + + + +    figure  [ fig : syss ] depicts an example demonstrating component movement relative to another component .",
    "it shows two robots ",
    "components @xmath9 and @xmath11 are performing circular movements .",
    "robot @xmath9 features an attachment point . in additional component @xmath10",
    ": a robot arm is attached to this attachment point . @xmath10",
    "also performs circular movements , relative to the movement of @xmath9 .",
    "a question one wants to investigate is whether a collision between @xmath11 and @xmath9 is possible .",
    "we propose the use of four different layers for modeling systems and their behavior in terms of space , internal behavior and communication .    1 .   a topological or geospatial coordinate system . in our window",
    "cleaning example this is provided by the window itself . in the communicating cars example this is provided by the topological graph representing the roads and its geographic / geometric interpretation .",
    "2 .   static components and their interconnections . in the sense of for example a street network",
    ", we can have road blocks and road construction sites as well as refuel stations . in the window cleaning example",
    ", we can have single obstacles on the surface .",
    "3 .   mobile components .",
    "these comprise the cars and robots from our examples moving within or across their allocated segment without changes in the static components structure .",
    "behavior , may be expressed using geometric expressions .",
    "4 .   information flow .",
    "this can occur between mobile and static components such as cars or robots or a fuel station .",
    "systems can evolve and change their structure and behavior .",
    "a new road may be added or a new fuel station .",
    "cars can move and communicate with each others .",
    "the layers are ordered with respect to the rate of expected changes , with layer 1 seeing the least changes and level 4 most changes over time .",
    "we allow different layers of abstractions for describing systems and their components .",
    "one can mix different specification methods to describe a widely distributed system , e.g. , for covering the interactions , spatial behavior ( topological and geometric ) and aspects of state changes within components .    [",
    "[ specification - formalisms ] ] specification formalisms + + + + + + + + + + + + + + + + + + + + + + + +    for describing components and their interactions on a requirements level , the following possibilities are reasonable :    * _ uml state charts _ , _ message sequence charts _ and _ concurrent automata _ can be used to specify the behavior of single components and their interactions .",
    "* _ process algebra terms _ can be used as another way to specify components and their interactions .",
    "* we can instrument _ pieces of program code _",
    "( e.g. , a domain specific language , but also plain scala or java code can be used ) .",
    "the instrumentation can be used to generate sequences of behavior at runtime and eventually create behavioral descriptions from them .    furthermore , for describing interactions between components , we use :    * logical formula describing events and time points implying interactions .",
    "* partially ordered sets of events or shared time points , are used to describe shared time where different components may interact with each other .",
    "[ [ components ] ] components + + + + + + + + + +    as described above , we distinguish static and mobile components , these can be aggregated into subcomponents , e.g. , an industrial robot can be made up of arm segments and a mounted tool .",
    "each subcomponent can have its own behavioral descriptions .    [",
    "[ time ] ] time + + + +    time in our models is defined by a set of time points @xmath12 and a partial order on these time points @xmath13 .",
    "each component specification is associated with a set of time points that is relevant for it .",
    "two time points can form a time interval . which can serve as a means for a safe overapproximation of behavior that is happening in between two time points .",
    "[ [ properties ] ] properties + + + + + + + + + +    in particular we are interested in properties that deal with overlapping conditions of space .    * in case of avoiding collisions we are dealing with occupied space for components . the occupied space specified in our abstractions that are the basis for verification and analysis must present an overapproximation of the space that is really used in the real - live system to derive a safe ( cf .",
    "@xcite ) result .",
    "we require that occupied space of components may overlap at no shared time point or time interval . * in case of communication possibilities , with limited ranges , we work with space that is a safe underapproximation of a sender and receiver range . here",
    ", we can require space inclusion for a set of shared time points or time intervals .",
    "we can combine safe overapproximations and underapproximations into properties , e.g. , to state that a component is always within a certain range of another component , but never comes too close ( safety margin ) given certain speed limits .",
    "we describe the verification part of our framework in this section .",
    "figure  [ fig : wf ] shows the workflow for checking the properties of models with respect to involved computation steps and tools .",
    "models and properties are given to our tool chain for checking .",
    "* in a first step , an algorithm is used to identify large scale verification goals .",
    "for example static components that are separated in space and do not interact with each other may be checked independently .",
    "the behavior of mobile components may also be checked independently if they are only acting in a local area in space or time .",
    "properties may only regard a local area and therefore only the behavior of components that act within this local area has to be taken into account .",
    "best practices for this approach can be scenario and domain specific . for determining whether one component or a property depends on another , techniques from model checking like cone - of - influence reduction @xcite can be applied .",
    "a result of this step is the identification of a set of relevant components for the desired properties .",
    "* in a next step , we compute the abstractions of behavior : _ invariants _ for all relevant components .",
    "one way to do this is to unfold all possible execution traces of an automaton , include all relevant events and annotate them with time points .",
    "these traces are than formalized as invariants .",
    "* we use these invariants to generate verification conditions in a next step .",
    "verification conditions can be checked by separate highly specialised tools like sat   and smt solvers ( e.g. , yices  @xcite or z3  @xcite ) . *",
    "the last step collects the results of used verification tools and presents an overall results .",
    "optionally , we refine invariants or verification conditions , if the result does not satisfy our needs .",
    "eventually this may lead to an iterative process : a fixpoint computation or counterexample guided abstraction refinement @xcite where invariants are the predicates .",
    "computation of invariants can be done in parallel in many cases .",
    "verification conditions never depend on each other , so they can be always checked in parallel .",
    "the checking workflow of possible interference of two components is done in the following way .",
    "first , a behavioral abstraction : an invariant is created for each component which is than broken down or combined with information from another component s invariant to derive verification conditions .",
    "these are given to a solver .",
    "here , invariants contain only overapproximations of single components and do not take restrictions due to possible interference with other components into account .",
    "thus , overapproximations are safe , but may be coarse .    for achieving more fine grained approximations , optionally , we can create logical conditions capturing the interference of components .",
    "these are invariants , too . based on them",
    ", we can create verification conditions that further restrain verification conditions derived solely from the invariants that capture the behavior of single components .",
    "our invariants capture the entire behavior of a component over time or distinct aspects of interference between components .",
    "they provide a safe overapproximation of behavior .",
    "[ [ nature - of - invariants ] ] nature of invariants + + + + + + + + + + + + + + + + + + + +    like invariants in classical hoare style loop verification , our _ spatial component invariants _ are supposed to hold over the entire execution time of a system .",
    "like loop invariants , spatial component invariants typically abstract from the actual implementation . similar to loop invariants , where variables values are often described in relation to a changing loop index",
    ", we describe the occupied or otherwise classified space and if applicable other component state based information in relation to time .",
    "[ [ invariants - for - occupied - space ] ] invariants for occupied space + + + + + + + + + + + + + + + + + + + + + + + + + + + + +    figure  [ fig : newexwsinv ] shows invariants for the second forklift in our forklift example . these overapproximate the occupation of space for time points that are associated with the nodes . furthermore , overapproximations for time intervals between time points are shown . in this case",
    "the invariants provide a geometric interpretation of the underlying graph .        here , to gain , a safe collision analysis , we must use overapproximations of the space that is actually occupied .",
    "[ [ invariants - for - communication - and - detection ] ] invariants for communication and detection + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + +    figure  [ fig : newexwcinv ] shows invariants for the second forklift in the forklift example indicating visibility ranges to detect other forklifts . in order to safely analyse detection possibilities , we need to work with underapproximations .",
    "invariants characterising time intervals are not shown , but are created from union operations between the invariants that characterize two neighbouring time points .",
    "note , that for displaying purposes , the granularity of time points in figure  [ fig : newexwsinv ] and figure  [ fig : newexwcinv ] is large . for real systems ,",
    "the boxes are much closer together , so that safe overapproximations can be much tighter to the actual system behavior .",
    "[ [ invariants - for - interplay - between - components ] ] invariants for interplay between components + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + +    on an abstract view , we can associate interaction possibilities between components with events .",
    "events can also be associated with detection of obstacles or external interactions .",
    "these events can be used in invariants , to characterize interactions between components .",
    "such a formula can have the form :    @xmath14 time point @xmath15 event @xmath16 @xmath17 occupied space & other actions    we can create invariants that describe aspects of interactions between components . some possible conditions on triggering events can have the forms    time point @xmath18 event + or + @xmath14 time point @xmath15 event @xmath16 @xmath18 event +    combining these invariants can be done by intersection with other invariants characterizing the behavior of a single component in order to restrain its behavior and derive more refined verification conditions that are given to solvers .    [ [ aggregating - subcomponents ] ] aggregating subcomponents + + + + + + + + + + + + + + + + + + + + + + + + +    we can aggregate subcomponents into larger components . likewise , we can integrate their invariants .",
    "figure  [ fig : ex1a ] shows invariants characterizing occupied space for a given point in time for the cleaning platforms from figure  [ fig : ex1 ] .",
    "the right side displays invariants for subcomponents like the actual platform , the robot arm and the tool while the left side displays a safe overapproximation of the combined system .",
    "[ [ term - based - representations - of - invariants ] ] term based representations of invariants + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + +    we represent invariants syntactically as terms .",
    "invariants are built from predicates that are combined using function symbols like logical operators .",
    "an invariant that characerizes the spatial behavior of a single component has the form :    ... + @xmath19 + @xmath20 + @xmath21 + ... +    for non linear time , the @xmath22 index is replaced by a more complex time point indicating the node in the graph characterizing the partial order of time points .",
    "we can perform operations on invariants like the merging of time points into time intervals thereby transforming it into another syntactic representation . for the example above this",
    "is realized as follows :    ... + @xmath23 + @xmath24 + @xmath25 @xmath26 + @xmath27 + @xmath28 + @xmath29 @xmath30 + ...    here , @xmath18 and @xmath15 are function symbols of the term .",
    "the @xmath31 is a function that performs an interpretation and yields a subterm representing a semantic union of its arguments .",
    "furthermore , we have operations that comprise simplifications , abstractions , normalizations and assigning and removing ownership",
    " means to indicate that space belongs to a distinct component  to occupied space .",
    "contrary to abstractions we have interpretations on the invariant level , e.g. , for assigning a geometry to parts of topological or high - level component representations , thereby lifting invariants to a more concrete level .",
    "[ [ generating - invariants ] ] generating invariants + + + + + + + + + + + + + + + + + + + + +    invariants may be directly encoded or generated in the following ways from spatial behavioral specifications .    * _ unfolding of automata to generate timed conditions in invariants . _",
    "if we are only interested in checking a limited time span , this is straight forward . for periodically repeating behavior , we can group time points into equivalence classes for a finite invariant that describes the infinite behavior .",
    "a special case of automata unfolding are sequences of states that a system component has gone through during a simulation .",
    "these sequences can be generated from other tools such .",
    "* _ instrumentation of code pieces to generate timed conditions in invariants at runtime during a testing phase of a system .",
    "_ here , we have to ensure that we cover all relevant aspects of a system , because we are in danger of getting an unsafe underapproximation of the behavior",
    ". however , regarding the behavior of robots , it seems reasonable to exhaustively catch all spatial movements of a robot without having exhausted the robot s software state space . *",
    "_ transformation of specifications on a symbolical / semantical level .",
    "_ this involves symbolic analysis of the program code that controls a distributed system and the extraction of invariants based on them .",
    "[ [ abstractions - using - invariants ] ] abstractions using invariants + + + + + + + + + + + + + + + + + + + + + + + + + + + + +    we can use abstraction on the invariant level to facilitate later verification tasks . for space , we can use boxes to over- or underapproximate more detailed structures .",
    "figure  [ fig : bbo ] shows a screenshot of a box based overapproximation in the rotating robots example for collision detection .                 here",
    ", the exact amount of space for segments of robot components is automatically abstracted using overapproximations .",
    "we connect different tools including sat and smt solvers to our framework .",
    "verification conditions are generated from invariants so that a property can be verified and the input is suitable for the particular tool .",
    "[ [ predicate - based - space - conditions ] ] predicate based space conditions + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + +    in our invariants we can use predicates to characterize the occupation of space for a distinct time point or time interval . as an example : each point indicating the occupation of a square on a plane can be identified using a predicate . by doing so",
    ", space occupied by different components can be made comparable on the invariant level . shown in figure",
    "[ fig : predunf ] is the unfolding of a predicate characterizing the occupation of a box specified by an upper left and a lower right pair of coordinates .",
    "1.2 cm @xmath32 + @xmath33 + @xmath34 + @xmath35 + @xmath36 + @xmath37    the resulting representation can be compared with unfolded invariants of other components .",
    "this comparison must be made for each shared time point or time interval between components and can by either given to a sat solvers or can by realized by a small algorithm implemented in scala in our framework .",
    "[ [ space - conditions - based - on - inequalities ] ] space conditions based on inequalities + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + +    a second way of comparing different invariants that characterize geometric occupation of space is to generate for each shared time point a geometric formula characterizing the potential overlapping of occupied space .",
    "for example , two components @xmath38 and @xmath39 specified with a spatial occupation specified by boxes with upper left and lower right coordinates as given below :    @xmath40 , @xmath41 , + @xmath42 , @xmath43    where each component is given by a function that depends on a time parameter @xmath44 we generate the following :    @xmath45  @xmath46 + @xmath47 + @xmath48 + @xmath49 + @xmath50    a solution characterizes the overlapping at any shared time point .",
    "if no solution exists , there is no overlapping .",
    "we can use this as a verification condition thereby unfolding the @xmath51 and treating multiple time points or generate an independent verification condition for each time point .",
    "here , we describe some features of our framework that we have implemented and evaluated .      invariants and operations on them",
    "are encoded using abstract data type style _",
    "case classes _ from the scala language .",
    "[ [ basic - constructs ] ] basic constructs + + + + + + + + + + + + + + + +    to give a look and feel , a small excerpt of the abstract datatypes in scala is given below :    .... abstract class invariant ;    abstract class atom extends invariant ;    case class or ( t1 : invariant , t2 : invariant )      extends invariant ; case class and ( t1 : invariant , t2 : invariant )       extends invariant ; case class not ( t : invariant ) extends invariant ; case class implies ( t1 : invariant , t2 : invariant )       extends invariant ;          ... case class bigor ( t : list[invariant ] ) extends invariant ; case class bigand ( t : list[invariant ] ) extends invariant ;          ... case class timepoint [ t](timepoint : t )      extends atom ;   case class timeinterval [ t ]   ( timepoint1 : t , timepoint2 : t )      extends atom ;   case class event[e ] ( event : e ) extends atom ;          ... case class occupy3dbox     ( x1 : int , y1 : int , z1 : int ,      x2 : int , y2 : int , z2 : int ) extends atom ; case class occupysegment3d     ( x1 : int , y1 : int , z1 : int ,     x2 : int , y2 : int , z2 : int , radius : int )        extends atom ; case class occupy3dpoint ( x : int , y : int , z : int )        extends atom ....    the excerpt shows only some logical operations , time ( the actual type used for representing time is parameterized t , any type with a partial order is suitable ) and geometric constructs for an euclidian space .",
    "some abbreviations for different levels of modeling and easier automatic processing can be seen .",
    "for example , the bigor and bigand constructs are semantically equivalent to nested and and or constructs .",
    "[ [ ownership - of - geometric - structures ] ] ownership of geometric structures + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + +    we support the ownership of geometric structures to identify structures that belong to a specific aspect of an entity .",
    "for example , the following constructors are available :    .... case class ownbox[c ] ( owningcomponent : c , x1 : int , y1 : int , x2 : int , y2 : int ) extends atom ;   // a box that is owned by a component .          ...",
    "case class ownpoint[c ] ( owningcomponent : c , x : int , y : int ) extends atom ....    [ [ relative - time - points - and - symbolic - integer - values ] ] relative time points and symbolic integer values + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + +    in addition to absolute time , we also allow the specification of time relative to an event ( event relative time point ertp ) and the use of symbolic values as integers for coordinates ( type si .",
    "geometric constructs making use of these types are provided .",
    "for example , the following constructors are available :    .... abstract class timepoint ;    abstract class ertp ; //",
    "event relative time point    case class tertp [ e , t ] ( event : e , offset : t ) extends ertp ; case class intertp [ e](event : e , offset : int ) extends ertp ;     abstract class si ; //",
    "symbolicint case class si_c ( c : int ) extends si ; case class si_add ( i1 : si , i2 : si ) extends si ; case class si_sub ( i1 : si , i2 : si ) extends si ; case class si_times ( i1 : si , i2 : si ) extends si ; case class si_var [ v](v : v ) extends si          ... case class occupyboxsi ( x1 : si , y1 : si , x2 : si ,",
    "y2 : si ) extends atom ;   //",
    "symbolic coordinates , alternative concept to eroccupybox case class eroccupybox (     x1 : ( ertp = > int),y1 : ( ertp = > int ) ,     x2 : ( ertp = > int),y2 : ( ertp = > int ) ) extends atom ;   // coordinates depending on an event relative time point ....    [ [ specification - example ] ] specification example + + + + + + + + + + + + + + + + + + + + +    a very small example for an invariant encoded in scala describing only the possible movement of a forklift in the graph shown in figure  [ fig : newex ] is presented below ( here , some more abstract representation occupynode is chosen ) :    ....    val topologicalinvariant_fl2 : invariant =      and ( and ( and (        implies(timepoint(\"pt1\"),occupynode(\"n2 \" ) ) ,         implies(timepoint(\"pt2 \" ) ,           or ( occupynode(\"n3\"),occupynode(\"n4 \" ) ) ) ) ,         implies(timepoint(\"pt3 \" ) ,           or ( occupynode(\"n6\"),occupynode(\"n7 \" ) ) ) ) ,        implies(timepoint(\"pt4\"),occupynode(\"n7 \" ) ) ) ;   ....    only 4 different time points and no geometric interpretation are encoded .",
    "in realistic examples , we use functions that build abstract datatypes comprising thousands of constructors based .",
    "the construction can be based on parameters to characterize different behaviors and interaction possibilities of different components .",
    "parameterized specifications can be created by scala functions that create distinct formalizations based on their parameters .",
    "[ [ lifting - of - a - workpiece ] ] lifting of a workpiece + + + + + + + + + + + + + + + + + + + + + +    figure  [ fig : wplift ] shows a grapple hook lifting a workpiece .",
    "the behavior of the hook and the workpiece is formalized in besl .            here ,",
    "a grapple hook consists of four subcomponents : the two arms for holding the workpiece on the sides , a components that links the two arms and a chain that can be lowered or raised to position the hook .",
    "the workpiece is just formalized as a single component .",
    "[ [ parameterized - lifting - invariants ] ] parameterized lifting invariants + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + +    we have experimented with different behavioral descriptions for the hook .",
    "one parameterized description for one of the arms is given below .",
    "it formalizes the behavior of for 200 time points .",
    "the speed can be given as a parameter .",
    "furthermore , the lifting may be stopped for a given point in time .",
    ".... def invariantr3(speed : float , stoppointup : int ) : invariant = {      var inv : list[invariant ] = nil ;             for ( i < - 0 to 100 ) {        inv : : = ( implies(timestamp ( i ) ,             occupysegment(300,200+(i*speed).toint,320,200+(i*speed).toint,3 ) ) )          }      for ( i < - 0 to 100 ) {            if ( i < stoppointup ) {                inv : : = ( implies(timestamp ( i+101 ) ,                         occupysegment (                       300 ,                       200+(100*speed).toint-(i*speed).toint ,                       320 ,                       200+(100*speed).toint-(i*speed).toint,3 ) ) )                     } else {                inv : : = ( implies(timestamp ( i+101 ) ,                         occupysegment (                       300 ,                       200+(100*speed).toint-(stoppointup*speed).toint ,                       320 ,                       200+(100*speed).toint-(stoppointup*speed).toint,3 ) ) )                       }      }      return ( bigand(inv ) ) ; } ....    a 3d version of the workpiece lifting is shown in figure  [ fig : grab3d ] .",
    "it contains an abstraction of segment descriptions based on 3d boxes .",
    "we have implemented the checking of component invariants for possible collisions . as a more realistic example and",
    "means for measuring performance we have regarded two invariants for collisions where each invariant comprises 1000 different time point entries and associated geometric occupied space .    1 .",
    "breaking the invariants down to smt verification conditions where one verification condition is generated per time point and calling the smt solver takes between 20 and 25 seconds . 2 .   breaking the invariants down to a single smt verification condition and checking can be performed in slightly less then one second .",
    "3 .   breaking the invariants down to verification conditions each one comprising 15000 predicates indicating the occupation of single points for one invariant and 20000 predicates indicating the occupation of single points for the second invariant for each time point can be done in at most 7 - 8 seconds . here , a hashset based java implementation is used . in case of early collision detection",
    "the checking time can be significantly less .    from experiments 1 and 2",
    "one can be seen that it is usually a good idea to encode as many information as possible into an smt formula , since the overhead of calling it is significant .",
    "if higher resolutions are used , the single points abstractions in the third experiment performance decreases linear with the amount of points used .",
    "the third experiment can be done using a sat solver , this takes significantly longer , due to the higher complexity of sat formula compared to the java hashset and the less abstraction power compared to the smt based approach .",
    "collisions have to be checked between each two components for each shared time point or time interval .",
    "our notion of time allows the characterization of components that will never interfere , so the amount of components that one has to check for a time point does depend on the application scenario .",
    "analysing whether a time point or time interval is shared or not can be based on requirements and specification documents . to achieve a safe result , we must use an overapproximation of shared time points and time intervals .",
    "furthermore , it is possible that components have a non - deterministic behavior . in that case , we need to adapt out smt conditions for the experiments one and two or use the approach based on the experiment three and add all possible occupied point to the hashset .",
    "[ [ visualization ] ] visualization + + + + + + + + + + + + +    in our framework single invariants and scenarios consisting of multiple invariants can be graphically depicted as demonstrated in the figures throughout the report . in figure  [ fig:3dinv ]",
    "the x and y coordinates of three objects spaces are plotted against the time .",
    "we presented work towards a unified approach to cyber - physical systems and component - based software development by motivating a new framework concentrating on spatial aspects of cyber - physical systems .",
    "we described a process for checking properties of our models and described the approach using different examples .",
    "different directions for future work and ongoing work comprise : 1 ) taking the parallel checking of our models into account and implementing it for a suitable platform .",
    "2 ) offering soa based services for spatial modeling and checking .",
    "3 ) building a spatial behavioral type system for components following our previous ideas @xcite .",
    "another more academic area of future work is reasoning about spatial properties in proof assistants like coq or isabelle @xcite . here",
    ", we are aiming at 1 ) connecting proof assistants as additional reasoning tools to manually verify concrete properties at an invariant or verification condition level that are undecidable 2 ) derive meta - results on the process of getting from models to invariants and verification conditions .",
    "b. bennett , a. g. cohn , f. wolter , m. zakharyaschev . multi - dimensional modal logic as a framework for spatio - temporal reasoning . applied intelligence , volume 17 , issue 3 , kluwer academic publishers , november 2002 .",
    "j. o. blech .",
    "towards a framework for behavioral specifications of osgi components .",
    "formal engineering approaches to software components and architectures .",
    "electronic proceedings in theoretical computer science , 2013 .",
    "j. o. blech , y. falcone , h. rue , b. schtz .",
    "behavioral specification based runtime monitors for osgi services . leveraging applicationsof formal methods , verification and validation ( isola ) , vol .",
    "7609 of lncs , springer , 2012 .",
    "l. caires and h. torres vieira .",
    "slmc : a tool for model checking concurrent systems against dynamical spatial logic specifications .",
    "tools and algorithms for the construction and analysis of systems .",
    "springer , 2012 .",
    "the complexity of robot motion planning . mit press , cambridge , 1988 .",
    "f. gadducci and a. lluch lafuente",
    ". graphical verification of a spatial logic for the @xmath0-calculus . \" electronic notes in theoretical computer science 154.2 , 2006 .",
    "s. gottschalk , m. c. lin , d. manocha , s. gottschalk , m. c. lint , d. manocha .",
    "obb - tree : a hierarchical structure for rapid interference detection .",
    "acm siggraph , 171 - 180 , 1996 .",
    "f. han , j. o. blech , p. herrmann , h. schmidt . towards verifying safety properties of real - time probabilistic systems .",
    "formal engineering approaches to software components and architectures , 2014 .",
    "_ to appear _",
    "f. a. kraemer and p. herrmann .",
    "service specification by composition of collaborations  an example .",
    "international conference on web intelligence and intelligent agent technology .",
    "ieee , 2006 .",
    "robot motion planning .",
    "kluwer academic publishers , 1991 .      c. loiseaux , s. graf , j. sifakis , a. bouajjani and s. bensalem .",
    "property preserving abstractions for the verification of concurrent systems .",
    "formal methods in system design , volume 6 issue 1 , kluwer academic publishers , 1995 .",
    "g. frehse , c. le guernic , a. donz , s. cotton , r. ray , o. lebeltel , r. ripado , a. girard , t. dang , o. maler .",
    "spaceex : scalable verification of hybrid systems .",
    "computer aided verification ( cav11 ) , 2011 .",
    "a. platzer , j - d . quesel .",
    "keymaera : a hybrid theorem prover for hybrid systems ( system description ) . international joint conference on automated reasoning , vol .",
    "5195 of lncs , pages 171 - 178 .",
    "springer , 2008 .",
    "a. troynikov and h. schmidt .",
    "designing robust fault tolerant systems with shape .",
    "improving systems and software engineering conference incorperating sepg@xmath52 asia - pacific conference 2012 , melbourne , august 2012 .    c. weaver , d. peuquet , a. m. maceachren .",
    "stnexus : an integrated database and visualization environment for space - time information exploitation .",
    "http://www.geovista.psu.edu/publications/2005/weaver_arda_05.pdf , 2005 ."
  ],
  "abstract_text": [
    "<S> in this report , we present work towards a framework for modeling and checking behavior of spatially distributed component systems . design goals of our framework are the ability to model spatial behavior in a component oriented , simple and intuitive way , the possibility to automatically analyse and verify systems and integration possibilities with other modeling and verification tools . </S>",
    "<S> we present examples and the verification steps necessary to prove properties such as range coverage or the absence of collisions between components and technical details . </S>"
  ]
}