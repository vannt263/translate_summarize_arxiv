{
  "article_text": [
    "searching ordered lists is one of the most fundamental and most studied problems in the theory of algorithms . given an ordered list and some element ,",
    "the ordered search problem is to find the index of that element .",
    "we  are interested the quantum black  box complexity of searching , which is a quantum analogue of the decision tree complexity .    formally , the input is a sorted boolean list of size  @xmath0 and the problem is to find the index of the leftmost  1 .",
    "we  assume that the list is given as a black  box , so the only way we can obtain information about the list is via queries .",
    "the input to a query is an index and the output is the bit of the list at that index .",
    "we  assume that not all values of the list are  0 and hence the problem is always well - defined .",
    "the classical query complexity of this problem is , as is well known , exactly @xmath6 .",
    "farhi , goldstone , gutmann and sipser  @xcite have shown that on a quantum computer , we can solve this problem using only roughly @xmath3 queries .",
    "the previously best known lower bound is due to ambainis  @xcite who recently proved that @xmath7 queries are required .",
    "we  improve this lower bound to @xmath1 which is about @xmath8 .",
    "thus , a speedup by a constant factor somewhere between @xmath9 and @xmath10 is achievable .",
    "there are at least three reasons why the quantum complexity of the ordered searching problem seems to be of interest .",
    "firstly because of its significance in algorithmics in general . secondly because the problem possesses some symmetries and periodicities of a different nature than previously studied problems in quantum algorithmics .",
    "determining symmetries and periodicities seems to be a primary ability of quantum computers and it is not at all clear how far - reaching this skill  is .",
    "thirdly because ordered searching represents a non - boolean non - symmetric function .",
    "a  ( partial ) function is said to be symmetric if for each possible hamming weight , the function is either not defined for any input of that hamming weight , or it takes the same value on all inputs of that hamming weight . searching ordered lists",
    "is not such a problem since it is only defined for exactly  1 input of each hamming weight .",
    "only few non - trivial quantum bounds for non - boolean non - symmetric functions are known .",
    "we  prove our lower bound of @xmath1 by utilizing what we refer to as a weighted all - pairs inner product argument .",
    "we  hope that this proof technique , which extends previous work by especially bennett , bernstein , brassard and vazirani  @xcite and ambainis  @xcite , will be of use elsewhere .",
    "we  first give a description of our proof technique in  section  [ sec : blackbox ] , by utilizing which we prove a general lower bound in section  [ sec : general ] .",
    "we  then apply the technique to ordered searching in section  [ sec : search ] .    in  section",
    "[ sec : upper ] , we give a new quantum algorithm for ordered searching .",
    "our algorithm is exact and uses @xmath4 queries , which is roughly @xmath5 .",
    "this is better than classically , but not as good as the currently best known algorithm which requires only roughly @xmath3 queries  @xcite .",
    "whereas most quantum algorithms is based on fourier transform and amplitude amplification , our algorithm can be viewed as a quantum version of the classical ( binary search ) algorithm .",
    "our main idea is to run several applications of the binary search algorithm in quantum parallel , and let them find the element in teamwork .",
    "we let some applications concentrate primarily on some parts of the inputs , meanwhile other applications concentrate primarily on other parts of the input . depending on where the searched element is",
    ", this implies that some applications learn a great deal ( about where the element is ) , whereas others learn only little .",
    "we  then , as our main trick , use a method for letting the different applications learn from each other , in the sense that the applications that know the most about the input inform the other applications , hereby letting everybody learn a great deal about the input . letting the different applications work",
    "as a team allows us reduce the complexity from @xmath11 to roughly @xmath12 .",
    "finally , we conclude in section  [ sec : conclusion ] with some remarks and open questions .",
    "we  use the so - called black  box model in which the input is given as an oracle and our measure of complexity is the number of queries to the oracle  @xcite . fix some positive integer @xmath13 .",
    "the input @xmath14 is given as an oracle , and the only way we can access the bits of the oracle is via queries .",
    "a  query implements the operator @xmath15 here @xmath16 and @xmath17 are non - negative integers . by  a query to oracle  @xmath18 we mean an application of the unitary operator  @xmath19 .",
    "we  sometimes refer to  @xmath19 as the oracle .",
    "a  quantum algorithm  @xmath20 that uses @xmath21 queries to an oracle  @xmath22 is a unitary operator of the form @xmath23 we  always apply algorithm  @xmath20 on the initial state  @xmath24 , and after applying  @xmath20 , we always measure the final state in the computational basis .",
    "thus , a quantum algorithm for oracle quantum computing is defined by specifying a unitary operator  @xmath25 and a number of iterations  @xmath21 .",
    "our model for oracle quantum computing is slightly different from , but equivalent to , the `` standard '' model used for example in  @xcite .",
    "we  favor utilizing this model , since hereby oracle  @xmath19 is a diagonal matrix with respect to the computational basis .",
    "consider the computation of some function @xmath26 .",
    "after applying quantum algorithm  @xmath20 on  @xmath24 , we measure the @xmath27 rightmost qubits of  @xmath28 and output the outcome  @xmath29 .",
    "the success probability @xmath30 of  @xmath20 on input  @xmath31 is defined as the probability that @xmath32 . for complete functions",
    "@xmath26 , we define the success probability of  @xmath20 as the minimum of @xmath30 over all @xmath31 . for partial functions @xmath33 , where @xmath34 , we take the minimum over  @xmath35 only .",
    "there is a key conceptual idea which is used in this paper and which we would like to emphasize , and that is that we are concerned about _ distinguishing _ oracles rather than _ determining _ the value of the function  @xmath36 .",
    "this is a line of thought that we have learned primarily from ettinger  @xcite and farhi , goldstone , gutmann and sipser  @xcite .",
    "thus the general question we are interested in is that of distinguishing operators as opposed to distinguishing states or computing functions .",
    "we  now give our version of such an approach applied to black  box computing .",
    "the basic observation is that some oracles are easier to distinguish between than others .",
    "intuitively , it is easier to distinguish between the oracle @xmath37 of all zeros and the oracle @xmath38 of all ones , than it is to distinguish between two oracles of almost the same hamming weight .",
    "one reason for a problem to be hard , is if we want to distinguish between oracles of almost the same hamming weight . in  general ,",
    "if  a problem is hard , it is because that there are some pairs of oracles that are hard to distinguish .",
    "other pairs of oracles might be easy to distinguish , but that may not necessarily lower the complexity of the problem .    for a given problem",
    "we therefore want to identify the _ pairs of oracles _ that are hard to _",
    "distinguish_. this idea is applicable when proving lower as well as upper bounds . to  capture the hardness of distinguishing each pair of oracles ,",
    "we introduce a _ weight function _ @xmath39 that takes non - negative real values .",
    "the harder an oracle  @xmath18 is to distinguish from an oracle  @xmath40 , the more weight we put on the pair  @xmath41 .",
    "the total weight  @xmath42 distributed is the sum of @xmath43 over all pairs @xmath44 .",
    "we  do not want to put any restrictions on  @xmath45 in general , though for many applications we probably want @xmath45 to be symmetric , normalized and take the value  0 along the diagonal .",
    "the weight function allows us to easily capture any complete as well as partial function .",
    "let @xmath46 be a function of interest , where @xmath34 .",
    "we  say that _",
    "@xmath45 is a weight function for  @xmath36 _ if whenever @xmath47 then @xmath48 , and if for every pair @xmath49 we have @xmath48 .",
    "hereby , we may ignore  @xmath36 and just consider the scenario in which we are given weight function  @xmath45 .",
    "the first general technique for proving lower bounds for quantum computing was introduced by bennett , bernstein , brassard and vazirani in their influential paper  @xcite .",
    "their beautiful technique is nicely described in vazirani s exposition  @xcite .",
    "our technique is a natural generalization of theirs , but it can also be viewed as a generalization of ambainis powerful entanglement lower bound approach recently proposed in  @xcite ( provided one casts his technique using a language similar to the one used in  @xcite and here ) .    here is the basic idea : consider a quantum algorithm @xmath50 that we use to distinguish between two oracles @xmath51 .",
    "our initial state is  @xmath24 .",
    "after @xmath52  iterations , our state is @xmath53 if we are given oracle  @xmath18 , and it is @xmath54 if we are given oracle  @xmath40 .",
    "two quantum states are distinguishable with high probability if and only if they are almost orthogonal .",
    "if  the states @xmath55 and @xmath56 have large overlap , then they can not be distinguished with high probability , and hence more queries are required . if  a query can separate two states @xmath55 and  @xmath56 by only a small additional amount , then many queries are required .",
    "we  have to choose how to measure the overlap of states among the plentiful studied measures .",
    "we  pick here the probably most simple possibility : inner products .",
    "two states can be distinguished with certainty if and only if their inner product is zero .",
    "furthermore , two states can be distinguished with high probability if and only if their inner product is of small absolute value .",
    "[ lm : epsilon ] suppose that we are given one of two states @xmath57 .",
    "there exists some measurement that will correctly determine which of the two states we are given with error probability at most  @xmath58 if and only if @xmath59 .",
    "we  are not only interested in distinguishing two particular oracles , but many oracles , and thus we will use an `` all - pairs inner product '' measure .",
    "but as we discussed in the previous section , some oracles are harder to distinguish than others , and this leads us to our final choice : we use an _ all - pairs inner product measure weighted by  @xmath45_. we  now formalize this approach .",
    "let @xmath50 be any quantum algorithm .",
    "for every oracle @xmath31 and every integer @xmath60 , let @xmath61 denote the state of the computer after applying @xmath52 iterations using oracle  @xmath19 .",
    "for every integer @xmath62 , let @xmath63 denote the weighted all - pairs inner product after @xmath52 iterations .",
    "initially , the total weight is @xmath64 .",
    "after @xmath21 iterations , the total weight is @xmath65 . if algorithm  @xmath20 is capable of distinguishing with certainty between all pairs of oracles @xmath66 of nonzero weight , then @xmath67 .",
    "conversely , if @xmath68 then there exists some pair of oracles @xmath41 with @xmath69 between which algorithm  @xmath20 does not distinguish perfectly .    in  summary ,",
    "initially all inner products are  1 and the initial weight is therefore  @xmath42 , whereas at the end of the computation all inner products are hopefully small and the final weight  @xmath70 is therefore small .",
    "if  the total weight can decrease by at most @xmath71 by each query , we require at least @xmath72 queries to perfectly distinguish between all pairs of oracles of nonzero weight .",
    "[ thm : general ] let @xmath73 be a given function where @xmath34 , and let @xmath74 be a weight function for  @xmath36 .",
    "let @xmath50 be any quantum algorithm that computes  @xmath36 with error at most  @xmath75 using @xmath21 queries .",
    "then @xmath76 where @xmath77 denotes the initial weight , and @xmath71 is an upper bound on @xmath78 for all @xmath79 .    by  definition , @xmath64 , and by lemma",
    "[ lm : epsilon ] , @xmath80 .",
    "write @xmath81 as a telescoping sum .",
    "then @xmath82 , and the theorem follows .",
    "our formulation of theorem  [ thm : general ] has been heavily inspired by the general formulations used by ambainis in  @xcite . in  @xcite , bennett , bernstein , brassard and vazirani",
    "are interested in distinguishing one unique oracle  @xmath83 from all other oracles .",
    "that is , for every pair of oracles @xmath66 of interest , we have  @xmath84 .",
    "ambainis  @xcite removes this restriction , and he also allows a non - uniform interest in different oracles by weighting each oracle individually .",
    "we  are also interested in distinguishing general pairs of oracles , but we discriminate our interest in each pair by weighting each _ pair of oracles _ via weight function  @xmath45 .",
    "this discrimination is essential in our application to ordered searching .",
    "searching ordered lists is a non - boolean promise problem : the list is promised to be sorted , and the answer is an index , not a bit .",
    "formally , the set  @xmath35 of @xmath0 possible inputs consists of all @xmath31 for which @xmath85 and @xmath86 for all @xmath87 .",
    "the search function @xmath33 is defined by @xmath88 , where we identify the result @xmath89 with its binary encoding as a bit - string of length @xmath90 .",
    "the classical query complexity of this problem is , as is well known , exactly @xmath6 .",
    "the best known quantum algorithm for this problem requires roughly @xmath3 queries and is due to farhi , goldstone , gutmann and sipser  @xcite .",
    "the first lower bound of @xmath91 was proved by buhrman and de  wolf  @xcite by an ingenious quantum reduction from the or problem .",
    "farhi , goldstone , gutmann and sipser  @xcite improved this to @xmath92 , and ambainis  @xcite then recently proved the previous best known lower bound of @xmath7 . in  @xcite ,",
    "they use , as we do here , an inner product argument along the lines of  @xcite .",
    "the first and essential step in our lower bound is to pick a good weight function  @xmath45 for  @xmath36 .",
    "we  choose @xmath93 that is , we use the inverse of the hamming distance of @xmath18 and  @xmath40 .",
    "intuitively , a weight function that ( only ) depends on the hamming distance ought to be a good choice since it can put most weight on pairs of oracles that are almost identical .",
    "the initial weighted all - pairs inner product is @xmath94 where @xmath95 denotes the @xmath16th harmonic number .",
    "note that @xmath96 for all @xmath97 .",
    "since any query can decrease the weighted all - pairs inner product by at most  @xmath98 , our main theorem follows by applying theorem  [ thm : general ] .",
    "[ lm : search ] for weight function  @xmath45 defined by eq .",
    "[ eq : weight ] , we have that @xmath99 for all @xmath100 .",
    "any quantum algorithm for ordered searching that errs with probability at most  @xmath75 requires at least @xmath101 queries to the oracle . in  particular , any exact quantum algorithm requires more than @xmath1 queries .",
    "we  end this section by given our proof of lemma  [ lm : search ] .",
    "lemma  [ lm : search ] for any oracle @xmath31 , we will think of  @xmath18 as an infinite bit - string where @xmath102 for all @xmath103 .",
    "operator  @xmath19 defined by eq .",
    "[ eq : oracle ] is then given  by @xmath104 let @xmath105 denote the identity operator .",
    "for every @xmath106 , let @xmath107 denote the projection operator onto the subspace querying the @xmath16th oracle bit .",
    "let @xmath108 .",
    "by  definition @xmath109{x , y \\in \\{0,1\\}^n } }     \\sum_{i : x_i \\neq y_i\\vphantom{\\}^n } }     { \\ensuremath{\\omega}}(x , y)\\ ; { \\mbox{$\\langle \\psi_x^j |{{{\\mathsf{p}}}}_i| \\psi_y^j \\rangle$}}.\\end{aligned}\\ ] ] for every @xmath110 and @xmath111 , let @xmath112 , where @xmath31 is such that @xmath113 ( @xmath114 for answer ) .",
    "then @xmath115 where @xmath116 denotes the complex conjugate of  @xmath117 .",
    "rewrite the above equation in terms of distances @xmath118 , @xmath119 for every @xmath120 , let @xmath121 denote the total mass that queries the oracle at @xmath16  index - positions above and below the leftmost  1 . by  the cauchy ",
    "schwarz inequality , @xmath122    the right hand side is the written - out product of 3  matrices .",
    "let @xmath123 $ ] and @xmath124^t$ ] , where @xmath125 denotes transposition , and let @xmath126 denote the @xmath127 matrix with entry @xmath128 defined  by @xmath129 for all @xmath130 .",
    "then @xmath131 where @xmath132 denotes the induced matrix norm .",
    "since @xmath133 , we have that @xmath134 .",
    "matrix  @xmath126 is a hankel matrix , and its norm is upper bounded by the norm of the @xmath127 hilbert matrix @xmath135 defined by @xmath136 for all @xmath130 .",
    "the norm of any hilbert matrix is upper bounded by  @xmath137 ( see for example  @xcite for a neat argument ) , and hence @xmath138 .",
    "in  this section , we sketch the main elements in our new quantum algorithm for ordered searching .",
    "first , we give some general remarks , outline the main parts and discuss the intuition behind the algorithm .",
    "we then , in subsection  [ subsec : analysis ] , comment on parts of the analysis of its complexity .",
    "our algorithm is exact and requires only @xmath4 queries to the oracle .",
    "our algorithm bear many resemblances to the classical binary search algorithm .",
    "all unitary transformations are `` nice '' in the sense that the algorithm only uses @xmath139 operations ( also referred to as controlled - not ) and rotations by multiples of angle  @xmath140 .",
    "the requirements to the resolution of the rotations in the algorithm are thus moderate .    in  the algorithm , we use a very important idea of _ explicitly known bits of the oracle_. if  the algorithm can increase the number of explicitly known bits by a factor of  @xmath141 by each query , then we obtain a complexity of @xmath142 .    consider an application of the classical binary search algorithm on an oracle @xmath143 of length @xmath144 . by  definition of the ordered search problem we are promised that @xmath145 and that @xmath146 for all @xmath147 .",
    "we  say that a bit of the oracle is _ explicitly known _ if the classical algorithm can output the value of that bit with certainty for all possible input oracles .",
    "initially , only the bit @xmath148 is explicitly known ( since we are promised that @xmath145 ) . after the first query , the bit @xmath149 is also explicitly known , and after the second query , the bits @xmath150 are explicitly known , since independently of which oracle the algorithm is given , it knows the value of these four bits with certainty . finally ,",
    "after the third and last query , all 8  bits are explicitly known .",
    "since it is important for what follows , please do not confuse bits that are _ explicitly known _ with bits who s value",
    "can be deduced only for _ some _ oracles . as  an example",
    ", suppose we run the classical binary search algorithm on oracle  @xmath18 for which @xmath151 and @xmath152 .",
    "after the second query , the classical binary search algorithm knows that @xmath153 and that @xmath152 . from this , it can deduce the values of all 8 bits , but @xmath154 .",
    "however , it is only the values of the four bits @xmath150 that can be deduced no matter what oracle is given as input , and thus it is only these four bits we consider explicitly known .",
    "the concept of explicitly known bits for the classical binary search algorithm is very simple : for an input of length @xmath155 , after @xmath52 queries , there are exactly @xmath156 bits explicitly known , these being @xmath157 .",
    "the concept of explicitly known bits for our quantum algorithm is almost as simple and it is defined below .",
    "our quantum algorithm is , in many senses , simply to run many copies of ( variations of ) the classical binary search algorithm in quantum parallel .",
    "every basis state in every one of the superpositions we ever obtain , has a natural classical interpretation as being the state of a classical computer running some classical search algorithm .",
    "therefore , we shall often refer to basis states of a superposition as  _ computers_. the point being that every basis state can be thought of as the state of a classical computer in the middle of searching . by  making queries in quantum parallel",
    "we achieve that some of the computers know more about where in the list the shift from to  is .",
    "these computers then communicate their knowledge to the rest of the computers in the superposition .    with this",
    ", we can define we mean by explicitly known bits for our quantum algorithm : _ we  say that a computer in a superposition explicitly knows a bit if it knows the value of that bit regardless of which oracle the algorithm is given as input .",
    "_ to  illustrate what we hereby mean , consider the previous example in which we are given an oracle @xmath143 of length @xmath144 with @xmath151 and @xmath152 .",
    "suppose that we have superposition of 4  computers .",
    "we  want to find the shift from to in the oracle .",
    "suppose that 2  of the computers explicitly know 4  bits ( the bits 2 , 4 , 6 , and  8) , that 1  computer explicitly knows 2  bits ( bits 4 and  8) and that 1  computer explicitly knows only 1  bit ( bit  8) .",
    "the following sequence of operations illustrates how we , using only a single query , combine the 4  computers so they all know 8  bits . @xmath158",
    "\\begin{array}{r } \\sqrt{2}{\\mbox{$| x_6 \\rangle$}}{\\mbox{$| 5$--$8\\rangle$}}\\\\ \\sqrt{2}(-1)^{x_5}{\\mbox{$| 1 \\rangle$}}{\\mbox{$| 5$--$6\\rangle$ } } \\end{array } \\overset{{{\\mathsf{v}}}^{(4)}}{\\longrightarrow } \\begin{array}{r } \\sqrt{2}{\\mbox{$| 0 \\rangle$}}{\\mbox{$| 5$--$6\\rangle$}}\\\\ \\sqrt{2}(-1)^{x_5}{\\mbox{$| 1 \\rangle$}}{\\mbox{$| 5$--$6\\rangle$ } } \\end{array } \\overset{{{\\mathsf{u}}}^{(2)}}{\\longrightarrow } \\begin{array}{r } \\sqrt{4}{\\mbox{$| x_5 \\rangle$}}{\\mbox{$| 5$--$6\\rangle$ } } \\end{array } \\overset{{{\\mathsf{v}}}^{(2)}}{\\longrightarrow } \\begin{array}{r } \\sqrt{4}{\\mbox{$| 0 \\rangle$}}{\\mbox{$| 6$--$6\\rangle$}}. \\end{array}\\end{gathered}\\ ] ] we  have here ( without loss of generality ) assumed that the query operator  @xmath159 is such that all computers but the one that knows the least have their answers given in the phase of their amplitudes .",
    "the computer that knows the least is given the answer directly into its leftmost qubit .",
    "to  be able to combine the knowledge from several computers we have them distribute their explicitly known bits in a certain way . in figure",
    "[ f2]a it is shown how we for each one of 4 computers distribute 11 explicitly known bits so that after 1  iteration all 4  computers explicitly know 32  bits .",
    "the distribution is so that we divide the list into 4 sublists of equal size , where we for each sublist distribute 11 bits as shown in figure  [ f2]b .",
    "similarly , if we have @xmath160 computers , we divide the list into @xmath160 sublists of equal size . in  general , the more computers we use , the more sublists we have , and the more explicitly known bits each computer needs to have .      in  each iteration of the algorithm , we utilize 2  operators , and , where is used to combine 2  computers and makes a computer ready for the next operator , which is defined as follows .",
    "@xmath161 here @xmath162 is a single bit , @xmath163  is a power of  2 , and @xmath164 and  @xmath165 are the endpoints of an interval .",
    "we use the operator defined by eq .",
    "[ trick ] as in the following @xmath166 where is an interval , is the bit at the middle of the interval , @xmath167 and @xmath168 are real - valued amplitudes satisfying @xmath169 , and is a superposition orthogonal to and .",
    "the operators @xmath170 are defined  by @xmath171 we  always use operator @xmath170 as in the following , @xmath172 each operator @xmath170 takes a interval and the value of the bit  @xmath173 in the middle of that interval , and chooses the upper part of that interval if @xmath174 , and chooses the lower part if @xmath175 .",
    "the operators are applied to the state in the following fashion @xmath176    assume that we have @xmath177 computers which have distributed their explicitly known bits in a way such that we obtain @xmath178 sublists .",
    "the shift from 0s to 1s in the list is in one and only one of these sublists .",
    "consider the sublist containing the shift .",
    "first all computers make a query to the oracle in quantum parallel .",
    "then we combine the computers using the 2  operators @xmath179 and  @xmath170 .",
    "these operators are applied @xmath180 times after a query . after applying this sequence of operations all computers know where in the sublist the shift is . as  we have seen @xmath170 changes the name of the computers so that they can be combined .",
    "operator  @xmath179 combine 2 ( sets of ) computers .",
    "suppose that after the application of operator with , say , @xmath181 the state is @xmath182 we now apply the operator which gives us the state @xmath183 and after the application of operator we have @xmath184 from this we can verify that all computers obtain the explicit knowledge of @xmath185 bits ( in this sublist ) after @xmath186 applications of and @xmath180 of . since the operators @xmath179 and @xmath170 are unitary it follows that the operator given by eq .",
    "[ iteration ] is unitary .    to be able to apply the iteration again after another query",
    ", one must make the above iteration in a superposition so that there now is a superposition of computers that have their explicitly known bits distributed in a structure resembling figure  [ f2 ] .",
    "we explain how this is done , including other omitted parts , in the final version of this paper .",
    "our routine described above can be utilized to increase to number of known bits by a factor of almost  3 by each iteration .",
    "consider figure  [ f2](a ) . in this figure , we use 4 computers , one corresponding to each of the 4 rows .",
    "each of the 4 computers knows 11 bits ( 1 + 2 + 4 + 4 ) before the iteration , whereas after the iteration , all of them know 32 bits .",
    "thus , using only 1  query , we increase the number of known bits from 11 to  32 .    in  general",
    ", starting with @xmath177 computers , each of them explicitly knows @xmath187  bits of the oracle , where @xmath187 is given  by @xmath188 after 1  iteration , all of the @xmath178 computers will know @xmath189 bits .",
    "thus , with just 1  iteration we go from having @xmath190 known bits to having @xmath191 known bits , an expansion factor of almost  3 .",
    "given any value of  @xmath187 we can decompose it into the @xmath192 number system and obtain an expansion factor of almost  3 .",
    "for integer  @xmath187 , write @xmath193 where @xmath194 for @xmath195 , with @xmath196 . using 1  query , we expand @xmath187 known bits into @xmath197 known bits where @xmath198 we achieve an expansion factor of @xmath199",
    "the inner product of two quantum states is a measure for their distinguishability .",
    "for instance , two states can be distinguished with certainty if and only their inner product is  0 . in  this paper , we have introduced a weighted all - pairs inner product argument as a tool for proving lower bounds in the quantum black  box model .",
    "we  have used this argument to give a better and also simpler lower bound of @xmath1 for quantum ordered searching .",
    "it  seems to us that the possibility of using non - uniform weights is particular suitable when proving lower bounds for non - symmetric ( possibly partial ) functions .",
    "we  have chosen here to use inner products which is only one of the many studied measures for distinguishability of states .",
    "a  striking example of the limitations of using this measure is given by jozsa and schlienz in  @xcite .",
    "in  @xcite , zalka uses a non - linear measure to prove the optimality of grover s algorithm  @xcite . communicating knowledge between computers or basis states .",
    "it  could be instructive to studying if this view on quantum computation could be useful in constructing quantum algorithms for other problems . either in the sense if it is possible quantumly to speed up classical algorithms for other problems ( where amplitude amplification does not apply ) or if it is possible in solutions for other problems to take advantage of communication between computers ."
  ],
  "abstract_text": [
    "<S> we  prove that any exact quantum algorithm searching an ordered list of @xmath0  elements requires more than @xmath1 queries to the list . </S>",
    "<S> this improves upon the previously best known lower bound of @xmath2 . </S>",
    "<S> our proof is based on a weighted all - pairs inner product argument , and it generalizes to bounded - error quantum algorithms .    </S>",
    "<S> the currently best known upper bound for exact searching is roughly @xmath3 . </S>",
    "<S> we  give an exact quantum algorithm that uses @xmath4 queries , which is roughly @xmath5 . </S>",
    "<S> the main principles in our algorithm are an quantum parallel use of the classical binary search algorithm and a method that allows basis states in superpositions to communicate . </S>"
  ]
}