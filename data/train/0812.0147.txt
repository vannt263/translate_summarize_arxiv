{
  "article_text": [
    "a cnf formula over the variables @xmath0 is a conjunction of clauses @xmath1 where each clause is a disjunction of one or more literals .",
    "each literal is either a variable or its negation .",
    "a formula is said to be in @xmath2-cnf form if every clause contains exactly @xmath2 literals .",
    "a cnf formula is satisfiable if there is a boolean assignment to the variables such that every clause contains at least one literal which evaluates to true .",
    "3sat , the language of all satisfiable 3cnf formulas , is well known to be np - complete @xcite .",
    "hstad  @xcite proves that it is np - hard to approximate max-3sat ( the problem of finding an assignment that satisfies as many clauses as possible ) within a ratio better than 7/8 ( which is the expected number of clauses satisfied by a random assignment ) .",
    "the plethora of worst - case np - hardness results for many interesting optimization problems motivates the study of heuristics that give `` useful '' answers for `` typical '' subset of the problem instances , where `` useful '' and `` typical '' are usually not well defined .",
    "one way of evaluating and comparing heuristics is by running them on a collection of input instances ( `` benchmarks '' ) , and checking which heuristic usually gives better results .",
    "though empirical results are sometimes informative , we seek more rigorous measures of evaluating heuristics .",
    "one possibility of rigourously modeling such `` average '' instances is to use random models .    in this paper",
    "we analyze the performance of ( for brevity ) , a popular message passing algorithm , when applied to satisfiable formulas drawn from a certain random distribution over satisfiable 3cnf formulas , commonly called the planted distribution .",
    "we show that the standard way of running message passing algorithms ",
    "run message passing until convergence , simplify the formula according to the resulting assignment , and satisfy the remaining subformula , if possible , using a simple  off the shelf \" heuristic  works for planted random satisfiable formulas with a sufficiently large yet constant clause - variable ratio .",
    "the effectiveness of message passing algorithms was _ experimentally _ shown for  hard \" formulas @xcite , for which other heuristics fail ; however no rigorous analysis backs up these results .",
    "our result is the first to rigorously prove the effectiveness of a message passing algorithm for the solution of a non - trivial random sat distribution .",
    "algorithmic theory of random structures has been the focus of extensive research in recent years ( see @xcite for a survey ) . as part of this trend ,",
    "* uniformly random 3cnfs * ( generated by selecting at random @xmath3 clauses over the variables @xmath4 ) have attracted much attention .",
    "random 3cnfs are known to have a sharp satisfiability threshold in the clause - variable ratio @xcite .",
    "namely , a random 3cnf with clause - variable ratio below the threshold is satisfiable @xmath5 ( with high probability , meaning with probability tending to 1 as @xmath6 goes to infinity ) and one with ratio above the threshold is unsatisfiable @xmath5 .",
    "this threshold is not known exactly ( and not even known to be independent of @xmath6 ) .",
    "the threshold is known to be at least 3.52 @xcite and at most 4.506 @xcite .",
    "experimental results indicate that the threshold is closer to the higher end of the interval @xcite .    in this work",
    "we mainly consider formulas with large clause - variable ratio . at such ratios almost all 3cnf formulas",
    "are not satisfiable , therefore more refined definitions are due .",
    "we consider the * planted distribution * , denoted throughout by @xmath7 .",
    "a random 3cnf in this distribution is obtained by first picking an assignment @xmath8 to the variables , and then including every clause satisfied by @xmath8 with probability @xmath9 , thus guaranteeing that the resulting instance is satisfiable . throughout",
    ", we use @xmath8 to denote the planted assignment when the relevant instance is clear from context .",
    "planted - solution distributions are favored by many researchers , e.g. @xcite in the context of 3sat , and also for other graph problems such as the of planted clique , planted bisection , planted coloring , and planted bipartite hypergraphs studied e.g. in @xcite .",
    "is a simple iterative message passing algorithm , and serves as an excellent intuitive introduction to more involved message passing algorithms such as @xcite and @xcite .",
    "these algorithms are based on the _ cavity method _ in which the messages that a clause ( or a variable ) receives are meant to reflect a situation in which a `` cavity '' is formed , namely , the receiving clause ( or variable ) is no longer part of the formula .",
    "messages in the algorithm can be interpreted as `` warnings '' , telling a clause the values that variables will have if the clause `` keeps quite '' and does not announce its wishes , and telling a variable which clauses will not be satisfied if the variable does not commit to satisfying them .",
    "we now present the algorithm in a formal way .",
    "let @xmath10 be a cnf formula .",
    "for a variable @xmath11 , let @xmath12 be the set of clauses in @xmath10 in which @xmath11 appears positively ( namely , as the literal @xmath11 ) , and @xmath13 be the set of clauses in which @xmath11 appears negatively .",
    "for a clause @xmath14 , let @xmath15 be the set of variables that appear positively in @xmath14 , and respectively @xmath16 for negative ones .",
    "there are two types of messages involved in the algorithm .",
    "messages sent from a * variable * @xmath17 to a * clause * @xmath18 in which it appears : @xmath19 if @xmath20 appears only in @xmath21 then we set the message to 0 . the intuitive interpretation of this message should be @xmath20 signals",
    "@xmath21 what is currently its favorable assignment by the other clauses it appears in ( a positive message means true , negative one means false and a 0 message means unassigned ) .",
    "the second type are messages sent from a * clause * @xmath18 to a * variable * @xmath17 appearing in @xmath21 : @xmath22 where @xmath23 is an indicator function which is 1 iff @xmath24 ( respectively @xmath25 ) .",
    "if @xmath21 contains only @xmath20 ( which can not be the case in 3cnf formulas ) then the message is set to 1 .",
    "@xmath26 can be intuitively interpreted as @xmath18 sending a _ warning _ to @xmath20 asking it to commit to satisfying @xmath21 ( as all other literals signaled @xmath21 that currently they evaluate to false ) .",
    "lastly , we define the current assignment of a variable @xmath20 to be @xmath27 if @xmath28 then @xmath11 is assigned true , if @xmath29 then @xmath20 is assigned false , otherwise @xmath20 is unassigned .",
    "assume some order on the clause - variable messages ( e.g. the lexicographical order on pairs of the form @xmath30 representing the message @xmath31 ) .",
    "given a vector @xmath32 in which every entry is the value of the corresponding @xmath33 message , a partial assignment @xmath34 can be generated according to the corresponding @xmath35 values ( as previously explained ) .      given a 3cnf formula @xmath10 on @xmath6 variables and @xmath36 clauses , the _ factor graph _",
    "( e.g. @xcite ) of @xmath10 , denoted by @xmath37 , is the following graph representation of @xmath10 .",
    "the factor graph is a bipartite graph , @xmath38 where @xmath39 ( the set of variables ) and @xmath40 ( the set of clauses ) . @xmath41",
    "iff @xmath20 appears in @xmath21 . for a 3cnf @xmath10 with @xmath36 clauses it holds that @xmath42 , because every clause contains exactly 3 different variables .",
    "( here and elsewhere , @xmath43 denotes the cardinality of a set @xmath44 .",
    "the notation @xmath45 will denote the absolute value of a real number @xmath46 . )",
    "it would be convenient to think of the messages in terms of the corresponding factor graph .",
    "every undirected edge @xmath47 of the factor graph is replaced with 2 anti - parallel directed edges , @xmath48 associated with the message @xmath49 and respectively the edge @xmath50 .",
    "@xmath51 @xmath52 + @xmath53 @xmath54 + @xmath55 + @xmath56 + @xmath57 + @xmath58 @xmath54 + @xmath59 @xmath60 @xmath61 + @xmath62 + @xmath63 @xmath64 @xmath65 @xmath35 @xmath66 + @xmath67 @xmath64 .",
    "+ in the above description it might seem as it no update of variable - clause messages is carried out",
    ". however , these updates are implicit in line ` 3.b ` .",
    "namely , when evaluating the clause - variable message along the edge @xmath68 , @xmath69 , the variable - clause messages concerning this calculation ( @xmath70 ) are evaluated on - the - fly using the last updated values @xmath71 , @xmath72 ( allowing feedback from the same iteration ) .",
    "we allow the algorithm not to terminate ( the clause - variable messages may keep changing every iteration ) .",
    "if the algorithm does return an assignment @xmath64 then we say that it converged . in practice",
    "it is common to limit in advance the number of iterations , and if the algorithm does not converge by then , return a failure .",
    "currently , the  @xcite algorithm experimentally outperforms all known algorithms in finding satisfying assignments to uniformly random 3cnf formulas with clause - variable ratio @xmath73 close to the satisfiability threshold ( @xmath74 ) .",
    "however , theoretical understanding of and other message passing algorithm for random sat problems is still lacking .",
    "this should be compared with the success of message passing algorithms for decoding low - density - parity - check ( ldpc ) codes  @xcite . here , the experimental success of message passing algorithms  @xcite was recently complemented rigourously by a large body of theoretical work , see e.g.  @xcite .",
    "some important insights emerge from this theoretical work .",
    "in particular , it is shown that the quality of decoding improves exponentially with the number of iterations  thus all but a small constant fraction of the received codeword can be decoded correctly using a constant number of iterations .",
    "our analysis of on @xmath7 shows that much of the coding picture is valid also for @xmath7 thus providing important insights as to the success of message passing algorithms for random satisfiability problems .",
    "the planted 3sat model is similar to ldpc in many ways .",
    "both constructions are based on random factor graphs . in codes , the received corrupted codeword provides noisy information on a single bit or on the parity of a small number of bits of the original codeword . in @xmath7 , @xmath8 being the planted assignment , the clauses containing a variable @xmath20 contain noisy information on the polarity of @xmath75 in the following sense  each clause contains @xmath20 in a polarity coinciding with @xmath75 with probability @xmath76 .",
    "the sat setting is however more involved than its coding counterpart ; for example a sat instance may have many satisfying assignments ( which is @xmath5 the case in @xmath7 with clause - variable ratio of order @xmath77 ) whereas a transmitted codeword has a unique true solution .",
    "more discussion follows in section [ resutlssubs ] .    as for relevant results in random graph theory , the seminal work of alon and kahale @xcite paved the road towards dealing with large - constant - degree planted distributions .",
    "@xcite present an algorithm that @xmath5 @xmath2-colors planted @xmath2-colorable graphs ( the distribution of graphs generated by partitioning the @xmath6 vertices into @xmath2 equally - sized color classes , and including every edge connecting two different color classes with probability @xmath78 ; commonly denoted @xmath79 ) with a sufficiently large constant expected degree .",
    "building upon the techniques introduced in @xcite , chen and frieze @xcite present an algorithm that 2-colors large constant degree planted 3-uniform bipartite hypergraphs , and flaxman @xcite presents an algorithm for satisfying large - constant clause - variable ratio planted 3sat instances .",
    "though in our analysis we use similar techniques to the aforementioned works , our result is conceptually different in the following sense . in @xcite",
    "the starting point is the planted distribution , and then one designs an algorithm that works well under this distribution .",
    "the algorithm may be designed in such a way that makes its analysis easier .",
    "in contrast , our starting point is a given message passing algorithm ( ) , and then we ask for which input distributions it works well . we can not change the algorithm in ways that would simplify the analysis .",
    "this is similar in spirit to the work of  @xcite who showed that rwalksat works on very sparse uniformly random 3cnf instances ( for which other simple heuristics are also known to work ) , and to the work in  @xcite , where a certain version of the @xmath2-opt heuristic is shown to work on @xmath7 .",
    "another kind of interplay between algorithms and random distributions is involved in the work on the lower end of the satisfiability threshold .",
    "much of it is based on the analysis of simple heuristics , often too simple to be of practical value ( e.g. , in  @xcite the pure - literal heuristic is used for very sparse uniformly random 3cnf instances ) .",
    "another difference between our work and that of @xcite is that unlike the algorithms analyzed in those other papers , is a randomized algorithm , a fact which makes its analysis more difficult .",
    "we could have simplified our analysis had we changed to be deterministic ( for example , by initializing all clause - variable messages to  1 in step  2 of the algorithm ) , but there are good reasons why is randomized . for example , it can be shown that ( the randomized version ) converges with probability  1 on 2cnf formulas that form one cycle of implications , but might not converge if step  4 does not introduce fresh randomness in every iteration of the algorithm ( details omitted ) .",
    "given a 3cnf @xmath10 , * simplify * @xmath10 according to @xmath64 , when @xmath64 is a partial assignment , means : in every clause substitute every assigned variable with the value given to it by @xmath64 . if a clause contains a literal which evaluates to true , remove the clause . from the remaining clauses ,",
    "remove all literals which evaluate to false .",
    "the resulting instance is not necessarily in 3cnf form , as clauses may have any number of literals between  0 and  3 .",
    "denote by @xmath80 the 3cnf @xmath10 simplified according to @xmath64 . note that @xmath80 may contain empty clauses , in which case it is not satisfiable .",
    "for a set of variables @xmath81 , denote by @xmath82 $ ] the set of clauses in which all variables belong to @xmath44 .    to better understand our results",
    "it would be convenient to have the somewhat informal notion of a _ simple formula _ in mind .",
    "we call a 3cnf formula simple , if it can be satisfied using simple well - known heuristics ( examples include very sparse random 3cnf formulas which are solvable @xmath5 using the pure - literal heuristic @xcite , formulas with small weight terminators  to use the terminology of @xcite  solvable @xmath5 using rwalksat , etc ) .    [ convergencethmmed ]",
    "let @xmath10 be a 3cnf formula randomly sampled according to @xmath7 , where @xmath83 , @xmath84 a sufficiently large constant",
    ". then the following holds @xmath5 ( the probability taken over the choice of @xmath10 , and the random choices in lines 2 and 4 of the algorithm ) .",
    "there exists a satisfying assignment @xmath85 ( not necessarily the planted one ) such that :    1 .",
    "@xmath86 converges after at most @xmath87 iterations .",
    "2 .   let @xmath64 be the partial assignment returned by @xmath86 , let @xmath88 denote the variables assigned to either true or false in @xmath64 , and @xmath89 the variables left unassigned .",
    "then for every variable @xmath90 , @xmath91 . moreover , @xmath92 .",
    "3 .   @xmath80 is a simple formula which can be satisfied in time @xmath93 .",
    "theorem  [ convergencethmmed ] relates to the planted 3sat model , but as recent results show @xcite , it also applies to the random 3sat distribution , in which first a random 3cnf is generated by selecting every clause with probability @xmath9 , independently of the others , and then conditioning on satisfiability ( or selecting @xmath3 clauses uniformly at random and conditioning on satisfiability ) .",
    "details omitted .",
    "[ convergencepropdense ] let @xmath10 be a 3cnf formula randomly sampled according to @xmath7 , where @xmath94 , with @xmath95 a sufficiently large constant , and let @xmath8 be its planted assignment .",
    "then @xmath5 after at most 2 iterations , @xmath86 converges , and the returned @xmath64 equals @xmath8 .",
    "it is worth noting that formulas in @xmath7 , with @xmath96 some large constant , are not known to be simple ( in the sense that we alluded to above ) .",
    "for example , it is shown in @xcite that rwalksat is very unlikely to hit a satisfying assignment in polynomial time when running on a random @xmath7 instance in the setting of theorem [ convergencethmmed ] .",
    "comparing our results with the coding setting , the effectiveness of message passing algorithms for amplifying local information in order to decode codes close to channel capacity was recently established in a number of papers , e.g.  @xcite .",
    "our results are similar in flavor , however the combinatorial analysis provided here allows to recover an assignment satisfying _ all _ clauses , whereas in the random ldpc codes setting , message passing allows to recover only @xmath97 fraction of the codeword correctly . in @xcite",
    "it is shown that for the erasure channel , all bits may be recovered correctly using a message passing algorithm , however in this case the ldpc code is designed so that message passing works for it .",
    "we on the other hand take a well known sat distribution and analyze the performance of a message passing algorithm on it , without changing either of them to ease - up the analysis .",
    "moreover , the sat setting is more involved , as there are many assignments satisfying the formula , while for the erasure channel there is a unique codeword satisfying the combinatorial constraints given by the message .",
    "the remainder of the paper is structured as follows .",
    "section [ sec : intuition ] provides an overview that may help the reader follow the more technical parts of the proofs . in section [ propofrandominstsection ]",
    "we discuss some properties that a typical instance in @xmath7 possesses . using these properties , we prove in section [ resultsproofsection ] theorem [ convergencethmmed ] and proposition [ convergencepropdense ] . in section [ discussionsec ]",
    "we summarize our results and discuss potentially interesting lines for further research .",
    "let us first consider some possible fixed points of the warning propagation ( wp ) algorithm .",
    "the _ trivial _",
    "fixed point is the one in which all messages are * 0*. one may verify that this is the unique fixed point in some cases when the underlying 3cnf formula is very easy to satisfy , such as when all variables appear only positively , or when every clause contains at least two variables that do not appear in any other clause . a _ local maximum _",
    "fixed point is one that corresponds to a strict local maximum of the underlying max-3sat instance , namely to an assignment @xmath98 to the variables in which flipping the truth assignment of any single variable causes the number of satisfied clauses to strictly decrease .",
    "the reader may verify that if every clause @xmath14 sends a * 1 *  message to a variable if no other variable satisfies @xmath14 under @xmath98 , and a * 0 *  message otherwise , then this is indeed a fixed point of the wp algorithm .",
    "needless to say , the wp algorithm may have other fixed points , and might not converge to a fixed point at all .",
    "recall the definition of @xmath7 .",
    "first a truth assignment @xmath8 to the variables @xmath99 is picked uniformly at random .",
    "next , every clause satisfied by @xmath8 is included in the formula with probability @xmath78 ( in our case @xmath100 , @xmath84 a sufficiently large constant ) .",
    "there are @xmath101 clauses satisfied by @xmath8 , hence the expected size of @xmath10 is @xmath102 ( when @xmath84 is constant , then this is linear in @xmath6 , and therefore such instances are sometimes referred to as _ sparse",
    "_ 3cnf formulas ) . to simplify the presentation , we assume w.l.o.g .",
    "( due to symmetry ) that the planted assignment @xmath8 is the all - one vector .    to aid intuition , we list some ( incorrect ) assumptions and analyze the performance of wp on a @xmath7 instance under these assumptions .    1 .   in expectation , a variable appears in @xmath103 clauses positively , and in @xmath104 clauses negatively .",
    "our first assumption is that for every variable , its number of positive and negative appearances is equal to these expectations . 2 .",
    "we say that a variable _ supports _ a clause with respect to the planted assignment ( which was assumed without loss of generality to be the all * 1 *  assignment ) if it appears positively in the clause , and the other variables in the clause appear negatively .",
    "hence the variable is the only one to satisfy the clause under the planted assignment . for every variable in expectation there are roughly @xmath105 clauses that it supports .",
    "our second assumption is that for every variable , the number of clauses that it supports is equal to this expectation .",
    "3 .   recall that in the initialization of the algorithm , every clause - variable message @xmath106 is 1 w.p .",
    "@xmath107 , and 0 otherwise .",
    "our third assumption is that with respect to every variable , half the messages that it receives from clauses in which it is positive are initialized to  1 , and half the messages that it receives from clauses in which it is negative are initialized to  1 .",
    "recall that in step 3b of , clause - variable messages are updated in a random order .",
    "our fourth assumption is that in each iteration of step  3 , the updates are based on the values of the other messages from the previous iteration , rather than on the last updated values of the messages ( that may correspond either to the previous iteration or the current iteration , depending on the order in which clause - variable messages are visited ) .",
    "put differently , we assume that in step 3b all clause - variable messages are evaluated in _ parallel_.    observe that under the first two assumptions , the planted assignment is a local maximum of the underlying max-3sat instance . we show that under the third and fourth assumption , converges to the corresponding local maximum fixed point in two iterations .",
    "based on the initial messages as in our third assumption , the messages that variables send to clauses are all roughly @xmath108 . following the initialization , in the first iteration of step  3",
    "every clause @xmath14 that @xmath11 supports will send @xmath11 the message 1 , and all other messages will be 0 .",
    "here we used our fourth assumption .",
    "( without our fourth assumption , may run into trouble as follows .",
    "the random ordering of the edges in step 3 may place for some variable @xmath11 all messages from clauses in which it appears positively before those messages from clauses in which it appears negatively . during the iteration , some of the messages from the positive clauses may change from 1 to 0 . without our fourth assumption ,",
    "this may at some point cause @xmath11 to signal to some clauses a negative rather than positive value . )",
    "the set of clause - variable messages as above will become a fixed point and repeat itself in the second iteration of step 3 .",
    "( for the second iteration , the fourth assumption is no longer needed . )",
    "hence the algorithm will terminate after the second iteration .",
    "unfortunately , none of the four assumptions that we made are correct .",
    "let us first see to what extent they are violated in the context of proposition  [ convergencepropdense ] , namely , when @xmath84 is very large , significantly above @xmath109 .",
    "standard concentration results for independent random variables then imply that the first , second and third assumptions simultaneously hold for all variables , up to small error terms that do not effect the analysis .",
    "our fourth assumption is of course never true , simply because we defined differently .",
    "this complicates the analysis to some extent and makes the outcome depend on the order chosen in the first iteration of step 3a of the algorithm .",
    "however , it can be shown that for most such orders , the algorithm indeed converges to the fixed point that corresponds to the planted assignment .",
    "the more difficult part of our work is the case when @xmath84 is constant ( though a sufficiently large constant ) , as in the case of theorem  [ convergencethmmed ] . in this case , already our first two assumptions are incorrect .",
    "random fluctuations with respect to expected values will @xmath5 cause a linear fraction of the variables to appear negatively more often than positively , or not to support any clause ( with respect to the planted assignment ) .",
    "in particular , the planted assignment would no longer be a local maximum with respect to the underlying max-3sat instance .",
    "nevertheless , as is known from previous work  @xcite , a large fraction of the variables will behave sufficiently close to expectation so that the planted assignment is a local maximum with respect to these variables . slightly abusing notation , these set of variables",
    "are often called the _ core _ of the 3cnf formula .",
    "our proof plan is to show that @xmath110 does converge , and that the partial assignment in step 4 assigns all core variables their correct planted value .",
    "moreover , for non - core variables , we wish to show that the partial assignment does not make any unrecoverable error ",
    "whatever value it assigns to some of them , it is always possible to assign values to those variables that are left unassigned by the partial assignment so that the input formula is satisfied .",
    "the reason why we can expect such a proof plan to succeed is that it is known to work if one obtains an initial partial assignment by means other than @xmath110 , as was already done in  @xcite .",
    "let us turn now to our third assumption .",
    "it too is violated for a linear fraction of the variables , but is nearly satisfied for most variables .",
    "this fact marks one point of departure for our work compared to previous work  @xcite .",
    "our definition of the core variables will no longer depend only on the input formula , but also on the random choice of initialization messages .",
    "this adds some technical complexity to our proofs .",
    "the violation of the fourth assumption is perhaps the technical part in which our work is most interesting .",
    "it relates to the analysis of @xmath110 on factor graphs that contain cycles , which is often a stumbling point when one analyzes message passing algorithms . recall that when @xmath84 is very large ( proposition  [ convergencepropdense ] ) , making the fourth assumption simplifies the proof of convergence of wp .",
    "hence removing this assumption in that case becomes a nuisance . on the other hand ,",
    "when @xmath84 is smaller ( as in theorem  [ convergencethmmed ] ) , removing this assumption becomes a necessity .",
    "this will become apparent when we analyze convergence of wp on what we call _ free cycles_. if messages in step 3b of are updated based on the value of other messages in the _ previous _ iteration ( as in our fourth assumption ) , then the random choice of order in step 3a of does not matter , and one can design examples in which the messages in a free cycle never converge .",
    "in contrast , if messages in step 3b of are updated based on the latest value of other messages ( either from the previous iteration or from the current iteration , whichever one is applicable ) , free cycles converge with probability 1 ( as we shall later show ) .    to complete the proof plan , we still need to show that simplifying the input formula according to the partial assignment returned by results in a formula that is satisfiable , and moreover , that a satisfying assignment for this sub - formula can easily be found .",
    "the existential part ( the sub - formula being satisfiable ) will follow from a careful analysis of the partial assignment returned by .",
    "the algorithmic part ( easily finding an assignment that satisfies the sub - formula ) is based on the same principles used in  @xcite , showing that the sub - formula breaks into small connected components .",
    "in this section we discuss relevant properties of a random @xmath7 instance .",
    "this section is rather technical in nature .",
    "the proofs are based on probabilistic arguments that are standard in our context .",
    "thus we sometimes present only an outline of a proof , when the details can be easily completed by the reader . in cases where our argument is more tricky",
    "we give the complete proof ( most notably , proposition [ notwocycleprop ] ) .    in the rest of the paper , for simplicity of presentation , we assume w.l.o.g . that the planted assignment is the all true assignment .",
    "a variable @xmath11 * supports * a clause @xmath14 with respect to a partial assignment @xmath64 , if it is the only variable to satisfy @xmath14 under @xmath64 , and the other two variables are assigned by @xmath64 .    [ supportsuccrate ]",
    "let @xmath10 be a 3cnf formula randomly sampled according to @xmath7 , where @xmath111 , @xmath84 a sufficiently large constant .",
    "let @xmath112 be a random variable counting the number of variables in @xmath10 whose support w.r.t .",
    "@xmath8 is less than @xmath113",
    ". then @xmath5 @xmath114 .",
    "( outline ) the proposition follows from simple concentration arguments .",
    "every variable is expected to support @xmath115 clauses , thus using e.g. chernoff s bound and linearity of expectation , one obtains @xmath116\\leq e^{-\\theta(d)}n$ ] .",
    "to prove concentration around the expected value one can use the chernoff bound once more as the support of one variable is independent of the others ( since it concerns different clauses which are included independently of each other ) .    following the definitions in section [ wpsubs ] , given a cnf @xmath10 and a variable @xmath11 , we let @xmath117 be the set of clauses in @xmath10 in which @xmath11 appears positively but does nt support w.r.t .",
    "@xmath8 . let @xmath118 be the set of clause in @xmath10 which @xmath11 supports w.r.t .",
    "@xmath8 . let @xmath119 be some ordering of the clause - variable message edges in the factor graph of @xmath10 .",
    "for an index @xmath120 and a literal @xmath121 ( by @xmath121 we denote a literal over the variable @xmath11 ) let @xmath122 be the set of clause - variable edges @xmath123 that appear before index @xmath120 in the order @xmath124 and in which @xmath11 appears in @xmath14 as @xmath121 . for a set of clause - variable edges @xmath125 and a set of clauses @xmath126 we denote by @xmath127 the subset of edges containing a clause from @xmath126 as one endpoint .",
    "[ stabledefn ] a variable @xmath11 is * stable * in @xmath10 w.r.t .",
    "an edge order @xmath124 if the following holds for every clause - variable edge @xmath128 ( w.l.o.g .",
    "assume @xmath129 , @xmath128 is the @xmath120th message in @xmath124 ) :    1",
    ".   @xmath130 .",
    "2 .   @xmath131 .",
    "3 .   @xmath132    and the same holds for @xmath133 .",
    "[ stablesuccrate ] let @xmath10 be a 3cnf formula randomly sampled according to @xmath7 , where @xmath111 , @xmath84 a sufficiently large constant .",
    "let @xmath124 be a random ordering of the clause - variable messages , and @xmath134 be a random variable counting the number of variables in @xmath10 which are not stable . then @xmath5 @xmath135 .",
    "we start by bounding @xmath136 $ ] .",
    "consider a clause - variable message edge @xmath68 in location @xmath120 in @xmath124 , @xmath137 .",
    "now consider location @xmath138 .",
    "the probability of an edge @xmath139 in location @xmath140 is @xmath141 which is exactly the probability of an edge @xmath142 , @xmath143 .",
    "this implies @xmath144=0.\\ ] ] if however @xmath145 then at least one of the quantities deviates from its expectation by @xmath146 .",
    "look at @xmath147  this is the number of success in draws without replacement .",
    "it is known that this quantity is more concentrated than the corresponding quantity if the draws were made with replacement  @xcite . in particular , since the expectation of @xmath147 is @xmath148 it follows from chernoff s bound that the probability that it deviates from its expectation by more than @xmath146 is @xmath149 .",
    "a similar statement holds for @xmath150 .",
    "properties @xmath151 and @xmath152 are bounded similarly using concentration results .",
    "the calculations above hold in particular for the first @xmath153 appearances of messages involving @xmath11 . as for message @xmath154 , the probability of this message causing @xmath11 to become unstable",
    "is bounded by the event that @xmath11 appears in more than @xmath153 clauses .",
    "as @xmath11 is expected to appear in @xmath155 clauses , the latter event happens w.p .",
    "@xmath149 ( again using standard concentration results ) . to sum up ,",
    "@xmath156\\leq 5d\\cdot e^{-\\theta(d)}+e^{-\\theta(d)}=e^{-\\theta(d)}.\\ ] ] the bound on @xmath136 $ ] follows by linearity of expectation .",
    "we are now left with proving that @xmath134 is concentrated around its expectation , we do so using a martingale argument .",
    "define two new random variables , @xmath157 counting the number of unstable variables @xmath11 s.t .",
    "there exists a clause @xmath14 , containing @xmath11 , and another variable @xmath158 , s.t .",
    "@xmath158 appears in more than @xmath159 clauses , and @xmath160 to be the unstable variables s.t . in all clauses in which they appear ,",
    "all the other variables appear in at most @xmath109 clauses .",
    "observe that @xmath161 . to bound @xmath157 ,",
    "observe that if @xmath162 , then in particular this implies that there exists a variable which appears in more than @xmath109 clauses in @xmath10 .",
    "this however can be shown not to happen @xmath5 ( since every variable is expected to appear only in @xmath148 clauses ) .",
    "to bound @xmath160 we use a martingale argument in the constellation of @xcite , page 101 .",
    "we use the clause - exposure martingale ( the clause - exposure martingale implicitly includes the random ordering @xmath124 , since one can think of the following way to generate the random instance ",
    "first randomly shuffle all possible clauses , and then toss the coins ) .",
    "the exposure of a new clause @xmath14 can change @xmath160 by at most @xmath163 since every variable in @xmath14 appears in at most @xmath109 clauses , namely with at most @xmath164 other variables that might become ( un)stable due to the new clause .",
    "the martingale s total variance , to use the terminology in @xcite , is @xmath165 . using inequality ( 7.1 ) in @xcite page 101 , with @xmath166 , and the fact that @xmath167\\leq e[f_{unstab}]$ ] , concentration around the expectation of @xmath160 is obtained .",
    "let @xmath168 be a clause - variable message vector .",
    "for a set of clause - variable message edges @xmath125 let @xmath169 be the set of edges along which the value is 1 according to @xmath170 . for a set of clauses @xmath126",
    ", @xmath171 denotes the set of clause - variable message edges in the factor graph of @xmath10 containing a clause from @xmath126 as one endpoint and along which the value is 1 in @xmath170 .",
    "[ violateddefn ] a variable @xmath11 is * violated * by @xmath170 in @xmath124 if there exists a message @xmath68 , @xmath172 , in place @xmath120 in @xmath124 s.t .",
    "one of the following holds :    1 .",
    "@xmath173 2 .",
    "@xmath174 3 .",
    "@xmath175 .    or one of the above holds for @xmath133 .",
    "[ violatedsuccrate ] let @xmath10 be as in the setting of theorem [ convergencethmmed ] , and let @xmath176 be a set of stable variables w.r.t .",
    "an arbitrary ordering @xmath124 .",
    "let @xmath170 be a random clause - variable message vector .",
    "let @xmath177 be a random variable counting the number of violated variables in @xmath176 .",
    "then , @xmath178 .",
    "as in the proof of proposition [ stablesuccrate ] , we first bound @xmath179 $ ] , and then prove concentration using a martingale argument . since the martingale argument is the same as proposition [ stablesuccrate ] ( instead of a clause - exposure martingale , we have a clause - variable message values exposure martingale ) , we just show how to bound the expectation .    consider a stable variable @xmath11 in @xmath10 w.r.t . to an ordering @xmath124 of the clause - variable messages .",
    "let @xmath170 be a random assignment to the clause - variable messages .",
    "consider a clause - variable message edge @xmath68 at location @xmath120 in @xmath124 .",
    "@xmath11 is stable and therefore @xmath180 since @xmath170 is a random assignment @xmath181\\leq d/60.\\ ] ] if however @xmath182 then at least one of the quantities in ( [ equa ] ) deviated from its expectation by at least @xmath183 .",
    "since both quantities are binomially distributed with expectation @xmath148 , the probability of the latter happening is @xmath149 , using standard concentration results .",
    "properties @xmath151 and @xmath152 are bounded similarly using tight concentration results .",
    "using the union bound as in the proof of proposition [ stablesuccrate ] and the linearity of expectation the bound on the expectation follows .",
    "the next property we discuss is analogous to a property proved in @xcite for random graphs . loosely speaking , @xcite",
    "prove that @xmath5 a random graph does nt contain a small induced subgraph with a large average degree .",
    "a similar proposition for 3sat can also be found in @xcite .",
    "[ nodensesubformulas ] let @xmath184 be an arbitrary constant .",
    "let @xmath185be as in the setting of theorem [ convergencethmmed ] .",
    "then @xmath5 there exists _ no _ subset of variables @xmath186 , s.t .",
    "@xmath187 and there are at least @xmath188 clauses in @xmath10 containing two variables from @xmath186 .",
    "( outline ) for a fixed set @xmath186 of variables , @xmath189 , the number of clauses containing two variables from @xmath186 is @xmath190 + each of these clauses is included independently w.p .",
    "thus , the probability that @xmath192 of them are included is at most @xmath193 using the union bound , the probability there exists a `` dense '' set @xmath186 is at most @xmath194 the last equality is obtained using standard calculations .",
    "we describe a subset of the variables , denoted throughout by @xmath195 and referred to as the _ core variables _ , which plays a crucial role in the analysis .",
    "the notion of a stable variable is not enough to ensure that the algorithm will set a stable variable according to the planted assignment , as it may happen that a stable variable @xmath11 appears in many of its clauses with unstable variables .",
    "thus , @xmath11 can be biased in the wrong direction ( by wrong we mean disagreeing with the planted assignment ) . however ,",
    "if most of the clauses in which @xmath11 appears contain only stable variables , then this is already a sufficient condition to ensure that @xmath11 will be set correctly by the algorithm .",
    "the set @xmath195 captures the notion of such variables .",
    "there are several ways to define a set of variables with these desired properties , we present one of them , and give a constructive way of obtaining it ( though it has no algorithmic implications , at least not in our context ) .",
    "formally , @xmath196 is constructed using the following iterative procedure :    [ sizeofhbarpr ] if both @xmath170 and @xmath124 are chosen uniformly at random then @xmath5 @xmath197 .",
    "let @xmath198 .",
    "set @xmath199 .",
    "partition the variables in @xmath200 into variables that belong to @xmath201 , and variables that were removed in the iterative step , @xmath202 .",
    "if @xmath203 , then at least one of @xmath204 , @xmath205 has cardinality at least @xmath206 .",
    "consequently , @xmath207 \\leq \\underbrace{pr[\\#a_1 \\cup a_2 \\cup a_3\\geq \\delta n/2]}_{(a)}+\\underbrace{pr[\\#\\bar{h}^{it } \\geq \\delta n/2\\text { } \\big|\\text { } \\#a_1 \\cup a_2 \\cup",
    "a_3 \\leq\\delta n/2]}_{(b)}.\\end{aligned}\\ ] ] propositions [ supportsuccrate ] , [ stablesuccrate ] , and [ violatedsuccrate ] and azuma s inequality for example are used to bound @xmath208 .",
    "to bound @xmath151 , observe that every variable that is removed in iteration @xmath120 of the iterative step ( step 2 ) , supports at least @xmath209 clauses in which at least another variable belongs to @xmath210 , or appears in @xmath211 clauses each containing at least one of the latter variables .",
    "consider iteration @xmath212 .",
    "assuming @xmath213 , by the end of this iteration there exists a set containing at most @xmath214 variables , and there are at least @xmath215 clauses containing at least two variables from it ( we divide by 3 as every clause might have been counted 3 times ) . plugging @xmath216 in proposition [ nodensesubformulas ] , @xmath151 is bounded .",
    "proposition [ sizeofhbarpr ] implies that for @xmath217 , @xmath95 a sufficiently large constant , @xmath5 @xmath195 contains already all variables .",
    "therefore the following propositions are relevant for the setting of theorem [ convergencethmmed ] ( namely , @xmath218 ) .",
    "[ sizeofconnectedcompprop ] * whp * every connected component in the factor graph induced by the non - core variables contains @xmath87 variables .",
    "a proposition of similar flavor to proposition [ sizeofconnectedcompprop ] was proven in @xcite though with respect to a different notion of core .",
    "proposition [ sizeofconnectedcompprop ] will not suffice to prove theorem [ convergencethmmed ] , and we need a further characterization of the non - core factor graph , which is not present in any of the aforementioned works .",
    "[ notwocycleprop ] * whp * every connected component in the factor graph induced by the non - core variables contains at most one cycle .",
    "[ prop : nolongcycle ] the probability of a cycle of length at least @xmath2 in the factor graph induced by the non - core variables is at most @xmath219 .",
    "[ cor : nolongcycle ] let @xmath220 be an arbitrary growing function of @xmath6 ( namely , @xmath221 as @xmath222 ) .",
    "then @xmath5 there is no cycle of length @xmath223 in the non - core factor graph    since propositions [ sizeofconnectedcompprop]-[prop : nolongcycle ] are all proven using similar arguments , we chose to prove proposition [ notwocycleprop ] which is not present in any of @xcite . we proceed with the proof of proposition [ notwocycleprop ] and corollary [ cor : nolongcycle ] .      in order to prove proposition [ notwocycleprop ] it suffices to prove that @xmath5 there are no two cycles with a simple path ( maybe of length 0 ) connecting the two . to this end",
    ", we consider all possible constellations of such prohibited subgraphs and prove the proposition using a union bound over all of them .",
    "every simple @xmath224-cycle in the factor graph consists of @xmath2 variables , w.l.o.g .",
    "say @xmath225 ( all different ) , and @xmath2 clauses @xmath226 , s.t .",
    "the cycle itself consists of @xmath224 edges .    as for paths",
    ", we have 3 different types of paths : paths connecting a clause in one cycle with a variable in the other ( type 1 ) , paths connecting two clauses ( type 2 ) , and paths connecting two variables ( type 3 ) .",
    "clause - variable paths are always of odd length , and clause - clause , variable - variable paths are always of even length .",
    "a @xmath2-path @xmath228 consists of @xmath2 edges .",
    "if it is a clause - variable path , it consists of @xmath229 clauses and the same number of variables .",
    "if it is a variable - variable path , it consists of @xmath230 variables and @xmath231 clauses and symmetrically for the clause - clause path ( we do nt take into account the clauses / variables that participate in the cycle , only the ones belonging exclusively to the path ) .",
    "our prohibited graphs consist of two cycles @xmath232 and a simple path @xmath228 connecting them .",
    "we call a graph containing exactly two simple cycles and a simple path connecting them a _ bi - cycle_. the path @xmath228 can be of either one of the three types described above . similarly to the bi - cycle case , one can have a cycle @xmath14 and a chord @xmath228 in it .",
    "we call such a cycle a _ chord - cycle_. for parameters @xmath233 $ ] , and @xmath234 , we denote by @xmath235 a bi - cycle consisting of a @xmath236-cycle connected by a @xmath2-path of type @xmath237 to a @xmath238-cycle . similarly , we denote by @xmath239 a chord - cycle consisting of a @xmath236-cycle with a @xmath2-path of type @xmath237 as a chord .",
    "our goal is then to prove that @xmath5 the graph induced by the non - core variables contains no bi - cycles and no chord - cycles .    for a fixed factor graph @xmath240 we let @xmath241 be a fixed minimal set of clauses inducing @xmath240 , and @xmath242 be the set of variables in @xmath240 . in order for a fixed graph @xmath240 to belong to the factor graph induced by the non - core variables it must be that there exists some @xmath243 s.t .",
    "@xmath244 and that @xmath245 ( put differently , @xmath246 ) .",
    "let @xmath247 ( or @xmath248 if @xmath249 is a chord - cycle ) be a fixed bi - cycle and @xmath250 a fixed minimal - set of clauses inducing @xmath249 .",
    "we start by bounding @xmath251 $ ] and then use the union bound over all possible bi - cycles ( chord - cycles ) and inducing minimal sets of clauses .",
    "as the two events  @xmath252 and @xmath253  are not independent , the calculations are more involved . loosely speaking , to circumvent the dependency issue , one needs to defuse the effect that the event @xmath252 might have on @xmath195 . to this end",
    "we introduce a set @xmath254 , defined very similarly to @xmath195 only `` cushioned '' in some sense to overcome the dependency issues ( the `` cushioning '' depends on @xmath250 ) .",
    "this is done using similar techniques to @xcite .",
    "we start by defining the new set of core variables @xmath254 ( again w.r.t .",
    "an ordering @xmath124 of the clause - variable messages and an initial values vector @xmath170 ) .",
    "the changes compared to @xmath195 are highlighted in bold .",
    "+ propositions [ stablesuccrate ] and [ violatedsuccrate ] could be easily adjusted to accommodate the 6-gap in the new definition in @xmath255 and @xmath256 .",
    "therefore proposition [ sizeofhbarpr ] can be safely restated in the context of @xmath254 :    [ sizeofhbartagpr ] if both @xmath170 and @xmath124 are chosen uniformly at random then @xmath5 @xmath257 .",
    "let @xmath258 , then the set @xmath259 defined above satisfies @xmath260    observe that if @xmath250 is minimal then @xmath261 .",
    "this is because in every cycle the number of variables equals the number of clauses , and in the worst case , the path contains at most one more clause than the number of variables , and the same goes for the chord - cycle .",
    "now suppose in contradiction that @xmath262 , then there are more than @xmath263 variables in @xmath264 , each appearing in at least 6 different clauses in @xmath250 .",
    "thus , @xmath265 ( we divided by three as every clause might have been counted 3 times ) , contradicting @xmath261 .",
    "+ the following proposition  defuses \" the dependency between the event that a bi - cycle ( chord - cycle ) was included in the graph and the fact that it does nt intersect the core variables . in the following proposition we fix an arbitrary @xmath124 and @xmath170 in the definition of @xmath254 , therefore the probability is taken only over the randomness in the choice of @xmath10 .",
    "[ cycleprobprop]@xmath266\\leq pr[f_{b } \\subseteq { { \\cal{f}}}]\\cdot pr[j \\cap { { \\cal{h}}}^ * = \\emptyset]$ ]    to prove proposition [ cycleprobprop ] we need the following lemma .    [ basicinclemma ] for every bi - cycle ( chord - cycle )",
    "@xmath249 and every minimal inducing set @xmath267 , @xmath268 .",
    "this lemma clarifies the motivation for defining @xmath254 .",
    "it is not necessarily true that @xmath269 .",
    "for example , a variable which appears in @xmath270 could disappear from @xmath271 since the clauses in @xmath267 make it unstable .",
    "loosely speaking , @xmath254 is cushioned enough to prevent such a thing from happening .",
    "+   +    ( proposition [ cycleprobprop ] ) @xmath272 \\leq pr[f_b \\subseteq { { \\cal{f}}}\\text { and } j \\cap { { \\cal{h}}}= \\emptyset ] = pr[j \\cap { { \\cal{h}}}= \\emptyset | f_b \\subseteq { { \\cal{f } } } ] pr[f_b",
    "\\subseteq { { \\cal{f}}}].\\ ] ] therefore , it suffices to prove @xmath273 \\leq pr[j \\cap { { \\cal{h}}}^ * = \\emptyset].\\ ] ] @xmath274 = \\sum_{f : j \\cap { { \\cal{h}}}^*(f ) = \\emptyset}pr[{{\\cal{f}}}=f]\\underbrace{\\geq } _ { lemma~\\ref{basicinclemma}}\\sum_{f : j",
    "\\cap { { \\cal{h}}}(f\\cup f_b ) = \\emptyset}pr[{{\\cal{f}}}=f]\\ ] ] break each set of clauses @xmath275 into @xmath276 and @xmath277 , and the latter equals @xmath278\\ ] ] since the two sets of clauses , @xmath279 , and @xmath280 , are disjoint , and clauses are chosen independently , the last expression equals , @xmath281pr[{{\\cal{f}}}\\cap f_b = f'']= \\\\ & \\sum_{f':f ' \\cap f_b=\\emptyset , j \\cap { { \\cal{h}}}(f'\\cup f_b)=\\emptyset } pr[{{\\cal{f}}}\\setminus f_b = f ' ] \\underbrace{\\sum_{f'':f''\\subseteq f_b } pr[{{\\cal{f}}}\\cap f_b = f'']}_{1 } = \\\\ & \\sum_{f':f ' \\cap f_b=\\emptyset , j \\cap { { \\cal{h}}}(f'\\cup f_b)=\\emptyset}pr[{{\\cal{f}}}\\setminus f_b = f']\\end{aligned}\\ ] ] since @xmath282 , and clauses are chosen independently , the event @xmath283 is independent of the event @xmath284 .",
    "therefore , the latter expression can be rewritten as @xmath285=   pr[j \\cap { { \\cal{h}}}= \\emptyset|f_b \\subseteq { { \\cal{f}}}].\\ ] ]     +    ( lemma [ basicinclemma ] ) the lemma is proved using induction on @xmath120 ( @xmath120 being the iteration counter in the construction of @xmath195 ) . for the base case @xmath286 , since every variable in @xmath287 appears in at most 6 clauses in @xmath250 it holds that @xmath288 , @xmath289 .",
    "@xmath290 holds at any rate as more clauses can only increase the support , and the set @xmath259 was not even considered for @xmath291 .",
    "suppose now that @xmath292 , and prove the lemma holds for iteration @xmath293 .",
    "if @xmath294 then @xmath11 supports at least @xmath113 clauses in which all variables are in @xmath295 . since @xmath296 , then @xmath11 supports at least this number of clauses with only variables of @xmath297 .",
    "also , @xmath11 appears in at most @xmath298 clauses with some variable outside of @xmath295 , again since @xmath299 and @xmath267 contains at most 6 clauses containing @xmath11 , @xmath11 will appear in no more than @xmath211 clauses each containing some variable not in @xmath300 .",
    "we conclude then that @xmath301 .",
    "+    [ chordcycleprobcor ] let @xmath248 be a chord - cycle , and let @xmath302 , then @xmath303\\leq p(i , k)$ ] where :    1 .",
    "@xmath304 if @xmath249 consists of a @xmath236-cycle and a variable - variable @xmath2-path as a chord .",
    "2 .   @xmath305 if @xmath249 consists of @xmath236-cycle and a clause - clause @xmath2-path as a chord .",
    "3 .   @xmath306 if @xmath249 consists of @xmath236-cycle and a variable - clause @xmath2-path as a chord .    in @xmath208",
    ", we have @xmath307 variables and @xmath308 clauses .",
    "since the clauses are chosen independently , @xmath309\\leq ( d / n^2)^{i+\\frac{k}{2}}.\\ ] ] to bound the event @xmath310 , observe that @xmath250 is fixed in the context of this event , and there is no pre - knowledge whether @xmath250 is included in @xmath10 or not .",
    "therefore , @xmath259 can be treated as a fixed set of variables , thus the choice of @xmath254 is uniformly distributed over @xmath259 . recalling that @xmath311 , it follows that @xmath312 \\leq \\frac{\\binom{n-\\#{{\\cal{h}}}^*}{\\#j}}{\\binom{n}{\\#j}}=\\frac{\\binom{\\lambda n}{(i+\\frac{k}{2}-1)/4}}{\\binom{n}{(i+\\frac{k}{2}-1)/4 } } \\leq \\lambda^{(i+\\frac{k}{2}-1)/4}.\\end{aligned}\\ ] ] the last inequality follows from standard bounds on the binomial coefficients .",
    "@xmath208 now follows immediately from proposition [ cycleprobprop ] . in the same manner items",
    "@xmath313 are proven ( just counting how many variables and clauses @xmath249 contains , depending on the type of its path ) .",
    "[ bicycleprobcor ] let @xmath247 be a bi - cycle , and let @xmath302 , then @xmath303\\leq p(i , j , k)$ ] where :    1 .",
    "@xmath314 if @xmath249 consists of a @xmath236,@xmath238-cycles and a variable - variable @xmath2-path .",
    "2 .   @xmath315 if @xmath249 consists of @xmath236,@xmath238-cycles and a clause - clause @xmath2-path .",
    "3 .   @xmath316 if @xmath249 consists of @xmath236,@xmath238-cycles and a variable - clause @xmath2-path .",
    "corollary [ bicycleprobcor ] is proven in a similar way to corollary [ chordcycleprobcor ] .    to complete the proof of proposition [ notwocycleprop ] ,",
    "we use the union bound over all possible bi / chord - cycles .",
    "we present the proof for the bi - cycle case ; the proof of the chord - cycle is analogous .",
    "first consider the case where @xmath249 is a bi - cycles with a variable - variable path ( in which case the path must be of even length ) .",
    "let @xmath317 ( namely , @xmath318 and @xmath319 ) .",
    "the probability of @xmath249 is then at most @xmath320    we now move to the case @xmath249 is a bi - cycles with a clause - clause path ( in which case the path again must be of even length ) .",
    "let @xmath321 ( namely , @xmath318 and @xmath322 ) .",
    "observe that in this case the number of classes in @xmath250 is @xmath323 , however only for @xmath324 clauses one has the freedom in choosing the third variable ( the two clauses which are the endpoints of the path are completely determined once the order of the variables is fixed ) .",
    "the probability is then at most @xmath325",
    "lastly , we need to consider the case @xmath249 is a bi - cycles with a clause - variable path ( in which case the path must be of odd length ) . let @xmath326 ( namely , @xmath327 ) .",
    "again , one clause in @xmath250 is completely determined once the the order of the variables is fixed .",
    "the probability is then at most @xmath328 to sum up , the probability of a bi - cycle in the graph induced by the non - core variables is @xmath329 .",
    "the proof is basically the same as that of proposition [ notwocycleprop ] .",
    "one defines the same notion of  cushioned \" core @xmath254 , and proceeds similarly .",
    "we therefore reprove only the last part  the union bound over all possible cycles .",
    "first let us bound the number of cycles of length @xmath2 .",
    "there are @xmath330 ways to choose the variables inducing the cycle , and @xmath331 ways to order them on the cycle . as for the set of clauses that induces the cycle ,",
    "once the cycle is fixed , we have at most @xmath332 ways of choosing the third variable and setting the polarity in every clause . in what follows we",
    "let @xmath333 be the number of vertices in the non - core factor graph .",
    "using the union bound , the probability of a cycle of length at least @xmath2 in the non - core factor graph is at most @xmath334 assuming that proposition [ sizeofhbartagpr ] holds ( which is the case @xmath5 ) , then @xmath335 and @xmath336  which is much smaller than 1 . in particular ,",
    "the last summation is simply the sum of a decreasing geometric series with quotient @xmath149 , which sums up to at most twice the first item , which is at most @xmath219 .",
    "we start by giving an outline of the proof of theorem [ convergencethmmed ] . proposition [ convergencepropdense ]",
    "is derived as an easy corollary of that proof .",
    "recall that to prove theorem [ convergencethmmed ] , we need to establish three properties :    1 .",
    "_ convergence _ : the wp algorithm converges to a fixed point .",
    "consistency _ : the partial assignment implied by this fixed point is consistent with some satisfying assignment .",
    "simplicity _ : after simplifying the input formula by substituting in the values of the assigned variables , the remaining subformula is not only satisfiable ( this is handled by consistency ) , but also simple .",
    "we assume that the formula @xmath10 and the execution of @xmath337 are _ typical _ in the sense that propositions [ sizeofhbarpr ] , [ sizeofconnectedcompprop ] , and [ notwocycleprop ] hold .",
    "first we prove that after one iteration sets the core variables @xmath195 correctly ( @xmath35 agrees with @xmath8 in sign ) and this assignment does not change in later iterations .",
    "the proof of this property is rather straightforward from the definition of a core .",
    "this establishes convergence and consistency for the core variables . from iteration 2",
    "onwards @xmath110 is basically running on @xmath10 in which variables belonging to @xmath195 are substituted with their planted assignment .",
    "this subformula is satisfiable .",
    "moreover , its factor graph contains small ( logarithmic size ) connected components , each containing at most one cycle .",
    "this last fact serves a dual purpose .",
    "it shows that if the wp will eventually converge , the simplicity property will necessarily hold .",
    "moreover , it will assist us in proving convergence and consistency for the subformula .",
    "consider a connected component composed of a cycle and trees  hanging \" on the cycle .",
    "proving convergence on the trees is done using a standard inductive argument .",
    "the more interesting part is proving convergence on the cycle .",
    "the difficulty there is that messages on a cycle may have more than one fixed point to which they may possibly converge , which makes it more difficult to prove that they converge at all .",
    "our proof starts with a case analysis that identifies those cases that have multiple fixed points . on these cases",
    "we prove that almost surely random fluctuations caused by step  3.a of the wp algorithm will lead to convergence to some fixed point .",
    "this is similar in flavor to the fact that a random - walk on a line eventually reaches an endpoint of the line ( even though one can not tell a - priori which endpoint this will be ) .",
    "hand - in - hand with establishing convergence for the trees and cycle , we shall also prove consistency .",
    "the set @xmath88 of theorem  [ convergencethmmed ] is composed of all variables from @xmath195 and those variables from the non - core factor graph that get assigned .",
    "the set @xmath89 is composed of the unassigned variables from non - core factor graph .",
    "we now proceed with the formal proof .",
    "we start by proving that the messages concerning the factor graph induced by the core - variables converge to the correct value , and remain the same until the end of the execution .",
    "we say that a message @xmath68 , @xmath338 , is _ correct _ if its value is the same as it is when @xmath339 and @xmath340 are 1 ( that is agree in sign with their planted assignment ) .",
    "in other words , @xmath68 is 1 iff @xmath341 ( @xmath11 supports @xmath14 ) .    [",
    "prop : invariant ] if @xmath342 and all messages @xmath343 , @xmath344 $ ] are correct at the beginning of an iteration ( line 3 in the algorithm ) , then this invariant is kept by the end of that iteration .    by contradiction ,",
    "let @xmath345 be the first wrongly evaluated message in the iteration .",
    "assume @xmath346 .",
    "then at least one of @xmath347 sent a wrong message to @xmath348 .",
    "@xmath349 every message @xmath142 , @xmath350\\cap \\{n^{++}(y)\\cup n^{-}(y)\\}$ ] is 0 ( since it was correct at the beginning of the iteration and that did nt change until evaluating @xmath345 ) . on the other hand , @xmath351",
    "and therefore it supports at least @xmath352 clauses in @xmath353 $ ] .",
    "thus at least @xmath354 messages in the left hand sum are ` 1 ' ( we subtract 1 as @xmath158 might support @xmath348 ) .",
    "@xmath158 appears in at most @xmath211 clauses with non - core variables ( all of which may contribute a wrong 1 message to the right hand sum ) .",
    "all in all , @xmath355 , which is correct ( recall , we assume @xmath356 ) .",
    "the same applies for @xmath133 , contradicting our assumption .",
    "[ propnoproof ] if @xmath342 and all messages @xmath343 , @xmath344 $ ] are correct by the end of a iteration , then @xmath35 agrees in sign with @xmath75 by the end of that iteration .",
    "proposition [ propnoproof ] follows immediately from the definition of @xmath195 and the message @xmath35 .",
    "it suffices to show then that after the first iteration all messages @xmath357 , @xmath358 $ ] are correct .",
    "[ coresetcorrectprop ] if @xmath10 is a typical instance in the setting of theorem [ convergencethmmed ] , then after one iteration of @xmath359 , for every variable @xmath342 , every message @xmath343 , @xmath358 $ ] is correct .",
    "the proof is by induction on the order of the execution in the first iteration .",
    "consider the first message @xmath68 , @xmath137 , @xmath358 $ ] , to be evaluated in the first iteration . now consider the message @xmath360 at the time @xmath68 is evaluated .",
    "all messages @xmath361 , @xmath362 $ ] have their initial random value ( as @xmath68 is the first core message to be evaluated ) .",
    "furthermore , @xmath351 , and therefore there are at most @xmath211 messages of the form @xmath142 , @xmath363 $ ] .",
    "@xmath364 hence it is stable w.r.t . @xmath124 and",
    "not violated by the initial clause - variable random messages .",
    "therefore @xmath365 the same applies to @xmath133 , to show that @xmath366 is correct .",
    "now consider a message @xmath68 at position @xmath120 , and assume all core messages up to this point were evaluated correctly .",
    "observe that every core message @xmath367 that was evaluated already , if @xmath368 $ ] then its value is 0 by the induction hypothesis . since @xmath11 is not violated by @xmath170 , property @xmath151 in definition [ violateddefn ] ensures that to begin with @xmath369 .",
    "@xmath370 , therefore it appears in at most @xmath211 non - core messages , all of which could have been already wrongly evaluated , changing the above difference by additional @xmath211 . as for the core messages of @xmath158 which were already evaluated , since they were evaluated correctly , property @xmath208 in definition [ violateddefn ]",
    "ensures that the above difference changes by at most additional @xmath211 .",
    "all in all , by the time we evaluate @xmath68 , @xmath371 as for messages that @xmath158 supports , property @xmath152 in definition [ violateddefn ] ensures that their contribution is at least @xmath372 to begin with .",
    "every core message in @xmath373 that was evaluated turned to 1 , every non - core message was already counted in the above difference .",
    "therefore @xmath374 .",
    "the same applies to @xmath133 showing that @xmath68 is correct .",
    "to prove proposition [ convergencepropdense ] , observe that when @xmath217 , with @xmath95 a sufficiently large constant , proposition [ sizeofhbarpr ] implies @xmath375 . combining this with proposition [ coresetcorrectprop ] ,",
    "proposition [ convergencepropdense ] readily follows .",
    "it now remains to analyze the behavior of on the non - core factor graph , given that the messages involving the core factor graph have converged correctly .",
    "a key observation is that once the messages in the factor graph induced by the core variables converged , we can think of @xmath337 as if running on the formula resulting from replacing every core variable with its planted assignment and simplifying ( which may result in a 1 - 2 - 3cnf ) .",
    "the observation is made formal by the following proposition :    [ prop : asifsimplified ] consider a run of @xmath110 that has converged on the core .",
    "starting at some iteration after @xmath110 has converged on the core , consider two alternative continuations of the warning propagation algorithm .",
    "@xmath376 denotes continuing with @xmath110 on the original input formula .",
    "@xmath377 denotes continuing with @xmath337 on the formula obtained by replacing each core variable with its planted assignment and simplifying .",
    "then for every iteration @xmath237 , the sequence of messages in the @xmath237th iteration of @xmath377 is identical to the respective subsequence in @xmath376 .",
    "( this subsequence includes those messages not involving the core variables , and includes messages of type @xmath378 and of the type @xmath379 . )    first note that all messages @xmath378 , @xmath380 , do not change ( sign ) from the second iteration onwards ( by the analysis in the proof of proposition [ coresetcorrectprop ] ) .",
    "furthermore , if @xmath121 satisfies @xmath14 in @xmath8 , then @xmath381 is positive ( if @xmath11 is a true literal in @xmath14 , or negative otherwise ) , and therefore all messages @xmath382 , @xmath383 are constantly 0 .",
    "namely , they do nt effect any calculation , and this is as if we replaced @xmath121 with true , and in the simplification process @xmath14 disappeared . if @xmath121 is false in @xmath14 under @xmath8 , then @xmath378 is constantly negative ( if @xmath384 , or constantly positive if @xmath385 ) , and this is exactly like having @xmath121 removed from @xmath14 ( which is the result of the simplification process ) .",
    "note that to prove the convergence of the algorithm we need also to prove that messages of the sort @xmath379 where @xmath14 is not in the core and @xmath11 is in the core converge .",
    "however , if we prove that all messages in the factor graph induced by the non - core variables converge , then this ( with the fact that the core factor graph messages converge ) immediately implies the convergence of messages of this type .",
    "therefore , our _ goal reduces to proving convergence of on the factor graph induced by @xmath386 , where @xmath64 assigns the core variables their planted assignment , and the rest are unassigned .",
    "_    we say that @xmath110 converged correctly in a connected component @xmath126 of the non - core factor graph if there exists a satisfying assignment @xmath64 of the entire formula which is consistent with @xmath8 on the core , and with the assignment of @xmath110 to @xmath126 .",
    "consider a connected component in the non - core factor graph consisting of a cycle with trees hanging from it .",
    "our analysis proceeds in three steps :",
    "1 .   we first prove that clause - variable and variable - clause messages of the form @xmath387 where @xmath388 lead from the trees to the cycle , converge weakly correctly w.r.t . the planted assignment . in the case",
    "that the component has no cycles , this concludes the proof .",
    "2 .   then , using a refined case analysis , we show that the messages along the cycle also converge @xmath5 , this time not necessarily to the planted assignment , but to some satisfying assignment which agrees with the already converged messages .",
    "finally , we conclude by showing that messages from the cycles to the trees converge .",
    "moreover , this will imply that convergence will be to values consistent with the values converged to in step  ( a ) , and that hence that all messages in the connected component converge correctly according to some satisfying assignment .",
    "consider the factor graph @xmath275 induced by the simplified formula .",
    "a _ cycle _ in @xmath275 is a collection @xmath389 where @xmath20 and @xmath390 belong to @xmath391 for all @xmath120 ( in our description we consider only odd values of @xmath120 ) and @xmath392 , @xmath393 for all @xmath120 .",
    "a factor graph @xmath275 is a _ tree _ if it contains no cycles .",
    "it is _ unicyclic _ if it contains exactly one cycle .",
    "let @xmath378 be a directed edge of @xmath275 .",
    "we say that @xmath378 _ belongs _ to the cycle , if both @xmath11 and @xmath14 belong to the cycle . for an edge @xmath378 that does not belong to the cycle",
    ", we say that @xmath378 _ is directed towards _",
    "the cycle if @xmath11 does nt belong to the cycle and @xmath14 lies on the simple path from @xmath11 to the cycle .",
    "we say that the edge @xmath394 is _ directed away _ from the cycle if @xmath14 does nt belong to the cycle and @xmath11 lies on the simple path from the cycle to @xmath14 .",
    "similarly we define what it means for an edges @xmath379 to belong to the cycle , to be directed towards the cycle and to be directed away from the cycle .",
    "let @xmath275 be a unicyclic factor graph .",
    "then every directed edge of the form @xmath378 or @xmath379 either belongs to the cycle , or is directed towards it or directed away from it .",
    "recall that the factor graph is an undirected graph , and the direction is associated with the messages .",
    "take an edge @xmath381 ( similarly for @xmath106 ) , if it lies on the cycle , then we are done .",
    "otherwise , since the factor graph is connected , consider the path in the tree leading from some element of the cycle to @xmath14 .",
    "this path is either contained in the path to @xmath11 or contains it ( otherwise there is another cycle ) . in the first case @xmath381",
    "is directed towards the cycle , and in the latter @xmath381 is directed away from the cycle .",
    "our analysis proceeds in two parts : first we shall analyze @xmath110 on the trees , then @xmath110 on the cycle and connect the two ( which is relevant for the uni - cyclic components ) .      as we already mentioned before",
    ", there are two directions to consider : messages directed towards the cycle and away from the cycle . in this section",
    "we shall consider a rooted tree , and partition the messages according to messages which are oriented away from the root ( they will correspond in the sequel to messages going away from the cycle ) and messages towards the root ( messages from the leaves towards the root  later to be identified with messages going into the cycle ) .",
    "the first lemma concerns messages going towards the root .",
    "[ rem : convergenceontrees ] lemma [ messageintocycleconvergelem ] is a special case of the known fact ( see  @xcite for example ) that for every tree induced by a satisfiable formula , @xmath110 converges and there exists a satisfying assignment @xmath64 such that every @xmath35 is either 0 or agrees with @xmath64 . in lemma [ messageintocycleconvergelem ]",
    "we assume that the formula is satisfiable by the all  1 assignment ( the planted assignment ) , and consider only messages towards the root .",
    "[ messageintocycleconvergelem ] let @xmath68 be an edge in the non - core factor graph belonging to a connected component of size @xmath395 , and in particular to a rooted tree @xmath396 .",
    "if @xmath128 is directed towards the root then the message @xmath366 converges after at most @xmath397 iterations .",
    "furthermore , if @xmath398 then @xmath11 appears positively in @xmath14 .",
    "we consider the case @xmath399  the case @xmath400 where all three literals belong to non - core variables is proved similarly . for an edge @xmath401 in the factor graph , we define @xmath402 to be the number of edges in a path between @xmath14 and the leaf most distant from @xmath14 in the factor graph from which the edge @xmath401 is removed . the lemma is now proved using induction on the level @xmath120 .",
    "namely , after the @xmath403 iteration , all messages @xmath366 associated with an edge @xmath401 at level @xmath120 converge , and if @xmath398 then @xmath11 appears positively in @xmath14 .    the base case is an edge @xmath401 at level 0 .",
    "if @xmath404 then @xmath14 is a unit clause containing only the variable @xmath11 . by the definition of the messages , in this case @xmath405 and indeed it must be the case that @xmath11 is positive in @xmath14 ( as the other two variables evaluate to false under the planted ) .",
    "now consider an edge @xmath401 at level @xmath120 , and consider iteration @xmath120 .",
    "since @xmath406 , it must be that there is another non - core variable @xmath158 in @xmath14 ( or two more variables @xmath347 ) .",
    "consider an edge @xmath407 , @xmath408 ( if no such @xmath409 exists that we are done as @xmath379 will be constantly 0 in this case ) .",
    "@xmath410 is strictly smaller than @xmath120 since every path from @xmath14 to a leaf ( when deleting the edge @xmath401 ) passes through some edge @xmath407 . by the induction hypothesis ,",
    "all messages @xmath411 already converged , and therefore also @xmath412 and in turn @xmath106 .",
    "it is only left to take care of the case @xmath413 . in this case",
    ", there must be a clause @xmath409 s.t . @xmath414",
    "and @xmath158 appears positively in @xmath409 ( by the induction hypothesis ) .",
    "if @xmath415 it must be that @xmath158 appears negatively in @xmath14 and therefore @xmath11 must appear positively ( otherwise @xmath14 is not satisfied by the planted assignment ) .",
    "next we consider several scenarios that correspond to messages going form the root towards the leaves .",
    "those scenarios correspond to step  ( c ) of our analysis , referred to in section  [ sec : noncoreoutline ] .",
    "[ 1msgiffunsatclm ] assume that @xmath275 is a unicyclic formula .",
    "assume further that wp has converged on @xmath275 .",
    "let @xmath378 be directed away from the cycle .",
    "let @xmath416 be the subformula inducing the tree rooted at @xmath14 , while @xmath11 itself is removed from @xmath14 .",
    "this formula contains all clauses whose path to the cycle goes via @xmath11 and a clause corresponding to @xmath14 where the literal corresponding to the variable @xmath11 is removed ( see pic1 ) .",
    "then @xmath417 in the fixed point if and only if @xmath416 is satisfiable .",
    "the structure of the proof is similar to that of lemma [ messageintocycleconvergelem ] . for convenience",
    "we extend the definition of level above as to include edges on the cycle .",
    "we say that an edge @xmath401 in the factor graph has @xmath402 equal @xmath418 if @xmath401 lies on a cycle and @xmath419 if @xmath237 is the maximal length of a path between @xmath14 and a leaf in the factor graph from which the edge @xmath401 is removed .",
    "the lemma is now proved using induction on @xmath237 .    the base case is an edge @xmath401 at level 0 .",
    "if @xmath404 then @xmath14 is a unit clause containing only the variable @xmath11 , and then @xmath416 is the empty formula . indeed",
    "@xmath420 by definition and @xmath416 is unsatisfiable ( by definition again , the empty formula is not satisfiable ) .",
    "now consider an edge @xmath401 at level @xmath421 .",
    "assume @xmath422 ( maybe only @xmath423 ) .",
    "observe that every edge @xmath424 in @xmath416 has @xmath425 value which is strictly smaller than @xmath237  since every path from @xmath14 to a leaf ( when deleting the edge @xmath401 ) passes through some edge @xmath424 .",
    "first we prove that if @xmath416 is not satisfiable then it must be that @xmath426 .",
    "if @xmath416 is not satisfiable then it must be that @xmath427 and @xmath428 ( otherwise , if one of them is positive then @xmath8 satisfies @xmath416 ) .",
    "further , observe that there must exist at least one clause @xmath21 containing @xmath158 positively , and at least one @xmath429 containing @xmath133 positively s.t .",
    "@xmath430 and @xmath431 are unsatisfiable .",
    "otherwise , we can define @xmath432 to be @xmath8 except that @xmath158 or @xmath133 are assigned false ( depending which of @xmath433 or @xmath21 does nt exist ) .",
    "it is easy to see that @xmath432 satisfies @xmath416 , contradicting our assumption . by the induction hypothesis @xmath434 and @xmath435",
    "this in turn implies that @xmath436 ( since @xmath433 and @xmath21 contain @xmath158 and @xmath133 respectively in an opposite polarity to @xmath14 and there can not be any message @xmath437 where @xmath158 appears negatively in @xmath429 since @xmath438 is satisfiable in this case ) .",
    "now assume that @xmath420 .",
    "the same arguments imply that @xmath14 must be of the form @xmath439 and there exists @xmath440 as above . by the induction hypothesis",
    ", if one is to satisfy @xmath416 it must be that @xmath441 ( this is the only way to satisfy @xmath442 and @xmath443 when inserting @xmath158 back to @xmath433 and @xmath133 to @xmath21 ) , but then @xmath14 is not satisfied .",
    "[ spinaldecomp ] assume that @xmath275 is a unicyclic formula .",
    "assume further that wp has converged on @xmath275 .",
    "let @xmath444 be directed away from the cycle .",
    "consider a subformula @xmath416 which induces a tree rooted at a clause @xmath14 .",
    "this formula contains the clause @xmath14 and all other clauses whose path to the cycle goes via @xmath158 .",
    "if in the fixed point for @xmath275 it holds that    * @xmath445 , * @xmath158 appears negatively in @xmath14 , * @xmath446 ,    then wp converge correctly in @xmath416 if ( recall this means that there exists a satisfying assignment @xmath64 of the entire formula which is consistent with @xmath8 on the core , and with the assignment of @xmath110 to @xmath416 ) .",
    "let us track the origin of the message @xmath412 in the tree .",
    "( which is directed towards the root ) . for @xmath446 to occur , there must be a clause @xmath447 in the tree that contains @xmath158 positively and a message @xmath448 in the direction of the root ( as messages in the direction of the root are only effected by other messages in that direction ) .",
    "let us backtrack one more step .",
    "@xmath449 for some variables @xmath450 ; @xmath2 and @xmath451 must appear negatively in @xmath447 by lemma [ messageintocycleconvergelem ] ) , and the fact that @xmath452 , that is both @xmath2 and @xmath451 were issued warnings having them not satisfy @xmath447 . let us consider the clauses @xmath453 and @xmath454 that issues warnings to @xmath2 and @xmath451 respectively .",
    "@xmath455 , @xmath456 and @xmath457 , and both messages are directed towards the root .",
    "obviously , one can inductively continue this backtracking procedure which terminates at the leaves of the tree ( since there are not cycles the procedure is well defined and always terminates ) .",
    "let us call the clauses and variables that emerge in this backtrack the _ spine _ of the tree .",
    "the figure below illustrates this procedure .        for the subtree corresponding to the spinal variable",
    "we show that all messages that point away from the root converge in a consistent way with planted assignment .",
    "this combined with lemma [ messageintocycleconvergelem ] completes that part of the proof .",
    "let @xmath2 be some variable that belongs to the spine , and let @xmath458 be the subformula corresponding to the tree hanging from @xmath2 ( and we think of the messages along that tree oriented away from the cycle ) .",
    "we claim that @xmath459 for every @xmath14 in @xmath458 .",
    "this is proven via induction on the distance of the variable from @xmath158 .",
    "the base case is distance 0 , which is @xmath158 itself .",
    "the messages that we need to verify are of the form @xmath460 , @xmath461 , which are pointing away from the cycle . in this case",
    "@xmath462 ( @xmath158 s message agrees with the planted ) ; this is because the wrong message @xmath463 is evened by the correct warning @xmath464 , and @xmath465 depends only on one message which is directed away from the cycle  otherwise there is a second cycle .",
    "the induction step follows very similarly .",
    "this fact guarantees correct convergence of the variables in the trees hanging from spinal variables .",
    "finally , for the spinal variables , there is always at most one message in the direction away from the cycle ( otherwise there is more than one cycle ) ; this message may be wrong . using a very similar inductive argument",
    "one can show that there is always at least one correct warning ( in the direction of the cycle ) , therefore @xmath466 for every spinal variable @xmath451 .",
    "as for the non - spinal parts of the tree that hang on @xmath158 , say a clause @xmath467 , then @xmath468 since the wrong message of @xmath14 is evened by the correct warning of @xmath447 ( and there may be other correct warnings from messages in the direction of the cycle ) .",
    "since there is a satisfying assignment of that subtree which is consistent with @xmath469 , remark [ rem : convergenceontrees ] can be applied to guarantee correct convergence .",
    "we will denote a cycle by @xmath470 where by this we mean that @xmath20 appears in the clauses before / after it and that @xmath433 contains the two variables before / after it .",
    "we consider two different types of cycles .    *",
    "_ biased _ cycles : cycles that have at least one warning message @xmath471 coming into the cycle , where @xmath472 directs into the cycle and the value of @xmath472 is the value after the edge has converged .",
    "* _ free _ cycles : cycles that do not have such messages coming in , or all messages coming in are 0 messages .      first we observe that we may assume w.l.o.g . that edges that enter the cycle enter it at a variable rather than at a clause ( hence that every clause on the cycle contains exactly two non - core variables ) .",
    "this is because of a simple argument similar to proposition [ prop : asifsimplified ] : consider an edge going into the cycle , @xmath473 , and w.l.o.g .",
    "assume that @xmath133 appears positively in @xmath14 .",
    "after all the edges going into the cycle have converged , if @xmath474 it follows that @xmath475 for cycle edges @xmath401 , and thus execution on the cycle is the same as if @xmath14 was removed from the formula , only now we are left with a tree , for which convergence to a correct assignment is guaranteed ( remark [ rem : convergenceontrees ] ) .",
    "if @xmath476 , then the execution is exactly as if @xmath133 was removed from @xmath14 ( and @xmath14 is in 2-cnf form ) .",
    "[ prop : connvergenceinbiasedcaseclm ] let @xmath126 be a connected component of the factor graph of size @xmath395 containing one cycle s.t .",
    "there exists an edge directed into the cycle @xmath472 where @xmath20 belongs to the cycle and such that the message converges to @xmath471 .",
    "then @xmath110 converges on @xmath126 after at most @xmath397 rounds .",
    "moreover for the fixed point , if the message @xmath477 then @xmath11 appears positively in @xmath409 .",
    "a message of the cycle @xmath478 depends only on cycle messages of the type @xmath479 and on messages coming into the cycle . in other words during the execution of @xmath110 the values of all messages @xmath480 do not effect the value of the message @xmath478 .",
    "recall that we are in the case where there exists a message @xmath471 going into the cycle ( after the convergence of these messages ) .",
    "also @xmath20 must appear positively in @xmath14 .",
    "we consider the following cases :    * there exists a variable @xmath481 that appears positively in both @xmath482 and @xmath483 ( the case @xmath484 is allowed here ) .",
    "we note that in this case the message @xmath485 must take the value either @xmath486 or @xmath487 which implies that the message @xmath488 converges to the value @xmath486 .",
    "this in turn implies that the value of all messages @xmath489 and @xmath490 for @xmath491 will remain the same if the clause @xmath483 is removed from the formula .",
    "however , this case reduces to the case of tree formula . *",
    "@xmath20 appears negatively in @xmath391 and positively in @xmath492 .",
    "we note that in this case the message @xmath493 always take the value @xmath487 which implies that the message @xmath494 always take the value @xmath487 .",
    "thus in this case we may remove the clause @xmath391 from the formula and replace it by the unit clause @xmath423 where @xmath495 .",
    "again , this reduces to the case of a tree formula . *",
    "the remaining case is the case where @xmath20 appears negatively in both @xmath492 and @xmath391 and there is no @xmath140 such that @xmath481 appears positively in both @xmath482 and @xmath483 .",
    "we claim that this leads to contradiction .",
    "note that by the lemma above there exists a satisfying assignment where @xmath496 .",
    "write @xmath497 . then for the truth assignment we must have @xmath498 , similarly @xmath499 etc . until we reach @xmath500 - a contradiction .    to summarize , by lemma [ messageintocycleconvergelem ] the messages going into the rooted tree at @xmath20 converge after @xmath397 steps , and at least one warning is issued . by the above discussion , for every clause @xmath501 in the connected component it holds that @xmath502 ( as @xmath20 appears in at most one message which may be wrong  a cycle message ) .",
    "since there is always a satisfying assignment consistent with @xmath20 assigned true , then after reducing the cycle to a tree we are left with a satisfiable tree .",
    "remark [ rem : convergenceontrees ] guarantees convergence in additional @xmath397 iterations .",
    "the main result of this subsection is summarized in the following claim :    [ connvergenceinnonbiasedcasemainclm ] let @xmath126 be a connected component of the factor graph of size @xmath395 containing one cycle of size @xmath503 s.t .",
    "the fixed point contains no messages @xmath504 going into the cycle ( the cycle is free ) .",
    "then @xmath5 converges on @xmath126 after at most @xmath505 rounds .",
    "moreover for the fixed point , if we simplify the formula which induces @xmath126 according to the resulting @xmath35 s , then the resulting subformula is satisfiable .",
    "[ diffrem]observe that the free case is the only one where convergence according to the planted assignment is not guaranteed .",
    "furthermore , the free cycle case is the one that may not converge  quickly \" ( or not at all ) , though this is extremely unlikely .",
    "the proof of proposition [ connvergenceinnonbiasedcasemainclm ] is the only place in the analysis where we use the fact that in line ` 3.a ` of we use fresh randomness in every iteration .",
    "we consider two cases : the easy one is the case in which the cycle contains a pure variable w.r.t the cycle ( though this variable may not be pure w.r.t to the entire formula ) .",
    "[ connvergenceofnonbiasedcyclepure ] if the cycle contains a variable @xmath20 appearing in the same polarity in both @xmath506 , then the messages @xmath379 along cycle edges converge .",
    "moreover for the fixed point , if @xmath507 then @xmath11 satisfies @xmath14 according to @xmath8 .",
    "the proof is very similar to the first case in the proof of proposition [ prop : connvergenceinbiasedcaseclm ] .",
    "we omit the details .",
    "we now move to the harder case , in which the cycle contains no pure variables ( which is the case referred to in remark [ diffrem ] ) .",
    "[ freecyclenopureconvergenceclm ] consider a free cycle of size @xmath503 with no pure literal , and one of the two directed cycles of messages .",
    "then the messages along the cycle converge @xmath5 to either all @xmath486 or all @xmath487 in @xmath508 rounds .",
    "convergence @xmath5 in polynomial time suffices due to corollary [ cor : nolongcycle ] ( which asserts that @xmath5 every cycle is of length at most @xmath509 for every @xmath510 ) . the proof of proposition [ freecyclenopureconvergenceclm ] is given in the end of this section .",
    "we proceed by analyzing assuming that proposition [ freecyclenopureconvergenceclm ] holds , which is the case @xmath5 .",
    "[ prop : free_cycle_comp_convergence ] suppose that the cycle messages have converged ( in the setting of proposition [ freecyclenopureconvergenceclm ] ) , then the formula resulting from substituting every @xmath20 with the value assigned to it by @xmath35 ( according to the fixed point of @xmath110 ) , and simplifying , is satisfiable .",
    "let @xmath275 be the subformula that induces the connected component @xmath126 , and decompose it according to the trees that hang on the cycle s variables and the trees that hang on the cycle s clauses .",
    "observe that the formulas that induce these trees are variable and clause disjoint ( since there is only one cycle in the @xmath126 ) .",
    "let us start with the cycle clauses .",
    "the key observation is that setting the cycle variables according to one arbitrary orientation ( say , set @xmath20 to satisfy @xmath391 ) satisfies the cycle and does nt conflict with any satisfying assignment of the hanging trees : if the tree hangs on a variable @xmath20 , then since the cycle is free , the tree is satisfiable regardless of the assignment of @xmath20 ( proposition [ 1msgiffunsatclm ] ) . in the case",
    "that the tree hangs on a cycle - clause @xmath14 , then the cycle variables and the tree variables are disjoint , and @xmath14 is satisfied already by a cycle - variable regardless of the assignment of the tree - variables .",
    "now how does this coincide with the result of @xmath110 . recall that we are in the case where the cycle is free",
    ". therefore only messages @xmath472 where both @xmath14 and @xmath20 belong to the cycle effect @xmath35 .",
    "if in the fixed point one cycle orientation is 0 and one orientation is 1 , then the @xmath35 messages of the cycle variables implement exactly this policy .",
    "if both cycle orientations converged to 1 or to 0 , then the corresponding @xmath35 messages of all cycle variables are unassigned ( since the cycle is free ) , but then the same policy can be used to satisfy the clauses of the cycle in a manner consistent with the rest of the formula .    it remains to show that @xmath110 converges on every tree in a manner that is consistent with some satisfying assignment of the tree .",
    "we consider several cases .",
    "consider a tree hanging on a cycle variable @xmath20 .",
    "let @xmath14 be some non - cycle clause that contains @xmath20 , and @xmath416 the subformula that induces the tree rooted at @xmath14 .",
    "observe that once the cycle has converged , then the message @xmath511 does not change anymore . if @xmath512 agrees with @xmath8",
    "there are two possibilities .",
    "either @xmath20 satisfies @xmath14 under @xmath8 , in which case @xmath14 always sends 0 to @xmath416 , and then @xmath110 executes on @xmath416 as if @xmath14 is removed . remark [ rem : convergenceontrees ] guarantees correct convergence ( as @xmath513 is satisfiable ) , and as for @xmath14 , @xmath514 and we can set @xmath20 to true so that it satisfies @xmath14 and is consistent with the assignment of the cycle ( @xmath514 since @xmath515 and @xmath516 as we are in the free cycle case ) .",
    "if @xmath20 appears negatively in @xmath14 , then @xmath110 executes as if @xmath20 was deleted from @xmath14 .",
    "still @xmath416 is satisfiable and correct convergence is guaranteed .    now consider the case where @xmath512 disagrees with @xmath8 . recall that we assume @xmath517 , and therefore @xmath381 is negative in the fixed point .",
    "if @xmath20 appears negatively in @xmath14 then @xmath518 for every @xmath519 ( since @xmath20 signals @xmath14 that it satisfies it ) , and therefore @xmath14 does nt effect any calculation from this point onwards , and the correct convergence of @xmath416 is again guaranteed by remark [ rem : convergenceontrees ] on the convergence for satisfiable trees .",
    "the more intricate case is if @xmath14 contains @xmath20 positively .",
    "since we are in the free case , it must hold that @xmath520 . therefore using proposition [ 1msgiffunsatclm ]",
    "one obtains that @xmath416 is satisfiable ( regardless of the assignment of @xmath20 ) , and @xmath110 will converge as required ( again remark [ rem : convergenceontrees ] ) .",
    "now consider a tree hanging on a cycle clause .",
    "namely , @xmath521 , where @xmath522 are cycle variables , and @xmath523 is a tree edge .",
    "if one of the cycle orientations converged to 0 , then @xmath463 converges to 0 , and then remark [ rem : convergenceontrees ] guarantees correct convergence .",
    "the same applies to the case where @xmath524 converges to 1 and @xmath158 is positive in @xmath391 ( since then we can remove @xmath158 from the tree , use remark [ rem : convergenceontrees ] for the remaining part , then add back @xmath158 , and set it to true without causing any conflict with the tree assignment , but satisfying @xmath391 according to the planted assignment ) .",
    "the delicate case remains when @xmath524 converges to 1 but @xmath158 s polarity in @xmath391 disagrees with @xmath8 , that is , @xmath158 is negative in @xmath391 .",
    "the key observation is that the message @xmath525 ( which is directed towards the cycle ) must have converged to a positive value ( otherwise , @xmath526 and @xmath527 would have converged to 0 ) .",
    "however this complies with the scenario of proposition [ spinaldecomp ] , and again correct convergence is guaranteed .    in theorem [ convergencethmmed ]",
    "the unassigned variables are required to induce a",
    " simple \" formula , which is satisfiable in linear time .",
    "observe that the factor graph induced by the unassigned variables consists of connected components whose structure is a cycle with trees hanging on it , or just a tree . a formula",
    "whose factor graph is a tree can be satisfied in linear time by starting with the leaves ( which are determined uniquely in case that the leaf is a clause  namely , a unit clause , or if the leaf is a variable then it appears only in one clause , and can be immediately assigned ) and proceeding recursively . regarding the cycle ,",
    "consider an arbitrary variable @xmath11 on the cycle . by assigning @xmath11 and simplifying accordingly ,",
    "we remain with a tree .",
    "since there are only two ways to assign @xmath11 , the whole procedures is linear in the size of the connected component .",
    "this completes the proof of theorem [ convergencethmmed ] .",
    "since the cycle has no pure literal it must be of the following form : @xmath528 .",
    "consider one of the directed cycles , say : @xmath529 and note that when the message @xmath530 is updated it obtains the current value of @xmath531 and when the message @xmath532 is updated , it obtains the current value of @xmath530 .",
    "it thus suffices to show that the process above converges to all @xmath486 or all @xmath487 in time polynomial in the cycle length .",
    "this we prove in the lemma below .",
    "[ clm : perm_process ] consider the following process on @xmath533 .",
    "given the state of the process @xmath534 at round @xmath120 , the state @xmath535 at round @xmath293 is defined by choosing a permutation @xmath536 uniformly at random .",
    "then let @xmath537 and for @xmath538 , let @xmath539 be obtained from @xmath540 by setting @xmath541 and @xmath542 for all @xmath543 .",
    "finally , let @xmath544 .",
    "let @xmath396 be the stopping time where the process hits the state all @xmath486 or all @xmath487 .",
    "then @xmath545 \\leq l 2^{-a}.\\ ] ] for all @xmath546 integer .",
    "the proof of proposition  [ clm : perm_process ] is based on the fact that the process defined in this lemma is a martingle .",
    "this is established in the following two lemmas .",
    "[ lem : perm_process_mart ] consider the following variant @xmath547 of the process @xmath534 defined in proposition  [ clm : perm_process ] . in the variant , different intervals of @xmath548",
    "are assigned different colors and the copying procedure is as above .",
    "fix one color and let @xmath549 denote the number of elements of the cycle of that color in @xmath550 .",
    "then @xmath549 is a martingle with respect to the filtration defined by @xmath550 .    from the definition of the copying process it is easy to see that @xmath551 = e[x_{i+1 } | x_i].\\ ] ]",
    "we will show below that @xmath552 = 0 $ ] and thus that @xmath553 is a martingle with respect to the filtration @xmath550 .",
    "assume that @xmath554 .",
    "then w.l.o.g .",
    "we may assume that the configuration @xmath550 consists of an interval of @xmath487 s of length @xmath2 and an interval of @xmath486 s of length @xmath555 .",
    "we calculate separately the expected shifts in the locations of left end - points of the @xmath486 and @xmath487 interval respectively .",
    "we denote the two shift random variables by @xmath556 and @xmath557 .",
    "clearly @xmath558 where @xmath559 is the indicator of the event that @xmath486 left - end point shifted by at least @xmath140 and similarly for @xmath557 .",
    "note that @xmath560 = \\frac{1}{j ! } - \\frac{1}{(l - k+j)!}\\ ] ] and that @xmath561 = \\frac{1}{j ! } - \\frac{1}{(k+j)!}.\\ ] ] the last equation follows from the fact that in order for the @xmath487 interval to extend by at least @xmath140 , the @xmath140 copying has to take place in the correct order and it is forbidden that they all took place in the right order and the interval has become a @xmath486 interval .",
    "the previous equation is dervied similarly . thus @xmath562 = e[l_1 ] - e[l_0 ] = \\sum_{j=1}^{l - k } \\left(\\frac{1}{j ! } - \\frac{1}{(k+j)!}\\right ) - \\sum_{j=1}^{k } \\left(\\frac{1}{j ! } - \\frac{1}{(l - k+j)!}\\right ) = 0\\ ] ] this concludes the proof that @xmath549 is a martingle .",
    "the proof follows .",
    "+   + the proof of proposition  [ clm : perm_process ] follows by a union bound from the following lemma where the union is taken over all intervals .",
    "[ lem : perm_process_tail ] consider the process @xmath547 defined in lemma  [ lem : perm_process_mart ] .",
    "fix one interval and let @xmath549 denote its length .",
    "let @xmath396 be the stopping time where @xmath563 equals either @xmath486 or @xmath564 .",
    "then @xmath565 \\leq 2^{-a}.\\ ] ]    in order to bound the hitting probability of @xmath486 and @xmath564 , we need some bounds on the variance of the martingale differences . in particular , we claim that unless @xmath566 or @xmath567 it holds that @xmath568 \\geq 1/2.\\ ] ] if @xmath569 or @xmath570 this follows since with probability at least @xmath571 the end of the interval will be hit .",
    "otherwise , it is easy to see that the probability that @xmath572 is at least @xmath487 is at least @xmath573 and similarly the probability that it is at most @xmath574 is at least @xmath573 .",
    "this can be verified by considering the event that one end - points moves by at least @xmath575 and the other one by at most @xmath487 .",
    "let @xmath396 be the stopping time when @xmath576 hits @xmath486 or @xmath6 .",
    "then by a wald kind of calculation we obtain : @xmath577 = e [ ( \\sum_{t=1}^{\\infty } 1(t \\geq t ) ( x_t - x_{t-1}))^2 ] \\\\ & = & e[\\sum_{t , s=1}^{\\infty } ( x_t - x_{t-1})(x_s - x_{s-1 } ) 1(t \\geq \\max{t , s } ) ] \\\\ & = & e[\\sum_{t=1}^{\\infty } ( x_t - x_{t-1})^2 1(t \\geq t ) ] \\geq \\frac{1}{2 } \\sum_{t=1}^{\\infty } p[t \\geq t ] = e[t]/2,\\end{aligned}\\ ] ] where the first equality in the last line follows from the fact that if @xmath578 say then : @xmath579\\ ] ] @xmath580\\ ] ] @xmath581\\ ] ] @xmath582 = 0.\\ ] ]    we thus obtain that @xmath583 \\leq 2 l^2 $ ] .",
    "this implies in turn that @xmath584 \\leq 1/2 $ ] and that @xmath585 \\leq 2^{-a}$ ] for @xmath546 since @xmath586 is a markov chain .",
    "the proposition follows .",
    "our results show that is effective in solving @xmath7 . though not being the first to give an algorithm for @xmath7 , our results are a first example of rigourously analyzing a message passing algorithm on a natural non - trivial random sat distribution .",
    "we remark that our goal was to analyze under its most common definition , resisting attempts to modify the algorithm in ways that would simplify the analysis .",
    "one such simplification would result if in the first few iterations , messages are updated in _",
    "parallel _ in two phases : clause - variable messages updates and then variable - clause messages updates .    in the non - planted case , for low density formulas ( considerably below the satisfiability threshold )",
    ", some algorithms were rigorously shown to find @xmath5 a satisfying assignment efficiently @xcite .",
    "experimental results predict that as the density of the formula increases , more sophisticated algorithms are needed in order to find a satisfying assignment . at higher densities ( closer to the satisfiability threshold )",
    ", there is a major gap between the experimental performance of the best known algorithms @xcite ( a message passing algorithm that experimentally works at density @xmath5874.2 ) , and the best rigorously - analyzed algorithm @xcite ( density 3.52 ) .",
    "one possible explanation for the increasing computational hardness of finding solutions in the non - planted case is based on the geometry of the space of satisfying assignment .",
    "it is now established @xcite that for @xmath2-sat just below the satisfiability threshold and @xmath588 , the space of solutions decomposes into an exponential number of ( hamming - distance ) connected clusters such that the distance between each two is linear in the number of variables .",
    "such complex geometry of the space of solutions poses a complex algorithmic challenge .    our results , and similarly @xcite ,",
    "show that in the planted case ( with density some large constant above the satisfiability threshold ) , the algorithmic task of finding a satisfying assignment is relatively easy , and in particular , the nave algorithm is effective in finding satisfying assignments . planted formulas in this regime have only one cluster of satisfying assignments ( see @xcite for more discussion ) .",
    "we conclude with an open problem .",
    "can our analysis be extended to show that ( ) finds a satisfying assignment to @xmath7 in the setting of theorem [ convergencethmmed ] ?",
    "experimental results predict the answer to be positive .",
    "however , our analysis of does not extend as is to .",
    "in , all warnings received by a variable ( or by a clause ) have equal weight , but in this need not be the case ( there is a probability level associated with each warning ) .",
    "in particular , this may lead to the case that messages received from non - core portions of the formula can effect the core , a possibility that our analysis managed to exclude for the algorithm .",
    "a.  kaporis , l.  kirousis , and e.  lalas . the probabilistic analysis of a greedy satisfiability algorithm . in _ proc .",
    "10th annual european symposium on algorithms _ , volume 2461 of _ lecture notes in comput .",
    "_ , pages 574585 .",
    "springer , berlin , 2002 .",
    "m.  luby , m.  mitzenmacher , a.  shokrollahi , and d.  spielman .",
    "analysis of low density parity check codes and improved designs using irregular graphs . in _ proc .",
    "30th acm symp . on theory of computing _ , pages 249258 , 1998 ."
  ],
  "abstract_text": [
    "<S> experimental results show that certain message passing algorithms , namely , , are very effective in finding satisfying assignments for random satisfiable 3cnf formulas which are considered hard for other sat heuristics . unfortunately , rigorous understanding of this phenomena is still lacking . in this paper </S>",
    "<S> we make a modest step towards providing rigorous explanation for the effectiveness of message passing algorithms . </S>",
    "<S> we analyze the performance of , a popular message passing algorithm that is simpler than . </S>",
    "<S> we show that for 3cnf formulas drawn from a certain distribution over random satisfiable 3cnf formulas , commonly referred to as the planted - assignment distribution , running in the standard way ( run message passing until convergence , simplify the formula according to the resulting assignment , and satisfy the remaining subformula , if necessary , using a simple  off the shelf \" heuristic ) works when the clause - variable ratio is a sufficiently large constant . </S>",
    "<S> we are not aware of previous rigorous analysis of message passing algorithms for satisfiability instances , though such analysis was performed for decoding of low density parity check ( ldpc ) codes . </S>",
    "<S> we discuss some of the differences between results for the ldpc setting and our results . </S>"
  ]
}