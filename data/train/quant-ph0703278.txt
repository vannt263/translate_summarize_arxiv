{
  "article_text": [
    "stabilizer states are ubiquitous elements of quantum information theory , as a consequence both of their power and of their relative simplicity .",
    "the fields of quantum error correction , measurement - based quantum computation , and entanglement classification all make substantial use of stabilizer states and their transformations under clifford operations  @xcite .",
    "stabilizer states are distinctly quantum mechanical in that they can possess arbitrary amounts of entanglement , but the existence of a compact description that can be updated efficiently sets them apart from other highly entangled states .",
    "their prominence , as well as their name , derives from this description , a formalism in which a state is identified by a set of pauli operators generating the subgroup of the pauli group that stabilizes it , i.e. , the subgroup of which the state is the @xmath0 eigenvector . in this paper",
    "we seek to augment the stabilizer formalism by developing a graphical representation both of the states themselves and of the transformations induced on them by clifford operations .",
    "it is our hope that this representation will contribute to the understanding of this important class of states and to the ability to manipulate them efficiently .",
    "the notion of representing states graphically is not new .",
    "simple graphs are regularly used to represent _ graph states _ , i.e.",
    ", states that can be constructed by applying a sequence of controlled-@xmath1 gates to qubits each initially prepared in the state @xmath2 .",
    "the transformations of graph states under local clifford operations were studied by van den nest  @xcite , who found that local complementation generated all graphs corresponding to graph states related by local clifford operations .",
    "the results presented here constitute an extension of work by van den nest and others to arbitrary stabilizer states .",
    "our graphical depiction of stabilizer states is motivated by the equivalence of stabilizer states to graph states under local clifford operations  @xcite .",
    "because of this equivalence , _ stabilizer - state graphs _ can be constructed by first drawing the graph for a locally equivalent graph state and then adding decorations , which correspond to local clifford operations , to the nodes of the graph .",
    "only three kinds of decoration are needed since it is possible to convert an arbitrary stabilizer state to some graph state by applying one of six local clifford operations ( including no operation ) to each qubit .",
    "the standard form of the generator matrix for stabilizer states plays a crucial role in the development of this material , particularly in exploring the properties of _ reduced graphs _ , a subset of stabilizer graphs ( which we introduce ) that is sufficient for representing any stabilizer state .",
    "more generally , however , our stabilizer - state graphs are best understood in terms of a canonical circuit for creating the stabilizer state .",
    "this description also permits the use of circuit identities in proving various useful equalities . in this way",
    ", we establish a correspondence between clifford operations on stabilizer states and graph operations on the corresponding stabilizer - state graphs .",
    "ultimately , these rules allow us to simplify testing the equivalence of two stabilizer graphs to the point that the test becomes provably trivial .",
    "this paper is organized as follows .",
    "section  [ sec : background ] contains background information on stabilizer states , clifford operations , and quantum circuits .",
    "stabilizer - state graphs are developed in sec .",
    "[ sec : graphs ] , and a graphical description of the action of local clifford operations on these graphs is given in sec .",
    "[ sec : transformations ] .",
    "the issue of the uniqueness of stabilizer graphs is taken up in sec .",
    "[ sec : equiv ] .",
    "the appendix deals with the graph transformations associated with @xmath3 gates .",
    "the _ pauli group _ on @xmath4 qubits , @xmath5 , is defined to be the group , under matrix multiplication , of all @xmath4-fold tensor products of the identity , @xmath6 , and the pauli matrices , @xmath7 , @xmath8 , and @xmath9 , including overall phases @xmath10 and @xmath11 . a _ stabilizer state _",
    "is defined to be the simultaneous @xmath0 eigenstate of a set of @xmath4 commuting , hermitian pauli - group elements that are independent in the sense that none of them can be written as a product of the others .",
    "these elements are called _ stabilizer generators _ and are denoted here by @xmath12 , while @xmath13 is used to denote the @xmath14th pauli matrix in the tensor - product decomposition of generator @xmath12 .",
    "stabilizer generator sets are not unique ; replacing any generator with the product of itself and another generator yields an equivalent generating set .",
    "an arbitrary product of stabilizer generators , @xmath15 , where @xmath16 is called a _ stabilizer element _ ; the stabilizer elements make up a subgroup of the pauli group known as the _",
    "stabilizer_.    a _ graph state _ is a special kind of stabilizer state whose generators can be written in terms of a simple graph as @xmath17 where @xmath18 denotes the set of neighbors of node @xmath19 in the graph ( see sec .  [",
    "subsec : terminology ] and ref .",
    "@xcite for graph terminology ) .",
    "_ simple graphs _ and , hence , graph states can also be defined in terms of an _ adjacency matrix _ @xmath20 , where @xmath21 if @xmath22 and @xmath23 otherwise . in a simple graph ,",
    "a node is never its own neighbor , i.e. , there are no self - loops ; thus the diagonal elements of the adjacency matrix of a simple graph are all equal to zero .",
    "the binary representation of the pauli group associates a two - dimensional binary vector @xmath24 with each pauli matrix @xmath25 , where @xmath26 , @xmath27 , @xmath28 , and @xmath29 .",
    "this association is generalized to an arbitrary element @xmath30 , whose @xmath14th pauli matrix is @xmath31 , by letting @xmath32 be a @xmath33-dimensional vector whose @xmath14th and @xmath34th entries are the entries of @xmath35 , i.e. , @xmath36_k & [ r(p)]_{n+k } \\end{array } \\right)$ ] . the binary representation of a pauli - group element specifies the element up to the overall phase of @xmath37 or @xmath38 ; hermitian pauli - group elements are specified up to a sign .",
    "the binary representation of the product of two pauli - group elements , @xmath39 , is the binary sum of their associated vectors , i.e. , @xmath40 .",
    "two such elements commute if their _ skew product _ , @xmath41_j[r(q)]_{n+j}+[r(p)]_{n+j}[r(q)]_j\\;,\\ ] ] has value @xmath42 ; otherwise they anticommute .    using binary notation , a full set of generators for a stabilizer state can be represented ( up to a sign for each generator ) by an @xmath43 _ generator matrix _ whose @xmath19th row is @xmath44 . because the stabilizer generators commute , the rows of the generator matrix are orthogonal under the skew product .",
    "similarly , the independence of the stabilizer generators under matrix multiplication implies that the rows of the generator matrix are linearly independent under addition .",
    "the freedom to take products of stabilizer generators without changing the stabilized state becomes , for the generator matrix , the freedom to add one row of the matrix to another .",
    "the exchange of any pair of qubits @xmath19 and @xmath14 of a stabilizer state corresponds to the exchange of columns @xmath19 and @xmath14 and columns @xmath45 and @xmath46 in the generator matrix . since rows of the generator matrix are linearly independent and have vanishing skew product , these two operations are sufficient to allow us to transform any generator matrix to a _",
    "canonical form _",
    "@xcite , @xmath47 where @xmath48 and the vertical line divides the matrix in half .",
    "the vanishing skew product of rows of the generator matrix implies that @xmath49 is a symmetric matrix and that @xmath50 and @xmath51 appear as indicated .",
    "the @xmath6s in eq .",
    "( [ eq : canonicalstabilizer ] ) denote a pair of identity matrices whose dimensions sum to @xmath4 .",
    "the dimension of the upper left identity matrix is called the _ left rank _ of the generator matrix . due to the freedom inherent in qubit exchange ,",
    "the canonical form of the generator matrix is not unique .    for graph states , eq .",
    "( [ eq : canonicalstabilizer ] ) becomes @xmath52 where @xmath49 has only @xmath42s on the diagonal .",
    "graph states thus have generator matrices of full left rank , with @xmath49 being the adjacency matrix of the graph state s underlying graph .",
    "we denote generator matrices of this sort by the term _ strict graph form _ , whereas the term _ graph form _",
    "is used for generator matrices of the form shown in eq .",
    "( [ eq : canonicalgraph ] ) where @xmath49 is any symmetric matrix .",
    "the binary representation does not encode the sign of pauli group elements , so the generator matrix really specifies a set of generators up to @xmath53 possible sign assignments and thus specifies not a single stabilizer state , but rather an orthonormal basis of simultaneous eigenstates of the generators , each member of which corresponds to one of the sign choices . despite this , we continue , for convenience , to refer to _ the _ stabilizer state associated with a generator matrix .",
    "the _ clifford group _ is the normalizer of the pauli group , i.e. , the set of all unitary operators @xmath54 such that @xmath55 for all @xmath56 .",
    "any local operation in the clifford group can be obtained by repeated application of hadamard and phase gates , which are written in the standard basis as @xmath57 respectively .",
    "adding the two - qubit controlled-@xmath1 ( or controlled - sign ) gate , @xmath58 completes the basis for clifford operations  @xcite .",
    "quantum - circuit notation  @xcite is a pictorial method for representing the application of discrete operations to a quantum system . as with electrical circuits , repeated usage of a small number of simple , standard parts results in complex quantum circuits that are easier to understand and implement .",
    "a typical component gate set contains a basis for clifford operations together with a single non - clifford operation . for brevity , we employ more clifford gates than are necessary to generate the clifford group , augmenting the gates of eqs .",
    "( [ eq : hsdefinition ] ) and ( [ eq : czdefinition ] ) by the pauli matrices and @xmath59 .",
    "any state can be expressed in terms of a quantum circuit that prepares it from some fiducial state , traditionally taken to be the one in which each qubit is initially in the state @xmath60 . to prepare any @xmath61-qubit stabilizer state from @xmath62",
    ", it is sufficient to apply clifford gates , since , by definition of the clifford group , there exists a clifford operation that takes the stabilizer of the fiducial state to the stabilizer of the desired state under conjugation . applying this operation to the fiducial state yields a @xmath0 eigenstate of the stabilizers of the desired state , i.e. , the desired stabilizer state .",
    "graph states can be written in a particularly simple form using quantum - circuit notation .",
    "any graph state can be prepared using two layers of gates . in the first layer , @xmath63 is applied to each qubit . in the second layer , @xmath3 gates are applied between all pairs of qubits corresponding to connected nodes on the graph . to prepare an arbitrary stabilizer state",
    ", it is sufficient to add a third layer that contains only @xmath63 and @xmath64 gates .",
    "this is because any stabilizer state is equivalent to some graph state under local clifford operations  @xcite .",
    "any stabilizer state with a generator matrix of canonical form can be converted by local clifford operations to a state possessing a generator matrix of strict graph form . applying @xmath63 to the last @xmath65 qubits of the stabilizer state , where @xmath66 is the initial left rank of the canonical - form generator matrix , exchanges columns @xmath67 through @xmath4 in the generator matrix with columns @xmath68 through @xmath33 , so that a generator matrix as in eq .",
    "( [ eq : canonicalstabilizer ] ) is transformed to @xmath69 the diagonal of @xmath49 in this graph - form generator matrix can then be stripped of @xmath70s without otherwise changing the generator matrix by applying @xmath64 to offending qubits .",
    "the resulting generator matrix has the form of a graph state and corresponds to a stabilizer state that differs from that represented by eq .",
    "( [ eq : canonicalstabilizer ] ) by at most a single @xmath63 or @xmath64 gate per qubit .",
    "the close relationship between graph states and stabilizer states suggests the possibility of a graph - like representation of stabilizer states .",
    "one approach to such a representation is simply to transform the generator matrix of a stabilizer state into strict graph form , draw the graph thereby obtained , and add decorations to each node indicating whether an @xmath63 or @xmath64 was applied to the corresponding qubit in the process of reaching strict graph form .",
    "thus are stabilizer graphs constructed in this paper , where we choose to signal the application of hadamard gates by hollow ( unfilled ) nodes and the application of phase gates by loops .",
    "the decision to represent @xmath64 gates by loops is motivated by the standard graph convention that a @xmath70 on the diagonal of an adjacency matrix denotes a loop on that node .     and",
    "@xmath71 on the left with the matching columns on the right , an operation that corresponds to applying a hadamard to qubits @xmath72 and @xmath71 . in graph form ,",
    "the adjacency matrix is just the right half of the generator matrix .",
    "loops arise from @xmath70s on the diagonal of the adjacency matrix , and hollow nodes are used to indicate which columns were exchanged between the right and left halves of the generator matrix to get the adjacency matrix .",
    "notice that there are no edges between hollow nodes , nor are there any loops on hollow nodes.[fig : graph],width=321 ]    the following steps provide a recipe for translating an arbitrary stabilizer generator matrix into a _ stabilizer graph _ :    1 .   through row reduction and qubit swapping ,",
    "transform the generator matrix into canonical form , as in eq .",
    "( [ eq : canonicalstabilizer ] ) , keeping track during the process of how columns of the generator matrix map to qubits .",
    "2 .   draw the graph corresponding to the adjacency matrix @xmath73 including loops for @xmath70s on the diagonal .",
    "3 .   make solid the nodes corresponding to the rows and columns of the submatrix @xmath49 , and make hollow the nodes corresponding to the rows and columns of the submatrix @xmath42 .",
    "notice that this procedure does not associate every combination of edges , loops , hollow nodes , and solid nodes with a stabilizer state . because the submatrix @xmath42 in eq .",
    "( [ eq : baat0 ] ) contains only @xmath42s , hollow nodes never have loops , and there are no edges between hollow nodes .",
    "we refer to stabilizer graphs having this property as _ reduced_. an example of a generator matrix and an associated reduced stabilizer graph is given in fig .",
    "[ fig : graph ] .",
    "it is important to note that the graphs in this paper are _ labeled graphs _ in that each node is associated with a particular qubit . swapping two qubits",
    "is a physical operation that generally produces a different quantum state . in our graphs",
    "gate can be described either by relabeling the corresponding nodes or by exchanging the nodes and all their decorations and connections while leaving the labeling the same . since the process of bringing the generator matrix into canonical form can involve swapping qubits",
    ", we must keep track during this process of the correspondence between qubits and columns of the generator matrix and thus between these columns and the nodes of our graphs .    just as a generator matrix contains no information about generator signs ,",
    "so also are stabilizer graphs derived from generator matrices devoid of such information .",
    "it is for this reason that we can be cavalier about whether @xmath64 or @xmath74 is used to convert a canonical generator matrix to strict graph form . in the absence of sign information ,",
    "however , stabilizer graphs are best thought of as specifying an orthonormal basis rather than a single stabilizer state .",
    "luckily , it is not hard to include sign information in the graph , as we show in the next subsection .      having motivated a stabilizer - graph notation using generator matrices , we now turn to the quantum - circuit formalism to expand it .",
    "the binary representation of stabilizers lacks a convenient way to keep track of generator signs , applied gates , and qubit swaps . since , for example , labeling is important , the column exchanges required to bring a generator matrix to canonical form must be tracked , perhaps by appending an extra row with qubit labels to the generator matrix .",
    "details such as this are automatically dealt with when deriving stabilizer graphs from quantum circuits .",
    "consider a quantum circuit consisting of three layers of gates applied to @xmath4 qubits , each initially in the state @xmath60 .",
    "in the first layer , the hadamard gate , @xmath63 , is applied to each qubit . in the second",
    ", controlled - sign gates , @xmath3 , are applied between various pairs of qubits .",
    "finally , in the third layer , sign - flip gates , @xmath1 , phase gates , @xmath64 , and hadamard gates are applied ( in that order ) to various subsets of qubits .",
    "we refer to such circuits as having _ graph form_.",
    "the descriptor arises because a quantum circuit in this form can be depicted as a graph possessing three kinds of decoration .",
    "in such a graph , two nodes are linked if a @xmath3 gate is applied between the qubits of the circuit corresponding to those nodes ; the various kinds of node decoration indicate the presence or absence of terminal @xmath1 , @xmath64 , and @xmath63 gates on the corresponding qubits .",
    "it is the restrictions of such a representation that impel us to specify an order for the terminal gates , since @xmath75 .",
    "the decoration corresponding to each gate is as follows : @xmath1 gates are denoted by a minus sign in the node , @xmath64 gates by a loop , and @xmath63 gates by a hollow ( as opposed to a solid ) node .",
    "we refer to an arbitrary arrangement of solid and hollow nodes with loops , edges , and signs as a _ stabilizer - state graph _ or , more simply , as a _ stabilizer graph_. an example graph - form circuit and the corresponding stabilizer graph are given in fig .",
    "[ fig : stabgraph ] .     gates between qubits are transformed into links between nodes , terminating @xmath1 gates become negative signs , terminating @xmath64 gates result in loops , and terminating @xmath63 gates are denoted by hollow nodes .",
    "nodes in  ( b ) are labeled sequentially , beginning with the top node and moving clockwise .",
    "[ fig : stabgraph],width=321 ]    as might be guessed from our choice of decorations , the @xmath1 gates in a graph - form circuit specify the signs of the stabilizer generators .",
    "the gates applied in the third layer of a graph - form circuit can be written as @xmath76 where @xmath77 , @xmath78 , and @xmath79 are binary variables taking on the values @xmath42 or @xmath70 . from eq .",
    "( [ eq : thirdlayer ] ) it follows that the third layer of gates transforms a set of graph - state generators as in eq .",
    "( [ eq : graphgenerators ] ) to the following stabilizer - state generators : @xmath80 equation  ( [ eq : stabilizerstategenerators ] ) shows that the exclusive effect of each terminal @xmath1 operator is to flip the sign of a single stabilizer generator .",
    "this can also be seen through circuit identities , since pushing a @xmath1 gate from the third layer of a graph - form quantum circuit to the beginning of the circuit merely transforms it to an @xmath81 gate ; flipping an input bit is equivalent to flipping the sign of the associated stabilizer since the stabilizer of @xmath60 is @xmath1 , which acquires a negative sign under conjugation by @xmath81 .",
    "using either of these methods , it is clear that terminal @xmath1 gates , and hence the signs in stabilizer graphs , only impact the signs of the stabilizer generators , and can thus be omitted when these signs are thought to be unimportant .",
    "modulo generator signs , the definition of stabilizer graphs given in the previous subsection and the definition given in this one are compatible .",
    "the graph - form circuit and generator matrix associated with a stabilizer graph each specify the same stabilizer up to possible signs .",
    "the method of deriving stabilizer graphs from generator matrices described in sec .",
    "[ subsec : gengraphs ] , however , produces exclusively reduced stabilizer graphs , i.e. , stabilizer graphs satisfying the restriction that hollow nodes never have loops and never be connected to other hollow nodes . in terms of graph - form quantum circuits , this is the restriction that lines with terminating hadamard gates have no terminating @xmath64 gates and not be connected by @xmath3 gates .",
    "the relative merits of stabilizer graphs and reduced stabilizer graphs are clarified in the following sections , particularly sec .",
    "[ sec : equiv ] .",
    "important roles are found for both .",
    "it is frequently useful to consider the way in which stabilizer states transform under the application of clifford gates .",
    "primarily , this is because clifford gates take stabilizer states to stabilizer states , a property that follows from their preservation of the pauli group .",
    "this same property implies that the action of a clifford gate can be thought of as a transformation between the graphs representing the initial and final stabilizer states . in this section",
    "we consider the transformations induced by local clifford gates .",
    "the transformations induced by @xmath3 gates are discussed separately in the appendix .",
    "we begin by introducing terminology for describing transformations on stabilizer graphs .",
    "we use a number of terms , some adopted from graph theory and others invented for the task at hand .    among those terms common to graph theory",
    "are _ neighbors _ , _ complement _ , and _ local complement_. the neighbors of a node  @xmath19 are those nodes connected to @xmath19 by edges ; we denote the set of neighbors of node  @xmath19 by @xmath82 . in the transformation rules that follow , a loop does not count as an edge , so a node is never its own neighbor . complementing the edge between two nodes",
    "removes the edge if one is present and adds one otherwise .",
    "the local complement is performed by complementing a selection of edges , with the pattern of edges depending on whether local complementation is applied to a node or along an edge .",
    "performing local complementation on a node complements the edges between all of the node s neighbors .",
    "thus , local complementation at node  @xmath19 transforms the adjacency matrix  @xmath20 of a graph according to @xmath83 i.e. , it complements an edge if both nodes of the edge are neighbors of @xmath19 .",
    "local complementation along an edge is equivalent to a sequence of local complementations on the _ decision nodes _ ,",
    "i.e. , the nodes defining the edge .",
    "the sequence is as follows : first perform local complementation on one of the decision nodes , then local complement on the other decision node , and finally local complement on the first decision node again .",
    "this sequence transforms the adjacency matrix of a simple graph in the following way : @xmath84 where @xmath19 and @xmath14 are the decision nodes .",
    "equation  ( [ eq : threelc ] ) is symmetric in the two decision nodes , so it does not matter at which decision node local complementation is first performed .",
    "additionally , since we do not consider self - loops to be edges , eq .",
    "( [ eq : threelc ] ) can be applied to adjacency matrices with nonzero diagonal entries simply by ignoring those entries .",
    "notice that an edge one of whose nodes is a decision node transforms according to @xmath85 .    to describe the net effect of local complementation along an edge , it is helpful to define the _ decision neighborhood _ of a node as the intersection of its neighborhood with the decision nodes",
    ". then local complementation along an edge can be summarized by three steps :    1 .",
    "the edge between the decision nodes is left unchanged .",
    "an edge one of whose nodes is a decision node is transferred from this decision node to the other .",
    "an edge neither of whose nodes is a decision node is complemented if its end nodes have decision neighborhoods that are not empty and not identical .    to these terms",
    "we add _ flip _ and _ advance_. flip is used to describe the simple reversal of some binary property , such as the sign or the fill state ( color ) of a node .",
    "advance refers specifically to an action on loops ; advancing generates a loop on nodes where there was not previously one , and it removes the loop and flips the sign on nodes where there was a loop .",
    "its action mirrors the application of the phase gate , since @xmath86 .",
    "an arbitrary local clifford operation can be decomposed into a product of @xmath63 , @xmath64 , and @xmath1 gates ( the @xmath1 is unnecessary , but convenient ) .",
    "the effect of a local clifford operation on a stabilizer graph can thus be obtained by repeated application of the following six transformation rules .    1 .",
    "applying @xmath63 to a node flips its fill .",
    "2 .   applying @xmath64 to a solid node advances its loop .",
    "3 .   applying @xmath64 to a hollow node without a loop performs local complementation on the node and advances the loops of its neighbors .",
    "+ if the node has a negative sign , flip the signs of its neighbors as well .",
    "4 .   applying @xmath64 to a hollow node with a loop flips its fill , removes its loop , performs local complementation on it , and advances the loops of its neighbors .",
    "+ if the node does not have a negative sign , flip the signs of its neighbors as well . 5 .   applying @xmath1 to",
    "a solid node flips its sign .",
    "applying @xmath1 to a hollow node flips the signs of all of its neighbors .",
    "if the node has a loop , its own sign is flipped as well .",
    "these transformation rules can be derived from the circuit identities in fig .",
    "[ fig : identproof ] , which rely on the basic circuit identities given in fig .",
    "[ fig : basics ] . given an understanding of the relationship between circuits and graphs , transformation rules t1 , t2 , and t5 are trivial .",
    "transformation rule t6 follows simply from fig .",
    "[ fig : identproof](a , b ) .",
    "transformation rules t3 and t4 derive from figs .",
    "[ fig : identproof](c ) and ( d ) , respectively .",
    "the transformation rules t1t6 do not generally take reduced stabilizer graphs to reduced stabilizer graphs . from sec .",
    "[ subsec : gengraphs ] , however , we know that there exists a reduced stabilizer graph corresponding to each stabilizer state , so it is always possible to represent the effect of a local clifford operation as a mapping between reduced stabilizer graphs .",
    "the appropriate transformation rules for reduced stabilizer graphs are listed below , excepting those for @xmath1 operations , which are identical to t5 and t6 .",
    "applying @xmath63 to a solid node without a loop , which is only connected to other solid nodes , flips the fill of that node .",
    "applying @xmath63 to a solid node with a loop , which is only connected to other solid nodes , performs local complementation on the node and advances the loops of its neighbors .",
    "flip the node s sign , and if it now has a negative sign , flip the signs of its neighbors as well .",
    "applying @xmath63 to a solid node without a loop , which is connected to a hollow node , flips the fill of the hollow node and performs local complementation along the edge connecting the nodes .",
    "flip the sign of nodes connected to both the solid and hollow nodes .",
    "if either of these two nodes has a negative sign , flip it and the signs of its current neighbors .    applying @xmath63 to a solid node with a loop , which is connected to a hollow node ,",
    "performs local complementation on the solid node and then on the hollow node .",
    "then it removes the loop from the solid node , advances the loops of the solid node s current neighbors , and flips the fill of the hollow node .",
    "flip the signs of nodes that were originally connected to both the solid and hollow nodes . if the originally solid node initially had a negative sign ,",
    "flip it and the signs of its current neighbors , and if the originally hollow node initially had a negative sign , flip the signs of its current neighbors .    applying @xmath63 to",
    "a hollow node flips its fill .",
    "applying @xmath64 to a solid node advances its loop .",
    "applying @xmath64 to a hollow node performs local complementation on that node and advances the loops of its neighbors .",
    "if the node has a negative sign , flip the signs of its neighbors as well .    of these transformation rules , t(i ) , t(v ) ,",
    "and t(vi ) are trivial , and t(vii ) is a rewrite of t3 . to prove the others requires results from sec .",
    "[ sec : equiv ] , in particular , the equivalence rules in sec .  [ subsec : circuitequiv ] .",
    "specifically , t(ii ) is obtained by applying equivalence rule  e1 , which gives an equivalent , but unreduced graph and then applying the hadamard , via rule  t1 , which leaves a reduced graph . for t(iii ) , one first applies the hadamard , via rule  t1 , and then uses equivalence rule  e2 to convert to a reduced graph . in the case of t(iv ) , one applies the hadamard , using rule  t1 , and then applies equivalence rule e1 , first to the originally solid node and then to the hollow node .",
    "a key part of these transformations is the conversion of stabilizer graphs to reduced form , a process discussed in more detail in sec .",
    "[ subsubsec : convert ] .",
    "it is not hard to check that , in using rules t(iii ) and t(iv ) , any other hollow nodes that are connected to the originally solid node do not become connected and do not acquire loops , in accordance with the need to end up with a reduced graph .",
    "as we have defined it , the mapping between a graph - form circuit and its corresponding stabilizer graph is one - to - one .",
    "this does not imply , however , that each stabilizer state corresponds to a unique graph . on the contrary , an example of different graph - form circuits corresponding to the same stabilizer state",
    "can be found in fig .",
    "[ fig : identproof ] . applying an additional @xmath64 gate to the top qubit in fig .",
    "[ fig : identproof](d ) makes the initial circuit identical to that in  ( b ) , but the final circuits are quite different .",
    "the two circuit identities thus define distinct transformation rules for applying a @xmath1 gate to a hollow node with a loop , thereby demonstrating the existence of multiple , equivalent graph - form circuits . for every way of obtaining a particular stabilizer state from a circuit in graph form",
    ", there is an associated stabilizer graph . in this section",
    "we examine the resulting equivalence classes of stabilizer graphs , first by presenting equivalence rules for full and reduced stabilizer graphs and then by introducing simplified graph - form - circuit equalities which we use to show that the equivalence rules given here are complete .          applying either of the following two rules to a stabilizer graph yields an equivalent graph , i.e. , one which represents the same stabilizer state .    1 .",
    "flip the fill of a node with a loop .",
    "perform local complementation on the node , and advance the loops of its neighbors .",
    "+ flip the node s sign , and if the node now has a negative sign , flip the signs of its neighbors as well .",
    "2 .   flip the fills of two connected nodes without loops , and local complement along the edge between them .",
    "+ flip the signs of nodes connected to both of the two original nodes .",
    "if either of the two original nodes has a negative sign , flip it and the signs of its current neighbors .",
    "the first of these equivalence rules can be obtained by applying an additional @xmath64 gate to the top qubit in the identity of fig .",
    "[ fig : identproof](d ) and equating the final circuit to the final circuit in fig .",
    "[ fig : identproof](b ) . for the second rule ,",
    "we need yet another circuit identity .",
    "figure  [ fig : transident](a ) shows how hadamards can be removed from a pair of connected qubits without @xmath64 gates .",
    "figure  [ fig : transident](b ) extends this identity to a demonstration of rule  e2 .",
    "the equivalence rules of the previous section can be reworked to yield equivalence rules for reduced stabilizer graphs .",
    "the resulting equivalence rules are    for a hollow node connected to a solid node with a loop , local complement on the solid node and then on the hollow node . then remove the loop from the solid node , advance the loops of its current neighbors , and flip the fills of both nodes .    as for signs ,",
    "follow the sequence in transformation rule t(iv ) .",
    "for a hollow node connected to a solid node without a loop , local complement along the edge between them .",
    "then flip the fills of both nodes .    as for signs , follow the sequence in equivalence rule  e2 .",
    "there is a simple relationship between the two sets of equivalence rules .",
    "equivalence rule e(ii ) is identical to e2 for the case that the two connected nodes have opposite fill .",
    "equivalence rule e(i ) is simply rule e1 applied twice : first to the solid node with the loop and then once to the hollow node that has acquired a loop from the first application of e1 .",
    "the second application of e1 is needed because the resulting graph is not reduced after one employment of the rule .",
    "both of these equivalence rules can also be derived by applying two hadamards to a solid node , e(i ) handling the case in which the solid node has a loop and e(ii ) the case in which it does not .",
    "thus equivalence rule  e(i ) is simply transformation rule  t(iv ) followed by use of rule  t(i ) to apply a second hadamard to the originally solid node . likewise , e(ii ) is rule  t(iii ) followed by t(i ) to apply a second hadamard to the originally solid node .",
    "notice that both rules preserve the number of hollow nodes .",
    "having described a set of rules for converting between equivalent stabilizer graphs , we show in this section that , in each case , the aforementioned rules generate the entire equivalence class of stabilizer graphs . the proof is divided into three parts .",
    "the first part shows how to use rules  e1 and e2 to convert an arbitrary stabilizer graph to an equivalent graph in reduced form .",
    "the second part explains how an equivalence test for a pair of reduced stabilizer graphs can be simplified , using rules  e(i ) and  e(ii ) , to a special form .",
    "finally , the third part proves that the graphs on the two sides of such a simplified equivalence test are equivalent only if they are trivially identical . taken as a whole",
    ", this proves that the set of equivalence rules given in secs .",
    "[ subsec : circuitequiv ] and [ subsec : redequiv ] is sufficient to convert ( reversibly ) between any two equivalent stabilizer graphs and thus that they generate all stabilizer graphs that are equivalent to the same stabilizer state . similarly , considering only the final two parts of the proof shows that the rules given in sec .",
    "[ subsec : redequiv ] are sufficient to generate all reduced stabilizer graphs .",
    "two features identify a stabilizer graph as reduced . in a reduced graph ,",
    "hollow nodes never have loops , and hollow nodes are never connected to each other .",
    "equivalence rule  e1 can be used to convert looped nodes from hollow to solid . applying",
    "rule e1 in this sort of situation can cause hollow nodes to acquire loops , but each application fills one hollow node of the graph , so the procedure will terminate in at most a number of repetitions equal to the number of hollow nodes in the graph .",
    "similarly , connected hollow nodes in the resulting graph can be converted to solid nodes using the appropriate case of rule e2 .",
    "once again , the process is guaranteed to terminate because the number of hollow nodes to which the rule might be applied decreases by two with each application of the rule .",
    "concomitantly , the conversion of a stabilizer graph to an equivalent reduced graph never increases the number of hollow nodes .",
    "equivalence testing for pairs of reduced graphs is facilitated by simplifying the equivalence such that nodes that are hollow only in the first graph never connect to nodes that are hollow only in the second .",
    "this simplification can be accomplished by iterating the following process .",
    "choose a pair of connected ( in either graph ) nodes @xmath87 and @xmath88 such that @xmath87 is hollow in one graph and @xmath88 is hollow in the other , and to the graph in which they are connected , apply the relevant reduced equivalence rule to the selected nodes . among other things ,",
    "the equivalence operation reverses the fill of the two nodes it is applied to . since one node is hollow and the other solid , this preserves the total number of hollow nodes while yielding a node that is hollow in both graphs . because it is applied only to unpaired hollow nodes , subsequent uses of this equivalence rule do not disturb the newly paired hollow node .",
    "consequently , this process also terminates in at most a number of repetitions equal to the number of hollow nodes in each of the graphs .",
    "the two reduced graphs composing a simplified reduced - graph equivalence test are equivalent , i.e. , correspond to the same state , if and only if the graphs are identical . to see why this is so , we return to the graph - form quantum circuits discussed earlier .",
    "in addition to the standard restrictions for reduced graphs , the circuits corresponding to the graphs in a simplified equivalence test have the following property : if in one of the circuits , a qubit with a terminal @xmath63 participates in a @xmath3 gate with a second qubit ( which can not have a terminal @xmath63 ) , then in the other circuit , it can not be true that the second qubit has a terminal @xmath63 and the first does not .",
    "we prove the triviality of simplified reduced - graph equivalence testing by considering an arbitrary simplified reduced - graph equivalence test and showing that the two graphs must be identical if they are to correspond to the same state .    in terms of unitaries ,",
    "an arbitrary graph - form circuit equality can be written as @xmath89 where @xmath90 lists the pairs of qubits participating in @xmath3 gates and @xmath91 , @xmath92 , and @xmath93 are sets enumerating the qubits to which @xmath63 , @xmath1 , and @xmath64 gates are applied respectively .",
    "the total number of qubits is denoted by @xmath61 and the subscripts @xmath94 and @xmath66 discriminate between the circuits on the left- and right - hand sides of the equation . in terms of these sets , a reduced - graph - form circuit satisfies the constraints @xmath95 and @xmath96 for all @xmath97 .",
    "the circuits in simplified tests also satisfy @xmath98 for all @xmath99 and @xmath100 , where @xmath101 denotes the complement of @xmath91 , i.e. , the set of qubits to which @xmath63 is not applied .",
    "suppose now that the two graphs have hollow nodes at different locations ; i.e. , at least one of the sets , @xmath102 and @xmath103 , is not empty . for specificity ,",
    "let s say that @xmath102 is not empty .",
    "in the language of circuits , this means that there exists a qubit @xmath87 that has a terminal @xmath63 on the left side of eq .",
    "( [ eq : arbsimpgraphformcircequal ] ) , but not on the right side .",
    "since qubit  @xmath87 is part of a circuit for a reduced graph , it does not participate in @xmath3 gates with other qubits that possess terminal @xmath63 gates .",
    "consequently , on the left side of eq .",
    "( [ eq : arbsimpgraphformcircequal ] ) , the @xmath3 gates involving qubit @xmath87 can all be moved to the end of the circuit where they become @xmath104 gates with @xmath87 as the target . doing this and transferring the @xmath104 gates to the other side yields ,    @xmath105    where @xmath106 denotes the set of qubits that participate in @xmath3 gates with qubit @xmath87 on the left - hand side of eq .",
    "( [ eq : arbsimpgraphformcircequal ] ) .    because the original graph equality  ( [ eq : arbsimpgraphformcircequal ] ) was simplified , @xmath107 and , by assumption , @xmath108 , so the @xmath104 gates and the terminal hadamards on the right side of eq .",
    "( [ eq : modcircequal ] ) do not act on the same qubits .",
    "thus we can commute the @xmath104 gates past the terminal hadamards .",
    "moreover , we can then move the @xmath104 gates to the beginning of the circuit where they have no effect and can therefore be dropped .",
    "during this migration , however , they generate a complicated menagerie of phases . the resulting expression for the right side of eq .",
    "( [ eq : modcircequal ] ) is @xmath109    where @xmath110 is defined similarly to @xmath106 , @xmath111 and @xmath112 represents an indicator function , e.g. , @xmath113 equals @xmath70 if @xmath114 and @xmath42 otherwise .",
    "it might appear that we have made things substantially worse by this rearrangement , but in an important sense , eq .  (",
    "[ eq : modcircequalright ] ) is now very simple with regard to qubit  @xmath87 : @xmath63 is applied to qubit  @xmath87 followed by a sequence of unitary gates all of which are diagonal in the standard basis .",
    "this implies that there are an equal number of terms in the resultant state where qubit  @xmath87 is in the state @xmath60 and the state @xmath115 . on the left side of eq .",
    "( [ eq : modcircequal ] ) , however , the only gate remaining on qubit  @xmath87 is the identity or an @xmath81 , depending on whether @xmath116 ; thus qubit  @xmath87 is separable and is either in state @xmath60 or @xmath115 depending on whether @xmath116 .",
    "consequently , our initial assumption that @xmath117 is incompatible with satisfying the equality .",
    "the preceding discussion shows that two graphs composing a simplified equivalence test are equivalent only if they have hollow nodes in exactly the same locations .",
    "given this constraint , the terminal hadamards can be canceled from both sides of eq .",
    "( [ eq : arbsimpgraphformcircequal ] ) , giving @xmath118 the state after the initial hadamards is an equally weighted superposition of all the states in the standard basis .",
    "the subsequent unitaries are diagonal in the standard basis , so they put various phases in front of the terms in the equal superposition . since a unitary is fully described by its action on a complete set of basis states , demanding equality term - by - term in eq .",
    "( [ eq : paredsimpgraphformcircequal ] ) amounts to requiring that @xmath119 which is only satisfied when @xmath120 , @xmath121 , and @xmath122 .",
    "thus , after simplification , the equivalence of pairs of reduced graphs is trivial to evaluate , since equivalence requires that the two graphs be identical .",
    "an example of the entire process of testing graph equivalence is given in fig .",
    "[ fig : equivalenceexample ] . an example which illustrates the circuit manipulations described algebraically in the text of this section",
    "is given in fig .",
    "[ fig : partthreeexample ] .    as mentioned above",
    ", our proof provides a constructive procedure for testing the equivalence of stabilizer graphs .",
    "moreover , it shows that the set of equivalence rules given in sec .",
    "[ subsec : circuitequiv ] is sufficient to convert between any equivalent stabilizer graphs and that the rules given in sec .",
    "[ subsec : redequiv ] are sufficient to convert between any equivalent reduced stabilizer graphs . since the conversion of an arbitrary stabilizer graph to reduced form never increases the number of hollow nodes and the rules  e(i ) and e(ii ) that convert among reduced graphs preserve the number of hollow nodes , we conclude that the reduced stabilizer graphs for a stabilizer state are those that have the least number of hollow nodes .",
    "motivated by the relation between the graphs and the generator matrices associated with graph states , we extend the graph representation of states to encompass all stabilizer states .",
    "these _ stabilizer graphs _ differ from the graphs employed by @xcite in that nodes can be either hollow or solid and can possess both loops and signs .",
    "the additional decorations identify the local clifford operations that relate the desired stabilizer state to the graph state corresponding to the unadorned graph . imposing the restriction that the number of hollow nodes be minimal yields a subset of the stabilizer graphs which we term reduced .",
    "reduced graphs follow naturally from the binary representation of the stabilizer formalism , while generic stabilizer graphs are more closely related to the quantum - circuit formalism . for graph states ,",
    "reduced stabilizer graphs are identical to the standard representation of these states in terms of graphs .    using circuit identities",
    ", we derive a set of rules for transforming stabilizer graphs under the application of various local clifford gates . from this list , we abstract a similar set for transforming reduced stabilizer graphs . considering these transformation rules , particularly those for reduced stabilizer graphs , it becomes clear that the mapping between stabilizer states and stabilizer graphs is not one - to - one .",
    "rules for converting between equivalent graphs are found , and we prove that the equivalence rules given are universal by developing a constructive procedure for testing the equivalence of any two stabilizer graphs .",
    "this research was partly supported by army research office contract no .",
    "w911nf-04 - 1 - 0242 and national science foundation grant no .",
    "the transformation rules given in sec .",
    "[ sec : transformations ] suffice to describe the effect of any local clifford operation on a stabilizer state . in order to complete the set of transformation rules for the clifford group , we include transformation rules for the @xmath3 gate here . in the interest of brevity",
    ", we consider only reduced - stabilizer - graph transformations . transformation rules for general stabilizer graphs can be derived by first using the equivalence rules in sec .",
    "[ subsec : circuitequiv ] to convert to an equivalent reduced graph and then applying the transformation rules below .",
    "transformation rule  t(viii ) is trivial since the @xmath3 gate simply commutes into layer two of the reduced - graph - form circuit .",
    "the circuit identities needed to prove rules  t(ix ) and  t(x ) are given in fig .",
    "[ fig : czident ] .",
    "m. hein , w. dr , j. eisert , r. raussendorf , m. van den nest , and h .- j .",
    "briegel , in _ entanglement in graph staes and its applications _ , proceedings of the international school of physics `` enrico fermi , '' course  162 , varenna , july 515 , 2005 , edited by g.  casati , d.  l. shepelyansky , p.  zoller , and g.  benenti ( ios press , amsterdam , 2006 ) , e - print arxiv : quant - ph/0602096 ."
  ],
  "abstract_text": [
    "<S> we introduce a graphical representation of stabilizer states and translate the action of clifford operators on stabilizer states into graph operations on the corresponding stabilizer - state graphs . </S>",
    "<S> our stabilizer graphs are constructed of solid and hollow nodes , with ( undirected ) edges between nodes and with loops and signs attached to individual nodes . </S>",
    "<S> we find that local clifford transformations are completely described in terms of local complementation on nodes and along edges , loop complementation , and change of node type or sign . </S>",
    "<S> additionally , we show that a small set of equivalence rules generates all graphs corresponding to a given stabilizer state ; we do this by constructing an efficient procedure for testing the equality of any two stabilizer graphs . </S>"
  ]
}