{
  "article_text": [
    "[ intro ]    the technique of _ chaining _ is applicable in many situations . a simple case is e.g. , when we want to calculate the partial sums ( resp .  products ) of a ( not necessarily bounded ) list of integers , with a given ` base ' integer ; such a list of partial sums ( resp .",
    "products ) can be calculated , incrementally , with the help of the following two equations :     @xmath0    where @xmath1 is the empty list , @xmath2 is the given base integer , @xmath3 is an integer variable , and @xmath4 is the given list of integers .",
    "the partial sums ( resp .",
    "products ) are returned as a list , by evaluating the function @xmath5 , when @xmath6 is interpreted as the sum ( resp .",
    "product ) of @xmath3 with the given base integer @xmath2 .",
    "a more sophisticated example is the cipher block chaining encryption mode ( cbc , in short ) , employed in cryptography , a mode which uses the ac - operator exclusive - or ( xor ) for ` chaining the ciphers across the message blocks ' ; here is how this is done : let  @xmath7 stand for xor ( which we let distribute over block concatenation ) , and let @xmath8 be a message given as a list of @xmath9 ` plaintext ' message subblocks .",
    "then the encryption of @xmath10 , with any given public key @xmath11 and an initialization vector @xmath12 , is defined as the list @xmath13 of ciphertext message subblocks , where : @xmath14 , and  @xmath15 , for any @xmath16 .",
    "( note : it is usual in cryptography to see a message as a sequence of `` records '' , each record being decomposed into a sequence of blocks of the same size ; what we refer to as ` message ' in this paper , would then correspond to a ` record ' in the sense of cryptography . )",
    "the above set of equations also models this cbc encryption mode : for this , we interpret the function @xmath17 as the encryption @xmath18 of any single block message @xmath3 , xor - ed with the initialization vector @xmath19 , using the given public key @xmath11 .",
    "under such a vision , a message @xmath10 is decomposed as the concatenation of its first message block @xmath20 with the rest of the message list @xmath21 , i.e. , we write @xmath22 ; then , the encryption of @xmath10 with any given public key @xmath11 , with @xmath3 taken as initialization vector ( iv ) , is derived by @xmath23 .    actually , our interest in the equational theory defined by the above two equations was motivated by the possibility of such a modeling for cipher block chaining , and the fact that rewrite as well as unification techniques are often employable , with success , for the formal analysis of cryptographic protocols ( cf .",
    "e.g. , @xcite , and also the concluding section ) .",
    "this paper is organized as follows . in section  [ prelim ]",
    "we introduce our notation and the basic notions used in the sequel ; we shall observe , in particular , that the two equations above can be turned into rewrite rules and form a convergent rewrite system over a 2-sorted signature : _ lists _ and _ elements_. our concern in section  [ bc - inf ] is the unification problem modulo this rewrite system , that we denote by @xmath24 ; we present a 2-level inference system ( corresponding , in a way , to the two sorts of the signature ) for solving this problem .",
    "although our main aim is to investigate the unification problem for the case where @xmath25 is an interpreted function symbol ( as in the two situations illustrated above ) , we shall also be considering the case where @xmath25 is a free uninterpreted symbol .",
    "the soundness and completeness of our inference procedure are established in section  [ method ] . while the complexity of the unification problem is polynomial over the size of the problem when @xmath25 is uninterpreted , it turns out to be np - complete when @xmath25 is interpreted so that the rewrite system models cbc encryption .",
    "we then present , in section  [ dbc ] , a 2-sorted convergent system @xmath26 that fully models at an abstract level , a block chaining cipher - decipher mode without using any ac - operators ; this is done by adding a couple of equations to the above two : one for specifying a left - inverse @xmath27 for @xmath25 ( @xmath27 does the deciphering ) , and the other for specifying the block chaining mode for deciphering .",
    "a 2-level inference procedure extending the one given in section  [ bc - inf ] is presented , and is shown to be sound and complete for unification modulo this extended system @xmath26 ; unification modulo @xmath26 also turns out to be np - complete . in the concluding section we briefly evoke possible lines of future work over these systems @xmath24 and @xmath26 .",
    "the first part of this paper , devoted to unification modulo @xmath24 , is a more detailed version of the work we presented at lata 2012  ( @xcite ) .",
    "we consider a ranked signature @xmath28 , with two _ disjoint _ sorts : @xmath29 and @xmath30 , consisting of binary functions _",
    "bc , cons , h _ , and a constant @xmath1 , and typed as follows :     @xmath31 , @xmath32 , @xmath33 , @xmath34 .",
    "we also assume given a set @xmath35 of countably many variables ; the objects of our study are the ( well - typed ) terms of the algebra @xmath36 ; terms of the type @xmath29 will be referred to as _ elements _ ; and those of the type @xmath30 as _ lists_.",
    "it is assumed that the only constant of type list is @xmath1 ; the other constants , if any , will all be of the type element . for better readability",
    ", the set of variables @xmath35 will be divided into two subsets : those to which ` lists ' can get assigned will be denoted with upper - case letters as : @xmath37 , with possible suffixes or primes ; these will be said to be variables of type @xmath30 ; variables to which ` elements ' can get assigned will be denoted with lower - case letters , as : @xmath38 , with possible suffixes or primes ; these will be said to be variables of type @xmath29 .",
    "the theory we shall be studying first in this paper is defined by the two axioms ( equations ) already mentioned in the introduction :     @xmath39    it is easy to see that these axioms can both be oriented left - to - right under a suitable _ lexicographic path ordering ( lpo ) _",
    "e.g. ,  @xcite ) , and that they form then a convergent  i.e. , confluent and terminating  2-sorted rewrite system .",
    "as mentioned in the previous section , we consider two theories that contain the above two axioms .",
    "the first is where these are the _ _ only axioms ; we call that theory  @xmath40",
    ". the other theory is where @xmath25  is interpreted as for cbc , i.e. , where @xmath41 where @xmath7  is exclusive - or and @xmath42 is encryption using some ( fixed ) given key  @xmath11 .",
    "this theory will be referred to as  @xmath43 .",
    "we use the phrases `` @xmath24-unification '' and `` unification modulo @xmath24 '' to refer to unification problems modulo both the theories , collectively .",
    "note that in the case where @xmath25 is a free uninterpreted symbol ( i.e. ,  @xmath40 ) @xmath25 is fully cancellative in the sense that for any terms @xmath44 , @xmath45 if and only if @xmath46 and @xmath47 .",
    "but when @xmath25 is interpreted for cbc , this is no longer true ; in such a case , @xmath25 will be only _ semi - cancellative _ , in the sense that for all terms @xmath48 , the following holds :    @xmath25 is right - cancellative : @xmath49 if and only if @xmath46 , and    @xmath25 is also left - cancellative : @xmath50 if and only if @xmath46 .",
    "thus , in the sequel , when we look for the unifiability of any set of element equations modulo @xmath51 ( resp .",
    "modulo @xmath52 ) the cancellativity of @xmath25 ( resp .",
    "the semi - cancellativity of @xmath25 ) will be used as needed , in general without any explicit mention .    our concern in this section , and the one following , is the equational unification problems modulo @xmath40 and @xmath43 .",
    "we assume without loss of generality ( wlog ) that any given @xmath24-unification problem @xmath53 is in _ standard form , _",
    "i.e. , @xmath53 is given as a set of equations @xmath54 , each having one of the following forms :     @xmath55 + @xmath56    where @xmath57 stands for any ground constant of sort  @xmath29 .",
    "the first four kinds of equations  the ones with a list - variable on the left - hand side  are called _ list - equations , _ and the rest ( those which have an element - variable on the left - hand side ) are called _ element - equations . _ for any problem @xmath53 in standard form , @xmath58 will denote the subset formed of its list - equations , and @xmath59 the subset of element - equations .",
    "a set of element - equations is said to be in _ dag - solved form _ ( or _ d - solved form _ ) ( @xcite ) if and only if they can be arranged as a list @xmath60 , such that :     @xmath61 :   @xmath62 and @xmath63 are distinct variables , and @xmath62 does not occur in @xmath64 nor in any @xmath65 .",
    "such a notion is naturally extended to sets of list - equations as well . in the next section",
    "we give an inference system for solving any @xmath24-unification problem in standard form .",
    "for any given problem @xmath53 , its rules will transform @xmath58 into one in @xmath66-solved form .",
    "the element - equations at that point can be passed on to an algorithm for solving them  thus in the case of  @xmath43 what we need is an algorithm for solving the _ general _ unification problem modulo the theory of exclusive - or .",
    "any development presented below  without further precision on @xmath25  is meant as one which will be valid for both @xmath67 and @xmath68 .",
    "[ bc - inf ]    the inference rules have to consider two kinds of equations : the rules for the _ list - equations _ in @xmath53 , i.e. , equations whose left - hand sides ( lhs ) are variables of type @xmath30 , and the rules for the _ element - equations , _ i.e. , equations whose lhs are variables of type @xmath29",
    ". our method of solving any given unification problem will be ` modular ' on these two sets of equations : the list - inference rules will be shown to terminate under suitable conditions , and then all we will need to do is to solve the resulting set of element - equations for @xmath25 .    a few technical points need to be mentioned before we formulate our inference rules .",
    "note first that it is not hard to see that @xmath69 is cancellative ; by this we mean that @xmath70 , for terms @xmath71 , if and only if @xmath46 and @xmath72 .",
    "on the other hand , it can be shown by structural induction ( and the semi - cancellativity of @xmath25 ) that @xmath5 is _ conditionally _ semi - cancellative , depending on whether its first argument is @xmath1 or not ; for details , see _",
    "appendix-1_. this property of @xmath5 will be assumed in the sequel .",
    "the inference rules given below will have to account for cases where an ` occur - check ' succeeds on some list - variable , and the problem will be unsolvable .",
    "the simplest among such cases is when we have an equation of the form @xmath73 in the problem .",
    "but one could have more complex unsolvable cases , where the equations involve both @xmath69 and @xmath5 ; e.g. , when @xmath53 contains equations of the form : @xmath74 ; the problem will be unsolvable in such a case : indeed , from the axioms of @xmath24 , one deduces that @xmath75 must be of the form @xmath76 , for some @xmath12 and @xmath77 , then @xmath3 must be of the form @xmath78 , and subsequently @xmath79 , and we are back to a set of equations of the same format .",
    "we need to infer failure in all such cases . with that purpose ,",
    "we define the following relations on the list - variables of the equations in @xmath53 :    * @xmath80 iff @xmath81 , for some @xmath2 . *",
    "@xmath82 iff there is an equation @xmath83 * @xmath84 iff @xmath85 , or @xmath86 , for some @xmath87 .",
    "note that @xmath88 is the symmetric closure of the relation @xmath89 ; its reflexive , symmetric and transitive closure is denoted as @xmath90 .",
    "the transitive closure of @xmath89 is denoted as @xmath91 ; and its reflexive transitive closure as @xmath92 .",
    "note , on the other hand , that @xmath93 is solvable by the substitution @xmath94 ; in fact this equation forces @xmath95 to be @xmath1 , as would also a set of equations of the form @xmath96 .",
    "such cycles ( as well as some others ) have to be checked to determine whether a list - variable is forced to be @xmath1 .",
    "this can be effectively done with the help of the relations defined above on the type @xmath30 variables .",
    "we define , recursively , a set * nonnil * of the list - variables of @xmath53 that can not be @xmath1 for any unifying substitution , as follows :    * if @xmath97 is an equation in @xmath53 , then @xmath98 . * if @xmath83 is an equation in @xmath53 , then @xmath98 if and only if @xmath99 .",
    "we have then the following obvious result :    [ nonnilvar ] a variable @xmath98 if and only if there are variables @xmath75 and  @xmath100 such that @xmath101 and @xmath102",
    ".    some of the inference rules below will refer to a graph whose nodes are the list - variables of the given problem @xmath53 , ` considered equivalent up to equality ' ; more formally : for any list - variable @xmath95 of @xmath53 , we denote by @xmath103 $ ] the equivalence class of list - variables that get equated to @xmath95 in @xmath53 , in the following sense :     @xmath103 = \\ { v \\mid u = _ { } ^ ?",
    "v \\in { \\mathcal{p}}~\\mathrm{or}~v = _ { } ^ ?",
    "u \\in { \\mathcal{p}}\\}.$ ]    any relation @xmath104 defined over the list - variables of @xmath53 is then extended naturally to these equivalence classes , by setting : @xmath105 , \\dotsc , [ u_n ] ) \\ ; ~ \\mathrm{iff}~ \\ ;     \\exists v_1 \\in [ u_1 ] \\ , \\dotso \\ ,",
    "\\exists v_n \\in [ u_n ]     \\colon \\mathcal{r}(v_1 , \\dotsc , v_n)$ ] .",
    "let @xmath106 be the graph whose nodes are the equivalence classes on the list - variables of @xmath53 , with arcs defined as follows : from a node @xmath103 $ ] on @xmath107 there is a _ directed _ arc to a ( not necessarily different ) node @xmath108 $ ] on @xmath107 if and only if :    * either @xmath109 : in which case the arc is labeled with @xmath110 * @xmath111 : in which case the arc is labeled with @xmath89 .    in the latter case , @xmath107 will also have a _ two - sided ( undirected ) _ edge between @xmath103 $ ] and @xmath108 $ ] , which is labeled with @xmath112 .",
    "the graph @xmath107 is called the _ propagation graph _ for @xmath53 .    a node @xmath103 $ ] on @xmath107 is said to be a @xmath113-peak if @xmath53 contains two different equations of the form @xmath114 ; the node @xmath103 $ ] is said to be a @xmath115-peak if @xmath53 has two different equations of the form @xmath116 .",
    "on the set of nodes of @xmath107 , we define a partial relation @xmath117 by setting : @xmath103 \\succ_l [ v]$ ] iff there is a path on @xmath107 from @xmath103 $ ] to @xmath108 $ ] , at least one arc of which has label @xmath110 . in other words ,",
    "@xmath118    a list - variable @xmath95 of @xmath53 is said to _ violate occur - check _",
    "iff @xmath103 \\succ_l [ u]$ ] on @xmath107 .",
    "for instance , the variable @xmath95 violates occur - check in the problem :     @xmath119 ,    as well as in the problem :     @xmath120    it can be checked that both the problems are unsatisfiable .",
    "[ inf - l ]    ( l1 ) _ variable elimination _ :    @xmath122{\\{u = _ { } ^ ?",
    "v\\ } \\cup \\ , [ v / u]({\\mathcal{eq } } ) }                 { \\{u = _ { } ^ ?",
    "v\\ } ~ \\uplus ~ { \\mathcal{eq}}}$ ]    ( l2 ) _ cancellation on @xmath69 _ :    @xmath123    ( l3.a ) _ nil solution-1 _ :    @xmath124    ( l3.b ) _",
    "nil solution-2 _ :    @xmath125    ( l3.c ) _",
    "nil solution-3 _ :    @xmath126     { { \\mathcal{eq}}~ \\cup ~ \\ { u = _ { } ^ ? nil , \\ ; v = _ { } ^ ? nil \\ } }     { { \\mathcal{eq}}~ \\uplus ~ \\ { u = _ { } ^ ?",
    "bc(v , x ) \\}}$ ]    ( l4.a ) _ semi - cancellation on @xmath5 _ , at a @xmath113-peak :    @xmath127    ( l4.b ) _ push @xmath5 below @xmath69 _ , at a @xmath128 @xmath113-peak :    @xmath129          & u ' = _ { } ^ ?",
    "bc(z , u ) , \\ ; u = _ { } ^ ?",
    "h(v , x ) , \\ ; u = _ { } ^ ?",
    "h(w , y ) \\",
    "}      \\end{aligned } }      { { \\mathcal{eq}}~ \\uplus ~ \\ { u = _ { } ^ ?",
    "bc(v , x ) , \\ ; u = _ { } ^ ?",
    "bc(w , y ) \\}}$ ]    if @xmath98    ( l5 ) _ splitting _ , at a @xmath115-peak :    @xmath130    ( l6 ) _ occur - check violation _ : +    @xmath131 } \\succ_l { [ } u { ] }   ~                     \\mathrm{~ on ~ the ~ graph ~ } g_l ]      { fail } { { \\mathcal{eq}}}$ ]    ( l7 ) _ size conflict _ : +    @xmath132    the symbol ` @xmath133 ' in the premises of the above inference rules stands for disjoint set union ( and ` @xmath134 ' for usual set union ) .",
    "the role of the variable elimination inference rule ( l1 ) is to keep the propagation graph of @xmath53 irredundant : each variable has a unique representative node on @xmath135 , up to variable equality .",
    "this rule is applied most eagerly .",
    "rules  ( l2 ) , ( l3.a)(l3.c ) and ( l4.a ) come next in priority , and then ( l4.b ) .",
    "the splitting rule ( l5 ) is applied in the `` laziest '' fashion , i.e. , ( l5 ) is applied only when no other rule is applicable .",
    "the above inference rules are all `` dont - care '' nondeterministic . ( the priority notions just mentioned serve essentially for optimizing the inference procedure . )    the validity of the rule ( l4.b ) ( ` pushing @xmath5 below @xmath69 ' ) results from the cancellativity of @xmath69 and the semi - cancellativity of @xmath5 ( _ appendix-1 _ ) . note that the variables @xmath136 , @xmath137 , and @xmath138 in the ` inferred part ' of this rule ( l4.b ) might need to be fresh ; the same is true also for the variables @xmath19 and @xmath139 in the inferred part of the splitting rule ; but , in either case this is not obligatory , if the equations already present can be used for applying these rules .",
    "type - inference failure is assumed to be checked implicitly ; no explicit rule is given .",
    "the following point should be kept in mind : any given problem @xmath53 naturally ` evolves ' under the inference rules ; and new variables might get added in the process , if rule ( l5 ) or rule ( l4.b ) is applied ; but none of the variables initially present in @xmath53 can disappear in the process ; not even under the variable elimination rule ( l1 ) .",
    "thus , although the graph @xmath107 referred to in the occur - check violation rule ( l6 ) is the graph of the ` current problem ' , the node it refers to might still be one corresponding to an initial variable .",
    "we show now that such an introduction of fresh variables can not go for ever , and that the above `` dont - care '' nondeterministic rules suffice , essentially , for deciding _ unifiability _ modulo the axioms of @xmath24 .",
    "[ list - unifiable ] let @xmath53 be any @xmath24-unification problem , given in standard form .",
    "the system @xmath121 of list - inference rules , given above , terminates on @xmath53 in polynomially many steps .",
    "assume given a problem @xmath53 in standard form , for which the inference process does not lead to failure on occur - check ( l6 ) or size - conflict ( l7 ) .",
    "if @xmath121 is non - terminating on such a @xmath53 , at least one of the rules of @xmath121 must have been applied infinitely often along some inference chain ; we show that this can not be true for any of the rules in @xmath121 .",
    "note first that an equation of the form @xmath140 in @xmath53 is never handled in ` both directions ' by the variable elimination rule ( l1 ) ; an application of this rule means : every occurrence of the variable @xmath95 in the problem is replaced by the variable @xmath75 .",
    "it is easy to check then , that for this reason , ( l1 ) can not give rise to non - termination . on the other hand , the list - inference rules ( l2 ) through ( l4.a )",
    "eliminate a ( directed ) outgoing arc from some node of @xmath107 ; so their termination is easy to check .",
    "it should be clear , that for these three rules , termination is polynomial ( even linear ) . thus , to show the termination of the entire inference process in polynomially many steps",
    ", we have to look at how the problem evolves under the rule  ( l5 ) ( _ splitting _ ) and the rule  ( l4.b ) ( _ pushing @xmath5 below @xmath69 _ ) .",
    "we show that if occur - check violation ( l6 ) does not occur , then the applications of the rule ( l5 ) or of the rule ( l4.b ) can not go on forever .    for proving this",
    ", we shall be using an equivalence relation denoted as @xmath141 , on the list - variables of the given problem .",
    "it is defined as the smallest equivalence relation can be viewed as a combination of the _ unification closure _ , a notion defined by kanellakis and revesz  @xcite , and the _ congruence closure _ of @xmath142 .",
    "the difference is that here we are working with a typed system . ]",
    "satisfying the following conditions , on the list - variables of @xmath53 :    * if @xmath101 then @xmath143 .",
    "* let @xmath144 and @xmath145 ; then @xmath146 implies @xmath147 .",
    "observe now that the number of @xmath5-equations , i.e. , list - equations of the form @xmath148 , never increases .",
    "this number decreases in most cases , except for ( l1 ) , ( l2 ) and  ( l5 ) .",
    "the splitting rule  ( l5 ) does not decrease the number of @xmath5-equations and may introduce new variables , but the number of @xmath141-equivalence classes of nodes ( on the current graph ) does not increase : indeed , applying the splitting rule ( l5 ) on a list - equation @xmath149 removes that equation , and creates a list - equation of the form @xmath150 for some list - variables @xmath151 and @xmath152 , such that @xmath153 ; we have : @xmath154 , since @xmath155 .",
    "suppose now that applying the splitting rule does not terminate .",
    "then , at some stage , the derived problem will have a sequence of variables of the form @xmath156 , such that the length of the sequence @xmath9 strictly exceeds the initial number of @xmath157-equivalence classes  which can not increase under splitting , as we just observed above .",
    "so there must exist indices @xmath158 such that @xmath159 .",
    "let @xmath160 be the smallest integer for which there exists an @xmath161 , such that @xmath159 .",
    "then , by the definition of @xmath157 , we must have @xmath162 .",
    "consequently , we would then also have @xmath163 \\succ_l [ u_{i}]$ ] ; and that would have caused the inference process to terminate with fail , as soon as both the variables @xmath164 and @xmath165 appear in the problem derived under the inferences .",
    "termination of ( l4.b ) can now be proved as follows : the number of @xmath166-equivalence classes may increase by  1 with each application of  ( l4.b ) , but the number of @xmath167-equivalence classes remains the same , for the same reason as above .",
    "let @xmath20 be the number of @xmath5-equations in the input problem and let @xmath9 be the number of variables in the input problem .",
    "we then show that the total number of applications of ( l4.b ) and ( l5 ) can not exceed  @xmath168 : indeed , whenever one of ( l4.b ) or ( l5 ) is applied , some number of @xmath5-equations are removed and an equal or lesser number are added ,",
    "whose variables belong to @xmath157-equivalence classes at a ` lower level ' as explained above , i.e. , below some @xmath69 steps . there are at most @xmath9 such equivalence classes , since the number of @xmath157 equivalence classes does not increase ( and there can not be more than @xmath9 such equivalence classes , to start with ) .",
    "so a @xmath5-equation can not be `` pushed down '' more than @xmath9 times .",
    "since there are initially @xmath20 @xmath5-equations , the total number of applications of ( l4.b ) and ( l5 ) can not exceed  @xmath168 .",
    "a set of equations will be said to be _",
    "l - reduced _ if none of the above inference rules ( l1 ) through ( l7 ) is applicable .",
    "( note : such a problem may not be in @xmath66-solved form : an easy example is given a couple of paragraphs below . )",
    "* unification modulo @xmath24 : * the rules ( l1 ) through ( l7 ) are not enough to show the existence of a unifier modulo @xmath24 .",
    "the subset of element - equations , @xmath169 , may not be solvable ; for example , the presence of an element - equation of the form @xmath170 should lead to failure .",
    "however , we have the following :    [ list - result ] if @xmath58 is in l - reduced form , then @xmath53 is unifiable modulo @xmath24 if and only if the set @xmath169 of its element - equations is solvable .",
    "if @xmath58 is @xmath171-reduced , then setting every list - variable that is not in * nonnil * to @xmath1 will lead to _ a unifier _ for @xmath58 , modulo @xmath24 , provided @xmath169 is solvable .",
    "recall that @xmath67 is the theory defined by @xmath24 when @xmath25 is uninterpreted .",
    "[ list - poly ] let @xmath53 be any @xmath67-unification problem , given in standard form .",
    "unifiability of @xmath53 modulo @xmath67 is decidable in polynomial time ( wrt the size of @xmath53 ) .    if the inferences of @xmath121 applied to @xmath53 lead to failure",
    ", then @xmath53 is not unifiable modulo @xmath24 ; so assume that this is not the case , and replace @xmath53 by an equivalent problem which is @xmath171-reduced , deduced in polynomially many steps by proposition  [ list - unifiable ] . by proposition  [ list - result ] , the unifiability modulo @xmath24 of such a @xmath53 amounts to checking if the set @xmath169 of its element - equations is solvable .",
    "we are in the case where @xmath25 is uninterpreted , so to solve @xmath169 we apply the rules for standard unification , and check for their termination without failure ; this can be done in polynomial time  @xcite .",
    "( in this case , @xmath25 is fully cancellative . )",
    "it can be seen that while termination of the above inference rules guarantees the _ existence _ of a unifier ( provided the element equations are syntactically solvable ) , the resulting @xmath171-reduced system may not lead directly to a unifier .",
    "for instance , the @xmath171-reduced system of list - equations @xmath172 is unifiable , with the following two incomparable unifiers :     @xmath173    to get a complete set of unifiers we need three more inference rules , which are `` dont - know '' nondeterministic , to be applied only to @xmath171-reduced systems :    ( l8 ) _ nil - solution - branch for @xmath5 _ , at a @xmath113-peak :    @xmath174    ( l9 ) _ guess a non - nil branch for @xmath5 _ , at a @xmath113-peak :    @xmath129          & u ' = _ { } ^ ?",
    "bc(z , u ) , \\ ; u = _ { } ^ ?",
    "h(v , x ) , \\ ; u = _ { } ^ ?",
    "h(w , y ) \\",
    "}      \\end{aligned } }      { { \\mathcal{eq}}~ \\uplus ~ \\ { u = _ { } ^ ?",
    "bc(v , x ) , \\ ; u = _ { } ^ ?",
    "bc(w , y ) \\}}$ ]    ( l10 ) _ standard unification on @xmath5 _ :    @xmath175    rule ( l9 ) nondeterministically ` guesses ' @xmath95 to be in * nonnil * ; in other words , it applies rule ( l4.b ) ` unconditionally ' .",
    "the inference system thus extended will be referred to as @xmath176 . by the same reasonings as developed above , @xmath176 also terminates , in polynomially many steps , on any problem given in standard form .",
    "we establish now a technical result , valid whether or not @xmath25 is interpreted :    [ d - solved ] let @xmath53 be any @xmath24-unification problem in standard form , to which none of the inferences of @xmath176 is applicable",
    ". then its set of list - equations is in @xmath66-solved form .",
    "if none of the equations in @xmath53 involve @xmath5 or @xmath69 ( i.e. , all equations are equalities between list - variables ) , then the proposition is proved by rule ( l1 ) ( _ variable elimination _ ) .",
    "observe first that if @xmath177 is inapplicable to @xmath53 , then , on the propagation graph @xmath107 for @xmath53 , there is _ at most one outgoing directed arc _ of @xmath107 at any node @xmath95 : otherwise , suppose there are two distinct outgoing arcs at some node @xmath95 on @xmath107 ; if both directed arcs bear the label @xmath110 , then rule ( l2 ) of @xmath177 would apply ; if both bear the label @xmath89 , then one of ( l4.a ) , ( l4.b ) , ( l9 ) , ( l10 ) would apply ; the only remaining case is where one of the outgoing arcs is labeled with @xmath110 and the other has label  @xmath89 , but then the splitting rule  ( l5 ) would apply .",
    "consider now any given connected component @xmath178 of @xmath107 .",
    "there can be no directed cycle from any node @xmath95 on @xmath178 to itself : otherwise the occur - check - violation rule ( l6 ) would have applied .",
    "it follows , from this observation and the preceding one , that there is a unique _ end - node _",
    "@xmath179 on @xmath178 , i.e. , a node from which there is _ no directed outgoing arc _ ; and also that for any given node @xmath95 on @xmath178 , there is a unique well - defined directed path leading from @xmath95 to that end - node @xmath179 .",
    "it follows easily from these , that the list - variables on the left hand sides of the equations in  @xmath53 ( on the different connected components of @xmath107 ) can be ordered suitably , so as to satisfy the condition for @xmath53 to be in a @xmath66-solved form .",
    "the following @xmath67-unification problem is in standard form :     @xmath180    we apply ( l5 ) ( _ splitting _ ) and write @xmath181 , with @xmath182 fresh ; this , followed by an application of rule ( l2 ) ( _ cancellation on cons _ ) leads to :     @xmath183 + @xmath184    we apply cancellativity of @xmath25 ( valid for @xmath51 ) , and an element - variable elimination ; the problem thus derived is the following :     @xmath185 + @xmath186    \\(i ) no rule of @xmath177 is applicable : in particular , ( l4.b ) does nt apply since @xmath100 is not in * nonnil * ; but the rule ( l8 ) ( _ nil - solution branch for @xmath5 _ ) can be nondeterministically applied :     @xmath187 + @xmath186    these equations , in @xmath66-solved form , give a solution to the original problem .",
    "\\(ii ) for the sake of completeness , we could also try the rule ( l9 ) ( _ guess a non - nil branch _ ) nondeterministically , successively on the two equations for @xmath100 in the problem derived above ; so we write @xmath188 and @xmath189 . these applications of ( l9 ) , followed by applications of _ variable elimination , cancellation on cons _ , and the cancellativity of @xmath25 ( valid for the theory @xmath51 ) , will lead us to :     @xmath190 @xmath191 + @xmath192    the list - equations are in @xmath66-solved form , but the element - equations being unsatisfiable",
    "we are led to failure .",
    "\\(iii ) for the following problem ( almost same as ( i ) above , but for an element - equation ) :     @xmath193    the reasonings as developed in ( ii ) above would have led us to a non - nil solution for @xmath100 :     @xmath194 @xmath195 @xmath196    where @xmath197 is any arbitrary list , and @xmath198 are any arbitrary elements .",
    "we turn our attention in the following section to the unification problem modulo @xmath24 .",
    "when @xmath25 is uninterpreted , we saw that this unification is decidable in polynomial time .",
    "but when @xmath25 is interpreted so that @xmath24 models cbc , we shall see that unification modulo @xmath68 is np - complete .",
    "let @xmath53 be a @xmath24-unification problem , given in standard form .",
    "we assume that @xmath199 has terminated without failure on @xmath53 ; we saw , in the preceding section ( proposition  [ d - solved ] ) , that @xmath53 is then in @xmath66-solved form .",
    "we also assume that we have a sound and complete procedure for solving the element - equations of @xmath53 , that we shall denote as @xmath200 .",
    "for the theory @xmath67 where @xmath25 is uninterpreted , we know ( proposition  [ list - poly ] ) that @xmath200 is standard unification , with cancellation rules for @xmath25 , and failure in case of ` symbol clash ' .",
    "for the theory @xmath68 , where @xmath17 is interpreted as @xmath201 for some fixed key @xmath11 , @xmath200 will have rules for semi - cancellation on @xmath25 , besides the rules for unification modulo xor in some fixed procedure ; such a procedure is assumed given once and for all .    in all cases",
    ", we shall consider @xmath200 as a black - box that either returns most general unifiers ( _ mgu _",
    "s ) for the element - equations of @xmath53 , or a failure message when these are not satisfiable . note that @xmath200 is unitary for @xmath51 and finitary for @xmath52 . for any problem @xmath53 in @xmath66-solved form , satisfiable under the theory @xmath51",
    ", there is a unique mgu , as expressed by the equations of @xmath53 themselves ( cf .",
    "also @xcite ) , that we shall denote by @xmath202 .",
    "under @xmath68 there could be more than one ( but finitely many ) mgu s ; we shall agree to denote by @xmath202 any one among them .",
    "the entire procedure for solving any @xmath24-unification problem @xmath53 , given in standard form , can now be synthesized as a nondeterministic algorithm :    * the algorithm @xmath203 : * given a @xmath24-unification problem @xmath53 , in standard form .",
    "+ @xmath107 = propagation graph for @xmath53 .",
    "+ @xmath176 = inference procedure given above for @xmath58 .",
    "+ @xmath204 = any given ( complete ) procedure for solving the equations of @xmath169 .    1 .",
    "compute a standard form for @xmath53 , to which the `` dont - care '' inferences of @xmath121 are no longer applicable . if this leads to failure , exit with fail .",
    "otherwise , replace @xmath53 by this standard form .",
    "apply the `` dont - know '' nondeterministic rules ( l8)(l10 ) , followed by the rules of @xmath121 as needed , until the equations no longer get modified by the inference rules ( l1)(l10 ) . if this leads to failure , exit with fail .",
    "3 .   apply the procedure @xmath200 for solving the residual set @xmath169 of element - equations ; if this leads to failure , exit with fail .",
    "4 .   otherwise let @xmath205 be the substitution on the variables of @xmath53 as expressed by the resulting equations .",
    "return @xmath205 as a solution to @xmath53",
    ".    [ complete ] the algorithm @xmath203 is sound and complete .",
    "the soundness of @xmath203 follows from the soundness ( assumed ) of @xmath200 and that of @xmath176 , which is easy to check : obviously , if @xmath206 is any problem derived from @xmath53 by applying any of these inference rules , then any solution for @xmath206 corresponds to a solution for @xmath53 .",
    "the completeness of @xmath203 follows from the completeness ( assumed ) of @xmath200 , and the completeness of @xmath176 that we prove below .",
    "[ soln - preserve ] if @xmath205 is a solution for a given @xmath24-unification problem @xmath53 in standard form , then there is a sequence of @xmath176-inference steps that transforms @xmath53 into a problem @xmath206 in @xmath66-solved form such that @xmath205 is an instance of @xmath207 ( modulo @xmath24 ) .",
    "we know that the inference rules of @xmath176 terminate on @xmath53 ; let @xmath208 be the maximum number of steps needed for this termination , including along all possible `` dont - know '' branches of the process .",
    "we prove the lemma by induction on @xmath208 , and case analysis for the possible branches .",
    "observe first that if @xmath206 is a problem derived from @xmath53 under any inference rule of @xmath176 , then the given substitution @xmath205 , on on the variables of @xmath53 , extends naturally as a substitution on the variables of @xmath206 , satisfying the equations of @xmath206 .",
    "( this needs to be checked only if @xmath206 might involve new variables , such as when @xmath206 is derived from @xmath53 under rule ( l5 ) or rule ( l4.b ) ; the reasoning is straightforward for either of these cases . )",
    "if @xmath206 is derived from @xmath53 by applying one of the `` dont - care '' rules of @xmath177 , then the assertion of the lemma follows from the above observation and the induction hypothesis .",
    "so we may assume wlog that the given problem @xmath53 is already @xmath171-reduced ( i.e. , none of the inferences of @xmath177 is applicable ) .",
    "if such a @xmath53 is already in @xmath66-solved form , then we are done , since @xmath209 , for some mgu @xmath202 .",
    "( if the theory is @xmath52 , this means : there exists one among the finitely many @xmath210s , for which this holds . )    if @xmath53 is not in @xmath66-solved form , then several cases are possible , depending on the possible inference branches .",
    "it suffices to consider one such case  the reasoning being quite similar for all the others .",
    "suppose there are two equations @xmath211 and @xmath212 in @xmath53 . if @xmath213 , then we must have @xmath214 , and @xmath205 is extendable as a solution for the problem obtained by applying the rule  ( l10 ) .",
    "if @xmath215 , then @xmath205 must be extendable as a solution to the problem derived under rule ( l8 ) or rule ( l9 ) .",
    "the induction hypothesis ( on the maximum number of inference steps needed for termination ) completes then the argument to prove the lemma , in all cases .",
    "[ finitariness ] unification modulo @xmath24 is finitary .",
    "let @xmath53 be a satisfiable @xmath24-unification problem .",
    "we can assume without loss of generality that @xmath53 is in standard form , because any unification problem can be converted to a finite problem in standard form .",
    "let @xmath216 be the set of mgus for @xmath53 .",
    "by lemma  [ soln - preserve ] , for each @xmath217 , there is a sequence of @xmath176-inference steps that leads to a problem @xmath206 in @xmath66-solved form , and an @xmath210 @xmath218 such that @xmath205 is an instance of @xmath218 .",
    "let @xmath219 be the set of all such derived problems .",
    "because all the inference rules in @xmath176 terminate , and because there are finitely many inference rules , @xmath219 contains finitely many problems .    in the uninterpreted case @xmath51 ,",
    "@xmath205 is @xmath218 for some @xmath220 , so there are finitely many unifiers in @xmath216 . for @xmath52 ,",
    "note that unification modulo xor is finitary  @xcite .",
    "therefore , there are finitely many xor - mgus for the element problem derived from @xmath206 , so there are finitely many unifiers in @xmath216 that are instances of @xmath218 .",
    "since there are finitely many problems in @xmath219 , there are finitely many unifiers in @xmath216 .      recall that @xmath51 is the theory defined by @xmath24 when @xmath25 is uninterpreted , and @xmath52 is the theory when @xmath25 is interpreted so that @xmath24 models the ( xor - based ) cipher - block - chaining mode cbc .",
    "unifiability modulo the theory @xmath68 is np - complete .",
    "np - hardness follows from the fact that general unification modulo xor is np - complete  @xcite .",
    "we deduce the np - upper bound from the following facts :    1 .   for any given @xmath24-unification problem , computing a standard form",
    "is in polynomial time , wrt the size of the problem .",
    "2 .   given a standard form , the propagation graph can be constructed in polynomial time ( wrt its number of variables ) .",
    "3 .   applying ( l1)-(l10 ) till termination takes only polynomially many steps .",
    "extracting the set of element - equations from the resulting set of equations is in p. 5 .",
    "solving the element - equations , with the procedure @xmath200 , using unification modulo xor , is in np .",
    "[ ill - examp ]    the following public key protocol is a slight variant of one that was studied in  @xcite  the modification is that the namestamp of the sender of a message appears as the _ first _ block of the encrypted message body , and not the second as was specified in  @xcite :    @xmath221 + @xmath222 + where @xmath223 are the participants of the protocol session , @xmath20 is a message that they intend secret for others , and @xmath224 ( resp .",
    "@xmath225 ) is the public key of @xmath226 ( resp .",
    "@xmath227 ) .",
    "if the cbc encryption mode is assumed and the message blocks are all of the same size , then this protocol becomes insecure ; here is why .",
    "let @xmath228 stand for the encryption @xmath229 with the public key @xmath230 of any principal @xmath136 . under the cbc encryption mode ,",
    "what @xmath227 sends to @xmath226 is the following list , in the ml - notation : + @xmath231\\,]$ ] .",
    "+ here @xmath7 stands for xor and @xmath12 is the initialization vector ( @xmath232 ) agreed upon between @xmath227 and @xmath226 .",
    "but then , some other agent @xmath233 , entitled to open a session with @xmath226 with initialization vector @xmath87 , can get hold of the first encrypted block ( namely : @xmath234 ) as well as the second encrypted block of what @xmath227 sent to @xmath226 , namely @xmath235 ; ( s)he can then send the following as a ` bona fide ' message to @xmath226 :    @xmath236 \\ , ] $ ] ; + upon which @xmath226 will send back to @xmath233 the following : + @xmath237 \\ , ] $ ] .",
    "it is clear now , that the intruder @xmath233 can get hold of the message @xmath20 intended to remain secret for him / her : by decrypting the second block of the ( encrypted part of the ) message received from @xmath226 , ( s)he first deduces : @xmath238 ; by xor - ing this with the first block of the message , ( s)he obtains : @xmath239 ; from which ( s)he can deduce @xmath20 by xor - ing with @xmath240 and @xmath234 , both of which are known to him / her ( the latter of these two terms is the first block of the message from @xmath227 to @xmath226 , that ( s)he has intercepted ) .",
    "[ ping ] the above attack ( which exploits the properties of xor : @xmath241 ) can be modeled as solving a certain @xmath68-unification problem .",
    "we assume that the names @xmath242 , as well as the initialization vector @xmath87 , are constants accessible to @xmath233 .",
    "the message @xmath20 and the initialization vector @xmath12 , that @xmath227 and @xmath226 have agreed upon , are constants intended to be secret for @xmath233 .",
    "we shall interpret the function symbol @xmath25 of @xmath24 in terms of encryption with the public key of @xmath226 : i.e. , @xmath17 is @xmath243 .",
    "the protocol above can then be modeled as follows : we assume that the list of terms @xmath227 sends to @xmath226 , namely @xmath244 \\,]$ ] , is seen by the latter as the list of terms @xmath245 , v)\\ , ] $ ] ; ( s)he first recovers the namestamp @xmath227 of the sender , then checks that the second argument under @xmath5 in what ( s)he received is the @xmath232 agreed upon with @xmath227 ; subsequently ( s)he sends back the appropriate list of terms to @xmath227 , acknowledging receipt of the message .",
    "now , due to our cbc - assumption , the ground terms @xmath246 are both accessible to the intruder @xmath233 .",
    "so the attack by @xmath233 , mentioned above , corresponds to the fact that @xmath233 _ can _ send to @xmath226 the following list of terms : @xmath247\\,]$ ] . that the attack materializes follows from the fact that @xmath226 can solve the @xmath52-unification problem :     @xmath248 , w ) { = _ { } ^?}cons(h(i , w ) , [ h(m , h(a , v))])$ ] ,    for the element - variable @xmath2",
    ", i.e. , @xmath226 needs to solve the element - equation : @xmath249 ; since @xmath25 is interpreted here so that @xmath24 models @xmath250 , ( s)he can do so by setting : @xmath251 ; and that precisely leads to the attack .",
    "[ r:1 ] ( i ) the above analysis does _ not _ go through if the namestamp forms the _ second block _ of the encrypted part of the messages sent .",
    "in such a case , the protocol is ` leak - proof ' even under cbc , provided we assume that an iv for a message is a secret to be shared only by the sender and the intended recipient of the message , and that it is _ not _ transmitted  as clear text or encrypted  as an initial ` block number zero ' of the message body . actually , by reasoning as above ,",
    "one checks that the intruder @xmath233 in such a case can only get hold of @xmath252 , where @xmath12 is the ( secret ) iv that only @xmath227 and @xmath226 share .",
    "this in a sense is in accordance with  @xcite , where the protocol was ` proved secure ' under such a specification .",
    "\\(ii ) the considerations above lead us to conclude , implicitly , that in cryptographic protocols employing the cbc encryption mode , it is necessary to forbid free access to the ivs of the ` records ' of the ` messages ' sent , if information leak is to be avoided .",
    "this fact has been pointed out in the 90 s , by bellare et al ( @xcite ) , and again , in some detail , by k.  g.  paterson et al in @xcite ; both point out that tls  1.0  with its predictable ivs  is inherently insecure . for more on this point , and on the relative advantages of tls  1.1 , tls  1.2 over tls  1.0 ,",
    "the reader can also consult , e.g. , http://www.educatedguesswork.org/2011/09/    ( note : keeping ivs as shared secrets alone may not always be sufficient in general , as is shown by example 2 above . )",
    "[ dbc ]    in this section we extend the 2-sorted equational theory @xmath51 studied above , into one that fully models , in a simple manner and without using any ac - symbols , a ` generic ' block chaining encryption - decryption scheme . this theory , that we shall refer to as @xmath26 , is defined by the following set of ( 2-sorted ) equations : @xmath253 where @xmath27 is typed as @xmath254 and @xmath255 is typed as @xmath256 .",
    "all these equations can be oriented from left to right under a suitable reduction ordering , to form a convergent ( 2-sorted ) rewrite system .",
    "the @xmath257th equation says that @xmath255 is a left - inverse for @xmath5 ; it is actually an inductive consequence of the first five : i.e. , for any list - term @xmath258 and element - term @xmath19 both in ground normal form , @xmath259 reduces to @xmath258 under the first five , a fact that can be easily checked by structural induction , cf . _ appendix-2_. ( its insertion as an equational axiom is for technical reasons , as will be explained in _ remark [ r:4]_(ii ) below . )    a few words , by way of intended semantics in the context of cryptographic protocols , seem appropriate : @xmath17 would in such a context stand for the encryption with the public key of an intended recipient @xmath226 , of message @xmath3 , _ ` coupled ' in a sense to be defined , _ with @xmath19 as initialization vector ( iv ) ; and @xmath260 would be the decryption of @xmath17 with the private key of @xmath226 , to be then _",
    "` decoupled ' , again in a sense to be defined _ , with @xmath19 .",
    "if an agent @xmath227 wants to send a list of terms @xmath261 to recipient @xmath226 , ( s)he would send out @xmath262 where @xmath2 is the iv they have mutually agreed upon ; and @xmath226 would see it as the list of terms @xmath263 , from which ( s)he can retrieve the individual message terms by applying the last equation for @xmath255 in the system @xmath26 .",
    "this generic block chained encryption - decryption scheme is a natural abstraction of the usual ( xor - based ) cbc : it suffices to interpret the roles of @xmath25 and @xmath27 suitably , and define properly the meanings of ` coupling ' and ` decoupling ' , to get the usual cbc mode ; for that , one would _ define _ the ` coupling ' as well as ` decoupling ' of @xmath3 with @xmath19 as @xmath264 ; @xmath17 would then stand for @xmath265 , and @xmath266 would stand for @xmath267 , where @xmath268 is decryption with the private key of @xmath226 . if we go back to example  [ ping ] based on the usual cbc , the encrypted part of",
    "what @xmath227 sends out to @xmath226 ( with the notation employed there ) is the list of terms : @xmath269 $ ] , that corresponds to the term @xmath270 , v)$ ] . by applying the fifth equation in @xmath26 to this list of terms , under the assignments : @xmath271 $ ] , @xmath226",
    "would then derive the following list :     @xmath272 , h(a , v ) ) \\,]$ ] ;    i.e. , the list @xmath273 $ ] . in other words ,",
    "the usual xor - based cbc is indeed an ` instance ' of the theory @xmath26 .",
    "[ r:2 ] other ` concrete ' cipher - decipher block chaining modes can also be seen as instances of @xmath26 ; one among them is the _ cipher feedback encryption mode _ ( cfb ) , which is defined as follows :",
    "let @xmath8 be a message given as a list of @xmath9 ` plaintext ' message subblocks .",
    "then the encryption of @xmath10 with any given key @xmath11 and initialization vector @xmath12 is defined as the list @xmath13 , of ciphertext message subblocks , where :     @xmath274 , and  @xmath275 , for any @xmath16    this encryption mode ( also using xor ) is very similar to cbc , but works in the reverse direction ( cf .",
    "e.g. , http://en.wikipedia.org/wiki/block_cipher_modes_of_operation ) .",
    "it is an instance of @xmath26 , if the ` coupling ' and the ` decoupling ' operations of @xmath26 , namely @xmath17 and @xmath276 , are both defined as @xmath277 .",
    "the theory @xmath26 thus appears , indeed , as a high level equational abstraction of the block chained encryption - decryption mode ; it employs no ac - symbols for this abstraction .",
    "it is easy to see , on the other hand , that the equations of @xmath26 can all be oriented left - to - right under a suitable reduction ordering , to give a convergent rewrite system .",
    "we shall be showing below that unification modulo @xmath26 is np - decidable ; it turns out to be actually np - complete , due to the presence of a left - inverse for @xmath25 ( namely @xmath27 ) .",
    "[ r:3 ] : it is important to note that the function  @xmath27 is not semi - cancellative : @xmath278 , but @xmath279 and @xmath280 need not be equivalent modulo  @xmath26",
    ". however , it is easy to show that @xmath27 is left - cancellative ; see _ appendix-1 _ for the details .",
    "[ unifmod - dbc ]    we assume without loss of generality that any @xmath26-unification problem @xmath53 is given in a standard form , i.e. , as a set of equations @xmath54 , each having one of the following forms :     @xmath281 + @xmath282    we have to extend some of the notions and notation of section  [ inf - l ] , in order to take  @xmath255 into account .",
    "these extensions concern the propagation graph @xmath107 of the problem and * nonnil * , the set of variables which can not be _ nil . _    1 .",
    "if @xmath283 is in @xmath53 , then write @xmath284 ; in which case , insert a directed arc on @xmath107 from @xmath103 $ ] to @xmath108 $ ] and label it with @xmath285 .",
    "the graph @xmath107 will also have then a _ two - sided ( undirected ) _ edge between @xmath103 $ ] and @xmath108 $ ] , labeled with @xmath286 .",
    "the set of variables * nonnil * , defined earlier , is extended as follows : + if @xmath283 is in @xmath53 , then @xmath95 is in * nonnil * if and only if @xmath75 is in * nonnil*.    we define a new relation @xmath287 .",
    "its symmetric closure is @xmath288 and its transitive , reflexive , and symmetric closure is @xmath289 .",
    "the relations @xmath290 are then defined in the usual manner . if @xmath291 , then @xmath95 and @xmath75 are related by ` chaining ' , i.e. by some number of @xmath5 and @xmath255 operations .",
    "we refine then the partial relation @xmath117 on the nodes of @xmath107 as follows :     @xmath292    this relation can still continue to be read as : @xmath103 \\succ_l [ v]$ ] iff there is a directed path on @xmath107 from @xmath103 $ ] to @xmath108 $ ] , at least one arc of which has label @xmath110 .",
    "we extend now the inference system @xmath199 of section  [ inf - l ] by adding the following list - inferences ; these additional rules are essentially the @xmath255-counterparts of the list - inferences of @xmath199 which only needed to consider @xmath5 .",
    "( there are several reasons why we have not worked with @xmath26 right from the start  maybe the inference system would possibly have been more concise , if we had done so .",
    "a first reason is , that would have been at the expense of readability ; a second reason is that @xmath24-unification is of interest on its own , especially for @xmath52 , as is shown by example  [ ping ] above ; a third and conclusive reason is that the inference system we present below for @xmath26-unification , actually reduces the problem to a problem of @xmath24-unification . )",
    "we first formulate the `` dont - care '' nondeterministic inference rules .",
    "( db1.a ) _",
    "nil solution-1 for @xmath255 _ : : :    @xmath293 ( db1.b ) _ nil solution-2 for @xmath255 _ : : :    @xmath294 ( db1.c ) _ nil solution-3 for @xmath255 _ : : :    @xmath295            { { \\mathcal{eq}}~ \\cup ~ \\ { \\ ;   u = _ { } ^ ? nil , \\",
    "; v = _ { } ^ ?",
    "nil   \\ ; \\ } }            { { \\mathcal{eq}}~ \\uplus ~ \\ { \\ ;   u = _ { } ^ ?",
    "db(v , x )   \\ ; \\}}\\ ] ] ( db2 ) _ left - cancellation on @xmath255 _ : : :    @xmath296            { { \\mathcal{eq}}~ \\cup ~ \\ { \\ ; u = _ { } ^ ?",
    "db(v , y ) , \\ ; x = _ { } ^ ? y   \\ ; \\ } }            { { \\mathcal{eq}}~ \\uplus ~ \\ { \\ ;   u = _ { } ^ ?",
    "db(v , x ) , \\ ; u = _ { } ^ ?",
    "db(v , y )   \\ ; \\}}\\ ] ] ( db3.a ) _ push @xmath255 below @xmath69 , at a @xmath128 @xmath297-peak _ : : :    @xmath298                & u ' = _ { } ^ ?",
    "db(v ' , v ) , \\ ; u ' = _ { } ^ ?",
    "db(w ' , w ) , \\ ;                            u = _ { } ^ ?",
    "g(v , x ) , \\ ; u = _ { } ^ ?",
    "g(w , y )   \\ ; \\ }            \\end{aligned } }            { { \\mathcal{eq}}~ \\uplus ~ \\ { \\ ;   u = _ { } ^ ?",
    "db(v , x ) , \\ ; u = _ { } ^ ?",
    "db(w , y ) \\ ;              \\}}\\ ] ]    +    @xmath299 ( db3.b ) _ push @xmath5 and @xmath255 below @xmath69 at a @xmath128 @xmath300-peak _ : : :    @xmath301                & u ' = _ { } ^ ?",
    "bc(v ' , u ) , \\ ; u ' = _ { } ^ ?",
    "db(w ' , w ) ,                               \\ ; u = _ { } ^ ?",
    "h(v , x ) , \\ ; w = _ { } ^ ?",
    "h(u , y )   \\ ; \\ }            \\end{aligned } }            { { \\mathcal{eq}}~ \\uplus ~ \\{\\ ; u = _ { } ^ ?",
    "bc(v , x ) , \\ ; u = _ { } ^ ?",
    "db(w , y ) \\;\\}}\\ ] ]    +    @xmath302 ( db4 ) _ splitting for @xmath255 at a @xmath303-peak _ : : :    @xmath304 ( db5 ) _ flip @xmath255 to @xmath5 conditionally : _ : :    @xmath305             { { \\mathcal{eq}}~ \\cup ~ \\ { v = _ { } ^ ?",
    "bc(u , x ) \\ } }           { { \\mathcal{eq}}~ \\uplus ~ \\ { u = _ { } ^ ?",
    "db(v , x ) \\ } } \\ ] ]    rules ( db3.a ) , ( db3.b ) , ( db4 ) and ( db5 ) have the lowest priority : they are to be applied in the `` laziest '' fashion .",
    "the rule ( db3.b ) ( `` _ push @xmath5 and @xmath255 below @xmath69 ",
    "if @xmath128 _ '' ) is justified by the conditional left - cancellativity of @xmath255 ( cf .",
    "lemma f , _ appendix-2 _ ) .",
    "rule ( db5 ) is actually a ` narrowing ' step , justified by the fact that @xmath255 ` is a left - inverse ' for @xmath5 .    for the completeness of the procedure",
    ", we shall also need a few more list inference rules which are `` dont - know '' nondeterministic ; namely , the rules ( db6.a)(db8 ) below :    ( db6.a ) _ guess a nil - solution - branch for @xmath255 at a @xmath297-peak _ : : :    @xmath306 ( db6.b ) _ guess a nil - solution - branch for @xmath5 and @xmath255 at a @xmath300-peak _ : : :    @xmath307 ( db7.a ) _ guess a narrowing step for @xmath255 at a @xmath297-peak _ : : :    @xmath308             { { \\mathcal{eq}}~ \\cup ~ \\ { v = _ { } ^ ?",
    "bc(u , x ) , \\ ;   u = _ { } ^ ?",
    "db(w , y\\}\\ } }             { { \\mathcal{eq}}~ \\uplus ~ \\ { u = _ { } ^ ?",
    "db(v , x ) , \\ ; u = _ { } ^ ?",
    "db(w , y\\ } } \\ ] ] ( db7.b ) _ guess a narrowing step for @xmath255 at a @xmath300-peak _ : : :    @xmath309             { { \\mathcal{eq}}~ \\cup ~ \\ { u = _ { } ^ ?",
    "bc(v , x ) , \\ ;   w = _ { } ^ ?",
    "bc(v , y\\}\\ } }             { { \\mathcal{eq}}~ \\uplus ~ \\ { u = _ { } ^ ?",
    "bc(v , x ) , \\ ; u = _ { } ^ ?",
    "db(w , y\\ } } \\ ] ] ( db8 ) _ standard unification on @xmath255 _ : : :    @xmath310    we denote by @xmath311 the inference system that extends @xmath176 with the list - inference rules ( db1)(db8 ) , given above .",
    "it is important to note that the occur - check violation rule ( l6 ) is henceforth to be applied to @xmath26-unification problems in standard form , under the partial relation @xmath117 _ as has been refined above_.    [ list - inf - dbc-1 ] let @xmath53 be any @xmath26-unification problem , given in standard form .",
    "the inference system @xmath311 terminates on @xmath53 in polynomially many steps .",
    "this is an extension of proposition  [ list - unifiable ] , to the inference system @xmath311 .",
    "the proof of that earlier proposition can be carried over practically verbatim : we only have to show that the new inferences that might introduce fresh variables , namely the three rules ( db3.a ) , ( db3.b ) and ( db4 ) , can not lead to a non - terminating chain of inferences .",
    "to ensure this , a first observation is that the relation @xmath167 , which was used in the proof of proposition  [ list - unifiable ] , _ has to be refined now _ so as to take _ also _ into account the relation @xmath286 , the symmetric closure of @xmath285 , as follows :    * if @xmath312 then @xmath143 .",
    "* let @xmath144 and @xmath145 ; then @xmath146 implies @xmath147 .",
    "a second observation is that these three rules which might introduce fresh variables remove a @xmath286-edge at some node @xmath95 , and introduce a new @xmath286-edge at a node @xmath137 such that @xmath313 ; but the number of @xmath141-equivalence classes remains the same , by the same argument as developed in the proof of proposition  [ list - unifiable ] .",
    "the other details of that earlier proof carry over verbatim .    given any @xmath26-unification problem @xmath53 in standard form , let @xmath314 denote the inference procedure based on the rules of @xmath311 , given above for its list - equations ; we augment the procedure @xmath314 with any given complete procedure for solving the residual set of element - equations in the problem , when the list - inference rules of @xmath311 are no longer applicable .",
    "we have then the following result :    [ completeness-2 ] the procedure @xmath314 is sound and complete for solving @xmath26-unification problems given in standard form .",
    "the proof uses the same lines of reasoning as for proposition  [ complete ] .",
    "the procedure @xmath314 is sound , because to any solution of a problem derived under any of its inferences , corresponds a solution for the initial problem .",
    "the completeness of @xmath314 is again proved , for any given problem , by induction on the maximum number of inference steps needed for the termination of the procedure @xmath314 on the problem ; and using case analysis when necessary , based on the `` dont - know '' inference rules ( db6.a)(db8 ) above , for such an analysis .",
    "we leave out the details , which are straightforward .",
    "[ list - inf - dbc-2 ] let @xmath53 be a @xmath26-unification problem in standard form , to which none of the inferences of @xmath311 is applicable",
    ". then its subset of list - equations with non - nil variables on the left - hand side is in @xmath66-solved form .",
    "this extends proposition  [ d - solved ] to the inference system @xmath311 .",
    "note that we just need to show the following : from any given node @xmath103 $ ] on any given connected component @xmath178 of the propagation graph @xmath107 , there is an unambiguous , cycle - free , directed path to a well - determined end - node on @xmath178 .",
    "now , given that any directed arc on @xmath107 is labeled with either @xmath110 , or @xmath89 , or @xmath285 , there can be at most one outgoing arc from @xmath103 $ ] : otherwise one of the inferences ( db2)(db8 ) would have been applicable ; there can be no directed @xmath117-cycle either at @xmath103 $ ] , otherwise the occur - check violation rule would have been applicable .",
    "thus , the proof of that earlier proposition carries over , essentially verbatim .",
    "[ dbd - in - np ] unification modulo the theory @xmath26 is np - complete .    given any @xmath26-unification problem @xmath53 , computing a standard form can be done in polynomial time ( wrt the number of variables of @xmath53 ) ; the same holds also for constructing the propagation graph for the standard form .",
    "applying then the inference rules of @xmath311 till termination , on this standard form , takes only polynomially many steps , by proposition  [ list - inf - dbc-1 ] . in case of non - failure , extracting the set of element - equations from the resulting problem can obviously be done in polynomial time .    to show that solving @xmath53 is in np , it suffices therefore to show that the set of its element - equations can be solved , modulo the theory defined by the single equation @xmath315 , in nondeterministic polynomial time . but",
    "this is a _ collapsing _ convergent system , and the unification problem for such theories is known to be decidable and finitary  @xcite . in particular , a decision procedure can be built by using basic normalized narrowing , e.g. , as given in  @xcite ; cf .  also  @xcite .",
    "we outline , briefly , such a procedure :    _ procedure for solving @xmath169 _ : note that every equation in @xmath169 is either a @xmath27-equation , i.e. , an equation of the form @xmath316 ; or an @xmath25-equation , of the form @xmath317 .    1 .",
    "if the set of element - equations is in d - solved form , then return that set ; + else if the set contains @xmath27-equations , then go to step 2 ; else go to step 3 .",
    "choose nondeterministically an equation in @xmath169 of the form @xmath316 ; and replace it by the @xmath25-equation @xmath318 .",
    "3 .   if @xmath169 contains two different @xmath25-equations with the same lhs variable , apply standard decomposition below @xmath25 on these two ; and suppress one of the two equations .",
    "apply ( element-)variable elimination to the resulting set of element - equations , if needed .",
    "go to step 1 .",
    "( note that step 2 is just narrowing . )",
    "it is easy to check that this procedure is in np on the size of @xmath169 .",
    "it remains to show that solving a general @xmath26-unification problem is np - hard .",
    "this follows from our proposition  [ nphard ] below , where we actually make a more precise statement .",
    "[ nphard ] unifiability modulo @xmath315 is np - complete .",
    "also  @xcite . ) we need only to prove the np lower bound ; we do that by reduction from the _ monotone 1-in-3 sat _ problem , formulated as follows :    * given a propositional formula in cnf _ without negation _ such that every clause has exactly 3 literals ( variables ) , check for its satisfiability under the condition that _ exactly _ one literal in each clause should evaluate to true .",
    "this problem is known to be np - complete  @xcite .",
    "now consider the following problem of unification modulo @xmath315 , involving 3 element - variables @xmath319 :     @xmath320    where @xmath321 are ground constants .    since @xmath322 is a convergent rewrite system ,",
    "the unifiability problem is equivalent to finding an instance of the equation under an irreducible substitution such that both sides can be reduced to the same term .",
    "but the right - hand side term @xmath323 is irreducible modulo @xmath322 ; so we need to eliminate two @xmath27 symbols from the left - hand side term @xmath324 . the only way to do that is by assigning @xmath325 to two of the variables , and then reduce using the rule @xmath326 .",
    "we easily check that we obtain the following possible results : @xmath327 , @xmath328 , @xmath329 .",
    "if we assign the third ` left - out ' variable  let us call it @xmath3  to @xmath325 , the term obtained @xmath330 would reduce to @xmath331 , which is irreducible and different from @xmath323 .",
    "if we assign this left - out variable to some irreducible term @xmath280 different from @xmath325 and @xmath332 , then @xmath333 would be irreducible , again different from @xmath323 .",
    "hence , the only way to reduce both sides of the given problem to become equal , is to assign @xmath332 to the left - out variable . in other words : solving this problem amounts to assigning the term @xmath332 to exactly one of the three variables @xmath319 , and assigning @xmath325 to the other two .",
    "now let us consider a ( finite ) set of clauses , each with three positive literals .",
    "to each clause @xmath334 in this set , we associate @xmath335 element - variables @xmath319 , and the element - equation @xmath336 on these variables . from the discussion above",
    ", the system of derived equations has a solution modulo @xmath315 if and only if the set of clauses is 1-in-3 satisfiable .",
    "[ r:4 ] ( i ) it can be shown that @xmath26-unification is finitary , along the same lines of reasoning as for the proof of proposition  [ finitariness ] .",
    "\\(ii ) the inference rules ( db5 ) , ( db7.a ) and ( db7.b ) of @xmath311  which are justified by the last equation of @xmath26  play the role of reducing unification modulo @xmath26 , in fine , to unification modulo @xmath24 .",
    "\\(i ) the following problem : @xmath337 is unsatisfiable .",
    "our procedure exits with failure : we have an occur - check violation : @xmath338 .",
    "\\(ii ) the following problem @xmath53 is in standard form :     @xmath339    we have a @xmath303-peak at @xmath103 $ ] on the graph of @xmath53 , and the only `` dont - care '' rule applicable is the splitting rule ( db4 ) ; we can use the equation @xmath340 for that splitting .",
    "after cancellation on @xmath69 and a variable elimination step , the problem derived is :     @xmath341    which is in d - solved form , and gives a solution .",
    "\\(i ) the following problem : @xmath342 is in standard form , but is not in a @xmath66-solved form . rule ( db1.c ) is applicable , and gives the `` nil '' solution to @xmath95 and @xmath75 , with @xmath343 arbitrary .",
    "\\(ii ) the following problem @xmath53 is in standard form : @xmath344 , but not in a d - solved form ; the only applicable inference rule is ( db5 ) ( _ flip @xmath255 to @xmath5 _ conditionally ) , and the problem becomes :     @xmath345    this is a @xmath24-unification problem which is l - reduced , but not in a d - solved form .",
    "none of the list - variables @xmath346 is in * nonnil * ; so , an obvious easy solution is @xmath347 , the element - variables @xmath348 being arbitrary ; this corresponds to applying rule ( l8 ) .",
    "we could also nondeterministically apply the rule ( l10 ) ( _ standard unification on @xmath5 _ ) ; to deduce then the most general solution solution , namely : @xmath349 .",
    "the following problem @xmath53 is in standard ( but not in a d - solved ) form :     @xmath350    observe that @xmath351 but @xmath352 , so the rule ( db5 ) ( _ flip @xmath255 to @xmath5 conditionally _ ) is applicable to the equation on @xmath100 ; and that gives :     @xmath353    the problem now presents a @xmath113-peak at @xmath354 which is in @xmath128 , so rule ( l4.b ) can be applied , by writing @xmath355 ; this , followed by cancellation on @xmath69 , and a standard unification step on @xmath25 , leads us to deduce : @xmath356 , and subsequently @xmath357 ; the problem is thus transformed ( after some variable elimination steps ) into :     @xmath358    the rule ( db5 ) ( _ flip @xmath255 to @xmath5 conditionally _ ) is again applicable , now to the equation on @xmath75 ; we thus get :     @xmath359    the rule ( l4.a ) ( _ semi - cancellation on @xmath5 at a @xmath113-peak _ ) is now applicable , and we deduce : @xmath360 ; after variable elimination , the problem transforms to :     @xmath361    which presents a @xmath115-peak on @xmath95 , so the splitting rule ( l5 ) is applicable ; we write @xmath362 , and the problem evolves ( after variable elimination ) to :    @xmath363 ,    @xmath364    the list - equations , as well as the element - equations , are now in @xmath66-solved form ; and they do give a solution to the problem we started with ( as can be easily checked ) .",
    "we first addressed the unification problem modulo a convergent 2-sorted rewrite system @xmath24 , that models , in particular , the ( usual , xor - based ) cbc encryption mode of cryptography , by interpreting suitably the function @xmath25 in  @xmath24 . a procedure is given for deciding unification modulo @xmath24 , which has been shown to be sound and complete ( and finitary ) when @xmath25 is either uninterpreted , or interpreted in such a manner . in the uninterpreted case , the procedure is a combination of the inference procedure @xmath365 presented in this paper , with syntactic unification ; it turns out to be of polynomial complexity , essentially for this reason . in the case where @xmath25 is interpreted as mentioned above , the unification procedure is a combination of @xmath365 with any complete procedure for deciding unification modulo the associative - commutative theory for xor ; and it turns out to be np - complete for this reason .",
    "the second part of the work extends @xmath24 into a theory @xmath26 that models , at an abstract level , a cipher - decipher block chaining scheme .",
    "unifiability modulo  @xmath26 is shown to be decidable by an inference procedure , which essentially ` reduces ' any @xmath26-unification problem in fine into one over @xmath24 .",
    "unification modulo @xmath26 is also ( finitary and ) np - complete .    a point that seems worth mentioning here concerns the binary function symbol @xmath69 in @xmath26 .",
    "we have implicitly assumed that in practical situations ( such as in example 2 above ) the two arguments of @xmath69 are ` accessible ' ; this can be made more explicit by adding two ` projection ' equations to @xmath26 , using @xmath366 and @xmath367 on @xmath69 , to get the following set of @xmath368 equations : @xmath369 with @xmath366 typed as @xmath370 , and @xmath367 as @xmath371 .",
    "all these equations can be oriented left - to - right under a suitable simplification ordering , and the resulting rewrite system remains convergent .",
    "it is not difficult to check that , even after the addition of these two projection rules , unification problems  with some very minor restrictions on the form of equations involving @xmath366 and @xmath367  can still be assumed in a standard form , and solved by the inference procedure @xmath311 given above . in other words , the results of section  [ dbc ] remain valid for this enlarged 2-sorted convergent rewrite system  that we shall again refer to as @xmath26 , since no confusion seems likely .",
    "the rewrite system @xmath26 thus enlarged can actually been shown to be @xmath372-strong in the sense of @xcite , under a suitable precedence based ( lpo- or rpo- like ) simplification ordering , by taking @xmath372 to be the subsystem formed of the two rules ( 6.1 ) and ( 6.2 ) .",
    "it would then follow from proposition 11 of @xcite , that the so - called ` passive deduction ' problem , for an intruder , is decidable , if the intruder capabilities are modeled by this theory @xmath26 .",
    "this would yield , to our knowledge , the first purely rewrite / unification based approach for analyzing cryptographic protocols employing the cbc encryption mode .",
    "the details will be given elsewhere , where we also hope to present decision procedures for a couple of other security problems , where an intruder eavesdrops or guesses some low - entropy data in the context of block ciphers .",
    "finally , observe that unification modulo equational theories often serves as an auxiliary procedure in several formal protocol analysis tools , such as maude - npa , cl - atse , ",
    ", for handling algebraic properties of cryptoprimitives .",
    "the work we have presented in this paper could be of use in these tools , as a first step towards the automation of attack detection in cryptographic protocols employing cbc .",
    "alpha    m.  abadi , v.  cortier .",
    "`` deciding knowledge in security protocols under equational theories '' .  367(1 - 2):232 ,  2006 .",
    "s.  anantharaman , c.  bouchard , p.  narendran , m.  rusinowitch .",
    "`` unification modulo chaining '' . in _ proc .",
    "of 6th int .",
    "conference on language and automata theory and applications - lata 2012 _ , lncs 7183 , pp .",
    "7082 , springer - verlag , 2012 .",
    "s.  anantharaman , p.  narendran , m.  rusinowitch .",
    "`` intruders with caps '' . in _ proc .   of the int .",
    "conference rta07 _ , lncs 4533 , pp .",
    "2035 , springer - verlag , 2007 .",
    "s.  anantharaman , h.  lin , c.  lynch , p.  narendran , m.  rusinowitch .",
    "`` unification modulo homomorphic encryption '' .",
    "48(2):135158  ( 2012 )    f.  baader , w.  snyder .",
    "`` unification theory '' . in _",
    "handbook of automated reasoning _ , pp .",
    "440526 , elsevier sc .",
    "publishers b.v . , 2001 .",
    "m.  bellare , r.  gurin , p.  rogaway .",
    "`` xor macs : new methods for message authentication using finite pseudorandom function '' in _ proc .  of the int",
    "crypt0 95 , lncs 963 , pp . 1528 , springer - verlag , 1995    m.  baudet .",
    "`` deciding security of protocols against off - line guessing attacks '' . in _ proc .  of the @xmath373th acm conf .",
    "on computer and comm . security _ , ccs05 , pp . 1625 , 2005 .",
    "h.  comon - lundh , r.  treinen . `` easy intruder deductions . ''",
    "verification : theory and practice , essays dedicated to zohar manna on the occasion of his @xmath374  birthday ( n.  dershowitz , ed . ) . in _",
    "lncs  _ 2772 , pp . 225242 , springer - verlag , 2003 .",
    "h.  comon - lundh , v.  shmatikov .",
    "`` intruder deductions , constraint solving and insecurity decision in presence of exclusive - or . '' in _ proc .  of the logic in computer science conference , lics03 , _ pp .",
    "271280 , 2003 .",
    "n.  dershowitz .",
    "`` termination of rewriting . ''",
    "3(1/2 ) : 69116  ( 1987 ) .",
    "d.  dolev , s.  even , r.  karp , `` on the security of ping - pong protocols '' .",
    "55:57 - 68 ( 1982 ) .",
    "q.  guo , p.  narendran , d.a .",
    "`` unification and matching modulo nilpotence . '' in _ proc .  of the 13th int .",
    "conf . on automated deduction , _",
    "( cade-13 ) , lncs  1104 , pp .",
    "261274 , springer , 1996 .",
    "`` canonical forms and unification . '' in _ proc .  of the 5th int . conf . on automated deduction , _",
    "( cade-5 ) , lncs  87 , pp .",
    "318334 , springer , july  1980 .",
    "jouannaud , and c.  kirchner .",
    "`` solving equations in abstract algebras : a rule - based survey of unification . '' in _ computational logic : essays in honor of alan robinson , _ 360394 , mit press , boston , 1991 .",
    "p. c.  kanellakis , and p. z.  revesz .",
    "`` on the relationship of congruence closure and unification . ''  7 : 427 - 444  ( 1989 ) .    c.  lynch , z.  liu , `` efficient general unification for xor with homomorphism . '' in em",
    "proc .  of the 23rd int .",
    "conference on automated seduction , ( cade-23 ) , lncs  6803 , pp .",
    "407421 , springer - verlag , 2011 .    c.  lynch , b.  morawska , `` basic syntactic mutation . '' in em proc .  of the 18th int .",
    "conference on automated deduction , ( cade-18 ) , lnai  2392 , pp .",
    "471485 , springer - verlag , 2002 .",
    "j.  millen , h .-",
    "`` narrowing terminates for encryption . '' in _ proc .",
    "of the ninth ieee computer security foundations workshop ( csfw ) _ , pp .",
    "3944 , 1996 .",
    "k. g.  paterson , t.  ristenpart , t.  shrimpton .",
    "`` tag size _ does _ matter : attacks and proofs for the tls record protocol '' in _ proc .  of int .",
    "asiacrypt 2011 , lncs 2073 , pp .",
    "372389 , springer - verlag , 2011 .",
    "t. j.  schaefer .",
    "`` the complexity of satisfiability problems . '' in _ proc .  of the 10th annual acm symposium on theory of computing _ , pp .",
    "216226 , 1978 .",
    "* lemma a*. for all terms @xmath375 , we have :     @xmath376 if and only if @xmath377 .    the proof is by structural induction on the terms , based on the semi - cancellativity of @xmath25 and the cancellativity of @xmath69 . if either @xmath378 or @xmath379 is @xmath1 , then the other has to be @xmath1 too , and the assertion of the lemma is trivial .",
    "so suppose that @xmath378 and @xmath379 are not @xmath1",
    ". then @xmath380 and @xmath381 , for some terms @xmath382 . substituting back into the original equation and applying the second axiom of @xmath24",
    ", we deduce that :     @xmath383    since @xmath69 is cancellative , we get :     @xmath384 , and @xmath385 .    from    the semi - cancellativity of @xmath25 , we then deduce that :     @xmath386 , and @xmath387 .",
    "therefore , by structural induction , we deduce that @xmath388 , and the result follows .",
    "* lemma b*. for all terms @xmath389 , we have :     @xmath390 if and only if @xmath391 or @xmath392",
    ".    the proof is by exactly the same reasonings as for proving the previous lemma .",
    "we shall paraphrase these two lemmas together by saying that @xmath5 is `` conditionally '' semi - cancellative .    * lemma c*. for all terms @xmath393 : if @xmath394 + then @xmath395 and @xmath377 .    by applying the second axiom of @xmath24",
    ", we get :     @xmath396    cancellation on @xmath69 gives :     @xmath397 and @xmath398    by lemma a above , this implies that @xmath377 .    in what follows , by @xmath26 we shall mean the equational theory @xmath26 of section  [ dbc ] , and the rewrite system it defines .",
    "as for the analogs of the above results for the operator @xmath255 of @xmath26 , we first observe that the function  @xmath27 is not semi - cancellative  more precisely , it is not right - cancellative : indeed , we have @xmath278 , although @xmath399 , in general .",
    "but left - cancellativity holds for @xmath27 .    * lemma d*.  [ dbc - left - can ] if @xmath400 then @xmath401 .",
    "we can assume wlog that the terms @xmath402 , @xmath403 , and @xmath404 are in normal form .",
    "if @xmath405 , then both @xmath406 and @xmath407 must be redexes , or , in other words , @xmath408 for some  @xmath409 .",
    "since  @xmath25 is semi - cancellative this leads to a contradiction .    * corollary e*.  [ dbc - g - neq ] if @xmath410 , and @xmath411 , then @xmath412 .",
    "so , the analog of lemma a for @xmath255 does not hold in general .",
    "however , @xmath255 is ` conditionally ' left - cancellative :    * lemma f*. for all terms @xmath413 , we have :     @xmath414 if and only if @xmath415 or @xmath416 .",
    "we just need to prove the `` only if '' assertion . if @xmath354 is not @xmath1 , then @xmath417 for some @xmath418 . applying the last axiom of @xmath26",
    ", we get :     @xmath419 .",
    "the assertion follows then from the cancellativity of @xmath69 and the left - cancellativity of @xmath27 .",
    "* lemma g*.[db - leftinversefor - bc ] let @xmath420 be the convergent rewrite system formed of the first five rules in the system @xmath26 of section  [ dbc ] . for any list - term @xmath95 and element - term @xmath3",
    "both in @xmath420-normal form , we have : @xmath421 .",
    "the proof is by structural induction on @xmath95 .",
    "the base case when @xmath95 is @xmath1 is trivial ; so suppose @xmath422 for some element - term @xmath138 , and list - term @xmath151 .",
    "substituting for @xmath95 and using first the @xmath423nd equational axiom of @xmath420 , the left - hand side of the assertion becomes :"
  ],
  "abstract_text": [
    "<S> we investigate unification problems related to the cipher block chaining ( cbc ) mode of encryption . we first model chaining in terms of a simple , convergent , rewrite system over a signature with two disjoint sorts : _ list _ and _ element . </S>",
    "<S> _ by interpreting a particular symbol of this signature suitably , the rewrite system can model several practical situations of interest . </S>",
    "<S> an inference procedure is presented for deciding the unification problem modulo this rewrite system . </S>",
    "<S> the procedure is modular in the following sense : any given problem is handled by a system of ` list - inferences ' , and the set of equations thus derived between the element - terms of the problem is then handed over to any ( ` black - box ' ) procedure which is complete for solving these element - equations . </S>",
    "<S> an example of application of this unification procedure is given , as attack detection on a needham - schroeder like protocol , employing the cbc encryption mode based on the associative - commutative ( ac ) operator xor . </S>",
    "<S> the 2-sorted convergent rewrite system is then extended into one that fully captures a block chaining encryption - decryption mode at an abstract level , using no ac - symbols ; and unification modulo this extended system is also shown to be decidable . </S>"
  ]
}