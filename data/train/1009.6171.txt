{
  "article_text": [
    "a common approach to specifying computation systems is via deductive systems . those are used to specify and reason about various logics , as well as aspects of programming languages such as operational semantics , type theories , abstract machines .",
    "such specifications can be represented as logical theories in a suitably expressive formal logic where _ proof - search _ can then be used to model the computation . a logic used as a specification language",
    "is known as a _ logical frameworks _",
    "@xcite , which comes equipped with a representation methodology .",
    "the encoding of the syntax of deductive systems inside formal logic can benefit from the use of _ higher - order abstract syntax _ ( hoas ) a high - level and declarative treatment of object - level bound variables and substitution . at the same time , we want to use such a logic to reason over the _ meta - theoretical _ properties of object languages , for example type preservation in operational semantics  @xcite , soundness and completeness of compilation  @xcite or congruence of bisimulation in transition systems  @xcite .",
    "typically this involves reasoning by ( structural ) induction and , when dealing with infinite behavior , co - induction  @xcite .    the need to support both inductive and co - inductive reasoning and some form of hoas requires some careful design decisions , since the two are prima facie notoriously incompatible .",
    "while any meta - language based on a @xmath0-calculus can be used to specify and animate hoas encodings , meta - reasoning has traditionally involved ( co)inductive specifications both at the level of the syntax and of the judgements  which are of course unified at the type - theoretic level .",
    "the first provides crucial freeness properties for datatypes constructors , while the second offers principles of case analysis and ( co)induction . this is well - known to be problematic , since hoas specifications may lead to non - monotone ( co)inductive operators , which by cardinality and consistency reasons are not permitted in inductive logical frameworks .",
    "moreover , even when hoas is weakened so as to be made compatible with standard proof assistants  @xcite such as hol or coq , the latter suffer the fate of allowing the existence of too many functions and yielding the so called _ exotic _ terms .",
    "those are canonical terms in the signature of an hoas encoding that do not correspond to any term in the deductive system under study .",
    "this causes a loss of adequacy in hoas specifications , which is one of the pillar of formal verification , and it undermines the trust in formal derivations . on the other hand , logics such as lf  @xcite that are weak by design in order to support this style of syntax are not directly endowed with ( co)induction principles .",
    "the contribution of this paper lies in the design of a new logic , called @xmath1 ( for a logic with @xmath0-terms , induction and co - induction),-quantifier the eponymous logic in tiu s thesis  @xcite . ] which carefully adds principles of induction and co - induction to a higher - order intuitionistic logic based on a proof theoretic notion of _ definition _ , following on work ( among others ) by lars hallns  @xcite , eriksson @xcite , schroeder - heister  @xcite and mcdowell and miller  @xcite .",
    "definitions are akin to logic programs , but allow us to view theories as `` closed '' or defining fixed points .",
    "this alone permits to perform case analysis independently from induction principles .",
    "our approach to formalizing induction and co - induction is via the least and greatest solutions of the fixed point equations specified by the definitions .",
    "the proof rules for induction and co - induction make use of the notion of _ pre - fixed points _ and _ post - fixed points _ respectively . in the inductive case",
    ", this corresponds to the induction invariant , while in the co - inductive one to the so - called simulation .",
    "judgements are encoded as definitions accordingly to their informal semantics , either inductive or co - inductive .    the simply typed language and the notion of free equality underlying @xmath1 , enforced via ( higher - order ) unification in an inference rule ,",
    "make it possible to reason _ intensionally _ about syntax .",
    "in fact , we can support hoas encodings of constants and we can _ prove _ the freeness properties of those constants , namely injectivity , distinctness and case exhaustion , although they can not be the constructors of a ( recursive ) datatype .",
    "@xmath1 can be proved to be a conservative extension of @xmath2  @xcite and a generalization ( with a term language based on simply typed @xmath0-calculus ) of martin - lf first - order theory of iterated inductive definitions  @xcite . moreover , to the best of our knowledge , it is the first sequent calculus with a syntactical cut - elimination theorem for co - inductive definitions . in recent years , several logical systems have been designed that build on the core features of @xmath1 . in particular ,",
    "one interesting , and orthogonal , extension is the addition of the @xmath3-quantifier  @xcite , which allows one to reason about the intentional aspects of _ names and bindings _ in object syntax specifications ( see , e.g. ,  @xcite ) .",
    "the cut elimination proof presented in this paper can be used as a springboard towards cut elimination procedures for more expressive ( conservative ) extensions of @xmath1 .",
    "in fact , the possibility of adapting the cut elimination proof for @xmath1 to various extensions of @xmath1 with @xmath3 is one of the main reasons to introduce a _ direct _",
    "syntactic cut elimination proof .",
    "we note that there are at least a couple of indirect methods to prove cut elimination in a logic with inductive and/or co - inductive definitions .",
    "the first of such methods relies on encodings of inductive and co - inductive definitions as second - order ( or higher - order ) formulae .",
    "this approach is followed in a recent work by baelde and miller  @xcite where a logic similar to @xmath1 is considered .",
    "cut elimination in their work is proved indirectly via an encoding into higher - order linear logic . however , in the presence of @xmath3 , the existence of such an encoding is presently unknown .",
    "the second approach is via semantical methods .",
    "this approach is taken in a recent work by brotherston and simpson  @xcite , which provide a model for a classical first - order logic with inductive definitions , hence , cut elimination follows by the semantical completeness of the cut free fragment .",
    "it is not obvious how such semantical methods can be adapted to prove cut elimination for extensions of @xmath1 with @xmath3 .",
    "this is because the semantics of @xmath3 itself is not yet very well understood , although there have been some recent attempts , see  @xcite .",
    "the present paper is an extended and revised version of  @xcite . in the conference paper ,",
    "the co - inductive rule had a technical side condition that is restrictive and unnatural .",
    "the restriction was essentially imposed by the particular cut elimination proof technique outlined in that paper .",
    "this restriction has been removed in the present version , and the ( co-)induction rules have been generalized . for the latter ,",
    "the formulation of the rules is inspired by a second - order encoding of least and greatest fixed points .",
    "consequently , we now develop a new cut elimination proof , which is radically different from the previous proof , using a reducibility - candidate technique , which is influenced by girard s strong normalisation proof for system f  @xcite .",
    "this paper is concerned only with the cut elimination proof of @xmath1 . for examples and applications of @xmath1 and its extensions with @xmath3",
    ", we refer the interested reader to  @xcite .",
    "the rest of the paper is organized as follows .",
    "section  [ sec : linc ] introduces the sequent calculus for the logic .",
    "section  [ sec : drv ] presents two transformations of derivations that are essential to the cut reduction rules and the cut elimination proof in subsequent sections .",
    "section  [ sec : cut - elim ] is the heart of the paper : we first ( subsection  [ sec : reduc ] ) give a ( sub)set of reduction rules that transform a derivation ending with a cut rule to another derivation .",
    "the complete set of reduction can be found in appendix  [ app : reduc ] .",
    "we then introduce the crucial notions of _ normalizability _ ( subsection  [ sec : norm ] ) and of _ parametric reducibility _ after girard ( subsection  [ sec : red ] ) .",
    "detailed proofs of the main lemma related to reducibility candidates are in appendix  [ app : red ] .",
    "the central result of this paper , i.e. , cut elimination , is proved in details in subsection  [ sec : ceproof ] .",
    "section  [ sec : lrel ] surveys the related work and concludes the paper .",
    "@xmath4{{c\\longrightarrow c } } { }       \\quad      \\infer[{\\hbox{\\sl c}{\\cal l}}]{{b,\\gamma\\longrightarrow c } }      { { b , b,\\gamma\\longrightarrow c } }      \\quad      \\infer[{\\hbox{\\sl w}{\\cal l}}]{{b,\\gamma\\longrightarrow c}}{{\\gamma\\longrightarrow c } }    }    \\\\ \\\\",
    "\\multicolumn{2}{c } {             \\infer[\\begin{array}{l }        { \\hbox{\\sl mc } } ,         \\mbox{where } n > 0       \\end{array } ]      { { \\delta_1,\\dots,\\delta_n , \\gamma\\longrightarrow c } }      { { \\delta_1\\longrightarrow b_1 }        & \\cdots &        { \\delta_n\\longrightarrow b_n } &        { b_1,\\dots , b_n , \\gamma\\longrightarrow c } } }            \\\\",
    "\\\\    \\infer[{\\bot{\\cal l}}]{{\\bot,\\gamma\\longrightarrow b}}{\\rule{0pt}{6pt } }    & \\infer[{\\top{\\cal r}}]{{\\gamma\\longrightarrow \\top } } { }    \\\\ \\\\",
    "\\infer[{\\land{\\cal l } } , i \\in \\{1,2\\}]{{b_1 \\land b_2,\\gamma\\longrightarrow d } }    { { b_i,\\gamma\\longrightarrow d } }    &     \\infer[{\\land{\\cal r}}]{{\\gamma\\longrightarrow b \\land c } }    { { \\gamma\\longrightarrow b }      & { \\gamma\\longrightarrow c } }    \\\\ \\\\    \\infer[{\\lor{\\cal l}}]{{b \\lor c,\\gamma\\longrightarrow d } }    { { b,\\gamma\\longrightarrow d }      & { c,\\gamma\\longrightarrow d } }    &     \\infer[{\\lor{\\cal r } } , i \\in \\{1,2\\}]{{\\gamma\\longrightarrow b_1 \\lor b_2 } }    { { \\gamma\\longrightarrow b_i } }    \\\\ \\\\    \\infer[{{\\supset}{\\cal l}}]{{b { \\supset}c,\\gamma\\longrightarrow d } }    { { \\gamma\\longrightarrow b }      & { c,\\gamma\\longrightarrow d } }    & \\infer[{{\\supset}{\\cal r}}]{{\\gamma\\longrightarrow b { \\supset}c } }    { { b,\\gamma\\longrightarrow c } }    \\\\ \\\\    \\infer[{\\forall{\\cal l}}]{{\\forall x.b\\,x,\\gamma\\longrightarrow c } }    { { b\\,t,\\gamma\\longrightarrow c } }    & \\infer[{\\forall{\\cal r}}]{{\\gamma\\longrightarrow \\forall x.b\\,x } }    { { \\gamma\\longrightarrow b\\,y } }    \\\\ \\\\    \\infer[{\\exists{\\cal l}}]{{\\exists x.b\\,x,\\gamma\\longrightarrow c } }    { { b\\,y,\\gamma\\longrightarrow c } }    &     \\infer[{\\exists{\\cal r}}]{{\\gamma\\longrightarrow \\exists x.b\\,x } }    { { \\gamma\\longrightarrow b\\,t } } \\end{array}\\ ] ] +    [ [ equality - rules ] ] equality rules + + + + + + + + + + + + + +    @xmath5 { { s = t , \\gamma\\longrightarrow c } } {    \\{{\\gamma\\rho\\longrightarrow c\\rho}~\\mid~s\\rho = _ { \\beta\\eta } t\\rho \\ } } \\qquad \\infer[{{\\rm eq}{\\cal r } } ] { { \\gamma\\longrightarrow t = t } } { } \\ ] ] +    [ [ induction - rules ] ] induction rules + + + + + + + + + + + + + + +    @xmath6 { { \\gamma ,      p\\,\\vec{t}\\longrightarrow c } } { { b\\,s \\ , \\vec{y}\\longrightarrow s\\,\\vec{y } } & { \\gamma ,      s\\,\\vec{t}\\longrightarrow c } } \\ ] ] @xmath7 { { \\gamma\\longrightarrow p\\,\\vec{t } } } { { \\gamma\\longrightarrow b\\,x^p\\,\\vec{t } } } \\qquad\\qquad \\infer[{{\\rm i}{\\cal r}_p } , p\\,\\vec x { \\stackrel{\\mu}{=}}b\\,p\\,\\vec x ] { { \\gamma\\longrightarrow x^p\\,\\vec{t } } } { { \\gamma\\longrightarrow b\\,x^p\\,\\vec{t}}}\\ ] ] +    [ [ co - induction - rules ] ] co - induction rules + + + + + + + + + + + + + + + + + +    @xmath8 { { p\\,\\vec{t } , \\gamma\\longrightarrow c } } { { b\\,x^p\\,\\vec{t } , \\gamma\\longrightarrow c } } \\qquad\\qquad \\infer[{{\\rm ci}{\\cal l}_p } , p\\,\\vec x { \\stackrel{\\nu}{=}}b\\,p\\,\\vec x ] { { x^p\\,\\vec{t } , \\gamma\\longrightarrow c } } { { b\\,x^p\\,\\vec{t } , \\gamma\\longrightarrow c } } \\ ] ] @xmath9 { { \\gamma\\longrightarrow p\\,\\vec{t } } } { { \\gamma\\longrightarrow s\\,\\vec{t } } &    { s\\,\\vec{y}\\longrightarrow b\\,s\\,\\vec{y } } } \\ ] ]    the logic @xmath1 shares the core fragment of @xmath2 , which is an intuitionistic version of church s simple theory of types .",
    "we shall assume that the reader is familiar with church s simply typed @xmath0-calculus ( with both @xmath10 and @xmath11 rules ) , so we shall recall only the basic syntax of the calculus here .",
    "a simple type is either a _ base type _ or a compound type formed using the function - type constructor @xmath12 .",
    "types are ranged over by @xmath13 , @xmath10 and @xmath14 .",
    "we assume an infinite set of typed variables , written @xmath15 , @xmath16 , etc .",
    "the syntax of @xmath0-terms is given by the following grammar : @xmath17 to simplify presentation , in the following we shall often omit the type index in variables and @xmath0-abstraction .",
    "the notion of free and bound variables are defined as usual .",
    "following church , we distinguish a base type @xmath18 to denote formulae , and we shall represent formulae as simply typed @xmath0-terms of type @xmath18 .",
    "we assume a set of typed constants that correspond to logical connectives .",
    "the constants @xmath19 and @xmath20 denote ` true ' and ` false ' , respectively .",
    "propositional binary connectives , i.e. , @xmath21 , @xmath22 , and @xmath23 , are assigned the type @xmath24 .",
    "quantifiers are represented by indexed families of constants : @xmath25 and @xmath26 , both are of type @xmath27 .",
    "we also assume a family of typed equality symbols @xmath28 .",
    "although we adopt a representation of formulae as @xmath0-terms , we shall use a more traditional notation when writing down formulae .",
    "for example , instead of writing @xmath29 , we shall use an infix notation @xmath30 .",
    "similarly , we shall write @xmath31 instead of @xmath32 . again",
    ", we shall omit the type annotation when it can be inferred from the context of the discussion .",
    "the type @xmath14 in quantifiers and the equality predicate are restricted to those simple types that do not contain occurrences of @xmath18 .",
    "hence our logic is essentially first - order , since we do not allow quantification over predicates . as we shall often refer to this kind of restriction to types , we give the following definition :    a simple type @xmath14 is _ essentially first - order _ ( efo ) if it is generated by the following grammar : @xmath33 where @xmath34 is a base type other than @xmath18 .    for technical reasons ( for presenting ( co-)inductive proof rules ) ,",
    "we introduce a notion of _ parameter _ into the syntax of formulae .",
    "intuitively , they play the role of eigenvariables ranging over the recursive call in a fixed point expression .",
    "more precisely , to each predicate symbol @xmath35 , we associate a countably infinite set @xmath36 , called the _",
    "parameter set for @xmath35_. elements of @xmath36 are ranged over by @xmath37 , @xmath38 , @xmath39 , etc , and have the same type as @xmath35 .",
    "when we refer to formulae of @xmath1 , we have in mind simply - typed @xmath0-terms of type @xmath18 _ in @xmath40-long normal form_. thus formulae of the logic @xmath1 can be equivalently defined via the following grammar : @xmath41 where @xmath14 is an efo - type .",
    "we shall omit the type annotation in @xmath42 when it is not important to the discussion .",
    "a _ substitution _ is a type - preserving mapping from variables to terms .",
    "we assume the usual notion of capture - avoiding substitutions .",
    "substitutions are ranged over by lower - case greek letters , e.g. , @xmath43 , @xmath44 and @xmath45 .",
    "application of substitution is written in postfix notation , @xmath46 denotes the term resulting from an application of substitution @xmath43 to @xmath47 .",
    "composition of substitutions , denoted by @xmath48 , is defined as @xmath49 .",
    "the whole logic is presented in the sequent calculus in figure  [ fig : linc ] , including rules for equality and fixed points , as we discuss in section  [ ssec : eq ] and  [ ssec : coind ] .",
    "a sequent is denoted by @xmath50 where @xmath51 is a formula in @xmath40-long normal form and @xmath52 is a multiset of formulae , also in @xmath40-long normal form .",
    "notice that in the presentation of the rule schemes , we make use of hoas , e.g. , in the application @xmath53 it is implicit that @xmath54 has no free occurrence of @xmath55 .",
    "similarly for the ( co)induction rules .",
    "we work modulo @xmath13-conversion without further notice . in the @xmath56 and @xmath57 rules",
    ", @xmath58 is an eigenvariable that is not free in the lower sequent of the rule .",
    "the @xmath59 rule is a generalization of the cut rule that simplifies the presentation of the cut - elimination proof .",
    "whenever we write a sequent , it is assumed implicitly that the formulae are well - typed : the type context , i.e. , the types of the constants and the eigenvariables used in the sequent , is left implicit as well as they can be inferred from the type annotations of the ( eigen)variables .    in some inference rules , reading them bottom up , new eigenvariables and parameters may be introduced in the premises of the rules , for instance , in @xmath57 and @xmath56 , as typical in sequent calculus .",
    "however , unusually , we shall also allow @xmath60 , @xmath61 and @xmath62 to possibly introduce new eigenvariables ( and new parameters , in the case of @xmath62 ) , again reading the rules bottom - up .",
    "thus the term @xmath47 in the premise of the @xmath60-rule may contain a free occurrence of an eigenvariable not already occuring in the conclusion of the rule .",
    "the implication of this is that @xmath63 is provable for any type @xmath14 ; in other words , there is an implicit assumption that all types are non - empty .",
    "hence the quantifiers in our setting behave more classically than intuitionistically .",
    "the reason for this rather awkward treatment of quantifiers is merely a technical convenience .",
    "we could forgo the non - emptiness assumption on types by augmenting sequents with an explicit signature acting as a typing environment , and insisting that the term @xmath47 in @xmath60 to be well - formed under the typing environment of the conclusion of the rule .",
    "however , adding explicit typing contexts into sequents introduces another layer of bureaucracy in the proof of cut elimination , which is not especially illuminating . and",
    "since our primary goal is to show the central arguments in cut elimination involving ( co-)induction , we opt to present a slightly simplified version of the logic so that the main technical arguments ( which are already quite complicated ) in the cut elimination proof , related to ( co-)induction rules , can be seen more clearly .",
    "the cut elimination proof presented in the paper can be adapted to a different presentation of @xmath1 with explicit typing contexts ; see  @xcite for an idea of how such an adaptation may be done .",
    "we extend the logical fragment with a proof theoretic notion of equality and fixed points .",
    "the right introduction rule for equality is reflexivity , that is , it recognizes that two terms are syntactically equal .",
    "the left introduction rule is more interesting .",
    "the substitution @xmath44 in @xmath64 is a _ unifier _ of @xmath65 and @xmath47 .",
    "note that we specify the premise of @xmath64 as a set , with the intention that every sequent in the set is a premise of the rule .",
    "this set is of course infinite ; every unifier of @xmath66 can be extend to another one ( e.g. , by adding substitution pairs for variables not in the terms ) .",
    "however , in many cases , it is sufficient to consider a particular set of unifiers , which is often called a _",
    "complete set of unifiers ( csu ) _",
    "@xcite , from which any unifier can be obtained by composing a member of the csu set with a substitution . in the case where the terms are first - order terms , or higher - order terms with the pattern restriction  @xcite , the set csu is a singleton , i.e. , there exists a most general unifier ( mgu ) for the terms .    our rules for equality",
    "actually encompasses the notion of _ free equality _ as commonly found in logic programming , in the form of clark s equality theory  @xcite : injectivity of function symbols , inequality between distinct function symbols , and the `` occur - check '' follow from rule @xmath64-rule .",
    "for instance , given a base type @xmath67 ( for natural numbers ) and the constants @xmath68 ( zero ) and @xmath69 ( successor ) , we can derive @xmath70 as follows : @xmath71 { { \\longrightarrow \\forall x.\\ z = ( s~x ) { \\supset}\\bot } } {    \\infer[{{\\supset}{\\cal r } } ] { { \\longrightarrow z = ( s~y ) { \\supset}\\bot } } { \\infer[{{\\rm eq}{\\cal l } } ] { { z = ( s~y)\\longrightarrow \\bot } } { } } } \\ ] ] since @xmath72 and @xmath73 are not unifiable , the @xmath64 rule above has empty premise , thus concluding the derivation .",
    "a similar derivation establishes the occur - check property , e.g. , @xmath74 .",
    "we can also prove the injectivity of the successor function , @xmath75 .",
    "this proof theoretic notion of equality has been considered in several previous work by schroeder - heister  @xcite , and mcdowell and miller  @xcite .",
    "one way of adding induction and co - induction to a logic is to introduce fixed point expressions and their associated introduction and elimination rules , using the @xmath76 and @xmath77 operators of the ( first - order ) @xmath76-calculus .",
    "this is essentially what we shall follow here , but with a different notation . instead of using a `` nameless '' notation with @xmath76 and @xmath77 to express fixed points",
    ", we associate a fixed point equation with an atomic formula .",
    "that is , we associate certain designated predicates with a _",
    "definition_. this notation is clearer and more convenient as far as our applications are concerned . for a proof system using nameless notation for ( co)inductive predicates ,",
    "the interested reader is referred to recent work by baelde and miller  @xcite .",
    "[ def : def - clause ] an _ inductive definition clause _ is written @xmath78 , where @xmath35 is a predicate constant . the atomic formula @xmath79 is called the _ head _ of the clause , and the formula @xmath80 , where @xmath54 is a closed term containing no occurrences of parameters , is called the _",
    "body_. similarly , a _",
    "co - inductive definition clause _ is written @xmath81 .",
    "the symbols @xmath82 and @xmath83 are used simply to indicate a definition clause : they are not a logical connective .",
    "we shall write @xmath84 to denote a definition clause generally , i.e. , when we are not interested in the details of whether it is an inductive or a co - inductive definition . a _ definition _ is a finite set of definition clauses .",
    "a predicate may occur only at most once in the heads of the clauses of a definition .",
    "we shall restrict to _ non - mutually recursive _ definitions .",
    "that is , given two clauses @xmath85 and @xmath86 in a definition , where @xmath87 , if @xmath35 occurs in @xmath51 then @xmath88 does not occur in @xmath54 , and vice versa .",
    "note that the above restriction to non - mutual recursion is immaterial , since in the first - order case it is well known how one can easily encode mutually recursive predicates as a single predicate with an extra argument .",
    "the rationale behind that restriction is merely to simplify the presentation of inference rules and the cut elimination proof .",
    "were we to allow mutually recursive definitions , the introduction rules @xmath89 and @xmath90 for a predicate @xmath35 would have possibly more than two premises , depending on the number of predicates which are mutually dependent on @xmath35 ( see  @xcite for a presentation of introduction rules for mutually dependent definitions ) .    for technical convenience we also bundle up all the definitional clause for a given predicate in a single clause , following the same principles of the _ iff - completion _ in logic programming .",
    "further , in order to simplify the presentation of rules that involve predicate substitutions , we denote a definition using an abstraction over predicates , that is @xmath91 where @xmath54 is an abstraction with no free occurrence of predicate symbol @xmath35 and variables @xmath92 .",
    "substitution of @xmath35 in the body of the clause with a formula @xmath93 can then be written simply as @xmath94 .",
    "when writing definition clauses , we often omit the outermost universal quantifiers , with the assumption that free variables in a clause are universally quantified .",
    "for example even numbers are defined as follows : @xmath95 where in this case @xmath54 is of the form @xmath96 .",
    "the left and right rules for ( co-)inductively defined atoms are given at the bottom of figure  [ fig : linc ] . in rules @xmath89 and @xmath90 , the abstraction @xmath93 is an invariant of the ( co-)induction rule .",
    "the variables @xmath97 are new eigenvariables and @xmath37 is a new parameter not already occuring in the lower sequent . for the induction rule @xmath89 , @xmath93 denotes a pre - fixed point of the underlying fixed point operator .",
    "similarly , for the co - induction rule @xmath90 , @xmath93 can be seen as denoting a post - fixed point of the same operator . here",
    ", we use a characterization of induction and co - induction proof rules as , respectively , the least and the greatest solutions to a fixed point equation .",
    "notice that the right - introduction rules for inductive predicates and parameters ( dually , the left - introduction rules for co - inductive predicates and parameters ) are slightly different from the corresponding rules in @xmath98-like logics ( see remark  [ rem : unf ] ) .",
    "these rules can be better understood by the usual interpretation of ( co-)inductive definitions in second - order logic  @xcite ( to simplify presentation , we show only the propositional case here ) : @xmath99 @xmath100 then the right - introduction rule for inductively defined predicate will involve an implicit universal quantification over predicates . as standard in sequent calculus ,",
    "such a universal quantified predicate will be replaced by a new eigenvariable ( in this case , a new parameter ) , reading the rule bottom up .",
    "note that if we were to follow the above second - order interpretation literally , an alternative rule for inductive predicates could be : @xmath101 { { \\gamma\\longrightarrow p } } { { b\\,x^p { \\supset}x^p , \\gamma\\longrightarrow x^p } } \\ ] ] then there would be no need to add the @xmath102-rule since it would be derivable , using the clause @xmath103 in the left hand side of the sequent .",
    "( this , of course , is true only when such an @xmath102 instance appears above an @xmath104 instance for @xmath35 . )",
    "our presentation has the advantage that it simplifies the cut - elimination arguments in the subsequent sections .",
    "the left - introduction rule for co - inductively defined predicate can be explained dually .",
    "a similar encoding of ( co-)inductive definitions as second - order formulae is used in  @xcite , where cut - elimination is indirectly proved by appealing to a _ focused _ proof system for higher - order linear logic .",
    "a similar approach can be followed for @xmath1 , but we prefer to develop a direct cut - elimination proof , since such a proof can serve as the basis of cut - elimination for extensions of @xmath1 , for example , with the @xmath3-quantifier  @xcite .",
    "[ rem : unf ] a commonly used form of introduction rules for definitions , or fixed points , uses an unfolding of the definitions .",
    "this form of rules is followed in several related logics , e.g. , @xmath2",
    "@xcite , @xmath98  @xcite and @xmath76-mall  @xcite .",
    "the right - introduction rule for inductive definitions , for instance , takes the form : @xmath105 { { \\gamma\\longrightarrow p\\,\\vec      t } } { { \\gamma\\longrightarrow b\\,p\\,\\vec t } } \\ ] ] that is , in the premise , the predicate @xmath35 is replaced with the body of the definition .",
    "the logic @xmath98 , like @xmath2 , imposes a stratification on definitions , which amounts to a strict positivity condition : the head of a definition can only appear in a strictly positive position in the body , i.e. , it never appears to the left of an implication . let us call such a definition a _",
    "stratified definition_. for stratified definitions , the rule @xmath106 can be derived as follows : @xmath107 { { \\gamma\\longrightarrow p\\,\\vec t } } { { \\gamma\\longrightarrow b\\,p\\,\\vec t } &    \\infer[{{\\rm i}{\\cal r } } ] { { b\\,p\\,\\vec t\\longrightarrow p\\,\\vec t } } { \\infer [ ]      { { b\\,p\\,\\vec t\\longrightarrow b\\,x^p\\,\\vec t } } { \\deduce{\\vdots } {          \\infer[{{\\rm i}{\\cal l } } ] { { p\\,\\vec u\\longrightarrow x^p\\,\\vec u } } { \\infer[{{\\rm i}{\\cal r}_p } ]            { { b\\,x^p\\,\\vec x\\longrightarrow x^p\\,\\vec x } } { \\infer[init ]              { { b\\,x^p\\,\\vec x\\longrightarrow b\\,x^p\\,\\vec x } } { } } & \\infer[init ]            { { x^p\\,\\vec u\\longrightarrow x^p\\,\\vec u } } { } } } } } } \\ ] ] where the ` dots ' are a derivation composed using left and right introduction rules for logical connectives in @xmath54 .",
    "notice that all leaves of the form @xmath108 can be proved by using the @xmath89 rule , with @xmath37 as the inductive invariant .",
    "conversely , given a stratified definition , any proof in @xmath1 using that definition can be transformed into a proof of @xmath98 simply by replacing @xmath37 with @xmath35 .",
    "note that once @xmath106 is shown admissible , one can also prove admissibility of unfolding of inductive definitions on the left of a sequent ; see  @xcite for a proof .    since a defined atomic formula can be unfolded via its introduction rules , the notion of size of a formula as simply the number of connectives in it would not take into account this possible unfolding .",
    "we shall define a more general notion assigning a positive integer to each predicate symbol , which we refer to as its _ level_. a similar notion of level of a predicate was introduced for @xmath2  @xcite .",
    "however , in @xmath2 , the level of a predicate is only used to guarantee monotonicity of definitions .",
    "[ def : level ] to each predicate @xmath35 we associate a natural number @xmath109 , the _ level _ of @xmath35 . given a formula @xmath54 , its _ size _",
    "@xmath110 is defined as follows :",
    "1 .   @xmath111 , for any @xmath37 and any @xmath112 .",
    "2 .   @xmath113 .",
    "3 .   @xmath114 .",
    "4 .   @xmath115 .",
    "5 .   @xmath116 .    note that in this definition , we do not specify precisely any particular level assignment to predicates .",
    "we show next that there is a level assignment that has a property that will be useful later in proving cut elimination .",
    "[ lm : level ] given any definition @xmath117 , there is a level assignment to every predicate @xmath35 occuring in @xmath117 such that if @xmath118 is in @xmath117 , then @xmath119 for every parameter @xmath120 .",
    "let @xmath121 be a binary relation on predicate symbols defined as follows : @xmath122 iff @xmath88 occurs in the body of the definition clause for @xmath35 .",
    "let @xmath123 be the reflexive - transitive closure of @xmath121 .",
    "since we restrict to non - mutually recursive definitions and there are only finitely many definition clauses ( definition  [ def : def - clause ] ) , it follows that @xmath123 is a well - founded partial order .",
    "we now compute a level assignment to predicate symbols by induction on @xmath123 .",
    "this is simply done by letting @xmath124 , if @xmath35 is undefined , and @xmath125 , for some parameter @xmath37 , if @xmath126 note that in the latter case , by induction hypothesis , every predicate symbol @xmath88 , other than @xmath35 , in @xmath54 has already been assigned a level , so @xmath127 is already defined at this stage .",
    "note also that it does not matter which @xmath37 we choose since all parameters have the same size .",
    "we shall assume from now on that predicates are assigned levels satisfying the condition of lemma  [ lm : level ] , so whenever we have a definition clause of the form @xmath128 , we shall implicitly assume that @xmath129 in @xmath2 , a notion of stratification is used to rule out non - monotone ( or in halns terminology _ partial _",
    "@xcite ) definitions , such as , @xmath130 , for which cut - elimination is problematic .",
    "in fact , from the above definition both @xmath35 and @xmath131 are provable , but there is no direct proof of @xmath132 .",
    "this can be traced back to the fact that unfolding of definitions in @xmath98 and @xmath2 is allowed on both the left and the right hand side of sequent . in @xmath1 ,",
    "inconsistency does not arise even allowing a non - monotone definition as above , due to the fact that arbitrary unfolding of fixed points is not permitted . instead",
    ", only a limited form of unfolding is allowed , i.e. , in the form of unfolding of inductive parameters on the right , and co - inductive parameters on the left . as a consequence of this restrictive unfolding , in @xmath1",
    "one can not reason about some well - founded inductive definitions which are not stratified .",
    "for example , consider the non - stratified definition : @xmath133 if this definition were to be interpreted as a logic program ( with negation - as - failure ) , for example , then its least fixed point is exactly the set of even natural numbers .",
    "however , the above encoding in @xmath1 is incomplete with respect to this interpretation , since not all even natural numbers can be derived using the above definition .",
    "for example , it is easy to see that @xmath134 is not derivable , since this would require a derivation of @xmath135 , for some inductive parameter @xmath136 , which is impossible because no unfolding of inductive parameter is allowed on the left of a sequent .",
    "the same idea prevents the derivability of @xmath137 given the definition @xmath130 .",
    "so while inconsistency in the presence of non - monotone definitions is avoided in @xmath1 , its reasoning power does not extend that of @xmath98 significantly .",
    "we now discuss some properties of derivations in @xmath1 which involve instantiations of eigenvariables and parameters .",
    "these properties will be used in the cut - elimination proof in subsequent sections .    before we proceed",
    ", it will be useful to introduce the following derived rule in @xmath1 : @xmath138 { { \\gamma\\longrightarrow c } } { \\ { { \\gamma\\theta\\longrightarrow c\\theta}\\}_\\theta } \\ ] ] this rule is just a ` macro ' for the following derivation : @xmath107 { { \\gamma\\longrightarrow c } } { \\infer[{{\\rm eq}{\\cal r } } ] { { \\longrightarrow t = t } } { } & \\infer[{{\\rm eq}{\\cal l } } ]   { { t = t,\\gamma\\longrightarrow c } }   {    \\{{\\gamma\\theta\\longrightarrow c\\theta}\\}_\\theta   } } \\ ] ] where @xmath47 is some arbitrary term .",
    "the motivation behind the rule @xmath139 is purely technical ; it allows us to prove that a derivation transformation ( i.e. , substitutions of eigenvariables in derivations in section  [ sec : subst ] ) commutes with cut reduction ( see lemma  [ lm : reduct_subst ] ) .",
    "since the rule @xmath139 hides a simple form of cut , to prove cut - elimination of @xmath1 , we have to show that @xmath139 , in addition to @xmath62 , is admissible . in the following",
    ", @xmath140 denotes the identity substitution , i.e. , @xmath141 for every variable @xmath55 .",
    "[ lm : subst - elimination ] for every @xmath52 and @xmath51 , if the sequent @xmath50 is ( cut - free ) derivable in @xmath1 with @xmath139 then it is ( cut - free ) derivable in @xmath1 without @xmath139 .    given a derivation @xmath142 of @xmath50 with occurrences of @xmath139 ,",
    "obtain a @xmath139-free derivation by simply replacing any subderivation in @xmath142 of the form : @xmath143 { { \\delta\\longrightarrow b } } { \\left\\ { \\raisebox{-1.3ex } { \\deduce{{\\delta\\theta\\longrightarrow b\\theta}}{\\pi^\\theta } } \\right\\}_\\theta } \\ ] ] with its premise @xmath144 .",
    "following  @xcite , we define a _ measure _ which corresponds to the height of a derivation :    [ def : mu ] given a derivation @xmath142 with premise derivations @xmath145 , for some index set @xmath146 , the measure @xmath147 is the least upper bound @xmath148 .",
    "note that given the possible infinite branching of @xmath64 rule , these measures can in general be ( countable ) ordinals .",
    "therefore proofs and definitions on those measures require transfinite induction and recursion . however , in most of the proofs to follow , we do case analysis on the last rule of a derivation . in such a situation",
    ", the inductive cases for both successor and limit ordinals are basically covered by the case analysis on the inference figures involved , and we shall not make explicit use of transfinite principles .    with respect to the use of eigenvariables and parameters in a derivation , there may be occurrences of the formers that are not free in the end sequent .",
    "we refer to these variables and parameters as the _ internal variables and parameters _ , respectively .",
    "we view the choices of those variables and parameters as arbitrary and therefore identify derivations which differ on the choice of internal variables and parameters . in other terms , we quotient derivations modulo injective renaming of internal eigenvariables and parameters .",
    "the following definition extends eigenvariable substitutions to apply to derivations .",
    "since we identify derivations that differ only in the choice of internal eigenvariables , we will assume that such variables are chosen to be distinct from the variables in the domain of the substitution and from the free variables of the range of the substitution .",
    "thus applying a substitution to a derivation will only affect the variables free in the end - sequent .",
    "[ def : subst ] if @xmath142 is a derivation of @xmath50 and @xmath43 is a substitution , then we define the derivation @xmath149 of @xmath150 as follows :    1 .",
    "suppose @xmath142 ends with the @xmath64 rule @xmath5{{s = t,\\gamma'\\longrightarrow c } }        { \\left\\{\\raisebox{-1.5ex }            { \\deduce{{\\gamma'\\rho\\longrightarrow c\\rho } }              { \\pi^{\\rho } } }          \\right\\}_{\\rho } }        \\enspace\\ ] ] where each @xmath44 satisfies @xmath151 .",
    "observe that any unifier for the pair @xmath152 can be transformed to another unifier for @xmath153 , by composing the unifier with @xmath43 .",
    "thus @xmath149 is @xmath5{{s\\theta = t\\theta,\\gamma'\\theta\\longrightarrow c\\theta } }        { \\left\\{\\raisebox{-1.5ex }            { \\deduce{{\\gamma'\\theta\\rho'\\longrightarrow c\\theta\\rho ' } }              { \\pi^{\\theta\\circ\\rho ' } } }      \\right\\}_{\\rho ' } }        \\enspace , \\ ] ] where @xmath154 .",
    "if @xmath142 ends with @xmath139 with premise derivations @xmath155 then @xmath149 also ends with the same rule and has premise derivations @xmath156 .",
    "if @xmath142 ends with any other rule and has premise derivations @xmath157 , then @xmath149 also ends with the same rule and has premise derivations @xmath158 .    among the premises of the inference rules of @xmath1 ( with the exception of @xmath90 ) , certain premises share the same right - hand side formula with the sequent in the conclusion .",
    "we refer to such premises as major premises .",
    "this notion of major premise will be useful in proving cut - elimination , as certain proof transformations involve only major premises .",
    "[ def : major - premise ] given an inference rule @xmath159 with one or more premise sequents , we define its major premise sequents as follows .    1 .",
    "if @xmath159 is either @xmath160 or @xmath89 , then its rightmost premise is the major premise 2 .",
    "if @xmath159 is @xmath90 then its left premise is the major premise .",
    "3 .   otherwise , all the premises of @xmath159 are major premises .",
    "a _ minor premise _ of a rule @xmath159 is a premise of @xmath159 which is not a major premise .",
    "the definition extends to derivations by replacing premise sequents with premise derivations .",
    "the proofs of the following two lemma are straightforward from definition  [ def : subst ] and induction on the height of derivations .",
    "[ lm : subst ] for any substitution @xmath43 and derivation @xmath142 of @xmath50 , @xmath149 is a derivation of @xmath150 .",
    "[ lm : subst - height ] for any derivation @xmath142 and substitution @xmath43 , @xmath161 .",
    "[ lm : subst - drv - comp ] for any derivation @xmath142 and substitutions @xmath43 and @xmath44 , the derivations @xmath162 and @xmath163 are the same derivation .",
    "[ def : param subst ] a _ parameter substitution _",
    "@xmath164 is a partial map from parameters to pairs of proofs and _ closed _ terms such that whenever @xmath165 then @xmath93 has the same type as @xmath35 and either one of the following holds :    * @xmath166 , for some @xmath54 and @xmath92 , and @xmath167 is a derivation of @xmath168 , or *",
    "@xmath169 , for some @xmath54 and @xmath92 , and @xmath167 is a derivation of @xmath170 .",
    "the _ support _ of @xmath164 is the set @xmath171 we consider only parameter substitutions with finite support .",
    "we say that @xmath37 is _ fresh for @xmath164 _ , written @xmath172 , if for each @xmath173 , @xmath174 and @xmath37 does not occur in @xmath93 whenever @xmath175 .",
    "we shall often enumerate a parameter substitution using a similar notation to ( eigenvariables ) substitution , e.g. , @xmath176\\ ] ] denotes a parameter substitution @xmath164 with support @xmath177 and @xmath178 .",
    "given a formula @xmath51 and a parameter substitution @xmath164 as above , we write @xmath179 to denote the formula @xmath180.\\ ] ]    let @xmath142 be a derivation of @xmath50 and let @xmath164 be a parameter substitution . define the derivation @xmath181 of @xmath182 by induction on the height of @xmath142 as follows :    * suppose @xmath183 for some @xmath37 such that @xmath184 and @xmath142 ends with @xmath102 , as shown below left .",
    "then @xmath181 is as shown below right .",
    "{ { \\gamma\\longrightarrow x^p \\vec t } }   { \\deduce{{\\gamma\\longrightarrow b\\,x^p \\vec t}}{\\pi ' } } \\qquad \\infer[mc ] { { \\gamma\\theta\\longrightarrow s\\,\\vec t } } { \\deduce{{\\gamma\\theta\\longrightarrow b\\,s\\,\\vec t}}{\\pi'\\theta } & \\deduce{{b\\,s\\,\\vec t\\longrightarrow s\\,\\vec t}}{\\pi_s[\\vec t/\\vec x ] } } \\ ] ] * similarly , suppose @xmath142 ends with @xmath186 on @xmath187 and @xmath188 : @xmath189 { { x^p \\vec t , \\gamma'\\longrightarrow c } } {    \\deduce{{b\\,x^p\\vec t , \\gamma'\\longrightarrow c}}{\\pi ' } } \\ ] ] where @xmath169 and @xmath190 .",
    "then @xmath181 is @xmath107 { { s\\,\\vec t , \\gamma'\\theta\\longrightarrow c\\theta } } { \\infer[mc ]    { { s\\,\\vec t\\longrightarrow b\\,s\\,\\vec t } } { \\infer[init ] { { s\\,\\vec          t\\longrightarrow s\\,\\vec t } } { } & \\deduce{{s\\,\\vec t\\longrightarrow b\\,s\\,\\vec          t}}{\\pi_s[\\vec t/\\vec x ] } } & \\deduce{{b\\,s\\,\\vec t ,        \\gamma'\\theta\\longrightarrow c\\theta}}{\\pi'\\theta } } \\ ] ] * in all other cases , suppose @xmath142 ends with a rule @xmath159 with premise derivations @xmath191 for some index set @xmath146 . since we identify derivations up to renaming of internal parameters , we assume without loss of generality that the internal eigenvariables in the premises of @xmath159 ( if any ) do not appear in @xmath164 .",
    "then @xmath181 ends with the same rule , with premise derivations @xmath192 .    notice that the definition of application of parameter substitution in derivations in definition  [ def : param subst ] is asymmetric in the treatment of inductive and co - inductive parameters , i.e. , in the cases where @xmath142 ends with @xmath102 and @xmath186 . in the latter case , the substituted derivation uses a seemingly unnecessary cut @xmath193   { { s\\,\\vec t\\longrightarrow b\\,s\\,\\vec t } } { \\infer[init ] { { s\\,\\vec t\\longrightarrow s\\,\\vec t } } { } & \\deduce{{s\\,\\vec t\\longrightarrow b\\,s\\,\\vec        t}}{\\pi_s[\\vec t/\\vec x ] } } \\ ] ] the reason behind this is rather technical ; in our main cut elimination proof , we need to establish that @xmath194 $ ] is `` reducible '' ( i.e. , all the cuts in it can be eventually eliminated ) , given that the above cut is reducible . in a typical cut elimination procedure ,",
    "say gentzen s proof for lk , one would have expected that the above cut reduces to @xmath194 $ ] , hence reducibility of @xmath167 would follow from reducibility of the above cut .",
    "however , according to our cut reduction rules ( see section  [ sec : reduc ] ) , the above cut does not necessarily reduce to @xmath194 $ ] .",
    "however , if the instance of @xmath195 appears instead on the right premise of the cut , e.g. , as in @xmath107 { { b\\,s\\,\\vec t\\longrightarrow s\\,\\vec t } } { \\deduce{{b\\,s\\,\\vec        t\\longrightarrow s\\,\\vec t}}{\\pi_s[\\vec t/\\vec x ] } & \\infer[init ] { { s\\,\\vec t\\longrightarrow s\\,\\vec t } } { } } \\ ] ] the cut elimination procedure does reduce this to @xmath196 $ ] , so it is not necessary to introduce explicitly this cut instance in the case involving inductive parameters .",
    "it is possible to define a symmetric notion of parameter substitution , but that would require different cut reduction rules than the ones we proposed in this paper . another possibility would be to push the asymmetry to the definition of _ reducibility _ ( see section  [ sec : cut - elim ] ) .",
    "we have explored these alternative options , but for the purpose of proving cut elimination , we found that the current definition yields a simpler proof .    the following lemma states that the derivation @xmath181 is well - formed .",
    "[ lm : param subst ] let @xmath164 be a parameter substitution and @xmath142 a derivation of @xmath50 . then @xmath181 is a derivation of @xmath197 .    note that since parameter substitutions replace parameters with closed terms , they commute with ( eigenvariable ) substitutions .",
    "[ lm : param subst commutes ] for every derivation @xmath142 , substitution @xmath198 , parameter substitution @xmath164 , the derivation @xmath199 is the same as the derivation @xmath200 .    in the following ,",
    "we denote with @xmath201 $ ] , where @xmath202 , a parameter substitution obtained by extending @xmath164 with the map @xmath203 .",
    "[ lm : param subst vacuous ] let @xmath142 be a derivation of @xmath50 , @xmath164 a parameter substitution and @xmath37 a parameter such that @xmath204 and @xmath37 does not occur in @xmath50",
    ". then @xmath205 = \\pi\\theta$ ] for every @xmath167 and @xmath93 .",
    "the central result of our work is cut - elimination , from which consistency of the logic follows .",
    "gentzen s classic proof of cut - elimination for first - order logic uses an induction on the size of the cut formula .",
    "the cut - elimination procedure consists of a set of reduction rules that reduces a cut of a compound formula to cuts on its sub - formulae of smaller size . in the case of @xmath1 ,",
    "the use of induction / co - induction complicates the reduction of cuts .",
    "consider for example a cut involving the induction rules : @xmath206 { { \\delta , \\gamma\\longrightarrow c } } { \\infer[{{\\rm i}{\\cal r } } ]    { { \\delta\\longrightarrow p\\,\\vec t } } { \\deduce{{\\delta\\longrightarrow b\\,x^p\\,\\vec t}}{\\pi_1 } } &    \\infer[{{\\rm i}{\\cal l } } ] { { p\\,\\vec t , \\gamma\\longrightarrow c } } {      \\deduce{{b\\,s\\,\\vec y\\longrightarrow s\\,\\vec y}}{\\pi_b } & \\deduce{{s\\,\\vec t ,          \\gamma\\longrightarrow c}}{\\pi } } } \\ ] ] there are at least two problems in reducing this cut .",
    "first , any permutation upwards of the cut will necessarily involve a cut with @xmath93 that can be of larger size than @xmath35 , and hence a simple induction on the size of the cut formula will not work .",
    "second , the invariant @xmath93 does not appear in the conclusion of the left premise of the cut .",
    "the latter means that we need to transform the left premise so that its end sequent will agree with the right premise .",
    "any such transformation will most likely be _ global _ , and hence simple induction on the height of derivations will not work either .",
    "we shall use the _ reducibility _ technique to prove cut elimination . more specifically",
    ", we shall build on the notion of reducibility introduced by martin - lf to prove normalization of an intuitionistic logic with iterative inductive definition @xcite .",
    "martin - lf s proof has been adapted to sequent calculus by mcdowell and miller  @xcite , but in a restricted setting where only natural number induction is allowed .",
    "since our logic involves arbitrary stratified inductive definitions , which also includes iterative inductive definitions , we shall need different , and more general , cut reductions .",
    "but the real difficulty in our case is in establishing cut elimination in the presence of co - inductive definitions , for which there is no known direct cut elimination proof ( prior to our work  @xcite on which this article is based on ) , at the best of our knowledge , as far as the sequent calculus is concerned .",
    "the main part of the reducibility technique is a definition of the family of reducible sets of derivations . in martin - lf s theory of iterative inductive definition",
    ", this family of sets is defined inductively by the `` type '' of the derivations they contain , i.e. , the formula in the right - hand side of the end sequent in a derivation .",
    "extending this definition of reducibility to @xmath1 is not obvious . in particular , in establishing the reducibility of a derivation of type @xmath207 ending with a @xmath90 rule",
    "one must first establish the reducibility of its premise derivations , which may have larger types , since @xmath208 could be any formula",
    ". therefore a simple inductive definition based on types of derivations would not be well - founded .",
    "the key to properly `` stratify '' the definition of reducibility is to consider reducibility under parameter substitutions .",
    "this notion of reducibility , called _ parametric reducibility _ , was originally developed by girard to prove strong normalisation of system  f , i.e. , in the interpretation of universal types . as with strong normalisation of system",
    "f , ( co-)inductive parameters are substituted with some `` reducibility candidates '' , which in our case are certain sets of derivations satisfying closure conditions similar to those for system f , but which additionally satisfy certain closure conditions related to ( co-)inductive definitions .",
    "the remainder of this section is structured as follows . in section  [ sec : reduc ] we define a set of cut reduction rules that are used to elimination the applications of the cut rule . for the cases involving logical operators , the cut - reduction rules used to prove the cut - elimination for @xmath1 are the same as those of @xmath2  @xcite .",
    "the crucial differences are , of course , in the reduction rules involving induction and co - induction rules , where we use the transformation described in definition  [ def : param subst ] .",
    "we then proceed to define two notions essential to our cut elimination proof : _ normalizability _ ( section  [ sec : norm ] ) and _ parametric reducibility _",
    "( section  [ sec : red ] ) .",
    "these can be seen as counterparts for martin - lf s notions of normalizability and _ computability _",
    "@xcite , respectively .",
    "normalizability of a derivation implies that all the cuts in it can be eventually eliminated ( via the cut reduction rules defined earlier ) .",
    "reducibility is a stronger notion , in that it implies normalizability .",
    "the main part of the cut elimination proof is presented in section  [ sec : ceproof ] , where we show that every derivation is reducible , hence it can be turned into a cut - free derivation .",
    "we now define a reduction relation on derivations ending with @xmath62 .",
    "this reduction relation is an extension of the similar cut reduction relation used in mcdowell and miller s cut elimination proof  @xcite . in particular , the reduction rules involving introduction rules for logical connectives are the same .",
    "the main differences are , of course , in the reduction rules involving induction and co - induction rules .",
    "there is also slight difference in one reduction rule involving equality , which in our case utilises the derived rule @xmath139 .",
    "therefore in the following definition , we shall highlight only those reductions that involve ( co-)induction and equality rules .",
    "the complete list of reduction rules can be found in appendix  [ app : reduc ] .    to ease presentation",
    ", we shall use the following notations to denote certain forms of derivations .",
    "the derivation @xmath107 { { \\delta_1 , \\ldots , \\delta_n , \\gamma \\longrightarrow c } } {    \\deduce{{\\delta_1\\longrightarrow b_1}}{\\pi_1 } & \\cdots & \\deduce{{\\delta_n\\longrightarrow b_n}}{\\pi_n } & \\deduce{{\\gamma\\longrightarrow c}}{\\pi } } \\enspace\\ ] ] is abbreviated as @xmath209 .",
    "whenever we write @xmath210 we assume implicitly that the derivation is well - formed , i.e. , @xmath142 is a derivation ending with some sequent @xmath50 and the right - hand side of the end sequent of each @xmath211 is a formula @xmath212 .",
    "similarly , we abbreviated as @xmath213 the derivation @xmath214 { { b\\longrightarrow b}}{}\\ ] ] and @xmath215 denotes a derivation ending with the rule @xmath139 with premise derivations @xmath216 .",
    "[ def : reduct ] we define a _ reduction _ relation between derivations .",
    "the redex is always a derivation @xmath217 ending with the multicut rule @xmath206{{\\delta_1,\\ldots,\\delta_n,\\gamma\\longrightarrow c } }      { \\deduce{{\\delta_1\\longrightarrow b_1 } }        { \\pi_1 }        & \\cdots        & \\deduce{{\\delta_n\\longrightarrow b_n } }        { \\pi_n }        & \\deduce{{b_1,\\ldots , b_n,\\gamma\\longrightarrow c } }        { \\pi } }      \\enspace\\ ] ] we refer to the formulas @xmath218 produced by the @xmath59 as _ cut formulas_.    if @xmath219 , @xmath217 reduces to the premise derivation @xmath142 .",
    "for @xmath220 we specify the reduction relation based on the last rule of the premise derivations .",
    "if the rightmost premise derivation @xmath142 ends with a left rule acting on a cut formula @xmath221 , then the last rule of @xmath211 and the last rule of @xmath142 together determine the reduction rules that apply . following mcdowell and miller  @xcite",
    ", we classify these rules according to the following criteria : we call the rule an _ essential _ case when @xmath211 ends with a right rule ; if it ends with a left rule or @xmath139 , it is a _ left - commutative _ case ; if @xmath211 ends with the @xmath222 rule , then we have an _ axiom _ case ; a _ multicut _ case arises when it ends with the @xmath59 rule . when @xmath142 does not end with a left rule acting on a cut formula , then its last rule is alone sufficient to determine the reduction rules that apply .",
    "if @xmath142 ends with @xmath139 or a rule acting on a formula other than a cut formula , then we call this a _ right - commutative _ case .",
    "structural _ case results when @xmath142 ends with a contraction or weakening on a cut formula .",
    "if @xmath142 ends with the @xmath222 rule , this is also an axiom case ; similarly a multicut case arises if @xmath142 ends in the @xmath59 rule .",
    "for simplicity of presentation , we always show @xmath223 .",
    "we show here the cases involving ( co-)induction rules .",
    "[ [ essential - cases ] ] essential cases : + + + + + + + + + + + + + + + +    suppose @xmath224 and @xmath142 are @xmath225{{\\delta_1\\longrightarrow s = t } }      { }      \\qquad\\qquad\\qquad      \\infer[{{\\rm eq}{\\cal l}}]{{s = t , b_2,\\ldots , b_n,\\gamma\\longrightarrow c } }      { \\left\\{\\raisebox{-1.5ex }          { \\deduce{{b_2\\rho,\\ldots , b_n\\rho,\\gamma\\rho\\longrightarrow c\\rho } }            { \\pi^\\rho } }        \\right\\}_\\rho }      \\enspace\\ ] ] note that in this case , @xmath44 in @xmath142 ranges over all substitution , as any substitution is a unifier of @xmath65 and @xmath47 .",
    "let @xmath226 be the derivation @xmath227 . in this case",
    ", @xmath217 reduces to @xmath228    { { \\delta_1,\\delta_2,\\ldots,\\delta_n,\\gamma\\longrightarrow c } }    { \\deduce{{\\delta_2,\\ldots,\\delta_n,\\gamma\\longrightarrow c}}{\\xi_1}}\\ ] ] we use the double horizontal lines to indicate that the relevant inference rule ( in this case , @xmath229 ) may need to be applied zero or more times .",
    "suppose @xmath224 and @xmath142 are , respectively , @xmath230 { { \\delta_1\\longrightarrow p\\,\\vec t } } {   \\deduce{{\\delta_1\\longrightarrow d\\,x^p\\,\\vec t}}{\\pi_1 ' } } \\qquad \\infer[{{\\rm i}{\\cal l } } ] { { p\\,\\vec{t } , b_2,\\dots , b_n,\\gamma\\longrightarrow c } } {    \\deduce{{d\\,s\\,\\vec{y}\\longrightarrow s\\,\\vec{y}}}{\\pi_s } &    \\deduce{{s\\,\\vec{t } , b_2,\\dots , b_n , \\gamma\\longrightarrow c}}{\\pi ' } } \\ ] ] where @xmath231 and @xmath37 is a new parameter .",
    "then @xmath217 reduces to @xmath232 , \\pi_s[\\vec t/\\vec y ] ) , \\pi_2,\\ldots,\\pi_n,\\pi').\\ ] ]    suppose @xmath224 and @xmath142 are @xmath233   { { \\delta_1\\longrightarrow p\\,\\vec{t } } }   {    \\deduce{{\\delta_1\\longrightarrow s\\,\\vec{t}}}{\\pi_1 ' } &    \\deduce{{s\\,\\vec{y}\\longrightarrow d\\,s\\,\\vec{y}}}{\\pi_s }   }   \\qquad \\qquad \\infer[{{\\rm",
    "ci}{\\cal l } } ]   { { p\\,\\vec{t } , \\dots , \\gamma\\longrightarrow c } } {    \\deduce{{d\\,x^p\\,\\vec{t},\\dots , \\gamma\\longrightarrow c}}{\\pi ' } } \\ ] ] where @xmath234 and @xmath37 is a new parameter .",
    "then @xmath217 reduces to @xmath235 ) , \\pi_2,\\ldots,\\pi_n,\\pi'[(\\pi_s , s)/x^p]).\\ ] ]    [ [ left - commutative - cases ] ] left - commutative cases : + + + + + + + + + + + + + + + + + + + + + + +    in the following , we suppose that @xmath142 ends with a left rule , other than @xmath236 , acting on @xmath237 .    : :    suppose @xmath224 is    @xmath238 { { p\\,\\vec{t } , \\delta_1'\\longrightarrow b_1 } } {      \\deduce{{d\\,s\\,\\vec{y}\\longrightarrow s\\,\\vec{y}}}{\\pi_s } &      \\deduce{{s\\,\\vec{t } , \\delta_1'\\longrightarrow b_1}}{\\pi_1 ' } } \\ ] ]    where @xmath231 . let    @xmath239",
    ". then    @xmath217 reduces to    @xmath238 { { p\\,\\vec{t } , \\delta_1',\\dots,\\delta_n\\longrightarrow c } } {      \\deduce{{d\\,s\\,\\vec{y}\\longrightarrow s\\,\\vec{y}}}{\\pi_s } &      \\deduce{{s\\,\\vec{t } , \\delta_1',\\dots,\\delta_n,\\gamma\\longrightarrow c}}{\\xi_1 }    } \\ ] ]    [ [ right - commutative - cases ] ] right - commutative cases : + + + + + + + + + + + + + + + + + + + + + + + +    : :    suppose @xmath142 is    @xmath238 { { b_1,\\dots , b_n , p\\,\\vec{t},\\gamma'\\longrightarrow c } } {      \\deduce{{d\\,s\\,\\vec{y}\\longrightarrow s\\,\\vec{y}}}{\\pi_s } &      \\deduce{{b_1,\\dots , b_n , s\\,\\vec{t } , \\gamma'\\longrightarrow c}}{\\pi ' } }    \\enspace , \\ ] ] where    @xmath231 .",
    "let    @xmath240",
    ". then    @xmath217 reduces to    @xmath238 { { \\delta_1,\\dots,\\delta_n , p\\,\\vec{t},\\gamma'\\longrightarrow c } } {      \\deduce{{d\\,s\\,\\vec{y}\\longrightarrow s\\,\\vec{y}}}{\\pi_s } &      \\deduce{{\\delta_1,\\dots,\\delta_n , s\\,\\vec{t } , \\gamma'\\longrightarrow c}}{\\xi_1 }    } \\enspace\\ ] ] : :    suppose @xmath142 is    @xmath233 { { b_1,\\dots , b_n,\\gamma\\longrightarrow p\\,\\vec{t } } } {      \\deduce{{b_1,\\dots , b_n,\\gamma\\longrightarrow s\\,\\vec{t}}}{\\pi ' } &      \\deduce{{s\\,\\vec{y}\\longrightarrow d\\,s\\,\\vec{y}}}{\\pi_s } } \\enspace , \\ ] ]    where @xmath241 .",
    "let    @xmath242",
    ". then    @xmath217 reduces to    @xmath233 { { \\delta_1,\\dots,\\delta_n,\\gamma\\longrightarrow p\\,\\vec{t } } } {      \\deduce{{\\delta_1,\\dots,\\delta_n,\\gamma\\longrightarrow s\\,\\vec{t}}}{\\xi_1 } &      \\deduce{{s\\,\\vec{y}\\longrightarrow d\\,s\\,\\vec{y}}}{\\pi_s } } \\enspace\\ ] ]    it is clear from an inspection of the inference rules in figure  [ fig : linc ] and the definition of cut reduction ( see appendix  [ app : reduc ] ) that every derivation ending with a multicut has a reduct . note",
    "that since the left - hand side of a sequent is a multiset , the same formula may occur more than once in the multiset . in the cut reduction rules",
    ", we should view these occurrences as distinct so that no ambiguity arises as to which occurrence of a formula is subject to the @xmath62 rule .",
    "the following lemma shows that the reduction relation is preserved by eigenvariable substitution . the proof is given in appendix  [ app : red ] .",
    "[ lm : reduct_subst ] let @xmath142 be a derivation ending with a @xmath59 and let @xmath43 be a substitution . if @xmath149 reduces to @xmath217 then there exists a derivation @xmath243 such that @xmath244 and @xmath142 reduces to @xmath243 .",
    "[ def : norm ] we define the set of _ normalizable _ derivations to be the smallest set that satisfies the following conditions :    1 .",
    "if a derivation @xmath142 ends with a multicut , then it is normalizable if every reduct of @xmath142 is normalizable .",
    "if a derivation ends with any rule other than a multicut , then it is normalizable if the premise derivations are normalizable .",
    "the set of all normalizable derivations is denoted by @xmath245 .",
    "each clause in the definition of normalizability asserts that a derivation is normalizable if certain ( possibly infinitely many ) other derivations are normalizable .",
    "we call the latter the _ predecessors _ of the former",
    ". thus a derivation is normalizable if the tree of its successive predecessors is well - founded .",
    "we refer to this well - founded tree as its _",
    "normalization_. since a normalization is well - founded , it has an associated induction principle : for any property @xmath246 of derivations , if for every derivation @xmath142 in the normalization , @xmath246 holds for every predecessor of @xmath142 implies that @xmath246 holds for @xmath142 , then @xmath246 holds for every derivation in the normalization .",
    "we shall define explicitly a measure on a normalizable derivation based on its normalization tree .",
    "[ def : deg - norm ] let @xmath142 be a normalizable derivation .",
    "the _ normalization degree of @xmath142 _ , denoted by @xmath247 , is defined by induction on the normalization of @xmath142 as follows : @xmath248    the normalization degree of @xmath142 is basically the height of its normalization tree .",
    "note that @xmath247 can be an ordinal in general , due to the possibly infinite - branching rule @xmath64 .",
    "[ lm : norm - cut - free ] if there is a normalizable derivation of a sequent , then there is a cut - free derivation of the sequent .    similarly to  @xcite .    in the proof of the main lemma for cut elimination ( lemma  [ lm : comp ] ) we shall use induction on the normalization degree , instead of using directly the normalization ordering .",
    "the reason is that in some inductive cases in the proof , we need to compare a ( normalizable ) derivation with its instances , but the normalization ordering does not necessarily relate the two , e.g. , @xmath142 and @xmath149 may not be related by the normalization ordering , although their normalization degrees are ( see lemma  [ lm : norm - degree ] ) .",
    "later , we shall define a stronger ordering called _ reducibility _ , which implies normalizability . in the cut elimination proof for @xmath2  @xcite , in one of the inductive cases , an implicit reducibility ordering is assumed to hold between derivation @xmath142 and its instance @xmath149 .",
    "as the reducibility ordering in their setting is a subset of the normalizability ordering , this assumption may not hold in all cases , and as a consequence there is a gap in the proof in  @xcite .    the next lemma states that normalization is closed under substitutions .",
    "[ lm : subst - norm ] if @xmath142 is a normalizable derivation , then for any substitution @xmath43 , @xmath149 is normalizable .    by induction on @xmath247 .    1",
    "if @xmath142 ends with a multicut , then @xmath149 also ends with a multicut . by lemma  [ lm : reduct_subst ]",
    "every reduct of @xmath149 corresponds to a reduct of @xmath142 , therefore by induction hypothesis every reduct of @xmath149 is normalizable , and hence @xmath149 is normalizable .",
    "2 .   suppose @xmath142 ends with a rule other than multicut and has premise derivations @xmath249 . by definition  [ def : subst ]",
    "each premise derivation in @xmath149 is either @xmath211 or @xmath250 . since @xmath142 is normalizable",
    ", @xmath211 is normalizable , and so by the induction hypothesis @xmath250 is also normalizable .",
    "thus @xmath149 is normalizable .",
    "the normalization degree is non - increasing under eigenvariable substitution .",
    "[ lm : norm - degree ] let @xmath142 be a normalizable derivation .",
    "then @xmath251 for every substitution @xmath43 .",
    "by induction on @xmath247 using definition  [ def : subst ] and lemma  [ lm : reduct_subst ] . note that @xmath252 can be smaller than @xmath247 because substitution may reduces the number of premises in @xmath64 , , if @xmath142 ends with an @xmath64 acting on , say @xmath253 ( which are unifiable ) , and @xmath43 is a substitution that maps @xmath55 and @xmath58 to distinct constants then @xmath149 ends with @xmath64 with empty premise .      in the following",
    ", we shall use the term `` type '' in two different settings : in categorizing terms and in categorizing derivations . to avoid confusion",
    ", we shall refer to the types of terms as _ syntactic types _ , and the term `` type '' is reserved for types of derivations .",
    "our notion of a type of a set of derivations may abstract from particular first - order terms in a formula .",
    "this is because our definition of reducibility ( candidates ) will have to be closed under eigenvariable substitutions , which is in turn imposed by the fact that our proof rules allow instantiation of eigenvariables in the derivations ( i.e. , the @xmath64 and the @xmath139 rules ) .",
    "[ def : type - of - drv ] we say that _ a derivation @xmath142 has type @xmath51 _ if the end sequent of @xmath142 is of the form @xmath50 for some @xmath52 .",
    "let @xmath254 be a term with syntactic type @xmath255 , where each @xmath256 is a syntactic efo - type .",
    "are always efo - types . ]",
    "a set of derivations @xmath257 is said to be _ of type @xmath254 _ if every derivation in @xmath257 has type @xmath258 for some terms @xmath259 . given a list of terms @xmath260 and a set of derivations @xmath257 of type @xmath261 , we denote with @xmath262 the set @xmath263    [ def : candidates ] let @xmath254 be a _ closed term _ having the syntactic type @xmath264 .",
    "a set of derivations @xmath265 of type @xmath254 is said to be a _",
    "reducibility candidate of type @xmath254 _ if the following hold :    cr0 : :    if @xmath266 then @xmath267 ,    for every @xmath43 .",
    "cr1 : :    if @xmath266 then @xmath142 is normalizable .",
    "cr2 : :    if @xmath266 and @xmath142 reduces to    @xmath243 then @xmath268 .",
    "cr3 : :    if @xmath142 ends with @xmath62 and all its reducts    are in @xmath265 , then @xmath266 .",
    "cr4 : :    if @xmath142 ends with @xmath195 , then    @xmath266 .",
    "cr5 : :    if @xmath142 ends with a left - rule or @xmath139 ,    then all its minor premise derivations are normalizable , and all its    major premise derivations are in @xmath265 , then    @xmath266 .",
    "we shall write @xmath269 to denote a reducibility candidate @xmath265 of type @xmath254 .",
    "the conditions * cr1 * and * cr2 * are similar to the eponymous conditions in girard s definition of reducibility candidates in his strong normalisation proof for system f ( see  @xcite , chapter 14 ) .",
    "girard s * cr3 * is expanded in our definition to * cr3 , cr4 * and",
    "* cr5*. these conditions deal with what girard refers to as `` neutral '' proof term ( or , in our setting , derivations ) .",
    "neutrality corresponds to derivations ending in @xmath62 , @xmath195 , @xmath139 , or a left rule .",
    "the condition * cr0 * is needed because our cut reduction rules involve substitution of eigenvariables in some cases ( i.e. , those that involve permutation of @xmath64 and @xmath139 in the left / right commutative cases ) , and consequently , the notion of reducibility ( candidate ) needs to be preserved under eigenvariable substitution .",
    "let @xmath257 be a set of derivations of type @xmath54 and let @xmath270 be a set of derivations of type @xmath51 .",
    "then @xmath271 denotes the set of derivations such that @xmath272 if and only if @xmath142 ends with a sequent @xmath50 such that @xmath273 and for every @xmath274 , we have @xmath275 .",
    "let @xmath93 be a closed term .",
    "define @xmath276 to be the set @xmath277 it can be shown that @xmath276 is a reducibility candidate of type @xmath93 .",
    "[ lm : norm red ] let @xmath93 be a term of syntactic type @xmath278 . then the set @xmath276 is a reducibility candidate of type @xmath93 .    *",
    "cr0 * follows from lemma  [ lm : subst - norm ] , * cr1 * follows from the definition of @xmath276 , and the rest follow from definition  [ def : norm ] .",
    "[ def : candidate - subst ] a _ candidate substitution _",
    "@xmath279 is a partial map from parameters to triples of reducibility candidates , derivations and closed terms such that whenever @xmath280 , we have    * @xmath93 has the same syntactic type as @xmath35 , * @xmath265 is a reducibility candidate of type @xmath93 , and * either one of the following holds : * * @xmath166 and @xmath142 is a normalizable derivation of @xmath281 , or * * @xmath169 and @xmath142 is a normalizable derivation of @xmath282 .",
    "we denote with @xmath283 the _ support _ of @xmath279 , i.e. , the set of parameters on which @xmath279 is defined .",
    "each candidate substitution @xmath279 determines a unique parameter substitution @xmath164 , given by : @xmath284 we denote with @xmath285 the parameter substitution @xmath164 obtained this way .",
    "we say that a parameter @xmath37 is _",
    "fresh for @xmath279 _ , written @xmath286 if @xmath287 .",
    "[ [ notation ] ] notation + + + + + + + +    since every candidate substitution has a corresponding parameter substitution , we shall often treat a candidate substitution as a parameter substitution .",
    "in particular , we shall write @xmath288 to denote @xmath289 and @xmath290 to denote @xmath291 .",
    "we are now ready to define the notion of parametric reducibility .",
    "we follow a similar approach for @xmath2  @xcite , where families of reducibility sets are defined by the _ level _ of derivations , the size of the types of derivations . in defining a family ( or families ) of sets of derivations at level @xmath34",
    ", we assume that reducibility sets at level @xmath292 are already defined .",
    "the main difference with the notion of reducibility for @xmath2 , aside from the use of parameters in the clause for ( co)induction rules ( which do not exist in @xmath2 ) , is in the treatment of the induction rules .",
    "[ def : param red ] let @xmath293 be the set of all formula of size @xmath34 , @xmath294,$ ] where @xmath51 is a formula and @xmath279 is a candidate substitution , is defined by induction on the size of @xmath51 as follows . for each @xmath34 , the family of _ parametric reducibility sets of level @xmath34 _",
    "\\in \\fscr_k}\\ ] ] is the smallest family of sets satisfying , for each @xmath296 :    p1 : :    suppose @xmath297 for some @xmath298    and some parameter @xmath37 .",
    "if    @xmath299 then    @xmath300 = \\rscr~\\vec u,$ ] where    @xmath301",
    ". otherwise ,    @xmath300 = \\nm_{x^p}\\,\\vec u$ ] .",
    "otherwise , @xmath302 , for any @xmath298 and @xmath37 .",
    "then a derivation @xmath142 of type @xmath288 is in @xmath300 $ ] if it is normalizable and one of the following holds :    p2 : :    @xmath142 ends with @xmath62 , and all its reducts are    in @xmath300 $ ] .",
    "p3 : :    @xmath142 ends with @xmath303 , i.e. ,    @xmath304 and @xmath142 is of the form :    @xmath305               { { \\gamma\\longrightarrow b\\omega { \\supset}d\\omega } }               { \\deduce{{\\gamma , b\\omega\\longrightarrow d\\omega}}{\\pi ' } } \\ ] ]    and for every substitution @xmath44 ,    @xmath306 \\rightarrow \\red_{d\\rho}[\\omega])$ ] .",
    "p4 : :    @xmath142 ends with @xmath104 , i.e. ,    @xmath307        { { \\gamma\\longrightarrow p\\,\\vec t } }        { \\deduce{{\\gamma\\longrightarrow b\\,x^p\\,\\vec t}}{\\pi'}}\\ ] ] without    loss of generality , assume that @xmath308 : for every    reducibility candidate @xmath309 , where    @xmath146 is a closed term of the same syntactic type as    @xmath35 , for every normalizable derivation @xmath310    of @xmath311 , if for every    @xmath298 the following holds :    @xmath312 \\in ( \\red_{(b\\,x^p\\,\\vec u)}[\\omega , ( \\sscr ,        \\pi_i , i)/x^p ] \\rightarrow \\sscr~\\vec u)\\ ] ] then    @xmath313 , \\pi_i[\\vec t/\\vec y ] )   \\in \\sscr\\,\\vec t\\ ] ] p5 : :    @xmath142 ends with @xmath90 , i.e. ,    @xmath314      { { \\gamma\\longrightarrow p\\,\\vec t } }      {        \\deduce{{\\gamma\\longrightarrow i\\,\\vec t}}{\\pi ' }        &        \\deduce{{i\\,\\vec y\\longrightarrow b\\,i\\,\\vec y}}{\\pi_i }      } \\ ] ] and there exist a parameter @xmath37 such that    @xmath308 and a reducibility candidate    @xmath309 such that @xmath315 and    @xmath312 \\in ( \\sscr\\,\\vec u \\rightarrow      \\red_{b\\,x^p\\,\\vec u}[\\omega , ( \\sscr , \\pi_i , i)/x^p ] ) \\ \\hbox{for every        $ \\vec u$.   } \\ ] ] p6 : :    @xmath142 ends with any other rule and its major premise    derivations are in the parametric reducibility sets of the appropriate    types .",
    "we shall write @xmath316 , instead of @xmath300 $ ] , when the @xmath283 of a candidate substitution is the empty set .",
    "a derivation @xmath142 of type @xmath51 is _ reducible _ if @xmath317 .",
    "some comments and comparison with girard s definition of parametric reducibility for system f  @xcite are in order , although our technical setting is somewhat different from that of girard :    * condition * p3 * quantifies over @xmath44 .",
    "this is needed to show that reducibility is closed under substitution ( see lemma  [ lm : red - subst ] ) .",
    "a similar quantification is used in the definition of reducibility for @xmath2  @xcite for the same purpose . in the same clause",
    ", we also quantify over derivations in @xmath318 $ ] , but since @xmath319 has smaller size than @xmath320 , this quantification is legitimate and the definition is well - founded .",
    "note also the similar quantification in * p4 * and * p5 * , where the parametric reducibility set @xmath321 $ ] is defined in terms of @xmath322 $ ] . by lemma  [ lm",
    ": level ] , @xmath323 so in both cases the set @xmath322 $ ] is already defined by induction .",
    "it is clear by inspection of the clauses that the definition of parametric reducibility is well - founded .",
    "* clauses * p2 * and * p6 * are needed to show that the notion of parametric reducibility is closed under left - rules , @xmath324 and @xmath62 , i.e. , condition * cr3 *  * cr5*. this is also a point where our definition of parametric reducibility diverges from a typical definition of reducibility in natural deduction ( e.g. ,  @xcite ) , where closure under reduction for `` neutral '' terms is a derived property . * * p4 * ( and dually * p5 * ) can be intuitively explained in terms of the second - order encoding of inductive definitions . to simplify presentation",
    ", we restrict to the propositional case , so , * p4 * can be simplified as follows : + _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ suppose @xmath142 ends with @xmath104 , i.e. , @xmath325      { { \\gamma\\longrightarrow p } }      { \\deduce{{\\gamma\\longrightarrow b\\,x^p}}{\\pi'}}\\ ] ] without loss of generality , assume that @xmath308 : for every reducibility candidate @xmath309 , where @xmath146 is a closed term of the same syntactic type as @xmath35 , for every normalizable derivation @xmath310 of @xmath326 , if @xmath327 \\rightarrow \\sscr )       $ ] , then @xmath328 , \\pi_i )   \\in \\sscr$ ] . _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ + note that in the propositional @xmath1 , the set @xmath329 \\rightarrow \\sscr\\ ] ] is equivalent to @xmath330,$ ] i.e. , a set of reducible derivations of type @xmath331 .",
    "so , intuitively , @xmath243 can be seen as a higher - order function that takes any function of type @xmath331 ( i.e. , the derivation @xmath310 ) , and turns it into a derivation of type @xmath146 ( i.e. , the derivation @xmath328 , \\pi_i)$ ] ) , for all candidate @xmath309 .",
    "this intuitive reading matches the second - order interpretation of @xmath35 , i.e. , @xmath332 , where the universal quantification is interpreted as the universal type constructor and @xmath23 is interpreted as the function type constructor in system f.    we shall now establish a list of properties of the parametric reducibility sets that will be used in the main cut elimination proof .",
    "the main property that we are after is one which shows that a certain set of derivations formed using a family of parametric reducibility sets actually forms a reducibility candidate .",
    "this will be important later in constructing a reducibility candidate which acts as a co - inductive `` witness '' in the main cut elimination proof .",
    "the proofs of the following lemmas are mostly routine and rather tedious ; so we omit them here , but they can be found in appendix  [ app : red ] .",
    "[ lm : red - norm ] if @xmath333 $ ] then @xmath142 is normalizable .",
    "since every @xmath333 $ ] is normalizable , @xmath247 is defined .",
    "this fact will be used implicitly in subsequent proofs , i.e. , we shall do induction on @xmath247 to prove properties of @xmath300 $ ] .",
    "[ lm : red - subst ] if @xmath333 $ ] then for every substitution @xmath44 , @xmath334 $ ] .",
    "[ lm : red vacuous ] let @xmath335 $ ] .",
    "let @xmath51 be a formula such that @xmath336 .",
    "then for every @xmath142 , @xmath333 $ ] if and only if @xmath337 $ ] .",
    "[ lm : red candidate ] let @xmath279 be a candidate substitution and @xmath254 be a closed term of syntactic type @xmath338 . then the set @xmath339 \\ \\hbox{for some $ \\vec u$ } \\}\\ ] ] is a reducibility candidate of type @xmath340 .",
    "[ lm : red param subst ] let @xmath279 be a candidate substitution and let @xmath37 be a parameter such that @xmath308 .",
    "let @xmath93 be a closed term of the same type as @xmath35 and let @xmath341 \\ \\hbox{for some $ \\vec u$ } \\}.\\ ] ] suppose @xmath342 $ ] is a candidate substitution , for some @xmath343 .",
    "then @xmath344}[\\omega ] = \\red_c[\\omega , ( \\rscr , \\psi , s\\omega)/x^p].\\ ] ]      we shall now show that every derivation is reducible , hence every derivation can be normalized to a cut - free derivation .",
    "but in order to prove this , we need a slightly more general lemma , which states that every derivation is in @xmath300 $ ] for a certain kind of candidate substitution @xmath279 .",
    "the precise definition is given below .    a candidate substitution @xmath279 is _ definitionally closed _ if for every @xmath299 , if @xmath345 then either one of the following holds :    * @xmath166 , for some @xmath54 and for every @xmath298 of the appropriate syntactic types : @xmath346 \\in",
    "\\red_{b\\,x^p\\,\\vec u}\\ , [ \\omega ] \\rightarrow \\rscr\\,\\vec u.\\ ] ] * @xmath169 , for some @xmath54 and for every @xmath298 of the appropriate syntactic types : @xmath346 \\in \\rscr\\,\\vec u \\rightarrow \\red_{b\\,x^p\\,\\vec    u}\\ , [ \\omega].\\ ] ]    the next two lemmas show that definitionally closed substitutions can be extended in a way that preserves definitional closure .    [ lm : clo - ext - ind ] let @xmath347 $ ] be a candidate substitution such that @xmath166 , @xmath348 is definitionally closed , and for every @xmath298 of the same types as @xmath92 , @xmath346 \\in \\red_{b\\,x^p\\,\\vec u}\\ , [ \\omega ] \\rightarrow \\rscr\\,\\vec u\\ ] ] then @xmath279 is definitionally closed .",
    "let @xmath349 .",
    "suppose @xmath350 .",
    "we need to show that @xmath351 \\in \\red_{b\\,y^q\\,\\vec t}\\ , [ \\omega ] \\rightarrow \\sscr\\,\\vec t\\ ] ] for every @xmath112 of the same types as @xmath92 . if @xmath352 then this follows from the assumption of the lemma .",
    "otherwise , @xmath353 , and by the definitional closure assumption on @xmath348 , we have @xmath351 \\in \\red_{b\\,y^q\\,\\vec t}\\ , [ \\omega ' ] \\rightarrow \\sscr\\,\\vec t\\ ] ] for every @xmath112 . since @xmath354 ( recall that definition clauses can not contain occurrences of parameters ) , by lemma  [ lm : red vacuous ] we have @xmath355 = \\red_{b\\,y^q\\,\\vec t}\\ , [ \\omega]$ ] , and therefore the result .",
    "[ lm : clo - ext - coind ] let @xmath347 $ ] be a candidate substitution such that @xmath169 , @xmath348 is definitionally closed , and for every @xmath298 of the same types as @xmath92 , @xmath346 \\in \\rscr \\,\\vec u \\rightarrow \\red_{b\\,x^p\\,\\vec u}\\ , [ \\omega]\\ ] ] then @xmath279 is definitionally closed .",
    "analogous to the proof of lemma  [ lm : clo - ext - ind ] .",
    "we are now ready to state the main lemma for cut elimination .",
    "[ lm : comp ] let @xmath279 be a definitionally closed candidate substitution .",
    "let @xmath142 be a derivation of @xmath356 , and let @xmath357 where @xmath358 , be derivations in , respectively , @xmath359 , \\ldots , \\red_{b_n}\\ , [ \\omega]$ ] .",
    "then the derivation @xmath217 @xmath206{{\\delta_1,\\ldots,\\delta_n,\\gamma\\omega\\longrightarrow c\\omega } }    { \\deduce{{\\delta_1\\longrightarrow b_1\\omega } }      { \\pi_1 }      & \\cdots      & \\deduce{{\\delta_n\\longrightarrow b_n\\omega } }      { \\pi_n }      & \\deduce{{b_1\\omega,\\ldots , b_n\\omega,\\gamma\\omega\\longrightarrow c\\omega } }      { \\pi\\omega}}\\ ] ] is in @xmath360 $ ] .",
    "the proof is by induction on @xmath361 where @xmath362 is the multiset @xmath363 of normalization degrees of @xmath224 to @xmath364 .",
    "note that the measure @xmath365 can be well - ordered using the lexicographical ordering .",
    "we shall refer to this ordering as simply @xmath366 .",
    "note also that @xmath365 is insensitive to the order in which @xmath211 is given , thus when we need to distinguish one of the @xmath211 , we shall refer to it as @xmath224 without loss of generality .",
    "the derivation @xmath217 is in @xmath300 $ ] if all its reducts are in @xmath300 $ ] .",
    "[ [ case - i - n-0 ] ] * case i : n = 0 * + + + + + + + + + + + + + + +    in this case , @xmath217 reduces to @xmath290 , thus it is enough to show that that @xmath367 $ ] .",
    "this is proved by case analysis on @xmath51 and on the last rule of @xmath142 .",
    "[ [ i.1 ] ] * i.1",
    "* + + + + +    suppose @xmath368 for some parameter @xmath37 and terms @xmath112 .",
    "if @xmath369 then we need only to show that @xmath290 is normalizable .",
    "this follows mostly straightforwardly from the induction hypothesis and lemma  [ lm : red - norm ] .",
    "the only interesting case is when @xmath142 ends with @xmath186 on some @xmath370 such that @xmath349 , i.e. , @xmath142 takes the form @xmath371   { { y^q\\,\\vec u , \\gamma\\longrightarrow c } } { \\deduce{{d\\,y^q\\,\\vec u , \\gamma\\longrightarrow c}}{\\pi ' } } \\ ] ] suppose @xmath372",
    ". then @xmath373 ) , \\pi'\\omega)$ ] . by * cr4",
    "* we have that @xmath374 , so by the definitional closure of @xmath279 and * cr3 * , we have @xmath375 ) \\in \\red_{d\\,s\\,\\vec u}\\ , [ \\omega]$ ] .",
    "since @xmath376 , and since @xmath377),\\pi'\\omega),$ ] by the induction hypothesis , we have @xmath367 $ ] , and therefore , by lemma  [ lm : red - norm ] , @xmath290 is normalizable .",
    "note that this case is actually independent of the form of @xmath51 .",
    "otherwise , suppose @xmath299 , and @xmath378 .",
    "then there are several cases to consider , based on the last rule of @xmath142 . in all cases ,",
    "we need to show that @xmath379 .",
    "note that since @xmath290 is of type @xmath380 , @xmath381 implies that @xmath382 .",
    "so in the following in some cases we need to show only that @xmath383 .",
    "* @xmath142 ends with @xmath195 : then @xmath290 also ends with @xmath195 and by * cr4 * , @xmath381 . *",
    "@xmath142 ends with @xmath62 : this follows from the induction hypothesis and lemma  [ lm : red - norm ] .",
    "* @xmath142 ends with @xmath186 : suppose @xmath142 ends with @xmath186 acting on a formula @xmath384 .",
    "if @xmath385 , then this follows immediately from the induction hypothesis and * cr5*. if @xmath349 , then we use the same arguments as shown above .",
    "* @xmath142 ends with @xmath139 or a left - rule other than @xmath186 : suppose the premise derivations of the rule are @xmath386 for some index set @xmath146 .",
    "then @xmath290 ends with the same left rule and has premise derivations @xmath387 .",
    "+ by the induction hypothesis , @xmath388 $ ] for every @xmath389 , and by lemma  [ lm : red - norm ] , each @xmath390 is also normalizable .",
    "the latter implies that @xmath290 is normalizable .",
    "note that if @xmath390 is a major premise derivation , then @xmath391 for some @xmath298 , and we have @xmath392 .",
    "therefore , by * cr5 * , we have that @xmath381 .",
    "* suppose @xmath142 ends with @xmath102 : @xmath185 { { \\gamma\\longrightarrow x^p\\vec t } } { \\deduce{{\\gamma\\longrightarrow d\\,x^p\\,\\vec t}}{\\pi ' } } \\ ] ] where @xmath393 .",
    "then @xmath394 $ ] . from the induction hypothesis , we have that @xmath395 $ ] .",
    "this , together with the definitional closure of @xmath279 , implies that @xmath290 is indeed in @xmath396 .",
    "[ [ i.2 ] ] * i.2 :",
    "* + + + + + +    suppose @xmath397 for any parameter @xmath37 and any terms @xmath112 .",
    "most subcases follow easily from the induction hypothesis , lemma  [ lm : red - norm ] and definition  [ def : param red ] .",
    "the subcases where @xmath142 ends with a left rule follow the same lines of arguments as in case i.1 above .",
    "we show here the non - trivial subcases involving right - introduction rules :    [ [ i.2.a ] ] * i.2.a",
    "* + + + + + + +    suppose @xmath142 ends with @xmath303 , as shown below left .",
    "then @xmath290 is as shown below right .",
    "@xmath305 { { \\gamma\\longrightarrow c_1 { \\supset}c_2 } } { \\deduce{{\\gamma ,        c_1\\longrightarrow c_2}}{\\pi ' } } \\qquad \\infer[{{\\supset}{\\cal r } } ] { { \\gamma\\omega\\longrightarrow c_1\\omega { \\supset}c_2\\omega } } {    \\deduce{{\\gamma\\omega , c_1\\omega\\longrightarrow c_2\\omega}}{\\pi'\\omega } } \\ ] ] to show @xmath367 $ ] , we need to show that @xmath290 is normalizable and that @xmath398 \\rightarrow \\red_{c_2\\theta}[\\omega]\\ ] ] for every @xmath43 . since @xmath376 , by the induction hypothesis , @xmath399 $ ] .",
    "normalizability of @xmath290 then follows immediately from this and lemma  [ lm : red - norm ] .",
    "it remains to show that statement  [ eq : ce1 ] holds :    let @xmath343 be a derivation in @xmath400 $ ] .",
    "let @xmath401 .",
    "note that since parameter substitution commutes with eigenvariable substitution , @xmath402 .",
    "since @xmath403 ( lemma  [ lm : subst - height ] ) , by induction hypothesis , we have @xmath404 $ ] . in other words ,",
    "statement  [ eq : ce1 ] holds for arbitrary @xmath43 , and therefore by definition  [ def : param red ] , @xmath367 $ ] .",
    "[ [ i.2.b ] ] * i.2.b",
    "* + + + + + + +    suppose @xmath142 ends with @xmath104 , as shown below left , where @xmath393 .",
    "we can assume w.l.o.g .",
    "that @xmath308 .",
    "then @xmath290 is as shown below right .",
    "@xmath230 { { \\gamma\\longrightarrow p\\,\\vec t } } { \\deduce{{\\gamma\\longrightarrow d\\,x^p\\,\\vec t}}{\\pi ' } } \\qquad \\infer[{{\\rm i}{\\cal r } } ] { { \\gamma\\omega\\longrightarrow p\\,\\vec t } } { \\deduce{{\\gamma\\omega\\longrightarrow d\\,x^p \\,\\vec t}}{\\pi'\\omega } } \\ ] ] to show that @xmath367 $ ] , we need to show that @xmath290 is normalizable ( as before this easily follows from the induction hypothesis and lemma  [ lm : red - norm ] ) and that @xmath405 , \\pi_s[\\vec t/\\vec x ] ) \\in \\rscr\\,\\vec t\\ ] ] for every candidate @xmath406 and every @xmath167 that satisfies : @xmath407 \\in",
    "\\red_{d\\,x^p\\,\\vec u}\\ , [ \\omega , ( \\rscr,\\pi_s , s)/x^p ]    \\rightarrow \\rscr\\,\\vec u    \\hbox { for every $ \\vec u$.}\\ ] ] let @xmath408 $ ] .",
    "note that since @xmath409 , we have @xmath410 = \\pi'\\omega ' .",
    "$ ] so statement  [ eq : casei3-a ] above can be rewritten to @xmath411 ) \\in \\rscr\\,\\vec t.\\ ] ] by lemma  [ lm : clo - ext - ind ] , we have that @xmath348 is definitionally closed .",
    "therefore we can apply the induction hypothesis to @xmath243 and @xmath348 , obtaining @xmath412 $ ] .",
    "this , together with definitional closure of @xmath348 , immediately implies statement  [ eq : casei3-c ] above , hence @xmath290 is indeed in @xmath300 $ ] .",
    "[ [ i.2.c ] ] * i.2.c",
    "* + + + + + + +    suppose @xmath142 ends with @xmath90 , as shown below left , where @xmath413 .",
    "let @xmath414 .",
    "then @xmath290 is as shown below right .",
    "@xmath233 { { \\gamma\\longrightarrow p\\,\\vec t } } { \\deduce{{\\gamma\\longrightarrow s\\,\\vec t}}{\\pi ' } & \\deduce{{s\\,\\vec x\\longrightarrow d\\,s\\,\\vec        x}}{\\pi_s } } \\qquad \\infer[{{\\rm ci}{\\cal r } } ] { { \\gamma\\omega\\longrightarrow p\\,\\vec t } } { \\deduce{{\\gamma\\omega\\longrightarrow s'\\,\\vec t}}{\\pi'\\omega } & \\deduce{{s'\\vec        x\\longrightarrow d\\,s'\\,\\vec x}}{\\pi_s\\omega } } \\ ] ] note that @xmath290 is normalizable , by the induction hypothesis and lemma  [ lm : red - norm ] . to show that @xmath367 $ ] it remains to show that there exists a reducibility candidate @xmath415 such that    ( a ) : :    @xmath416 , and ( b ) : :    @xmath417 \\in \\rscr\\,\\vec u \\rightarrow      \\red_{d\\,x^p\\,\\vec u}\\ , [ \\omega , ( \\rscr , \\pi_s\\omega , s')/x^p]$ ] for    a new @xmath308 .",
    "let @xmath418 \\}. $ ] by lemma  [ lm : red candidate ] , @xmath265 is a reducibility candidate of type @xmath419 . by the induction hypothesis",
    ", we have @xmath420 , so @xmath265 satisfies * ( a)*. since substitution does not increase the height of derivations , we have that @xmath421 ) } \\leq { { \\rm ht}(\\pi_s)}$ ] , and therefore , by applying the induction hypothesis to @xmath422 $ ] , we have @xmath423 ) \\in \\red_{d\\,s\\,\\vec u}\\ , [ \\omega ] $ ] for every @xmath424 $ ] . in other words , @xmath425 \\in \\red_{s\\,\\vec u}\\ , [ \\omega ] \\rightarrow \\red_{d\\,s\\,\\vec u}\\ , [ \\omega].\\ ] ] notice that @xmath426 $ ] is exactly @xmath427 .",
    "so the above statement can be rewritten to @xmath425 \\in \\rscr\\,\\vec u \\rightarrow \\red_{d\\,s\\,\\vec u}\\ , [ \\omega].\\ ] ] by lemma  [ lm : red param subst ] , @xmath428 = \\red_{d\\,x^p\\,\\vec u}\\ , [ \\omega , ( \\rscr , \\pi_s\\omega , s')/x^p]$ ] , which means that @xmath265 indeed satisfies condition * ( b ) * above , and therefore @xmath367 $ ] .",
    "[ [ case - ii - n-0 ] ] * case ii : @xmath429 * + + + + + + + + + + + + + + + + + + + + + + + + + + + + + +    to show that @xmath430 $ ] in this case , we need to show that all its reducts are in @xmath300 $ ] and that @xmath217 is normalizable .",
    "the latter follows from the former by lemma  [ lm : red - norm ] and definition  [ def : norm ] , so in the following we need only to show the former .",
    "note that in this case , we do not need to distinguish cases based on whether @xmath51 is headed by a parameter or not . to see why ,",
    "suppose @xmath431 for some parameter @xmath37 . if @xmath369 then to show @xmath430 $ ] we need to show that it is normalizable , which means that we need to show that all its reducts are normalizable .",
    "but since all reducts of @xmath217 has the same type @xmath187 , showing their normalizability amounts to the same thing as showing that they are in @xmath300 $ ] .",
    "if @xmath432 , then to show @xmath430 $ ] we need to show that @xmath433 .",
    "then by * cr3 * , it is enough to show that all reducts of @xmath217 are in @xmath265 , which is the same as showing that all reducts of @xmath217 are in @xmath300 $ ] .    since the applicable reduction rules to @xmath217 are driven by the shape of @xmath290 , and since @xmath290 is determined by @xmath142 , we shall perform case analysis on @xmath142 in order to determine the possible reduction rules that apply to @xmath217 , and show in each case that the reduct of @xmath217 is in the same parametric reducibility set .",
    "there are several main cases depending on whether @xmath142 ends with a rule acting on a cut formula @xmath221 or not .",
    "again , when we refer to @xmath221 , without loss of generality , we assume @xmath434 .    in the following , we say that an instance of @xmath186 is _ trivial _ if it applies to a formula @xmath435 for some @xmath298 , but @xmath385 .",
    "otherwise , we say that it is non - trivial .",
    "[ [ ii.1 ] ] * ii.1",
    "* + + + + + +    suppose @xmath142 ends with a left rule , other than @xmath436 , @xmath229 and a non - trivial @xmath186 , on @xmath237 and @xmath224 ends with a right - introduction rule .",
    "there are several subcases depending on the logical rules that are applied to @xmath237 .",
    "we show here the non - trivial cases :    suppose @xmath224 and @xmath142 are @xmath305 { { \\delta_1\\longrightarrow b_1'\\omega { \\supset}b_1''\\omega } } {    \\deduce{{\\delta_1,b_1'\\omega\\longrightarrow b_1''\\omega}}{\\pi_1 ' } } \\qquad \\infer[{{\\supset}{\\cal l}}. ]   { { b_1'{\\supset}b_1'',b_2,\\dots , b_n,\\gamma\\longrightarrow c } } {    \\deduce{{b_2,\\dots,\\gamma\\longrightarrow b_1'}}{\\pi ' } &    \\deduce{{b_1'',b_2,\\dots,\\gamma\\longrightarrow c}}{\\pi '' } } \\ ] ] let @xmath437 . then @xmath438 $ ] by induction hypothesis since @xmath376 and therefore @xmath439 . since @xmath440 $ ] , by definition  [ def : param red ] , we have @xmath441 \\rightarrow \\red_{b_1''}[\\omega]\\ ] ] and therefore the derivation @xmath442 with end sequent @xmath443 is in @xmath444 $ ] .",
    "let @xmath445 .",
    "the reduct of @xmath217 in this case is the derivation @xmath446 : @xmath447    { { \\delta_1,\\ldots,\\delta_n,\\gamma\\omega\\longrightarrow c\\omega } }    {      \\deduce      { { \\delta_1,\\ldots , \\delta_n,\\gamma\\omega ,          \\delta_2,\\ldots , \\delta_n,\\gamma\\omega\\longrightarrow c\\omega }      }      { \\xi_3 }    } \\ ] ] by the induction hypothesis , we have @xmath448 $ ] , and therefore , by lemma  [ lm : red - norm ] , it is normalizable . by definition  [ def : norm ] , this means that @xmath446 is normalizable and by definition  [ def : param red ] , @xmath449 $ ] .",
    "suppose @xmath224 and @xmath142 are @xmath71 { { \\delta_1\\longrightarrow \\forall x.b_1'\\omega } } {    \\deduce{{\\delta_1\\longrightarrow b_1'\\omega[y / x]}}{\\pi_1 ' } } \\qquad \\qquad \\infer[{\\forall{\\cal l } } ] { { \\forall x.b_1',b_2,\\dots , b_n,\\gamma\\longrightarrow c } } {    \\deduce{{b_1'[t / x],b_2,\\dots , b_n,\\gamma\\longrightarrow c}}{\\pi ' } } \\ ] ] the reduct of @xmath217 in this case is @xmath450 , \\pi_2 , \\ldots , \\pi_n , \\pi'\\omega).\\ ] ] since @xmath451}[\\omega]$ ] , by lemma  [ lm : red - subst ] we have @xmath452 \\in \\red_{b_1'[t / x]}[\\omega]\\ ] ] note that @xmath376 , so we can apply the induction hypothesis to obtain @xmath453 $ ] .",
    "suppose @xmath224 and @xmath142 are @xmath225 { { \\delta_1\\longrightarrow s = t } } { } \\qquad \\qquad \\infer[{{\\rm eq}{\\cal l } } ] { { s = t,\\dots , b_n,\\gamma\\longrightarrow c } } { \\left\\{\\raisebox{-1.5ex } {        \\deduce{{b_2\\rho,\\dots , b_n\\rho,\\gamma\\rho\\longrightarrow c\\rho } }        { \\pi^\\rho } } \\right\\}_\\rho } \\ ] ] note that in this case @xmath65 must be the same term as @xmath47 , and therefore both are unifiable by any substitution .",
    "let @xmath243 be the derivation : @xmath143 { { b_2,\\ldots , b_n,\\gamma\\longrightarrow c } } { \\left\\ { \\raisebox{-1.3ex } { \\deduce{{b_2\\rho,\\ldots , b_n\\rho,\\gamma\\rho\\longrightarrow c\\rho}}{\\pi^\\rho } } \\right\\}_\\rho } \\ ] ] and let @xmath437 .",
    "since @xmath454 and since the total size of cut formulas in @xmath226 is smaller than in @xmath217 , by the induction hypothesis , we have @xmath455 $ ]",
    ". then the reduct of @xmath217 in this case is the derivation @xmath446 : @xmath228 { { \\delta_1,\\delta_2,\\ldots,\\delta_n,\\gamma\\longrightarrow c } } { \\deduce{{\\delta_2,\\ldots,\\delta_n,\\gamma\\longrightarrow c}}{\\xi_1 } } \\ ] ] which is also in @xmath300 $ ] , by the definition of parametric reducibility .",
    "suppose @xmath224 and @xmath142 are the derivations @xmath230 { { \\delta_1\\longrightarrow p\\,\\vec t } } { \\deduce{{\\delta_1\\longrightarrow d\\,x^p\\,\\vec t}}{\\pi_1 ' } } \\qquad \\infer[{{\\rm i}{\\cal l } } ] { { p\\,\\vec{t } , \\gamma\\longrightarrow c } } {    \\deduce{{d\\,s\\,\\vec{x}\\longrightarrow s\\,\\vec{x}}}{\\pi_s } &    \\deduce{{s\\,\\vec{t } , \\gamma\\longrightarrow c}}{\\pi ' } } \\ ] ] where @xmath456 and @xmath37 is a new parameter not occuring in the end sequent of @xmath224 ( we can assume w.l.o.g .  that @xmath308 and that it does not occur either in the end sequent of @xmath142 ) .",
    "then @xmath290 is the derivation @xmath238 { { p\\,\\vec{t } , \\gamma\\omega\\longrightarrow c\\omega } } {    \\deduce{{d\\,s'\\,\\vec{x}\\longrightarrow s'\\,\\vec{x}}}{\\pi_s\\omega } &    \\deduce{{s'\\,\\vec{t } , \\gamma\\omega\\longrightarrow c\\omega}}{\\pi'\\omega } } \\ ] ] where @xmath414 .",
    "let @xmath457 ,",
    "\\pi_s\\omega[\\vec t/\\vec x]$ ]",
    ". then the reduct of @xmath217 in this case is the derivation @xmath458 since @xmath459 ) } \\leq { { \\rm ht}(\\pi_s ) } < { { \\rm ht}(\\pi)}$ ] by the induction hypothesis , we have @xmath460 \\in \\red_{d\\,s\\,\\vec u}\\ , [ \\omega ] \\rightarrow \\red_{s\\,\\vec u}\\ , [ \\omega].\\ ] ] let @xmath461 \\hbox { for    some $ \\vec u$ } \\}$ ] .",
    "then by lemma  [ lm : red candidate ] , @xmath265 is a reducibility candidate of type @xmath419 .",
    "moreover , by lemma  [ lm : red param subst ] , we have @xmath462 = \\red_{d\\,x^p\\,\\vec u}\\ , [ \\omega , ( \\rscr , \\pi_s\\omega , s')/x^p].\\ ] ] this , together with statement  [ eq : caseii.1-a ] above , implies that @xmath463 \\in \\red_{d\\,x^p\\,\\vec u}\\ , [ \\omega , ( \\rscr , \\pi_s\\omega , s')/x^p ] \\rightarrow \\rscr \\,\\vec u\\ ] ] for every @xmath298 .",
    "since @xmath464 $ ] , it follows from definition  [ def : param red ] that for every reducibility candidate @xmath309 and @xmath310 such that @xmath465 \\in \\red_{d\\,x^p\\,\\vec u}\\ , [ \\omega , ( \\sscr , \\pi_i , i)/x^p ] \\rightarrow \\sscr\\,\\vec u \\hbox { for every $ \\vec u$ , } \\ ] ] we have @xmath466 , \\pi_i[\\vec t/\\vec x ] ) \\in \\sscr\\,\\vec t.\\ ] ] substituting @xmath265 for @xmath257 , @xmath467 for @xmath310 and @xmath419 for @xmath146 , and using statement  [ eq : caseii.1-b ] above , we obtain : @xmath468 , \\pi_s\\omega[\\vec t/\\vec x ] ) \\in \\rscr\\,\\vec t = \\red_{s\\,\\vec t}\\ , [ \\omega].\\ ] ] since @xmath376 , we can then apply the induction hypothesis to conclude that @xmath453 $ ] .",
    "suppose @xmath224 and @xmath142 are @xmath233 { { \\delta_1\\longrightarrow p\\,\\vec{t } } } {    \\deduce{{\\delta_1\\longrightarrow s\\,\\vec{t}}}{\\pi_1 ' } &    \\deduce{{s\\,\\vec{x}\\longrightarrow d\\,s\\,\\vec{x}}}{\\pi_s } } \\qquad \\qquad \\infer[{{\\rm ci}{\\cal l } } ] { { p\\,\\vec{t } , b_2 , \\dots , \\gamma\\longrightarrow c } } { \\deduce{{d\\,x^p\\,\\vec{t},b_2,\\dots , \\gamma\\longrightarrow c}}{\\pi'}}\\ ] ] where @xmath469 and @xmath37 is a parameter not already occuring in the end sequent of @xmath142 ( and w.l.o.g .",
    "assume also @xmath308 and @xmath37 not occuring in @xmath470 or @xmath221 ) . then @xmath290 is @xmath471   { { p\\,\\vec{t } , b_2\\omega , \\dots ,      \\gamma\\omega\\longrightarrow c\\omega } } { \\deduce{{d\\,x^p\\,\\vec{t},b_2\\omega,\\dots ,        \\gamma\\omega\\longrightarrow c\\omega}}{\\pi'\\omega}}\\ ] ] since @xmath464 $ ] , by definition  [ def : param red ] , there exists a reducibility candidate @xmath406 such that @xmath472 and such that for every @xmath298 , @xmath346 \\in \\rscr\\,\\vec u \\rightarrow \\red_{d\\,x^p\\,\\vec    u}\\ , [ \\omega , ( \\rscr,\\pi_s , s)/x^p)].\\ ] ] let @xmath473 $ ] . then by lemma  [ lm : clo - ext - coind ] , @xmath348 is definitionally closed .",
    "let @xmath474)$ ] . by the definitional closure of @xmath348",
    ", we have that @xmath475 $ ] .",
    "the reduct of @xmath217 in this case is the derivation @xmath476 note that since @xmath37 does not occur in @xmath470 or @xmath221 , by lemma  [ lm : red vacuous ] , we have that @xmath477 = \\red_{b_i}[\\omega']\\ ] ] for every @xmath478 .",
    "therefore , by induction hypothesis , we have that @xmath479.\\ ] ] but since @xmath37 is also new for @xmath51 , we have @xmath480 = \\red_c[\\omega]$ ] , and therefore @xmath481.\\ ] ]    [ [ ii.2 ] ] * ii.2 * + + + + + +    @xmath142 ends with a left rule , other than @xmath436 , @xmath229 and a non - trivial instance of @xmath186 , acting on @xmath237 , and @xmath224 ends with a left - rule or @xmath139 .    note that in these cases , the reducts always end with a left - rule . the proof for the following cases abide to the same pattern : we first establish that the premise derivations of the reduct are either normalizable or in certain reducibility sets .",
    "we then proceed to show that the reduct itself is reducible by applying to the closure conditions of reducibility under applications of left - rules . for the latter ,",
    "we need to distinguish three cases depending on @xmath51 : if @xmath431 for some @xmath482 , then closure under left - rules is guaranteed by * c5 * ; if @xmath369 then we need to show that the reduct is normalizable , and the closure condition under left - rules is guaranteed by the definition of normalizability .",
    "otherwise , @xmath51 is not headed by any parameter , and in this case , the closure condition follows from * p6*. we shall explicitly do these case analysis in one of the subcases below , but will otherwise leave them implicit .",
    "we show the non - trivial subcases only ; other cases can be proved by straightforward applications of the induction hypothesis .",
    "suppose @xmath224 is @xmath483 { { d_1 { \\supset}d_2,\\delta_1'\\longrightarrow b_1\\omega } } {    \\deduce{{\\delta_1'\\longrightarrow d_1}}{\\pi_1 ' } &    \\deduce{{d_2,\\delta_1'\\longrightarrow b_1\\omega}}{\\pi_1 '' } } \\ ] ] since @xmath440 $ ] , it follows from definition  [ def : param red ] that @xmath484 is normalizable and @xmath485 $ ] .",
    "let @xmath486 . since @xmath487 , by induction hypothesis , @xmath488 $ ] .",
    "the reduct of @xmath217 in this case is the derivation @xmath446 : @xmath483    { { d_1 { \\supset}d_2,\\delta_1',\\delta_2,\\ldots,\\gamma\\omega\\longrightarrow c\\omega } }    {      \\infer=[{\\hbox{\\sl w}{\\cal l } } ]      { { \\delta_1',\\ldots,\\gamma\\omega\\longrightarrow d_1 } }      {        \\deduce{{\\delta_1'\\longrightarrow d_1}}{\\pi_1 ' }       }      &      \\deduce{{d_2,\\delta_1',\\delta_2,\\ldots,\\gamma\\omega\\longrightarrow c\\omega } }      { \\xi_1 }    } \\ ] ] since @xmath484 is normalizable , by definition  [ def : norm ] the left premise derivation of @xmath446 is normalizable , and since reducibility implies normalizability ( lemma  [ lm : red - norm ] ) , the right premise is also normalizable , hence @xmath446 is normalizable .    now to show @xmath449 $ ] , we need to distinguish three cases based on @xmath51 :    * suppose @xmath183 for some @xmath299 and @xmath489 .",
    "then we need to show that @xmath490 .",
    "this follows from definition  [ def : candidates ] , more specifically , from * cr5 * and the fact that @xmath455 = \\rscr\\,\\vec t$ ] .",
    "* suppose @xmath368 but @xmath369 .",
    "then we need to show that @xmath446 is normalizable . but",
    "this follows immediately from the normalizability of both of its premise derivations .",
    "* suppose @xmath491 for any parameter @xmath37 and any terms @xmath112 .",
    "since @xmath455 $ ] , by definition  [ def : param red ] , we have @xmath449 $ ] .",
    "suppose @xmath224 is as shown below left .",
    "then the reduct of @xmath217 in this case is shown below right , where @xmath492 .",
    "@xmath5{{s = t,\\delta_1'\\longrightarrow b_1\\omega } } { \\left\\{\\raisebox{-1.5ex }      { \\deduce{{\\delta_1'\\rho\\longrightarrow b_1\\omega\\rho } } { \\pi^{\\rho } } }    \\right\\}_{\\rho } } \\qquad \\infer[{{\\rm eq}{\\cal l } } ] { { s = t,\\delta_1',\\delta_2,\\dots,\\gamma\\omega\\longrightarrow c\\omega } } { \\left\\{\\raisebox{-1.5ex }      { \\deduce{{\\delta_1'\\rho,\\dots,\\gamma\\omega\\rho\\longrightarrow c\\omega\\rho } }        { \\xi^{\\rho } } } \\right\\}_{\\rho}}\\ ] ] @xmath493 $ ] by the induction hypothesis ( since @xmath494 and the other measures are non - increasing ) .",
    "hence , the reduct of @xmath217 is in @xmath300 $ ] by the definition of parametric reducibility .",
    "suppose @xmath224 is @xmath495   { { p\\,\\vec{t } , \\delta_1'\\longrightarrow b_1\\omega } } {    \\deduce{{d\\,s\\,\\vec{x}\\longrightarrow s\\,\\vec{x}}}{\\pi_s } &    \\deduce{{s\\,\\vec{t } , \\delta_1'\\longrightarrow b_1\\omega}}{\\pi_1 ' } } \\ ] ] since @xmath440 $ ] , we have that @xmath167 is normalizable and @xmath496 $ ] .",
    "let @xmath226 be the derivation @xmath497 then @xmath498 $ ] by the induction hypothesis , since @xmath499 .",
    "therefore the reduct of @xmath217 @xmath238 { { p\\,\\vec{u},\\delta_1 ' ,      \\dots,\\delta_n,\\gamma\\omega\\longrightarrow c\\omega } } {    \\deduce{{d\\,s\\,\\vec{x}\\longrightarrow s\\,\\vec{x}}}{\\pi_s } &    \\deduce{{s\\,\\vec{u},\\delta_1 ' ,        \\ldots,\\delta_n,\\gamma\\omega\\longrightarrow c\\omega}}{\\xi_1 } } \\ ] ] is also in @xmath360 $ ] .",
    "[ [ ii.3 ] ] * ii.3 * + + + + + +    @xmath142 ends with a left rule , other than @xmath436 , @xmath229 and a non - trivial instance of @xmath186 , acting on @xmath237 , and @xmath224 ends with @xmath62 or @xmath195 : these cases follow straightforwardly from the induction hypothesis .",
    "[ [ ii.4 ] ] * ii.4",
    "* + + + + + +    suppose @xmath142 ends with a non - trivial application of @xmath186 on @xmath237 .",
    "that is , @xmath500 , for some @xmath501 and some @xmath112 , and @xmath142 is @xmath189 { { x^p\\,\\vec t , b_2 , \\ldots , b_n , \\gamma\\longrightarrow c } } {    \\deduce{{d\\,x^p\\,\\vec t , b_2,\\ldots , b_n , \\gamma\\longrightarrow c}}{\\pi ' } } \\ ] ] where @xmath234 .",
    "suppose @xmath502 .",
    "then @xmath290 is @xmath503 ) , \\pi'\\omega$ ] .",
    "let @xmath504)$ ] .",
    "note that @xmath226 has exactly one reduct , that is , @xmath505).\\ ] ] note that @xmath506 also has exactly one reduct , namely , @xmath224 .",
    "since @xmath507 = \\rscr\\,\\vec t$ ] , this means , by * cr3 * , that @xmath506 is in @xmath396 .",
    "since @xmath279 is definitionally closed , we have that @xmath508 $ ] . and",
    "since @xmath509 is the only reduct of @xmath226 , this also means that , by definition  [ def : param red ] , @xmath510 $ ] .    the reduct of @xmath217 , the derivation @xmath511 is therefore in @xmath300 $ ] by the induction hypothesis .",
    "[ [ ii.5 ] ] * ii.5",
    "* + + + + + +    suppose @xmath142 ends with @xmath229 or @xmath436 acting on @xmath237 , or @xmath195 .",
    "then @xmath290 also ends with the same rule .",
    "the cut reduction rule that applies in this case is either @xmath512 , @xmath513 or @xmath514 . in these cases ,",
    "parametric reducibility of the reducts follow straightforwardly from the assumption ( in case of @xmath195 ) , the induction hypothesis and definition  [ def : param red ] .",
    "[ [ ii.6 ] ] * ii.6",
    "* + + + + + +    suppose @xmath142 ends with @xmath62 .",
    "then @xmath290 also ends with @xmath62 .",
    "the reduction rule that applies in this case is the reduction @xmath515 .",
    "parametric reducibility of the reduct in this case follows straightforwardly from the induction hypothesis and definition  [ def : param red ] .",
    "[ [ ii.7 ] ] * ii.7",
    "* + + + + + +    suppose @xmath142 ends with @xmath139 or a rule acting on a formula other than a cut formula .",
    "most cases follow straightforwardly from the induction hypothesis , lemma  [ lm : red - norm ] and lemma  [ lm : red - subst ] ( which is needed in the reduction case @xmath516 and @xmath517 ) .",
    "we show the interesting subcases here :    suppose @xmath142 ends with a non - trivial @xmath102 , i.e. , @xmath142 is @xmath185 { { b_1,\\ldots , b_n,\\gamma\\longrightarrow x^p\\,\\vec t } } {    \\deduce{{b_1,\\ldots , b_n,\\gamma\\longrightarrow d\\,x^p\\,\\vec t}}{\\pi ' } } \\ ] ] where @xmath393 and @xmath299 .",
    "suppose @xmath518 .",
    "then @xmath290 is the derivation @xmath519 $ ] .",
    "the reduct of @xmath217 in this case is the derivation @xmath520).\\ ] ] by the induction hypothesis , we have @xmath521 .",
    "$ ] this , together with the definitional closure of @xmath279 , implies that @xmath522 $ ] .",
    "suppose @xmath142 is @xmath230 { { b_1,\\ldots , b_n,\\gamma\\longrightarrow p\\,\\vec t } } {    \\deduce{{b_1,\\ldots , b_n,\\gamma\\longrightarrow d\\,x^p\\,\\vec t}}{\\pi ' } } \\ ] ] where @xmath456 .",
    "without loss of generality we can assume that @xmath37 is chosen to be sufficiently fresh ( e.g. , not occurring in @xmath279 , @xmath523 , @xmath237 , etc . ) . let @xmath524 .",
    "then the reduct of @xmath217 is the derivation @xmath446 @xmath525   { { \\delta_1,\\ldots,\\delta_n,\\gamma\\omega\\longrightarrow p\\,\\vec      t } } {    \\deduce{{\\delta_1,\\ldots,\\delta_n,\\gamma\\omega\\longrightarrow d\\,x^p\\,\\vec        t}}{\\xi_1 } } \\ ] ] to show that @xmath449 $ ] , we first need to show that it is normalizable .",
    "this follows straightforwardly from the induction hypothesis ( which shows that @xmath510 $ ] ) and lemma  [ lm : red - norm ] .",
    "it then remains to show that @xmath526 , \\pi_s[\\vec t/\\vec x ] ) \\in \\rscr\\,\\vec t\\ ] ] for every reducibility candidate @xmath406 and every @xmath167 such that @xmath527 \\in \\red_{d\\,x^p\\,\\vec u}\\ , [ \\omega , ( \\rscr,\\pi_s , s)/x^p ] \\rightarrow \\rscr\\,\\vec u ,    \\hbox { for every $ \\vec u$.}\\ ] ]    so suppose @xmath528 satisfies statement  [ eq : ii.7.a.1 ] above",
    ". let @xmath529 $ ] .",
    "by lemma  [ lm : clo - ext - ind ] , @xmath348 is definitionally closed . note",
    "that since we assume that @xmath37 is a fresh parameter not occuring in @xmath221 , we have @xmath530 = \\red_{b_i}[\\omega']$ ] by lemma  [ lm : red vacuous ] , and @xmath531 = \\pi_i \\in \\red_{b_i}[\\omega ' ] $ ] by lemma  [ lm : param subst vacuous ] , for every @xmath532 .",
    "therefore , by the induction hypothesis we have : @xmath533 = mc(\\pi_1,\\ldots,\\pi_n,\\pi'\\omega ' ) \\in",
    "\\red_{d\\,x^p\\,\\vec t}\\ , [ \\omega'].\\ ] ] this , together with the definitional closure of @xmath348 , implies that @xmath534    suppose @xmath142 ends with a non - trivial @xmath186 , i.e. , @xmath142 is @xmath189 { { b_1,\\ldots , b_n , x^p\\,\\vec t , \\gamma'\\longrightarrow c } } {    \\deduce{{b_1,\\ldots , b_n , d\\,x^p\\,\\vec t , \\gamma'\\longrightarrow c}}{\\pi ' } } \\ ] ] where @xmath234 and @xmath299 .",
    "suppose @xmath489 .",
    "then @xmath290 is @xmath535),\\pi'\\omega).\\ ] ] let @xmath536)$ ] . by * cr4",
    "* , @xmath537 , and therefore , by definitional closure of @xmath279 , we have @xmath538 $ ] .",
    "the reduct of @xmath217 in this case is @xmath539 which is in @xmath300 $ ] by the induction hypothesis .",
    "suppose @xmath142 is @xmath233 { { b_1,\\dots , b_n,\\gamma\\longrightarrow p\\,\\vec{t } } } {    \\deduce{{b_1,\\dots , b_n,\\gamma\\longrightarrow s\\,\\vec{t}}}{\\pi ' } &    \\deduce{{s\\,\\vec{x}\\longrightarrow d\\,s\\,\\vec{x}}}{\\pi_s } } \\enspace\\ ] ] where @xmath540 .",
    "let @xmath414 .",
    "the derivation @xmath290 in this case is @xmath233 { { b_1\\omega,\\dots , b_n\\omega,\\gamma\\omega\\longrightarrow p\\,\\vec{t } } } {    \\deduce{{b_1\\omega,\\dots , b_n\\omega,\\gamma\\omega\\longrightarrow s'\\,\\vec{t}}}{\\pi'\\omega }    & \\deduce{{s'\\,\\vec{x}\\longrightarrow d\\,s'\\,\\vec{x}}}{\\pi_s\\omega } } \\ ] ] let @xmath226 be the derivation @xmath541 . by the induction hypothesis , @xmath542 $ ] and @xmath543 $ ] , hence both @xmath226 and @xmath467 are also normalizable by lemma  [ lm : red - norm ] .",
    "the reduct of @xmath217 is the derivation @xmath446 @xmath544 { { \\delta_1,\\dots,\\delta_n,\\gamma\\omega\\longrightarrow p\\,\\vec{t } } } {    \\deduce{{\\delta_1,\\dots,\\delta_n,\\gamma\\omega\\longrightarrow s'\\,\\vec{t}}}{\\xi_1 }    & \\deduce{{s'\\,\\vec{x}\\longrightarrow d\\,s'\\,\\vec{x}}}{\\pi_s\\omega } } \\ ] ] let @xmath37 be a parameter fresh for @xmath279 , @xmath52 , @xmath470 and @xmath221 .    to show that @xmath449 $ ] we must first show that it is normalizable",
    "this follows from immediately from normalizability of @xmath226 and @xmath467 .",
    "then we need to find a reducibility candidate @xmath545 such that    ( a ) : :    @xmath546 , and ( b ) : :    @xmath417 \\in \\rscr\\,\\vec u \\rightarrow      \\red_{d\\,x^p\\,\\vec u}\\ , [ \\omega,(\\rscr,\\pi_s , s)/x^p]$ ] .",
    "let @xmath418 \\}. $ ] as in case * i.2.c * , we show , using lemma  [ lm : red candidate ] , that @xmath265 is a reducibility candidate of type @xmath419 . by the induction hypothesis , we have @xmath546 , so @xmath265 satisfies * ( a)*. using the same argument as in case * i.2.c * we can show that @xmath265 also satisfies * ( b ) * , by appealing to the induction hypothesis , applied to @xmath167 .",
    "every derivation is reducible .",
    "the proof follows from lemma  [ lm : comp ] , by setting @xmath219 and @xmath279 to the empty candidate substitution .",
    "since reducibility implies cut - elimination and since every cut - free derivation can be turned into a @xmath139-free derivation ( lemma  [ lm : subst - elimination ] ) , it follows that every proof can be transformed into a cut - free and @xmath139-free derivation .",
    "[ cor : cut - elimination ] given a fixed definition , a sequent has a derivation in @xmath1 if and only if it has a cut - free and @xmath139-free derivation .",
    "the consistency of @xmath1 is an immediate consequence of cut - elimination . by consistency",
    "we mean the following : given a fixed definition and an arbitrary formula @xmath51 , it is not the case that both @xmath51 and @xmath547 are provable .",
    "[ cor : consistency ] the logic @xmath1 is consistent .",
    "of course , there is a long association between mathematical logic and inductive definitions  @xcite and in particular with proof - theory , starting with the takeuti s conjecture , the earliest relevant entry for our purposes being martin - lf s original formulation of the theory of _ iterated inductive definitions _  @xcite . from the representation of algebraic types",
    "@xcite and the introduction of ( co)inductive types in system f  @xcite , ( co)induction / recursion became mainstream and made it into type - theoretic proof assistants such as coq  @xcite , first via a primitive recursive operator , but eventually in the let - rec style of functional programming languages , as in gimenez s _ calculus of infinite constructions _  @xcite . unlike works in these type - theoretic settings",
    ", we put less emphasis on proof terms and strong normalization ; in fact , our cut elimination procedure is actually a form of weak normalization , in the sense that our procedure only guarantees termination with respect to a particular strategy , i.e , by reducing the lowest cuts in a derivation tree .",
    "our notion of equality , which internalizes unification in its left introduction rule , departs from the more traditional notion of equality . as a consequence of these differences ,",
    "it is not at all obvious that strong normalization proofs for term calculi with ( co-)inductive types can be adapted straightforwardly to our setting .",
    "baelde and miller have recently introduced an extension of mulitplicative - additive linear logic with least and greatest fixed points  @xcite , called @xmath76mall . in that work , cut elimination is proved indirectly via a second - order encoding of the least and the greatest fixed point operators into higher - order linear logic and via an appeal to completeness of focused proofs for higher - order linear logic .",
    "such an encoding can also be used for proving cut elimination for @xmath1 , but as we noted earlier , our main concern here is to provide a basis for cut elimination for ( orthogonal ) extensions of @xmath1 with the @xmath3-quantifier , for which there are currently no known encodings into higher - order ( linear ) logic .",
    "baelde has also given a direct cut - elimination proof for @xmath76mall  @xcite .",
    "the proof uses a notion of orthogonality in the definition of reducibility , defined via classical negation , so it is not clear if it can be adapted straightforwardly to the intuitionistic setting like ours .",
    "circular proofs are also connected with the proof - theory of fixed point logics and process calculi  @xcite , as well as in traditional sequent calculi such as in  @xcite .",
    "the issue is the equivalence between systems with local vs.  global induction , that is , between fixed point rules vs.  well - founded and guarded induction ( circular proofs ) . in the traditional sequent calculus",
    ", it is unknown whether every global inductive proof can be translated into a local one .    in higher order logic",
    "( co)inductive definitions are usually obtained via the tarski set - theoretic fixed point construction , as realized for example in isabelle / hol  @xcite . as we mentioned before ,",
    "those approaches are at odd with hoas even at the level of the syntax .",
    "this issue has originated a research field in its own and we only mention the main contenders : in the twelf system  @xcite the lf type theory is used to encode deductive systems as judgments and to specify meta - theorems as relations ( type families ) among them ; a logic programming - like interpretation provides an operational semantics to those relations , so that an external check for totality ( incorporating termination , well - modedness and coverage  @xcite ) verifies that the given relation is indeed a realizer for that theorem .",
    "coinduction is still unaccounted for and may require a switch to a different operational semantics for lf .",
    "there exists a second approach to reasoning in lf that is built on the idea of devising an explicit ( meta-)meta - logic ( @xmath548 ) for reasoning ( inductively ) about the framework  @xcite .",
    "it can be seen as a constructive first - order inductive type theory , whose quantifiers range over possibly open lf objects . in this calculus",
    "it is possible to express and inductively prove meta - logical properties of an object level system .",
    "@xmath548 can be also seen as a dependently - typed functional programming language , and as such it has been refined into the _ delphin _ programming language  @xcite . in a similar vein _ beluga _",
    "@xcite is based on context modal logic  @xcite , which provides a basis for a different foundation for programming with hoas and dependent types . because all of these systems are programming languages , we refrain from a deeper discussion .",
    "we only note that systems like delphin or beluga separate data from computations .",
    "this means they are always based on eager evaluation , whereas co - recursive functions should be interpreted lazily . using standard techniques such as _ thunks",
    "_ to simulate lazy evaluation in such a context seems problematic ( pientka , personal communication ) .",
    "_ weak higher - order abstract syntax _",
    "@xcite is an approach that strives to co - exist with an inductive setting .",
    "the problem of negative occurrences in datatypes is handled by replacing them with a new type .",
    "similarly for hypothetical judgments , although _ axioms _ are needed to reason about them , to mimic what is inferred by the cut rule in our architecture .",
    "framework  @xcite embraces this _ axiomatic _ approach extending coq with the `` theory of contexts '' ( toc ) .",
    "the theory includes axioms for the the reification of key properties of names akin to _ freshness_. furthermore , higher - order induction and recursion schemata on expressions are also assumed .",
    "_ hybrid _",
    "@xcite is a @xmath0-calculus on top of isabelle / hol which provides the user with a _ full _ hoas syntax , compatible with a classical ( co)-inductive setting .",
    "@xmath1 improves on the latter on several counts .",
    "first it disposes of hybrid notion of _ abstraction _ , which is used to carve out the `` parametric '' function space from the full hol function space .",
    "moreover it is not restricted to second - order abstract syntax , as the current hybrid version is ( and as toc can not escape from being ) . finally , at higher types , reasoning via @xmath64 and fixed points is more powerful than inversion , which does not exploit higher - order unification .",
    "_ nominal logic _ gives a different foundation to programming and reasoning with _ names_. it can be presented as a first - order theory  @xcite , which includes primitives for variable renaming and freshness , and a ( derived ) `` new '' freshness quantifier .",
    "it is endowed of natural principles of structural induction and recursion over syntax  @xcite .",
    "urban have engineered a _ nominal datatype package _ inside isabelle / hol  @xcite analogous to the standard datatype package but defining equivalence classes of term constructors .",
    "co - induction / recursion on nominal datatypes is not available , but to be fair it is also currently absent from isabelle / hol .",
    "we have presented a proof theoretical treatment of both induction and co - induction in a sequent calculus compatible with hoas encodings .",
    "the proof principle underlying the explicit proof rules is basically fixed point ( co)induction .",
    "however , the formulation of the rules is inspired by a second - order encoding of least and greatest fixed points .",
    "we have developed a new cut elimination proof , radically different from previous proofs ( @xcite ) , using a reducibility - candidate technique  la girard .",
    "consistency of the logic is an easy consequence of cut - elimination .",
    "our proof system is , as far as we know , the first which incorporates a co - induction proof rule with a direct cut elimination proof .",
    "this schema can be used as a springboard towards cut elimination procedures for more expressive ( conservative ) extensions of @xmath1 , for example in the direction of @xmath549  @xcite , or more recently , the logic @xmath550",
    "@xcite by tiu and the logic @xmath551 by gacek  @xcite .",
    "an interesting problem is the connection with circular proofs , which is particularly attractive from the viewpoint of proof search , both inductively and co - inductively .",
    "this could be realized by directly proving a cut - elimination result for a logic where circular proofs , under termination and guardedness conditions completely replace ( co)inductive rules .",
    "indeed , the question whether `` global '' proofs are equivalent to `` local '' proofs @xcite is still unsettled .",
    "* acknowledgements * the @xmath1 logic was developed in collaboration with dale miller .",
    "we thank david baelde for his comments to a draft of this paper .",
    "10    peter aczel .",
    "an introduction to inductive definitions .",
    "in j.  barwise , editor , _ handbook of mathematical logic _ , volume  90 of _ studies in logic and the foundations of mathematics _ , chapter c.7 , pages 739782 .",
    "north - holland , amsterdam , 1977 .",
    "simon ambler , roy crole , and alberto momigliano . combining higher order abstract syntax with tactical theorem proving and ( co)induction . in v.",
    "a. carreo , editor , _ proceedings of the 15th international conference on theorem proving in higher order logics , hampton , va , 1 - 3 august 2002 _ , volume 2342 of _",
    "lncs_. springer verlag , 2002 .",
    "franz baader and wayne snyder .",
    "unification theory . in john",
    "alan robinson and andrei voronkov , editors , _ handbook of automated reasoning _ , pages 445532 .",
    "elsevier and mit press , 2001 .",
    "david baelde .",
    "least and greatest fixed points in linear logic . ,",
    "abs/0910.3383 , 2009 .",
    "david baelde , andrew gacek , dale miller , gopalan nadathur , and alwen tiu .",
    "the bedwyr system for model checking over syntactic expressions . in frank pfenning ,",
    "editor , _ cade _ , volume 4603 of _ lecture notes in computer science _ , pages 391397 .",
    "springer , 2007 .",
    "david baelde and dale miller .",
    "least and greatest fixed points in linear logic . in _ lpar _ ,",
    "lecture notes in computer science , pages 92106 .",
    "springer , 2007 .    c.  bohm and a.  berarducci",
    ". automatic synthesis of typed @xmath0-programs on term algebras .",
    ", 39(2 - 3):135153 , august 1985 .",
    "james brotherston and alex simpson .",
    "complete sequent calculi for induction and infinite descent . in _ lics _ , pages 5162 .",
    "ieee computer society , 2007 .",
    "k.  l. clark .",
    "negation as failure . in j.",
    "gallaire and j.  minker , editors , _ logic and data bases _ , pages 293322 . plenum press , new york , 1978 .",
    "joelle despeyroux and andre hirschowitz .",
    "higher - order abstract syntax with induction in coq . in _",
    "fifth international conference on logic programming and automated reasoning _ , pages 159173 , june 1994 .",
    "lars - henrik eriksson . a finitary version of the calculus of partial inductive definitions . in l .- h .",
    "eriksson , l.  hallns , and p.  schroeder - heister , editors , _ proceedings of the second international workshop on extensions to logic programming _ , volume 596 of _ lecture notes in artificial intelligence _ , pages 89134 .",
    "springer - verlag , 1991 .",
    "murdoch  j. gabbay .",
    "fresh logic : proof - theory and semantics for fm and nominal techniques .",
    ", 5(2):356387 , 2007 .",
    "andrew gacek .",
    "the abella interactive theorem prover ( system description ) . in alessandro armando ,",
    "peter baumgartner , and gilles dowek , editors , _ ijcar _ , volume 5195 of _ lecture notes in computer science _ , pages 154161 .",
    "springer , 2008 .",
    "andrew gacek , dale miller , and gopalan nadathur .",
    "combining generic judgments with recursive definitions . in _ lics _ , pages 3344 .",
    "ieee computer society , 2008 .",
    "andrew gacek , dale miller , and gopalan nadathur .",
    "reasoning in abella about structural operational semantics specifications .",
    ", 228:85100 , 2009 .",
    "herman geuvers .",
    "inductive and coinductive types with iteration and recursion . in b.",
    "nordstrm , k.  pettersson , and g.  plotkin , editors , _ informal proceedings workshop on types for proofs and programs , bstad , sweden , 812 june 1992 _ , pages 193217 .",
    "dept .  of computing science ,",
    "chalmers univ .  of technology and gteborg univ . , 1992",
    "eduardo gimnez . .",
    "thesis phd 96 - 11 , laboratoire de linformatique du paralllisme , ecole normale suprieure de lyon , december 1996 .",
    "jean - yves girard , paul taylor , and yves lafont . .",
    "cambridge university press , 1989 .",
    "lars hallns .",
    "partial inductive definitions . , 87(1):115142 , 1991 .",
    "robert harper , furio honsell , and gordon plotkin .",
    "a framework for defining logics .",
    ", 40(1):143184 , 1993 .",
    "furio honsell , marino miculan , and ivan scagnetto .",
    "an axiomatic approach to metareasoning on nominal algebras in hoas . in fernando",
    "orejas , paul  g. spirakis , and jan van leeuwen , editors , _ icalp _ , volume 2076 of _ lecture notes in computer science _ , pages 963978 .",
    "springer , 2001 .    .",
    ": a package for higher - order syntax in isabelle / hol and coq .",
    "hybrid.dsi.unimi.it , 2008 , accessd we d feb 24 2010 .",
    "bart jacobs and jan rutten . a tutorial on ( co)algebras and ( co)induction . , 62:222259 , june 1997 .",
    "surveys and tutorials .    per martin - lf .",
    "hauptsatz for the intuitionistic theory of iterated inductive definitions . in j.",
    "e. fenstad , editor , _ proceedings of the second scandinavian logic symposium _ , volume  63 of _ studies in logic and the foundations of mathematics _ , pages 179216 .",
    "north - holland , 1971 .",
    "raymond mcdowell and dale miller .",
    "cut - elimination for a logic with definitions and induction .",
    ", 232:91119 , 2000 .",
    "raymond mcdowell and dale miller .",
    "reasoning with higher - order abstract syntax in a logical framework .",
    ", 3(1):80136 , january 2002 .",
    "raymond mcdowell , dale miller , and catuscia palamidessi . encoding transition systems in sequent calculus .",
    ", 294(3):411437 , 2003 .    n.  p. mendler .",
    "recursive types and type constraints in second - order lambda calculus . in _ lics _ , pages 3036 .",
    "ieee computer society , 1987 .",
    "marino miculan and kidane yemane . a unifying model of variables and names .",
    "in vladimiro sassone , editor , _ fossacs _ , volume 3441 of _ lecture notes in computer science _ , pages 170186 .",
    "springer , 2005 .",
    "dale miller . a logic programming language with lambda - abstraction , function variables , and simple unification . in peter schroeder - heister ,",
    "editor , _ extensions of logic programming : international workshop , tbingen _ , volume 475 of _ lnai _ , pages 253281 .",
    "springer - verlag , 1991 .",
    "dale miller and alwen tiu . a proof theory for generic judgments .",
    ", 6(4):749783 , 2005 .",
    "alberto momigliano and simon ambler .",
    "multi - level meta - reasoning with higher order abstract syntax . in a.",
    "gordon , editor , _ fossacs03 _ ,",
    "volume 2620 of _ lncs _ , pages 375392 .",
    "springer verlag , 2003 .",
    "alberto momigliano and alwen tiu .",
    "induction and co - induction in sequent calculus . in stefano berardi ,",
    "mario coppo , and ferruccio damiani , editors , _ types _ , volume 3085 of _ lecture notes in computer science _ , pages 293308 .",
    "springer , 2003 .",
    "aleksandar nanevski , frank pfenning , and brigitte pientka .",
    "contextual modal type theory . , 9(3 ) , 2008 .",
    "nominal isabelle .",
    "isabelle.in.tum.de/nominal , 2008 , accessed sun feb 14 2010 .",
    "christine paulin - mohring .",
    "inductive definitions in the system coq : rules and properties . in m.",
    "bezem and j.  f. groote , editors , _ proceedings of the international conference on typed lambda calculi and applications _ , pages 328345 ,",
    "utrecht , the netherlands , march 1993 .",
    "springer - verlag lncs 664 .",
    "lawrence  c. paulson .",
    "mechanizing coinduction and corecursion in higher - order logic .",
    ", 7(2):175204 , march 1997 .",
    "frank pfenning .",
    "logical frameworks . in alan robinson and andrei voronkov , editors , _ handbook of automated reasoning _ , chapter  17 , pages 10631147 .",
    "elsevier science publisher and mit press , 2001 .",
    "frank pfenning and christine paulin - mohring .",
    "inductively defined types in the calculus of constructions . in m.",
    "main , a.  melton , m.  mislove , and d.  schmidt , editors , _ proceedings of the fifth conference on the mathematical foundations of programming semantics , tulane university , new orleans , louisiana _ , pages 209228 .",
    "springer - verlag lncs 442 , march 1989 .",
    "brigitte pientka .",
    "verifying termination and reduction properties about higher - order logic programs .",
    "34(2):179207 , 2005 .    brigitte pientka . a type - theoretic foundation for programming with higher - order abstract syntax and first - class substitutions . in george",
    "c. necula and philip wadler , editors , _ popl _ , pages 371382 .",
    "acm , 2008 .    andrew  m. pitts .",
    "nominal logic , a first order theory of names and binding .",
    ", 186(2):165193 , 2003 .",
    "andrew  m. pitts .",
    "alpha - structural recursion and induction . , 53(3):459506 , 2006 .",
    "adam poswolsky and carsten schrmann . practical programming with higher - order encodings and dependent types . in sophia",
    "drossopoulou , editor , _ esop _ , volume 4960 of _ lecture notes in computer science _ , pages 93107 .",
    "springer , 2008 .",
    "luigi santocanale . a calculus of circular proofs and its categorical semantics . in mogens",
    "nielsen and uffe engberg , editors , _ fossacs _ , volume 2303 of _ lecture notes in computer science _ , pages 357371 .",
    "springer , 2002 .",
    "ulrich schpp .",
    "modelling generic judgements . , 174(5):1935 , 2007 .",
    "peter schroeder - heister",
    ". rules of definitional reflection . in m.",
    "vardi , editor , _ eighth annual symposium on logic in computer science _ , pages 222232 .",
    "ieee computer society press , ieee , june 1993 .",
    "carsten schrmann . .",
    "phd thesis , carnegie - mellon university , 2000 .",
    "cmu - cs-00 - 146 .",
    "carsten schrmann .",
    "the twelf proof assistant . in stefan berghofer ,",
    "tobias nipkow , christian urban , and makarius wenzel , editors , _ tphols _ , volume 5674 of _ lecture notes in computer science _ , pages 7983 .",
    "springer , 2009 .",
    "carsten schrmann and frank pfenning .",
    "a coverage checking algorithm for lf . in david  a. basin and burkhart wolff , editors , _ tphols",
    "_ , volume 2758 of _ lecture notes in computer science _ , pages 120135 .",
    "springer , 2003 .    c.  spenger and m.  dams . on the structure of inductive reasoning : circular and tree - shaped proofs in the @xmath76-calculus . in a.",
    "gordon , editor , _ fossacs03 _ ,",
    "volume 2620 of _ lncs _ , pages 425440 .",
    "springer verlag , 2003 .",
    "alwen tiu . .",
    "phd thesis , pennsylvania state university , may 2004 .",
    "alwen tiu .",
    "a logic for reasoning about generic judgments .",
    ", 174(5):318 , 2007 .",
    "alwen tiu and dale miller .",
    "proof search specifications of bisimulation and modal logics for the @xmath552-calculus .",
    ", 11(2):135 , 2010 .",
    "[ [ essential - cases-1 ] ] essential cases : + + + + + + + + + + + + + + + +    if @xmath224 and @xmath142 are @xmath553{{\\delta_1\\longrightarrow b_1 ' \\land b_1 '' } }        { \\deduce{{\\delta_1\\longrightarrow b_1 ' } }          { \\pi_1 ' }      & \\deduce{{\\delta_1\\longrightarrow b_1 '' } }          { \\pi_1 '' } }        \\qquad\\qquad        \\infer[{\\land{\\cal l}}]{{b_1 ' \\land b_1'',b_2,\\ldots , b_n,\\gamma\\longrightarrow c } }        { \\deduce{{b_1',b_2,\\ldots , b_n,\\gamma\\longrightarrow c } }          { \\pi ' } }        \\enspace , \\ ] ] then @xmath217 reduces to @xmath554 .",
    "the case for the other @xmath555 rule is symmetric .",
    "suppose @xmath224 and @xmath142 are @xmath556{{\\delta_1\\longrightarrow b_1 ' \\lor b_1 '' } }        { \\deduce{{\\delta_1\\longrightarrow b_1 ' } }          { \\pi_1 ' } }        \\quad        \\infer[{\\lor{\\cal l}}]{{b_1 ' \\lor b_1'',b_2,\\ldots , b_n,\\gamma\\longrightarrow c } }        { \\deduce{{b_1',b_2,\\ldots , b_n,\\gamma\\longrightarrow c } }          { \\pi ' }      & \\deduce{{b_1'',b_2,\\ldots , b_n,\\gamma\\longrightarrow c } }          { \\pi''}}\\ ] ] then @xmath217 reduces to @xmath557 .",
    "the case for the other @xmath558 rule is symmetric .",
    "suppose @xmath224 and @xmath142 are @xmath305{{\\delta_1\\longrightarrow b_1 ' { \\supset}b_1 '' } }        { \\deduce{{b_1',\\delta_1\\longrightarrow b_1 '' } }          { \\pi_1 ' } }        \\qquad        \\infer[{{\\supset}{\\cal l}}]{{b_1 ' { \\supset}b_1'',b_2,\\ldots , b_n,\\gamma\\longrightarrow c } }        { \\deduce{{b_2,\\ldots , b_n,\\gamma\\longrightarrow b_1 ' } }          { \\pi ' }      & \\deduce{{b_1'',b_2,\\ldots , b_n,\\gamma\\longrightarrow c } }          { \\pi '' } }        \\enspace\\ ] ] let @xmath559 .",
    "then @xmath217 reduces to @xmath447        { { \\delta_1,\\ldots,\\delta_n,\\gamma\\longrightarrow c } }        {          \\infer[{\\hbox{\\sl mc } } ]          { { \\delta_1,\\ldots,\\delta_n,\\gamma , \\delta_2,\\ldots,\\delta_n,\\gamma\\longrightarrow c } }          {            \\raisebox{-2.5ex}{\\deduce{{\\ldots\\longrightarrow b_1''}}{\\xi_1 } }            &             \\left\\{\\raisebox{-1.5ex}{\\deduce{{\\delta_i\\longrightarrow b_i}}{\\pi_i}}\\right\\}_{i \\in \\{2 .. n\\ } }            & \\raisebox{-2.5ex}{\\deduce{{b_1'',\\{b_i\\}_{i \\in \\{2 .. n\\}},\\gamma\\longrightarrow c}}{\\pi '' } }          }        }        \\enspace\\ ] ]    if @xmath224 and @xmath142 are @xmath71{{\\delta_1\\longrightarrow \\forall x.b_1 ' } }        { \\deduce{{\\delta_1\\longrightarrow b_1'[y / x ] } }          { \\pi_1 ' } }        \\qquad\\qquad\\qquad        \\infer[{\\forall{\\cal l}}]{{\\forall x.b_1',b_2,\\ldots , b_n,\\gamma\\longrightarrow c } }        { \\deduce{{b_1'[t / x],b_2,\\ldots , b_n,\\gamma\\longrightarrow c } }          { \\pi ' } }        \\enspace , \\ ] ] then @xmath217 reduces to @xmath560,\\pi_2,\\ldots,\\pi_n,\\pi'$ ] .    if @xmath224 and @xmath142 are @xmath561{{\\delta_1\\longrightarrow \\exists x.b_1 ' } }        { \\deduce{{\\delta_1\\longrightarrow b_1'[t / x ] } }          { \\pi_1 ' } }        \\qquad\\qquad\\qquad        \\infer[{\\exists{\\cal l}}]{{\\exists x.b_1',b_2,\\ldots ,            b_n,\\gamma\\longrightarrow c } }        { \\deduce{{b_1'[y / x],b_2,\\ldots , b_n ,          \\gamma\\longrightarrow c } }          { \\pi ' } }        \\enspace , \\ ] ] then @xmath217 reduces to @xmath562 $ ] .",
    "suppose @xmath224 and @xmath142 are , respectively , @xmath230 { { \\delta_1\\longrightarrow p\\,\\vec t } } {   \\deduce{{\\delta_1\\longrightarrow d\\,x^p\\,\\vec t}}{\\pi_1 ' } } \\qquad \\infer[{{\\rm i}{\\cal l } } ] { { p\\,\\vec{t } , b_2,\\dots , b_n,\\gamma\\longrightarrow c } } {    \\deduce{{d\\,s\\,\\vec{y}\\longrightarrow s\\,\\vec{y}}}{\\pi_s } &    \\deduce{{s\\,\\vec{t } , b_2,\\dots , b_n , \\gamma\\longrightarrow c}}{\\pi ' } } \\ ] ] where @xmath231 and @xmath37 is a new parameter . then @xmath217 reduces to @xmath232 , \\pi_s[\\vec t/\\vec y ] ) , \\pi_2,\\ldots,\\pi_n,\\pi').\\ ] ]    suppose @xmath224 and @xmath142 are @xmath233   { { \\delta_1\\longrightarrow p\\,\\vec{t } } }   {    \\deduce{{\\delta_1\\longrightarrow s\\,\\vec{t}}}{\\pi_1 ' } &    \\deduce{{s\\,\\vec{y}\\longrightarrow d\\,s\\,\\vec{y}}}{\\pi_s }   }   \\qquad \\qquad \\infer[{{\\rm",
    "ci}{\\cal l } } ]   { { p\\,\\vec{t } , \\dots , \\gamma\\longrightarrow c } } {    \\deduce{{d\\,x^p\\,\\vec{t},\\dots , \\gamma\\longrightarrow c}}{\\pi ' } } \\ ] ] where @xmath413 and @xmath37 is a new parameter .",
    "then @xmath217 reduces to @xmath235 ) , \\pi_2,\\ldots,\\pi_n,\\pi'[(\\pi_s , s)/x^p]).\\ ] ]    suppose @xmath224 and @xmath142 are @xmath225{{\\delta_1\\longrightarrow s = t } }      { }      \\qquad\\qquad\\qquad      \\infer[{{\\rm eq}{\\cal l}}]{{s = t , b_2,\\ldots , b_n,\\gamma\\longrightarrow c } }      { \\left\\{\\raisebox{-1.5ex }          { \\deduce{{b_2\\rho,\\ldots , b_n\\rho,\\gamma\\rho\\longrightarrow c\\rho } }            { \\pi^\\rho } }        \\right\\}_\\rho }      \\enspace\\ ] ] note that in this case , @xmath44 in @xmath142 ranges over all substitution , as any substitution is a unifier of @xmath65 and @xmath47 .",
    "let @xmath226 be the derivation @xmath563 .",
    "then @xmath217 reduces to @xmath228    { { \\delta_1,\\delta_2,\\ldots,\\delta_n,\\gamma\\longrightarrow c } }    { \\deduce{{\\delta_2,\\ldots,\\delta_n,\\gamma\\longrightarrow c}}{\\xi_1}}\\ ] ]    [ [ left - commutative - cases-1 ] ] left - commutative cases : + + + + + + + + + + + + + + + + + + + + + + +    in the following cases , we suppose that @xmath142 ends with a left rule , other than @xmath236 , acting on @xmath237 .",
    "suppose @xmath224 is as below left , where @xmath564 is any left rule except @xmath565 , @xmath64 , or @xmath89 .",
    "let @xmath566 .",
    "then @xmath217 reduces to the derivation given below right .",
    "@xmath567            { { \\delta_1\\longrightarrow b_1 } }            { \\left\\{\\raisebox{-1.5ex}{\\deduce{{\\delta_1^i\\longrightarrow b_1 } }                { \\pi_1^i}}\\right\\}_i            }      \\qquad      \\infer[{\\bullet{\\cal l } } ]            { { \\delta_1,\\delta_2,\\ldots,\\delta_n,\\gamma\\longrightarrow c } }            {              \\left\\ {              \\raisebox{-1.3ex } {                \\deduce{{\\delta_1^i,\\delta_2,\\ldots,\\delta_n,\\gamma\\longrightarrow c}}{\\xi^i }              }              \\right\\}_i            } \\ ] ]",
    "suppose @xmath224 is @xmath483{{d_1 ' { \\supset}d_1'',\\delta_1'\\longrightarrow b_1 } }      { \\deduce{{\\delta_1'\\longrightarrow d_1 ' } }        { \\pi_1 ' }        & \\deduce{{d_1'',\\delta_1'\\longrightarrow b_1 } }        { \\pi_1 '' } }      \\enspace\\ ] ] let @xmath568 .",
    "then @xmath217 reduces to @xmath483      { { d_1 ' { \\supset}d_1'',\\delta_1',\\delta_2,\\ldots,\\delta_n,\\gamma\\longrightarrow c } }      {        \\infer=[{\\hbox{\\sl w}{\\cal l } } ]        { { \\delta_1',\\delta_2,\\ldots,\\delta_n,\\gamma\\longrightarrow d_1 ' } }        { \\deduce{{\\delta_1'\\longrightarrow d_1'}}{\\pi_1 ' } }        &         \\deduce{{d_1'',\\delta_1',\\delta_2,\\ldots,\\delta_n,\\gamma\\longrightarrow c}}{\\xi_1 }      }      \\enspace\\ ] ]    suppose @xmath224 is @xmath238 { { p\\,\\vec{t } , \\delta_1'\\longrightarrow b_1 } } {    \\deduce{{d\\,s\\,\\vec{y}\\longrightarrow s\\,\\vec{y}}}{\\pi_s } &    \\deduce{{s\\,\\vec{t } , \\delta_1'\\longrightarrow b_1}}{\\pi_1 ' } } \\ ] ] where @xmath569 .",
    "let @xmath570 .",
    "then @xmath217 reduces to @xmath238 { { p\\,\\vec{t } , \\delta_1',\\dots,\\delta_n\\longrightarrow c } } {    \\deduce{{d\\,s\\,\\vec{y}\\longrightarrow s\\,\\vec{y}}}{\\pi_s } &    \\deduce{{s\\,\\vec{t } , \\delta_1',\\dots,\\delta_n,\\gamma\\longrightarrow c}}{\\xi_1 } } \\ ] ]    suppose @xmath224 is as below left .",
    "let @xmath571 .",
    "then @xmath217 reduces to the derivation given below right .",
    "@xmath572{{s = t,\\delta_1'\\longrightarrow b_1 } }      { \\left\\{\\raisebox{-1.5ex }          { \\deduce{{\\delta_1'\\rho\\longrightarrow b_1\\rho } }            { \\pi_1^{\\rho } } }        \\right\\ } }      \\qquad      \\infer[{{\\rm eq}{\\cal l}}. ]          { { s = t,\\delta_1',\\delta_2,\\ldots,\\delta_n,\\gamma\\longrightarrow c } }          {            \\left\\ {            \\raisebox{-1.3ex } {            \\deduce{{\\delta_1'\\rho,\\delta_2\\rho,\\ldots,\\delta_n\\rho,\\gamma\\rho\\longrightarrow c\\rho}}{\\xi^\\rho }            }            \\right\\ }          } \\ ] ]    suppose @xmath224 is @xmath573",
    ". then @xmath217 reduces to @xmath574    [ [ right - commutative - cases-1 ] ] right - commutative cases : + + + + + + + + + + + + + + + + + + + + + + + +    suppose @xmath142 is as given below left , where where @xmath575 is any left rule other than @xmath565 , @xmath64 , or @xmath89 acting on a formula other than @xmath576 .",
    "let @xmath577 .",
    "then @xmath217 reduces to the derivation given below right .",
    "@xmath578{{b_1,\\ldots , b_n,\\gamma\\longrightarrow c } }      { \\left\\{\\raisebox{-1.5ex}{\\deduce{{b_1,\\ldots , b_n,\\gamma^i\\longrightarrow c } }            { \\pi^i}}\\right\\}_i }      \\qquad      \\infer[{\\circ{\\cal l } } ]            { { \\delta_1,\\ldots,\\delta_n,\\gamma\\longrightarrow c } }            {              \\left\\ {              \\raisebox{-1.3ex } {                \\deduce{{\\delta_1,\\ldots,\\delta_n,\\gamma^i\\longrightarrow c}}{\\xi^i }              }              \\right\\}_i            } \\ ] ]    suppose @xmath142 is @xmath483{{b_1,\\ldots , b_n , d ' { \\supset}d'',\\gamma'\\longrightarrow c } }      { \\deduce{{b_1,\\ldots , b_n,\\gamma'\\longrightarrow d ' } }        { \\pi ' }        & \\deduce{{b_1,\\ldots , b_n , d'',\\gamma'\\longrightarrow c } }        { \\pi '' } }      \\enspace\\ ] ] let @xmath579 and let @xmath580",
    ". then @xmath217 reduces to @xmath483{{\\delta_1,\\ldots,\\delta_n , d ' { \\supset}d'',\\gamma'\\longrightarrow c } }      { \\deduce{{\\delta_1,\\ldots,\\delta_n,\\gamma'\\longrightarrow d ' } }        { \\xi_1 }        & \\deduce{{\\delta_1,\\ldots,\\delta_n , d'',\\gamma'\\longrightarrow c } }        { \\xi_2 } }      \\enspace\\ ] ]    suppose @xmath142 is @xmath238 { { b_1,\\dots , b_n , p\\,\\vec{t},\\gamma'\\longrightarrow c } } {    \\deduce{{d\\,s\\,\\vec{y}\\longrightarrow s\\,\\vec{y}}}{\\pi_s } &    \\deduce{{b_1,\\dots , b_n , s\\,\\vec{t } , \\gamma'\\longrightarrow c}}{\\pi ' } } \\enspace , \\ ] ] where @xmath569 .",
    "let @xmath242 .",
    "then @xmath217 reduces to @xmath238 { { \\delta_1,\\dots,\\delta_n , p\\,\\vec{t},\\gamma'\\longrightarrow c } } {    \\deduce{{d\\,s\\,\\vec{y}\\longrightarrow s\\,\\vec{y}}}{\\pi_s } &    \\deduce{{\\delta_1,\\dots,\\delta_n , s\\,\\vec{t } , \\gamma'\\longrightarrow c}}{\\xi_1 } } \\enspace\\ ] ]    suppose @xmath142 is as shown below left .",
    "let @xmath581 .",
    "then @xmath217 reduces to the derivation below right .",
    "@xmath5{{b_1,\\ldots , b_n , s = t,\\gamma'\\longrightarrow c } }      { \\left\\{\\raisebox{-1.5ex }          { \\deduce{{b_1\\rho,\\ldots , b_n\\rho,\\gamma'\\rho\\longrightarrow c\\rho } }            { \\pi^{\\rho}}}\\right\\ } }      \\qquad      \\infer[{{\\rm eq}{\\cal l } } ]      { { \\delta_1,\\ldots,\\delta_n , s = t,\\gamma'\\longrightarrow c } }      {        \\left\\ {        \\raisebox{-1.3ex }        {          \\deduce{{\\delta_1\\rho,\\ldots,\\delta_n\\rho,\\gamma'\\rho\\longrightarrow c\\rho}}{\\xi^\\rho }        }        \\right\\ }      } \\ ] ]    if @xmath582 then @xmath217 reduces to @xmath583 .    if @xmath142 is as below left , where where @xmath584 is any right rule except @xmath90 , then @xmath217 reduces to the derivation below right , where @xmath577 .",
    "@xmath585{{b_1,\\ldots , b_n,\\gamma\\longrightarrow c } }      { \\left\\{\\raisebox{-1.5ex } {            \\deduce{{b_1,\\ldots , b_n,\\gamma^i\\longrightarrow c^i } }            { \\pi^i}}\\right\\}_i }      \\qquad      \\infer[{\\circ{\\cal r } } ]            { { \\delta_1,\\ldots,\\delta_n,\\gamma\\longrightarrow c } }            {              \\left\\ {              \\raisebox{-1.3ex } {                \\deduce{{\\delta_1,\\ldots,\\delta_n,\\gamma^i\\longrightarrow c^i}}{\\xi^i }                }              \\right\\}_i            } \\ ] ]    suppose @xmath142 is @xmath233 { { b_1,\\dots , b_n,\\gamma\\longrightarrow p\\,\\vec{t } } } {    \\deduce{{b_1,\\dots , b_n,\\gamma\\longrightarrow s\\,\\vec{t}}}{\\pi ' } &    \\deduce{{s\\,\\vec{y}\\longrightarrow d\\,s\\,\\vec{y}}}{\\pi_s } } \\enspace , \\ ] ] where @xmath540 .",
    "let @xmath242 .",
    "then @xmath217 reduces to @xmath233 { { \\delta_1,\\dots,\\delta_n,\\gamma\\longrightarrow p\\,\\vec{t } } } {    \\deduce{{\\delta_1,\\dots,\\delta_n,\\gamma\\longrightarrow s\\,\\vec{t}}}{\\xi_1 } &    \\deduce{{s\\,\\vec{y}\\longrightarrow d\\,s\\,\\vec{y}}}{\\pi_s } } \\enspace\\ ] ]    [ [ multicut - cases ] ] multicut cases : + + + + + + + + + + + + + + +    if @xmath142 ends with a left rule , other than @xmath436 and @xmath229 , acting on @xmath237 and @xmath224 ends with a multicut and reduces to @xmath484 , then @xmath217 reduces to @xmath586 .",
    "suppose @xmath142 is @xmath206{{b_1,\\ldots , b_n,\\gamma^1,\\ldots,\\gamma^m,\\gamma'\\longrightarrow c } }      { \\left\\{\\raisebox{-1.5ex}{\\deduce{{\\{b_i\\}_{i \\in i^j},\\gamma^j\\longrightarrow d^j } }            { \\pi^j}}\\right\\}_{j \\in \\{1 .. m\\ } }        & \\raisebox{-2.5ex}{\\deduce{{\\{d^j\\}_{j \\in \\{1 .. m\\}},\\{b_i\\}_{i \\in i'},\\gamma'\\longrightarrow c } }          { \\pi ' } } }      \\enspace , \\ ] ] where @xmath587 partition the formulas @xmath588 among the premise derivations @xmath224 , ",
    ", @xmath589,@xmath243 .",
    "for @xmath590 let @xmath591 be @xmath206{{\\{\\delta_i\\}_{i \\in i^j},\\gamma^j\\longrightarrow d^j } }      { \\left\\{\\raisebox{-1.5ex}{\\deduce{{\\delta_i\\longrightarrow b_i } }            { \\pi_i}}\\right\\}_{i \\in i^j }        & \\raisebox{-2.5ex}{\\deduce{{\\{b_i\\}_{i \\in i^j},\\gamma^j\\longrightarrow d^j } }          { \\pi^j } } }      \\enspace\\ ] ] then @xmath217 reduces to @xmath206{{\\delta_1,\\ldots,\\delta_n,\\gamma^1,\\ldots\\gamma^m,\\gamma'\\longrightarrow c } }      { \\left\\{\\raisebox{-1.5ex}{\\deduce{{\\ldots\\longrightarrow d^j } }            { \\xi^j}}\\right\\}_{j \\in \\{1 .. m\\ } }        & \\left\\{\\raisebox{-1.5ex}{\\deduce{{\\delta_i\\longrightarrow b_i } }            { \\pi_i}}\\right\\}_{i \\in i ' }        & \\raisebox{-2.5ex}{\\deduce{{\\ldots\\longrightarrow c } }          { \\pi ' } } }      \\enspace\\ ] ]    [ [ structural - cases ] ] structural cases : + + + + + + + + + + + + + + + + +    if @xmath142 is as shown below left , then @xmath217 reduces to the derivation shown below right , where @xmath592 .",
    "@xmath593{{b_1,b_2,\\ldots , b_n,\\gamma\\longrightarrow c } }      { \\deduce{{b_1,b_1,b_2,\\ldots , b_n,\\gamma\\longrightarrow c } }        { \\pi ' } }      \\qquad      \\infer=[{\\hbox{\\sl",
    "c}{\\cal l } } ]      { { \\delta_1,\\delta_2,\\ldots,\\delta_n,\\gamma\\longrightarrow c } }      {        \\deduce{{\\delta_1,\\delta_1,\\delta_2,\\ldots,\\delta_n,\\delta_n,\\gamma\\longrightarrow c}}{\\xi_1 }      } \\ ] ]    if @xmath142 is as shown below left , then @xmath217 reduces to the derivation shown below right , where @xmath594 .",
    "@xmath595{{b_1,b_2,\\ldots , b_n,\\gamma\\longrightarrow c } }      { \\deduce{{b_2,\\ldots , b_n,\\gamma\\longrightarrow c } }        { \\pi ' } }      \\qquad      \\infer[{\\hbox{\\sl",
    "w}{\\cal l } } ]      { { \\delta_1,\\delta_2,\\ldots,\\delta_n,\\gamma\\longrightarrow c } }      {        \\deduce{{\\delta_2,\\ldots,\\delta_n,\\gamma\\longrightarrow c}}{\\xi_1 }      } \\ ] ]    [ [ axiom - cases ] ] axiom cases : + + + + + + + + + + + +    suppose @xmath142 ends with a left - rule acting on @xmath237 and @xmath224 ends with the @xmath222 rule",
    ". then it must be the case that @xmath596 and @xmath217 reduces to @xmath597 .",
    "if @xmath142 ends with the @xmath222 rule , then @xmath598 , @xmath52 is the empty multiset , and @xmath51 must be a cut formula , i.e. , @xmath599 .",
    "therefore @xmath217 reduces to @xmath224 .",
    "lm : reduct_subst let @xmath142 be a derivation ending with a @xmath59 and let @xmath43 be a substitution . if @xmath149 reduces to @xmath217 then there exists a derivation @xmath243 such that @xmath244 and @xmath142 reduces to @xmath243 .",
    "observe that the redexes of a derivation are not affected by eigenvariable substitution , since the cut reduction rules are determined by the last rules of the premise derivations , which are not changed by substitution .",
    "therefore , any cut reduction rule that is applied to @xmath149 to get @xmath217 can also be applied to @xmath142 .",
    "suppose that @xmath243 is the reduct of @xmath142 obtained this way .",
    "in all cases , except for the cases where the reduction rule applied is either @xmath600 , @xmath601 , or those involving @xmath64 , it is a matter of routine to check that @xmath602 . for the reduction rules @xmath600 and @xmath601 , we need lemma  [ lm : param subst ] which shows that eigenvariable substitution commutes with parameter substitution . we show here the case involving @xmath64 .",
    "the only interesting case is the reduction @xmath603 . for simplicity",
    ", we show the case where @xmath142 ends with @xmath62 with three premises ; it is straightforward to adapt the following analysis to the more general case .",
    "so suppose @xmath142 is the derivation : @xmath107 { { \\delta_1 , \\delta_2 , \\gamma\\longrightarrow c } } { \\infer[{{\\rm eq}{\\cal r } } ] { { \\delta_1\\longrightarrow t = t } } { } & \\deduce{{\\delta_2\\longrightarrow b}}{\\pi_2 } &   \\infer[{{\\rm eq}{\\cal l } } ] { { t = t , b , \\gamma\\longrightarrow c } } { \\left\\ { \\raisebox{-1.5ex } { \\deduce{{b\\rho , \\gamma\\rho\\longrightarrow c\\rho}}{\\pi^\\rho } } \\right\\}_\\rho } } \\ ] ] according to definition  [ def : subst ] , the derivation @xmath149 is @xmath107 { { \\delta_1\\theta,\\delta_2\\theta , \\gamma\\theta\\longrightarrow c\\theta } } { \\infer[{{\\rm eq}{\\cal r } } ] { { \\delta_1\\theta\\longrightarrow t\\theta = t\\theta } } { } &   \\deduce{{\\delta_2\\theta\\longrightarrow b\\theta}}{\\pi_2\\theta } & \\infer[{{\\rm eq}{\\cal l } } ] { { t\\theta = t\\theta , b\\theta , \\gamma\\theta\\longrightarrow c\\theta } } { \\left\\ { \\raisebox{-1.5ex } { \\deduce{{b\\theta\\rho ' , \\gamma\\theta\\rho'\\longrightarrow c\\theta\\rho'}}{\\pi^{(\\theta\\circ \\rho ' ) } } } \\right\\}_{\\rho ' } } } \\ ] ] let @xmath604 .",
    "the reduct of @xmath149 in this case ( modulo the different order in which the weakening steps are applied ) is : @xmath228 { { \\delta_1\\theta , \\delta_2\\theta , \\gamma\\theta\\longrightarrow c\\theta } } { \\deduce{{\\delta_2\\theta,\\gamma\\theta\\longrightarrow c\\theta}}{\\psi } } \\ ] ] let us call this derivation @xmath217 .",
    "let @xmath605 .",
    "the above reduct can be matched by the following reduct of @xmath142 ( using the same order of applications of the weakening steps ) : @xmath228 { { \\delta_1 , \\delta_2 , \\gamma\\longrightarrow c } } { \\deduce{{\\delta_2,\\gamma\\longrightarrow c}}{\\psi ' } } \\ ] ] let us call this derivation @xmath243 . by definition  [ def : subst ] , we have @xmath606 , and obviously , also @xmath244 .      by case analysis on @xmath51 . if @xmath297 for some @xmath298 and @xmath299 then @xmath266 , where @xmath301 , hence it is normalizable by definition  [ def : candidates ] ( specifically , condition * cr1 * ) .",
    "otherwise , @xmath142 is normalizable by definition  [ def : param red ] .",
    "suppose @xmath608 , for some @xmath298 and some @xmath609 , and suppose @xmath610 . then @xmath266 by definition  [ def : param red ] . by definition  [ def : candidates ] ( * cr0 * ) we also have @xmath611 .",
    "otherwise , suppose @xmath612",
    ". then @xmath613 by definition  [ def : param red ] . by lemma  [ lm : subst - norm ]",
    ", we have @xmath614 , therefore @xmath334 $ ] .    otherwise , @xmath615 for any @xmath298 and any parameter @xmath616 . in this case , to apply the inner induction hypothesis , we need to show that @xmath617 is normalizable , which follows immediately from lemma  [ lm : red - norm ] and lemma  [ lm : subst - norm ] .",
    "we distinguish several cases based on the last rule of @xmath142 :    * suppose @xmath142 ends with @xmath62 , i.e. , @xmath618 for some @xmath619 and @xmath243 . by lemma  [ lm : reduct_subst ] ,",
    "every reduct of @xmath617 , say @xmath217 , is the result of applying @xmath44 to a reduct of @xmath142 . by the inner induction hypothesis ( on the normalization degree )",
    ", every reduct of @xmath617 is in @xmath620 $ ] , and therefore @xmath617 is also in @xmath620 $ ] by definition  [ def : param red ] ( * p2 * ) .",
    "* suppose @xmath142 ends with @xmath303 , with the premise derivation @xmath243 . in this case ,",
    "@xmath304 for some @xmath54 and @xmath621 .",
    "since @xmath333 $ ] , we have that ( * p3 * ) @xmath622 \\rightarrow \\red_{d\\theta}[\\omega])\\ ] ] for every @xmath43 .",
    "we need to show that @xmath623 \\rightarrow \\red_{d\\rho\\delta}[\\omega])$ ] for every @xmath198 .",
    "note that by lemma  [ lm : subst - drv - comp ] , @xmath624 , so this is just an instance of statement  [ eq : param1 ] above .",
    "* @xmath142 ends with @xmath104 or @xmath90 : this follows from definition  [ def : param red ] and the fact that reducibility candidates are closed under substitution ( condition * cr0 * in definition  [ def : candidates ] ) . in the case where @xmath142 ends with @xmath104",
    ", we also need the fact that eigenvariable substitution commutes with parameter substitution ( lemma  [ lm : param subst commutes ] ) . in the case where @xmath142 ends with @xmath90 , to establish @xmath334 $ ]",
    ", we can use the same reducibility candidate which is used to establish @xmath333 $ ] .",
    "* @xmath142 ends with a rule other than @xmath62 , @xmath303 , @xmath104 or @xmath90 : this case follows straightforwardly from the induction hypothesis .",
    "suppose @xmath625 for some @xmath349 and suppose @xmath626 . since @xmath336 , this means that @xmath627 and @xmath628 .",
    "then obviously , @xmath333 $ ] iff @xmath337 $ ] . if @xmath385 , then obviously @xmath300 = \\nm_{y^q}\\,\\vec u = \\red_c[\\omega']$ ] .",
    "otherwise , suppose @xmath629 , and @xmath333 $ ] .",
    "the latter implies that @xmath142 is normalizable .",
    "we show , by induction on @xmath247 that @xmath337 $ ] . in most cases , this follows straightforwardly from the induction hypothesis .",
    "we show the interesting cases here :    * suppose @xmath142 ends with @xmath303 , i.e. , @xmath304 for some @xmath54 and @xmath621 and @xmath142 is of the form : @xmath305 { { \\gamma\\longrightarrow b\\omega { \\supset}d\\omega } } {   \\deduce{{\\gamma , b\\omega\\longrightarrow d\\omega}}{\\pi ' } } \\ ] ] note that since @xmath336 , we have that @xmath630 and @xmath631 . since @xmath333 $ ] , we have @xmath632 \\rightarrow \\red_{d\\rho}[\\omega])\\ ] ] for every @xmath44 .",
    "since @xmath633 and @xmath634 , by the ( outer ) induction hypothesis , we have @xmath318 = \\red_{b\\rho}[\\omega']$ ] and @xmath635 = \\red_{d\\rho}[\\omega']$ ] .",
    "therefore , we also have that @xmath636 \\rightarrow \\red_{d\\rho}[\\omega'])\\ ] ] for every @xmath44 .",
    "this means , by definition  [ def : param red ] , that @xmath637 $ ] .",
    "* suppose @xmath142 ends with @xmath104 : @xmath230 { { \\gamma\\longrightarrow q\\,\\vec t } } { \\deduce{{\\gamma\\longrightarrow d\\,y^q\\,\\vec t}}{\\pi'}}\\ ] ] where @xmath638 and @xmath639 is a new parameter .",
    "since we identify derivations which differ only in the choice of internal variables and parameters , we can assume without loss of generality that @xmath640 .",
    "note that since the body of a definition can not contain occurrences of parameters , we also have @xmath641 .",
    "suppose @xmath257 is a reducibility candidate of type @xmath146 , for some closed term @xmath146 of the same syntactic type as @xmath88 , and suppose @xmath310 is a normalizable derivation of @xmath642 such that @xmath643 \\in ( \\red_{(d\\,y^q\\,\\vec u)}[\\omega ' , ( \\sscr,\\pi_i , i)/y^q ] \\rightarrow \\sscr \\,\\vec u)\\ ] ] for every @xmath298 of the appropriate types . to show that @xmath637 $ ] we need to show that @xmath644 , \\pi_i[\\vec t/ \\vec y ] ) \\in \\sscr\\,\\vec t\\ ] ] + since @xmath645 by lemma  [ lm : level ] , we have , by the outer induction hypothesis , @xmath646   = \\red_{(d\\,y^q\\,\\vec u)}[\\omega , ( \\sscr,\\pi_i , i)/y^q]\\ ] ] hence , by statement  [ eq : vac1 ]",
    ", we also have @xmath647 \\in ( \\red_{(d\\,y^q\\,\\vec u)}[\\omega , ( \\sscr,\\pi_i , i)/y^q ] \\rightarrow \\sscr \\,\\vec u)\\ ] ] for arbitrary @xmath298 .",
    "now since @xmath648 $ ] ( from the assumption ) , this means that @xmath644 , \\pi_i[\\vec t/ \\vec y ] ) \\in \\sscr\\,\\vec t\\ ] ] and therefore @xmath142 is indeed in @xmath480 $ ] .",
    "* suppose @xmath142 ends with @xmath90 : @xmath233 { { \\gamma\\longrightarrow q\\,\\vec t } } {    \\deduce{{\\gamma\\longrightarrow i\\,\\vec t}}{\\pi ' }    &    \\deduce    { { i\\,\\vec y\\longrightarrow b\\,i\\,\\vec y } }    { \\pi_i } } \\ ] ] where @xmath649 .",
    "since @xmath333 $ ] , by definition  [ def : param red ] ( * p4 * ) , there exist a parameter @xmath639 such that @xmath640 and a reducibility candidate @xmath309 such that @xmath315 and @xmath650 \\in ( \\sscr\\,\\vec u \\rightarrow   \\red_{b\\,y^q\\,\\vec u}[\\omega , ( \\sscr,\\pi_i , i)/y^q])\\ ] ] for every @xmath298 . to show @xmath337 $ ] we need to find a reducibility candidate satisfying * p4*. we simply use @xmath257 as that candidate .",
    "it remains to show that @xmath651 \\in ( \\sscr\\,\\vec u \\rightarrow   \\red_{b\\,y^q\\,\\vec u}[\\omega ' , ( \\sscr,\\pi_i , i)/y^q])\\ ] ] this follows from statement ( [ eq : vac2 ] ) above and the outer induction hypothesis , since @xmath652 = \\red_{b\\,y^q\\,\\vec u}[\\omega ' , ( \\sscr,\\pi_i , i)/y^q]\\ ] ]    the converse , i.e. , @xmath337 $ ] implies @xmath333 $ ] , can be proved analogously . in particular , in the case where @xmath142 ends with @xmath90 , we rely on the fact that the choice of the new parameter @xmath639 is immaterial , as long as it is new , so we can assume without loss of generality that @xmath653 .",
    "lm : red candidate let @xmath279 be a candidate substitution and @xmath254 a closed term of type @xmath338 . then the set @xmath654 \\ \\hbox{for some    $ \\vec u$ } \\ }   $ ] is a reducibility candidate of type @xmath340 .",
    "suppose @xmath655 for some @xmath299 and suppose @xmath656 .",
    "then in this case , we have @xmath657 , so @xmath265 is a reducibility candidate of type @xmath254 by assumption . if @xmath655 but @xmath369 then in this case @xmath658 , and by lemma  [ lm : norm red ] , @xmath265 is also a reducibility candidate .",
    "otherwise , @xmath659 for any parameter @xmath37 .",
    "we need to show that @xmath265 satisfies * cr0 * - * cr5*. * cr0 * follows from lemma  [ lm : red - subst ] .",
    "* cr1 * follows from lemma  [ lm : red - norm ] , and the rest follow from definition  [ def : param red ] .",
    "lm : red param subst let @xmath279 be a candidate substitution and let @xmath37 be a parameter such that @xmath308 .",
    "let @xmath93 be a closed term of the same type as @xmath35 and let @xmath341 \\ \\hbox{for some $ \\vec u$ } \\}.\\ ] ] suppose @xmath342 $ ] is a candidate substitution , for some @xmath343 .",
    "then @xmath344}[\\omega ] = \\red_c[\\omega , ( \\rscr , \\psi , s\\omega)/x^p].\\ ] ]    by induction on @xmath607 .",
    "if @xmath660 , then @xmath661 = \\rscr\\,\\vec u = \\red_{s\\,\\vec u}[\\omega]\\ ] ] by assumption .",
    "the other cases where @xmath51 is @xmath384 for some parameter @xmath653 are straightforward .",
    "so suppose @xmath629 for any @xmath298 and any parameter @xmath639 . we show that for every @xmath142 , @xmath662}[\\omega]$ ] iff @xmath663 $ ] . note that",
    "if @xmath37 does not occur in @xmath51 then @xmath664 = c$ ] , and by lemma  [ lm : red vacuous ] we have @xmath344}[\\omega ] = \\red_c[\\omega]=\\red_c[\\omega , ( \\rscr , \\psi , s\\omega)/x^p].\\ ] ] so assume that @xmath37 is not vacuous in @xmath51 .",
    "let @xmath665 $ ] .",
    "* suppose @xmath662}[\\omega]$ ] .",
    "then @xmath142 is normalizable .",
    "we show , by induction on @xmath247 , that @xmath337 $ ] .",
    "most cases follow immediately from the induction hypothesis .",
    "the only interesting case is when @xmath142 ends with @xmath303 , where @xmath304 , for some @xmath54 and @xmath621 , and @xmath142 takes the form : @xmath305 { { \\gamma\\longrightarrow b[s / x^p]\\omega { \\supset}d[s / x^p]\\omega } } {    \\deduce{{\\gamma , b[s / x^p]\\omega\\longrightarrow d[s / x^p]\\omega}}{\\pi ' } } \\ ] ] since @xmath662}[\\omega]$ ] , we have that @xmath666\\rho}[\\omega ] \\rightarrow \\red_{d[s / x^p]\\rho}[\\omega])\\ ] ] for every @xmath44 . by the outer induction hypothesis ( on the size of @xmath51 )",
    ", we have @xmath636 \\rightarrow \\red_{d\\rho}[\\omega'])\\ ] ] hence @xmath667 $ ] . * the converse , i.e. , @xmath337 $ ] implies @xmath662}[\\omega]$ ] , can be proved analogously ."
  ],
  "abstract_text": [
    "<S> proof search has been used to specify a wide range of computation systems . in order to build a framework for reasoning about such specifications , </S>",
    "<S> we make use of a sequent calculus involving induction and co - induction . </S>",
    "<S> these proof principles are based on a proof theoretic ( rather than set - theoretic ) notion of _ definition _  </S>",
    "<S> @xcite . </S>",
    "<S> definitions are akin to logic programs , where the left and right rules for defined atoms allow one to view theories as `` closed '' or defining fixed points . </S>",
    "<S> the use of definitions and free equality makes it possible to reason intentionally about syntax . </S>",
    "<S> we add in a consistent way rules for pre and post fixed points , thus allowing the user to reason inductively and co - inductively about properties of computational system making full use of higher - order abstract syntax . </S>",
    "<S> consistency is guaranteed via cut - elimination , where we give the first , to our knowledge , cut - elimination procedure in the presence of general inductive and co - inductive definitions .    </S>",
    "<S> logical frameworks,(co)-induction , higher - order abstract syntax , cut - elimination , parametric reducibility . </S>"
  ]
}