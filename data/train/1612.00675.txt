{
  "article_text": [
    "we deal in this paper with algorithmic and complexity of _ enumeration _ , the task of generating all solutions of a problem instance . over the last 15 years , in both practice and theory",
    ", one can observe a growing interest in studying enumeration problems which have previously been poorly studied compared to decision , optimization and counting problems .",
    "the main reason for this may lie in the huge increase of the size of the data computers are nowadays demanded and able to process in everyday applications .",
    "it is in the meanwhile commonly agreed to consider an enumeration algorithm _",
    "efficient _ if it has _ polynomial delay _ ( @xcite ) , , the time passing between outputs of two successive solutions is polynomial in the input size ( while the total time of the output process is usually exponential , due to large solution sets ) . variants and different degrees of efficiency in this context exist , see e.g. @xcite . known reductions for enumeration are essentially one - to - one parsimonious reductions , as opposed to counting complexity where a greater variety of useful reductions exist , see e.g. @xcite",
    ". an interesting issue of enumeration is the order in which the solutions are output .",
    "imposing different orders for an enumeration process may drastically change the complexity , see e.g. @xcite .",
    "we focus in this paper on the task of enumerating the models of a propositional formula .",
    "this task has already been addressed in the context of boolean constraint satisfaction problems ( csps ) .",
    "one considers here formul in generalized conjunctive normal form @xcite , also called _ @xmath3-formul _",
    "where @xmath3 is the _ constraint language_. in @xcite this task , @xmath4 for short , has been studied without imposing any special order .",
    "there is a polynomial delay algorithm if and only if the underlying constraint language @xmath3 is either horn , or dual horn , or affine , or 2cnf , unless @xmath5 .",
    "it is worth mentioning that the algorithms underlying this result are all straight forward extensions of the corresponding decision procedures via the notion of _ self - reducibility _",
    "@xcite which naturally leads to lexicographic order . in the non - boolean domain",
    "the self - reducible fragment does not deliver all tractable cases anymore @xcite and things get much more involved .    back to the boolean domain ,",
    "@xmath4 has also been considered imposing the order of non - decreasing weight ( @xmath6 for short ) , the weight of a model being the number of variables assigned to 1 .",
    "the weight is a natural parameter in boolean csps that can be assimilated to the cost of an assignment .",
    "hence , the task @xmath6 can be seen as the task of enumerating the cheapest solutions first , then the more expensive ones in order of increasing cost . in @xcite",
    "the task @xmath6 has been studied for @xmath3-formul .",
    "there is a polynomial delay algorithm to enumerate the models of a propositional @xmath3-formula by order of non - decreasing weight if and only if @xmath3 is width-2-affine or horn , unless @xmath5 . by duality in that context ,",
    "the task of enumerating by order of non - increasing weight , @xmath7 for short , is tractable if and only if @xmath3 is width-2-affine or dual horn .    in this paper",
    "we reveal new tractable fragments of propositional logic for @xmath6 and @xmath7 by considering fragments of propositional logic by a different approach .",
    "@xmath0-formula _ is a propositional formula whose connectives are taken from @xmath0 , a fixed set of boolean functions .",
    "this approach covers different fragments than the classical constraint approach , e.g. monotonic , self - dual , 0-separating of degree @xmath8 .",
    "it has first been taken by lewis @xcite who showed that the satisfiability problem for @xmath0-formul , @xmath9 for short , is @xmath10-complete if and only if the set @xmath0 is able to express negation of implication ( @xmath11 ) , unless @xmath5 . since then",
    ", a number of problems dealing with propositional formul have been parameterized by @xmath0-formul in order to get a finer classification of their complexity , e.g. equivalence @xcite , implication @xcite , circumscription @xcite , abduction @xcite .",
    "in @xcite the model enumeration problem has been studied in the context of @xmath0-circuits without imposing an order and imposing lexicographic order .",
    "roughly speaking , a @xmath0-formula can be represented by a @xmath0-circuit without size - increase , but , in general , not vice versa .",
    "therefore , tractability translates from @xmath0-circuits to @xmath0-formul , whereas this does not automatically hold for hardness results .",
    "we observe however that only slight modifications in the hardness proof from @xcite suffice and one obtains the same classification for @xmath0-formul .",
    "our main contribution lies in complete classifications for @xmath6 and @xmath7 .",
    "we show that the models of a @xmath0-formula can efficiently be enumerated by order of non - decreasing weight if and only if the connectives are either 0-separating , or affine , or conjunctive , or disjunctive , unless @xmath5 .",
    "we further show that we can efficiently enumerate by order of non - increasing weight if and only if the connectives are either 0-separating of degree 2 , or monotone , or affine , unless @xmath5 .",
    "we also consider the weighted variants of @xmath6 and @xmath7 ( denoted @xmath12 and @xmath13 , respectively ) where a weight function @xmath14 assigns a non - negative integer weight to each variable and the weight of an assignment is the sum of the weights of the variables assigned to @xmath15 .",
    "we show that for @xmath12 the previously tractable fragment of 0-separating connectives now compounds intractable cases .",
    "we also shed new light on the optimization problems known as @xmath1 and @xmath2 where the task is to find a model of minimal / maximal weight .",
    "we use these tasks , together with their weighted and non - trivial variants , to obtain hardness of the enumeration problems .",
    "these two tasks are in our setting not `` the same '' : contrary to the classical constraint setting @xcite , no duality notion allows to easily derive the classification for @xmath2 from the one for @xmath1 , or vice versa .",
    "this is because the duality notion in our setting transforms @xmath1 ( find a satisfying assignment with minimal number of 1 s ) into the task of finding a non - satisfying assignment with maximal number of 1 s .",
    "we show further that allowing weights on the variables renders previously tractable fragments intractable , contrarily to the classical constraint approach .    among the algorithmic enumeration strategies we use , we apply a method we shall call _ priority queue method_. it has first been used in @xcite in order to enumerate all maximal independent sets of a graph in lexicographical order .",
    "this method turned out to be applicable in much more generality @xcite .",
    "we use it to obtain various polynomial delay algorithms for @xmath6 and @xmath7 and their weighted variants .",
    "we give another non - trivial enumeration algorithm for @xmath7 for the fragment of connectives that are 0-separating of degree 2 ( proposition  [ prop : enumsatdec - s02-indelayp ] ) that may be intuitively best described by _ nested _ or _",
    "incremental bruteforce _ : we use the erds - ko - rado theorem @xcite to obtain a combinatorial bound that allows us to _ buy time _",
    "@xcite from a relatively large number of models whose output process delivers then enough time to compute further , computationally more involving models that are stored and output afterwards .",
    "the paper is organized as follows . in section 2",
    "we give the necessary preliminaries on complexity theory , propositional formul and clones of boolean functions . in section 3",
    "we briefly look at model enumeration without order prescription .",
    "we treat the order of non - decreasing and non - increasing weight in sections 4 and 5 respectively .",
    "we conclude in section 6 .",
    "for the decision problems the arising complexity degrees encompass the classes @xmath16 and @xmath10 . for our hardness results we employ logspace many - one reductions .    an _ enumeration problem _",
    "@xmath17 can be formalized by a triple @xmath18 , where @xmath19 are the instances , @xmath20 is a function mapping each instance @xmath21 to its set of solutions @xmath22 and @xmath23 is a partial order ( possibly empty ) on the solution space .",
    "we say that an algorithm @xmath24 solves an enumeration problem @xmath25 if for a given input @xmath21 , @xmath24 generates one by one the elements of @xmath22 without repetition such that for all @xmath26 such that @xmath27 , @xmath24 outputs @xmath28 before @xmath29 .",
    "an enumeration algorithm runs in _ polynomial delay _",
    "if the delay until the first solution is output and thereafter the delay between any two consecutive solutions is bounded by a polynomial @xmath30 in the input size @xmath8 .",
    "we denote _ delayp _ the class of enumeration problems that admit a polynomial delay algorithm and _ spacedelayp _ those problems in @xmath31 that are solvable within polynomial space .      we assume familiarity with propositional logic . for a propositional formula @xmath32",
    "we denote by @xmath33 the set of variables occurring in @xmath32 .",
    "we represent an assignment @xmath34 usually as a tuple over @xmath35 or when convenient by the set of variables assigned to @xmath15 , , the empty set corresponds to @xmath36 and @xmath33 to @xmath37 .",
    "a _ model _ for a formula @xmath32 is an assignment that satisfies @xmath32 .",
    "non - trivial _ assignment is an assignment different from @xmath36 and @xmath37 .",
    "the _ complement _ of an assignment @xmath38 is defined as @xmath39 .",
    "we call a variable @xmath40 _ fictive _ , if the assignment @xmath41 can be extended to a model of @xmath32 if and only if so can the assignment @xmath42 .",
    "we denote by @xmath43 $ ] the formula obtained from @xmath32 by replacing all occurrences of @xmath44 with @xmath45 .",
    "a _ boolean function _ is an @xmath8-ary function @xmath46 . for technical reasons we consider only boolean functions of arity @xmath47 .",
    "it is not difficult but just technical to include also functions of arity @xmath48 into our considerations .",
    "we denote the @xmath8-ary boolean constants by @xmath49 and @xmath50 , respectively .",
    "when the arity is not relevant , we indicate them also by @xmath51 and @xmath52 , keeping in mind that they have at least one fictive coordinate .",
    "an @xmath8-ary assignment @xmath53 such that @xmath54 will be called _ model _ of @xmath55 .",
    "clone _ is a set of boolean functions that is closed under superposition , , it contains all projections ( that is , the functions @xmath56 for all @xmath57 and @xmath58 ) and is closed under arbitrary composition .",
    "let @xmath0 be a finite set of boolean functions .",
    "we denote by @xmath59 $ ] the smallest clone containing @xmath0 and call @xmath0 a _ base _ for @xmath59 $ ] . in 1941 post identified the set of all clones of boolean functions @xcite .",
    "he gave a finite base for each of the clones and showed that they form a lattice under the usual @xmath60-relation , hence the name _",
    "post s lattice _",
    "e.g. _ , figure  [ fig : complexity ] ) . to define the clones we introduce the following notions , where @xmath55 is an @xmath8-ary boolean function :    *",
    "@xmath55 is _ @xmath61-reproducing _ if @xmath62 , @xmath63 .",
    "* @xmath55 is _ monotonic _ if @xmath64 implies @xmath65 .",
    "* @xmath55 is _ @xmath61-separating of degree @xmath66 _ if for all @xmath67 of size @xmath68 there exists an @xmath69 such that @xmath70 implies @xmath71 , @xmath63 .",
    "* @xmath55 is _ @xmath61-separating _ if @xmath55 is @xmath61-separating of degree @xmath72 .",
    "* @xmath55 is _ self - dual _ if @xmath73 , where @xmath74 .",
    "* @xmath55 is _ affine _ if @xmath75 with @xmath63 .",
    "a list of some clones with definitions and finite bases is given in table  [ tab : clones ] .",
    "we will often add some function @xmath76 to a clone @xmath77 and consider the clone @xmath78 $ ] generated out of @xmath77 and @xmath55 . with post s lattice one can determine this @xmath79 quite easily : it is the lowest clone above @xmath77 that contains @xmath55",
    ". we will use in particular the identities @xmath80 = \\clones_1 $ ] , @xmath81 = \\clonebf$ ] , @xmath82 = \\clonebf$ ] , @xmath83 = \\cloner_1 $ ] , and @xmath84 = \\clonem_1 $ ] .",
    "a propositional formula using only connectives from @xmath0 is called a _",
    "@xmath0-formula_.    let @xmath55 be an @xmath8-ary boolean function and let @xmath0 be a set of boolean functions .",
    "a @xmath0-formula @xmath32 with @xmath85 is called @xmath0-_representation _ of @xmath55 if there is an index function @xmath86 such that @xmath87 it holds @xmath88 if and only if @xmath89 .",
    "we note that such a @xmath0-representation exists for every @xmath90 $ ] .",
    "we note further that , if @xmath55 does not contain fictive coordinates , then there is also a @xmath0-representation for @xmath55 without fictive variables",
    ". we shall keep this in mind , since some problems we consider are not stable under introduction / elimination of fictive variables .",
    "there is a canonical transformation of a @xmath91-formula @xmath92 into a @xmath0-formula , if @xmath93 $ ] : replace every connective in @xmath92 by its @xmath0-representation .",
    "though , this may lead to an explosion of the formula size .",
    "this can happen when a @xmath0-representation for some @xmath90 $ ] uses some input variable more than once and @xmath92 is of linear nesting depth , see e.g. @xcite .",
    "we will nevertheless use this transformation idea in order to obtain reductions .",
    "this is possible since in the cases we encounter , we are always able to ( re-)write @xmath92 as a formula of logarithmic nesting depth . we note that this is not possible in general .",
    "we call formul of logarithmic nesting depth _",
    "compact_.    p1cmll name & definition & base + @xmath94 & all boolean functions & @xmath95 + @xmath96 & @xmath97 & @xmath98 + @xmath99 & @xmath100 & @xmath101 + @xmath102 & @xmath103 & @xmath104 + @xmath105 & @xmath106 & @xmath107 + @xmath108 & @xmath109 & @xmath110 + @xmath111 & @xmath112 & @xmath113 + @xmath114 & @xmath115 & @xmath116 + @xmath117 & @xmath118 & @xmath119 + @xmath120 & @xmath121 & @xmath122 + @xmath123 & @xmath124 & @xmath125 +    @xmath126 & @xmath127 & @xmath128 + @xmath129 & @xmath130 & @xmath131 + @xmath132 & @xmath133 & @xmath134 +    @xmath135 & @xmath136 & @xmath137 + @xmath138 & @xmath139 is a disjunction of variables or constants@xmath140 & @xmath141 + @xmath142 & @xmath139 is a conjunction of variables or constants@xmath140 & @xmath143 +",
    "we begin by looking at the model enumeration problem without order prescription .",
    "this problem has been studied in @xcite considering @xmath0-circuits instead of @xmath0-formul .",
    "it is not difficult to observe that the algorithms from @xcite also prove @xmath144-membership for @xmath0-formul for the clones @xmath102 , @xmath135 , @xmath126 and @xmath145 .",
    "but we have to slightly modify the hardness proof from @xcite in order to deal with the issue of possible exponential blowup .",
    "hardness of @xmath146 is inherited from @xmath147 , the non - trivial satisfiability problem for @xmath0-formul ( given a @xmath0-formula , does it admit a non - trivial model @xmath53 , , @xmath148 ? ) .",
    "a look at post s lattice shows us that @xmath149 $ ] if and only if either @xmath59 \\subseteq \\clonem$ ] , or @xmath59 \\subseteq \\clonel$ ] , or @xmath59 \\subseteq \\cloned$ ] , or @xmath59 \\subseteq \\clones_0 ^ 2 $ ] .",
    "the following proposition will therefore complete the classification .",
    "[ prop : satstarnphard ] let @xmath150 $ ] .",
    "then @xmath147 is @xmath10-complete .",
    "let @xmath0 be a finite set of boolean functions .",
    "then @xmath146 is    1 .",
    "@xmath10-hard if @xmath151 $ ] , 2 .   in @xmath144",
    "otherwise ( , @xmath59 \\subseteq \\clonem$ ] or @xmath59 \\subseteq \\clonel$ ] or @xmath59 \\subseteq \\cloned$ ] or @xmath59 \\subseteq \\clones_0 ^ 2 $ ] ) .",
    "in this section we consider model enumeration by order of non - decreasing weight .    [",
    "prop : enumsatinc - vels0-indelayp ] let @xmath59 \\subseteq \\clonev$ ] or @xmath59 \\subseteq \\clonee$ ] or @xmath59 \\subseteq \\clonel$ ] or @xmath59 \\subseteq \\clones_0 $ ]",
    ". then @xmath152 .",
    "the first three cases are easy .",
    "more interesting is the fourth case .",
    "let @xmath32 be a @xmath0-formula with @xmath8 variables .",
    "since we are @xmath48-separating , we know that there is a special variable , call it @xmath153 , such that any assignment with @xmath154 is a model .",
    "the number of assignments of weight @xmath66 with @xmath155 ( which all are satisfying assignments , we call them therefore _ steady _ models ) is @xmath156 , while the number of assignments of weight @xmath66 with @xmath157 is @xmath158 . since the factor between @xmath156 and @xmath158 is polynomial , the output process of the _ steady _ models delivers enough time to determine in the meanwhile the set of _ unsteady _ models , that is , models of weight @xmath66 with @xmath157 .",
    "these can be stored and output afterwards .",
    "note that this method uses exponential space .",
    "one can however obtain polynomial space ( still maintaining polynomial delay ) by not storing for each @xmath66 the whole set of _ unsteady _ models , but by starting outputting them while still outputting the _ steady _ ones .",
    "solving @xmath6 requires to efficiently solve @xmath1 , the task of computing a model of minimal weight .",
    "we will therefore inherit hardness from @xmath1 .",
    "[ prop : minones - np - hard ] let @xmath159 $ ] or @xmath160 $ ] for an @xmath161 or @xmath162 $ ] .",
    "then @xmath163 is @xmath10-hard .    in the all three cases we reduce from @xmath1(positive-2cnf )",
    "( @xmath10-hard according to @xcite ) .",
    "the second and third case are technically involving , where we deal with the @xmath164-ary @xmath165-threshold function .",
    "[ thm : minones_classification ] let @xmath0 be a finite set of boolean functions",
    ". then @xmath166    1 .",
    "is @xmath10-hard if @xmath167 $ ] for some @xmath161 or @xmath162 $ ] or @xmath168 $ ] , 2 .",
    "is in @xmath144 otherwise ( , @xmath59 \\subseteq \\clones_0 $ ] or @xmath59 \\subseteq \\clonev$ ] or @xmath59 \\subseteq \\clonel$ ] or @xmath59 \\subseteq \\clonee$ ] ) .",
    "we turn to the weighted variant .",
    "the following method will deliver us several tractability results .",
    "[ thm : delaypmethod ] let @xmath169 be an enumeration problem . if it holds    1 .",
    "[ enum : totpoly ] for each @xmath21 , @xmath23 restricted to @xmath22 is total and computable in polynomial time in @xmath170 , 2 .",
    "[ enum : minsolpoly ] it can be determined in polynomial time in @xmath170 whether @xmath22 is non - empty and if so , then @xmath171 is computable in polynomial time in @xmath170 , 3 .",
    "[ enum : f ] there is a binary function @xmath55 such that for all @xmath21 and for all @xmath172 holds : 1 .",
    "[ enum : fpoly ] @xmath173 is computable in polynomial time in @xmath170 2 .",
    "[ enum : fsol ] @xmath174 3 .",
    "[ enum : fcov ] if @xmath175 then there is a @xmath176 such that @xmath177 and @xmath178 ,    then @xmath179 .",
    "correctness of the following algorithm is not difficult to observe .",
    "@xmath180  no q = newpriorityqueue(@xmath23 ) compute @xmath181 q.enqueue(@xmath182 )    @xmath182 : = q.dequeue output @xmath182 compute @xmath183  @xmath184  q.enqueue(@xmath29 )    the priority queue is supposed to eliminate duplicates . note that this method may run in exponential space .    in order to apply the method to the partial order induced by the weight of assignments , it suffices to extend it to a total order , for instance by the lexicographical order on assignments .",
    "let @xmath59 \\subseteq \\clonev$ ] or @xmath59 \\subseteq \\clonee$ ]",
    ". then @xmath185 .    in the first case",
    "a @xmath0-formula can be seen as disjunction of variables and constants .",
    "all assignments are models , with the possible exception of @xmath36 .",
    "thus , we reduce our problem to generate all subsets @xmath186 by non - decreasing weight @xmath187 , where @xmath188 this task can be solved in polynomial delay and polynomial space by a dynamic programming method if the weights on the variables are polynomially bounded @xcite .",
    "otherwise , the priority queue method from theorem  [ thm : delaypmethod ] is applicable with @xmath189 .    in the second case",
    "a @xmath0-formula can be seen as conjunction of variables and constants .",
    "if this disjunction contains a constant @xmath190 , then there are no models .",
    "otherwise @xmath37 is the only model , up to fictive variables occurring in constants @xmath191 .",
    "again , we reduce our problem to @xmath192 as in the previous case .    [ prop : wenumsatinc - l - indelayp ] let @xmath59 \\subseteq \\clonel$ ]",
    ". then @xmath185 .",
    "apply theorem  [ thm : delaypmethod ] with @xmath193 .",
    "the following previously tractable fragment becomes intractable .",
    "[ prop : wminones - s00-nphard ] let @xmath194 $ ] .",
    "then @xmath195 is @xmath10-hard .    via a reduction from @xmath196 , replacing @xmath51 by a fresh variable of big weight .",
    "let @xmath0 be a finite set of boolean functions .",
    "then @xmath197    1 .",
    "is @xmath10-hard if @xmath198 $ ] or @xmath162 $ ] or @xmath168 $ ] , 2 .",
    "is in @xmath31 otherwise ( , @xmath59 \\subseteq \\clonev$ ] or @xmath59 \\subseteq \\clonel$ ] or @xmath59 \\subseteq \\clonee$ ] ) .",
    "in this section we consider model enumeration by order of non - increasing weight .",
    "analogously to proposition  [ prop : enumsatinc - vels0-indelayp ] we obtain @xmath144-membership for disjunctive , conjunctive , affine , or 0-separating formul .    [ prop : enumsatdecc - vels0-indelayp ] let @xmath59 \\subseteq \\clonev$ ] or @xmath59 \\subseteq \\clonee$ ] or @xmath59 \\subseteq \\clonel$ ] or @xmath59 \\subseteq \\clones_0 $ ]",
    ". then @xmath199 .",
    "for monotone formul in general we apply once more the priority queue method .",
    "[ prop : enumsatdec - m - indelayp ] let @xmath59 \\subseteq \\clonem$ ]",
    ". then @xmath200 .",
    "apply theorem  [ thm : delaypmethod ] with @xmath201 .",
    "we now address one of the rare cases where the priority queue method is not applicable and still we obtain tractability .",
    "we use for this the following classical result from combinatorics .",
    "[ lem : erkorath ] let @xmath202 and @xmath24 be a family of distinct subsets of @xmath203 such that each subset is of size @xmath204 and each pair of subsets intersects",
    ". then it holds @xmath205    [ lem : crucial ] let @xmath206 be an @xmath8-ary boolean function and let @xmath66 be an integer such that @xmath207",
    ". then the number of models of weight @xmath66 is at least @xmath156 .",
    "[ prop : enumsatdec - s02-indelayp ] let @xmath59 \\subseteq \\clones_0 ^ 2 $ ] . then @xmath200 .    in a first step",
    "we give a description of the enumeration scheme for the weight range @xmath8 down to @xmath208 .",
    "we start with weight @xmath8 : there is one such assignment which is also a model ( all functions in @xmath145 are 1-reproducing ) .",
    "we continue with an inductive argument ( for @xmath209 ) : assume that we know for weight @xmath66 exactly the set of models @xmath210 . by lemma  [ lem : crucial ] , we have @xmath211 . the total time needed to output these models",
    "is something polynomial in @xmath212 .",
    "this delivers enough time to bruteforce all assignments of the next weight level @xmath213 : there are @xmath214 such assignments to be tested , and the factor between @xmath214 and @xmath212 is obviously polynomially bounded in @xmath8 . summed up , while outputting ( with polynomial delay ) the models of weight @xmath66 , we can compute the set of models of weight @xmath213 .",
    "repeated application of this allows to enumerate with polynomial delay all models in the weight range @xmath8 down to @xmath208 by order of non - increasing weight .",
    "the models in the weight range @xmath208 down to @xmath48 can be computed and stored during the first step : when during the first step an assignment @xmath215 is tested , also test its complement , @xmath216 , which lies then in the weight range @xmath208 down to @xmath48 . if @xmath216 is a model , put it on a stack .",
    "after step 1 has finished , output all the assignments from the stack .",
    "we turn to the intractable cases .",
    "solving @xmath7 requires to efficiently solve @xmath217 , the task of computing a model of maximal weight different from @xmath37 .",
    "the hardness of this task will therefore deliver us hardness of @xmath7 .",
    "the hardness of @xmath217 is obtained from @xmath218 and the following problem .",
    "[ lem : invrootweightsat ] @xmath219 is @xmath10-complete .",
    "it remains @xmath10-complete if the number of variables is assumed to be a power of @xmath220 .",
    "[ prop : maxonesstar - np - hard ] let @xmath150 $ ] or @xmath221 $ ] .",
    "then @xmath222 is @xmath10-hard .    in the first case we reduce from @xmath147 via @xmath223 and",
    "conclude with proposition  [ prop : satstarnphard ] . in the second case we have a technically involving reduction from @xmath219 .",
    "let @xmath0 be a finite set of boolean functions",
    ". then @xmath224    1 .",
    "is @xmath10-hard if @xmath151 $ ] or @xmath221 $ ] , 2 .",
    "is in @xmath31 otherwise ( , @xmath59 \\subseteq \\clones_0 ^ 2 $ ] or @xmath59 \\subseteq \\clonem$ ] or @xmath59 \\subseteq \\clonel$ ] ) , where @xmath225 for @xmath226    lastly , a look at the weighted variant , where we obtain only partial results .",
    "[ prop : wenumsatdec - s0-indelayp ] let @xmath59 \\subseteq \\clones_0 $ ] or @xmath59 \\subseteq \\clonem$ ]",
    ". then @xmath227 .",
    "apply theorem  [ thm : delaypmethod ] with @xmath201 .",
    "[ prop : wenumsatdec - l - indelayp ] let @xmath59 \\subseteq \\clonel$ ] . then @xmath227 .",
    "analogously to proposition  [ prop : wenumsatinc - l - indelayp ] .",
    "the following tractability indicates that also @xmath228 might be tractable .",
    "however , none of the above algorithmic strategies seems to work out .",
    "[ prop : wmaxonesstar - s02-inp ] let @xmath59 \\subseteq \\clones_0 ^ 2 $ ]",
    ". then @xmath229 .",
    "in this paper we provided complete complexity classifications of the problem of enumerating all satisfying assignments of a propositional @xmath0-formula for every set @xmath0 of allowed connectives , imposing the orders of non - decreasing weight and non - increasing weight .",
    "we also considered the weighted variant , where the variables are assigned a non - negative integer weight .",
    "we obtained a complete classification for the weighted variant when imposing the order of non - decreasing weight and remained with one open case for the order of non - increasing weight when the connectives are @xmath48-separating of degree @xmath230 .",
    "interesting are the polynomial delay algorithms we obtained .",
    "they either relay on combinatorial bounds allowing a brute force approach , or on the use of a priority queue which necessarily leads to an exponential space usage . future research could affront the open case , but should also investigate the question of exponential space : can it be avoided , or is it inherent to these problems , in particular to @xmath192 without polynomial bounds on the weights ?    * acknowledgements .",
    "* the author would like to thank johan thapper for combinatorial support .",
    "10    o.  beyersdorff , a.  meier , m.  thomas , and h.  vollmer .",
    "the complexity of propositional implication .",
    ", 109(18):10711077 , 2009 .",
    "e.  bhler , n.  creignou , m.  galota , s.  reith , h.  schnoor , and h.  vollmer .",
    "complexity classifications for different equivalence and audit problems for boolean circuits . , 8(3 ) , 2012 .",
    "a.  a. bulatov , m.  e. dyer , l.  a. goldberg , m.  jalsenius , m.  jerrum , and d.  richerby .",
    "the complexity of weighted and unweighted # csp .",
    ", 78(2):681688 , 2012 .",
    "n.  creignou and j .- j .",
    "n generating all solutions of generalized satisfiability problems . , 31(6):499511 , 1997 .",
    "n.  creignou , f.  olive , and j.  schmidt .",
    "enumerating all solutions of a boolean csp by non - decreasing weight . in _ proc .",
    "of 14th international conference on theory and applications of satisfiability testing ( sat2011 ) _ , lecture notes in computer science , pages 120133 , 2011 .",
    "n.  creignou , j.  schmidt , and m.  thomas .",
    "complexity classifications for propositional abduction in post s framework .",
    ", 22(5):11451170 , 2012 .",
    "a.  durand , m.  hermann , and p.  g. kolaitis .",
    "subtractive reductions and complete problems for counting complexity classes .",
    ", 340(3):496513 , 2005 .",
    "p.  erds , chao ko , and r.  rado .",
    "intersection theorem for system of finite sets .",
    ", 12:313318 , 1961 .",
    "d.  s. johnson , c.  h. papadimitriou , and m.  yannakakis . on generating all maximal independent sets .",
    ", 27(3):119123 , 1988 .",
    "s.  khanna , m.  sudan , and d.  p. williamson .",
    "a complete classification of the approximability of maximization problems derived from boolean constraint satisfaction . in _ stoc _ , pages 1120 , 1997 .",
    "b.  kimelfeld and y.  sagiv .",
    "incrementally computing ordered answers of acyclic conjunctive queries . in _ ngits _ , pages 141152 , 2006 .",
    "h.  lewis .",
    "satisfiability problems for propositional calculi .",
    ", 13:4553 , 1979 .",
    "e.  post .",
    "the two - valued iterative systems of mathematical logic .",
    "5:1122 , 1941 .    s.  reith . on the complexity of some equivalence problems for propositional calculi . in _ proc .",
    "28th mfcs _ ,",
    "volume 2747 of _ lncs _ , pages 632641 , 2003 .",
    "t.  j. schaefer .",
    "the complexity of satisfiability problems . in _",
    "proceedings 10th symposium on theory of computing _ , pages 216226 .",
    "acm press , 1978 .",
    "j.  schmidt .",
    "enumeration : algorithms and complexity .",
    "preprint ( 2009 ) , available at http://www.thi.uni-hannover.de/fileadmin/forschung/arbeiten/schmidt-da.pdf .    h.  schnoor and i.  schnoor . enumerating all solutions for constraint satisfaction problems . in _ stacs _ , pages 694705 , 2007 .    c.  schnorr .",
    "optimal algorithms for self - reducible problems . in _ icalp _ , pages 322337 , 1976 .",
    "y.  strozecki .",
    "enumeration complexity and matroid decomposition . , 2010 .",
    "m.  thomas .",
    "the complexity of circumscriptive inference in post s lattice . in _ proc .",
    "10th lpnmr _ ,",
    "volume 5753 of _ lecture notes in computer science _ , pages 290302 .",
    "springer verlag , 2009 .",
    "[ cols= \" < , < , < \" , ]      @xmath10-membership is obvious . for the hardness , we give a reduction from the satisfiability problem for @xmath0-formul .",
    "we know from @xcite that @xmath231 is @xmath10-complete if @xmath232 $ ] .",
    "since @xmath233 \\subseteq [ b \\cup \\{\\false\\}]$ ] , we conclude that @xmath234 is @xmath10-complete .",
    "let @xmath32 be a @xmath235-formula with variable set @xmath236 .",
    "we construct @xmath237 \\land \\bigwedge_{i=1}^n t \\land ( f \\rightarrow x_i)$ ] . it is not difficult to verify that @xmath32 is satisfiable if and only if @xmath238 admits a non - trivial model .",
    "note that @xmath239 and @xmath240 are in @xmath120 and have therefore a @xmath0-representation .",
    "we transform @xmath238 into the final @xmath0-formula by replacing the connectives @xmath239 and @xmath240 with their @xmath0-representations .",
    "we avoid exponential blowup by a compact @xmath238 : write the @xmath8-ary conjunction as a balanced tree of the binary conjunction @xmath239 .      in the first case",
    "a @xmath0-formula can be seen as disjunction of variables and constants .",
    "all assignments are models , with the possible exception of @xmath36 .",
    "we obviously can enumerate those assignments by order of non - decreasing weight by standard combinatorial methods .    in the second case",
    "a @xmath0-formula can be seen as conjunction of variables and constants .",
    "if this disjunction contains a constant @xmath190 , then there are no models .",
    "otherwise @xmath37 is the only model , up to fictive variables occurring in constants @xmath191 .",
    "again we can enumerate those assignments by order of non - decreasing weight by standard combinatorial methods .    in the third case",
    "a @xmath0-formula can be seen as linear equation over gf(2 ) .",
    "therefore , the set of models is either the set of assignments with an even number of non - fictive variables set to @xmath15 , or the set with an odd number of non - fictive variables set to @xmath15 .",
    "again , all these models can be enumerated by non - decreasing weight by standard combinatorial methods .        since the functions of @xmath145 are 0-separating of degree 2 , the statement of this lemma is nothing else than a disguised form of the erds - ko - rado theorem @xcite : set @xmath243 and represent an assignment as subset of @xmath244 by the set of indexes of the coordinates which are set to @xmath48",
    ". then @xmath24 corresponds to the set of non - models .",
    "we map @xmath32 to @xmath247 \\land t$ ] and @xmath66 to @xmath248 .",
    "the formula @xmath238 can be written as a @xmath0-formula by replacing the connective @xmath239 by its @xmath0-representation ( @xmath249 $ ] ) .",
    "we prove the second statement by induction over @xmath253 . for @xmath257",
    "we have @xmath258 and the statement holds by definition of @xmath250 .",
    "consider then @xmath259 ) . assuming that none of the @xmath260 can be triggered with less than @xmath255 inputs set to 1",
    ", we observe that @xmath261 can not be triggered with less than @xmath262 inputs set to 1 .",
    "let @xmath266 be an instance of @xmath267 , @xmath8 the number of variables in @xmath32 .",
    "choose @xmath268 such that @xmath269 ( , @xmath270 ) and we obtain with lemma  [ lem : minones - threshold ] that @xmath252 has arity and size polynomial in @xmath8 and evaluates to @xmath48 whenever less than @xmath271 inputs are set to @xmath15 ( @xmath272 ) .",
    "denote by @xmath273 the @xmath0-formula obtained from @xmath252 by replacing each @xmath274 by its @xmath0-representation .",
    "exponential blowup does not occur since @xmath252 is compact .",
    "we finally map @xmath266 to @xmath275 , where @xmath276 $ ] and @xmath277 and the @xmath278 are fresh variables .",
    "one easily verifies that @xmath32 admits a model of weight @xmath279 if and only if @xmath238 admits a model of weight @xmath280 .      in the first case we have @xmath281 $ ] , so we obtain by lemma  [ lem : minones_constant_1 ] that @xmath246 .",
    "since @xmath282 \\subseteq [ b\\cup \\{\\true\\}]$ ] , we can reduce from @xmath1(positive-2cnf ) ( @xmath10-hard according to @xcite ) to @xmath283 by replacing every connective ( @xmath284 ) by its ( @xmath285)-representation , avoiding exponential blowup by a compact representation of the multi - ary conjunction in the 2cnf - formula .    in the second case we have that @xmath286 $ ] , in the third case we have that @xmath287 $ ] . in both cases we obtain by lemma  [ lem : minones_constant_0 ] that @xmath265 . since further in both cases it holds @xmath288 $ ]",
    ", we can reduce from @xmath1(positive-2cnf ) to @xmath267 by replacing every connective ( @xmath284 ) by its ( @xmath235)-representation ( avoiding exponential blowup by a compact formula ) .",
    "we give a reduction from @xmath196 , an @xmath10-hard problem according to theorem  [ thm : minones_classification ] , since @xmath289 \\subseteq [ b \\cup \\{\\false\\}]$ ] .",
    "let @xmath266 be an instance of @xmath267 , @xmath8 the number of variables in @xmath32 .",
    "we map @xmath266 to @xmath275 , where @xmath237 $ ] , @xmath55 a fresh variable and @xmath277 .",
    "we set the weight of all variables from @xmath32 to @xmath15 and the weight of @xmath55 to @xmath271 .",
    "one easily verifies that @xmath32 admits a model of weight @xmath279 if and only if @xmath238 admits a model of weight @xmath280 .            * if we have @xmath292 , we set @xmath293 and @xmath294 and map the instance @xmath295 to @xmath296 .",
    "+   + let @xmath297 . by definition of @xmath182",
    "this implies that @xmath298 .",
    "that is , there is a model @xmath38 of weight @xmath299 .",
    "@xmath238 has @xmath300 variables .",
    "the model @xmath38 can be extended to a model @xmath301 of @xmath238 by setting additionally the variables @xmath302 to @xmath48 .",
    "this @xmath301 has then weight @xmath303 that is , @xmath304 .",
    "+   + conversely , let @xmath304 .",
    "that is , there is a model @xmath301 with @xmath305 construct @xmath38 from @xmath301 by removing the assignments for the @xmath306 and we get that @xmath38 satisfies @xmath32 and @xmath299 .",
    "that is , @xmath298 and , since @xmath307 , @xmath297 .",
    "* else if @xmath308 , we set @xmath309 .",
    "one easily verifies that @xmath310 and that consequently @xmath311 from the property that for @xmath312 we have @xmath313 one obtains that @xmath314 +   + set now @xmath315 and map the instance @xmath295 to @xmath316 .",
    "+   + let @xmath297 .",
    "that is , there is a model @xmath38 of weight @xmath317 .",
    "@xmath238 has @xmath318 variables .",
    "the model @xmath38 can be extended to a model @xmath301 of @xmath238 by setting additionally the variables @xmath302 to @xmath15 .",
    "this @xmath301 has then weight @xmath319 that is , @xmath304 .",
    "+   + conversely , let @xmath304 . that is",
    ", there is a model @xmath301 with @xmath320 .",
    "that is , @xmath321 . by construction of @xmath238 , we know that @xmath301 has to set all @xmath302 to @xmath15 . thus , by reducing @xmath301 by the values for the @xmath306 , we obtain an assignment @xmath38 with @xmath317 . by construction of @xmath238 , we conclude that @xmath38 is indeed a model of @xmath32 .",
    "that is , @xmath297 .    to prove the second statement , add enough dummy variables to fill up to the next power of @xmath220 , be @xmath253 such that @xmath322 .",
    "force the right amount of them to @xmath15 and the rest to @xmath48 in order to map models of weight @xmath323 to models of weight @xmath324 and models of weight @xmath325 to models of weight @xmath326 .        in the second case",
    "we give a reduction from @xmath219 with the assumption that the number of variables is a power of @xmath220 .",
    "let @xmath32 be an instance of @xmath219 with variable set @xmath236 , where @xmath327 .",
    "we transform @xmath32 in several steps .",
    "we assume @xmath32 to be a compact @xmath328-formula .    1 .   since @xmath329 $ ] and @xmath330 $ ]",
    ", we can transform @xmath32 into a compact @xmath331-formula @xmath92 by replacing the connectives @xmath328 with their @xmath331-representations .",
    "2 .   set @xmath332 \\land \\bigwedge_{i=1}^{n}(f \\to x_i)$ ] , where @xmath55 is a fresh variable and the @xmath8-ary conjunction be represented in a compact way by the binary conjunction .",
    "note that @xmath333 is now a compact @xmath334-formula .",
    "3 .   since @xmath335 $ ] and @xmath336 $ ]",
    ", we can transform @xmath333 into a compact @xmath337-formula @xmath338 by replacing the connectives @xmath334 with their @xmath337-representations .",
    "4 .   set @xmath339 $ ] .",
    "observe that @xmath340 is a compact @xmath341-formula of size polynomial in the size of @xmath32 with variable set @xmath342 .",
    "5 .   at last , since @xmath343 $ ] , we can transform @xmath340 into @xmath344 by replacing the connectives @xmath345 with their @xmath0-representations .",
    "note that @xmath344 is still of polynomial size , since @xmath340 is compact .",
    "we finally map @xmath32 to @xmath346 .",
    "it is not difficult to verify that @xmath32 admits a model of weight @xmath347 with @xmath348 if and only if @xmath344 admits a model of weight @xmath349 with @xmath350 ( to pass from one model to another , add / remove the assignment @xmath351 ) .",
    "let @xmath8 be the number of variables in an instance .",
    "we obtain a model different from @xmath37 of maximal weight by searching among the set of assignments with one @xmath48 and @xmath353 @xmath15 s .",
    "the number of such assignments is obviously polynomial in @xmath8 and the property of being 0-separating of degree 2 guarantees us among them a non - empty set of models .",
    "obviously a maximum weight model different from @xmath37 is among them ( all assignments with more than one @xmath48 are of less or equal weight ) ."
  ],
  "abstract_text": [
    "<S> in our setting enumeration amounts to generate all solutions of a problem instance without duplicates . </S>",
    "<S> we address the problem of enumerating the models of @xmath0-formul . </S>",
    "<S> a @xmath0-formula is a propositional formula whose connectives are taken from a fixed set @xmath0 of boolean connectives . without imposing any specific order to output the solutions , this task is solved . </S>",
    "<S> we completely classify the complexity of this enumeration task for all possible sets of connectives @xmath0 imposing the orders of ( 1 ) non - decreasing weight , ( 2 ) non - increasing weight ; the weight of a model being the number of variables assigned to 1 . </S>",
    "<S> we consider also the weighted variants where a non - negative integer weight is assigned to each variable and show that this add - on leads to more sophisticated enumeration algorithms and even renders previously tractable cases intractable , contrarily to the constraint setting . as </S>",
    "<S> a by - product we obtain also complexity classifications for the optimization problems known as @xmath1 and @xmath2 which are in the @xmath0-formula setting two different tasks . </S>"
  ]
}