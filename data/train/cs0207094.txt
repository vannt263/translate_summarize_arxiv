{
  "article_text": [
    "integrity constraints ( ic ) capture an important normative aspect of every database application , whose aim is to guarantee the consistency of its data .",
    "however , it is very difficult , if not impossible , to always have a consistent database instance . databases may become inconsistent with respect to a given set of integrity constraints .",
    "this may happen due , among others , to the following factors :  ( 1 ) certain ics can not be expressed / maintained by existing dbmss .",
    "( 2 ) transient inconsistencies caused by the inherent non - atomicity of database transactions . ( 3 ) delayed updates of a datawarehouse . ( 4 ) integration of heterogeneous databases , in particular with duplicated information . ( 5 ) inconsistency with respect to _ soft _ integrity constraints , where transactions in violation of their conditions are not prevented from executing . ( 6 ) legacy data on which one wants to impose semantic constraints . ( 7 ) the consistency of the database will be restored by executing further transactions .",
    "( 8) user constraints than can not be checked or maintained ( 9 ) no permission to restore consistency .",
    "( 10 ) inconsistent information can be useful .",
    "( 11 ) restoring consistency can be a complex and non deterministic process .",
    "an inconsistent database may be the only source of data , and we may still want or need to use it . in these cases ,",
    "one faces the important problem of characterizing and retrieving the _ consistent _ information from the database .",
    "furthermore , the database can still provide us with correct answers to certain queries , making the problem of determining what kinds of queries and query answers are consistent with the integrity constraints a worthwhile effort .",
    "these problems have been studied in the context of relational databases and recent publications deal with some of the issues that arise from trying to define and retrieve consistent information from an inconsistent relational database .",
    "more specifically , in order to approach the problem of _ consistent query answering _ ( cqa ) , in @xcite , a model theoretic definition of consistent answer to a query posed to an inconsistent database was introduced .",
    "the notion is based on the minimal repairs of the inconsistent database : an answer @xmath0 to a first - order query @xmath1 is  _ consistent _  if it is an answer to the same query in every minimal repair of the database .",
    "a repair must be minimal in the sense that the set of inserted or deleted tuples ( to restore inconsistency ) is minimal under set inclusion .",
    "a possible computational mechanisms for retrieving consistent answers is as follows : given a first - order query @xmath2 and an inconsistent database instance @xmath3 , instead of explicitly computing all the repairs of @xmath3 and querying all of them , a new query @xmath4 is computed and posed to @xmath3 , the only available database . the answers to the new query",
    "are expected to be the consistent answers to @xmath2 .",
    "iterative query transformation operators were introduced and analyzed with respect to soundness , completeness and termination in @xcite .    nevertheless , the query rewriting approach has some limitations .",
    "the operators introduced in @xcite work for some particular classes of queries and constraints , e.g. they can not be applied to disjunctive or existential queries .",
    "furthermore , what we have so far is a _ semantic _ , model based definition of consistent query answer , based on database repairs , plus a computational mechanism .",
    "nevertheless , we do not have a specification of the database repairs in a logical language of the class of all the repairs of a given database instance relative to a fixed set of ics .",
    "such a description is natural and useful if we want to express the explicit or implicit properties that are shared by all database repairs , e.g. consistent answers , without constructing those repairs explicitly .",
    "actually , as shown in @xcite , it is easy to find situations where there is an exponential number of database repairs wrt the original database instance . in consequence , the specification would be a compact way of representing the whole class of database repairs .",
    "from such a specification , say @xmath5 , we could : ( 1 ) reason from @xmath5 .",
    "( 2 ) consistently answer queries by asking : @xmath6 .",
    "( 3 ) obtain the intended models of @xmath5 that should correspond to the database repairs .",
    "( 4 ) derive algorithms for consistent query answering .",
    "( 5 ) analyze complexity issues related to consistent query answering . in this paper",
    ", we are motivated mainly by the possibility of retrieving consistent answers to general first - order queries , extending the possibilities we developed in @xcite .",
    "we are also interested in the possibility of obtaining the models of the specification , i.e. the database repairs .",
    "having the repairs explicitly available , allows us to analyze different ways to restore the consistency of the database .",
    "that is , a mechanism for computing database repairs could be used for conflict resolution .",
    "notice that consistent answers are non - monotonic in the sense that adding information to the original database , may cause loosing previous consistent answers . in consequence , a non - monotonic semantics for  @xmath5 ( or their consequences ) should be expected .    in this direction , in @xcite a specification in annotated predicate calculus of the database repairs was presented .",
    "that specification was used to derive algorithms for consistent query answering and to obtain some complexity results .",
    "as expected , the database repairs correspond to certain minimal models of the specifications .",
    "this approach is based on a non - classical logic .    in the same spirit , in @xcite",
    "an alternative specification of the database repairs was presented .",
    "it is based on extended disjunctive logic programs with an answer sets semantics .",
    "the the database repairs correspond to the intended models of the program .",
    "this paper extends the results presented in @xcite , addressing several new issues .",
    "our main contributions are : ( 1 ) the introduction and application of extended disjunctive logic programs with exceptions to the specification of database repairs and consistent query answering .",
    "( 2 ) a detailed analysis of the correspondence between answer sets and database repairs for binary integrity constraints . (",
    "3 ) the use of the specification of database repairs to retrieve consistent answers to general first order queries .",
    "( 4 ) an analysis of the applicability of the disjunctive well - founded semantics to consistent query answering . ( 5 ) application of the _ dlv _ system @xcite to obtain database repairs and consistent answers .",
    "( 6 ) the use of weak constraints to capture database repairs based on minimal _ number _ of changes .",
    "( 7 ) extensions to of the methodology to more general universal constraints and to referential integrity constraints .",
    "this paper is structured as follows . in section",
    "[ sec : cqa ] we introduce the notions of database repair and consistent answer to a query , and the query language .",
    "sections [ sec : dlpes ] introduces extended disjunctive logic programs with exceptions . in section [ sec : example ] we show a complete , but informal example that describes the main ideas behind our approach to consistent query answering and specification of database repairs by means of logic programs . in section , [ sec : bics ] we present the repair programs in their general form for binary integrity constraints . in section [ sec : wf ] we analyze the well - founded interpretation as an approximation to the set of consistent answers , and we identify cases where it provides the exact solution . in section [ sec : eval ] , we discuss how to evaluate the queries . in section [ sec : impl ] we show some examples using the _ dlv _ system to obtain database repairs and consistent answers . in section [ sec : belief ]",
    "we shown how database repairs based on minimal number of changes can be specified by introducing weak constraints in our repair programs . in section [ sec :",
    "remarks ] we show by means of examples how to extend the methodology to deal with more general universal constraints and referential integrity constraints . in section",
    "[ sec : concl ] we discuss related work , mention some open issues , and draw conclusions .",
    "a relational database instance @xmath3 can be represented by a finite set of finite relations whose names are part of a database schema .",
    "a database schema can be represented by a typed language @xmath7 of first - order predicate logic , that contains a finite set of sorted predicates and a fixed infinite set of constants @xmath8 .",
    "the language contains a predicate for each database relation and the constants in @xmath8 correspond to the elements in the database domain , that we will also denote by @xmath8 . in consequence ,",
    "every database instance has an infinite domain @xmath8 .",
    "the active domain of a database instance @xmath3 is the set of those elements of @xmath8 that explicitly appear in @xmath3 .",
    "the active domain is always finite and we denote it by @xmath9 .",
    "we may also have a set of built - in ( or evaluable ) predicates , like equality , order relations , arithmetical relations , etc . in this case",
    ", we have the language @xmath10 possibly extended with these predicates . in all database instances",
    "each of these predicates has a fixed and possibly infinite extension .",
    "of course , since we defined database instances as finite sets of ground atoms , we are not considering these built - in atoms as members of database instances .",
    "in addition to the database schema and instances , we may also have a set of integrity constraints @xmath11 expressed in a language @xmath10 .",
    "these are first - order formulas which the database instances are expected to satisfy .    if a database instance @xmath3 satisfies @xmath11 , what is denoted by  @xmath12 , we say that it is consistent ( wrt @xmath13 ) , otherwise we say it is inconsistent , in consequence , the notation  @xmath12 makes sense . ] . in any case",
    ", we will assume from now on that @xmath11 is consistent as a set of first - order sentences .",
    "the original motivation in @xcite was to consistently answer first - order queries .",
    "we will call them _ basic queries _ and are defined by the grammar @xmath14 , in such a way that @xmath15 , where @xmath16 is a basic query , asks for the values of @xmath17 that are consistent answers to @xmath16 ( or whether @xmath18 is consistently true , i.e. true in all repairs , when @xmath18 is a sentence ) .",
    "the _ @xmath19-queries _ are similarly defined : @xmath20    in this paper we will concentrate mostly on answering _ basic @xmath19-queries _ of the form @xmath21 , where @xmath22 is a basic query , but in section [ sec : eval ] we sketch how to handle general @xmath19-queries .",
    "[ ex : uno ] assume there is the following database instance @xmath29    c|cc @xmath30 & @xmath31 & @xmath32 + & @xmath33 & 5000 + & @xmath33 & 8000 + & @xmath34 & 3000 + & @xmath35 & 7000 +    and @xmath36 is the functional dependency  @xmath37 , meaning that @xmath31 functionally determines @xmath32 , that is violated by the table @xmath30 , actually by the tuples with the value @xmath38 in attribute @xmath31 .",
    "the possible repairs are    c|cccc|cc @xmath39 & @xmath31 & @xmath32 &  & @xmath40 & @xmath31 & @xmath32 + & @xmath38 & 5000 & & & @xmath38 & 8000 + & @xmath41 & 3000 & & & @xmath41 & 3000 + & @xmath42 & 7000 & & & @xmath42 & 7000 +    here , @xmath43 is a consistent answer to the query @xmath44 , i.e.  @xmath45 $ ] , but  @xmath46 $ ]",
    ". it also holds   @xmath47 ,   and   @xmath48 .",
    "@xmath28 +    notice that the definition of consistent query answer depends on our definition of repair . in section [ sec : dalal s ] we will consider an alternative definition based on minimal _ number _ of changes instead of minimal _ set _ of changes .    computing consistent answer through generation of all possible repairs is not a natural and feasible alternative @xcite .",
    "instead , an approach based on querying the available , although inconsistent , database is much more natural . in @xcite",
    "a query rewriting iterative operator @xmath49 was introduced , that applied to a given query @xmath2 produces a new query @xmath4 whose ( ordinary ) answers in an instance @xmath3 are the consistent answers to @xmath2 in @xmath3 .",
    "[ ex : dos ] ( example [ ex : uno ] continued ) the functional dependency @xmath50 can be expressed by means of the formula  @xmath51 . given the query  @xmath52 , the consistent answers are :  @xmath53 ,  @xmath54 , but not   @xmath55 ,  @xmath56 .",
    "the consistent answers can be obtained by means of the transformed query  @xmath57 posed to the given instance . @xmath28",
    "+    this rewriting approach is not complete for disjunctive or existential queries , like   @xmath58 .",
    "we would like to be able to obtain consistent answers to basic @xmath19-queries at least .",
    "logic programs with exceptions ( lpes ) were first introduced in @xcite . they are built with definite extended clauses , that is , with clauses where the ( non - disjunctive ) head and the body are literals ( with classical negation ) and weak negation ( or negation as failure ) may appear in the bodies @xcite . among those clauses , in a lpe there are positive _ default _ rules , that is clauses with positive heads , whose conclusions can be overridden by conclusions derived from _ exception _ rules , which are clauses with negative heads .",
    "the idea is that exceptions have priority over defaults . to capture this intuition , a new semantics is introduced , _",
    "e - answer sets_.    [ ex : clean ] as an example of lpe , we present here a program  @xmath59   that cleans a database instance @xmath60 from tuples participating in the violation of the @xmath61  @xmath62 .",
    "we start by introducing a new predicate @xmath63 that will store the tuples in the clean version of the database .    1 .",
    "default rule :  @xmath64 .",
    "+ it says that every tuple  @xmath65   passes from @xmath3 to @xmath23 .",
    "negative exception rule :  @xmath66 .",
    "+ it says that tuples @xmath65 where  @xmath67   is associated to different values are not accepted in the clean table .",
    "facts :  the contents of  @xmath3 plus  @xmath68 .",
    "intuitively , rule 2 . should have a priority over rule 1 .",
    "@xmath28 +    the semantics of the program should give an account of the priorities ; they should be reflected in the intended models of the program .",
    "the semantics is constructed as follows .",
    "first , instantiate the program @xmath59 in the database domain , making it ground .",
    "now , let @xmath69 be a set of ground literals @xmath70 .",
    "in example [ ex : clean ] , @xmath69 could be something like  @xmath71 @xmath72 .",
    "this @xmath69 is a candidate to be a model , a guess to be verified , and accepted if properly justified .",
    "next , generate a new set of ground rules  @xmath73 according to the following steps :    * delete every rule in @xmath59 containing  @xmath74 in the body , with @xmath75 . *",
    "delete from the remaining clauses every condition  @xmath76 in the body , when  @xmath77 . *",
    "delete every rule having a positive conclusion @xmath78 with  @xmath79 .",
    "the result is a ground extended logic program without  @xmath80 .",
    "now , we say that @xmath69 is an _",
    "e - answer set _ of the original program if @xmath69 is the smallest set of ground literals , such that    * for any clause  @xmath81  in @xmath73 , if @xmath82 , then  @xmath83 .",
    "* if @xmath69 contains two complementary literals , then @xmath69 is the set of all literals .",
    "the e - answer sets are the intended models of the original program . in example",
    "[ ex : clean ] , the only e - answer set is essentially the cleaned instance , what is reflected in the existence of only one e - answer set , where the extension of @xmath23 is that of @xmath3 , but without its conflicting tuples .",
    "notice that this instance is not a repair , but the intersection of all repairs .",
    "above , ( a ) - ( b ) are as in the _ answer sets semantics _ for extended logic programs @xcite , but now ( c ) gives an account of exceptions .    in order to specify database repairs ,",
    "we need to extend the lpes as presented in @xcite in order to accommodate also negative defaults .",
    "i.e. defaults with negative conclusions that can be overridden by positive exceptions , and extended disjunctive exceptions , i.e. rules of the form @xmath84 where the @xmath85s are literals . in our application scenario",
    "we will need disjunctive exceptions rules , but not disjunctive defaults .",
    "the e - answer semantics is extended as follows .",
    "the ground program is pruned according to a new version of the rule ( c ) we had in the previous section :    * delete every ( positive ) default having a positive conclusion @xmath78 , with @xmath86 ; and every ( negative ) default having a negative conclusion @xmath87 , with @xmath75 .     applying ( a )",
    ", ( b ) and ( c ) to the ground program , we are left with a ground disjunctive logic program without @xmath88 .",
    "if the candidate set of literals @xmath69 belongs to @xmath89 , the set of minimal models of program @xmath73 , then we say that @xmath69 is an _",
    "e - answer set_.    as described in @xcite for non - disjunctive programs with negative exceptions , there is a one to one correspondence between the e - answer sets of a disjunctive logic program with exceptions and the answer sets of an extended disjunctive logic program @xcite .",
    "it is easy to show a general program transformation that establishes this correspondence",
    ". we will give this transformation in section [ sec : fddbs ] , remark [ rem : transf ] , but only for the programs we will use . as shown in @xcite , the extended disjunctive program obtained after the transformation can be transformed in its turn into a disjunctive normal program ( without classical negation ) with a stable model semantics .",
    "now , we will use logic programs with exceptions for answering basic @xmath19-queries .    given a set of ics and an inconsistent database instance @xmath3 , the first step consists of writing a logic program @xmath90 having as e - answer sets the repairs of the original database instance . for this purpose",
    ", we will use the _ disjunctive logic program with exceptions _ ( dlpes ) introduced in section [ sec : dlpes ] . with those _ repair programs",
    "_ we can specify the class of all the repairs of a given inconsistent database instance .",
    "next , if a first - order query is posed with the intention of retrieving all and only its consistent answers , then a new logic program , a _ query program _ , that expresses the query , is run together with the repair program . in this way",
    "we can pose and consistently answer queries we can not handle with the query rewriting approach presented in @xcite .",
    "program @xmath90 captures the fact that when a database instance @xmath3 is repaired most of the data persists , except for some tuples . in consequence ,",
    "default rules are introduced : everything persists from the instance @xmath3 to the repairs .",
    "it is also necessary to introduce exception rules : everything persists , as stated by the defaults , unless the ics are violated and have to be satisfied .",
    "we illustrate repair programs by means of an example .",
    "[ ex : exdlpe ] consider an inclusion dependency   @xmath91 , stating that every tuple in table @xmath92 has to be also a tuple in table @xmath2 , and the inconsistent database instance @xmath93 .",
    "the repairs of the database are specified by a dlpe  @xmath90 obtained as follows :   we introduce new predicates @xmath94 corresponding to the repaired versions of the original tables , plus the following program clauses :    1 .   _ facts _ :   @xmath95 .",
    "+ 2 .   _ triggering exception _ :  @xmath96 + this rule gives an account of the first two possible steps leading to a repair of the db : in order to  locally \" repair the ( in this case , single ) ic , either eliminate @xmath65 from @xmath92 or insert @xmath65 into @xmath2 .",
    "the semantics of these dlpes gives the disjunction an exclusive interpretation .",
    "we use weak negations in the body of the last rule in order to give an account of the closed world assumption .",
    "+ 3 .   _ stabilizing exceptions _ :  @xmath97 + this rule states that eventually the ic has to be satisfied in the repairs , this kind of exceptions are necessary if there are interacting ics and local repairs alone are not sufficient . the contrapositive is introduced for technical reasons .",
    "persistence defaults _ :  @xmath98 ; @xmath99 this means that , by default , everything from @xmath3 is put into @xmath23 and nothing else",
    ".    rules 2 . and 3 .",
    "have priority over rule 4 .",
    "+   + it is possible to verify that the e - answer sets of the program are the expected database repairs :  @xmath100 @xmath101 .",
    "the underlined literals represent the deletion of @xmath102 in one repair and the insertion of @xmath103 , in the other , resp . notice that @xmath102 and @xmath104 do not change , because there is no rule able to do that .",
    "@xmath28      in order to obtain the consistent answers to a first - order query @xmath16 , this query is translated into a stratified logic program @xmath105 with new query goal @xmath106 using a standard methodology @xcite .",
    "the predicates appearing in the query program @xmath105 will be the repaired , primed versions of the original database tables , more precisely the set of consistent answers to @xmath16 will be the set @xmath107 .",
    "( example [ ex : exdlpe ] continued ) the query  @xmath108 , asking for consistent values of @xmath109 in the database instance , can be transformed in the following query program @xmath110 : @xmath111 in order to obtain consistent answers it is necessary to evaluate the query goal  @xmath106   wrt the combined program  @xmath112 .",
    "each of the e - answer sets of the combined program will contain a a set of ground @xmath113-atoms . those @xmath113-atoms",
    "( rather their tuple arguments ) that are present simultaneously in all the e - answer sets will be the consistent answers to the original query .    as another example of query ,",
    "consider  @xmath114 . in order to obtain the consistent answers , we keep @xmath90 , but we run it in combination with the new query program @xmath115 : @xmath116    queries like the ones in the previous example can not be handled by the rewriting methodology presented in @xcite .",
    "in this section we will introduce the dlpes for specifying database repairs , and will give a careful analysis of those programs for consistent query answering wrt binary integrity constraints ( bics ) .",
    "we represent integrity constraints in the _ standard format _",
    "@xcite @xmath117 where the @xmath118 are atomic database formulas .",
    "where @xmath18 is a first - order formula containing only built - in predicates only and whose variables are among the @xmath119s ; and there is an implicit universal quantification in front .",
    "binary integrity constraints are in this standard format , but they have the restricted syntactic form @xmath120 where @xmath121 are database literals associated to database tables , i.e. atomic or negations of atomic formulas whose predicates are part of the database schema .",
    "that is , in ( [ eq : genbics ] ) the conditions @xmath122 , @xmath123 hold .",
    "we represent bics in this form , as a particular case of the general standard format , because it is easy to generalize the program we will give next for bics to the general case .",
    "nevertheless , in this paper we will concentrate mainly on bics .",
    "bics with one database literal plus possibly a formula containing built - ins are called _",
    "unary ics_. several interesting classes of ics @xcite can be represented by bics :   ( a ) range constraints , e.g. @xmath124 ; ( b ) non existential inclusion constraints ( example [ ex : exdlpe ] ) , ( b ) functional dependencies ( examples [ ex : uno ] , [ ex : dos ] ) , etc .",
    "nevertheless , for referential ics , like in  @xmath125 , we need existential quantifiers or skolem functions @xcite .",
    "we briefly consider existential inclusion dependencies in section [ sec : remarks ] .      in this section",
    "we will first analyze the case of finite domain databases .",
    "that is , in this section , we will momentarily depart from our initial assumption that databases have an infinite domain @xmath8 ( see section [ sec : intro ] ) .",
    "the reason is that in the general case , we will be interested in _ domain independent _ bics , for which only the active domain is relevant ( and finite ) .      in the following , in order to analyze the behavior of dlpes for bics , we will separate the default rules of the programs from the other rules that represent exceptions .",
    "we will concentrate first on the program without the defaults , that we will denote by  @xmath126 .",
    "this is the part of the program responsible for the changes .    splitting the program in this way",
    "makes its analysis easier .",
    "in addition , we will see that keeping @xmath126 , but using different form of defaults , we can capture different kinds of repairs . in this section",
    ", we will use defaults ( def .",
    "[ def : winsprog ] ) that lead to our notion of repair based on minimal set of changes ( def .",
    "[ def : basic ] ) . in section [ sec : dalal s ] , we will use other defaults that lead to repairs based on minimal number of changes .",
    "[ def : changeprogs ] given a set of bics  @xmath11 and an instance @xmath3 , the change dlpe , @xmath126 , contains the following rules :    1 .",
    "facts : 1 .   for every atomic database formula @xmath127",
    "such that @xmath128 , the fact   @xmath127 .",
    "2 .   for every @xmath129 in @xmath8 , the fact  @xmath130 .",
    "2 .   for every ic of the form ( [ eq : genbics ] ) ,",
    "the triggering rule @xmath131 3 .   for every @xmath132 ,",
    "the stabilizing rule @xmath133 for every @xmath134 , the stabilizing rule @xmath135    in these rules , @xmath136 is an abbreviation for the conjunction of cases of membership to @xmath137 of all the components in the @xmath138s .",
    "of course , depending on the syntax , it may be necessary to unfold the formula @xmath18 appearing in the bodies in additional program rules , but @xmath18 will usually be a conjunction of literals.@xmath28 +    notice that the sets of rules 2 . and 3 .",
    "in example [ ex : exdlpe ] have the form of these general triggering and stabilizing rules , respectively .",
    "it is always the case that for bics , the stabilizing rules in @xmath126 do not contain disjunctions in the heads .",
    "this can also be seen in example [ ex : exdlpe ] . only triggering rules are properly disjunctive .",
    "[ def : model ] a _ model _ of a dlpe , @xmath59 , is a set of ground literals , @xmath69 , that does not contain complementary literals and satisfies @xmath59 in the usual logical sense , but with weak negation interpreted as not being an element of @xmath69 .",
    "@xmath28    given a model @xmath69 of @xmath126 , we define the database instance corresponding to @xmath69 by    @xmath139 .",
    "@xmath28 +    notice that , for a given model @xmath69 of the change program , @xmath140 merges in one new instance of the schema all the positive primed tuples with all the old , non primed tuples that persisted , i.e. that their negative primed version do not belong to the model .",
    "since we do not have persistence defaults in @xmath126 , persistence is captured and imposed through @xmath140 , by keeping in it all the atoms from the original database that were not discarded via the primed predicates .",
    "[ l1 ] given a database instance @xmath3 and a set of bics @xmath11 , if @xmath69 is a model of @xmath126 , then @xmath140 satisfies @xmath11 .",
    "@xmath28 +    given database instances @xmath3 and @xmath23 over the same schema and domain , we define @xmath141    @xmath142 collects the maximal set of literals that can be obtained from two database instances .",
    "it contains everything from both @xmath3 and @xmath23 .",
    "the atoms corresponding to the second argument are primed .",
    "negative literals corresponding to the first argument , intended to be the original databases instance , are not considered , because we will apply weak negation to them .",
    "[ l2 ] given a database instance @xmath3 and a set of bics @xmath143 , if  @xmath23 satisfies @xmath11 , then @xmath142 is a model of @xmath126.@xmath28 +    in the following we will be considering subsets of @xmath144 .",
    "the previous result tells us that its subsets can be potential models of the program .",
    "@xmath144 can be a large model , in the sense that the difference between @xmath3 and @xmath145 may not be minimal .",
    "[ exstable ] for bics , the change program @xmath126 has an answer set .",
    "@xmath28 +      program @xmath126 gives an account of the changes in the original instance that are needed to produce the repairs , but the actual repairs contain data that persists from the original instance .",
    "this can be captured by adding persistence defaults .",
    "[ def : winsprog ] the repair program @xmath90 consists of the rules in program @xmath126 ( def . [ def : changeprogs ] ) plus the following two rules for each predicate @xmath146 in the original database :    * persistence _ defaults _ @xmath147",
    "[ rem : transf ] as shown in @xcite , the dlpe 1. 4 .",
    ", which has an e - answer semantics , can be transformed into a disjunctive extended logic program with answer set semantics , by transforming the persistence defaults into    * persistence _ rules _",
    "as shown in @xcite , the resulting extended disjunctive normal program can be further transformed into a disjunctive normal program with a stable model semantics , with a one to one correspondence between answer sets and stable models .",
    "for this reason , we will interchangeably use the terms answer sets and stable models .",
    "@xmath28    [ aux2 ] given a database instance @xmath3 over a finite domain , and a set of bics @xmath149 , if @xmath150 is an answer set and @xmath90 with persistence rules instead of persistence defaults , we do not find any defaults . in consequence",
    ", we can talk about answer sets as in @xcite instead of e - answer sets @xcite .",
    "] of @xmath126 , then @xmath151 is an answer set of @xmath90 .",
    "@xmath28 +    in order to establish the correspondence between the answer sets of the repair program @xmath90 and the repairs of @xmath3 , we need the following lemma .",
    "it says that whenever we build an answer set @xmath69 with literals taken from @xmath142 , and @xmath145 satisfies the ics and is already as close as possible to @xmath3 , then in @xmath69 we can get essentially @xmath145 only .",
    "the condition that @xmath69 is contained in @xmath142 makes sure that the literals in @xmath69 are taken from the right , maximal set of literals .",
    "[ l3 ] let @xmath3 and @xmath23 be database instances over the same schema and domain , and @xmath11 , a set of bics .",
    "assume that  @xmath152 and the symmetric difference @xmath153 is a minimal element under set inclusion in the set  @xmath154 .",
    "then , for every answer set @xmath69 of @xmath126 contained in @xmath142 , it holds  @xmath155 .",
    "@xmath28 +    [ tw ] if @xmath90 is the program @xmath126 plus rules 4. , for a finite domain database instance @xmath3 and a set of bics @xmath11 , then it holds :    1 .   for every repair @xmath23 of @xmath3 wrt @xmath11 ,",
    "there exists an answer set @xmath69 of @xmath90 such that @xmath156 .",
    "2 .   for every answer set @xmath69 of @xmath90 ,",
    "there exists a repair @xmath23 of @xmath3 wrt @xmath11 such that @xmath157 .",
    "@xmath28 +    in the case of finite domain databases , the domain can be and has been declared .",
    "in this situation , we can handle any set of binary ics , without caring about their safeness or domain independence .",
    "[ ex : finite ] let us take  @xmath158 , @xmath159 and @xmath160 . in this case , the program @xmath90 is @xmath161 the only answer set is  @xmath162 , that corresponds to the only repair   @xmath163 .",
    "@xmath28 +    in this example , the ic demands that every element in domain @xmath8 belongs to table @xmath146 ; and this is possible to satisfy because the domain is finite . nevertheless ,",
    "if the domain @xmath8 were infinite this would not be possible , because relational tables contain finitely many tuples .",
    "so , this kind of ics can not be handled in infinite domains .",
    "now we consider only ics that are _ domain independent _ @xcite .",
    "for these ics only the active domain matters .",
    "in particular , checking their satisfaction in an instance @xmath3 can be done considering the elements of @xmath9 only .",
    "the ic in example [ ex : finite ] is not domain independent .    for domain independent bics",
    "all previous lemmas and theorems still hold if we have infinite database domains @xmath8 . to obtain them ,",
    "all we need to do is to use a predicate  @xmath164 , standing for the active domain @xmath9 of instance @xmath3 , instead of predicate @xmath165 .",
    "this is because , for domain independent bics , the database domain can be considered to be the finite domain @xmath9 .",
    "furthermore , in this case we can omit the @xmath166 facts in 1 .",
    "of @xmath126 ( definition [ def : changeprogs ] ) . in consequence , we have the following theorem , first stated in @xcite .",
    "[ theo : domainindep ] for a set of domain independent binary integrity constraints and a database instance @xmath3 , there is a one to one correspondence between the answers sets of the repair program @xmath90 and the repairs of @xmath3 .",
    "@xmath28    as a consequence of this general result , we have that our dlpes @xmath90 correctly specify the repairs of relational databases that violate usual integrity constraints like range constraints , key constraints , functional dependencies , and non - existential inclusion dependencies .",
    "computing the stable model semantics for disjunctive programs is @xmath167-complete in the size of the ground program . in some cases , computing consistent answers can be done more efficiently .",
    "the intersection of all answer sets of a extended disjunctive logic program contains the well - founded interpretation for such programs @xcite , that can be computed in polynomial time in the size of the ground program .",
    "this interpretation may be partial and not necessarily a model of the program . actually , it is a total interpretation if and only if it is the only answer set .    the well - founded interpretation , @xmath168 , of program @xmath90 , where @xmath169 are the sets of true positive , negative , unknown literals , resp . ,",
    "is the given by the fixpoint @xmath170 of operator @xmath171 , that maps interpretations to interpretations @xcite .",
    "more precisely , assuming that we have the ground instantiation of the repair program @xmath90 , @xmath172 is defined on interpretations @xmath173 that are sets of ground literals ( without pairs of complementary literals ) by :  @xmath174 .    intuitively , @xmath175 is the immediate consequence operator that declares a literal true whenever there is ground rule containing it in the head , the body is true in @xmath173 and the other literals in the ( disjunctive ) head are false in @xmath173 .",
    "@xmath176 denotes the set of complements of the literals in @xmath177 , being the latter the largest set of unfounded literals , those that definitely can not be derived from the program and the set @xmath173 of assumptions ; in consequence their complements are declared true .",
    "the well - founded interpretation , @xmath178 , is the least fixpoint @xmath179 of @xmath180 .",
    "more details can be found in @xcite .",
    "the intersection of all answer sets of @xmath90 is @xmath181 interpretation @xmath182 , being a subset of @xmath183 , can be used as an approximation from below to the core that can be computed more efficiently than all database repairs , or their intersection in the general case .",
    "nevertheless , it is possible to identify classes of ics for which @xmath184 coincides with @xmath183 . in these cases ,",
    "the core is no longer approximated by @xmath178 , but computed exactly .    in order to prove these results , we will assume , as in section [ sec : fddbs ] , that we have a finite database domain @xmath8 .",
    "we know that the results obtained under this hypothesis still hold for infinite domain databases and domain independent integrity constraints . in consequence ,",
    "program @xmath90 contains domain predicates .",
    "the domain facts belong to every answer set and are obtained after the first iteration of the well - founded operator .",
    "[ prop : wfs ] for a database instance @xmath3 , and a set of ics containing functional dependencies and unary ics only ) , plus built - ins .",
    "they include range constraints , e.g.  @xmath185 , stating that products in stock may not go below 100 units .",
    "] , the @xmath183 of program @xmath90 coincides with @xmath178 , the well - founded interpretation of program @xmath90 .",
    "@xmath28 +    as corollary of this proposition and results presented in @xcite about the computational complexity of the disjunctive well - founded interpretation , we obtain that , for fds and unary constraints , @xmath183 can be computed in polynomial time in the size of the ground instantiation of @xmath90 , a result first established in @xcite for fds . in particular , we can consistently answer non - existential conjunctive queries in polynomial time , because we can use @xmath183 only . furthermore , in @xcite , for the case of functional dependencies , some conditions on queries are identified under which one can take advantage of computations on the core to answer aggregate queries more efficiently .    for programs of the kind we may have for bics , it is not always the case that the core coincides with the well - founded interpretation .",
    "[ ex : noncore ] consider the bics  @xmath186 and the empty database instance .",
    "the program @xmath90 wrt @xmath143 is + _ triggering rules _ : @xmath187 _ stabilizing rules _ : @xmath188 _ persistence rules _ : @xmath189 the answer sets are : @xmath190 and @xmath191 .",
    "then @xmath192 , but @xmath193 .",
    "@xmath28 +    the results obtained so far in this section apply to the repair program @xmath90 .",
    "nevertheless , when we add an arbitrary query program @xmath194 to @xmath90 , obtaining program @xmath59 , then it is possible that @xmath195 properly extends the well - founded interpretation of @xmath59 , even for fds .",
    "consider @xmath196 , the fd :   @xmath197 , and the query @xmath198 . program @xmath59 is :    @xmath199    @xmath200    the answer sets of @xmath59 are @xmath201 and @xmath202 . the well - founded interpretation is  @xmath203 @xmath204 , with @xmath205 , @xmath206 @xmath207 , and implicitly , the set of undetermined literals @xmath208 @xmath209 .",
    "in particular , @xmath210 , but @xmath211 .",
    "@xmath28 +    we know , by complexity results presented in @xcite for functional dependencies that , unless @xmath212 , consistent answers to first - order queries can not be computed in polynomial time . in consequence , we can not expect to compute the @xmath195 of the program that includes the query program by means of the well - founded interpretation of @xmath59 only .",
    "the results in section [ sec : bics ] provide the underpinning of a general method of evaluating @xmath19-queries . assume @xmath3 is a database instance and the set of integrity constraints _ ic _ is given . we show how to evaluate queries of the form @xmath213 where @xmath214 is a basic query .",
    "first , from @xmath214 we obtain a stratified logic program @xmath215 ( this is a standard construction @xcite ) in terms of the new , primed predicates .",
    "one of the predicate symbols , @xmath216 , of @xmath215 is designated as the query predicate .",
    "this is illustrated in section [ sec : queryp ] .",
    "second , determine all the answers sets @xmath217 of the logic program @xmath218 .",
    "third , compute the intersection   @xmath219 ,   where @xmath220 is the extension of @xmath221 in @xmath222 .",
    "the set of tuples @xmath223 is the set of answers to @xmath224 in @xmath3 .",
    "notice that the set @xmath225 consisting of all the ground primed database literals , @xmath226 , and all the ground non primed database literals , @xmath227 , form a _ partition _ for the program @xmath59 , because whenever a literal in @xmath225 appears in a head , all the literals in the body also appear in @xmath225 @xcite . the set @xmath225 partitions the program precisely into the two expected parts , @xmath90 and @xmath194 , because the literals in @xmath225 do not appear in heads of rules in @xmath194 ( for @xmath194 , literals in @xmath225 are like extensional literals ) . from @xcite , we know that every answer set of @xmath59 can be represented as the union of an answer set of @xmath90 and an answer set of @xmath194 , where each answer set for @xmath90 acts as an extensional database for the computation of the answer sets of @xmath194",
    ". program @xmath194 is stratified , in consequence , for each answer set for @xmath90 , there will only one answer set for @xmath194 .    to obtain query answers to general @xmath19-queries",
    "the above method needs to be combined with some method of evaluating first - order queries .",
    "for example , safe - range first - order queries @xcite can be translated to relational algebra .",
    "the same approach can be used for @xmath19 queries with the subqueries of the form @xmath228 replaced by new relation symbols .",
    "then when the resulting relational algebra query is evaluated and the need arises to materialize one of the new relations , the above method can be used to accomplish that goal .",
    "as shown in section [ sec : fddbs ] , our disjunctive programs with exceptions can be transformed @xcite into extended disjunctive logic programs with an answer set semantics @xcite .",
    "once this transformation has been performed , obtaining program @xmath90 , it is possible to use any implementation of extended disjunctive logic programs with answer set semantics . in this section , we give some examples that show the application of the _ dlv _ system @xcite to the computation of database repairs and consistent query answers .    in @xcite",
    "it is shown how to compute the answer sets of a program starting from the well - founded interpretation , that can be efficiently computed and is contained in the intersection of the answer sets .",
    "this is what _ dlv _ basically does , but instead of starting from the well - founded interpretation , it starts from the also efficiently computable set of _ deterministic consequences _ of the program , that is still contained in the intersection of all answer sets , and in its turn , contains the well - founded interpretation @xcite . actually , _",
    "dlv _ can be explicitly asked to return the set of deterministic consequences of the program , and it can be also used as an approximation from below to the intersection of all answer sets .",
    "[ ex : ssn ] consider a database schema @xmath229 .",
    "each person should have just one ssn and different persons should have different ssns .",
    "that is , the following functional dependencies are expected to hold :  @xmath230 ,  @xmath231 .",
    "the following is an inconsistent instance :    c|cc @xmath232 & @xmath233 & _ ssn _ + & irwin koper & 677 - 223 - 112 + & irwin koper & 952 - 223 - 564 + & michael baneman & 334 - 454 - 991 +    in order to consistently query this database , we can generate the following _ dlv _ program , where the prime predicate @xmath234 , containing the repaired extension , we had before is now denoted by @xmath235    .... % domains of the database dom_name(\"irwin koper \" ) .         dom_name(\"michael baneman \" ) .",
    "dom_number(\"677 - 223 - 112 \" ) .",
    "dom_number(\"952 - 223 - 564 \" ) .",
    "dom_number(\"334 - 454 - 991 \" ) .",
    "% initial database emp(\"irwin koper \" , \" 677 - 223 - 112 \" ) .",
    "emp(\"irwin koper \" , \" 952 - 223 - 564 \" ) .",
    "emp(\"michael baneman \" , \" 334 - 454 - 991 \" ) .",
    "% default rules emp_p(x , y )   : - emp(x , y ) , not -emp_p(x , y ) .",
    "-emp_p(x , y ) : - dom_name(x ) , dom_number(y ) , not emp(x , y ) , not emp_p(x , y ) .",
    "% triggering rules -emp_p(x , y ) v -emp_p(x , z ) : - emp(x , y ) , emp(x , z ) , y!=z .",
    "-emp_p(y , x ) v -emp_p(z , x ) : - emp(y , x ) , emp(z , x ) , y!=z .",
    "% stabilizing rules .",
    "-emp_p(x , y ) : - emp_p(x , z ) , dom_number(y ) , y!=z .",
    "-emp_p(y , x ) : - emp_p(z , x ) , dom_name(y ) , y!=z . ....",
    "dlv _ running on this program delivers two answer sets , corresponding to the two following repairs :    c|cc @xmath232 & @xmath233 & _ ssn _ + & irwin koper & 952 - 223 - 564 + & michael baneman & 334 - 454 - 991 +    c|cc @xmath232 & @xmath233 & _ ssn _ + & irwin koper & 677 - 223 - 112 + & michael baneman & 334 - 454 - 991 +    in order to pose the query  @xmath236 ? , asking for the consistent tuples in table @xmath237 , it is necessary to add a new rule to the program :    .... query(x , y ) : - emp_p(x , y ) .",
    "....    now , the two answer sets of the program will contain query literals , namely    .... { ... , query(\"irwin koper\",\"952 - 223 - 564 \" ) ,                            query(\"michael baneman\",\"334 - 454 - 991 \" ) }    { ... , query(\"irwin koper\",\"677 - 223 - 112 \" ) ,                            query(\"michael baneman\",\"334 - 454 - 991 \" ) } ....    in order to obtain the consistent answers to the query , it is sufficient to choose all the ground query atoms that are in the intersection of all answer sets of the program extended by the query rule . in this case , we obtain as only consistent answer the tuple : ` x=\"michael baneman \" ` , ` y=\"334 - 454 - 991 \" ` . here",
    "we had a non - quantified conjunctive query .",
    "in other cases , the query predicate will be defined by a more complex program @xmath194 . @xmath28",
    "as discussed in @xcite , our notion of database repair coincides with that of revision model obtained with the  possible model approach \" introduced by winslett in @xcite ( see also @xcite ) in the context of belief update , when the database instance ( a model ) is updated by the ics , generating a new set of models , in this case , the database repairs . in consequence , we have shown in section [ sec : fddbs ] that our repair program @xmath90   ( cf .",
    "theorem [ tw ] )   has as its answer sets the winslett s revision models of @xmath3 wrt @xmath143 .",
    "winslett s revision models are based on minimal _ set _ of changes . in @xcite",
    ", dalal presents an alternative notion of revision model based on minimal _ number _ of changes .",
    "given a database instance @xmath3 , an instance @xmath23 is a _ dalal repair _ of @xmath3 wrt to @xmath11 iff @xmath238 and @xmath239 is a minimal element of @xmath240 .",
    "@xmath28 +    we could give a definition of _ dalal consistent answer _",
    "exactly in the terms of definition [ def : basic ] , but replacing  repair \" by  dalal repair \" .",
    "it is possible to specify dalal repairs using the same repair programs we had in section [ sec : bics ] , but with the persistence defaults replaced by _ weak constraints _ @xcite .",
    "the latter will not be a sort of weak version of the original , database ics .",
    "rather they will be new constraints imposed on the answer sets of the repair program , actually on @xmath126 , the part of the repair program of section [ sec : bics ] that is responsible for the changes .",
    "as described in @xcite , weak constraints are written in the form  @xmath241 , where the @xmath85 s are literals containing strong or weak negation .",
    "they are added to an extended disjunctive program .",
    "their semantics is such , that , when violated in a model of the program , they do not necessarily  kill \" the model .",
    "the models of the program that minimize the _ number _ of violated ground instantiations of the given weak constraints are kept .    in order to capture the dalal repairs we need a very simple form of weak constraint .",
    "the program @xmath242 that specifies the dalal repairs of a database instance @xmath3 wrt a set of bics consists of program @xmath243 of section [ sec : fddbs ] ( rules 1 .",
    " 3 . ) plus    * for every database predicate @xmath146 , the weak constraints @xmath244    these constraints say that the contents of the original database and of each repair are expected to coincide .",
    "since they are weak constraints , they allow violations , but only a minimum _ _ n__umber of tuples that belong to the repair and not to the original instance , or the other way around , will be accepted .",
    "the results for the change program @xmath126 still hold here . the program obtained by the combination of the change program with the weak constraints 4 \" . in ( [ eq : wics ] ) will have answers sets that correspond to repairs that are minimal under set inclusion and under number of changes , i.e. dalal repairs only .",
    "so , for bics and finite domain databases we have    [ td ] given a ( finite domain ) database instance @xmath3 and a set of bics  @xmath11 :    1 .   for every dalal repair @xmath23 of @xmath3 wrt @xmath11 ,",
    "there exists an answer set  @xmath69   of @xmath245 such that @xmath246 .",
    "2 .   for every answer set @xmath69 of @xmath245 ,",
    "there exists a dalal repair @xmath23 of @xmath3 wrt @xmath11 such that @xmath246 .",
    "@xmath28    as with winslett s repairs , the theorem still holds for infinite domain databases when the bics are domain independent .",
    "let @xmath247 , @xmath159 and @xmath248 . in this case",
    ", @xmath245 is @xmath249    weak constraints are implemented in _ dlv _ , where @xmath250 is a conjunction of ( possibly negated ) literals .",
    "see _ dlv _ s user manual in  http://www.dbai.tuwien.ac.at/proj/dlv/man . ] . running _ dlv _ on this program",
    "we obtain the answer set @xmath251 @xmath252 , corresponding to the empty database repair , but not the other winslett s repair  @xmath253 , whose set of changes wrt @xmath3 has two elements , whereas the first repair differs from @xmath3 by one change only .",
    "@xmath28 +    notice that , by construction of @xmath245 , in most cases the primed predicates in the answer sets of the program will not contain all the information ( we replaced the persistence defaults 4 . by the weaks constraints 4 \" . ) . in consequence",
    ", we will have to interpret the result , and the answers to queries will be obtained by using negation as failure , as we shown in the following table : +     @xmath254 & @xmath255 + & @xmath256 + @xmath257 & @xmath258 + & @xmath259 +",
    "in this section we will show how the specifications of database repairs given for binary integrity constraints can be extended to referential integrity constraints and to universal constrains with more than two database literals in the standard format .",
    "we will only consider the case of minimal repairs under set inclusion .      by appropriate representation of existential quantifiers as program rules it",
    "is possible to apply the methodology for universal constraints presented in the previous sections to handle referential integrity constraints ( rics ) .",
    "consider the _ ric _ :  @xmath260 , and the inconsistent database instance @xmath261 .",
    "for things to work properly , it is necessary to assume that there is an underlying database domain @xmath8 .",
    "the repair program has the persistence default rules @xmath262 @xmath263 in addition , it has the stabilizing exceptions @xmath264 with @xmath265 and the triggering exception @xmath266 with  @xmath267 .    the variables in this program range over @xmath8 ,",
    "that is , they do not take the value @xmath268 .",
    "this is the reason for the last literal in clause ( [ eq : null ] ) .",
    "the last literal in clause ( [ eq : null2 ] ) is necessary to insert a null value only when it is needed ; this clause relies on the fact that variables range over @xmath8 only .",
    "instantiating variables on @xmath8 only in the clauses , to force variables to take values in @xmath8 only , excluding the null value . ]",
    ", the only two answer sets are the expected ones , namely delete @xmath269 or insert @xmath270 .",
    "it would be natural to include here the functional dependency @xmath271 on @xmath272 , expressing that @xmath273 is a primary key in @xmath272 and a foreign key in @xmath92 .",
    "this can be done without problems , actually the two constraints would not interact , that is , reparing one of them will not cause violations of the other one .    finally , it should be clear how to modify the specification above if the only admissible changes are elimination of tuples , but not introduction of null values .",
    "for example , the triggering exception ( [ eq : tri ] ) would have to be changed into  @xmath274 .",
    "it has been possible to use _ dlv _ to impose some preferences on the repairs via an appropriate representation of constraints , obtaining , for example for rics , introduction of null values , a cascade policy , ...",
    "( example [ ex : ssn ] contd ) consider the same schema and _ fd_s as before , but now extended with a unary table @xmath275 .",
    "now , we have the following instance    c|cc @xmath232 & @xmath233 & @xmath276 + & irwin koper & 677 - 223 - 112 + & irwin koper & 952 - 223 - 564 + & michael baneman & 952 - 223 - 564 +    c|c @xmath277 & @xmath233 + & irwin koper + & michael baneman +    the _ dlv _ repair program , without considering any change on table _ person _ , is as in example [ ex : ssn ] , but with :    .... dom_number(\"677 - 223 - 112 \" ) .",
    "dom_number(\"952 - 223 - 564 \" ) .",
    "% initial database emp(\"irwin koper \" , \" 677 - 223 - 112 \" ) .",
    "emp(\"irwin koper \" , \" 952 - 223 - 564 \" ) .",
    "emp(\"michael baneman \" , \" 952 - 223 - 564 \" ) . ....",
    "if _ dlv _ is run with this program as input , we obtain the answer sets :    .... { ... , emp_p(\"irwin koper\",\"677 - 223 - 112 \" ) ,        -emp_p(\"irwin koper\",\"952 - 223 - 564 \" ) ,         emp_p(\"michael baneman\",\"952 - 223 - 564 \" ) ,        -emp_p(\"michael baneman\",\"677 - 223 - 112 \" ) }    { ... , -emp_p(\"irwin koper\",\"677 - 223 - 112 \" ) ,         emp_p(\"irwin koper\",\"952 - 223 - 564 \" ) ,        -emp_p(\"michael baneman\",\"952 - 223 - 564 \" ) ,        -emp_p(\"michael baneman\",\"677 - 223 - 112 \" ) } ....    corresponding to the database repairs :    c|cc    @xmath232 & @xmath233 & @xmath276 + & irwin koper & 677 - 223 - 112 + & michael baneman & 952 - 223 - 564 +    c|cc @xmath232 & @xmath233 & @xmath276 + &  irwin koper   & 952 - 223 - 564 +    in the second repair michael baneman does not have a ssn , in consequence it is not a consistent answer that he has a ssn . actually , it is possible to ask with _ dlv _ for those persons who have a ssn by computing the answer sets of the program extended by the query rule :  ` query(x):- emp_p(x , y ) . `",
    "two answer sets are obtained :    .... { ... , query(\"irwin koper \" ) , query(\"michael baneman \" ) } , { ... , query(\"irwin koper \" ) } ....    from them , we can say that only irwin koper has a ssn ( in all repairs ) .",
    "if we want every person to have a ssn , then we may enforce the ric ,  @xmath278 @xmath279 , stating that every person must have a ssn .    in section [ sec : ref ]",
    ", we repaired the database introducing the ric as a part of the program , producing either the introduction of null values or cascading deletions .",
    "we may not want any of these options ( we do not want null values in the key _ ssn _ ) or we do not want to delete any employees ( in this case , m. baneman from _ person _ ) .",
    "an alternative is to use _ dlv _ s possibility of specifying _ strong constraints _ , that have the effect of pruning those answer sets that do not satisfy them .",
    "this can be done in _",
    "dlv _ by introducing the denial ` : - dom_name(x ) , not has_ssn(x ) . ` , with   ` has_ssn(x ) : - emp_p(x , y ) . ` .",
    "the answer sets of the original program that do not satisfy the ics are filtered out .",
    "now , only one repair is obtained :    .... { ... , emp_p(\"irwin koper\",\"677 - 223 - 112 \" ) ,        -emp_p(\"irwin koper\",\"952 - 223 - 564 \" ) ,         emp_p(\"michael baneman\",\"952 - 223 - 564 \" ) ,        -emp_p(\"michael baneman\",\"677 - 223 - 112 \" ) ,         has_ssn(\"irwin koper \" ) ,   has_ssn(\"michael baneman \" ) ,         query(\"irwin koper \" ) ,   query(\"michael baneman \" ) } ....    in it , every person has a ssn ( according to the has_ssa predicate ) .",
    "as expected , the answers to the original query are ` x=\"irwin koper \" ` and ` x=\"michael ` ` baneman \" ` .      in order to handle universal ics with a larger number of database literals",
    ", we can use the same program @xmath90 , but with @xmath126 , as introduced in definition [ def : changeprogs ] for bics , now without the condition @xmath280 in ( [ eq : genbics ] ) .",
    "now @xmath281 and @xmath282 can be arbitrary .",
    "this will produce properly disjunctive stabilizing rules , by passing in turns just one of the disjuncts to the body in it complementary form .",
    "furthermore , we need to extend @xmath126 with more disjunctive stabilizing rules .",
    "in essence , as indicated in @xcite , we need to consider all possible subsets of the database literals appearing in the standard format ( [ eq : genbics ] ) and put them in a disjunction in the head , passing to the body the remaining literals and the formula @xmath18 .",
    "we will show this by means of some examples .",
    "[ ex : ternary ] consider the db instance   @xmath283   and the following set of ternary integrity constraints  @xmath284 .",
    "the repair program contains the usual persistence defaults for @xmath285 , plus triggering exceptions , e.g. for the first ic in @xmath143 : @xmath286 and the stabilizing rules directly obtained from definition [ def : changeprogs ] , e.g. for the first ic @xmath287 we add to the program the other possible combinations , e.g. for the first ic : @xmath288 in this case we obtain as answer set the only repair , namely the empty instance , represented by @xmath289 .",
    "it is easy to verify that without using the disjunctive stabilizing rules ( [ stadis ] ) , but with the rules ( [ stanodis ] ) as the only stabilizing rules , the empty repair can not be obtained .",
    "let @xmath158 , @xmath290 and @xmath11 the transitivity constraint   @xmath291 . here , the only repairs are @xmath292 , @xmath293 and @xmath294 .",
    "the repair program @xmath90 contains the facts   @xmath295 @xmath296  plus the rules @xmath297    @xmath298    with this program we will get as answer sets the three repairs , but also six other models corresponding to non - minimal repairs , e.g.  @xmath299 @xmath300 @xmath301 @xmath302 @xmath303 @xmath304 @xmath305 @xmath306 @xmath307 @xmath308 @xmath309 @xmath310 @xmath311 @xmath312 , meaning that we are repairing the database by inserting the tuple @xmath313 into @xmath146 , but also the tuples @xmath314 , etc .",
    "the reason is that a rule like ( [ eq : dist ] ) for example is inserting tuples @xmath315 , for essentially any @xmath316 , independently of the condition in the body . in order to solve this problem",
    ", one can add extra conditions in the body of ( [ eq : dist ] ) that relate the possible values for @xmath316 with the values in the original database . in consequence ,",
    "that rule should be replaced by  @xmath317 .",
    "the domain predicate , introduced in ( [ eq : dist ] ) to make the rule safe , is no longer needed .",
    "similar changes have to be performed in the other stabilizing rules . @xmath28",
    "there are several interesting open issues related to computational implementation of the methodology we have presented .",
    "the existing implementations of stable models semantics are based on grounding the rules , what , in database applications , may lead to huge ground programs .",
    "in addition , those implementations are geared to computing stable models , possibly not all of them , and answering ground queries . at the same time , in database applications the possibility of posing and answering open queries ( with variables ) is much more natural .",
    "in addition , consistent query answering requires , at least implicitly , having all stable models .",
    "it would be useful to implement a consistent query answering system based on the interaction of our repairs logic programs with relational dbms .",
    "for this purpose , some functionalities and front - ends included in _",
    "dlv _ s architecture @xcite could be used .",
    "another interesting issue has to do with the possibility of having the consistent query answering mechanism guided by the query , so that irrelevant computations are avoided .",
    "there , are other open problems that could be considered : ( a ) analyzing conditions under which simpler programs can be obtained .",
    "( b ) a more detailed treatment of referential ics ( and other existential ics ) . ( c ) identification of other classes of ics for which the well - founded interpretation and the intersection of all database repairs coincide .",
    "( d ) preferences for certain kinds of repair actions . in principle",
    "they could be captured by choosing the right disjuncts in the triggering rules .    with respect to related work , the closest approach to ours",
    "is presented in @xcite ( see also @xcite ) .",
    "there disjunctive programs are used to specify the sets of changes under set inclusion that lead to database repairs in the sense of @xcite .",
    "they present a compact schema for generating repair programs for universal integrity constraints .",
    "the application of such a schema leads to programs that involve essentially all possible disjunctions of database literals in the heads .",
    "they concentrate mainly on producing the set of changes , rather than the repaired databases explicitly .",
    "in particular , they do no have persistence rules in the program . in consequence",
    ", the program can not be used directly to obtain consistent answers .",
    "they also introduce  repair constraints \" to specify preferences for certain kinds of repairs .",
    "another approach to database repairs based on logic programming semantics consists of the _ revision programs _ @xcite .",
    "the rules in those programs explicitly declare how to enforce the satisfaction of an integrity constraint , rather than explicitly stating the ics , e.g. @xmath318 has the intended procedural meaning of inserting the database atom @xmath129 whenever @xmath319 are in the database , but not @xmath320 .",
    "they also give a declarative , stable model semantics to revision programs .",
    "preferences for certain kinds of repair actions can be captured by declaring the corresponding rules in program and omitting rules that could lead to other forms of repairs .",
    "revision programs could be used , as the programs in @xcite , to obtain consistent answers , but not directly , because they give an account of the changes only .",
    "* acknowledgments : *   work supported by fondecyt grant 1000593 , nsf grant int-9901877/conicyt grant 1998 - 02 - 083 , nsf grant iis-0119186 , carleton university start - up grant 9364 - 01 .",
    "we are grateful to francisco orchard for informative paper presentations , discussions , and experiments with dlv .",
    "we are grateful to nicola leone for kindly answering all our questions about _",
    "dlv_.    abiteboul , s. ; hull , r. ; and vianu , v. .",
    "addison - wesley , 1995 .",
    "arenas , m. ; bertossi , l. ; and chomicki , j. . in _ proc .",
    "acm symposium on principles of database systems ( acm pods99 , philadelphia ) _ , acm press , 1999 , pp .",
    "arenas , m. ; bertossi , l. ; and chomicki , j. . in",
    "_ flexible query answering systems .",
    "recent developments _ , h.l .",
    "larsen , j. kacprzyk , s. zadrozny , h. christiansen ( eds . ) , springer , 2000 , pp . 2741 .",
    "arenas , m. ; bertossi , l. ; and chomicki , j. . in _",
    "database theory - icdt 2001 _ ( proc .",
    "international conference on database theory , icdt2001 ) , springer , lecture notes in computer science 1973 , 2001 , pp .",
    "39  53 .",
    "arenas , m. ; bertossi , l. ; and kifer , m. . in _ ` computational logic - cl 2000 ' .",
    "stream : 6th international conference on rules and objects in databases ( dood2000 ) _ , springer , lecture notes in artificial intelligence 1861 , 2000 , pp . 926941 .",
    "buccafurri , f. ; leone , n. ; rullo , p. . , 2000 , 12(5 )",
    ": 845 - 860 .",
    "celle , a. ; and bertossi , l. . in _ ` computational logic - cl 2000 ' .",
    "stream : 6th international conference on rules and objects in databases ( dood2000 ) _ , pp .",
    "springer lecture notes in artificial intelligence 1861 .",
    "chou , t. ; and winslett , m. .",
    ", 1994 , 12:157208 .",
    "dalal , m. . in _ proc .",
    "seventh national conference on artificial intelligence ( aaai88 ) _ , 1988 , pp .",
    "475479 .",
    "dantsin , e. , eiter , t. , gottlob , g. and voronkov , a. complexity and expressive power of logic programming . to appear in acm computing surveys .",
    "eiter , t. ; leone , n. ; mateis , c. ; pfeifer , g. ; and scarcello , f. . in _ proceedings of the international conference on principles of knowledge representation and reasoning , kr98 , trento , italy , june 1998_. morgan kaufman .",
    "eiter , t. ; faber , w. ; leone , n. ; pfeifer , g. . in _ logic - based artificial intelligence _ , j. minker ( ed . ) , kluwer , 2000 , pp .",
    "79103 .    fitting , m. .",
    "texts and monographs in computer science .",
    "springer verlag , 2nd ed . , 1996 .",
    "gelfond , m. ; and lifschitz , v. .",
    "in _ logic programming , proceedings of the fifth international conference and symposium _ , r. a. kowalski and k. a. bowen ( eds . ) , mit press 1988 , pp . 10701080 .",
    "gelfond , m. ; and lifschitz , v. . , 1991 , 9:365385 .    greco , s. ; and zumpano , e. querying inconsistent databases . in proc .",
    "7th international conference on logic for programming and automated reasoning ( lpar2000 ) , springer lncs 1955 , 2000 , pp .",
    "308 - 325 .",
    "greco , s. ; and zumpano , e. computing repairs for inconsistent databases .",
    "the third international symposium on cooperative database systems for advanced applications ( codas01 ) , beijing , april 23 - 24 , 2001 .",
    "greco , g. ; greco , s. ; and zumpano , e. a logic programming approach to the integration , repairing and querying of inconsistent databases . in proc .",
    "17th international conference on logic programming , iclp01 , ph .",
    "codognet ( ed . ) , lncs 2237 , springer , 2001 , pp .",
    "348364 .",
    "kowalski , r. ; and sadri , f. .",
    ", 1991 , 9:387400 .",
    "leone , n. ; rullo , p. ; and scarcello , f. .",
    ", 1997 , 135(2):69 - 112 .",
    "leone , n. personal communication , 2000 .",
    "lifschitz , v. and turner , h. splitting a logic program . in proceedings of the eleventh international conference on logic programming , pascal van hentenryck ( ed . ) , mit press , 1994 , pp .",
    "23 - 37 .",
    "lloyd , j.w . .",
    "springer verlag , 1987 .",
    "marek , v. w. ; and truszczynski , m. . , 1998 , 190(2):241277 .",
    "ullman , j. .",
    "computer science press , 1988 .",
    "winslett , m. . in _ proc .",
    "seventh national conference on artificial intelligence ( aaai88 ) _ , 1988 , pp .",
    "_ proof  of   proposition [ l1 ] _ consider an arbitrary element in @xmath149 : @xmath321 we have to prove that @xmath140 satisfies any instantiation of this formula , that is @xmath322 we need to consider two cases .    1 .",
    "if @xmath3 does not satisfy this ground constraint , then @xmath69 satisfies the body of the ground triggering rule : @xmath323 thus , there exists @xmath324 or @xmath325 .",
    "but , if @xmath324 , then @xmath326 , and therefore ( [ e1 ] ) holds .",
    "if @xmath325 , then @xmath327 . thus @xmath328 , and therefore ( [ e1 ] ) holds .",
    "2 .   if @xmath3 satisfies the ground constraint , then @xmath3 could satisfy @xmath18 , and in this case @xmath329 .",
    "otherwise , @xmath3 satisfies some @xmath330 or some @xmath331 .",
    "+ assume that ( [ e1 ] ) is not true . in this case , @xmath332 , and therefore @xmath3 must satisfy some @xmath330 or some @xmath333 . if @xmath3 satisfies @xmath330 , then @xmath334 .",
    "but , @xmath335 , since ( [ e1 ] ) does not holds , and therefore @xmath336 , by definition of @xmath140 .",
    "but , in this case @xmath69 satisfies the body of the ground stabilizing rule : @xmath337 thus , by using an argument analogous to the argument given in ( i ) , we conclude that ( [ e1 ] ) holds , a contradiction .",
    "+ the case in which @xmath3 satisfies @xmath333 can be handled in a similar way .",
    "@xmath28    _ proof  of   proposition [ l2 ] _ in order to prove that @xmath338 satisfies @xmath126 , we need to consider only the four different kinds of ground stabilizing rules ( the satisfaction of the other rules follows from the fact that @xmath145 satisfies @xmath143 ) .      in the same way ,",
    "it is possible to prove that @xmath345 satisfies all the rules of the form : @xmath346 @xmath28 + _ proof  of   proposition [ exstable ] _ from the previous proposition , we know that the change program has models .",
    "now , that program can be partitioned into two programs , the first one containing the stabilizing rules and modified versions of the triggering rules , where the literals of the form @xmath347 in the bodies are replaced by @xmath348 .",
    "the other one contains the domain and database facts plus the new rules @xmath349 . by a result in @xcite ,",
    "the partitioned program has as answer sets the unions of the answer sets of the second program and the answer sets of the first one , where the atoms @xmath348 are treated as extensional database predicates .",
    "the second program is stratified and has one answer set .",
    "the first one does not contain weak negation , it is a positive program in that sense , and its minimal models coincide with its answer sets .",
    "@xmath28 + _ proof  of   proposition [ aux2 ] _ notice that the two sets added to @xmath350 on the right - hand side are expected to give an account of the persistence rules that are not included in @xmath126 .",
    "let @xmath351 be the set added to @xmath350 : @xmath352 it is easy to verify that @xmath353 . then , since @xmath350 is an answer set of @xmath126 , in order to prove that @xmath69 is an answer set of @xmath90 , it suffices to prove ( i ) and ( ii ) below .",
    "1 .   @xmath354 . + let @xmath355 be an element of @xmath351 . if @xmath356 , then @xmath357 and @xmath358 , and , therefore , @xmath127 and @xmath359 are rules in @xmath360 .",
    "thus , @xmath361 is in @xmath362 .",
    "if @xmath363 , then @xmath364 and @xmath365 , and , therefore , @xmath366 is a reduced ground persistence rule in @xmath360 .",
    "thus , @xmath367 is in @xmath362 .",
    "2 .   from @xmath351 is not possible to deduce an element that is not included in @xmath69 . + assume that @xmath368 is a rule in @xmath126 , and @xmath369 @xmath370 is a rule in @xmath360 . if @xmath371 , we need to show that @xmath372 . by contradiction",
    ", suppose that @xmath373",
    ". then @xmath374 and @xmath375 .",
    "therefore , @xmath376 or @xmath377 .",
    "if @xmath378 is not in @xmath150 , then @xmath150 satisfies the body of the rule @xmath379 because @xmath380 . in consequence ,",
    "but , this implies that @xmath382 , a contradiction , or @xmath383 , also a contradiction ( since @xmath384 ) .",
    "otherwise , if @xmath377 , then by using the rule @xmath385 , we can conclude that @xmath367 is in @xmath150 , a contradiction .",
    "+ analogously , it is possible to prove the same property for any of the rules : @xmath386        1 .",
    "@xmath128 and @xmath389 . in this case ,",
    "@xmath390 and @xmath391 .",
    "thus , by definition of @xmath140 we conclude that @xmath392 .",
    "therefore , @xmath393 .",
    "but this implies that @xmath394 .",
    "thus , @xmath395 .",
    "2 .   @xmath396 and @xmath397 . in this case , @xmath398 ( @xmath69 is a minimal model and @xmath399 does not need to be in @xmath69 if it was not in @xmath3 ) .",
    "thus , by definition of @xmath140 we conclude that @xmath400",
    ". therefore , @xmath401 .",
    "but this implies that @xmath402 .",
    "thus , @xmath395 .",
    "thus , @xmath387 .",
    "but , by proposition [ l1 ] , @xmath140 satisfies @xmath143 , and therefore , @xmath403 must be equal to @xmath404 , since @xmath404 is minimal under set inclusion in @xmath405 .",
    "then , we conclude that @xmath406 .",
    "@xmath28 + _ proof  of   theorem [ tw ] _ we will prove the first part of this theorem .",
    "the second one can be proved analogously .",
    "given a repair @xmath145 of @xmath3 , by lemma [ l3 ] , @xmath407 , where @xmath350 is an answer set of @xmath126 , with @xmath408 .",
    "define @xmath69 from @xmath350 as in ( [ e2 ] ) .",
    "we obtain that @xmath69 is an answer set of @xmath90 . by construction of @xmath69 , @xmath409 .",
    "furthermore , @xmath410 .",
    "@xmath28 + _ proof  of   proposition [ prop : wfs ] _ since it is always the case that @xmath411 @xcite , we only need to show that @xmath412 . in consequence",
    ", it is necessary to check that whenever a literal @xmath413 belongs to @xmath414 , where @xmath129 is tuple of elements in the domain @xmath8 and @xmath146 is a database predicate , @xmath413 can be fetched into @xmath415 for some finite integer @xmath282 .",
    "each literal @xmath78 in the original database @xmath3 , in its primed version , will become @xmath78 or its complement @xmath416 in the answer sets , but we are invoking the cwa .",
    "all the literals in the original instance will belong to @xmath183 . ] .",
    "we will do the proof by cases , considering for a literal @xmath417 contained in @xmath183 all the possible transitions from the original instance to the core : ( a ) negative to positive .",
    "( b ) positive to positive . ( c )",
    "negative to negative .",
    "( d ) positive to negative .",
    "we will prove only the first two cases , the other two are similar .    for each case , again several cases have to be verified according to the different ground program rules that could have made @xmath418 get into @xmath414 .",
    "+   + ( i ) assume @xmath419 . to prove : @xmath420 .",
    "two cases    1 .   @xmath421 . since fds can only produce deletions @xmath418 has to be true because an unary constraint was false for @xmath399 :",
    "@xmath422 is false , where @xmath423 is the instantiation of the ics in the domain @xmath8 .",
    "then , @xmath424 is false . in the ground program",
    "we find the rule   @xmath425 .",
    "the second subgoal becomes true of @xmath426 . since @xmath427",
    "then , @xmath428 .",
    "2 .   @xmath429 .",
    "intuitively , @xmath399 persisted .",
    "this means there is no ground ic of the form @xmath430 that is false , nor of the form @xmath431 , with @xmath432 false .",
    "otherwise , @xmath418 could not be in the core .",
    "the second case implies that we can never obtain @xmath433 by means of a rule of the form  @xmath434 .",
    "some cases need to be examined : 1 .",
    "there is @xmath435 with @xmath436 false .",
    "then , with the rule  @xmath437 , with @xmath424 . in this case , as in case 1 . , @xmath428 .",
    "if there is no ground constraint as in the previous item , either because there is no @xmath435 in @xmath423 or the @xmath424s are true , then there is no applicable rule of the form  @xmath437 in the ground program . since rules associated to fds delete tuples only",
    ", we could obtain @xmath418 due to a default rule @xmath438 only , via the unfoundedness of @xmath439 , or directly via the unfoundedness of @xmath433 in the ground program .",
    "if the @xmath440 operator declares @xmath433 unfounded , then @xmath418 will belong to @xmath441 .",
    "so , we have to concentrate on the unfoundeness of @xmath433 .",
    "we know that we can never get @xmath433 from rules of the form @xmath434 .",
    "@xmath433 can not be obtained via the default rule , because @xmath442 has the second subgoal false .",
    "@xmath433 can not be obtained via a possible unfoundedness of @xmath418 , because @xmath418 belongs to answer sets .",
    "we are left with rules associated to fds .",
    "assume that @xmath443 .",
    "there are only two alternatives : @xmath444 , in which case , the associated triggering rule can not be applied ; or @xmath445 and @xmath446 is true and there is no @xmath447 with @xmath448 false ( otherwise , @xmath433 would have to be true ) .",
    "+ the rule  @xmath449 can not be applied , because @xmath450 is false .",
    "+ we have to analyze the stabilizing rule  @xmath451 .",
    "if @xmath444 , the rule does not apply . otherwise , we have @xmath452 , and then @xmath453 .",
    "@xmath454 can not be obtained from the default @xmath455 , because @xmath450 is false .",
    "neither can it be obtained from a rule @xmath456 , because @xmath448 would have to be true .",
    "+ in consequence , @xmath454 is unfounded , i.e. @xmath457 , then @xmath433 turns out to be unfounded : @xmath458 ."
  ],
  "abstract_text": [
    "<S> a relational database is _ inconsistent _ if it does not satisfy a given set of integrity constraints . </S>",
    "<S> nevertheless , it is likely that most of the data in it is consistent with the constraints . in this paper </S>",
    "<S> we apply logic programming based on answer sets to the problem of retrieving consistent information from a possibly inconsistent database . </S>",
    "<S> since consistent information persists from the original database to every of its minimal repairs , the approach is based on a specification of database repairs using _ disjunctive logic programs with exceptions _ , whose answer set semantics can be represented and computed by systems that implement stable model semantics . </S>",
    "<S> these programs allow us to declare persistence by defaults and repairing changes by exceptions . </S>",
    "<S> we concentrate mainly on logic programs for binary integrity constraints , among which we find most of the integrity constraints found in practice . </S>"
  ]
}