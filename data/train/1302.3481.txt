{
  "article_text": [
    "the problem of satisfiability of word equations was considered as one of the most intriguing in computer science and its study was initiated by markow already in the 50 . the first algorithm for it was given by makanin  @xcite , despite earlier conjectures that the problem is undecidable .",
    "the proposed solution was very complicated in terms of proof - length , algorithm and computational complexity .",
    "it was improved several times , however , no essentially different approach was proposed for over two decades .",
    "an alternative algorithm was proposed by plandowski and rytter  @xcite , who shoved that each minimal solution of a word equation is exponentially compressible , in the sense that for a word equation of size @xmath3 and minimal solution of size @xmath4 the lz77 ( a popular practical standard of compression ) representation of the minimal solution is polynomial in @xmath3 and @xmath5 .",
    "hence a simple non - deterministic algorithm that guesses a compressed representation of a solution and verifies the guess has running time polynomial in @xmath3 and @xmath5 .",
    "however , at that time the only bound on @xmath4 followed from makanin s work ( with further improvements ) and it was triply exponential in @xmath3 .    soon after plandowski showed , using novel factorisations , that @xmath4 is at most doubly exponential  @xcite , showing that satisfiability of word equations is in nexptime . exploiting the interplay between factorisations and compression he improved the algorithm so that it worked in pspace  @xcite .    producing a description of all solutions of a word equation , even when a procedure for verification of its satisfiability is known , proved to be also a non - trivial task .",
    "still , it is also possible to do this in pspace  @xcite , though insight and non - trivial modifications to the earlier procedure are needed .",
    "on the other hand , it is only known that the satisfiability of word equations is np - hard .      since in general the problem is outside p , it was investigated , whether some subclass is feasible , with a restriction on the number of variables being a natural candidate .",
    "it was shown by charatonik and pacholski  @xcite that indeed , when only two variables are allowed ( though with arbitrarily many occurrences ) , the satisfiability can be verified in deterministic polynomial time .",
    "the degree of the polynomial was very high , though .",
    "this was improved over the years and the best known algorithm is by dbrowski and plandowski  @xcite and it runs in @xmath6 and returns a description of all solutions .      clearly , the case of equations with only one variable is in p. constructing a cubic algorithm is almost trivial , small improvements are needed to guarantee a quadratic running time .",
    "first non - trivial bound was given by obono , goralcik and maksimenko , who devised an @xmath7 algorithm  @xcite .",
    "this was improved by dbrowksi and plandowski  @xcite to @xmath0 , where @xmath1 is the number of occurrences of the variable in the equation .",
    "furthermore they showed that there are at most @xmath8 distinct solutions and at most one infinite family of solutions .",
    "intuitively , the @xmath9 summand in the running time comes from the time needed to find and test these @xmath8 solutions .",
    "this work was not completely model - independent , as it assumed that the alphabet @xmath10 is finite or that it can be identified with numbers .",
    "a more general solution was presented by laine and plandowski  @xcite , who improved the bound on the number of solutions to @xmath11 ( plus the infinite family ) and gave an @xmath12 algorithm that runs in a pointer machine model ( i.e.  letters can be only compared and no arithmetical operations on them are allowed ) ; roughly one candidate for the solution is found and tested in linear time .",
    "recently , the author proposed a new technique of _ recompression _ based on previous techniques of mehlhorn et .",
    "al@xcite ( for dynamic text equality testing ) , lohrey and mathissen  @xcite ( for fully compressed membership problem for nfas ) and sakamoto  @xcite ( for construction of the smallest grammar for the input text ) .",
    "this method was successfully applied to various problems related to grammar - compressed strings  @xcite .",
    "unexpectedly , this approach was also applicable to word equations , in which case alternative proofs of many known algorithmic results were obtained using a unified approach  @xcite .",
    "the technique is based on iterative application of two replacement schemes performed on the text @xmath13 :    pair compression of @xmath14 : :    for two different letters @xmath15 , @xmath16 such that    substring @xmath14 occurs in @xmath13 replace each of    @xmath14 in @xmath13 by a fresh letter @xmath17 .",
    "@xmath15 s block compression : :    for each maximal block @xmath18 , where @xmath15 is    a letter and @xmath19 , that occurs in @xmath13 ,    replace all @xmath18s in @xmath13 by a fresh letter    @xmath20 .    in one phase , pair compression ( block compression ) is applied to all pairs ( blocks , respectively ) that occurred at the beginning of this phase .",
    "ideally , each letter is then compressed and so the length of @xmath13 halves , in a worst - case scenario during one phase @xmath13 is still shortened by a constant factor .",
    "the surprising property is that such a schema can be efficiently applied to grammar - compressed data  @xcite or to text given in an implicit way , i.e.  as a solution of a word equation  @xcite . in order to do so ,",
    "local changes of the variables ( or nonterminals ) are needed : @xmath21 is replaced with @xmath22 ( or @xmath23 ) , where @xmath18 is prefix ( suffix , respectively ) of the substitution for @xmath21 . in this way",
    "the solution that substitutes @xmath24 ( or @xmath25 , respectively ) for @xmath21 is implicitly replaced with one that substitutes @xmath26 .      clearly ,",
    "as the recompression approach works for general word equations , it can be applied also to restricted subclasses . however , while in case of word equations it heavily relies on the nondeterminism , when restricted to instances with one variable it can be easily determinised ; section  [ sec : prelim ] recalls the main notions of word equations and recompression .",
    "furthermore , a fairly natural implementation has @xmath0 running time , so the same as the dbrowski and plandowski algorithm  @xcite ; this is presented in section  [ sec : main algorithm ] .",
    "furthermore adding a few heuristics , data structures as well as applying a more sophisticated analysis yields a linear running time , this is described in section  [ sec : faster ] .",
    "in this paper we present an algorithm for one - variable equation based on the recompression .",
    "it also provides a compact description of all solutions of such an equation .",
    "intuitively : when pair compression is applied , say @xmath14 is replaced by @xmath17 ( assuming it _ can _ be applied ) then there is a one - to - one correspondence of the solutions before and after the compression , this correspondence is simply an exchange of all @xmath14s by @xmath17s and vice - versa .",
    "the same applies to the block compression . on the other hand ,",
    "the modification of @xmath21 can lead to loss of solutions ( note that for technical reasons we do note consider the solution @xmath27 ) : when @xmath21 is to be replaced with @xmath22 the new equation has corresponding solutions for @xmath28 _ other than _ @xmath29 .",
    "so before the replacement , it is tested whether @xmath29 is a solution and if so , it is reported .",
    "the test itself is simple : both sides of the equation are read and their values under substitution @xmath29 are created on the fly and compared symbol by symbol , until a mismatch is found or both strings end .",
    "it is easy to implement the recompression so that one phase takes linear time .",
    "then the cost can be distributed to explicit words between the variables , each of them is charged proportionally to its length .",
    "consider such a string @xmath26 , if it is long enough , its length decreases by a constant factor in one phase , see lemma  [ lem : reducing length ] .",
    "thus , the cost of compressing this fragment and testing a solution can be charged to the lost length . however ,",
    "this is not true when @xmath26 is short and the @xmath30 summand in the running time comes from bounding the running time for such ` short ' strings .    in section  [ sec : faster ] it is shown that using a couple of heuristics as well as more involved analysis the running time can be lowered to @xmath2 .",
    "the mentioned heuristics are as follows :    * the problematic ` short ' words between the variables need to be substrings of the ` long ' words , this allows smaller storage size and consequently faster compression .",
    "* when we compare @xmath31 from one side of the equation with its copy ( i.e.  another occurrence @xmath31 ) on the other side , we make such a comparison in @xmath32 time ( using suffix arrays ) .",
    "* @xmath33 and @xmath34 ( perhaps offsetted ) are compared in @xmath35 time instead of naive @xmath36 , using simple facts from combinatorics on words .",
    "furthermore a more insightful analysis shows that problematic ` short ' words in the equation can be used to invalidate several candidate solutions fast , even before a mismatch in the equation is found during the testing .",
    "this allows a tighter estimation of the time spent on testing the solutions .      in order to perform the recompression efficiently , some algorithm for grouping pairs",
    "is needed .",
    "when we can identify the symbols in @xmath10 with consecutive numbers , the grouping can be done using radixsort in linear time .",
    "thus , all ( efficient ) applications of recompression technique make such an assumption . on the other hand ,",
    "the second of the mentioned heuristics craves checking string equality in constant time , to this end a suffix array  @xcite plus a structure for answering _",
    "longest common prefix query _ ( lcp ) is employed  @xcite on which we use range minimum queries  @xcite .",
    "the last structure needs the flexibility of the ram model to run in @xmath32 time per query .",
    "a _ word equation _ with one variable over the alphabet @xmath10 and variable @xmath21 is ` @xmath37 ' , where @xmath38 . during the run of algorithm wordeqsat",
    "we introduce new letters into @xmath39 , but no new variable is introduced . in this paper",
    "we shall consider only equations with one variable .    without loss of generality in a word equation @xmath37 one of @xmath40 and @xmath41",
    "begin with a variable and the other with a letter :    * if they both begins with the same symbol ( be it letter or nonterminal ) , we can remove this symbol from them , without affecting the set of solutions ; * if they begin with different letters , this equation clearly has no solution .",
    "the same applies to the last symbols of @xmath42 and @xmath43 .",
    "thus , in the following we assume that the equation is of the form @xmath44 where @xmath45 ( we call them _ words _ or _ explicit words _ ) and @xmath46 ( @xmath47 ) denote the number of @xmath21 occurrences in @xmath40 ( @xmath41 , respectively ) .",
    "note that exactly one of @xmath48 , @xmath49 is empty and @xmath50 is non - empty . if this condition is violated for any reason , we greedily repair it by cutting identical letters ( or variables ) from both sides of the equation .",
    "we say that @xmath50 is the _ first _ word of the equation and the non - empty of @xmath48 and @xmath49 is the _",
    "last word_. we additionally assume that none of words @xmath51 is empty . we later ( after lemma  [ lem : pop preserves solutions ] ) justify why this is indeed without loss of generality .    a _ substitution _",
    "@xmath28 assigns a string to @xmath21 , we expand it to @xmath52 with an obvious meaning .",
    "solution _ is a substitution such that @xmath53 . for a given equation @xmath37 we are looking for a description of all its solutions .",
    "we treat the empty solution @xmath27 in a special way and always assume that @xmath54 .",
    "note that if @xmath54 , then using   we can always determine the first ( @xmath15 ) and last ( @xmath16 ) letter of @xmath55 in @xmath32 time .",
    "in fact , we can determine the length of the @xmath15-prefix and @xmath16-suffix of x.    [ lem : a prefix ] for every solution @xmath28 of a word equation the first letter of x is the first letter of @xmath50 and the last the last letter of @xmath56 or @xmath49 ( whichever is non - empty ) .    if @xmath57 then @xmath58 for each solution @xmath28 of @xmath37 .",
    "if the first letter of @xmath50 is @xmath15 and @xmath59 then there is at most one solution @xmath58 , existence of such a solution can be tested ( and its length returned ) in @xmath60 time .",
    "furthermore , for @xmath61 the lengths of the @xmath15-prefixes of x and @xmath50 are the same .",
    "it is later shown that finding all solutions from @xmath62 can be done in linear time , see lemma  [ lem : a * solution ] .",
    "concerning the first claim , observe that the first letter of @xmath63 is the first letter of @xmath50 , while the first letter of @xmath64 is the first letter of x , hence those letters are equal .",
    "the same applies to the last letter of x and the last letter of @xmath48 or @xmath49 , whichever of them is non - empty .",
    "consider the case when @xmath57 and suppose that @xmath65 , let @xmath66 be the length of the @xmath15-prefix of x. the length of the @xmath15-prefix of @xmath67 is then @xmath68 , which is the length of the @xmath15-prefix of @xmath69 , contradiction .",
    "hence @xmath58 .",
    "consider now the case when @xmath50 begins with @xmath15 but @xmath59 , let its @xmath15-prefix has length @xmath70 .",
    "consider @xmath58 , say @xmath29 .",
    "let the first letter other than @xmath15 in @xmath41 be the @xmath71 letter in @xmath41 and let it be in explicit word @xmath72 .",
    "if there is no such @xmath72 then there is no solution @xmath58 , as then @xmath69 consists only of @xmath15s , which is not true for @xmath67 .",
    "the length of the @xmath15-prefix of @xmath67 is @xmath70 , while the length of the @xmath15-prefix of @xmath69 is @xmath73 . those two need to be equal , so @xmath74 and consequently @xmath75 , so this is the only candidate for the solution .",
    "it is easy to verify whether @xmath29 is a solution for a single @xmath76 in linear time .",
    "it is enough to compare @xmath63 and @xmath64 letter by letter , note that they can be created on the fly while reading @xmath77 and @xmath78 .",
    "each such comparison consumes one symbol from @xmath77 and @xmath78 ( note that if we compare a suffix of x , i.e.  some @xmath79 for @xmath80 , with @xmath29 we simply remove @xmath79 from both those strings ) .",
    "so the running time is linear .",
    "lastly , consider @xmath65 .",
    "then the @xmath15-prefix of @xmath67 has length @xmath70 and as @xmath61 , the @xmath15-prefix of @xmath69 is the same as the @xmath15-prefix of x , which consequently has length @xmath70 .",
    "symmetric version of lemma  [ lem : a prefix ] holds for the suffix of x.    by @xmath81 we denote a procedure , described in lemma  [ lem : a prefix ] , that for @xmath82 establishes the unique possible solution @xmath29 , tests it and returns @xmath76 if this indeed is a solution .",
    "consider any solution @xmath28 of @xmath37 .",
    "we claim that x is uniquely determined by its length and so when describing solution of @xmath37 it is enough to give their lengths .",
    "[ lem : solution form ] each solution @xmath28 of equation of the form   is of the form @xmath83 , where @xmath84 is a prefix of @xmath50 and @xmath85 .",
    "in particular , it is uniquely defined by its length .    if @xmath86 then @xmath55 is a prefix of @xmath50 , so x is uniquely determined by its length .",
    "when @xmath87 then @xmath67 begins with @xmath88 while @xmath69 begins with @xmath55 and thus x has a period @xmath50 .",
    "consequently , it is of the form @xmath89 , where @xmath84 is a prefix of @xmath50 .",
    "each letter in the current instance of our algorithm represents some string ( in a compressed form ) of the input equation , we store its _ weight _ which is the length of such a string .",
    "furthermore , when we replace @xmath21 with @xmath22 ( or @xmath23 ) we keep track of sum of weights of all letters removed so far from @xmath21 . in this way , for each solution of the current equation we know what is the length of the corresponding solution of the original equation ( it is the sum of weights of letters removed so far from @xmath21 and the weight of the current solution ) .",
    "therefore , in the following , we will not explain how we recreate the solutions of the original equation from the solution of the current one .",
    "we recall here the technique of recompression  @xcite , restating all important facts about it .",
    "note that in case of one variable many notions simplify .",
    "all subprocedures of the presented algorithm should preserve solutions , i.e.  there should be a one - to - one correspondence between solution before and after the application of the subprocedure .",
    "however , when we replace @xmath21 with @xmath22 ( or @xmath90 ) , some solutions may be lost in the process and so they should be reported .",
    "we formalise these notions .",
    "we say that a subprocedure _ preserves solutions _ when given an equation @xmath37 it returns @xmath91 such that for some strings @xmath92 and @xmath93 ( calculated by the subprocedure )    * some solutions of @xmath37 are reported by the subprocedure ; * for each unreported solution @xmath28 of @xmath37 there is a solution @xmath94 of @xmath91 , where @xmath95 and @xmath96 ; * for each solution @xmath94 of @xmath91 the @xmath95 is an unreported solution of @xmath37 .",
    "the intuitive meaning of these conditions is that during transformation of the equation , either we report a solution or the new equation has a corresponding solution ( and no new ` extra ' solutions ) .",
    "by @xmath97 we denote the string obtained from @xmath26 by replacing each @xmath17 by @xmath14 , which corresponds to the inverse of pair compression .",
    "we say that a subprocedure _ implements pair compression _ for @xmath14 , if it satisfies the conditions for preserving solutions above , but with @xmath98 and @xmath99 replacing @xmath95 and @xmath100 .",
    "similarly , by @xmath101 we denote a string with letters @xmath18 replaced with blocks @xmath18 ( note that this requires that we know , which letters ` are ' @xmath20 and what is the value of @xmath76 , but this is always clear from the context ) and we say that a subprocedure _ implements blocks compression _ for a letter @xmath15 .",
    "the intuitive meaning is the same as in case of preserving solutions : we not loose , nor gain any solutions .    given an equation @xmath37 , its solution @xmath28 and a pair @xmath102 occurring u ( or v ) we say that this occurrence is _ explicit _ , if it comes from substring @xmath14 of @xmath40 ( or @xmath41 , respectively ) ; _ implicit _ , if it comes ( wholly ) from x ; _ crossing _ otherwise .",
    "a pair is _ crossing _ if it has a crossing occurrence and _ non - crossing _ otherwise .",
    "similar notion applies to maximal blocks of @xmath15s , in which case we say that @xmath15 _ has a crossing block _ or it _ has no crossing blocks_. alternatively , a pair @xmath14 is crossing if @xmath16 is the first letter of x and @xmath103 occurs in the equation or @xmath15 is the last letter of x and @xmath104 occurs in the equation or @xmath15 is the last and @xmath16 the first letter of x and @xmath105 occurs in the equation .    unless explicitly stated , we consider crossing / non - crossing pairs @xmath14 for @xmath106 . note that as the first ( last ) letter of x is the same for each @xmath28 , see lemma  [ lem : a prefix ]",
    ", the definition of the crossing pair _ does not depend on the solution _ ; the same applies to crossing blocks .",
    "when a pair @xmath14 is non - crossing , its compression is easy , as it is enough to replace each explicit @xmath14 with a fresh letter @xmath17    let @xmath107 be an unused letter replace each explicit @xmath14 in @xmath40 and @xmath41 by @xmath17    similarly when none block of @xmath15 has a crossing occurrence , the @xmath15 s blocks compression consists simply of replacing explicit @xmath15 blocks .",
    "let @xmath108 be an unused letter replace every explicit @xmath15 s @xmath76-block occurring in @xmath40 or @xmath41 by @xmath20    [ lem : paircomp blockcomp ] let @xmath14 be a non - crossing pair then @xmath109 implements the pair compression for @xmath14 .",
    "let @xmath15 has no crossing blocks , then @xmath110 implements the block compression for @xmath15 .",
    "consider first the case of paircompncr .",
    "suppose that @xmath111 has a solution @xmath28 .",
    "define @xmath94 : @xmath112 is equal to x with each @xmath14 replaced with @xmath17 ( where @xmath17 is a new letter ) .",
    "consider @xmath63 and @xmath113 .",
    "then @xmath113 is obtained from @xmath67 by replacing each @xmath14 with @xmath17 ( as @xmath106 this is well - defined ) : the explicit occurrences of @xmath14 are replaced by @xmath109 , the implicit ones are replaced by the definition of @xmath94 and by the assumption there are no crossing occurrences .",
    "the same applies to @xmath64 and @xmath114 , hence @xmath94 is a solution of @xmath91 .",
    "since @xmath17 is a free letter , the @xmath67 is obtained from @xmath115 by replacing each @xmath17 with @xmath14 , the same applies to x and @xmath112 as well as @xmath69 and @xmath114 .",
    "hence @xmath116 and @xmath117 , as required by the definition of implementing the pair compression .",
    "lastly , for a solution @xmath94 of @xmath118 take the corresponding @xmath28 defined as @xmath117 ( i.e.  replacing each @xmath17 with @xmath14 in @xmath112 ) .",
    "it can be easily shown that @xmath119 and @xmath120 , thus @xmath28 is a solution of @xmath37 .",
    "the proof for the block compression follows in the same way .",
    "the main idea of the recompression method is the way it deals with the crossing pairs : imagine @xmath14 is a crossing pair , this is because @xmath121 and @xmath103 occurs in @xmath37 or @xmath122 and @xmath123 occurs in it ( the remaining case , in which @xmath124 and @xmath105 occurs in the equation is treated in the same way ) .",
    "the cases are symmetric , so we deal only with the first one . to ` uncross ' @xmath14 in this case it is enough to ` left - pop ' @xmath16 from @xmath21 : replace each @xmath21 in the equation with @xmath123 and implicitly change the solution to @xmath125 .",
    "note that before replacing @xmath21 with @xmath103 we need to check , whether @xmath126 is a solution , as this solution can not be represented in the new equation ; similar remark applies to replacing @xmath21 with @xmath104 .",
    "[ guess first letter ] report solution @xmath127 [ first letter test solution ] replace each @xmath21 in @xmath37 by @xmath123 [ leftpop ] [ guess last letter ] report solution @xmath126 replace each @xmath21 in @xmath37 by @xmath128 [ rightpop ]    [ lem : pop preserves solutions ] @xmath129 preserves solutions and after its application the pair @xmath14 is noncrossing .",
    "note that lemma  [ lem : pop preserves solutions ] justifies our earlier claim that without loss of generality we can assume that none of @xmath130 , @xmath131 is empty : at the beginning of the algorithm we can run @xmath129 once for @xmath15 being the first and @xmath132 the last letter of x. this ensures the claim and increases the size of the instance at most thrice .",
    "it is easy to verify that a pair @xmath14 is crossing if and only if one of the following situations occurs :    1 .",
    "[ cp1]@xmath103 occurs in the equation and the first letter of @xmath55 is @xmath16 ; 2 .",
    "[ cp2]@xmath104 occurs in the equation and the last letter of @xmath55 is @xmath15 ; 3 .",
    "[ cp3]@xmath105 occurs in the equation , the first letter of @xmath55 is @xmath16 and the last @xmath15 .",
    "let @xmath91 be the obtained equation , we show that @xmath14 in @xmath91 is noncrossing .",
    "consider whether @xmath21 was replaced by @xmath123 is line  [ leftpop ] .",
    "if not , then the first letter of x and @xmath112 is not @xmath16 , so @xmath14 can not be crossing because of ( ) nor ( ) . suppose that @xmath21 was replaced with @xmath123 .",
    "then to the left of each @xmath21 there is a letter which is not @xmath15 , so none of situations ( ) , ( ) occurs .",
    "a similar analysis applied to the last letter of x yields that ( ) can not happen and so @xmath14 can not be a crossing pair .",
    "pop can be naturally divided into two parts , which correspond to the replacement of @xmath21 by @xmath123 and the replacement of @xmath21 by @xmath128 .",
    "we show for the first one that it preserves solutions , the proof for the second one is identical .",
    "if x does not begin with @xmath16 ( recall that all solutions have the same first letter ) then nothing changes and the set of solutions is preserved .",
    "otherwise @xmath121 . in this case",
    "the solutions of the new equation shall be obtained by prepending @xmath16 to them .",
    "consider what happens with a solution @xmath121    if @xmath133 : :    then it is reported in line  [ first letter test solution ] ; if @xmath134 : :    then @xmath135 is a solution of the    obtained equation .",
    "note that the solution reported by pop is verified , so it is indeed a solution .",
    "furthermore , the only reported solutions is @xmath127 , none of which corresponds to a non - empty solution after popping .",
    "lastly , when @xmath135 is a solution after popping @xmath16 then clearly @xmath121 is a solution of @xmath37 .",
    "a symmetric analysis is done for the operation of right - popping @xmath15 , which ends the proof .",
    "now the presented procedures can be merged into one procedure that turns crossing pairs into noncrossing ones and then compresses them , effectively compressing crossing pairs .",
    "run @xmath129 run @xmath109 [ crossing pair compression ]    [ lem : crossing pairs preserve ] @xmath136 implements the pair compression of the pair @xmath14 .",
    "the proof follows by combining lemma  [ lem : paircomp blockcomp ] and [ lem : pop preserves solutions ] .",
    "there is one issue : the number of non - crossing pairs can be large , however , a simple preprocessing , which basically applies pop , is enough to reduce the number of crossing pairs to @xmath137 .",
    "let @xmath15 , @xmath16 be the first and last letter of x run @xmath129    [ lem : preproc preserves solutions ] @xmath138 preserves solution and after its application there are at most two crossing pairs .",
    "it is enough to show that there are at most @xmath137 crossing pairs , as the rest follows form lemma  [ lem : pop preserves solutions ] .",
    "let @xmath15 and @xmath16 be the first and last letters of x , and @xmath139 , @xmath140 such letters after the application of preproc . then",
    "each @xmath21 is proceeded with @xmath15 and succeeded with @xmath16 in @xmath91 .",
    "so the only crossing pairs are @xmath141 and @xmath142 ( note that this might be the same pair or part of a letter - block , i.e. @xmath143 or @xmath144 ) .",
    "the problems with crossing blocks can be solved in a similar fashion : @xmath15 has a crossing block if and only if @xmath145 is a crossing pair .",
    "so we ` left - pop ' @xmath15 from @xmath21 until the first letter of x is different than @xmath15 , we do the same with the ending letter @xmath16 .",
    "this can be alternatively seen as removing the whole @xmath15-prefix ( @xmath16-suffix , respectively ) from @xmath21 : suppose that @xmath146 , where @xmath26 does not begin with @xmath15 nor end with @xmath16 .",
    "then we replace each @xmath21 by @xmath147 implicitly changing the solution to @xmath125 , see algorithm  [ alg : prefix ] .",
    "@xmath50 is not a block of letters , the non - empty of @xmath48 , @xmath49 is not a block of letters let @xmath15 be the first letter of x report solution found by @xmath81 [ test prefix ] let @xmath148 be the length of the @xmath15-prefix of @xmath50 replace each @xmath21 in @xmath37 by @xmath22 , let @xmath16 be the last letter of x report solution found by @xmath149 let @xmath150 be the length of the @xmath16-suffix of the non - empty of @xmath48 , @xmath49    replace each @xmath21 in @xmath37 by @xmath90 ,    [ lem : cutpref cutsuff ] let @xmath15 be the first letter of the first word and @xmath16 the last of the last word . if the first word is not a block of @xmath15s and the last not a block of @xmath16s then cutprefsuff preserves solutions and after its application there are no crossing blocks of letters .",
    "consider first only the changes done by the modification of the prefix .",
    "suppose that @xmath151 , where @xmath26 does not begin with @xmath15 .",
    "if @xmath133 then as @xmath59 by lemma  [ lem : a prefix ] there is only one such solution and it is reported in line  [ test prefix ] .",
    "otherwise , by lemma  [ lem : a prefix ] , each solution @xmath28 of the equation is of the form @xmath152 , where @xmath18 is the @xmath15-prefix of @xmath50 and @xmath134 nor does it begin with @xmath15 .",
    "then the @xmath135 is the solution of the new equation .",
    "similarly , for any solution @xmath135 the @xmath152 is the solution of the original equation .",
    "the same analysis can be applied to the modifications of the suffix : observe that if at the beginning the last word was not a block of @xmath16s it did not become one during the cutting of the @xmath15-prefix .",
    "lastly , suppose that some letter @xmath17 has a crossing block , without loss of generality assume that @xmath17 is the first letter of x and @xmath153 occurs in the equation .",
    "but this is not possible : @xmath21 was replaced by @xmath22 and so the only letter to the left of @xmath21 is @xmath15 and x does not start with @xmath15 , contradiction .",
    "the cutprefsuff allows defining a procedure blockcomp that compresses maximal blocks of all letters , regardless of whether they have crossing blocks or not .",
    "@xmath154 letters occurring in the equation run cutprefsuff [ cut pref ] [ loop of compressions ] @xmath110 [ block compression local ]    [ lem : consistent no crossing block ] let @xmath15 be the first letter of the first word and @xmath16 the last of the last word . if the first word is not a block of @xmath15s and the last not a block of @xmath16s then blockcomp implements the block compression for letters present in @xmath37 before its application .",
    "the proof follows by combining lemma  [ lem : paircomp blockcomp ] and [ lem : cutpref cutsuff ] .",
    "the following algorithm onevarwordeq is basically a specification of the general algorithm for testing the satisfiability of word equations  @xcite and is built up from procedures presented in the previous section .",
    "[ alg : one mainloop ] @xmath155 pairs occurring in @xmath53 [ listing pairs ] blockcomp [ a * solution pref ] preproc [ preproc ] @xmath156 list of crossing pairs from _ pairs _ [ listing crossing pairs ] @xmath157 list of non - crossing pairs from _",
    "pairs_[listing noncrossing pairs ] @xmath109 [ pair compression onevar ] [ loop of outer onever ] @xmath136 [ pair compression onevar 2 ] testsolution    we call one iteration of the main loop a _ phase_.    [ thm : onevar ] onevarwordeq runs in time @xmath158 and correctly reports all solution of a word equation @xmath37 .    before showing the running time , let us first comment on how the equation is stored .",
    "each of sides ( @xmath40 and @xmath41 ) is represented as two lists of pointers to strings , i.e.  to @xmath50 , @xmath159 ,  , @xmath48 and to @xmath160 , @xmath161 ,  , @xmath49 .",
    "each of those words is stored as a doubly - linked list . when we want to refer to a concrete word in a phase , we use names @xmath130 and @xmath131 , when we want to stress its evolution in phases , we use names @xmath40 @xmath162-word and @xmath41 @xmath163-word .",
    "the most important property of onevarwordeq is that the explicit strings between the variables shorten ( assuming that they have a large enough length ) . to show this we use the following technical lemma , which is also used several times later on :    [ lem : shortening ] consider two consecutive letters",
    "@xmath15 , @xmath16 in @xmath67 for any solution @xmath28 .",
    "at least one of those letters is compressed in this phase .",
    "consider whether @xmath164 or not :    @xmath164 : :    then they are compressed using blockcomp .",
    "@xmath106 : :    then @xmath14 is a pair occurring in the equation at the    beginning of the phase and so it was listed in _ pairs _ in    line  [ listing pairs ] and as such we try to compress it , either in    line  [ pair compression onevar ] or in line  [ pair compression onevar 2 ] .",
    "this occurrence can not be compressed only when one of the letters    @xmath15 , @xmath16 was already compressed , in some other    pair or by blockcomp . in either case we are done .",
    "we say that a word @xmath130 ( @xmath72 ) is _ short _ if it consists of at most @xmath165 letters and _ long _ otherwise . to avoid usage of strange constants and its multiplicities ,",
    "we shall use @xmath166 to denote this value .",
    "[ lem : reducing length ] consider the length of the @xmath40 @xmath162-word ( or @xmath41 @xmath163-word ) .",
    "if it is long then its length is reduced by @xmath167 in this phase . if it is short then after the phase it still is .",
    "the length of each unreported solution is reduced by at least @xmath167 in a phase .",
    "additionally , if the first ( last ) word is short and has at least @xmath137 letters then its length is shortened by at least @xmath168 in a phase .",
    "we shall first deal with the words and then comment how this argument extends to the solutions . consider two consecutive letters @xmath15 , @xmath16 in any word at the beginning of a phase . by lemma  [ lem : shortening ]",
    "at least one of those letters is compressed in this phase .",
    "hence each uncompressed letter in a word ( the last letter ) can be associated with the two letters to the right that are compressed .",
    "this means that in a word of length @xmath169 during the phase at least @xmath170 letters are compressed i.e.  its length is reduced by at least @xmath171 letters .    on the other hand",
    ", letters are introduced into words by popping them from variables .",
    "let _ symbol",
    "_ denote a single letter or block @xmath18 that is popped into a word , we investigate , how many symbols are introduced in this way in one phase . at most one symbol",
    "is popped to the left and one to the right by blockcomp in line  [ a * solution pref ] , the same holds for preproc in line  [ preproc ] . moreover ,",
    "one symbol is popped to the left and one to the right in line  [ pair compression onevar 2 ] ; since this line is executed twice , this yields @xmath172 symbols in total .",
    "note that the symbols popped by blockcomp are replaced by single letters , so the claim in fact holds for letters as well .",
    "so , consider any word @xmath173 ( the proof for @xmath131 is the same ) , at the beginning of the phase and let @xmath174 be the corresponding word at the end of the phase",
    ". there were at most @xmath172 symbols introduced into @xmath174 ( some of them might be compressed later ) . on the other hand , by lemma  [ lem : shortening ]",
    ", at least @xmath175 letters were removed @xmath130 due to compression .",
    "hence @xmath176 it is easy to check that when @xmath130 is short , i.e.  @xmath177 , then @xmath174 is short as well and when @xmath130 is long , i.e.  @xmath178 then @xmath179 .",
    "it is left to show that the first word shortens by at least one letter in each phase .",
    "consider that if a letter @xmath15 is left - popped from @xmath21 then we created @xmath160 and in order to preserve   the first letters of @xmath160 and @xmath50 are removed .",
    "thus , @xmath50 gained one letter on the right and lost one on the left , so its length stayed the same . furthermore the right - popping does not affect the first word at all ( as @xmath21 is not to its left ) ; the same analysis applies to cutting the prefixes and suffixes .",
    "hence the length of the first word is never increased by popping letters .",
    "moreover , if at least one compression ( be it block compression or pair compression ) is performed inside the first word , its length drops .",
    "so consider the first word at the end of the phase let it be @xmath50 .",
    "note that there is no letter representing a compressed pair or block in @xmath50 : consider for the sake of contradiction the first such letter that occurred in the first word .",
    "it could not occur through a compression inside the first word ( as we assumed that it did not happen ) , cutting prefixes does not introduce compressed letters , nor does popping letters .",
    "so in @xmath50 there are no compressed letters .",
    "but if @xmath180 then this contradicts lemma  [ lem : shortening ]",
    ".    now , consider a solution x. we know that x is either a prefix of @xmath50 or of the form @xmath181 , where @xmath84 is a prefix of @xmath50 , see lemma  [ lem : solution form ] . in the former case ,",
    "x is compressed as a substring of @xmath50 . in the latter",
    "observe that argument follows in the same way ,",
    "as long as we try to compress every pair of letters in x. so consider such a pair @xmath14 .",
    "if it is inside @xmath50 then we are done .",
    "otherwise , @xmath15 is the last letter of @xmath50 and @xmath16 the first .",
    "then this pair occurs also on the crossing between @xmath50 and @xmath21 in @xmath40 , i.e.  @xmath14 is one of the crossing pairs .",
    "in particular , we try to compress it .",
    "so , the claim of the lemma holds for x as well .",
    "the correctness of the algorithm follows from lemmata  [ lem : consistent no crossing block ] ( for blockcomp ) , lemma  [ lem : preproc preserves solutions ] ( for preproc ) , lemma  [ lem : paircomp blockcomp ] ( for paircompncr ) , lemma  [ lem : crossing pairs preserve ] ( for paircomp ) and from the lemma below , which deals with testsolution .",
    "[ lem : a * solution ] for @xmath182 we can report all solutions in which @xmath29 for some natural @xmath76 in @xmath183 time . there is either exactly one @xmath76 for which @xmath29 is a solution or @xmath29 is a solution for each @xmath76 or there is no solution of this form .",
    "note that we do not assume that the first or last word is a block of @xmath15s .",
    "the algorithm and proof is similar as in lemma  [ lem : a prefix ] . consider a substitution @xmath29 .",
    "we calculate the length of the @xmath15-prefix of @xmath63 and @xmath64 .",
    "consider first letter other than @xmath15 in @xmath40 , let it be in the @xmath184 and suppose that there were @xmath70 letters @xmath15 before it ( if there is non such letter , imagine we attach an ` ending marker ' to both @xmath40 and @xmath41 , which then becomes such letter ) . then the length of the @xmath15-prefix of @xmath67 is @xmath185 .",
    "let additionally @xmath186 be obtained from @xmath40 by removing those letters @xmath15 and variables in between them .",
    "similarly , define @xmath187 , @xmath188 and @xmath189 .",
    "then the length of the @xmath15-prefix of @xmath64 is @xmath190 .",
    "the substitution @xmath29 is a solution if and only if @xmath191 and @xmath192 .",
    "consider the number of natural solutions of the equation @xmath193    no natural solution : :    clearly there is no solution of the word equation    @xmath37 ; one solution @xmath194 : :    then @xmath29 is the only possible    solution from @xmath62 of    @xmath37 . to verify",
    "whether    @xmath28 satisfies @xmath91 we    apply the same strategy as in    @xmath81 :    we evaluate both sides of @xmath91    under the substitution @xmath29 on    the fly . the same argument as in lemma",
    "[ lem : a prefix ] shows that the    running time is linear in @xmath195 satisfied by all natural numbers : :    then the @xmath15-prefixes of @xmath40 and    @xmath41 are of the same length for each    @xmath196 .",
    "we thus repeat the    procedure for @xmath91 , shortening them    so that they obey the form  , if needed .",
    "clearly , solutions in    @xmath197 of @xmath91 are    exactly the solutions of @xmath37 in    @xmath197 .",
    "the stopping condition for the recurrence above is obvious : if @xmath186 and @xmath189 are both empty then we are done ( each @xmath29 is a solution of this equation ) , if exactly one of them is empty and the other is not then there is no solution at all .",
    "lastly , observe that the cost of the subprocedure above is proportional to the amount of read letters , which are then not read again , so the running time is @xmath60      concerning the running time , we first show that one phase runs in linear time , which follows by standard approach , and then that in total the running time is @xmath0 . to this end",
    "we assign in a fixed phase to each @xmath40 @xmath162 word and @xmath41 @xmath163 word cost proportional to its length . for a fixed @xmath40 @xmath162 word the sum of costs assigned while it was long forms a geometric sequence , so sums up to at most constant more than the initial length of @xmath40 @xmath162 word ; on the other hand the cost assigned",
    "when @xmath40 @xmath162 word is short is @xmath32 per phase ad there are @xmath198 phases .",
    "[ lem : one iteration cost ] one phase of onevarwordeq can be performed in @xmath60 time .",
    "for grouping of pairs and blocks we use radixsort , to this end it is needed that the alphabet of ( used ) letters can be identified with consecutive numbers , i.e.  with an interval of at most @xmath199 integers . in the first phase of onevarwordeq this follows from the assumption on the input . : in such case we can use radixsort to sort @xmath39 in time @xmath183 and then replace @xmath39 with set of consecutive natural numbers .",
    "] at the end of this proof we describe how to bring back this property at the end of the phase .",
    "to perform blockcomp we want for each letter @xmath15 occurring in the equation to have lists of all maximal @xmath15-blocks occurring in @xmath37 ( note that after cutprefsuff there are no crossing blocks , see lemma  [ lem : cutpref cutsuff ] ) .",
    "this is done by reading @xmath37 and listing triples @xmath200 , where @xmath169 is the length of a maximal block of @xmath15s and @xmath201 is a pointer to the beginning of this occurrence .",
    "notice , that the maximal block of @xmath15 s may consist also of prefixes / suffixes that were cut from @xmath21 by cutprefsuff .",
    "however , by lemma  [ lem : a prefix ] such a prefix is of length at most @xmath202(and similar analysis applies for the a suffix ) .",
    "then each maximal block includes at most one such prefix and one such suffix thus the length of the @xmath15 maximal block is at most @xmath203 .",
    "hence , the triples @xmath200 can be sorted by their first two coordinates using radixsort in total time @xmath183 .",
    "after the sorting , we go through the list of maximal blocks . for a fixed letter @xmath15",
    ", we use the pointers to localise @xmath15 s blocks in the rules and we replace each of its maximal block of length @xmath204 by a fresh letter . since the blocks of @xmath15 are sorted , all blocks of the same length are consecutive on the list , and replacing them by the same letter is easily done .    to compress all non - crossing pairs , i.e.  to perform the loop in line  [ pair compression onevar ] , we do a similar thing as for blocks : we read both @xmath40 and @xmath41 , whenever we read a pair @xmath14 where @xmath106 and both @xmath15 and @xmath16 are not letters that replaced blocks during the blocks compression , we add a triple @xmath205 to the temporary list , where @xmath201 is a pointer to this position . then we sort all these pairs according to lexicographic order on first two coordinates , we use radixsort for that . since in each phase",
    "we number the letters occurring in @xmath37 using consecutive numbers , this can be done in time @xmath183 .",
    "the occurrences of the crossing pairs can be removed from the list : by lemma  [ lem : preproc preserves solutions ] there are at most two crossing pairs and they can be easily established ( by looking at @xmath206 ) .",
    "so we read the sorted list of pairs occurrences and we remove from it the ones that correspond to a crossing pair .",
    "lastly , we go through this list and replaces pairs , as in the case of blocks . note that when we try to replace @xmath14 it might be that this pair is no longer there as one of its letters was already replaced , in such a case we do nothing",
    "this situation is easy to identify : before replacing the pair we check whether it is indeed @xmath14 that we expect there , as we know @xmath15 and @xmath16 , this is done in costant time .",
    "we can compress each of the crossing pairs naively in @xmath183 time by simply first applying the popping and then reading the equation form the left to the right and replacing occurrences of this fixed pair .",
    "it is left to describe , how to enumerate ( with consecutive numbers ) letters in @xmath39 at the end of each phase .",
    "firstly notice that we can easily enumerate all letters introduced in this phase and identify them ( at the end of this phase ) with @xmath207 , where @xmath208 is the number of introduced letters ( note that none of them were removed during the wordeqsat ) .",
    "next by the assumption the letters in @xmath39 ( from the beginning of this phase ) are already identified with a subset of @xmath209 , we want to renumber them , so that the subset of letters from @xmath39 that are present at the end of the phase is identified with @xmath210 for an appropriate @xmath211 . to this end",
    "we read the equation , whever we spot a letter @xmath15 that was present at the beginning of the phase we add a pair @xmath212 where @xmath201 is a pointer to this occurrence .",
    "we sort the list in time @xmath213 . from this list",
    "we can obtain a list of present letters together with list of pointers to their occurrences in the equation . using those pointers",
    "the renumbering is easy to perform in @xmath213 time .",
    "so the total running time is @xmath213 .",
    "the amortisation , especially in the next section , is much easier to be shown when we know that both the first and last words are long .",
    "this assumption is not restrictive , as as soon as one of them becomes short , the remaining running time of wordeqsat is linear .",
    "[ lem : first is short ] as soon as first or last word becomes short , the rest of the running time of onevarwordeq is @xmath2 .",
    "one phase takes @xmath213 time by lemma  [ lem : one iteration cost ] ( this is at most @xmath2 by lemma  [ lem : reducing length ] ) and as lemma  [ lem : reducing length ] guarantees that both the first word and the last word are shortened by at least one letter in a phase , there will be at most @xmath214 many phases .",
    "lastly , lemma  [ lem : a * solution ] shows that testsolution also runs in @xmath2 .",
    "so it remains to estimate the running time until one of the last or first word becomes short .",
    "[ lem : till one is first ] the running time of onevarwordeq till one of first or last word becomes short is @xmath215 .    by lemma  [ lem : one iteration cost ]",
    "the time of one iteration of onevarwordeq is @xmath60 .",
    "we distribute the cost among the @xmath40 words and @xmath41 words : we charge @xmath216 to @xmath40 @xmath162-word and @xmath217 to @xmath41 @xmath163-word , for appropriate positive @xmath218 .",
    "fix @xmath40 @xmath162-word , we separately estimate how much was charged to it when it was a long and short word .",
    "long : :    let @xmath219 be the initial length of    @xmath40 @xmath162-word .",
    "then by    lemma  [ lem : reducing length ] the length in the @xmath220-th    phase it at most @xmath221 and so these costs    are at most    @xmath222 .",
    "short : :    since @xmath40 @xmath162-word is short , its    length is at most @xmath223 , so we charge at most    @xmath224 to it .",
    "notice , that there are    @xmath8 iterations of the loop in total ,    as first word is of length at most @xmath3 and it shortens by    @xmath225 in each iteration when it is long and we    calculate only the cost when it is long .",
    "hence we charge in this way    @xmath8 times , so in total    @xmath8 .",
    "summing those costs over all phases over all words and phases yields @xmath226 .",
    "the intuition gained from the analysis in the previous section , especially in lemma  [ lem : till one is first ] is that the main obstacle in obtaining the linear running time is the necessity of dealing with short words , as the time spend on processing them is difficult to charge .",
    "this applies to both the compression performed within the short words , which does not guarantee any reduction in length , see lemma  [ lem : reducing length ] , and to testing of the candidate solutions , which can not be charged to the length decrease of the whole equation .",
    "observe that by lemma  [ lem : first is short ] as soon as the first or last word becomes short , the remaining running time is linear .",
    "hence , in our improvements of the running time we can restrict ourselves to the case , in which the first and last word are long .",
    "several equations : :    instead of a single equation , we store a system of several equations    and look for a solution of such a system .",
    "this allows removal of some    words from the equations that always correspond to each other . and    thus decreases the overall storing space and testing time .",
    "this is    described in section  [ subsec : several ] and section  [ subsec : storing ] .",
    "small solutions : :    we identify a class of particularly simple solutions , called _ small _ ,    and show that a solution is reported within    @xmath32 phases from the moment when it became    small . in several problematic cases of the analysis we are able to    show that the solutions involved are small and so it is easier to    charge the time spent on testing them .",
    "section  [ subsec : small ] is    devoted to this issue .",
    "storage : :    the storage is changed so that all words are represented by a    structure of size proportional to the size of the _ long words_. in    this way the storage space decreases by a constant factor in each    phase and so the running time ( except for testing ) is linear .",
    "this is    explained in section  [ subsec : storing ] testing : :    the testing procedure is modified , so that the time it spends on the    short words is reduced . in particular , we improve the rough estimate    that one testsimplesolution takes time proportional to the equation to    an estimation that actually counts for each word whether it was    included in the test or not .",
    "section  [ subsec : testing ] is devoted to    this .",
    "we use a standard data structure for comparisons on strings : a suffix array @xmath227 $ ] for a string @xmath228 $ ] stores the @xmath208 non - trivial suffixes of @xmath26 , that is @xmath229 , w[m-1{\\mathinner{\\ldotp\\ldotp}}m ] , \\ldots , w[1{\\mathinner{\\ldotp\\ldotp}}m]$ ] in ( increasing ) lexicographical order . in other words ,",
    "@xmath230 = p$ ] if and only if @xmath231 $ ] is the @xmath169-th suffix according to the lexicographical order .",
    "it is known that such an array can be constructed in @xmath232 time  @xcite assuming that radixsort is applicable to letters , i.e.  that they are integers from @xmath233 for some constant @xmath17 .",
    "we assume explicitly that this is the case in our problem .",
    "using a suffix array the equality testing for substrings of @xmath26 reduces to the _ longest common prefix _",
    "( lcp ) query : observe that @xmath234 = w[j { \\mathinner{\\ldotp\\ldotp}}j+k]$ ] if and only if the common prefix of @xmath235 $ ] and @xmath236 $ ] is at least @xmath169 . the first step in constructing a data structure for answering such queries is the lcp array : for each @xmath237 the @xmath238 $ ] stores the length of the longest common prefix of @xmath239 $ ] and @xmath240 $ ] . given a suffix array ,",
    "the lcp array can be constructed in linear time  @xcite , however , the linear - time construction of suffix arrays can be in fact extended to return also the lcp array  @xcite .    when the lcp array is supplied , the general longest prefix queries reduce to the range minimum queries : the longest common prefix of @xmath239 $ ] and @xmath241 $ ] ( for @xmath242 ) is the minimum among @xmath238 , \\ldots , lcp[j-1]$ ] , and so it is enough to have a data structure that answers the queries about the minimum in the range in constant time .",
    "such data structures in general case are known and in case of lcp arrays even simpler construction were given  @xcite .",
    "the construction time is linear and query time is @xmath32  @xcite .",
    "hence , after a linear preprocessing , we can calculate the length of the longest common prefix of two substrings of a given string in @xmath32 time .",
    "the improved analysis assumes that we do not store a single equation , instead , we store several equations and look for substitutions that simultaneously satisfy all of them .",
    "hence we have a collection @xmath243 of equations , for @xmath244 , each of them is of the form described by  ; by @xmath37 we denote the whole system of those equations . in particular , each of those equations specifies the first and last letter of the solution , length of the @xmath15-prefix and suffix etc .",
    ", exactly in the same way as it does for a single equation .",
    "if there is a conflict , as two equations give different answers regarding the first / last letter or the length of the @xmath15-prefix or @xmath16-suffix , then there is no solution at all .",
    "still , we do not check the consistency of all those answers , instead , we use an arbitrary equation , say @xmath245 , to establish the first , last letter , etc . , and",
    "as soon as we find out that there is a conflict , we stop the computation and terminate immediately .",
    "the system of equations stored by onevarwordeq is obtained by replacing one equation @xmath246 ( where @xmath247 ) with equivalent two equations @xmath248 and @xmath249 ( note that in general the latter two equation are not equivalent to the former one , however , we perform the replacement only when they are ; moreover , we need to trim them so that they satisfy the form  ) .",
    "the described way of splitting the equations implies a natural order on the equations in the system : when @xmath246 is split to @xmath248 and @xmath249 then @xmath248 is before @xmath249 ( moreover , they are both before / after each equation before / after which @xmath246 was ) .",
    "this order is followed whenever we perform any operations on all words of the equations .",
    "we store a list of all equations , in this order .",
    "we store each of those equations in the same way as described for a single equation in the previous phase , i.e.for an equation @xmath243 we store a list of pointers to words on one side and list of pointers to words on the other side .",
    "additionally , the first word of @xmath250 has a link to the last word of @xmath251 and the last word of @xmath250 similarly , the last word of @xmath250 has a link to the first word of @xmath250 and the first word of @xmath252 .",
    "we also say that @xmath130 ( @xmath131 ) is first or last if it is in any of the stored equations .",
    "all operations on a single equation introduced in the previous sections ( popping letters , cutting prefixes and suffixes , pair compression , blocks compression ) generalise to a system of equations .",
    "the running times are addressed in detail later on . concerning the properties",
    ", they are the same , we list those for which the generalisation or the proof are non - obvious : preproc should ensure that there are only two crossing pairs .",
    "this is the case , as each @xmath21 in every equation is replaced by the same @xmath253 and @xmath55 is the same for all equations , which is the main fact used in the proof of lemma  [ lem : preproc preserves solutions ] .",
    "lemma  [ lem : reducing length ] ensured that in each phase the length of the first and last word is decreased .",
    "currently the first words in each equation may be different , however , the analysis in lemma  [ lem : reducing length ] applies to each of them .",
    "we say that a word @xmath26 is _ almost periodic _ with _ period size _ @xmath201 and _ side size _ @xmath254 if it can be represented as @xmath255 ( where @xmath76 is an arbitrary number ) , where @xmath256 and @xmath257 ; we often call @xmath258 the _ periodic part _ of this factorisation .",
    "( note that several such representation may exist , we use this notion for a particular representation that is clear from the context ) .",
    "a substitution @xmath28 is _ small _ , if @xmath259 , where @xmath26 , @xmath93 are almost periodic with period and side sizes @xmath223 .",
    "intuition is as follows : observe first that in each phase we make pop and test whether @xmath126 , where @xmath15 is a single letter , is a solution .",
    "thus it is enough to show that a small solution is reduced to one letter within @xmath32 phases . to see this ,",
    "consider first an almost periodic word , represented as @xmath260 .",
    "ideally , all compressions performed in one phase of onevarwordeq are done separately on @xmath261 , @xmath262 and each @xmath258 . in this way",
    "we obtain a string @xmath263 and from lemma  [ lem : shortening ] it follows that @xmath264 is shorter than @xmath265 by a constant fraction .",
    "after @xmath266 steps we obtain a word @xmath267 in which @xmath268 is a single letter , and so in this phase @xmath269 is replaced with a single letter .",
    "then , since the length of @xmath270 is at most @xmath223 , after @xmath32 phases this is also reduced to a single letter .",
    "concerning the small solution , @xmath271 we first make such an analysis for @xmath26 , when it is reduced to a single letter ( after @xmath32 phases ) after one additional phase @xmath272 is also reduced to one letter ( by blockcomp ) and so the obtained string @xmath273 is a concatenation of two almost periodic strings . using the same analysis as above for each of them",
    "we obtain that it takes @xmath32 time to reduce them all to single letters .",
    "thus we have a @xmath137-letter string , which is reduced to a single letter within @xmath137 phases .    in reality",
    "we need to take into the account that some compression are made on the crossings of the considered strings , however , we can alter the factorisation ( into almost periodic words and almost periodic words into periodic part and rest ) of the string so that the result is almost as in the idealised case .",
    "we say that for a substring @xmath26 of x during one phase of onevarwordeq the letters in @xmath26 are _ compressed independently _ , if every compressed pair or block were either wholly within this @xmath26 or wholly outside this @xmath26 ( in some sense this corresponds to the non - crossing compression ) .",
    "the following lemma shows that given an almost periodic substring of x with period size @xmath201 and side size @xmath254 we can find an alternative representation in which the period size is the same , side size increases ( a bit ) but each @xmath26 in @xmath274 in this new representation is compressed independently .",
    "this shows that the intuition about shortening of almost periodic strings is almost precise  we can think that periodic part in almost periodic strings are compressed independently , but we need to pay for that by an increase in the side size .",
    "[ lem : small solution partition ] consider almost periodic substring of x with period size @xmath201 and side size @xmath254 represented as @xmath275 , where @xmath26 is not a block of single letter .",
    "then there is a representation of this string as @xmath276 such that    * @xmath277 * @xmath278 ( and consequently @xmath279 ) * the form of @xmath280 depends solely on @xmath258 and does not depend on @xmath261 , @xmath262 ( it does depend on the equation and on the order of blocks and pairs compressed by onevarwordeq ) * the compression in one phase of onevarwordeq compresses each @xmath281 from @xmath282 independently .",
    "first of all , if @xmath284 then we take @xmath285 , @xmath286 and concatenate @xmath287 to @xmath261 to obtain @xmath288 ( and take @xmath289 ) .",
    "so in the following we consider the case in which @xmath290 and set @xmath291 .",
    "let @xmath292 , where @xmath293 , @xmath294 and @xmath295 does not start with @xmath15 nor it ends with @xmath16 , such a representation is possible , as @xmath258 is not a block of letters . then @xmath296 .",
    "since @xmath261 can end with @xmath15 and @xmath258 can begin with @xmath16 , we are interested in compressions within the middle @xmath297 . we first show that indeed there is a compression of a substring that is fully within the @xmath297 :    * if @xmath298 or @xmath299 then we compress the block @xmath300 or @xmath301 . * if @xmath302 , @xmath164 then @xmath303 is a block and it is compressed . * if @xmath302 , @xmath106 and @xmath304 then this substring is @xmath305 . as @xmath290",
    "the pair @xmath14 is listed by onevarwordeq and we try to compress it . if we fail then it means that one of the letters was already compressed with a letter inside the considered string . *",
    "if @xmath302 and @xmath106 and @xmath306 then @xmath307 is listed among the pairs and we try to compress the occurrence right after the first @xmath308 .",
    "if we fail then it means that one of the letters was compressed with its neighbouring letter , which is also in the string .",
    "consider the first substring that is compressed and it is wholly within @xmath297 .",
    "there are two cases : the compressed substring is a block of letters or it is a pair . we give a detailed analysis in the latter case , the analysis in the former case is similar .",
    "so , let the first pair compressed wholly within this fragment @xmath297 be @xmath309 , see fig .",
    "[ fig : factors ] for an illustration .",
    "we claim that all pairs @xmath309 that occurred within this fragment at the beginning of the phase are compressed at this moment .",
    "assume for the sake of contradiction that this is not the case .",
    "so this means that one of the letters , say @xmath17 was already compressed in some other compression performed earlier . by the choice of the compressed pair ( i.e.  @xmath309 ) , this @xmath17 is compressed with a letter from outside of the fragment @xmath310 , there are two possibilities :    @xmath17 is the last letter of @xmath297 : :    observe that the letter succeeding @xmath17 is either    @xmath16 or a letter representing a compressed pair / string . in    the latter case",
    "we do not make a further compression , so it has to be    @xmath16 .",
    "this is a contradiction : each @xmath17 that is    a last letter of @xmath308 was initially followed by    @xmath16 , and so in fact some compression of @xmath311    ( note that by our choice the last letter of @xmath308 was not    @xmath16 , and so @xmath312 ) was performed wholly    within @xmath297 and it was done    earlier than the compression of @xmath309 , contradiction with    the choice of @xmath309 .",
    "@xmath17 is the first letter of @xmath297 : :    the argument is symmetric , with @xmath15 preceding    @xmath17 in this case .",
    "there are at least @xmath314 occurrences of @xmath309 that are separated by @xmath315 letters , i.e.  the @xmath316 is a substring of @xmath297 , for some @xmath313 of length @xmath315 , see fig .",
    "[ fig : factors ] .",
    "we take @xmath317 and let @xmath288 be the @xmath261 concatenated with string proceeding the @xmath316 and @xmath318 the @xmath262 concatenated with the string following this @xmath319 ( note that the latter includes the ending @xmath309 , see fig .",
    "[ fig : factors ] ) . clearly @xmath320 and consequently @xmath321 .",
    "note that each @xmath280 begins with @xmath309 , which is the first substring even partially within @xmath280 that is compressed , furthermore , each of those @xmath280 is also followed by @xmath309 .",
    "so the compression inside each @xmath280 is done independently ( because by the choice of @xmath309 there was no prior compression applied in @xmath280 ) .",
    "the immediate consequence of lemma  [ lem : small solution partition ] is that when an almost periodic string is a substring of @xmath28 , then we can give bounds on the period size and side size on the corresponding word after one phase of onevarwordeq .",
    "[ lem : shortening of the almost periodic word ] consider an almost periodic substring of x with period size @xmath201 and side size @xmath254 .",
    "then the corresponding substring after the phase of onevarwordeq has a factorisation with period size at most @xmath323 and side size at most @xmath324 .",
    "there are two remarks : firstly , if period size of the original word was @xmath168 then the given bound is @xmath325 , which holds , i.e.  the corresponding word has no periodic part in the factorisation .",
    "secondly , the first ( last ) letter of the substring may be compressed with the letter to the left ( tight , respectively ) , so outside of the considered substring .",
    "in such a case we still include the letter representing the replaced pair or block in the corresponding substring .",
    "let us fix the factorisation @xmath326 of @xmath26 , where @xmath327 is the period size and @xmath328 is the side size .",
    "first of all , consider the special case , in which @xmath258 is a block of letters , say @xmath15 , without loss of generality we may assume that it is a single letter ( note that this simple borderline case is not covered by lemma  [ lem : small solution partition ] ) . without loss of generality",
    "we also may assume that @xmath261 does not end and @xmath262 does not begin with @xmath15 , as otherwise we can move those letters to @xmath329 , decreasing the side size and not increasing the period size . then during the block compression",
    "the @xmath330 is going to be replaced by a single letter ( this block may also include some letters from outside of @xmath26 , when @xmath261 or @xmath262 is empty , this does not affect the analysis ) .",
    "now consider @xmath261 : its first letter can be compressed with letters outside it , otherwise each letter not compressed in the phase , except perhaps the last one , is followed by two letters that are , see lemma  [ lem : shortening ] .",
    "hence at most @xmath331 letters are uncompressed and so the length of the corresponding compressed @xmath288 is at most @xmath332 and similarly for @xmath318 its length is at most @xmath333 . adding @xmath168 for the letter replacing @xmath329 we obtain @xmath334 , as claimed .    in other cases ,",
    "by lemma  [ lem : small solution partition ] we can refactor @xmath26 into @xmath335 such that @xmath336 and @xmath337 and each @xmath338 is compressed independently ( note that @xmath339 ) . then after one phase of onevarwordeq the corresponding word @xmath281 can be represented as @xmath340 .",
    "let us inspect its compression rate .",
    "the argument for @xmath341 and @xmath342 is the same as for @xmath261 and @xmath258 in the previous case , so @xmath343 and @xmath344 . as @xmath336 ,",
    "the new side size is at most @xmath345 , as @xmath346 . for the period size ,",
    "consider @xmath338 . by lemma  [ lem :",
    "shortening ] , each uncompressed letter ( perhaps except the last one ) is followed by a compressed one , and so @xmath347 . for @xmath348 this yields the desired compression rate @xmath225 , for @xmath349 and @xmath350 observe that by lemma  [ lem : shortening ] at least one letter inside @xmath338 is compressed and we know that the compressions inside @xmath338 are done independently , so @xmath351 , which yields the desired bound for those two border cases .",
    "imagine now we want to make a similar refactoring also for the small word ( in order to draw conclusions about shortening of x , which is small ) .",
    "so take @xmath271 where both @xmath26 and @xmath93 are almost periodic words ( with some period sizes and side sizes ) and @xmath169 is some number .",
    "when we look at @xmath274 , each single @xmath26 can be refactored so that its periodic part is compressed independently .",
    "note that this is the same word , i.e.  we are still given @xmath271 , though we have in mind a different factorisation of @xmath26 .",
    "however , the compression of the @xmath26 is influenced by the neighbouring letters , so while each of the middle @xmath26 in @xmath352 is compressed in the same way , both the first and the last @xmath26 can be compressed differently .",
    "hence , after the compression we obtain something of the form @xmath353 , where @xmath354 are almost periodic . in the next phase the process continues and we accumulate almost periodic words on both sides of @xmath355 .",
    "so in general we deal with a word of the form @xmath356 , where @xmath26 is almost periodic and @xmath357 are concatenations of almost periodic words .",
    "the good news is that we can bound the sum of side sizes and period sizes of almost periodic words occurring in @xmath92 , @xmath93 .",
    "moreover , the period size of @xmath26 drops by a constant factor in each phase , so after @xmath32 phases it is reduced to @xmath358 , i.e.  @xmath274 is almost periodic .    as a first technical step",
    "we show that lemma  [ lem : small solution partition ] can be used to analyse what happens with a concatenation of almost periodic words in one phase of onevarwordeq : as in the case of a single word , see lemma  [ lem : shortening of the almost periodic word ] , the sum of period sizes drops by a constant factor , while the sum of side sizes drops by a constant factor but it increases by magnitude of sum of period sizes .",
    "[ lem : shortening of the almost periodic word concatenation ] let @xmath92 , a substring of x , be a concatenation of almost periodic words with a factorisation for which the sum of period sizes if @xmath201 and side sizes is @xmath254 . then after one phase of onevarwordeq the corresponding string @xmath359 is a concatenation of almost periodic words with a factorisation for which the sum of period sizes is at most @xmath360 and sum of side sizes is at most @xmath324 .",
    "note that as in the case of lemma  [ lem : shortening of the almost periodic word ] when sum of the period sizes is @xmath168 , then after one phase we are guaranteed that all almost periodic words in the factorisation have empty periodic parts .",
    "moreover , as in the case of lemma  [ lem : shortening of the almost periodic word ] the first and last letter of @xmath92 may be compressed with the letters outside @xmath92 , in which case we include in the corresponding word the letters that are obtained in this way .",
    "let the promised factorisation of @xmath92 into almost periodic words be @xmath361 .",
    "we apply lemma  [ lem : shortening of the almost periodic word ] to each of them . by a simple summation of the guarantees from lemma  [ lem : shortening of the almost periodic word ]",
    "the bound on the size of the period sizes is @xmath323 while the bound on the sum of the side sizes is @xmath324 .",
    "the following lemma is the crowning stone of our considerations .",
    "it gives bounds on the period sizes and side sizes for the word that can be represented as @xmath362 , where @xmath26 is almost periodic and @xmath363 are concatenations of almost periodic words .",
    "[ lem : new sizes ] suppose that at the beginning of the phase of onevarwordeq a substring of @xmath364 can be represented as @xmath365 , where @xmath26 is almost periodic with period size @xmath366 and side size @xmath367 while @xmath357 are concatenations of almost periodic words , let the sum of their period sizes be @xmath368 and side sizes @xmath369 .",
    "then the corresponding substring at the end of the phase can be represented as @xmath370 , where @xmath281 is almost periodic with period size @xmath371 and side size @xmath372 and @xmath373 are concatenations of almost periodic words , the sum of their period sizes is @xmath374 and the sum of their side sizes @xmath375 at most @xmath376 .",
    "consider the factorisation of @xmath26 as an almost periodic word .",
    "consider first the main case , in which the periodic part of @xmath26 is not a block of single letter .",
    "then we can apply lemma  [ lem : small solution partition ] to each @xmath26 , obtaining a factorisation @xmath255 such that @xmath377 and @xmath378 .",
    "then @xmath362 can be represented as @xmath379 define @xmath380 and @xmath381 , they are concatenations of almost periodic words , the sum of their period sizes is @xmath382 while side sizes @xmath383 . define also @xmath384 , observe that each such @xmath281 is delimited by @xmath258 ( it includes it in the left end and to the right there is a copy of it which is not inside this @xmath281 ) and each @xmath258 is compressed independently , so also each @xmath281 is compressed independently , so in particular it is compressed in the same way .",
    "thus @xmath385 is compressed into @xmath386 , let us estimate their sizes .",
    "for @xmath359 and @xmath387 can can straightforwardly apply lemma  [ lem : shortening of the almost periodic word concatenation ] , obtaining that the sum of their period sizes is at most @xmath388 while their side sizes @xmath389 .",
    "concerning @xmath281 : we apply lemma  [ lem : shortening of the almost periodic word ] , which shows that the new period size is at most @xmath390 and new side size @xmath391 , so all as claimed .",
    "let us return to the trivial case , in which @xmath255 and @xmath258 is a block of a single letter .",
    "note that without a loss of generality , we can assume that @xmath258 is a single letter ( we replace @xmath329 with @xmath392 ) and that @xmath261 does not end and @xmath262 does not begin with @xmath15 ( we can move those letters to @xmath258 , decreasing side size and not increasing the period size ) . then @xmath393 . if @xmath394 this is equal to @xmath395 , we treat @xmath396 as a almost periodic word with period size @xmath168 and side size @xmath358 , so @xmath397 have a sum of period sizes @xmath398 and sum of side sizes @xmath369 .",
    "applying lemma  [ lem : shortening of the almost periodic word concatenation ] yields the claim : the sum of period sizes is at most @xmath388 while the new side sizes @xmath399 .",
    "similarly , when @xmath400 we can treat @xmath401 as a concatenation of almost periodic words , the sum of their period sizes is at most @xmath402 and side sizes @xmath403 ; again , applying lemma  [ lem : shortening of the almost periodic word concatenation ] yields the claim : the sum of period sizes is at most @xmath388 while the new side sizes @xmath404 .",
    "so let us go back to the main case , in which @xmath405 and @xmath406 .",
    "then @xmath407 . as @xmath408 is non - empty and does not end , nor begin with @xmath15 , each @xmath18 in @xmath409",
    "is compressed independently .",
    "we set @xmath410 , @xmath411 and @xmath412 . applying lemma  [ lem : shortening of the almost periodic word concatenation ] to @xmath359 and @xmath281 yields that after one phase the sum of period sizes is @xmath413 while side size @xmath414 . on the other hand ,",
    "the period size of @xmath415 is @xmath390 while its side size at most @xmath416      consider the string x. we show that within @xmath417 this string is reduced to a single letter .",
    "this means that x is reported in the same time .",
    "note that in the following phases the corresponding solution ( if unreported ) _ is not _ the corresponding string , as we also pop letters from @xmath21 .",
    "however , the corresponding solution is the substring of this string .",
    "so fix a small solution and its occurrence within @xmath67 .",
    "it can be represented as @xmath271 , where @xmath26 and @xmath93 are almost periodic with period and side size @xmath223 we claim that in each following phase the corresponding string can be represented as @xmath418 , where @xmath359 and @xmath387 are concatenations of almost periodic words , the sum of their period sizes is at most @xmath419 while side sizes @xmath420 .",
    "also , @xmath281 is almost periodic with side size at most @xmath421 and period size dropping by @xmath225 in each phase ( and at most @xmath223 at the beginning ) .",
    "this claim can be easily verified by induction on the estimations given by lemma  [ lem : new sizes ] .",
    "as the period size of @xmath281 drops by @xmath225 in each phase and initially it is @xmath223 , after @xmath422 phases @xmath281 has period size @xmath358 .",
    "then inside @xmath418 we treat @xmath355 as a periodic word with period size @xmath423 and side size @xmath358 .",
    "thus @xmath418 is a concatenation of almost periodic words with sum of period sizes at most @xmath424 and sum of side size at most @xmath420 .",
    "then , by easy induction on bounds given by lemma  [ lem : shortening of the almost periodic word concatenation ] , in the following phases the corresponding string will be a concatenation of almost periodic strings , with sum of period sizes decreasing by @xmath225 in each phase ( and initial value @xmath425and sum of side sizes at most @xmath420 . thus after @xmath422 phase its sum of period sizes is reduced to @xmath358 and so it is a string of length at most @xmath420 , which will be reduced to a single letter within @xmath422 rounds , as claimed . since @xmath214 .      to reduce the running time we store duplicates of short word only once .",
    "recall that for each equation we store lists of pointers pointing to strings that are the explicit words in this equation .",
    "we store the long words in a natural way , i.e.  each long word is represented by a separate string .",
    "the short words are stored more efficiently : if two short words in equations are equal we store only one string , to which both pointers point . in this way",
    "all identical short words are stored only once ( though each of them has a separate pointer pointing to it ) ; we call such a representation",
    "_ succinct_.",
    "we show that the compression can be performed on the succinct representation , without the need of reading the actual equation .",
    "this allows bounding the running time using the size of the succinct representation and not the equation .",
    "we distinguish two types of short words : those that are substrings of long words ( normal ) and those that are not ( overdue ) .",
    "we can charge the cost of processing the normal short words to the time of processing the long words .",
    "the overdue words can be removed from the equation after @xmath32 phases after becoming overdue , so their processing time is constant per @xmath40-@xmath162 word ( or @xmath41-@xmath163 word ) .",
    "* we first give precise details , how we store short and long words , see section  [ subsubsec : storing details ] and prove that we can perform compression using only succinct representation , see lemma  [ lem : words are equal ] . *",
    "we then define precisely the normal and overdue words , see section  [ subsubsec : overdue ] as well as show that we can identify new short and overdue words , see lemma  [ lem : identify overdue ] .",
    "then we show that overdue words can be removed @xmath32 phases after becoming overdue , see lemma  [ lem : overdue can be removed ] and [ lem : overdue ] . *",
    "lastly , in section  [ subsubsec : compression time ] , we show that the whole compression time , summed over all phases is @xmath2 .",
    "the analysis is done separately for long words normal short words and overdue short words .    as observed at the beginning of section  [ sec : faster ] ,",
    "as soon as the first or last word becomes short , the remaining running time is linear .",
    "thus , when such a word becomes short , we drop our succinct representation and recreate out of it the simple representation used in sections[sec : prelim][sec : main algorithm ] .",
    "such a recreation takes linear time .",
    "we give some more details about the storing : all long words are stored on two doubly - linked lists , one representing the long words on the left - hand sides and the other the long words on the right - hand sides .",
    "those words are stored on the lists according to the initial order of the words in the input equation .",
    "furthermore , for each long word we store additionally , whether it is a first or last word of some equation ( note that a short word can not be first or last ) .",
    "the short words are also organised as a list , the order on the list is irrelevant .",
    "each short word has a list of its occurrences in the equations , the list points to the occurrences in the natural order ( occurrences on the left - hand sides and on the right - hand sides are stored separately ) .",
    "we say that such a representation is _ succinct _ and its size is the sum of lengths of words stored in it ( so the sum of sizes of long words , perhaps with multiplicities , plus the sum of sizes of different short words ) . note that we do _ not _ include the number of pointers from occurrences of short words .",
    "we later show that in this way we do not need to actually read the whole equation in order to compress it ; it is enough to read the words in the succinct representation , see lemma  [ lem : compression cost ] .",
    "[ lem : words are equal ] consider any explicit words @xmath84 and @xmath132 in the input equation .",
    "suppose that during onevarwordeq they were transformed to @xmath426 , none of which is a first or last word in one of the equations .",
    "then @xmath427 if and only if @xmath426 .    by induction on operation performed by onevarwordeq .",
    "since none of the @xmath428 , @xmath429 is the first or last word in the equation , it means that during the whole onevarwordeq they had @xmath21 to the left and to the right .",
    "so whenever a letter was left - popped or right - popped from @xmath21 , it was prepended or appended to both @xmath84 and @xmath132 ; the same applies to cutting prefixes and suffixes .",
    "compression is never applied to a crossing pair or a crossing block , so after it two strings are equal if and only if they were before the operation .",
    "the removal of letters ( in order to preserve  ) is applied only to first and last words , so it does not apply to words considered here . partitioning the equation into subequations does not affect the equality of explicit words .",
    "the long words are stored in a list and we can compress them without the need of reading the word table . we know which one of them is first or last , so when letters are popped from @xmath21 we know what letters are appended / prepended to each of those words .",
    "since they are stored explicitly , the claim for them follows from the analysis of the original version of onevarwordeq , see lemma  [ lem : one iteration cost ] .",
    "this analysis in particular requires that we can identify the letters used in the equation with numbers from an interval of linear size . here",
    "the size is the size of the succinct representation .",
    "note though that this part of the proof follows in the same way : when listing letters ( to replace them with new ones ) we do not need to list letters in different occurrences of the same short word , it is enough to do this once , which can be done using the succinct representation .    for the short words stored in the list of short words , from lemma  [ lem :",
    "words are equal ] it follows that if an explicit word @xmath84 occurs twice in the equations ( both times not as a first , nor last word of the equation ) it is changed during onevarwordeq in the same way at both those instances .",
    "so it is enough to perform the operations on the words stored in the list , doing so as in the original version of onevarwordeq takes time linear in the size of the tables of short words , as in lemma  [ lem : one iteration cost ] .",
    "the short words stored in the tables are of two types : normal and overdue .",
    "normal _ words are substrings of the long words or @xmath430 and consequently the sum of their sizes is proportional to the size of the long words .",
    "a word becomes _ overdue _ if at the beginning of the phase it is not a substring of a long word nor @xmath430 .",
    "it might be that it becomes a substring of such a word later , it does not stop to be an overdue word in such a case .",
    "since the normal words are of size @xmath431 , the sum of lengths of normal words stored in short word list is at most @xmath32 larger than the sum of sizes of the long words .",
    "hence the processing time of normal short words can be charged to the long words .",
    "for the overdue words the analysis is different : we show that after @xmath32 phases we can remove them from the equation ( splitting the equations ) .",
    "thus their processing time is @xmath32 per @xmath40-@xmath162 word ( or @xmath41-@xmath163 word ) and thus @xmath2 in total .",
    "consider all long words @xmath50 , ",
    ", @xmath432 ( with or without multiplicities , it does not matter ) and all short ( not already overdue ) words @xmath433 , ",
    "@xmath434 , without multiplicities ; in both cases this is just a listing of words stored in the representation ( except for old overdue words ) .",
    "we construct a suffix array for the string @xmath435 as it was already observed that the size of the alphabet is linear in the size of the succinct representation , the construction of the suffix array can be done in linear time  @xcite .",
    "now @xmath436 is a factor in some @xmath437 ( the case of @xmath430 is similar , it is omitted to streamline the presentation ) if and only if for some suffix @xmath438 of @xmath437 the strings @xmath439 and @xmath440 have a common prefix of length at least @xmath441 . in terms of a suffix array ,",
    "the entries for @xmath440 and @xmath442 should have a common prefix of length at least @xmath441 . recall that the length of the longest common prefix of two suffixes stored at positions @xmath443 in the suffix array is the minimum of @xmath444 $ ] , @xmath445 $ ] ,  , @xmath446 $ ] .    for fixed suffix @xmath440",
    "we want to find @xmath442 ( where @xmath438 is a suffix of some long word @xmath437 ) with which it has the longest common prefix .",
    "as the length of the common prefix of @xmath201th and @xmath447th entry in a suffix array is @xmath448 , lcp[p+1 ] , \\ldots , lcp[p'-1])$ ] , this is is either the first previous or first next suffix of this form in the suffix array .",
    "thus the appropriate computation can be done in linear time : we first go down in the suffix array , storing the last spotted entry corresponding to a suffix of some long @xmath437 , calculating the lcp with consecutive suffixes and storing them for the suffixes of the form @xmath440 .",
    "we then do the same going from the bottom of the suffix array .",
    "lastly , we choose the larger from two stored values ; for @xmath440 it is smaller than @xmath441 if and only if @xmath174 just became an overdue word .",
    "first we need to define what does it mean that for solution word @xmath84 in one side of the equation is at the same position as its copy on the other side of the equation : we say that for a substitution @xmath28 the explicit word @xmath130 ( or its subword ) is _ arranged against _",
    "the explicit word @xmath131 ( x for some fixed occurrence of @xmath21 ) if the position within @xmath449 occupied by this explicit word @xmath130 ( or its subword ) are within the positions occupied by explicit word @xmath131 ( x , respectively ) in @xmath450 .",
    "[ lem : overdue can be removed ] consider a short word @xmath84 in a phase in which it becomes overdue .",
    "then for each solution x either @xmath28 is small or in every @xmath451 each explicit word @xmath130 equal to @xmath84 is arranged against another explicit word @xmath131 equal to @xmath84 .",
    "consider an equation and a solution @xmath28 such that in some @xmath452 an explicit word @xmath130 ( equal to an overdue word @xmath84 ) is not arranged against another explicit word equal to @xmath84 .",
    "there are three cases :      note that in this case @xmath84 is a substring of x. either x is a substring of @xmath50 or @xmath453 , where @xmath454 is a prefix of @xmath50 . in the former case",
    "@xmath84 is a factor of @xmath50 , which is a contradiction , in the latter it is a factor of @xmath455 .",
    "as @xmath50 is long and @xmath84 short , it follows that @xmath456 and so @xmath84 is a factor of @xmath430 , contradiction with the assumption that @xmath84 is overdue .",
    "since @xmath84 is an overdue word , this means that @xmath130 is arranged against a short word @xmath131 .",
    "note that both @xmath130 and @xmath131 are preceded and succeeded by x , since @xmath459 we conclude that x has a period at most @xmath460 , see fig .",
    "[ fig : arranged ] ; in particular @xmath28 is small .",
    "since @xmath130 is not arranged against any word , nor arranged against x , it means that some substring of @xmath130 is arranged against x and as @xmath130 is preceded and succeeded by x , this means that either x is shorter than @xmath130 or it has a period at most @xmath461 , see figure  [ fig : misarranged1 ] and  [ fig : misarranged2 ] , respectively . in both cases",
    "@xmath28 is small .",
    "observe that due to theorem  [ thm : solution with small height ] and lemma  [ lem : overdue can be removed ] the @xmath40-@xmath162-words and @xmath41-@xmath163-words that are overdue can be removed in @xmath32 phases after becoming overdue : suppose that @xmath84 becomes an overdue word in phase @xmath76 .",
    "any solution , in which an overdue word @xmath84 is not arranged against another occurrence of @xmath84 is small and so it is reported after @xmath32 phases .",
    "consider an equation @xmath243 in which @xmath84 occurs .",
    "then the first occurrence of @xmath84 in @xmath250 and the first occurrence of @xmath84 in @xmath462 are arranged against each other for each solution @xmath28 . in particular , we can write @xmath243 as @xmath463 , where @xmath250 and @xmath464 do not have @xmath84 as an explicit word ( recall that @xmath84 is not the first , nor the last word in @xmath243 ) .",
    "this equation is equivalent to two equations @xmath465 and @xmath249 .",
    "this procedure can be applied recursively to @xmath249 . in this way , all occurrences of @xmath84 are removed and no solutions are lost in the process",
    ". there may be many overdue strings so the process is a little more complicated , however , as each word can be removed once during the whole algorithm , in total it takes @xmath2 time .    [",
    "lem : overdue ] consider the set of overdue words introduced in phase @xmath76 .",
    "then in phase @xmath466 we can remove all occurrences of overdue words from the equations .",
    "the obtained set of equations has the same set of solutions .",
    "the amortised time spend on removal of overdue words , over the whole run of onevarwordeq , is @xmath467 .",
    "consider any word @xmath84 that become overdue in phase @xmath76 and any solution @xmath28 of this equation , such that in some @xmath452 the explicit word @xmath84 is not arranged against another instance of the same explicit word",
    ". then due to lemma  [ lem : overdue can be removed ] the x is small .",
    "consequently , from theorem  [ thm : solution with small height ] this solution is reported before phase @xmath468 , for some constant @xmath17 .",
    "so any solution @xmath94 in phase @xmath468 corresponds to a solution @xmath28 from phase @xmath76 that had each explicit word @xmath84 arranged in each @xmath452 against another explicit word @xmath84 . since all operations in a phase either transform solution , implement the pair compression of implement the blocks compression for a solution x , it follows that in phase @xmath468 the corresponding overdue words @xmath428 are arranged against each other in @xmath469 .",
    "moreover , by lemma  [ lem : words are equal ] each explicit word @xmath428 in this phase corresponds to an explicit word @xmath84 in phase @xmath76 .",
    "this observation allows removing all overdue words introduced in phase @xmath76 .",
    "let @xmath470 , @xmath471 , ",
    ", @xmath472 ( in phase @xmath468 ) correspond to all overdue words introduced in phase @xmath76 . by lemma  [ lem :",
    "identify overdue ] we have already identified the overdue words . using the list of short words , for each overdue word @xmath473",
    ", we have the list of pointers to occurrences of @xmath473 in left - hand sides of the equations and right - hand sides of the equations , those lists are sorted according to the order of occurrences . in phase",
    "@xmath468 we go through those lists , if the first occurrences of @xmath84 in the left - hand sides and right - hand sides are in different equations then the equations are not satisfiable , as this would contradict that in each solution both @xmath84 is arranged against its copy . otherwise , they are in the same equation @xmath243 , which is of the form @xmath463 , where @xmath474 and @xmath475 do not have any occurrence of @xmath84 within them .",
    "we split @xmath243 into two equations @xmath465 and @xmath249 and we trim them so that they are in the form described in  .",
    "the new equations have exactly the same set of solutions as the original one .",
    "note that as new equations are created , we need to reorganise the pointers from the first / last words in the equations , however , this is easily done in @xmath32 time .",
    "the overall cost can be charge to the removed @xmath21 , which makes in total at most @xmath467 cost .        by lemma  [ lem : compression cost ]",
    "the cost of compression is linear in terms of the size of the succinct representation by lemma  [ lem : identify overdue ] in the same time bounds we can also identify the overdue words .",
    "lastly , by lemma  [ lem : overdue can be removed ] the total cost of removing the overdue words is @xmath2 .",
    "so it is enough to show that the sum of sizes of the succinct representations summed over all phases is @xmath2 .    when the overdue words are excluded , the size of the succinct representation is proportional to the total length of long words . since by lemma  [ lem : reducing length ] this sum of lengths decreases by a constant in each phase , the sum of those costs is linear in @xmath3 .    concerning the costs related to the overdue words :",
    "note that an @xmath40 @xmath162-word or @xmath41 @xmath163-word is overdue for only @xmath32 phases , after which it is deleted from the equation see lemma  [ lem : overdue ] .",
    "so in @xmath32 phases it is charged @xmath431 cost , during the whole run of onevarwordeq .",
    "summing over all @xmath40 @xmath162-words and @xmath41 @xmath163-words yields @xmath2 time .",
    "we already know that thanks to appropriate storing the compression of the equations can be performed in linear time .",
    "it remains to explain how to test the solutions fast , i.e.  how to perform testsimplesolution when all first and last words are still long .",
    "recall that testsimplesolution checks whether @xmath28,which is of the form @xmath29 for some @xmath76 , is a solution by comparing @xmath364 and @xmath476 letter by letter , replacing @xmath21 with @xmath18 on the fly .",
    "we say that in such a case a letter @xmath16 in @xmath364 is _ tested against _ the corresponding letter in @xmath476 .",
    "note that during the testing we do not take advantage of the smaller size of the succinct representation , so we need to make a separate analysis .",
    "consider two letters , from @xmath130 and @xmath131 , that are tested against each other .",
    "if one of @xmath130 and @xmath131 is long , this can be amortised against the length of the long word .",
    "the same applies when one of the words @xmath477 or @xmath478 is long .",
    "so the only problematic case is when all of those words are short . to deal with this case",
    "efficiently we distinguish between different test types , in which we exploit different properties of the solutions to speed up the tests . in the end , we show that the total time spent on testing is linear .    for a substitution @xmath28 by a _ mismatch _",
    "we denote the first position on which @xmath28 is shown not be a solution , i.e.  sides of the equation have different letters ( we use a natural order on the equations ) ; clearly , a solution has no mismatch .",
    "furthermore , onevarwordeq stops the testing as soon as it finds a mismatch , so in the rest of this section , if we use a name _ test _ for a comparison of letters , this means that the compared letters are before the mismatch ( or that there is no mismatch at all ) .",
    "there are two preliminary technical remarks : first we note that for when testing a substitution @xmath28 , for a fixed occurrence of @xmath21 there is at most explicit word whose letters are tested against letters from this occurrence of @xmath21 .",
    "and @xmath479 both have their letters arranged against letters from fixed occurrence of @xmath21 .",
    "then the @xmath21 separating them is a proper substring of another @xmath21 , contradiction.[fig : protected ] ]    [ lem : against x ] fix a tested substitution @xmath28 and an occurrence of @xmath21 in the equation .",
    "then there is at most one explicit word whose letters are arranged against letters from this fixed occurrence of x.    without loss of generality assume that @xmath21 occurs within @xmath480 in an equation @xmath481 .",
    "suppose that @xmath131 and @xmath479 ( for @xmath482 ) have their letters arranged against a letter from this fixed occurrence of x , see fig  [ fig : protected ] .",
    "but @xmath131 and @xmath479 are separated by at least one @xmath21 in the equation , and whole this @xmath21 is also arranged against this fixed occurrence of @xmath21 , contradiction .    as a second remark ,",
    "observe that tests include not only explicit letters from @xmath483 and @xmath484 but also letters from x. in the following we will focus on tests in which at least one letter comes from an explicit word .",
    "it is easy to show that the time spent on other tests is at most as large as time spent on those tests .",
    "this follows from the fact that such other tests boil down to comparison of long blocks of @xmath15 and the previous test is of a different type , so we can account the comparison between two long blocks of @xmath15 to the previous test .",
    "however , our fast testing procedures in some times makes a series of tests in @xmath32 time , so this argument can be made precise only after the explanation of the details of various testing optimisations .",
    "for this reason the proof of lemma  [ lem : only letter tests ] is delayed till the end of this section .",
    "suppose that for a substitution @xmath28 a letter from @xmath130 is tested against a letter from @xmath485 or a letter from @xmath131 is tested against a letter from @xmath486 ( the special case , when there is no explicit word after @xmath21 is explained later ) .",
    "we say that this test is :    protected : :    if at least one of @xmath130 , @xmath477 ,    @xmath131 , @xmath478 is long ; failed : :    if @xmath130 , @xmath477 , @xmath131 and    @xmath478 are short and a mismatch for @xmath28 is    found till the end of @xmath477 or @xmath478 ; aligned : :    if @xmath487 and @xmath488 , all of    them are short and the first letter of @xmath130 is tested    against the first letter of @xmath131 ; misaligned : :    if all of @xmath130 , @xmath477 , @xmath131 ,    @xmath478 are short , @xmath489 or    @xmath490 and this is not an aligned nor failed    test ; periodical : :    if @xmath491 , @xmath492 , all of    them are short and this is not an aligned nor failed test .      *",
    "if @xmath130 is not followed by @xmath21 in the equation then @xmath130 is a last word , in particular it is long",
    ". therefore this test is protected . *",
    "if @xmath130 is followed by @xmath21 then there is a mismatch till the end of @xmath493 , so this test is failed .    observe that ` failed test ' does not mean a mismatch , just a fact that soon there will be a mismatch .",
    "the protected , misaligned and failed tests are done in a letter - by - letter way , while the aligned and periodical tests are made in larger groups ( in @xmath32 time per group , this of course means that we use some additional data structures ) .",
    "it is easy to show that there are no other tests , see lemma  [ lem : no other test ] .",
    "we separately calculate the cost of each type of tests .",
    "as some tests are done in groups , we distinguish between number of tests of a particular type ( which is the number of letter - to - letter comparisons ) and the time spent on test of a particular type ( which may be smaller , as group of tests are performed in @xmath32 time ) ; the latter includes also the time needed to create and sustain the appropriate data structures .    for failed tests note that they take constant time per phase and we know that there are @xmath8 phases .",
    "for protected tests , we charge the cost of the protected test to the long word and only @xmath494 such tests can be charged to one long word @xmath473 in a phase . on the other hand ,",
    "each long word is shortened by a constant factor in a phase , see lemma  [ lem : reducing length ] , and so this cost can be charged to those removed letters and thus the total cost of those tests ( over the whole run of onevarwordeq ) is @xmath2 .    in case of the misaligned tests",
    ", it can be shown that @xmath28 in this case is small and that it is tested at the latest @xmath32 phases after the last of @xmath477 , @xmath130 , @xmath495 , @xmath72 becomes short , so this cost can be charged to , say , @xmath72 becoming short and only @xmath32 such tests are charged to this @xmath72 ( over the whole run of the algorithm ) .",
    "hence the total time of such tests is @xmath2 .    for the aligned tests ,",
    "consider the consecutive aligned tests , they correspond to comparison of @xmath496 and @xmath497 , where @xmath498 for @xmath499 .",
    "so to perform them efficiently , it is enough to identify the maximal ( syntactically ) equal substrings of the equation and from lemma  [ lem : words are equal ] it follows that this corresponds to the ( syntactical ) equality of substrings in the original equation . such an equality can be tested in @xmath32 using a suffix array constructed for the input equation ( and general lcp queries on it ) . to bound the total running time it is enough to notice that the previous test is either misaligned or protected .",
    "there are @xmath2 such tests in total , so the time spent on aligned tests is also linear .",
    "for the periodical test suppose that we are to test the equality of ( suffix of ) @xmath500 and ( prefix of ) @xmath501 .",
    "if @xmath502 then the test for @xmath477 and @xmath478 is the same as for @xmath130 and @xmath131 and so can be skipped .",
    "if @xmath503 then the common part of @xmath500 and @xmath501 have periods @xmath504 and @xmath505 and consequently has a period @xmath506 .",
    "so it is enough to test first common @xmath507 letters and check whether @xmath504 and @xmath505 have period @xmath507 , which can be checked in @xmath32 time .          without loss of generality ,",
    "consider a test of a letter from @xmath130 and from @xmath508 .",
    "if any of @xmath477 , @xmath478 , @xmath130 or @xmath131 is long then it is protected ( this includes the case in which some of @xmath477 , @xmath131 , @xmath478 does not exist ) . concerning the running time ,",
    "for each explicit word we keep a flag , whether it is short or long . furthermore , as each explicit word has a link to its successor and predecessor , we can establish whether any of @xmath477 , @xmath478 , @xmath130 or @xmath131 is long in @xmath32 time .",
    "so consider the case in which all @xmath477 , @xmath478 , @xmath130 or @xmath131 ( if they exist ) are short , which also can be established in @xmath32 time",
    ". it might be that this test is failed ( again , some of the words @xmath477 , @xmath131 , @xmath478 may not exist ) , too see this we need to make some look - ahead tests , but this can be done in @xmath509 time ( we do not treat those look - aheads as tests , so there is not recursion here ) .    otherwise ,",
    "if the first letter of @xmath130 and @xmath131 are tested against each other and @xmath487 and @xmath488 then the test is aligned ( clearly this can be established in @xmath32 time using look - aheads ) .",
    "otherwise , if @xmath489 or @xmath490 then it is misaligned ( again , @xmath32 time for look - aheads ) . in the remaining case @xmath510 and @xmath492 , so this is a periodical test .",
    "as noticed , there are @xmath32 substitutions tested per phase .",
    "suppose that the mismatch is for the letter from @xmath130 and a letter from @xmath511 ( the case of @xmath512 and @xmath131 is symmetrical ) .",
    "then the failed tests include at least one letter from @xmath513 or @xmath514 , assuming they come from a short word .",
    "there are at most @xmath515 failed tests that include a letter from @xmath516 , @xmath130 , @xmath517 , @xmath518 ( as the test is failed then in particular this explicit word is short ) . concerning the tests including the short occurrences of @xmath21 in - between them",
    ", observe that by lemma  [ lem : against x ] each such @xmath21 can have tests with at most one short word , so this gives additional @xmath519 tests .",
    "since @xmath214 , we conclude that there are @xmath32 failed tests per phase and so @xmath8 failed tests in total , as there are @xmath8 phases , see lemma  [ lem : reducing length ] .",
    "as already claimed , the total number of protected tests is linear in terms of length of long words : to show this it is enough to charge the cost of the protected test to the appropriate long word and see that a long word @xmath84 can be charged only @xmath461 such tests for test including letters from @xmath84 and @xmath32 letters from neighbouring short words , which yields @xmath520 tests . as the length of the long words drops by a constant factor , summing this up over all phases in which this explicit word is long yields @xmath2 tests in total .",
    "[ lem : protected is linear ] in one phase the total number of protected tests is proportional to the length of the long words . in particular , there are @xmath2 such test during the whole run of onevarwordeq .",
    "as observed in lemma  [ lem : only letter tests ] we can consider only tests in which at least one letter comes from an explicit word . suppose that a letter from @xmath130 takes part in the protected test ( the argument for a letter from @xmath131 is similar , it is given later on ) and it is tested against a letter from @xmath511 , then one of @xmath130 , @xmath477 , @xmath131 , @xmath478 is long , we charge the cost according to this order , i.e.  we charge it to @xmath130 if it is long , if @xmath130 is not but @xmath477 is long , we charge it to @xmath477 , if not then to @xmath518 if it is long and otherwise to @xmath478 .",
    "the analysis and charging for a test of a letter from @xmath131 is done in a symmetrical way ( note that when the test includes two explicit letters , we charge it twice , but this is not a problem ) .",
    "now , fix some long word @xmath130 , we estimate , how many protected tests can be charged to it .",
    "it can be charged with cost of tests that include its own letters , so @xmath521 tests .",
    "when @xmath516 is short , it can also charge tests in which its letters take part .",
    "as it is short , it is at most @xmath431 such tests .",
    "also some @xmath41 words can charge the cost of tests to @xmath130 , we can count only the test in which letters from @xmath522 do not take part .",
    "this can happen in two situations : letters tested against @xmath512 and letters tested against @xmath523 ( in which case we additionally assume that @xmath516 is short ) . we have already accounted the tests made against @xmath516 and @xmath130 and by lemma  [ lem : against x ] for each occurrence of @xmath21 there is at most one explicit short word whose letters are tested against this occurrence of @xmath21 . so there are additionally at most @xmath524 tests of this form .",
    "so in total @xmath522 is charged only @xmath525 in a phase . from lemma  [",
    "lem : reducing length ] the sum of lengths of long words drops by a constant factor in each phase , and as in the input it is at most @xmath3 , the total sum of number of protected tests is @xmath2 .",
    "on the high level , in this section we want to show that if there is a misaligned test then the tested solution is small and use this fact for accounting the cost of such tests . however , this statement is trivial , as we test only solutions of the form @xmath526 for some @xmath169 , which are always small . to make this statement more meaningful ,",
    "we generalise the notion of a misaligned test for arbitrary substitutions , not only the tested one . in this way",
    "two explicit words @xmath130 and @xmath131 can be misaligned for a substitution @xmath28 .",
    "we show three properties of this notion :    1 .",
    "[ m1 ] if there is a misaligned test for a substitution @xmath28 for a letter from @xmath130 against letter in @xmath511 or a letter from @xmath131 against letter from @xmath512 then @xmath130 and @xmath131 are misaligned for @xmath28 .",
    "this is shown in lemma  [ lem : definition reformulation ] .",
    "2 .   [ m2 ] if there are misaligned words @xmath130 and @xmath131 for a solution @xmath28 then @xmath28 is small , as shown in lemma  [ lem : low height for misaligned ] .",
    "[ m3 ] if @xmath130 and @xmath131 are misaligned for @xmath28 in a phase @xmath76 then @xmath28 is reported in phase @xmath76 or the corresponding words @xmath174 and @xmath527 in phase @xmath528 are also misaligned for the corresponding @xmath94 , see lemma  [ lem : misaligned earlier ] .",
    "those properties are enough to improve the testing procedure so that one @xmath40 @xmath162-word ( or @xmath41 @xmath163-word ) takes part in only @xmath32 misaligned tests : suppose that @xmath130 becomes small in phase @xmath76 .",
    "then all solutions , for which it is misaligned with some @xmath131 , are small by  ( ) . hence , by theorem  [ thm : solution with small height ] , all of those solutions are reported ( in particular : tested ) within the next @xmath17 phases , for some constant @xmath17 .",
    "thus , if @xmath130 takes part in a misaligned test ( for @xmath28 ) in phase @xmath529 then @xmath28 is not a solution : by  ( ) also in phase @xmath76 the @xmath130 and @xmath131 were misaligned ( for the corresponding solution @xmath94 ) , and solution @xmath94 was reported before phase @xmath530 .",
    "hence we can immediately terminate the test ; therefore @xmath130 can take part in misaligned tests in phases @xmath76 , @xmath528 , ",
    ", @xmath468 , i.e.  @xmath32 ones .",
    "this plan is elaborated in this section , in particular , some technical details ( omitted in the above description ) are given .      * a mismatch for @xmath28",
    "is not found till the end of @xmath477 or @xmath478 ; * all @xmath477 , @xmath130 , @xmath478 and @xmath131 are short ; * either @xmath532 or @xmath533 * it does not hold that @xmath487 and @xmath488 and the first letter of @xmath130 is at the same position as the first letter of @xmath131 under substitution @xmath28 ; * the position of the first letter of @xmath130 in @xmath534 is among the position of @xmath485 in @xmath535 or , symmetrically , the position of the first letter of @xmath131 in @xmath536 is among the position of @xmath486 in @xmath537      [ lem : definition reformulation ] if a letter from @xmath130 is tested ( for @xmath28 ) against a letter from @xmath511 and this test is misaligned then @xmath130 and @xmath131 are misaligned for @xmath28 ; similar statement holds for letters from @xmath131 .      * since this is not a failed test , there is no mismatch till the end of @xmath477 and @xmath478 . * as this is not a protected test , all @xmath130 , @xmath477 , @xmath131 and @xmath478 are short . * as this is a misaligned test , either @xmath532 or @xmath533 . * as this is not an aligned test , either @xmath459 or @xmath538 or the first letter of @xmath130 is not at the same position as the first letter of @xmath131 ( both under @xmath28 ) .",
    "* by the choice of @xmath131 , the first position of @xmath130 under @xmath28 is among the positions of @xmath511 ( under @xmath28 ) .",
    "suppose that @xmath130 and @xmath131 are from an equation @xmath531 .",
    "in the proof we consider only one of the symmetric cases , in which @xmath130 is begins not later than @xmath131 ( i.e.  the first letter of @xmath130 is arranged against the letter from @xmath511 ) .",
    "there are two main cases : either some of @xmath130 , @xmath477 , @xmath131 and @xmath478 has some of its letters arranged against an explicit word or all those words are arranged against ( some occurrences ) of @xmath21 .      [",
    "[ one - of - the - words - has - some - of - its - letters - arranged - against - an - explicit - word . ] ] one of the words has some of its letters arranged against an explicit word .",
    "^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^    we claim that in this case @xmath28 has a period of length at most @xmath223 , in particular , it is small . first of all observe that it is not possible that _ each _ of @xmath130 , @xmath477 , @xmath131 and @xmath478 has _ all _ of its letters arranged against letters of an explicit word : since @xmath130 is arranged against @xmath511 this would imply that @xmath130 is arranged against @xmath131 ( in particular , their first letters are at corresponding positions ) and ( as no mismatch is found till end of @xmath130 and @xmath131 ) so @xmath487 .",
    "similarly , @xmath488 .",
    "this contradicts the assumption that @xmath130 and @xmath131 are misaligned .",
    "thus , there is a word among @xmath130 , @xmath477 , @xmath131 and @xmath478 , say @xmath131 , that is partially arranged against an explicit word and partially against @xmath21 ( note that this explicit word does not have to be among @xmath130 , @xmath477 , @xmath131 and @xmath478 ) , see figure  [ fig : misaligned_in ] .",
    "as each explicit words is proceeded and succeeded by @xmath21 , it follows that x has a period at most @xmath223 .    , @xmath477 , @xmath131 and @xmath478",
    "are arranged against the letters from x. the lengths of fragments of text are beneath the figure , between dashed lines . comparing the positions of the first and second x yields that @xmath201 is a period of x , second and third that @xmath541 while the third and fourth that @xmath542 is .",
    "the borders of x corresponding to the first and third one are marked in grey . ]",
    "[ [ all - words - have - all - their - letters - arranged - against - occurrences - of - x . ] ] all words have all their letters arranged against occurrences of @xmath21 .",
    "^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^    in the following we assume that letters from @xmath130 , @xmath477 , @xmath518 and @xmath478 are arranged against the letters from x. observe that due to lemma  [ lem : against x ] this means that whole @xmath130 is arranged against x preceding @xmath131 , the @xmath131 against x preceding @xmath477 , whole @xmath477 against x preceding @xmath478 and whole @xmath478 against x succeeding @xmath477 .",
    "consider first the case in which @xmath546 , see fig .",
    "[ fig : misaligned ] .",
    "let @xmath201 denote the offset between the x preceding @xmath522 and the one proceeding @xmath518 ; then @xmath55 has a period @xmath201 .",
    "similarly , when we consider the x succeeding @xmath130 and the one succeeding @xmath131 we obtain that the offset between them is @xmath542 , which is also a period of x. those offsets correspond to borders ( of x ) of lengths @xmath548 and @xmath549 , see fig .",
    "[ fig : misaligned ]",
    ". then the shorter border ( of length @xmath548 ) is also a border of the longer one ( of length @xmath550 ) , hence the border of length @xmath549 has a period @xmath551 , so it is of the form @xmath552 , where @xmath553 and @xmath554 .",
    "now , the prefix of x of length @xmath555 is of the form @xmath556 , for some @xmath359 of length less than @xmath15 ( as this is a prefix of length @xmath550 extended by the following @xmath16 letters ) .",
    "when we compare the positions of x preceding @xmath131 and the one succeeding @xmath130 we obtain that @xmath55 has a period @xmath557 so the whole x is of the form @xmath558 , where @xmath281 is a prefix of @xmath556 , hence @xmath28 is small : @xmath26 and @xmath92 are of length at most @xmath4 , as @xmath281 is a prefix of @xmath552 , either it is a prefix of @xmath274 , so it is of the form @xmath559 where @xmath415 is a prefix of @xmath26 , or it includes the whole @xmath274 , so it is of the form @xmath560 , where @xmath561 is a prefix of @xmath92 .    consider the symmetric case , in which @xmath562 and again use fig .",
    "[ fig : misaligned ] . the same argument as before shows that @xmath201 and @xmath542 are periods of x and the corresponding borders are of length @xmath548 and @xmath549 .",
    "now , the shorter of them ( of length @xmath549 ) is a border of longer of them ( of length @xmath548 ) , so the prefix of length @xmath548 of x has a period @xmath563 , so it is of the form @xmath552 , where @xmath564 and @xmath565 .",
    "hence the prefix of length @xmath557 is of the form @xmath556 for some @xmath359 of length less than @xmath16 . as in the previous case",
    ", x has a period @xmath557 and so the whole x is of the form @xmath558 , where @xmath281 is a prefix of @xmath556 , hence @xmath28 is small .",
    "consider now the last case , in which @xmath566 . if @xmath567 then @xmath568 and we can repeat the same argument as above , with @xmath518 and @xmath477 taking the roles of @xmath522 and @xmath518 , which shows that @xmath28 is small .",
    "so consider the case in which @xmath569 .",
    "if @xmath570 then again , repeating the argument as above for @xmath477 and @xmath478 yields that @xmath28 is small .",
    "so we are left with the case in which @xmath571 .",
    "then @xmath477 is arranged against the same letters in x as @xmath522 and @xmath478 is arranged against the same letters in x as @xmath518 . as there is no mismatch till the end of @xmath477 and @xmath478 , we conclude that @xmath510 and @xmath492 contradicting the assumption that @xmath130 and @xmath131 are misaligned , so this case is non - existing .    we now show that if @xmath130 and @xmath131 are misaligned for @xmath28 then they were ( for a corresponding solution ) in the previous phase ( assuming that all involved words were short ) .",
    "this is an easy consequence of the way explicit words are modified ( we prepend and append the same letters and compress all explicit words in the same way ) .    [",
    "lem : misaligned earlier ] suppose that @xmath130 and @xmath131 are misaligned for a solution @xmath28 . if at the previous phase all @xmath572 , @xmath174 , @xmath573 and @xmath527 were short then @xmath174 and @xmath527 were misaligned for the corresponding solution @xmath94 .      *",
    "since @xmath94 is a solution , there is no mismatch .",
    "* by the assumption , all @xmath572 , @xmath174 , @xmath573 and @xmath527 are short .",
    "* we know that either @xmath532 or @xmath533 and so by lemma  [ lem : words are equal ] either @xmath574 or @xmath575 ( observe that none of them is the last nor first , as they are all short ) .",
    "* suppose that @xmath576 , @xmath577 and under @xmath94 the first letters of @xmath174 and @xmath527 are arranged against each other .",
    "by lemma  [ lem : words are equal ] it follows that @xmath487 , @xmath488 . observe that left - popping and right popping preserves the fact that the first letters of @xmath40 @xmath162-word and @xmath41 @xmath163-word are arranged against each other for @xmath94 ( as @xmath67 and @xmath113 are the same words).(as @xmath67 and @xmath113 are the same words ) as @xmath94 is a solution , the same applies to pair compression and block compression .",
    "hence , the first letters of @xmath130 and @xmath131 are arranged against each other , contradiction with the assumption that @xmath130 and @xmath131 are misaligned . *",
    "suppose that the first letter of @xmath130 is arranged against a letter from @xmath485 .",
    "consider , how @xmath174 and @xmath578 under @xmath94 are transformed to @xmath130 and @xmath579 under @xmath28 .",
    "as in the above item , popping letters does not influence whether the first letter of @xmath40 @xmath162-word is arranged against letter from x and @xmath41 @xmath163-word ( as @xmath67 and @xmath113 are the same words ) .",
    "since @xmath94 is a solution , the same applies also to pair and block compression .",
    "so the position of the first letter of @xmath130 is among the position of @xmath485 if and only if the first letter of @xmath174 is arranged against a letter from @xmath580 .",
    "+ the case in which the position of the first letter of @xmath131 is among the position of @xmath486 is shown in a symmetrical way .",
    "consider a tested solution @xmath581 and a misaligned test for a letter from @xmath130 against a letter from @xmath511 ( the case of test of letters from @xmath131 tested against @xmath512 the argument is the same ) .",
    "let @xmath76 be the number of the first phase , in which all @xmath40 @xmath162-word , @xmath40 @xmath582-word , @xmath41 @xmath163-word and @xmath41 @xmath583-word are short .",
    "we claim that this misaligned test happens between @xmath76-th and @xmath584 phase , where @xmath17 is the @xmath32 constant from theorem  [ thm : solution with small height ] .",
    "let @xmath174 and @xmath527 be the corresponding words in the phase @xmath76 . using induction on lemma  [ lem : misaligned earlier ]",
    "it follows that @xmath174 and @xmath527 are misaligned for @xmath94 .",
    "thus by lemma  [ lem : low height for misaligned ] the @xmath94 is small and thus by theorem  [ thm : solution with small height]it is reported till phase @xmath584 .",
    "so it can be tested only between phases @xmath76 and @xmath584 , as claimed .",
    "this allows an improvement to the testing algorithm : whenever ( say in phase @xmath76 ) a letter from @xmath130 has a misaligned test against a letter from @xmath585 we can check ( in @xmath32 time ) , in which turn @xmath530 the last among @xmath40 @xmath162-word , @xmath40 @xmath586 , @xmath41 @xmath163-word and @xmath41 @xmath587 word became small ( it is enough to store for each explicit word the number of phase in which it became small ) . if @xmath588 then we can terminate the test , as we know already that @xmath28 is not a solution .",
    "otherwise , we continue .      the misaligned tests that lead to the rejection of @xmath28 : :    this can happen once per tested solution and there are    @xmath8 tested solution in total    ( @xmath32 per phase and there are    @xmath8 phases ) . other misaligned tests : :    the cost of the test ( of a letter from @xmath130 tested    against @xmath508 )",
    "is charged to the last    one among @xmath40 @xmath162-word ,    @xmath40 @xmath589-word ,    @xmath41 @xmath163-word and    @xmath41 @xmath587-word that became short .    by the argument above",
    ", this means that this word became short within    the last @xmath17 phases .",
    "+    let us calculate , for a fixed @xmath40 @xmath162    word ( the argument for @xmath41 @xmath163-word    is symmetrical ) how many aligned tests of this kind can be charged to    this word .",
    "they can be charged only within @xmath17 phases    after this word become short . in a fixed phase",
    "we test only a constant    ( i.e.  @xmath590 ) substitutions . for a fixed substitution",
    ",    @xmath130 can be charged the cost of tests in which letters    from @xmath130 or @xmath516 are involved    ( providing that @xmath130/@xmath516 is short ) ,    which is at most @xmath524 .",
    "they can be charged    also the tests from letters from @xmath131 that is aligned    against @xmath21 proceeding @xmath516 or    @xmath21 proceeding @xmath130 ( providing that    @xmath131 as well as @xmath516 are short ) . note    that there is only one @xmath131 whose letter are aligned    against @xmath21 proceeding @xmath516 and one for    @xmath21 proceeding @xmath130 , see lemma  [ lem : against    x ] , so when they are short this gives additional    @xmath524 tests .",
    "+    this yields that one @xmath40 @xmath162 word is    charged    @xmath431 tests    in total .",
    "summing over all words in the instance yields the claim of    the lemma .",
    "suppose that we make an aligned test , without loss of generality consider the first such test in a sequence of aligned tests .",
    "let it be between the first letter of @xmath130 and the first letter in @xmath131 ( both of those words are short ) .",
    "for this @xmath130 and @xmath131 we want to perform the whole sequence of successive aligned tests at once , which corresponds of jumping to @xmath591 and @xmath592 within the same equation such that      note that this corresponds to a syntactical equality of fragments of the equation , which , by lemma  [ lem : words are equal ] is equivalent to a syntactical equality of fragments of the original equation .",
    "we preprocess ( in @xmath2 time ) the input equation ( building a suffix array equipped with a structure answering general lcp queries ) so that in @xmath32 we can return such @xmath169 as well as the links to @xmath591 and @xmath592 . in this way",
    "we perform all equality tests for @xmath598 in @xmath32 time .",
    "to simplify the considerations , when @xmath493 ( @xmath599 ) ends one side of the equation , we say that this @xmath130 ( @xmath131 , respectively ) is _ almost last _ word .",
    "observe that in a given equation exactly one side has a last word and one an almost last word .",
    "[ lem : data structure aligned test ] in @xmath2 we can build a data structure which given equal @xmath130 and @xmath131 in @xmath32 time returns the smallest @xmath600 and links to @xmath591 and @xmath592 such that @xmath595 or one of @xmath591 , @xmath592 is a last word or one of @xmath591 , @xmath592 is an almost last word .",
    "note that it might be that some of the equal words @xmath601 are long , and so their tests should be protected ( also , the tests for some neighbouring words ) .",
    "so in this way we also make some free protected tests , but this is not a problem .",
    "furthermore , the returned @xmath591 and @xmath592 are guaranteed to be in the same equation .",
    "first of all observe that for @xmath130 and @xmath131 it is easy to find the last word in their equation as well as the almost last word of the equation : when we begin to read a particular equation , we have the link to both the last word and the almost last word of this equation and we can keep them for the testing of this equation .",
    "we also know the numbers of those words so we can also calculate the respective candidate for @xmath169 .",
    "so it is left to calculate the minimal @xmath169 such that @xmath602 .",
    "let @xmath603 , @xmath604 etc .",
    "denote the corresponding original words of the input equation .",
    "observe that by lemma  [ lem : words are equal ] it holds that @xmath605 if and only if @xmath498 as long as none of them is last or first word .",
    "hence , it is enough to be able to answer such queries for the input equation : if the returned word is in another equation then we should return the last or almost last word instead .    to this end",
    "we build a suffix array  @xcite for the input equation , i.e.  for @xmath606 .",
    "now , the lcp query for suffixes @xmath607 and @xmath608returns the length of the longest common prefix .",
    "we want to know what is the number of explicit words in the common prefix , which corresponds to the number of @xmath21s in this common prefix .",
    "this information can be easily preprocessed and stored in the suffix array : for each position @xmath76 in @xmath606 we store , how many @xmath21s are before it in the string and store this in the table @xmath609 .",
    "then when for a suffixes beginning at positions @xmath201 and @xmath447 we get that their common prefix is of length @xmath76 , the @xmath610 - \\textsl{prefx}[p]$ ] is the number of @xmath21s in the common prefix in such a case . if none of @xmath130 , @xmath477 ,  , @xmath591 nor @xmath131 , @xmath478 , ",
    ", @xmath592 is the last word nor it ends the equation ( i.e.  they are all still in one equation ) by lemma  [ lem : words are equal ] the @xmath169 is the answer to our query ( as @xmath487 , @xmath488,  and @xmath595 and none of them is a last word , nor none of them ends the equation ) . to get the actual links to those words , at the beginning of the computation",
    "we make a table , which for each @xmath162 return the pointer to @xmath40 @xmath162-word and @xmath41 @xmath162-word has the link to this word .",
    "as we know @xmath162 , @xmath163 and @xmath169 we can obtain the appropriate links in @xmath32 time .",
    "so it is left to compare the value of @xmath169 with the value calculated for the last word and almost last word and choose the one with smaller @xmath169 and the corresponding pointers .    using this data structure",
    "we perform the aligned tests is in the following way : whenever we make an aligned test ( for the first letter of @xmath130 and the first letter of @xmath131 ) , we use this structure , obtain @xmath169 and jump to the test of the first letter of @xmath591 with the first letter of @xmath592 and we proceed with testing from this place on . concerning the cost , by easy case analysis it can be shown that the test right before the first of sequence of aligned tests ( so the test for the last letters of @xmath516 and @xmath517 ) is either protected or misaligned . there are only @xmath2 such tests ( over the whole run of onevarwordeq ) , so the time spend on aligned tests is @xmath2 as well .",
    "we formalise the discussion above . in @xmath32",
    "we get to know that this is an aligned test , see lemma  [ lem : no other test ] . then in @xmath32 , see lemma  [ lem : data structure aligned test ]",
    ", we get the smallest @xmath169 such that @xmath595 or one of them is an almost last word for this equation or the last word for this equation .",
    "we then jump straight to the test for the first letter of @xmath591 and @xmath592 .",
    "consider @xmath516 and @xmath517 we show that the test for their last letters ( so the test immediately before the first aligned one ) is protected or misaligned . by lemma  [ lem : no other test ] it is enough to show that it is not aligned , nor periodic , nor failed .    *",
    "if it were failed then also the test for the first letters of @xmath522 and @xmath131 would be failed .",
    "* it can not be aligned , as we chose @xmath130 and @xmath131 as the first in a series of aligned tests . * if it were periodic , then @xmath611 and @xmath612 while by assumption @xmath487 , which implies that this test is in fact aligned , which was already excluded .",
    "hence we can associate the @xmath32 cost of whole sequence of aligned test to the previous test , which is misaligned or protected .",
    "clearly , one misaligned or protected test can be charged with only one sequence of aligned tests ( as it is the immediate previous test ) . by lemma  [ lem : protected is linear ] and [ lem : misaligned is linear ] in total",
    "there are @xmath2 misaligned and protected tests .",
    "thus in total all misaligned tests take @xmath2 time .",
    "the general approach in case of periodical tests is similar as for the aligned tests : we would like to perform all consecutive periodical tests in @xmath509 time and show that the test right before this sequence of periodic tests is either protected or misaligned .",
    "as in case of aligned tests , the crucial part is the identification of a sequence of consecutive periodical tests . to identify them quickly , we keep for each short @xmath130 the value @xmath169 such that @xmath591 is the first word that is different from @xmath130 or is the last word or the almost last word ( in the sense as in the previous section : @xmath591 is almost last if @xmath596 ends the side of the equation ) , as well as the link to this @xmath591 .",
    "those are easy to calculate at the beginning of each phase .",
    "now when we perform a periodical test for a letter from @xmath130 , we test letters from @xmath613 against the letters from ( suffix of ) @xmath614 . if @xmath615 then both strings are periodic with period @xmath616 and their equality can be tested in @xmath520 .",
    "if @xmath617 then we retrieve the values @xmath618 and @xmath619 which tell us what is repetition of @xmath620 and @xmath621 .",
    "if one of them is smaller than @xmath622 we make the test naively , in time @xmath623 . if not , we exploit the fact that @xmath624 has a period @xmath625 while @xmath626 has a period @xmath616 and so their common fragment ( if they are indeed equal ) has a period @xmath627 .",
    "hence we check , whether @xmath628 and @xmath629 have this period and check the common fragment of this length , which can be done in @xmath623 time .",
    "the converse implication holds as well : if @xmath630 and @xmath631 have period @xmath632 and the first @xmath632 tests are successful then all of them are .",
    "concerning the overall running time , as in the case of aligned test , the test right before the first periodic test is either protected or misaligned , so as in the previous section it can be shown that the time spent on periodical tests is @xmath2 during the whole onevarwordeq .",
    "similarly as in the case of aligned tests , see lemma  [ lem : data structure aligned test ] , we can easily keep the value @xmath169 and the link to @xmath591 such that @xmath591 is the last or almost last word in this equation , the same applies for @xmath592 .",
    "hence it is left to show how to calculate for each short @xmath130 ( and @xmath131 ) the @xmath169 such that @xmath591 is the first word that is different from @xmath130 .    at the end of the phase we list all words @xmath130 that become short in this phase , ordered from the left to the right (",
    "this is done anyway , when we identify the new short words ) .",
    "note that this takes at most the time proportional to the length of all long words from the beginning of the phase , so @xmath2 in total .",
    "consider any @xmath522 on this list ( the argument for @xmath131 is identical ) , note that    * if @xmath489 then @xmath130 should store @xmath400 and a pointer to this @xmath477 ; * if @xmath633 then @xmath477 also became short in this phase and so it is on the list and consequently @xmath130 should store @xmath168 more than @xmath477 and the same pointer as @xmath477 .",
    "so we read the list from the right to the left , let @xmath130 be an element on this list . using the above condition , we can establish in constant time the value and pointer stored by @xmath130 .",
    "this operation is performed once per block , so in total takes @xmath2 time .",
    "consider a periodic test , without loss of generality suppose that a letter from @xmath130 is tested against a letter from @xmath511 ( in particular , @xmath130 begins earlier than @xmath131 ) , let the @xmath634 and @xmath187 be stored by @xmath130 and @xmath131 ; as this is a periodical test , both @xmath634 and @xmath187 are greater than @xmath168 . among @xmath635 and",
    "@xmath636 consider the one which begins earlier under substitution @xmath28 : this can be determined in @xmath32 by simply comparing the lengths , the length on the @xmath84-side of the equation is @xmath637 while @xmath132-side is @xmath638 , where @xmath76 is the remainder of x that is compared with @xmath130 .",
    "note that the test for the first letter of this word is not periodic , so when we jump to it we skip the whole sequence of periodic tests .",
    "we show that in @xmath32 time we can perform the tests for all letters before this word and that the test right before the first test for @xmath130 is protected or misaligned .",
    "let @xmath639 , @xmath640 and @xmath545 .",
    "first consider the simpler case in which @xmath164 .",
    "let @xmath641 .",
    "then the tests for @xmath477 ,  , @xmath642 are identical as for @xmath130 , and",
    "so it is enough to perform just the test for @xmath130 and @xmath131 and then jump right to @xmath591 .",
    "so let us now consider the case in which @xmath546 .",
    "observe that when the whole @xmath643 is within @xmath644 then this can be tested in constant time in a naive way : the length of @xmath644 is @xmath645 while the length of @xmath646 is @xmath647 .",
    "hence @xmath648 and so @xmath649 , because @xmath650 is at most @xmath223 .",
    "thus all tests for @xmath644 and @xmath643 can be done in @xmath431 time .",
    "first @xmath660 has period @xmath661 .",
    "however , it is covered with @xmath643 , so it also has period @xmath662 . since @xmath663",
    ", it follows that also the @xmath664 is a period of @xmath660 and so also of @xmath657 and thus also @xmath665 .",
    "the second item is obvious .",
    "since @xmath657 and @xmath658 have period @xmath659 also @xmath655 and @xmath656 have this period .",
    "as the first @xmath659 tests for @xmath655 and @xmath656 are successful , it follows that all the tests for their common part are .",
    "so , to perform the test for the common part of @xmath666 and @xmath667 it is enough to : calculate @xmath668 , test whether @xmath669 , @xmath665 have period @xmath201 and then perform the first @xmath201 tests for @xmath666 and @xmath667 .",
    "all of this can be done in @xmath32 , since @xmath670 ( note also that calculating @xmath201 can be done in @xmath32 , as @xmath671 and @xmath672 ) .",
    "the case with @xmath562 is similar : in the special subcase we consider whether @xmath500 is within @xmath673 . if so then the tests can be done in @xmath509 time .",
    "if not , then we observe that the @xmath674 is covered by @xmath500 .",
    "so it the tests are successful , it has period both @xmath675 as well as @xmath676 , so it has period @xmath664 .",
    "the rest of the argument is identical .      for the accounting",
    ", we would like to show that the test right before the first among the considered periodic tests is not periodic .",
    "observe , that as @xmath130 begins not later ( under @xmath28 ) than @xmath131 it means that the last letter of @xmath517 is not earlier than the last letter of @xmath516 , see figure  [ fig : what_is_prev ] .",
    "so the previous test includes the last letter of @xmath517 .",
    "it is enough to show that this test is not failed , periodic , nor aligned",
    ".    failed : :    if it is failed then also the test for the letters in    @xmath130 are failed .",
    "periodic : :    if it is periodic then this contradicts our choice that the test for    the first letter of @xmath130 is the first in the sequence    periodic tests .",
    "aligned : :    since the first letter of @xmath130 is arranged against    @xmath511 , in this case the last letter of    @xmath517 needs to be arranged against the last letter of    @xmath516",
    ". then by the definition of the aligned test ,    @xmath677 and their first letters are at the same    position .",
    "as by the assumption about the periodic tests we know that    @xmath510 and @xmath492 we    conclude that the test for the first letter of @xmath130 is in    fact aligned , contradiction .",
    "hence , by lemma  [ lem : no other test ] , the test for the last letter of @xmath517 is either protected or misaligned .",
    "using the same accounting as in lemma  [ lem : aligned is linear ] we conclude that we spent at most @xmath2 time on all periodic tests .",
    "recall that we only test solutions of the form @xmath678 . since we make the comparisons from left to the right in both @xmath483 and @xmath484",
    "then when we begin comparing letters from one x with the other x , we in fact compare some suffix @xmath18 of @xmath526 with @xmath526 .",
    "then we can skip those @xmath18 letters in @xmath32 time .",
    "consider the previous test , which needs to include at least one explicit letter . whatever type of test it was or whatever group of tests it was in , some operations were performed and this took @xmath679 time .",
    "so we associate the cost of comparing x with x to the previous test , increasing the running time by at most a multiplicative constant .",
    "is it possible to remove the usage of range minimum queries from the algorithm without increasing the running time ? can the recompression approach be used to speed up the algorithms for the two variable word equations ? can one use recompression approach also to better upper bound the number of solutions of an equation with a single variable ?",
    "i would like to thank a.  okhotin for his remarks about ingenuity of plandowski s result , which somehow stayed in my memory ; p.  gawrychowski for initiating my interest in compressed membership problems and compressed pattern matching , exploring which eventually led to this work as well as for pointing to relevant literature  @xcite ; j.  karhumki , for his explicit question , whether the techniques of local recompression can be applied to the word equations ; last not least , w.  plandowski for his numerous comments and suggestions on the recompression applied to word equations .",
    "robert dbrowski and wojciech plandowski .",
    "solving two - variable word equations . in josep daz , juhani karhumki , arto lepist , and donald sannella , editors , _",
    "icalp _ , volume 3142 of _ lncs _ , pages 408419 .",
    "springer , 2004 .",
    "artur je .",
    "faster fully compressed pattern matching by recompression . in artur czumaj , kurt mehlhorn , andrew pitts , and roger wattenhofer , editors , _ icalp ( 1 ) _ , volume 7391 of _ lncs _ , pages 533544 .",
    "springer , 2012 .",
    "artur je .",
    "approximation of grammar - based compression via recompression . in johannes fischer and peter sanders , editors ,",
    "_ cpm _ , volume 7922 of _ lncs _ , pages 165176 .",
    "springer , 2013 .",
    "full version at http://arxiv.org/abs/1301.5842 .",
    "toru kasai , gunho lee , hiroki arimura , setsuo arikawa , and kunsoo park .",
    "linear - time longest - common - prefix computation in suffix arrays and its applications . in amihood amir and gad  m. landau , editors , _ cpm _ , volume 2089 of _ lncs _ , pages 181192 .",
    "springer , 2001 .",
    "markus lohrey and christian mathissen .",
    "compressed membership in automata with compressed labels . in alexander  s. kulikov and nikolay  k. vereshchagin , editors , _ csr _ , volume 6651 of _ lncs _ , pages 275288 .",
    "springer , 2011 .",
    "s.  eyono obono , pavel goralcik , and m.  n. maksimenko .",
    "efficient solving of the word equations in one variable . in igor prvara , branislav rovan , and peter ruzicka , editors , _ mfcs _ , volume 841 of _ lncs _ , pages 336341 .",
    "springer , 1994 .",
    "wojciech plandowski and wojciech rytter .",
    "application of lempel - ziv encodings to the solution of word equations . in kim",
    "guldstrand larsen , sven skyum , and glynn winskel , editors , _ icalp _ , volume 1443 of _ lncs _ , pages 731742 .",
    "springer , 1998 ."
  ],
  "abstract_text": [
    "<S> in this paper we consider word equations with one variable ( and arbitrary many occurrences of it ) . </S>",
    "<S> a recent technique of recompression , which is applicable to general word equations , is shown to be suitable also in this case . </S>",
    "<S> while in general case the recompression is non - deterministic it determinises in case of one variable and the obtained running time is @xmath0 , where @xmath1 is the number of occurrences of the variable in the equation . </S>",
    "<S> this matches the previously - best algorithm due to dbrowski and plandowski . </S>",
    "<S> then , using a couple of heuristics as well as more detailed time analysis , the running time is lowered to @xmath2 in the ram model . </S>",
    "<S> unfortunately , no new properties of solutions are shown . </S>"
  ]
}