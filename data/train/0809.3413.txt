{
  "article_text": [
    "the discrete logarithm plays two opposing roles in group computations . as a constructive tool ,",
    "discrete logarithms are the key ingredient in generic algorithms for extracting roots ( including square roots in finite fields ) @xcite and for computing group structure @xcite .",
    "on the other hand , a wide range of cryptographic applications depend on the essential difficulty of computing discrete logarithms in the worst case ( see @xcite or @xcite for a survey ) .    typically the discrete logarithm is defined in the context of a cyclic group : for any @xmath4 there is a unique nonnegative integer @xmath5 for which @xmath6 . more generally , given @xmath7 , if every @xmath8 can be written uniquely as @xmath9 with @xmath10 , then @xmath11 is the _ discrete logarithm _ of  @xmath12 with respect to  @xmath13 , and we call the vector @xmath13 a _ basis _ for the group it generates .",
    "we work in the computational framework of generic group algorithms , as defined , for example , in  @xcite .",
    "thus we suppose that a  black box \" is used to perform group operations , possibly including the provision of random elements , with each group element arbitrarily assigned a unique identifier .",
    "we are interested in constructive applications of the discrete logarithm , but let us first recall the negative result of shoup @xcite .",
    "any generic algorithm to compute discrete logarithms in a finite abelian group @xmath2 with prime exponent is the least positive integer @xmath14 for which @xmath15 for all @xmath16 . ] uses @xmath17 group operations . a matching upper bound",
    "is achieved , for cyclic groups , by shanks baby - step giant - step algorithm @xcite and ( probabilistically ) by pollard s rho method @xcite .",
    "both algorithms can be generalized to compute discrete logarithms in any finite abelian group using @xmath3 group operations @xcite .",
    "however , when the exponent of the group is not prime , we can do better .",
    "this was proven for cyclic groups by pohlig and hellman @xcite and later generalized by teske @xcite .",
    "the pohlig ",
    "hellman approach relies on computing discrete logarithms in subgroups of the given group .",
    "the reduction to subgroups of prime - power order is straightforward , hence we focus primarily on abelian @xmath0-groups .    if @xmath13 is a basis for a finite abelian group @xmath2 of exponent @xmath18 and rank @xmath19 , teske s generalization of the pohlig ",
    "hellman algorithm computes @xmath20 using @xmath21 group operations ( * ? ? ?",
    "to @xmath22 , which we consider in section [ section : structure ] . note that we use @xmath23 throughout .",
    "] when @xmath24 this reduces to the @xmath3 upper bound mentioned above .",
    "if @xmath0 and @xmath19 are small ( when computing square roots in finite fields , for example , @xmath25 and @xmath26 ) the first term dominates and the complexity becomes @xmath27 , where @xmath28 . for cyclic groups this can be improved to @xmath29 @xcite , and we achieve here an @xmath30 bound for arbitrary finite abelian groups when @xmath0 and @xmath19 are suitably bounded .",
    "more generally , algorithm [ algorithm : dlp ] computes @xmath20 using @xmath31 group operations , improving the dependence on @xmath32 in both terms of ( [ equation : teskebound ] ) .",
    "discrete logarithms may be applied to compute the structure of a finite abelian group .",
    "typically , one uses discrete logarithms to construct a relation matrix , which is then reduced to yield a basis by computing the smith normal form @xcite .",
    "we take a simpler ( and faster ) approach , using our algorithm for discrete logarithms to directly construct a basis .",
    "given a generating set @xmath33 for a finite abelian @xmath0-group @xmath2 of rank @xmath19 , we give a deterministic generic algorithm to construct a basis using @xmath34 group operations , improving the @xmath35 result of buchmann and schmidt @xcite .",
    "the bound in ( [ equation : tbbound ] ) is minimized when @xmath36 .",
    "if we pick a random subset @xmath37 , of size @xmath38 , then @xmath33 generates @xmath2 with very high probability @xcite .",
    "when combined with an algorithm to compute the group exponent , this yields a generic monte carlo algorithm to compute the structure of an arbitrary finite abelian group using @xmath3 operations .",
    "when sufficiently tight bounds on the group order are known , this can be converted to a las vegas algorithm .",
    "this approach can also be applied to a sylow @xmath0-subgroup @xmath39 .",
    "if the group exponent ( or order ) is known , the complexity then depends primarily on the size and shape of @xmath1 , not @xmath2 .",
    "this is useful when extracting @xmath0th roots in @xmath2 , which only requires a basis for @xmath1 @xcite .",
    "we begin by describing a bijection between finite abelian @xmath0-groups and young tableaux that motivates our approach and allows us to fix some terminology .",
    "we work in this section and the next with a basis @xmath7 for an abelian @xmath0-group @xmath2 of order @xmath40 , exponent @xmath18 , and @xmath0-rank ( rank ) @xmath19 .",
    "we let @xmath41 and assume that @xmath42 . up to isomorphism",
    ", @xmath2 is determined by the integer partition @xmath43 .",
    "for example , if @xmath44 then @xmath45 is a partition of @xmath46 into three parts , with young diagram : @xmath47 a cyclic group has @xmath25 and a single row in its diagram , while a group with prime exponent has @xmath24 and a single column . in our example , @xmath2 has @xmath48 and @xmath49 .    for each @xmath50",
    ", we regard @xmath11 as an element of the ring @xmath51 the additive group of @xmath52 is isomorphic to @xmath2 , via the map @xmath53 ( the inverse map sends @xmath12 to @xmath20 ) .",
    "we may write the components of @xmath54 in base @xmath0 as @xmath55 where @xmath56 is the _ most _ significant digit ( and may be zero ) .",
    "we can then represent  @xmath57 ( and @xmath58 ) by a young tableau of shape @xmath59 with label @xmath60 in the @xmath61th row and @xmath62th column .",
    "for our example @xmath2 in ( [ equation : examplegroup ] ) , if @xmath26 and @xmath63 , we have    @xmath64    corresponding to @xmath65 .",
    "we wish to split the tableau above into left and right halves , allowing us to write @xmath66 the vector @xmath67 is a `` shift '' vector whose components are powers of @xmath0 , while @xmath68 and @xmath69 correspond to the left and right halves of @xmath57 respectively .",
    "these vectors are obtained by computing discrete logarithms in certain subgroups of @xmath2 , as we now describe .",
    "if we multiply @xmath57 ( exponentiate @xmath12 ) by the integer scalar @xmath70 , this shifts the labels of the tableau to the left @xmath71 places , leaving zeros on the right . in our example , if @xmath72 , we have @xmath73 , yielding @xmath74 ( with shifted labels in bold ) , corresponding to @xmath75 .",
    "the element @xmath76 lies in the subgroup of @xmath70th powers in @xmath2 , @xmath77 which has a basis to contain trivial elements . in practice",
    "we may truncate @xmath78 . ]",
    "@xmath78 defined by @xmath79 .",
    "the diagram of @xmath80 corresponds to the @xmath81 rightmost columns in the diagram of @xmath2 . in our example",
    "we have the shape @xmath82 .",
    "now let @xmath83 .",
    "the vector @xmath69 is an element of @xmath84 , but as a vector of integers written in base @xmath0 , each component of @xmath69 contains the low order @xmath81 digits of the corresponding component of @xmath57 .",
    "we may  clear \" these digits of @xmath57 to obtain @xmath85 by subtracting @xmath69 from @xmath57 ( in @xmath86 ) , to obtain a reduced element of @xmath52 .",
    "in our example we have @xmath87 , @xmath88 and the tableau @xmath89 with the entries unaffected by subtracting @xmath69 from @xmath57 in bold .",
    "the element @xmath90 has order at most @xmath70 and lies in the @xmath70-torsion subgroup @xmath91=\\{\\beta : \\beta^{p^k}={1_{\\scriptscriptstyle{g}}},\\thickspace \\beta\\in g\\}.\\ ] ] a basis @xmath92 for @xmath93 $ ] is given by @xmath94 , where @xmath95 .",
    "the diagram of @xmath93 $ ] corresponds to the @xmath71 leftmost columns of the diagram of @xmath2 . in our example , @xmath96)=(2,2,1)$ ] .",
    "if we now let @xmath97 , then @xmath98 and @xmath99 as desired .",
    "in our example we have @xmath100 and @xmath101 yielding @xmath102 this equation effectively reconstructs the tableau in @xmath103 by gluing together the bold portions of the tableaux in @xmath104 and @xmath105 .",
    "note that @xmath69 and @xmath68 were defined via discrete logarithms in the subgroups @xmath80 and @xmath93 $ ] respectively .",
    "this suggests a recursive approach , leading to base cases in subgroups corresponding to single columns in the young diagram of @xmath2 .",
    "a recursive algorithm , along the lines suggested above , yields an improvement over the result of teske @xcite , and in the cyclic case is equivalent to shoup s balanced divide - and - conquer version of the pohlig ",
    "hellman algorithm @xcite .",
    "however , we can achieve a further speedup by broadening the recursion tree , allowing us to take advantage of fixed - base exponentiation techniques . at the same time",
    ", we can structure the algorithm to facilitate precomputation , an important practical optimization in applications that rely heavily on discrete logarithms @xcite .",
    "we will need to compute discrete logarithms in various subgroups of the form @xmath106 for nonnegative integers @xmath107 .",
    "the subgroup @xmath108 consists of all @xmath109th powers of order at most @xmath110 , and corresponds to columns @xmath111 through @xmath71 in the diagram of  @xmath2 . if @xmath2 has exponent @xmath18 , then @xmath112 .",
    "we wish to obtain a basis for @xmath108 from our given basis @xmath7 for  @xmath2 . to this end , let @xmath113 , let @xmath114 , and define @xmath115 then @xmath116 is our desired basis , as we now show .",
    "[ lemma : basisvector ] let @xmath7 be a basis for a finite abelian @xmath2 , and let @xmath62 and @xmath71 be nonnegative integers with @xmath107 . then @xmath116 is a basis for @xmath108 .",
    "let @xmath117 .",
    "we first show that @xmath118 is a basis for @xmath119 .",
    "suppose for the sake of contradiction that @xmath120 with @xmath121 distinct .",
    "we must have @xmath122 for some @xmath61 , which implies @xmath123 and @xmath124 .",
    "we also have @xmath125 . as @xmath126 and @xmath127 are distinct integers less than @xmath128 , the vectors @xmath129 and @xmath130 are distinct elements of @xmath52 . but",
    "this is a contradiction , since @xmath13 is a basis .",
    "we now prove @xmath131 .",
    "every @xmath132 is a @xmath109th power ( since @xmath133 ) and has order at most @xmath110 ( since @xmath134 ) , thus @xmath135 .",
    "conversely , for @xmath136 , if @xmath137 , then @xmath138 and @xmath139 for each @xmath61 .",
    "if @xmath140 then @xmath141 , so @xmath142 in every case . it follows that @xmath143 , hence @xmath144 .",
    "we now give a recursive algorithm to compute discrete logarithms in @xmath108 , using @xmath116 and @xmath145 as defined above .",
    "note that if @xmath146 , then each component of @xmath145 divides the corresponding component of @xmath147 , and we may then write @xmath148 to denote point - wise division . for convenience ,",
    "let @xmath149 denote @xmath150 .",
    "we assume the availability of a standard algorithm for computing discrete logarithms in the base cases , as discussed below .    [",
    "algorithm : dlp ] given a basis @xmath13 for a finite abelian @xmath0-group @xmath2 and @xmath151 , the following algorithm computes @xmath149 for integers",
    "@xmath152 and @xmath153 :    1 .   if @xmath154 , compute @xmath155 as a base case and return @xmath57 .",
    "2 .   choose integers @xmath156 satisfying @xmath157 .",
    "3 .   compute @xmath158 for @xmath61 from 1 to @xmath159 , and set @xmath160 .",
    "4 .   for @xmath61 from @xmath159 down to 1 : 1 .",
    "recursively compute @xmath161 .",
    "2 .   set @xmath162 , where @xmath163 .",
    "return @xmath57 .",
    "let @xmath2 be cyclic of order @xmath164 with basis @xmath165 , @xmath166 and @xmath167 .",
    "then @xmath168 and @xmath169 is a basis for @xmath170 .",
    "let @xmath171 and @xmath172 , so that @xmath173 $ ] is partitioned into sub - intervals @xmath174 $ ] , @xmath175 $ ] , and @xmath176 $ ] .",
    "we then have @xmath177 , @xmath178 , @xmath179 , and also @xmath180 . for @xmath181 , algorithm [ algorithm : dlp ]",
    "computes    = @xmath182=@xmath183 + @xmath184@xmath185 + @xmath186@xmath187    the final value @xmath188 contains 7 base @xmath0 digits : 2 in @xmath189 , 3 in @xmath190 , and 2 in @xmath191 .",
    "suppose instead that @xmath2 is cyclic of order @xmath192 , but keep the other parameters as above .",
    "we then have @xmath193 , @xmath194 , @xmath195 , @xmath196 , and @xmath197 . for @xmath181 , the algorithm now computes    = @xmath198=@xmath199 + @xmath200@xmath201 + @xmath202@xmath203    the computation of @xmath204 requires no group operations ; the algorithm can determine @xmath205 from the fact that @xmath206 ( since @xmath207 is given ) .",
    "the final value @xmath188 contains 3 base @xmath0 digits : 2 in @xmath189 and 1 in @xmath190 .",
    "these examples illustrate the general situation ; we compute discrete logarithms in @xmath19 cyclic groups in parallel .",
    "the second example is contrived , but it shows what happens when a cyclic factor of @xmath2 has order less than @xmath70 .",
    "we assume that no cost is incurred by trivial operations ( those involving the identity element ) . as a practical optimization",
    ", the loop in step 4 may begin with the largest @xmath61 for which @xmath123 ( it will compute @xmath208 up to this point in any event ) .",
    "the correctness of algorithm [ algorithm : dlp ] follows inductively from the lemma below .",
    "[ lemma : dlpcorrectness ] let @xmath13 be a basis for a finite abelian @xmath0-group @xmath2 and let @xmath209 and @xmath71 be integers with @xmath210 . for all @xmath153 the following hold :    1 .   if @xmath211 and @xmath212 , then @xmath213 .",
    "if we also have @xmath214 and @xmath215 , + then @xmath216 .    for ( i ) , note that @xmath12 is a @xmath109th power , so @xmath217 is a @xmath218th power , and every element of @xmath219 is a @xmath218th power , hence @xmath118 is a @xmath218th power .",
    "we also have @xmath220 it follows from the definition in ( [ equation : alphajk ] ) that @xmath221 , since we have @xmath222 .",
    "we then obtain @xmath223 thus @xmath118 has order at most @xmath224 , and therefore @xmath213 , proving ( i ) .    note",
    "that @xmath225 implies @xmath226 , so @xmath147 is divisible ( component - wise ) by @xmath227 , and @xmath228 in ( ii ) is well defined .",
    "now @xmath229 and therefore @xmath230 , proving ( ii ) .",
    "we now consider the parameter @xmath231 in algorithm [ algorithm : dlp ] .",
    "if @xmath232 is small , we precompute a lookup table for @xmath233 , containing at most @xmath234 group elements , for some suitable value of @xmath231 .",
    "this will handle all the base cases , since they arise in subgroups @xmath108 of @xmath233 , where @xmath154 .",
    "this is especially effective when one can amortize the cost over many discrete logarithm computations , in which case a larger @xmath231 is beneficial . in applications where @xmath235 , one typically chooses @xmath231 to be logarithmic in the relevant problem size ( which may be larger than @xmath236 ) .    when @xmath232 is large , we instead set @xmath237 and use a standard @xmath238 algorithm for computing discrete logarithms in finite abelian groups .",
    "a space - efficient algorithm derived from pollard s rho method is given in @xcite , and a baby - steps giant - steps variant can be found in ( * ? ? ?",
    "9.3 ) ( see section [ section : performance ] for optimizations ) .    when partitioning the interval @xmath239 $ ] into subintervals in step 2 , we assume the subintervals are of approximately equal size , as determined by the choice of @xmath159 .",
    "the choice @xmath240 limits the recursion depth to 1 and corresponds to the standard pohlig  hellman algorithm .",
    "the choice @xmath241 yields a balanced binary recursion tree .",
    "this might appear to be an optimal choice , but we can actually do better with a somewhat larger choice of @xmath159 , using fixed - base exponentiation techniques .",
    "we recall a theorem of yao .    [",
    "theorem : yao ] there is an online algorithm that , given @xmath242 and any input sequence of positive integers @xmath243 , outputs @xmath244 using at most @xmath245 multiplications , where @xmath246 and @xmath247 is a constant . , the constant @xmath248 approaches 1 . ]    the online algorithm in the theorem outputs @xmath249 before receiving the input @xmath250 . if we set @xmath251 , yao s theorem tells us that provided @xmath252",
    ", we can perform @xmath159 exponentiations of a common base with @xmath14-bit exponents using just @xmath253 multiplications , the same bound as when @xmath254 .",
    "there are several algorithms that achieve yao s bound @xcite , and they typically require storage for @xmath255 group elements .",
    "consider the execution of algorithm 1 computing @xmath256 .",
    "it will be convenient to label the levels of the recursion tree with @xmath257 at the bottom , and @xmath258 at the top , where @xmath259 is the maximum depth of the recursion . at each level",
    "the interval @xmath260 $ ] is partitioned into successively smaller subintervals .",
    "we let @xmath261 denote the size of the initial interval at level @xmath259 , and at level @xmath262 partition each interval into approximately @xmath263 subintervals of maximum size @xmath264 and minimum size @xmath265 .    in the tree above we start at level @xmath266 with @xmath267 and @xmath268 , partitioning 100 into two subintervals of size @xmath269 and five subintervals of size  14 .",
    "we then have @xmath270 and @xmath271 , and finally @xmath272 and @xmath273 .",
    "the base cases are all at level 0 in this example , but in general may also occur at level 1 .",
    "the fan - out of each node at level @xmath262 is @xmath263 , except possibly at level 1 ( in this example , we can not partition 2 into three parts ) .",
    "our strategy is to choose @xmath274 and apply yao s theorem to bound the cost at each level of the recursion tree by @xmath275 group operations , not including the base cases .",
    "the standard pohlig ",
    "hellman approach reduces the problem to base cases in one level , potentially incurring a cost of @xmath276 to do so . a binary recursion uses @xmath277 group operations at each level , but requires @xmath278 levels , while we only need @xmath279 .    with these ideas in mind , we now prove an absolute bound on the running time of algorithm [ algorithm : dlp ] .",
    "an asymptotic bound appears in the corollary that follows .",
    "[ proposition : dlcomplexity ] let @xmath7 be a basis for a finite abelian @xmath0-group @xmath2 with rank @xmath19 and exponent @xmath18 . set @xmath113 , and let @xmath280 be the rank of the subgroup of @xmath109th powers in @xmath2 .",
    "there is a generic algorithm to compute @xmath20 using @xmath281 group operations , where @xmath248 is an absolute constant independent of @xmath2 .",
    "when a probabilistic algorithm is used for the base cases ( such as the rho method ) , the algorithm in the proposition is probabilistic and @xmath282 refers to the expected running time , but otherwise the algorithm is deterministic .",
    "the bound on @xmath282 depends only on the structure of @xmath2 , not the basis @xmath13 .",
    "we use algorithm [ algorithm : dlp ] to compute @xmath283 using @xmath237 .",
    "as discussed above , we label the levels of the recursion tree with @xmath257 at the base and @xmath258 at the root .",
    "we let @xmath284 denote the size of the first interval at level @xmath262 , and assume that all others have size at least @xmath285 and at most  @xmath284 .",
    "thus @xmath261 , and we recursively define @xmath286 down to @xmath273 . to simplify the proof we use @xmath287 ( independent of @xmath0 ) , and assume @xmath288 .",
    "there is a base case in @xmath289 for each @xmath290 , with @xmath291 .",
    "applying either of the standard @xmath238 discrete logarithm algorithms to the base cases yields the second sum in the bound for @xmath282 , with @xmath292 .    at level @xmath262 of the recursion tree ,",
    "the total cost of step 3 is bounded by @xmath293 since @xmath32 exponentiations by @xmath0 are required .",
    "the total cost of the multiplications by  @xmath132 in step 4a is bounded by @xmath294 .",
    "all other group operations occur in exponentiations in step 4a .",
    "these are of the form @xmath295 , where @xmath296 .",
    "to bound their cost , we consider the cost @xmath297 associated to a particular @xmath298 at level @xmath262 .",
    "the exponentiation of @xmath298 is nontrivial only when @xmath299 and @xmath300 .",
    "thus to bound @xmath297 , we only count exponentiations with @xmath299 , and only consider levels @xmath262 of the recursion tree with @xmath301 , since at all higher levels @xmath302 will still be zero .    in the recursive call to compute @xmath149 , we may compute @xmath295 using fixed bases @xmath303 , where @xmath304 as in ( [ equation : alphajk ] ) , since @xmath145 divides @xmath227 for all @xmath305 . for each @xmath298",
    "we can precompute all the @xmath303 for a cost of @xmath306 at level @xmath307 with @xmath301 , there are @xmath308 instances of up to @xmath309 nontrivial exponentiations involving @xmath298 .",
    "these are computed using the common base @xmath303 , with exponents bounded by @xmath310 . applying yao s theorem ,",
    "@xmath311 if @xmath312 , we replace @xmath313 by 1 and @xmath314 by @xmath315 , otherwise we replace @xmath314 by @xmath316 .",
    "we then apply @xmath317 ( for @xmath318 ) to remove both ceilings and obtain @xmath319 if @xmath320 then @xmath321 .",
    "otherwise @xmath322 , and then @xmath323 which implies @xmath324 .",
    "this yields @xmath325 .",
    "it remains to bound the number of levels @xmath307 with @xmath301 .",
    "this is equal to the least @xmath262 for which @xmath326 , which we denote @xmath327 .",
    "we derive an upper bound on @xmath327 as a function of @xmath328 by proving a lower bound on @xmath284 as a function of  @xmath262 .",
    "we recall that @xmath273 and for @xmath329 we have @xmath330 and @xmath331 .",
    "this implies @xmath332 and @xmath333 for all @xmath334 .",
    "stirling s formula yields a lower bound on @xmath284 , from which one obtains the upper bound @xmath335 valid for @xmath336 .",
    "the lexicographically minimal sequence of integers satisfying @xmath273 and @xmath337 for all @xmath307 begins @xmath338 , and one finds that @xmath339 satisfy ( [ equation : dni ] ) , with @xmath340 and @xmath341 .",
    "the total cost of all computations outside of the base cases is then bounded by @xmath342 where we use @xmath343 , and the constant @xmath344 .",
    "this yields the first sum in the bound for @xmath282 and completes the proof .    for the sake of brevity",
    "we have greatly overestimated the constant @xmath248 in the proof above .",
    "empirically , @xmath248 is always less than 2 , and typically close to 1 ( see section [ section : performance ] ) .",
    "the space used by algorithm 1 depends on how the base cases are handled , but can be bounded by @xmath345 group elements .",
    "there are at most @xmath346 distinct @xmath303 that need to be precomputed , which fits within this bound . in practice ,",
    "additional precomputation using slightly more storage , perhaps @xmath277 elements , can accelerate both the exponentiations and the base cases @xcite .",
    "for many groups arising `` in nature '' , both sums in the bound for @xmath282 are typically dominated by their first terms .",
    "divisor class groups of curves and ideal class groups of number fields are , at least heuristically , two examples .",
    "one often sees an @xmath347-shaped young diagram , with @xmath348 , where @xmath349 .",
    "algorithm  1 yields a useful improvement here , with a complexity of @xmath350 versus @xmath351 .",
    "more generally , we have the following corollary .",
    "[ corollary : dlcomplexity ] let @xmath13 be a basis for a finite abelian @xmath0-group @xmath2 of size @xmath40 , exponent  @xmath18 , and rank @xmath19 .",
    "there is a generic algorithm to compute @xmath20 using @xmath352 group operations .",
    "the first term is immediate from proposition [ proposition : dlcomplexity ] since @xmath353 and @xmath354 for all @xmath61 . for the second term , consider @xmath355 .",
    "we have @xmath356 and @xmath357 . for",
    "fixed @xmath19 and @xmath14 , the worst case , up to a constant factor , occurs when the @xmath358 are roughly equal ( one uses lemma [ lemma : prodsum ] to prove this ) .",
    "the asymptotic upper bound on @xmath282 achieved here is nearly tight for generic algorithms . when @xmath359 , the bound in the corollary becomes @xmath350 , matching shoup s @xmath360 lower bound .",
    "even when this is not the case , one may argue , along the lines of shoup , that the sum @xmath361 in proposition [ proposition : dlcomplexity ] is tight in any event .",
    "the first term in the corollary is @xmath362 , and one does not expect to do better than @xmath277 , given an @xmath363 lower bound for exponentiation .    to complete our discussion of discrete logarithms",
    ", we give an algorithm to compute @xmath20 in an arbitrary finite abelian group @xmath2 .",
    "we assume that @xmath13 is a prime - power basis for @xmath2 , composed of bases @xmath364 for each of the sylow @xmath0-subgroups of @xmath2 .",
    "the construction of such a basis is discussed in the next section ( and readily obtained from a given basis in any event ) .",
    "[ algorithm : dl ] given a prime - power basis @xmath13 for a finite abelian group @xmath2 with @xmath365 a factorization into powers of distinct primes @xmath366 , and @xmath50 , the following algorithm computes @xmath11 :    1 .",
    "let @xmath367 and compute @xmath368 for @xmath62 from 1 to @xmath71 .",
    "2 .   compute @xmath369 using algorithm [ algorithm : dlp ] .",
    "3 .   set @xmath370 .    the symbol ",
    "@xmath371 \" denotes concatenation of vectors . since @xmath372 , we must have @xmath373 , and the components of @xmath374 all have order a power of @xmath375 .",
    "the exponent vector @xmath376 is thus divisible by @xmath377 , since @xmath377 is coprime to @xmath375 and therefore a unit in each factor of the ring @xmath378 .",
    "the correctness of algorithm [ algorithm : dl ] follows easily .",
    "let @xmath379 . for @xmath380 , the exponentiations in step 1 can be performed using @xmath253 group operations , by yao s theorem .",
    "as @xmath71 approaches @xmath14 , this bound increase to @xmath381 , and one should instead apply the @xmath382 algorithm of ( * ? ? ?",
    "the total running time is then @xmath383 group operations , where @xmath384 denotes the sylow @xmath109-subgroup of @xmath2 . for sufficiently large @xmath236 ,",
    "the bound for @xmath282 is dominated by the sum in ( [ equation : tdlgeneral ] ) .",
    "for a finite abelian group @xmath2 , the _ group structure _ problem asks for a factor decomposition of @xmath2 into cyclic groups of prime - power order , with a generator for each factor .",
    "this is equivalent to computing a basis for each of the ( nontrivial ) sylow @xmath0-subgroups of @xmath2 .",
    "we first suppose that @xmath2 is a @xmath0-group , then give a reduction for the general case in section [ section : generalbasis ] .    typically , a basis is derived from a matrix of relations among elements of a generating set for the group @xcite .",
    "this generating set may be given , our obtained ( with high probability ) from a random sample .",
    "one then computes the smith normal form of the relation matrix @xcite , applying corresponding group operations to the generating set to produce a basis .",
    "relations may be obtained via _ extended discrete logarithms_. if @xmath13 is a basis for a subgroup of @xmath2 and @xmath50 , then @xmath385 is the pair @xmath386 satisfying @xmath22 that minimizes @xmath387 , with @xmath54 . in a @xmath0-group , @xmath388 is necessarily a power of @xmath0 .",
    "while our approach does not require us to compute @xmath385 , we note that any algorithm for @xmath20 can be used to compute @xmath385 .",
    "[ lemma : edlreduction ] given a basis @xmath13 for a subgroup of a finite abelian @xmath0-group @xmath2 and @xmath50 , there is a generic algorithm to compute @xmath385 using at most @xmath389 group operations .",
    "assume algorithm [ algorithm : dlp ] returns an error whenever a base case fails .",
    "compute @xmath390 for @xmath391 , then use a binary search to find the least @xmath62 for which one can successfully compute @xmath392 .",
    "we then have @xmath393 .",
    "teske gives an algorithm to directly compute @xmath385 , avoiding the @xmath394 factor above , but this may still be slower than applying lemma [ lemma : edlreduction ] to algorithm [ algorithm : dlp ] . alternatively , we may modify algorithm @xmath395 to solve a slightly easier problem . instead of solving @xmath22 , we seek a solution to @xmath396 .",
    "more specifically , let us define a function @xmath397 that extends the function @xmath149 computed by algorithm 1 .",
    "if @xmath13 is a basis for a subgroup of an abelian @xmath0-group @xmath2 and @xmath50 , we wish to compute a pair @xmath398 , with @xmath399 and @xmath400 minimal .",
    "it may be that there is no @xmath401 for which such a pair exists , and in this case should be @xmath402 here ( so that @xmath403 ) , but this is less convenient .",
    "] we let @xmath404 and @xmath208 . when @xmath13 generates a subgroup with exponent @xmath18 , we use @xmath405 to denote @xmath406 .    [",
    "algorithm : edlp ] let @xmath13 be a basis for a subgroup of a finite abelian @xmath0-group @xmath2 and let @xmath151 . given @xmath50 and @xmath407 , compute @xmath408 as follows :    1 .   if @xmath154 , compute @xmath409 as a base case .",
    "return @xmath398 .",
    "2 .   choose integers @xmath156 satisfying @xmath157 .",
    "3 .   compute @xmath158 for @xmath61 from 1 to @xmath159 , and set @xmath160 .",
    "4 .   for @xmath61 from @xmath159 down to 1 : 1 .",
    "recursively compute @xmath410 .",
    "2 .   set @xmath162 , where @xmath411 .",
    "3 .   if @xmath412 then return @xmath413 .",
    "return @xmath414 .    for @xmath237 , the base case simply computes @xmath11 and returns @xmath414 , or @xmath415 if a failure occurs .",
    "when @xmath416 , one applies lemma [ lemma : edlreduction ] ( if a lookup table is used , this means @xmath417 table lookups and @xmath418 group operations ) .    aside from the computation of @xmath419 and the possibility of early termination , algorithm 3",
    "is essentially the same as algorithm 1 . indeed , assuming @xmath237 , if @xmath398 is the output of algorithm 3 , the sequence of group operations performed by algorithm 1 on input @xmath420 will be effectively identical ( ignoring operations involving the identity ) .",
    "thus the complexity bounds in proposition [ proposition : dlcomplexity ] and its corollary apply .    to verify the correctness of algorithm 3 , we first note that if @xmath404 then the first base case must have failed and the output @xmath421 is correct .",
    "if @xmath401 then it follows from the correctness of algorithm 1 that @xmath399 .",
    "it is only necessary to check that @xmath419 is minimal , but if not , the base case @xmath422 would have succeeded and @xmath419 would be smaller .    we now explain how to construct a basis using algorithm 3 .",
    "let us start with a vector @xmath13 consisting of a single element of @xmath2 .",
    "clearly @xmath13 is a basis for the cyclic subgroup it generates , and we would like to extend @xmath13 to a basis for all of @xmath2 by adding elements to it one by one .",
    "this will only be possible if our basis at each step generates a subgroup @xmath1 that is a factor of @xmath2 ( meaning @xmath423 ) .",
    "some care is required , since @xmath1 need not be a factor of @xmath2 , but let us first consider how to extend a basis .",
    "given a basis @xmath13 for a subgroup @xmath1 of @xmath2 , we say that @xmath242 is _ independent _ of  @xmath13 if the vector @xmath424 is a basis for @xmath425 , and write @xmath426 .",
    "the following lemma shows how and when one may use @xmath405 to obtain such a @xmath118 .",
    "[ lemma : independence ] let @xmath13 be a basis for a subgroup of a finite abelian @xmath0-group @xmath2 , with @xmath113 , @xmath427 , and @xmath428 .",
    "let @xmath50 and let @xmath429 , where @xmath430 .",
    "the following hold :    1 .   if @xmath431 then @xmath432 .",
    "if @xmath431 and @xmath433 then @xmath426 .    if @xmath434 then @xmath435 , and we have @xmath436 since @xmath437 , as defined in ( [ equation : alphajk ] ) , has @xmath438 .",
    "it follows that @xmath439 and this can not hold for any @xmath440 , by the minimality of @xmath419 . thus ( i ) holds when @xmath434 .",
    "now suppose @xmath441 .",
    "then @xmath208 , @xmath442 , and @xmath443 .",
    "if @xmath431 , then @xmath444 , thus ( i ) also holds when @xmath441 .    to prove ( ii ) , assume @xmath445 and @xmath446 , and suppose @xmath426 does not hold .",
    "then there is a nontrivial relation of the form @xmath447 , for some @xmath85 and @xmath448 , since @xmath432 by ( i ) .",
    "we claim that @xmath449 is not divisible by @xmath109 , since @xmath450 and if @xmath109 divides @xmath449 we can set @xmath451 to obtain @xmath452 which contradicts the minimality of @xmath419 .",
    "we now note that if @xmath446 , then @xmath453 has order at most @xmath454 . but @xmath455 has order greater than @xmath454 , since some @xmath456 is not divisible by @xmath109 , and therefore @xmath457 , yielding a contradiction .",
    "lemma [ lemma : independence ] not only tells us how to find independent elements , it gives sufficient conditions to ensure that this is possible .",
    "this yields a remarkably simple algorithm to construct a basis from a generating set @xmath33 .",
    "start with @xmath13 consisting of a single element of @xmath33 with maximal order @xmath18 .",
    "every @xmath458 then satisfies @xmath459 , and we may use algorithm [ algorithm : dlp ] to compute an independent @xmath429 for each @xmath12 .",
    "we can then choose one with maximal order to extend our basis @xmath13 , and continue in this fashion until we have a basis spanning the entire group generated by @xmath33 .",
    "[ algorithm : pbasis ] given a subset @xmath33 of a finite abelian @xmath0-group , the following algorithm computes a basis @xmath13 for @xmath460 :    1 .",
    "set @xmath461 and compute @xmath462 for each @xmath463 .",
    "2 .   if every @xmath464 , return @xmath13 . + otherwise pick a maximal @xmath465 , set @xmath466 , then @xmath467 and @xmath468 .",
    "3 .   for each @xmath469",
    ": 1 .   compute @xmath470 using algorithm [ algorithm : edlp ] .",
    "2 .   set @xmath471 and @xmath472 .",
    "4 .   go to step 2 .",
    "after step 1 we have ( trivially ) @xmath473 for all @xmath474 , and after step  2 we must have @xmath475 for all @xmath465 . by lemma [ lemma : independence ] , these statements remain true after step  3 , and at every step the algorithm ensures that @xmath476 and @xmath477 . if every @xmath464 , then @xmath478 is trivial and @xmath13 is a basis for @xmath2 .",
    "some nonzero @xmath465 is set to zero each time step 2 is executed , so this eventually happens .",
    "note that when an element @xmath474 is appended to @xmath13 , its order @xmath479 is known , as desired .",
    "[ proposition : basiscomplexity ] given a set @xmath33 that generates an abelian group @xmath2 of size @xmath40 , exponent @xmath18 , and rank @xmath19 , there is a generic algorithm to compute a basis for @xmath2 using @xmath480 group operations , where @xmath282 is as in proposition [ proposition : dlcomplexity ] , and @xmath248 is an absolute constant independent of @xmath33 and @xmath2 .",
    "we apply algorithm [ algorithm : pbasis ] , setting @xmath237 in algorithm [ algorithm : edlp ] .",
    "we assume that a table of all nontrivial @xmath109th powers of each element of @xmath13 is maintained throughout , for a total cost of at most @xmath481 group operations ( this table can also be made available to algorithm [ algorithm : edlp ] , avoiding the need for any precomputation )",
    ". for each @xmath482 , computing @xmath483 in step 1 requires less than @xmath484 group operations .",
    "the cost of all the exponentiations in step 3b related to @xmath12 is bounded by @xmath481 ( if we consider @xmath11 for the initial value of @xmath12 relative to the final basis @xmath13 , each base-@xmath0 digit of @xmath485 is  cleared \" in step 3b at most once ) .",
    "the total cost of all steps other than 3a is thus @xmath486 group operations , which is bounded by the sum of the first and last terms in the bound for @xmath487 , for a suitable constant @xmath248 .",
    "we now consider the cost of step 3a for those @xmath488 for which @xmath465 is never chosen in step 2 , meaning @xmath474 is never appended to @xmath13 .",
    "there are exactly @xmath489 such @xmath12 . for each base case that succeeds in some computation @xmath405",
    ", the order of @xmath12 is reduced by a factor of @xmath0 in step 3b , so there are at most @xmath32 successful base cases relevant to @xmath12 in the entire execution of algorithm [ algorithm : pbasis ] .",
    "ignoring the cost of reaching the first base case , and failed base cases , the successful part of all the @xmath405 computations involving @xmath12 corresponds to a single computation @xmath20 with respect to the final basis @xmath13 for @xmath2 , which we bound by @xmath282 .",
    "when computing @xmath405 , reaching the first base case involves exponentiating  @xmath12 ( and precomputing @xmath116 , but this was addressed above ) .",
    "the order of @xmath12 is bounded by the order of the most recently added component @xmath298 of @xmath13 , hence the total cost of all the initial exponentiations of @xmath12 is at most @xmath490 , which is bounded by a constant factor of @xmath282 .",
    "summing over the @xmath489 elements  @xmath12 yields the term @xmath491 in the bound for @xmath492 .",
    "it remains to consider the cost of step 3a for the elements @xmath493 that are at some point appended to @xmath13 . with @xmath113",
    ", we have @xmath494 .",
    "define @xmath495 for @xmath496 , and let @xmath497 .",
    "excluding base cases , the successful part of all computations @xmath498 may be bounded , as in proposition [ proposition : dlcomplexity ] , by a constant factor of @xmath499 where we have used @xmath500 for positive integers @xmath501 with @xmath502 . as above , the total cost of reaching the first base case in the computations @xmath498 for @xmath474 is at most @xmath481 , which may be incorporated into ( [ equation : bbound1 ] ) , yielding the first term of the bound for @xmath492 .",
    "finally , we consider the cost of the base cases occurring for @xmath493 . in the @xmath61th iteration of step 3a , there are @xmath503 elements @xmath474 which have yet to be appended to @xmath13 , and exactly one base case fails for each of these .",
    "thus we may bound the cost of all failed base cases by a constant factor of @xmath504 for the successful base cases , let @xmath280 be the rank of the subgroup of @xmath109th powers in  @xmath2 , as in proposition [ proposition : dlcomplexity ] , so that @xmath357 .",
    "for each @xmath280 we obtain a sum of the form ( [ equation : bbound2 ] ) , and note that , as in corollary [ corollary : dlcomplexity ] , we may bound the cost to within a constant factor by assuming the @xmath280 are all approximately equal to @xmath19 . in this case",
    "we have @xmath505 , yielding the term @xmath506 in the bound for @xmath492 , which also covers the failed base cases , for a suitable choice of @xmath248 .    if we are given a set @xmath33 of independent elements , proposition [ proposition :",
    "basiscomplexity ] implies that we can typically verify that @xmath33 is a basis for @xmath507 more quickly than we can compute discrete logarithms in @xmath2 .",
    "in fact this is true whenever @xmath508 , even if the elements of @xmath33 are not independent .",
    "more generally , we have the following corollary .",
    "[ corollary : basiscomplexity ] given a generating set @xmath33 for a finite abelian @xmath0-group @xmath2 of rank @xmath19 , with @xmath509 , there is a generic algorithm to compute a basis for @xmath2 using @xmath510 group operations .",
    "when a generating set is not available , or when @xmath511 , we may instead use a probabilistic algorithm to construct a basis from randomly sampled elements of @xmath2 .",
    "if @xmath19 is known ( or bounded ) , corollary [ corollary : basiscomplexity ] can be applied to a randomly generated subset @xmath37 of size @xmath512 to obtain a generic monte carlo algorithm that is correct of @xmath2 , but it may be that @xmath513 . ] with probability at least @xmath514 .",
    "this follows from the lemma below , whose proof can be found in ( * ? ? ?",
    "* eq .  2 ) and",
    "also ( * ? ? ?",
    "* lem .  4 ) .",
    "[ lemma : generatingprobability ] let @xmath2 be a finite abelian @xmath0-group of rank @xmath19 , and let @xmath33 be a sample of @xmath515 independent and uniformly distributed random elements of @xmath2 .",
    "then @xmath33 generates @xmath2 with probability @xmath516    in general , we do not know the rank of @xmath2 , _ a priori_. indeed , determining @xmath19 may be a reason for computing a basis .",
    "in this situation we could apply algorithm [ algorithm : pbasis ] to progressively larger randomly generated sets @xmath33 until @xmath517 , where @xmath19 is the rank of @xmath478 and @xmath231 is a constant .",
    "however , a more efficient approach is to simply select random @xmath50 , using the black box or via lemma [ lemma : randomelements ] below , and attempt to use lemma [ lemma : independence ] to extend the current basis .",
    "this eliminates the loop in step 3 of algorithm [ algorithm : pbasis ] , but we must now address the situation where lemma [ lemma : independence ] fails to apply ( @xmath518 or @xmath519 ) .",
    "it may happen that the basis we have constructed can not be extended to a basis for @xmath2 , and in this case we need to backtrack .",
    "fortunately , this is easy to detect ( and correct ) , and has negligible impact on the expected running time .",
    "[ algorithm : prandbasis ] given a randomized black box for a finite abelian @xmath0-group @xmath2 and @xmath151 , the following algorithm computes a basis @xmath13 for a subgroup @xmath1 of @xmath2 , where @xmath520 with probability at least @xmath514 :    1 .",
    "set @xmath521 .",
    "pick a random @xmath522 and set @xmath523 .",
    "2 .   if @xmath524 then return @xmath13 .",
    "3 .   pick a random @xmath50 and compute @xmath525 .",
    "4 .   if @xmath526 then increment @xmath527 and go to step 2 , otherwise set @xmath528 .",
    "5 .   for each @xmath298 with @xmath529 , remove @xmath298 from @xmath13 and set @xmath521 . 6 .",
    "set @xmath530 and go to step 2 .",
    "the correctness of algorithm [ algorithm : prandbasis ] depends on an easy corollary to lemma [ lemma : independence ] . if we let the ( possibly empty ) vector @xmath531 consist of those components of @xmath13 that satisfy @xmath532 , then @xmath533 ( the proof is the same ) .",
    "it follows that after step 6 , @xmath13 is a basis for the subgroup it generates ( this is obviously also true after step 1 ) .",
    "when the algorithm terminates , it has found @xmath231 ( independent , uniformly distributed ) random elements @xmath50 that lie in @xmath534 .",
    "if @xmath1 is a proper subgroup of @xmath2 , it must be smaller by a factor of at least @xmath0 ; the probability that @xmath231 random elements @xmath50 all happen to lie in @xmath1 is then at most @xmath535 .",
    "[ proposition : prandbasiscomplexity ] given a randomized black box for a finite abelian @xmath0-group @xmath2 of rank @xmath19 , exponent @xmath18 , and size @xmath40 , and @xmath151 , there is a probabilistic generic algorithm that computes a basis for a subgroup @xmath1 of @xmath2 using an expected @xmath536 group operations , such that @xmath520 with probability at least @xmath514 .",
    "the absolute constant @xmath248 is independent of both @xmath231 and @xmath2 .",
    "we apply algorithm [ algorithm : prandbasis ] .",
    "if it never backtracks ( removes elements from @xmath13 in step 5 ) , the final basis @xmath13 is obtained from the first @xmath19 random elements , and then @xmath231 discrete logarithms are computed using this basis . in this case , the bound @xmath537 follows from an argument similar to that used in the proof of proposition [ proposition : basiscomplexity ] , with @xmath508 ( and a better constant factor ) .",
    "we will show that the expected cost of algorithm [ algorithm : prandbasis ] is within a constant factor of the cost arising in this ideal scenario .",
    "let @xmath7 be the final basis output by algorithm [ algorithm : prandbasis ] , and note that @xmath538 .",
    "as the computation proceeds , for each @xmath71 from 1 to @xmath19 , there is a stage @xmath71 where @xmath539 is a ( possibly empty ) prefix of the final basis , and the algorithm is in the process of determining @xmath540 .",
    "this may involve extending and then backtracking to the prefix @xmath541 ( several times , perhaps ) , but once @xmath540 is determined , we have the prefix @xmath542 and transition to stage @xmath543 .",
    "if no backtracking occurs , the algorithm completes stage 1 after step 1 , and a single computation of @xmath544 is required for each stage @xmath545 . from proposition [ proposition :",
    "dlcomplexity ] , the cost of this computation may be bounded by @xmath546 where @xmath547 is a constant , @xmath113 , and the ranks @xmath548 are as in proposition  [ proposition : dlcomplexity ] .",
    "let @xmath549 and @xmath550 denote the two sums in @xmath551 , including the factor @xmath547 .",
    "we now consider the probability that the computation @xmath552 completes stage @xmath71 .",
    "let @xmath449 be the discrete logarithm of @xmath12 relative to the final basis @xmath13 .",
    "provided that @xmath553 is not divisible by @xmath0 , when @xmath419 is computed in step 3 we will have @xmath554 , and compute @xmath555 in step 4 , since no subsequent computation can yield an independent element of order greater than @xmath556 ( since @xmath557 for @xmath558 ) . thus for each random @xmath50 processed during stage  @xmath71 , the probability that we do not complete stage  @xmath71 is at most @xmath559 ( this is true for any extension of @xmath541 arising during stage  @xmath71 ) .",
    "conditioning on @xmath159 , the number of random @xmath50 processed during stage  @xmath71 , the expected cost of stage  @xmath71 may be bounded by a sum of the form @xmath560 where @xmath561 .",
    "we have assumed here , as a worst case , that after processing each @xmath12 the current basis is extended by a @xmath118 that maximizes the cost of subsequent discrete logarithm computations .",
    "for each increment in @xmath159 we suppose that @xmath562 increases by a factor of @xmath563 ( in fact , it increases by at most a factor of @xmath564 ) , and that every @xmath280 increases by 1 .",
    "the second sum in ( [ equation : prandbasis1 ] ) is a geometric series , bounded by @xmath565 .",
    "summation by parts yields the identity @xmath566 allowing us to bound the first sum in ( [ equation : prandbasis1 ] ) by 4 .",
    "hence @xmath567 for a constant @xmath568 , and the bound on @xmath569 follows .",
    "the correctness probability was addressed above , and clearly @xmath570 is independent of @xmath231 and @xmath2 .    in practice , the constant @xmath248 in proposition [ proposition : prandbasiscomplexity ] is quite small and @xmath571 , even when @xmath26 ( the worst case , as far as the constant factors are concerned ) .",
    "when @xmath282 is dominated by @xmath572 , the constant @xmath231 can be improved to @xmath573 using a baby - steps giant - steps approach , as discussed in section [ section : performance ] .",
    "if we are given a bound @xmath574 satisfying @xmath575 ( perhaps @xmath576 ) , we can easily convert algorithm [ algorithm : prandbasis ] from a monte carlo algorithm to a las vegas algorithm by replacing the test ",
    "@xmath524 \" in step 2 with  @xmath577 \" ( note that @xmath578 ) .",
    "we now give a method to construct uniformly random elements of @xmath2 from a generating set @xmath33 .",
    "this is useful in general , and allows us to apply algorithm [ algorithm : prandbasis ] to a generating set @xmath33 , which may be faster than using algorithm [ algorithm : pbasis ] when @xmath511 .",
    "[ lemma : randomelements ] given a generating set @xmath33 for a finite abelian group @xmath2 with exponent @xmath579 , and @xmath151 , there is a generic algorithm to compute @xmath231 independent , uniformly random elements of @xmath2 using @xmath580 group operations and storage for at most @xmath581 group elements .",
    "we represent @xmath33 as a vector @xmath582 . to construct random elements",
    "@xmath583 , first set each @xmath584 to @xmath585 , then , for each @xmath132 , compute @xmath586 , select @xmath231 uniformly random integers @xmath587 , and set @xmath588 for each @xmath62 .",
    "we assume all the @xmath589 are chosen independently .",
    "the cost of computing @xmath590 is at most @xmath591 group operations .",
    "by yao s theorem , the cost of @xmath231 exponentiations of the common base @xmath132 is at most @xmath592 group operations , where @xmath247 .",
    "accounting for the multiplication by @xmath584 and summing over the @xmath132 yields the bound @xmath593 .",
    "we only need to store the @xmath584 and at most @xmath594 powers of a single @xmath132 at each step ( we do nt count the size of the input set @xmath33 , since we only access one element of @xmath33 at a time ) .",
    "clearly the @xmath584 are independent ; we must show each is uniformly distributed over  @xmath2 .",
    "let @xmath595 .",
    "the map @xmath596 that sends @xmath449 to @xmath597 is a surjective group homomorphism , and we have @xmath598 , where @xmath599 is uniformly distributed over @xmath1 . as each coset of @xmath600 has the same size , it follows that @xmath584 is uniformly distributed over @xmath601 .    in practice ,",
    "we may wish to generate random elements  on demand \" , without knowing @xmath231 .",
    "we can generate random elements in small batches of size @xmath602 to effectively achieve the same result .",
    "if @xmath33 is reasonably small , the first term of @xmath593 may be treated as a precomputation and need not be repeated .",
    "provided that @xmath603 , we may apply lemma [ lemma : randomelements ] and proposition [ proposition : prandbasiscomplexity ] to compute a basis for @xmath460 , with high probability , using @xmath3 group operations . by contrast , algorithm [ algorithm : pbasis ] uses @xmath35 group operations when @xmath33 is large , as does the algorithm of buchmann and schmidt @xcite . however , we note that both of these algorithms are ( or can be made ) deterministic .",
    "we now suppose that @xmath2 is an arbitrary finite abelian group .",
    "if we know the exponent of @xmath2 , call it @xmath604 , and its factorization into prime powers , we can easily reduce the computation of a basis for @xmath2 to the case already considered .",
    "in fact , it suffices to know any reasonably small multiple @xmath605 of @xmath604 , including @xmath606 .",
    "factoring @xmath605 does not require any group operations , and is , in any event , a much easier problem than computing @xmath604 in a generic group , hence we ignore this cost .",
    "lower bound of ( * ? ? ?",
    "2.3 ) . ]",
    "as shown in the author s thesis , @xmath604 can be computed using @xmath607 group operations @xcite .",
    "this bound is strictly dominated by the worst - case complexity of both the algorithms presented in the previous section , allowing us to extend our complexity bounds for abelian @xmath0-groups to the general case .",
    "the basic facts needed for the reduction are given by the following lemma .",
    "[ lemma : subsample ] let @xmath2 be a finite abelian group and let @xmath605 be a multiple of @xmath604 .",
    "let @xmath608 be distinct primes dividing @xmath605 , and let @xmath609 be the sylow @xmath610-subgroup of @xmath2",
    ".    1 .   given a generating set @xmath33 for @xmath2 , one can compute generating sets @xmath611 for @xmath612 , each of size @xmath613 , using @xmath614 group operations .",
    "2 .   given a uniformly distributed random @xmath50",
    ", one can compute elements @xmath615 uniformly distributed over the groups @xmath612 @xmath616respectively@xmath617 , using @xmath618 group operations .",
    "let @xmath619 be the largest divisor of @xmath605 relatively prime to @xmath610 .",
    "given @xmath458 , or a random @xmath50 , we compute @xmath620 with either algorithm  7.3 or algorithm  7.4 of @xcite , using @xmath621 group operations .",
    "the map @xmath622 sending @xmath12 to @xmath623 is a surjective group homomorphism , invertible on @xmath624 . thus if @xmath33 generates @xmath2 , then @xmath625 generates @xmath609 , which proves ( i ) .",
    "if @xmath12 is uniformly distributed over @xmath2 , then @xmath626 is uniformly distributed over @xmath609 , proving ( ii ) .",
    "we now extend propositions [ proposition : basiscomplexity ] and [ proposition : prandbasiscomplexity ] to arbitrary finite abelian groups . to simplify the statement of results",
    ", we suppose that @xmath605 is equal to either @xmath604 or @xmath236 .",
    "[ proposition : basis ] let @xmath2 be a finite abelian group whose nontrivial sylow subgroups are @xmath612 , and suppose that the exponent @xmath616resp .",
    "order@xmath617 of @xmath2 is given .",
    "let @xmath33 be a generating set for @xmath2 , with @xmath627 as in lemma [ lemma : subsample ] .    1 .",
    "there is a generic algorithm to compute a basis for @xmath2 which uses @xmath628 group operations , where @xmath629 is bounded as in proposition [ proposition : basiscomplexity ] .",
    "2 .   given a randomized black box for @xmath2 , there is a monte carlo @xmath616resp .",
    "las vegas@xmath617 generic algorithm to compute a basis for @xmath2 using an expected @xmath630 group operations , where @xmath631 is bounded as in proposition [ proposition : prandbasiscomplexity ] .",
    "\\(i ) is immediate from lemma [ lemma : subsample ] and proposition [ proposition : basiscomplexity ] .",
    "( ii ) follows similarly from proposition [ proposition : prandbasiscomplexity ] and the comments following , using the bound @xmath632 from lemma [ lemma : prodsum ] .",
    "[ corollary : basis ] given a randomized black box for a finite abelian group @xmath2 , there is a probabilistic algorithm to compute a basis for @xmath2 using @xmath3 group operations .",
    "algorithm 8.1 of @xcite computes @xmath633 ( with high probability ) using @xmath634 group operations , assuming algorithms 5.1 and 5.2 of @xcite are used for order computations .",
    "the corollary then follows from ( 3 ) of proposition [ proposition : basis ] .",
    "if we are given a generating set @xmath33 with @xmath603 , we may apply lemma  [ lemma : randomelements ] to obtain an analogous corollary .    the space required by the algorithms of proposition [ proposition : basis ] and corollary [ corollary : basis ]",
    "can be made quite small , polynomial in @xmath635 , using algorithms based on pollard s rho method to handle the base cases of the discrete logarithm computations , and also the search used in algorithm 5.1 of @xcite .",
    "if this is done , the complexity bound for computing @xmath604 increases to @xmath636 ( but will typically be better than this ) .",
    "it is not necessary to use a particularly fast algorithm to compute @xmath604 in order to prove corollary [ corollary : basis ] , any @xmath636 algorithm suffices .",
    "however , the time to compute a basis for @xmath2 is often much less then @xmath637 group operations , as the worst case may arise rarely in practice . applying algorithms 5.1 and 5.2 of @xcite yields considerable improvement in many cases . of @xmath638 $ ] , with @xmath639 , using @xmath640 group operations @xcite . in @xcite , a basis for @xmath2",
    "is computed using @xmath641 group operations . ]",
    "these comments are especially relevant when one only wishes to compute a basis for a particular sylow @xmath0-subgroup @xmath1 of @xmath2 ( perhaps as a prelude to extracting @xmath0th roots in @xmath2 ) .",
    "once we have computed @xmath604 , we can compute a basis for any of  @xmath2 s sylow subgroups with a running time that typically depends only on the size and shape of the subgroup of interest , not on @xmath2 .",
    "the following proposition follows immediately from lemma [ lemma : subsample ] and proposition [ proposition : prandbasiscomplexity ] .",
    "let @xmath1 be a sylow @xmath0-subgroup of a finite abelian group @xmath2 .",
    "given a multiple @xmath605 of the exponent of @xmath2 and a randomized black box for @xmath2 , there is a probabilistic generic algorithm to compute a basis for @xmath1 using @xmath642 group operations , where @xmath19 is the rank of @xmath1 .",
    "we tested the new algorithms on abelian @xmath0-groups of various sizes and shapes in order to assess their performance .",
    "as in previous sections , @xmath2 is an abelian group of size @xmath40 , exponent @xmath18 , and rank @xmath19 , whose shape is given by a partition of @xmath14 into  @xmath19 parts , with largest part @xmath32 .",
    "we present here results for @xmath26 , as this permits the greatest variation in the other parameters , and also because the sylow 2-subgroup is of particular interest in many applications .",
    "results for other small primes are similar . when @xmath0 is large , the results are not as interesting : @xmath14 , @xmath19 , and @xmath32 are all necessarily small and the computation is dominated by the discrete logarithms computed in the base cases , whose @xmath643 performance is well understood .",
    "our tests in @xmath0-groups used a black box which represents each cyclic factor of @xmath2 using integers mod @xmath644 .",
    "this is a convenient but arbitrary choice .",
    "identical results are obtained for any black box implementation , since the algorithms are generic .",
    "our performance metric counts group operations ( multiplications and inversions ) , and does not depend on the speed of the black box or the computing platform .    to compute discrete logarithms in the base cases , we used shanks baby - steps giant - steps algorithm @xcite extended to handle products of cyclic groups . rather than the lexicographic ordering used by algorithm 9.3 of @xcite ,",
    "we instead compute a gray code @xcite when enumerating steps , always using one group operation per step ( this is especially useful for small @xmath0 , saving up to a factor of 2 ) .",
    "a more significant optimization available with shanks method is the ability to perform @xmath71 discrete logarithms in a group of size @xmath605 using @xmath645 ( rather than @xmath646 ) group operations by storing @xmath647 baby steps in a lookup table and then taking @xmath648 giant steps as each of the @xmath71 discrete logarithms is computed .",
    "baby steps to optimize the expected case , assuming @xmath8 . ]",
    "this optimization is useful in algorithms [ algorithm : dlp ] and [ algorithm : edlp ] , even for a single discrete logarithm computation , as there may be many base cases in the same subgroup .",
    "it is even more useful in the context of algorithms [ algorithm : pbasis ] and [ algorithm : prandbasis ] , as several calls to algorithm [ algorithm : edlp ] may use the same basis . in the bound for @xmath282 in corollary [ corollary : dlcomplexity ] , this effectively replaces the factor @xmath649 by @xmath650 . when the rank - dependent terms in @xmath282 dominate sufficiently , the bounds in propositions [ proposition : basiscomplexity ] and [ proposition : prandbasiscomplexity ] can be improved by replacing @xmath489 with @xmath651 and @xmath231 with @xmath573 ( respectively ) .",
    "table 1 lists group operation counts for algorithm [ algorithm : dlp ] computing discrete logarithms in @xmath652-groups of rectangular shape , corresponding to partitions of @xmath14 into @xmath19 parts , all of size @xmath653 .",
    "each entry is an average over 100 computations of @xmath20 for a random @xmath50 .",
    "precomputation was optimized for a single discrete logarithm ( repeated for each @xmath12 ) and these costs are included in table [ table : dltests ] .",
    "reusing precomputed values can improve performance significantly over the figures given here , particularly when additional space is used , as in @xcite .",
    "algorithm 1 used the parameter @xmath654 in these tests , which was near optimal in most cases .",
    "the optimal choice of @xmath159 is slightly less than that used in the proof of proposition [ proposition : dlcomplexity ] , as the average size of the exponents is smaller than the bound used there . for each entry in table",
    "[ table : dltests ] , if one computes the bound on @xmath282 given by proposition [ proposition : dlcomplexity ] , we find the constant @xmath248 close to 1 in most cases ( never more than 1.5 ) . in the first four columns of table [",
    "table : dltests ] , the counts are dominated by the exponent - dependent terms of @xmath282 , explaining the initially decreasing costs as @xmath19 increases for a fixed value of @xmath14 ( @xmath19 is larger , but @xmath653 is smaller ) .    .group operations to compute @xmath655 in @xmath656 . [ cols=\">,>,>,>,>,>,>\",options=\"header \" , ]",
    "the author would like to thank david harvey for his extensive feedback on an early draft of this paper , and the referee , for improving the proof of lemma  6 .",
    "the inequality below is elementary and surely known . lacking a suitable reference",
    ", we provide a short proof here .",
    "we assume @xmath662 .",
    "if we fix @xmath663 , we can only decrease @xmath664 by supposing @xmath665 , since if @xmath666 , we have @xmath667 we now assume @xmath668 and @xmath669 with @xmath670 . since @xmath671 is a decreasing function of @xmath672 ,",
    "we maximize @xmath673 by assuming @xmath674 as well .",
    "thus it suffices to consider the case @xmath675 , and we now view @xmath676 as a function of a real variable @xmath14 , which is maximized by @xmath677 .",
    "therefore , we may bound @xmath678 by @xmath679 and the lemma follows .",
    "the bound on @xmath248 given in the lemma is not necessarily tight , since @xmath14 must be an integer .",
    "if we note that @xmath676 is increasing for @xmath680 and decreasing for @xmath681 , it follows that the best possible @xmath248 is @xmath682 applying ( [ equation : app1 ] ) with @xmath683 we obtain the following lemma ."
  ],
  "abstract_text": [
    "<S> we present a generic algorithm for computing discrete logarithms in a finite abelian @xmath0-group @xmath1 , improving the pohlig  hellman algorithm and its generalization to noncyclic groups by teske . </S>",
    "<S> we then give a direct method to compute a basis for @xmath1 without using a relation matrix . </S>",
    "<S> the problem of computing a basis for some or all of the sylow @xmath0-subgroups of an arbitrary finite abelian group @xmath2 is addressed , yielding a monte carlo algorithm to compute the structure of @xmath2 using @xmath3 group operations . </S>",
    "<S> these results also improve generic algorithms for extracting @xmath0th roots in @xmath2 . </S>"
  ]
}