{
  "article_text": [
    "a binary word of length @xmath6 is _ prefix normal _ if for all @xmath7 , no substring of length @xmath8 has more @xmath0s than the prefix of length @xmath8 .",
    "for example , @xmath9 is not prefix normal because the substring @xmath10 has more @xmath0s than the prefix @xmath11 .",
    "these words were introduced in  @xcite , where it was shown that each binary word @xmath1 has a canonical _ prefix normal form _",
    "@xmath12 of the same length : @xmath1 and @xmath12 are equivalent in a certain sense .",
    "the study of prefix normal words , and prefix normal forms , is motivated by the string problem known as _ binary jumbled pattern matching_. in that problem , we are given a text of length @xmath6 over a binary alphabet , and two numbers @xmath13 and @xmath14 , and ask whether the text has a substring with exactly @xmath13 @xmath0s and @xmath14 @xmath15s . while the online version can be solved with a simple sliding window algorithm in @xmath4 time , the offline version , where many queries are expected , has recently attracted much interest : here an index of size @xmath4 can be generated which then allows answering queries in constant time  @xcite .",
    "however , the best construction algorithms up to date have running time o@xmath16  @xcite .",
    "several recent papers have yielded better results under specific assumptions , such as word level parallelism or highly compressible strings  @xcite , or for constructing an approximate index  @xcite ; but the general case has not been improved .",
    "it was demonstrated in  @xcite that prefix normal forms of the text can be used to construct this index .",
    "see the appendix for a brief explanation of this connection .    _ jumbled pattern matching _ ( jpm ) , over an arbitrary alphabet , is a variant of approximate pattern matching : we are given a text and a pattern , and want to answer the question whether the text has a substring which is a permutation of the pattern ( existence ) , or find one or all occurrences of such substrings ( occurrence , listing ) . over a finite ordered alphabet @xmath17",
    "is the vector @xmath18 s.t .  for all @xmath19",
    ", @xmath20 is the number of occurrences of @xmath21 in @xmath22 .",
    "given the text @xmath22 and pattern @xmath23 , we want to find ( occurrences of ) substrings @xmath24 of @xmath22 s.t .",
    "] this problem has also been studied under the terms _ abelian pattern matching , parikh vector matching , and permutation matching_. a closely related problem is that of parikh fingerprints  @xcite .",
    "applications in computational biology include snp discovery , alignment , gene clusters , pattern discovery , and mass spectrometry data interpretation  @xcite .    for one query , the jpm problem can be solved in optimal linear time with a classical sliding window approach  @xcite , while recently , interest has turned towards the indexing problem  @xcite .",
    "moreover , several variants of the original problem have recently been introduced : approximate jpm @xcite , jpm in the streaming model @xcite , jpm on trees and graphs @xcite .",
    "_ bubble languages _ are an interesting new class of binary languages defined by the following property : @xmath26 is a bubble language if , for every word @xmath27 , replacing the first occurrence of @xmath2 ( if any ) by @xmath3 results in another word in @xmath26  @xcite .",
    "a generic generating algorithm for bubble languages was given in  @xcite , leading to gray codes for each of these languages , while the algorithm s efficiency depends only on a language - dependent subroutine .",
    "in the best case , this leads to cat ( constant amortized time ) generating algorithms .",
    "many important languages are bubble languages , among them necklaces , binary lyndon words , and @xmath8-ary dyck words .    in this paper , we show that prefix normal words form a bubble language and present an efficient generating algorithm which runs in @xmath4 amortized time per word , and which yields a gray code for prefix normal words .",
    "the best previous generating algorithm for prefix normal words ran in @xmath28 time , and consisted simply in testing each binary word for the prefix normal property ( unpublished ) .",
    "based on experimental evidence , we conjecture that the running time of our algorithm is in fact @xmath29 amortized .",
    "we also give a new characterization of bubble languages in terms of a closure property in the computation tree of a certain generating algorithm for binary words .",
    "we prove new properties of prefix normal words and present a linear time testing algorithm for words which have been obtained from prefix normal words via a simple operation .",
    "this could lead to a better understanding of prefix normal words and in the long run , to faster computation of prefix normal forms , and thus contribute to the goal of strongly subquadratic algorithms for binary jumbled pattern matching .",
    "a _ binary word _ ( or _ string _ ) @xmath30 over @xmath31 is a finite sequence of elements from @xmath32 .",
    "its length @xmath6 is denoted by @xmath33 . for any @xmath34",
    ", the @xmath35-th symbol of a word @xmath1 is denoted by @xmath36 .",
    "we denote by @xmath37 the words over @xmath32 of length @xmath6 , and by @xmath38 the set of finite words over @xmath32 .",
    "the empty word is denoted by @xmath39 .",
    "let @xmath40 .",
    "if @xmath41 for some @xmath42 , we say that @xmath43 is a _ prefix _ of @xmath1 and @xmath44 is a _ suffix _ of @xmath1 .",
    "a _ substring _ of @xmath1 is a prefix of a suffix of @xmath1 .",
    "binary language _ is any subset @xmath45 of @xmath46 .    in the following",
    ", we will often write binary words @xmath47 in a canonical form @xmath48 , where @xmath49 and @xmath50 .",
    "in other words , @xmath22 is the length of the first , possibly empty , @xmath0-run of @xmath1 , @xmath23 the length of the first @xmath15-run , and @xmath51 the remaining , possibly empty , suffix .",
    "note that this representation is unique .",
    "we call @xmath52 the _ critical prefix _ of @xmath1 and @xmath53 the _ critical prefix length _ of @xmath1 .",
    "we denote by @xmath54 the number of occurrences in @xmath1 of character @xmath55 , and by @xmath56 the set of all binary strings @xmath1 of length @xmath6 such that @xmath57 ( the _ density _ of @xmath1 is @xmath58 ) .    given a string @xmath1",
    ", we can obtain another string @xmath59 , the string obtained from @xmath1 by exchanging the characters in positions @xmath35 and @xmath60 .",
    "let @xmath61 . for @xmath62 , we set    * @xmath63 , the number of @xmath0s in the @xmath35-length prefix of @xmath64 * @xmath65 , the maximum number of @xmath0s over all substrings of length @xmath35 .    a binary word @xmath1 is _ prefix normal _ if , for all @xmath66 , @xmath67 . in other words ,",
    "a word is prefix normal if no substring contains more @xmath0s than the prefix of the same length .",
    "for example , @xmath9 is not prefix normal because the substring @xmath10 has more @xmath0s than the prefix @xmath11 .",
    "we denote by @xmath68 the language of prefix normal words . in",
    "@xcite it was shown that for every word @xmath1 there exists a unique word @xmath12 , called its _",
    "prefix normal form _ , or @xmath69 , such that for all @xmath66 , @xmath70 , and @xmath12 is prefix normal .",
    "therefore , a prefix normal word is a word coinciding with its prefix normal form .    _",
    "note : _ in  @xcite , the property ` prefix normal ' was defined both with respect to @xmath0 and with respect to @xmath15 . here",
    "we restrict ourselves to prefix normal words w.r.t .",
    "@xmath0 .",
    "* 2l @||@ * 2l @xmath71 & words with this pnf & @xmath71 & words with this pnf + & & &    ' '' ''     + @xmath72 & \\{@xmath72 } & @xmath73 & \\{@xmath74 } + @xmath75 & \\{@xmath75 , @xmath76 } & @xmath77 & @xmath78 + @xmath79 & \\{@xmath79 , @xmath80 } & @xmath81 & @xmath82 + @xmath83 & \\{@xmath83 , @xmath84 , @xmath85 } & @xmath86 & @xmath87 + @xmath88 & \\{@xmath88 } & @xmath89 & @xmath90 + @xmath91 & \\{@xmath92 } & @xmath93 & @xmath94 + @xmath95 & \\{@xmath96 } & @xmath97 & @xmath98 + & & & +    in table  [ table : classes5 ] we list all prefix normal words of length @xmath99 , and , for each @xmath100 , the set of binary words @xmath1 such that @xmath101 ( i.e. , its equivalence class ) .",
    "several methods were presented in  @xcite for testing whether a word is prefix normal ; however , all ran in quadratic time .",
    "one open problem given there was that of enumerating prefix normal words ( counting ) .",
    "the number of prefix normal words of length @xmath6 can be computed by checking for each binary word whether it is prefix normal , i.e.  altogether in @xmath102 time . in this paper",
    ", we present an algorithm that is far superior in that it generates only prefix normal words , rather than testing every binary word ; it runs in @xmath4 time per word ; and it generates prefix normal words in cool - lex order , constituting a gray code ( subsequent words differ by a constant number of swaps or flips ) .      here",
    "we give a brief introduction to bubble languages , mostly summarising results from  @xcite .",
    "we also give a new characterization of bubble languages in terms of the computation tree of a generating algorithm ( obs .  [ obs : tree ] ) .",
    "a language @xmath103 is called _ a bubble language _ if , for every word @xmath104 , exchanging the first occurrence of @xmath2 ( if any ) by @xmath3 results in another word in @xmath26 .",
    "for example , the languages of lyndon words , necklaces and pre - necklaces are bubble languages .",
    "a language @xmath105 is a bubble language if and only if each of its fixed - density subsets @xmath106 is a bubble language  @xcite .",
    "this implies that for generating a bubble language , it suffices to generate its fixed - density subsets .",
    "next we consider combinatorial generation of binary strings .",
    "let @xmath1 be a binary string of length @xmath6 .",
    "let @xmath58 be the number of @xmath0s in @xmath1 , and let @xmath107 denote the positions of the @xmath0s in @xmath1 .",
    "clearly , we can obtain @xmath1 from the word @xmath108 with the following algorithm : first swap the last @xmath0 with the @xmath15 in position @xmath109 , then swap the @xmath110st @xmath0 with the @xmath15 in position @xmath111 etc .",
    "note that every @xmath0 is moved at most once , and in particular , once the @xmath8th @xmath0 is moved into the position @xmath112 , the suffix @xmath113 remains fixed for the rest of the algorithm .",
    "these observations lead us to the following generating algorithm ( fig .",
    "[ algo : bubble ] ) , which we will refer to as recursive swap generation algorithm ( like alg .  1 from  @xcite , which in addition includes a language - specific subroutine ) .",
    "it generates recursively all binary strings from @xmath56 with fixed suffix @xmath51 , where @xmath49 , starting from the string @xmath114 .",
    "the call generate(@xmath115 ) generates all binary strings of length @xmath6 with density @xmath58 .",
    "generate(@xmath116 ) @xmath117 and @xmath118 + @xmath119 + @xmath120 + _ generate_(@xmath121 ) + @xmath120 + _ visit _ ( )    the algorithm swaps the last @xmath0 of the first @xmath0-run with each of the @xmath15s of the first @xmath15-run , thus generating a new string each , for which it makes a recursive call . during the execution of the algorithm , the current string resides in a global array @xmath1 . in the subroutine visit ( ) we can , but do not have to , print the contents of this array ; we may just want to increment a counter ( for enumeration ) , or check some property of the current string . the main point of visit ( ) is that it touches every object once .",
    "let @xmath122 denote the recursive computation tree generated by a call to _",
    "generate_(@xmath115 ) . as an example ,",
    "[ fig : example1 ] illustrates the computation tree @xmath123 .",
    "the computation tree @xmath124 for @xmath125.,scaledwidth=100.0% ]    the depth of the tree equals @xmath58 , the number of @xmath0s ; while the maximum degree is @xmath126 , the number of @xmath15s . in general , for the subtree rooted at @xmath127 , we have depth @xmath22 and maximum degree @xmath23 ; in particular , the number of children of @xmath44 is exactly @xmath23 .",
    "in fact , @xmath44 s @xmath35th child has the form @xmath128 .",
    "moreover , the suffix @xmath51 remains unchanged in the entire subtree , and the computation tree is isomorphic to the computation tree of @xmath52 .",
    "this @xmath51 is called _ fixed suffix _  @xcite .",
    "note also that the critical prefix length @xmath129 strictly decreases along any downward path in the tree .",
    "the algorithm performs a post - order traversal of the tree , yielding an enumeration of the strings of @xmath130 in what is referred to as _ cool - lex order _",
    "a pre - order traversal of the same tree , which implies moving line 4 of the algorithm before line 1 , would yield an enumeration in _ co - lex order_. a crucial property of cool - lex order is that any two subsequent strings differ by at most two swaps ( transpositions ) , thus yielding a _ gray code _  @xcite .",
    "this can be seen in the computation tree @xmath124 as follows .",
    "note that in a post - order traversal of @xmath124 , we have : + @xmath131    let @xmath132 both be children of @xmath44 .",
    "this means that for some @xmath133 and @xmath49 , we have @xmath134 , @xmath135 , and @xmath136 .",
    "let @xmath137 be a descendant of @xmath44 along the leftmost path , i.e.  @xmath138 for some @xmath8 .",
    "then @xmath139    we now state a crucial property of bubble languages with respect to the recursive swap generating algorithm which follows immediately from the definition of bubble languages :    [ obs : tree ] a language @xmath26 is a bubble language if and only if , for every @xmath140 , its fixed - density subset @xmath141 is closed w.r.t .  parents and left siblings in the computation tree @xmath124 of the recursive swap generating algorithm . in particular ,",
    "if @xmath142 , then it forms a subtree rooted in @xmath108 .    using this property ,",
    "the recursive swap generating algorithm can be used to generate _ any _ fixed - density bubble language @xmath26 , as long as we have a way of deciding , for a node @xmath48 , already known to be in @xmath26 , which is its rightmost child ( if any ) that is still in @xmath26 .",
    "if such a child exists , and it is the @xmath8th child @xmath143 , then the bubble property ensures that all children to its left are also in @xmath26 .",
    "thus , line @xmath144 in the algorithm can simply be replaced by `` for @xmath145 '' . moreover",
    ", the recursive swap generating algorithm , which visits the words in the language in cool - lex order , will yield a gray code , since because of this closure property , @xmath146 will again either be the parent , or a node on the leftmost path of the right sibling , both of which are reachable within two swaps , see  .    in  @xcite , a generic generating algorithm was given which moves the job of finding this rightmost child @xmath8 into a subroutine oracle(@xmath116 ) . if oracle(@xmath116 ) runs in time @xmath147",
    ", then we have a cat algorithm . in general , this will not be possible , and a generic oracle tests for each child from left to right ( or from right to left ) whether it is in the language . because of the bubble property , after the first negative ( positive ) test , it is guaranteed that no more children will be in the language , and the running time of the algorithm is amortized that of the membership tester .",
    "the crucial trick is that it is not necessary to have a _",
    "membership tester , since all we want to know is which of the children of a node _ already known to be in @xmath26 _ are in @xmath26 ; moreover , the membership tester is allowed to use other information , which it can build up iteratively while examining earlier nodes .",
    "[ sec : combgenpnw ] in this section we prove that the set of prefix normal words @xmath68 is a bubble language . then , by providing some properties regarding membership testing , we can apply the cool - lex framework to generate all prefix normal words of a given length @xmath6 and density @xmath58 in @xmath4-amortized time . by concatenating the lists together for all densities in increasing order",
    ", we obtain an @xmath4-amortized time algorithm to list all prefix normal words of length @xmath6 .",
    "[ lemma : pnbubble ] the language @xmath68 is a bubble language .    let @xmath1 be a prefix normal word containing an occurrence of @xmath2 .",
    "let @xmath12 be the word obtained from @xmath1 by replacing the first occurrence of @xmath2 with @xmath3 .",
    "then @xmath148 , @xmath149 for some @xmath150 .",
    "let @xmath151 be a substring of @xmath12 .",
    "we have to show that @xmath152 .",
    "note that for any @xmath8 , @xmath153 .",
    "in fact , @xmath154 , and for every @xmath155 , @xmath156 . now if @xmath151 is contained in @xmath43 or in @xmath44",
    ", then @xmath151 is a substring of @xmath1 , and thus @xmath157 . if @xmath158 , with @xmath159 suffix of @xmath43 and @xmath137 prefix of @xmath44 , then @xmath160 . if @xmath161 , with @xmath137 prefix of @xmath44 , then @xmath162 , and @xmath163 is a substring of @xmath1 , thus @xmath164 .",
    "else @xmath165 , with @xmath159 suffix of @xmath43 .",
    "we can assume that @xmath159 is a proper suffix of @xmath43 .",
    "let @xmath166 be the substring of @xmath12 of the same length as @xmath151 and starting one position before @xmath151 ( in other words , @xmath166 is obtained by shifting @xmath151 to the left by one position ) . since @xmath43 does not contain @xmath2 as a substring , we have @xmath167 for some @xmath168 . if @xmath166 is a power of @xmath15 s , then @xmath169 and the claim holds .",
    "else , @xmath170 , and @xmath166 is a substring of @xmath1 .",
    "thus @xmath171 .    in fig .",
    "[ fig : example2 ] , we give the computation tree @xmath172 and highlight the subtree corresponding to @xmath68 . since @xmath68 is a bubble language , by obs .",
    "[ obs : tree ] it is closed w.r.t .  left siblings and parents",
    ". however , we still have to find a way of deciding which is the rightmost child of a node that is still in @xmath68 .",
    "the computation tree @xmath172 for @xmath125 .",
    "prefix normal words in bold.,scaledwidth=100.0% ]    the following lemma states that , given a prefix normal word @xmath1 , in order to decide whether one of its children in the computation tree is prefix normal , it suffices to check the pn - property for one particular length only : the critical prefix length of the child node .",
    "moreover , this check can be done w.r.t .",
    ". this fact will be crucial in the generating algorithm .",
    "[ lemma : ispnf ] let @xmath173 , with @xmath48 , with @xmath174 .",
    "let @xmath175 , i.e.  @xmath51 padded with @xmath15s to length @xmath6 .",
    "let @xmath176 .",
    "then @xmath177 , unless one of the following holds :    1 .",
    "@xmath178 has a substring of length @xmath179 with at least @xmath22 @xmath0s , or 2 .",
    "the string @xmath180 has at least @xmath22 @xmath0s .",
    "moreover , the latter is the case if and only if @xmath181 ( where by convention , we regard a prefix of negative length as the empty word ) .",
    "let s assume that @xmath182 .",
    "then there is a substring @xmath43 of @xmath12 s.t .",
    "let @xmath184 be the length of @xmath43 .",
    "_ @xmath43 is a substring of @xmath1 . since @xmath173 , therefore @xmath185 .",
    "since also @xmath186 , this implies @xmath187 , because for all other arguments , @xmath188 and @xmath189 coincide . note that @xmath43 must have an occurrence in @xmath12 which contains neither of the swapped bits ,",
    "else it would not be a substring of @xmath1 .",
    "thus @xmath43 starts at some position to the right of @xmath190 .",
    "therefore we can write @xmath191 , with @xmath44 a substring of @xmath51 ; in particular , if @xmath43 is a substring of @xmath51 , then @xmath192 and @xmath193 ; otherwise , @xmath44 is a prefix of @xmath51 .",
    "now set @xmath194 , with @xmath137 the substring of @xmath178 of length @xmath195 following @xmath44",
    ". then @xmath159 has length @xmath179 , and since @xmath196 , it contains at least @xmath22 many @xmath0s .",
    "_ @xmath43 is not a substring of @xmath1 .",
    "therefore it contains at least one of the two swapped bits .",
    "it can not contain the swapped @xmath15 ( in position @xmath22 ) because then it would be preceded only by @xmath0s , in which case the prefix of @xmath12 of length @xmath184 could not have fewer @xmath0s than @xmath43 .",
    "thus , @xmath43 contains the swapped @xmath0 only ( in position @xmath190 ) .",
    "if @xmath197 , then the prefix of @xmath12 of length @xmath184 overlaps with @xmath43 , i.e.  we can write @xmath198 and @xmath199 for some non - empty @xmath137 containing the swapped @xmath0 . since @xmath186",
    ", this implies that also @xmath159 has more @xmath0s than the prefix of the same length .",
    "since @xmath159 is a substring of @xmath1 , we are back in case 1 .",
    "so we have @xmath200 .",
    "we can write @xmath201 , with @xmath44 prefix of @xmath51 .",
    "now remove the starting @xmath15s from @xmath43 and extend it to the right to get @xmath202 , with @xmath137 be the prefix of @xmath178 of length @xmath203 . then @xmath204 and @xmath205 .",
    "moreover , @xmath206 .",
    "[ coro : ispnf ] given @xmath207 .",
    "if we know @xmath208 and @xmath209 , then it can be decided in constant time whether @xmath176 is prefix normal .",
    "[ lemma : fpcalculate ] let @xmath210 , with @xmath49 .",
    "then for all @xmath211 ,    @xmath212    a substring of length @xmath35 either uses the new @xmath0 in the first position , or it does not .",
    "if it does , then it is a prefix of @xmath213 and its number of @xmath0s is given by @xmath214 .",
    "else it is a substring of @xmath215 , and its number of @xmath0s is given by @xmath216 for @xmath35 up to the length of @xmath51 , or by the number of @xmath0s in @xmath51 , @xmath217 , if @xmath35 spans all of @xmath51 .",
    "[ coro : f ] the @xmath218-function of @xmath51 for node @xmath48 can be computed in linear time based on the @xmath218-function of @xmath1 s parent node .    by applying these results , the algorithm _",
    "generatepn(@xmath115 ) _ can be used to generate @xmath219 in cool - lex gray code order .",
    "starting from the left child and proceeding right ( with respect to the computation tree @xmath220 ) , the algorithm will make a recursive call until a child is no longer prefix normal .",
    "the membership test is done in the subroutine _ ispn _ , which uses the conditions of lemma  [ lemma : ispnf ] .",
    "the algorithm maintains an array @xmath218 which contains the maximum number of @xmath0s in @xmath35-length substrings of @xmath51 ( the @xmath218-function of @xmath51 ) , and a variable @xmath151 . before testing the first child , in _",
    "update(@xmath221 ) _ , it computes the current @xmath51 s @xmath218-function based on the parent s ( corollary  [ coro : f ] ) .",
    "note that it is not necessary to compute all of the @xmath218-function , since all nodes in the subtree have critical prefix length smaller than @xmath129 , thus this update is done only up to length @xmath129 . after the recursive calls to the children , the array is restored to its previous state in _ restore(@xmath221)_. the variable @xmath151 contains the number of @xmath0s in the prefix of @xmath51 which is spanned by the substring of case 2 . of lemma  [ lemma : ispnf ]",
    ", for the first child .",
    "it is updated in constant time after each successful call to _ ispn _ , to include the number of @xmath0s in the two following positions in @xmath51 .",
    "generatepn(@xmath116 ) @xmath117 * and * @xmath118 + @xmath222 + @xmath223 + @xmath224 + @xmath225 * and",
    "* _ ispn_(@xmath226 ) + @xmath120 + _ generatepn_(@xmath121 ) + _ update_@xmath227 + @xmath228 + @xmath120 + _ restore_(@xmath221 ) + _ visit _",
    "( )    by concatenating the lists of prefix normal words with densities @xmath229 , we obtain an exhaustive listing of @xmath230 .",
    "generatepn(@xmath6 ) @xmath231 + initialize @xmath218 of length @xmath6 with all @xmath15s + _",
    "generatepn(@xmath115 ) _    as an example , a call to _",
    "generatepn(@xmath99 ) _ produces the following list of prefix normal words of length 5 : @xmath232 these strings are also given in sec .",
    "[ sec : pnw ] .",
    "since the fixed - density listings are a cyclic gray code ( theorem 3.1 from @xcite ) , it follows that this complete listing is also a gray code .",
    "in fact , if the fixed - density listings are listed by the odd densities ( increasing ) , followed by the even densities ( decreasing ) , the resulting listing would be a cyclic gray code .",
    "generatepn(@xmath6 ) _ generates all prefix normal words of length @xmath6 in amortized @xmath4 time per word .    since @xmath108 is prefix normal for every @xmath58",
    ", we only need to show that the correct subtrees of @xmath124 are generated by the algorithm . by lemma  [ lemma : ispnf ]",
    ", only those children will be generated that are prefix normal ; on the other hand , by the bubble property ( obs .  [ obs : tree ] ) , as soon as a child tests negative , no further children will be prefix normal .",
    "the running time of the recursive call on @xmath173 consists of ( a ) updating and restoring @xmath218 ( lines 2 and 9 ) : the number of steps equals the critical prefix length of @xmath1 , which is @xmath4 ; ( b ) computing @xmath151 ( line 3 ) : again @xmath233 , the critical prefix length of @xmath1 , many steps , so @xmath4 ; and ( c ) work within the while - loop ( lines 5 to 8) , which , for a word with @xmath8 prefix normal children , consists of @xmath8 positive and @xmath0 negative membership tests , of @xmath8 updates of @xmath151 , and the recursive calls on the positive children .",
    "the membership tests take constant time by corollary  [ coro : ispnf ] , so does the update of @xmath151 . since @xmath1 has @xmath8 prefix normal children , we charge the positive membership tests and the @xmath151-updates to the children , and the negative test to the current word .",
    "so for one word @xmath173 , we get @xmath234 work .",
    "in this section we present some theoretical and numerical results about the number of prefix normal words and their structure .",
    "these have become available thanks to the algorithm presented , which allowed us to generate @xmath68 up to length 50 on a home computer .",
    "let @xmath235 .",
    "the following lemma follows from the observation that @xmath236 is a prefix normal word of length @xmath6 for all words @xmath1 of length @xmath237 .",
    "the number of prefix normal words grows exponentially in @xmath6 .",
    "we have that @xmath238 .",
    "the first members of the sequence @xmath239 are listed in @xcite , and these values suggest that the lower bound above is not sharp .",
    "we turn our attention to the growth rate of @xmath239 as @xmath6 increases .",
    "note that @xmath240 .",
    "the lower bound follows form the fact that all prefix normal words can be extended by adding a @xmath15 to the end , and the upper bound is implied by the prefix - closed property of @xmath68 .",
    "[ figgrowth ] ( left ) shows the growth ratio for small values of @xmath6 .",
    "the figure shows two interesting phenomena : the values seem to approach 2 slowly , i.e. , the number of prefix normal words almost doubles as we increase the length by 1 .",
    "second , the values show on oscillation pattern between even and odd values .",
    "we have so far been unable to establish these observations theoretically .",
    "( left ) , and of @xmath241 for prefix normal words for @xmath242 ( right ) . ]     ( left ) , and of @xmath241 for prefix normal words for @xmath242 ( right ) . ]",
    "[ figstgrowth ]    the structure of prefix normal words is also relevant for the generation algorithm , since the amortized running time of the algorithm is bounded above by the average value of the critical prefix length @xmath129 taken over all prefix normal words .",
    "this differs from the expected critical prefix length of the prefix normal form of a uniformly random word . for the latter we have the following result .",
    "[ lemma : random_pnf_st ] given a random word @xmath1 , let @xmath243 .",
    "let @xmath244 denote the critical prefix length of @xmath12 .",
    "then for the the expected value of @xmath244 we have @xmath245 .",
    "write @xmath246 in the usual form , i.e.  with @xmath247 , and consider the random variables @xmath248 and @xmath249 .",
    "it is known that the expected maximum length of a run of 1s in a random word is @xmath250@xcite .",
    "clearly , @xmath251 equals the length of the longest run of @xmath0s of @xmath1 , thus @xmath252 . to determine @xmath253 ,",
    "consider a @xmath0-run of @xmath1 of maximum length @xmath254 .",
    "if @xmath1 has at least another occurrence of @xmath0 , then there is a substring of @xmath1 consisting of the maximal @xmath0-run and one more @xmath0 ; the number of @xmath15 s in this substring is an upper bound on @xmath24 . since these @xmath15s form a single @xmath15-run , their number is again @xmath255 in expectation . if on the other hand , all occurrences of @xmath0 in @xmath1 are in the maximal run , then @xmath256 so @xmath257 .",
    "the number of words with at most one @xmath0-run is @xmath258 .",
    "so we have : @xmath259    the expected value of the critical prefix length for prefix normal words is shown in fig .",
    "[ figstgrowth ] ( right ) for @xmath260 , on a loglinear scale .",
    "we conjecture that @xmath241 is polylogarithmic for prefix normal words .",
    "the linear alignment of the data points together with lemma [ lemma : random_pnf_st ] seems to support that .",
    "we presented a new generating algorithm for prefix normal words , which produces all prefix normal words of length @xmath6 in amortized linear time per word .",
    "notice that the number of words that are _ not _ prefix normal also grows exponentially and greatly dominates prefix normal words ( e.g. , @xmath261 ) , so the gain of any algorithm that runs in amortized time per word , over brute - force testing of all binary words , is considerable .",
    "we believe , moreover , that our algorithm actually runs in time @xmath262 per word .",
    "this could be proved by showing that the expected critical prefix length of a prefix normal word is polylogarithmic in @xmath6 .    in sec .",
    "[ sec : combgenpnw ] we gave a linear time testing algorithm for words which are derived from a word @xmath1 already known to be prefix normal , via a particular operation ( swapping the last @xmath0 of the first 1-run with a @xmath15 in the first 0-run ) .",
    "this testing algorithm relies both on the knowledge that @xmath1 is prefix normal , and on the presence of a data structure for @xmath1 ( the @xmath218-function ) .",
    "we pose as an open problem to find a strongly subquadratic time testing algorithm _ for arbitrary words_. another open problem is the computation of prefix normal forms . solving this problem would lead immediately to an improvement for indexed binary jumbled pattern matching .",
    "the observation that our language is a bubble language has opened up completely new roads .",
    "an efficient implementation of the generating algorithm led to new experimental results which were not available with our previous approach .",
    "the obtained data led to new conjectures and results .",
    "we are confident that the connection to bubble languages will also help in establishing theoretical results about the number and structure of prefix normal words , and could hopefully lead to a strongly subquadratic testing algorithm .    10    a.  amir , a.  apostolico , g.  m. landau , and g.  satta .",
    "efficient text fingerprinting via parikh mapping .",
    ", 1(5 - 6):409421 , 2003 .",
    "g.  badkobeh , g.  fici , s.  kroon , and zs .",
    "binary jumbled string matching for highly run - length compressible texts .",
    ", 113(17):604608 , 2013 .",
    "g.  benson . composition alignment . in _ proc . of the 3rd international workshop on algorithms in bioinformatics ( wabi03 ) _ , pages 447461 , 2003 .",
    "s.  bcker .",
    "simulating multiplexed snp discovery rates using base - specific cleavage and mass spectrometry .",
    ", 23(2):512 , 2007 .",
    "s.  bcker , k.  jahn , j.  mixtacki , and j.  stoye .",
    "computation of median gene clusters . in _ proc .  of the twelfth annual international conference on computational molecular biology ( recomb 2008 ) _ ,",
    "pages 331345 , 2008 .",
    "lnbi 4955 .",
    "p.  burcsi , f.  cicalese , g.  fici , and zs .",
    "liptk . on table arrangements , scrabble freaks , and jumbled pattern matching .",
    "in _ proc .  of the 5th international conference on fun with algorithms ( fun 2010 ) _ ,",
    "volume 6099 of _ lncs _ , pages 89101 , 2010 .",
    "p.  burcsi , f.  cicalese , g.  fici , and zs .",
    "liptk . on approximate jumbled pattern matching in strings .",
    ", 50(1):3551 , 2012 .",
    "a.  butman , r.  eres , and g.  m. landau . scaled and permuted string matching . , 92(6):293297 , 2004 .",
    "f.  cicalese , g.  fici , and zs .",
    ". searching for jumbled patterns in strings . in _ proc .",
    "of the prague stringology conference 2009 ( psc 2009 ) _ , pages 105117 .",
    "czech technical university in prague , 2009 .",
    "f.  cicalese , t.  gagie , e.  giaquinta , e.  s. laber , zs .",
    "liptk , r.  rizzi , and a.  i. tomescu .",
    "indexes for jumbled pattern matching in strings , trees and graphs . in _ proc .  of the 20th string processing and information retrieval symposium ( spire 2013 )",
    "_ , volume 8214 of _ lncs _ , pages 5663 , 2013 .",
    "f.  cicalese , e.  s. laber , o.  weimann , and r.  yuster .",
    "near linear time construction of an approximate index for all maximum consecutive sub - sums of a sequence . in _ proc .",
    "23rd annual symposium on combinatorial pattern matching ( cpm 2012 ) _ , volume 7354 of _ lncs _ , pages 149158 , 2012 .",
    "k.  dhrkop , m.  ludwig , m.  meusel , and s.  bcker .",
    "faster mass decomposition . in _",
    "wabi _ , pages 4558 , 2013 .",
    "g.  fici and zs .",
    "liptk . on prefix",
    "normal words . in _ proc .  of the 15th intern .",
    "conf .  on developments in language theory ( dlt 2011 ) _ , volume 6795 of _ lncs _ , pages 228238 .",
    "springer , 2011 .",
    "t.  gagie , d.  hermelin , g.  m. landau , and o.  weimann .",
    "binary jumbled pattern matching on trees and tree - like structures . in _ proc .  of the 21st annual european symposium on algorithm ( esa 2013 ) _ ,",
    "pages 517528 , 2013 .",
    "e.  giaquinta and sz .",
    "new algorithms for binary jumbled pattern matching . , 113(14 - 16):538542 , 2013 .",
    "l.  j. guibas and a.  odlyzko .",
    "long repetitive patterns in random sequences .",
    ", 53:241262 , 1980 .",
    "t.  kociumaka , j.  radoszewski , and w.  rytter .",
    "efficient indexes for jumbled pattern matching with constant - sized alphabet . in _ proc .  of the 21st annual european symposium on algorithm ( esa 2013 ) _ , pages 625636 , 2013 .",
    "lee , m.  lewenstein , and q.  zhang .",
    "parikh matching in the streaming model . in _ proc .",
    "of 19th international symposium on string processing and information retrieval , spire 2012 _ , volume 7608 of _ lecture notes in computer science _ , pages 336341 .",
    "springer , 2012 .",
    "t.  m. moosa and m.  s. rahman .",
    "indexing permutations for binary strings . , 110:795798 , 2010 .",
    "t.  m. moosa and m.  s. rahman .",
    "sub - quadratic time and linear space data structures for permutation matching in binary strings .",
    ", 10:59 , 2012 .",
    "l.  parida .",
    "gapped permutation patterns for comparative genomics . in _ proc .  of the 6th international workshop on algorithms in bioinformatics , ( wabi 2006 ) _ , pages 376387 , 2006 .",
    "f.  ruskey , j.  sawada , and a.  williams . binary bubble languages and cool - lex order . , 119(1):155169 , 2012 .",
    "f.  ruskey , j.  sawada , and a.  williams .",
    "de bruijn sequences for fixed - weight binary strings . , 26(2):605517 , 2012 .",
    "j.  sawada and a.  williams .",
    "efficient oracles for generating binary bubble languages .",
    ", 19(1):p42 , 2012 .",
    "n.  j.  a. sloane .",
    "the on - line encyclopedia of integer sequences .",
    "available electronically at http://oeis.org .",
    ".    a.  m. williams . .",
    "phd thesis , university of victoria , canada , 2009 .",
    "p    the linear space solutions for binary pattern matching all rely on a simple property of binary strings , which we refer to as interval lemma ( folklore ) : for a binary string @xmath1 and any fixed length @xmath263 , if @xmath1 has two substrings of length @xmath8 , with one containing @xmath13 @xmath0s , and the other @xmath14 @xmath0s , where @xmath264 , then , for any @xmath265 , @xmath1 also contains a substring of length @xmath8 with exactly @xmath151 @xmath0s . in other words , all parikh vectors of substrings of the same length",
    "build an interval .",
    "the lemma implies that in order to be able to answer existence jumbled pattern matching queries , it suffices to store , for every length @xmath8 , the maximum and minimum number of @xmath0s in any substring of length @xmath8 : when querying whether @xmath1 has a substring with parikh vector @xmath266 , we can simply ask whether @xmath13 lies between the maximum and minimum number of @xmath0s for length @xmath267 . this list of minima and maxima for every length is the linear size index used . the big open question is how to compute it faster than the current @xmath268 time .",
    "now , prefix normal forms of a word @xmath1 can be used to compute this index .",
    "we know that two words have the same parikh set ( parikh vectors of substrings ) if and only if they have the same prefix normal forms both w.r.t .",
    "@xmath0 and to @xmath15 ( see  @xcite , thm .  2 ) .    in fig .",
    "[ fig : esempio ] , we present the word @xmath269 and its prefix normal forms in a standard representation for binary words : draw in the euclidean plane the word @xmath1 by representing each letter @xmath0 by an upper unit diagonal and each letter @xmath15 by a lower unit diagonal , starting from the origin @xmath270 .",
    "the region between @xmath271 and @xmath272 forms exactly the parikh set of @xmath1 .",
    "for example , all substrings of length @xmath273 have one of the parikh vectors @xmath274 .",
    "( dashed line ) and its prefix normal forms ( grey lines ) .",
    "the area between the two pnfs is the parikh set of @xmath1 .",
    "the vertical line shows all parikh vectors of substrings of length @xmath273 , namely @xmath274.,height=132 ]"
  ],
  "abstract_text": [
    "<S> a prefix normal word is a binary word with the property that no substring has more @xmath0s than the prefix of the same length . </S>",
    "<S> this class of words is important in the context of binary jumbled string matching . in this paper </S>",
    "<S> we present an efficient algorithm for exhaustively listing the prefix normal words with a fixed length . </S>",
    "<S> the algorithm is based on the fact that the language of prefix normal words is a bubble language , a class of binary languages with the property that , for any word @xmath1 in the language , exchanging the first occurrence of @xmath2 by @xmath3 in @xmath1 results in another word in the language . </S>",
    "<S> we prove that each prefix normal word is produced in @xmath4 amortized time , and conjecture , based on experimental evidence , that the true amortized running time is @xmath5 . </S>"
  ]
}