{
  "article_text": [
    "in the grammar - based compression text is represented by a  context - free grammar ( cfg ) generating exactly one string .",
    "such an approach was first considered by rubin  @xcite , though he did not mention cfgs explicitly . in general",
    ", the idea behind this approach is that a cfg can compactly represent the structure of the text , even if this structure is not apparent .",
    "furthermore , the natural hierarchical definition of the context - free grammars makes such a  representation suitable for algorithms , in which case the string operations can be performed on the compressed representation , without the need of the explicit decompression  @xcite .",
    "while grammar - based compression was introduced with practical purposes in mind and the paradigm was used in several implementations  @xcite , it also turned out to be very useful in more theoretical considerations .",
    "intuitively , in many cases large data have relatively simple inductive definition , which results in a grammar representation of small size .",
    "on the other hand , it was already mentioned that the hierarchical structure of the cfgs allows operations directly on the compressed representation .",
    "a recent survey by lohrey@xcite gives a comprehensive description of several areas of theoretical computer science in which grammar - based compression was successfully applied .",
    "the main drawback of the grammar - based compression is that producing the smallest cfg for a text is _ intractable _ : given a string @xmath12 and number @xmath13 it is np - hard to decide whether there exist a cfg of size @xmath13 that generates @xmath12  @xcite .",
    "furthermore , the size of the smallest grammar for the input string can not be approximated within some small constant factor  @xcite .",
    "the first two algorithms with an approximation ratio @xmath14 were developed simultaneously by rytter  @xcite and charikar et  al .",
    "they followed a similar approach , we first present rytter s approach as it is a bit easier to explain .",
    "rytter s algorithm  @xcite applies the lz77 compression to the input string and then transforms the obtained lz77 representation to an @xmath9 size grammar , where @xmath6 is the size of the lz77 representation .",
    "it is easy to show that @xmath10 and as @xmath15 is increasing , the bound @xmath16 on the size of the grammar follows ( and so a bound @xmath14 on approximation ratio ) .",
    "the crucial part of the construction is the requirement that the derivation tree of the intermediate constructed grammar satisfies the avl condition . while enforcing this requirement",
    "is in fact easier than in the case of the avl search trees ( as the internal nodes do not store any data ) , it remains involved and non - trivial .",
    "note that the final grammar for the input text is also avl - balanced , which makes is suitable for later processing .",
    "charikar et  al .",
    "@xcite followed more or less the same path , with a different condition imposed on the grammar : it is required that its derivation tree is length - balanced , i.e.  for a rule @xmath17 the lengths of words generated by @xmath18 and @xmath19 are within a certain multiplicative constant factor from each other . for such trees",
    "efficient implementation of merging , splitting etc .",
    "operations were given ( i.e.  constructed from scratch ) by the authors and so the same running time as in the case of the avl grammars was obtained .",
    "since all the operations are defined from scratch , the obtained algorithm is also quite involved and the analysis is even more non - trivial .",
    "sakamoto  @xcite proposed a different algorithm , based on  @xcite , which is one of the practically implemented and used algorithms for grammar - based compression .",
    "his algorithm iteratively replaces pairs of different letters and maximal repetitions of letters ( @xmath20 is a _",
    "maximal repetition _ if that can not be extended by @xmath21 to either side ) .",
    "a special pairing of the letters was devised , so that it is ` synchronising ' : if @xmath22 has @xmath23 disjoint occurrences in @xmath12 , then those two occurrences can be represented as @xmath24 , where @xmath25 , such that both occurrences of @xmath26 in @xmath12 are paired and compressed in the same way .",
    "the analysis was based on considering the lz77 representation of the text and proving that due to ` synchronisation ' the factors of lz77 are compressed very similarly as the text to which they refer .",
    "constructing such a pairing is involved and the analysis non - trivial .",
    "recently , the author proposed another algorithm  @xcite . similarly to the sakamoto s algorithm it iteratively applied two local replacement rules ( replacing pairs of different letters and replacing maximal repetitions of letters ) .",
    "though the choice of pairs to be replaced was simpler , still the construction was involved .",
    "the main feature of the algorithm was its analysis based on the recompression technique , which allowed avoiding the connection of slps and lz77 compression .",
    "this made it possible to generalise this approach also to grammars generating trees  @xcite .",
    "on the downside , the analysis is quite complex .",
    "we present a very simple algorithm together with a straightforward and natural analysis .",
    "it chooses the pairs to be replaced in the word during a left - to - right sweep and additionally using the information given by a lz77 factorisation .",
    "we require that any pair that is chosen to be replaced is either inside a factor of length at least @xmath23 or consists of two factors of length @xmath27 and that the factor is paired in the same way as its definition . to this end",
    "we modify the lz77 factorisation during the sweep . after the choice",
    ", the pairs are replaced and the new word inherits the factorisation from the original word .",
    "this procedure is repeated until a trivial word is obtained . to see that this is indeed a grammar construction ,",
    "when the pair @xmath28 is replaced by @xmath5 we create a rule @xmath29 .",
    "the presented algorithm runs in linear time , assuming that we can compute the lz77 factorisation in linear time .",
    "this can be done assuming that the letters of the input words can be sorted in linear time , which follows from a standard assumption that @xmath3 can be identified with a continues subset of natural numbers of size @xmath30 for some constant @xmath5 and the can be performed on it .",
    "note that such an assumption is needed for all currently known linear - time algorithms that attain the @xmath14 approximation guarantee .",
    "by @xmath1 we denote the size of the input word .",
    "an lz77 factorisation ( called simply factorisation in the rest of the paper ) of a word @xmath12 is a representation @xmath31 , where each @xmath32 is either a single letter ( called _ free letter _ in the following ) or @xmath33 $ ] for some @xmath34 , in such a case @xmath35 is called a _ factor _ and @xmath36 $ ] is called the _ definition _ of this factor .",
    "we do not assume that a factor has more than one letter though when we find such a factor we demote it to a free letter .",
    "the _ size _ of the lz77 factorisation @xmath37 is @xmath6 .",
    "there are several simple and efficient linear - time algorithms for computing the smallest lz77 factorisation of a word  @xcite and all of them rely on linear - time algorithm for computing the suffix array  @xcite .      _",
    "straight line programme _",
    "( _ slp _ ) is a cfg in the chomsky normal form that generates a unique string . without loss of generality",
    "we assume that nonterminals of an slp are @xmath38 , each rule is either of the form @xmath39 or @xmath40 , where @xmath41 .",
    "the _ size _ of the slp is the number of its nonterminals ( here : @xmath2 ) .",
    "the problem of finding smallest slp generating the input word @xmath12 is np - hard  @xcite and the size of the smallest grammar for the input word can not be approximated within some small constant factor  @xcite . on the other hand ,",
    "several algorithms with approximation ratio @xmath42 , where @xmath2 is the size of the smallest grammar generating @xmath12 , are known  @xcite .",
    "most of those constructions use the inequality @xmath10 , where @xmath6 ( @xmath2 ) is the size of the smallest lz77 factorisation ( grammar , respectively ) for @xmath12  @xcite .",
    "relaxing the chomsky normal form , let us identify each nonterminal generating a  single letter with this letter .",
    "suppose that we already have an slp for @xmath12 .",
    "consider the derivation tree for @xmath12 and the nodes that have only leaves as children ( they correspond to nonterminals that have only letters on the right - hand side ) .",
    "such nodes define a _ pairing _ on @xmath12 , in which each letter is paired with one of the neighbouring letters ( such pairing is of course a symmetric relation ) .",
    "construction of the grammar can be naturally identified with iterative pairing : for a word @xmath43 we find a pairing , replace pairs of letters with ` fresh ' letters ( different occurrences of a pair @xmath28 can be replaced with the same letter though this is not essential ) , obtaining @xmath44 and continue the process until a word @xmath45 has only one letter .",
    "the fresh letters from all pairings are the nonterminals of the constructed slp and its size is twice the number of different introduced letters .",
    "our algorithm will find one such pairing using the lz77 factorisation of a word .",
    "suppose that we are given a word @xmath12 and know its factorisation .",
    "we try the naive pairing : the first letter is paired with second , third with fourth and so on , see fig .",
    "[ fig : pairing ] .",
    "if we now replace all pairs with new letters , we get a word that is @xmath23 times shorter so @xmath46 such iterations give an slp for @xmath12 .",
    "however , in the worst case there are @xmath47 different pairs already in the first pairing and so we can not give any better bound on the grammar size than @xmath48 .    a better estimation uses the lz77 factorisation .",
    "let @xmath31 and consider a factor @xmath32 .",
    "it is equal to @xmath49 $ ] and so all pairs occurring in @xmath32 already occur in @xmath49 $ ] unless the parity is different , i.e.  @xmath50 and @xmath51 are of different parity , see fig .  [",
    "fig : pairing ] .",
    "we want to fix this : it seems a bad idea to change the pairing in @xmath49 $ ] , so we change it in @xmath32 : it is enough to shift the pairing by one letter , i.e.  leave the first letter of @xmath32 unpaired and pair the rest as in @xmath52 $ ] .",
    "note that the last letter in the factor definition may be paired with the letter to the right , which may be impossible inside @xmath32 , see fig .",
    "[ fig : pairing ] . as a last observation note that since we alter each @xmath32 , instead of creating a pairing at the beginning and modifying it we can create the pairing while scanning the word from left to right .",
    "there is one issue : after the pairing we want to replace the pairs with fresh letters .",
    "this may make some of the the factor definitions improper : when @xmath32 is defined as @xmath36 $ ] it might be that @xmath53 $ ] is paired with letter to the left . to avoid this situation , we replace the factor @xmath32 with @xmath53f_i'$ ] and change its definition to @xmath54 $ ] .",
    "similar operation may be needed at the end of the factor , see fig .",
    "[ fig : pairing ] .",
    "this increases the size of the lz77 factorisation , but the number of factors stays the same ( i.e.  only the number of free letters increases ) .",
    "additionally , we pair two neighbouring free letters , whenever this is possible .",
    "when the appropriate pairing is created , we replace each pair with a new letter .",
    "if the pair is within a factor , we replace it with the same symbol as the corresponding pair in the definition of the factor . in this way only pairs that are formed from free letters may contribute a fresh letter . as a result",
    "we obtain a new word together with a factorisation in which there are @xmath6 factors .",
    "the analysis is based on the observation that a factor @xmath32 is shortened by a constant fraction , so it takes part in @xmath55 phases and in each of them it introduces @xmath56 free letters .",
    "hence the total number of free letters introduced to the word is @xmath57 ( which is shown in details later on ) . as creation of a rule decreases the number of free letters in the instance by at least @xmath27 , we obtain that this is also an upper bound on the size of the grammar .",
    "the word is represented as a table of letters .",
    "the table @xmath58 stores the information about the beginnings of factors : @xmath59 = j$ ] means that @xmath60 is the first letter of a factor and @xmath50 is the first letter of its definition ; otherwise @xmath59 = { { { \\textnormal{\\textsl{false}}}}}$ ] .",
    "similarly @xmath61 stores the information about the ends of factors : @xmath62 $ ] is a bit flag , i.e.  has value @xmath63 , that tells whether @xmath64 $ ] is the last letter of a factor .",
    "when we replace the pairs with new letters , we reuse the same tables , overwriting from left to the right .",
    "additionally , a table @xmath65 stores the corresponding positions : @xmath66 = j$ ] means that    * the letter on position @xmath60 was unpaired and @xmath50 is the position of the corresponding letter in the new word _ or _ * the letter on position @xmath60 was paired with a letter to the right and the corresponding letter in the new word is on position @xmath50 .",
    "lastly , @xmath66 $ ] is not defined when position @xmath60 was the second element in the pair .",
    "it is easy to see that the algorithm can be converted to lists and pointers instead of tables .",
    "( though the used in the lz77 construction needs tables ) .      our algorithm makes a technical assumptions : a factor @xmath32 ( of length at least @xmath23 ) starting at position @xmath50 can not have @xmath67 = j-1 $ ] , i.e.  its definition is at least two positions to the left .",
    "this is verified and repaired while sweeping through @xmath12 : if @xmath36 = w[j-1 { \\mathinner{\\ldotp\\ldotp}}j + |f_i|-2]$ ] then @xmath68 for some letter @xmath21 .",
    "in such a case we split @xmath32 : we make @xmath53 $ ] a free letter and set @xmath69 = j-1 $ ] ( note that the latter essentially requires that indeed @xmath32 is a repetition of one letter ) .",
    "we are going to devise a pairing with the following ( a bit technical ) properties :    1 .",
    "[ p1]there are no two consecutive letters that are both unpaired ; 2 .",
    "[ p2]the first two letters ( last two letters ) of any factor @xmath35 are paired with each other ; 3 .",
    "[ p3]if @xmath70 $ ] has a definition @xmath71{\\mathinner{\\ldotp\\ldotp}}{{{\\textnormal{\\textsl{start}}}}}[i]+|f|-1]$ ] then letters in @xmath35 and in @xmath71{\\mathinner{\\ldotp\\ldotp}}{{{\\textnormal{\\textsl{start}}}}}[i]+|f|-1]$ ] are paired in the same way .",
    "the pairing is found incrementally by a left - to - right scan through @xmath12 : we read @xmath12 and when we are at letter @xmath60 we make sure that the word @xmath72 $ ] satisfies ( )  ( ) . to this end we not only devise the pairing but also modify the factorisation a bit ( by replacing a factor @xmath35 with @xmath73 or by @xmath74 , where @xmath21 is the first and @xmath75 the last letter of @xmath35 ) .",
    "if during the sweep some @xmath35 is shortened so that @xmath76 then we demote it to a free letter .    the pairing is recorded in table : @xmath77 $ ] can be set to @xmath78 , @xmath79 or @xmath80 , meaning that @xmath64 $ ] is the first , second in the pair or it is unpaired , respectively .",
    "@xmath81 \\gets { { { \\textnormal{\\textsl{none}}}}}$ ] @xmath82 [ ensure non - trivial ] @xmath59 \\gets { { { \\textnormal{\\textsl{end}}}}}[i ] \\gets",
    "{ { { \\textnormal{\\textsl{false}}}}}$ ] [ blok ] @xmath83 \\gets i-1 $ ] @xmath59 \\gets { { { \\textnormal{\\textsl{false}}}}}$ ] [ blok pocz ] [ lewy koniec ] @xmath83 \\gets { { { \\textnormal{\\textsl{start}}}}}[i ] + 1 $ ] [ popping left ] @xmath59 \\gets { { { \\textnormal{\\textsl{false}}}}}$ ] [ kopiowanie parowania ] @xmath77 \\gets { { { \\textnormal{\\textsl{pair}}}}}[j]$ ] [ copy pairing ] @xmath84 , @xmath85 [ prawy koniec ] @xmath86 [ popping right ] @xmath87 = { { { \\textnormal{\\textsl{true}}}}}$ ] , @xmath62 = { { { \\textnormal{\\textsl{false}}}}}$ ] @xmath77 = { { { \\textnormal{\\textsl{none}}}}}$ ] [ end of factor ] [ pairing trivial factors ] @xmath88 \\gets { { { \\textnormal{\\textsl{first}}}}}$ ] , @xmath77 \\gets { { { \\textnormal{\\textsl{second}}}}}$ ] [ pairing trivial factors 2 ] @xmath77 \\gets { { { \\textnormal{\\textsl{none}}}}}$ ] @xmath84      we read @xmath12 from left to right , suppose that we are at position @xmath60 .",
    "if we read @xmath64 $ ] that is a free letter then we check , whether the previous letter is not paired .",
    "if so , then we pair them .",
    "otherwise we continue to the next position .",
    "if @xmath60 is a first letter of a factor , we first check whether the length of this factor is one ; if so , we change @xmath64 $ ] into a free letter .",
    "if the factor has definition only one position to the left ( i.e.  at @xmath89 ) then we split the factor : we make @xmath64 $ ] a free letter and set @xmath90 $ ] as a first letter of a factor with a  definition starting at @xmath89 .",
    "otherwise we check whether @xmath71]$ ] is indeed the first letter of a pair .",
    "if not ( i.e.  it is a second letter of a pair or an unpaired letter ) then we split the factor : we make @xmath64 $ ] a free letter and @xmath90 $ ] the beginning of a factor with a definition beginning at @xmath59 + 1 $ ] ( note that this factor may have length @xmath27 ) ; we view the factor beginning at @xmath90 $ ] as a modified factor that used to begin at @xmath64 $ ] . if for any reason we turned @xmath64 $ ] into a free letter",
    ", we re - read this letter , treating it accordingly .",
    "if @xmath71]$ ] is a first letter of a pair , we copy the pairing from the whole factor s definition to the factor starting at @xmath60 .",
    "when this is done we need to make sure that the factor indeed ends with a pair , i.e.  that ( ) holds : if the last letter of a factor , say @xmath92 $ ] , is not the second in the pair . to this end",
    "we split the factor : we make @xmath92 $ ] a free letter , clear @xmath93 s pairing , decrease @xmath93 by @xmath27 and set the flag for @xmath92 $ ] ( making it the end of the new factor ) .",
    "we iterate it until the @xmath92 $ ] is indeed a second letter of a factor .",
    "this is all formalised in algorithm  [ alg : pairing ] .",
    "@xmath94 @xmath95 \\gets j ' \\gets { { { \\textnormal{\\textsl{newpos}}}}}[{{{\\textnormal{\\textsl{start}}}}}[i]]$ ] @xmath59 \\gets { { { \\textnormal{\\textsl{false}}}}}$ ] @xmath66 \\gets i'$ ] @xmath92 \\gets w[j']$ ] @xmath96 , @xmath97 @xmath98 @xmath84 @xmath99 \\gets { { { \\textnormal{\\textsl{true}}}}}$ ] @xmath87 \\gets { { { \\textnormal{\\textsl{false}}}}}$ ] @xmath66 \\gets i'$ ] @xmath92 \\gets w[i]$ ] @xmath84 , @xmath96 @xmath92 \\gets $ ] fresh letter @xmath98 , @xmath96      when the pairing is done , we read the word @xmath12 again ( from left to right ) and replace the pairs by letters .",
    "we keep two indices : @xmath60 , which is the pointer in the current word ( pointing at the first unread letter ) and @xmath93 , which is a pointer in the new word , pointing at the first free position .",
    "additionally , when reading @xmath60 we store ( in @xmath66 $ ] ) the position of the corresponding letter in the new word , which is always @xmath93 .    if @xmath64 $ ] is a first letter in a pair and this pair consists of two free letters , in the new word we add a fresh letter and move two letters to the right in @xmath12 ( as well as one position in the new word ) .",
    "if @xmath64 $ ] is unpaired and a free letter then we simply copy this letter to the new word , increasing both @xmath60 and @xmath93 by @xmath27 . if @xmath64 $ ] is first letter of a factor ( and so also a first letter of a pair by ( ) ) , we copy the corresponding fragment of the new word ( the first position is given by @xmath100 $ ] ) , moving @xmath60 and @xmath93 in parallel : @xmath93 is always incremented by @xmath27 , while @xmath60 is moved by @xmath23 when it reads a first letter of a pair and by @xmath27 when it reads a free letter .",
    "also , we store the new beginning and end of the factor in the new word : for a factor beginning at @xmath60 and ending at @xmath93 we set @xmath101 = { { { \\textnormal{\\textsl{newpos}}}}}[{{{\\textnormal{\\textsl{start}}}}}[i]]$ ] and @xmath102 = { { { \\textnormal{\\textsl{true}}}}}$ ] ( note that @xmath103 and @xmath93 are paired ) .",
    "details are given in algorithm  [ alg : replace ] .",
    "compute lz77 factorisation of @xmath12 compute a pairing of @xmath12 using replace the pairs using output the constructed grammar       first computes the lz77 factorisation and then iteratively applies and , until a one - word letter is obtained .",
    "we begin the analysis with showing that indeed produces the desired pairing .",
    "[ lem : main ] runs in linear time .",
    "it creates a proper factorisation and returns a pairing that satisfies ( )  ( ) ( for this new factorisation ) .",
    "when the current factorisation for the input word for has @xmath104 factors then creates at most @xmath105 new free letters and the returned pairing has at most @xmath104 factors .",
    "we show the second claim of the lemma by induction : at all time the stored factorisation is proper , furthermore , when we processed @xmath106 $ ] ( i.e.  we are at position @xmath60 , note that we can go back in which case position gets unprocessed ) then we have a partial pairing on @xmath106 $ ] , which differs from the pairing only in the fact that the position @xmath89 may be assigned as first in the pair and @xmath60 is not yet paired .",
    "this partial pairing satisfies ( )  ( ) restricted to @xmath107 $ ] .",
    "if in line  [ ensure non - trivial ] we have @xmath59 = { { { \\textnormal{\\textsl{end}}}}}[i]$ ] then @xmath64 $ ] is a one - letter factor and so after replacing it with a free letter the factorisation stays proper .",
    "observe now that the verification in line  [ ensure non - trivial ] ensures that in each other case considered in lines [ blok][end of factor ] we deal with factors of length at least @xmath23 .",
    "the modifications of the factorisation in line  [ blok pocz ] results in a proper factorisation : the change is applied only when @xmath59 = i-1 $ ] , in which case @xmath108 = w[i - 1 { \\mathinner{\\ldotp\\ldotp}}i + |f| - 2]$ ] , which implies that @xmath109 , where @xmath110 $ ] .",
    "since @xmath111 ( by case assumption ) , in such a case @xmath112 = w[i-1{\\mathinner{\\ldotp\\ldotp}}i + |f| - 3]$ ] so we can split the factor @xmath113 $ ] to @xmath64 $ ] and a factor @xmath112 $ ] which is defined as @xmath114 $ ] ( @xmath35 had at least two letters , so after the modification it has at least @xmath27 letter ) .",
    "concerning the symmetric shortening in line  [ popping right ] , it leaves a proper factorisation ( as in case of line  [ popping left ] ) , as long as we do not move @xmath60 before the beginning of the factor",
    ". however , observe that when we reach line  [ copy pairing ] this means that the factor beginning at @xmath93 has length at least @xmath23 , @xmath95 < i'-1 $ ] and @xmath115 = { { { \\textnormal{\\textsl{first}}}}}$ ] .",
    "thus @xmath95 + 1 < i'$ ] and so by induction assumption we already made a pairing for it .",
    "since @xmath95 $ ] is assigned @xmath78 , @xmath95 + 1 $ ] is assigned @xmath79 .",
    "so @xmath116 is assigned @xmath79 as well .",
    "since the end of the factor is at position @xmath117 , in our search for element marked with _",
    "second _ at positions @xmath60 , @xmath89 ,  we can not move to the left more than to @xmath116 .",
    "thus the factor remains ( and has at least @xmath23 letters ) .",
    "we show that indeed we have a partial pairing .",
    "firstly , if @xmath60 is decreased , then as a result we get a partial pairing : the only nontrivial case is when @xmath89 and @xmath60 were paired then @xmath89 is assigned as the first element in the pair but it has no corresponding element , which is allowed in the partial pairing . if @xmath60 is increased then we need to make sure if @xmath89 is assigned as a first element in a pair then @xmath60 will be assigned as the second one ( or the pairing is cleared ) .",
    "note that @xmath89 can be assigned in this way only when it is part of the factor , i.e.  it gets the same status as some @xmath50 . if @xmath60 is also part of the same factor , then it is assigned the status of @xmath118 , which by inductive assumption is paired with @xmath50 , so is the second element in the pair . in the remaining case ,",
    "if @xmath89 was the last element of the factor then in loop in line  [ prawy koniec ] we decrease @xmath60 and so unprocess @xmath89 ( in particular , we clear its pairing ) .    for ( ) observe that for the first two letters it is explicitly verified in line  [ lewy koniec ] .",
    "similarly , for the second part of ( ): we shorten the last factor in line  [ prawy koniec ] ( ending at @xmath60 ) until @xmath77 = { { { \\textnormal{\\textsl{second}}}}}$ ] .",
    "we already shown that pairing is defined for @xmath119 $ ] and when @xmath60 is assigned @xmath79 then @xmath89 is assigned @xmath78 , as claimed .",
    "suppose that ( ) does not hold for @xmath120 , i.e.  they are both unpaired after processing @xmath60 .",
    "it can not be that they are both within the same factor , as then the corresponding @xmath121 $ ] and @xmath53 $ ] in the definition of the factor are also unpaired , by ( ) , which contradicts the induction assumption .",
    "similarly , it can not be that one of them is in a factor and the other outside this factor , as by ( ) ( which holds for @xmath72 $ ] ) a factor begins and ends with two paired letters .",
    "so they are both free letters .",
    "but then we needed to pass line  [ pairing trivial factors ] for @xmath60 and both @xmath122 $ ] and @xmath64 $ ] were free at that time , which means that they should have been paired at that point , contradiction .    to see the third claim of the lemma , i.e.  the bound on the number of new free letters , fix a factor @xmath35 that begins at position @xmath60 .",
    "when it is modified , we identify the obtained factor with @xmath35 ( which in particular shows that the number of factors does not increase ) .",
    "we show that it creates at most @xmath123 new free letters in this phase .",
    "if at any point @xmath59 $ ] and @xmath62 $ ] , i.e.  the factor has only one letter , then it is replaced with a free letter and afterwards can not introduce any free letters ( as @xmath35 is no longer there ) .",
    "hence at most one free letter is introduced by @xmath35 due to condition in line  [ ensure non - trivial ] .    if @xmath59 = i-1 $ ] then it creates one free letter inside condition in line  [ blok ] .",
    "it can not introduce another free letter in this way ( in this phase ) , as afterwards @xmath83 = i-1 $ ] and there is no way to decrease this distance ( in this phase ) .",
    "we show that condition in line  [ lewy koniec ] , i.e.  that the first letter of the factor definition is not the first in the pair , holds at most twice for a fixed factor @xmath35 in a phase .",
    "since we set @xmath124 $ ] and increase both @xmath60 and @xmath50 by @xmath27 until @xmath125 = { { { \\textnormal{\\textsl{first}}}}}$ ] , this can be viewed as searching for the smallest position @xmath126 that is first in a pair and we claim that @xmath127 . on the high - level , this should hold because ( ) holds for @xmath107 $ ] , and so among three consecutive letters there is at least one that is the first element in the pair . however , the situation is a bit more complicated , as some pairing may change during the search .",
    "= i-1 $ ] , so some care is needed . ]",
    "consider first the main case , in which @xmath128 .",
    "then the elements at position @xmath50 , @xmath118 , @xmath129 have already assigned pairings and so at least one of them is assigned as a first element of some pair .",
    "the only way to change the pairing from @xmath78 to some other is in loop in line  [ prawy koniec ] .",
    "however , we can go to this loop only after condition in line  [ lewy koniec ] fails , which implies that it holds at most twice ( i.e.  for at most two other among @xmath50 , @xmath118 , @xmath130 ) .    as the case",
    "in which @xmath59 = i-1 $ ] is excluded by the case assumption of the algorithm , the remaining case is @xmath131 .",
    "as in the previous argument , we consider the letters whose pairing are known , i.e.  @xmath132 $ ] and @xmath122 $ ] . if any of them is a first letter in a pair , we are done ( as in the previous case ) . as ( ) holds for them , the only remaining possibility is that @xmath132 $ ] is a second letter in a pair and @xmath122 $ ] is unpaired .",
    "then when we consider @xmath60 in line  [ lewy koniec ] it is made free .",
    "when we consider @xmath64 $ ] in line  [ pairing trivial factors ] ( re - reading it as a free letter ) , it is paired with @xmath89 .",
    "hence when we read @xmath133 ( the new first letter in the factor ) its definition ( @xmath89 ) is a first letter in a pair , as claimed .",
    "finally , it is left to show that when we processed the whole @xmath12 then we have a proper factorisation and a pairing satisfying ( )  ( ) . from the inductive proof it follows that the kept factorisation is proper and the partial pairing satisfies ( )  ( ) for the whole word .",
    "so it is enough to show that this partial pairing is a pairing , i.e.  that the last letter of @xmath12 is not assigned as a first element of a pair .",
    "consider , whether it is in a factor or a free letter .",
    "if it is in a factor then clearly it is the last element of the factor and so by ( ) it is the second element in a pair .",
    "if it is a free letter observe that we only pair free letters in line  [ pairing trivial factors 2 ] , which means that it is paired with the letter on the next position , contradiction .    now",
    ", we show that when we have a pairing satisfying ( )  ( ) ( so in particular the one provided by is fine , but it can be any other pairing satisfying ( )  ( ) ) then creates a word @xmath134 out of @xmath12 together with a factorisation .",
    "[ lem : pairing and trivial ] when a pairing satisfies ( )  ( ) then runs in linear time and returns a word @xmath134 together with a factorisation ; @xmath135 and the factorisation of @xmath134 has the same number of factors as the factorisation of @xmath12 .",
    "if @xmath136 fresh letters were introduced then @xmath134 has @xmath136 less free letters than @xmath12 .",
    "firstly , we show that when we erase the information about beginnings and ends of factors of @xmath12 we do not erase the newly created information for @xmath134 . to this end",
    "it is enough to show that @xmath137 in such situation .",
    "whenever @xmath93 is incremented , @xmath60 is incremented by at least the same amount , so it is enough to show that @xmath137 when @xmath60 is the first letter of the first factor , in other words , there is at least one pair before the first factor . by ( ) there is a pair within first three positions of the factor .",
    "if the pair is at positions @xmath27 , @xmath23 then by ( ) the factor begins at position @xmath138 or later and we are done .",
    "if the pair is at positions @xmath23 , @xmath138 then by ( ) the factor begins at position @xmath139 or later or at position @xmath23 ; however , the latter case implies that the factor definition is @xmath27 to the left of the factor , which is excluded by .    concerning the size of the produced word , by ( ) each unpaired letter ( perhaps except the last letter of @xmath12 ) is followed by a pair .",
    "thus , at least @xmath140 letters are removed from @xmath12 , which yields the claim .        now , consider any factor @xmath35 in @xmath12 with a definition @xmath141 $ ] . by",
    "( ) both the first and the last two letters of @xmath35 are paired and by ( ) pairing of @xmath35 is the same as the pairing of its definition .",
    "so it is enough to copy the letters in @xmath134 corresponding to @xmath141 $ ] , i.e.  beginning with @xmath142 $ ] , which is what the algorithm does .",
    "when we consider a free letter , if it is unpaired , it should be copied ( as it is not replaced ) , and when it is paired , the pair can be replaced with a fresh letter ; in both cases the corresponding letter in the new word should be free .",
    "and the algorithm does that .    concerning the number of fresh letters introduced ,",
    "suppose that @xmath28 is replaced with @xmath5 .",
    "if @xmath28 is within some factor @xmath35 then we use for the replacement the same letter as we use in the factor definition and so no new fresh letter is introduced .",
    "if both this @xmath21 and @xmath75 are free letters then each such a pair contributes one fresh letter . and",
    "those two free letters are replaced with one free letter , hence the number of free letters decreases by @xmath27 .",
    "the last possibility is that one letter from @xmath28 comes from a factor and the other from outside this factor , but this contradicts ( ) that a factor begins and ends with a pair .",
    "due to lemma  [ lem : pairing and trivial ] each introduction of a fresh letter reduces the number of free letters by @xmath27 .",
    "thus to bound the number of different introduced letters it is enough to estimate the number of created free letters . in the initial lz77 factorisation",
    "there are at most @xmath6 of them . for",
    "the free letters created during the let us fix a factor @xmath35 of the original factorisation and estimate how many free letters it created .",
    "due to ( ) the length of @xmath35 drops by a constant fraction in each phase and so it will take part in @xmath144 phases . in each phase it can introduce at most @xmath123 free letters , by lemma  [ lem : main ] .",
    "so @xmath145 free letters were introduced to the word during all phases .",
    "consider @xmath146 under the constraint @xmath147 . as",
    "function @xmath148 is concave , we conclude that this is maximised for all @xmath32 being equal to @xmath149 .",
    "hence the number of nonterminals in the grammar introduced in this way is @xmath150 . adding the @xmath6 for the free letters in the lz77 factorisations yields the claim .",
    "concerning the running time , the creation of the lz77 factorisation takes linear time  @xcite . in each phase",
    "the pairing and replacement of pairs takes linear time in the length of the current word .",
    "thanks to ( ) the length of such a word is reduced by a constant fraction in each phase , hence the total running time is linear .",
    "anisa al - hafeedh , maxime crochemore , lucian ilie , evguenia kopylova , william  f. smyth , german tischler , and munina yusufu .",
    "a comparison of index - based lempel - ziv lz77 factorization algorithms .",
    ", 45(1):5 , 2012 .",
    "gang chen , simon  j. puglisi , and william  f. smyth .",
    "fast and practical algorithms for computing all the runs in a string . in bin ma and kaizhong zhang , editors ,",
    "_ cpm _ , volume 4580 of _ lncs _ , pages 307315 .",
    "springer , 2007 .",
    "pawe gawrychowski .",
    "pattern matching in lempel - ziv compressed strings : fast , simple , and deterministic . in camil",
    "demetrescu and magns  m. halldrsson , editors , _ esa _ , volume 6942 of _ lncs _ , pages 421432 .",
    "springer , 2011 .",
    "leszek gsieniec , marek karpiski , wojciech plandowski , and wojciech rytter .",
    "efficient algorithms for lempel - ziv encoding . in rolf",
    "g. karlsson and andrzej lingas , editors , _ swat _ , volume 1097 of _ lncs _ , pages 392403 .",
    "springer , 1996 .",
    "artur je .",
    "faster fully compressed pattern matching by recompression . in artur czumaj , kurt mehlhorn , andrew pitts , and roger wattenhofer , editors , _ icalp ( 1 ) _ , volume 7391 of _ lncs _ , pages 533544 .",
    "springer , 2012 .",
    "artur je .",
    "approximation of grammar - based compression via recompression . in johannes fischer and peter sanders , editors ,",
    "_ cpm _ , volume 7922 of _ lncs _ , pages 165176 .",
    "springer , 2013 .",
    "full version at http://arxiv.org/abs/1301.5842 .",
    "artur je and markus lohrey .",
    "approximation of smallest linear tree grammar . in ernst",
    "w. mayr and natacha portier , editors , _ stacs _ , volume  25 of _ lipics _ , pages 445457 .",
    "schloss dagstuhl  leibniz - zentrum fuer informatik , 2014 .",
    "juha krkkinen , dominik kempa , and simon  j. puglisi .",
    "linear time lempel - ziv factorization : simple , fast , small . in johannes fischer and peter sanders , editors ,",
    "_ cpm _ , volume 7922 of _ lncs _ , pages 189200 .",
    "springer , 2013 .",
    "james  a. storer and thomas  g. szymanski . the macro model for data compression . in richard",
    "j. lipton , walter  a. burkhard , walter  j. savitch , emily  p. friedman , and alfred  v. aho , editors , _ stoc _ , pages 3039 .",
    "acm , 1978 ."
  ],
  "abstract_text": [
    "<S> in this paper we present a _ really _ simple linear - time algorithm constructing a context - free grammar of size @xmath0 for the input string , where @xmath1 is the size of the input string and @xmath2 the size of the optimal grammar generating this string . </S>",
    "<S> the algorithm works for arbitrary size alphabets , but the running time is linear assuming that the alphabet @xmath3 of the input string can be identified with numbers from @xmath4 for some constant @xmath5 . </S>",
    "<S> algorithms with such an approximation guarantee and running time are known , however all of them were non - trivial and their analyses were involved . </S>",
    "<S> the here presented algorithm computes the lz77 factorisation and transforms it in phases to a grammar . in each phase </S>",
    "<S> it maintains an lz77-like factorisation of the word with at most @xmath6 factors as well as additional @xmath7 letters , where @xmath6 was the size of the original lz77 factorisation . in one phase in a greedy way ( by a left - to - right sweep and a help of the factorisation ) we choose a set of pairs of consecutive letters to be replaced with new symbols , i.e.  nonterminals of the constructed grammar . </S>",
    "<S> we choose at least 2/3 of the letters in the word and there are @xmath7 many different pairs among them . </S>",
    "<S> hence there are @xmath8 phases , each of them introduces @xmath7 nonterminals to a grammar . a more precise analysis yields a bound @xmath9 . as @xmath10 , </S>",
    "<S> this yields the desired bound @xmath11 . </S>"
  ]
}