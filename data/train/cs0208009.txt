{
  "article_text": [
    "_ partial evaluation _ has over the past decade received considerable attention both in functional ( e.g.  @xcite ) , imperative ( e.g.  @xcite ) and logic programming ( e.g.   @xcite ) .",
    "partial evaluators are also sometimes called @xmath1 , as they usually perform a mixture of evaluation and code generation steps . in the context of pure logic programs ,",
    "partial evaluation is sometimes referred to as _ partial deduction _ , the term partial evaluation being reserved for the treatment of impure logic programs .    guided by the",
    "_ futamura projections _ @xcite a lot of effort , specially in the functional partial evaluation community , has been put into making systems self - applicable . a partial evaluation or deduction system",
    "is called _ self - applicable _ if it is able to effectivelyspecialise itself . in that case one may ,",
    "according to the second futamura projection , obtain _ compilers _ from interpreters and , according to the third futamura projection , a _ compiler generator _",
    "( @xmath0 for short ) .",
    "in essence , given a particular program @xmath2 , a @xmath0 generates a _ specialised specialiser _ for @xmath2 .",
    "if @xmath2 is an interpreter a @xmath0 thus generates a compiler .",
    "however writing an effectively self - applicable specialiser is a non - trivial task  the more features one uses in writing the specialiser the more complex the specialisation process becomes , because the specialiser then has to handle these features as well .",
    "this is why so far no partial evaluator for full prolog ( like mixtus  @xcite , or paddy   @xcite ) is effectively self - applicable . on the other hand a partial deducer which specialises only purely declarative",
    "logic programs ( like sage @xcite or the system in @xcite ) has itself to be written purely declaratively leading to slow systems and impractical compilers and compiler generators .",
    "so far the only practical compilers and compiler generators for logic programs have been obtained by @xcite and @xcite .",
    "however , the specialisation in @xcite is incorrect with respect to some extra - logical built - ins , leading to incorrect results when attempting self - application @xcite .",
    "the partial evaluator logimix  @xcite does not share this problem , but gives only modest speedups when self - applied ( compared to results for functional programming languages ; see @xcite ) and can not handle partially static data .    however , the actual creation of the @xmath0 according to the third futamura projection is not of much interest to users since @xmath0 can be generated once and for all when a specialiser is given .",
    "therefore , from a user s point of view , whether a @xmath0 is produced by self - application or not is of little importance ; what is important is that it exists and that it is efficient and produces efficient , non - trivial specialised specialisers .",
    "this is the background behind the approach to program specialisation called the _",
    "cogen approach _ ( as opposed to the more traditional @xmath1 approach ) : instead of trying to write a partial evaluation system @xmath1 which is neither too inefficient nor too difficult to self - apply one simply writes a compiler generator directly .",
    "this is not as difficult as one might imagine at first sight : basically the @xmath0 turns out to be just a simple extension of a `` binding - time analysis '' for logic programs ( something first discovered for functional languages in @xcite and then exploited in , e.g. , @xcite ) .    in this paper",
    "we will describe the first @xmath0 written in this way for a logic programming language .",
    "we start out with a @xmath0 for a small subset of prolog and progressively improve it to handle a large part of prolog and to extend its capabilities .",
    "although the futamura projections focus on how to generate a compiler from an interpreter , the projections of course also apply when we replace the interpreter by some other program . in this case",
    "the program produced by the second futamura projection is not called a compiler , but a _ generating extension_. the program produced by the third futamura projection could rightly be called a _ generating extension generator _ or gengen , but we will stick to the more conventional @xmath0 .",
    "the main contributions of this work are :    * a formal specification of the concept of _ binding - time analysis _ and more generally _ binding - type analysis _ , allowing the treatment of _ partially static _ structures , in a ( pure ) logic programming setting and a description of how to obtain a generic procedure for _ offline partial deduction _ from such an analysis .",
    "* based upon point 1 , the first description of an efficient , handwritten compiler generator ( @xmath0 ) for a logic programming language , which has  exactly as for other handwritten cogens for other programming paradigms  a quite elegant and natural structure . * a way to handle both _ extra - logical _ features ( such as var/1 ) and _ side - effects _ ( such as print/1 ) within the @xmath0 . a refined treatment of the call/1 predicate is also presented . * how to handle negation , disjunction and the if - then - else conditional in the @xmath0 . * experimental results showing the efficiency of the @xmath0 , the generating extensions , and also of the specialised programs . * a method to obtain a binding - type analysis through the exploitation of existing termination analysers .",
    "this paper is a much extended and revised version of @xcite : points 3 , 4 , 5 , 6 and the partially static structures of point 1 are new , leading to a more powerful and practically useful @xmath0 .",
    "the paper is organised as follows : in section  [ section : off - line - pd ] we formalise the concept of off - line partial deduction and the associated binding - type analysis . in section  [ section : cogen - pure ]",
    "we present and explain our @xmath0 approach in a pure logic programming setting , starting from the structure of the generating extensions",
    ". in section  [ section : cogen - impure ] we discuss the treatment of declarative and non - declarative built - ins as well as constructs such as negations , conditionals , and disjunctions . in section  [ section : results ] we present experimental results underlining the efficiency of the @xmath0 and of the generating extensions it produces .",
    "we also compare the results against a traditional offline specialiser .",
    "in section  [ section : bta ] we present a method for doing an automatic binding - type analysis .",
    "we evaluate the efficiency and quality of this approach using some experiments .",
    "we conclude with some discussions of related and future work in section  [ section : discussion ] .",
    "throughout this paper , we suppose familiarity with basic notions in logic programming . we follow the notational conventions of @xcite .",
    "in particular , in programs , we denote variables through strings starting with an upper - case symbol , while the notations of constants , functions and predicates begin with a lower - case character .",
    "we start off by presenting a general procedure for performing partial deduction .",
    "more details on partial deduction and how to control it can be found , e.g. , in @xcite .    given a logic program @xmath2 and a goal @xmath3 , _ partial deduction _ produces a new program @xmath4 which is @xmath2 `` specialised '' to the goal @xmath3 ; the aim being that the specialised program @xmath4 is more efficient than the original program @xmath2 for all goals which are instances of @xmath3 . the underlying technique of partial deduction is to construct finite , non - trivial but possibly incomplete sldnf - trees .",
    "( a _ trivial _ sldnf - tree is one in which no literal in the root has been selected for resolution , while an _",
    "incomplete _ sldnf - tree is a sldnf - tree which , in addition to success and failure leaves , may also contain leaves where no literal has been selected for a further derivation step . ) the derivation steps in these sldnf - trees correspond to the computation steps which have already been performed by the _",
    "partial deducer _ and the clauses of the specialised program are then extracted from these trees by constructing one specialised clause ( called a _ resultant _ ) per non - failing branch .",
    "these sldnf - trees and resultants are obtained as follows .",
    "[ def : unfoldingrule ] an _ unfolding rule _ is a function which , given a program @xmath2 and a goal @xmath3 , returns a non - trivial and possibly incomplete sldnf - tree for @xmath5 .    [",
    "def : resultants ] let @xmath2 be a normal program and @xmath6 an atom .",
    "let @xmath7 be a finite , incomplete sldnf - tree for @xmath8 .",
    "let @xmath9 be the goals in the leaves of the non - failing branches of @xmath7 .",
    "let @xmath10 be the computed answers of the derivations from @xmath11 to @xmath9 respectively .",
    "then the set of resultants , @xmath12 , is defined to be the set of clauses @xmath13 .",
    "we also define the set of leaves , @xmath14 , to be the atoms occurring in the goals @xmath15 .",
    "partial deduction uses the resultants for a given set of atoms @xmath16 to construct the specialised program ( and for each atom in @xmath16 a different specialised predicate definition will be generated ) . under the conditions stated in @xcite , namely _ closedness _",
    "( all leaves are an instance of an atom in @xmath16 ) and _ independence _",
    "( no two atoms in @xmath16 have a common instance ) , correctness of the specialised program is guaranteed .    in most practical approaches independence",
    "is ensured by using a _ renaming _ transformation which maps dependent atoms to new predicate symbols . adapted correctness results can be found in @xcite and @xcite .",
    "renaming is often combined with argument _ filtering _ to improve the efficiency of the specialised program ; see e.g.  @xcite .",
    "closedness can be ensured by using the following outline of a partial deduction procedure , similar to the ones used in e.g.   @xcite .",
    "( partial deduction ) [ skeleton : pdalgorithm ]    * input * : : :    a program @xmath2 and an initial set    @xmath17 of atoms to be specialised * output * : : :    a set of atoms @xmath16 * initialisation * : : :    @xmath18 * repeat * : :     ; ;      @xmath19     ; ;      @xmath20      @xmath21     ; ;      @xmath22 * until * : :    @xmath23 ( modulo variable    renaming ) * output * : :    @xmath24    the above procedure is parametrised by an unfolding rule @xmath25 and an generalisation operation @xmath26 .",
    "the latter can be used to ensure termination and can be formally defined as follows .",
    "[ def : abstract ] an _ generalisation operation _ is a function @xmath26 from sets of atoms to sets of atoms such that , for any finite set of atoms @xmath27 , @xmath28 is a finite set of atoms @xmath29 using the same predicates as those in @xmath27 , and every atom in @xmath27 is an instance of an atom in @xmath29 .",
    "if procedure  [ skeleton : pdalgorithm ] terminates then the closedness condition is satisfied .",
    "finally , note that , two sets of atoms @xmath30 and @xmath31 are said to be identical _ modulo variable renaming _ if for every @xmath32 there exists @xmath33 such that @xmath34 and @xmath35 are variants , and vice versa .      in procedure  [ skeleton : pdalgorithm ] one can distinguish between two different levels of control . the unfolding rule @xmath36 controls the construction of the incomplete sldnf - trees .",
    "this is called the _ local control _",
    "the generalisation operation controls the construction of the set of atoms for which such sldnf - trees are built",
    ". we will refer to this aspect as the _ global control_.",
    "the control problems have been tackled from two different angles : the so - called _ off - line _ versus _ on - line _ approaches .",
    "the _ on - line _ approach performs all the control decisions _ during _ the actual specialisation phase .",
    "the _ off - line _ approach on the other hand performs an analysis phase _",
    "prior _ to the actual specialisation phase , based on a description of what kinds of specialisations will be required .",
    "this analysis phase provides annotations which then guide the specialisation phase proper , often to the point of making it almost trivial .",
    "partial evaluation of functional programs @xcite has mainly stressed off - line approaches , while supercompilation of functional @xcite and partial deduction of logic programs @xcite have mainly concentrated on on - line control .",
    "an initial motivation for using the off - line approach was to achieve effective self - application @xcite .",
    "but the off - line approach is in general also much more efficient since many decisions concerning control are made _ before _ and not during specialisation .",
    "this is especially true in a setting where the same program is re - specialised several times .",
    "( note , however , that the global control is usually not done in a fully offline fashion : almost all offline partial evaluators maintain during specialisation a list of calls that have been previously specialised or are pending @xcite . )",
    "most off - line approaches perform what is called a _ binding - time analysis ( _ bta _ ) _ prior to the specialisation phase .",
    "the purpose of this analysis is to figure out which values will be known at specialisation time proper and which values will only be known at runtime .",
    "the simplest approach is to classify arguments within the program to be specialised as either _",
    "static _ or _",
    "dynamic_. the value of a static argument will be _ definitely known _",
    "( bound ) at specialisation time whereas a dynamic argument is not necessarily known at specialisation time . in the context of partial deduction of logic programs ,",
    "a static argument can be seen @xcite as being a term which is guaranteed not to be more instantiated at run - time ( it can never be less instantiated at run - time ; otherwise the information provided would be incorrect ) .",
    "for example if we specialise a program for all instances of @xmath37 then the first argument to @xmath38 is static while the second one is dynamic    this approach is successful for functional programs , but often proves to be too weak for logic programs : in logic programming partially instantiated data structures appear naturally even at runtime .",
    "a simple classification of arguments into `` fully known '' or `` totally unknown '' is therefore unsatisfactory and would prevent specialising a lot of `` natural '' logic programs such as the vanilla metainterpreter @xcite or most of the benchmarks from the dppd library @xcite .",
    "the basic idea to improve upon the above shortcoming , is to describe parts of arguments which will actually be known at specialisation time by a special form of types .",
    "below , we will develop the first such description , of what we call _ binding - types _ , in logic programming .      in logic programming",
    ", a type can be defined as a set of terms closed under substitution @xcite .",
    "we will stick to this view and adapt the definitions and concepts of @xcite ( which mainly follow the hilog notation @xcite ) .    as is common in polymorphically typed languages",
    "( e.g.  @xcite ) , types are are built up from type variables and type constructors in much the same way as terms are built - up from ordinary variables and function symbols .",
    "formally , a _ type _ is either a _ type variable _ or a _ type constructor _ of arity @xmath39 applied to @xmath40 types .",
    "we presuppose the existence of three 0-ary type constructors : static , dynamic , and nonvar .",
    "these constructors will be given a pre - defined meaning below .",
    "also , a type which contains no variables is called _",
    "ground_.    a _ type definition _ for a type constructor @xmath41 of arity @xmath40 is of the form @xmath42 with @xmath43 and where @xmath44 are distinct function symbols , @xmath45 are distinct type variables , and @xmath46 are types which only contain type variables in @xmath47 .",
    "a _ type system _ @xmath48 is a set of type definitions , exactly one for every type constructor @xmath41 different from static , dynamic , and nonvar",
    ". we will refer to the type definition for @xmath41 in @xmath48 by @xmath49 .",
    "from now on we will suppose that the underlying type system @xmath48 is fixed .",
    "a type system @xmath50 , defining a type constructor for parametric lists , can be defined as follows : @xmath51 = @xmath52 . using the ascii notations of mercury @xcite and using prolog s list notation ,",
    "the type system @xmath50 would be written down as follows :    .... : - type list(t ) --- > [ ] ; [ t | list(t ) ] . ....",
    "we define _ type substitutions _ to be finite sets of the form @xmath53 , where every @xmath54 is a type variable and @xmath55 a type .",
    "type substitutions can be applied to types ( and type definitions ) to produce _ instances _ in exactly the same way as substitutions can be applied to terms .",
    "for example , @xmath56 .",
    "a type or type definition is called _ ground _ if it contains no type variables .",
    "we now define type judgements relating terms to types in the underlying type system @xmath48 .",
    "_ type judgements _ have the form @xmath57 , where @xmath58 is a term and @xmath7 is a type , and are inductively defined as follows .",
    "* @xmath59 holds for any term @xmath58 * @xmath60 holds for any ground term @xmath58 * @xmath61 holds for any non - variable term @xmath58 * @xmath62 holds if there exists a ground instance of the type definition @xmath49 in the underlying type system @xmath48 which has the form @xmath63 and where @xmath64 for @xmath65 .",
    "we also say that a type @xmath7 is _ more general _ than another type @xmath66 iff whenever @xmath67 then also @xmath68 .",
    "note that our definitions guarantee that types are downwards - closed in the sense that for all terms @xmath58 and types @xmath7 we have @xmath69 @xmath70 @xmath71 .",
    "here are a few examples , using the type system @xmath50 above .",
    "first , we have @xmath72 , @xmath73 , and @xmath74 . also , @xmath75 , @xmath76 but not @xmath77 . for variables we have @xmath78 , but neither @xmath79 nor @xmath80",
    ". a few examples with lists ( using prolog s list notation ) are as follows : @xmath81 : \\mathit{list}(\\mathit{static})$ ] ,   @xmath72 hence @xmath82 : \\mathit{list}(\\mathit{static})$ ] ,   @xmath78 and @xmath83 hence @xmath84 : \\mathit{list}(\\mathit{dynamic})$ ] .",
    "finally , we have , for example , that @xmath85 is more general than @xmath86 .",
    "we will now formalise the concept of a _ binding - type _ analysis ( which is an extension of a binding-_time _ analysis , as in @xcite ) .",
    "for that we first define the concept of a division which assigns types to arguments of predicates .",
    "[ def : division ] a _ division for a predicate @xmath38 _ of arity @xmath40 is an expression of the form @xmath87 where each @xmath55 is a ground type .",
    "a _ division for a program @xmath2 _ is a set of divisions for predicates in @xmath88 , with at most one division for any predicate . when there is no ambiguity about the underlying program @xmath2 we will also often simply refer to a _",
    "division_.    a division is called _ simple _ iff it contains only the types static and dynamic . a division @xmath89 is called _",
    "more general _ than another division @xmath90 iff @xmath91 @xmath92 there exists @xmath93 such that for @xmath65 @xmath55 is more general than @xmath94 .",
    "the fact that divisions only use ground types means that we do not cater for polymorhpic types , although we can still use parametric types .",
    "this simplifies the remainder of the presentation ( mainly definition  [ def : gen - delta ] ) but can probably be lifted .",
    "as can be seen from the above definition , we restrict ourselves to monovariant divisions in this paper . as discussed in @xcite , a way to handle polyvariant divisions by a monovariant approach",
    "is to``invent sufficiently many versions of each predicate . ''",
    "now , a _ binding - type analysis _ will , given a program @xmath2 ( and some description of how @xmath2 will be specialised ) , perform a pre - processing analysis and return a single _ division _ for every predicate in @xmath2 describing the part of the values that will be known at specialisation time .",
    "it will also return an _ annotation _ which will then guide the local unfolding process of the actual partial deduction . for the time being , an annotation can simply be seen as a particular unfolding rule @xmath95 .",
    "we will return to this in section  [ subsec : particual - off - line - pd ] .",
    "we are now in a position to formally define a binding - type analysis in the context of ( pure ) logic programs :    a _ binding - type analysis _",
    "( _ bta _ ) yields , given a program @xmath2 and an arbitrary initial division @xmath96 for @xmath2 , a couple @xmath97 consisting of an unfolding rule @xmath95 and a division @xmath89 for @xmath2 more general than @xmath96 .",
    "we will call the result of a binding - time analysis a _ binding - type classification _ ( _ btc _ ) .",
    "the purpose of the initial division @xmath96 is to give information about how the program will be specialised : it specifies what form the initial atom(s ) ( i.e. , the ones in @xmath98 of procedure  [ skeleton : pdalgorithm ] ) can take .",
    "the rle of @xmath89 is to give information about the atoms and their binding types that can occur at the global level ( i.e. , the ones in @xmath99 and @xmath100 of procedure  [ skeleton : pdalgorithm ] ) . in that light ,",
    "not all _ btc _ are correct and we have to develop a safety criterion . basically a _ btc _ is safe iff every atom that can potentially appear in one of the sets @xmath99 of procedure  [ skeleton : pdalgorithm ] ( given the restrictions imposed by the annotation of the _ bta _ ) corresponds to the patterns described by @xmath89 .. ]    we first define a safety notion for atoms and goals .",
    "let @xmath2 be a program and let @xmath89 be a division for @xmath2 and let @xmath101 be an atom .",
    "then @xmath101 is _ safe wrt @xmath89 _ iff @xmath102 such that @xmath103 we have @xmath64 .",
    "a set of atoms @xmath27 is _ safe wrt @xmath89 _ iff every atom in @xmath27 is safe wrt @xmath89 . also a goal @xmath3 is _ safe wrt @xmath89 _ iff all the atoms occurring in @xmath3 are safe wrt @xmath89 .",
    "for example @xmath37 and @xmath104 are safe wrt @xmath105 while @xmath106 is not .",
    "[ def : safety ] [ def : safebta ] let @xmath107 be a _",
    "btc _ for a program @xmath2 .",
    "then @xmath108 is a _ globally safe _ btc _ for @xmath2 _ iff for every goal @xmath3 which is safe wrt @xmath89 , @xmath109 is an sldnf - tree @xmath7 for @xmath5 whose leaf goals are safe wrt @xmath89 . a _",
    "bta _ is _ globally safe _ if for any program @xmath2 it produces a globally safe _ btc _ for @xmath2 .",
    "sometimes  in order to simplify both the partial deducer and the _ bta _  one might want to generalise atoms and then lift them to the global level ( i.e. , @xmath99 in procedure  [ skeleton : pdalgorithm ] ) _ before _ the full sldnf - tree @xmath7 has been built , namely at the point where a left - to - right selection rule would have selected the atom .",
    "this is the motivation behind the following notion of a _ strongly _ globally safe _",
    "btc_.    [ def : strong - global - safety ] let @xmath107 be a _",
    "btc _ for a program @xmath2 .",
    "then @xmath108 is a _ strongly globally safe _ _ btc _ for @xmath2 iff it is globally safe for @xmath2 and for every goal @xmath3 which is safe wrt @xmath89 , @xmath109 is an sldnf - tree such that the literals to the left of selected literals are also safe wrt @xmath89 .",
    "notice , that in the above definitions of safety no requirement is made about the actual atoms selected by @xmath95 .",
    "indeed , contrary to functional or imperative programming languages , definite logic programs can handle uninstantiated variables and a positive atom can always be selected .",
    "nonetheless , if we have negative literals or prolog built - ins , this is no longer true .",
    "for example , x is y + 1 can only be selected if y is ground .",
    "put in other terms , we can only select a call `` @xmath110 is @xmath58 '' if it is safe wrt @xmath111 .",
    "also , we might want to restrict unfolding of user - defined predicates to cases where only one clause matches .",
    "for example , we might want to unfold a call @xmath112 ( see example  [ example : append ] below ) only if it is safe wrt @xmath113 .",
    "this motivates the next definition , which can be used to ensure that only properly instantiated calls to built - ins and atoms are selected .",
    "a _ btc _ @xmath107 is _ locally safe for @xmath2 _ iff for every goal @xmath3 which is safe wrt @xmath89 , @xmath109 is an sldnf - tree for @xmath5 where all selected literals are safe wrt @xmath89 .",
    "the difference between local and global safety is illustrated in figure  [ fig : safety ] .",
    "note that it might make sense to use different divisions for local and global safety .",
    "this can be easily allowed , but we will not do so in the presentation of this article .",
    "# 1#2#3#4#5 @font    ( 6312,3123)(3601,-5665 ) ( 4801,-2836)(-1,-1)1050 ( 6226,-3886)(7.46746,4.97830)118(1.6667,11.6667 ) .",
    "( 9076,-3286 ) ( 1 , 0)0 ( 7088,-3286)(8.99548,0.00000)221(1.6667,11.6667 ) .",
    "( 9256,-4606)(210,210)[bl ] ( 9256,-3316)(210,210)[tl ] ( 9796,-4606)(210,210)[br ] ( 9796,-3316)(210,210)[tr ] ( 9256,-4711)(9.00000,0.00000)61(1.6667,11.6667 ) .",
    "( 9256,-3211)(9.00000,0.00000)61(1.6667,11.6667 ) .",
    "( 9151,-4606)(0.00000,9.02098)144(1.6667,11.6667 ) .",
    "( 9901,-4606)(0.00000,9.02098)144(1.6667,11.6667 ) .",
    "( 9005,-4071 ) ( 1 , 0)0 ( 7730,-4071)(8.97887,0.00000)142(1.6667,11.6667 ) .",
    "( 5151,-5611)(0,0)[lb ] ( 3601,-4111)(0,0)[lb ] ( 5531,-4111)(0,0)[lb ] ( 4031,-2686)(0,0)[lb ] ( 9341,-4061)(0,0)[lb ] ( 7200,-3161)(0,0)[lb ] ( 8021,-3931)(0,0)[lb ] ( 8276,-5411)(0,0)[lb ]    let us now return to the global control .",
    "definition  [ def : safebta ] requires atoms to be safe in the leaves of incomplete sldnf - trees , i.e.  at the point where the atoms get abstracted and then lifted to the _ global _ level .",
    "so , in order for definition  [ def : safebta ] to ensure safety at all stages of procedure  [ skeleton : pdalgorithm ] , the particular generalisation operation employed should not abstract atoms which are safe wrt @xmath89 into atoms which are no longer safe wrt @xmath89 .",
    "this motivates the following definition :    [ def : abstract - safe ] an generalisation operation @xmath26 is _ safe wrt a division @xmath89 _ iff for every finite set of atoms",
    "@xmath27 which is safe wrt @xmath89 , @xmath28 is also safe wrt @xmath89 .    in particular",
    "this means that @xmath26 can only generalise positions marked as dynamic or the arguments of positions marked as nonvar within the respective binding - type .",
    "for example , @xmath114)\\ } ) = \\{p(x)\\}$ ] is neither safe wrt @xmath115 nor wrt @xmath116 nor wrt @xmath117 , but it is safe wrt @xmath118 .",
    "also , @xmath119))\\ } ) = \\{p(f(x))\\}$ ] is not safe wrt @xmath115 but is safe wrt both @xmath116 and @xmath118 .",
    "[ example : append ] let @xmath2 be the well known append program    _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ @xmath120,l , l ) \\leftarrow$ ] + @xmath121,y,[h|z ] ) \\leftarrow \\mathit{app}(x , y , z)$ ] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _    let @xmath122 and let @xmath95 be any unfolding rule . then @xmath97 is a globally and locally safe _ btc _ for @xmath2 .",
    "e.g. , the goal @xmath123,y , z)$ ] is safe wrt @xmath89 and @xmath124 can either stop at @xmath125,y , z)$ ] , @xmath126,y',z')$ ] or at the empty goal @xmath127 .",
    "all of these goals are safe wrt @xmath89 . more generally , unfolding a goal @xmath128 where @xmath129 is ground ( and thus static ) , leads only to goals whose first arguments are ground ( static ) .      in this subsection",
    "we define a specific off - line partial deduction method which will serve as the basis for the @xmath0 developed in the remainder of this paper . for simplicity",
    ", we will , until further notice , restrict ourselves to definite programs .",
    "negation will in practice be treated in the @xmath0 either as a built - in or via the _ if - then - else _ construct ( both of which we will discuss later ) .",
    "we first define a particular class of simple - minded but effective unfolding rules .",
    "[ def : annotation ] an _ annotation _",
    "@xmath130 for a program @xmath2 marks every literal in the body of each clause of @xmath2 as either _ reducible _ or _ non - reducible_. a program @xmath2 together with an annotation @xmath130 for @xmath2 is called an _ annotated program _ , and is denoted by @xmath131 .    given an annotation @xmath130 for @xmath2 , @xmath132 denotes the unfolding rule which given a goal @xmath3 computes @xmath133 by unfolding the leftmost atom in @xmath3 and then continously unfolds leftmost reducible atoms until an sld - tree is obtained with only non - reducible atoms in the leaves .",
    "syntactically we represent an annotation for @xmath2 by underlining the predicate symbol of reducible literals .",
    "let @xmath131 be the following annotated program    _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ @xmath134 + @xmath135 + @xmath136 _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _    let @xmath89 = @xmath137",
    ". then @xmath108 = @xmath138 is a globally safe _ btc _ for @xmath2 .",
    "for example the goal @xmath139 is safe wrt @xmath89 and unfolding it according to @xmath132 will lead ( via the intermediate goals @xmath140 and @xmath141 ) to the empty goal @xmath127 which is safe wrt @xmath89 .",
    "note that every selected atom is safe wrt @xmath89 , hence @xmath108 is actually also locally safe for @xmath2 .",
    "also note that @xmath142 , where @xmath143 marks every literal as non - reducible , is _ not _ a safe _ btc _ for @xmath2 .",
    "for instance , given the goal @xmath139 the unfolding rule @xmath144 just performs one unfolding step and thus stops at the goal @xmath140 which contains the unsafe atom @xmath145 .",
    "from now on we will only use unfolding rules of the form @xmath132 obtained from an annotation @xmath130 and our _ btas _ will thus return results of the form @xmath146 .",
    "given we have a btc for a program @xmath2 , in order to arrive at a concrete instance of procedure  [ skeleton : pdalgorithm ] we now only need a ( safe ) generalisation operation , which we define in the following .    [ def : gen - delta ]",
    "we first define a family of mappings @xmath147 from terms to terms , parameterised by types , inductiely as follows :    * @xmath148 , for any term @xmath58 * @xmath149 , for any term @xmath58 and where @xmath150 is a fresh variable * @xmath151 = @xmath152 ,   where @xmath45 are @xmath40 distinct fresh variables * @xmath153 = @xmath154 , if there exists a ground instance in @xmath49 of the form @xmath155 .",
    "let @xmath89 be a division for some program @xmath2 .",
    "we then define the partial mapping @xmath156 from atoms to atoms by :    * @xmath157 if @xmath158 @xmath87 @xmath159 such that @xmath160 .",
    "we also define the generalisation operation @xmath161 as follows : for a set @xmath27 of atoms which is safe w.r.t .",
    "@xmath89 , @xmath162 is a minimal subset @xmath30 of @xmath163 such that for every element @xmath110 of @xmath31 there exists a variant of @xmath110 in @xmath30 .",
    "for example , if @xmath89 = @xmath164 @xmath165 we have @xmath166 = @xmath37 and @xmath167 = @xmath168 .",
    "we also have that @xmath169 @xmath170 = @xmath171 . + for @xmath90 = @xmath172 ( where @xmath173 is defined in section  [ subsection : off - line - pd ] ) we have that @xmath174))$ ] = @xmath175)$ ] and @xmath176))$ ] is undefined because it is not safe w.rt .",
    "@xmath89 .",
    "as can be seen @xmath156 is in general not total , but is total for atoms safe wrt @xmath89 .",
    "hence , in the context of a globally safe _ bta _ , @xmath156 and @xmath161 will always be defined .    for every division @xmath89 ,",
    "@xmath161 is safe wrt @xmath89 .    based upon this generalisation operation",
    ", we can also define a corresponding renaming and filtering operation :    [ def : filter - delta ] let @xmath177 be a fixed mapping from atoms to natural numbers such that @xmath178 iff @xmath6 and @xmath179 are variants .",
    "we then define @xmath180 as follows : @xmath181 = @xmath182 , where @xmath183 , @xmath38 is the predicate symbol of @xmath6 , and @xmath184 are the variables appearing in @xmath185 .",
    "the purpose of the mapping @xmath177 is to assign to every specialised atom ( i.e. , atoms of the form @xmath185 ) a unique identifier and predicate name , thus ensuring the independence condition @xcite .",
    "the @xmath180 operation will properly rename instances of these atoms and also filter out static parts , thus improving the efficiency of the residual code @xcite .",
    "for example , given the division @xmath89 = @xmath164 @xmath165 , @xmath186 , and @xmath187 we have that @xmath188 = @xmath189 as well as @xmath190 = @xmath191 .    in the remainder of this paper we will use the following off - line partial deduction method :    ( off - line partial deduction)[algo : bta - pd ]    1 .   perform a globally safe _ bta _ ( possibly by hand ) returning results of the form @xmath138 .",
    "perform procedure  [ skeleton : pdalgorithm ] with @xmath132 as unfolding rule and @xmath161 as generalisation operation .",
    "the initial set of atoms @xmath17 should only contain atoms which are safe wrt @xmath89 .",
    "3 .   construct the specialised program @xmath4 using @xmath180 and the output @xmath192 of procedure  [ skeleton : pdalgorithm ] as follows : @xmath4 = @xmath193 @xmath194 @xmath195 @xmath196 @xmath197 @xmath198 .",
    "let @xmath138 be a globally safe _ btc _ for a program @xmath2 .",
    "let @xmath192 be a set of atoms safe wrt @xmath89 . then all sets @xmath99 and @xmath100 arising during the execution of procedure  [ algo : bta - pd ] are safe wrt @xmath89 .",
    "notably , if procedure  [ algo : bta - pd ] terminates then the final set @xmath192 will be safe wrt @xmath89 .",
    "however , none of our notions of safety actually ensure ( local or global ) termination of procedure  [ algo : bta - pd ] .",
    "termination is thus another issue ( orthogonal to safety ) which a _ bta _ has to worry about .",
    "basically , the annotation @xmath130 has to be such that for all atoms @xmath6 which are safe wrt @xmath89 , @xmath132 returns a finite sldnf - tree @xmath7 for @xmath199 .",
    "furthermore , @xmath89 has to be such that @xmath161 ensures that only finitely many atoms can appear at the global level .",
    "we will return to this issue in section  [ section : bta ] .",
    "we now illustrate procedure  [ algo : bta - pd ] on a relatively simple example .",
    "[ example : parser ] we use a small generic parser for a set of languages which are defined by grammars of the form @xmath200 ( where @xmath201 is a terminal symbol and @xmath202 is a placeholder for a terminal symbol ) .",
    "the example is adapted from @xcite and the ( annotated ) parser @xmath2 is depicted in figure  [ figure : parser ] .",
    "the first argument to @xmath203 is the value for @xmath202 while the other two arguments represent the string to be parsed as a difference list",
    ".    1 .   given the initial division @xmath204 @xmath205 , a _",
    "bta _ might return @xmath146 with @xmath206 @xmath207 @xmath208 @xmath209 and where @xmath130 is represented in figure  [ figure : parser ] .",
    "it can be seen that @xmath108 is a globally and locally safe _ btc _ for @xmath2 .",
    "2 .   let us now perform the proper partial deduction for @xmath210 .",
    "note that the atom @xmath211 is safe wrt @xmath212 ( and hence also wrt @xmath89 ) .",
    "unfolding the atom in @xmath17 yields the sld - tree in fig .  [",
    "figure : parser - unfold ] .",
    "we see that the only atomin the leaves is @xmath213 and we obtain @xmath214 ( modulo variable renaming ) .",
    "3 .   the specialised program before and after filtering is depicted in figure  [ figure : parser - spec ] . note that , if one wishes to call the filtered version in exactly the same way as the unfiltered one has to add the clause @xmath215 .",
    "[ cols= \" < \" , ]     the conducted experiments show that the approach is feasible and can be automated .",
    "however , some issues regarding the current binding - time analysis remain .",
    "the analysis basically deals with boolean binding - times : either a value is instantiated enough with respect to a norm , or it is not .",
    "recent research @xcite shows that termination proofs can be constructed by measuring the size of a term by means of a number of simple norms rather than using a single sophisticated norm .",
    "these simple norms basically count the number of subterms of the term that are of a particular type . in the presence of type information",
    "these norms can be constructed automatically . when combined with information that denotes",
    "whether further instantiating a term can introduce more subterms of the particular type they provide a more fine - grained characterisation of a term s size and instantiation .",
    "we conjecture such a more detailed characterisation to be a powerful and promising mechanism to derive an automatic binding - time analysis capable of constructing more precise binding - types .",
    "also note that the current analysis only produces monovariant divisions .",
    "polyvariance of the analysis can in principle be obtained by allowing several calls to the same predicate in the abstract callset , creating a new variant of the predicate definition for each abstract call and checking termination of each such predicate separately . in summary , at least for the experiments in tables  [ table : bta : benchmarks ] and [ table : speedups2 ] , we can conclude that online systems are to be preferred  both in terms of speed and quality of the specialised code  in one - shot situations where no expert user is available to perform the annotation . nonetheless , the quality of the fully automatic logen is satisfactory and the cost of the binding - time analysis will usually be recovered already after a few specialisations .",
    "this means that the fully automatic logen might be useful in situations were the same program is specialised multiple times and the specialisation times itself are of utmost importance .",
    "further work is needed to extend and refine the binding - time analysis and to establish its scaling properties for larger programs .",
    "[ section : discussion ]      the first hand - written compiler generator based on partial evaluation principles was , in all probability , the system _ redcompile _ @xcite for a dialect of lisp . since then",
    "successful compiler generators have been written for many different languages and language paradigms @xcite .    in the context of definite clause grammars and parsers based on them , the idea of hand writing",
    "the compiler generator has also been used in @xcite .",
    "however , it is not based on ( off - line ) partial deduction . also the construction of our program @xmath216 ( definition  [ def : pul - transf ] ) is related to the idea of _ abstract compilation _ @xcite . in abstract compilation a program @xmath2 is first transformed and abstracted .",
    "evaluation of this transformed program corresponds to the actual abstract interpretation analysis of @xmath2 . in our case concrete execution of @xmath216 performs ( part of ) the partial deduction process .",
    "another similar idea has also been used in @xcite to calculate abstract answers .",
    "finally , @xcite uses a source - to - source transformation similar to ours to compute trace terms for the global control of logic and functional program specialisation ( however , the specialisation technique itself is still basically online ) .",
    "the local control component of our generating extensions is still rather limited : either a call is always reducible or never reducible . to remedy this problem , and to allow any kind of partially instantiated data , an extension of our cogen approach has been developed in @xcite .",
    "this approach uses a sounding analysis ( at specialisation time ) to measure the minimum depth of partially instantiated terms .",
    "the result of this analysis is then used to control the unfolding and ensure termination .",
    "this approach allows more aggressive unfolding than the technique presented in this paper , passing the kmp - test and rivalling online systems in terms of flexibility . due to the sounding analysis",
    ", however , it is not fully offline . in terms of speed of the specialisation process",
    ", it is hence slower than our fully offline cogen approach ( but still much faster than online systems such as mixtus or ecce ) .",
    "also , @xcite only addresses the local control component and it is still unclear how it can be extended for the global control ( the prototype in @xcite uses the online ecce system for global control ; to this end trace terms were built up in the generating extension like in @xcite ) .",
    "although our approach is closely related to the one for functional programming languages there are still some important differences .",
    "since computation in our cogen is based on unification , a variable is not forced to have a fixed binding time assigned to it .",
    "in fact the binding - time analysis is only required to be safe , and this does not enforce this restriction .",
    "consider , for example , the following program :    ....    g(x ) : - p(x),q(x )    p(a ) .",
    "q(a ) . ....",
    "if the initial division @xmath96 states that the argument to g is dynamic , then @xmath96 is safe for the program and the unfolding rule that unfolds predicates p and q. the residual program that one gets by running the generating extensions is :    ....    g__0(a ) . ....",
    "in contrast to this any cogen for a functional language known to us will classify the variable x in the following analogous functional program ( here exemplified in scheme ) as dynamic :    ....    ( define ( g x ) ( and ( equal ? x a ) ( equal ?",
    "x a ) ) ) ....    and the residual program would be identical to the original program .",
    "one could say that our system allows divisions that are not _ uniformly _ congruent in the sense of launchbury @xcite and essentially , our system performs specialisation that a partial evaluation system for a functional language would need some form of _ driving _",
    "@xcite to be able to do .",
    "however , our divisions are still congruent : the value of a static variable can not depend on a dynamic value . in the above example , the value of @xmath202 within the call @xmath217 , if reached , is always going to be @xmath201 , no matter what the argument to g is .      some built - ins can be treated in a more refined fashion than described in section  [ section : cogen - impure ] .",
    "for instance , for a call var(x ) which is non - reducible we could still check whether the call fails or succeeds in the generating extension .",
    "if the call fails , we know that it will definitely fail at runtime as well . in that case we do nt have to generate code and we thus achieve improved specialisation over a purely offline approach .",
    "if the call var(x ) succeeds , however , we have gained nothing and still have to perform var(x ) at runtime .    similarly , for a call such as ground(x ) , if it succeeds in the generating extension we can simply generate true in the specialised program . in that case we have again improved the efficiency of the specialised program . if , on the other hand , ground(x ) fails in the generating extension it might still succeed at runtime : we have to generate the code ground(x ) and have gained nothing .",
    "the rules below cater for such a mixline @xcite treatment of some built - ins .",
    "the code of the @xmath0 in appendix  [ appendix : cogen ] uses these optimisations if a mixcall annotation is used ( these annotations have not been used for the experimental results in section  [ section : benchmarks ] ) .",
    "it also contains a mixline conditional , which reduces the conditional to the then branch ( respectively else branch ) if the test definitely succeeds ( respectively definitely fails ) in the generating extension .",
    "similarly , one can also produce a new binding - type , called mix , which lies in between static and dynamic @xcite .",
    "basically , mix behaves like static for the generalisation @xmath156 ( definition  [ def : gen - delta ] ) but like dynamic for filtering @xmath180 ( definition  [ def : filter - delta ] ) .",
    "the former means that an argument marked as mix will not be abstracted away by @xmath156 , while the latter allows such an argument to contain variables .",
    "again , the code for these improvements can be found in appendix  [ appendix : cogen ] .",
    "another worthwhile improvement is to enable _ mixline _ unfolding of predicates . in other words , instead of either always or never unfolding a predicate , one would like to either unfold the predicate or not based upon some ( simple ) criterion .",
    "this improvement can be achieved , without having to change the @xmath0 itself , by modifying the annotation process .",
    "indeed , instead of marking a call @xmath101 either as reducible or non - reducible we simply insert a static conditional into the annotated program : ( @xmath219 - > @xmath220 ; @xmath101 ) .",
    "thus , if @xmath219 succeeds the generating extension will unfold the call , otherwise it will be memoised .",
    "we have actually used these improvements to produce a mixline annotation of the @xmath221 benchmark from section  [ section : benchmarks ] .",
    "the results of this experiment ( after some very simple post - processing ) is as follows .",
    "@xmath222    note that logen now outperforms mixtus , passes the kmp - test ( actually , even without the post - processing ; see @xcite ) .",
    "in addition to extending our _ bta _ to generate hide_nf annotations and to fully integrate the _ bta _ into the logen system , one might also think of further extending its capabilities and domain of application .",
    "first , one could try to extend the @xmath0 approach so that it can achieve multi - level specialisation  la @xcite .",
    "one could also try to use the @xmath0 for run time code generation .",
    "a first version of the latter has in fact already been implemented ; this actually does not require all that many modifications to our @xmath0 .",
    "the former also seems to be reasonably straightforward to achieve .",
    "another interesting recent development is fragmental specialisation @xcite , where the idea is to specialise fragments of the code ( such as modules ) in the order in which they arrive . it should be possible to add such a capability to our @xmath0 , by using co - routining features ( e.g. , of sicstus prolog ) so as to suspend , for predicates @xmath38 defined in other fragments , calls to the corresponding @xmath223 or @xmath224 predicates until the fragment defining",
    "@xmath38 is available .",
    "one might also investigate whether the @xmath0 approach can be ported to other logical programming languages .",
    "it seems essential that such languages have some metalevel built - in predicates , like prolog s findall and call predicates , for the method to be efficient .",
    "further work is needed to establish whether it is possible to adapt the @xmath0 approach for gdel @xcite or mercury @xcite so that it still produces efficient generating extensions .",
    "finally , it also seems natural to investigate to what extent more powerful control techniques ( such as characteristic trees @xcite , trace terms @xcite or the local control of @xcite ) and specialisation techniques ( like conjunctive partial deduction @xcite ) can be incorporated into the @xmath0 , while keeping its advantages in terms of efficiency .      in the present paper",
    "we have formalised the concept of a _ binding - type analysis _ , allowing the treatment of _ partially static _ structures , in a ( pure ) logic programming setting and how to obtain a generic procedure for offline partial deduction from such an analysis .",
    "we have then developed the @xmath0 approach for offline specialisation , reaping the benefits of self - application without having to write a self - applicable specialiser .",
    "the resulting system , called logen , is surprisingly compact and can handle partially static data structures , declarative and non - declarative built - ins , disjunctions , conditionals , and negation .",
    "we have shown that the resulting system achieves fast specialisation in situations where the same program is re - specialised multiple times .",
    "we have also overcome several limitations of earlier offline systems and shown that logen can be applied on a wide range of natural logic programs and that the resulting specialisation is also very good , sometimes even surpassing that of existing online systems .",
    "we have also developed the foundation for a fully automatic binding - type analysis for the logen system , and have evaluated its performance on several examples .",
    "we thank michael codish , bart demoen , danny de schreye , andr de waal , robert glck , gerda janssens , neil jones , bern martens , torben mogensen , ulrich neumerkel , kostis sagonas , and peter thiemann for interesting discussions and contributions on this work .",
    "my thanks also go to laksono adhianto for developing the graphical user interface . finally , we are very grateful to anonymous referees for their helpful comments and constructive criticism .",
    "xx    andersen , l.  o. ( 1994 ) .",
    ", phd thesis , diku , university of copenhagen .",
    "( diku report 94/19 ) .",
    "apt , k.  r. and marchiori , e. ( 1994 ) .",
    "reasoning about prolog programs : from modes through types to assertions , _ formal aspects of computing _ * 6*(6a ) :  743765 .",
    "beckman , l. , haraldson , a. , oskarsson , . and sandewall , e. ( 1976 ) . a partial evaluator and its use as a programming tool , _ artificial intelligence _ * 7 * :  319357 .",
    "benkerimi , k. and hill , p.  m. ( 1993 ) . supporting transformations for the partial evaluation of logic programs , _ journal of logic and computation _ * 3*(5 ) :  469486 .",
    "birkedal , l. and welinder , m. ( 1994 ) .",
    "hand - writing program generator generators , _ in _ m.  hermenegildo and j.  penjam ( eds ) , _ programming language implementation and logic programming .",
    "proceedings , proceedings of plilp91 _ , lncs 844 , springer - verlag , madrid , spain , pp",
    ".  198214 .",
    "bol , r. ( 1993 ) .",
    "loop checking in partial deduction , _ the journal of logic programming _ * 16*(1&2 ) :  2546 .",
    "bondorf , a. and jrgensen , j. ( 1993 ) .",
    "efficient analyses for realistic off - line partial evaluation , _ journal of functional programming _ * 3*(3 ) :  315346 .",
    "bondorf , a. , frauendorf , f. and richter , m. ( 1990 ) .",
    "an experiment in automatic self - applicable partial evaluation of prolog , _ technical report 335 _ , lehrstuhl informatik v , university of dortmund .",
    "bruynooghe , m. , de  schreye , d. and martens , b. ( 1992 ) . a general criterion for avoiding infinite unfolding during partial deduction , _ new generation computing _ * 11*(1 ) :  4779 .",
    "bruynooghe , m. , leuschel , m. and sagonas , k. ( 1998 ) . a polyvariant binding - time analysis for off - line partial deduction , _ in _ c.  hankin ( ed . ) , _ programming languages and systems , proc . of esop98 ,",
    "part of etaps98 _ , springer - verlag , lisbon , portugal , pp .",
    "lncs 1381 .",
    "chen , w. , kifer , m. and warren , d.  s. ( 1989 ) .",
    "a first - order semantics of higher - order logic programming constructs , _ in _",
    "e.  l. lusk and r.  a. overbeek ( eds ) , _ logic programming : proceedings of the north american conference _ , mit press , pp .",
    "10901114 .",
    "codish , m. and demoen , b. ( 1995 ) . analyzing logic programs using `` prop''-ositional logic programs and a magic wand , _ the journal of logic programming _ * 25*(3 ) :  249274 .",
    "codish , m. and taboch , c. ( 1999 ) . a semantic basis for the termination analysis of logic programs , _ journal of logic programming _ * 41*(1 ) :  103123 .    consel , c. ( 1993 ) .",
    "polyvariant binding - time analysis for applicative languages , _ pepm93 _ ,",
    "acm , pp .",
    "consel , c. and danvy , o. ( 1993 ) .",
    "tutorial notes on partial evaluation , _ proceedings of acm symposium on principles of programming languages ( popl93 ) _ , acm press , charleston , south carolina , pp .  493501 .",
    "cosmadopoulos , y. , sergot , m. and southwick , r.  w. ( 1991 ) .",
    "data - driven transformation of meta - interpreters : a sketch , _ in _",
    "h.  boley and m.  m. richter ( eds ) , _ proceedings of the international workshop on processing declarative knowledge ( pdk91 ) _ , vol .",
    "567 of _ lnai _ , springer verlag , kaiserslautern , frg , pp .  301308 .",
    "de  schreye , d. , glck , r. , jrgensen , j. , leuschel , m. , martens , b. and srensen , m.  h. ( 1999 ) .",
    "conjunctive partial deduction : foundations , control , algorithms and experiments , _ the journal of logic programming _ * 41*(2 & 3 ) :  231277 .",
    "fujita , h. and furukawa , k. ( 1988 ) . a self - applicable partial evaluator and its use in incremental compilation , _ new generation computing _ * 6*(2 & 3 ) :  91118 .",
    "futamura , y. ( 1971 ) . partial evaluation of a computation process  an approach to a compiler - compiler , _ systems , computers , controls _ * 2*(5 ) :  4550 .",
    "gallagher , j. ( 1991 ) . a system for specialising logic programs , _ technical report tr-91 - 32 _ , university of bristol .",
    "gallagher , j. ( 1993 ) .",
    "tutorial on specialisation of logic programs , _ proceedings of pepm93 , the acm sigplan symposium on partial evaluation and semantics - based program manipulation _",
    ", acm press , pp .",
    "gallagher , j. and bruynooghe , m. ( 1990 ) . some low - level transformations for logic programs , _ in _ m.  bruynooghe ( ed . ) , _ proceedings of meta90 workshop on meta programming in logic _ , leuven , belgium , pp .",
    "229244 .",
    "gallagher , j. and bruynooghe , m. ( 1991 ) .",
    "the derivation of an algorithm for program specialisation , _ new generation computing _ * 9*(3 & 4 ) :  305333 .",
    "gallagher , j. and lafave , l. ( 1996 ) .",
    "regular approximations of computation paths in logic and functional languages , _ in _ o.  danvy , r.  glck and p.  thiemann ( eds ) , _ partial evaluation , international seminar _ , lncs 1110 , springer - verlag , schlo  dagstuhl , pp",
    ".  115136 .",
    "genaim , s. , codish , m. , gallagher , j. and lagoon , v. ( 2002 ) . combining norms to prove termination , _ in _ t.  cortesi ( ed . ) , _ pre - proceedings workshop on verification , model checking and abstract interpretation , vmcai2002 , venice_.    glck , r. and jrgensen , j. ( 1995 ) .",
    "efficient multi - level generating extensions for program specialization , _ in _ s.  swierstra and m.  hermenegildo ( eds ) , _ programming languages , implementations , logics and programs ( plilp95 ) _ , lncs 982 , springer - verlag , utrecht , the netherlands , pp .  259278 .",
    "glck , r. and srensen , m.  h. ( 1994 ) .",
    "partial deduction and driving are equivalent , _ in _",
    "m.  hermenegildo and j.  penjam ( eds ) , _ programming language implementation and logic programming .",
    "proceedings , proceedings of plilp94 _ , lncs 844 , springer - verlag , madrid , spain , pp .",
    "165181 .",
    "glck , r. , jrgensen , j. , martens , b. and srensen , m.  h. ( 1996 ) . controlling conjunctive partial deduction of definite logic programs , _ in _",
    "kuchen and s.  swierstra ( eds ) , _ proceedings of plilp96 _ , lncs 1140 , springer - verlag , aachen , germany , pp .",
    "152166 .",
    "gurr , c.  a. ( 1994 ) . , phd thesis , department of computer science , university of bristol .",
    "helsen , s. and thiemann , p. ( 2000 ) .",
    "fragmental specialization , _ in _",
    "w.  taha ( ed . ) , _ proceedings of saig00 _ , lncs 1924 , springer - verlag , pp .",
    "hermenegildo , m. , warren , r. and debray , s.  k. ( 1992 ) .",
    "global flow analysis as a practical compilation tool , _ the journal of logic programming _ * 13*(4 ) :  349366 .",
    "hill , p. and gallagher , j. ( 1998 ) .",
    "meta - programming in logic programming , _ in _",
    "d.  m. gabbay , c.  j. hogger and j.  a. robinson ( eds ) , _ handbook of logic in artificial intelligence and logic programming _ , vol .  5 , oxford science publications , oxford university press , pp .",
    "421497 .",
    "hill , p. and lloyd , j.  w. ( 1994 ) .",
    ", mit press .",
    "holst , c.  k. ( 1989 ) .",
    "syntactic currying : yet another approach to partial evaluation , _ technical report _",
    ", diku , department of computer science , university of copenhagen .",
    "holst , c.  k. and launchbury , j. ( 1991 ) .",
    "handwriting cogen to avoid problems with static typing , _ draft proceedings , fourth annual glasgow workshop on functional programming , skye , scotland _ , glasgow university , pp .",
    "210218 .",
    "jones , n.  d. , gomard , c.  k. and sestoft , p. ( 1993 ) . , prentice hall .",
    "jones , n.  d. , sestoft , p. and sndergaard , h. ( 1989 . ) . mix : a self - applicable partial evaluator for experiments in compiler generation , _ lisp and symbolic computation _ * 2*(1 ) :  950 .",
    "jrgensen , j. and leuschel , m. ( 1996 ) .",
    "efficiently generating efficient generating extensions in prolog , _ in _",
    "o.  danvy , r.  glck and p.  thiemann ( eds ) , _ partial evaluation , international seminar _ , lncs 1110 , springer - verlag , schlo dagstuhl , pp .  238262 .",
    "komorowski , j. ( 1992 ) .",
    "an introduction to partial deduction , _ in _",
    "a.  pettorossi ( ed . ) , _ proceedings meta92 _ , lncs 649 , springer - verlag , pp .  4969 .",
    "launchbury , j. ( 1991 ) .",
    ", distinguished dissertations in computer science , cambridge university press .",
    "leuschel , m. ( 1996 - 2000 ) .",
    "the ecce partial deduction system and the dppd library of benchmarks , obtainable via http://www.ecs.soton.ac.uk/~mal .",
    "leuschel , m. and bruynooghe , m. ( 2002 ) .",
    "logic program specialisation through partial deduction : control issues , _ theory and practice of logic programming _ * 2*(4 & 5 ) :  461515 .",
    "leuschel , m. and de  schreye , d. ( 1998 ) . constrained partial deduction and the preservation of characteristic trees , _ new generation computing _ * 16 * :  283342 .    leuschel , m. and lehmann , h. ( 2000 ) . solving coverability problems of petri nets by partial deduction , _ in _",
    "m.  gabbrielli and f.  pfenning ( eds ) , _ proceedings of ppdp2000 _ , acm press , montreal , canada , pp .",
    "268279 .",
    "leuschel , m. and srensen , m.  h. ( 1996 ) .",
    "redundant argument filtering of logic programs , _ in _",
    "j.  gallagher ( ed . ) , _ logic program synthesis and transformation .",
    "proceedings of lopstr96 _ , lncs 1207 , springer - verlag , stockholm , sweden , pp .",
    "83103 .",
    "leuschel , m. , de  schreye , d. and de  waal , a. ( 1996 ) .",
    "a conceptual embedding of folding into partial deduction : towards a maximal integration , _ in _ m.  maher ( ed . ) , _ proceedings of the joint international conference and symposium on logic programming jicslp96 _ , mit press , bonn , germany , pp .",
    "319332 .",
    "leuschel , m. , martens , b. and de  schreye , d. ( 1998 ) .",
    "controlling generalisation and polyvariance in partial deduction of normal logic programs , _ acm transactions on programming languages and systems _ * 20*(1 ) :  208258 .",
    "lloyd , j.  w. ( 1987 ) .",
    ", springer - verlag .",
    "lloyd , j.  w. and shepherdson , j.  c. ( 1991 ) .",
    "partial evaluation in logic programming , _ the journal of logic programming _ * 11*(3 & 4 ) :  217242 .",
    "martens , b. and de schreye , d. ( 1995 ) .",
    "two semantics for definite meta - programs , using the non - ground representation , _ in _",
    "k.  r. apt and f.  turini ( eds ) , _ meta - logics and logic programming _ , mit press , pp .  5782 .",
    "martens , b. and de schreye , d. ( 1996 ) .",
    "automatic finite unfolding using well - founded measures , _ the journal of logic programming _ * 28*(2 ) :  89146 .",
    "martens , b. and gallagher , j. ( 1995 ) . ensuring global termination of partial deduction while allowing flexible polyvariance , _ in _ l.  sterling ( ed . ) , _ proceedings iclp95 _ , mit press , kanagawa , japan , pp",
    ".  597613 .",
    "martin , j. and leuschel , m. ( 1999 ) . sonic partial deduction , _ proceedings of the third international ershov conference on perspectives of system informatics _ ,",
    "lncs 1755 , springer - verlag , novosibirsk , russia , pp .",
    "101112 .",
    "mogensen , t. and bondorf , a. ( 1992 ) .",
    "logimix : a self - applicable partial evaluator for prolog , _ in _ k .- k . lau and t.  clement ( eds ) ,",
    "_ _ logic program synthesis and transformation .",
    "_ proceedings of lopstr92 _ , springer - verlag , pp .  214227 .",
    "neumann , g. ( 1990 ) . transforming interpreters into compilers by goal classification , _ in _",
    "m.  bruynooghe ( ed . ) , _ proceedings of meta90 workshop on meta programming in logic _ ,",
    "leuven , belgium , pp .",
    "205217 .",
    "neumann , g. ( 1991 ) . a simple transformation from prolog - written metalevel interpreters into compilers and its implementation , _ in _",
    "a.  voronkov ( ed . ) , _ _ logic programming .",
    "_ proceedings of the first and second russian conference on logic programming _ , lncs 592 , springer - verlag , pp .  349360 .",
    "pettorossi , a. and proietti , m. ( 1994 ) .",
    "transformation of logic programs : foundations and techniques , _ the journal of logic programming _ * 19 & 20 * :  261320 .",
    "prestwich , s. ( 1992 ) .",
    "the paddy partial deduction system , _ technical report ecrc-92 - 6 _ , ecrc , munich , germany .",
    "romanenko , s.  a. ( 1988 ) .",
    "a compiler generator produced by a self - applicable specializer can have a surprisingly natural and understandable structure , _ in _",
    "d.  bjrner , a.  p. ershov and n.  d. jones ( eds ) , _ partial evaluation and mixed computation _ , north - holland , pp .",
    "445463 .",
    "sahlin , d. ( 1993 ) .",
    "mixtus : an automatic partial evaluator for full prolog , _ new generation computing _ * 12*(1 ) :  751 .",
    "somogyi , z. , henderson , f. and conway , t. ( 1996 ) .",
    "the execution algorithm of mercury : an efficient purely declarative logic programming language , _ the journal of logic programming _ * 29*(13 ) :  1764",
    ".    srensen , m.  h. and glck , r. ( 1995 ) .",
    "an algorithm of generalization in positive supercompilation , _ in",
    "_ j.  w. lloyd ( ed . ) , _ proceedings of ilps95 , the international logic programming symposium _ , mit press , portland , usa , pp .  465479 .",
    "srensen , m.  h. and glck , r. ( 1999 ) .",
    "introduction to supercompilation , _ in _ j.  hatcliff , t.   .",
    "mogensen and p.  thiemann ( eds ) , _ partial evaluation  practice and theory _ , lncs 1706 , springer - verlag , copenhagen , denmark , pp .",
    "246270 .",
    "sterling , l. and shapiro , e. ( 1986 ) .",
    ", mit press .",
    "tarau , p. and de  bosschere , k. ( 1994 ) . memoing techniques for logic programs , _ in _ y.  deville ( ed . ) , _ _ logic program synthesis and transformation . _",
    "proceedings of lopstr93 _ , workshops in computing , springer - verlag , louvain - la - neuve , belgium , pp .  196209 .",
    "thiemann , p. ( 1996 ) .",
    "cogen in six lines , _ international conference on functional programming _ , acm press , pp .",
    "180189 .",
    "turchin , v.  f. ( 1986 ) .",
    "the concept of a supercompiler , _ acm transactions on programming languages and systems _ * 8*(3 ) :  292325 .",
    "vanhoof , w. ( 2000 ) . binding - time analysis by constraint solving : a modular and higher - order approach for mercury , _ in _",
    "m.  parigot and a.  voronkov ( eds ) , _ proceedings of lpar2000 _ , lnai 1955 , springer - verlag , pp .",
    "399416 .",
    "vanhoof , w. and bruynooghe , m. ( 2001 ) .",
    "inding - time annotations without binding - time analysis , _ in _ r.  nieuwenhuis and a.  voronkov ( eds ) , _",
    "logic for programming , artificial intelligence , and reasoning , 8th international conference , proceedings _ , vol .",
    "2250 of _ lecture notes in artificial intelligence _ , springer - verlag , pp .",
    "707722 .",
    "vanhoof , w. and bruynooghe , m. ( 2002 ) .",
    "hen size does matter - termination analysis for typed logic programs , _ in _",
    "a.  pettorossi ( ed . ) , _ logic - based program synthesis and transformation , proceedings of lopstr 2001 _ , vol .",
    "2372 of _ lecture notes in computer science _ , springer - verlag , pp .",
    "129147 .",
    "vanhoof , w. and martens , b. ( 1997 ) . to parse or not to parse , _ in _ n.  fuchs ( ed . ) , _ logic program synthesis and transformation .",
    "proceedings of lopstr97 _ , lncs 1463 , leuven , belgium , pp",
    ".  322342 .",
    "venken , r. and demoen , b. ( 1988 ) . a partial evaluation system for prolog : theoretical and practical considerations , _ new generation computing _ * 6*(2 & 3 ) :  279290 .",
    "yardeni , e. , frhwirth , t. and shapiro , e. ( 1992 ) .",
    "polymorphically typed logic programs , _ in _",
    "f.  pfenning ( ed . ) , _ types in logic programming _ , mit press , pp .",
    "this appendix contains the listing of the cogen .",
    "it works on an annotated version of the program to be specialised which contains definitions for the following predicates :    * residual : defines the predicates by which the generating extension is to be called , as well as the predicates which are residualised . *",
    "filter : the division for the residual predicates * ann_clause : the annotated clauses where calls in the body are annotated by : * * unfold for reducible user - defined predicates , and memo for non - reducible user - defined predicates , * * call for reducible primitives ( i.e. , built - ins or open predicates ; c.f",
    ". , section  [ section : cogen - impure ] ) , and rescall for non - reducible user - defined predicates , * * semicall for non - reducible primitives to be specialised in a mixline fashion ( c.f . , section  [ subsection : mixline ] ) , * * ucall for a call primitive calling a reducible user - defined predicate and mcall for a call primitive calling a non - reducible user - defined predicate ( c.f .",
    ", section  [ section : call - pred ] ) , * * if and resif for reducible and non - reducible conditionals respectively , and semif for conditionals to be specialised in a mixline fashion ( c.f . , section  [ subsection : mixline ] ) , * * not and resnot for reducible and non - reducible negations respectively , * * ; and resdisj for reducible and non - reducible disjunctions respectively , * * hide , hide_nf to prevent the propagation of bindings and failure .",
    "an example annotated file can be found in appendix  [ appendix : parser ] .    .... / * ----------- * / / *   c o g e n   * / / * ----------- * / : - ensure_consulted('pp ' ) .",
    "cogen : -    findall(c , memo_clause(c),clauses1 ) ,    findall(c , unfold_clause(c),clauses2 ) ,    pp(clauses1 ) ,    pp(clauses2 ) .",
    "memo_clause(clause(head,(find_pattern(call , v ) - >                            true ;                            ( insert_pattern(gcall , hd ) ,                             findall(nclause ,                                     ( rcall , nclause = clause(hd , body ) ) ,                                     nclauses ) ,                             pp(nclauses ) ,                             find_pattern(call , v ) ) ) ) ) : -    residual(call ) , cogen_can_generalise(call ) , generalise(call , gcall ) ,    add_extra_argument(\"_u\",gcall , body , rcall ) ,    add_extra_argument(\"_m\",call , v , head ) .",
    "memo_clause(clause(head,(find_pattern(call , v ) - >                            true ;                            ( generalise(call , gcall ) ,                             add_extra_argument(\"_u\",gcall , body , rcall ) ,                             insert_pattern(gcall , hd ) ,                             findall(nclause ,                                     ( rcall , nclause = clause(hd , body ) ) ,                                     nclauses ) ,                             pp(nclauses ) ,                             find_pattern(call , v ) )                          ) ) ) : -    residual(call ) , not(cogen_can_generalise(call ) ) ,    add_extra_argument(\"_m\",call , v , head ) .",
    "unfold_clause(clause(rescall , flatresbody ) ) : -    ann_clause(_,call , body ) ,    add_extra_argument(\"_u\",call , flatvars , rescall ) ,    body(body , resbody , vars ) , flatten(resbody , flatresbody ) , flatten(vars , flatvars ) .",
    "body((g , gs),gres , vres ) : -    body(g , g1,v),filter_cons(g1,gs1,gres , true ) ,    filter_cons(v , vs , vres , true ) , body(gs , gs1,vs ) .",
    "body(unfold(call),rescall , v ) : - add_extra_argument(\"_u\",call , v , rescall ) .",
    "body(memo(call),avcall , vfilteredcall ) : -          add_extra_argument(\"_m\",call , vfilteredcall , avcall ) .",
    "body(true , true , true ) .",
    "body(call(call),call , true ) .",
    "body(rescall(call),true , call ) .",
    "body(semicall(call),genexcall , rescall ) : -          specialise_imperative(call , genexcall , rescall ) .",
    "body(if(g1,g2,g3 ) ,     / * static if : * /       ( ( rg1 ) - > ( rg2,(v = vs2 ) ) ; ( rg3,(v = vs3 ) ) ) , v ) : -          body(g1,rg1,_vs1 ) , body(g2,rg2,vs2 ) , body(g3,rg3,vs3 ) .",
    "body(resif(g1,g2,g3 ) , / * dynamic if : * /       ( rg1,rg2,rg3 ) , / * rg1,rg2,rg3 should n't fail and be determinate * /       ( ( vs1 ) - > ( vs2 ) ; ( vs3 ) ) ) : -          body(g1,rg1,vs1 ) , body(g2,rg2,vs2 ) , body(g3,rg3,vs3 ) .",
    "body(semif(g1,g2,g3 ) , / * semi - online if : * /       ( rg1,flatten(vs1,flatvs1 ) ,        ( ( flatvs1 = = true )          - > ( rg2,speccode = vs2 )          ;   ( ( flatvs1 = = fail )              - > ( rg3,speccode = vs3 )              ;   ( rg2,rg3 , ( speccode = ( ( flatvs1 ) - > ( vs2 ) ; ( vs3 ) ) ) )             )       ) ) , speccode ) : -   / * rg1,rg2,rg3 should n't fail and be determinate * /          body(g1,rg1,vs1 ) , body(g2,rg2,vs2 ) , body(g3,rg3,vs3 ) .",
    "body(resdisj(g1,g2),(rg1,rg2),(vs1 ; vs2 ) ) : - / * residual disjunction *",
    "/          body(g1,rg1,vs1 ) , body(g2,rg2,vs2 ) .",
    "body ( ( g1;g2 ) , ( ( rg1,v = vs1 ) ; ( rg2,v = vs2 ) ) , v ) : - / * static disjunction * /          body(g1,rg1,vs1 ) , body(g2,rg2,vs2 ) .",
    "body(not(g1),\\+(rg1),true ) : - body(g1,rg1,_vs1 ) .",
    "body(resnot(g1),rg1,\\+(vs1 ) ) : - body(g1,rg1,vs1 ) .",
    "body(hide_nf(g1),gxcode , rescode ) : -          ( body(g1,rg1,vs1)- >           ( flatten(rg1,flatrg1 ) , flatten(vs1,flatvs1 ) ,              gxcode = ( varlist(g1,varsg1 ) ,                         findall((flatvs1,varsg1),flatrg1,forall1 ) ,                        make_disjunction(forall1,varsg1,rescode ) ) ) ;             ( gxcode = true , rescode = fail ) ) .",
    "body(hide(g1),gxcode , rescode ) : -          ( body(g1,rg1,vs1)- >           ( flatten(rg1,flatrg1 ) , flatten(vs1,flatvs1 ) ,              gxcode = ( varlist(g1,varsg1 ) ,                         findall((flatvs1,varsg1),flatrg1,forall1 ) ,                        forall1 = [ _ | _ ] , / * detect failure * /                        make_disjunction(forall1,varsg1,rescode ) ) ) ;             ( gxcode = true , rescode = fail ) ) .             /",
    "* some special annotations : * / body(ucall(call ) , ( add_extra_argument(\"_u\",call , v , rescall ) , call(rescall ) ) , v ) .",
    "body(mcall(call ) , ( add_extra_argument(\"_m\",call , v , rescall ) , call(rescall ) ) , v ) .",
    "make_disj([],fail ) .",
    "make_disj([h],h ) : - ! .",
    "make_disj([h|t],(h ; dt ) ) : - make_disj(t , dt ) .",
    "make_disjunction([],_,fail ) .",
    "make_disjunction([(h , crg)],rg , flatcode ) : -           ! , simplify_equality(rg , crg , eqcode ) , flatten((eqcode , h),flatcode ) .",
    "make_disjunction([(h , crg)|t],rg,(flatcode ; dist ) ) : -          simplify_equality(rg , crg , eqcode ) , make_disjunction(t , rg , dist ) ,          flatten((eqcode , h),flatcode ) .",
    "specialise_imperative(call , call , call ) : - varlike_imperative(call),!. specialise_imperative(call , ( call - > ( code = true ) ; ( code = call ) ) , code ) : -           groundlike_imperative(call),!. specialise_imperative(x , true , x ) .",
    "varlike_imperative(var(_x ) ) .",
    "varlike_imperative(copy_term(_x,_y ) ) .",
    "varlike_imperative((_x\\==_y ) ) .",
    "groundlike_imperative(ground(_x ) ) .",
    "groundlike_imperative(nonvar(_x ) ) .",
    "groundlike_imperative(_x==_y ) .",
    "groundlike_imperative(atom(_x ) ) .",
    "groundlike_imperative(integer(_x ) ) .",
    "generalise(call , gcall ) : -      ( ( filter(call , argtypes ) , call = .. [ f|fargs ] ,        l_generalise(argtypes , fargs , gargs ) )      - > ( gcall = .. [ f|gargs ] )      ;   ( print ( ' * * * warning : unable to generalise : ' ) , print(call),nl ,          gcall = call ) ) .",
    "cogen_can_generalise(call ) : -      filter(call , argtypes ) ,      static_types(argtypes ) . / * check whether we can filter at cogen time * /    / * types which allow generalisation / filtering at cogen time * / static_types ( [ ] ) .",
    "static_types([static|t ] ) : - static_types(t ) .",
    "static_types([dynamic|t ] ) : - static_types(t ) .",
    "generalise(static , argument , argument ) .",
    "generalise(dynamic,_argument,_freshvariable ) .",
    "generalise(free,_argument,_freshvariable ) .",
    "generalise(nonvar , argument , genargument ) : -      nonvar(argument ) , argument = .. [ f|fargs ] ,      make_fresh_variables(fargs , gargs ) , genargument = .. [ f|gargs ] .",
    "generalise((type1 ; _ type2),argument , genargument ) : -      generalise(type1,argument , genargument ) .",
    "generalise((_type1 ; type2),argument , genargument ) : -      generalise(type2,argument , genargument ) .",
    "generalise(type(f),argument , genargument ) : -      typedef(f , typeexpr ) , generalise(typeexpr , argument , genargument ) .",
    "generalise(struct(f , targs),argument , genargument ) : -      nonvar(argument ) , argument = .. [ f|fargs ] ,      l_generalise(targs , fargs , gargs ) , genargument = .. [ f|gargs ] .",
    "generalise(mix , argument , argument ) . /",
    "* treat as static for generalisation * /    l_generalise ( [ ] , [ ] , [ ] ) .",
    "l_generalise([type1|tt],[a1|at],[g1|gt ] ) : -      generalise(type1,a1,g1 ) , l_generalise(tt , at , gt ) .",
    "make_fresh_variables ( [ ] , [ ] ) .",
    "make_fresh_variables([_|t],[_|ft ] ) : - make_fresh_variables(t , ft ) .",
    "typedef(list(t),(struct ( [ ] , [ ] ) ; struct('.',[t , type(list(t ) ) ] ) ) ) .",
    "typedef(model_elim_literal,(struct(pos,[nonvar ] ) ; struct(neg,[nonvar ] ) ) ) .",
    "add_extra_argument(t , call , v , rescall ) : -    call = .. [ pred|args],res_name(t , pred , respred ) ,    append(args,[v],newargs),rescall = .. [ respred|newargs ] .    res_name(t , pred , respred ) : -    name(pe_sep , t),string_concatenate(pred , pe_sep , respred ) .",
    "filter_cons(h , t , ht , fval ) : -          ( ( nonvar(h),h = fval ) - > ( ht = t ) ; ( ht = ( h , t ) ) ) . ....",
    "the annotated program looks like :    ....    / * file : parser.ann * / static_consult ( [ ] ) . residual(nont ( _ , _ , _ ) ) .",
    "filter(nont(x , t , r),[static , dynamic , dynamic ] ) .",
    "ann_clause(1,nont(x , t , r ) , ( unfold(t(a , t , v)),memo(nont(x , v , r ) ) ) ) .",
    "ann_clause(2,nont(x , t , r ) , ( unfold(t(x , t , r ) ) ) ) .",
    "ann_clause(3,t(x,[x|es],es),true ) . ....",
    "this supplies cogen with all the necessary information about the parser program , this is , the code of the program ( with annotations ) and the result of the binding - time analysis .",
    "the predicate filter defines the division for the program and the predicate residual represents the set @xmath225 in the following way .",
    "if residual(@xmath6 ) succeeds for a call @xmath6 then the predicate symbol @xmath38 of @xmath6 is in @xmath226 and @xmath38 is therefore one of the predicates for which a @xmath227-predicate is going to be generated .",
    "the annotations unfold and memo is used by cogen to determine whether or not to unfold a call .",
    "the generating extension produced by @xmath0 for the annotation @xmath228 is :    .... / * file : parser.gx * / / *   --------------------   * / / *   generating extension   * / / *   --------------------   * / : - logen_reconsult('memo ' ) .",
    ": - logen_reconsult('pp ' ) .",
    "nont_m(b , c , d , e ) : -     ( ( find_pattern(nont(b , c , d),e )     ) - > ( true ) ; (      insert_pattern(nont(b , f , g),h ) ,      findall(i , ( nont_u(b , f , g , j),i = ( clause(h , j))),k ) ,      pp(k ) , find_pattern(nont(b , c , d),e )    ) ) .",
    "nont_u(b , c , d,','(e , f ) ) : - t_u(a , c , g , e ) , nont_m(b , g , d , f ) .",
    "nont_u(h , i , j , k ) : - t_u(h , i , j , k ) .",
    "t_u(l,[l|m],m , true ) .",
    "....    the generating extension is usually executed using nont_m , whereby the last argument is instantated to the filtered version of the call under consideration .",
    "e.g. , to specialise the original program for nont(c , t , r ) we call nont_m(c , t , r , fcall ) , which instantiates fcall to nont__0(t , r ) and prints the following residual program :    ....    nont__0([a|b],c ) : -       nont__0(b , c ) .    nont__0([c|d],d ) . ....    observe that we can use the computed answer substitution for fcall to produce an interface definition clause :    ....    nont(c , t , r ) : - nont__0(t , r ) . ....    this will be done automatically by the logen system when it produces the specialised program .",
    "some other examples which can be handled by simple divisions ( i.e. , using just the binding - types static and dynamic ) , such as an interpreter for the ground representation ( where the overhead is compiled away ) and a `` special '' regular expression parser from @xcite ( where we obtain deterministic automaton after specialisation ) can be found in @xcite .",
    "a possible annotated program of the transpose benchmark program for matrix transposition looks like :    ....    static_consult ( [ ] ) .",
    "residual(transpose(a , b ) ) .",
    "filter(transpose(a , b),[type(list(type(list(dynamic)))),dynamic ] ) .",
    "ann_clause(1,transpose(a,[]),unfold(nullrows(a ) ) ) .    ann_clause(2,transpose(a,[b|c ] ) ,                    ( unfold(makerow(a , b , d)),unfold(transpose(d , c ) ) ) ) .",
    "filter(makerow(a , b , c),[type(list(type(list(dynamic)))),dynamic , dynamic ] ) .",
    "ann_clause(3,makerow([],[],[]),true ) .",
    "ann_clause(4,makerow([[a|b]|c],[a|d],[b|e]),unfold(makerow(c , d , e ) ) ) .",
    "filter(nullrows(a),[type(list(type(list(dynamic ) ) ) ) ] ) .",
    "ann_clause(5,nullrows([]),true ) .",
    "ann_clause(6,nullrows([[]|a]),unfold(nullrows(a ) ) ) .",
    "....    in the above we stipulate that the first argument to transpose will be of type @xmath229 , i.e. , a list skeleton whose elements are in turn list skeletons ( in other words we have a matrix skeleton , without the actual matrix elements ) .",
    "the generating extension produced by @xmath0 then looks like this :    .... / * file : bench / transpose.gx * / / *   --------------------   * / / *   generating extension   * / / *   --------------------   * / : - logen_reconsult('memo ' ) .",
    ": - logen_reconsult('pp ' ) .",
    "transpose_m(b , c , d ) : -     ( ( find_pattern(transpose(b , c),d )     ) - > ( true ) ; (      generalise(transpose(b , c),e ) , add_extra_argument([95,117],e , f , g ) ,      insert_pattern(e , h ) , findall(i , ( g , i = ( clause(h , f))),j ) ,      pp(j ) , find_pattern(transpose(b , c),d )    ) ) .",
    "transpose_u(b,[],c ) : -   nullrows_u(b , c ) . transpose_u(d,[e|f],','(g , h ) ) : - makerow_u(d , e , i , g ) , transpose_u(i , f , h ) .",
    "makerow_u([],[],[],true ) .",
    "makerow_u([[j|k]|l],[j|m],[k|n],o ) : -   makerow_u(l , m , n , o ) .",
    "nullrows_u([],true ) .",
    "nullrows_u([[]|p],q ) : - nullrows_u(p , q ) . ....",
    ".... filter(transpose(a , b ) ,   [ ( struct ( ' [ ] ' , [ ] )   ;        struct('.',[type(list(dynamic)),type(list(dynamic))])),dynamic ] ) .",
    "filter(makerow(a , b , c),[type(list(type(list(dynamic)))),dynamic , dynamic ] ) . ...."
  ],
  "abstract_text": [
    "<S> the so called `` @xmath0 approach '' to program specialisation , writing a compiler generator instead of a specialiser , has been used with considerable success in partial evaluation of both functional and imperative languages . </S>",
    "<S> this paper demonstrates that the @xmath0 approach is also applicable to the specialisation of logic programs ( called partial deduction ) and leads to effective specialisers . </S>",
    "<S> moreover , using good binding - time annotations , the speed - ups of the specialised programs are comparable to the speed - ups obtained with online specialisers .    </S>",
    "<S> the paper first develops a generic approach to offline partial deduction and then a specific offline partial deduction method , leading to the offline system lix for pure logic programs . </S>",
    "<S> while this is a usable specialiser by itself , it is used to develop the @xmath0 system logen . given a program , a specification of what inputs will be static , and </S>",
    "<S> an annotation specifying which calls should be unfolded , logen generates a specialised specialiser for the program at hand . running this specialiser with particular values for the static inputs results in the specialised program . </S>",
    "<S> while this requires two steps instead of one , the efficiency of the specialisation process is improved in situations where the same program is specialised multiple times .    </S>",
    "<S> the paper also presents and evaluates an automatic binding - time analysis that is able to derive the annotations . while the derived annotations are still suboptimal compared to hand - crafted ones , they enable non - expert users to use the logen system in a fully automated way .    finally , logen is extended so as to directly support a large part of prolog s declarative and non - declarative features and so as to be able to perform so called mixline specialisations .    </S>",
    "<S> * keywords * partial evaluation , partial deduction , program specialisation , compiler generation , abstract interpretation    [ firstpage ] </S>"
  ]
}