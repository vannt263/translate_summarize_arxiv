{
  "article_text": [
    "nowadays , the development of large and complex software applications is based on reusing pre - existing functionalities instead of developing them from scratch @xcite .",
    "application programming interfaces ( apis ) are recognized as the most commonly used repositories supporting software reuse @xcite .",
    "apis provide a pre - implemented , tested and high quality set of functionalities @xcite .",
    "consequently , they increase software quality and reduce the effort spent on coding , testing and maintenance activities @xcite .    in the case of object - oriented apis ,",
    "standard template libraries _ in _",
    "c++ _ or _ java sdk _",
    ", the functionalities are encapsulated as object - oriented classes .",
    "it is well known that reusing and understanding large apis such as _ java sdk _ , which contains more than 7.000 classes , is not an easy task @xcite .",
    "consequently , several approaches have been proposed , such as @xcite , in order to facilitate the understandability and the reusability of apis by discovering frequent usage patterns of apis .",
    "this is based on the api usage history of software applications ( i.e. api clients ) . despite the value of frequent usage patterns ,",
    "these are not sufficient to provide a high degree of api reusability and understandability .",
    "these are used as guides for reusing api classes and are not themselves reusable entities @xcite .",
    "otherwise , software components are admitted to be more reusable and understandable entities than object - oriented ( oo ) ones @xcite .",
    "this is because components are considered coarse - grained software entities , while oo classes are considered fine - grained ones .",
    "in addition , components define their required and provided interfaces .",
    "this means that the component dependencies are more understandable compared to the dependencies among objects .",
    "consequently many approaches have been proposed to identify components from oo software applications such as @xcite .",
    "nevertheless , no approach has been proposed to identify components from object - oriented apis .",
    "thus , in this paper , we propose an approach to mine components from object - oriented apis .",
    "this does not only improve the reusability of apis themselves , but also supporting component - based reuse techniques by providing component based apis .",
    "the approach exploits specificities of api entities .",
    "we statically analyze the source code of both apis and their software clients to identify groups of api classes that are able to form oo components .",
    "this is based on two criteria .",
    "the first one is the probability of classes to be reused together by api clients .",
    "the second one is related to the structural and behavioral dependencies among classes and thus their ability to form a quality - centric component . in order to validate the proposed approach",
    ", we experimented on a set of 100 _ java _ applications that use three _ android _ apis .",
    "the evaluation shows that structuring object - oriented apis as component - based ones improves the reusability and the understandability of these apis .",
    "the rest of this paper is organized as follows .",
    "the subsequent section , section 2 puts in context the problem of component identification from apis .",
    "it presents the goal of the proposed approach , the background needed to understand our proposal and the problem analysis .",
    "section 3 presents the foundation of our approach .",
    "then , in section 4 we present the identification of component interface classes .",
    "section 5 presents how apis are organized as component - based libraries .",
    "experimentation and results of our approach are discussed through three apis case studies in section 6 .",
    "next , the related work is discussed in section 7 . finally , concluding remarks and future directions are presented in section 8",
    "our goal is to reengineer object - oriented apis into component based ones .",
    "based on @xcite , we consider a component as , a software element that ( a ) can be composed without modification , ( b ) can be distributed in an autonomous way , ( c ) encapsulates the implementation of one or many closed functionalities , and ( d ) adheres to a component model . according to this definition , we derive three quality characteristics that should be satisfied by a component ; _ composability _ , _ autonomy _ and _ specificity_. _ composability _ of a component refers to its ability to be composed through its interfaces without any modification .",
    "_ autonomy _ refers to that a component can be reused in an autonomous way because it encapsulates the strongly dependent functionalities .",
    "_ specificity _ refers to that a component implements a limited number of closed functionalities , which makes it a coarse - grained entity .",
    "based on that , we consider as oo components those implemented as a group of oo classes . in the context of our approach",
    ", the identification of a component means identifying oo classes that can be considered as the implementation of this component .",
    "thus we consider that a component can be identified from a cluster of classes that may belong to different packages .",
    "classes that have direct links ( e.g. method call , attribute access ) with classes implementing other components compose the interfaces of the component .",
    "provided interfaces of a component are defined as a group of methods implemented by classes composing these interfaces . required interfaces of a component are defined as a group of methods invoked by the component and provided by other components .",
    "figure [ fig : objectcomponent ] shows our object to component mapping model .",
    "we have proposed in our previous works related to romantic approach @xcite a set of metrics to measure the ability of a group of classes in a software application to form a component .",
    "these metrics are defined based on the main characteristics of a component ( i.e. _ composability _ , _ autonomy _ and _ specificity _ ) . similar to the software quality model iso 9126 @xcite , we proposed to refine the characteristics of the component into sub - characteristics .",
    "next , the sub - characteristics are refined into the properties of the component ( e.g. number of required interfaces ) . then , these properties are mapped to the properties of the group of classes from which the component is identified ( e.g. group of classes coupling ) .",
    "lastly , these properties are refined into",
    "oo metrics ( e.g. coupling metric ) .",
    "this quality refinement model is shown in figure [ fig : componentquality ] . according to this model",
    ", a quality function has been proposed to measure the component quality .",
    "this quality function is used as a similarity metric for a hierarchal clustering algorithm @xcite as well as in search - based algorithms @xcite to partition the oo classes into groups ; where each group represents a component .          in the domain of data mining , a frequent usage pattern ( fup )",
    "is defined as a set of items , subsequences or substructures that are frequently used together by customers @xcite .",
    "it provides information that helps decision makers ( e.g. customer shopping behavior ) by mining associations and correlations among a set of items in a huge data set .",
    "an example of fup mining is a market basket analysis . in this example",
    ", the customer buying habits are analyzed to identify items that are frequently bought together in the customer shopping baskets , for instance , milk and bread form a fup when they bought frequently together .",
    "the identification of fup is based on _ support _ quality metric that is used to measure the interestingness of a set of items .",
    "_ support _ refers to the probability of finding a set of items in the transactions .",
    "for example , the value of 0.30 _ support _ , means that 30% of all the transactions contain the target item set .",
    "the following equation refers to _ support _ : @xmath0 where _",
    "e2 _ are sets of items ; _ s _ refers to _ support _ ; _ p _ refers to the probability .",
    "fups are observations made based on the analysis of previous uses of apis .",
    "they aim to help users of apis by identifying recurring patterns , composed of classes frequently used together .",
    "fups and components serve the reuse needs in two different ways .",
    "components are entities that can be directly reused and integrated into software applications , while fups are guides for reuse and not entities for reuse . in addition ,",
    "components and fups are structurally different . related to _ specificity _ characteristic , classes composing a component serve a coherent body of services , while classes composing a fup may be related to different services . concerning _ autonomy _",
    "characteristic , dependencies of component s classes are mostly internal , which forms an autonomous entity .",
    "fup s classes can be very dependent on other classes that are not directly used by clients of apis . concerning _ composability _ characteristic , a component is structured and reused via interfaces , while fups are not directly reusable entities .",
    "based on the observations made in the previous sections , we consider that :    * in object - oriented apis , a component is identified as a group of classes . * to reengineer the entire object - oriented api into component - based one , each class of the api is mapped to be part of at least one component .",
    "each class is mapped either as a class of the component interfaces or as a part of the internal classes of the component . *",
    "classes directly accessed by the software clients represent the end - users services .",
    "these classes compose fups .",
    "these ones are the candidate to form the provided interface of the components mined from the api . * as a fup can be composed of classes providing multiple services , its classes can be mapped to be a part of different component interfaces . * a class of an api can be a part of several fups and can participate to implement multiple services . consequently a class can be mapped into multiple component interfaces .",
    "figure [ fig : patterntocomponentmapping ] shows our mapping model which maps class - to - component through fups .",
    "according to this mapping model , we propose the following process to mine components from apis ( c.f .",
    "figure [ fig : miningprocess ] ) :        * * identification of frequent usage patterns . *",
    "fups are identified by analyzing the interactions between the api and its application clients . *",
    "* identification of the interfaces of components .",
    "* we partition the set of classes of each fup in subgroups , where each is considered as related to the provided interfaces of one component ( c.f .",
    "figure [ fig : patterntocomp ] ) .",
    "the partitioning is based on criteria related to dependencies and lexical similarity of classes and their frequency of simultaneous reuse . * * identification of internal classes of components driven by their provided interfaces .",
    "* classes forming the provided interfaces of a component form the starting point for identifying the rest of the component classes . to identify these classes we rely on the analysis of structural and behavioral dependencies between classes in the api with those forming the interfaces .",
    "we check if these classes are able to form a quality - centric component . *",
    "* organizing api as layers of components . *",
    "as we previously mentioned , the api classes can be categorized according to whether they are directly reused by the api clients or not .",
    "classes that are not directly used by api clients can also be organized into two categories .",
    "this is based on whether they belong to components identified from the classes that are directly used by api clients or not .",
    "as each class of the api must be a part of at least one component , we associate classes that do not compose any of the already identified components to new ones . based on that , we organize component - based apis as a set of layers describing how their components are organized .",
    "this organization is used - driven . the first layer is composed of components that are used by the software clients , while the second layer is composed of components that provide services used by components of the first layer , and so on . as a result , the api is structured in @xmath1 layers of components ( c.f .",
    "figure [ fig : apilayers ] ) .",
    "the identification of classes forming an api component is driven by the identification of classes composing the provided interfaces of this component .",
    "classes composing these interfaces are those directly accessed by the clients of the api .",
    "classes belonging to the same interface are those frequently used together",
    ". therefore they are identified from frequent usage patterns .",
    "classes of the api composing frequent usage patterns are identified based on the analysis of how api classes were used by the api clients .",
    "api classes used together constitute transactions of usage .",
    "a transaction of usage is a set of interactions between an api and a client of this api .",
    "these interactions consist of calling methods , accessing attributes , inheritance or creating an instance object based on a class of the api .",
    "they are identified by statically analyzing the source code of the api and its clients .",
    "transactions are different depending on the choice of api clients .",
    "therefore the choice of the api clients directly affects the type of the resulting patterns .",
    "a client can be considered either a class , a group of classes or the whole software application .",
    "we define a client as group of classes forming a functional component in software applications .",
    "the idea behind that is to mine patterns related to functionalities composing the applications .",
    "thus , a transaction is a set of api classes used by classes composing a client component ( c.f .",
    "figure [ fig : clientcom ] ) . to this end , we use romantic approach to identify client components composing software applications .",
    "algorithm [ algo : identifytransactions ] shows the process of transaction identification .",
    "it starts by partitioning each software client into components .",
    "then , for each component , it identifies api classes that are reused by the component classes .      in the previous step ,",
    "the interactions of all client components with the api are identified as transactions .",
    "based on these transactions , we identify fups .",
    "a fup is a set of api classes that are frequently used together by client components .",
    "it allows the detection of hidden correlations of usage among classes of the api .",
    "we mine fups based on the fpgrowth algorithm @xcite . in this algorithm ,",
    "a pattern is considered as frequent if it reaches a predefined threshold of interestingness metric .",
    "this metric is known as @xmath2 .",
    "the @xmath2 refers to the probability of finding a set of api classes in the transactions .",
    "the use of the @xmath2 metric separates the classes of api into two groups according to whether they belong to at least one fup or not .",
    "classes that do not belong to any of the identified fups are the less commonly used classes . as each api class that belongs to a transaction",
    "is a class that has been accessed by the clients of the api , therefore it must be a part of the classes composing the interfaces of at least one component .",
    "we propose assigning each class of the less commonly used classes to the pattern holding the maximum @xmath2 value when they are merged together .",
    "we identify classes composing component interfaces from those composing fups .",
    "each fup is partitioned into a set of groups , where each group represents a component interface .",
    "classes are grouped together according to three heuristics that measure the probability of a set of classes to be a part of the same interface .",
    "the first is the frequency of simultaneous use of these classes by the same client .",
    "the second is the cohesion of these classes .",
    "this measures the strength of sharing data ( e.g. attributes ) between these classes .",
    "the third heuristic is the lexical similarity between these classes based on the textual names of the classes , their methods as well as their attributes .",
    "based on the above heuristics , we propose a fitness function , given below , measuring the ability of a group of classes to form a component interface .",
    "we use _ lcc _ metric @xcite to measure the cohesion of a set of classes , _ conceptual coupling _",
    "metric @xcite to measure classes lexical similarity and _ support _ metric to measure the association frequency of a set of classes .",
    "the partition of each pattern into groups of classes is based on a hierarchical clustering algorithm which uses this function as a function of similarity .",
    "@xmath3    where _ e _ is a set of oo classes ; _",
    "lcc(e ) _ is the _ cohesion _ of _ e _ ; _ cc(e ) _ is _ conceptual coupling _ of _ e _ ; _ s(e ) _ is the _ support _ of _ e _ ; and @xmath4 , @xmath5 , @xmath6 are weight values , situated in [ 0 - 1 ] .",
    "these are used by the api expert to weight each characteristic as needed .",
    "+      methods of provided interfaces of an api component are the public methods of classes identified as composing the provided component interfaces .",
    "methods of the required interfaces are those called by at least one of the classes of the component and defined in classes composing other components .",
    "these two sets of methods constitute the initial search space to identify component interfaces .",
    "the identification process is based on the following heuristics to partition this search space into sub - groups ; where each represents an interface :    * methods that belong to the same interface have a high probability to be used together .",
    "consequently , we consider that methods frequently called together have a higher probability of belonging to the same component interface .",
    "* a group of methods belonging to the same oo interface has a higher probability of belonging to the same component interface . * a group of methods having a high cohesion and a high lexical similarity has a high probability of belonging to the same component interface .    based on these heuristics , we define a similarity function that measures the quality of a set of methods to form a component interface .",
    "we use @xmath2 , @xmath7@xcite and @xmath8 similarity @xcite metrics to respectively measures the frequency of use , cohesion and lexical similarity of a set of methods .",
    "this function is defined as follows :    interface(m)=(_1lcc(m ) + _ 2cs(m ) + _ 3s(m)+ _ 4soi(m ) )    where :    * @xmath9 is a set of methods . *",
    "@xmath10 , @xmath11 , @xmath12 , and @xmath13 respectively refers to the cohesion , @xmath8 similarity , @xmath14 and the association with the same oo interface(1 if yes , else 0 ) of @xmath9 .",
    "* @xmath4 , @xmath5 , @xmath6 and @xmath15 are weight values , situated in [ 0 - 1 ] .",
    "these are used by the api expert to weight each characteristic as needed .",
    "based on this similarity function , we partition methods of the above search space into clusters based on a hierarchical clustering algorithm .",
    "each cluster contains a set of methods forming an interface .",
    "as we mentioned before , the component identification process is driven by the identification of its provided interfaces .",
    "this means that api classes forming a component are identified in relation to their direct or indirect structural and behavioral dependencies with the classes forming provided interfaces of the component .",
    "the selection of a class of the api to be a part of the component classes is based on the measurement of the quality of this component , when this is included .",
    "the identification of these classes is done gradually . in other words",
    ", we start to form the group of classes composing the interface ones , and then we add other classes to form a component based on the component quality measurement model .",
    "classes having either direct or indirect links with the interface ones represent the candidate classes to be added to them . at each step , we add a new api class . this is selected based on the quality value of the component , formed by adding this class to the ones already selected .",
    "the class that maximizes the quality value is selected in this step .",
    "this is done until all api classes are investigated .",
    "each time we add a class , we evaluate the component quality .",
    "then , we select the peak quality value to decide which classes form the component .",
    "this means that we exclude classes added after the peak value . as an example , @xmath16 and @xmath17 in figure [ fig : potcomexample ]",
    "are excluded from the resulting component because they were added after the quality value reached the peak .",
    "+      as we previously mentioned , the api is structured in @xmath1 layers of components . to identify components of layer @xmath18",
    ", we rely on components of layer @xmath19 .",
    "we proceed similarly to the identification of the components of the first layer .",
    "we use required interfaces of the components already identified in layer @xmath19 to identify the interfaces provided by components in layer @xmath18 .",
    "this continues until reaching a layer where its components either do not require any interface or they require ones already identified .",
    "each interface defined as a required for a component of layer @xmath19 is considered as a provided by a component of layer @xmath18 except ones provided by the already identified components .",
    "all interfaces provided in layer @xmath18 are grouped into clusters to identify those provided by the same component of layer @xmath18 .",
    "the clusters are obtained based on a hierarchical clustering algorithm .",
    "this algorithm uses a similarity function that measures : ( i ) the cohesion of classes composing a group of interfaces , ( ii ) the lexical similarity of these classes and ( iii ) the frequency of their simultaneous use .",
    "clusters that maximize this function are selected .",
    "the interfaces composing each cluster are considered as provided by the same component .",
    "analogously to the identification of the components of the first layer , the other classes composing each component are identified starting from classes composed of its already identified provided interfaces .",
    "we collected a set of 100 @xmath20 applications from open - source repositories , @xmath21 , @xmath22 , @xmath23 , and @xmath24 .",
    "the average size of these applications in terms of number of classes is 90 .",
    "the application names are listed in the appendix .",
    "these applications are developed based on classes of the @xmath25 apis . in our experimentation , we focus on three of these apis .",
    "the first is the @xmath26 composed of 491 classes .",
    "this api provides services related to the definition and management of the user interfaces in android applications .",
    "the second api is the @xmath27 composed of 361 classes .",
    "this api provides services related to creating and managing android applications .",
    "the last api is the @xmath25 composed of 5790 classes .",
    "this api includes all of the android services .",
    "the approach is evaluated on the collected software applications and apis .",
    "we identify client components independently from each software application .",
    "each component in software is considered as a client of the apis to form a transaction of classes .",
    "then , we mine frequent usage pattern ( fup ) from the identified transactions .",
    "next , from classes composing each fup , we identify classes composing a set of component interfaces .",
    "then , we identify all component classes starting from ones composing their interfaces .",
    "lastly , the final results obtained by our approach are presented .",
    "we evaluate the obtained components by answering the three following research questions .",
    "* * rq1 : does the approach reduce the understandability efforts ? * this research question aims at measuring the saved efforts in the api understandability that are brought by migrating object - oriented apis into component - based ones . *",
    "* rq2 : are the mined components reusable ? *",
    "as our approach aims at mining reusable components , we evaluate the reusability of the resulted component .",
    "this is based on measuring how much related classes are grouped into the same components . *",
    "* rq3 : is the identification of provided interfaces based on fups useful ? *",
    "the proposed approach identifies the provided interfaces of the components based on how clients have used the api classes ( i.e. fups ) .",
    "thus , this research question evaluates how much benefit the use of fups brings by comparing components identified by our approach with ones identified without taking fups into account .    to answer the second question that related to the reusability",
    ", we use the @xmath28 cross validation method @xcite .",
    "the idea is to partition the client applications into @xmath29 parts .",
    "then , the identification process is applied @xmath29 times by considering , each time , @xmath30 different parts for the identification process and by using the remaining part to measure the reusability .",
    "next , we take the average of all @xmath29 trail results . in our experiment , we set @xmath29 to 2 , 4 , and 8 .            the average number of client components identified from each software is @xmath31 and the average number of classes composing each component is @xmath32 .",
    "table [ transactionsresults ] shows the average number of transactions per software application ( @xmath33 ) , the average of transaction size in terms of classes ( @xmath34 ) , and the percentage of components that have used the api ( @xmath35 ) .",
    "the last column of this table shows an example of transactions .",
    "the results show that @xmath25 , @xmath36 , and @xmath37 apis have been used respectively by only 54% , 29% and 32% of client components .",
    "in addition , we note that each client component has used the api classes intensively compared to the number of classes composing it .",
    "for example , the transaction size is 17.91 classes for the @xmath36 api , where the average number of classes per component is 18.73 .",
    "this is due to the fact that classes that serve the same services in software applications , and consequently depend on the same api classes , are grouped together in the same client component .",
    ".the identification of transactions [ cols=\"^,^,^,^,<\",options=\"header \" , ]     [ providedinterfacesvalidation ]",
    "[ relatedwork ] to the best of our knowledge , no approach has been proposed to identify components from object - oriented apis . however , we present two research areas that are related to our approach .",
    "the first one aims at identifying components from oo software applications .",
    "the second area aims at mining frequent patterns of api usage .    concerning the identification of software components from the source code of software applications ,",
    "numerous approaches have been presented .",
    "garcia et al .",
    "provide a survey of some of these approaches @xcite . in @xcite , detten et al .",
    "presented the archimetrix approach , which aims at mining the architecture of the legacy software .",
    "it relies on a clustering algorithm to partition the system classes into components .",
    "this algorithm depends on name resemblance , coupling and cohesion metrics as a fitness function . in @xcite , kebir et al .",
    "presented an approach to extract components from a single oo software system .",
    "classes composing the extracted components form a partition .",
    "mined components are considered as a part of the component - based architecture of the corresponding software . in @xcite allier",
    "et al . depended on dynamic dependencies between classes to recover components .",
    "based on the use case diagram , the execution trace scenarios are identified .",
    "classes that frequently occur in the execution traces are grouped into a single component .",
    "cohesion and coupling metrics are also taken into account during the identification process .",
    "weinreich et al .",
    "proposed , in @xcite , an approach to recover multi - view architecture model of software applications implemented based on service oriented architecture .",
    "the authors classified software artifacts based on the information from source code , configuration files and binary codes . in @xcite ,",
    "an approach has been presented to mine reusable components from a set of similar software applications .",
    "a component is considered as more reusable , when it is reused many times by the software applications .",
    "the authors firstly identified components independently from each software application .",
    "then , based on the lexical similarity between the classes composing these components , they identified reusable ones .    in the context of api mining ,",
    "many approaches have been proposed to mine frequent usage patterns of apis based on the usage history of apis .",
    "robillard et al .",
    "provide a survey of these approaches @xcite .",
    "these approaches can be mainly classified based on four main criteria . the first one is related to the goal , which can be either giving examples and recommendations of how to use api entities ( e.g. @xcite ) , supporting the documentation of apis ( e.g. @xcite ) , or improving the bug detection task ( e.g. @xcite ) .",
    "the second criterion is related to the pattern ordering , where some approaches mine ordered patterns ( e.g. @xcite ) , while other ones mine unordered patterns ( e.g. @xcite ) .",
    "the third one concerns the granularity of the elements composing a pattern . for examples , in @xcite ) , the approaches mine patterns composed of methods , and the approach in @xcite mines patterns composed of classes .",
    "the fourth one related to the technique that is used to identify the patterns .",
    "the used technique can be association rules mining ( e.g. @xcite ) , clustering algorithms ( e.g. @xcite ) or a heuristic defined by the authors such as @xcite .",
    "some approaches combines many techniques , e.g. , unddin et al .",
    "used principle component analysis with clustering algorithm @xcite , and buse and weimer combined the clustering algorithm with their own proposed heuristic @xcite .",
    "in this paper , we presented an approach aimed at mining software components from object - oriented apis .",
    "it is based on static analysis of the source code of both the apis and their software clients .",
    "the mining process is used - driven .",
    "this means that components are identified starting from classes composing their interfaces .",
    "classes composing the provided interface of the first layer components compose fups .",
    "we experimented our approach by applying it on a set of open source @xmath38 applications as clients for three android apis .",
    "the results show that our approach improves the reusability of the api .",
    "as our approach is used - driven , the results depend on the quality and the number of usages of the api .",
    "this means that identified fups rely on the considered software clients .",
    "therefore the identification of provided interfaces and then their corresponding components depends on api clients .",
    "consequently it is essential to select clients having the largest number of usages of the api .",
    "our future work will focus on migrating the identified oo components into existing component models such as osgi model , and developing a visual environment that allows domain experts to interact with the approach at each step of the identification process , thus modify the obtained results as needed .",
    "these are the names of the applications that considered as clients of the apis .    _ adw launcher , apv , armarker , arviewer , alerts , alogcat , andorstrail , andromaze , androidomatickeyer , appsorganizer , aripucatracker , asciicam , asqare , augmentrealityfw , aussieweatherradar , autoanswer , avare , bansheeremote , bismoclient , bigplanettracks , binauralbeats , blokish , bostonbusmap , calendarpicker , ch - etherdroid , cvox , camtimer , chanimagebrowser , cidrcalculator , colorpicker , comparemydinner , connectbot , corporateaddressbook , countdown , countdowntimer , crossword , custommaps , diygenomics , dazzle , dialer2 , diskusage , distlibrary , dolphin , doom , drismo , droidlife , droidstack , droidar , exchangeowa , feedgoal , filemanager , floatingimage , gcstar , geeklist , getarobotvpnfrontend , gltron , gohome , googlemapssupport , graphview , heartsong , hermit , historify , holoken , hotdeath , introspy , legomindstroms , lexic , libvoyager , livemusic , localebridge , mame4droid , look , looksocial , macnos , mandelbrot , mathdoku , mediaplayer , ministocks , motiondetection , ngnstack , newspaperpuzzles , onmyway , openintents , openmap , opensudoku , pedometer , phoenix , photspot , prey , pubkeygenerator , pwdhash , queueman , ratebeermobile , alienbloodbath , supergenpass , swallowcatcher , swiftp , tumblife , vectorpinball , wordsearch .",
    "_              uddin , g. , dagenais , b. , robillard , m.p . : temporal analysis of api usage concepts . in : proc . of the 2012 inter",
    ". conf . on software engineering ( icse ) ,",
    "ieee press , piscataway , nj , usa ( 2012 )    wang , j. , dang , y. , zhang , h. , chen , k. , xie , t. , zhang , d. : mining succinct and high - coverage api usage patterns from source code . in : proc . of the 10th working conf . on mining software repositories ( msr ) ,",
    "319328 . ieee press , piscataway , nj ,",
    "usa ( 2013 )      monperrus , m. , bruch , m. , mezini , m. : detecting missing method calls in object - oriented software . in : european conf . on object - oriented programming ecoop .",
    "lncs , vol . 6183 , pp .",
    "springer , heidelberg ( 2010 )        kebir , s. , seriai , a.d . , chardigny , s. , chaoui , a. : quality - centric approach for software component identification from object - oriented code . in : joint working ieee",
    "/ ifip conf . and",
    "european conf . on software architecture ( wicsa)/(ecsa ) ,",
    ". 181190 .",
    "( 2012 )    allier , s. , sadou , s. , sahraoui , h. , fleurquin , r. : from object - oriented applications to component - oriented applications via component - oriented architecture . in : 9th working ieee",
    "/ ifip conf . on software architecture ( wicsa ) ,",
    ". 214223 .",
    "( 2011 )        chardigny , s. , seriai , a. , oussalah , m. , tamzalit , d. : extraction of componentbased architecture from object - oriented systems . in : 7th working ieee / ifip conf . on software architecture ( wicsa ) ,",
    "( 2008 )      chardigny , s. , seriai , a.d . ,",
    "oussalah , m. , tamzalit , d. : search - based extraction of component - based architecture from object - oriented systems . in : 2nd european conf . in software architecture ( ecsa ) .",
    "lncs , vol .",
    "5292 , pp .",
    "springer , heidelberg ( 2008 )          garcia , j. , ivkovic , i. , medvidovic , n. : a comparative analysis of software architecture recovery techniques . in : ieee",
    "/ acm 28th inter . conf . on automated software engineering ( ase ) ,",
    "( 2013 )      weinreich , r. , miesbauer , c. , buchgeher , g. , kriechbaum , t. : extracting and facilitating architecture in service - oriented software systems . in : joint working ieee",
    "/ ifip conf . and european conf . on software architecture ( wicsa)/(ecsa ) , pp",
    "( 2012 )    shatnawi , a. , seriai , a.d . :",
    "mining reusable software components from objectoriented source code of a set of similar software . in : ieee 14th inter . conf . on information reuse and integration ( iri ) ,",
    "pp . 193200 ."
  ],
  "abstract_text": [
    "<S> object - oriented application programing interfaces ( apis ) support software reuse by providing pre - implemented functionalities . due to the huge number of included classes , reusing and understanding large apis is a complex task . otherwise , software components are admitted to be more reusable and understandable entities than object - oriented ones . </S>",
    "<S> thus , in this paper , we propose an approach for reengineering object- oriented apis into component - based ones . </S>",
    "<S> we mine components as a group of classes based on the frequency they are used together and their ability to form a quality - centric component . to validate our approach </S>",
    "<S> , we experimented on 100 _ java _ applications that used _ android _ apis . </S>"
  ]
}