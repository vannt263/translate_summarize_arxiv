{
  "article_text": [
    "in this paper we are concerned with the complexity analysis of constructor term rewrite systems . since term rewrite systems ( trss for short )",
    "underlie much of declarative programming , time complexity of functions defined by trss is of particular interest .    in rewriting two notions of complexity have been widely studied .",
    "hofbauer and lautemann proposed to assess the complexity of a given trs as the maximal length of derivation sequences .",
    "more precisely the _ derivational complexity function _ relates the maximal length of a derivation with the size of the starting term  @xcite . as an alternative hirokawa and the second author proposed to study the _ runtime complexity function _",
    "@xcite , which forms a variation of the derivational complexity function . instead of all possible derivations ,",
    "one studies only derivations with starting terms whose arguments are constructor terms ( aka _ basic terms _ ) , see also  @xcite . in the context of this paper ,",
    "runtime complexity is the more natural notion .",
    "we emphasise that the runtime complexity of a rewrite system forms a _ polynomially invariant _ cost model  @xcite , cf .",
    "section  [ s : basics ] .    to motivate our studies , we present a natural encoding of the well - known satisfiability problem @xmath0 of propositional logic as a trs . given a propositional formula in conjunctive normal form , the trs @xmath1 given below computes a satisfying assignment if it exists .",
    "note that @xmath1 is not confluent , i.e. , the computation is performed nondeterministically .",
    "the rewrite system @xmath1 thus encodes the function problem _ @xmath2 _ associated with the satisfiability problem .",
    "@xmath2 is complete for the class of _ function problems over @xmath3 _",
    "( @xmath4 for short ) .",
    "see section  [ s : basics ] where @xmath4 is formally defined . as corollary to the polynomial invariance of the runtime complexity of rewrite systems",
    ", we obtain that the runtime complexity of @xmath1 is expected to be polynomial .",
    "[ ex : rssat ] consider the following ( non - confluent ) trs @xmath1 : @xmath5 \\rlabel{rssat : eq : zo } & & \\meq(\\mz(x),\\mo(y ) ) & \\to \\mfalse   & ~ \\rlabel{rssat : eq : zz } & & \\meq(\\mz(x),\\mz(y ) ) & \\to \\meq(x , y )   \\\\ \\rlabel{rssat : eq : oz } & & \\meq(\\mo(x),\\mz(y ) ) & \\to \\mfalse   & ~ \\rlabel{rssat : eq : oo } & & \\meq(\\mo(x),\\mo(y ) ) & \\to \\meq(x , y )   \\\\ \\rlabel{rssat : eq : np } & & \\meq(-x,+y ) & \\to \\mfalse   & ~ \\rlabel{rssat : eq : nn } & & \\meq(-x ,- y ) & \\to \\meq(x , y )   \\\\ \\rlabel{rssat : eq : pn } & & \\meq(+x ,- y ) & \\to \\mfalse   & ~ \\rlabel{rssat : eq : pp } & & \\meq(+x ,- y ) & \\to \\meq(x , y )   \\\\ \\rlabel{rssat : eq : ee } & & \\meq(\\varepsilon,\\varepsilon ) & \\to \\mtrue   \\\\[2 mm ] \\rlabel{rssat : if : t } & & \\mif(\\mtrue , t , e ) & \\to t   & ~ \\rlabel{rssat : if : f } & & \\mif(\\mfalse , t , e ) & \\to e   \\\\[2 mm ] \\rlabel{rssat : verify : b } & & \\verify(\\nil ) & \\to \\mtrue   & ~ \\rlabel{rssat : verify : r } & & \\verify(l \\cons ls ) & \\to \\mif(\\member(\\mneg(l),ls ) , \\mfalse , \\verify(ls ) ) \\\\[2 mm ] \\rlabel{rssat : member : b } & & \\member(x,\\nil ) & \\to \\mfalse & ~ \\rlabel{rssat : member : r } & & \\member(x , y \\cons ys ) & \\to \\mif(\\meq(x , y ) , \\mtrue , \\member(x , ys ) )   \\\\[2 mm ] \\rlabel{rssat : guess : b } & & \\guess(\\nil ) & \\to \\nil & ~ \\rlabel{rssat : guess : r } & & \\guess(c \\cons cs ) & \\to \\choice(c ) \\cons \\guess(cs ) \\\\[2 mm ] \\rlabel{rssat : choice : a } & & \\choice(a \\cons \\nil ) & \\to a & ~ \\rlabel{rssat : choice : b } & & \\choice(a \\cons b \\cons bs ) & \\to \\choice(b \\cons bs ) \\\\ \\rlabel{rssat :",
    "choice : a2 } & & \\choice(a \\cons b \\cons bs ) & \\to a \\\\[2 mm ] \\rlabel{rssat : issat } & & \\issat(cs ) & \\to \\mparbox{1cm}{\\issat'(\\guess(cs ) ) } \\\\ \\rlabel{rssat : issat ' } & & \\issat'(as ) & \\to \\mparbox{1cm}{\\mif(\\verify(as),as,\\unsat ) \\tpkt}\\end{aligned}\\ ] ] atoms are encoded as binary strings ( built from the constant @xmath6 , and unary constructors @xmath7 and @xmath8 ) , the unary constructors ( @xmath9 ) and ( @xmath10 ) lift atoms to positive and negative literals respectively .",
    "the rules   define negation and equality on this representation of literals .",
    "clauses are lists of literals , clause sets are denoted by lists of clauses .",
    "lists are constructed in the usual way using a constant @xmath11 and binary constructor @xmath12 .",
    "call a list of literals consistent , if an atom does not occur positively and negatively .",
    "this is formalised by rules  . a clause set @xmath13 is satisfiable",
    "if and only if there exists a list of literals @xmath14 , denoting a satisfying assignment , such that @xmath14 is consistent and contains at least one literal from every clause @xmath15 .",
    "the rules   are used to generate a candidate list @xmath14 that contains for each clause one literal . using these auxiliary rules , the algorithm is implemented by rules   and  .",
    "given a clause set @xmath13 , a candidate list @xmath14 is guessed and its consistency is checked .",
    "if this check succeeds the list @xmath14 is returned .",
    "it is easy to see that @xmath1 is terminating , for example this can be verified by showing compatibility with the multiset path order (  for short )  @xcite .",
    "it is a standard exercise in rewriting to assess the complexity of rewrite systems via an analysis of termination techniques and it is a well - known result that  induces primitive recursive derivational and runtime complexity  @xcite .",
    "furthermore ,  _ characterises _ the _ primitive recursive functions _ ( @xmath16 for short )  @xcite : any function computed by an @xmath17-terminating trs is primitive recursive , vice versa , any primitive recursive function can be stated as an @xmath17-terminating trs .",
    "however , from these results we can only conclude that the runtime complexity function of @xmath1 is bounded by a primitive recursive function , which is hardly revealing .",
    "this motivates the quest for a `` polynomial path order '' depicted by the question mark in figure  [ fig:3 ] .",
    "such an order should be a restriction of , but _",
    "miniaturises _ its properties : it would be expected that this order induces _ polynomial _ runtime complexity and provides a characterisation of the class @xmath18 of _ functions computable in polynomial time_.    \\(1 ) ; ( 2 ) [ right = of 1 ] _ prim",
    ".  rec .",
    "runtime compl .",
    "_ ; ( 5 ) [ right = of 2 ] @xmath16 ; ( 3 ) [ below = of 1 ] ; ( 4 ) [ below = of 2 , yshift=2pt ] _ polynomial runtime compl . _ ; ( 6 ) [ below = of 5 ] @xmath18 ;    ( 1.south ) ",
    "( 3.north ) ; ( 2.south ) ",
    "( 4.north ) ; ( 5.south ) ",
    "( 6.north ) ; ( 1.east ) ",
    "( 2.west ) ; ( 2.east ) ",
    "( 5.west ) ; ( 3.east )  ( 4.west ) ; ( 4.east )  ( 6.west ) ;    in this paper , we propose the _ polynomial path order _ ( _ _ for short ) as such a miniaturisation of :  induces polynomial runtime complexity ( for innermost rewriting ) and at the same time yields a characterisation of @xmath18 . in the design of  we have striven for a _",
    "maximal _ miniaturisation of , so that these key features of  remain intact . alas ,",
    "some of the essential properties of  can not be preserved .",
    "first ,  can only analyse the _ runtime complexity _ of trss ; the derivational complexity induced by  is ( at least ) double - exponential ( example  [ ex : dc ] ) .",
    "second , the restriction to _ innermost _ rewriting is essential ( example  [ ex : outermost ] ) and finally , our result only holds for _ constructor _ trs ( example  [ ex : constructor ] ) .",
    "more precisely , we establish the following results .    1",
    ".   induces polynomial innermost runtime complexity on constructor trss .",
    "that is , the innermost runtime complexity function for a constructor trs compatible with  is polynomially bounded ( theorem  [ t : popstar ] ) .",
    "2 .   captures exactly the class @xmath18 on orthogonal constructor trss .",
    "that is , any orthogonal constructor trs compatible with  computes a polytime function . on the other hand ,",
    "any function in @xmath18 can be implemented by an orthogonal constructor trs compatible with  ( theorems  [ t : icc : soundness ] and  [ t : icc : completeness ] ) .",
    "we extend upon  by proposing a generalisation , admitting the same properties as outlined above , but that allows to handle more general recursion schemes that make use of parameter substitution ( theorem  [ t : popstarps ] ) .",
    "we have implemented the proposed technique in the _ tyrolean complexity tool _ (  for short )  @xcite .",
    "the experimental evidence obtained indicates the viability of the method .    by a comparison with the formal definition in section  [ s : popstar ] it is not difficult to verify that @xmath1 is compatible with ( cf .",
    "example  [ ex : rssat:2 ] ) .",
    "this implies that the number of rewrite steps starting from @xmath19 is polynomially bounded in the size of the cnf @xmath13 .",
    "this can be automatically verified by @xmath20 in a fraction of a second .",
    "due to a suitable adaption of the polynomial invariance theorem  @xcite ( cf .",
    "proposition  [ p : invariance ] ) we can thus _ automatically _ conclude that @xmath2 belongs to @xmath4 .",
    "the termination order  gives a syntactic account of the principle of _ predicative recursion _ as proposed by bellantoni and cook  @xcite .",
    "conclusively any trs compatible with is called _ predicative recursive_. analogously  can be conceived as syntactic account of leivant s notion of _ tiered recurrence _",
    "@xcite , cf .",
    "simmons  @xcite .",
    "we think that  is not only of interest from the viewpoint of automated runtime complexity , but also from the viewpoint of _ implicit computational complexity _ ( _ icc _ for short )  @xcite .",
    "in particular  is applicable to verify closure properties of the class of polytime computable function . through our extension ,",
    "we reobtain bellantoni s result that predicative recursion is closed under parameter substitution ( cf .  section  [ s : popstarps ] ) .",
    "preliminary versions of the presented results appeared in  @xcite .",
    "the order @xmath21 has been introduced in  @xcite , extended to quasi - precedences in  @xcite and the extension @xmath22 appeared in  @xcite .",
    "apart from the correction of some shortcomings , we extend our earlier work in the following way : first , the presented definition of @xmath21 is more liberal and captures the underlying idea of predicative recursion more precisely , compare  ( * ? ? ? * definition  4 ) and definition  [ d : gpop ] from section  [ s : popstar ] .",
    "second , our soundness result ( cf .",
    "theorem  [ t : icc : soundness ] from section  [ s : icc ] ) is new and more general than similar results presented earlier .",
    "in particular it does no longer require typing of constructors nor the intermediate step of completely defined trss , cf .",
    "third , the propositional encoding used in our automation of polynomial path orders ( cf .  section  [ s : impl ] ) has been completely overhauled .",
    "polynomial complexity analysis is an active research area in rewriting .",
    "starting from  @xcite interest in _ automated _ polynomial complexity analysis greatly increased over the last years , see for example  @xcite .",
    "this is partly due to the incorporation of a dedicated category for complexity into the annual termination competition ( termcomp ) .",
    "there are several accounts of predicative analysis of recursion in the ( icc ) literature .",
    "we mention marion s _ light multiset path order _ ( _ _ for short )  @xcite .",
    "the path order  provides an order - theoretic characterisation of the class @xmath18 and can be also consider as a miniaturisation of  of sorts : it is a restriction of  and yields an order - theoretic characterisation of a complexity class . on the other hand  can not be used to characterise the ( innermost ) runtime complexity of trss .",
    "this follows from example  [ ex : rs2 ] below .",
    "in particular , although @xmath1 is compatible with @xmath23 , from this we can only conclude that @xmath2 is computable on a nondeterministic turing machine in polynomial time .",
    "however , this follows by design as @xmath2 is complete for @xmath4 .",
    "the trs @xmath24 is given by the following rules : [ ex : rs2 ] @xmath25 for a precedence @xmath26 that fulfils @xmath27 and @xmath28 we obtain that @xmath24 is compatible with @xmath23 .",
    "however it is straightforward to verify that the family of terms @xmath29 admits ( innermost ) derivations whose length grows exponentially in @xmath30 .",
    "still the underlying function can be proven polynomial , essentially relying on memoisation techniques  @xcite .    on the other hand arai and",
    "the second author introduced the _ polynomial path order for @xmath18 _ ( _ _ for short ) . in a similar way as ,  characterises the class @xmath18 and in addition induces innermost polynomial runtime complexity . however in comparison to ,  severely lacks applicability as it requires a specific signature of the given rewrite system .",
    "for example is not directly applicable to @xmath1 : only a special transformation of the rewrite system @xmath1 can be handled .",
    "furthermore , a strengthening of our first main theorem to runtime complexity can be obtained if one considers polynomial interpretations , where the interpretations of constructor symbols is restricted .",
    "such restricted polynomial interpretations are called _ additive _ in  @xcite .",
    "note that additive polynomial interpretations also characterise the functions computable in polytime  @xcite .",
    "similarly , _ quasi - interpretations _",
    "@xcite provide an elegant way to characterise time complexity classes through a combination of syntactic ( via restrictions of reduction orders ) and semantic ( via quasi - interpretations ) considerations .",
    "to date it is unknown whether quasi - interpretations can be used to assess polynomial runtime complexity of trss .",
    "unarguable these semantic techniques admit a better intensionality than the syntactic characterisation provided through the path order .",
    "but semantic methods are notoriously difficult to implement efficiently in an automated setting",
    ". in particular we are only aware of one accessible implementation of quasi - interpretations , our own  @xcite .",
    "note that these semantic methods are not tailored for innermost rewriting , in particular example  [ ex : dup ] given below can not be handled , while it can be easily handled by .",
    "although we consider here only time complexity , related work indicates that the overall approach is general enough to reason also about space complexity .",
    "for instance , the _ knuth - bendix _",
    "order  @xcite can be miniaturised to characterise linear space  @xcite . likewise , _",
    "sup - interpretations _",
    "@xcite provide a semantic technique capable of characterising polynomial space .    in  @xcite , beckmann and weiermann",
    "have given a term rewriting characterisation of the principle of predicative recursion proposed by bellantoni and cook .",
    "following ideas proposed by cichon and weiermann in  @xcite , beckmann and weiermann thus reobtain bellantoni s result that predicative recursion is closed under parameter recursion .",
    "we have extended our complexity analysis tool  @xcite with polynomial path orders .",
    "we briefly contrast this implementation to related tools for the static resource analysis of programs .",
    "hoffmann  et  al .",
    "@xcite provide an automatic multivariate amortised cost analysis exploiting typing , which extends earlier results on amortised cost analysis  @xcite . to indicate the applicability of our method",
    "we have employed a straightforward ( and complexity preserving ) transformation of the raml programs considered in  @xcite into trss . equipped with  our complexity analyser",
    "can handle all examples from  @xcite .",
    "albert et al .",
    "@xcite present an automated complexity tool for java@xmath31 bytecode programs , alias et al .  @xcite give a complexity and termination analysis for flowchart programs , and gulwani  et  al .",
    "@xcite as well as zuleger  et  al .",
    "@xcite provide an automated complexity tool for c programs . very recently",
    "hofmann and rodriguez proposed in  @xcite an automated resource analysis for object - oriented programs via an amortised cost analysis .",
    "the remainder of this paper is organised as follows . in the next section we recall basic notions and starting points of this paper . in section  [ s : popstar ]",
    "we introduce polynomial path orders . in the subsequent sections  [ s : pop ] and",
    "[ s : embed ] we show that the innermost runtime complexity of predicative recursive trss is polynomially bounded . as essential tool for this",
    "we introduce an extended version of . in section  [",
    "s : icc ] we present our ramification of polynomial path orders in icc .",
    "parameter substitution is incorporated in section  [ s : popstarps ] .",
    "our implementation is detailed in section  [ s : impl ] and experimental evidence is provided in section  [ s : exps ] .",
    "finally , we conclude and present future work in section  [ s : conclusion ] .",
    "we denote by @xmath32 the set of natural numbers @xmath33 .",
    "let @xmath34 be a binary relation . the transitive closure of @xmath34 is denoted by @xmath35 and its transitive and reflexive closure by @xmath36 . for a binary relation @xmath34",
    ", we frequently write @xmath37 instead of @xmath38 .",
    "composition of binary relations @xmath34 and @xmath39 is denoted by @xmath40 , and defined in the usual way . for @xmath41",
    "we denote by @xmath42 the _ @xmath30-fold composition of @xmath34_. the binary relation @xmath34 is _ well - founded _ if there exists no infinite chain @xmath43 with @xmath44 for all @xmath45 .",
    "moreover , we say that @xmath34 is well - founded on a set @xmath46 if there exists no such infinite chain with @xmath47 .",
    "the relation @xmath34 is _ finitely branching _ if for all elements @xmath48 , the set",
    "@xmath49 is finite .",
    "a _ proper order _ is an irreflexive and transitive binary relation .",
    "a _ preorder _ is a reflexive and transitive binary relation .",
    "an _ equivalence relation _ is reflexive , symmetric and transitive .",
    "a multiset is a collection in which elements are allowed to occur more than once .",
    "we denote by @xmath50 the set of multisets over @xmath46 and write @xmath51 to denote multisets with elements @xmath52 .",
    "we use @xmath53 for the summation and @xmath54 for difference on multisets @xmath55 and @xmath56 . the _ multiset extension _",
    "@xmath57 _ of a relation @xmath34 on @xmath46 _ is the relation on @xmath50 such that @xmath58 if there exists multisets @xmath59 satisfying    1 .",
    "@xmath60 , 2 .",
    "@xmath61 and 3",
    ".   for all @xmath62 there exists an element @xmath63 such that @xmath64 .    in order to extend this definition to preorders and equivalences ,",
    "we follow  @xcite .",
    "let @xmath65 denote an equivalence relation over the set @xmath46 and let @xmath66 be a binary relation over @xmath46 so that @xmath67 and @xmath65 are _ compatible _ in the following sense : @xmath68 .",
    "let @xmath69 denote the _ equivalence class of @xmath70 _ with respect to @xmath65 . by the compatibility requirement , the extension @xmath71 of @xmath67 to equivalence classes such that @xmath72 if and only if @xmath73 , is well defined .",
    "we define the _ strict multiset extension @xmath74 of @xmath75 _ as @xmath76 if and only if @xmath77 .",
    "further , the _ weak multiset extension @xmath78 of @xmath75 _ is given by @xmath79 if and only if @xmath77 or @xmath80 holds .",
    "note that if @xmath81 is a preorder ( on @xmath46 ) then @xmath74 is a proper order and @xmath78 a preorder on @xmath50 , cf .",
    "also @xmath74 is well - founded if @xmath67 is well - founded .",
    "notations are taken from  @xcite . the _ function problem _ @xmath82 associated with a binary relation @xmath34 is defined as follows : given @xmath83 find some @xmath84 such that @xmath85 holds if @xmath84 exists , otherwise return @xmath86 .",
    "a binary relation @xmath34 on words is called _ polynomially balanced _ if for all @xmath85 , the size of @xmath84 is polynomially bounded in the size of @xmath83 .",
    "the relation @xmath34 is _ polytime decidable _ if @xmath85 is decided by a deterministic _ turing machine _ ( _ tm _ for short ) @xmath87 operating in polynomial time . the class @xmath3 is the class of languages @xmath88 admitting polynomially balanced , polytime decidable relations @xmath89  ( * ? ? ? * chapter  9 ) : @xmath90 .",
    "the class @xmath4 is the class of function problems associated with the polynomially balanced and polytime decidable relations @xmath89 as above . the class of _ polytime computable functions _",
    "@xmath18 is the subclass resulting if we only consider function problems in @xmath4 that can be solved in polynomial time  ( * ? ? ?",
    "* chapter 10 ) .",
    "recall that a function problem @xmath91 _ reduces _ to a function problem @xmath92 if there exist functions @xmath93 and @xmath94 , both computable in logarithmic space , such that for all @xmath95 with @xmath91 computing @xmath84 on input @xmath83 , @xmath92 computes on input @xmath96 the output @xmath97 with @xmath98 .",
    "note that both @xmath4 and @xmath18 are closed under reductions .",
    "we note that nondeterministic turing machines running in polynomial time compute function problems from @xmath4 .",
    "[ p : fnp ] let @xmath99 be a nondeterministic turing machine that computes the function problem @xmath91 in polynomial time . then @xmath100 .    define the following relation @xmath34 : @xmath85 if and only if @xmath84 is the encoding of an accepting computation of @xmath99 on input @xmath83 . for this encoding",
    "it is sufficient to encode a successful sequence of configurations .",
    "since @xmath99 operates in polynomial time , the length of any computation , and also the size of each configuration , is polynomially bounded .",
    "it follows that @xmath34 is polynomially balanced .",
    "as it can be checked in linear time that @xmath84 encodes an accepting run of @xmath99 on input @xmath83 , @xmath34 is polytime decidable . hence the function problem",
    "@xmath82 that computes an accepting run @xmath84 of @xmath99 on input @xmath83 is in @xmath4 .",
    "finally notice that @xmath91 reduces to @xmath82 . to see this ,",
    "employ following reduction : the function @xmath93 is simply the identity function ; the logspace computable function @xmath94 extracts the result of @xmath99 on input @xmath83 from the accepting run @xmath84 computed by @xmath82 on input @xmath83 .",
    "we conclude the lemma since @xmath4 is closed under reductions .",
    "we assume at least nodding acquaintance with the basics of term rewriting  @xcite .",
    "we fix notions and notation that are used in the paper .    throughout the paper",
    ", we fix a countably infinite set of _ variables _ @xmath101 and a finite _ signature _ @xmath102 of _ function symbols_. the signature @xmath102 is partitioned into _ defined symbols _ @xmath103 and _ constructors _ @xmath104 . the set of _ values _ , _ basic terms _ and _ terms _ is defined according to the grammar @xmath105 where @xmath106 , @xmath107 , and @xmath108 .    the _ arity _ of a function symbol @xmath109 is denoted by @xmath110 .",
    "we write @xmath111 if @xmath112 is a _ subterm _ of @xmath93 , the strict part of @xmath113",
    "is denoted by @xmath114 .",
    "the _ size _ of a term @xmath112 is denoted by @xmath115 and refers to the number of occurrences of variables and function symbols contained in @xmath112 .",
    "we denote by @xmath116 the _ depth _ of @xmath112 which is defined as @xmath117 if @xmath118 and @xmath119 .",
    "let @xmath26 be a preorder on the signature @xmath102 , called _ quasi - precedence _ or simply _",
    "precedence_. we always write @xmath120 for the induced proper order and @xmath121 for the induced equivalence on @xmath102 .",
    "we lift the equivalence @xmath122 to terms modulo argument permutation : @xmath123 if either @xmath124 or @xmath125 and @xmath126 where @xmath127 and for some permutation @xmath128 , @xmath129 for all @xmath130 .",
    "further we write @xmath131 if @xmath112 is a subterm of @xmath93 modulo @xmath65 , i.e. , @xmath132 .",
    "we denote by @xmath133 the set of function symbols below @xmath134 in the precedence @xmath26 .",
    "the _ rank _ of a function symbol is inductively defined by @xmath135 .",
    "a _ rewrite rule _ is a pair @xmath136 of terms , in notation @xmath137 , such that @xmath138 is not a variable and all variables in @xmath94 occur also in @xmath138 . here",
    "@xmath138 is called the _ left - hand _ , and @xmath94 the _ right - hand side _ of @xmath137 .",
    "term rewrite system _ ( _ trs _ for short ) @xmath139 over @xmath140 is a set of _",
    "rewrite rules_. in the following , @xmath139 always denotes a trs .",
    "if not mentioned otherwise , we assume @xmath139 to be _",
    "a relation on @xmath140 is a _",
    "rewrite relation _ if it is closed under contexts and closed under substitutions .",
    "the smallest rewrite relation that contains @xmath139 is denoted by @xmath141 .",
    "a term @xmath142 is called a _ normal form _ if there is no @xmath143 such that @xmath144 . with @xmath145",
    "we denote the set of all normal forms of a trs @xmath139 ; if the trs is clear from context we simply write @xmath146 . whenever @xmath112 is a normal form of @xmath139 we write @xmath147 for @xmath148 . the _ innermost rewrite relation _",
    ", denoted as @xmath149 , is the restriction of @xmath141 where the arguments of the redex are in normal form .",
    "the trs @xmath139 is _ terminating _ if no infinite rewrite sequence exists .",
    "the trs @xmath139 has _",
    "unique normal forms _ if for all @xmath150 with @xmath151 and @xmath152 we have @xmath153 .",
    "the trs @xmath139 is called _ confluent _ if for all @xmath150 with @xmath154 and @xmath155 there exists a term @xmath156 such that @xmath157 and @xmath158 .",
    "an _ orthogonal _",
    "trs is a _ left - linear _ and _ non - overlapping _ trs . here _",
    "left - linear _ means that no variable occurs more than once in each left - hand side .",
    "a trs is _ overlapping _ , if some pair of rules @xmath159 and @xmath160 in @xmath139 , renamed so that variables are disjoint , satisfies : ( i )  a subterm @xmath161 of @xmath162 is unifiable with @xmath163 , i.e. , @xmath164 for some substitution @xmath165 ; and ( ii )  if @xmath166 then the rules @xmath159 and @xmath160 are not equal up to renaming of variables .",
    "note that every orthogonal trs is confluent  @xcite .",
    "a trs @xmath139 is a _",
    "trs if all left - hand sides are basic terms .",
    "we fix _ call - by - value _ semantics and only consider _ constructor _ trss @xmath139 .",
    "input and output are taken from the set of values @xmath167 , and defined symbols @xmath108 denote computed functions .",
    "more precise , a ( finite ) _ computation _ of @xmath168 on input @xmath169 is given by _",
    "innermost _ reductions @xmath170 if the above computation ends in a value , i.e. , @xmath171 , we also say that @xmath134 _ computes _ on input @xmath172 in @xmath173 steps the value @xmath174 .    to account for nondeterministic computation ,",
    "we capture the semantics of @xmath139 by assigning to each @xmath30-ary defined symbol @xmath108 an @xmath175-ary relation @xmath176 that relates input arguments @xmath172 to computed values @xmath174 .",
    "set @xmath177 of _ non - accepting patterns _ is used to distinguish meaningful outputs @xmath174 from outputs that should not be considered part of the computation  @xcite .",
    "a value @xmath174 _ is accepting _ with respect to @xmath177 if no @xmath178 and no substitution @xmath165 exists , such that @xmath179 holds .",
    "a typical example of a value that should not be accepted is the constant @xmath180 appearing in the trs @xmath1 from example  [ ex : rssat ] .",
    "below function problem are extended to @xmath175-ary relations in the obvious way .",
    "[ d : computation ] let @xmath139 be a trs and let @xmath177 be a set of non - accepting patterns . for each @xmath30-ary symbol @xmath108",
    "the _ relation @xmath181 defined by @xmath134 in @xmath139 _ is given by @xmath182 w } \\text { and $ w$ is accepting with respect to $ \\na$}\\tpkt\\ ] ] we say that @xmath139 _ computes _ the function problems associated with @xmath176 .",
    "note that if @xmath139 is confluent , then @xmath176 is in fact a ( partial ) function .",
    "following  @xcite we adopt an _ unitary cost model _ for rewriting , where each reduction step accounts for one time unit , cf .",
    "reductions are of course measured in the size of the input .    the _ innermost runtime complexity function _",
    "@xmath183}{\\n \\to \\n}$ ] relates sizes of basic terms @xmath184 to the maximal length of computation .",
    "formally @xmath185(n ) \\defsym",
    "\\max\\{\\ell \\mid \\exists s \\in \\basics , \\size{s } \\leqslant n \\text { and } s   = t_0 \\irew t_1 \\irew \\dots \\irew t_\\ell\\ } \\tpkt\\ ] ] if clear from context , we sometime drop the qualifier innermost and simply speak of _ runtime complexity _",
    "( of the trs @xmath139 ) .",
    "the restriction @xmath186 accounts for the fact that computations start only from basic terms .",
    "we sometimes use @xmath187(s ) \\defsym",
    "\\max\\{\\ell \\mid \\exists t.~s \\irsl{\\ell } t\\}$ ] to refer to the _ ( innermost ) derivation height _ of a single term @xmath93 .",
    "note that the runtime complexity function is well - defined if @xmath139 is _ terminating _",
    ", i.e. , @xmath149 is well - founded .",
    "suppose @xmath188 is asymptotically bounded from above by a linear , quadratic ,  , polynomial function , we simply say that the runtime of @xmath139 is linear , quadratic ,  , or respectively polynomial .",
    "if no confusion can arise , we drop the reference to the trs @xmath139 and simple write @xmath189 instead of @xmath190 $ ] .",
    "by folklore it is known that rewriting can be implemented with only polynomial overhead if terms grow only polynomial during reductions .",
    "this implies that the functions computed by specific trss of polynomial runtime complexity can be implemented with polynomial time complexity on a turing machine ( or an alternative computation model ) .",
    "this observation can be significantly extended as it can be shown that the restriction on polynomial growth is not necessary .    in  @xcite it is shown that the unitary cost model is reasonable for full rewriting .",
    "the deterministic case was established independently in  @xcite using essentially the same approach . by proposition  [ p : fnp ] and a suitable adaption of theorem  6.2 in  @xcite to innermost rewriting we obtain the following proposition .",
    "[ p : invariance ] let @xmath139 be a rewrite system with polynomial runtime . then the function problems associated with @xmath176 defined by @xmath139 are contained in @xmath4 .",
    "if @xmath139 is confluent , i.e. , deterministic , then @xmath176 is a ( partial ) function contained in @xmath18 .",
    "our choice of adopting call - by - value semantics rests on the observation that the unitary cost model of unrestricted rewriting often overestimates the runtime complexity of computed functions .",
    "this has to do with the unnecessary duplication of redexes .",
    "[ ex : dup ] consider the constructor trs @xmath191 given by the following rules : @xmath192 then for @xmath193 , @xmath194 computes a binary tree of height @xmath30 in a linear number of steps . on the other hand",
    ", @xmath191 gives also rise to a non - innermost reduction @xmath195 obtained by preferring @xmath196 over @xmath197 .",
    "the length of the derivation is however exponential in @xmath30 .",
    "by proposition  [ p : invariance ] we obtain @xmath198 .",
    "as indicated later , our analysis can automatically classify the function @xmath199 as feasible .",
    "we arrive at the formal definition of the _ polynomial path order _ ( _ _ for short ) .",
    "variants of the definition presented here have been presented in earlier conference publications  @xcite .    as already mentioned in the introduction the multiset path order capture the primitive recursive functions .",
    "hence reduction orders can entail implicit characterisations of complexity classes .",
    "this motivates the quest for a miniaturisation of  that precisely captures the class @xmath18 .",
    "another motivation for the design of  rests on the observation that term - rewriting characterisations of complexity classes may facilitate the study of ( low ) complexity classes , cf .",
    "such applications imply the need to craft an order that induces polynomial innermost runtime complexity",
    ".  meets these demands , by providing a syntactic account of the _ predicative analysis _ of recursion set forth by bellantoni and cook  @xcite .",
    "analogously  can be conceived as syntactic account of leivant s notion of _ tiered recurrence _",
    "@xcite .    for each function @xmath134",
    ", the arguments to @xmath134 are separated into _ normal _ and _ safe _ ones . to highlight this separation ,",
    "we write @xmath200 where arguments @xmath201 to the left of the semicolon are normal , the arguments @xmath202 to the right are safe .",
    "bellantoni and cook define a class @xmath203 , consisting of a small set of initial functions and that is closed under _",
    "safe composition _ and _ safe recursion on notation _",
    "( _ safe recursion _ for brevity ) .",
    "the crucial ingredient in @xmath203 is that a new function @xmath134 is defined via safe recursion by the equations : @xmath204 for functions @xmath205 and @xmath206 already defined in @xmath203 .",
    "this definition corresponds to a recursion on the binary representation of numbers .",
    "consequently the number of recursive calls is linear in the size of the recursive input . unlike primitive recursive functions , the stepping functions @xmath207 can not perform recursion on the _ impredicative _ value @xmath208",
    "this is a consequence of _ data tiering _ : recursion is performed on _ normal _ arguments only .",
    "dual , the recursive call @xmath208 is substituted into a _",
    "safe _ argument position .    to maintain the separation , safe composition",
    "restricts the usual composition operator so that safe arguments are not substituted into normal argument position .",
    "precisely , for functions @xmath209 , @xmath210 and @xmath211 already defined in @xmath203 , a function @xmath134 is defined by safe composition using the equation @xmath212 crucially , the safe arguments @xmath202 are absent in normal arguments to @xmath209 . the main result from  @xcite states that the class @xmath203 coincides with the class of polytime computable functions  @xmath18 .    as a first step to capture the notion of predicative recursion in  @xmath21",
    ", we introduce the concept of _ safe mappings _ to handle the separation of argument positions .",
    "[ d : safemapping ] a _ safe mapping _",
    "@xmath213 is a function @xmath214 that associates with every @xmath30-ary function symbol @xmath134 the set of _ safe argument positions _",
    "argument positions included in @xmath216 are called _ safe _ , those not included are called _ normal _ and collected in @xmath217 . for @xmath30-ary constructors",
    "@xmath15 we require that all argument positions are safe , i.e. , @xmath218 .",
    "we refine term equivalence so that the safe mapping is taken into account .",
    "[ d : eqis ] let @xmath219 denote a precedence and @xmath213 a safe mapping . we define _",
    "safe equivalence _",
    "@xmath220 for terms @xmath221 inductively as follows : @xmath222 if either @xmath124 or @xmath125 , @xmath126 , @xmath127 and there exists a permutation @xmath128 such that for all @xmath130 , @xmath223 and @xmath224 if and only if @xmath225 .    to avoid notational overhead , we fix a safe mapping @xmath213 and suppose that for each @xmath226 ary function symbol @xmath134 , the first @xmath227 argument positions are normal , and the remaining argument positions are safe , i.e. , @xmath228 .",
    "this allows use to write @xmath229 as before .",
    "we require that the precedence @xmath26 adheres the partitioning of @xmath102 into defined symbols and constructors in the following sense .",
    "a precedence @xmath26 is _ admissible _ ( for ) if @xmath127 implies that either both @xmath134 and @xmath230 are defined symbols , or both are constructors .",
    "in particular @xmath220 preserves values , i.e. , if @xmath231 and @xmath222 then also @xmath232 .",
    "the following definition introduces an auxiliary order @xmath233 , the full order @xmath234 is then presented in definition  [ d : gpop ] .",
    "[ d : gsq ] let @xmath219 denote a precedence .",
    "consider terms @xmath235 such that @xmath236[l]{s})$ ] .",
    "then @xmath237 if one of the following alternatives holds :    1 .",
    "[ d : gsq : st ] @xmath238 for some @xmath239 and , if @xmath108 then @xmath240 is a normal argument position ( @xmath241 ) ; 2 .   [",
    "d : gsq : ia ] @xmath108 , @xmath242[n]{t})$ ] where @xmath243 and @xmath244 for all @xmath245 .",
    "here we set @xmath246 .",
    "consider a function @xmath134 defined by safe composition from @xmath94 and @xmath93 , cf .",
    "the effect of this auxiliary order is to ( properly ) encompass safe composition in the full order @xmath234 .",
    "note that the auxiliary order can orient @xmath247 for defined symbols @xmath134 and @xmath94 with @xmath248 . on the other hand , @xmath249 and safe arguments",
    "@xmath250 are incomparable , and thus the orientation of @xmath249 and @xmath251 fails , even if @xmath252 is supposed .",
    "[ d : gpop ] let @xmath219 denote a precedence .",
    "consider terms @xmath235 such that @xmath236[l]{s})$ ] .",
    "then @xmath253 if one of the following alternatives holds :    1 .",
    "[ d : gpop : st ] @xmath254 for some @xmath239 , or 2 .",
    "[ d : gpop : ia ] @xmath108 , @xmath242[n]{t})$ ] where @xmath243 and the following conditions hold : * @xmath255 for all normal argument positions @xmath256 ; * @xmath257 for all safe argument positions @xmath258 ; * @xmath259 for at most one safe argument position @xmath260 ; 3 .",
    "[ d : gpop : ep ] @xmath108 , @xmath242[n]{t})$ ] where @xmath127 and the following conditions hold : * @xmath261{s } } \\gpopmul \\mset{\\seq[m]{t}}$ ] ; * @xmath262[k+1]{s } } \\geqpopmul \\mset{\\seq[m+n][m+1]{t}}$ ] .    here",
    "@xmath263 .",
    "we use the notation @xmath264 and respectively @xmath265 to refer to the case in definition  [ d : gsq ] respectively definition  [ d : gpop ] . note that  is not a reduction order , as for example closure under contexts fails due to the conditions put upon @xmath266 .",
    "however  is a restriction of  and thus a _ termination order_.    the restrictions put upon amount to the fact that allows at most one recursive call per right - hand side .",
    "the proposed constraints are weaker compared to the corresponding clause given in  ( * ? ? ?",
    "* definition 4 ) . the early definition from  ( * ? ? ?",
    "* definition  4 ) , used the full order @xmath234 only on one argument of the right - hand side ( the one that possibly holds the recursive call ) , the remaining arguments were all oriented with the auxiliary order @xmath233 .",
    "the case accounts for definitions by safe composition .",
    "the final restriction put onto is used to prevent multiple recursive calls as indicated in example  [ ex : rs2 ] .",
    "the case restricts the corresponding case in   by taking the separation of normal and safe argument positions into account .",
    "note that here normal arguments need to decrease .",
    "this reflects that as in recursion is performed on normal argument positions .",
    "we emphasise that one application of possibly followed by one application of orients the defining equations in , using the obvious precedence ( using suitable term representation of natural numbers ) .    our order - theoretic account of predicative recursion motivates following definition .",
    "we call a constructor trs @xmath139 _ predicative recursive _ , if @xmath139 is compatible with an instance @xmath234 of @xmath21 based on an admissible precedence",
    ".    note that it can be determined in nondeterministic polynomial time that a constructor trs is predicative recursive : simply guess a safe mapping and a precedence and apply the definition of .",
    "this is in contrast to semantic method ( like additive polynomial interpretations ) whose synthesis is undecidable in general .",
    "we clarify definition  [ d : gpop ] on several examples .",
    "the first of these examples shows a typical application of predicative recursion .",
    "[ ex : mult1 ] consider the trs @xmath267 expressing multiplication in peano arithmetic .",
    "@xmath268 the trs @xmath267 is predicative recursive , using the precedence @xmath269 and the safe mapping as indicated in the rules : the rules and are oriented by .",
    "the rule is oriented by @xmath270 using @xmath271 and @xmath272 .",
    "note that the latter inequality only holds as the first argument position of addition is normal .",
    "similar , the final rule is oriented by , employing @xmath273 together with @xmath274 and @xmath275 .",
    "note that the latter two inequalities require that the both argument positions of @xmath276 are normal , i.e. ,  are used for recursion .",
    "we re - consider the motivation example  [ ex : rssat ] from the introduction .",
    "[ ex : rssat:2 ] consider the trs  @xmath1 from the motivating example  [ ex : rssat ] , where the separation into normal and safe arguments for the defined function symbols is defined as follows : @xmath277 , @xmath278 .",
    "we set @xmath279 , and for all remaining defined function symbols , we make all arguments normal , i.e. , @xmath280 .",
    "then @xmath281 for any admissible precedence satisfying the following constraints : @xmath282 , @xmath283 , @xmath284 , and @xmath285 .",
    "the next example is negative , in the sense that the considered trss admits polynomial runtime complexity , but fails to be compatible with @xmath21 .",
    "consider the trs @xmath267 where the rule is replaced by the rule @xmath286{times2a}~\\times(\\sn{\\ms(\\sn{}{x}),y } { } ) \\to + ( \\sn{\\times(\\sn{x , y}{})}{y } )    \\tpkt\\ ] ] the resulting system has polynomial runtime complexity , which can be automatically verified with  .",
    "however , the trs does not follow the rigid scheme of predicative recursion . for this reason ,",
    "it can not be handled by .",
    "technically , the terms @xmath287 and @xmath288 are incomparable with respect to @xmath233 independent on the precedence , and consequently also orientation of left- and right - hand side with fails .    the following examples clarifies the need for data tiering .",
    "consider the extension of @xmath267 by the two rules @xmath289 that express exponentiation @xmath290 in an exponential number of steps .",
    "the definition of @xmath291 disregards data tiering as imposed by predicative recursion .",
    "in particular , since @xmath276 admits no safe argument positions it can not serve as a stepping function .",
    "independent on the safe mapping for @xmath291 , rule can not be oriented using polynomial path orders .",
    "the following theorem constitutes the first main result of this paper .",
    "[ t : popstar ] let @xmath139 be a predicative recursive ( constructor ) trs",
    ". then the innermost derivation height of any basic term @xmath292 is bounded by a polynomial in the maximal depth of normal arguments @xmath293 .",
    "the polynomial depends only on @xmath139 and the signature @xmath102 .",
    "in particular , the innermost runtime complexity of @xmath139 is polynomial .",
    "[ popstar : proofplan ] the proof of theorem  [ t : popstar ] is involved and requires a variety of ingredients .",
    "we give a short outline . in section  [",
    "s : pop ] , we define _ predicative interpretations _ @xmath294 that flatten terms to _ sequences of terms _ , essentially separating safe from normal arguments .",
    "this allows us to analyse terms independent from safe arguments .",
    "then we introduce an order @xmath295[]$ ] on sequences of terms , that is simpler compared to @xmath234 and does not rely on the separation of argument positions .",
    "this _ polynomial path order on sequences _ extends the polynomial path order for @xmath18 , introduced in  @xcite . in section  [ s :",
    "embed ] we establish a _ predicative embedding _ of derivations into @xmath295[]$ ] as depicted in figure  [ fig:2 ] .",
    ";    ;    ;    in 1, ... ,2 ( s _ ) at ( , 0 ) @xmath296 ; ( is _ ) at ( , -0.9 ) @xmath297 ; ( s _ ) to node[right ] ( is _ ) ; ;    ; at ( , 0 ) @xmath298 ; at ( , -0.9 ) @xmath298 ; ( s_2 + 2 ) at ( , 0 ) @xmath299 ; ( is_2 + 2 ) at ( , -0.9 ) @xmath300 ; ( s_2 + 2 ) to node[right ] ( is_2 + 2 ) ; ;    in 1, ... ,2 ( rew _ ) at ( + 1.8/2,0 ) @xmath149 ; ( ord _ ) at ( + 1.8/2,-0.9 ) @xmath295[]$ ] ; ; ( rew_2 + 1 ) at ( + 1.8/2,0 ) @xmath149 ; ( ord_2 + 1 ) at ( + 1.8/2,-0.9 ) @xmath295[]$ ] ; ;    in theorem  [ t : pop ] we show that the length of @xmath295[]$ ] descending sequences starting from basic terms can be bound appropriately .",
    "one may wonder whether a precise degree on the provided polynomial bound can be obtained by reasoning based on the depth of recursion and formation of composition rules .",
    "this is not the case as lemma  [ l : imprecise ] clarifies , where we provide a family of trs @xmath301 , all with depth of recursion one and without the use of composition , such that @xmath302(n ) } = \\omega(n^k)$ ] .",
    "however , it is possible to design a restriction of , dubbed _ small polynomial path order _ in  @xcite , which induces a precise degree on the provided polynomial bound .",
    "[ l : imprecise ] for every @xmath303 there exists a trs @xmath304 over constructors @xmath305 defining a single defined symbol @xmath306 such that @xmath307 and @xmath302(n ) } = \\omega(n^k)$ ] .",
    "consider the following trs @xmath304 that is compatible with @xmath234 : @xmath308 we show the stronger claim that for all @xmath309 there exist constants @xmath310 such that @xmath311{{\\geqslant}c_k \\cdot n^k } \\m{f}_k(0 , \\dots , 0)\\ ] ] by induction on @xmath227 .",
    "the base case is trivial , we consider the inductive step . applying the induction hypothesis , by definition of @xmath304 and @xmath312",
    "it is easy to see that for all @xmath309 @xmath313{{\\geqslant}c_k \\cdot n^k } \\m{f}_{k+1}(0 , \\dots , 0,\\ms^{n}(0 ) ) \\\\    & \\rew[\\rs_{k+1}]\\m{f}_{k+1}(\\ms^{n-1}(0),\\dots,\\ms^{n-1}(0),\\ms^{n-1}(0 ) ) \\tpkt    \\end{aligned}\\ ] ] using this observation , a simple side induction on @xmath30 reveals @xmath314{{\\geqslant}f(n ) } \\m{f}_{k+1}(0 , \\dots , 0 , 0)\\ ] ] where @xmath315 . the exact overhead due to multiset comparisons is further investigated in example  [ ex : multisets ] .",
    "the next three examples stress that the restrictions to runtime complexity ( example  [ ex : dc ] ) , innermost reductions ( example  [ ex : outermost ] ) , as well as constructor trss ( example  [ ex : constructor ] ) , are all essential for the correctness of theorem  [ t : popstar ] .",
    "[ ex : dc ] consider the trs @xmath316 given by the following rules , cf .",
    "* example  1 ) .",
    "@xmath317 where we suppose that @xmath318 and @xmath319 are the only constructors . as shown by hofbauer and lautemann",
    ", @xmath316 admits at least double - exponentially _ derivational complexity _ ; in particular it is easy to find a family of terms @xmath320 such that @xmath321 .",
    "on the other hand @xmath316 is compatible with a polynomial path order @xmath234 as induced by a precedence @xmath26 satisfying @xmath322 and the safe mapping as indicated in the rules . as a side - remark",
    "we emphasise that the orientability of rule   induces that  properly extends the safe composition scheme  .",
    "[ ex : outermost ] observe that @xmath323 with any admissible precedence satisfying @xmath324 for the trs @xmath191 depicted in example  [ ex : dup ] .",
    "we use @xmath325 and @xmath326 for the defined function symbols .",
    "theorem  [ t : popstar ] thus implies that the ( innermost ) runtime complexity of @xmath191 is polynomial . on the other hand",
    ", we already observed that @xmath191 admits exponentially long _ outermost _ reductions .",
    "[ ex : constructor ] consider the trs @xmath327 given by the rules @xmath328 where we suppose that the only constructors are @xmath329 , @xmath318 and @xmath319 .",
    "the rule   is used to define the symbol @xmath330 , and to properly set up the precedence .",
    "the rules   and   are used to translate a tower @xmath331 to @xmath332 , using rule   we thus obtain a family of reductions @xmath333 \\mh(\\sn{}{\\m{gs}(\\sn{\\ms^n(\\sn{}{0 } ) } { } ) } )     \\rss[\\rsnc ] \\mh(\\sn{}{\\mg^n(\\sn{}{0 } ) } { } ) \\tkom\\ ] ] for @xmath193 .",
    "it is not difficult to see that the derivation height of the final term @xmath334 grows exponentially in @xmath30 due to rule , and so the innermost runtime complexity of @xmath327 is bounded by an exponential from below .    on the other hand , @xmath327 is compatible with a polynomial path order @xmath234 as induced by a precedence @xmath26 satisfying @xmath335 and the safe mapping as indicated in the rules . observe that for rule   we exploit that @xmath330 is defined , conclusively one can show @xmath336 and therefore @xmath337 holds .",
    "however , due to rule   @xmath327 is not a constructor trs , as demanded by theorem  [ t : popstar ] .",
    "bellantoni and cook s characterisation , as well as leivant s work on tiered recurrence , was originally stated on word algebras . in quite recent",
    "work by dal  lago  et  al .",
    ",  @xcite the result by leivant  @xcite has been extended to arbitrary free algebras .",
    "in particular , in  @xcite a function @xmath134 is defined by _ general ramified recursion _ as @xmath338 for every @xmath30-ary constructor @xmath15 , provided a data tiering principle is satisfied . due to the linearity condition imposed on @xmath270 , such a recursion principle can not be expressed in predicative recursive trss . indeed , allowing this form of recursion would invalidate theorem  [ t : popstar ] .",
    "let @xmath339 denote the extension of @xmath191 from example  [ ex : dup ] by the rules @xmath340 the above definition of @xmath341 is expressible in the system of  @xcite , by simply conceiving the rewrite rules as defining equations .",
    "in particular it follows that @xmath176 is polytime computable . on the other hand ,",
    "the runtime complexity of @xmath339 is at least exponential as a derivation of @xmath342 , @xmath339 traverses every node of a binary tree of height @xmath30 .",
    "finally we note that the order @xmath234 is _ blind _ on constructors , in particular @xmath234 collapses to the subterm relation ( modulo equivalence ) on values .",
    "[ l : gpop : val ] suppose the precedence underlying @xmath234 is admissible .",
    "if @xmath253 and @xmath231 then @xmath112 is a safe subterm of @xmath93 ( modulo @xmath220 ) , in particular @xmath232 holds .",
    "fix again a safe mapping @xmath213 on the signature @xmath102 .",
    "we now define the notion of _ predicative interpretation _ of a term @xmath112 . guided by the safe mapping , predicative interpretations map terms to sequences of terms .",
    "we then introduce the _ polynomial path order on sequences _ , intended to orient images of the predicative interpretation as outlined before .",
    "to formalise sequences , we use an auxiliary variadic function symbol @xmath343 . here",
    "variadic means that the arity of @xmath343 is finite but arbitrary .",
    "we always write @xmath344 for @xmath345 , in particular if we write @xmath346 then @xmath347 .",
    "define the _ normalised signature _ @xmath348 as follows : @xmath349 the predicative interpretation of a term @xmath229 results in a sequence @xmath350{a } ) } \\append a_{k+1 } \\append \\cdots \\append a_{k+l}$ ] , where @xmath351 denotes _ concatenation _ of sequences and the sequences @xmath352 are predicative interpretations of the corresponding arguments @xmath353 ( @xmath354 ) .",
    "note that in the interpretations , terms have sequences as arguments .",
    "[ d : sequencedterms ] the set of _ terms with sequence arguments _ @xmath355 and the set of _ sequences _",
    "@xmath356 is inductively defined as follows :",
    "@xmath357 , and 2 .",
    "if @xmath358 and @xmath359 then @xmath360 , and 3 .   if @xmath361 then @xmath362 .",
    "we always write @xmath363 , possibly extended by subscripts , for elements from @xmath364 and @xmath365 .",
    "the restriction of @xmath364 and @xmath365 to ground terms is denoted by @xmath366 and @xmath367 respectively .",
    "when no confusion can arise from this we call terms with sequence arguments simply terms .",
    "further , we sometimes abuse set notation and write @xmath368 if @xmath369 for some @xmath130 .",
    "we denote by @xmath370 the _ concatenation _ of @xmath371 and @xmath372 . to avoid notational overhead we overload concatenation to both terms and sequences .",
    "let @xmath373 if @xmath374 and @xmath375 if @xmath376 .",
    "we set @xmath377 where @xmath378 and @xmath379{b}$ ] .",
    "as concatenation is associative we drop parenthesis at will .",
    "we define the _ length _ over @xmath380 as @xmath381 where @xmath378 . the _ sequence width _",
    "@xmath382 ( or _ width _ for short ) of an element @xmath371 is given recursively by @xmath383 in the following we tacitly employ @xmath384 and @xmath385 for all @xmath386 .",
    "we define the _ norm _ of @xmath143 in correspondence to the depth of @xmath112 , but disregard normal argument positions .",
    "@xmath387[l]{t})$}.    \\end{cases }    \\tpkt\\ ] ] note that since all argument positions of constructors are safe,[d : normonval ] the norm @xmath388 and depth @xmath389 coincide on values .",
    "predicative interpretations are given by two mappings @xmath294 and @xmath390 : the interpretation @xmath294 is applied on safe arguments and removes normal forms ; the interpretation @xmath390 is applied to normal arguments and additionally encodes the norm of the given term as tally sequence . the latter allows us to track the maximal depth of normal forms erased by @xmath294 .",
    "let @xmath391 be a fresh constant . to encode natural numbers @xmath41 ,",
    "define its _ tally sequence representation _ @xmath392 as the sequence containing @xmath30 occurrences of this fresh constant : @xmath393 and @xmath394 .",
    "[ d : pi ] a _ predicative interpretation _ for a trs @xmath139 is a pair @xmath395 of mappings @xmath396 defined as follows : @xmath397 here ( @xmath398 ) stands for @xmath399 .    as the rewrite system",
    "@xmath139 is usually clear from the context , we drop the references to @xmath139 when unambiguous .",
    "below we introduce the order @xmath295[]$ ] on sequences @xmath400 . in the next section",
    "we then embed innermost @xmath139-steps into this order , and use @xmath295[]$ ] to estimate the length of reductions accordingly . for basic terms",
    "@xmath401 we obtain @xmath402 hence the obtained bound depends on depths of normal arguments only . to get the reader prepared for the definition of @xmath295[]$ ] ,",
    "we exemplify definition  [ d : pi ] on a predicative recursive trs .",
    "[ ex : pint ] consider following trs @xmath403 , where we suppose that besides @xmath341 , also @xmath404 and @xmath405 are defined symbols : @xmath406 consider a substitution @xmath407 .",
    "using that @xmath408 and @xmath409 for all normal forms @xmath410 , the embedding @xmath411 [ ] \\ints(r\\sigma)$ ] of root steps ( @xmath412 ) results in the following order constraints . @xmath413 [ ] \\nil & & \\text{from rule \\rlbl{1}}\\\\      \\mparbox[r]{45mm}{\\lst{\\fsn{\\m{f}}(\\nattoseq{\\depth(x\\sigma ) + 1 } ) } } & \\gpopv [ ] [ ] \\mparbox[l]{65mm}{\\lst{\\fsn{\\m{g}}(\\intn(\\m{h}(\\sn{x\\sigma}{})))~\\fsn{\\m{f}}(\\nattoseq{\\depth(x\\sigma ) } ) } }   & & \\text{from rule \\rlbl{2 } , }    \\end{aligned}\\ ] ] where @xmath414 .",
    "consider now a step @xmath415 f(s_1,\\dots , t_i,\\dots , s_{k+l } ) = t \\tkom\\ ] ] below the root , where @xmath416 t_i$ ] .",
    "depending on the rewrite position @xmath240 , which is either normal ( @xmath241 ) or safe ( @xmath417 ) , the predicative embedding introduces one of the following two constraints : @xmath418 [ ] \\lst{\\fn(\\intn(s_1 ) , \\dots , \\intn(t_i ) , \\dots , \\intn(s_k ) ) } \\append \\ints(s_{k+1 } ) \\append \\cdots \\append \\ints(s_{k+l } ) = \\intn(t ) , \\text { or } \\\\[1 mm ]      \\ints(s )      & = \\lst{\\fn(\\intn(s_1 ) , \\dots , \\intn(s_k ) ) } \\append \\ints(s_{k+1 } ) \\append \\cdots \\append \\ints(s_{i } ) \\append \\cdots \\append \\ints(s_{k+l } )",
    "\\tag{b } \\\\      & \\gpopv [ ] [ ] \\lst{\\fn(\\intn(s_1 ) , \\dots , \\intn(s_k ) ) } \\append \\ints(s_{k+1 } ) \\append \\cdots \\append \\ints(t_{i } ) \\append \\cdots \\append \\ints(s_{k+l } ) = \\ints(t ) \\tpkt    \\end{aligned}\\ ] ] to be able to deal with steps below normal argument positions as in @xmath419 , we also orient images of @xmath390 .",
    "this results additionally in following constraints : @xmath420 [ ] \\ints(y\\sigma ) \\append \\nattoseq{\\depth(y\\sigma ) }      & & \\text{from rule \\rlbl{1}}\\\\      \\mparbox[r]{45mm}{\\ints(\\m{f}(\\sn{\\ms(x\\sigma)}{y\\sigma}))\\append \\nattoseq{\\depth(y\\sigma ) + 1 } }       & \\gpopv [ ] [ ] \\mparbox[l]{65mm}{\\ints(\\m{g}(\\sn{\\m{h}(\\sn{x\\sigma}{})}{\\m{f}(\\sn{x\\sigma}{y\\sigma } ) } ) ) \\append \\nattoseq{\\depth(y\\sigma ) + 2 } }      & & \\text{from rule \\rlbl{2}}.    \\end{aligned}\\ ] ]    the _ polynomial path order on sequences _ ( _ _  for short ) , denoted by @xmath295[]$ ] , constitutes a generalisation of the _ path order for @xmath18 _ as put forward in  @xcite . whereas we previously used the notion of safe mapping to dictate predicative recursion on compatible trss , the order on sequences relies on the explicit separation of safe arguments as given by predicative interpretations .",
    "following buchholz  @xcite , it suffices to present _ finite approximations _",
    "@xmath421[l]$ ] of  @xmath295[]$ ] .",
    "the parameters @xmath422 and @xmath423 are used to controls the width and depth of right - hand sides . fix a precedence @xmath26 on the normalised signature @xmath348 .",
    "we extend term equivalence with respect to @xmath26 to sequences by disregarding the order on elements .",
    "[ d : eqi ] we define @xmath424 if @xmath425 or there exists a permutation @xmath128 such that @xmath426 for all @xmath427 , where either ( i ) @xmath428 , @xmath429 , or ( ii ) @xmath430 , @xmath431 and @xmath127 .    in correspondence to @xmath234 , the order @xmath421[l]$ ] is based on an auxiliary order @xmath432[l]$ ] .",
    "[ d : gppv ] let @xmath433 .",
    "we define @xmath432[l]$ ] with respect to the precedence @xmath26 inductively as follows :    1 .",
    "[ d : gppv : st ] @xmath434[l ] b$ ] if @xmath435[l ] b$ ] for some @xmath130 ; 2 .",
    "[ d : gppv : ia ] @xmath434[l ] g(\\seq[m]{b})$ ] if @xmath243 and the following conditions are satisfied : * @xmath434[l-1 ] b_j$ ] for all @xmath256 ; * @xmath436 ; 3 .",
    "[ d : gppv : ialst ] @xmath434[l ] \\lseq[m]{b}$ ] if the following conditions are satisfied : * @xmath434[l-1 ] b_j$ ] for all @xmath256 ; * @xmath437 ; 4 .",
    "[ d : gppv : ms ] @xmath438[l ] \\lseq[m]{b}$ ] if the following conditions are satisfied : * @xmath439{b } \\eqi c_1 \\append \\cdots \\append c_n$ ] ; * @xmath435[l ] c_i$ ] for all @xmath440 ; * @xmath441[l ] c_{i_0}$ ] for at least one @xmath442 ; * @xmath443 ;    here @xmath444[l]}$ ] denotes @xmath445[l ] } \\cup { \\eqi}$ ] .",
    "we write @xmath432 $ ] to abbreviate @xmath432[k]$ ] .",
    "we stress that the definition lacks a case @xmath434[l ] g(\\seq[m]{b})$ ] where @xmath127 .",
    "still the order is sufficient to account for terms oriented by the auxiliary order @xmath233 .",
    "[ ex : gppv ] reconsider rule @xmath446 from the trs @xmath403 given in example  [ ex : pint ] , where in particular @xmath447 .",
    "we show below @xmath448[4 ] \\intn(\\m{h}(\\sn{\\ms(x\\sigma)}{}))$ ] for all substitutions @xmath407 .",
    "first recall that by the overloading of concatenation , we can write @xmath449 with @xmath30 occurrences of @xmath450 , appending @xmath451-times the empty sequence @xmath11 for all @xmath452 . using that @xmath453 and @xmath454[l-1 ] \\nil$ ] for @xmath455 , we can thus prove @xmath456[l ] \\nattoseq{n}$ ] whenever @xmath457 .",
    "moreover we have @xmath458[2 ] \\nattoseq{\\depth(x\\sigma ) }        & & \\text{as $ \\depth(x\\sigma ) + 1 > \\depth(x\\sigma)$ }       \\\\      \\rlbl{2 } : & & \\fsn{\\m{f}}(\\nattoseq{\\depth(x\\sigma ) + 1 } )       & \\cppv{ia}[1][3 ] \\fsn{\\m{h}}(\\nattoseq{\\depth(x\\sigma ) } )      & & \\text{using $ \\fsn{\\m{f } } \\sp \\fsn{\\m{h}}$ and \\rlbl{1 } }       \\\\      \\rlbl{3 } : & & \\fsn{\\m{f}}(\\nattoseq{\\depth(x\\sigma ) + 1 } )       & \\cppv{ialst}[1][4 ] \\lst{\\fsn{\\m{h}}(\\nattoseq{\\depth(x\\sigma)})~\\theconst }      & & \\text{by \\rlbl{2 } and $ \\fsn{\\m{f}}(\\dots ) \\cppv{ia}[1][3 ] \\theconst$ } \\\\       & & & = \\intn(\\m{h}(\\sn{x\\sigma } { } ) )       \\tpkt    \\end{aligned}\\ ] ]    we arrive at the definition of the full order @xmath421[l]$ ] .",
    "[ d : gpopv ] let @xmath433 .",
    "we define @xmath421[l]$ ] inductively as the least extension of @xmath432[l]$ ] such that :    1 .   [",
    "d : gpopv : st ] @xmath459[l ] b$ ] if @xmath460[l ] b$ ] for some @xmath130 ; 2 .",
    "[ d : gpopv : ep ] @xmath459[l ] g(\\seq[m]{b})$ ] if @xmath127 and following conditions are satisfied : * @xmath461[l]}~\\mset{\\seq[m]{b}}$ ] ; * @xmath436 ; 3 .",
    "[ d : gpopv : ialst ] @xmath459[l ] \\lseq[m]{b}$ ] and following conditions are satisfied : * @xmath459[l-1 ] b_{j_0}$ ] for at most one @xmath462 ; * @xmath434[l-1 ] b_j$ ] for all @xmath463 ; * @xmath437 ; 4 .",
    "[ d : gpopv : ms ] @xmath464[l ]   \\lseq[m]{b}$ ] and following conditions are satisfied : * @xmath439{b } \\eqi c_1 \\append \\cdots \\append c_n$ ] ; * @xmath460[l ] c_i$ ] for all @xmath465 ; * @xmath466[l ] c_{i_0}$ ] for at least one @xmath467 ; * @xmath443 ;    here @xmath468[l]}$ ] denotes @xmath469[l ] } \\cup { \\eqi}$ ] .",
    "we write @xmath421 $ ] to abbreviate @xmath421[k]$ ] .",
    "the polynomial path order on sequences forms a restriction of the recursive path order with multiset status , where the variadic symbol @xmath343 is implicitly ranked lowest in the precedence . as a consequence the order it is well - founded  @xcite .",
    "the use of the auxiliary order in @xmath470[l]$ ] accounts for our restriction that predicative recursive trss admit at most one recursive call per right - hand side .",
    "observe @xmath471 for all terms @xmath472 , consequently @xmath473 if at least one term @xmath474 is ground .",
    "[ ex : gpopv ] we continue with the orientation of root steps from the trs @xmath403 depicted in example  [ ex : pint ] for substitutions @xmath407 .",
    "consider the more involved case @xmath475 \\m{g}(\\sn{\\m{h}(\\sn{x\\sigma}{})}{\\m{f}(\\sn{x\\sigma}{y\\sigma})})$ ] due to rule .",
    "note that in the orientation below we use @xmath476 to orient the recursive call ( proof step ) , and @xmath477 for the remaining elements ( proof step ) .",
    "@xmath478[2 ] \\nattoseq{\\depth(x\\sigma ) }        & & \\text{as in example~\\ref{ex : gppv } }       \\\\      \\rlbl{5 } : & & \\fsn{\\m{f}}(\\nattoseq{\\depth(x\\sigma ) + 1 } )      & \\cpopv{ep}[1][3 ] \\fsn{\\m{f}}(\\nattoseq{\\depth(x\\sigma ) } )      & & \\text{using \\rlbl{4 } }       \\\\",
    "\\rlbl{6 } : & & \\fsn{\\m{f}}(\\nattoseq{\\depth(x\\sigma ) + 1 } )      & \\cppv{ia}[1][5 ] \\fsn{\\m{g}}(\\intn(\\m{h}(\\sn{x\\sigma } { } ) ) )      & & \\text{using $ \\fsn{\\m{f } } \\sp \\fsn{\\m{g}}$ and \\rlbl{3 } }       \\\\",
    "\\rlbl{7 } : & & \\fsn{\\m{f}}(\\nattoseq{\\depth(x\\sigma ) + 1 } )      & \\cpopv{ialst}[1][6 ] \\lst{\\fsn{\\m{g}}(\\intn(\\m{h}(\\sn{x\\sigma}{})))~\\fsn{\\m{f}}(\\nattoseq{\\depth(x\\sigma ) } ) }      & & \\text{using \\rlbl{5 } and \\rlbl{6 } }      \\\\      & & & = \\ints(\\m{g}(\\sn{\\m{h}(\\sn{x\\sigma}{})}{\\m{f}(\\sn{x\\sigma}{y\\sigma } ) } ) )      \\\\      \\rlbl{8 } : & & \\ints(\\m{f}(\\sn{\\ms(x\\sigma)}{y\\sigma } ) ) & =       \\lst{\\fsn{\\m{f}}(\\nattoseq{\\depth(x\\sigma ) + 1 } ) } \\\\      & & & \\cpopv{ialst}[1][6 ] \\ints(\\m{g}(\\sn{\\m{h}(\\sn{x\\sigma}{})}{\\m{f}(\\sn{x\\sigma}{y\\sigma } ) } ) )      & & \\text{using \\rlbl{7 } }      \\\\      \\rlbl{9 } : & & \\fsn{\\m{f}}(\\nattoseq{\\depth(x\\sigma ) + 1 } )      & \\cpopv{ialst}[2][6 ] \\lst{\\fsn{\\m{g}}(\\intn(\\m{h}(\\sn{x\\sigma}{})))~\\fsn{\\m{f}}(\\nattoseq{\\depth(x\\sigma)})~\\theconst }      & & \\text{by \\rlbl{5 } , \\rlbl{6 } and $ \\fsn{\\m{f}}(\\dots ) \\gpopv[1][1 ] \\theconst$ }      \\\\      \\rlbl{10 } : & & \\intn(\\m{f}(\\sn{\\ms(x\\sigma)}{y\\sigma } ) ) & =       \\lst{\\fsn{\\m{f}}(\\nattoseq{\\depth(x\\sigma ) + 1})}\\append \\nattoseq{\\depth(y\\sigma ) + 1 } \\\\      & & & \\cpopv{ialst}[2][6 ] \\ints(\\m{g}(\\sn{\\m{h}(\\sn{x\\sigma}{})}{\\m{f}(\\sn{x\\sigma}{y\\sigma } ) } ) ) \\append \\nattoseq{\\depth(y\\sigma ) + 2 }      & & \\text{using \\rlbl{9 } and $ \\theconst \\eqi \\theconst$ }      \\\\      & & & = \\intn(\\m{g}(\\sn{\\m{h}(\\sn{x\\sigma}{})}{\\m{f}(\\sn{x\\sigma}{y\\sigma } ) } ) ) \\tpkt    \\end{aligned}\\ ] ] for the last orientation we employ that the width of the left - hand side is at least @xmath479 , and the length of the right hand side is @xmath480 , as required we have @xmath481    observe that as in the above example , the parameter @xmath138 in @xmath421[l]$ ] controls the depth of the proof tree of @xmath482[l ] b$ ] . since leafs of such proof trees hold either due to case @xmath483 or the absence of arguments in the right - hand side , it follows that the depth of @xmath484 is bounded linearly in @xmath138 and the depth of @xmath48 . from the example it should also be clear how the parameter @xmath227 controls the length of right - hand sides , compare steps   and   where we had to increase the parameter @xmath227 .    in the example we obtained that the predicative embedding of root steps @xmath485 r\\sigma$ ] of predicative recursive trs @xmath403 is possible for @xmath486 , independent on the considered substitution @xmath165 .",
    "the next lemma clarifies that such a global @xmath227 can always be found , and depends on the right - hand sides only .",
    "[ l : int : len ] let @xmath487 , @xmath143 , and @xmath165 be a normalising substitution",
    ". then    1 .",
    "[ l : int : len : s ] @xmath488 ; and 2 .",
    "[ l : int : len : gsq ] if @xmath237 then @xmath489 ; and 3 .",
    "[ l : int : len : gpop ] if @xmath253 then @xmath490 .    as a consequence of the above lemma",
    "we obtain : if @xmath491 is a root step of a predicative trs @xmath139 , then @xmath492 for @xmath493 . in the predicative embedding we instantiate @xmath227 by twice the maximum size of right - hand sides of @xmath139 .",
    "the side - conditions imposed on @xmath421[l]$ ] allow us to estimate the length of right - hand sides based on the width of left - hand sides and the parameter @xmath227 .",
    "this and other frequently used properties are collected in the next lemma , whose proof is not difficult .",
    "[ l : approx ] the following properties hold for all @xmath303 and @xmath494 .    1 .",
    "[ l : approx : kmon ] @xmath495 } \\subseteq { \\gpopv[l ] } \\subseteq { \\gpopv[k]}$ ] for all @xmath496 ; 2 .",
    "[ l : approx : modeqi ] @xmath497 } \\cdot { \\eqi } \\subseteq { \\gpopv[k]}$ ] ; 3 .",
    "[ l : approx : bound ] @xmath482 b$ ] implies @xmath498 ; 4 .",
    "[ l : approx : subseq ] @xmath482 b$ ] implies @xmath499 { c_1 \\append b \\append c_2}$ ] .",
    "following  @xcite we define a function @xmath500 $ ] that measures the @xmath421$]-descending lengths on sequences .",
    "to simplify matters , we restrict the definition of @xmath500 $ ] to ground sequences . as images of predicative interpretations",
    "are always ground , this suffices for our purposes .",
    "we define @xmath501}{\\gtls \\to \\n}$ ] as @xmath502(a ) \\defsym 1 + \\max   \\ { \\slow[k](b ) \\mid b \\in \\gtls \\text { and } a \\gpopv[k ] b   \\}\\tpkt\\ ] ]    note that due to lemma  , @xmath500(a ) = \\slow[k](b)$ ]",
    "whenever @xmath424 .",
    "the next lemma confirms that sequences act purely as containers .",
    "[ l : slowsum ] for @xmath503 it holds that @xmath500(\\lseq{a } ) = \\sum_{i=1}^n \\slow[k](a_i)$ ] .",
    "let @xmath504 .",
    "we first show @xmath500(a ) \\geqslant \\sum_{i=1}^n \\slow[k](a_i)$ ] .",
    "let @xmath505 and consider maximal sequences @xmath506 b_1 \\gpopv[k ] \\cdots \\gpopv[k ] b_o$ ] and @xmath507 c_1 \\gpopv[k ] \\cdots \\gpopv[k ] c_p$ ] .",
    "using lemma   repeatedly we get @xmath508 b_1 \\append c \\gpopv[k ] \\cdots \\gpopv[k ] b_o \\append c    \\gpopv[k ] b_o \\append c_1 \\gpopv[k ]   \\cdots \\gpopv[k ] b_o \\append c_p \\tkom\\ ] ] and thus @xmath500(b \\append c ) \\geqslant \\slow[k](b ) + \\slow[k](c)$ ] holds for all @xmath505 .",
    "we conclude @xmath509(a ) =   \\slow[k](a_1 \\append \\cdots \\append a_n ) \\geqslant \\sum_{i=1}^n \\slow[k](a_i )    $ ] with a straight forward induction on @xmath30 .",
    "it remains to verify @xmath500(a ) \\leqslant \\sum_{i=1}^n \\slow[k](a_i)$ ] .",
    "for this we show that @xmath482 b$ ] implies @xmath500(b ) < \\sum_{i=1}^n \\slow[k](a_i)$ ] by induction on @xmath500(a)$ ] .",
    "consider the base case @xmath500(a ) = 0 $ ] .",
    "since @xmath48 is ground it follows that @xmath510 , the claim is trivially satisfied . for the inductive step @xmath500(a )",
    "> 1 $ ] , let @xmath482 b$ ] . since @xmath48 is a sequence , @xmath511 .",
    "hence @xmath512 where @xmath460 b_i$ ] and thus @xmath500(b_i ) \\leqslant \\slow[k](a_i)$ ] for all @xmath513 .",
    "additionally @xmath466 b_{i_0}$ ] and hence @xmath500(b_{i_0 } ) < \\slow[k](a_{i_0})$ ] for at least one @xmath514 . as in the first half of the proof , one verifies @xmath500(b_i ) \\leqslant \\slow[k](b)$ ] for all @xmath427 .",
    "note @xmath500(b ) < \\slow[k](a)$ ] as @xmath482 b$ ] , hence induction hypothesis is applicable to @xmath484 and all @xmath515 ( @xmath427 ) .",
    "it follows that @xmath516(b ) \\leqslant \\sum_{c \\in b } \\slow[k](c )       \\leqslant \\sum_{i=1}^n \\sum_{c \\in b_i } \\slow[k](c )      = \\sum_{i=1}^n \\slow[k](b_i )       < \\sum_{i=1}^n",
    "\\slow[k](a_i ) \\tpkt    \\end{aligned}\\ ] ] this concludes the second part of the proof .    the central theorem of this section , theorem  [ t : pop ] , states that @xmath500(f(a_1 , \\dots , a_n))$ ] is polynomial in @xmath517(a_i)$ ] , where the polynomial bound depends only on @xmath227 and the rank @xmath518 of @xmath134 .",
    "the proof of this is involved . to cope with the multiset comparison underlying @xmath519 $ ]",
    ", we introduce as a first step an _ order - preserving _",
    "extension @xmath520 of @xmath500 $ ] to multisets of sequences , in the sense that @xmath521{b})$ ] holds whenever @xmath522{a } } \\mextension{\\gpopv[k ] } \\mset{\\seq[m]{b}}$ ] ( provided @xmath523 , cf .  lemma  [ l : slowpoly ] ) . as the next step toward our goal , we estimate @xmath500(f(a_1,\\dots , a_n))$ ] in terms of @xmath524 whenever @xmath525 and @xmath526",
    ". technically we bind following functions by polynomials @xmath527 . for all @xmath528 with @xmath303",
    "we define @xmath529 as @xmath530 the definition of @xmath520 is defined in terms of an order - preserving homomorphism from @xmath531 to @xmath32 . to illustrate the construction carried out below , consider the following example .",
    "[ ex : multisets ] consider multisets @xmath531 of size @xmath227 .",
    "conceive such multisets @xmath532 as natural numbers written in base-@xmath15 ( with @xmath533 for all @xmath534 ) , where digits @xmath535 are sorted from left to right in decreasing order .",
    "then one can formulate chains @xmath536 that can be understood as decreasing counters which however wrap from @xmath537 to @xmath538 .",
    "compare the trs @xmath304 defined in lemma  [ l : imprecise ] that models such counters . using the correspondence , it is easy to prove that the length of a chain of this form starting from @xmath539 is given by @xmath540 the inclusion follows by @xmath227-times application of the faulhaber s formula  @xcite , which states that for all @xmath541 , @xmath542 for some polynomial @xmath543 of degree @xmath544 .",
    "the above example gives a polynomial lower bound on the number of @xmath545 descending sequences on multisets @xmath531 of size @xmath227 .",
    "we now prove that this lower bound also serves as an asymptotic upper bound , for all multisets of natural number of length _ up to _ @xmath227 . for @xmath546 and @xmath547",
    "we define the family of functions @xmath548 such that @xmath549{m } ) = \\sum_{i=1}^n \\sort{n}(\\seq[n]{m},i ) \\cdot c^{(k - i ) } \\tpkt\\end{aligned}\\ ] ] here @xmath550{m},i)$ ] denote the  element of @xmath551{m}$ ] sorted in descending order , i.e. , @xmath550{m},i ) \\defsym m_{\\pi(i)}$ ] for @xmath513 and some permutation @xmath128 such that @xmath552 ( @xmath553 ) .",
    "[ l : homo ] let @xmath554 such that @xmath555 .",
    "then for all @xmath551{m } \\in \\n$ ] and @xmath556{m}$ ] we obtain :",
    "[ l : homo:5 ] @xmath522{m } } \\mextension { > } \\mset{\\seq[n']{m'}}$ ] implies @xmath557{m } ) > \\homo{n'}{k}{c}(\\seq[n']{m'})$ ] , and 2 .",
    "[ l : homo:4 ] @xmath558{m})$ ] .",
    "let @xmath422 be fixed and let @xmath559 collect all multisets of size up to @xmath227 . by lemma  [ l : homo ]",
    "the functions @xmath560 gives an order preserving homomorphism from @xmath561 to @xmath562 .",
    "furthermore this homomorphism is polynomially bounded in its elements .",
    "we extend this homomorphism to multisets @xmath522{a}}$ ] over @xmath400 .",
    "let @xmath563 such that @xmath564 .",
    "we define @xmath565 as follows : @xmath566{a } ) \\defsym \\homo{n}{k}{c}(\\slow[k](a_1),\\dots,\\slow[k](a_n ) )    $ ] , where @xmath567(a_i ) \\mid i \\in \\{1,\\dots , n\\}}$ ] .",
    "we obtain :    [ l : slowpoly ] let @xmath568{b}\\in \\gtls$ ] and let @xmath523",
    ". then @xmath569 } \\mset{\\seq[m]{b } }     \\quad \\iimp \\quad \\mslow{n}{k}(\\seq{a } ) > \\mslow{m}{k}(\\seq[m]{b } ) \\tpkt\\ ] ]    in theorem  [ t : pop ] below we prove @xmath570 for some constants @xmath571 depending only on @xmath227 and @xmath518 .",
    "inevitably the proof of theorem  [ t : pop ] is technical , the reader may to skip the formal proof on the first read . in the proof of theorem  [ t : pop ] , we instantiate the constants @xmath572 by parameters @xmath573 , which are defined by recursion on @xmath518 as follows:[d : dkp : ckp ] @xmath574 the theorem is then proven by induction on @xmath518 and @xmath451 .",
    "consider term @xmath575 with @xmath564 and @xmath576 . at the heart of the proof , we show that @xmath577(b)$ ] for arbitrary @xmath484 with @xmath459 b$ ] .",
    "the most involved case is @xmath578[l ] \\lseq[o]{b}$ ] where for all but one @xmath579 we have @xmath434[l-1 ] b_j$ ] .",
    "here it is important to give a precise analysis of the order @xmath432[l]$ ] , exploiting the parameters @xmath227 and @xmath138 . to this avail we define for @xmath580 and @xmath581 a family of auxiliary functions @xmath582 by @xmath583 having as premise the induction hypothesis of the main proof , the next lemma explains the rle of @xmath432[l]$ ] .",
    "[ l : pop : aux ] let @xmath584 .",
    "let @xmath564 and @xmath585 .",
    "suppose @xmath586 for all @xmath587 and @xmath588 .",
    "then for all @xmath589 , @xmath590[l ] b \\quad \\iimp \\quad \\slow(b ) \\leqslant g_{k , l,\\rk(f)}(m+2 ) \\tpkt\\ ] ]    we prove lemma by induction on @xmath138 .",
    "the base case @xmath591 is easy to show , hence assume @xmath592 .",
    "suppose @xmath434[l ] b$ ] , we continue by case analysis :    : :    then @xmath593[l ] b$ ] for some    @xmath130 , and consequently    @xmath594 .",
    "then by definition and    assumption we even have    @xmath595 .",
    "@xmath596       then       $ ] f ( ) b_j@xmath597j = 1,  ,o@xmath598m ( ) @xmath599(b_j ) + 1 \\mid j \\in \\{1,\\dots , o\\}}^k         & & \\text{by definition and lemma~\\eref{l : homo}{4 } } \\\\        & \\leqslant { ( g_{k , l-1,\\rk(f)}(m+2)+ 1)}^k        & & \\text{applying induction hypothesis . }      \\end{align * }      as in the considered case $ ] ( g ) < ( f)@xmath600(b ) ( m)@xmath601(b )         & \\leqslant c_{k,\\rk(g ) } \\cdot { ( m ' + 2)}^{d_{k,\\rk(f)-1 } } & & \\\\              & < c_{k,\\rk(f)-1 } \\cdot { ( { ( g_{k , l-1,\\rk(f)}(m+2)+ 1)}^k + 2)}^{d_{k,\\rk(f)-1 } } & & \\text{substituting bound for $ m'$ } \\\\        & \\leqslant c_{k,\\rk(f)-1 } \\cdot { ( ( m+2 ) \\cdot g_{k , l-1,\\rk(f)}(m+2))}^{k \\cdot d_{k,\\rk(f)-1 } } & & \\\\        & = g_{k , l,\\rk(f)}(m+2 ) & & \\text{using $ \\rk(f ) > 0$}\\tpkt      \\end{align * }    \\item[\\dcase{$f(\\seq{a } ) \\cppv{ialst}[k][l ] b$ where $ b = \\lseq[o]{b}}$ ] : :    order constraints give @xmath602 and    @xmath434[l-1 ] b_j$ ]    ( @xmath603 ) . exploiting that @xmath352 is    ground , a standard argument shows that    @xmath604(a_i)$ ] , and consequently    @xmath605 .",
    "thus    @xmath606 since by lemma  [ l : slowsum ] we have    @xmath500(b ) = \\sum_{i=1}^o \\slow[k](b_i)$ ] , using we see    @xmath607(b ) & \\leqslant k \\cdot ( m + 1 ) \\cdot g_{k , l-1,\\rk(f)}(m+2 ) & & \\text{by induction hypothesis } \\\\         &",
    "< g_{k , l,\\rk(f)}(m+2 ) & & \\text{by case analysis . }        \\end{aligned}\\ ] ]    [ t : pop ] let @xmath303 and @xmath581 .",
    "there exists constants @xmath571 ( depending only on @xmath227 and @xmath518 ) such that for all @xmath608 we have @xmath609    fix @xmath610{a } ) \\in \\gts$ ] such that @xmath611 , @xmath564 and @xmath612 . to show the theorem",
    ", we prove that for all @xmath484 with @xmath610{a } ) \\gpopv[k ] b$ ] we have @xmath500(b ) < c_{k , p } \\cdot { ( m+2)}^{d_{k , p}}$ ] for constants @xmath613 and @xmath614 as defined on page  .",
    "the proof is by induction on the lexicographic combination of @xmath518 and @xmath451 .",
    "the base case where @xmath615 and @xmath616 is easy to proof , we consider the inductive step . consider the inductive step . by induction hypothesis we have @xmath617 for @xmath618 we will use the induction hypothesis as a premise to lemma  [ l : pop : aux ] , for @xmath619 we use below the consequence @xmath620(g(\\seq[o]{b } ) ) < c_{k , p } \\cdot ( m+1)^{d_{k , p } }       \\text{\\quad if $ f \\ep g$ , $ o \\leqslant k$ and $ \\mslow{o}{k}(b_1,\\dots , b_o ) < m$ } \\tpkt    \\end{aligned}\\ ] ] we analyse the cases @xmath615 and @xmath621 separately . in both cases",
    "we perform a side induction on @xmath138 .    : :    by side induction on @xmath138 we prove that    @xmath500(b ) < k^k \\cdot { ( m+1)}^{k+1 } + k^l \\cdot { ( m + 2)}^l$ ]    for all @xmath484 with @xmath459[l ] b$ ] .",
    "+    note that if @xmath622[l ] b$ ] holds , as in    the proof of lemma  [ l : pop : aux ] , we even have    @xmath500(b ) \\leqslant \\mslow{n}{k}(\\seq[n]{a } ) \\leqslant m$ ] .",
    "+    consider now @xmath623[l ] b$ ] where    @xmath624{b})$ ] .",
    "the ordering constraints give    @xmath625 and    @xmath626[l ] } \\mset{\\seq[o]{b}}$ ] ,    from lemma  [ l : slowpoly ] we thus get    @xmath627{b } ) < \\mslow{n}{k}(\\seq[n]{a } ) \\leqslant m$ ] .",
    "since also @xmath127 in this case we conclude as we even    have @xmath628(g(\\seq[o]{b } ) )           & < c_{k,0 } \\cdot ( m + 1)^{d_{k,0 } }           & & \\text{by main induction hypothesis}\\\\          & = k^k \\cdot ( m + 1)^{k+1 }           & & \\text{by definition of $ c_{k,0}$ and $ d_{k,0}$. }        \\end{aligned}\\ ] ]    +    next consider @xmath578[l]$ ] where    @xmath629{b}$ ] .",
    "the order constraints give ( i )    @xmath482[l-1 ] b_{j_0}$ ] for some    @xmath630 , ( ii )    @xmath631[l-1 ] b_j$ ] for all @xmath463 ,    and ( iii ) @xmath602 .",
    "we have    @xmath628(b_{j_0 } ) & < k^k \\cdot { ( m+1)}^{k+1 } + k^{l-1 } \\cdot { ( m + 2)}^{l-1 } & & \\text{from ( i ) , using sih on $ l$ } \\\\",
    "\\slow[k](b_j ) & \\leqslant k^{l-1 } \\cdot { ( m + 2)}^{l-1}\\text { for $ j",
    "\\not = j_o$ } & & \\text{from ( ii ) , using lemma~\\ref{l : pop : aux } } \\\\",
    "o & \\leqslant k \\cdot ( m + 1 ) & & \\text{from ( iii ) . }        \\end{aligned}\\ ] ] for the last inequality , compare equation   from    lemma  [ l : pop : aux ] . as    @xmath500(b ) = \\sum_{j = 1}^o \\slow[k](b_j)$ ] by    lemma  [ l : slowsum ] , substituting the above inequalities we get    @xmath628(b ) & <   k^k \\cdot { ( m+1)}^{k+1 } + k^{l-1 } \\cdot { ( m + 2)}^{l-1 } & & \\text{bound on $ \\slow[k](b_{j_0})$}\\\\          & \\quad + ( k \\cdot ( m+1 ) - 1 ) \\cdot k^{l-1 } \\cdot { ( m + 2)}^{l-1 } & & \\text{bound on $ o$ and $ \\slow[k](b_{j})$ , $ j \\not = j_0$}\\\\           & <   k^k \\cdot { ( m+1)}^{k+1 } + k^{l } \\cdot { ( m + 2)}^{l } \\tpkt        \\end{aligned}\\ ] ] this concludes the final case of the side    induction .",
    "since @xmath469 } = { \\gpopv[k][k]}$ ] this    preparatory step gives @xmath628(b ) < k^k \\cdot { ( m+1)}^{k+1 } + k^k \\cdot { ( m + 2)}^k                 \\leqslant k^k \\cdot { ( m + 2)}^{k+1}\\tkom        \\end{aligned}\\ ] ] we conclude the case @xmath615 . : :    we show first that for all @xmath632 , if    @xmath459[l ] b$ ] then    @xmath633(b ) \\leqslant c_{k , p }   \\cdot { ( m+1)}^{d_{k , p } } + c_{k , p } \\cdot { ( m + 2)}^{{(k \\cdot d_{k , p-1})}^{l+1 } } \\tpkt\\ ] ]    the proof is by induction on @xmath138",
    ". suppose    @xmath459[l ] b$ ] .",
    "the base case    @xmath591 is trivial , so consider the inductive step    @xmath592 . as in the case",
    "@xmath615 , if    @xmath622[l ] b$ ] then even    @xmath500(b ) \\leqslant m$ ] , and if    @xmath623[l ] b$ ] then even    @xmath500(b ) \\leqslant c_{k , p }   \\cdot { ( m+1)}^{d_{k , p}}$ ] .",
    "consider @xmath578[l ] b$ ] .",
    "then    @xmath634{b}$ ] with ( i )    @xmath482[l-1 ] b_{j_0}$ ] for some    @xmath635 , ( ii )    @xmath631[l-1 ] b_j$ ] for all @xmath463 ,    and ( iii ) @xmath602 .",
    "a standard argument    gives @xmath636 for all @xmath193 , thus    @xmath637(b_{j_0 } ) & <   c_{k , p } \\cdot { ( m+1)}^{d_{k , p } } + c_{k , p } \\cdot { ( m + 2)}^{{(k \\cdot d_{k , p-1})}^{l } }          & & \\text{from ( i ) , using sih on $ l$ } \\\\",
    "\\slow[k](b_j ) & \\leqslant c_{k , p-1}^{\\sum_{i=1}^{l-2 } { ( k \\cdot d_{k , p-1})}^i } \\cdot ( m+2)^{\\sum_{i=1}^{l-1 } { ( k \\cdot d_{k , p-1})}^i } \\text { for $ j \\not = j_o$ }           & & \\text{from ( ii ) , using lemma~\\ref{l : pop : aux } } \\\\          o & \\leqslant k \\cdot ( m + 1 ) & & \\text{from ( iii ) . }        \\end{aligned}\\ ] ] using lemma  [ l : slowsum ] and substituting the    above inequalities we get @xmath638(b )           & \\leqslant c_{k , p } \\cdot { ( m+1)}^{d_{k , p } } + c_{k , p } \\cdot { ( m + 2)}^{{(k \\cdot d_{k , p-1})}^{l } }           & & \\text{bound on $ \\slow[k](b_{j_0})$}\\\\          & ~~ + k \\cdot ( m+1 ) \\cdot c_{k , p-1}^{\\sum_{i=1}^{l-2 } { ( k \\cdot d_{k , p-1})}^i } \\cdot { ( m+2)}^{\\sum_{i=1}^{l-1 } { ( k \\cdot d_{k , p-1})}^i }          & & \\text{bound on $ \\slow[k](b_{j})$ , $ j \\not = j_0$}\\\\          & < c_{k , p } \\cdot { ( m+1)}^{d_{k , p } } + c_{k , p } \\cdot { ( m + 2)}^{{(k \\cdot d_{k , p-1})}^{l } } \\\\          & ~~ + c_{k , p } \\cdot ( m + 1 ) \\cdot { ( m+2)}^{\\sum_{i=1}^{l-1 } { ( k \\cdot d_{k , p-1})}^i }          & & \\text{as $ k \\cdot c_{k , p-1}^{\\sum_{i=1}^{l-2 } { ( k \\cdot d_{k , p-1})}^i } < c_{k , p}$}\\\\          & \\leqslant c_{k , p } \\cdot { ( m+1)}^{d_{k , p } } + c_{k , p } \\cdot { ( m+2)}^{\\sum_{i=0}^{l } { ( k \\cdot d_{k , p-1})}^i } \\\\          & \\leqslant c_{k , p } \\cdot { ( m+1)}^{d_{k , p } } + c_{k , p } \\cdot { ( m+2)}^{{(k \\cdot d_{k , p-1})}^{l+1 } } \\tkom         \\end{aligned}\\ ] ] as desired , we conclude equation  . from this    preparatory step ,",
    "@xmath469 } = { \\gpopv[k][k]}$ ] and    @xmath639    we finally get @xmath628(b ) & \\leqslant c_{k , p+1 }   \\cdot { ( m+1)}^{d_{k , p } } + c_{k , p } \\cdot { ( m + 2)}^{{(k \\cdot d_{k , p-1})}^{k+1 } } \\\\          & = c_{k , p } \\cdot ( { ( m+1)}^{d_{k , p } } + { ( m + 2)}^{{(k \\cdot d_{k , p-1})}^{k+1 } } )           < c_{k , p } \\cdot { ( m + 2)}^{d_{k , p}}\\tkom        \\end{aligned}\\ ] ] and conclude also this case .    as a consequence , the number of @xmath421$]-descents on basic terms interpreted with predicative interpretation @xmath294 is polynomial in sum of depths of normal arguments .",
    "[ c : pop ] let @xmath303 and consider @xmath108 with @xmath436 normal arguments .",
    "there exists a constant @xmath640 depending only on @xmath227 and the rank of @xmath134 such that : @xmath502(\\ints(f(\\pseq[m][n]{u } ) ) ) = \\bigo\\bigl({(\\textstyle{\\max}_{i=1}^m \\depth(u_i))}^{d}\\bigr)\\ ] ] for all @xmath641{u } \\in \\val$ ] .",
    "let @xmath642[n]{u})$ ] be as given by the corollary .",
    "recall that since arguments of @xmath93 are values , we have @xmath643 as indicated on page  , and further @xmath644 holds for all @xmath245 .",
    "thus @xmath645 as @xmath500(\\theconst)$ ] is constant , say @xmath500(\\theconst ) = c$ ] , by lemma  [ l : slowsum ] we see that @xmath500(\\nattoseq{\\depth(u_i ) } ) = c \\cdot \\depth(u_i)$ ] .",
    "we conclude as @xmath516(\\ints(s ) ) =      & \\slow[k](\\fn(\\nattoseq{\\depth(u_1 ) } , \\dots , \\nattoseq{\\depth(u_m ) } ) )       & & \\text{by lemma~\\ref{l : slowsum } }       \\\\      & \\leqslant \\fpop{k}{\\rk(f)}\\bigl(\\mslow{l}{k}(\\nattoseq{\\depth(u_1 ) } , \\dots , \\nattoseq{\\depth(u_m)})\\bigr )       & & \\text{by assumption $ m \\leqslant k$ }      \\\\      & \\leqslant \\fpop{k}{\\rk(f)}\\bigl({\\bigl(1 + \\textstyle{\\max}_{i=1}^m \\slow[k](\\nattoseq{\\depth(u_i)})\\bigr)}^k\\bigr )       & & \\text{by lemma~\\eref{l : homo}{4 } }       \\\\      & \\leqslant \\fpop{k}{\\rk(f)}\\bigl({\\bigl(c \\cdot ( 1 + \\textstyle{\\max}_{i=1}^m \\depth(u_i))\\bigr)}^k\\bigr )      & & \\text{using $ \\slow[k](\\nattoseq{\\depth(u_i ) } ) \\leqslant c \\cdot \\depth(u_i)$ }      \\\\      & \\in \\bigo\\bigl({\\bigl(c \\cdot ( 1 + \\textstyle{\\max}_{i=1}^m \\depth(u_i))\\bigr)}^{k+{d_{k,\\rk(f)}}}\\bigr )      & & \\text{by theorem~\\ref{t : pop } }       \\\\      & = \\bigo\\bigl(({\\textstyle{\\max}_{i=1}^m \\depth(u_i)})^{k+d_{k,\\rk(f)}}\\bigr ) \\tpkt      \\rlap{\\hbox to 217 pt{\\hfill\\qed } }    \\end{aligned}\\ ] ]",
    "fix a predicative recursive trs @xmath139 and signature @xmath102 , and let @xmath234 be the polynomial path order underlying @xmath139 based on the ( admissible ) precedence @xmath26 .",
    "we denote by @xmath26 also the induced precedence on @xmath348 given by : @xmath646 if @xmath127 and @xmath647 if @xmath243 .",
    "further , we set @xmath648 for all @xmath649 .",
    "we denote by @xmath650 $ ] ( and respectively @xmath651 $ ] ) the approximation given in definition  [ d : gpopv ] ( respectively definition  [ d : gppv ] ) with underlying precedence @xmath26 .    in this section",
    ", we establish the embedding of @xmath149 into @xmath650 $ ] as outlined in the proof plan on page  ; in the sequel @xmath173 is set to twice the maximum size of right - hand sides of @xmath139 .",
    "lemma  [ l : embed : root ] below proves the embedding of root steps for the case @xmath652 . in lemma",
    "[ l : embed : ctx ] we then show that the embedding is closed under contexts .",
    "the next auxiliary lemma connects the auxiliary orders @xmath233 and @xmath432[l]$ ] ( compare example  [ ex : gppv ] ) .",
    "[ l : embedgsq : root ] suppose @xmath653 , @xmath143 and @xmath407 .",
    "then for predicative interpretation @xmath654 we have @xmath655 \\intq(t\\sigma ) \\tpkt\\ ] ]    the proof proceeds by induction on the definition of @xmath233 and makes use of lemmas  [ l : gpop : val ] ,  [ l : int : len ] and  [ l : approx ] .",
    "[ l : embed : root ] suppose @xmath653 , @xmath143 and @xmath407 .",
    "then for predicative interpretation @xmath654 we have @xmath656 \\intq(t\\sigma ) \\tpkt\\ ] ]    let @xmath93 , @xmath112 , @xmath165 be as given in the lemma .",
    "we prove the stronger assertions    1 .",
    "[ l : er1 ] @xmath657 \\ints(t\\sigma)$ ] , 2 .",
    "[ l : er2 ] @xmath658 \\ints(t\\sigma)$ ] if @xmath659 , and 3 .",
    "[ l : er3 ] @xmath660 \\intn(t\\sigma)$ ] .    as @xmath661 , property  [ l : er1 ] and lemma",
    "yield @xmath662 \\ints(s\\sigma)$ ] .",
    "furthermore @xmath663 .",
    "hence property  [ l : er3 ] immediately yields @xmath664 \\intn(s\\sigma)$ ] .",
    "we continue with the proof of the assertions by induction on @xmath234 and set @xmath665 .",
    ": :    due to lemma  [ l : gpop : val ] ( employing    @xmath666 ) we obtain that    @xmath667 is a safe subterm of @xmath668 and    @xmath669 .",
    "the latter implies    @xmath670 and thus properties  [ l : er1 ]    and  [ l : er2 ] follow . for property",
    "[ l : er3 ] , observe that    @xmath671 . here",
    "the last    inequality follows by a simple case distinction on @xmath240 .    from this and @xmath672 \\theconst$ ]",
    "we get    @xmath673 \\nm{t\\sigma } = \\intn(t\\sigma )          \\tpkt\\ ] ] : :    the assumption gives @xmath242[n]{t})$ ] where    @xmath243 and further @xmath244 for all    normal argument positions @xmath674 , and    @xmath675 for all safe argument positions    @xmath676 , of @xmath230 .",
    "additionally    @xmath677 for at most one argument    position @xmath678 .",
    "set    @xmath679    and let    @xmath680 for    all safe argument positions @xmath676 .",
    "hence , we    obtain :    @xmath681    applying lemma  [ l : embedgsq : root ] on all normal arguments of    @xmath112 , we see @xmath682 \\gn(\\intn(t_1\\sigma ) , \\dots , \\intn(t_m\\sigma ) ) = v          \\tkom\\ ] ] from the assumptions @xmath647 and    @xmath244 for all @xmath674 .",
    "since    @xmath683 by assumption , induction hypothesis on    @xmath678 gives    @xmath684 { \\ints(t_{i_0}\\sigma ) } =         { \\lst{v_{i_0,1 } , \\dots , v_{i_0,j_{i_0}}}}$ ] .",
    "we obtain :    @xmath685 { v_{i_0,j_0 } }           & & \\text{for some $ j_0 \\in \\{1,\\dots , j_{i_0}\\}$}\\label{e : c3:1}\\\\          v & \\gppv[2\\cdot\\size{t}-1 ] { v_{i_0,j } }           & & \\text{for all $ j = 1,\\dots , j_{i_0}$ , $ j \\not = j_0$.}\\label{e : c3:2 }        \\end{aligned}\\ ] ] induction hypothesis on safe argument positions    @xmath240 gives : @xmath686 { v_{i , j } }           & & \\text{for all $ i = m+1,\\dots , m+n$ , $ i \\not = i_0 $ and $ j = 1,\\dots , j_{i}$. } \\label{e : c3:3 }        \\end{aligned}\\ ] ] due to lemma  ,    @xmath488 .",
    "hence    property  [ l : er1 ] follows by    @xmath687 $ ] using equations .    likewise , property  [ l : er3 ] follows by an additional use of    @xmath688 \\theconst$ ] and    @xmath689 here the first inequality follows by lemma  . for    property",
    "[ l : er2 ] we proceed as above , but strengthen inequality   to    @xmath690 { v_{i_0,j_0}}$ ] .",
    ": :    then @xmath242[n]{t})$ ] where @xmath127 .",
    "further , the assumption gives    @xmath261{s } } \\gpopmul \\mset{\\seq[m]{t}}$ ] and    @xmath262[k+1]{s } } \\geqpopmul \\mset{\\seq[m+n][m+1]{t}}$ ] .",
    "hence @xmath691 and property  [ l : er2 ] is    vacuously satisfied .",
    "we prove properties  [ l : er1 ] and  [ l : er3 ] . using    @xmath692 for all normal argument positions    @xmath674 and employing lemma  [ l : gpop : val ]",
    "we see    that @xmath261{s } } \\gpopmul \\mset{\\seq[m]{t}}$ ]    implies    @xmath693 } \\mset{\\intn(t_1\\sigma ) , \\dots , \\intn(t_m\\sigma ) }          \\tpkt\\ ] ] hence due to @xmath646 and    @xmath694 we    obtain : @xmath695 \\gn(\\intn(t_1\\sigma ) , \\dots , \\intn(t_m\\sigma ) )          \\tpkt\\ ] ] assumption    @xmath262[k+1]{s } } \\geqpopmul \\mset{\\seq[m+n][m+1]{t}}$ ]    together with @xmath692 for all    @xmath696 gives @xmath697 . as a    consequence we have @xmath698 for all    @xmath699 and we obtain :    @xmath700         \\lst{\\gn(\\intn(t_1\\sigma ) , \\dots , \\intn(t_m\\sigma ) ) } = \\ints(t\\sigma)\\ ] ]    which concludes the argument for property  [ l : er1 ] . for    property",
    "[ l : er3 ] , we see that the order constraints on safe arguments    imply @xmath701 . thus    @xmath702 \\nm{t\\sigma}$ ] ,    using this and equation   we obtain    @xmath703   \\gn(\\intn(t_1\\sigma ) , \\dots , \\intn(t_m\\sigma ) ) \\append \\nm{t\\sigma } = \\intn(t\\sigma )        \\tkom\\ ] ] by lemma   and lemma  .",
    "[ l : embed : ctx ] let @xmath704 and @xmath221 .",
    "then for @xmath705 , @xmath706 \\intq(t ) \\quad",
    "\\iimp \\quad \\intq(c[s ] ) \\gpopv[\\ell ] \\intq(c[t ] ) \\tpkt\\ ] ]    we proceed by induction on the context @xmath707 .",
    "it suffices to consider the inductive step .",
    "consider terms @xmath708 and @xmath709 .",
    "we restrict our attention the predicative interpretation @xmath390 and show @xmath710 \\intn(f(s_1,\\dots , t_i , \\dots , s_{k+l}))$ ] , whenever @xmath711 \\intn(t_i)$ ] .",
    "recall that @xmath712 and @xmath713 .",
    "if @xmath714 then @xmath715 \\intn(t)$ ] follows from @xmath716 \\ints(t)$ ] and lemma  .",
    "hence suppose @xmath717 .",
    "we consider only the case where @xmath718 .",
    "the assumption @xmath717 implies that @xmath240 is a safe argument position of @xmath134 .",
    "hence we obtain : @xmath719 by definition we have @xmath720 .",
    "this together with @xmath717 yields @xmath721 by the shape of @xmath93 and @xmath112 . using lemma   and the assumption @xmath711 \\intn(t_i)$ ] we obtain : @xmath722 \\ints(t_i ) \\append \\nm{t_i } \\append \\theconst           \\tpkt\\ ] ] from this we have @xmath723 \\ints(t_i ) \\append \\nm{t}$ ] and thus due to lemma   and lemma   we obtain @xmath724 \\intn(t)$ ] .",
    "we have established our first main result .",
    "let @xmath139 be a predicative recursive trs and fix an arbitrary basic term @xmath642[n]{u})$ ] .",
    "set the parameter @xmath173 as follows : @xmath725 as @xmath348 and @xmath139 are finite , @xmath173 is well - defined .",
    "consider a maximal @xmath139-derivation @xmath726{1cm}{s }     \\mparbox[c]{1cm}{\\irew[\\rs ] } \\mparbox[c]{1cm}{s_1 }     \\mparbox[c]{1cm}{\\irew[\\rs ] } \\mparbox[c]{1cm}{s_2 }     \\mparbox[c]{1cm}{\\irew[\\rs ] } \\mparbox[c]{1cm}{\\cdots }    \\mparbox[c]{1cm}{\\irew[\\rs ] } \\mparbox[c]{1cm}{s_k\\tkom}\\ ] ] starting from an arbitrary term @xmath93 , that is , @xmath727(s)$ ] .",
    "using lemma  [ l : embed : root ] together with lemma  [ l : embed : ctx ] @xmath227-times we get @xmath726{1cm}{\\ints(s ) }      \\mparbox[c]{1cm}{\\gpopv[\\ell ] } \\mparbox[c]{1cm}{\\ints(s_1 ) }      \\mparbox[c]{1cm}{\\gpopv[\\ell ] } \\mparbox[c]{1cm}{\\ints(s_2 ) }     \\mparbox[c]{1cm}{\\gpopv[\\ell ] } \\mparbox[c]{1cm}{\\cdots }     \\mparbox[c]{1cm}{\\gpopv[\\ell ] } \\mparbox[c]{1cm}{\\ints(s_k ) }     \\tpkt\\ ] ] as a consequence , we have @xmath728(\\ints(s))$ ] by definition of @xmath729 $ ] and thus : @xmath730(\\ints(s ) )   = \\bigo\\bigl((\\max_{i=1}^m \\depth(u_i))^{d}\\bigr ) \\tkom\\ ] ] where the asymptotic estimation follows by corollary  [ c : pop ] .",
    "note that the degree @xmath731 depends only on  @xmath173 .",
    "we now present the application of polynomial path orders in the context of _ implicit computational complexity_. as by - product of proposition  [ p : invariance ] and theorem  [ t : popstar ] we immediately obtain that @xmath21 is _ sound _ for @xmath4 respectively @xmath18 .",
    "[ t : icc : soundness ] let @xmath139 be a predicative recursive ( constructor ) trs . for every relation @xmath176 defined by @xmath139 ,",
    "the function problem @xmath732 associated with @xmath176 is in @xmath4 .",
    "moreover , if @xmath139 is confluent then @xmath733 .",
    "although it is decidable whether a trs @xmath139 is predicative recursive ( we present a sound and complete automation in section  [ s : exps ] ) , confluence is undecidable in general . to get a decidable result for @xmath18",
    ", one can replace confluence by an decidable criteria , for instance orthogonality .",
    "we will now also establish that  is _ complete _ for @xmath18 , that is , every function @xmath734 is computed by some confluent ( even orthogonal ) predicative recursive trs . for this",
    "we employ beckmann and weiermann s _ term rewriting characterisation _ of the bellantoni and cook s class @xmath203 .",
    "* definition  2.2 ) [ d : rb ] for each @xmath735 the set of function symbols @xmath736 with @xmath227 normal and @xmath138 safe argument positions is the least set of function symbols such that    1 .",
    "@xmath737 , @xmath738 , @xmath739 , @xmath740 and @xmath741 , where @xmath742 ; 2 .",
    "if @xmath743{r } \\in \\fb^{k,0}$ ] , @xmath744{s } \\in \\fb^{k , l}$ ] and @xmath745 then @xmath746 \\in \\fb^{k , l}$ ] ; 3 .   if @xmath747 and @xmath748 then @xmath749 \\in \\fb^{k+1,l}$ ] ;    the _ predicative signature _ is given by @xmath750 . only the constant @xmath751 and _ dyadic successors _",
    "@xmath752 , which serve the purpose of encoding natural numbers in binary , are constructors .",
    "the remaining symbols from @xmath753 are defined symbols .    in figure  [ fig:1 ]",
    "we recall from  ( * ? ? ?",
    "* definition  2.7 ) the ( infinite ) schema of rewrite rules @xmath754 that form a term rewriting characterisation of the class @xmath203 .",
    "here we let @xmath755 range over @xmath32 and set @xmath756{x}$ ] and @xmath757{y}$ ] for @xmath227 respectively @xmath138 distinct variables .",
    "@r@  c@  l@r + @xmath758 & @xmath759 & @xmath751 + @xmath760 & @xmath759 & @xmath83 & for @xmath761 + @xmath762 & @xmath759 & @xmath763 & for all @xmath764 + @xmath762 & @xmath759 & @xmath765 & for all @xmath766 + @xmath767 & @xmath759 & @xmath84 + @xmath768 & @xmath759 & @xmath769 & for @xmath770 + @xmath771 & @xmath759 & @xmath751 +   + @xmath746(\\svec{x}{y})$ ] & @xmath759 & @xmath772 +   + @xmath749(\\sn{\\epsilon , \\vec x}{\\vec y})$ ] & @xmath759 & @xmath773 + @xmath749(\\sn{\\ms_i ( \\sn{}{z } ) , \\vec x}{\\vec y } )       $ ] & @xmath759 & @xmath774(\\sn{z , \\vec x}{\\vec y})})$ ] & for @xmath770    we emphasise that the system @xmath754 is called _ infeasible _ in  @xcite . indeed @xmath754 admits an exponential lower bound on the derivation height if one considers full rewriting .",
    "this is induced by duplicating redexes as explained already in example  [ ex : dup ] on page  . however , this should rather be understood as a miss - configuration of the evaluation strategy , rather than a defect of the rewrite system . indeed , in our completeness argument below",
    ", we exploit that @xmath754 is predicative recursive , thus the _ innermost _ runtime complexity is polynomial , as expected .",
    "we emphasise that the above rules are all orthogonal and the following proposition verifies that @xmath754 generates only polytime computable functions .",
    "[ prop : rf ] ( * ? ? ?",
    "* lemma  5.2 ) let @xmath734 .",
    "there exists a finite restriction @xmath775 such that @xmath403 computes @xmath134 .",
    "we arrive at our completeness result .",
    "[ t : icc : completeness ] for every @xmath734 there exists a finite , orthogonal , and predicative recursive ( constructor ) trs @xmath403 that computes @xmath134 .",
    "take the finite trs @xmath775 from proposition  [ prop : rf ] that computes @xmath134 .",
    "obviously @xmath403 is orthogonal hence confluent .",
    "it remains to verify that @xmath403 is compatible with some instance @xmath234 .",
    "to define @xmath234 we use the separation of normal from safe argument positions as indicated in the rules . to define the precedence underlying @xmath234",
    ", we define a mapping @xmath776 from the signature of @xmath753 into the natural numbers as follows :    * @xmath777 if @xmath134 is one of @xmath751 , @xmath778 , @xmath779 , @xmath780 , @xmath781 , @xmath782 or @xmath783 ; * @xmath784 ) \\defsym 1 + \\lh(h ) + \\sum_{r \\in \\vec{r } } \\lh(r ) + \\sum_{s \\in \\vec{s } }   \\lh(s)$ ] ; * @xmath785 ) \\defsym 1 + \\lh(g ) + \\lh(h_1 ) + \\lh(h_2)$ ] .    finally for each pair of function symbol",
    "@xmath134 and @xmath230 occurring in @xmath403 , we set @xmath243 if @xmath786",
    ". then @xmath120 defines an admissible precedence .",
    "it is straight forward to verify that @xmath787 where @xmath234 is based on the precedence  @xmath120 and the safe mapping as indicated in definition  [ d : rb ] .",
    "observe that compatibility of @xmath754 with  together with theorem  [ t : popstar ] yields a strengthened version of theorem  4.3 in  @xcite , as due to our result the innermost derivation height is polynomially bounded in the depth of the normal arguments only .",
    "the latter result can be obtained directly , by a simplification of the semantic argument given in  ( * ? ? ?",
    "* section  4 ) , see  @xcite .    by theorem  [ t :",
    "icc : soundness ] and theorem  [ t : icc : completeness ] we obtain a precise characterisation of the class of polytime computable functions and thus arrive at the second main result of the paper .",
    "[ c : fp ] the following class of functions are equivalent :    1 .   the class of functions computed by confluent predicative recursive ( constructor ) trss .",
    "2 .   the class of polytime computable functions @xmath18 .",
    "we note that it is not decidable whether a rewrite system is confluent .",
    "however , to get a decidable characterisation we could replace confluence by orthogonality , compare theorem  [ t : icc : completeness ] .",
    "bellantoni  @xcite already observed that the class @xmath203 is closed under _ predicative recursion on notation with parameter substitution _",
    "( scheme ) .",
    "essentially this recursion scheme allows substitution on _ safe _ argument positions .",
    "more precise , a new function @xmath134 is defined by the equations @xmath788    bellantoni s result has been reobtained by beckmann and weiermann  ( * ? ? ?",
    "* corollary  5.4 ) employing a similar term rewriting characterisation . in this section ,",
    "we introduce the _ polynomial path order with parameter substitution _ ( _ _ for short ) .",
    "provides an order - theoretic characterisation of predicative recursion with parameter substitution , that again precisely captures the class @xmath18 . furthermore  induces polynomial innermost runtime complexity . as a consequence ,",
    "we obtain yet another proof of bellantoni s result .",
    "the next definition introduces @xmath22 .",
    "it is a variant of @xmath21 , where clause @xmath266 has been modified and allows computation at safe argument positions .",
    "[ d : gpopps ] let @xmath219 denote a precedence .",
    "consider terms @xmath235 such that @xmath236[l]{s})$ ] .",
    "then @xmath789 if one of the following alternatives holds :    1 .",
    "[ d : gpopps : st ] @xmath790 for some @xmath239 , or 2 .",
    "[ d : gpopps : ia ] @xmath108 , @xmath242[n]{t})$ ] where @xmath243 and the following conditions hold : * @xmath255 for all normal argument positions @xmath256 ; * @xmath791 for all safe argument positions @xmath258 ; * @xmath259 for at most one safe argument position @xmath260 ; 3 .",
    "[ d : gpopps : ep ] @xmath108 , @xmath242[n]{t})$ ] where @xmath127 and the following conditions hold : * @xmath261{s } } \\gpopmulps \\mset{\\seq[m]{t}}$ ] ; * @xmath791 and @xmath792 for all safe argument positions @xmath793 .    here @xmath794 .",
    "the next lemma shows that @xmath22 extends the analytic power of @xmath21 .",
    "[ l : psextends ] for any underlying admissible precedence @xmath26 , @xmath795 .",
    "note that  is strictly more powerful than , as witnessed by the following example .",
    "[ ex : rsrev ] consider the constructor trs @xmath796 defining the reversal of lists in a tail recursive fashion : @xmath797 it is not difficult to see that @xmath796 is compatible with , if we use the precedence @xmath798 .",
    "note that orientation of rule   breaks down to @xmath799 and @xmath800 . on the other hand",
    ", @xmath234 fails as the corresponding clause @xmath266 requires @xmath801 .",
    "due to lemma  [ l : psextends ] ,  is complete for the class of polytime computable functions . to show that it is sound",
    ", we prove that  induces polynomially bounded runtime complexity in the sense of theorem  [ t : popstar ] .",
    "the crucial observation is that the embedding of @xmath149 into @xmath802 does not break if we relax compatibility constraints to @xmath803 .",
    "[ l : embed : root : ps ] suppose @xmath487 , @xmath143 and @xmath804 .",
    "then for predicative interpretation @xmath654 we have @xmath805 \\intq(t\\sigma ) \\tpkt\\ ] ]    first one verifies that lemma  [ l : int : len ] holds even if we replace @xmath234 by @xmath806 . in particular , the assumptions give @xmath807 the proof follows the pattern of the proof of lemma  [ l : embed : root ] , i.e. , we proceed by induction on @xmath806 .",
    "we cover only the new case @xmath808 .",
    "let @xmath93 , @xmath112 , and @xmath165 be as given in the lemma",
    ". then @xmath242[n]{t})$ ] where @xmath127 .",
    "further , the assumption gives @xmath261{s } } \\gpopmul \\mset{\\seq[m]{t}}$ ] .",
    "as @xmath691 it suffices to verify property  [ l : er1 ] and property  [ l : er3 ] from lemma  [ l : embed : root ] .",
    "as before , we obtain : @xmath809",
    "\\gn(\\intn(t_1\\sigma ) , \\dots , \\intn(t_m\\sigma ) ) \\tpkt\\ ] ] by assumption @xmath791 and @xmath810 , induction hypothesis gives @xmath811 \\ints(t_j\\sigma ) \\tpkt\\ ] ] as @xmath488 by lemma  , we obtain @xmath812 \\ints(t\\sigma)$ ] from equations   and  .",
    "likewise , from this assertion  [ l : er3 ] follows by @xmath813 using additionally @xmath814 \\theconst$ ] and @xmath815    following the pattern of the proof of theorem  [ t : popstar ] , replacing the use of lemma  [ l : embed : root ] by lemma  [ l : embed : root : ps ] we obtain :    [ t : popstarps ] let @xmath139 be a constructor trs compatible with an instance of @xmath22 . then the innermost derivation height of any basic term @xmath292 is bounded by a polynomial in the maximal depth of normal arguments @xmath293 .",
    "the polynomial depends only on @xmath139 and the signature @xmath102 .    as a corollary we get the following variant of  theorem  5.3 in  @xcite .",
    "let @xmath139 be the rewrite system based on the defining equations from figure  [ fig:1 ] and the schema  .",
    "then the innermost derivation height of any basic term @xmath292 is bounded by a polynomial in the maximal depth of normal arguments @xmath293 .    by construction",
    "there exists an instance @xmath806 such that @xmath816 .",
    "thus by the theorem , the result follows .    applying proposition  [ p : invariance ] yields that predicative recursion is closed under parameter substitution .",
    "we can even show a stronger result from theorem  [ t : popstarps ] .",
    "let @xmath139 be a constructor trs compatible with an instance of @xmath22 .",
    "for every relation @xmath176 defined by @xmath139 , the function problem @xmath732 associated with @xmath176 is in @xmath4 .",
    "moreover , if @xmath139 is confluent than @xmath733 .    by lemma",
    "[ l : psextends ] , parameter substitution extends the power of @xmath21 , together with theorem  [ t : icc : completeness ] that shows completeness of @xmath21 , this shows completeness of .",
    "we obtain our third result .. ]    [ c : fptime : ps ] the following class of functions are equivalent :    1 .",
    "the class of functions computed by confluent constructor trs compatible with an instance of @xmath22 .",
    "2 .   the class of polytime computable functions @xmath18 .",
    "in this section we present an automation of polynomial path orders , for brevity we restrict our efforts to the order @xmath234 . consider a constructor trs @xmath139 . checking whether @xmath139 is predicative recursive is equivalent to guessing a precedence @xmath26 and partitioning of argument positions so that @xmath817 holds for the induces order @xmath234 . as standard for recursive path orders  @xcite",
    ", this search can be automated by encoding the constraints imposed by definition  [ d : gpop ] into _ propositional logic_. to simplify the presentation , we extend the language of propositional logic with truth - constants @xmath818 and @xmath329 in the obvious way . in the constraint presented below",
    "we employ the following atoms .",
    "to encode the separation of normal from safe arguments , we introduce for @xmath108 and @xmath819 the atoms @xmath820 so that @xmath820 represents the assertion that the argument position of @xmath134 is safe .",
    "further we set @xmath821 for @xmath30-ary @xmath822 and @xmath427 , reflecting that argument positions of constructors are always safe .    since @xmath21 is blind on constructors , predicative recursive trss are even compatible with @xmath234 as induced by an admissible precedence where constructors are equivalent and minimal . for each pair of symbols",
    "@xmath823 , we introduce propositional atoms @xmath824 and @xmath825 so that @xmath824 represents the assertion @xmath243 , and likewise @xmath825 represents the assertion @xmath127 .",
    "overall we define for function symbols @xmath134 and @xmath230 the propositional formulas @xmath826    to ensure that the variables @xmath824 and respectively @xmath825 encode a preorder on @xmath103 we encode an order preserving homomorphism into the natural order @xmath827 on @xmath32 . to this extent , to each @xmath108",
    "we associate a natural number @xmath828 encoded as binary string with @xmath829 bits .",
    "it is straight forward to define boolean formulas @xmath830 ( respectively @xmath831 ) that are satisfiable iff the binary numbers @xmath828 and @xmath832 are decreasing ( respectively equal ) in the natural order . using these we set @xmath833    we say that a propositional assignment @xmath834 _ induces _ the precedence @xmath26 if @xmath834 satisfies @xmath835 when @xmath243 and @xmath836 when @xmath127 .",
    "the next lemma verifies that @xmath837 serves our needs .    for any assignment @xmath834 that satisfies @xmath838",
    ", @xmath834 induces an admissible precedence on @xmath102 .",
    "vice versa , for any admissible precedence @xmath26 on @xmath102 , any valuation @xmath834 , satisfying @xmath839 iff @xmath243 and @xmath839 iff @xmath127 , also satisfies the formula @xmath838 .      for concrete pairs of terms @xmath125 and @xmath112",
    ", we define @xmath840 which enforces the orientation @xmath841 using propositional formulations of the three clauses in definition  [ d : gpop ] . to complete the definition for arbitrary left - hand sides",
    ", we set @xmath842 for all @xmath106 .",
    "further , weak orientation is given by @xmath843 where the constraint @xmath844 refers to a formulation of definition  [ d : eqis ] in propositional logic , defined as follows .",
    "for @xmath124 we simply set @xmath845 .",
    "consider the case @xmath125 and @xmath126 .",
    "then @xmath222 if @xmath127 and moreover @xmath223 for all @xmath427 and some permutation @xmath128 on argument positions that takes the separation of normal and safe positions into account .",
    "to encode @xmath846 , we use fresh atoms @xmath847 for @xmath848 . the propositional formula @xmath849 is used to assert that the atoms @xmath847 reflect a permutation on @xmath850 .",
    "here @xmath851 expresses that exactly one of its arguments evaluates to @xmath818 .",
    "we set @xmath852 to complete the definition , we set @xmath853 for the remaining cases .",
    "suppose the assignment @xmath834 induces an admissible precedence @xmath26 and @xmath834 satisfies @xmath844 .",
    "then @xmath222 with respect to the precedence @xmath26 .",
    "vice versa , if @xmath222 then @xmath844 is satisfiable by assignments @xmath834 that induce the precedence underlying @xmath220 .",
    "we now define the encoding for the different cases underlying the definition of @xmath234 . assuming that @xmath854 enforces @xmath855 clause @xmath856 is expressible as @xmath857 in propositional logic . for clause",
    "@xmath270 we use propositional atoms @xmath858 ( @xmath674 ) to mark the unique argument position of @xmath859{t})$ ] that allows @xmath860 .",
    "the propositional formula @xmath861{\\alpha})$ ] expresses that zero or one @xmath858 valuates to @xmath818 .",
    "further , we introduce the auxiliary constraint @xmath862{t } ) \\in \\termsbelow[f ] } \\defsym \\enc{f \\sp g } \\wedge \\bigwedge_{j=1}^m \\enc{t_j \\in \\termsbelow[f ] } \\tpkt\\ ] ] and @xmath863 } \\defsym \\top$ ] for @xmath106 . using these",
    ", clause @xmath270 becomes expressible as @xmath864{t } ) } \\defsym    \\enc{f \\in \\ds }    \\wedge \\enc{f \\sp g } \\\\",
    "\\wedge \\bigwedge_{j=1}^m ( \\esafe{g}{j }",
    "\\imp \\enc{s \\gpop t_j } )    \\wedge \\bigwedge_{j=1}^m ( \\neg \\esafe{g}{j } \\imp \\enc{s \\gsq t_j } ) \\\\    \\wedge \\ezeroone(\\seq[m]{\\alpha } )     \\wedge \\bigwedge_{j=1}^m ( \\neg \\alpha_j \\imp \\enc{t_j \\in \\termsbelow } ) \\tpkt\\end{gathered}\\ ] ] here @xmath865 if @xmath108 and otherwise @xmath866 .",
    "the propositional formula @xmath867 expresses the orientation with the @xmath233 and is given by @xmath868 and otherwise @xmath869 , where @xmath870{t})$ } \\\\",
    "\\quad \\wedge \\bigwedge_{j=1}^m \\enc{f(\\seq{s } ) \\gsq t_j } \\\\",
    "\\bot & \\text { if $ t \\in \\vs$}.    \\end{cases}\\end{aligned}\\ ] ] this concludes the propositional formulation of clause @xmath270 .",
    "the main challenge in formulating clause @xmath266 is to deal with the encoding of multiset - comparisons .",
    "we proceed as in  @xcite and encode the underlying _",
    "multiset cover_.",
    "let @xmath871 denote the multiset extension of a binary relation @xmath872 .",
    "then a pair of mapping @xmath873 where @xmath874 and @xmath875 is a multiset cover on multisets",
    "@xmath876 and @xmath877{b}}$ ] if the following holds for all @xmath878 :    1 .   [",
    "d : mscover:1 ] if @xmath879 then @xmath880 , in this case we say that @xmath352 _ covers _",
    "@xmath881 ; 2 .",
    "[ d : mscover:2 ] if @xmath882 then @xmath883 and @xmath884 is invective on @xmath885 , i.e. , @xmath886 covers only @xmath881 .",
    "the multiset cover @xmath873 is said to be _ strict _ if at least one cover is strict , i.e. , @xmath887 for some @xmath878 .",
    "it is straight forward to verify that multiset covers characterise the multiset extension of @xmath67 in the following sense .",
    "we have @xmath888{b}}$ ] if and only if there exists a multiset cover @xmath873 on @xmath876 and @xmath877{b}}$ ]",
    ". moreover , @xmath889{b}}$ ] if and only if the cover is strict .",
    "consider the orientation @xmath890{t})$ ] .",
    "then normal arguments are strictly , and safe arguments weakly decreasing with respect to the multiset - extension of @xmath234 .",
    "since the partitioning of normal and safe argument is not fixed , in the encoding of @xmath266 we formalise a multiset - comparison on _ all _ arguments , where the underlying multiset - cover @xmath873 will be restricted so that if @xmath353 covers @xmath891 , i.e. , @xmath892 , then both @xmath353 and @xmath891 are safe or respectively normal . to this",
    "extend , for a specific multiset cover @xmath873 we introduce variables @xmath893 and @xmath894 , where @xmath895 represents @xmath879 and @xmath896 denotes @xmath897 ( @xmath898 , @xmath899 ) .",
    "we set @xmath900{t } ) } \\defsym     \\enc{f \\in \\ds }    \\wedge \\enc{f \\sp g } \\\\",
    "\\wedge     \\bigwedge_{i=1}^{n } \\bigwedge_{j=1}^{m } \\bigl ( \\gamma_{i , j } \\to \\bigl ( \\varepsilon_i \\to \\enc{s_i \\eqis t_j } \\bigr )                                               \\wedge \\bigl ( \\neg \\varepsilon_i \\to \\enc{s_i \\gpop t_j } \\bigr )                                               \\wedge \\bigl ( \\esafe{f}{i } \\iff \\esafe{g}{j } \\bigr )                                        \\bigr ) \\\\",
    "\\wedge \\bigwedge_{j=1}^m \\eone(\\gamma_{1,j},\\dots,\\gamma_{n , j } )      \\wedge \\bigwedge_{i=1}^{n } \\bigl(\\varepsilon_i \\to \\eone(\\gamma_{i,1},\\dots,\\gamma_{i , m})\\bigr )       \\wedge   \\bigvee_{i=1}^n \\bigl ( \\neg \\esafe{f}{i } \\wedge",
    "\\neg \\varepsilon_i \\bigr )   \\tpkt\\end{gathered}\\ ] ] here the first line establishes the condition  , where @xmath901 additionally enforces the separation of normal from safe arguments .",
    "the final line formalises that @xmath902 maps @xmath903 to @xmath850 , condition   as well as the strictness condition on normal arguments .",
    "this completes the encoding of @xmath234 .",
    "suppose @xmath834 induces an admissible precedence @xmath26 and satisfies @xmath904 .",
    "then @xmath253 with respect to the precedence @xmath26",
    ". vice versa , if @xmath253 then @xmath904 is satisfiable assignments @xmath834 that induce the precedence underlying @xmath234 .    putting the constraints together",
    "we get the following theorem , which witnesses the fourth main result of this paper .",
    "let @xmath139 be a constructor trs .",
    "the propositional formula @xmath905 is satisfiable if and only if @xmath139 is predicative recursive .",
    "we have implemented this reduction to  in our complexity analyser .",
    "as underlying -solver we employ the open source solver  @xcite .",
    "the -solver  requires its input in cnf . for a concise translation of @xmath906 to cnf",
    "we use the approach of plaisted and greenbaum  @xcite that gives an equisatisfiable cnf linear in size .",
    "our implementation also eliminates redundancies resulting from multiple comparisons of the same pair of term @xmath907 by replacing subformulas @xmath904 with unique propositional atoms @xmath908 .",
    "since @xmath904 occurs only in positive contexts , it suffices to add @xmath909 , resulting in an equisatisfiable formula . also during construction of @xmath906",
    "our implementation performs immediate simplifications under boolean laws .",
    "in this section we present an empirical evaluation of polynomial path orders .",
    "we selected two testbeds : testbed   constitutes of 597 terminating constructor trss , obtained by restricting the innermost runtime complexity problemset from the _ _ termination problem database _ _ ( _ tpdb _ for short ) , version 8.0 , to known to be terminating constructor trss .",
    "termination is checked against the data available from the termination competition .",
    "testbed  , containing 290 examples , results from restricting testbed   to orthogonal systems .",
    "unarguably the tpdb is an imperfect choice as examples were collected primarily to assess the strength of termination provers , but it is at the moment the only extensive source of trss .",
    "experiments were conducted with @xmath20 version 1.9.1 , on a laptop with 4 gb of ram and intel@xmath910 core@xmath31 i72620 m cpu ( 2.7ghz , quad - core ) .",
    "we assess the strength of @xmath21 and @xmath22 in comparison to its predecessors @xmath17 and @xmath23 .",
    "the implementation of @xmath17 , @xmath23 and @xmath22 follows the line of polynomial path orders as explained in section  [ s : impl ] . in",
    "is the only implementation currently available . ]",
    "we contrast these syntactic techniques to _ interpretations _ as implemented in our complexity tool @xmath20 .",
    "the last column show result of constructor restricted matrix interpretations  @xcite ( dimension @xmath911 and @xmath912 ) as well as polynomial interpretations  @xcite ( degree @xmath913 and @xmath912 ) , run in parallel on the quad - core processor .",
    "we employ interpretations in their default configuration of , noteworthy coefficients ( respectively entries in coefficients ) range between @xmath318 and @xmath914 , and we also make use of the _ usable argument positions _ criterion  @xcite that weakens monotonicity constraints .",
    "table  [ tbl : exp1 ] shows totals on systems that can respectively can not be handled . to the right of each entry",
    "we annotate the average execution time , in seconds .",
    ".empirical evaluation , comparing syntactic to semantic techniques .",
    "[ cols=\"<,<,^,^,^,^,^\",options=\"header \" , ]     it is immediate that syntactic techniques can not compete with the expressive power of interpretations . in testbed",
    "there are in fact only three examples compatible with  where  could not find interpretations .",
    "there are additionally four examples compatible with  but not so with interpretations , including the trs @xmath24 from example  [ ex : rs2 ] .",
    "all but one ( noteworthy the merge - sort algorithm from steinbach and khlers collection ( * ? ? ?",
    "* example  2.43 ) ) of these do in fact admit exponential runtime complexity , thus a  priori they are not compatible to the restricted interpretations .",
    "we emphasise that parameter substitution significantly increases the strength of , 13 examples are provable by  but neither by  nor .",
    "could benefit from parameter substitution , we conjecture that the resulting order is still sound for @xmath18 .    in sum on testbed  , containing only orthogonal trss , in total 75 systems ( 26% of the testbed )",
    "can be verified to encode polytime computable functions , 35 ( 12% of the testbed ) can be verified polytime computable by only syntactic techniques .",
    "it should be noted that not all examples appearing in our collection encode polytime computable functions , the total amount of such systems is unknown .",
    "it seems that table  [ tbl : exp1 ] clearly shows the weakness of polynomial path orders ( even with parameter substitution ) for automated polynomial runtime complexity",
    ". however , remark the average execution times provided",
    ".  succeeds on average 14 times faster than polynomial and matrix interpretations . here",
    "the difficulty of implementing interpretations efficiently is also reflected in the total number of timeouts . furthermore note that a competitive complexity analyser can not be based on direct techniques alone .",
    "instead , our complexity analyser  recursively decomposes complexity problems using various complexity preserving transformation techniques  @xcite , discarding those problems that can be handled by basic techniques as contrasted in table  [ tbl : exp1 ] .",
    "certificates are only obtained if finally all subproblems can be discarded , above all it is crucial that subproblems can be discarded quickly . due to the efficiency of syntactic methods , these can be safely preposed to semantic techniques , thus speeding up the overall procedure .",
    "this paper is concerned with the complexity analysis of constructor term rewrite systems and its ramification in implicit computational complexity .",
    "we have proposed a path order with multiset status , the polynomial path order .",
    "the order @xmath21 is a syntactical restriction of multiset path orders , with the distinctive feature that the innermost runtime complexity of compatible trss lies in @xmath915 for some @xmath731 .",
    "based on @xmath21 , we delineate a class of rewrite systems , dubbed systems of predicative recursion , so that the class of functions computed by these systems corresponds to @xmath18 , the class of polytime computable functions .",
    "we have shown that an extension of @xmath21 , the order @xmath22 that also accounts for parameter substitution , increases the intensionality of @xmath21 .    from the viewpoint of implicit computational complexity we have provided new implicit characterisations of the class of polytime functions . more precisely ,  and   are sound for the class of function problems @xmath4 and are readily applicable to obtain exact characterisations of the polytime computable functions . as an easy corollary",
    ", we have given an alternative proof of bellantoni s result that the polytime computable functions are closed under parameter substitution .    from the viewpoint of ( automated ) runtime complexity analysis we have proposed two new syntactic techniques to establish polynomial innermost runtime complexity .",
    "in contrast to semantic techniques polynomial path orders are partly lacking in intensionality but greatly surpluses in verification time .",
    "note that in our complexity prover , we do not intend to replace semantic techniques , but rather prepose them by , in order to improve  both in analytic power and speed .    in runtime complexity analysis one",
    "is in particular interested in obtaining asymptotically tight bounds . although we could estimate the degree of the witnessing bounding function for  and ,",
    "such a bound would be a gross overestimation .",
    "this is partly due to the underlying multiset extension .",
    "very recently , together with eguchi we have proposed a simplification of the polynomial path orders studied here : the _ small polynomial path orders _ ( _ _ for short ) .",
    "this termination order entails a finer control on the runtime complexity : for any rewrite system compatible with that employs recursion upto depth @xmath731 , the innermost runtime complexity is polynomially bounded of degree @xmath731 .",
    "this bound is tight , see  @xcite .",
    "this becomes possible , as the underlying scheme of safe composition is restricted to so - called _ weak safe composition_.",
    "we are in particular thankful to nao hirokawa for fruitful discussions .",
    "furthermore the second author would like to thank toshiyasu arai for having introduced him to the topic of predicative recursion .",
    "finally , we are indebted to the annonymous reviewers for their constructive criticism ."
  ],
  "abstract_text": [
    "<S> this paper is concerned with the complexity analysis of constructor term rewrite systems and its ramification in implicit computational complexity . </S>",
    "<S> we introduce a path order with multiset status , the _ polynomial path order _ , that is applicable in two related , but distinct contexts . on the one hand  </S>",
    "<S> induces polynomial innermost runtime complexity and hence may serve as a syntactic , and fully automatable , method to analyse the innermost runtime complexity of term rewrite systems . on the other hand  </S>",
    "<S> provides an order - theoretic characterisation of the polytime computable functions : the polytime computable functions are exactly the functions computable by an orthogonal constructor trs compatible with . </S>"
  ]
}