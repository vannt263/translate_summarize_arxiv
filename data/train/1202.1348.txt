{
  "article_text": [
    "with the introduction of high speed applications such as flash memory , fiber and free - space optical communications comes the need for fast and low - complexity error control coding .",
    "message passing algorithms for decoding low - density parity - check ( ldpc ) codes such as the sum - product algorithm ( spa ) offer very attractive error performance , especially for codes with column - weight @xmath0 .",
    "however , the complexity of these algorithms is still high and the decoding speed is limited , mostly due the fact that the operations at variable and check nodes must be carried out for every edge in the tanner graph . for regular column - weight - three ldpc codes , which allow lower complexity implementation , message passing algorithms ( as well as other classes of decoding algorithms ) usually suffer from high error floor .",
    "this weakness of message passing algorithms in regular column - weight - three ldpc codes justifies the search for alternatives which offer better trade - offs between complexity , decoding speed and error performance .    among existing decoding algorithms for ldpc codes on the binary symmetric channel ( bsc ) ,",
    "bit flipping algorithms are the fastest and least complex .",
    "the check node operations of these algorithms are modulo - two additions while the variable node operations are simple comparisons .",
    "the simplicity of these algorithms also makes them amenable to analysis .",
    "many important and interesting results on the error correction capability of the serial and parallel bit flipping algorithms have been derived ( see @xcite for a list of references ) .",
    "unfortunately , their error performance is typically inferior . as a result ,",
    "bit - flipping - oriented algorithms have been largely considered to be impractical , even after the introduction of some improved versions , such as the one in @xcite .    in @xcite , a class of bit flipping algorithms that employ two bits for decoding ldpc codes over the bsc was proposed .",
    "compared to serial and parallel bit flipping , a two - bit bit flipping ( tbf ) algorithm employs one additional bit at a variable node and one at a check node .",
    "the additional bits introduce _ memory _ in the decoding process , which slows down the decoding when necessary .",
    "initial results showed that decoders which employ a group of these algorithms operating in parallel lower the error floor while maintaining low complexity .",
    "however , in @xcite we have not given a complete failure analysis of these algorithms , nor have we established the methodology to derive good algorithms and/or a collection of mutually good algorithms .    in this paper , we provide complete failure analysis for tbf algorithms .",
    "more importantly , we give a rigorous procedure to select groups of algorithms based on their complementariness in correcting different error patterns .",
    "decoders that employ algorithms selected using this procedure have provably good error performance and , by the nature of bit flipping , high speed .",
    "as one can expect , a tbf algorithm ( like other sub - optimal graph - decoding algorithms ) fails on some low - weight error patterns due to the presence of certain small subgraphs in the tanner graph . in this paper",
    ", we characterize a special class of these subgraphs and refer to them with the common term `` trapping sets . ''",
    "our definition of a trapping set for a given algorithm readily gives a sufficient condition for successful decoding .",
    "the set of all possible trapping sets of a given decoding algorithm constitutes the algorithm s trapping set profile .",
    "a unique property of trapping sets for tbf algorithms is that a trapping set profile may be obtained by a recursive procedure .",
    "the diversity among trapping set profiles of different algorithms allows us to select groups of algorithms such that they can collectively correct error patterns that are uncorrectable by individual algorithms .",
    "the rest of the paper is organized as follows .",
    "section [ sect_pre ] gives the necessary background .",
    "section [ sect_mot ] gives motivation . in section [ sect_analysis ] , we define trapping sets , trapping set profiles and describe the recursive procedure for constructing a trapping set profile .",
    "section [ sect_select ] discusses the process of selecting algorithms .",
    "numerical results are given in section [ sect_sim ] .",
    "let @xmath1 denote an ( @xmath2 ) binary ldpc code .",
    "@xmath1 is defined by the null space of @xmath3 , an @xmath4 _ parity - check matrix _ of @xmath1 .",
    "@xmath3 is the bi - adjacency matrix of @xmath5 , a tanner graph representation of @xmath1 .",
    "@xmath5 is a bipartite graph with two sets of nodes : @xmath6 variable ( bit ) nodes @xmath7 and @xmath8 check nodes @xmath9 ; and a set of edges @xmath10 .",
    "a ( @xmath11)-regular ldpc code has a tanner graph @xmath5 in which all variable nodes have degree @xmath12 and all check nodes have degree @xmath13 . in this paper , we only consider ( @xmath11)-regular ldpc codes .",
    "a subgraph of a bipartite graph @xmath5 is a bipartite graph @xmath14 such that @xmath15 , @xmath16 and @xmath17 .",
    "@xmath5 is said to contain @xmath14 . furthermore ,",
    "if @xmath18 is a graph which is isomorphic to @xmath14 then @xmath5 is also said to contain @xmath18 . in a bipartite graph @xmath5 , the induced subgraph on a set of variable nodes",
    "@xmath19 is a bipartite graph @xmath14 with @xmath20 , @xmath21 and @xmath22 .",
    "a vector @xmath23 is a codeword if and only if @xmath24 , where @xmath25 is the transpose of @xmath3 .",
    "assume the transmission of the all - zero codeword over the bsc .",
    "denote by @xmath26 the channel output vector and denote by @xmath27 the decision vector after the @xmath28th iteration of the iterative algorithm , where @xmath28 is a positive integer . at the end of the @xmath28th iteration",
    ", a variable node @xmath29 is said to be _ corrupt _ if @xmath30 , otherwise it is _",
    "correct_. for the sake of convenience , we let @xmath31 .",
    "a variable node @xmath29 with @xmath32 is _ initially corrupt _",
    ", otherwise it is _ initially correct_. let @xmath33 denote the syndrome vector of the decision vector after the @xmath28th iteration , i.e. , @xmath34 .",
    "a check node @xmath35 is said to be satisfied at the beginning of the @xmath28th iteration if @xmath36 , otherwise it is unsatisfied .",
    "tbf algorithms are defined as follows .",
    "the class @xmath37 of tbf algorithms is given in algorithm [ algo_tbfa ] , where @xmath38 gives the states of the check nodes at the beginning of the @xmath28th iteration while @xmath39 gives the states of the variable nodes at the end of the @xmath28th iteration .",
    "a variable node @xmath29 takes its state from the set @xmath40 , i.e. , it can be strong zero , weak zero , weak one or strong one .",
    "a check node takes its state from the set @xmath41 , i.e. , it can be previously satisfied , newly satisfied , previously unsatisfied or newly unsatisfied .",
    "the state @xmath42 of a variable node @xmath29 is initialized to @xmath43 if @xmath44 and to @xmath45 if @xmath46 .",
    "the state @xmath47 of a check node @xmath35 is initialized to @xmath48 if @xmath49 and to @xmath50 otherwise .",
    "a tbf algorithm @xmath51 iteratively updates @xmath52 and @xmath53 until all check nodes are satisfied or until a maximum number of iteration @xmath54 is reached .",
    "the check node update function @xmath55 is defined as follows : @xmath56 and @xmath57 .",
    "the variable node update is specified by a function @xmath58 , where @xmath59 is the set of all ordered 4-tuples @xmath60 such that @xmath61 and @xmath62 . @xmath63 and @xmath64 give the number of check nodes with states @xmath65 and @xmath66 , respectively , that are connected to @xmath29 .",
    "the function @xmath67 must be symmetric with respect to @xmath68 and @xmath69 and must allow every state of a variable node to be reachable from any other state .",
    "[ algo_tbfa2 ] @xmath70 , @xmath71 , @xmath72 @xmath73 ; @xmath74 ; @xmath75 ;    what makes a tbf algorithm novel is that a variable node has `` strength '' and a check node s reliability is evaluated based on its state in the previous iteration .",
    "consider a collection @xmath76 of iterative decoding algorithms for ldpc codes .",
    "let us assume for a moment that the set of all uncorrectable error patterns for each and every algorithm in @xmath76 is known .",
    "more precisely , in the context of ldpc codes , we assume that the induced subgraphs on such error patterns can be enumerated for each decoding algorithm .",
    "this naturally suggests the use of a decoder @xmath77 which employs multiple algorithms drawn from @xmath76 . the basis for this use of multiple algorithms is rather simple",
    ": if different algorithms are capable of correcting different error patterns , then a decoder employing a set of properly selected algorithms can achieve provably better error performance than any single - algorithm decoder .",
    "disappointingly , the above hypothetical assumption is not valid for most iterative algorithms . for message passing algorithms such as the spa",
    ", there is no simple criterion to verify weather or not an arbitrary error pattern is correctable , much less an explicit methodology to design a decoder which employs multiple algorithms in a collaborative manner .    interestingly , for tbf algorithms , we are able to establish a framework to analyze and enumerate all uncorrectable error patterns , and this is the main contribution of this paper .",
    "in particular , we characterize the decoding failures of tbf algorithms by redefining trapping sets and introducing the definition of trapping set profiles .",
    "it is an important property of the newly defined trapping sets that enable us to enumerate them using a recursive procedure .",
    "we remark that the enumeration of trapping sets is code independent .",
    "more importantly , the concept and explicit construction of trapping set profiles allow rigorous selections of multiple algorithms which can collectively correct a fixed number of errors with high probability . given that the selection of multiple algorithms would become straightforward once the trapping sets / trapping set profiles have been defined and constructed , we devote a considerable portion of the paper to introducing these two objects .",
    "we also focus on giving criteria for selecting algorithms rather than explicitly describing the selection process .",
    "although the term trapping set was originally defined as a set of variable nodes that are not eventually correctable by an iterative decoding algorithm @xcite , in the literature it has been used more frequently to refer to a _ combinatorially defined subgraph _ that _ may _ be harmful to decoding .",
    "the justification for this less rigorous use of terminology is that the variable node set of a so - called trapping set ( a subgraph ) would be an actual set of non - eventually - correctable variable nodes if the parallel bit flipping algorithm were used ( see @xcite for details ) .",
    "examples of such trapping sets are fixed sets @xcite and absorbing sets @xcite . for tbf algorithms ,",
    "failure analysis can no longer solely rely on these combinatorial objects . for certain tbf algorithms , the smallest subgraphs that cause decoding",
    "failures are neither absorbing sets nor fixed sets .",
    "we therefore ( re)define the notion of a trapping set for tbf algorithms , as we now explain .",
    "we first introduce the following definition on failures of a tbf algorithm .",
    "consider a tbf algorithm @xmath78 and a tanner graph @xmath5 .",
    "let @xmath79 denote the set of variable nodes that are initially corrupt and let @xmath80 denote the induced subgraph on @xmath79 . if the algorithm @xmath78 does not converge on @xmath5 after @xmath81 iterations , then we say that _ @xmath78 fails on the subgraph @xmath80 of @xmath5_.    it can be seen that the decoding failure of @xmath78 is defined with the knowledge of the induced subgraph on the set of initially corrupt variable nodes . to characterize failures of @xmath78 , a collection of all induced subgraphs @xmath80 must be enumerated .",
    "while this is difficult in general , for practically important cases of small numbers of initial errors ( less than 8) and small column - weight codes ( @xmath82 or 4 ) , the enumeration of such induced subgraphs is tractable .",
    "consider a given tanner graph @xmath80 .",
    "let @xmath83 denote a set of tanner graphs containing a subgraph @xmath84 isomorphic to @xmath80 such that @xmath78 fails on @xmath84 .",
    "since @xmath83 is undeniably too general to be useful , we focus our attention on a subset @xmath85 of @xmath83 , described as follows .",
    "[ defn_er ] consider a tanner graph @xmath86 such that @xmath78 fails on the subgraph @xmath87 of @xmath88 .",
    "then , @xmath89 if there _ does not _",
    "exist @xmath90 such that :    1 .",
    "@xmath78 fails on the subgraph @xmath91 of @xmath92 , and 2 .",
    "there is an isomorphism between @xmath92 and a proper subgraph of @xmath88 under which the variable node set @xmath93 is mapped into the variable node set @xmath94 .",
    "now we are ready to define trapping sets and trapping set profiles of a tbf algorithm .    if @xmath95 then @xmath96 is a trapping set of @xmath78 .",
    "@xmath80 is called an inducing set of @xmath96 .",
    "@xmath85 is called the trapping set profile with inducing set @xmath80 of @xmath78 .",
    "the following proposition states an important property of a trapping set .",
    "[ allcprop ] let @xmath96 be a trapping set of @xmath78 with inducing set @xmath80 .",
    "then , there exists at least one induced subgraph @xmath84 of @xmath96 which satisfies the following properties :    1 .",
    "@xmath84 is isomorphic to @xmath80 , and 2 .",
    "@xmath78 fails on @xmath84 of @xmath96 , and 3 .",
    "consider the decoding of @xmath78 on @xmath96 with @xmath97 being the set of initially corrupt variable nodes .",
    "then , for any variable node @xmath98 , there exist an integer @xmath99 such that @xmath100 .    the proof is omitted due to page limits . from proposition",
    "[ allcprop ] , one can see that the trapping set profile @xmath85 of @xmath78 contains the graphs that are most `` compact . ''",
    "we consider these graphs most compact because for at least one @xmath84 isomorphic to @xmath80 , the decoding of @xmath78 on such a graph with @xmath97 being the set of initially corrupt variable nodes could be made successful _ by removing any variable node of the graph_. this special property of trapping sets is the basis for an explicit recursive procedure to obtain all trapping sets up to a certain size , which compensates for the lack of a fully combinatorial characterization of trapping sets .",
    "we remark that for certain reasonably good algorithms , the necessary condition for a tanner graph to be a trapping set can be easily derived . before describing the recursive procedure for constructing trapping set profiles , we state the following proposition , which gives a sufficient condition for the convergence of an algorithm @xmath78 on a tanner graph @xmath5 .",
    "[ proff ] consider decoding with an algorithm @xmath78 on a tanner graph @xmath5 .",
    "let @xmath101 be the set of initially corrupt variable nodes and @xmath80 be the induced subgraph on @xmath101 . then",
    ", algorithm @xmath78 will converge after at most @xmath81 decoding iterations if there does not exist a subset @xmath102 of @xmath103 such that @xmath104 and the induced subgraph on @xmath102 is isomorphic to a graph in @xmath85",
    ".    follows from the definition of @xmath85 . _",
    "remark : _ proposition [ proff ] only gives a sufficient condition because the existence of @xmath19 which satisfies the above - mentioned conditions does not necessarily indicate that @xmath105 .",
    "the recursive procedure for constructing a trapping set profile @xmath85 relies on proposition [ allcprop ] .",
    "let us assume that we are only interested in trapping sets with at most @xmath106 variable nodes .",
    "consider the decoding of @xmath78 on a tanner graph @xmath80 with @xmath107 being the set of initially corrupt variable nodes .",
    "let @xmath108 .",
    "if @xmath78 fails on the subgraph @xmath80 of @xmath80 then @xmath109 and we have found the trapping set profile .",
    "if @xmath78 does not fail on the subgraph @xmath80 of @xmath80 , then we expand @xmath80 by recursively adding variable nodes to @xmath80 until a trapping set is found . during this process",
    ", we only add variable nodes that become corrupt at the end of a certain iteration .    consider all possible bipartite graphs obtained by adding one variable node , namely @xmath110 , to the graph @xmath80 such that when the decoding is performed on these graphs with @xmath107 being the set of initially corrupt variable nodes , the newly added variable node is a corrupt variable node at the end of the _ first iteration _",
    ", i.e. , @xmath111 .",
    "let @xmath112 denote the set of such graphs .",
    "take one graph in @xmath112 and denote it by @xmath14 .",
    "then , there can be two different scenarios in this step .",
    "first , @xmath78 does not fail on the subgraph @xmath80 of @xmath14 . in this case",
    ", @xmath14 is certainly not a trapping set and we put @xmath14 in a set of tanner graphs denoted by @xmath113 .",
    "second , @xmath78 fails on the subgraph @xmath80 of @xmath14 . in this case",
    ", @xmath14 can be a trapping set and a test is carried out to determine if @xmath14 is indeed one . if @xmath14 is not a trapping set then it is discarded .",
    "we complete the formation of @xmath113 by repeating the above step for all other graphs in @xmath112 .",
    "let us now consider a graph @xmath114 .",
    "again , we denote by @xmath115 the set of tanner graphs obtained by adding one variable node , namely @xmath116 , to the graph @xmath14 such that when the decoding is performed on these graphs with @xmath107 being the set of initially corrupt variable nodes , the newly added variable node is a corrupt variable node at the end of the first iteration , i.e. , @xmath117 .",
    "it is important to note that the addition of variable node @xmath116 , which is initially correct , can not change the fact that variable node @xmath110 is also corrupt at the end of the first iteration .",
    "this is because the addition of correct variable nodes to a graph does not change the states of the existing check nodes and the decoding dynamic until the newly added variable nodes get corrupted .",
    "similar to what have been discussed before , we now take a graph in @xmath115 and determine if it is a trapping set , or it is to be discarded , or it is a member of the set of tanner graph @xmath118 . by repeating this step for all other graphs in @xmath113 , all graphs in @xmath118 can be enumerated . in a similar fashion , we obtain @xmath119 . for the sake of convenience , we also let",
    "@xmath120 .    at this stage , we have considered one decoding iteration on @xmath80 . it can be seen that if @xmath96 is a trapping set with at most @xmath106 variable nodes then either @xmath96 has been found , or @xmath96 must contain a graph in @xmath121 .",
    "therefore , we proceed by expanding graphs in @xmath122 .",
    "let @xmath123 denote a tanner graph in @xmath122 .",
    "we now repeat the above graph expanding process with @xmath123 being the input . specifically , we first obtain @xmath124 , which is defined as the set of all tanner graphs obtained by adding one variable node @xmath125 to the graph @xmath123 such that when decoding is performed on these graphs with @xmath107 being the set of initially corrupt variable nodes , the newly added variable node is a corrupt variable node at the end of the _ second iteration _ , but not a corrupt variable node at the end of the first iteration , i.e. , @xmath126 and @xmath127 .",
    "graphs in @xmath124 that are not trapping sets are either discarded or to form the set @xmath128 . by recursively adding variable nodes , graphs in @xmath129",
    "are enumerated .",
    "one can see that there are two recursive algorithms .",
    "the first algorithm enumerates graphs in @xmath130 for a given graph @xmath123 by recursively adding variable nodes .",
    "the second algorithm recursively calls the first algorithm to enumerates graphs in @xmath130 for each graph @xmath123 in @xmath122 .",
    "each recursion of the second algorithm corresponds to a decoding algorithm . as a result",
    ", the trapping set profile is obtained after @xmath54 recursions of the second algorithm .",
    "due to page limits , we only summarize the most important criteria for selecting tbf algorithms .",
    "let us first briefly discuss the number of possible algorithms .",
    "let @xmath131 be the set of all functions from @xmath132 that satisfy the symmetry and the irreducibility condition .",
    "due the symmetry condition , @xmath133 .",
    "there are two possible values of @xmath134 , and two possible values of @xmath135 . however , with a given @xmath135 , the two sets of algorithms @xmath78 that correspond to two possible @xmath134 are identical ( as @xmath136 and @xmath137 , @xmath138 and @xmath139 can be interchanged ) .",
    "consequently , if we disregard the maximum number of iterations , then @xmath140 . one can easily show that @xmath141 .",
    "therefore , an upper - bound on the number of tbf algorithms is : @xmath142 when @xmath143 , and is @xmath144 when @xmath145 . due to the huge number of possible algorithms ,",
    "it is necessary to focus on a small subset of algorithms .",
    "this subset of algorithms may be obtained by imposing certain constraints on the function @xmath67 .",
    "one example of such a constraint is as follows : if @xmath146 then @xmath147 .",
    "this constraint requires that when a strong zero variable node is flipped with a given combination of check nodes , a weak variable node is also flipped with the same check node combination .",
    "other constraints on @xmath67 are derived by analyzing possible transitions of variable nodes and check nodes for a small number of iterations .",
    "we first discuss the main criterion to select one algorithm among all possible algorithms .",
    "let @xmath148 be the smallest number of variable nodes of tanner graphs in @xmath85 .",
    "we would like to select an algorithm @xmath78 such that @xmath148 is maximized .",
    "the justification for this selection criterion relies on the following proposition , whose proof is omitted due to page limits .",
    "[ profg ] given three random tanner graph @xmath149 with @xmath150 , the probability that @xmath5 contains @xmath92 is less than the probability that @xmath5 contains @xmath88 .    from proposition [ profg ]",
    ", one can see that the larger the number @xmath151 of a given tanner graph @xmath96 is , the easier it would be ( if at all possible ) to construct a tanner graph @xmath5 that does not contain @xmath96 .",
    "therefore , a larger @xmath148 means that the sufficient condition for the convergence of @xmath78 can be met with higher probability . in this sense ,",
    "an algorithm @xmath78 with a larger @xmath148 is more favorable .    if for two",
    "algorithms @xmath152 and @xmath153 , @xmath154 = @xmath155 , then one can derive other comparison criteria based on @xmath156 and @xmath157 , and/or compare @xmath152 and @xmath153 with a different assumption of @xmath80 .",
    "for example , the probability of a graph @xmath5 containing a trapping set @xmath96 can be also be evaluated based on @xmath158 .",
    "we now consider the problem of selecting of multiple algorithms .",
    "the basis for this selection is that one should select good individual algorithms with diverse trapping set profiles . in this paper",
    ", we only consider decoder @xmath77 with algorithms @xmath159 operating in parallel , i.e. , the received vector of the channel is the input vector for all algorithms .",
    "note that one can also use trapping set profiles to select algorithms that operate in serial , i.e. , the output from one algorithm is the input to another . for a decoder @xmath77 that employs parallel algorithms , the concept of trapping sets and trapping set profiles",
    "can be defined in the same manner as trapping sets and trapping set profiles for a single tbf algorithm .",
    "one can easily modify the recursive procedures given in section [ sect_algo ] to generate trapping set profiles of the decoder @xmath77 .",
    "then , @xmath77 can be designed with the same criterion discussed in the previous subsection .    _",
    "remark : _ knowledge on the tanner graph of a code @xmath1 can be used in the selection of algorithms .",
    "for example , if it is known that the tanner graph of @xmath1 does not contain a certain subgraph @xmath18 , then all graphs containing @xmath18 must be removed from a trapping set profile .",
    "as an example , we describe a selection of tbf algorithms for regular column - weight - three ldpc codes with girth @xmath160 . for simplicity , we let @xmath161 , @xmath162 and @xmath163 for all algorithms . by imposing certain constraints on the functions @xmath67",
    ", we obtain a set of @xmath164 tbf algorithms . out of these",
    ", there are @xmath165 algorithms which can correct any weight - three error pattern .",
    "such an algorithm is capable of correcting any weight - three error pattern because its trapping set profile @xmath85 with any inducing set @xmath80 containing three variable nodes is empty .",
    "since all weight - three error patterns can be corrected with a single algorithm , our next step is to select a collection of algorithms which can collectively correct weight - four and -five error patterns with high probability . to achieve this goal , we construct all trapping set profiles with inducing sets containing four and five variable nodes for each algorithm .",
    "note that there are 10 possible inducing sets ( tanner graphs with girth @xmath160 ) containing four variable nodes and 24 possible inducing sets containing five variable nodes .",
    "hence , for each algorithm , we construct a total of 34 trapping set profiles . from the trapping set profiles of all algorithms",
    ", we select a collection of 35 algorithms based on the criterion mentioned in the previous section .",
    "then , we simulate the performance of a decoder @xmath77 which employs these algorithms in parallel .",
    "the maximum total number of iterations of @xmath77 is @xmath166 .",
    "figure [ fig_fer1 ] shows the frame error rate ( fer ) performance of @xmath77 on the @xmath167 tanner code .",
    "this code has @xmath168 , @xmath169 and minimum distance @xmath170 . for comparison ,",
    "the fer performance of the spa with a maximum of 100 iterations is also included .",
    "it can be seen that the fer performance of @xmath77 approach ( and might surpasses ) that of the spa in the error floor region .",
    "it is also important to note that if we eliminate all trapping sets containing subgraphs that are not present in the tanner graph of this code , then all the obtained trapping set profiles are empty .",
    "this indicates that @xmath77 can correct any error pattern up to weight 5 in the tanner code .",
    "figure [ fig_fer1 ] also shows the fer performance of @xmath77 on a quasi - cyclic code @xmath171 of length @xmath172 , rate @xmath173 and minimum distance @xmath174 . the fer performance of the spa is also included for comparison .",
    "it can be seen that the slope of the fer curve of @xmath77 in the error floor region is higher than that of the spa . finally , we remark that the slope of the fer curve of @xmath77 in the error floor region is between 5 and 6 , which indicates that @xmath77 can correct error patterns of weight 4 and 5 with high probability .",
    "this also agrees with the fact that in our simulation , no weight - four error pattern that leads to decoding failure of @xmath77 was observed .",
    "we remark that the implementation of tbf algorithms operating in parallel can be done with a relatively small number of common logic gates .",
    "for example , if a decoder @xmath77 employs both the tbfa1 and the tbfa2 given in @xcite , then the implementation of the variable node updates require less than 800 and - gate inputs and 100 or - gate inputs . in comparison ,",
    "the implementation of a 6-bit adder requires 2196 and - gate inputs and 355 or - gate inputs while that of a 6-bit comparator requires 1536 and - gate inputs and 190 or - gate inputs .",
    "one can also expect that the complexity introduced by an additional algorithm would decrease as the number of algorithms increases , because many min - terms in the variable node update logic functions would be already available .",
    "more details will be provided in the journal version of this paper .",
    "this work is funded by nsf under the grants ccf-0963726 , ccf-0830245 .",
    "d.  v. nguyen , s.  k. chilappagari , b.  vasic , and m.  w. marcellin , `` on the construction of structured ldpc codes free of small trapping sets , '' _ ieee trans .",
    "inf . theory _ ,",
    "58 , no .  4 , pp . 22802302 , apr . 2012 .",
    "l.  dolecek , z.  zhang , v.  anantharam , m.  j. wainwright , and b.  nikolic , `` analysis of absorbing sets and fully absorbing sets of array - based ldpc codes , '' _ ieee trans .",
    "inf . theory _ ,",
    "56 , no .  1 ,",
    "181201 , jan . 2010"
  ],
  "abstract_text": [
    "<S> a class of two - bit bit flipping algorithms for decoding low - density parity - check codes over the binary symmetric channel was proposed in @xcite . </S>",
    "<S> initial results showed that decoders which employ a group of these algorithms operating in parallel can offer low error floor decoding for high - speed applications . as the number of two - bit bit flipping algorithms is large , designing such a decoder is not a trivial task . in this paper , we describe a procedure to select collections of algorithms that work well together . </S>",
    "<S> this procedure relies on a recursive process which enumerates error configurations that are uncorrectable by a given algorithm . </S>",
    "<S> the error configurations uncorrectable by a given algorithm form its _ trapping set profile_. based on their trapping set profiles , algorithms are selected so that in parallel , they can correct a fixed number of errors with high probability . </S>"
  ]
}