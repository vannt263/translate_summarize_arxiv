{
  "article_text": [
    "the classic slepian  wolf coding theorem characterizes the optimal rates for the lossless compression of two correlated data sources . in this theorem",
    "the correlated data sources ( two sequences of correlated random variables ) are encoded separately ; then the compressed data are delivered to the receiver where all the data are jointly decoded , see the scheme in fig .  1 .",
    "[ fig - scheme ]    the seminal paper  @xcite gives a very precise characterization of the profile of accessible compression rates in terms of shannon s entropies of the sources .",
    "namely , if the data sources are obtained as @xmath4 and @xmath5 , where @xmath6 , @xmath7 is a sequence of i.i.d .",
    "random pairs , then all pairs of rates satisfying the inequalities @xmath8 can be achieved ( with a negligible error probability ) ; conversely , if at least one of the inequalities @xmath8 is violated , then the error probability becomes overwhelming .",
    "the areas of _ achievable _ and _ non - achievable _ rates are shown in fig .  2 ( the hatched green area consists of achievable points , and the solid red area consists of non - achievable points ; the gap between these areas vanishes as @xmath9 ) .",
    "r0.55     it is instructive to view the slepian  wolf coding problem in the general context of information theory . in the paper",
    "`` _ _ three approaches to the quantitative definition of information _",
    "@xcite , kolmogorov compared a _ combinatorial _ ( _ cf_. hartley s combinatorial definition of information , @xcite ) , a _ probabilistic _ ( _ cf_. shannon s entropy ) , and an _ algorithmic _ approach ( _ cf_. algorithmic complexity a.k.a .",
    "kolmogorov complexity ) .",
    "quite a few fundamental concepts and constructions in information theory have parallel implementations in all three approaches .",
    "a prominent example of this parallelism is provided by the formal information inequalities : they can be equivalently represented as linear inequalities for shannon s entropy , for kolmogorov complexity , @xcite , or for ( logs of ) cardinalities of finite sets , @xcite , @xcite .",
    "it is remarkable that many results known in one of these approaches look very similar to its homologues from the two other approaches , whereas the mathematical techniques and formal proofs behind them are fairly different .    as for the multi - source coding theory ,",
    "two homologue theorems are known : the slepian ",
    "wolf coding theorem in shannon s framework ( where the data sources are random variables , and the achievable rates are characterized in terms of the shannon entropies of the sources ) and muchnik s theorem on conditional coding , @xcite , in kolmogorov s framework ( where the data sources are words , and the achievable rates are characterized in terms of the kolmogorov complexities of the sources ) .",
    "what is missing in this picture is a satisfactory `` combinatorial '' version of the slepian ",
    "wolf theorem ( though several partial results are known , see blow ) .",
    "we try to fill this gap ; we start with a formal definition of the combinatorial slepian  wolf coding scheme and then prove some bounds for the areas of achievable rates .",
    "we focus on the binary symmetric case of the problem . in our ( combinatorial )",
    "version of the slepian ",
    "wolf coding problem the data sources are binary strings , and the correlation between sources means that the hamming distance between these strings is bounded .",
    "more formally , we consider a communication scheme with two senders ( let us call them alice and bob ) and one receiver ( we call him charlie ) .",
    "we assume alice is given a string @xmath0 and bob is given a string @xmath1 .",
    "both strings are of length @xmath2 , and the hamming distance between @xmath0 and @xmath1 is not greater than a threshold @xmath3 . the senders prepare some messages @xmath10 and @xmath11 for the receiver ( i.e. , alice computes her message given @xmath0 and bob computes his message given @xmath1 ) .",
    "when both messages are delivered to charlie , he should decode them and reconstruct both strings @xmath0 and @xmath1 .",
    "our aim is to characterize the optimal lengths of alice s and bob s messages .",
    "this is the general scheme of the combinatorial version of the slepian",
    " wolf coding problem .",
    "let us place emphasis on the most important points of our setting :    * alice knows @xmath0 but not @xmath1 and bob knows @xmath1 but not @xmath0 ; * one way communication : alice and bob send messages to charlie without feedback ; * no communications between alice and bob ; * parameters @xmath2 and @xmath12 are known to all three parties .    in some sense , this is the `` worst case '' counterpart of the classic `` average case '' slepian - wolf problem .",
    "it is usual for the theory of communication complexity to consider two types of protocols : deterministic communication protocols ( alice s and bob s messages are deterministic functions of @xmath0 and @xmath1 respectively , as well as charlie s decoding function ) and randomized communication protocol ( encoding and decoding procedures are randomized , and for each pair @xmath13 charlie must get the right answer with only a small probability of error @xmath14 ) .",
    "in the next section we give the formal definitions of the deterministic and the randomized versions of the combinatorial slepian  wolf scheme and discuss the known lower and upper bounds for the achievable lengths of messages .",
    "in the usual terms of the theory of communication complexity , we study one - round communication protocols for three parties ; two of them ( alice and bob ) send their messages , and the third one ( charlie ) receives the messages and computes the final result .",
    "thus , a formal definition of the communication protocol involves the coding functions for alice and bob and the decoding function for charlie .",
    "we are interested not only in the total communication complexity ( the sum of the lengths of alice s and bob s messages ) but also in the trade - off between the two sent messages . in what follows",
    "we formally define two version of the slepian  wolf communication scheme   the deterministic and the probabilistic ones .      in the deterministic framework the _ communication protocol _ for the combinatorial slepian ",
    "wolf coding scheme can be defined simply as a pair of uniquely decodable mappings  the coding functions of alice and bob .",
    "[ unique - coding - mappings ] we say that a pair of coding mappings @xmath15 is _ uniquely decodable _ for the combinatorial slepian",
    " wolf coding scheme with parameters @xmath16 , if for each pair of images @xmath17 , @xmath18 there exist at most one pairs of strings @xmath19 such that @xmath20 , and @xmath21 ( this means that the pair @xmath13 can be uniquely reconstructed given the values of @xmath10 and @xmath11 ) .",
    "if such a pair of coding mappings exists , we say that the pair of integers @xmath22 ( the lengths of the codes ) is a pair of _ achievable rates_.    if we are interested in effective constructions of the communication scheme , we can also explicitly introduce the decoding function for charlie @xmath23 and investigate the computational complexities of these three mappings @xmath24 , @xmath25 and @xmath26 .",
    "we say that _ encoding _ in this scheme is _ linear _ ( syndrome - coding ) , if both functions @xmath24 and @xmath25 in definition  [ unique - coding - mappings ] can be understood as linear mappings over the field of @xmath27 elements : @xmath28 further , we say that an encoding is _ semi - linear _ , if at least one of these two coding functions is linear .",
    "we use the following standard[standard - model ] _ communication model with private sources of randomness _ :    * each party ( alice , bob , and charlie ) has her / his own `` random coin ''  a source of random bits ( @xmath29 , @xmath30 , and @xmath31 respectively ) , * the coins are fair , i.e. , produce independent and uniformly distributed random bits , * the sources of randomness are private : each party can access only its own random coin .    in this model the message sent by alice is a function of her input and her private random bits .",
    "similarly , the message sent by bob is a function of his input and his private random bits .",
    "charlie reconstructs @xmath0 and @xmath1 given both these messages and , if needed , his own private random bits .",
    "( in fact , in the protocols we construct in this paper charlie will not use his own private random bits .",
    "the same time , the proven lower bounds remain true for protocols where charlie employs randomness . )",
    "let us give a more formal definition .",
    "a randomized protocol for the combinatorial slepian  wolf scheme with parameters @xmath32 is a triple of mappings @xmath33 and @xmath34 such that for every pair of strings @xmath19 satisfying @xmath20 @xmath35 > 1-\\varepsilon.\\ ] ] here @xmath36 is the length of alice s message and @xmath37 is the length of bob s message .",
    "the second argument of the mappings @xmath24 , @xmath25 , and @xmath26 should be understood as a sequence of random bits ; we assume that each party of the protocol uses at most @xmath38 random bits ( for some integer @xmath38 ) .",
    "condition  ( [ def - prob - protocol ] ) means that for each pair of inputs @xmath39 satisfying @xmath20 , the probability of the error is less than @xmath14 .",
    "when we discuss _ efficient _ communication protocols , we assume that the mappings @xmath24 , @xmath25 , and @xmath26 can be computed in time polynomial in @xmath2 ( in particular , this means that only @xmath40 random bits can be used in the computation ) .    there is a major difference between the classic probabilistic setting of the slepian  wolf coding and the randomized protocols for combinatorial version of this problem . in the probabilistic",
    "setting we minimize the _ average _ communication complexity ( for _ typical _ pairs @xmath13 ) ; and in the combinatorial version of the problem we deal with the _ worst _ case communication complexity ( the protocol must succeed with high probability for _ each _ pair @xmath13 with bounded hamming distance ) .",
    "a simple counting argument gives very natural lower bounds for lengths of messages in the deterministic setting of the problem :    [ trivial - bound ] for all @xmath41 , a pair @xmath42 can be an achievable pair of rates for the deterministic combinatorial slepian ",
    "wolf problem with parameters @xmath16 _ only if _",
    "the following three inequalities are satisfied    * @xmath43 , * @xmath44 , * @xmath45 ,    where @xmath46 denotes shannon s entropy function , @xmath47    _ remark 1 : _ the proof of theorem  [ trivial - bound ] is a straightforward counting argument .",
    "let us observe that the bound @xmath43 ( the lower bound for the total communication complexity ) remains valid also in the model where alice and bob can communicate with each other , and there is a feedback from charlie to alice and bob ( even if we do not count the bits sent between alice and bob and the bits of the feedback from charlie ) .            the asymptotic version of these conditions is shown in fig .  3 : the points in the area below the dashed lines are _ not achievable_. notice that these bounds are similar to the classic slepian  wolf bounds , see fig .  2",
    "the correspondence is quite straightforward : in theorem  [ trivial - bound ] the sum of lengths of two messages is lower - bounded by the `` combinatorial entropy of the pair '' @xmath48 , which is basically the logarithm of the number of possible pairs @xmath13 with the given hamming distance ; in the classic slepian  wolf theorem",
    "the sum of two channel capacities is bounded by the shannon entropy of the pair .",
    "similarly , in theorem  [ trivial - bound ] the lengths of both messages are bounded by @xmath49 , which is the `` combinatorial conditional entropy '' of @xmath0 conditional on @xmath1 or @xmath1 conditional on @xmath0 , i.e. , the logarithm of the maximal number of @xmath0 s compatible with a fixed @xmath1 and vice - versa ; in the standard slepian  wolf theorem the corresponding quantities are bounded by the two conditional shannon entropies .    though the trivial bound from theorem  [ trivial - bound ]",
    "looks very similar to the lower bounds in the classic slepian ",
    "wolf theorem and in muchnik s conditional coding theorem , this parallelism can not be extended further .",
    "in fact , the bound from theorem  [ trivial - bound ] is not optimal ( for the deterministic communication protocols ) .",
    "more specifically , we can not achieve any pairs of code lengths in @xmath50-neighborhoods of the points @xmath51 and @xmath52 ( in the dashed circles around points @xmath53 and @xmath54 in fig .",
    "this negative result was proven assuming that @xmath55 .",
    "though this argument deals with only very special type of schemes where @xmath55 , it also implies some bound for the general slepian ",
    "wolf problem : we can conclude that small neighborhoods around the points @xmath51 and @xmath52 can not be achieved , as it is shown in fig .",
    "4 , see proposition  [ prop - orlitsky ] in appendix . ] in @xcite , see also a discussion in @xcite .",
    "thus , the bound from theorem  [ trivial - bound ] does not provide the exact characterization of the set of achievable pairs . here",
    "we see a sharp contrast with the classic slepian  wolf coding .    in this paper",
    "we prove another negative result for all _ linear _ and even for all _ semi - linear _ encodings :    [ thm - linear - codes - bound ] for each real @xmath56 there exists an @xmath57 such that for all achievable pairs @xmath22 for the semi - linear deterministic combinatorial slepian  wolf scheme with a distance @xmath12 , it holds    * @xmath58 , * @xmath59 , * @xmath60 .",
    "moreover , the value of @xmath61 can be defined explicitly as @xmath62    h0.45     the geometrical meaning of this bound is shown in fig .  5 :",
    "the area of non - achievable pairs of rates for given @xmath12 becomes grater than the trivial counting lower bound : to the trivially forbidden area from theorem  [ trivial - bound ] ( the light red area in the picture ) we add a new stripe of forbidden points ( the dark red area ) .",
    "it is instructive to compare the known necessary and sufficient conditions for the achievable rates .",
    "if we plug some linear codes approaching the gilbert ",
    "varshamov bound in the construction from ( * ? ? ?",
    "* theorem  2 ) , we obtain the following proposition .",
    "[ prop - chumbalov ] for each real @xmath56 there exists a function @xmath63 such that and for all @xmath2 , all pairs of integers @xmath22 satisfying    * @xmath64 , * @xmath65 , * @xmath66    are achievable for the deterministic combinatorial slepian  wolf scheme with parameters @xmath16 .",
    "moreover , these rates can be achieved with some _ linear _ schemes ( where encodings of alice and bob are linear ) .    in fig .",
    "6 we combine together the known upper and lower bounds : the points in the light red area are non - achievable ( for any deterministic scheme ) due to theorem  [ trivial - bound ] ; the points in the dark red area are non - achievable ( for linear and semi - linear deterministic scheme ) by theorem  [ thm - linear - codes - bound ] ; the points in the hatched green area are achievable due to proposition  [ prop - chumbalov ] .",
    "the gap between the known sufficient and necessary conditions remains pretty large .",
    "[ fig - sw - areas ]    our proof of theorem  [ thm - linear - codes - bound ] ( see section  [ lower - bound ] ) is inspired by the classic proof of the elias  bassalygo bound in the coding theory , @xcite .",
    "we do not know whether this bound holds for non - linear encodings .",
    "this seems to be an interesting question in between the coding theory and the communication complexity theory .",
    "thus , we see that the solution of the deterministic version of the combinatorial slepian  wolf problem of is quite different from the standard slepian  wolf theorem .",
    "what about the probabilistic version ? the same conditions as in theorem  [ thm - chumbalov ] hold for the probabilistic protocols :    [ thm - chumbalov ] for all @xmath67 and @xmath41 , a pair @xmath42 can be an achievable pair of rates for the probabilistic combinatorial slepian ",
    "wolf problem with parameters @xmath32 _ only if _",
    "the following three inequalities are satisfied    * @xmath43 , * @xmath44 , * @xmath45 ,    _ remark 2 : _ the bounds from theorem  [ thm - chumbalov ] holds also for the model with public randomness , where all the parties access a common source of random bits .    in the contrast to the deterministic case ,",
    "for the probabilistic setting the sufficient conditions for achievable pairs are very close to the basic lower bound above .",
    "more precisely , for every @xmath68 , all pairs in the hatched ( green ) area in fig .",
    "7 are achievable for the combinatorial slepian ",
    "wolf problem with parameters @xmath32 , see @xcite .",
    "the gap between known necessary and sufficient conditions ( the hatched and non - hatched areas in the figure ) is negligibly small .",
    "thus , for randomized protocols we get a result similar to the classic slepian ",
    "wolf theorem .",
    "so , the case of randomized protocol for the combinatorial slepian ",
    "wolf problem seems closed : the upper and lower bounds known from @xcite ( asymptotically ) match each other .",
    "the only annoying shortcoming of the result in @xcite was computational complexity .",
    "the protocols in @xcite require exponential computations on the senders and the receiver sides . in this paper",
    "we improve computational complexity of this protocol without degrading communication complexity .",
    "we propose a communication protocol with ( i ) optimal trade - off between the lengths of senders messages and ( ii ) polynomial time algorithms for all parties . more precisely , we prove the following theorem and theorem  [ thm - main ] are very similar .",
    "the gap between necessary and sufficient conditions for achievable pairs is only @xmath69 . ] :    [ thm - main ] there exists a real @xmath70 and a function @xmath63 such that for all @xmath41 and all integers @xmath2 , every pair @xmath42 that satisfies three inequalities    * @xmath71 , * @xmath72 , * @xmath73 ,    is achievable for the combinatorial slepian ",
    "wolf coding problem with parameters @xmath74 @xmath75 ( in the communication model with private sources of randomness ) .",
    "moreover , all the computations in the communication protocol can done in polynomial time .",
    "poly - time protocols achieving the marginal pairs @xmath76 and @xmath77 were originally proposed in @xcite and later in @xcite .",
    "we generalize these results : we construct effective protocols for all points in hatched area in fig .  7 .",
    "in fact , our construction uses the techniques proposed in @xcite and @xcite .",
    "the rest of this paper is organized as follows . in section",
    "[ lower - bound ] we discuss a non - trivial lower bound for communication complexity of the deterministic version of the combinatorial slepian  wolf coding scheme ( a proof of theorem  [ thm - linear - codes - bound ] ) .",
    "the argument employs binary johnson s bound , similarly to the proof of the well known elias  bassalygo bound in the coding theory .    in section",
    "[ section - randomized ] we provide an effective protocol for the randomized version of the combinatorial slepian",
    " wolf coding scheme ( a proof of theorem  [ thm - main ] ) .",
    "our argument combines several technical tools : reduction of one global coding problem with strings of length @xmath2 to many local problems with strings of length @xmath78 ( similar to the classic technique of concatenated codes ) ; reed  solomon checksums ; pseudo - random permutations ; universal hashing .    in conclusion",
    "we discuss how to make the protocol from theorem  [ thm - main ] more practical  how to simplify the algorithms involved in the protocol .",
    "the price for this simplification is a weaker bound for the probability of error .",
    "through this paper , we use the following notation :    * we denote @xmath79 and use the standard asymptotic bound for the binomial coefficients : @xmath80 * we denote by @xmath81 the _ weight _ ( number of @xmath82 s ) in a binary string @xmath83 , * for a pair of binary strings @xmath84 of the same length we denote by @xmath85 their bitwise sum modulo @xmath27 , * we denote by @xmath86 the hamming distance between bit strings @xmath87 and @xmath88 ( which coincides with @xmath89 ) , * for an @xmath2-bits string @xmath90 and a tuple of indices @xmath91 we denote @xmath92",
    "in this section we prove theorem  [ thm - linear - codes - bound ] .",
    "we precede the proof of this theorem by several lemmas .",
    "first of all , we define the notion of _ list decoding _ for the slepian  wolf scheme ( similar to the standard notion of list decoding from the coding theory ) .",
    "we say that a pair of coding mappings @xmath93 is _",
    "@xmath94-list decodable _ for the combinatorial slepian  wolf coding scheme with parameters",
    "@xmath16 , if for each pair of images @xmath17 , @xmath18 there exist at most @xmath94 pairs of strings @xmath19 such that @xmath20 , and @xmath95    the lengths of codewords of @xmath40-decodable mappings must obey effectively the same asymptotical bounds as the codewords of uniquely decodable mappings .",
    "let us formulate this statement more precisely .",
    "[ lemma - list - decoding - lower - bound ] if @xmath22 is an achievable pair of integers for the combinatorial slepian ",
    "wolf scheme with parameters @xmath16 with list decoding ( with the list size @xmath96 ) , then    * @xmath97 , * @xmath98 , * @xmath99 .",
    "the lemma follow from a standard counting argument .",
    "the lower bounds in this lemma are asymptotically the same as the bounds for the schemes with unique decoding in theorem  [ thm - chumbalov ] .",
    "the difference between the right - hand side of the inequalities in this lemma and in theorem  [ thm - chumbalov ] is only @xmath100 , which is negligible ( an @xmath69-term ) as @xmath96 .",
    "we will use the following well known bound from the coding theory .",
    "[ lemma - johnson ] let @xmath12 and @xmath61 be positive reals satisfying ( [ eq - johnson ] ) .",
    "then for every list of n - bits strings @xmath101 , @xmath102 with hamming weights at most @xmath103 ( i.e. , all @xmath101 belong to the ball of radius @xmath104 around @xmath105 in hamming s metrics ) , there exists a pair of strings @xmath106 , @xmath107 ( @xmath108 ) such that @xmath109    _ proof:_see @xcite .",
    "now we are ready to prove the main technical lemma : every pair of mappings that is _ uniquely _ decodable for the slepian ",
    "wolf scheme with parameters @xmath16 must be also @xmath40-decodable with parameters @xmath110 with some @xmath111 .",
    "[ lemma - elias - bassalygo ] let @xmath12 and @xmath61 be positive reals as in ( [ eq - johnson ] ) .",
    "if a pair of integers @xmath22 is achievable for the combinatorial semi - linear slepian  wolf scheme with parameters @xmath16 ( with unique decoding ) , then the same pair is achievable s for the combinatorial slepian ",
    "wolf scheme for the greater distance @xmath61 with @xmath112-list decoding .",
    "the value of @xmath61 can be explicitly defined from ( [ eq - johnson ] ) .",
    "_ proof:_let as fix some pair of encodings @xmath113 that is _",
    "uniquely decodable _ for pairs @xmath19 with the hamming distance @xmath3 .",
    "we assume that at least one of these mappings ( say , @xmath24 ) is linear . to prove the lemma",
    "we show that the same pair of encodings is _ list _",
    "@xmath40-_list decodable _ for the pairs of strings with a greater hamming distance @xmath103 .",
    "let us fix some @xmath114 and @xmath115 , and take the list of all @xmath24- and @xmath25-preimages of these points :    * let @xmath116 be all strings such that @xmath117 , and * let @xmath118 be all strings such that @xmath119 .",
    "our aim is to prove that the number of pairs @xmath120 such that @xmath121 is not greater than @xmath122 .",
    "suppose for the sake of contradiction that the number of such pairs is at least @xmath123 .    for each pair @xmath120 that satisfy @xmath121 we take their bitwise sum , @xmath124 . since the hamming distance between @xmath125 and @xmath126 is not greater than @xmath103 , the weight of @xmath87 is not greater than @xmath103 .",
    "thus , we get at least @xmath123 different strings @xmath127 with hamming weights not greater than @xmath103 . from lemma  [ lemma - johnson ]",
    "it follows that there exist a pair of strings @xmath128 , @xmath129 ( say , @xmath130 and @xmath131 ) such that @xmath132 .",
    "hence , there exists a string @xmath88 that is @xmath133-close to both @xmath128 and @xmath129 , i.e. , @xmath134 we use this @xmath88 as a translation vector and define @xmath135 for the chosen @xmath88 we have @xmath136 and @xmath137 further , since @xmath138 and the mapping @xmath24 is linear , we get @xmath139 . hence , @xmath140 thus , we obtain two different pairs of strings @xmath141 and @xmath142 with the hamming distances bounded by @xmath3 , such that @xmath143 this contradicts the assumption that the codes @xmath24 and @xmath25 are uniquely decodable for pairs at the distance @xmath3 . the lemma is proven .",
    "now we can prove theorem  [ thm - linear - codes - bound ] .",
    "assume that a pair of integers @xmath22 is achievable for the combinatorial slepian ",
    "wolf coding scheme with unique decoding for a distance @xmath3 . from lemma  [ lemma - elias - bassalygo ]",
    "it follows that the same pair is achievable for the combinatorial slepian ",
    "wolf coding scheme with @xmath112-list decoding with a greater distance @xmath103 .",
    "then , we apply lemma  [ lemma - list - decoding - lower - bound ] and get the required bounds for @xmath36 and @xmath37 .",
    "in this section we summarize the technical tools that we use to construct an effective randomized protocol .",
    "a distribution on the set @xmath144 of permutations of @xmath145 is called _",
    "almost @xmath146-wise independent _",
    "if for every tuple of indices @xmath147 , the distribution of @xmath148 for @xmath149 chosen according to this distribution has distance at most @xmath150 from the uniform distribution on @xmath146-tuples of @xmath146 distinct elements from @xmath145 .    [ proposition - knr ] for all @xmath151 , there exists an integer @xmath152 and an explicit map @xmath153 computable in time @xmath40 , such that the distribution @xmath154 for random @xmath155 is almost @xmath146-wise independent .",
    "[ proposition - rs ] assume @xmath156 .",
    "then we can assign to every sequence of @xmath157 strings @xmath158 ( where @xmath159 for each @xmath160 ) a string of _ checksums _ @xmath161 of length @xmath162 , @xmath163 with the following property .",
    "if at most @xmath164 strings @xmath165 are corrupted , the initial tuple @xmath0 can be uniquely reconstructed given the value of @xmath166 .",
    "moreover , encoding ( computation @xmath167 ) end decoding ( reconstruction of the initial values of @xmath0 ) can done in time @xmath168 .    _",
    "proof : _ the required construction can be obtained from a systematic reed ",
    "solomon code with suitable parameters ( see , e.g. , @xcite ) .",
    "indeed , we can think of @xmath169 as of a sequence of elements in a finite field @xmath170 .",
    "then , we interpolate a polynomial @xmath171 of degree at most @xmath172 such that @xmath173 for @xmath174 and take the values of @xmath171 at some other points of the field as checksums : @xmath175 the tuple @xmath176 is a codeword of the reed ",
    "solomon code , and we can recover it if at most @xmath164 items of the tuple are corrupted . it is well known that the error - correction procedure for reed ",
    "solomon codes can be implemented in polynomial time .",
    "[ proposition - hash ] there exists a family of poly - time computable functions @xmath177 such that @xmath178 , @xmath179 it holds @xmath180 = 1/2^k,\\ ] ] where index @xmath181 ranges over @xmath182 ( i.e. , each hash function from the family can be specified by a string of length @xmath183 bits ) .",
    "such a family of hash unctions can be constructed explicitly : the value of @xmath184 can be computed in polynomial time from @xmath83 and @xmath181 .",
    "parameter @xmath185 in proposition  [ proposition - hash ] is called _ the length of the hash_.    the following claim is an ( obvious ) corollary of the definition of a universal hashing family .",
    "let @xmath184 be a family of functions satisfying proposition  [ proposition - hash ] .",
    "then for every @xmath186 , for each @xmath187 ,",
    "@xmath188 < \\frac{|s|}{2^k}.\\ ] ] this property allows to identify an element in @xmath189 by its hash value .",
    "the following version of the law of large numbers is suitable for our argument :    [ proposition - lln ] assume @xmath190 are random variables ranging over @xmath191 , each with expectation at most @xmath192 , and for some @xmath193 , for every set of @xmath194 indices @xmath195 we have @xmath196 \\le \\mu^t.\\ ] ] if @xmath197 , then @xmath198   =   2^{-\\theta(m^{c } ) } .\\ ] ]    more technically , we will use the following lemma :    [ lemma1 ] ( a ) let @xmath199 be a positive constant , @xmath200 , and @xmath201 some function of @xmath2 .",
    "then for each pair of subsets @xmath202 such that @xmath203 and @xmath204 , for a @xmath185-wise almost independent permutation @xmath205 , @xmath206   = o\\left(\\frac1{\\delta^2 k}\\right).\\ ] ] ( b ) let @xmath207 , where @xmath208 are disjoint sets of cardinality @xmath185 ( so @xmath209 ) . also we let @xmath210 ( for some @xmath193 ) and assume @xmath211 .",
    "then , for a @xmath212-wise almost independent permutation @xmath149 , @xmath213    =   2^{-\\theta(m^{c } ) } ,   \\\\   { \\mathrm{prob}}_{\\pi}\\big[\\   \\big| \\pi ( i ) \\cap \\delta_j \\big| < ( \\rho-\\delta ) k",
    "\\   \\mbox { for at least   } 3\\mu m \\mbox { different } j     \\big ]    =   2^{-\\theta(m^{c})}.   \\end{array}\\ ] ]    ( the proof is deferred to section  [ appendix ] . )    notice that a uniform distribution on the set of all permutation is a special case of a @xmath185-wise almost independent permutation .",
    "so the claims of lemma  [ lemma1 ] can be applied to a uniformly chosen random permutation .",
    "the complete proof of theorem  [ thm - main ] involves a few different technical tricks . to make the construction more modular and intuitive , we split it in several possibly independent parts . to this end",
    ", we introduce several auxiliary communication models .",
    "the first two models are somewhat artificial ; they are of no independent interest , and make sense only as intermediate steps of the proof of the main theorem . here is the list of our communication model :    * model 1 . * * the model with partially shared sources of perfect randomness : * alice and bob have their own sources of independent uniformly distributed random bits .",
    "charlie has a free access to alice s and bob s sources of randomness ( these random bits are not included in the communication complexity ) ; but alice and bob can not access the random bits of each other .    *",
    "model 2 . * * the model with partially shared sources of @xmath214-non - perfect randomness : * alice and bob have their own ( independent of each other ) sources of randomness . however these sources are not perfect : they can produce @xmath214-independent sequences of bits and @xmath214-_wise almost independent _ permutations on @xmath145 .",
    "charlie has a free access to alice s and bob s sources of randomness , whereas alice and bob can not access the random bits of each other .",
    "* model 3 . * * the standard model with private sources of perfect randomness ( our principal model ) . * in this model alice and bob have their own sources of independent uniformly distributed random bits .",
    "charlie can not access random bits of alice and bob unless they include these bits in their messages .",
    "we show that in all these models the profile of achievable pairs of rates is the same as in theorem  [ thm - chumbalov ] ( the hatched area in fig .",
    "we start with an effective protocol for model  1 , and then extend it to model  2 , and at last to model  3 .",
    "[ section - protocol - model-1 ] in this section we show that all pairs of rates from the hatched area in  4 are achievable for model  1 . technically , we prove the following statement .",
    "[ prop - model-2 ] the version of theorem  [ thm - main ] holds for the communication model  1 .",
    "_ remark 1 .",
    "_ _ remark 1 . _ our protocol involves random objects of different kinds : randomly chosen permutations and random hash functions from a universal family . in this section",
    "we assume that the used randomness is perfect .",
    "this means that all permutations are chosen with the uniform distribution , and all hash functions are chosen independently .",
    "our construction has some `` degrees of freedom '' ; it involves several parameters , and values of these parameters can be chosen in rather broad intervals . in what follows we list these parameters , with short comments .",
    "* @xmath215 is any fixed number between @xmath105 and @xmath82 ( this parameter controls the ratio between the lengths of messages sent by alice and bob ) ; * @xmath216 ( some absolute constants that control the asymptotic of communication complexity hidden in the @xmath217-terms in the statements of theorem  [ thm - main ] and proposition  [ prop - model-3 ] ) ; * @xmath200 ( we will cut strings of alice and bob in `` blocks '' of length @xmath185 ; we can afford the brute force search over all binary strings of length @xmath185 , since @xmath218 is polynomial in @xmath2 ) ; * @xmath219 ( when we split @xmath2-bits strings into blocks of length @xmath185 , we get @xmath157 blocks ) ; * @xmath220 ( this parameter controls the chances to get a collision in hashing ; we choose @xmath221 so that @xmath222 ) ; * @xmath223 ( the threshold for deviation of the relative frequency from the probability involved in the law of large numbers ; notice that we choose @xmath224 such that @xmath225 ) ; * @xmath226 for some constant @xmath227 ( in our construction @xmath228 is the length of the reed - solomon checksum ; we chose @xmath229 such that @xmath230 ) ; * @xmath146 ( this parameter characterize the quality of the random bits used by alice and bob ; accordingly , this parameter is involved in the law(s ) of large numbers used to bound the probability of the error ; we let @xmath231 for some @xmath232 ) .",
    "* alice s part of the protocol : *    * select at random a tuple of @xmath233 indices @xmath234 .",
    "technically , we may assume that alice chooses at random a permutation @xmath235 on the set @xmath236 and lets @xmath237 .",
    "* send to the receiver the bits @xmath238 , see fig .",
    "+ ( dummy ) @xmath239 ; ( 1 ) [ right = 0.3 cm of dummy]@xmath240 ; ( 2 ) [ right = 0.1 cm of 1 ] @xmath241 ; ( 3 ) [ right = 0.1 cm of 2 ] @xmath242 ; ( 4 ) [ right = 0.1 cm of 3 ] @xmath243 ; ( 5 ) [ right = 0.1 cm of 4 ] @xmath244 ; + \\(6 ) [ right = 0.1 cm of 5 ] @xmath245 ; + \\(7 ) [ right = 0.1 cm of 6 ] @xmath246 ; ( 8) [ right = 0.1 cm of 7 ] @xmath247 ; + \\(9 ) [ below = 2 cm of 4 ] @xmath233 randomly chosen bits ; + ( 9)(2 ) ; ( 9)(4 ) ; ( 9)(5 ) ; ( 9)(8 ) ; +    ' '' '' + \\(a ) alice ; ( c ) charlie ; ( a.-5 )  node[thin , above = 0.1 , circle , fill = red!20,draw , minimum size=0.7cm , inner sep=0pt ] ( 1 ) @xmath244 ( c.-175 ) ; ( 2 ) [ right = 0.1 cm of 1 ] @xmath245 ; ( 3 ) [ right = 0.1 cm of 2 ] @xmath247 ; ( 4 )",
    "[ left = 0.1 cm of 1 ] @xmath243 ; ( 5 ) [ left = 0.1 cm of 4 ] @xmath241 ; + \\(6 ) [ above = 0.01 cm of 5 ] ; ( 7 ) [ above = 0.01 cm of 3 ] ; + \\(70 ) [ below = 0.4 cm of a ] ; ( 8) [ left = 0 of 70 ] @xmath241 ; ( 9 ) [ left = 0.1 of 8 ] @xmath240 ; ( 10 ) [ right = 0 of 70 ] @xmath245 ; ( 11 ) [ right = 0.1 of 10 ] @xmath247 ; + \\(6 )  ( 7 ) node [ above=0.2cm , midway ] @xmath233 ; * choose another random permutation @xmath248 and permute the bits of @xmath0 , i.e. , let - permutation of bits in @xmath1 and denote it @xmath249 thus , the prime in the notation ( e.g. , @xmath250 and @xmath251 ) implies that we permuted the bits of the original strings by @xmath252 . ]",
    "@xmath253 ( see fig .",
    "+ ( dummy ) @xmath239 ; ( 1 ) [ right = 0.3 cm of dummy]@xmath240 ; ( 2 ) [ right = 0.2 cm of 1 ] @xmath241 ; ( 3 ) [ right = 0.2 cm of 2 ] @xmath242 ; + \\(4 ) [ right = 0.3 cm of 3 ] @xmath245 ; + \\(5 ) [ right = 0.2 cm of 4 ] @xmath247 ; + ( dummy2 ) @xmath254 ; ( 12 ) [ right = 0.3 cm of dummy2]@xmath255 ; ( 22 ) [ right = 0.2 cm of 12 ] @xmath247 ; ( 32 ) [ right = 0.2 cm of 22 ] @xmath240 ; + \\(42 ) [ right = 0.3 cm of 32 ] @xmath245 ; + \\(52 ) [ right = 0.2 cm of 42 ] @xmath242 ; + ( 1.-90 ) edge[out=270,in=90,- > ] ( 32.90 ) ; ( 2.-90 ) edge[out=270,in=90,- > ] ( 42.90 ) ; ( 3.-90 ) edge[out=270,in=90,- > ] ( 52.90 ) ; ( 4.-90 ) edge[out=270,in=90,- > ] ( 12.90 ) ; ( 5.-90 ) edge[out=270,in=90,- > ] ( 22.90 ) ; + ( bt ) [ below=0.9 of dummy ] ; ( p ) [ right=0.2 of bt ] @xmath256 ; + further , divide @xmath250 into blocks of length @xmath257 , i.e. , represent @xmath250 as a concatenation @xmath258 where @xmath259 for each @xmath160 ( see fig .",
    "* then alice computes hash values of these blocks .",
    "more technically , we consider a universal family of hash functions @xmath260 with some standard universal hash family , we may assume that these hash functions are indexed by bit strings @xmath261 of length @xmath262 , see proposition  [ proposition - hash ] .",
    "alice choses at random @xmath157 indices @xmath263 of hash functions .",
    "then alice applies each @xmath264 to the corresponding block @xmath265 and sends to charlie the resulting hash values @xmath266 see fig .",
    "+ \\(1 ) @xmath267 ; ( 20 ) [ right = 0 cm of 1 ] @xmath245 ; ( 3 ) [ right = 0 cm of 20 ] @xmath268 ; + \\(4 ) [ right = 0.6 cm of 3 ] @xmath269 ; ( 50 ) [ right = 0 cm of 4 ] @xmath245 ; ( 6 ) [ right = 0 cm of 50 ] @xmath270 ; + \\(7 ) [ right = 0.3 cm of 6 ] @xmath245 ; + \\(8 ) [ right = 0.3 cm of 7 ] @xmath271 ; ( 90 ) [ right = 0 cm of 8 ] @xmath245 ; ( 10 ) [ right = 0 cm of 90 ] @xmath272 ; + ( @xmath273 ) rectangle ( @xmath274 ) ; ( @xmath275 ) rectangle ( @xmath276 ) ; ( @xmath277 ) rectangle ( @xmath278 ) ; + ; ; ; + \\(200 ) @xmath279 bits hash ; ( 20)(200 ) ; ( 500 ) @xmath279 bits hash ; ( 50)(500 ) ; ; ( 900 ) @xmath279 bits hash ; ( 90)(900 ) ; + ; ; ; * compute the reed - solomon checksums of the sequence @xmath280 that are enough to reconstruct all blocks @xmath281 if most @xmath282 of them are corrupted , and send them to charlie .",
    "these checksums make a string of @xmath283 bits , see proposition  [ proposition - rs ] .",
    "* choose at random a permutation @xmath284 and use it to permute the bits of @xmath1 , i.e. ,    * summary : * alice sends to charlie three tranches of information ,    * @xmath233 bits of @xmath0 selected at random , * hashes for each of @xmath285 blocks in the permuted string @xmath250 , * the reed ",
    "solomon checksums for the blocks of @xmath250 .",
    "* bob s part of the protocol : *    * choose at random permutation @xmath284 and use it to permute the bits of @xmath1 , i.e. , let and denote @xmath286 thus , the double prime in the notation ( e.g. , @xmath287 and @xmath288 ) implies that we permuted the bits of the original strings by @xmath289 . ]",
    "@xmath290 see fig .  11 .",
    "+ ( dummy ) @xmath291 ; ( 1 ) [ right = 0.3 cm of dummy]@xmath292 ; ( 2 ) [ right = 0.2 cm of 1 ] @xmath293 ; ( 3 ) [ right = 0.2 cm of 2 ] @xmath294 ; + \\(4 ) [ right = 0.3 cm of 3 ] @xmath245 ; + \\(5 ) [ right = 0.2 cm of 4 ] @xmath295 ; + ( dummy2 ) @xmath296 ; ( 12 ) [ right = 0.3 cm of dummy2]@xmath297 ; ( 22 ) [ right = 0.2 cm of 12 ] @xmath298 ; ( 32 ) [ right = 0.2 cm of 22 ] @xmath292 ; + \\(42 ) [ right = 0.3 cm of 32 ] @xmath245 ; + \\(52 ) [ right = 0.2 cm of 42 ] @xmath293 ; + ( 1.-90 ) edge[out=270,in=90,- > ] ( 32.90 ) ; ( 2.-90 ) edge[out=270,in=90,- > ] ( 42.90 ) ; ( 3.-90 ) edge[out=270,in=90,- > ] ( 52.90 ) ; ( 4.-90 ) edge[out=270,in=90,- > ] ( 12.90 ) ; ( 5.-90 ) edge[out=270,in=90,- > ] ( 22.90 ) ; + ( bt ) [ below=0.9 of dummy ] ; ( p ) [ right=0.2 of bt ] @xmath299 ; + further , divide @xmath288 into blocks of length @xmath185 , and represent @xmath288 as a concatenation @xmath300 where @xmath301 for each @xmath160 , see fig .  12 .",
    "* then choose at random @xmath157 hash functions @xmath302 from a universal family of hash functions @xmath303 ( we assume that @xmath304 are @xmath305-independent ) and send to charlie random hash values @xmath306 see fig .",
    "+ \\(1 ) @xmath307 ; ( 20 ) [ right = 0 cm of 1 ] @xmath245 ; ( 3 ) [ right = 0 cm of 20 ] @xmath308 ; + \\(4 ) [ right = 0.6 cm of 3 ] @xmath309 ; ( 50 ) [ right = 0 cm of 4 ] @xmath245 ; ( 6 ) [ right = 0 cm of 50 ] @xmath310 ; + \\(7 ) [ right = 0.3 cm of 6 ] @xmath245 ; + \\(8 ) [ right = 0.3 cm of 7 ] @xmath311 ; ( 90 ) [ right = 0 cm of 8 ] @xmath245 ; ( 10 ) [ right = 0 cm of 90 ] @xmath312 ; + ( @xmath273 ) rectangle ( @xmath274 ) ; ( @xmath275 ) rectangle ( @xmath276 ) ; ( @xmath277 ) rectangle ( @xmath278 ) ; + ; ; ; + \\(200 ) @xmath313 bits hash ; ( 20)(200 ) ; ( 500 ) @xmath313 bits hash ; ( 50)(500 ) ; ; ( 900 ) @xmath313 bits hash ; ( 90)(900 ) ; + ; ; ; + similarly to ( @xmath314 ) , we may assume that these hash functions are indexed by bit strings @xmath261 of length @xmath262 , see proposition  [ proposition - hash ] .",
    "* compute the reed - solomon checksums of the sequence @xmath315 , that are enough to reconstruct all blocks @xmath316 , if at most @xmath282 of them are corrupted , and send them to charlie .",
    "these checksums should be a string of length @xmath317 bits , see proposition  [ proposition - rs ] .",
    "* summary : * bobs sends to charlie two tranches of information ,    * hashes for each of @xmath285 blocks in the permuted string @xmath288 , * the reed ",
    "solomon checksums for the blocks of @xmath288 .",
    "* charlie s part of the protocol : *    * apply bob s permutation @xmath289 to the positions of bits selected by alice , and denote the result by @xmath318 , i.e. , @xmath319 then split indices of @xmath318 into @xmath157 disjoint parts corresponding to the different intervals @xmath320 , and @xmath321 ( the red nodes in fig .",
    "further , for each @xmath322 denote by @xmath323 the bits sent by alice , that appear in the interval @xmath324 after permutation @xmath289 .",
    "( we will show later that the typical size of @xmath323 is close to @xmath325 . )",
    "+ \\(x ) @xmath326 ; ( y ) [ below = 2 cm of x ] @xmath327 ; + \\(1 ) [ right = 0.5 cm of x ] @xmath245 ; + \\(4 ) [ right = 0.6 cm of 1 ] @xmath328 ; ( 5 ) [ right = 0.1 cm of 4 ] @xmath329 ; ( 51 ) [ right = 0.1 cm of 5 ] @xmath329 ; ( 52 ) [ right = 0.1 cm of 51 ] @xmath330 ; ( 53 ) [ right = 0.1 cm of 52 ] @xmath329 ; + \\(50 ) [ right = 0 cm of 53 ] @xmath245 ; ( 6 ) [ right = 0 cm of 50 ] @xmath331 ; + \\(7 ) [ right = 0.6 cm of 6 ] @xmath245 ; + ( @xmath275 ) rectangle ( @xmath276 ) ; + \\(666 ) [ above = 1.2 cm of 52 ] @xmath332 bits are received from alice ; + ( 666)(4 ) ; ( 666)(52 ) ; ( 666)(6 ) ; + ( 1y ) [ right = 0.5 cm of y ] @xmath245 ; + ( 4y ) [ right = 0.6 cm of 1y ] @xmath329 ; ( 5y ) [ right = 0.1 cm of 4y ] @xmath329 ; ( 51y ) [ right = 0.1 cm of 5y ] @xmath329 ; ( 52y ) [ right = 0.1 cm of 51y ] @xmath329 ; ( 53y ) [ right = 0.1 cm of 52y ] @xmath329 ; + ( 50y ) [ right = 0 cm of 53y ] @xmath245 ; ( 6y ) [ right = 0 cm of 50y ] @xmath329 ; + ( 7y ) [ right = 0.6 cm of 6y ] @xmath245 ; + ( @xmath333 ) rectangle ( @xmath334 ) ; * for each @xmath335 try to reconstruct @xmath336 .",
    "to this end , find all bit strings @xmath337 that satisfy a pair of conditions ( @xmath338 ) and ( @xmath339 ) that we formulate below .",
    "+ we abuse notation and denote by @xmath340 the subsequence of bits from @xmath341 that appear at the positions determined by @xmath342 .",
    "that is , if @xmath343 where @xmath344 then @xmath345 . with this notation",
    "we can specify the required property of @xmath341 : * * @xmath346 , see fig .",
    "14 , * * @xmath347 must coincide with the hash value @xmath348 received from bob .",
    "+ \\(x ) @xmath349 ; ( y ) [ below = 2 cm of x ] @xmath350  ; + \\(4 ) [ right = 0.5 cm of x ] @xmath328 ; ( 5 ) [ right = 0.1 cm of 4 ] @xmath329 ; ( 51 ) [ right = 0.1 cm of 5 ] @xmath329 ; ( 52 ) [ right = 0.1 cm of 51 ] @xmath330 ; ( 53 ) [ right = 0.1 cm of 52 ] @xmath329 ; + \\(50 ) [ right = 0 cm of 53 ] @xmath245 ; ( 6 ) [ right = 0 cm of 50 ] @xmath331 ; + ( @xmath275 ) rectangle ( @xmath276 ) ; + ( 4y ) [ right = 0.5 cm of y ] @xmath351 ; ( 5y ) [ right = 0.15 cm of 4y ] @xmath329 ; ( 51y ) [ right = 0.1 cm of 5y ] @xmath329 ; ( 52y ) [ right = 0.15 cm of 51y ] @xmath330 ; ( 53y ) [ right = 0.1 cm of 52y ] @xmath329 ; + ( 50y ) [ right = 0.03 cm of 53y ] @xmath245 ; + ( 6y ) [ right = 0 cm of 50y ] @xmath352 ; + ( @xmath333 ) rectangle ( @xmath334 ) ; + ( 4)(4y ) ; ( 52)(52y ) ; ( 6)(6y ) ; + if there is a unique @xmath341 that satisfies these two conditions , then take it as a candidate for @xmath336 ; otherwise ( if there is no such @xmath341 or if there exist more than one @xmath341 that satisfy these conditions ) we say that the procedure of reconstruction of @xmath336 fails .",
    "+ _ remark 1 : _ the requirement from  ( @xmath338 ) makes sense since in a typical case the indices from @xmath318 are somehow uniformly distributed .",
    "+ _ remark 2 : _ there can be two kinds of troubles at this stage .",
    "first , for some blocks @xmath336 reconstruction fails ( this happens when charlie gets no or more than one @xmath341 that satisfy  ( @xmath338 ) and  ( @xmath339 ) ) .",
    "second , for some blocks @xmath336 the reconstruction procedure seemingly completes , but the obtained result is incorrect ( charlie gets a @xmath341 which is not the real value of @xmath336 ) . in what follows",
    "we prove that both events are rear . in a typical case , at this stage most ( but not all ! ) blocks @xmath336 are correctly reconstructed . * use reed - solomon checksums received from bob to correct the blocks @xmath336 that we failed to reconstruct or reconstructed incorrectly at step  ( @xmath353 ) .",
    "+ _ remark 3 : _ below we prove that in a typical case , after this procedure we get correct values of all blocks @xmath336 , so concatenation of these blocks gives @xmath288 .",
    "* apply permutation @xmath354 to the bits of @xmath288 and obtain @xmath1 . *",
    "permute bits of @xmath1 and @xmath355 using permutation @xmath252 .",
    "* for each @xmath335 try to reconstruct @xmath265 . to this end , find all bit strings @xmath356 such that * * at each position from @xmath357 the bit from @xmath250 ( in the @xmath160-th block ) sent by alice coincides with the corresponding bit in @xmath358 , * * @xmath359 * * @xmath360 coincides with the hash value @xmath361 received from alice .",
    "+ if there is a unique @xmath358 that satisfies these conditions , then take this string as a candidate for @xmath265 ; otherwise ( if there is no such @xmath358 or if there exist more than one @xmath358 satisfying these conditions ) we say that reconstruction of @xmath265 fails .",
    "+ _ remark : _ we will show that in a typical case , most ( but not all ) blocks @xmath265 will be correctly reconstructed . *",
    "use reed - solomon checksums received from alice to correct the blocks @xmath265 that were incorrectly decoded at step  ( @xmath362 ) .",
    "+ _ remark : _ we will show in a typical case , after this procedure we get correct values of all blocks @xmath265 , so concatenation of these blocks gives @xmath250 .",
    "* apply permutation @xmath363 to the positions of bits of @xmath250 and obtain @xmath0 .",
    "the main technical result of this section ( correctness of the protocol ) follows from the next lemma .",
    "[ lemma - error - model-2 ] in communication model  1 , the protocol described above fails with probability at most @xmath364 for some @xmath70 .",
    "( the proof is deferred to section  [ appendix ] . )      alice sends @xmath233 bits at step  ( @xmath365 ) , @xmath366 for each block @xmath335 at step  ( @xmath367 ) , and @xmath368 bits of the reed - solomon checksums at step  ( @xmath314 ) .",
    "so the total length of alice s message is @xmath369 for the values of parameters that we have chosen above ( see section  [ section - parameters ] ) , this sum can be estimated as @xmath370 bob sends @xmath371 bits for each block @xmath335 at step  ( @xmath372 ) and @xmath368 bits of the reed - solomon checksums at step  ( @xmath373 ) .",
    "this sums up to @xmath374 bits . for the chosen values of parameters",
    "this sum is equal to @xmath375 when we vary parameter @xmath215 between @xmath105 and @xmath82 , we variate accordingly the lengths of both messages from @xmath376 to @xmath377 , whereas the sum of alice s and bob s messages always remains equal to @xmath378 thus , varying @xmath215 from @xmath105 to @xmath82 , we move in the graph in fig .  7 from @xmath54 to @xmath53 .",
    "it remains to notice that algorithms of all participants require only @xmath40-time computations .",
    "indeed , all manipulations with reed - solomon checksums ( encoding and error - correction ) can be done in time @xmath40 , with standard encoding and decoding algorithms .",
    "the brute force search used in the decoding procedure requires only the search over sets of size @xmath379 ) .",
    "thus , proposition  [ prop - model-2 ] is proven .",
    "in this section we prove that the pairs of rates from fig .",
    "7 are achievable for communication model  2 .",
    "now the random sources of alice and bob are not perfect : the random permutations are only @xmath146-wise almost independent and the chosen hash functions are @xmath146-independent ( for a suitable @xmath146 ) .    [ prop - model-3 ] the version of theorem  [ thm - main ] holds for communication model  2 ( with parameter @xmath380 ) .",
    "to prove proposition  [ prop - model-3 ] we do not need a new communication protocol  in fact , the protocol that we constructed for model  1 in the previous section works for model  2 as well .",
    "the only difference between proposition  [ prop - model-2 ] and proposition  [ prop - model-3 ] is a more general statement about the estimation of the error probability :    [ lemma - error - model-3 ] for communication model  2 with parameter @xmath380 the communication protocol described in section  [ section - model-2 ] fails with probability at most @xmath364 for some @xmath70 .",
    "( the proof is deferred to section  [ appendix ] . )    since the protocol remains the same , the bounds for the communication and computational complexity , proven in proposition  [ prop - model-2 ] , remain valid in the new setting . with lemma  [ lemma - error - model-3 ]",
    "we get the proof of proposition  [ prop - model-3 ] .",
    "proposition  [ prop - model-3 ] claims that the protocol from section  [ section - model-2 ] works well for the artificial communication model  2 ( with non - perfect and partially private randomness ) .",
    "now we want to modify this protocol and adapt it to communication model  3 .",
    "technically , we have to get rid of ( partially ) shared randomness .",
    "that is , in model  3 we can not assume that charlie access alice s and bob s random bits for free .",
    "moreover , alice and bob can not just send their random bits to charlie ( this would dramatically increase the communication complexity ) .",
    "however , we can use the following well - known trick : we require now that alice and bob use pseudo - random bits instead of truly uniformly random bits .",
    "alice and bob take short seeds for pseudo - random generators at random ( with the truly uniform distribution ) expand them to longer sequences of pseudo - random bits , and feed these _ pseudo - random _ bits in the protocol described in the previous sections .",
    "alice and bob transmit the random seeds of their generators to charlie ( the seeds are rather short , so they do not increase communication complexity substantially ) ; so charlie ( using the same pseudo - random generators ) expands the seeds to the same long pseudo - random sequences and plug them in into his side of the protocol .",
    "more formally , we modify the communication protocol described in section  [ section - protocol - model-1 ] .",
    "now alice and bob begin the protocol with the following steps :    * alice choses at random the seeds for pseudo - random generators and send them to charlie .",
    "* bob choses at random the seeds for pseudo - random generators and also send them to charlie .",
    "when these preparations are done , the protocol proceeds exactly as in section  [ section - protocol - model-1 ] ( steps ( @xmath381)(@xmath382 ) for alice , ( @xmath372)(@xmath383 ) for bob , and ( @xmath384)(@xmath385 ) for charlie ) .",
    "the only difference that all _ random _ objects ( random hash functions and random permutations ) are now _ pseudo - random _ , produces by pseudo - random generators from the chosen random seeds .    it remains to choose some specific pseudo - random generators that suits our plan .",
    "we need two different pseudo - random generators  one to generate indices of hash functions and another to generate permutations . constructing a suitable sequence of pseudo - random hash - functions",
    "is simple .",
    "both alice and bob needs @xmath157 random indices @xmath386 of hash functions , and the size of each family of hash functions is @xmath387 .",
    "we need the property of @xmath146-independency of @xmath386 for @xmath210 ( for a small enough @xmath388 ) . to generate these bits",
    "we can take a random polynomial of degree at most @xmath389 over @xmath390 .",
    "the seed of this `` generator '' is just the tuple of all coefficients of the chosen polynomial , which requires @xmath391 bits .",
    "the outcome of the generator ( the resulting sequence of pseudo - random bits ) is the sequence of values of the chosen polynomial at ( some fixed in advance ) @xmath157 different points of the field .",
    "the property of @xmath146-independence follows immediately from the construction : for a randomly chosen polynomial of degree at most @xmath389 the values at any @xmath146 points of the field are independent .",
    "the construction of a pseudo - random permutation is more involved .",
    "we use the construction of a pseudo - random permutation from @xcite .",
    "we need the property of @xmath146-wise almost independence ; by proposition  [ proposition - knr ] such a permutation can be effectively produced by a pseudo - random generator with a seed of length @xmath392 .",
    "alice and bob chose seeds for all required pseudo - random permutations at random , with the uniform distribution .",
    "the seeds of the generators involved in our protocol are much shorter than @xmath2 , so alice and bob can send them to charlie without essentially increasing communication complexity .",
    "the probability of the error remain the same is in section  [ section - protocol - model-2 ] , since we plugged in the protocol the pseudo - random bits which are @xmath214-wise independent .",
    "hence , we can use the bound from proposition  [ prop - model-3 ] .",
    "this concludes the proof of theorem  [ thm - main ] .      in this section",
    "we prove the technical probabilistic propositions used to estimate the probability of the failure in our communication protocols .",
    "_ proof of lemma  [ lemma1 ] ( a ) : _ first we prove the statement for a uniformly independent permutations .",
    "let @xmath393 .",
    "we denote @xmath394 we use the fact that the variables @xmath395 are `` almost independent '' .",
    "since the permutation @xmath149 is chosen uniformly , we have @xmath396 = |\\delta | / n = k / n$ ] for each @xmath164 .",
    "hence , @xmath397 . let us estimate the variance of this random sum .",
    "for @xmath398 we have @xmath399 = \\frac{k}{n } \\cdot \\frac{k-1}{n-1 } = \\left(\\frac{k}{n}\\right)^2 + o(k / n^2).\\ ] ] so , the correlation between every two @xmath395 is very weak . we get @xmath400",
    "now we apply chebyshev s inequality @xmath401",
    "< \\frac{{\\mathrm{var}}(\\sum \\xi_s)}{(\\delta k)^2 }   = o\\left(\\frac1{\\delta^2 k}\\right ) ,   \\label{eq - lemma4-a}\\ ] ] and we are done .    for a @xmath185-wise almost independent",
    "permutation we should add to the right - hand side of  ( [ eq - lemma4-a ] ) the term @xmath402 , which does not affect the asymptotic of the final result .",
    "before we prove lemma  [ lemma1 ]  ( b ) , let us formulate a corollary of lemma  [ lemma1 ]  ( a ) .    [ lemma - a - prim ]",
    "let @xmath403 be some disjoint subsets in @xmath404 such that @xmath405 for each @xmath160 . then for a uniformly random or @xmath406-wise almost independent permutation @xmath205 , @xmath407    \\le \\mu^t\\ ] ] and",
    "@xmath408    \\le \\mu^t.\\ ] ]    _ proof of corollary : _ ( sketch ) for a uniform permutation",
    "it is enough to notice that that the events `` _ _ there are too few @xmath149-images of @xmath409 in @xmath208 _ _ '' are negatively correlated with each other .",
    "that is , if we denote @xmath410 then @xmath411 >    { \\mathrm{prob}}_{\\pi}\\big[\\    e_{j_1}\\    \\big|   \\",
    "\\big ] > \\ldots   > { \\mathrm{prob}}_{\\pi}\\big[\\    e_{j_1}\\    \\big|   \\   e_2 \\ \\mbox { and } e_2   \\",
    "\\big ] > \\ldots\\ ] ] it remains to use the bound from  ( a ) for the unconditional probabilities .",
    "similarly to the proof of lemma  [ lemma1 ]  ( a ) , in the case of almost independent permutations the difference of probabilities is negligible .",
    "_ proof of lemma  [ lemma1 ] ( b ) : _ follows immediately from the corollary  [ lemma - a - prim ] and proposition  [ proposition - lln ] .",
    "_ proof of lemma  [ lemma - error - model-2 ] and lemma  [ lemma - error - model-3 ] : _ we prove directly the statement of lemma  [ lemma - error - model-3 ] ( which implies of course lemma  [ lemma - error - model-2 ] ) .",
    "let us estimate probabilities of errors at each step of charlie s part of the protocol .",
    "step ( @xmath384 ) : no errors .",
    "step ( @xmath353 ) : we should estimate probabilities of errors in reconstructing each block @xmath316 .    _",
    "1st type error : _ the number of alice s bits @xmath412 that appear in the block @xmath336 is less than @xmath413 .",
    "technically , this event itself is not an error of decoding ; but it is undesirable : we can not guarantee the success of reconstruction of @xmath336 if we get in this slot too few bits from alice .",
    "denote the probability of this event ( for a block @xmath335 ) by @xmath414 . by the law of large numbers , @xmath415 if @xmath416 .",
    "this fact follows from lemma  [ lemma1](a ) .    _",
    "2nd type error : _ @xmath82st type error does not occur but @xmath417 denote the probability of this event ( for a block @xmath335 ) by @xmath418 .",
    "again , by the law of large numbers , @xmath419 if @xmath420",
    ". technically , we apply lemma  [ lemma1](a ) with @xmath421 and @xmath422 .    _",
    "3rd type error : _",
    "1st and 2nd type errors do not occur but there exist at least two different strings @xmath341 satisfying  ( 1 ) and  ( 2 ) .",
    "we choose the length of hash values for @xmath423 so that this event happens with probability less than @xmath424 .",
    "let us explain this in more detail .",
    "all the positions of @xmath324 are split into two classes : the set @xmath425 and its complement @xmath426 . for each position in @xmath342 charlie",
    "knows the corresponding bit from @xmath287 sent by alice . to get @xmath341 , we should    * invert at most @xmath427 of alice s bits ( here we use the fact that the 2nd type error does not occur ) , and * choose some bits for the positions in @xmath428 ( we have no specific restrictions for these bits ) .",
    "the number of all strings that satisfy ( i ) and ( ii ) is equal to @xmath429 ( in the last equality we use the assumption that the 1st type error does not occur , so @xmath430 . )",
    "we set the length of the hash function @xmath423 to @xmath431 ( here we choose suitable values of parameters @xmath432 and @xmath433 ) .",
    "hence , from proposition  [ proposition - hash ] it follows that the probability of the 3rd type error is at most @xmath434 .",
    "we say that a block @xmath435 is _ reconstructible _ , if the errors of type @xmath82 , @xmath27 , and @xmath436 do not occur for this @xmath160 .",
    "for each block @xmath316 , probability to be non - reconstructible is at most @xmath437 .",
    "this sum can be bounded by some threshold @xmath438 , where @xmath439 . for the chosen parameters @xmath224 and @xmath221 we have @xmath440 for some @xmath232 .    since for each @xmath322 the probability that @xmath336 is non - reconstructible is less than @xmath192",
    ", we conclude that the expected number of non - reconstructible blocks is less than @xmath441 .",
    "this is already good news , but we need a stronger statement  we want to conclude that with high probability the number of non - reconstructible blocks is not far above the expected value .",
    "since random permutations in the construction are @xmath442-wise almost independent and the indices of hash functions are @xmath443-independent , we can apply proposition  [ proposition - lln ] and lemma  [ lemma1](b ) .",
    "we obtain @xmath444   = o(2^{-m^{c}})\\ ] ] for some @xmath232 .",
    "we conclude that on stage  ( @xmath353 ) with probability @xmath445 charlie decodes all blocks of @xmath336 except for at most @xmath446 of them .",
    "( @xmath447 ) here charlie reconstructs the string @xmath288 , if the number of non - reconstructible blocks @xmath336 ( at the previous step ) is less than @xmath446 .",
    "indeed , @xmath446 is just the number of errors that can be corrected by the reed - solomon checksums .",
    "hence , the probability of failure at this step is less than @xmath448 .",
    "here we choose the value of @xmath229 : we let @xmath449 .",
    "steps ( @xmath450 ) and  ( @xmath451 ) : no errors .",
    "step ( @xmath362 ) is similar to step ( @xmath353 ) .",
    "we need to estimate the probabilities of errors in the reconstruction procedures for each block @xmath281 .",
    "_ 1st type error : _ the number of alice s bits @xmath412 is less than @xmath413 .",
    "( we can not guarantee a correct reconstruction of a block @xmath265 if there are too few bits from alice in this slot ) .",
    "we denote the probability of this event by @xmath452 . from lemma",
    "[ lemma1](a ) it follows that @xmath453 since @xmath454 .    _",
    "2nd type error : _",
    "1st type error does not occur but @xmath455 denote the probability of this event by @xmath456 .",
    "again , from lemma  [ lemma1](a ) it follows that @xmath457 since @xmath416 .    _",
    "3rd type error : _",
    "1st and 2nd type errors do not occur but there exist at least two different strings @xmath358 satisfying  ( @xmath458 ) and  ( @xmath459 ) .",
    "all the positions @xmath324 are split into two classes : the set @xmath460 and its complement @xmath461 . for each position in @xmath462 charlie",
    "knows the corresponding bit from @xmath250 sent by alice . for",
    "the other bits carlie already knows the bits of @xmath463 , but not the bits of @xmath265 . to obtain @xmath341 , we should invert at most @xmath464 bits of @xmath465 .",
    "the number of such candidates is equal to @xmath466 we set the length of the hash function @xmath467 to @xmath468 from proposition  [ proposition - hash ] it follows that the probability of the 2nd type error @xmath469 .",
    "we say that block @xmath281 is _ reconstructible _ , if the errors of type @xmath82 , @xmath27 , and @xmath436 do not happen .",
    "for each block @xmath281 , probability to be non - reconstructible is at most @xmath470 .",
    "this sum is less than some threshold @xmath471 , where @xmath472 . for the chosen values of parameters we have @xmath473 for some @xmath232 .",
    "since the random permutations in the construction are @xmath442-wise almost independent and the indices of hash functions are @xmath443-independent , we get from proposition  [ proposition - lln ] and lemma  [ lemma1 ] @xmath474   = o(2^{-m^c}).\\ ] ] thus , with probability @xmath475 charlie decodes on this stage all blocks of @xmath265 except for at most @xmath476 of them .",
    "step ( @xmath477 ) is similar to step ( @xmath447 ) . at this step charlie",
    "can reconstructs @xmath250 if the number of non - reconstructible blocks @xmath265 ( at the previous step ) is less than @xmath476 ( this is the number of errors that can be corrected by the reed - solomon checksums ) .",
    "hence , the probability of failure at this step is less than @xmath478 .",
    "step ( @xmath385 ) : no errors at this step .",
    "thus , with probability @xmath479 ( for some @xmath480 ) charlie successfully reconstructs strings @xmath0 and @xmath1 .",
    "_ practical implementation . _ the coding and decoding procedures in our protocol run in polynomial time .",
    "however , the protocol does not seem very practical ( mostly due to the use of the knr generator from proposition  [ proposition - knr ] , which requires quite sophisticated computations ) .",
    "a simpler and more practical protocol can be implemented if we substitute @xmath146-wise almost independent permutations ( knr generator ) by @xmath27-independent permutation ( e.g. , a random affine mapping ) .",
    "the price that we pay for this simplification is a weaker bound for the probability of error , since with @xmath27-independent permutations we have to employ only chebyshev s inequality instead of stronger versions of the law of large numbers ( applicable to @xmath481-wise almost independent series of random variables ) .",
    "( a similar technique was used in @xcite to simplify the protocol from @xcite . ) in this `` simplified '' version of the protocol we can conclude that the probability of error @xmath482 tends to @xmath105 , but the convergence is rather slow .",
    "another shortcoming of our protocol is very slow convergence to the asymptotically optimal communication complexity ( the @xmath217-terms in theorem  [ thm - main ] are not so small ) .",
    "this is a general disadvantage of the concatenated codes and allied techniques , and there is probably no simple way to improve our construction .",
    "d. slepian and j.k .",
    "_ noiseless coding of correlated information sources_. ieee transactions on information theory , 19 , 471480 ( 1973 ) .",
    "wyner , _ recent results in the shannon theory _ , ieee trans .",
    "theory , vol .",
    "it-20 , no .  1 ,",
    "pp .  2 - 10 , jan",
    "yan zong ding , danny harnik , alon rosen , and ronen shaltiel .",
    "constant - round oblivious transfer in the bounded storage model . in proc .",
    "tcc 2004 , pp .  446472 , 2004 . j. p. schmidt , a. siegel , and a. srinivasan .",
    "chernoff - hoeffding bounds for applications with limited independence .",
    "siam j. discrete math .",
    ", 8(2):223250 , 1995 .",
    "e.  kaplan , m.  naor , and o.  reingold . _ derandomized construction of @xmath185-wise ( almost ) independent permutation_. approximation , randomization and combinatorial optimization .",
    "algorithms and techniques . 354365 ( 2005 ) .",
    "a.  smith , _ scrambling adversarial errors using few random bits _ , optimal information reconciliation , and better private codes . in proc .",
    "18th acm - siam symposium on discrete algorithms ( soda ) , 395404 ( 2007 ) .",
    "v. guruswami and a. smith , codes for computationally simple channels : explicit constructions with optimal rate , in proc .",
    "51st ieee symposium on foundations of computer science ( focs ) , 723732 ( 2010 ) .",
    "a.  chuklin , _ effective protocols for low - distance file synchronization _ , arxiv:1102.4712 ( 2011 ) .",
    "d. chumbalov , _ combinatorial version of the slepian - wolf coding theorem for binary strings _ , siberian electronic mathematical reports , 10 , 656665 ( 2013 ) .",
    "macwilliams , n.j.a .",
    "sloane , _ the theory of error - correcting codes _",
    ", north - holland , 1977 .",
    "l. carter , m. wegman , _ universal hash functions _ , journal of computer and system science , 18,143154 , 1979 .",
    "a.  y , k.  viswanathan , _ one - way communication and error - correcting codes . _ ieee transactions on information theory , 49(7 ) , 17811788 ( 2003 ) .",
    "i.  csiszar and j.  krner .",
    "information theory : coding theorems for discrete memoryless systems .",
    "cambridge university press ( 2011 ) .",
    "v.  guruswami .",
    "list decoding of error - correcting codes .",
    "springer science & business media , 2004 .",
    "new upper boundes for error - correcting codes .",
    "problems of information transmission , 1 ( 1 ) , 3235 ( 1965 ) .",
    "_ proof of proposition  [ prop - chumbalov ] : _ to prove the proposition , it is enough to show that for every @xmath483 there exists a linear encoding scheme with messages of length @xmath484 we use the idea of syndrome encoding that goes back to @xcite .",
    "first of all , we fix linear code with codewords of length @xmath2 that achieves the gilbert  varshamov bound .",
    "denote @xmath485 ( @xmath486 , @xmath487 for @xmath488 ) the parity - check matrix of this code .",
    "so , the set of codewords @xmath489 of this code",
    "consists of all solutions of the system if uniform equations @xmath490 ( a linear system over the field of @xmath27 elements ) . w.l.o.g .",
    "we assume that the rank of this system is equal to @xmath185 , and the last @xmath185 columns of @xmath491 make up a minor of maximal rank ( if this is not the case , we can eliminate the redundant rows and re - numerates the columns of the matrix ) .    _",
    "remark : _ the assumption above guarantees that for every sequence of binary values @xmath492 and for any @xmath493 we can uniquely determine @xmath494 satisfying the linear system @xmath495 ( in other words , @xmath493 are the free variables of this linear system , and @xmath496 are the dependent variables ) .",
    "let us show that charlie can reconstruct @xmath0 and @xmath1 given these two messages .",
    "first of all , given the syndromes @xmath499 and @xmath502 , charlie obtains @xmath503 , which is the syndrome of the bitwise sum of @xmath0 and @xmath1 .",
    "since the distance between @xmath0 and @xmath1 is not greater than @xmath3 , the bitwise sum @xmath504 contains at most @xmath3 ones .",
    "the code defined by matrix @xmath491 corrects @xmath505 errors , so charlie can reconstruct all bits of @xmath504 given the syndrome @xmath503 .",
    "now charlie knows the positions @xmath181 where @xmath506 , and the bits @xmath507 , and @xmath508 .",
    "this information is enough to reconstruct the first @xmath509 bits in both strings @xmath0 and @xmath1 .",
    "further , given the first @xmath510 bits of @xmath0 and @xmath1 and the syndromes of these strings , charlie reconstructs the remaining bits of @xmath0 and @xmath1 ( see the remark above ) .",
    "[ prop - orlitsky ] for every small enough @xmath511 there exists a @xmath512 such that for all large enough @xmath2 , for the deterministic combinatorial slepian ",
    "wolf schemes with parameters @xmath513 there is no achievable pairs of rates @xmath22 in the @xmath514-neighborhoods of the points @xmath51 and @xmath52 ( points @xmath53 and @xmath54 in fig .  4 ) .    _",
    "proof : _ at first we remind the argument from ( * ? ? ?",
    "* theorem  2 ) .",
    "it concerns an asymmetric version of the slepian ",
    "wolf scheme and it proves a lower bound for the length of @xmath10 assuming that @xmath55 . here is the idea of the proof : for each value @xmath515 , the set of pre - images @xmath516 is a set of strings with pairwise distances greater than @xmath517 , i.e. , these pre - images make up an error correcting code that corrects @xmath3 errors .",
    "so we can borrow from the coding theory a suitable bound for the binary codes and use it to bound the number of pre - images of @xmath515 .",
    "then , we obtain a lower bound for the number of values of @xmath10 and , accordingly , for the length of @xmath10 .",
    "technically , if we know from the coding theory that for a binary code that corrects @xmath3 errors the number of codewords can not be greater than @xmath518 for some specific function @xmath519 , then this argument implies that the length of @xmath10 can not be less than @xmath520 .",
    "for example , in in the well known elias  bassalygo bound @xmath521 which is stronger than the trivial volume bound @xmath522 , @xcite .",
    "alternatively , we can take the mceliece ",
    "rodemich  rumsey  welch bound .",
    "though this argument deals with only very special type of schemes where @xmath55 , it also implies some bound for the general slepian  wolf problem .",
    "indeed , assume there exists a deterministic slepian  wolf scheme for string @xmath0 and @xmath1 of length @xmath2 with @xmath523 for some threshold @xmath524 .",
    "denote the lengths of alice s and bob s messages by @xmath525 respectively .",
    "we will prove that the pair of parameters @xmath526 can not be too close to zero .",
    "notice that strings @xmath0 and @xmath1 of any length @xmath527 can be padded ( by a prefix of zeros ) to the length @xmath2 .",
    "hence , the given communication scheme ( originally used for pairs of strings of length @xmath2 , with the hamming distance @xmath214 ) can be used also for the slepian ",
    "wolf problem with shorter strings of length @xmath528 and the same distance between words @xmath214 ( which can be represented as @xmath529 for @xmath530 ) .",
    "thus , for the slepian  wolf problem with parameters @xmath531 we have a communication scheme with messages of the same lengths @xmath36 and @xmath37 , which can be represented now as @xmath532 we apply the explained above orlitsky  viswanathan bound to this scheme and obtain @xmath533 ( for any suitable bound @xmath534 from the coding theory ) .",
    "it follows that @xmath535 the functions @xmath534 from the elias  bassalygo bound and from the mceliece ",
    "rodemich  rumsey ",
    "welch bound are a continuous functions , and for small positive @xmath83 they are bigger than @xmath536 .",
    "hence , ( [ eq - orlitsky ] ) implies that for every fixed @xmath12 the values of @xmath537 and @xmath538 can not be very small simultaneously .",
    "we do not discuss here the exact shape of this forbidden zone for values of @xmath526 ; we only conclude that small neighborhoods around the point @xmath52 and ( from a symmetric argument ) @xmath51 can not be achieved , which concludes the proof of the proposition ."
  ],
  "abstract_text": [
    "<S> we study the following combinatorial version of the slepian  wolf coding scheme . </S>",
    "<S> two isolated senders are given binary strings @xmath0 and @xmath1 respectively ; the length of each string is equal to @xmath2 , and the hamming distance between the strings is at most @xmath3 . </S>",
    "<S> the senders compress their strings and communicate the results to the receiver . </S>",
    "<S> then the receiver must reconstruct both strings @xmath0 and @xmath1 . </S>",
    "<S> the aim is to minimise the lengths of the transmitted messages .    for an asymmetric variant of this problem ( where one of the senders transmits the input string to the receiver without compression ) with deterministic encoding a nontrivial bound </S>",
    "<S> was found by a.  orlitsky and k.  viswanathany , @xcite . in our paper </S>",
    "<S> we prove a new lower bound for the schemes with syndrome coding , where at least one of the senders uses linear encoding of the input string .    for the combinatorial slepian  </S>",
    "<S> wolf problem with randomized encoding the theoretical optimum of communication complexity was found in @xcite , though effective protocols with optimal lengths of messages remained unknown . </S>",
    "<S> we close this gap and present a polynomial time randomized protocol that achieves the optimal communication complexity .    </S>",
    "<S> coding theory , communication complexity , pseudo - random permutations , randomized encoding , slepian  wolf coding </S>"
  ]
}