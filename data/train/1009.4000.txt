{
  "article_text": [
    "malicious cryptography and malicious mathematics malicious are an emerging field [ 2 , 3,4 ] that finds its origin in the initial work of young and yung on the use of asymmetric cryptography in the design of dedicated offensive functions for money extorsion ( cryptovirology ) [ 5 ] . but this initial approach is very limited and gives only a very small insight of the way mathematics and cryptography can be actually perverted by malware .",
    "malicious cryptology and malicious mathematics make in fact explode young and yung s narrow vision .",
    "this results in an unlimited , fascinating yet disturbing field of research and experimentation .",
    "this new domain covers several fields and topics ( non - exhaustive list ) :    * use of cryptography and mathematics to develop `` _ super malware _ ''",
    "( _ ber - malware _ ) which evade any kind of detection by implementing : * * optimized propagation and attack techniques ( e.g. by using biased or specific random number generator ) @xcite . * * sophisticated self - protection techniques .",
    "the malware code protect itself and its own functional activity by using strong cryptography - based tools @xcite . * * code invisibility techniques using testing simulability @xcite . * * code mutation techniques ( by combining the different methods of the previous three items ) . * use of complexity theory or computability theory to design undetectable malware @xcite . * use of malware to perform applied cryptanalysis operations ( theft of secrets elements such as passwords or secret keys , static or on - the - fly modification of systems to reduce their cryptographic strength @xcite ... ) by a direct action on the cryptographic algorithm or its environment . * design and implementation of encryption systems with hidden mathematical trapdoors .",
    "the knowledge of the trap ( by the system designer only ) enables to break the system very efficiently . despite the fact that system is open and public",
    ", the trapdoor must remain undetectable .",
    "this can also apply to the keys themselves in the case of asymmetric cryptography @xcite .    to summarize",
    ", we can define malicious cryptography and malicious mathematics as the interconnection and interdependence of computer virology with cryptology and mathematics for their mutual benefit .",
    "the possibilities are virtually infinite .",
    "it is worth mentioning that this vision and the underlying techniques can be translated for `` non - malicious '' use as the protection of legitimate codes ( e.g. for copyright protection purposes ) against static ( reverse engineering ) and dynamic ( sandboxing , virtualization ) analyses . if simple and classical obfuscation techniques are bound to fail as proved by barak and al .",
    "@xcite theoretically ( for a rather restricted model of computation ) , new models of computation @xcite and new malware techniques @xcite have proved that efficient code protection can be achieved practically .",
    "if the techniques arising from this new domain are conceptually attractive and potentially powerful , their operational implementation is much more difficult and tricky .",
    "this requires a very good mastery of algorithms and low - level programming . above all the prior operational thinking of the attack",
    "is unavoidable .",
    "the same code implementing the same techniques in two different contexts will have quite different outcomes .",
    "in particular , we must never forget that the code analysis is static ( disassembly / decompilation ) but also dynamic ( debugging , functional analysis ... ) .",
    "code encryption usually protects  possibly  against static code analysis only .    in this paper",
    "we will show how the techniques of malicious cryptography enable to implement total amoring of programs , thus prohibiting any reverse engineering operation .",
    "the main interest of that approach lies in the fact that transec properties are achieved at the same time . in other words ,",
    "the protected binary has the same entropy as any legitimate , unprotected code .",
    "this same technique can also achieve a certain level of polymorphism / metamorphism at the same time : a suitable 59-bit key stream cipher is sufficient to generate up to @xmath0 variants very simply .",
    "more interestingly , the old fashioned concept of decryptor which usually constitutes a potential signature and hence a weakness , is totally revisited .",
    "these techniques have been implemented by the author in the libthor which has been written and directed by anthony desnos @xcite .",
    "the paper is organized as follows .",
    "section  [ cacm ] recalls some important aspect about code protection and discusses key points about code armouring and code mutation .",
    "then section  [ cs ] presents the context we consider to apply our technique : we aim at protecting critical portions of code that are first transformed into an intermediate representation ( ir ) , then into the bytecode .",
    "this code itself is that of virtual machine used to provide efficent protection against dynamic analysis .",
    "section  [ mprng ] presents the different models and techniques of malicious pseudo - random number generator ( prng ) .",
    "finally section  [ imp_k ] presents implementation issue which must be considered to achieve protection against both static and dynamic analyses .",
    "we will not recall in details what these two techniques are . the reader may consult @xcite for a complete presentation with respect to them . as far as malicious cryptography",
    "is concerned , we are just going to discuss some critical points which are bottlenecks in their effective implementation .",
    "most of the times the attempts to play with these techniques fail due to a clumsy use of cryptography .",
    "code armouring @xcite consists in writing a code so as to delay , complicate or even prevent its analysis .",
    "as for code mutation techniques they strive to limit ( polymorphism ) or to remove ( metamorphism ) any fixed component ( invariant ) from one mutated version to another . the purpose is to circumvent the notion of antiviral signature , may it be a a simple sequence of contiguous or nor contiguous bytes or meta - structures such as control flow graphs ( cfg ) and other traces describing the code functional ( behavioral ) structure .    in all these cases ,",
    "the general approach is to encrypt the code to protect or to use special techniques for generating random data .",
    "but encryption and generation of randomness relates to two major practical problems : their characteristic entropy profile and the secret elements ( keys ) management .",
    "the whole problem lies in the fact that code armouring and code mutation involve random data .",
    "these must be generated on - the - fly and in the context of metamorphism , the generator itself must be too .",
    "for sake of simplicity , we shall speak of _ pseudo - random number generator _ ( prng ) to describe both a random number generator and an encryption system .",
    "the difference lies in the fact that in the latter case either random data produced from the expansion of the key are combined with the plaintext ( stream ciphers ) or they are the result of the combination of the key with the plaintext ( block ciphers ) .",
    "the whole issue lies in the generation of a so - called `` good '' randomness . except that in the context of malicious cryptography @xcite , the term `` good '' does not necessarily correspond to what cryptographers",
    "usually mean .",
    "in fact , it is better  yet a simplified but sufficient reduction as a first approximation  to use the concept of entropy @xcite . in the same way",
    ", the term of random data will indifferently describe the random data themselves or the result of encryption .    consider a ( malicious ) code as an information source @xmath1 . when parsed , the source outputs characters taking the possible values @xmath2 , each with a probability @xmath3 $ ] .",
    "then the entropy @xmath4 of the source is the following sum - grams and would compute entropy when @xmath5 . ] : @xmath6 random data , by nature will exhibit a high entropy value . ] . on the contrary ,",
    "non random data exhibit a low entropy profile ( they are easier or less difficult to predict ) .    from the attacker",
    "s point of view the presence of random data means that something is hidden but he has to make the difference between legitimate data ( e.g. use of packers to protect code against piracy ) and illegitimate data ( e.g. malware code ) . in the nato terminology  at the present time it is the most precise and accurate one as far as infosec is concerned random data relate to a comsec ( _ communication security _ ) aspect only .    for the attacker ( automated software or human expert ) ,",
    "the problem is twofold : first detect random data parts inside a code and then decrypt them . in this respect ,",
    "any code area exhibiting a high entropy profile must be considered as suspicious . to prevent attention to be focused on those random parts ,",
    "is it possible to add some transec ( _ transmission security _ ) aspect .",
    "the most famous one is steganography but for malware or program protection purposes it is not directly usable ( data can not be directly executed ) and we have to find different ways .",
    "the other solution is to use malicious statistics as defined and exposed in @xcite .",
    "it is also possible to break randomness by using noisy encoding techniques like perseus @xcite . in this case",
    "the code remains executable while being protected and exhibiting low entropy profile at the same time ( or the entropy profile of any arbitrary kind of data ) . as for an exemple , on a 175-bytes script , the unprotected code has an entropy of 3.90 .",
    "an encrypted version ( by combining simple transpositions with simple substitutions ) of that code has an entropy equal to 5.5 .",
    "when protected by perseus the entropy is about 2.57 .",
    "so it is very close to a normal program and thus evade entropy - based detection .",
    "this applies well on any data used for code mutation ( e.g. junk code insertion ) , including specific subsets of code as cfgs : randomly mutated cfg must exhibit the same profile as any normal cfg would .",
    "otherwise , considering the comsec aspect only is bound to make the code detection very easy .",
    "encrypting a code or a piece of code implies its preliminary deciphering whenever it is executed .",
    "but in all of the cases  except those involving money extortion introduced young and yung @xcite  the key must be accessible to the code itself to decipher .",
    "consequently in a way or another it is contained in a more or less obfuscated form inside the code .",
    "therefore is it accessible to the analyst who will always succeed in finding and accessing it . instead of performing cryptanalysis , a simple decoding /",
    "deciphering operation is sufficient .",
    "it is therefore necessary to consider keys that are external to the encrypted code .",
    "two cases are possible @xcite :    * environmental key management introduced in @xcite and developped in @xcite .",
    "the code gathers information in its execution environment and calculates the key repeatedly .",
    "the correct key will be computed when and only when the suitable conditions will be realized in the code environment  which is usually under the control of the code designer .",
    "the security model should prohibit dictionary attacks or environment reduction attacks ( enabling reduced exhaustive search ) by the code analyst .",
    "consequently the analyst must examine the code in an controlled dynamic area ( sandbox or virtual machine ) and wait until suitable conditions are met without knowing when they will be .",
    "however it is possible to build more operational scenarii for this case and to detect that the code is being analyzed and controlled @xcite . *",
    "use of @xmath7-ary codes @xcite in which a program is no longer a single monolithic binary entity but a set of binaries and non executable files ( working in a serial mode or in a parallel mode ) to produce a desired final ( malicious or not ) action .",
    "then the analyst has a reduced view on the whole code only since generally he can access a limited subset of this @xmath7-set . in the context of ( legitimate ) code protection , one of the files will be a kernel - land module communicating with a userland code to protect .",
    "the code without the appropriate operating environment  with a user - specific configuration by the administrator  will never work .",
    "this solution has the great advantage of hiding ( by outsourcing it ) , the encryption system itself .",
    "it is one particular instance with respect to this last solution that we present in this paper .",
    "in this section we are going to illustrate our approach with simple but powerful cases . without loss of generality and for sake of clarity , we consider a reduced case in which only a very few instructions are protected against any disassembly attempt . of course any real case  as we did in libthor  will consider far more instructions , especially all critical ones ( those defining the cfg for instance ) .",
    "the libthor library initiated and mainly developped by anthony desnos @xcite uses virtual machines ( vm ) as the core tool .",
    "virtual machines offer a powerful protection for an algorithm or anything else that we would like to protect against reverse engineering .",
    "we can have a lot of different vms piled up ( like russian dolls ) into a software .",
    "this technique must be combined with classical techniques since it is just a one more step towards code protection .    in libthor ,",
    "the main goal of vms is to build a simple code which interprets another one .",
    "the idea is to take a piece of x86 assembly instructions and to have a simple , dynamic , metamorphic vms very quickly to interpret it .",
    "it is worth stressing on the fact that you can embed different vm into the same program to protect differents parts .    in desnos libthor vms",
    "are codes which interpret an intermediate representation ( ir ) derived from the reil language @xcite .",
    "so a translation between x86 assembly instructions and the chosen ir is performed .",
    "the vm is totaly independent from the libc or anything like that .",
    "the main goal of the vm is to run an algorithm into an encapsulated object ( which can be loaded anywhere ; in fact it is a simple shellcode ) , but the main feature of the vm is to have a different version of it at each generation for a same code so if we want to protect a simple instruction @xmath1 , we can build a new vm every time to protect the same @xmath1 .",
    "this new vm will be different from the previous one .",
    "moreover everything must be dynamic .",
    "therefore we must have simple working rules :    * the bytecode must be dynamic and hidden by using the malicious cryptography tools ( malicious pnrg ) we are exposing hereafter ; * information must be dynamic ( area for each context , the offset for each register in the context ... ) ; * the code must be transformed with the internal libthor metamorphic package ( in which malicious pnrg can used used too ) ; * integer constants can be hidden with libthor internal junk package .",
    "this is very useful to hide opcode values , register offsets or anything which represent any invariant in a program . here",
    "again malicious prngs play a critical role .    during the code generation ( mutation ) , we use the libthor metamorphic package a lot of times on a function .",
    "we have several steps during a generation :    1 .",
    "obfuscation of c source code .",
    "2 .   compiling the c source code of the vm into a library .",
    "3 .   extraction of interesting functions from the library .",
    "4 .   transformation of x86 assembly instructions into ir .",
    "obfuscation of ir by using metamorphic package",
    "transformation of ir into bytecode",
    "creation of dynamic functions to handle the bytecode",
    "obfuscation of functions by using the metamorphic package .",
    "the mutated code is produced here and the malicious prng is mainly involved here .",
    "assembly of all parts to have a simple shellcode .",
    "our prng is essentially dedicated to the protection of the bytecode which is the final result of the transformation : x86 asm @xmath8 reil ir @xmath8 bytecode .",
    "here is an illustrating example :    ....     [ x86 asm ]        mov eax , 0x3 [ b803000000 ]     [ reil ir ]        str ( 0x3 , b4 , 1 , 0 ) , ( eax , b4 , 0 , 0 )     [ bytecodes ]      0xf1010000 0x40004 0x3 0x0 0x6a ....    we have five fields in the bytecode corresponding respectively to :    * 0xf1010000 * * 0xf1 : the opcode of the instruction ( str ) , * * 0x01 : specifies that it is an integer value , * * 0x00 : useless with respect to this instruction , * * 0x00 : specifies that it is a register . * 0x40004 * * 0x04 : the size of the first operand , * * 0x00 : useless with respect this instruction , * * 0x04 : the size of the third operand , * 0x3 : direct value of the integer , * 0x0 : useless with respect to this instruction , * 0x6a : value of the register .    in this setting the 0x00 values ( useless with respect this instruction ) contribute directly to the transec aspect .",
    "now that the working environment is defined , let us explain how a malicious prng can efficiently protect the opcode values while generating them dynamically .",
    "sophisticated polymorphic / metamorphic or obfuscation techniques must rely on prng ( pseudo - random number generator ) . in the context of this paper ,",
    "the aim is to generate sequences of random numbers ( here bytecode values ) on - the - fly while hiding the code behavior .",
    "sequences are precomputed and we have to design a generator which will afterwards output those data .",
    "the idea is that any data produced by the resulting generator will be first used by the code as a valid address , and then will itself seed the pnrg to produce the next random data .",
    "three cases are to be considered :    1 .",
    "the code is built from any arbitrary random sequence ; 2 .",
    "the sequence is given by a ( non yet protected ) instance of bytecode and we have to design an instance of pnrg accordingly ; 3 .",
    "a more interesting problem lies in producing random data that can be somehow interpreted by a prng as meaningful instructions like jump 0x89 directly .",
    "this relates to interesting problems of prng cryptanalysis .",
    "we are going to address these three cases .    from a general point of view",
    "it is necessary to recall that for both three cases the malware author needs reproducible random sequences . by reproducible ( hence the term of pseudo - random ) , we mean that the malware will replay this sequence to operate its course of actions .",
    "the reproducibility condition implies to consider a _ deterministic finite - state machine _ ( dfsm ) .",
    "the general scheme of how this dfsm is working is illustrated as follows . without the dfsm , any instruction data whenever executed produced a data used the next instruction ( e.g. an address , an operand ... ) .",
    "@xmath9    any analysis of the code will easily reveal to the malware analyst all the malware internals since all instructions are hardcoded .",
    "but if a few data / instructions are kept under an encrypted form , and deciphered at execution only , the analysis is likely to be far more difficult ( up to decryptor and the secret key protection issue ) .",
    "it is denied of a priori analysis capabilities .",
    "so we intend to have @xmath10 where @xmath11 for all i. upon execution , we just have to input data @xmath12 into the dfsm which will then output the data @xmath13 .",
    "a few critical points are worth stressing on    1 .",
    "no key is neither required nor used ; 2 .",
    "instructions can similarly protected as well .",
    "of course to be useful as a prevention tool against analysis , the dfsm must itself be obfuscated and protected against analysis . but this last point is supposed to be fulfilled .",
    "we will show a more powerful implementation by using @xmath14-ary malware in section  [ imp_k ] .      in this case",
    ", the sequence is arbitrary chosen before the design of the code and hence the code is written directly from this arbitrary sequence .",
    "this case is the most simple to manage .",
    "we just have to choose carefully the dfsm we need .",
    "one of the best choice is to take a congruential generator since it implies a very reduced algorithm with simple instructions .",
    "let us consider @xmath15 an initial value and the corresponding equation @xmath16 where @xmath17 is the multiplier , @xmath18 is the increment and @xmath19 is the modulus . since the length of the sequence involved in the malware design is rather very short ( up to a few tens of bytes ) , the choice of those parameters is not as critical as it would be for practical cryptographic applications . in this respect",
    ", one can refer to knuth s seminal book to get the best sets of parameters @xcite .",
    "here are a few such examples among many others :    standard minimal generator : :    @xmath20 .",
    "vax - marsaglia generator : :    @xmath21 .",
    "lavaux & jenssens generator : :    @xmath22 .",
    "haynes generator : :    @xmath23 .",
    "kuth s generator : :    @xmath24 and    @xmath25 .",
    "of course the choice of the modulus is directly depending on the data type used in the malware .",
    "another interesting approach is to consider hash functions and s / key .",
    "the principle is almost the same .",
    "we take a @xmath26 hash function @xmath27 which produces a @xmath28-bit output from a @xmath29-bit input with @xmath30 . in our case",
    "we can build @xmath29 in the following way    ....",
    "m = < data to protect><padding of random data><size of data > ....    or equivalently    ....",
    "m = d_i < random data > |d_i| ....    then we choose a @xmath29-bit initialization vector ( iv ) and we compute the random sequence as follows @xmath31 the iteration value @xmath32 can be used to get one or more required arbitrary value thus anticipating the next case .",
    "of course the nature of the hash function is also a key parameter : you can either use existing hash function ( e.g md5 , sha-1 , ripemd 160 , sha-2 ... ) and keep only a subset of the output bit ; or you can design your own hash function as explained in @xcite .      in this slightly different case ,",
    "the sequence is determined by a ( non yet protected ) instance of a code .",
    "this issue is then to design or use an instance of prng accordingly .",
    "this is of course a far more difficult issue which implies cryptanalytic techniques . to formalize the problem we have a sequence @xmath33 which represents critical data ( addresses , asm instructions , operands ... ) of a particular instance of a ( malware ) code . as for example let us consider three series of 32-bit integers describing bytecode values as defined in section  [ cs ] :    .... 0x2f010000",
    "0x040004 0x3 0x0 0x89         ( 1 ) 0x3d010000 0x040004 0x3 0x0 0x50         ( 2 )       0x5010000 0x040004 0x3 0x0 0x8d         ( 3 )    ....    they are just different instances of the same instruction @xcite .",
    "the aim is to have these data in the code under a non hardcoded form .",
    "then we intend to code them under an obfuscated form , e.g. @xmath34 we then have to find a dfsm such that @xmath35 the notation @xmath36 directly suggests that the quantity input to the dfsm is a key in a cryptographic context but these keys have to exhibit local low entropy profile at the same time .",
    "so the malicious prng must take this into account as well . in this case",
    ", we have to face a two - fold cryptanalytic issue :    * either fix the output value @xmath37 and find out the key @xmath36 which outputs @xmath37 for an arbitrary dfsm , * or for an arbitrary set of pairs @xmath38 design a unique suitable dfsm for those pairs .",
    "the first case directly relates to a cryptanalytic problem while the second refers more to the problem of designing cryptographic dfsms with trapdoors . in our context of malicious cryptography ,",
    "the trapdoors here are precisely the arbitrary pairs of values @xmath38 while the dfsm behaves for any other pair as a strong cryptosystem @xcite .",
    "this second issue is far more complex to address and will not be exposed in this paper ( research under way ; to be published later ) .",
    "we will focus on the first case which has been partially addressed for real - life cryptosystem like _ bluetooth _",
    "e0 @xcite in the context of zero knowledge - like proof of cryptanalysis .",
    "but in our case we do not need to consider such systems and much simpler dfsm can be built conveniently for our purposes : sequences of data we use are rather short .",
    "we have designed several such dfsms and we have proceeded to their cryptanalysis to find out the keys @xmath36 which output the values @xmath37",
    ".    as we will see , those dfsm have to exhibit additional features in order to    * be used for code mutation purposes , * exhibit transec properties . in other words , if we have @xmath39 , then @xmath1 and @xmath40 must have the same entropy profile .",
    "replacing @xmath1 with a @xmath40 having a higher entropy profile would focus the analyst s attention .    without loss of generality , let us consider the mathematical description of a 59-key bit stream cipher ( we currently work on block cipher which should offer more interesting features ; to be continued  ) we have designed for that purpose .",
    "other dfsms with larger key size ( up to 256 ) have been also designed ( available upon request ) .",
    "the principle is very simple yet powerful : three registers @xmath41 and @xmath42 are filtered by a boolean function @xmath43 , thus outputing bits @xmath44 ( or bytes in a vectorized version ) that are combined to the plaintext ( figure  [ combsys ] ) .        the value @xmath36 initializes the content of registers @xmath41 and @xmath42 at time instant @xmath45 , and outputs bits @xmath46 which represent the binary version of values @xmath37 .",
    "the linear feedback polynomials driving the registers are the following : @xmath47 where @xmath48 denotes the exclusive or .",
    "the combination function is the _ majority function",
    "_ applied on three input bits and is given by @xmath49 an efficient implementation in c language is freely available by contacting the author . for our purposes , we will use it in a procedure whose prototype is given by    ....",
    "void sco(unsigned long long int * x , unsigned long long int k )   {    / * k obfuscated value ( input ) , x unobfuscated value ( output ) * /    / * ( array of 8 unsigned char ) by sco                          * /    ...   } ....    now according to the level of obfuscation you need , different ways exist to protect your critical data inside the code ( series of integers ( 1 ) , ( 2 ) and ( 3 ) above ) .",
    "we are going to detail two of them .",
    "the dfsm outputs critical data under a concatenated form to produce chunks of code corresponding to the exact entropy of the input value @xmath50 , thus preventing any local increase of the code entropy . for the dfsm",
    "considered , it means that we output series ( 1 ) , ( 2 ) and ( 3 ) under the following form    ....",
    "1)-- > 0x2f01000000040004000000030000000000000089",
    "2)-- > 0x3d01000000040004000000030000000000000050    3)-- > 0x050100000004000400000003000000000000008d    ....    let us detail the first output sequence ( 1 ) .",
    "it will be encoded as three 59-bit outputs @xmath51 and @xmath52    ....",
    "m_1 =      0x0bc04000000ll ;     m_2 = 0x080008000000060ll ;     m_3 = 0x000000000000089ll ;   ....    to transform @xmath51 and @xmath52 back into five 32-bit values @xmath53 and @xmath54 , we use the following piece of code :    ....    / * generate the m_i values * /    sco(&m_1 , k_1 ) ;    sco(&m_2 , k_2 ) ;    sco(&m_3 , k_3 ) ;      x_1 = m_1 > > 10 ;   / * x_1 = 0x2f010000l * /           x_2 = ( ( m_2 > > 37 ) | ( m_1 < < 22 ) ) & 0xffffffffl                       / * x_2 = 0x00040004l * /    x_3 = ( m_2 > > 5 ) & 0xffffffffl ; / * x_3 = 0x3 * /    x_4 = ( ( m_3 > > 32 ) | ( m_2 < < 27 ) ) & 0xffffffffl ;                      / * x_4 = 0x0 * /    x_5 = m_3 & 0xffffffffl ;        / * x_5 = 0x89 * / ....    values @xmath51 and @xmath52 will be stored in the code as the values @xmath55 and @xmath56 with @xmath57 :    ....     k_1 = 0x6aa006000000099ll ;     k_2 = 0x500403000015dc8ll ;     k_3 = 0x0e045100001eb8all ;      ....    similarly we have for sequence ( 2 )    ....     m_1 =      0x0f404000000ll ;   k_1 = 0x7514360000053c0ll ;     m_2 = 0x080008000000060ll ;   k_2 = 0x4c07a200000a414ll ;     m_3 = 0x000000000000050ll ;   k_3 = 0x60409500001884all ; ....    and for sequence ( 3 )    ....     m_1 =      0x01404000000ll ;   k_1 = 0x76050e00001f0b1ll ;     m_2 = 0x080008000000060ll ;   k_2 = 0x00000010c80c460ll ;     m_3 = 0x00000000000008dll ;   k_3 = 0x000000075098031ll ; ....    the main interest of that method is that the interpretation of code is not straightforward .",
    "code / data alignment does not follow any logic ( that is precisely why we have chosen a 59-bit fsm which is far better that a seemingly more obvious 64-bit fsm ; any prime value is optimal ) .",
    "moreover , as we can notice , the @xmath36 values are themselves sparse as unobfuscated opcodes are ( structural aspect ) .",
    "additionally , their entropy profile ( quantitative aspects ) is very similar to the @xmath58 values ( and hence the @xmath37 ones ) .",
    "this implies that any detection techniques based on local entropy picks is bound to fail .    due to the careful design of our 59-bit dfsm",
    ", we managed to obtain a unicity distance which is greater than 59 bits ( the unicity distance is the minimal size for a dfsm output to be produced by a single secret key ) . in our case a large number of different 59-bit keys can output an arbitrary output sequence .",
    "here are the results for the three series ( 1 ) , ( 2 ) and ( 3 ) ( table  [ res ] ) :    .number of possible keys for a given output value [ cols=\"^,^,^\",options=\"header \" , ]     this implies that we can randomly select our 9 @xmath58 values and thus we have @xmath59 different possible code variants .",
    "it is approximatively equal to @xmath60 variants .",
    "the different files ( @xmath61 with @xmath62 ) whose name is given in right column of table  [ res ] are freely available upon request .",
    "to build a variant , you just have to select data in the nine files randomly according to the following piece of code ( code extract to generate the @xmath63 values for the first serie ( 1 ) only ; refer to section  [ imp_k ] for a secure implementation ) :    ....    f1 = fopen(\"res11\",\"r \" ) ;             f2 = fopen(\"res12\",\"r \" ) ;    f3 = fopen(\"res13\",\"r \" ) ;                                      randval = ( 314.0*(rand()/(1 + rand_max ) ) ;         for(i = 0 ; i < randval ; i++ )        fscanf(f1 ,  % lx % lx % lx\\n  , & y1,&y2 , & y3 ) ;                k_1 = y1 | ( y2 < < 17 ) | ( y3 < < 36 )  ;              / * do the same for values m_2 and m_3 of serie ( 1 ) * /        ....                  / * repeat the same for series ( 2 ) and ( 3 )           * /        ....                  / * generate m_1 value for series(1 )                 * /                  sco(&m_1 , k_1 ) ; ....    the different files ( @xmath61 with @xmath62 ) can be stored in a program whose size is less than 400 kb .      in this second case ,",
    "the dfsm outputs 59-bit chunks of data whose only the 32 least significant bits are useful .",
    "in this case we output five 59-bit chunks of data @xmath64 and @xmath65 .",
    "for sequence ( 1 ) we have    ....     m_1 = 0x???????2f010000ll ;      m_2 = 0x???????00040004ll ;      m_3 = 0x???????00000003ll ;      m_4 = 0x???????00000000ll ;      m_5 = 0x???????00000089ll ; ....    where  ` ? ` describes any random nibble .",
    "we get the @xmath37 values from the @xmath58 values with @xmath66    the main interest of that method is that it naturally and very simply provides increased polymorphism compared to the previous approach . indeed about @xmath0 5-tuples @xmath67 whenever input in our dfsm produces 5-tuples @xmath68",
    ". then we can produce a huge number of different instances of the same code by randomly choosing any possible 5-tuples . by increasing size of the memory of the fsm",
    "we even can arbitrarily increase the number of possible polymorphic instances .",
    "the obfuscation techniques we have presented before , which are based on malicous cryptography ( malicious , biased prng ) and cryptanalysis techniques ( to precompute inputs to the dfsm ) require obviously to protect the dfsm itself very strongly . indeed obtaining the @xmath37 values from the @xmath36",
    "is straightforward whenever we have the dfsm .",
    "we would then come back to the weak existing implementations and reduce the problem to a simple decoding scheme .",
    "but this obfuscation is impossible to reverse in the context of @xmath7-ary malware @xcite . in this case , the viral information is not contained in a single code as usual malware do , but it is split into @xmath7 different innocent - looking files whose combined action -",
    "serially or in parallel - results in the actual malware behavior and in the metamorphic code instance generation .",
    "just imagine a 2-ary code ( we can take of course @xmath69 ) made of parts @xmath70 and @xmath71 .",
    "part @xmath70 just embeds the dfsm and wait in memory for values @xmath36 coming from part @xmath71 .",
    "its role is to compute @xmath72 values and send them back to part @xmath71 according to the protocol summarized by figure  [ fig2 ] .",
    "the interpretation of data by the reverser ( and hence the reversing of the code ) is no longer possible since the dfsm is deported in the part @xmath70 and the analysis of part @xmath71 would require to reconstruct the dfsm and to break it .",
    "this is of course impossible since the code does not contain a sufficient quantity of encrypted information .    in the case of metamorphism",
    ", the part @xmath70 will output a random @xmath36 value instead during the code instance generation .    from a practical point of view",
    ", we have considered different implementations .",
    "communication pipes : :    due to the relationship between father and children processes , only    parallel class a or c @xcite k - ary codes can be implemented .",
    "it is    not the most optimal solution .",
    "named communication pipes : :    in this case , k - ary parallel class b codes can be efficiently    implemented ( the most powerful class since there is no reference in    any part [ hence information ] to other any part ) .",
    "system v ipc : :    this is the most powerful method since everything is located into    shared memory",
    ".    the source codes of our implementation will be soon publicly available .    in the context of code protection for legitimate purpose , the part @xmath71 will be a kernel - land module can be user / host specific .",
    "it can also be a program located on a server outside the code analyst s scope .",
    "we have shown in this paper that it is possible to prevent code analysis from reversing while ensuring a high level of metamorphism . of course , we have to apply those techniques to all critical parts of the code ( especially those which determine the execution flow ) . in this case",
    "it is obvious that static analysis is no longer possible . as far as dynamic analysis is concerned , the analyst has to perform debugging and sandboxing . but using delay detection technique @xcite can trigger a different code behaviour and code mutation .",
    "our current research and experimentation work is related to non deterministic fsms . in this case",
    "any internal state of the fsm results in many possible outcome ( next state at time instant @xmath73 ) .",
    "even if is likely to be far beyond any av software detection capability , human analysis becomes impossible .",
    "non deterministic contexts result in untractable complexity .",
    "thanks to anthony desnos for his support with respect to virtual machines and ir and for many other reasons : geoffroy gueguen ( and his awful vanwinjgaarden formal grammars ) , eloi vanderbken ( aka _ baboon _ ) for his funny way of thinking security .",
    "50 b. barak , o. goldreich , r. impagliazzo , s. rudich , a. sahai , s. vadhan and k. yang ( 2001 ) . on the ( im)possibility of obfuscation programs . in : _ advances in cryptology - crypto",
    "2001 _ , lncs 2139 , pp . 1 - 8 , springer verlag .",
    "philippe beaucamps and eric filiol ( 2006 ) . on the possibility of practically obfuscating programs - towards a unified perspective of code protection .",
    "_ journal in computer virology _",
    ", 2(4 ) , wtcv06 special issue , g. bonfante editor , springer verlag .",
    "anthony desnos ( 2009 ) .",
    "implementation of @xmath14-ary viruses in python .",
    "hack.lu 2009 conference .",
    "anthony desnos ( 2010 ) .",
    "dynamic , metamorphic ( and open source ) virtual machines . to appear in the _ proceedings of the hack.lu 2010 conference _ , luxembourg .",
    "thomas dullien and sebastian porst ( 2009 ) .",
    "reil : a platform independent intermediate representation of disassembled code for static code analysis .",
    "cansecwest 2009 , vancouver , canada .",
    "available on http://www.zynamics.com/downloads/csw09.pdf robert erra and christophe grenier ( 2009 ) . how to choose rsa keys ( the art of rsa : past , present and future ) ?",
    "iawacs 2009 conference .",
    "available on http://www.esiea-recherche.eu/iawacs_2009_papers.html eric filiol .",
    "strong cryptography armoured computer viruses forbidding code analysis : the bradley virus . in : _",
    "proceedings of the 14th eicar conference _ , pp.- 201217 , may 2005 , malta .",
    "eric filiol ( 2005 ) .",
    "_ computer viruses : from theory to applications _ , iris international series , springer verlag france , isbn 2 - 287 - 23939 - 1",
    "eric filiol ( 2007 ) . _",
    "techniques virales avances _ , collection iris , springer verlag france , isbn 978 - 2 - 287 - 33887 - 8 .",
    "eric filiol and sbastien josse . a statistical model for viral detection undecidability .",
    "eicar 2007 special issue , v. broucek ed .",
    ", _ journal in computer virology _ , 3 ( 2 ) .",
    "springer verlag .",
    "eric filiol , edouard franc , alessandro gubbioli , benoit moquet and guillaume roblot ( 2007 ) .",
    "combinatorial optimisation of worm propagation on an unknown network .",
    "_ international journal in computer science _ , 2 ( 2 ) , pp .",
    "124130 , 2007 .",
    "eric filiol ( 2007 ) .",
    "formalisation and implementation aspects of @xmath14-ary ( malicious ) codes .",
    "_ journal in computer virology _ ,",
    "3 , issue 3 .",
    "springer verlag .",
    "eric filiol ( 2007 ) .",
    "zero knowledge - like proof of cryptanalysis of bluetooth encryption . _",
    "international journal in information theory _ , 3 ( 4 ) , pp .",
    "40ff , http://www.waset.org/journals/ijit/v3/v3-4-40.pdf eric filiol and fred raynal ( 2008)._malicious cryptography ... reloaded - and also malicious statistics_. cansecwest conference , vancouver , canada , march 2008 .",
    "available on http://cansecwest.com/csw08/csw08-raynal.pdf eric filiol .",
    "the malware of the future : when mathematics are on the bad side .",
    "_ opening keynote talk _ , hack.lu 2008 , luxembourg , october 2008 .",
    "available on the hack.lu website .",
    "eric filiol ( 2010 ) anti - forensics techniques based on malicious cryptography . in : _ proceedings of the 9th european conference in information warfare eciw 2010 _ , thessaloniki , greece .",
    "eric filiol ( 2010 ) dynamic cryptographic trapdoors . submitted .",
    "shafi goldwasser and guy n. rothblum ( 2007 ) . on best - possible obfuscation . in : _ proceedings of the 4th theory of cryptography conference - tcc07_. lncs 4392 ,",
    "194213 , springer verlag .",
    "donald e. knuth ( 1998 ) .",
    "_ the art of computer programming : seminumerical algorithms _ , volume 2 , addison - wesley .",
    "libthor website ( 2010 ) _ playing with virology for fun and profit _ http://libthor.avcave.org .",
    "available on october 2010 .",
    "perseus homepage .",
    "james riordan and bruce schneier ( 1998 ) . environmental key generation towards clueless agents . in : _ mobile agents and security _ , g. vigna ed . ,",
    "lecture notes in computer science , pp . 1524 , springer verlag .",
    "adam young and moti yung ( 1999 ) . _ malicious cryptography - exposing cryptovirology_. wiley .",
    "isbn 0 - 7645 - 4975 - 8 ."
  ],
  "abstract_text": [
    "<S> fighting against computer malware require a mandatory step of reverse engineering . </S>",
    "<S> as soon as the code has been disassemblied / decompiled ( including a dynamic analysis step ) , there is a hope to understand what the malware actually does and to implement a detection mean . </S>",
    "<S> this also applies to protection of software whenever one wishes to analyze them . in this paper , we show how to amour code in such a way that reserse engineering techniques ( static and dymanic ) are absolutely impossible by combining malicious cryptography techniques developped in our laboratory and new types of programming ( k - ary codes ) . </S>",
    "<S> suitable encryption algorithms combined with new cryptanalytic approaches to ease the protection of ( malicious or not ) binaries , enable to provide both total code armouring and large scale polymorphic features at the same time . </S>",
    "<S> a simple 400 kb of executable code enables to produce a binary code and around @xmath0 mutated forms natively while going far beyond the old concept of decryptor . </S>"
  ]
}