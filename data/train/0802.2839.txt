{
  "article_text": [
    "many of the recent developments in the area of automated verification , both theoretical and practical , have focussed on infinite - state systems .",
    "although such systems are not , in general , amenable to fully algorithmic analysis , a number of important classes of models with decidable problems have been identified .",
    "several of these classes , such as petri nets , process algebras , process rewrite systems , faulty channel machines , timed automata , and many more , are instances of _ well - structured transition systems _ ,",
    "for which various problems are decidable  see  @xcite for a comprehensive survey .",
    "well - structured transition systems are predicated on the existence of ` compatible well - quasi orders ' , which guarantee , for example , that certain fixed - point computations will terminate , etc .",
    "unfortunately , these properties are often non - constructive in nature , so that although convergence is guaranteed , the rate of convergence is not necessarily known . as a result",
    ", the computational complexity of problems involving well - structured transition systems often remains open .    in this paper",
    ", we are interested in a particular kind of well - structured transition systems , known as faulty channel machines .",
    "a channel machine ( also known as a queue automaton ) consists of a finite - state controller equipped with several unbounded fifo channels ( queues , buffers ) .",
    "transitions of the machine can write messages ( letters ) to the tail of a channel and read messages from the head of a channel .",
    "channel machines can be used , for example , to model distributed protocols that communicate asynchronously .",
    "channel machines , unfortunately , are easily seen to be turing powerful  @xcite , and all non - trivial verification problems concerning them are therefore undecidable . in  @xcite , abdulla and jonsson , and finkel _",
    "et al . _  independently introduced _",
    "lossy channel machines _ as channel machines operating over an unreliable medium ; more precisely , they made the assumption that messages held in channels could at any point vanish nondeterministically .",
    "not only was this a compelling modelling assumption , more adequately enabling the representation of fault - tolerant protocols , for example , but it also endowed the underlying transition systems of lossy channel machines with a well - structure , thanks to higman s lemma  @xcite . as a result , several non - trivial problems , such as control - state reachability , are decidable for lossy channel machines .",
    "abdulla and jonsson admitted in  @xcite that they were unable to determine the complexity of the various problems they had shown to be decidable .",
    "such questions remained open for almost a decade , despite considerable research interest in the subject from the scientific community .",
    "finally , schnoebelen showed in  @xcite that virtually all non - trivial decidable problems concerning lossy channel machines have non - primitive recursive complexity .",
    "this result , in turn , settled the complexity of a host of other problems , usually via reduction from reachability for lossy channel machines .",
    "recently , the relevance of the lossy channel model was further understood when it was linked to a surprisingly complex variant of post s correspondence problem  @xcite .",
    "other models of unreliable media in the context of channel machines have also been studied in the literature . in  @xcite , for example , the effects of various combinations of insertion , duplication , and lossiness errors are systematically examined .",
    "although insertion errors are well - motivated ( as former users of modems over telephone lines can attest ! ) , they were surprisingly found in  @xcite to be theoretically uninteresting : channels become redundant , since read- and write - transitions are continuously enabled ( the former because of potential insertion errors , the latter by assumption , as channels are unbounded ) .",
    "consequently , most verification problems trivially reduce to questions on finite automata .",
    "recently , however , slightly more powerful models of channel machines with insertion errors have appeared as key tools in the study of metric temporal logic ( mtl ) . in  @xcite",
    ", the authors showed that mtl formulas can capture the computations of insertion channel machines _ equipped with primitive operations for testing channel emptiness_. this new class of faulty channel machines was in turn shown to have a non - primitive recursive reachability problem and an undecidable recurrent control - state reachability problem .",
    "consequently , mtl satisfiability and model checking were established to be non - primitive recursive over finite words  @xcite , and undecidable over infinite words  @xcite .",
    "independently of metric temporal logic , the notion of emptiness testing , broadly construed , is a rather old and natural one .",
    "counter machines , for instance , are usually assumed to incorporate primitive zero - testing operations on counters , and likewise pushdown automata are able to detect empty stacks .",
    "variants of petri nets have also explored emptiness testing for places , usually resulting in a great leap in computational power . in the context of channel machines ,",
    "a slight refinement of emptiness testing is _ occurrence testing _ , checking that a given channel contains no occurrence of a particular message , as defined and studied in  @xcite .",
    "emptiness and occurrence testing provide some measure of control over insertion errors , since once a message has been inserted into a channel , it remains there until it is read off it .",
    "our main focus in this paper is the complexity of the _ termination _ problem for insertion channel machines : given such a machine , are all of its computations finite ? we show that termination is non - elementary , yet primitive recursive .",
    "this result is quite surprising , as the closely related problems of reachability and recurrent reachability are respectively non - primitive recursive and undecidable .",
    "moreover , the mere _ decidability _ of termination for insertion channel machines follows from the theory of well - structured transition systems , in a manner quite similar to that for lossy channel machines . in the latter case , however , termination is non - primitive recursive , as shown in  @xcite . obtaining a primitive recursive upper bound for insertion channel machines",
    "has therefore required us to abandon the well - structure and pursue an entirely new approach .    on the practical side ,",
    "one of the main motivations for studying termination of insertion channel machines arises from the safety fragment of metric temporal logic .",
    "safety mtl was shown to be decidable in  @xcite , although no non - trivial bounds on the complexity could be established at the time .",
    "it is not difficult , however , to show that ( non-)termination for insertion channel machines reduces ( in polynomial time ) to satisfiability for safety mtl ; the latter , therefore , is also non - elementary .",
    "we note that in a similar vein , a lower bound for the complexity of satisfiability of an extension of linear temporal logic was given in  @xcite , via a reduction from the termination problem for counter machines with incrementation errors .",
    "in this section , we briefly review some key decision problems for lossy and insertion channel machines ( the latter equipped with either emptiness or occurrence testing ) .",
    "apart from the results on termination and structural termination for insertion channel machines , which are presented in the following sections , all results that appear here are either known or follow easily from known facts .",
    "our presentation is therefore breezy and terse .",
    "background material on well - structured transition systems can be found in  @xcite .",
    "the _ reachability _ problem asks whether a given distinguished control state of a channel machine is reachable .",
    "this problem was shown to be non - primitive recursive for lossy channel machines in  @xcite ; it is likewise non - primitive recursive for insertion channel machines via a straightforward reduction from the latter  @xcite .",
    "the _ termination _ problem asks whether all computations of a channel machine are finite , starting from the initial control state and empty channel contents .",
    "this problem was shown to be non - primitive recursive for lossy channel machines in  @xcite . for insertion channel machines ,",
    "we prove that termination is non - elementary in section  [ sec : non - elem ] and primitive recursive in section  [ sec : prim - rec ] .",
    "the _ structural termination _",
    "problem asks whether all computations of a channel machine are finite , starting from the initial control state but regardless of the initial channel contents .",
    "this problem was shown to be undecidable for lossy channel machines in  @xcite . for insertion channel machines , it is easy to see that termination and structural termination coincide , so that the latter is also non - elementary primitive - recursive decidable .    given a channel machine @xmath0 and two distinguished control states @xmath1 and @xmath2 of @xmath0 , a _ response _",
    "property is an assertion that every @xmath1 state is always eventually followed by a @xmath2 state in any infinite computation of @xmath0 .",
    "note that a counterexample to a response property is a computation that eventually visits @xmath1 and forever avoids @xmath2 afterwards .",
    "the undecidability of response properties for lossy channel machines follows easily from that of structural termination , as the reader may wish to verify .    in the case of insertion channel machines ,",
    "response properties are decidable , albeit at non - primitive recursive cost ( by reduction from reachability ) . for decidability one first shows using the theory of well - structured transition systems that the set of all reachable configurations , the set of @xmath1-configurations , and the set of configurations that have infinite @xmath2-avoiding computations are all effectively computable .",
    "it then suffices to check whether their mutual intersection is empty .",
    "the _ recurrence _ problem asks , given a channel machine and a distinguished control state , whether the machine has a computation that visits the distinguished state infinitely often .",
    "it is undecidable for lossy channel machines by reduction from response , and was shown to be undecidable for insertion channel machines in  @xcite .    finally , _",
    "ctl and ltl model checking _ for both lossy and insertion channel machines are undecidable , which can be established along the same lines as the undecidability of recurrence .",
    "these results are summarised in figure  [ fig : summary_results ] .     !",
    "width 0.7ptc!width 0.7ptc!width 0.7ptc!width 0.7pt & * lossy channel machines * & * insertion channel machines * + reachability & non - primitive recursive & non - primitive recursive + termination & non - primitive recursive & non - elementary / primitive recursive + struct .  term . &",
    "undecidable & non - elementary / primitive recursive + response & undecidable & non - primitive recursive + recurrence & undecidable & undecidable + ctl / ltl & undecidable & undecidable +",
    "a _ channel machine _ is a tuple @xmath3 , where @xmath4 is a finite set of control states , @xmath5 is the initial control state , @xmath6 is a finite channel alphabet , @xmath7 is a finite set of channel names , and @xmath8 is the transition relation , where @xmath9 is the set of transition labels . intuitively , label @xmath10 denotes the writing of message @xmath11 to tail of channel @xmath12 , label @xmath13 denotes the reading of message @xmath11 from the head of channel @xmath12 , label @xmath14 tests channel @xmath12 for emptiness , and label @xmath15 tests channel @xmath12 for the absence ( non - occurrence ) of message @xmath11 .",
    "we first define an _ error - free _ operational semantics for channel machines . given @xmath0 as above , a _ configuration _ of @xmath0 is a pair @xmath16 , where @xmath17 is the control state and @xmath18 gives the contents of each channel .",
    "let us write @xmath19 for the set of possible configurations of @xmath0 .",
    "the rules in @xmath20 induce an @xmath21-labelled transition relation on @xmath19 , as follows :    * @xmath22 yields a transition @xmath23 , where @xmath24 and @xmath25 for @xmath26 . _ in other words , the channel machine moves from control state @xmath2 to control state @xmath27 , writing message @xmath11 to the tail of channel @xmath12 and leaving all other channels unchanged . _ * @xmath28 yields a transition @xmath29 , where @xmath30 and @xmath25 for @xmath26 . _ in other words ,",
    "the channel machine reads message @xmath11 from the head of channel @xmath12 while moving from control state @xmath2 to control state @xmath27 , leaving all other channels unchanged . _ * @xmath31 yields a transition @xmath32 , provided @xmath33 is the empty word . _ in other words , the transition is only enabled if channel @xmath12 is empty ; all channel contents remain the same .",
    "_ * @xmath34 yields a transition @xmath35 , provided @xmath11 does not occur in @xmath33 . _ in other words , the transition is only enabled if channel @xmath12 contains no occurrence of message @xmath11 ; all channels remain unchanged . _    if the only transitions allowed are those listed above , then we call @xmath0 an _ error - free _ channel machine .",
    "this machine model is easily seen to be turing powerful  @xcite . as discussed earlier , however , we are interested in channel machines with ( potential ) _ insertion errors _ ; intuitively , such errors are modelled by postulating that channels may at any time acquire additional messages interspersed throughout their current contents .    for our purposes , it is convenient to adopt the _ lazy _ model of insertion errors , given next .",
    "slightly different models , such as those of @xcite , have also appeared in the literature .",
    "as the reader may easily check , all these models are equivalent insofar as reachability and termination properties are concerned .",
    "the lazy operational semantics for channel machines with insertion errors simply augments the transition relation on @xmath19 with the following rule :    * @xmath28 yields a transition @xmath36 . _ in other words , insertion errors occur ` just in time ' , immediately prior to a read operation ; all channel contents remain unchanged .",
    "_    the channel machines defined above are called _ insertion channel machines with occurrence testing _ , or",
    "_ _ icmot__s",
    ". we will also consider _ insertion channel machines with emptiness testing _ , or _",
    "_ icmet__s .",
    "the latter are simply icmots without any occurrence - testing transitions ( i.e. , transitions labelled with @xmath15 ) .",
    "a _ run _ of an insertion channel machine is a finite or infinite sequence of transitions of the form @xmath37 that is consistent with the lazy operational semantics .",
    "the run is said to start from the initial configuration if the first control state is @xmath38 and all channels are initially empty .",
    "our main focus in this paper is the study of the complexity of the _ termination _ problem : given an insertion channel machine @xmath0 , are all runs of @xmath0 starting from the initial configuration finite ?",
    "in this section , we show that the termination problem for insertion channel machines  icmets and icmots  is non - elementary .",
    "more precisely , we show that the termination problem for icmets of size @xmath39 in the worst case requires time at least @xmath40 .",
    ", known as tetration , denotes an exponential tower of @xmath41s of height @xmath42 . ] note that the same immediately follows for icmots .",
    "our proof proceeds by reduction from the termination problem for two - counter machines in which the counters are tetrationally bounded ; the result then follows from standard facts in complexity theory ( see , e.g. ,  @xcite ) .    without insertion errors ,",
    "it is clear that a channel machine can directly simulate a two - counter machine simply by storing the values of the counters on one of its channels . to simulate a counter machine in the presence of insertion errors , however , we require periodic integrity checks to ensure that the representation of the counter values has not been corrupted .",
    "below we give a simulation that follows the ` yardstick ' construction of meyer and stockmeyer  @xcite : roughly speaking , we use an @xmath42-bounded counter to check the integrity of a @xmath43-bounded counter .    [ lower_bound_theorem ] the termination problem for icmets and icmots is non - elementary .",
    "let us say that a counter is @xmath42-bounded if it can take values in @xmath44 .",
    "we assume that such a counter @xmath45 comes equipped with procedures @xmath46 , @xmath47 , @xmath48 , and @xmath49 , where @xmath50 and @xmath51 operate modulo @xmath42 , and increment , resp .",
    "decrement , the counter .",
    "we show how to simulate a deterministic counter machine @xmath52 of size @xmath39 equipped with two @xmath53-bounded counters by an icmet @xmath0 of size @xmath54 .",
    "we use this simulation to reduce the termination problem for @xmath52 to the termination problem for @xmath0 .    by induction , assume that we have constructed an icmet @xmath55 that can simulate the operations of a @xmath56-bounded counter @xmath57 . we assume that @xmath55 correctly implements the operations @xmath58 , @xmath59 , @xmath60 , and @xmath61 ( in particular , we assume that the simulation of these operations by @xmath55 is guaranteed to terminate ) .",
    "we describe an icmet @xmath62 that implements a @xmath63-bounded counter @xmath64 .",
    "@xmath62 incorporates @xmath55 , and thus can use the above - mentioned operations on the counter @xmath57 as subroutines .",
    "in addition , @xmath62 has two extra channels @xmath12 and @xmath65 on which the value of counter @xmath64 is stored in binary .",
    "we give a high - level description .",
    "we say that a configuration of @xmath62 is _ clean _ if channel @xmath12 has size @xmath56 and channel @xmath65 is empty .",
    "we ensure that all procedures on counter @xmath64 operate correctly when they are invoked in clean configurations of @xmath62 , and that they also yield clean configurations upon completion .",
    "in fact , we only give details for the procedure @xmath66see figure  [ fig : inc ] ; the others should be clear from this example .",
    "* procedure * @xmath66    @xmath60    * repeat *    @xmath67  / * increment counter @xmath64 while transferring @xmath12 to @xmath65 * /    @xmath58    * until * @xmath61 or @xmath68    * while * not @xmath61 * do *    @xmath69   / * transfer remainder of @xmath12 to @xmath65 * /    @xmath58    * endwhile *    @xmath70   / * check that there were no insertion errors on @xmath12 , otherwise halt * /    * repeat *    @xmath71   / * transfer @xmath65 back to @xmath12 * /    @xmath58    * until * @xmath61    @xmath72    / * check that there were no insertion errors on @xmath65 , otherwise halt * /    @xmath73    since the counter @xmath57 is assumed to work correctly , the above procedure is guaranteed to terminate , having produced the correct result , in the absence of any insertion errors on channels @xmath12 or @xmath65 . on the other hand , insertion errors on either of these channels will be detected by one of the two emptiness tests , either immediately or in the next procedure to act on them .    the initialisation of the induction is handled using an icmet @xmath74 with no channel ( in other words , a finite automaton ) of size @xmath41 , which can simulate a @xmath41-bounded counter ( i.e. , a single bit ) . the finite control of the counter machine , likewise , is duplicated using a further channel - less icmet .    using a product construction ,",
    "it is straightforward to conflate these various icmets into a single one , @xmath0 , of size exponential in @xmath39 ( more precisely : of size @xmath54 ) .",
    "as the reader can easily check , @xmath52 has an infinite computation iff @xmath0 has an infinite run .",
    "the result follows immediately .",
    "the central result of our paper is the following :    [ upper_bound_theorem ] the termination problem for icmots and icmets is primitive recursive . more precisely , when restricting to the class of icmots or icmets that have at most @xmath75 channels , the termination problem is in @xmath76-expspace .    in what follows , we sketch the proof for icmots , icmets being a special case of icmots .",
    "let us also assume that our icmots do not make use of any emptiness tests ; this restriction is harmless since any emptiness test can always be replaced by a sequence of occurrence tests , one for each letter of the alphabet , while preserving termination .",
    "let @xmath77 be a fixed icmot without emptiness tests ; in other words , @xmath0 s set of transition labels is @xmath78 .",
    "our strategy is as follows : we suppose that @xmath0 has no infinite runs , and then derive an upper bound on the length of the longest possible finite run .",
    "the result follows by noting that the total number of possible runs is exponentially bounded by this maximal length .    for a subset @xmath79 of channels",
    ", we define an equivalence @xmath80 over the set @xmath19 of configurations of @xmath0 as follows : @xmath81    let us write @xmath82 to denote the set @xmath83 of equivalence classes of @xmath19 with respect to @xmath80 .",
    "furthermore , given @xmath84 a ` bounding function ' for the channels in @xmath85 , let @xmath86_d \\in \\mathit{conf}_d : |u(d)| \\leq f(d)\\ \\text{for every}\\ d \\in d\\}\\ ] ] be the subset of @xmath82 consisting of those equivalence classes of configurations whose @xmath85-channels are bounded by @xmath87 . as the reader can easily verify , we have the following bound on the cardinality @xmath88 of @xmath89 : @xmath90    consider a finite run @xmath91 of @xmath0 ( with @xmath92 ) , where each @xmath93 is a configuration and each @xmath94 is a transition label .",
    "we will occasionally write @xmath95 to denote such a run , where @xmath96 .",
    "we first state a pumping lemma of sorts , whose straightforward proof is left to the reader :    [ lem - iteration ] let @xmath79 be given , and assume that @xmath97 ( with @xmath98 ) is a run of @xmath0 such that @xmath99 .",
    "suppose further that , for every label @xmath100 occurring in @xmath101 , either @xmath102 , or the label @xmath10 does not occur in @xmath101 .",
    "then @xmath101 is repeatedly firable from @xmath103 , i.e. , there exists an infinite run @xmath104 .",
    "note that the validity of lemma  [ lem - iteration ] rests crucially on ( the potential for ) insertion errors .",
    "let @xmath105 be a finite sequence , and let @xmath106 be a real number .",
    "a set @xmath107 is said to be @xmath108-frequent in the sequence @xmath109 if the set @xmath110 has cardinality at least @xmath111 .",
    "the next result we need is a technical lemma guaranteeing a certain density of repeated elements in an @xmath108-frequent sequence :    [ lem - density ] let @xmath105 be a finite sequence , and assume that @xmath107 is a finite @xmath108-frequent set in @xmath112 .",
    "then there exists a sequence of pairs of indices @xmath113 such that , for all @xmath114 , we have @xmath115 , @xmath116 , and @xmath117 .    by assumption , @xmath118 has a subsequence of length at least @xmath111 consisting exclusively of elements of @xmath107 .",
    "this subsequence , in turn , contains at least @xmath119 disjoint ` blocks ' of length @xmath120 . by the pigeonhole principle , each of these blocks contains at least two identical elements from @xmath107 , yielding a sequence of pairs of indices @xmath121 having all the required properties apart , possibly , from the requirement that @xmath122 .",
    "note also that there are , for now , twice as many pairs as required .",
    "consider therefore the half of those pairs whose difference is smallest , and let @xmath1 be the largest such difference .",
    "since the other half of pairs in the sequence @xmath123 have difference at least @xmath1 , and since there is no overlap between indices , we have @xmath124 , from which we immediately derive that @xmath1 is bounded by @xmath125 , as required .",
    "this concludes the proof of lemma  [ lem - density ] .",
    "recall our assumption that @xmath0 has no infinite run , and let @xmath126 be any finite run of @xmath0 , starting from the initial configuration ; we seek to obtain an upper bound on @xmath39 .    given a set @xmath79 of channels",
    ", it will be convenient to consider the sequence @xmath127_d = \\langle [ \\sigma_i]_d \\rangle_{0 \\leq i \\leq n}$ ] of equivalence classes of configurations in @xmath128 modulo @xmath80 ( ignoring the interspersed labelled transitions for now ) .",
    "let @xmath129 and @xmath106 be given , and suppose that @xmath130 is @xmath108-frequent in @xmath127_c$ ] , so that there are at least @xmath111 occurrences of configuration equivalence classes in @xmath130 along @xmath127_c$ ] . recall that @xmath130 contains @xmath131 elements .",
    "observe , by lemma  [ lem - iteration ] , that no member of @xmath130 can occur twice along @xmath127_d$ ] , otherwise @xmath0 would have an infinite run .",
    "consequently , @xmath132    we will now inductively build an increasing sequence @xmath133 , as well as functions @xmath134 and real numbers @xmath135 , for @xmath136 , such that @xmath137 is @xmath138-frequent in @xmath127_{d_i}$ ] for every @xmath139 . the base case is straightforward : the set @xmath140 is clearly @xmath141-frequent in @xmath127_\\emptyset$ ] .",
    "let us therefore assume that @xmath89 is @xmath108-frequent in @xmath127_d$ ] for some strict subset @xmath85 of @xmath7 and some @xmath84 and @xmath142 .",
    "we now compute @xmath143 strictly containing @xmath85 , @xmath144 , and @xmath145 such that @xmath146 is @xmath147-frequent in @xmath127_{d'}$ ] .",
    "thanks to our induction hypothesis and lemma  [ lem - density ] , we obtain a sequence of pairs of configurations @xmath148 , where @xmath149 , @xmath150_d = [ \\theta'_j]_d \\in \\mathit{conf}_d^f$ ] , and such that @xmath151 with each @xmath152 having length no greater than @xmath153 , for @xmath154 .    for each @xmath155",
    ", let @xmath156 be the set of occurrence - test labels that occur at least once in @xmath155 . among these sets , let @xmath157 denote the one that appears most often . note that there are @xmath158 different possible sets of occurrence - test labels , and therefore at least @xmath159 of the @xmath156 are equal to @xmath157 .    following a line of reasoning entirely similar to that used in lemma  [ lem - density ] , as follows .",
    "write the sequence of transition labels of @xmath128 as @xmath160 , with the @xmath161 as above .",
    "next , formally replace each instance of @xmath161 whose set of occurrence - test labels is @xmath157 by a new symbol @xmath162 ; if needed , add dummy non-@xmath162 symbols to the end of the sequence to bring its length up to @xmath39 , and call the resulting sequence @xmath109 .",
    "finally , note that the singleton set @xmath163 is @xmath164-frequent in @xmath112 .",
    "] , we can deduce that @xmath128 contains at least @xmath165 non - overlapping patterns of the form @xmath166 where :    * @xmath167_d = [ \\theta']_d \\in \\mathit{conf}_d^f$ ] and @xmath168_d = [ \\bar{\\theta}']_d \\in \\mathit{conf}_d^f$ ] , * @xmath169 each have length no greater than @xmath153 , * @xmath170 has length no greater than @xmath171 , and * the set of occurrence - test labels occurring in @xmath101 and @xmath172 in both cases is @xmath157 .",
    "consider such a pattern . observe that @xmath101 must contain at least one occurrence - test label @xmath173 with @xmath174 and such that the label @xmath10 occurs in @xmath101 , otherwise @xmath0 would have an infinite run according to lemma  [ lem - iteration ] .",
    "pick any such occurrence - test label and let us denote it @xmath173 .",
    "we now aim to bound the size of channel @xmath12 in the @xmath175 configuration of our patterns .",
    "note that since @xmath101 and @xmath172 contain the same set of occurrence - test labels , the label @xmath173 occurs in @xmath172 .",
    "that is to say , somewhere between configurations @xmath175 and @xmath176 , we know that channel @xmath12 did not contain any occurrence of @xmath11 . on the other hand , an @xmath11 was written to the tail of channel @xmath12 at some point between configurations @xmath177 and @xmath178 , since @xmath101 contains the label @xmath10 . for that @xmath11 to be subsequently read off the channel",
    ", the whole contents of channel @xmath12 must have been read from the time of the @xmath10 transition in @xmath101 to the time of the @xmath100 transition in @xmath172 . finally , note that , according to our lazy operational semantics , the size of a channel changes by at most 1 with each transition .",
    "it follows that the size of channel @xmath12 in configuration @xmath175 is at most @xmath179 .",
    "let @xmath180 , and define the bounding function @xmath181 such that @xmath182 for all @xmath183 , and @xmath184 . from our lower bound on the number of special patterns ,",
    "we conclude that the set @xmath146 is @xmath147-frequent in @xmath127_{d'}$ ] , where @xmath185 .",
    "we now string everything together to obtain a bound on @xmath39 , the length of our original arbitrary run @xmath128 . for convenience ,",
    "let @xmath186 be an enumeration of the channel names in @xmath7 in the order in which they are picked in the course of our proof ; thus @xmath187 for @xmath188 .",
    "correspondingly , let @xmath189 , for @xmath136 , with the convention that @xmath190 ; it is easy to see that @xmath191 is the maximum value of @xmath192 over @xmath193 , since the sequences @xmath194 and @xmath195 are monotonically increasing and decreasing respectively .    from equation",
    "[ gamma - bound ] , we easily get that @xmath196 , where @xmath197 is any reasonable measure of the size of our icmot @xmath0 . combining this with our expressions for @xmath198 and @xmath147 above",
    ", we obtain that @xmath199 for @xmath200 .",
    "this , in turns , lets us derive bounds for @xmath201 and @xmath202 , which imply , together with equation  [ n - bound ] , that @xmath203 where @xmath204 is some polynomial ( independent of @xmath0 ) , and the total height of the tower of exponentials is @xmath205 .",
    "the icmot @xmath0 therefore has an infinite run iff it has a run whose length exceeds the above bound . since the lazy operational semantics is finitely branching ( bounded , in fact , by the size of the transition relation ) , this can clearly be determined in @xmath206-expspace , which concludes the proof of theorem  [ upper_bound_theorem ] .",
    "theorems  [ lower_bound_theorem ] and [ upper_bound_theorem ] immediately entail the following :    the structural termination problem  are all computations of the machine finite , starting from the initial control state but regardless of the initial channel contents ?",
    "is decidable for icmets and icmots , with non - elementary but primitive - recursive complexity .",
    "the main result of this paper is that termination for insertion channel machines with emptiness or occurrence testing has non - elementary , yet primitive recursive complexity .",
    "this result is in sharp contrast with the equivalent problem for lossy channel machines , which has non - primitive recursive complexity .",
    "we remark that the set of configurations from which a given insertion channel machine has at least one infinite computation is finitely representable ( thanks to the theory of well - structured transition systems ) , and is in fact computable as the greatest fixed point of the pre - image operator .",
    "the proof of theorem  [ upper_bound_theorem ] , moreover , shows that this fixed point will be reached in primitive - recursively many steps .",
    "the set of configurations from which there is an infinite computation is therefore primitive - recursively computable , in contrast with lossy channel machines for which it is not even recursive ( as can be seen from the undecidability of structural termination ) .",
    "finally , another interesting difference with lossy channel machines can be highlighted by quoting a slogan from  @xcite : `` _ _ lossy systems with @xmath75 channels can be [ polynomially ] encoded into lossy systems with one channel .",
    "_ _ '' we can deduce from theorems  [ lower_bound_theorem ] and [ upper_bound_theorem ] that any such encoding , in the case of insertion channels machines , would require non - elementary resources to compute , if it were to preserve termination properties .",
    "parosh  aziz abdulla and bengt jonsson . verifying programs with unreliable channels . in _ proc .",
    "8th annual symposium on logic in computer science ( lics93 ) _ , pages 160170 .",
    "ieee computer society press , 1993 .",
    "pierre chambart and philippe schnoebelen .",
    "ost embedding problem is not primitive recursive , with applications to channel systems . in _ proc .",
    "27th international conference on foundations of software technology and theoretical computer science ( fsttcs07 ) _ , volume 4855 of _ lecture notes in computer science _ , pages 265276 .",
    "springer , 2007 .",
    "ranko lazi .",
    "safely freezing ltl . in _ proc .",
    "26th international conference on foundations of software technology and theoretical computer science ( fsttcs06 ) _ , volume 4337 of _ lecture notes in computer science _ , pages 381392 .",
    "springer , 2006 .",
    "ranko lazi , thomas  c. newcomb , jol ouaknine , a.  w. roscoe , and james worrell .",
    "nets with tokens which carry data . in _ proc .",
    "28th international conference on application and theory of petri nets ( icatpn07 ) _ , volume 4546 of _ lecture notes in computer science _ , pages 301320 .",
    "springer , 2007 .",
    "jol ouaknine and james worrell . on the decidability of metric temporal logic . in _ proc .",
    "19th annual symposium on logic in computer science ( lics05 ) _ , pages 188197 .",
    "ieee computer society press , 2005 .",
    "jol ouaknine and james worrell . on metric temporal logic and faulty turing machines . in _ proc .",
    "9th international conference on foundations of software science and computation structures ( fossacs06 ) _ , volume 3921 of _ lecture notes in computer science _ , pages 217230 .",
    "springer , 2006 .",
    "jol ouaknine and james worrell .",
    "safety metric temporal logic is fully decidable . in _ proc .",
    "12th international conference on tools and algorithms for the construction and analysis of systems ( tacas06 ) _ , volume 3920 of _ lecture notes in computer science _ , pages 411425 .",
    "springer , 2006 ."
  ],
  "abstract_text": [
    "<S> a _ channel machine _ consists of a finite controller together with several fifo channels ; the controller can read messages from the head of a channel and write messages to the tail of a channel . in this paper </S>",
    "<S> , we focus on channel machines with _ insertion errors _ , i.e. , machines in whose channels messages can spontaneously appear . </S>",
    "<S> such devices have been previously introduced in the study of metric temporal logic . </S>",
    "<S> we consider the _ termination _ problem : are all the computations of a given insertion channel machine finite ? we show that this problem has non - elementary , yet primitive recursive complexity .    </S>",
    "<S> patricia bouyer    nicolas markey    jol ouaknine    philippe schnoebelen    james worrell </S>"
  ]
}