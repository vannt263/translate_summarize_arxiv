{
  "article_text": [
    "the situation when we must search for the position of a value @xmath3 in many ordered sets frequently arises in data structures and computational geometry problems .",
    "the brute force approach of searching for @xmath3 in every set `` from scratch '' can be improved if there are restrictions on the order in which the sets can be searched .",
    "such improvements for some important problems were suggested by several researchers , see e.g. ,  @xcite .",
    "chazelle and guibas described in their seminal paper  @xcite a general data structuring technique , called fractional cascading , that addresses the general problem of searching in multiple sets .",
    "the fractional cascading technique solves the following iterative search problem : we are given a graph @xmath18 , called the catalog graph , so that an ordered set @xmath19 , called a catalog , is associated with every graph node .",
    "a query consists of an element @xmath20 and a subgraph @xmath21 of @xmath18 .",
    "the goal is to find the predecessor in @xmath22 , denoted @xmath23 , is the largest @xmath24 such that @xmath25 ; the successor of @xmath3 in @xmath22 , denoted @xmath26 , is the smallest @xmath24 such that @xmath27 .",
    "] of @xmath3 in _ each _ catalog @xmath1 for @xmath28 . in this paper",
    "we consider the following modification of the iterative search , further called _ multiple catalog searching _ problem : the graph @xmath18 is a rooted tree , the subgraph @xmath21 is a node - to - root path @xmath4 , and we must search in _ the union of all _ catalogs @xmath1 , @xmath29 .",
    "we also consider the reporting variant , further called multiple catalog reporting , in which all elements @xmath30 , @xmath29 , that belong to the query range @xmath31 $ ] must be reported .",
    "although the problems addressed in this paper are more restrictive than iterative searching , they can be applied in many situations in which iterative searching is traditionally used .",
    "we show that multiple catalog searching and reporting queries can be answered by spending constant time in each node @xmath2 of @xmath4 if @xmath4 is sufficiently large ( ignoring the time to output all elements in the answer ) .",
    "this enables us to obtain for the first time dynamic data structures with optimal query time and poly - logarithmic update time for point location in a set of horizontal segments , stabbing - max , and orthogonal line - segment intersection reporting . +",
    "* previous and related work .",
    "* chazelle and guibas  @xcite showed that it is possible to identify the predecessor of @xmath3 in @xmath1 for _ each _ catalog @xmath1 , @xmath28 , in @xmath32 time , where @xmath33 denotes the total number of elements in all catalogs , @xmath34 is the number of nodes in @xmath21 , and @xmath7 is the time needed to search in one catalog .",
    "the dynamic version of the fractional cascading is considered by mehlhorn and nher  @xcite ; in  @xcite the authors described how to support insertions into and deletions from a catalog @xmath1 in @xmath35 time if a pointer to the deleted element @xmath3 or the predecessor of an inserted element @xmath3 is given ; the data structure of  @xcite supports queries in @xmath36 time , i.e. , the search takes @xmath35 time in each node of @xmath21 . imai and asano  @xcite considered the semi - dynamic scenario , when new elements can be inserted but deletions are not supported .",
    "the result of  @xcite can be used to support insertions in @xmath37 time and search in @xmath38 time in the pointer machine model  @xcite ; another result of  @xcite can be used to support insertions in @xmath39 time and search in @xmath32 time in the ram model . since  @xcite , the dynamic fractional",
    "cascading was applied to a number of data structure problems , e.g. , point location , range reporting , and segment intersection .",
    "the technique was also extended e.g. , to support iterative search in graphs with super - constant local degree  @xcite and to the case when elements stored in different catalogs belong to different ordered sets , e.g.  @xcite",
    ". however , there is no currently known dynamic data structure that supports iterative search in @xmath40 time per catalog ( ignoring the @xmath41 term ) .",
    "since fractional cascading relies on the union - split - find queries , and union - split - find queries can not be answered in @xmath40 time  @xcite , it appears that we must spend @xmath42 time in each node to solve the iterative searching problem . + * our results . *",
    "the fractional cascading  @xcite technique and its variants for the dynamic and semi - dynamic scenarios  @xcite can be applied when the catalog graph is an arbitrary graph with locally bounded degree ( e.g. , any graph with bounded degree ; see  @xcite for precise definition ) . in our scenario",
    "the catalog graph is a rooted tree and all catalogs @xmath1 for all nodes @xmath2 on the path @xmath4 must be searched .",
    "moreover , instead of searching for @xmath3 in _ each _ catalog , we search in _ all _ catalogs",
    ". that is , the query consists of a value @xmath3 and a path @xmath4 between a node @xmath43 and the root of the tree ; the answer to the query is the predecessor @xmath44 of @xmath3 in the union of all catalogs on @xmath4 , @xmath45 .",
    "henceforth , such queries will be called _ multiple catalog searching _ queries .",
    "we obtain the following results with a linear space data structure : + 1 .",
    "multiple catalog searching queries can be answered in @xmath46 time , and updates are supported in @xmath47 time for any @xmath48 .",
    "multiple catalog searching queries can be answered in @xmath49 time , and updates are supported in @xmath35 time . + other trade - offs between query and update times are described in theorem  [ theor : mcs ] .",
    "we assume that a pointer to the position of an inserted or deleted element in the data structure is known for the update operation .",
    "we also consider the multiple catalog reporting problem .",
    "a query consists of values @xmath50 and a path @xmath4 from a node @xmath13 to a node @xmath14 , such that @xmath14 is the ancestor of @xmath13 .",
    "the answer to the query consists of all elements @xmath51 , such that @xmath52 .",
    "multiple catalog reporting queries can be answered in @xmath53 time , where @xmath16 is the number of elements in the answer , and updates are supported in @xmath47 time for any @xmath48 .",
    "multiple catalog reporting queries can be answered in @xmath54 time , where @xmath16 is the number of elements in the answer , and updates are supported in @xmath35 time .",
    "+ again , the space usage of our data structure is linear in the total number of elements in all catalogs .",
    "other trade - offs between query and update times are described in theorem  [ theor : mcrep ] .",
    "dynamic range reporting in a single catalog was considered in  @xcite .",
    "the data structure of  @xcite supports queries and updates in @xmath55 and @xmath56 time respectively , where @xmath57 is the size of the universe .",
    "another variant of their data structure supports queries in @xmath39 time and updates in @xmath58 time .",
    "besides that , the data structure described in  @xcite uses randomization and relies on a more extensive set of basic arithmetic operations .",
    "finally , we consider the multiple catalog maxima problem .",
    "a query consists of a path @xmath4 from a node @xmath13 to a node @xmath14 , such that @xmath14 is the ancestor of @xmath13 ; we must output the maximal element in every catalog @xmath1 , @xmath59 . for a tree with node degree @xmath60",
    "such queries can be answered in @xmath61 time .",
    "insertions and deletions are supported in @xmath62 and @xmath63 time respectively .",
    "moreover , in this case we extend the definition of update operations , so that an element can be simultaneously inserted into ( deleted from ) any catalogs @xmath64 where @xmath65 are sibling nodes .",
    "this result , described in section  [ sec : mcmax ] , is obtained with a different , simpler technique .",
    "+ * applications . * as an illustration of our technique , we present dynamic data structures for several problems that for the first time achieve @xmath66 query time in the word ram model .",
    "the marked ancestor problem  @xcite can be reduced to each of the problems described below , see  @xcite . in  @xcite",
    ", the authors also show that any data structure with poly - logarithmic update time and poly - logarithmic word size needs @xmath67 time to answer the marked ancestor problem .",
    "hence , we obtain data structures with optimal query time for all considered problems . + * horizontal point location . * in the horizontal point location problem aka vertical ray shooting problem , a set of @xmath33 horizontal segments is stored in the data structure , so that for a query point @xmath68 the segment immediately below ( or immediately above ) @xmath68 can be reported .",
    "giyora and kaplan  @xcite describe a linear space ram data structure with @xmath69 query and update times in the ram model .",
    "we refer to  @xcite for a detailed description of previous results .",
    "although the @xmath69 time is optimal if we can manipulate segments by comparing their coordinates , the query time can be improved in the word ram model . in this paper",
    "we present a data structure that supports queries in @xmath17 time and updates in @xmath70 amortized time ; our data structure uses @xmath71 space .",
    "as explained above , this query time is optimal . + * retroactive searching .",
    "* in the retroactive searching problem , introduced by demaine et.al .",
    "@xcite , the data structure maintains a sequence of keys .",
    "each key can be inserted at time @xmath72 and deleted at time @xmath73 .",
    "the answer to a query @xmath74 is the element that precedes @xmath68 at time @xmath75 .",
    "it was shown in  @xcite that retroactive searching is equivalent to the horizontal point location problem .",
    "thus our result for horizontal point location demonstrates that retroactive searching queries can be answered in @xmath17 time in the word ram model . +",
    "* stabbing - max data structure .",
    "* in the stabbing - max problem , we maintain a set of axis - parallel @xmath76-dimensional rectangles , and each rectangle @xmath77 has priority @xmath78 .",
    "given a query point @xmath68 , the stabbing - max data structure finds a rectangle with maximum priority that contains @xmath68 .",
    "the one - dimensional data structure of kaplan , molad , and tarjan  @xcite supports queries and insertions in @xmath69 time , deletions in @xmath79 time , and uses @xmath71 space .",
    "the data structure of agarwal , arge , and yi  @xcite also uses linear space and supports queries and updates in @xmath69 time .",
    "see  @xcite for a more extensive description of previous results .    in this paper",
    "we describe two data structures that support one - dimensional stabbing - max queries in optimal @xmath17 time .",
    "the first data structure uses @xmath80 space and supports insertions and deletions in @xmath69 and @xmath81 time respectively .",
    "the second data structure uses @xmath71 space but supports updates in @xmath70 time .",
    "+ * orthogonal line - segment intersection . * in this problem a set of horizontal segments is stored in a data structure , so that for a vertical query segment @xmath82 all segments that intersect with @xmath82 can be reported .",
    "the data structure of cheng and janardan  @xcite supports such queries in @xmath83 , where @xmath16 is the number of segments in the answer .",
    "mehlhorn and nher reduced the query time to @xmath84 using dynamic fractional cascading .",
    "the fastest previously known data structure of mortensen  @xcite supports queries and updates in @xmath85 and @xmath69 time respectively and uses @xmath80 space . in this paper",
    "we present a @xmath86 space data structure that answers queries in @xmath87 time and supports updates in @xmath70 time .",
    "all results presented in this paper are valid in the word ram computation model .",
    "we assume that every element ( resp .",
    "every point ) fits into one machine word and that additions , subtractions , and bit operations can be performed in constant time .",
    "we also assume that the most significant bit ( msb ) of an integer can be found in @xmath39 time .",
    "it is possible to find msb in @xmath39 time using @xmath88 operations  @xcite . throughout this paper @xmath89",
    "denotes an arbitrarily small positive constant .",
    "in this section we sketch the main ideas of our approach .",
    "we start by showing how the fractional cascading technique can be used to solve the multiple catalog searching problem .",
    "then , we describe the difference between the fractional cascading and our approach .    we construct augmented catalogs @xmath90 for all nodes @xmath2 of @xmath0 starting at the root . for the root @xmath91 ,",
    "@xmath92 . if @xmath93 for a node @xmath43 is already constructed , then @xmath94 for a child @xmath95 of @xmath43 consists of some elements from @xmath93 and all elements of @xmath96 .",
    "elements of @xmath97 and @xmath98 are called proper elements and improper elements respectively . for every improper element @xmath99",
    ", there is a copy @xmath100 of @xmath101 that is stored in @xmath102 .",
    "elements @xmath101 and @xmath100 are provided with pointers to each other and are called a _ bridge_. we want to organize the search procedure in such way that only a small number of elements in every visited node must be examined .",
    "using fractional cascading , we can guarantee that there are @xmath103 elements of @xmath104 between any two improper elements of @xmath105 , where @xmath2 is any node of @xmath0 except of the root and @xmath106 is the parent of @xmath2 .",
    "each element stored in the augmented catalog @xmath105 belongs either to @xmath1 or to a catalog @xmath107 for some ancestor @xmath106 of @xmath2 .",
    "hence , @xmath108 for any node - to - root path @xmath109 . therefore multiple catalog searching ( unlike general iterative searching ) is equivalent to finding the predecessor in @xmath110 .",
    "this suggests the following method for searching in @xmath5 : the search procedure starts by identifying @xmath111 and @xmath112 . for every node @xmath113 , @xmath114 , we find @xmath115 and @xmath116 .",
    "suppose that @xmath117 and @xmath118 for some @xmath119 are known .",
    "to identify @xmath120 and @xmath121 , we only need to examine elements of @xmath122 that belong to the interval @xmath123 $ ] . since there is no element @xmath124 between @xmath117 and @xmath118 , there are @xmath103 elements of @xmath122 between @xmath117 and @xmath118 , where @xmath76 is the maximal node degree of @xmath0 . for @xmath125 , we can search in a set of @xmath103 elements in @xmath39 time  @xcite .",
    "the only issue is how to quickly find elements of @xmath122 that are between @xmath117 and @xmath118 .",
    "let @xmath126 be the bridge that precedes @xmath117 and let @xmath127 be the bridge that follows @xmath118 ; there are @xmath103 elements between @xmath126 and @xmath127 in @xmath122 . bridges @xmath126 and @xmath127 can be found by storing proper and improper elements of @xmath128 as proper and auxiliary elements in a union - split - find data structure .",
    "unfortunately , we would need @xmath42 time to identify @xmath126 because of the lower bound of  @xcite .",
    "our solution does not rely on bridges and union - split - find data structures during the search procedure . instead",
    ", we construct additional catalogs @xmath129 in each node @xmath43 .",
    "catalogs @xmath130 are constructed in a leaf - to - root order : for a leaf node @xmath131 , @xmath132 ; for an internal node @xmath43 , @xmath129 contains all elements of @xmath93 and some elements from catalogs @xmath133 , where @xmath95 are the children of @xmath43 .",
    "we guarantee that at least one element from a sequence of @xmath134 consecutive elements in @xmath129 also belongs to @xmath135 for any node @xmath43 .",
    "this allows us to identify the elements @xmath126 and @xmath127 that precede @xmath117 and follow @xmath118 in @xmath136 in @xmath39 time .",
    "hence , we can quickly navigate from a node to its parent . on the other hand",
    ", a catalog @xmath137 , @xmath138 , can contain a large number of elements that are not relevant for the search procedure , i.e. , elements from some catalogs @xmath107 , such that @xmath106 is a descendant of @xmath113 and @xmath139 .",
    "hence , there can be an arbitrarily large number of elements in @xmath140 $ ] .",
    "however , we can show that the number of elements in @xmath141 $ ] is bounded .",
    "we store a data structure @xmath142 in every node @xmath2 of @xmath0 .",
    "for any two elements @xmath143 and @xmath144 , the data structure @xmath142 identifies an element @xmath145 such that @xmath146 , or determines that such @xmath147 does not exist .",
    "the data structure @xmath142 combines the approach of the dynamic range reporting data structure  @xcite and the labeling technique  @xcite ; details can be found in section  [ sec : mcs ] .",
    "using @xmath142 , we can identify relevant elements in every visited node on the search path @xmath4 .",
    "* overview . * in this section we give a more detailed description of the approach sketched in section  [ sec : overview ] .",
    "every node @xmath2 contains a catalog @xmath1 and an augmented catalog @xmath148 . for the root @xmath91 , @xmath149 . the augmented catalog for a non - root node @xmath2 contains some elements from catalogs @xmath104 for ancestors @xmath106 of @xmath2 , so",
    "that the following statement is true :    [ prop : fc ] let @xmath150 be a child of an internal node @xmath43 .",
    "suppose that for two elements @xmath151 and @xmath152 there is no @xmath153 such that @xmath154 .",
    "then there are @xmath103 elements @xmath155 , such that @xmath156 .    here and",
    "further @xmath76 denotes the maximal node degree of @xmath0 . using the standard fractional cascading technique  @xcite",
    ", we can construct and maintain catalogs @xmath105 that satisfy property  [ prop : fc ] .",
    "each node @xmath2 also contains a catalog @xmath157 .",
    "each catalog @xmath130 is subdivided into blocks @xmath158 , so that ( 1 ) any element in a block @xmath158 is smaller than any element in a block @xmath159 for @xmath160 , and ( 2 ) each block , except of the last one , contains more than @xmath161 and less than @xmath162 elements ; the last block contains at most @xmath163 elements .",
    "the set @xmath164 consists of first elements from each block @xmath158 of @xmath130 . for a leaf node @xmath165 , @xmath166 . for an internal node @xmath43 , @xmath167 , where the union is taken over all children @xmath150 of @xmath43 .",
    "thus @xmath168 .",
    "each element of @xmath164 and each element in @xmath169 contains a pointer to its copy in @xmath170 called _ the up - pointer_. we denote by @xmath171 the set of all elements in @xmath130 that have up - pointers , i.e. , @xmath172 .",
    "thus @xmath171 consists of first elements in every block of @xmath130 and improper elements from @xmath105 .",
    "see fig .",
    "[ fig : oacstruct ] . by a slight misuse of notation",
    ", we will sometimes denote the elements of @xmath171 as up - pointers .",
    "for each block @xmath158 of every catalog @xmath130 , we store a data structure @xmath173 that enables us to find for any @xmath174 the largest element @xmath175 such that @xmath176 .",
    "such queries can be supported in @xmath39 time because a block contains a poly - logarithmic number of elements .",
    "an example of blocks in catalogs @xmath130 and @xmath177 .",
    "elements @xmath169 and elements of @xmath164 are depicted with black circles and light blue circles respectively .",
    "proper elements of @xmath105 are shown with green circles and all other elements of @xmath130 are shown with white circles . ]",
    "we store in each node @xmath2 a data structure @xmath142 that enables us to find an element @xmath178 between any two elements of @xmath130 , or determine that such @xmath101 does not exist .",
    "the data structure the data structure @xmath142 and the following property play a key role in our construction    [ prop : search1 ] let @xmath179 and @xmath180 be two elements of @xmath171 such that there is no element @xmath181 with @xmath182 .",
    "then the catalog @xmath183 contains @xmath103 elements @xmath101 , such that @xmath184 .",
    "property  [ prop : search1 ] is a straightforward corollary of property  [ prop : fc ] : let @xmath185 and @xmath186 . since @xmath187 , @xmath188 .",
    "hence , there is no element of @xmath189 between @xmath190 and @xmath191 .",
    "therefore , by property  [ prop : fc ] , @xmath183 contains @xmath103 elements @xmath101 , such that @xmath156 . since @xmath192 , property  [ prop : search1 ] is true .",
    "we observe that property  [ prop : search1 ] only bounds the number of elements in @xmath193 $ ] .",
    "the number of elements in @xmath194 $ ] can be arbitrarily large .    in the next part of this section",
    "we show how multiple catalog searching queries can be answered if property  [ prop : search1 ] is satisfied .",
    "then , we describe the data structure for a block and the data structure @xmath142 .",
    "finally , we describe the update procedure and sketch the analysis of the space usage and the update time . +",
    "* search procedure .",
    "* let @xmath13 be a node of @xmath0 and let @xmath4 be the path from @xmath13 to the root @xmath91 of @xmath0 .",
    "we will describe the procedure that identifies both the predecessor and the successor of @xmath3 in @xmath195 . in every node @xmath29",
    "we identify elements @xmath196 and @xmath197 , where @xmath198 and @xmath199 is the path from @xmath13 to @xmath2 .",
    "clearly , we can find @xmath200 and @xmath201 in time @xmath41 .",
    "let @xmath202 and @xmath203 be the up - pointers that precede and follow @xmath200 and @xmath201 .",
    "since each block contains at least one up - pointer , we can find @xmath202 and @xmath203 in @xmath39 time .",
    "suppose that we know @xmath117 , @xmath118 , @xmath126 , and @xmath127 for some node @xmath204 , so that @xmath205 and @xmath126 , @xmath127 are up - pointers that satisfy the condition of property  [ prop : search1 ] .",
    "we can find @xmath120 , @xmath121 , @xmath206 , and @xmath207 for the parent @xmath208 of @xmath113 as follows . by property",
    "[ prop : search1 ] , there are at most @xmath103 elements of @xmath122 between @xmath126 and @xmath127 .",
    "since @xmath209 , elements of @xmath122 that do not belong to the interval @xmath210 $ ] are not relevant for our search .",
    "if @xmath141\\not=\\emptyset$ ] , we can identify some @xmath211 , @xmath212 , using the data structure @xmath213 .",
    "we will show in the next paragraph how all elements in @xmath214 $ ] can be examined and compared with @xmath3 , @xmath117 , and @xmath118 in @xmath39 time .",
    "hence , we can identify @xmath120 and @xmath121 in time @xmath39 .",
    "the up - pointers @xmath206 and @xmath207 are the up - pointers that precede @xmath120 in @xmath122 and follow @xmath121 in @xmath122 respectively . otherwise , if @xmath215=\\emptyset$ ] , @xmath216 and @xmath217 . in this case",
    "the up - pointers @xmath206 and @xmath207 are the up - pointers that precede @xmath218 and follow @xmath219 respectively . since every element in @xmath105 belongs either to @xmath1 or to @xmath107 for some ancestor @xmath106 of @xmath2 , @xmath220 .",
    "hence if we know @xmath221 and @xmath222 for the root node @xmath91 , we also know @xmath223 and @xmath224 .    it remains to show how we can find @xmath120 and @xmath121 if @xmath141\\not=\\emptyset$ ] and a pointer to some element @xmath211 , @xmath212 , is given .",
    "suppose that the maximal node degree @xmath225 for a constant @xmath226 .",
    "we divide @xmath105 for each @xmath227 into groups @xmath228 so that each group contains at least @xmath229 and at most @xmath230 elements and store the elements of each group in the atomic heap @xmath231 of fredman and willard  @xcite , so that predecessor queries and updates are supported in @xmath39 time  @xcite .",
    "there are @xmath39 groups @xmath228 , such that @xmath232\\not=\\emptyset$ ] .",
    "hence , we can find the largest index @xmath233 , such that the first element in @xmath234 is smaller than @xmath3 in @xmath39 time . using @xmath235",
    ", we find the predecessor @xmath236 of @xmath3 in @xmath234 .",
    "if @xmath236 is larger than @xmath117 , we set @xmath237 ; otherwise @xmath216 .",
    "hence , we can find @xmath120 in @xmath39 time .",
    "we can find @xmath121 with the symmetric procedure .",
    "thus our search procedure answers one query to a data structure @xmath142 in every node @xmath29 .",
    "all other operations take @xmath39 time per node .     searching for the predecessor and the successor of @xmath3 in a node @xmath208 .",
    "elements @xmath238 and elements of @xmath164 are depicted with black circles and light blue circles respectively .",
    "proper elements of @xmath105 are shown with green circles and all other elements of @xmath130 are depicted with white circles . only relevant up - pointers are shown . ]",
    "@xmath239 + * block data structure . *",
    "our data structure uses the fact that a block contains @xmath240 elements .",
    "hence , each element of a block can be specified with @xmath62 bits and information about @xmath241 elements can be packed into one machine word .",
    "we can use this fact to store information about all elements of a block in a tree with node degree @xmath241 .",
    "details are given below .",
    "we associate a unique stamp @xmath242 with each element @xmath101 in @xmath243 .",
    "the array @xmath244 contains entries for all elements of @xmath243 so that @xmath245=e$ ] for @xmath246 .",
    "we rebuild @xmath244 after @xmath162 update operations and assign an arbitrary stamp @xmath247 to each @xmath248 . when a new element @xmath100 is inserted into @xmath243 , we set @xmath249 , where @xmath250 is the number of update operations since the last rebuild .    we also store a b - tree @xmath251 with node degree @xmath241 augmented as follows .",
    "let @xmath252 be the set of elements stored in a leaf @xmath253 .",
    "the word @xmath254 contains the time - stamps and ranks of all elements in @xmath252 .",
    "we also associate a word ( i.e. , a sequence of @xmath69 bits ) @xmath255 with each node @xmath106 of @xmath0 .",
    "the @xmath256-th bit in @xmath257 for a leaf @xmath253 equals to @xmath258 if the @xmath256-th element of @xmath252 belongs to @xmath171 .",
    "the @xmath256-th bit in @xmath259 for an internal node @xmath106 equals to @xmath258 if and only if at least one bit in @xmath260 equals to @xmath258 , where @xmath261 is the @xmath256-th child of @xmath106 . for each word @xmath259 and for any @xmath256 ,",
    "we can find the largest @xmath262 , such that the @xmath263-th bit of @xmath259 is set to @xmath258 . using a look - up table of size @xmath264 , common for all blocks",
    ", we can answer such queries in @xmath39 time . for each element @xmath101 , we store a pointer to the leaf @xmath253 of @xmath251 , such that @xmath101 belongs to @xmath252 .    given an element @xmath101 , we identify the leaf @xmath253 in which it is stored . using @xmath254",
    "we identify the rank @xmath263 of @xmath101 in @xmath252 .",
    "this can be done in @xmath39 time with standard bit operations .",
    "if there is at least one bit set to 1 among the first @xmath265 bits of @xmath257 , we use @xmath254 to identify the stamp of the element @xmath100 that corresponds to the @xmath16-th bit in @xmath257 , where @xmath16 is the index of the rightmost bit set to @xmath258 among the first @xmath265 bits of @xmath257 .",
    "then , we find the element @xmath100 using the array @xmath244 .",
    "otherwise , we search for the rightmost leaf @xmath266 , such that @xmath266 is to the left of @xmath253 and @xmath267 contains at least one bit set to @xmath258 .",
    "since the height of @xmath251 is @xmath39 , we can find @xmath266 in @xmath39 time .",
    "then , we use @xmath268 and @xmath244 to identify the element corresponding to the rightmost bit set to @xmath258 in @xmath266 .    when a new element is inserted , we insert an entry into the array @xmath244 . then , we identify the leaf @xmath253 in which @xmath101 is stored and update the word @xmath254 .",
    "we also update the word @xmath257 and the words @xmath269 for all ancestors @xmath270 of @xmath253 . the b - tree can be re - balanced in a standard way .",
    "deletions are performed symmetrically . + * data structure @xmath142 . *",
    "essentially , our data structure is based on the combination of the range reporting data structure of mortensen , pagh , and patrascu  @xcite and the dynamic labeling scheme of  @xcite . using the method of  @xcite ,",
    "we can assign a positive integer label bounded by @xmath271 to each block of @xmath130 , so that labels can be inserted and deleted in @xmath272 time .",
    "if a block contains at least one element from @xmath105 , then we store the label of this block in a data structure @xmath273 that supports one - dimensional range reporting queries . using the result of  @xcite",
    ", the data structure @xmath273 supports queries in @xmath274 time and updates in time @xmath275 , where @xmath274 and @xmath275 are arbitrary functions satisfying @xmath276 , @xmath277 , and @xmath278 .",
    "for instance , queries and updates can be supported in @xmath39 time and @xmath279 time respectively .",
    "alternatively , @xmath273 can support queries in @xmath280 time and updates in @xmath35 time .",
    "although the data structure  @xcite uses randomization and the update time is expected , we can obtain the data structure with the same deterministic worst - case update time by replacing all bloomier filters with bit vectors .",
    "the space usage of this modified data structure is @xmath281 .",
    "we can determine , whether there is an element @xmath178 between two elements @xmath190 and @xmath191 that belong to the same block @xmath158 , using a data structure that is similar to the block data structure @xmath173 .",
    "if @xmath190 and @xmath191 belong to different blocks @xmath282 and @xmath283 , we can determine whether there is an element @xmath100 such that @xmath284 and @xmath100 is larger than @xmath190 or @xmath285 and @xmath100 is smaller than @xmath191 as explained in the previous paragraph .",
    "if such @xmath100 does not exist , we check whether there is a block between @xmath282 and @xmath283 that contains at least one element of @xmath105 using the data structure @xmath273 .",
    "if such a block @xmath286 is found , we identify an element @xmath287 . + * space usage and updates .",
    "* it was shown in  @xcite that all catalogs @xmath105 contain @xmath71 elements and an update on a catalog @xmath1 incurs @xmath39 amortized updates of catalogs @xmath93 .",
    "an element @xmath101 can be inserted into or deleted from a catalog @xmath93 in @xmath35 time if the position of ( the predecessor of ) the element @xmath101 in @xmath93 is known : see e.g. ,  @xcite . applying the method of  @xcite to catalogs",
    "@xmath105 , we can show that all catalogs @xmath130 also contain @xmath71 elements , and an update of a catalog @xmath105 incurs @xmath39 updates of @xmath288 for some nodes @xmath106 .",
    "when a new element @xmath101 is inserted into @xmath130 , we update the data structure for the block @xmath243 that contains @xmath101 ; we also update the data structure @xmath273 if @xmath178 .",
    "if the number of elements in a block equals to @xmath162 , we split the block into two blocks , so that each block contains @xmath289 elements , insert a new label for one of the newly created blocks , and update the data structure @xmath273 .",
    "when a new label is inserted , @xmath290 other labels may be changed .",
    "hence , we must perform @xmath290 updates of the data structure @xmath273 . since",
    "a new label is inserted after @xmath240 insertions , the amortized cost of an insertion into @xmath142 is @xmath291 .",
    "if @xmath101 also belongs to @xmath105 and @xmath101 is the only element in @xmath292 , then @xmath101 must be inserted into a data structure @xmath293 for some group @xmath228 .",
    "if the number of elements in @xmath228 equals to @xmath230 , we split the group into two groups of equal size .",
    "thus the amortized cost of an insertion into @xmath228 is @xmath39 .",
    "deletions are performed symmetrically . since the update time",
    "is dominated by an update of the data structure @xmath273 , the total cost of an update operation is @xmath294 .    during the search procedure",
    ", we must answer one query to a data structure @xmath142 in every node @xmath29 ; all other operations can be performed in @xmath39 time . hence",
    ", a query can be answered in @xmath295 time .",
    "the result of this section is summed up in the following theorem .",
    "[ theor : mcs ] we are given a tree @xmath0 with maximal node degree @xmath125 , so that a catalog @xmath19 is associated with each node @xmath2 , @xmath296 .",
    "let @xmath275 and @xmath274 be arbitrary functions satisfying @xmath276 , @xmath277 , and @xmath278 .",
    "there exists a data structure that answers multiple catalog searching queries in @xmath297 time , where @xmath7 denotes the time needed to search in one catalog of @xmath33 elements .",
    "if a pointer to the ( predecessor of ) @xmath3 in @xmath105 is given , then @xmath3 can be inserted or deleted in @xmath298 amortized time .",
    "two interesting choices of @xmath275 and @xmath274 are @xmath299 , @xmath300 and @xmath301 , @xmath302 .",
    "thus we can answer multiple catalog searching queries in @xmath6 time and support updates in @xmath279 amortized time .",
    "we can also answer multiple catalog searching queries in @xmath49 time and support updates in @xmath62 amortized time .      in this subsection",
    "we describe how our data structure can be modified to report elements in the query interval @xmath303 $ ] for all catalogs @xmath1 , where @xmath2 is a node on a path @xmath4 . in this case",
    "@xmath4 is a path from a node @xmath13 to a node @xmath14 such that @xmath14 is the ancestor of @xmath13 .",
    "we observe that , unlike in the multiple catalog searching problem , @xmath14 is not necessarily the root of @xmath0 .",
    "[ theor : mcrep ] we are given a tree @xmath0 with maximal node degree @xmath125 , so that a catalog @xmath19 is associated with each node @xmath2 , @xmath296 .",
    "let @xmath275 and @xmath274 be arbitrary functions satisfying @xmath276 , @xmath277 , and @xmath278 .",
    "there exists a data structure that answers multiple catalog reporting queries in @xmath304 time , where @xmath7 denotes the time needed to search in one catalog of @xmath33 elements and @xmath16 is the number of points in the answer .",
    "if a pointer to the ( predecessor of ) @xmath3 in @xmath105 is given , then @xmath3 can be inserted or deleted in @xmath298 amortized time .",
    "we maintain the catalog @xmath105 , the catalog @xmath130 , and the data structure @xmath142 in every node @xmath227 as described in section  [ sec : mcs ] .",
    "moreover , every node @xmath2 contains a data structure @xmath305 : for any two elements @xmath190 and @xmath191 in @xmath130 , @xmath305 identifies an element @xmath306 , @xmath307 , if such @xmath100 exists .",
    "@xmath305 is implemented in the same way as @xmath142 . in every node @xmath2 on the path @xmath4",
    ", we identify @xmath308 and @xmath309 such that @xmath310 and there is no @xmath178 with @xmath311 .",
    "we also identify @xmath312 and @xmath313 such that @xmath314 and there is no @xmath178 with @xmath315 . for any @xmath316 , @xmath317 $ ] if and only if @xmath318 .",
    "we set @xmath319 and @xmath320 . given @xmath321 and @xmath322 for some node @xmath29 , we identify the up - pointers @xmath323 and @xmath324 .",
    "up - pointers @xmath325 and @xmath326 satisfy property  [ prop : search1 ] .",
    "hence for the parent @xmath106 of @xmath2 , the catalog @xmath104 contains at most @xmath327 elements between @xmath325 and @xmath326 . we can search for an element @xmath328 , @xmath329 using the data structure @xmath330 .",
    "if such @xmath100 does not exist , we set @xmath331 and @xmath332 .",
    "otherwise we examine @xmath103 neighbors of @xmath100 in @xmath104 and find @xmath333 and @xmath334 .",
    "we can identify @xmath335 and @xmath336 for all nodes @xmath29 in the same way .",
    "since @xmath337 , any element @xmath30 belongs to the interval @xmath303 $ ] if and only if @xmath338 .",
    "if @xmath339\\not=\\emptyset$ ] , we can find some @xmath340 $ ] using the data structure @xmath305 .",
    "then , we examine elements that follow @xmath341 in @xmath1 until an element @xmath342 , @xmath343 , is found .",
    "we also examine elements that precede @xmath341 in @xmath1 until an element @xmath344 , @xmath345 is found .",
    "thus we can report all elements in @xmath346 $ ] in @xmath347|)$ ] time if @xmath322 and @xmath335 are known .",
    "update time and space usage are the same as in the catalog searching data structure .",
    "in this section we describe a simple data structure that enables us to identify the maximum element in each catalog @xmath1 for every node @xmath29 on a query path @xmath4 .",
    "again , @xmath4 is a path from a node @xmath13 to a node @xmath14 such that @xmath14 is the ancestor of @xmath13 . in this section",
    "we assume that the maximum node degree of a node is @xmath348 .    moreover , we can support extended update operations .",
    "an operation @xmath349 inserts an element @xmath101 into catalogs @xmath350 , where @xmath65 are children of some node @xmath2 . in this case",
    "we say that an element is associated with an interval @xmath351 $ ] in the node @xmath2 .",
    "we assume that each element is associated with at most one interval in every node @xmath2 of @xmath0 .",
    "an operation @xmath352 deletes an element @xmath101 from all catalogs @xmath350 , such that @xmath101 is associated with an interval @xmath351 $ ] in the node @xmath227 .",
    "[ theor : mcmax ] we are given a tree @xmath0 with maximal node degree @xmath353 , so that a catalog @xmath19 is associated with each node @xmath2 , @xmath296 .",
    "there exists a data structure that answers multiple catalog maxima queries in @xmath6 time , where @xmath7 denotes the time needed to search in one catalog of @xmath33 elements . if a pointer to ( the predecessor of ) @xmath3 in @xmath354 is given , then @xmath355 and @xmath356 are supported in @xmath62 time and @xmath63 time respectively .",
    "all elements from a catalog @xmath357 are stored in a data structure @xmath358 for a parent @xmath2 of @xmath113 .",
    "each element @xmath101 in @xmath358 is associated with an interval @xmath351 $ ] , @xmath359 , such that @xmath101 is stored in all catalogs @xmath64 .",
    "we implement @xmath358 using the generalized union - split - find data structure described in theorem 5.2 of  @xcite .",
    "this enables us to support the following operations : we can insert a new element @xmath101 associated with an interval @xmath360 $ ] into @xmath358 in @xmath35 time if the position of @xmath101 in @xmath361 is known .",
    "we can delete an element @xmath101 from @xmath358 in @xmath35 time .",
    "for any interval @xmath31 $ ] , @xmath362 , and any @xmath68 we can find the largest element @xmath363 such that @xmath364 and @xmath360\\cap [ x_1,x_2]\\not=\\emptyset$ ] .    we store a local tree @xmath365 in every node @xmath2 .",
    "leaves of @xmath365 correspond to children of @xmath2 ; @xmath365 is a binary tree of height @xmath35 .",
    "we say that an element @xmath101 _ covers _ a node @xmath43 of @xmath365 if @xmath101 is stored in all catalogs @xmath357 for all children @xmath113 of @xmath2 .",
    "we say that @xmath101 _ belongs _ to a node @xmath43 of @xmath365 if @xmath101 covers @xmath43 but @xmath101 does not cover the parent of @xmath43 .",
    "the set @xmath366 contains all elements that belong to a node @xmath43 of @xmath365 .",
    "the data structure @xmath367 contains maximal elements from every set @xmath366 .",
    "we can use the fact that @xmath367 contains @xmath69 elements and implement it in one machine word , so that for any path @xmath368 in @xmath365 the maximum element @xmath369 can be found in constant time .",
    "updates of @xmath367 are also supported in constant time .",
    "@xmath367 is implemented as follows .",
    "let @xmath370 denote the maximum element in @xmath366 .",
    "the word @xmath371 contains the _ rank _ of @xmath370 in @xmath367 for every node @xmath43 of @xmath365 ( nodes of @xmath365 are stored in pre - order ) . since ranks of all @xmath370 fit into one machine word",
    ", we can modify the ranks of all elements in @xmath367 in @xmath39 time when @xmath370 for some node @xmath43 of @xmath365 is changed . using table look - ups and bit operations on @xmath371",
    ", we can also find the maximum in @xmath372 for any path @xmath368 in @xmath365 .",
    "using data structures @xmath259 for the parent @xmath106 of @xmath2 , we can find the maximum element in @xmath1 for any node @xmath2 in constant time .",
    "we can identify the maximum element in a catalog @xmath1 by finding the maximum element among @xmath373 for @xmath374 . here",
    "@xmath375 denotes the path in @xmath376 from the leaf that corresponds to @xmath2 to the root of @xmath365 .",
    "hence , we can find the maximum element in each @xmath1 in @xmath39 time using @xmath367 .",
    "when a new element @xmath101 is inserted into catalogs @xmath377 , we insert @xmath101 into the data structure @xmath358 , where @xmath2 is the parent node of @xmath378 .",
    "we can find @xmath62 nodes @xmath379 in @xmath365 , such that @xmath101 belongs to each @xmath95 , @xmath380 .",
    "for every @xmath95 , if @xmath381 then we update the data structure @xmath367 .",
    "hence , an operation @xmath349 takes @xmath35 time .",
    "when an element @xmath101 is deleted from catalogs @xmath377 , we check whether @xmath101 is stored as a maximum element @xmath370 for some nodes @xmath43 in @xmath367 . for every such @xmath43 , we find the largest element @xmath382 such that @xmath383 .",
    "using the data structure @xmath358 , we can find @xmath384 in @xmath35 time .",
    "when @xmath384 is found , we update @xmath367 accordingly in @xmath39 time .",
    "finally , we delete @xmath101 from @xmath358 in @xmath62 time . hence , @xmath352 takes @xmath63 time .",
    "applications in which we associate ordered sets with each node of a balanced tree are a frequent topic in data structures . in many cases we want to search in all catalogs that are associated with nodes on a specified root - to - leaf path . since a root - to - leaf path in a balanced tree",
    "consists of @xmath69 nodes and @xmath385 , where @xmath7 is the time we need to search in one catalog of @xmath33 elements , theorem  [ theor : mcs ] enables us to spend @xmath39 time in each catalog .",
    "if the node degree of a balanced tree is @xmath386 for a constant @xmath387 , then a root - to - leaf path consists of @xmath17 nodes . using fusion trees  @xcite",
    ", we can search in a single catalog in @xmath388 time .",
    "hence , theorems  [ theor : mcs ] and  [ theor : mcrep ] enable us to spend @xmath39 time in each catalog even in the case when the node degree is poly - logarithmic .",
    "below we will sketch how our techniques can be used to obtain dynamic data structures for several important problems . + * point location in a horizontal subdivision . * in this problem the set of @xmath33 horizontal segments is stored in the data structure , so that for a query point @xmath389 the segment immediately below ( or immediately above ) @xmath68 can be reported . as in  @xcite and several other point location data structures  @xcite , our solution is based on segment trees .",
    "the leaves of a segment tree correspond to @xmath3-coordinates of segment endpoints .",
    "the range @xmath390 of a node @xmath2 is an interval @xmath391 $ ] where @xmath392 is the @xmath3-coordinate stored in the leftmost leaf descendant of @xmath2 and @xmath393 is the @xmath3-coordinate stored in the rightmost leaf descendant of @xmath2 .",
    "we denote by @xmath394 the projection of a segment @xmath77 on the @xmath3-axis .",
    "a set @xmath395 is associated with each node @xmath2 ; @xmath395 contains all segments @xmath77 such that @xmath390 is contained in @xmath394 but @xmath396 is not contained in @xmath394 .",
    "each internal node in our segment tree has @xmath397 children for @xmath398 .",
    "hence , each segment belongs to @xmath399 sets @xmath395 . if a @xmath400 for some segment @xmath77 , then @xmath77 is stored in one of sets @xmath395 , where @xmath29 and @xmath4 is the path from the leaf that contains the successor of @xmath401 to the root of the segment tree .",
    "we store the @xmath402-coordinates of segments from @xmath395 in a catalog @xmath1 . hence finding a segment below ( above ) @xmath389 is equivalent to searching for the predecessor ( successor ) of @xmath403 in @xmath5 .",
    "we apply the multiple catalog searching technique to catalogs @xmath1 , so that we can search in @xmath5 in @xmath17 time and update a catalog @xmath1 in @xmath404 time .",
    "when a new segment @xmath22 is inserted into the data structure , we insert the @xmath402-coordinate of @xmath77 into @xmath399 catalogs @xmath405 . using the standard fractional cascading technique",
    ", we can identify position of the @xmath402-coordinate @xmath406 of @xmath77 in augmented catalogs @xmath407 in @xmath408 time .",
    "then we can insert @xmath406 into the multiple catalog searching data structure in @xmath409 by theorem  [ theor : mcs ] .",
    "deletions are supported in the same way .",
    "the data structure uses @xmath410 space .",
    "but we can reduce the space usage to linear by using the technique described in  @xcite and the technique of  @xcite .",
    "details will be given in the full version of this paper .",
    "+ * stabbing - max data structure .",
    "* we use the same construction as in the point location data structure , but catalogs @xmath1 contain priorities of segments stored in @xmath395 . for this problem ,",
    "we use theorem  [ theor : mcmax ] . to find the segment @xmath77 with the highest priority such that @xmath411",
    ", we identify the maximum element in catalogs @xmath5 .",
    "suppose that a new segment @xmath77 is inserted .",
    "all nodes @xmath2 , such that @xmath77 is stored in @xmath395 can be divided into @xmath66 groups .",
    "the @xmath256-th group consists of sibling nodes @xmath412 that have the same parent node @xmath150 . using standard fractional cascading",
    ", we can identify the position of @xmath77 in all data structures @xmath413 in @xmath69 time .",
    "then , we can use theorem  [ theor : mcmax ] to insert the segment @xmath77 into @xmath413 and to update @xmath414 in @xmath35 time for each @xmath150 . hence , the total time for an insertion is @xmath69 .",
    "deletions are performed in a symmetric way , but we need @xmath415 time to update @xmath414 . hence , the total time for a deletion is @xmath81 .",
    "we observe that it is not necessary to store catalogs @xmath1 and set @xmath395 in every node @xmath2 .",
    "we only need to store the data structures @xmath358 and @xmath367 described in the proof of theorem  [ theor : mcmax ] .",
    "hence , the total space used by our construction is @xmath80 .",
    "thus we obtain a @xmath80 space data structure that answers stabbing - max queries in @xmath66 time , supports insertions in @xmath69 time , and supports deletions in @xmath81 time .",
    "alternatively , we can store @xmath1 using theorem  [ theor : mcs ] . to identify the highest priority segment that contains a query point @xmath68",
    ", we search for the predecessor of @xmath416 in @xmath5 ; here @xmath417 denotes the dummy priority such that @xmath417 is larger than priority of any segment in the data structure . in this case",
    "update time and space usage can be estimated as for the horizontal point location data structure .",
    "thus we obtain a @xmath71 space data structure that supports queries in @xmath66 time and updates in @xmath70 time . +",
    "* line - segment intersection .",
    "* again , we use the same construction as in the point location data structure .",
    "but now we use theorem  [ theor : mcrep ] , so that multiple catalog reporting queries can be answered . given a vertical segment @xmath418 with endpoints @xmath419 and @xmath420 , each segment that intersect @xmath418 belongs to some set @xmath395 for a node @xmath29 , where @xmath4 is the path from the node that contains the successor of @xmath421 to the root of the segment tree .",
    "a segment @xmath422 , @xmath29 , intersects with @xmath418 if and only if the @xmath402-coordinate of @xmath77 belongs to the range @xmath423 $ ] .",
    "hence , we can find all segments that intersect @xmath418 by answering a multiple catalog reporting query .",
    "as in the previous case the update time is @xmath70 .",
    "we need @xmath424 space to store all segments .",
    "but we can reduce the space usage to @xmath80 by using the technique similar to the compact representation described in  @xcite .",
    "details will be given in the full version .",
    "99 p. k. agarwal , l. arge , k. yi , _ an optimal dynamic interval stabbing - max data structure ? _ , proc .",
    "soda 2005 , 803 - 812 .",
    "p. k. agarwal , j. erickson , _ geometric range searching and its relatives _ , in `` advances in discrete and computational geometry '' , 156 .",
    "ams press , providence , ri , 1999 .",
    "s. alstrup , t. husfeldt , t rauhe , _ marked ancestor problems _ , proc .",
    "focs 1998 , 534 - 544 .",
    "a. andersson , p. b. miltersen , m. thorup , _ fusion trees can be implemented with ac0 instructions only_. theor .",
    "sci . 215(1 - 2 ) , 337 - 344 ( 1999 )",
    ". l. arge , g. s. brodal , l. georgiadis _ improved dynamic planar point location _ , proc .",
    "focs 2006 , 305 - 314 .",
    "h. baumgarten , h. jung , k. mehlhorn , _ dynamic point location in general subdivisions _ , j. algorithms 17(3 ) , 342 - 380 ( 1994 ) . h. baumgarten , h. jung , k. mehlhorn , _ dynamic point location in general subdivisions _",
    ", j. algorithms 17(3 ) , 342 - 380 ( 1994 ) .",
    "p. beame , f. e. fich , _ optimal bounds for the predecessor problem and related problems _ , j. comput .",
    "65(1 ) , 38 - 72 ( 2002 ) .",
    "g. e. blelloch , _ space - efficient dynamic orthogonal point location , segment intersection , and range reporting _ , proc .",
    "soda 2008 , 894 - 903 .",
    "d. k. blandford , g. e. blelloch , _ compact dictionaries for variable - length keys and data with applications_. acm transactions on algorithms 4(2 ) 2008",
    ". b. chazelle , l. j. guibas , _ fractional cascading : i. a data structuring technique _ , algorithmica 1(2 ) , 133 - 162 ( 1986 ) .",
    "s w. cheng and r. janardan , _ efficient dynamic algorithms for some geometric intersection problems _ , information processing letters , 36(5 ) , 251 - 258 ( 1990 )",
    ". j. l. chiang , r. tamassia , _ dynamic algorithms in computational geometry _",
    ", technical report cs-91 - 24 , dept . of computer science , brown university , 1991 .",
    "e. d. demaine , j. iacono , s. langerman , _ retroactive data structures _ ,",
    "acm transactions on algorithms 3 ( 2007 ) .",
    "m. l. fredman , d. e. willard , _ surpassing the information theoretic bound with fusion trees _ , j. comput .",
    "47(3 ) , 424 - 436 ( 1993 ) .",
    "m. l. fredman , d. e. willard , _ trans - dichotomous algorithms for minimum spanning trees and shortest paths _ , j. comput .",
    "48(3 ) , 533 - 551 ( 1994 ) .",
    "h. n. gabow , r.  e. tarjan , _ a linear - time algorithm for a special case of disjoint set union _ j. comput",
    "30(2 ) , 209 - 221 ( 1985 ) .",
    "y. giyora , h. kaplan , _ optimal dynamic vertical ray shooting in rectilinear planar subdivisions _ , acm transactions on algorithms 5 ( 2009 ) .",
    "h. imai and t. asano , _ dynamic orthogonal segment intersection search _ , journal of algorithms 8(1 ) , 1 - 18 ( 1987 ) .",
    "a. itai , a. g. konheim , m. rodeh , _ a sparse table implementation of priority queues _ ,",
    "8th icalp 1981,417 - 431 .",
    "h. kaplan , e. molad , r.  e. tarjan , _ dynamic rectangular intersection with priorities _ , proc .",
    "stoc 2003 , 639 - 648 .",
    "k. mehlhorn , _ data structures and algorithms 1 : sorting and searching _ , springer 1984",
    ". k. mehlhorn , s. nher , _ dynamic fractional cascading _ ,",
    "algorithmica 5 , 215 - 241 ( 1990 ) .",
    "k. mehlhorn , s. nher , h. alt , _ a lower bound on the complexity of the union - split - find problem _ , siam j. comput .",
    "17(6 ) , 1093 - 1102 ( 1988 ) . c. w. mortensen , _ fully - dynamic two dimensional orthogonal range and line segment intersection reporting in logarithmic time _ , proc .",
    "soda 2003 , 618 - 627 . c. w. mortensen , _ data structures for orthogonal intersection searching and other problems _ , ph .",
    "d. thesis , it university of copenhagen , 2006 .",
    "c. w. mortensen , r. pagh , m. patrascu , _ on dynamic range reporting in one dimension .",
    "stoc 2005 , 104 - 111 .",
    "y. nekrich , _ orthogonal range searching in linear and almost - linear space _ ,",
    "42(4 ) , 342 - 351 ( 2009 ) .",
    "m. patrascu , e. d. demaine , _ logarithmic lower bounds in the cell - probe model _ , siam j. comput .",
    "35(4 ) , 932 - 963 ( 2006 ) .",
    "r. raman , _ eliminating amortization : on data structures with guaranteed response time _ , ph .",
    "d. thesis , university of rochester , 1992 .",
    "r. e. tarjan , _ a class of algorithms which require nonlinear time to maintain disjoint sets _ , j. comput .",
    "18(2 ) , 110 - 127 ( 1979 ) .",
    "m. thorup , _ undirected single - source shortest paths with positive integer weights in linear time _ , j. acm 46(3 ) , 362 - 394 ( 1999 ) . m. thorup , _ space efficient dynamic stabbing with fast queries _ ,",
    "stoc 2003 , 649 - 658 .",
    "v. k. vaishnavi , d. wood , _ rectilinear line segment intersection , layered segment trees , and dynamization _",
    ", j. algorithms 3(2 ) , 160 - 176 ( 1982 ) .",
    "d. e. willard , _",
    "new data structures for orthogonal range queries _ , siam j. comput .",
    "14(1 ) , 232 - 253 ( 1985 ) .",
    "d. e. willard , _ a density control algorithm for doing insertions and deletions in a sequentially ordered file in good worst - case time _ , information and computation 97 , 150 - 204 ( 1992 ) ."
  ],
  "abstract_text": [
    "<S> in this paper we consider the following modification of the iterative search problem . we are given a tree @xmath0 , so that a dynamic catalog @xmath1 is associated with every tree node @xmath2 . for any @xmath3 and for any node - to - root path @xmath4 in @xmath0 </S>",
    "<S> , we must find the predecessor of @xmath3 in @xmath5 . </S>",
    "<S> we present a linear space dynamic data structure that supports such queries in @xmath6 time , where @xmath7 is the time needed to search in one catalog and @xmath8 denotes the number of nodes on path @xmath4 .    </S>",
    "<S> we also consider the reporting variant of this problem , in which for any @xmath9 , @xmath10 and for any path @xmath11 , all elements of @xmath12)$ ] must be reported ; here @xmath11 denotes a path between an arbitrary node @xmath13 and its ancestor @xmath14 . </S>",
    "<S> we show that such queries can be answered in @xmath15 time , where @xmath16 is the number of elements in the answer .    to illustrate applications of our technique , we describe the first dynamic data structures for the stabbing - max problem , the horizontal point location problem , and the orthogonal line - segment intersection problem with optimal @xmath17 query time and poly - logarithmic update time . </S>"
  ]
}