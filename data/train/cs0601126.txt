{
  "article_text": [
    "maximum likelihood decoding on tail - biting trellises ( tbt ) has been extensively studied in the literature and several linear time approximate algorithms have been proposed , ( see for example , @xcite ) .",
    "some of these algorithms may fail to converge on certain inputs .",
    "algorithms with guaranteed convergence were studied in @xcite , but they fail to achieve linear complexity . in particular , although the approximate algorithm proposed in @xcite , achieves performance close to an ideal ml decoder , it has a worst case time complexity of @xmath0 , where @xmath2 is the number of nodes in the tbt .",
    "the algorithm exploits the fact that a linear tail - biting trellis can be viewed as a coset decomposition of the group corresponding to the linear code with respect to a specific subgroup and is an adaptation of the classical @xmath3 algorithm .",
    "the algorithm operates in two phases .",
    "the first phase does a viterbi - like pass on the tbt to obtain certain _ estimates _ which are used in the second phase to guide the search for the shortest path corresponding to a codeword in the tbt .    in this note",
    ", the complexity of the approximate algorithm in @xcite is reduced to @xmath1 .",
    "the reduction in complexity is achieved by eliminating the use of a heap in the second phase of the original algorithm using the well known technique of dynamic programming .",
    "the estimates gathered during the first phase are used in the second phase for the computation of a _ metric _ for each node in the tbt using another simple viterbi - like pass .",
    "it turns out that updates performed by the two algorithms are identical for the shortest path which must be output by the algorithm ( although the metric values computed for other nodes may differ ) .",
    "we give an analysis of the algorithm here .",
    "simulations are included for completeness and the two algorithms perform identically as expected .",
    "a linear tail - biting trellis for an @xmath4 linear block code @xmath5 over field @xmath6 can be constructed as a _ trellis product _ @xcite of the representation of the individual trellises corresponding to the @xmath7 rows of the generator matrix @xmath8 for @xmath5 @xcite . the trellis product @xmath9 of a pair of trellises @xmath10 and @xmath11 will have at @xmath12 a set of vertices which is the cartesian product of vertices of @xmath10 and @xmath11 at that time index , with an edge between @xmath12 and @xmath13 from @xmath14 to @xmath15 , with label @xmath16 whenever @xmath17 and @xmath18 are edges between vertices at @xmath12 and @xmath13 in @xmath10 and @xmath11 with labels @xmath19 and @xmath20 respectively for some @xmath21 , @xmath22 , where @xmath23 denotes addition in @xmath6 .",
    "let @xmath24 , @xmath25 be the rows of a generator matrix @xmath8 for the linear code @xmath5 .",
    "each vector @xmath26 generates a one - dimensional subcode of @xmath5 , which we denote by @xmath27 .",
    "therefore @xmath28 , and the trellis representing @xmath5 is given by @xmath29 , where @xmath30 is the trellis for @xmath31 .",
    "given a codeword @xmath32 , the _ linear span _",
    "@xcite of @xmath33 , is the interval @xmath34",
    "\\in \\{1,2,\\cdots n\\}$ ] which contains all the non - zero positions of @xmath33 .",
    "a _ circular span _",
    "@xcite has exactly the same definition with @xmath35 .",
    "note that for a given vector , the linear span is unique , but circular spans are not . for a vector @xmath36 over the field @xmath6 , there is a unique _ elementary trellis _ @xcite representing @xmath37  @xcite .",
    "this trellis has @xmath38 vertices at time indices @xmath39 to @xmath40 mod @xmath41 , and a single vertex at other positions . consequently ,",
    "@xmath42 in the trellis product mentioned earlier , is the elementary trellis representing @xmath43 for some choice of span ( either linear or circular ) .",
    "koetter and vardy  @xcite have shown that any linear trellis , conventional or tail - biting can be constructed from a generator matrix whose rows can be partitioned into two sets , those which have linear span , and those taken to have circular span .",
    "the trellis for the code is formed as a product of the elementary trellises corresponding to these rows .",
    "we will represent such a generator matrix as @xmath44 $ ] , where @xmath45 is the submatrix consisting of rows with linear span , and @xmath46 the submatrix of rows with circular span .",
    "let @xmath47 denote the minimum conventional trellis for the code generated by @xmath48 .",
    "if @xmath49 is the number of rows of @xmath8 with linear span and @xmath50 the number of rows of circular span , the tail - biting trellis constructed using the product construction will have @xmath51 start states .",
    "where , each such start state defines a subtrellis whose codewords form a coset of the subcode corresponding to the subtrellis containing the all 0 codeword .    for the description of the decoding algorithm we assume a tail - biting trellis with start states @xmath52 and final states @xmath53 . where @xmath54 is the number of subtrellises .",
    "an @xmath55 path is a codeword path in trellis @xmath30 , whereas an @xmath56 path for @xmath57 is a non codeword path . for purposes of our discussion we term the edge label sequence along such a path as a _ semi - codeword _ as in  @xcite .",
    "we assume an awgn channel with binary antipodal signalling . when the edges are given weights corresponding to the log - likelihood values , ml decoding corresponds to finding the minimum weight codeword path in the tbt .",
    "the algorithm operates in two phases , each taking linear time .",
    "the first phase is a viterbi pass which computes a function @xmath58 for each vertex @xmath59 in the trellis .",
    "this value of cost is used by the second phase to compute a _",
    "metric _ at each vertex of the trellis .",
    "the final decoding decision will be based on the _ metric _ values at the final nodes of the trellis .",
    "let @xmath60 denote the length of the shortest path connecting vertices @xmath59 and @xmath61 in the tail - biting trellis . note that @xmath62 satisfies the _",
    "triangular inequality_. ie . , @xmath63 for all nodes @xmath64 in the trellis .",
    "codeword _ is an @xmath65 path while a _ semi - codeword _ is an @xmath66 path , @xmath67 , where @xmath54 is the number of subtrellises .",
    "note that all codewords are semi - codewords .",
    "define @xmath68 we say an edge @xmath69 if @xmath70 .",
    "define the _ metric at node @xmath59 for trellis @xmath39 _ @xmath71 .",
    "define _ metric at node @xmath59 _ , @xmath72 .",
    "suppose @xmath73 and this is the length of an @xmath74 path , the first phase of the algorithm assigns the program variable @xmath75 $ ] the value @xmath76 and @xmath77 $ ] the value @xmath39 .",
    "we call the the @xmath74 path corresponding to this assignment the _ survivor _ at @xmath59 .",
    "these values are used to assign values to the program variable @xmath78 $ ] in the second phase , which is intended to store the value of the metric @xmath79 .",
    "the trellis corresponding to the minimum metric value is stored in the variable @xmath80 $ ] .",
    "however , the values assigned to @xmath81 $ ] can be incorrect , in that it is not equal to @xmath82 .",
    "the algorithm may even fail to assign a value to @xmath78 $ ] for every node @xmath59 .",
    "we shall derive the conditions under which the algorithm may fail to decode correctly .",
    "the program variable @xmath83 $ ] stores the length of the path to the node corresponding to the minimum value of @xmath81 $ ] in the second phase .",
    "the program variable @xmath84 $ ] used in both the phases stores the predecessor along the paths traced to the node by the algorithm in the respective phases .",
    "the function @xmath85 assumed in the algorithm description below takes as input an edge @xmath86 and integer @xmath39 and returns true if the edge @xmath86 belongs to trellis @xmath42 , false otherwise .",
    "note that the function @xmath87 needs only @xmath88 lookup time although the lookup table is of size quadratic on the number of vertices in the trellis .",
    "* initialization : * + @xmath89 = @xmath90 @xmath91 + @xmath92=0 $ ] + @xmath93 = i$ ] + @xmath94=s_{i}$ ] + @xmath89 @xmath90 @xmath95 @xmath96 = \\infty$ ]    * estimation : * +   + @xmath89 @xmath97 to @xmath41 @xmath98 + @xmath89 @xmath90 @xmath99 @xmath100 @xmath98 + @xmath101 + l[u , v]$ ] + @xmath102 ( @xmath103 > temp$ ] ) @xmath104 + @xmath103 = temp$ ] + @xmath105 = u$ ] + @xmath106 = survtrellis[u]$ ] +    clearly by the end of this phase , @xmath75=\\delta ( u)$ ] for each vertex @xmath59 in the trellis .",
    "let @xmath107 .",
    "if the algorithm assigns @xmath108=j$ ] , then @xmath109 at @xmath110 which corresponds to the minimum weight semi - codeword in the trellis turns out to be a codeword and the algorithm stops .",
    "otherwise , the second phase described below will be executed .      * initialization : * +   + @xmath89 @xmath90 @xmath91 + @xmath102 @xmath111\\ne i)$ ] @xmath104 @xmath112=\\delta ( f_{i})$ ] + @xmath113 @xmath112=\\infty$ ] / * no processing for @xmath42 * / + @xmath94=s_{i}$ ] + @xmath114 = i$ ] + @xmath102 @xmath115=\\infty)$ ] then @xmath116=\\infty$ ] + @xmath113 @xmath116=0 $ ] + @xmath89 @xmath90 @xmath95 @xmath117 = \\infty$ ]    * revision * +   + @xmath89 @xmath97 to @xmath41 @xmath98 + @xmath89 @xmath90 @xmath99 @xmath100 @xmath98 + @xmath118    @xmath118 + @xmath102 (",
    "@xmath119 $ ] ) @xmath120 ; + @xmath121 + l[u , v ] + cost[f_{trellis[u ] } ] - cost[v]$ ] + @xmath102 ( @xmath117 > temp$ ] ) @xmath104 + @xmath117 = temp$ ] + @xmath105 = u$ ] + @xmath122 = trellis[u]$ ] + @xmath123 = dist[u ] + l[u , v]$ ] +    the second phase attempts to compute the value of the _ metric _ , @xmath79 for each vertex @xmath59 of the trellis",
    ". if the first phase assigned @xmath124=i$ ] for some final node @xmath125 , for the particular trellis @xmath42 the second phase processing is not required .",
    "we say a trellis @xmath42 _ participates _ in the second phase if @xmath124\\ne i$ ] and @xmath126=j } \\delta ( f_{j})$ ] .",
    "the final decoding decision is based on the values of the metric at the final nodes of the trellis .",
    "we shall derive the conditions under which the algorithm will achieve maximum likelihood decoding on a tail - biting trellis for a linear code , when binary antipodal signaling is used over an awgn channel .",
    "if the algorithm does not stop in the first phase , choose vertex @xmath127 $ ] .",
    "the output of the algorithm is the codeword corresponding to the @xmath128 path obtained by tracing the predecessors of @xmath110 till @xmath129 .",
    "the array @xmath130 stores the predecessors of each node along the path the minimizes the value of @xmath131 .",
    "note that if @xmath132 does not participate in the second phase , the path must be traced along @xmath130 values in the first phase .",
    "for any node @xmath59 , if @xmath80=j$ ] , then @xmath133 \\geq l(s_{j},u)$ ] because the value assigned @xmath133 $ ] is the length of an @xmath134 path .",
    "consequently @xmath78\\geq m_{j}(u)$ ] .",
    "we collect these facts into a lemma :    during the second phase , if the algorithm assigns for a node @xmath59 , @xmath80=j$ ] then @xmath133\\geq l(s_{j},u)$ ] and @xmath78\\geq m_{j}(u)$ ]",
    ".    the following simple property of @xmath135 will be useful :    if @xmath86 is an edge in the tbt , the @xmath136 .",
    "the shortest path from a start node to @xmath61 can not be longer than the shortest path from a start node to @xmath61 through @xmath59 .",
    "the following lemma asserts that the value assigned to @xmath137 by the algorithm can not be smaller than the @xmath137 value of its predecessor node .",
    "let @xmath86 be an edge in the tail - biting trellis .",
    "let @xmath80=i$ ] suppose the second phase assigns @xmath105=u$ ] then @xmath117\\geq metric[u]$ ]    an inspection of the algorithm reveals that the algorithm assigns to @xmath133 $ ] the cost of some @xmath74 path .",
    "hence @xmath133\\geq l(s_{i},u)$ ] . by the @xmath137 update rule of the algorithm , @xmath117=dist[u]+l(u , v)+ \\delta(f_{i})-\\delta(u)$ ] .",
    "since @xmath78=dist[u]+\\delta(f_{i})-\\delta(u)$ ] , the result follows as @xmath136 by lemma 2 .",
    "if the algorithm assigns @xmath80=i$ ] , then @xmath78\\geq metric[s_{i}]=\\delta(f_{i})$ ]    the algorithm initializes @xmath112 $ ] to @xmath138 . by previous lemma , the value can not decrease along any @xmath74 path .    the algorithm ,",
    "if assigns any value , must set @xmath139=j$ ] and @xmath140=dist[f_{j } ] \\geq l(s_{j},f_{j } ) = m_{j}(f_{j})$ ] for each @xmath141 .",
    "thus , if the shortest path corresponding to a codeword in the trellis is an @xmath142 path , then if @xmath140 = l(s_{j},f_{j})$ ] the algorithm is guaranteed to decode correctly . in the following ,",
    "we derive a condition necessary for the algorithm to fail .",
    "if the shortest codeword corresponds to an @xmath65 path @xmath143 , and if @xmath143 corresponds to the codeword output by a maximum likelihood decoder , then , the two phase algorithm fails to assign @xmath78=m_{i}(u)$ ] and @xmath80=i$ ] for any node @xmath59 in @xmath143 _ only if _",
    "there exists @xmath144 such that @xmath145 .    without loss of generality ,",
    "assume that the all zero codeword was transmitted and an ideal ml decoder will output the all zero codeword .",
    "again , without loss of generality let @xmath146 be the shortest @xmath147 path in the sub - trellis @xmath10 corresponding to the all zero codeword . we therefore have @xmath148 for all @xmath149 .",
    "let @xmath59 , be the first node along the path @xmath143 where there exists some @xmath150 such that @xmath151 .",
    "such node @xmath59 must exist for otherwise , the algorithm will decode correctly as it will assign @xmath152=1 $ ] with @xmath153=m_{1}(u_{i})$ ] all along the path @xmath143 .",
    "note that @xmath154 is the value the algorithm would have assigned to @xmath155 $ ] if the algorithm had assigned @xmath152=1 $ ] all along the path @xmath143 . as the algorithm assigns the minimum value of @xmath137 possible for each node , by lemma 3 , it must be true that the actual value assigned to the @xmath78 $ ] by the algorithm must satisfy @xmath78\\leq l(s_{1},f_{1})$ ] . since we assume that the algorithm assigned @xmath80=j$ ] , the value of the metric computed at @xmath59 must have followed an @xmath156 path and consequently @xmath78\\geq metric[s_{j}]=\\delta(f_{j})$ ] ( corollary 1 ) .",
    "hence @xmath157 .",
    "now , assume that the survivor at @xmath110 is an @xmath158 path , if @xmath159 , we have @xmath160 , a contradiction .",
    "otherwise , the condition stated in theorem holds .    now to specialize the above to awgn channel with binary antipodal signaling .",
    "the following two results proved in  @xcite are repeated here for completeness .",
    "the space of semi - codewords is a vector space .",
    "assume that each of the @xmath50 vectors in the submatrix @xmath46 of the generator matrix is of the form @xmath161 $ ] where @xmath162 stands for the sequence of symbols before the zero run , and is called the _",
    "and @xmath163 stands for the sequence of symbols following the zero run and is called the _ tail _ and @xmath164 is the zero run containing the appropriate number of zeroes .",
    "let @xmath165 be the vectors of @xmath46 .",
    "then the matrix @xmath166 defined as @xmath167 $ ] , where @xmath168 consists of @xmath169 rows of the form @xmath170,[\\vec{0},\\vec{t_i } ] , 1\\leq i \\leq c$ ] , generates the set of labels of all paths from any start node to any final node .",
    "the following is due to tendolkar and hartmann @xcite .",
    "let @xmath171 be the parity check matrix of the code and let a codeword @xmath172 be transmitted as a signal vector @xmath173 .",
    "let the binary quantization of the received vector @xmath174 be denoted by @xmath175 .",
    "let @xmath176 and @xmath177 .",
    "then maximum likelihood decoding is achieved by decoding a received vector @xmath178 into the codeword @xmath179 where @xmath180 is a binary vector that satisfies @xmath181 and has the property that if @xmath182 is any other binary vector such that @xmath183 then @xmath184 where @xmath185 is the inner product .",
    "combining all the above , we have the following necessary condition for error .",
    "assume the @xmath164 codeword is the ml codeword corresponding to the path @xmath186 in the tail biting trellis .",
    "let @xmath175 be the binary quantization of the received vector .",
    "let @xmath187 , @xmath188 be as defined in lemma 4 . for the error pattern",
    "@xmath180 the two phase algorithm decodes to a vector to a vector @xmath189 correspond an @xmath128 path @xmath190 _ only if _",
    "there exists a semi - codeword @xmath191 satisfying @xmath192 for all nonzero codewords @xmath5 , where the semi - codeword @xmath193 either shares either its head or tail with trellis @xmath194",
    ".    since the ideal ml decoder decodes @xmath175 to @xmath164 , we have @xmath195 or @xmath196 . let @xmath171 be the parity check matrix of the code while @xmath197 the parity check matrix for the semi - codeword vector space established in lemma 3 .",
    "any binary error vector @xmath182 which gives the same syndrome as @xmath198 must belong to the same coset of the code and hence must have the form @xmath199 , where c is a codeword .",
    "applying lemma 5 , we get @xmath200 for all codewords c , which proves the right inequality .    to yield the left inequality ,",
    "first observe that the first phase of the algorithm does an ml decoding on the semi - codeword space .",
    "any @xmath158 path @xmath143 in the tail - biting trellis with @xmath201 and @xmath202 corresponds to a semi - codeword that an ideal ml decoder operating on the space of semi - codewords will prefer to the all zero codeword .",
    "hence , by applying lemma 5 to this case and arguing identically as above , we find that for each path such @xmath143 there must exist a semi - codeword @xmath203 such that @xmath204 .",
    "the claim follows as theorem 1 asserts that this condition is necessary for the algorithm to fail to decode the received vector to the all zero codeword .",
    "since each phase takes linear time , the algorithm runs in time linear in the size of the tail - biting trellis . as each pass is viterbi like , the worst case number of comparisons performed is bounded by twice that of the viterbi algorithm .",
    "the space complexity is quadratic in the size of the trellis owing to the lookup table of size @xmath205 required for the @xmath206 function , where @xmath207 is the number of vertices in the trellis .",
    "however , this is not a serious drawback as the table can be efficiently implemented using bit vector representation .",
    "the results of simulations on an awgn channel for the two phase algorithm are displayed in the figures below .",
    "the codes used are a rate @xmath208 memory @xmath209 convoluational code with a circle size of @xmath210 ( same as the ( 554,744 ) code convolutional code used in @xcite ) and a rate @xmath208 memory 4 convolutional code with circle size @xmath211 ( same as the ( 72,62 ) code used in @xcite ) .",
    "the performance of the above codes is compared with that of the exact ml decoding algorithm in  @xcite .",
    "it is seen that the bit error rate of the algorithm approaches that of the ideal ml decoder .",
    "[ fig : fig1 ]     [ fig : fig2 ]",
    "the performance of the algorithm can be improved at the expense of more storage by tracking more than one paths corresponding lowest values of @xmath137 during the second second phase . however , the time complexity increases proportional to the number of stored paths .",
    "practice has shown that memorizing the best two paths corresponding to the minimum value of @xmath137 at each node gives performance almost indistinguishable from the ideal maximum likelihood decoder @xcite    an interesting failure condition of the algorithm is the following : the algorithm may fail to assign a value to the @xmath137 field for a node if in the second phase a node fail to belong to any of the trellises assigned to the @xmath212 field of its predecessors by the algorithm . if this happens along all paths to all final states , the algorithm may fail to output a codeword in the second phase .",
    "note that the error condition proved handles this case as well .",
    "however this situation never occurred in simulations performed .    from the results of simulations on the rate 1/2 , memory 4 convolutional code with a circle size of 20 and a rate 1/2 memory 6 convolutional code with a circle size of 48 , it is seen that the algorithm performs close to the ideal ml decoder .",
    "the performance is comparable with other linear time approximate methods .",
    "the present algorithm reduces computation to just two viterbi computation on the tail - biting trellis and does not require dynamic data structures like the heap necessary in the orginal versions using the a * algorithm @xcite .",
    "the authors acknowledge madhu a. s. for implementing the algorithm and helping with the simulations .",
    "cox and c.v .",
    "sundberg , an efficient adaptive circular viterbi algorithm for decoding generalized tailbiting convolutional codes , _ ieee transactions on vehicular technology _ * 43*(1 ) , february 1994 , pp 57 - 68 ."
  ],
  "abstract_text": [
    "<S> a linear time approximate maximum likelihood decoding algorithm on tail - biting trellises is presented , that requires exactly two rounds on the trellis . </S>",
    "<S> this is an adaptation of an algorithm proposed earlier with the advantage that it reduces the time complexity from @xmath0 to @xmath1 where @xmath2 is the number of nodes in the tail - biting trellis . </S>",
    "<S> a necessary condition for the output of the algorithm to differ from the output of the ideal ml decoder is deduced and simulation results on an awgn channel using tail - biting trellises for two rate 1/2 convolutional codes with memory 4 and 6 respectively , are reported . </S>"
  ]
}