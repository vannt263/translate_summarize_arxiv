{
  "article_text": [
    "energy disaggregation ( also called non - intrusive load monitoring or nilm ) is a computational technique for estimating the power demand of individual appliances from a single meter which measures the combined demand of multiple appliances .",
    "one use - case is the production of itemised electricity bills from a single , whole - home smart meter .",
    "the ultimate aim might be to help users reduce their energy consumption ; or to help operators to manage the grid ; or to identify faulty appliances ; or to survey appliance usage behaviour .",
    "research on nilm started with the seminal work of george hart  @xcite in the mid-1980s .",
    "hart described a ` signature taxonomy ' of features  @xcite and his earliest work from 1984 described experiments of extracting more detailed features .",
    "however , hart decided to focus on extracting only transitions between steady - states .",
    "many nilm algorithms designed for low frequency data ( 1  hz or slower ) follow hart s lead and only extract a small number of features . in contract , in high frequency nilm ( sampling at khz or even mhz ) , there are numerous examples in the literature of manually engineering rich feature extractors ( e.g. @xcite ) .",
    "humans can learn to detect appliances in aggregate data by eye , especially appliances with feature - rich signatures such as the washing machine signature shown in figure  [ fig : washer ] .",
    "humans almost certainly make use of a variety of features such as the rapid on - off cycling of the motor ( which produces the rapid @xmath0  watt oscillations ) , the ramps towards the end as the washer starts to rapidly spin the clothes etc .",
    "we _ could _ consider hand - engineering feature extractors for these rich features .",
    "but this would be time consuming and the resulting feature detectors may not be robust to noise and artefacts .",
    "two key research questions emerge : could an algorithm _ automatically learn _ to detect these features ?",
    "can we learn anything from neighbouring machine learning fields such as image classification ?    before 2012 , the dominant approach to extracting features for image classification was to hand - engineer feature detectors such as scale - invariant feature transform  @xcite ( sift ) and difference of gaussians ( dog ) .",
    "then , in 2012 , krizhevsky _ et al . _",
    "s winning algorithm  @xcite in the imagenet large scale visual recognition challenge achieved a substantially lower error score ( 15% ) than the second - best approach ( 26% ) .",
    "s approach did not use hand - engineered feature detectors .",
    "instead they used a deep neural network which automatically learnt to extract a _ hierarchy of features _ from the raw image .",
    "deep learning is now a dominant approach not only in image classification but also fields such as automatic speech recognition  @xcite , machine translation  @xcite , even learning to play computer games from scratch  @xcite !    in this paper , we investigate whether deep neural nets can be applied to energy disaggregation .",
    "the use of ` small ' neural nets on nilm dates back at least to roos _ et al . _",
    "1994  @xcite ( although that paper was just a proposal ) and continued with  @xcite but these small nets do not appear to learn a hierarchy of feature detectors . a big breakthrough in image classification came when the compute power ( courtesy of gpus ) became available to train _ deep _ neural networks on large amounts of data . in the present research ,",
    "we want to see if deep neural nets can deliver good performance on energy disaggregation .",
    "our main contribution is to adapt three deep neural network architectures to nilm . for each architecture , we train one network per target appliance .",
    "we compare two benchmark disaggregation algorithms ( combinatorial optimisation and factorial hidden markov models ) to the disaggregation performance of our three deep neural nets using seven metrics .",
    "we also examine how well our neural nets generalise to appliances in houses not seen during training because , ultimately , when nilm is used ` in the field ' we very rarely have ground truth appliance data for the houses for which we want to disaggregate .",
    "so it is essential that nilm algorithms can generalise to unseen houses .",
    "please note that , once trained , our neural nets _ do not _ need ground truth appliance data from each house !",
    "end - users would only need to provide aggregate data .",
    "this is because each neural network should learn the ` essence ' of its target appliance such that it can generalise to unseen instances of that appliance . in a similar fashion ,",
    "neural networks trained to do image classification are trained on many examples of each category ( dogs , cats , etc . ) and generalise to unseen examples of each category .    to provide more context",
    ", we will briefly sketch how our neural networks could be deployed at scale , in the wild .",
    "each net would undergo _ supervised _ training on _ many _ examples of its target appliance type so each network learns to generalise well to unseen appliances .",
    "training is computationally expensive ( days of processing on a fast gpu ) .",
    "but training does not have to be performed often .",
    "once these networks are trained , inference is much cheaper ( around a second of processing per network on a fast gpu for a week of aggregate data ) .",
    "aggregate data from unseen houses would be fed through each network .",
    "each network should filter out the power demand for its target appliance .",
    "this processing would probably be too computationally expensive to run on an embedded processor inside a smart meter or in - home - display .",
    "instead , the aggregate data could be sent from the smart meter to the cloud .",
    "the storage requirements for one 16  bit integer sample ( 0 - 64  kw in 1  watt steps ) every ten seconds is 17  kilobytes per day uncompressed .",
    "this signal should be easily compressible because there are numerous periods in domestic aggregate power demand with little or no change . with a compression ratio of 5:1 , and ignoring the datetime index ,",
    "the total storage requirements for a year of data from 10  million users would be 13  terabytes ( which could fit on two 8  tb disks ) .",
    "if one week of aggregate data can be processed in one second per home ( which should be possible given further optimisation ) then data from 10  million users could be processed by 16 gpu compute nodes . alternatively , disaggregation could be performed on a compute device within each home ( a modern laptop or mobile phone or a dedicated ` disaggregation hub ' could handle the disaggregation ) .",
    "a gpu is not _ required _ for disaggregation , although it makes it faster .",
    "this paper is structured as follows : in section  [ sec : intronets ] we provide a very brief introduction to artificial neural nets . in section  [ sec : data ] we describe how we prepare the training data for our nets and how we ` augment ' the training data by synthesising additional data . in section  [ sec : nets ] we describe how we adapted three neural net architectures to nilm . in section  [ sec : disaggregation ] we describe how we do disaggregation with our nets . in section  [ sec : results ] we present the disaggregation results of our three neural nets and two benchmark nilm algorithms .",
    "finally , in section  [ sec : conclusions ] discuss our results , offer our conclusions and describe some possible future directions for research .",
    "an artificial neural network ( ann ) is a directed graph where the nodes are artificial neurons and the edges allow information from one neuron to pass to another neuron ( or the same neuron in a future time step ) .",
    "neurons are typically arranged into layers such that each neuron in layer @xmath1 connects to every neuron in layer @xmath2 .",
    "connections are weighted and it is through modification of these weights that anns learn .",
    "anns have an _ input layer _ and an _ output layer_. any layers in between are called _",
    "hidden layers_. the _ forward pass _ of an ann is where information flows from the input layer , through any hidden layers , to the output . learning ( updating the weights ) happens during the _ backwards pass_.      each artificial neuron calculates a weighted sum of its inputs , adds a learnt bias and passes this sum through an activation function . consider a neuron which receives @xmath3 inputs .",
    "the value of each input is represented by input vector @xmath4 .",
    "the weight on the connection from input @xmath5 to neuron @xmath6 is denoted by @xmath7 ( so @xmath8 is the ` weights matrix ' ) .",
    "the weighted sum ( also called the ` network input ' ) of the inputs into neuron @xmath6 can be written @xmath9 .",
    "the network input @xmath10 is then passed through an activation function @xmath11 to produce the neuron s final output @xmath12 where @xmath13 . in this paper , we use the following activation functions : linear : @xmath14 ; rectified linear ( relu ) : @xmath15 ; hyperbolic tangent ( tanh ) : @xmath16 .",
    "multiple nonlinear hidden layers can be used to re - represent the input data ( hopefully by learning a hierarchy of feature detectors ) , which gives deep nonlinear networks a great deal of expressive power  @xcite .",
    "the basic idea of the backwards pass it to first do a forwards pass through the entire network to get the network s output for a specific network input .",
    "then compute the error of the output relative to the target ( in all our experiments we use the mean squared error ( mse ) as the objective function ) . then modify the weights in the direction which should reduce the error .    in practice ,",
    "the forward pass is often computed over a _ batch _ of randomly selected input vectors . in our work , we use a batch size of 64 sequences per batch for all but the largest recurrent neural network ( rnn ) experiments . in our largest rnns we use a batch size of 16 ( to allow the network to fit into the 3 gb of ram on our gpu ) .",
    "how do we modify each weight to reduce the error ?",
    "it would be computationally intractable to enumerate the entire error surface .",
    "mse gives a smooth error surface and the activation functions are differentiable hence we can use gradient descent . the first step is to compute the gradient of the error surface at the position for current batch by calculating the derivative of the objective function with respect to each weight",
    ". then we modify each weight by adding the gradient multiplied by a ` learning rate ' scalar parameter . to efficiently compute the gradient ( in @xmath17 time ) we use the backpropagation algorithm  @xcite . in all our experiments we use stochastic gradient descent ( sgd ) with nesterov momentum of @xmath18 .",
    "consider the task of identifying objects in a photograph .",
    "no matter if we hand engineer feature detectors or learn feature detectors from the data , it turns out that useful ` low level ' features concern small patches of the image and include features such as edges of different orientations , corners , blobs etc . to extract these features ,",
    "we want to build a small number of feature detectors ( one for horizontal lines , one for blobs etc . ) with small receptive fields ( overlapping sub - regions of the input image ) and slide these feature detectors across the entire image .",
    "convolutional neural nets ( cnns )  @xcite build a small number of filters , each with a small receptive field , and these filters are duplicated ( with shared weights ) across the entire input .",
    "similarly to computer vision tasks , in time series problems we often want to extract a small number of low level features with a small receptive fields across the entire input .",
    "all of our nets use at least one 1d convolutional layer at the input .",
    "deep neural nets need a lot of training data because they have a large number of trainable parameters ( the network weights and biases ) .",
    "the nets described in this paper have between 1  million to 150  million trainable parameters .",
    "large training datasets are important .",
    "it is also common practice in deep learning to increase the effective size of the training set by duplicating the training data many times and applying realistic transformations to each copy .",
    "for example , in image classification , we might flip the image horizontally or apply slight affine transformations .    a related approach to creating a large training dataset is to generate simulated data .",
    "for example , google deepmind train their algorithms  @xcite on computer games because they can generate an effectively infinite amount of training data .",
    "realistic synthetic speech audio data or natural images are harder to produce .    in energy disaggregation",
    ", we have the advantage that generating effectively infinite amounts of synthetic aggregate data is relatively easy by randomly combining real appliance activations .",
    "( we define an ` appliance activation ' to be the power drawn by a single appliance over one complete cycle of that appliance . for example",
    ", figure  [ fig : washer ] shows a single activation for a washing machine . )",
    "we trained our nets on both synthetic aggregate data and real aggregate data in a 50:50 ratio .",
    "we found that synthetic data acts as a regulariser .",
    "in other words , training on a mix of synthetic and real aggregate data rather than just real data appears to improve the net s ability to generalise to unseen houses . for validation and testing",
    "we use only real data ( not synthetic ) .",
    "we used uk - dale  @xcite as our source dataset .",
    "each submeter in uk - dale samples once every 6  seconds .",
    "all houses record aggregate apparent mains power once every 6  seconds . houses  1 , 2 and 5 also record active and reactive mains power once a second . in these houses , we downsampled the 1  second active mains power to 6  seconds to align with the submetered data and used this as the real aggregate data from these houses .",
    "any gaps in appliance data shorter than 3  minutes are assumed to be due to rf issues and so are filled by forward - filling .",
    "any gaps longer than 3  minutes are assumed to be due to the appliance and meter being switched off and so are filled with zeros .",
    "we manually checked a random selection of appliance activations from every house .",
    "the uk - dale metadata shows that house  4 s microwave and washing machine share a single meter ( a fact that we manually verified ) and hence these appliances from house  4 are not used in our training data .",
    "we train one network per target appliance .",
    "the target ( i.e. the desired output of the net ) is the power demand of the target appliance .",
    "the input to every net we describe in this paper is a window of aggregate power demand .",
    "the window width is decided on an appliance - by - appliance basis and varies from 128 samples ( 13  minutes ) for the kettle to 1536 samples ( 2.5  hours ) for the dish washer .",
    "we found that increasing the window size hurts disaggregation performance for short - duration appliances ( for example , using a sequence length of 1024 for the fridge resulted in the autoencoder ( ae ) failing to learn anything useful and the ` rectangles ' net achieved an f1 score of 0.68 ; reducing the sequence length to 512 allowed the ae to get an f1 score of 0.87 and the ` rectangles ' net got a score of 0.82 ) . on the other hand , it is important to ensure that the window width is long enough to capture the majority of the appliance activations .    for each house , we reserved the last week of data for testing and used the rest of the data for training .",
    "the number of appliance training activations is show in table  [ table : training_activations ] and the number of testing activations is shown in table  [ table : testing_activations ] .",
    "the specific houses used for training and testing is shown in table  [ table : houses ] .",
    "we used five target appliances in all our experiments : the fridge , washing machine , dish washer , kettle and microwave .",
    "we chose these appliances because each is present in at least three houses in uk - dale .",
    "this means that , for each appliance , we can train our nets on at least two houses and test on a different house .",
    "these five appliances consume a significant proportion of energy and the five appliances represent a range of different power ` signatures ' from the simple on / off of the kettle to the complex pattern shown by the washing machine ( figure  [ fig : washer ] ) .    ` small ' appliances such as games consoles and phone chargers are problematic for many nilm algorithms because the effect of small appliances on aggregate power demand tends to get lost in the noise . by definition",
    ", small appliances do not consume much energy individually but modern homes tend to have a large number of such appliances so their combined consumption can be significant",
    ". hence it would be useful to detect small appliances using nilm .",
    "we have not explored whether our neural nets perform well on ` small ' appliances but we plan to in the future .",
    "appliance activations are extracted using nilmtk s  @xcite + ` electric.get_activations ( ) ` method .",
    "the arguments we passed to ` get_activations ( ) ` for each appliance are shown in table  [ table : get_activations_arguments ] . on simple appliances such as toasters , we extract activations by finding strictly consecutive samples above some threshold power .",
    "we then throw away any activations shorter than some threshold duration ( to ignore spurious spikes ) . for more complex appliances such as washing machines",
    "whose power demand can drop below threshold for short periods during a cycle , nilmtk ignores short periods of sub - threshold power demand .",
    "first we locate all the activations of the target appliance in the home s submeter data for the target appliance .",
    "then , for each training example , the code decides with 50% probability whether this example should include the target appliance or not .",
    "if the code decides not include the target appliance then it finds a random window of aggregate data in which there are no activations of the target appliance .",
    "otherwise , the code randomly selects a target appliance activation and randomly positions this activation within the window of data that will be shown to the net as the target ( with the constraint that the activation must be captured completely in the window of data shown to the net , unless the window is too short to contain the entire activation ) .",
    "the corresponding time window of real aggregate data is also loaded and shown to the net and its input .",
    "if other activations of the target appliance happen to appear in the aggregate data then these are not included in the target sequence ; the net is trained to focus on the first complete target appliance activation in the aggregate data .      to create synthetic aggregate data we start by extracting a set of appliance activations for five appliances across all training houses : kettle , washing machine , dish washer , microwave and fridge . to create a single sequence of synthetic data ,",
    "we start with two vectors of zeros : one vector will become the input to the net ; the other will become the target .",
    "the length of each vector defines the ` window width ' of data that the network sees .",
    "we go through the five appliance classes and decide whether or not to add an activation of that class to the training sequence .",
    "there is a 50% chance that the target appliance will appear in the sequence and a 25% chance for each other ` distractor ' appliance . for each selected appliance class",
    ", we randomly select an appliance activation and then randomly pick where to add that activation on the input vector .",
    "distractor appliances can appear anywhere in the sequence ( even if this means that only part of the activation will be included in the sequence ) .",
    "the target appliance activation must be completely contained within the sequence ( unless it is too large to fit ) .",
    "of course , this relatively nave approach to synthesising aggregate data ignores a lot of structure that appears in real aggregate data .",
    "for example , the kettle and toaster might often appear within a few minutes of each other in real data , but our simple ` simulator ' is completely unaware of this sort of structure .",
    "we expect that a more realistic simulator might increase the performance of deep neural nets on energy disaggregation .",
    "all our code is written in python and we make use pandas , numpy and nilmtk for data preparation .",
    "each network receives data in a mini - batch of 64 sequences ( except for the large rnn sequences , in which case we use a batch size of 16 sequences ) .",
    "the code is multi - threaded so the cpu can be busy preparing one batch of data on the fly whilst the gpu is busy training on the previous batch .",
    "in general , neural nets learn most efficiently if the input data has zero mean .",
    "first , the mean of each sequence is subtracted from the sequence to give each sequence a mean of zero .",
    "every input sequence is divided by the standard deviation of a random sample of the training set .",
    "we do not divide each sequence by its _",
    "own _ standard deviation because that would change the scaling and the scaling is likely to be important for nilm .    forcing each sequence to have zero mean throws away information .",
    "information that nilm algorithms such as combinatorial optimisation and factorial hidden markov models rely on .",
    "we have done some preliminary experiments and found that neural nets appear to be able to generalise better if we independently centre each sequence .",
    "but there are likely to be ways to have the best of both worlds : i.e. to give the network information about the absolute power whilst also allowing the network to generalise well .",
    "one big advantage of training our nets on sequences which have been independently centred is that our nets do not need to consider vampire ( always on ) loads .",
    "targets are divided by a hand - coded ` maximum power demand ' for each appliance to put the target power demand into the range [ 0 , 1 ] .",
    "l s[table - format=5 ] s[table - format=4 ] s[table - format=2 ] s[table - format=4 ] s[table - format=4 ] & 1 & 2 & 3 & 4 & 5 + kettle & 2836 & 543 & 44 & 716 & 176 + fridge & 16336 & 3526 & 0 & 4681 & 1488 + washing machine & 530 & 53 & 0 & 0 & 51 + microwave & 3266 & 387 & 0 & 0 & 28 + dish washer & 197 & 98 & 0 & 23 & 0 +     l s[table - format=3 ] s[table - format=3 ] s[table - format=2 ] s[table - format=3 ] s[table - format=3 ] & 1 & 2 & 3 & 4 & 5 + kettle & 54 & 29 & 40 & 50 & 18 + fridge & 168 & 277 & 0 & 145 & 140 + washing machine & 10 & 4 & 0 & 0 & 2 + microwave & 90 & 9 & 0 & 0 & 4 + dish washer & 3 & 7 & 0 & 3 +    .houses used for training and testing . [ cols=\"<,<,^\",options=\"header \" , ]      l s[table - format=4 ] s[table - format=4 ] s[table - format=4 ] s[table - format=4 ] & max & on power & min . on & min .",
    "off + appliance & power & threshold & duration & duration + & ( watts ) & ( watts ) & ( secs ) & ( secs ) + kettle & 3100 & 2000 & 12 & 0 + fridge & 300 & 50 & 60 & 12 + washing m. & 2500 & 20 & 1800 & 160 + microwave & 3000 & 200 & 12 & 30 + dish washer & 2500 & 10 & 1800 & 1800 +",
    "in this section we describe how we adapted three different neural net architectures to do nilm .",
    "in section  [ sec : intronets ] we described _ feed forward _",
    "neural networks which map from a single input vector to a single output vector . when the network is shown a second input vector , it has no memory of the previous input .",
    "recurrent neural networks ( rnns ) allow cycles in the network graph such that the output from neuron @xmath5 in layer @xmath1 at time step @xmath19 is fed via weighted connections to every neuron in layer @xmath1 ( including neuron @xmath5 ) at time step @xmath20 .",
    "this allows rnns , in principal , to map from the _ entire history _ of the inputs to an output vector .",
    "this makes rnns especially well suited to sequential data . in our work , we train rnns using backpropagation through time ( bptt )  @xcite .    in practice",
    ", rnns can suffer from the ` vanishing gradient ' problem  @xcite where gradient information disappears or explodes as it is propagated back through time .",
    "this can limit an rnn s memory .",
    "one solution to this problem is the ` long short - term memory ' ( lstm ) architecture  @xcite which uses a ` memory cell ' with a gated input , gated output and gated feedback loop .",
    "the intuition behind lstm is that it is a differentiable latch ( where a ` latch ' is the fundamental unit of a digital computer s ram ) .",
    "lstms have been used with success on a wide variety of sequence tasks including automatic speech recognition  @xcite and machine translation  @xcite .    an additional enhancement to rnns is to use _ bidirectional _ layers . in a bidirectional rnn , there are effectively two parallel rnns , one reads the input sequence forwards and the other reads the input sequence backwards .",
    "the output from the forwards and backwards halves of the network are combined either by concatenating them or doing an element - wise sum ( we experimented with both and settled on concatenation , although element - wise sum appeared to work almost as well and is computationally cheaper ) .",
    "we should note that bidirectional rnns are not naturally suited to doing online disaggregation .",
    "bidirectional rnns could still be used for online disaggregation if we frame ` online disaggregation ' as doing _ frequent , small batches _ of offline disaggregation .",
    "we experimented with both rnns and lstms and settled on the following architecture for energy disaggregation :    1 .",
    "input ( length determined by appliance duration ) 2 .",
    "1d conv ( filter size=4 , stride=1 , number of filters=16 , activation function = linear , border mode = same ) 3 .",
    "bidirectional lstm ( n=128 , with peepholes ) 4 .",
    "bidirectional lstm ( n=256 , with peepholes ) 5 .   fully connected ( n=128 , activation function = tanh ) 6 .",
    "fully connected ( n=1 , activation function = linear )    at each time step , the network sees a single sample of aggregate power data and outputs a single sample of power data for the target appliance .    in principal",
    ", the convolutional layer should not be necessary ( because the lstms should be able to remember all the context ) .",
    "but we found the addition of a convolution layer to slightly increase performance ( the conv .",
    "layer convolves over the time axis )",
    ". we also experimented with adding a conv . layer _ between _ the two lstm layers with a stride >  1 to implement hierarchical subsampling  @xcite .",
    "this showed promise but we did not use it for our final experiments .    on the backwards",
    "pass , we clip the gradient at [ -10 , 10 ] as per alex graves in  @xcite . to speed up computation , we propagate the gradient backwards a maximum of 500 time steps .",
    "figure  [ fig : net_output ] shows an example output of our lstm network in the two ` rnn ' rows .      in this section , we frame energy disaggregation as a ` denoising ' task .",
    "typical denoising tasks include removing grain from an old photograph ; or removing reverb from an audio recording ; or even in - filling a masked part of an image .",
    "energy disaggregation can be viewed as an attempt to recover the ` clean ' power demand signal of the target appliance from the background ` noise ' produced by the other appliances .",
    "a successful neural network architecture for denoising tasks is the ` denoising autoencoder ' .",
    "an autoencoder ( ae ) is simply a network which tries to reconstruct the input .",
    "described like this , aes might not sound very useful !",
    "the key is that aes first _",
    "encode _ the input to a _ compact _ vector representation ( in the ` code layer ' ) and then _ decode _ to reconstruct the input .",
    "the simplest way of forcing the net to discover a _ compact _ representation of the data is to have a code layer with less dimensions than the input . in this case , the ae is doing dimensionality reduction .",
    "indeed , a linear ae with a single hidden layer is almost equivalent to pca . but",
    "aes can be deep and non - linear .",
    "a denoising autoencoder ( dae )  @xcite is an autoencoder which attempts to reconstruct a clean target from a noisy input .",
    "daes are typically trained by artificially corrupting a signal before it goes into the net s input , and using the clean signal as the net s target . in nilm",
    ", we consider the corruption as being the power demand from the other appliances .",
    "so we do not add noise artificially .",
    "instead we use the aggregate power demand as the ( noisy ) input to the net and ask the net to reconstruct the clean power demand of the target appliance .",
    "the first and last layers of our nilm daes are 1d convolutional layers .",
    "we use convolutional layers because we want the network to learn low level feature detectors which are applied equally across the _ entire _ input window ( for example , a step change of 1000  watts might be a useful feature to extract , no matter where it is found in the input ) .",
    "the aim is to provide some invariance to where exactly the activation is positioned within the input window .",
    "the last layer does a ` deconvolution ' .",
    "the exact architecture is as follows :    1 .",
    "input ( length determined by appliance duration ) 2 .",
    "1d conv ( filter size=4 , stride=1 , number of filters=8 , activation function = linear , border mode = valid ) 3 .   fully connected ( n=(sequence length - 3 ) @xmath21 8 , + activation function = relu ) 4 .   fully connected ( n=128 ; activation function = relu ) 5 .   fully connected ( n=(sequence length - 3 ) @xmath21 8 , + activation function = relu )",
    "1d conv ( filter size=4 , stride=1 , number of filters=1 , activation function = linear , border mode = valid )    layer 4 is the middle , code layer .",
    "the entire dae is trained end - to - end in one go ( we do not do layer - wise pre - training as we found it did not increase performance ) .",
    "we do not tie the weights as we found this also appears to not enhance nilm performance .",
    "an example output of our nilm dae is shown in figure  [ fig : net_output ] in the two ` autoencoder ' rows .",
    "many applications of energy disaggregation do not require a detailed second - by - second reconstruction of the appliance power demand . instead , most energy disaggregation use - cases require , for each appliance activation , the identification of the start time , end time and energy consumed . in other words , we want to draw a rectangle around each appliance activation in the aggregate data where the left side of the rectangle is the start time , the right side is the end time and the height is the average power demand of the appliance between the start and end times .",
    "deep neural networks have been used with great success on related tasks .",
    "for example , nouri used deep neural networks to estimate the 2d location of ` facial keypoints ' in images of faces  @xcite .",
    "example ` keypoints ' are ` left eye centre ' or ` mouth centre top lip ' . the input to nouri s neural net is the raw image of a face .",
    "the output of the network is a set of @xmath22 coordinates for each keypoint .",
    "our idea was to train a neural network to estimate three scalar , real - valued outputs : the start time , the end time and mean power demand of the first appliance activation to appear in the aggregate power signal .",
    "if there is no target appliance in the aggregate data then all three outputs should be zero .",
    "if there is more than one activation in the aggregate signal then the network should ignore all but the first activation .",
    "all outputs are in the range [ 0 , 1 ] .",
    "the start and end times are encoded as a proportion of the input s time window .",
    "for example , the start of the time window is encoded as 0 , the end is encoded as 1 and half way through the time window is encoded as 0.5 .",
    "for example , consider a scenario where the input window width is 10  minutes and an appliance activation starts 1  minute into the window and ends 1  minute before the end of the window .",
    "this activation would be encoded as having a start location of 0.1 and an end location of 0.9 .",
    "example output is shown in figure  [ fig : net_output ] in the two ` rectangles ' rows .",
    "the three target values for each sequence are calculated during data pre - processing . as for all of our other networks ,",
    "the network s objective is to minimise the mean squared error .",
    "the exact architecture is as follows :    1 .",
    "input ( length determined by appliance duration ) 2 .",
    "1d conv ( filter size=4 , stride=1 , number of filters=16 , activation function = linear , border mode = valid ) 3 .",
    "1d conv ( filter size=4 , stride=1 , number of filters=16 , activation function = linear , border mode = valid ) 4 .",
    "fully connected ( n=4096 , activation function = relu ) 5 .",
    "fully connected ( n=3072 ; activation function = relu ) 6 .",
    "fully connected ( n=2048 , activation function = relu ) 7 .",
    "fully connected ( n=512 , activation function = relu ) 8 .",
    "fully connected ( n=3 , activation function = linear )      we implemented our neural nets in python using the + https://github.com/lasagne/lasagne[lasagne library ] ] .",
    "lasagne is built on top of http://www.deeplearning.net/software/theano/[theano ]  @xcite .",
    "we trained our nets on an nvidia gtx 780ti gpu with 3  gb of ram ( but note that theano also allows code to be run on the cpu without requiring any changes to the user s code ) .",
    "on this gpu , our nets typically took between 1 and 12 hours to train per appliance .",
    "the exact code used to create the results in paper is available in our ` https://github.com/jackkelly/neuralnilm_prototype[neuralnilm prototype ] ' repository ] and a more elegant ( hopefully ! )",
    "re - write is available in our ` https://github.com/jackkelly/neuralnilm[neuralnilm ] ' repository ] .",
    "we manually defined the number of weight updates to perform during training for each experiment .",
    "for the rnns we performed 10,000 updates , for the denoising autoencoders we performed 100,000 and for the regression network we performed 300,000 updates .",
    "neither the rnns nor the aes appeared to continue learning past this number of updates .",
    "the regression networks appear to keep learning no matter how many updates we perform !",
    "the nets have a wide variation in the number of trainable parameters .",
    "the largest dae nets range from 1 m to 150 m ( depending on the input size ) ; the rnns all had 1 m parameters and the regression nets varied from 28 m to 120 m parameters ( depending on the input size ) .",
    "all our network weights were initialised randomly using lasagne s default initialisation .",
    "all of the experiments presented in this paper trained end - to - end from random initialisation ( no layerwise pre - training ) .",
    "how do we disaggregate arbitrarily long sequences of aggregate data given that each net has an input window duration of , at most , a few hours ? we first pad the beginning and end of the input with zeros .",
    "then we slide the net along the input sequence . as such",
    ", the first sequence we show to the network will be all zeros .",
    "then we shift the input window ` stride ` samples to the right , where ` stride ` is a manually defined positive , non - zero integer .",
    "if ` stride ` is less than the length of the net s input window then the net will see overlapping input sequences .",
    "this allows the network to have multiple attempts at processing each appliance activation in the aggregate signal , and on each attempt each activation will be shifted to the left by ` stride ` samples .    over the course of disaggregation , the network produces multiple estimated values for each time step because we give the network overlapping segments of the input . for our first two network architectures ,",
    "we combine the multiple values per timestep simply by taking the mean .    combing",
    "the output from our third network is a little more complex .",
    "we layer every predicted ` appliance rectangle ' on top of each other .",
    "we measure the overlap and normalise the overlap to [ 0 , 1 ] .",
    "this gives a probabilistic output for each appliance s power demand . to convert this to a single vector per appliance , we threshold the power and probability",
    "the disaggregation results on an unseen house are shown in figure  [ fig : results_unseen_house ] .",
    "the results on houses seen during training are shown in figure  [ fig : results_train_houses ] .",
    "we used benchmark implementations from nilmtk  @xcite of the combinatorial optimisation ( co ) and factorial hidden markov model ( fhmm ) algorithms .    on the unseen house ( figure  [ fig : results_unseen_house ] ) , both the denoising autoencoder and the net which regresses the start time , end time and power demand ( the ` rectangles ' architecture ) out - perform co and fhmm on every appliance on f1 score , precision score , proportion of total energy correctly assigned and mean absolute error",
    "the lstm out - performs co and fhmm on two - state appliances ( kettle , fridge and microwave ) but falls behind co and fhmm on multi - state appliances ( dish washer and washing machine ) .    on the houses seen during training ( figure  [ fig : results_train_houses ] )",
    ", the dae outperforms co and fhmm on every appliance on every metric except relative error in total energy .",
    "the ` rectangles ' architecture outperforms co and fhmm on every appliance ( except the microwave ) on f1 , precision , accuracy , proportion of total energy correctly assigned and mean absolute error .",
    "the full disaggregated time series for all our algorithms and the aggregate data and appliance ground truth data are available at http://www.doc.ic.ac.uk/~dk3810/neuralnilm[www.doc.ic.ac.uk/@xmath23dk3810/neuralnilm ]    the metrics we used are :    @xmath24    * proportion of total energy correctly assigned * = @xmath25    the proportion of total energy correctly assigned is taken from  @xcite .",
    "we have adapted three neural network architectures to nilm .",
    "the denoising autoencoder and the ` rectangles ' architectures perform well , especially on unseen houses .",
    "we believe that deep neural nets show great promise for nilm .",
    "but there is plenty of work still to do !",
    "it is worth noting that our comparison between each architecture is not entirely fair because the architectures have a wide range of trainable parameters .",
    "for example , every lstm we used had 1 m parameters whilst the larger dae and rectangles nets had over 150 m parameters ( we did try training an lstm with more parameters but it did not appear to improve performance ) .",
    "our lstm results suggest that lstms work best for two - state appliances but do not perform well on multi - state appliances such as the dish washer and washing machine .",
    "one possible reason is that , for these appliances , informative ` events ' in the power signal can be many time steps apart ( e.g. for the washing machine there might be over 1,000 time steps between the first heater activation and the spin cycle ) .",
    "in principal , lstms have an arbitrarily long memory .",
    "but these long gaps between informative events may present a challenge for lstms .",
    "further work is required to understand exactly why lstms struggle on multi - state appliances .",
    "one aspect of our lstm results that we _ did _ expect was that processing overlapping windows of aggregate data would not be necessary for lstms because they always output the same estimates , no matter what the offset of the input window ( see figure  [ fig : net_output ] ) .    we must also note that the fhmm implementation used in this work is not ` state of the art ' and neither is it especially tuned .",
    "other fhmm implementations are likely to perform better .",
    "we encourage other researchers to downloaddk3810/neuralnilm ] ] our disaggregation estimates and ground truth data and directly compare against our algorithms !",
    "this work represents just a first step towards adapting the vast number of techniques from the deep learning community to nilm , for example :      uk - dale has many hundreds of days of data but only from five houses .",
    "any machine learning algorithm is only able to generalise if given enough variety in the training set .",
    "for example , house  5 s dish washer sometimes has four activations of its heater but the dish washers in the two training houses ( 1 and 2 ) only ever have two peaks .",
    "hence the autoencoder completely ignores the first two peaks of house  5 s dish washer !",
    "if neural nets are to learn to generalise well then we must train on much larger numbers of appliances ( hundreds or thousands ) .",
    "this should help the networks to generalise across the wide variation seen in some classes of appliance .",
    "in nilm , we generally have access to much more _ unlabelled _ data than _ labelled _ data .",
    "one advantage of neural nets is that they could , in principal , be ` pre - trained ' on unlabelled data before being fine - tuned on labelled data . `",
    "pre - training ' should allow the networks to start to identify useful features from the data but does not allow the nets to learn to _ label _ appliances .",
    "( pre - training is rarely used in modern image classification tasks because very large labelled datasets are available for image classification .",
    "but in nilm we have much more unlabelled data than labelled data , so pre - training is likely to be useful . ) after unsupervised pre - training , each net would undergo _ supervised _ training . instead of ( or as well as ) pre - training on all available unlabelled data , it may also be interesting to try pre - training largely on unlabelled data from each house that we wish to disaggregate .",
    "jack kelly s phd is funded by the epsrc and by intel via their eu doctoral student fellowship programme .",
    "the authors would like to thank pedro nascimento for his comments on a draft of this manuscript .",
    "n.  amirach , b.  xerri , b.  borloz , and c.  jauffret . a new approach for event detection and feature extraction for nilm . in _",
    "electronics , circuits and systems ( icecs ) , 2014 21st ieee international conference on _ , pages 287290 .",
    "ieee , 2014 .",
    "a.  krizhevsky , i.  sutskever , and g.  e. hinton .",
    "imagenet classification with deep convolutional neural networks . in f.",
    "pereira , c.  burges , l.  bottou , and k.  weinberger , editors , _ advances in neural information processing systems 25 _ , pages 10971105 .",
    "curran associates , inc . , 2012 .",
    "a.  graves and n.  jaitly . towards end - to - end speech recognition with recurrent neural networks . in _ proceedings of the 31st international conference on machine learning ( icml-14 )",
    "_ , pages 17641772 , 2014 .",
    "i.  sutskever , o.  vinyals , and q.  v. le .",
    "sequence to sequence learning with neural networks . in z.",
    "ghahramani , m.  welling , c.  cortes , n.  lawrence , and k.  weinberger , editors , _ advances in neural information processing systems 27 _ , pages 31043112 .",
    "curran associates , inc . , 2014 .",
    "v.  mnih , k.  kavukcuoglu , d.  silver , a.  a. rusu , j.  veness , m.  g. bellemare , a.  graves , m.  riedmiller , a.  k. fidjeland , g.  ostrovski , et  al . human - level control through deep reinforcement learning .",
    ", 518(7540):529533 , 2015 .",
    "j.  roos , i.  lane , e.  botha , and g.  p. hancke .",
    "using neural networks for non - intrusive monitoring of industrial electrical loads . in _ instrumentation and measurement technology conference , 1994 .",
    "imtc/94 . conference proceedings .",
    "10th anniversary .",
    "advanced technologies in i & m. , 1994 ieee _ , pages 11151118 .",
    "ieee , 1994 .",
    "http://dx.doi.org/10.1109/imtc.1994.351862 [ ] .",
    "yang , h .- h .",
    "chang , and c .- l .",
    "design a neural network for features selection in non - intrusive monitoring of industrial electrical loads . in _ computer supported cooperative work in design , 2007 .",
    "cscwd 2007 .",
    "11th international conference on _ , pages 10221027 .",
    "ieee , 2007 .",
    "http://dx.doi.org/10.1109/cscwd.2007.4281579 [ ] .",
    "lin and m .- s .",
    "tsai . a novel feature extraction method for the development of nonintrusive load monitoring system based on bp - ann . in _",
    "2010 international symposium on computer communication control and automation ( 3ca ) _ , volume  2 , pages 215218 .",
    "ieee , 2010 .",
    "http://dx.doi.org/10.1109/3ca.2010.5533571 [ ] .",
    "a.  g. ruzzelli , c.  nicolas , a.  schoofs , and g.  m. ohare .",
    "real - time recognition and profiling of appliances through a single electricity sensor . in _",
    "sensor mesh and ad hoc communications and networks ( secon ) , 2010 7th annual ieee communications society conference on _ , pages 19 .",
    "ieee , 2010 .",
    "chang , p .- c .",
    "chien , l .- s .",
    "lin , and n.  chen .",
    "feature extraction of non - intrusive load - monitoring system using genetic algorithm in smart meters . in _",
    "e - business engineering ( icebe ) , 2011 ieee 8th international conference on _ , pages 299304 .",
    "ieee , 2011 .",
    "l.  e. atlas , t.  homma , and r.  j. marks  ii .",
    "an artificial neural network for spatio - temporal bipolar patterns : application to phoneme classification . in",
    "neural information processing systems ( nips ) _ , page  31 , 1988 .",
    "n.  batra , j.  kelly , o.  parson , h.  dutta , w.  knottenbelt , a.  rogers , a.  singh , and m.  srivastava .",
    ": an open source toolkit for non - intrusive load monitoring . in",
    "fifth international conference on future energy systems ( acm e - energy ) _ , cambridge , uk , 2014 . http://dx.doi.org/10.1145/2602044.2602051 [ ] .",
    "p.  vincent , h.  larochelle , y.  bengio , and p .- a .",
    "manzagol . extracting and composing robust features with denoising autoencoders . in _ proceedings of the 25th international conference on machine learning _ , pages 10961103 .",
    "acm , 2008 .",
    "j.  bergstra , o.  breuleux , f.  bastien , p.  lamblin , r.  pascanu , g.  desjardins , j.  turian , d.  warde - farley , and y.  bengio .",
    "theano : a cpu and gpu math expression compiler . in _ proceedings of the python for scientific computing conference ( scipy )",
    "_ , june 2010 . oral presentation .",
    "f.  bastien , p.  lamblin , r.  pascanu , j.  bergstra , i.  j. goodfellow , a.  bergeron , n.  bouchard , and y.  bengio .",
    "theano : new features and speed improvements .",
    "deep learning and unsupervised feature learning nips 2012 workshop , 2012 .",
    "j.  z. kolter and m.  j. johnson . : a public data set for energy disaggregation research . in _",
    "workshop on data mining applications in sustainability ( sigkdd ) , san diego , ca _ , volume  25 , pages 5962 .",
    "citeseer , 2011 ."
  ],
  "abstract_text": [
    "<S> energy disaggregation estimates appliance - by - appliance electricity consumption from a single meter that measures the whole home s electricity demand . </S>",
    "<S> recently , deep neural networks have driven remarkable improvements in classification performance in neighbouring machine learning fields such as image classification and automatic speech recognition . in this paper </S>",
    "<S> , we adapt three deep neural network architectures to energy disaggregation : 1 ) a form of recurrent neural network called ` long short - term memory ' ( lstm ) ; 2 ) denoising autoencoders ; and 3 ) a network which regresses the start time , end time and average power demand of each appliance activation . </S>",
    "<S> we use seven metrics to test the performance of these algorithms on real aggregate power data from five appliances . </S>",
    "<S> tests are performed against a house not seen during training and against houses seen during training . </S>",
    "<S> we find that all three neural nets achieve better f1 scores ( averaged over all five appliances ) than either combinatorial optimisation or factorial hidden markov models and that our neural net algorithms generalise well to an unseen house .    </S>",
    "<S> [ connectionism and neural nets ] [ pattern analysis , classifier design and evaluation ] </S>"
  ]
}