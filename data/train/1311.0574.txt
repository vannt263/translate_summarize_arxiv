{
  "article_text": [
    "the _ subgraph homeomorphism problem _ , shp  also known as _",
    "topological containment _",
    " is an important problem in graph theory , and belongs to garey and johnson s original list of np - complete problems .",
    "any fixed _ pattern graph _",
    "@xmath0 gives rise to the problem :    [ cols= \" < \" , ]     it is known that this problem can be solved in polynomial time for any fixed pattern graph , but practical algorithms exist only for a few small pattern graphs . among these are certain members of the wheel class of graphs , for which characterizations have been obtained : @xmath1 and @xmath2 in @xcite , and @xmath3 in @xcite . a result has also been obtained for @xmath4 in @xcite , which leads to an efficient algorithm for solving shp(@xmath4 ) .",
    "the length and difficulty of the proof increases for each @xmath5 as @xmath6 increases .",
    "the @xmath1 proof takes only a paragraph , and the @xmath2 proof occupies 7 pages . the @xmath3 proof , however ( 16 pages , with some automated analysis ) , requires extensive amounts of repetitive case analysis , and the @xmath4 proof even more so ( around 90 pages , also with automated analysis ) .",
    "this case analysis involves looking at numerous small graphs of bounded size , and searching for @xmath5-subdivisions in those graphs .",
    "this paper presents some algorithms developed to automate parts of the searching and analysis required in developing the results for @xmath3- and @xmath4-subdivisions .",
    "the proofs of these results are similar in structure : both involve beginning with a pattern graph for which some good characterization already exists , then examining all possible ways in which certain structures can be added to this graph to satisfy some necessary condition .",
    "it must then be determined whether or not the resulting graphs topologically contain the pattern graph for which the new characterization is desired .",
    "this technique involves testing many small graphs for the presence of @xmath3- or @xmath4-subdivisions .",
    "since the process of constructing these small graphs is repetitive in nature , it was possible to create a program that automates their construction . given the sheer number of test cases that arise , particularly for the @xmath4 result , this program is important in obtaining the information necessary to complete these proofs , as examining each graph individually by hand would take an inordinate amount of time . in particular , one of the key algorithms used in the program ( given in section [ furthertests ] ) could be applicable in a broader context  most obviously for developing characterizations relating to wheels with more than seven spokes , but also potentially for obtaining results for subdivisions of graphs other than wheels , if similar techniques can be used .",
    "each of the graphs generated by the program must be individually tested for the presence of a @xmath3- or @xmath4-subdivision .",
    "those that do not contain such a subdivision require further analysis in the proof , and so are given as output . in order to successfully perform a test for the presence of a @xmath5-subdivision on each generated graph , an algorithm is required that will solve shp(@xmath5 ) for each graph .",
    "we used a naive algorithm which runs in exponential , rather than polynomial time .",
    "it performs adequately for the small input graphs that arise in the proofs , and its correctness is easily verifiable .",
    "section [ testcases ] describes the types of case analysis required in the proofs of @xcite and @xcite , gives the algorithms that have been developed for generating these cases , and demonstrates how these algorithms are used in the context of the proofs .",
    "section [ wk_alg ] gives the exponential - time algorithm for solving shp(@xmath5 ) that is used in testing the generated graphs .",
    "each algorithm mentioned has been implemented in c , and the code can be found in the appendices at the end of the paper .",
    "the complete code for all implementations can be found online at ` http://www.csse.monash.edu.au/~rebeccar/wheelcode.html ` .",
    "if @xmath7 is a subset of graph @xmath8 , then @xmath9 denotes the set of all maximal subsets @xmath10 of @xmath11 such that any two vertices of @xmath10 are joined by a path in @xmath8 with no internal vertex in @xmath7 .",
    "each element of @xmath9 is referred to as a _ bridge _ of @xmath9 .",
    "a vertex @xmath12 of degree 2 is _ contracted _ in a graph @xmath8 by adding an edge between @xmath12 s neighbours , if such an edge does not already exist , then deleting @xmath12 .",
    "in developing proofs for the characterizations of @xcite and @xcite , algorithms were written to generate specific graphs that arise as cases in these proofs , then test these graphs for the presence of a @xmath3- or @xmath4-subdivision .",
    "this section outlines how such automated graph generation is done .",
    "section [ wheelproof ] describes the ` wheelproof ` function , which is used to perform preparatory work in the proofs of the @xmath3 and @xmath4 results .",
    "its role in the proofs is simple , but it provides a good illustration of the search techniques used .",
    "section [ furthertests ] describes the ` exception_generator ` function , which is a more general function that is applicable in a wider range of situations , and as such it is used often throughout the proofs .",
    "each of the proofs for the theorems regarding graphs with no @xmath5-subdivision , for @xmath13 , follows a similar overall structure :    * firstly , it is proved that for some graph @xmath8 that meets the conditions of the hypothesis , there must exist some @xmath14-subdivision @xmath0 centred on a specific vertex @xmath15 of degree @xmath16 . *",
    "it is then observed that some neighbour @xmath17 of @xmath15 exists such that @xmath17 is not a neighbour of @xmath15 in @xmath0 , and that , since @xmath8 is 3-connected , there must be two disjoint paths @xmath18 and @xmath19 in @xmath8 from @xmath17 to @xmath0 that do not meet @xmath15 . *",
    "all possible placings of the paths @xmath18 and @xmath19 must be examined , and each resulting graph must contain a @xmath5-subdivision , if it is to satisfy the hypothesis of the theorem . in situations where the graph @xmath20 contains a @xmath5-subdivision ,",
    "this is simple . where this is not the case , closer examination of the structure of @xmath8",
    "is required .",
    "the function ` wheelproof(k ) ` was created specifically to generate all possible placings of @xmath18 and @xmath19 for which @xmath20 does not contain a @xmath5-subdivision ( for any input @xmath6 ) .",
    "we refer to such graphs as _ exception _ graphs .",
    "this function firstly constructs the graph @xmath14 , then generates all possible ways in which a @xmath6^th^ neighbour can be added to the centre vertex , while still preserving the 3-connectivity of the graph . for each graph",
    "@xmath21 that is generated , the function ` findkwheel ` is then run with the arguments @xmath22 , to test for the presence of a @xmath5-subdivision .",
    "any graph generated which is found not to contain such a subdivision is recorded as an exception graph ; the function returns a list of all such graphs found .",
    "the c implementation for ` wheelproof(k ) ` is given in appendix [ app_wheelproof ] .",
    "running the ` wheelproof ` function with an input of @xmath23 generates no exception graphs .",
    "this is to be expected , as the characterization for graphs topologically containing @xmath1 is as follows @xcite :    _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ if @xmath8 is a 3-connected graph and @xmath12 is any vertex of degree @xmath24 in @xmath8 , then @xmath8 contains a @xmath1-subdivision centred on @xmath12 .",
    "_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _    the output of ` wheelproof(5 ) ` is also as expected , returning two different exception graphs ( shown in figure [ w5_exceptions ] ) , each of which is isomorphic to the starting graph of subcase 2b in theorem 3 of @xcite .",
    "( this theorem characterizes graphs containing no @xmath2-subdivision ; the subcase mentioned deals specifically with a section of the proof requiring the imposition of extra restrictions on the input graph @xmath8 , namely , that @xmath8 contains no internal 3-edge - cutsets , and that @xmath8 contains a cycle of length at least 5 disjoint from the selected vertex of degree @xmath25 . )",
    "the output of ` wheelproof(6 ) ` generates five different exception graphs .",
    "these graphs are isomorphic , and thus further analysis of only one is sufficient ( shown in figure [ w6_exceptions ] ) . such analysis is given in case ( b)(ii ) of the main theorem of @xcite .",
    "the output of ` wheelproof(7 ) ` gives 15 different graphs , but when examined for isomorphism , this number is reduced to three ( see figure [ w7_exceptions ] ) .",
    "each of these three graphs are analysed further in cases ( b)(i ) , ( b)(ii ) , and ( b)(iii ) of the main theorem of @xcite .     case .",
    "each of the 15 graphs generated from the output of ` wheelproof(7 ) ` is isomorphic to one of these three graphs . ]",
    "certain other situations arise in the proofs characterizing the @xmath3 and @xmath4 cases which lend themselves to further automated generation of test cases .",
    "these situations all have the following features :    * only part of the structure of @xmath8 is known , represented by a smaller graph , @xmath26 .",
    "each edge in @xmath26 corresponds to a path in @xmath8 .",
    "* @xmath26 contains a separating set @xmath27 , and @xmath26 contains a number of bridges of @xmath28 .",
    "* it is unknown whether @xmath27 is also a separating set of @xmath8 , or if each bridge of @xmath28 is contained in a separate bridge of @xmath29 .",
    "the proof requires that it be known how many bridges of @xmath28 are contained in separate bridges of @xmath29 .",
    "thus , a path @xmath30 is added to @xmath26 , where @xmath30 is disjoint from @xmath26 except at its endpoints , each of which are in two separate bridges of @xmath28 ( but not in @xmath27 ) .",
    "all possible graphs @xmath31 are generated , for all possible placements , in @xmath32 , of the endpoints of @xmath30 .",
    "each generated graph @xmath31 is then tested for the presence of a @xmath5-subdivision , and only those graphs which do not contain such a subdivision require further analysis .    the function `",
    "exception_generator ` is used to automate this process .",
    "this function takes a graph @xmath8 , and the vertex sets of two subgraphs of @xmath8 , say @xmath33 and @xmath34 .",
    "the function generates all possible graphs of the form @xmath35 , where @xmath30 is some path disjoint from @xmath8 except at its endpoints , one of which is in @xmath33 and one of which is in @xmath34 .",
    "the function tests each generated graph for the presence of a @xmath5-subdivision , and outputs those that do not contain such a subdivision .",
    "an outline of the algorithm is as follows :    * for each pair of vertices @xmath36 , where @xmath37 and @xmath38 : * * add edge @xmath39 * * check for existence of @xmath4-subdivision * * remove edge @xmath39 * * for each vertex @xmath6 in @xmath40 adjacent to @xmath41 : * * * create a new vertex @xmath12 , and subdivide the edge @xmath42 into two new edges @xmath43 and @xmath44 * * * add edge @xmath45 * * * check for existence of @xmath4-subdivision * * * remove edge @xmath45 * * * contract vertex @xmath12 * * for each vertex @xmath6 in @xmath46 adjacent to @xmath47 : * * * create a new vertex @xmath12 , and subdivide the edge @xmath48 into two new edges @xmath49 and @xmath44 * * * add edge @xmath50 * * * check for existence of @xmath4-subdivision * * * remove edge @xmath45 * * * for each vertex @xmath51 in @xmath40 adjacent to @xmath41 : * * * * create a new vertex @xmath17 , and subdivide the edge @xmath52 into two new edges @xmath53 and @xmath54 * * * * add edge @xmath55 * * * * check for existence of @xmath4-subdivision * * * * remove edge @xmath55 * * * * contract vertex @xmath17 * * * contract vertex @xmath12    the implementation of this algorithm is given in appendix [ app_exception_generator ] .",
    "we now give an example of how ` exception_generator ` is used in proofs . in the main result ( theorem 18 ) of @xcite , case ( b)(i ) 1.1.1.1.1 , we start with the graph of figure [ searcheg_start ] .",
    "note that the edges marked @xmath56 , @xmath57 , @xmath58 , and @xmath59 in this graph each have four possible placements in the graph ( represented by dotted lines in figure [ searcheg_start ] ) .",
    "thus , there are in fact @xmath60 possible starting graphs @xmath21 . for each of these graphs @xmath21",
    ", we consider the set @xmath61 , with the aim of discovering whether some path @xmath30 can be added to @xmath21 such that @xmath62 is not a separating set of @xmath63 , and @xmath64 does not contain a @xmath4-subdivision .",
    "the ` exception_generator ` function can be used as follows :    * for each starting graph @xmath21 : * * let @xmath33 , @xmath34 be the two components of @xmath65 * * call ` exception_generator(g_{i } , a , |v(a)| , b , |v(b)| ) `    running this algorithm finds that each generated graph contains a @xmath4-subdivision .",
    "thus , it can be assumed from this point onwards in the proof that @xmath62 is a separating set .",
    "the main algorithm in this section is ` findkwheel ` , and is given in section [ findkwheel ] .",
    "it solves shp(@xmath5 ) for any given input graph , and for any value of @xmath66 .",
    "this algorithm runs in exponential time , but performs sufficiently quickly on input graphs of small size .",
    "the algorithm ` findkwheel ` makes a call to another algorithm , ` iskwheel ` , which determines whether or not some input graph @xmath8 is a @xmath5-subdivision , for a given value of @xmath66 .      `",
    "iskwheel(g , k ) ` takes two arguments , a graph @xmath8 and an integer @xmath6 , and determines whether or not @xmath8 is a @xmath5-subdivision .    a 2-connected graph",
    "@xmath8 is isomorphic to the wheel @xmath5 if the following is true :    * @xmath67 ; * @xmath8 contains exactly @xmath6 vertices of degree 3 ; and * @xmath8 contains exactly one vertex of degree @xmath6 .",
    "a graph @xmath8 is a @xmath5-subdivision if , after contracting all vertices of degree 2 , @xmath8 becomes isomorphic to the graph @xmath5 .",
    "thus , the function ` iskwheel ` uses the following algorithm :    * step 1 . check to see if @xmath8 is two - connected . if not , @xmath8 can not be a @xmath5-subdivision : return null . *",
    "contract all vertices of degree 2 in @xmath8 .",
    "if @xmath8 contains exactly @xmath68 vertices , @xmath6 of which have degree 3 , and one of which has degree @xmath6 , then return @xmath8 ; otherwise return null .    determining",
    "if @xmath8 is two - connected in step 1 is done with a worst - case complexity of @xmath69 , using an implementation of hopcroft s biconnectivity algorithm @xcite .",
    "( the implementation is given in appendix [ app_is2connected ] . ) contracting all vertices of degree 2 until there are no such vertices left has a complexity of @xmath70 .",
    "counting the degrees of remaining vertices in step 3 is @xmath70 .",
    "thus , the entire algorithm s complexity is @xmath69 .",
    "the exact code is given in appendix [ app_iskwheel ] .",
    "the function ` findkwheel(g , k ) ` also takes as its arguments a graph @xmath8 and an integer @xmath6 .",
    "this function searches for a @xmath5-subdivision as a subgraph of @xmath8 ; if such a subgraph exists , ` findkwheel ` will return it , otherwise it returns null .",
    "this is done by recursively testing all subgraphs obtained by removing a single edge from the input graph .",
    "base cases are graphs that are @xmath5-subdivisions , or small graphs that clearly do not contain such a subdivision .",
    "the following algorithm is used .",
    "remove any vertices in @xmath8 with degree zero .",
    "* step 2 . call ` iskwheel(g ) ` . if @xmath8 is not a @xmath5-subdivision , go to step 3 ; otherwise return @xmath8 . * step 3 .",
    "if @xmath71 , or @xmath72 , then @xmath8 is too small to contain a @xmath5-subdivision .",
    "return null .",
    "if @xmath8 contains no vertex with degree @xmath16 , return null .",
    "* step 5 . for each edge",
    "@xmath73 that exists , call ` findkwheel(g - e , k ) ` .",
    "if a @xmath5-subdivision is found , return that graph , otherwise continue to step 6 .",
    "@xmath8 does not contain a @xmath5-subdivision .",
    "return null .",
    "this algorithm runs in exponential time , but still performs effectively on reasonably small graphs .",
    "the code is given in appendix [ app_findkwheel ] .",
    "the proofs of the main results in @xcite and @xcite regarding @xmath3- and @xmath4-subdivisions are of sufficient complexity that completing such proofs without the aid of a computer program becomes extremely difficult .",
    "the algorithms presented in this paper , particularly the ` exception_generator ` algorithm given in section [ furthertests ] , form a key component in automating the generation and testing of graphs required as test cases in these proofs .",
    "the ` exception_generator ` algorithm may well be useful in developing other characterizations of shp - related problems , where a similar approach is adopted in the proof of moving from a problem with a good characterization to one without .    1    alfred  v. aho , john  e. hopcroft , and jeffrey  d. ullman . .",
    "addison - wesley , reading , ma , 1974 .",
    "g.  farr .",
    "the subgraph homeomorphism problem for small wheels .",
    ", 71:129142 , 1988 .",
    "garey and d.s .",
    "johnson . .",
    "w. h. freeman , new york , 1979 .",
    "n.  robertson and p.d .",
    "graph minors .",
    "the disjoint paths problem .",
    "63:65110 , 1995 .    rebecca robinson and graham farr . structure and recognition of graphs with no 6-wheel subdivision . published online in _ algorithmica",
    "_ , january 2008 ; awaiting print publication .",
    "rebecca robinson and graham farr . graphs with no 7-wheel subdivision .",
    "technical report 2009/239 , clayton school of information technology , monash university ( clayton campus ) , 2009 .",
    ".... / * takes an integer k , and outputs all exception graphs - graphs that * * do not contain a w_{k}-subdivision - from the starting point of the * * proof . *",
    "/ static graphlist * wheelproof(const int k ) {     graph * graph ;     graphlist * exception_list = ( graphlist * ) malloc(sizeof(graphlist ) ) ;     graph * prev = null ;     graph * next_exception ;     int i , j , l , m , x , y ;     int u = k ;     int u1 = k+1 ;     int u2 = k+2 ;          exception_list->size = 0 ;          / * make the starting graph w_{k-1}. * /     graph = makewk(graph , k-1 ) ;          / * adding vertex u and joining to the centre vertex * /     graph = addvertex(graph , u ) ;     graph = addedge(graph , 0 , u ) ;     / * main loop : creates edges between u and u1 , and between u and u2 , * * for each possible placement of u1 and u2 . each resulting graph * * is tested for a w_{k}-subdivision .",
    "* /       / * for each vertex i in the graph ( except where i = u ) : * /     for ( i = 0 ; i < = graph->highestid ; i++ )     {        if ( i",
    "! = u & & graph->vertices[i ] !",
    "= null )        {           if ( i ! = 0 ) / * vertex 0 is already adjacent to u * /           {              / * where u1 is an already existing vertex - add edge .",
    "* /              graph = addedge(graph , u , i ) ;                / * now look at possibilities for u2 .",
    "* /              for ( l = i ; l < = graph->highestid ; l++ )              {                 if ( l",
    "! = u & & graph->vertices[l ] ! = null )                 {                    / * where u2 is already existing vertex : * /                    if ( l ! = 0 )                    {                       graph = addedge(graph , u , l ) ;                                             / * check if the two new edges make a w_{k } subdivision * /                       if ( ! findkwheel(graph , k , 0 , 0 ) )                       {                          if ( !",
    "is3connected(graph ) )                             printf(\"graph not 3-connected.\\n \" ) ;                          else                          {                             printf(\"exception found.\\n \" ) ;                             next_exception = graphcpy(graph ) ;                             if ( prev ! = null )                                prev->next = next_exception ;                             else                                exception_list->head = next_exception ;                             prev = next_exception ;                             exception_list->size++ ;                          }                       }                                             / * remove u - u2 edge again . *",
    "/                       graph = removeedge(graph , u , l ) ;                    }                      / * this time , u2 is a new vertex on some ' edge '                    * * ( since each edge represents a path in g ) .",
    "* /                    for ( m = i ; m < graph->vertices[l]->degree ; m++ )                    {                       y = graph->vertices[l]->neighbours[m ] ;                       if ( y > l & & y ! = u & & graph->vertices[y ] ! = null )                       {                          graph = addvertex(graph , u2 ) ;                          graph = addedge(graph , u , u2 ) ;                          graph = expand_edge(graph , l , y , u2 ) ;                                                   / * check if the two new edges make a w_{k } subdivision * /                          if ( !",
    "findkwheel(graph , k , 0 , 0 ) )                          {                             if ( !",
    "is3connected(graph ) )                                printf(\"graph not 3-connected.\\n \" ) ;                             else                             {                                printf(\"exception found:\\n \" ) ;                                next_exception = graphcpy(graph ) ;                                if ( prev ! = null )                                   prev->next = next_exception ;                                else                                   exception_list->head = next_exception ;                                prev = next_exception ;                                exception_list->size++ ;                             }                          }                                                   / * remove u2 again . *",
    "/                          graph = removeedge(graph , u , u2 ) ;                          graph = contractvertex(graph , u2 ) ;                       }                    }                 }              }                        / * remove the edge that was added before trying next possibility .",
    "* /              graph = removeedge(graph , u , i ) ;           }             / * look at all possibilities for u1 where u1 is a new vertex           * * that lies on the path between i and one of its ' neighbours '           * /                    for ( j = 0 ; j < graph->vertices[i]->degree ; j++ )           {              x = graph->vertices[i]->neighbours[j ] ;              if ( x > i & & x ! = u & & graph->vertices[x ] ! = null )              {                 / * new edge joins at a new vertex which splits an                 * * existing edge into two edges .",
    "* /                 graph = addvertex(graph , u1 ) ;                 graph = addedge(graph , u , u1 ) ;                 graph = expand_edge(graph , i , x , u1 ) ;                                 / * now select u2 * /                 for ( l = i ; l < = graph->highestid ;",
    "l++ )                 {                    if ( l",
    "! = u & & graph->vertices[l ] ! = null )                    {                         / * u2 is an already existing vertex * /                       if ( l ! = 0 )                       {                          graph = addedge(graph , u , l ) ;                          / * check if the two new edges make a w_{k } subdivision * /                          if ( !",
    "findkwheel(graph , k , 0 , 0 ) )                          {                             if ( !",
    "is3connected(graph ) )                                printf(\"graph not 3-connected.\\n \" ) ;                             else                             {                                printf(\"exception found:\\n \" ) ;                                next_exception = graphcpy(graph ) ;                                if ( prev ! = null )                                   prev->next = next_exception ;                                else                                   exception_list->head = next_exception ;                                prev = next_exception ;                                exception_list->size++ ;                             }                          }                                                   / * remove u - u2 edge again .",
    "* /                          graph = removeedge(graph , u , l ) ;                       }                                             / * u2 is a new vertex : generate all possibilities * /                       for ( m = i ; m < graph->vertices[l]->degree ;",
    "m++ )                       {                          y = graph->vertices[l]->neighbours[m ] ;                          if ( y > l & & y !",
    "= u & & graph->vertices[y ] ! = null )                          {                             graph = addvertex(graph , u2 ) ;                             graph = addedge(graph , u , u2 ) ;                             graph = expand_edge(graph , l , y , u2 ) ;                                                         / * check if the two new edges make a w_{k } subdivision * /                             if ( !",
    "findkwheel(graph , k , 0 , 0 ) )                             {                                if ( ! is3connected(graph ) )                                   printf(\"graph not 3-connected.\\n \" ) ;                                else                                {                                   printf(\"exception found:\\n \" ) ;                                   next_exception = graphcpy(graph ) ;                                   if ( prev ! = null )                                      prev->next = next_exception ;                                   else                                      exception_list->head = next_exception ;                                   prev = next_exception ;                                   exception_list->size++ ;                                }                             }                                                         / * remove u2 again . *",
    "/                             graph = removeedge(graph , u , u2 ) ;                             graph = contractvertex(graph , u2 ) ;                          }                       }                    }                 }                                 / * take u1 out again .",
    "* /                 graph = removeedge(graph , u , u1 ) ;                 graph = contractvertex(graph , u1 ) ;              }           }        }     }         graph = removeedge(graph , 0 , u ) ;     graph = removevertex(graph , u ) ;         return exception_list ; }    / * makewk : returns the graph w_{k } for given k * / static graph * makewk(graph * graph , int k )   {        int i = 0 ;         graph = initialise_graph(graph ) ;               / * create k+1 vertices * /        while ( i < = k )        {           graph = addvertex(graph , i ) ;           i++ ;        }               i = 1 ;               / * create k spokes * /        while ( i < = k )        {           graph = addedge(graph , 0 , i ) ;           i++ ;        }               i = 1 ;               / * create rim of wheel * /        while ( i < k )        {           graph = addedge(graph , i , i+1 ) ;           i++ ;             }               graph = addedge(graph , k , 1 ) ;        return graph ; } ....",
    ".... / * function to process all the possible exceptions that can be * * generated from each starting graph .",
    "* / static void exception_generator(graph * graph , int sectiona [ ] , int asize ,     int sectionb [ ] , int bsize ) {     int i , j , k , l , p , p1 , n , m , skip=0 , skip1=0 ;     vertex * currvertex , * currvertex1 ;     int newvertex1 = graph->highestid ;     int newvertex2 = ( graph->highestid ) + 1 ;     int nbr[maxdegree ] , nbr1[maxdegree ] ;    / * process possible graphs * /       for ( i=0 ; i < asize ; i++ )     {        for ( j=0 ; j < bsize ; j++ )        {           / * add new path : endpoints are vertices that already exist * /           graph = addedge(graph , sectiona[i ] , sectionb[j ] ) ;             / * is there a w7 ? * /           if ( findkwheel(graph , 7 , 0 , 0 ) = = null )           {              printf(\"exception:\\n \" ) ;              printgraph(graph ) ;           }           / * remove new path * /           graph = removeedge(graph , sectiona[i ] , sectionb[j ] ) ;             / * add new path : endpoints are new vertex in section a           * * and already existing vertex in section",
    "b           * /                    n = 0 ;           currvertex = graph->vertices[sectiona[i ] ] ;           while ( n < currvertex->degree )           {              nbr[n ] = currvertex->neighbours[n ] ;              n++ ;           }             / * for each neighbour k of i , try expanding the edge ik * /           for ( k=0 ; k < n ; k++ )           {                / * if we 've looked at this neighbour before , skip it .",
    "* /              for ( p=0 ; p < i ; p++ )              {                 if ( sectiona[p ] = = nbr[k ] )                    skip = 1 ;                 else                    skip = 0 ;              }                           / * ... otherwise , create a new vertex in section a along the              * * path between i and k , and make a path between this and              * * vertex j in section b              * /              if ( ! skip )              {                 graph = addvertex(graph , newvertex1 ) ;                 graph = expand_edge(graph , sectiona[i ] , nbr[k ] , newvertex1 ) ;                 graph = addedge(graph , newvertex1 , sectionb[j ] ) ;                 if ( findkwheel(graph , 7 , 0 , 0 ) = = null )                 {                    printf(\"exception:\\n \" ) ;                    printgraph(graph ) ;                 }                   / * remove path .",
    "* /                 graph = removeedge(graph , newvertex1 , sectionb[j ] ) ;                 graph = contractvertex(graph , newvertex1 ) ;              }           }             / * add new path : endpoints are new vertex in section b           * * and already existing vertex in section a           * /                    n = 0 ;           currvertex = graph->vertices[sectionb[j ] ] ;           while ( n < currvertex->degree )           {              nbr[n ] = currvertex->neighbours[n ] ;              n++ ;           }             / * for each neighbour k of j , try expanding the edge jk * /           for ( k=0 ; k < n ; k++ )           {                / * if we 've looked at this neighbour before , skip it . * /              for ( p=0 ; p < j ; p++ )              {                 if ( sectionb[p ] = = nbr[k ] )                    skip = 1 ;                 else                    skip = 0 ;              }                / * ... otherwise , create a new vertex in section b along the              * * path between j and k , and make a path between this and              * * vertex i in section a              * /              if ( ! skip )              {                 graph = addvertex(graph , newvertex1 ) ;                 graph = expand_edge(graph , sectionb[j ] , nbr[k ] , newvertex1 ) ;                 graph = addedge(graph , newvertex1 , sectiona[i ] ) ;                 if ( findkwheel(graph , 7 , 0 , 0 ) = = null )                 {                    printf(\"exception:\\n \" ) ;                    printgraph(graph ) ;                 }                 graph = removeedge(graph , newvertex1 , sectiona[i ] ) ;                     / * do n't contract new vertex yet , but rather ... * /                  / * add new path : endpoints are new vertex in section b              * * ( that is , the one we just made ) and new vertex in section a              * /                       m = 0 ;              currvertex1 = graph->vertices[sectiona[i ] ] ;              while ( m < currvertex1->degree )              {                 nbr1[m ] = currvertex1->neighbours[m ] ;                 m++ ;              }                / * for each neighbour l of i , try expanding the edge il * /              for ( l=0 ; l < m ; l++ )              {                      / * if we 've looked at this neighbour before , skip it . * /                    for ( p1=0 ; p1<i ; p1++ )                    {                       if ( sectiona[p1 ] = = nbr1[l ] )                          skip1 = 1 ;                       else                          skip1 = 0 ;                    }                   / * ... otherwise , create a new vertex in section a along the                 * * path between i and l , and make a path between this and                 * * the new vertex ( newvertex1 ) in section b                 * /                    if ( ! skip1 )                    {                       graph = addvertex(graph , newvertex2 ) ;                       graph = expand_edge(graph , sectiona[i ] , nbr1[l ] , newvertex2 ) ;                       graph = addedge(graph , newvertex1 , newvertex2 ) ;                       if ( findkwheel(graph , 7 , 0 , 0 ) = = null )                       {                          printf(\"exception:\\n \" ) ;                          printgraph(graph ) ;                       }                       graph = removeedge(graph , newvertex1 , newvertex2 ) ;                       graph = contractvertex(graph , newvertex2 ) ;                    }                 }                 graph = contractvertex(graph , newvertex1 ) ;              }           }        }     } } ....",
    ".... / * is2connected : returns 1 if the graph starting at input vertex * * ' head ' is 2-connected .",
    "returns 0 otherwise . *",
    "/ int is2connected(graph * graph ) {     int visited[maxgraphsize ] ;     int dfnumber[maxgraphsize ] ;     int low[maxgraphsize ] ;     int father[maxgraphsize ] ;     int count = 0 ;     int i = 0 ;       for ( i=0;i < maxgraphsize;i++ )     {        visited[i ] = 0 ;        dfnumber[i ] = -1 ;        low[i ] = -1 ;        father[i ] = -1 ;     }    / * find the first vertex in the graph .",
    "* /     i = 0 ;     while ( graph->vertices[i ] = = null )        i++ ;       return ( is2conn_rec(graph , i , visited , dfnumber , low , father , & count ) ) ; }    / * is2conn_rec : recursive function used by is2connected . * / static int is2conn_rec(graph * graph , int v_id , int visited [ ] , int dfnumber [ ] ,     int low [ ] , int father [ ] , int * count ) {     vertex * v = graph->vertices[v_id ] ;     vertex * w ;     int w_id ;     int i = 0 ;       visited[v_id ] = true ;     dfnumber[v_id ] = * count ;     ( * count)++ ;     low[v_id ] = dfnumber[v_id ] ;       while ( i < v->degree )     {        w_id = v->neighbours[i ] ;        w = graph->vertices[w_id ] ;        if ( w = = null )        {           printf(\"error : vertex connected to vertex that does n't exist.\\n \" ) ;           exit(1 ) ;        }        if ( visited[w_id ] = = false )        {           father[w_id ] = v_id ;           if ( !",
    "is2conn_rec(graph , w_id , visited , dfnumber , low , father , count ) )              return false ;           if ( low[w_id ] > = dfnumber[v_id ] & & ( ( dfnumber[v_id ] !",
    "= 0 ) || i > 0 ) )              return false ;            low[v_id ] = min(low[v_id ] , low[w_id ] ) ;        }        else if ( father[v_id ] !",
    "= w_id )        {           low[v_id ] = min(low[v_id ] , dfnumber[w_id ] ) ;        }        i++ ;     }       return true ; } ....",
    ".... / * iskwheel : takes a graph ' graph ' and an integer k. if the input   * * graph is the graph w_{k } once all vertices of degree 2 have been * * contracted , then the function returns a copy of the input graph   * * with all such vertices contracted . * * if the input graph is not the graph w_{k } , the function returns * * the null pointer .",
    "* /    graph * iskwheel(graph * graph , int k ) {     int countk = 0 ;     int count3 = 0 ;     int countcontracted = 1 ;     int i=0 ;     vertex * v ;      graph * newgraph ;       if ( !",
    "is2connected(graph ) ) return null ; / * graph must be 2-connected .",
    "* /     newgraph = graphcpy(graph ) ;    / * for each vertex in the graph : if v is of degree 2 , contract v * /       while ( countcontracted ! = 0 )     {        i = 0 ;        countcontracted = 0 ;        while ( i < = newgraph->highestid )        {           v = newgraph->vertices[i ] ;           if ( v !",
    "= null )           {              if ( v->degree = = 2 )              {                 newgraph = contractvertex(newgraph , i ) ;                 countcontracted++ ;              }           }           i++ ;        }     }    / * if v is degree 3 , increment counter of degree 3 vertices * * if v is of degree k , increment counter of degree k vertices * /     i = 0 ;     while ( i < = newgraph->highestid )     {        v = newgraph->vertices[i ] ;        if ( v ! = null )        {           if ( v->degree = = 3 )              count3++ ;           else if ( v->degree = = k )              countk++ ;        }           i++ ;     }       / * number of vertices ( not including those of degree 2 which * * were contracted ) must equal k+1 for graph to be w_{k}-subdivision . *",
    "/     if ( newgraph->size !",
    "= k+1 )     {        killgraph(newgraph ) ;        return null ;     }    / * must be k vertices of degree 3 and 1 vertex of degree k. * /       if ( count3 = = k & & countk = = 1 )        return newgraph ;    / * special case for w_{3 } , where there are 4 vertices of degree 3 .",
    "* /       else if ( k = = 3 & & count3 = = 4 )        return newgraph ;    / * if graph is not a w_{k}-subdivision , return null .",
    "* /     else     {        killgraph(newgraph ) ;        return null ;     } } ....",
    ".... / * findkwheel : takes as input a graph and an integer k. if * * the input graph contains a w_{k } subdivision , the function * * returns the input graph contracted to be w_{k}. otherwise , * * the null pointer is returned . * /           i = 0 ;     while ( i < = graph->highestid )     {        v = graph->vertices[i ] ;        if ( v",
    "! = null )        {           if ( v->degree = = 0 )           {              graph = removevertex(graph , i ) ;           }        }        i++ ;     }    / * if the graph is not w_{k } , the function is called recursively * * to test the removal of every possible combination of edges * * between vertices higher than startvertex1 and startvertex2 . * * if some combination of edge removal results in w_{k } , the program * * exits the while loop and returns successfully . *",
    "* once there are too few edges or vertices left in the graph , or   * * once all edge removal possibilities have been tried , the function * * returns null .",
    "* /     if ( ( subgraph = iskwheel(graph , k ) ) = = null )        / * only do this if the graph is n't w_{k } * /     {          / * too few edges to be able to remove any more ,     * * or too few vertices to make w_{k } * /        if ( graph->edges < = 2*k || graph->size < k+1 )           return null ;     / * or no vertex left of degree at least k * /        for ( i = 0 ; i < = graph->highestid ; i++ )        {           if ( graph->vertices[i ] !",
    "= null & & graph->vertices[i]->degree > = k )              break ;        }        if ( i > graph->highestid )           return null ;          i = startvertex1 ;     / * removing each edge in turn : * /        while ( i < = graph->highestid )         {           if ( i = = startvertex1 ) // first time through outer loop",
    "j = max(i , startvertex2 ) ;           else              j = i ;           while ( j < = graph->highestid )           {              if ( edgeexists(graph , i , j ) & & j >",
    "i )                 / * j >",
    "i check ensures only edges in one direction are detected * /              {                 subgraph = graphcpy(graph ) ;     / * call the function recursively on the graph with one fewer edge . * /                 if ( ( foundwheel = findkwheel(removeedge(subgraph , i , j ) , k , i , j ) ) !",
    "= null )                 {                    return foundwheel ;                 }                 killgraph(subgraph ) ;              }              j++ ;           }           i++ ;        }        return null ;     }     return subgraph ; } ...."
  ],
  "abstract_text": [
    "<S> practical algorithms for solving the subgraph homeomorphism problem are known for only a few small pattern graphs : among these are the wheel graphs with four , five , six , and seven spokes . the length and difficulty of the proofs leading to these algorithms increase greatly as the size of the pattern graph increases . </S>",
    "<S> proving a result for the wheel with six spokes requires extensive case analysis on many small graphs , and even more such analysis is needed for the wheel with seven spokes . </S>",
    "<S> this paper describes algorithms and programs used to automate the generation and testing of the graphs that arise as cases in these proofs </S>",
    "<S> . the main algorithm given may be useful in a more general context , for developing other characterizations of shp - related properties . </S>"
  ]
}