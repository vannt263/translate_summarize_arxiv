{
  "article_text": [
    "the main purpose of integrity constraints is to express semantic properties of the data stored in the database .",
    "usually , it is the database management system that is responsible for maintaining the integrity of the database .",
    "however , in many recent applications the integrity enforcement becomes a problematic issue .",
    "for example in the data integration setting , even when the data contained by a data source satisfies the integrity constrains , a different data source may contribute conflicting information .",
    "at the same time data sources may be autonomous and it may be impossible to modify their contents in order to remove the conflicts .",
    "integrity constraints may also fail to be enforced because of efficiency considerations .",
    "finally , in the case of long running operations , integrity violations may be only temporary and will be eliminated by further operations .",
    "typically , the user formulates a query with the assumption that the database is consistent ( i.e. satisfies the integrity constraints ) .",
    "a simple evaluation of the query over an inconsistent database may return incorrect answers . to address this problem arenas , bertossi , and",
    "chomicki @xcite proposed the framework of _ consistent query answers_. they introduced the notion of a _ repair _ : a consistent database that is minimally different from the original one .",
    "a _ consistent answer _ to a query is an answer _ true _ in _ every _ repair .",
    "the framework of @xcite is used as a foundation for most of the work in the area of querying inconsistent databases @xcite .",
    "[ ex : cqa ] consider a database consisting of two tables @xmath1 and @xmath2 whose instance @xmath3 can be found in table  [ tab : tab4 ] .",
    "name & dept + alice & a + alice & b +     dept & name & t + a & mary & 2 + b & bob & 1 + b & mary & 3 +    assume that we have two functional dependencies @xmath4 and @xmath5 .",
    "this database contains two conflicts : 1 ) in relation @xmath1 between the tuples @xmath6 and @xmath7 ; 2 ) in relation @xmath2 between the tuples @xmath8 and @xmath9 ( note that one person can be the manager of more than one department ) .",
    "each of those conflicts can be resolved in two different ways by assuming that one tuple is correct and removing the other .",
    "this leads to four different repairs : @xmath10 for example , the repair @xmath11 is obtained by assuming that @xmath12 works in department @xmath13 and the manager of department @xmath14 is @xmath15 . since in every repair @xmath16 is the manager of the department @xmath13 , we can infer that _ true _ is the consistent answer to the query @xmath17 however it is not certain that @xmath12 works in a department managed by @xmath16 , i.e. _ true _ is not the consistent answer to the following query @xmath18 this is because of the repair @xmath19 , where @xmath20 is false .",
    "as it is shown in the previous example , each conflict can be resolved in two different ways .",
    "the framework of @xcite does not provide any means to favor one way over another .",
    "however , in many cases some additional information which can be used to provide a resolution of some conflicts is available .",
    "for example :    * in e - commerce applications , data are accompanied with the timestamp of creation / last modification  the conflicts can be resolved by removing from consideration old , outdated tuples . * in data integration scenarios , it is often possible to provide a ( partial ) order on the sources , capturing the reliability of contributed information  the most reliable data can be used to resolve conflicts .",
    "* statistics can be used to resolve conflicts created by misspellings .",
    "suppose that the column @xmath21 of the table @xmath2 contains for each tuple its creation timestamp ( lower values correspond to older tuples ) .",
    "we can use this information to express the preference that if some tuples of @xmath2 are conflicting , the older should be removed from consideration ( but not removed from the database ) . since the tuple @xmath9 is older than @xmath8",
    ", we consider only the repairs containing the latter one : @xmath22 and @xmath23 .",
    "in such a case we can also infer that it is certain that @xmath12 works in the department managed by @xmath16 , i.e. _ true _ is the _ preferred _ consistent answer to the query @xmath20 .    in this paper",
    "we extend the framework of consistent query answers with an additional input consisting of preference information @xmath24 .",
    "we use @xmath24 to define the set of _ preferred _ repairs @xmath25 .",
    "when we compute consistent answers , instead of considering the set of all repairs @xmath26 , we use the set of preferred repairs .",
    "we assume that there exists a ( possibly partial ) operation of extending @xmath24 with some additional preference information and we write @xmath27 when @xmath28 is an _ extension _ of @xmath24 .",
    "we consider @xmath24 to be _ maximal _ when it can not be extended further .",
    "the main objective of our research is to develop a framework of preferred repairs that fulfills the following postulates :    1 .   * non - emptiness * @xmath29 2 .   *",
    "non - discrimination * : if no preference information is given , then no repair is removed from consideration @xmath30 3 .",
    "* monotonicity * : extending preferences can only narrow the set of preferred repairs @xmath31 4 .",
    "* categoricity * : given maximal preference information we obtain exactly one repair @xmath32    we note here that the postulates [ eq : p1 ] and [ eq : p3 ] together imply an important property of * conservativeness * : preferred repairs are a subset of the standard repairs",
    ".    another important goal of our research is to determine the computational implications of introducing preferences . for this purpose",
    "we study here two fundamental decision problems in inconsistent databases @xcite : ( i ) _ repair checking _  finding if a given database is a preferred repair ; ( ii ) _ computing consistent answers _",
    " finding if an answer to a query is present in every preferred repair .",
    "the main contributions of this paper are :    * a general and intuitive framework for incorporating preferences into inconsistency handling based on the notion of priority . * a study of the semantic and computational properties of two instantiations of the framework : ( locally preferred )  - repairs and ( globally preferred ) @xmath0-repairs .",
    "in this paper , we work with databases over a schema consisting of only one relation @xmath33 with attributes from @xmath34 .",
    "we use @xmath35 to denote elements of @xmath34 and @xmath36 to denote subsets of @xmath34 .",
    "we consider two disjoint domains : uninterpreted names @xmath37 and natural numbers @xmath38 .",
    "every attribute in @xmath34 is typed .",
    "we assume that constants with different names are different and that symbols @xmath39 , @xmath40 , @xmath41 , @xmath42 have the natural interpretation over @xmath38 .",
    "the instances of @xmath33 , denoted by @xmath43 , can be seen as finite , first - order structures , that share the domains @xmath37 and @xmath38 . for any tuple @xmath44 from @xmath45 by @xmath46",
    "we denote the value associated with the attribute @xmath13 . in this paper",
    "we consider first - order queries over the alphabet consisting of @xmath33 and binary relation symbols @xmath39 , @xmath40 , @xmath41 , and @xmath42 .",
    "the limitation to only one relation is made only for the sake of clarity and along the lines of @xcite the framework can be easily extended to handle databases with multiple relations .",
    "the class of integrity constraints we study consists of functional dependencies .",
    "we use @xmath47 to denote the following constraint : @xmath48 we use this formula to identify tuples creating conflicts .    given a set of functional dependencies @xmath49 , two tuples @xmath50",
    "are _ conflicting _",
    "w.r.t @xmath49 , denoted @xmath51 , if and only if there exists a functional dependency @xmath52 such that @xmath53 for all @xmath54 and @xmath55 for some @xmath56 .",
    "a database @xmath45 is _ inconsistent _ with a set of constraints @xmath49 if and only if @xmath45 contains some conflicting tuples .",
    "otherwise , the database is _",
    "consistent_.    in the general framework when repairing a database we consider two operations : adding or removing a tuple . because in the presence of functional dependencies adding new tuples can not remove conflicts , we only consider repairs obtained by deleting tuples from the original instance .",
    "[ def : repair ] given a database @xmath45 and a set of integrity constraints @xmath49 , a database @xmath57 is a _ repair _ of @xmath45 w.r.t .",
    "@xmath49 if @xmath57 is a maximal subset of @xmath45 consistent with @xmath49 .",
    "we denote by @xmath58 the set of all repairs of @xmath45 w.r.t @xmath49 .",
    "a repair can be viewed as the result of a process of cleaning the input relation .",
    "note that since every conflict can be resolved in two different ways and conflict are often independent , there may be an exponential number of repairs .",
    "also , the set of repairs of a consistent relation @xmath45 contains only @xmath45 .",
    "@xcite a _ conflict graph _",
    "@xmath59 is a graph whose set of vertices is equal to @xmath45 and two tuples @xmath50 are adjacent only if they are conflicting ( i.e. @xmath51 ) .",
    "recall that a maximal independent set of a graph @xmath60 is a maximal set of vertices that contains no edge from @xmath60 . by @xmath61",
    "we denote the set of all maximal independent sets of @xmath60 .",
    "the following observation explains why the conflict graph is considered a _",
    "compact representation of all repairs_.    for any database @xmath45 and any set of functional dependencies @xmath49 we have that @xmath62      for the clarity of presentation we assume that from now on we work with a fixed database instance @xmath45 and a fixed set of functional dependencies @xmath49 .    to represent the preference information , we use ( possibly partial ) orientations of the conflict graph .",
    "it allows us to express preferences at the level of single conflicts .",
    "a binary relation @xmath63 is a _ priority _ if :    1 .",
    "@xmath64 is asymmetric , i.e. @xmath65,\\ ] ] 2 .",
    "@xmath64 is defined only on conflicting tuples , i.e. @xmath66    if @xmath67 we say that the pair @xmath68 is _ prioritized _ and that @xmath69 _ dominates _ over @xmath70 .",
    "a priority @xmath64 is _ total _ if every pair of conflicting tuples is prioritized by @xmath64 .",
    "a priority @xmath64 is _ acyclic _ if there does not exist @xmath71 such that @xmath72 , where @xmath73 is the transitive closure of @xmath64 .",
    "the first condition of priority demands the preference information to be unambiguous for a single conflict .",
    "the second condition ensures that we are given only the relevant preference information .",
    "if the second condition is not fulfilled , then it can be easily enforced by intersecting @xmath64 with @xmath74 .",
    "this form of preference information allows us to easily define the the preference extension : we orient some conflicting edges that were not oriented before .",
    "[ def : extension ] a priority @xmath75 is an _ extension _ of a priority @xmath64 if @xmath75 agrees with @xmath64 where @xmath64 is defined ( i.e. @xmath76 ) .",
    "note that @xmath64 can not be extended further only if @xmath64 is total .",
    "also an extension @xmath75 of a priority @xmath64 is also a priority and therefore @xmath75 is antisymmetric and defined only on pairs of conflicting tuples .",
    "now we present two methods of using a priority to restrict the set of all repairs of a given relation .",
    "the first one ,  - repairs , uses the priority to restrict the ways of constructing a repair ( cleaning the database ) .",
    "the process consists of multiple iterative steps and in each of them only a limited number of conflicts is considered .",
    "the use of the priority has a local character because the subset of priority used in one step is not used in any further steps .",
    "the second method , @xmath0-repairs , uses the priority in a global fashion by selecting most preferred repairs according to an order induced by the priority .      recall a general nondeterministic procedure for constructing a maximal independent set of a graph : as long as the graph is not empty , we _",
    "choose _ a vertex , add it to the constructed set , and remove the vertex and all its neighbors from the graph . depending on the choices of vertices we make",
    ", we can construct any maximal independent set of the input graph .",
    "now , let s look at this procedure from the point of constructing a repair .",
    "each choice of a vertex corresponds to taking a single repair action : keeping the corresponding tuple in the relation and removing all tuples conflicting with it .",
    "since the choice of the tuple to keep is unconstrained , every conflict can be resolved in several different ways .",
    "we use the priority to restrict the possible ways of choosing the tuple that will be kept and whose conflicts will be resolved .",
    "the chosen tuple is among those that are not dominated at the given step of the repairing process .",
    "we use the _ winnow operator _ @xcite to formally describe the set of tuples that we choose from : @xmath77 algorithm  [ alg : alg1 ] implements the construction of preferred repairs .",
    "an _  - repair _ ( or a _ locally preferred _ repair ) is any instance @xmath57 we can obtain with this algorithm .",
    "we denote the set of all  - repairs of @xmath45 w.r.t .",
    "@xmath49 and @xmath64 by @xmath78 .",
    "[ step : stop_cond ] [ step : choice ]    note that an  - repair can be characterized by the sequence of choices made in the step [ step : choice ] in algorithm  [ alg : alg1 ] ( however there can be more than one such sequence ) .",
    "this observation allows us to state an alternative definition of an  - repair .",
    "[ prop : proc_computation_path ] given a priority @xmath64 , a set of tuples @xmath79 is an  - repair , if and only if there exists an ordering @xmath80 of @xmath79 such that for every @xmath81 the following set is non - empty @xmath82 and @xmath83 .",
    "the next construction uses the priority directly to compare two repairs .",
    "intuitively , one repair is better than another if all the differences between them are justified by the priority .",
    "formally , we define @xmath0-repairs in the following way .",
    "[ def : decl_repair ] given a priority @xmath64 and two repairs @xmath84 , we say that @xmath85 is _ preferred _ over @xmath86 , and write @xmath87 , if @xmath88 a repair is a @xmath0-repair ( or a _ globally _ preferred repair ) if it is a @xmath89-maximal repair . by @xmath90",
    "we denote the set of all @xmath0-repairs .",
    "this particular `` lifting '' of a preference on objects to a preference on sets of objects can be found in other contexts .",
    "for example , a similar definition is used for a preference among different models of a logic program @xcite , or for a preference among different worlds @xcite .      in this paper",
    ", we use a generalized notion of consistent query answers . instead of taking the set of all repairs , as in @xcite , we consider families of preferred repairs .",
    "we only study closed first - order logic queries .",
    "we can easily generalize our approach to open queries along the lines of @xcite .",
    "for a given query @xmath91 we say that _ true _ is an answer to @xmath91 in @xmath45 , if @xmath92 in the standard model - theoretic sense .",
    "given a closed query @xmath91 and a family of repairs @xmath93 , _ true _ is the _",
    "@xmath94-consistent query answer _ to a query @xmath91 if for every repair @xmath95 we have @xmath96 .",
    "note that we obtain the original notion of consistent query answer @xcite if we take for @xmath94 the whole set of repairs @xmath58 .    in this paper",
    ", we study the cases when we take for @xmath94 either the set of  - repairs or the set of @xmath0-repairs .",
    "this gives us two notions :    1 .",
    "_  - preferred consistent query answer _",
    "if @xmath97 , 2 .   _",
    "@xmath0-preferred consistent query answer _ if @xmath98 .",
    "we write @xmath99 ( @xmath100 ) to denote that _ true _ is the  - preferred ( resp .",
    "@xmath0-preferred ) consistent answer to @xmath91 ( in @xmath45 w.r.t .",
    "@xmath49 and @xmath64 ) .",
    "before discussing specific properties of preferred repairs , we present reasons for removing cyclic priorities from consideration .    [",
    "ex : ex1 ] assume a database schema @xmath101 and a set of functional dependencies @xmath102 .",
    "consider the following database @xmath103 and a total cyclic priority @xmath104 .",
    "the set of all repairs is @xmath105 as we can easily find @xmath78 is empty .",
    "it is also easy to see that @xmath87 and @xmath106 and thus @xmath107 .",
    "this violates the postulates [ eq : p1 ] and [ eq : p5 ] .    intuitively , a cycle in the conflict graph represents a mutually dependent group of conflicts ( a solution of one conflict may restrict the ways of solving other conflicts ) .",
    "our intention is to break the cycle by choosing a @xmath64-maximal element .",
    "if @xmath64 is cyclic , then such element does not exist , which makes the construction of a preferred repair impossible .",
    "we find this kind of preference information ( cyclic priority ) to be incoherent and we exclude it form our considerations .",
    "when we restrict our considerations only to acyclic priorities , the relation @xmath89 has interesting order properties .",
    "[ prop : decl_order ] if @xmath64 is an acyclic priority and the binary relation @xmath89 on @xmath108 is defined in terms of @xmath64 as in definition  [ def : decl_repair ] , then    1 .",
    "@xmath89 is reflexive , 2 .",
    "@xmath89 is anti - symmetric , 3 .",
    "@xmath89 is transitive , provided that @xmath64 is transitive .    before proving the main thesis",
    "we will introduce one definition and show its two properties    given two sets @xmath109 and a priority @xmath64 , an _",
    "@xmath110-alternating @xmath64-chain _ is a ( possibly infinite ) sequence @xmath111 such that :    * every element with even index belongs to @xmath13 @xmath112 * every element with odd index belongs to @xmath14 @xmath113 * @xmath64 holds between every two consecutive elements , i.e. @xmath114    we say that an @xmath110-alternating @xmath64-chain is _ maximal _ if it s not a proper prefix of some @xmath110-alternating @xmath64-chain is a proper prefix of a sequence @xmath115 if and only if @xmath116 and @xmath117 for every @xmath118 .",
    "note that @xmath115 can be infinite ( @xmath119 ) , but an infinite sequence can not have a proper prefix . ] .",
    "when @xmath64 will be know from the context instead of saying that @xmath120 is an @xmath110-alternating @xmath64-chain we will simply say that @xmath120 is an @xmath110-chain .    [ prop : inf_seq ] for any acyclic priority @xmath64 and any two sets @xmath109 every @xmath110-chain is finite .",
    "suppose there exists such an infinite @xmath110-chain @xmath120 . because @xmath45 is finite",
    ", @xmath120 contains a recurrent element @xmath70 .",
    "thus @xmath121 this gives us a contradiction with @xmath64 being acyclic .",
    "[ prop : altll ] for any acyclic priority @xmath64 , and any two sets @xmath122 such that @xmath123 ( where @xmath89 is defined in terms of @xmath64 ) , any maximal @xmath124-chain is of even length ( it ends with an element from @xmath125 ) .    by previous proposition",
    "we have that any @xmath124-chain is finite .",
    "assume now that , there exists a maximal @xmath124-chain of odd length ( i.e. ending with an element from @xmath126 ) : @xmath127 since @xmath123 , there exists @xmath128 such that @xmath129 . thus is a prefix of the following @xmath124-chain : @xmath130 this contradicts the maximality of .",
    "we also state a trivial fact    [ fact : altstart ] for any acyclic priority @xmath64 , any two sets @xmath131 such that @xmath123 , and any @xmath132 there exists an @xmath124-chain that starts with @xmath70 .",
    "now , we show the order properties of @xmath89 :    1 .",
    "@xmath89 is reflexive .",
    "+ because universal quantification over empty set is true , then trivially @xmath133 for any set @xmath134 .",
    "@xmath89 is asymmetric .",
    "+ take two different sets @xmath122 such that @xmath123 and @xmath135 , i.e. : @xmath136 w.l.o.g we can assume that @xmath137 . take any @xmath138 .",
    "by we are able to find @xmath139 such that @xmath140 .",
    "now , by we are able to find @xmath141 such that @xmath142 .",
    "this way we can construct an infinite @xmath143-chain .",
    "this contradicts proposition  [ prop : inf_seq ] .",
    "if @xmath64 is transitive , then @xmath89 is transitive . + assume @xmath64 is transitive and take three different sets @xmath144 such that @xmath123 and @xmath145 ( the case when two sets are equal is trivial ) .",
    "note that : @xmath146 now we take any @xmath147 and consider two cases depending if @xmath148 or not .",
    "+ suppose @xmath149 .",
    "let @xmath150 be a maximal @xmath151-chain where @xmath152 .",
    "( the existence of such a chain is by proposition [ prop : altll ] and fact [ fact : altstart ] ) .",
    "if there exists an element @xmath153 of this chain that belongs to @xmath154 then by transitivity of @xmath64 we have @xmath155 ( which end this path of the proof ) .",
    "suppose that none of the elements of the @xmath151-chain belongs to @xmath154 , then in particular @xmath156 belongs to @xmath157 . by there exists @xmath158 such that @xmath159 .",
    "moreover @xmath160 or otherwise we get a contradiction of the maximality of the @xmath151-chain . by transitivity of @xmath64",
    "we get @xmath161 and obviously @xmath162 ; + similarly we deal with the case when @xmath163 .",
    "take @xmath164 to be a maximal @xmath165-chain , where @xmath166 .",
    "if there exists an element @xmath153 of this sequence that belongs to @xmath154 , then by transitivity of @xmath64 we have @xmath167 ( which end this path of the proof ) .",
    "suppose that none of the elements of the @xmath124-chain belongs to @xmath154 , then in particular @xmath69 belongs to @xmath168 .",
    "by there exists @xmath169 such that @xmath170 .",
    "moreover @xmath171 or otherwise we get a contradiction of the maximality of the @xmath124-chain .",
    "finally , by transitivity of @xmath64 we get @xmath172 and obviously @xmath173 .",
    "this ends the proof .",
    "the following example shows that @xmath89 may not be transitive if the underlying priority is not transitive .",
    "consider a database @xmath174 over the schema @xmath101 with one functional dependency @xmath175 and with priority @xmath176 .",
    "there are three repairs of @xmath45 : @xmath177 the corresponding conflict graph is presented on figure [ fig : fig6 ] .",
    "( 3.4,1.6 ) ( 0.2,.5 ) ( 1.8,.5 ) ( 3.4,.5 )    we note that @xmath178 and @xmath179 but @xmath180 .",
    "before we prove the fulfillment of the postulates [ eq : p1][eq : p5 ] we state an important property of the two instantiations of preferred repairs : constructing a repair from the locally best tuples by the notion of  - repairs conforms with the global notion of preference ( @xmath0-repairs ) .",
    "[ thm : proc_subsumes_decl ] if @xmath64 is an acyclic priority , then @xmath181    induction over the size of @xmath45 .",
    "trivial for @xmath182 .",
    "assume the hypothesis holds for any proper subset of @xmath45 and there exists @xmath183 such that @xmath123 for some @xmath184 .",
    "by proposition [ prop : proc_computation_path ] @xmath185 is non - empty .",
    "take then any @xmath186 .",
    "@xmath148 or otherwise we receive a contradiction @xmath123 .",
    "note that @xmath187 is a repair of @xmath188 and @xmath189 even a  - repair of @xmath188 .",
    "moreover @xmath190 in terms of the database @xmath188 .",
    "thus @xmath191 is not @xmath0-repair of @xmath192 , which is a contradiction of the inductive hypothesis .    in the following example",
    "we observe that the reverse containment does not hold for an arbitrary acyclic priority , i.e. the construction of  - repairs by choosing only the best elements locally ( as in  - repairs ) may miss a @xmath0-repair .",
    "[ ex : proc_diff_decl ] consider a database @xmath193 over the schema @xmath194 with a set of functional dependencies @xmath195 and a acyclic priority @xmath196 the set of repairs is @xmath197 . as we can easily find @xmath198 . because each of the @xmath199 and @xmath200 is dominated ,",
    "the @xmath0-repair @xmath201 is not an  - repair , and thus @xmath202 .    later on we present sufficient conditions under which both instantiations of preferred repairs are equivalent ( theorem [ thm : proc_equals_decl ] ) .",
    "we recall that extending priority consists of prioritizing conflicts not prioritized before and a priority that can not be extended further ( i.e. is maximal ) is a total priority . both classes of referred repairs that we consider satisfy the postulates [ eq : p1 ]  [ eq : p5 ] :    [ thm : proc_postulates ] for every relation instance @xmath45 , set of functional dependencies @xmath49 , and acyclic priority @xmath64 , @xmath78 satisfies [ eq : p1][eq : p5 ] .",
    "we receive [ eq : p1 ] from the fact that if @xmath64 is acyclic then @xmath203 is non - empty if and only if @xmath79 is non - empty .",
    "[ eq : p3 ] is implied by the fact that @xmath204 is an identity function what makes @xmath205 a generic procedure for constructing all maximal independent sets of @xmath206 .    to prove [ eq : p4 ] assume that @xmath207 are acyclic priorities such that @xmath208 .",
    "take then any @xmath209 and let @xmath210 be any ordering of @xmath79 from proposition [ prop : proc_computation_path ] .",
    "note that since for any set @xmath13 we have @xmath211 then @xmath210 also fulfills conditions of proposition [ prop : proc_computation_path ] in terms of @xmath75 .",
    "[ eq : p5 ] is a consequence of [ eq : p1 ] for @xmath205 , theorem [ thm : proc_subsumes_decl ] , and [ eq : p5 ] for @xmath212 .",
    "[ thm : decl_postulates ] for every relation instance @xmath45 , set of functional dependencies @xmath49 , and acyclic priority @xmath64 , @xmath90 satisfies [ eq : p1][eq : p5 ] .",
    "we get [ eq : p1 ] from the definition .    with an empty priority we can not justify @xmath135 for any two different repairs @xmath79 and @xmath213 , what implies [ eq : p3 ] .    to show [ eq : p4 ] assume that @xmath207 are acyclic priorities such that @xmath208 , @xmath214 , and suppose there exists @xmath215 such that @xmath213 is preferred over @xmath79 in terms of @xmath75 .",
    "but since @xmath216 this implies that @xmath213 is also preferred over @xmath79 in terms of @xmath64 .",
    "this is a contradiction .    in order to prove [ eq : p5 ] assume there",
    "exist two different repairs @xmath79 and @xmath213 in @xmath90 .",
    "@xmath217 implies that there exists an element @xmath218 such that for any conflicting with @xmath70 tuple @xmath69 from @xmath125 we have @xmath219 .",
    "since @xmath64 is total for any such @xmath69 we have @xmath220 .",
    "take all such tuples @xmath221 and by @xmath222 denote any repair that contains the following elements @xmath223 such a repair exists because this set contains no conflicting tuples .",
    "obviously @xmath224 and at the same time @xmath225 .",
    "this contradicts that @xmath226 .",
    "as we showed in example [ ex : proc_diff_decl ] @xmath205 does nt have to be equal to @xmath212 .",
    "it suffices , however , to remove from consideration priorities with cyclic extensions to obtain the equivalence of the two notions of preferred repair :    [ thm : proc_equals_decl ] if @xmath64 is a priority having only acyclic extensions , then @xmath227    we need to show @xmath228 .",
    "take any @xmath214 and construct @xmath75 a total extension of @xmath64 by prioritizing ( un - prioritized by @xmath64 ) conflicts in favor for @xmath79 , i.e. @xmath75 is any total priority such that for any @xmath229 and any @xmath69 if @xmath230 and @xmath219 then @xmath231 . since @xmath64 has only acyclic extensions @xmath75 is acyclic .",
    "it should be clear from the construction that @xmath232 . by [ eq : p1 ] , [ eq : p3 ] ,",
    "[ eq : p5 ] and theorem [ thm : proc_subsumes_decl ] this implies that @xmath233 .",
    "this by [ eq : p4 ] gives us that @xmath234 .",
    "the following example shows , however , that the requirement of no cyclic extensions is not necessary for the equality above to hold .",
    "consider schema @xmath194 together with a set of functional dependencies @xmath195 .",
    "suppose we have a database : @xmath235 with a priority @xmath236 .",
    "the conflict graph is presented on figure [ fig : fig1 ] .",
    "( 2,1.3 ) ( .4,1.1 ) ( 1.6,1.1 ) ( .4,.1 ) ( 1.6,.1 )    @xmath64 has a cyclic extension @xmath237 . at the same time",
    "we study two fundamental problems of handling inconsistencies with priorities : ( i ) _ repair checking _  determining if a database is a preferred repair of a given database ; ( ii ) _ consistent query answers _  checking if _ true _ is an answer to a given query in every preferred repair .",
    "we use the notion of _ data complexity _ @xcite which captures the complexity of a problem as a function of the number of tuples in the database .",
    "the database schema , the integrity constraints , and the query are assumed to be fixed .      recall algorithm  [ alg : alg1 ] and note that because the consecutive choices made in the step  [ step : choice ] consist of mutually non - conflicting tuples , the state of the computation is independent of the order of the choices .",
    "given a repair @xmath57 , we can `` simulate '' its construction by restricting the choices in the step [ step : choice ] to @xmath239 .",
    "the simulation succeeds if and only if @xmath57 is an  - repair .",
    "[ thm : decl_total_tractable ] given a fixed set of functional dependencies @xmath49 , the set @xmath240 is in ptime .",
    "it is shown in @xcite that computing consistent answers to conjunctive queries is co - np - complete , but if we consider only ground quantifier - free queries , the problem is in ptime .",
    "on the other hand , computing  - preferred consistent answers turns out to be an intractable problem even if we consider very simple , single - atom queries .",
    "[ thm : proc_answers_intractable ] there exists a set of four functional dependencies @xmath49 and a quantifier - free ground query @xmath91 ( consisting of one atom only ) such that the set @xmath241 is co - np - complete .",
    "it s easy to construct a nondeterministic turing machine for @xmath242 following informal description presented here : the machine uses nondeterministic transitions to compute all  - preferred repairs of @xmath45 and for each one checks the answer to @xmath91 . note that @xmath243 this allows us to state that the constructed machine decides the complement of @xmath242 .",
    "now , consider the schema @xmath244 with the set of functional dependencies @xmath245 and a ground query @xmath246 , where the value of @xmath247 can be found in table [ tab : tab2 ] .    we show here a polynomial reduction of the complement of @xmath248 to @xmath249 , i.e. for any boolean formula @xmath91 in @xmath250 we construct a pair @xmath251 of a polynomial size in the size of @xmath91 and such that @xmath252 take then any formula @xmath91 in @xmath250 and let @xmath253 be the number of variables used in @xmath91 and @xmath254 the number of conjuncts of @xmath91 . for simplicity",
    "we assume that :    * used variables have consecutive indexes @xmath80 , * @xmath255 * each conjunct consists of exactly three literals @xmath256 for @xmath257 .",
    "we define two auxiliary functions @xmath258 and @xmath259 on literals in the following fashion : @xmath260 the constructed database contains the following elements : @xmath261 whose exact values can be found in table [ tab : tab2 ] .",
    "@xmath262    the priority relation @xmath263 is the unique minimal binary relation on @xmath264 satisfying the following conditions : @xmath265 note that this priority relation is acyclic .",
    "also note that construction of @xmath251 can be implemented in time polynomial in the size of the of the input formula @xmath91 . on figure [ fig : fig3 ]",
    "we can find a conflict graph of an instance received from reduction of a formula @xmath266 .",
    "( 15,-6 ) ( 1,-1 ) ( 2,-1 ) ( 3,-1 ) ( 4,-1 ) ( 5,-1 ) ( 6,-1 ) ( 7,-1 ) ( 8,-1 ) ( 9,-1 ) ( 10,-1 ) ( 11,-1 ) ( 12,-1 ) ( 13,-1 ) ( 14,-1 )    ( 4,-3 ) ( 8,-3 ) ( 12,-3 )    ( 8,-5.4 )    now , we show that @xmath267    * fist note that since @xmath268 then none of the tuples @xmath269 belongs to @xmath57",
    ". therefore for every @xmath118 either @xmath270 or @xmath271 belongs to @xmath57 .",
    "thus the following is a proper definition of a boolean valuation : @xmath272 next , we show that @xmath91 is true for @xmath273 .",
    "suppose otherwise , i.e. there exists a conjunct @xmath274 that is not true for @xmath273 .",
    "we can assume that @xmath275 .",
    "this implies that @xmath276 and thus @xmath277 .",
    "+ take @xmath278 to be the ordering of @xmath57 from proposition [ prop : proc_computation_path ] .",
    "since no @xmath279 tuples are present in @xmath57 , and the tuple @xmath247 is dominated by every @xmath279 tuple ( which in turn is dominated by some @xmath270 and @xmath271 tuples ) then @xmath280 .",
    "let @xmath281 be the last index of this sequence that @xmath282 is equal to either @xmath283 , @xmath284 , or @xmath285 .",
    "since @xmath286 is dominated only by @xmath287 , @xmath288 , and @xmath289 we have for any @xmath290 @xmath291 this implies that @xmath292 which gives a contradiction .",
    "* take any valuation @xmath273 for which @xmath91 is true and construct the following set @xmath293 first , note that @xmath57 is a repair : it contains no conflicting tuples and for every tuple from @xmath294 there exists a conflicting tuple in @xmath57 .",
    "+ next , we show that @xmath295 . in order to prove that we note that for any subset @xmath296 we have @xmath297 suppose otherwise , i.e. there exists a set @xmath298 and @xmath299 such that @xmath300 w.l.o.g .",
    "we can assume that @xmath301 .",
    "from the construction of @xmath264 and @xmath263 this implies that @xmath302 which is equivalent with @xmath303 , @xmath304 , and @xmath305 .",
    "this implies that @xmath274 is not true for @xmath273 which yields a contradiction with @xmath91 being satisfied by @xmath273 .",
    "+ the property allows us to use proposition [ prop : proc_computation_path ] ( take any ordering of @xmath57 with @xmath247 on the last position ) to state that @xmath57 is  - preferred repair w.r.t @xmath49 and @xmath263 .    it should be noted here that adding just one tuple @xmath306 and extending the priority with @xmath307 constructs a reduction of @xmath248 to the complement of @xmath308 . and",
    "therefore computing  - preferred consistent answers is intractable also for a query consisting only of one positive literal .      unlike  - repairs ,",
    "the notion of @xmath0-repairs , because of its global character , can not be captured without an essential use of nondeterminism .",
    "[ thm : decl_repair_check_intractable ] there exists a set of five functional dependencies @xmath49 such that the set @xmath309 is co - np - complete .",
    "it s easy to construct a nondeterministic turing machine @xmath310 .",
    "the machine first checks if @xmath57 is a repair ; if yes the machine nondeterministically computes every repair and checks if any of them ( different than @xmath57 ) is preferred over @xmath57 w.r.t .",
    "this machine decides the complement of @xmath310 .",
    "now , we show that the problem co - np - hard by reducing the complement of @xmath248 to @xmath310 .",
    "consider the database schema @xmath311 with the following set of integrity constraints @xmath312 .",
    "for any boolean formula @xmath91 in @xmath250 we construct a triple @xmath313 of size polynomial in the size of @xmath91 and such that @xmath314 moreover the reduction can be implemented in time polynomial in the size of @xmath91 .",
    "take then any formula @xmath91 in @xmath250 and let @xmath253 be the number of variables used in @xmath91 and @xmath254 the number of conjuncts of @xmath91 . for simplicity",
    "we assume that :    * used variables have consecutive indexes @xmath80 , * @xmath255 * each conjunct consists of exactly three literals @xmath256 for @xmath257 .",
    "we define two auxiliary functions @xmath258 and @xmath259 on literals as follows : @xmath260 the constructed database contains the following elements @xmath315 whose exact values can be found in table [ tab : tab1 ] .",
    "@xmath316    the set @xmath317 consists of the following elements @xmath318 it s easy to note that @xmath317 is a repair of @xmath264 w.r.t .",
    "clearly @xmath319 , no two elements of @xmath317 are conflicting , and for every element from the set @xmath320 there exists a conflicting element from @xmath317 ( @xmath281 for @xmath44 and @xmath321 for @xmath270 or @xmath271 ) .",
    "the priority relation @xmath263 is the unique minimal binary relation on @xmath264 satisfying the following conditions : @xmath322 note that this priority relation is acyclic .",
    "also note that the triple @xmath313 can be constructed in the time polynomial in the size of the formula @xmath91 . on figure [ fig : fig2 ]",
    "we can find a conflict graph of the instance received from reduction of the formula @xmath323 .",
    "( 17,-6 ) ( 5,-1 ) ( 7,-1 ) ( 8.5,-1 ) ( 9.5,-1 ) ( 11,-1 ) ( 12,-1 ) ( 13.5,-1 ) ( 14.5,-1 ) ( 16,-1 )    ( 1,-5 ) ( 3,-5 ) ( 5,-5 ) ( 7.75,-5 ) ( 10.25,-5 ) ( 12.75,-5 ) ( 15.25,-5 )    ( .5,-5.5)(16,-4.5 ) ( 9,-5.5)@xmath317    now , we show that for any @xmath91 using variables @xmath80 the following holds @xmath324    1 .",
    "suppose @xmath325 and take @xmath326 to be the valuation for which @xmath91 is true .",
    "consider the following set @xmath327 it s easy to find that @xmath328 is a repair and moreover @xmath329 .",
    "thus @xmath317 is not a maximally @xmath0-preferred repair . 2 .",
    "suppose @xmath330 , i.e. there exists @xmath331 such that @xmath135 and @xmath332 .",
    "+ first note that @xmath333 . otherwise for @xmath213 to be preferred over @xmath79 the tuple @xmath281 has to be contained in @xmath213 because there is no element dominating @xmath281 except for @xmath44 . since @xmath281 is adjacent with every @xmath270 and @xmath271 then also none of @xmath270 and @xmath271 belongs to @xmath213 .",
    "this implies that @xmath334 which is a contradiction .",
    "+ since @xmath44 is adjacent to every element of @xmath317 and @xmath333 the sets @xmath213 and @xmath317 are disjoint .",
    "this implies that for every @xmath335 the set @xmath213 contains either @xmath270 or @xmath271 ( from maximality , independence , and the fact that @xmath135 ) .",
    "+ take now the following boolean valuation @xmath336 we show that @xmath337 is a valuation for which @xmath91 is true .",
    "suppose otherwise , that there exists a conjunct @xmath274 that is not true under @xmath337 .",
    "w.l.o.g we can assume that @xmath338 .",
    "this implies that @xmath339 . from the construction of @xmath263",
    "we know that there are no elements dominating over @xmath286 except for @xmath340 . and since obviously @xmath341 , we receive @xmath217 which is a contradiction .    using the notion of @xmath0-repairs also leads to a significant increase of computational complexity when computing @xmath0-preferred consistent query answers .    [ thm : decl_answers_intractable ] there exists a set of four functional dependencies @xmath49 and a quantifier - free ground query @xmath91 ( consisting of one atom only ) such that the set @xmath342 is @xmath343-complete .",
    "the membership of @xmath344 in @xmath345 follows from the definition of @xmath0-preferred consistent query answer : query is not @xmath0-consistently true if it is false in some @xmath0-repair , and checking if a given set is a @xmath0-repair is in co - np .",
    "we show @xmath345-hardness below .",
    "consider a quantified boolean formula @xmath346 of the form @xmath347 where @xmath348 is quantifier - free and is in 3cnf , i.e @xmath348 equals to @xmath349 , and @xmath350 are clauses of three literals @xmath351 .",
    "we will construct a database instance @xmath352 ( over the schema @xmath353 ) and a priority relation @xmath354 such that true is a @xmath0-preferred consistent answer to a query @xmath355 if and only if @xmath346 is true ( the value of @xmath213 can be found in table [ tab : tab5 ] ) .",
    "the set of integrity constraints is @xmath356 .",
    "we define two auxiliary functions @xmath258 and @xmath259 on literals in the following fashion : @xmath357    now , we describe the tuples contained in @xmath352 .",
    "@xmath358 the exact values of tuples can be found in table [ tab : tab5 ] .",
    "@xmath359    the priority relation @xmath354 is the unique minimal priority relation that satisfies the following conditions : @xmath360    in figure [ fig : fig5 ] we can find a conflict graph of an instance obtained from the reduction of a formula @xmath361    ( 10,-4)(0,2 ) ( 2.5,1 ) ( 3.5,1 ) ( 6.5,1 ) ( 7.5,1 )    ( 5,1 ) ( 5,-3 )    ( 1,-1 ) ( 2,-1 ) ( 4.5,-1 ) ( 5.5,-1 ) ( 8,-1 ) ( 9,-1 )    ( 3.3,-3 ) ( 6.6,-3 )    we partition the set of all repairs of @xmath352 into two ( separate ) classes :    1 .",
    "@xmath362-repairs : repairs that contain @xmath213 .",
    "@xmath363-repairs : repairs that do nt contain @xmath213 .",
    "we will use @xmath363- and @xmath362-repairs to simulate all possible valuations of variables @xmath80 and @xmath364 respectively .      because of the functional dependency @xmath365 a repair is @xmath362-repair if and only if it contains any of @xmath366 or @xmath367 .",
    "moreover for any @xmath362-repair @xmath57 and for any @xmath368 either @xmath366 or @xmath367 belongs to @xmath57 .",
    "therefore there is one - to - one correspondence between @xmath362-repairs and valuations of @xmath369 variables . to easily move from the world of repairs to the world of valuations and vice versa",
    "we define the following two operators ( for @xmath57 being a @xmath362-repair and @xmath273 being a valuation of variables in @xmath348 ) : @xmath370(y_j ) =   \\begin{cases } true & q_j \\in r'\\\\ false & \\bar{q}_j \\in r ' \\end{cases } \\qquad   r_\\mathcal{y}[v ] = \\{q_j | v \\models y_j\\ } \\cup   \\{\\bar{q}_j | v \\models \\neg y_j \\ } \\cup \\{y\\}.\\ ] ]      we will partition further the class of @xmath363-repairs depending on their conformance with @xmath348 . because @xmath363-repairs will correspond only to valuations of @xmath371 we remove any usage of @xmath369 from @xmath346 in the following way : @xmath372 for a given valuation of @xmath373 construct the following set of tuples : @xmath374 = \\{p_i | v \\models x_i\\ } \\cup   \\{\\bar{p}_i | v \\models \\neg x_i \\ }         \\cup   \\{d_k | v \\not \\models \\tilde{c}_k\\ }        \\cup   \\{x\\}.\\ ] ] it s easy to verify that @xmath375 $ ] is a @xmath363-repair . an @xmath363-repair @xmath57 is _ strict _ if and only if there exists a valuation @xmath273 such that @xmath376 $ ] .",
    "otherwise the @xmath363-repair is _ non - strict_.    it s clear that there is a one - to - one correspondence between strict @xmath363-repairs and valuations of @xmath373 .",
    "construction of a valuation of @xmath373 from a strict @xmath363-repair @xmath57 is also straightforward , for technical reasons we extend it to any @xmath363-repair : @xmath377(x_i ) =   \\begin{cases } true & p_i \\in r'\\\\ false & \\bar{p}_i \\in r'\\\\ false & \\text{otherwise } \\end{cases}\\ ] ]    note that @xmath363-repairs can be characterized in a alternative way :    a repair of @xmath352 is an @xmath363-repair if and only if it contains @xmath79 .    in the main proof we use only strict @xmath79-repairs .",
    "the following observation will allow us to remove non - strict repairs from consideration .",
    "[ cl : strict_are_maximal ] strict @xmath363-repairs are @xmath89-maximal @xmath363-repairs .",
    "first we show how for any non - strict @xmath363-repair @xmath57 we construct a ( strict ) @xmath363-repair @xmath378 such that @xmath379 .",
    "take the valuation @xmath380 $ ] and let @xmath381 $ ] .",
    "the repair @xmath378 is strict and therefore @xmath382 .",
    "we show that @xmath383 , i.e. @xmath384 there are three cases of values of @xmath44 to consider :    1 .",
    "implies that @xmath378 is not an @xmath363-repair , a contradiction .",
    "2 .   for some @xmath335",
    "we have @xmath386 or @xmath387 .",
    "w.l.o.g assume that @xmath388 .",
    "this implies that @xmath389 . from construction of",
    "@xmath375 $ ] this implies that @xmath390 , a contradiction .",
    "3 .   for some @xmath254",
    "we have @xmath391 .",
    "assume that @xmath392 and @xmath393",
    ". then @xmath394 and @xmath395 ( it s the neighborhood of @xmath396 ) . from the construction of @xmath378",
    "we have that @xmath397 and both @xmath398 and @xmath399 dominate over @xmath396 .",
    "now , suppose that there exists a strict @xmath363-repair @xmath57 such that there exists an @xmath363-repair @xmath378 preferred over @xmath57 .",
    "we show that @xmath400 .",
    "note that @xmath57 and @xmath378 must agree on the tuples corresponding to the valuation of variables @xmath80 , i.e. @xmath401 since @xmath57 is strict , its content is determined by the corresponding valuation of variables @xmath80 .",
    "therefore @xmath402 $ ] .",
    "we showed in the previous part of the proof that @xmath403 .",
    "since @xmath354 is acyclic this implies that @xmath404 .    for any valuation @xmath273 of @xmath373 and @xmath369",
    "we have @xmath375 \\ll r_\\mathcal{y}[v]$ ] if and only if @xmath405 .",
    "we prove implication in two directions :    * by contradiction .",
    "suppose @xmath406 and there exists a tuple @xmath44 of @xmath375 $ ] which is not dominated by any tuple from @xmath407 $ ] .",
    "obviously ( from dependency @xmath365 ) @xmath44 can be only one of @xmath408 .",
    "assume that @xmath392 and @xmath409 .",
    "by construction of @xmath352 this implies that @xmath410 $ ] , @xmath411 $ ] , and @xmath412 $ ] . from the definition of @xmath375",
    "$ ] and @xmath407 $ ] we receive that @xmath413 , @xmath414 , and @xmath415 .",
    "this gives us @xmath416 which is a contradiction .",
    "* by contradiction .",
    "r_\\mathcal{y}[v]$ ] and there exists conjunct @xmath350 such that @xmath417 .",
    "assume that @xmath392 and @xmath409 .",
    "then @xmath413 , @xmath414 , and @xmath415 .",
    "consider @xmath396 and note that it belongs to @xmath375 $ ] ( by definition of @xmath418 ) .",
    "from the construction of @xmath419 we know that only @xmath398 , @xmath399 , and @xmath420 dominate over @xmath396 .",
    "@xmath421 $ ] does nt contain any of those and this gives us a contradiction .",
    "qbf @xmath346 is true if and only if for any strict @xmath363-repair @xmath57 there exists a @xmath362-repair @xmath378 such that @xmath379 .    by claim [ cl : strict_are_maximal ]",
    "we have that only a @xmath362-repair can be more preferred than a strict @xmath363-repair and for any non - strict @xmath363-repair there always exists a more preferred repair .",
    "qbf @xmath346 is true if and only if for any @xmath363-repair @xmath57 there exists a different repair @xmath378 such that @xmath379 .    from the partition of repairs",
    "we know that @xmath363-repairs can be characterized with a formula @xmath422 .",
    "@xmath423 . \\iff\\\\",
    "\\forall r ' \\in \\operatorname{rep}_f(r_\\psi ) .",
    "[ \\neg \\exists r '' \\in \\operatorname{rep}_f(r_\\psi ) .",
    "r'\\neq r '' \\land r ' \\ll r '' ] \\rightarrow r ' \\models r(y ) \\iff\\\\ \\forall r ' \\in \\operatorname{grep}_f^{\\prec_\\psi}(r_\\psi ) .   r'\\models r(y ) \\iff\\\\ ( r_\\psi,\\prec_\\psi ) \\in d_{f , r(y)}^g\\end{gathered}\\ ] ]    qbf @xmath346 is true if and only if true is @xmath0-preferred consistent answer to @xmath355 in @xmath352 w.r.t . @xmath49 and @xmath354 .",
    "if we use as characterization of @xmath363-repairs the formula @xmath424 then we can reduce qbf to answering to a query with one negated atom .",
    "qbf @xmath346 is true if and only if true is @xmath0-preferred consistent answer to @xmath425 in @xmath352 w.r.t . @xmath49 and @xmath354 .      the postulate [ eq : p5 ] allows us to think of a total acyclic priority as a cleaning program  an exact specification of how to resolve all conflicts .",
    "to run this program we simply use algorithm [ alg : alg1 ] and obtain a unique  - preferred repair .",
    "thanks to theorem [ thm : proc_equals_decl ] , this is also the unique @xmath0-repair .    given a a total acyclic priority @xmath64 , the unique  - repair ( which if also the unique @xmath0-repair ) can be computed in time polynomial in the size of the database .",
    "we limit our discussion to work on using priorities to maintain consistency and facilitate resolution of conflicts .    the first to notice the importance of priorities in information systems is @xcite .",
    "the authors study there the problem of updates of databases containing propositional sentences .",
    "the priority is expressed by storing a natural number with each clause ( the integrity constraints should be tagged with the highest priority @xmath426 ) . if an update ( inserting or deleting a sentence ) leads to inconsistency , among all consistent and realizing the update databases the minimally _ different _",
    "are selected .",
    "a database @xmath427 is less different than a database @xmath49 w.r.t . @xmath37 if either for some @xmath428 @xmath429 where @xmath253 is the lowest priority in @xmath37 and @xmath430 consists of all sentences from @xmath37 with priority less or equal to @xmath254 .",
    "although this framework does not define a notion of a conflict , we note that more than two facts can create a conflict w.r.t some constraint . for sake of the comparison ,",
    "assume that the conflicts are generated only by pairs of facts ( together with one of the constraints ) .",
    "then , the selected minimally different consistent databases are equivalent to @xmath0-repairs ( and because the considered class of priorities has only acyclic extensions it is equivalent to  - repairs ) .",
    "we note , however , that the chosen representation of priorities imposes a significant restriction on the class of considered priorities .",
    "in particular it assumes transitivity of the priority on conflicting facts i.e. if facts @xmath431 , @xmath247 , and @xmath432 are pair - wise conflicting and @xmath431 has a higher priority than @xmath247 and @xmath247 has a higher priority than @xmath432 , then the priority of @xmath431 is higher than @xmath432 .",
    "this assumption can not be always fulfilled in the context of inconsistent databases .",
    "for example the conflicts between @xmath431 and @xmath247 , and between @xmath247 and @xmath432 may be caused by violation of one integrity constraints while the conflict between @xmath431 and @xmath432 is introduced by a different constraint . while the user may supply us with a rule assigning priorities to conflicts created by the first integrity constraint ,",
    "the user may not wish to put any priorities on any conflicts created by the other constraint .",
    "a similar representation of priorities used to resolve inconsistency in first - order theories is studied in @xcite , where the inconsistent set of clauses is stratified ( again the lowest strata has the highest priority ) .",
    "then preferred maximal consistent subtheories are constructed in a manner analogous to  - repairs .",
    "furthermore , this approach is generalized to priorities being a partial orders , by considering all extensions to weak orders .",
    "again , however , this approach assumes transitivity of priority on conflicts , which as we explained previously may be considered a significant restriction .    in @xcite priorities",
    "are studied to facilitate the process of _ belief revision_. a belief state is represented as an ordered list of propositional formulae and the revision operation simply adds the given sentence at the end of the given belief state .",
    "this representation of belief state allows to keep track of revision history , which is later used to impose a preference order on the possible interpretations of the belief state .",
    "only maximally preferred interpretations are used when defining the entailment relation .    in the context of logic programs , priorities among rules",
    "can be used to handle inconsistent logic programs ( where rules imply contradictory facts ) .",
    "more preferred rules are satisfied , possibly at the cost of violating less important ones . in a manner analogous to @xmath89",
    ", @xcite lifts a total order on rules to a preference on ( extended ) answers sets . when computing answers only maximally preferred answers sets are considered .",
    "@xcite investigate disjunctive logic programs with priorities on facts .",
    "the authors use a transitive and reflexive closure ( denoted here @xmath433 ) of a user supplied set of priorities on facts .",
    "the preference on answer sets @xmath434 is defined as follows :    * @xmath435 for every answer set @xmath79 * @xmath436 if @xmath437,\\ ] ] where @xmath161 stands for @xmath438 . * if @xmath436 and @xmath439 , then @xmath440 .",
    "the answer to a program in the extended framework consists of all maximally preferred answer sets .",
    "the main shortcoming of using this framework is it s computational infeasibility ( which is specific to decision problems involving general disjunctive programs ) : computing answers to ground queries to disjunctive prioritized logic programs under cautious ( brave ) semantics is @xmath441-complete ( resp .",
    "@xmath442-complete ) .",
    "a simpler approach to the problem of inconsistent logic programs is presented in @xcite . there",
    "conflicting facts are removed from the model unless the priority specifies how to resolve the conflict . because only programs without disjunction are considered",
    ", this approach always returns exactly one model of the input program .",
    "constructing preferred repairs in a corresponding fashion ( by removing all conflicts unless the priority indicates a resolution ) would similarly return exactly one database instance ( fulfillment of [ eq : p1 ] and [ eq : p5 ] ) .",
    "however , if the priority does not specify how to resolve every conflict , the returned instance is not a maximal set of tuples and therefore it is not a repair .",
    "such an approach leads to a loss of ( disjunctive ) information and violates postulates [ eq : p3 ] and [ eq : p4 ] .",
    "@xcite proposes a framework of _ conditioned active integrity constraints _ , which allows the user to specify the way some of the conflicts can be resolved .",
    "this notion syntactically extends the notion of embedded dependency @xmath443 $ ] , where @xmath79 and @xmath213 are sets of variables , @xmath348 and @xmath346 are two conjunctions of literals , and each of existential variables @xmath213 is used only once .",
    "a conditioned active integrity constraint is obtained by adding a disjunctive list of update atoms ( @xmath444 for adding , and @xmath445 for deletion ) together with conditions @xmath446 specifying when a corresponding update atom can be used .",
    "such an extended constraint is denoted as @xmath447\\ ] ] a constraint ( or rather its grounded version ) is said to be _ applied _ to by a repair if the original integrity constraint ( @xmath448 ) is satisfied in the database and the repair is obtained by performing updates satisfying the conditional update atom lists ( one of the atoms @xmath449 has been added and the corresponding condition @xmath450 is satisfied , or one of the atoms @xmath451 has been removed and the corresponding condition @xmath452 is satisfied ) . on all repairs , which are obtained in the standard way by taking as integrity constraints only the heads of the conditioned action integrity constraints , we define relation of preference : a repair @xmath86 is preferred over @xmath85 if every ( ground ) constraint applied in @xmath86 is also applied in @xmath85 .",
    "we note here that when restricted to functional dependencies the set of preferred repairs is a superset of  - repairs .",
    "inclusion in the other direction does nt always hold , which is illustrated on the following example .",
    "consider a database @xmath453 consisting of three tuples @xmath454 and suppose we work in the presence of two functional dependencies @xmath455 and @xmath456 .",
    "suppose also , that the user specifies that if two tuples are conflicting w.r.t .",
    "the fd @xmath455 , then the tuple with higher value of the field @xmath457 should be preferred when repairing the database .",
    "a similar wish is expressed for conflicts generated by the second functional dependency .",
    "this can be expressed using the following two conditioned active integrity constraints @xmath458 , \\end{split } \\\\",
    "\\begin{split } \\forall x_1,x_2,y_1,y_2,z , s_1,s_2 .",
    "[ ( r(x_1,y_1,z , s_1 ) \\land r(x_2,y_2,z , s_2 ) \\supset s_1 \\neq s_2 )   \\supset \\\\ s_1>s_2 : -r(x_2,y_2,z , s_2 ) ] .",
    "\\end{split}\\end{gathered}\\ ] ] after grounding we remove constraints with their head equal to false and we obtain the following set @xmath459 the corresponding priority relation is @xmath460 . note that in the context of the database @xmath45 , the user has provided information sufficient to solve all the conflicts , i.e. among the repairs @xmath461 the repair @xmath86 is the unique repair selected by @xmath462 . at the same time",
    "only is applied to @xmath86 and only is applied to @xmath85 , what makes both repairs incomparable in terms of the framework of @xcite .",
    "this example also shows that the discussed framework violates the postulate [ eq : p4 ] .",
    "note also that removing preference information on how to resolve the conflict between @xmath463 and @xmath464 will yield only one repair @xmath86 .",
    "this shows that this framework violates the postulate [ eq : p5 ] . at the same time this framework fulfills the property of conservativeness",
    "( the preferred repairs are a subset of standard repairs ) and non - emptiness ( there is always at least one preferred repair ) .",
    "@xcite also describes how to translate conditioned active integrity constraints into a prioritized logic program @xcite , whose preferred models correspond to maximally preferred repairs .",
    "note that the framework of prioritized logic programming is computationally more powerful ( answering answers under the brave semantics is @xmath442-complete ) than required by the problem of finding if an atom is present in any repair ( @xmath465-complete ) .",
    "it is yet to be seen if less powerful programming environment ( like general disjunctive logic programs ) can be used to compute preferred answers .",
    "@xcite uses ranking functions on tuples to resolve conflicts by taking only the tuple with highest rank and removing others .",
    "this approach constructs a unique repair under the assumption that no two different tuples are of equal rank ( postulates [ eq : p1 ] and [ eq : p5 ] ) .",
    "if this assumption is not satisfied and the tuples contain numeric values , a new value , called the fusion , can be calculated from the conflicting tuples ( then , however , the constructed instance is not a repair in the sense of definition [ def : repair ] ) .",
    "a different approach based on ranking is studied in @xcite .",
    "the authors consider polynomial functions that are used to rank repairs . when computing preferred consistent query answers , only repairs with the highest rank are considered .",
    "the postulates [ eq : p1 ] and [ eq : p3 ] are trivially satisfied , but because this form of preference information does not have natural notions of extensions and maximality , it is hard to discuss postulates [ eq : p4 ] and [ eq : p5 ] . also , the preference among repairs in this method is not based on the way in which the conflicts are resolved .",
    "an approach where the user has a certain degree of control over the way the conflicts are resolved is presented in @xcite .",
    "using repair constraints the user can restrict considered repairs to those where tuples from one relation have been removed only if similar tuples have been removed from some other relation .",
    "this approach is monotonic , but not necessarily non - empty .",
    "the authors propose method of weakening the repair constraints to restore non - emptiness , however this comes at the price of losing monotonicity .",
    "in this paper we proposed a general framework of preferred repairs and preferred consistent query answers by formulating a set of intuitive postulates .",
    "we proposed two instantiations of the framework and studied their semantic and computational properties .",
    "table  [ tab : tab3 ] summarizes the computational complexity results ; its first row is taken from @xcite .",
    "we envision several directions for further work .",
    "the postulates [ eq : p1][eq : p5 ] can be refined , so that only non - trivial instantiations are captured .",
    "for example , the following instantiation fulfills the postulates : we ignore any priority which is not total and return all repairs in this case ; when the priority is total we return the unique  - repair .",
    "this approach , however , is trivial and obviously does not increase the computational complexity of any of considered problems . also , the computational consequences of further refining the postulates should be examined .",
    "the last is generalization of our framework to broader class of constraints .",
    "conflict graphs can be generalized to hypergraphs @xcite , which allow to handle broader class of denial constraints .",
    "then , more than two tuples can be involved in a single conflict and the current notion of priority does not have a clear meaning ."
  ],
  "abstract_text": [
    "<S> we study here the impact of priorities on conflict resolution in inconsistent relational databases . </S>",
    "<S> we extend the framework of @xcite , which is based on the notions of repair and consistent query answer . </S>",
    "<S> we propose a set of postulates that an extended framework should satisfy and consider two instantiations of the framework : ( locally preferred )  - repairs and ( globally preferred ) @xmath0-repairs . </S>",
    "<S> we study the relationships between them and the impact each notion of repair has on the computational complexity of repair checking and consistent query answers . </S>"
  ]
}